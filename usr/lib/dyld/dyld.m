BOOL dyld4::APIs::dyld_program_sdk_at_least(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = v2[16];
  v4 = v3 != 0;
  if (a2 == -1)
  {
    v5 = v2[13];
  }
  else if (v3 == a2 || v2[17] == a2)
  {
    v5 = v2[12];
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  return v5 >= HIDWORD(a2) && v4;
}

uint64_t dyld4::APIs::_dyld_objc_class_count(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(unsigned char *)(v1 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_objc_class_count()\n");
    uint64_t v1 = *((void *)this + 1);
  }
  v3 = *(unsigned int **)(v1 + 312);
  if (v3) {
    return *(unsigned int *)((char *)&v3[2 * v3[1] + 264 + v3[1]] + v3[1] + v3[4] + 1) + v3[2];
  }
  else {
    return 0;
  }
}

uint64_t dyld4::APIs::dyld_get_active_platform(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(unsigned int *)(v1 + 68);
  if (*(unsigned char *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_active_platform() => %d\n", v2);
  }
  return v2;
}

const char *_platform_strstr(const char *a1, char *__s)
{
  uint64_t v2 = a1;
  v3 = __s + 1;
  int v4 = *__s;
  if (!*__s) {
    return a1;
  }
  size_t v5 = _platform_strlen(__s + 1);
  while (1)
  {
    int v6 = *(unsigned __int8 *)v2;
    if (!*v2) {
      break;
    }
    v7 = v2++;
    if (v6 == v4 && !_platform_strncmp(v2, v3, v5)) {
      return v7;
    }
  }
  return 0;
}

uint64_t dyld4::APIs::findImageMappedAt(dyld4::APIs *this, char *a2, const dyld3::MachOLoaded **a3, BOOL *a4, const char **a5, void **a6, unint64_t *a7, unsigned __int8 *a8, const dyld4::Loader **a9)
{
  char v16 = 0;
  uint64_t v41 = 0;
  v42 = &v41;
  uint64_t v43 = 0x2000000000;
  char v44 = 0;
  uint64_t v17 = *((void *)this + 1);
  v18 = *(DyldSharedCache **)(v17 + 240);
  if (v18) {
    BOOL v19 = v18 >= (DyldSharedCache *)a2;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    if ((char *)v18 + DyldSharedCache::mappedSize(*(DyldSharedCache **)(v17 + 240)) <= a2)
    {
      char v16 = 0;
    }
    else
    {
      v27 = a8;
      v20 = (char *)v18 - DyldSharedCache::unslidLoadAddress(v18);
      v37 = 0;
      v38 = &v37;
      uint64_t v39 = 0x2000000000;
      int v40 = 0;
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 0x40000000;
      v36[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke;
      v36[3] = &unk_1EFF65328;
      v36[4] = &v37;
      v36[5] = a2 - v20;
      DyldSharedCache::forEachRange((char *)v18, (uint64_t)v36, 0);
      if (*((_DWORD *)v38 + 6) == 5)
      {
        v35[0] = _NSConcreteStackBlock;
        v35[1] = 0x40000000;
        v35[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_2;
        v35[3] = &unk_1EFF65350;
        v35[6] = a3;
        v35[7] = v20;
        v35[8] = a4;
        v35[9] = a5;
        v35[10] = a6;
        v35[11] = a7;
        v35[12] = v27;
        v35[13] = a9;
        v35[4] = &v41;
        v35[5] = a2 - v20;
        DyldSharedCache::forEachImageTextSegment((uint64_t)v18, (uint64_t)v35);
        if (*((unsigned char *)v42 + 24))
        {
          _Block_object_dispose(&v37, 8);
LABEL_28:
          uint64_t ImageMappedAt = 1;
          goto LABEL_31;
        }
      }
      _Block_object_dispose(&v37, 8);
      char v16 = 1;
      a8 = v27;
    }
  }
  v37 = 0;
  unsigned __int8 v34 = 0;
  if (dyld4::RuntimeState::inPermanentRange(this, (unint64_t)a2, (unint64_t)(a2 + 1), &v34, (const Loader **)&v37))
  {
    if (a3) {
      *a3 = (const dyld3::MachOLoaded *)dyld4::Loader::loadAddress((dyld4::Loader *)v37, this);
    }
    if (a4) {
      *a4 = 1;
    }
    if (a5) {
      *a5 = (const char *)dyld4::Loader::path((dyld4::Loader *)v37, this);
    }
    if ((unint64_t)a6 | (unint64_t)a7)
    {
      unint64_t v32 = 0;
      v33 = 0;
      unsigned __int8 v31 = 0;
      if (dyld4::Loader::contains((dyld4::Loader *)v37, this, a2, (const void **)&v33, &v32, &v31))
      {
        if (a6) {
          *a6 = v33;
        }
        if (a7) {
          *a7 = v32;
        }
      }
    }
    if (a8) {
      *a8 = v34;
    }
    if (a9) {
      *a9 = (const dyld4::Loader *)v37;
    }
    goto LABEL_28;
  }
  v22 = (uint64_t *)*((void *)this + 17);
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 0x40000000;
  v29[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_3;
  v29[3] = &unk_1EFF65378;
  char v30 = v16;
  v29[6] = a2;
  v29[7] = a3;
  v29[8] = a4;
  v29[9] = a5;
  v29[10] = a6;
  v29[11] = a7;
  v29[12] = a8;
  v29[13] = a9;
  v29[4] = &v41;
  v29[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v22, (uint64_t)v29);
  if (*((unsigned char *)v42 + 24) || (uint64_t v24 = *((void *)this + 30)) == 0)
  {
LABEL_30:
    uint64_t ImageMappedAt = *((unsigned __int8 *)v42 + 24) != 0;
  }
  else
  {
    v25 = (const void **)(*((void *)this + 29) + 8);
    uint64_t v26 = 16 * v24;
    while (*(v25 - 1) != a2)
    {
      v25 += 2;
      v26 -= 16;
      if (!v26) {
        goto LABEL_30;
      }
    }
    uint64_t ImageMappedAt = dyld4::APIs::findImageMappedAt(this, *v25, a3, a4, a5, (const void **)a6, a7, a8, a9);
  }
LABEL_31:
  _Block_object_dispose(&v41, 8);
  return ImageMappedAt;
}

uint64_t dyld4::APIs::_dyld_is_memory_immutable(dyld4::APIs *this, char *a2, uint64_t a3)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 0;
  uint64_t v6 = *((void *)this + 1);
  v7 = *(char **)(v6 + 240);
  if (v7) {
    BOOL v8 = v7 >= a2;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && &v7[DyldSharedCache::mappedSize(*(DyldSharedCache **)(v6 + 240))] > a2)
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    v15[2] = ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke;
    v15[3] = &unk_1EFF653C8;
    v15[5] = a2;
    v15[6] = a3;
    v15[4] = &v16;
    DyldSharedCache::forEachCache(v7, (uint64_t)v15);
  }
  v9 = v17;
  if (!*((unsigned char *)v17 + 24))
  {
    v14 = 0;
    unsigned __int8 v13 = 0;
    BOOL v10 = dyld4::RuntimeState::inPermanentRange(this, (unint64_t)a2, (unint64_t)&a2[a3], &v13, (const Loader **)&v14);
    v9 = v17;
    if (v10) {
      *((unsigned char *)v17 + 24) = ((v13 >> 1) & 1) == 0;
    }
  }
  if (*(unsigned char *)(*((void *)this + 1) + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_is_memory_immutable(%p, %lu) => %d\n", a2, a3, *((unsigned __int8 *)v9 + 24));
    v9 = v17;
  }
  uint64_t v11 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v16, 8);
  return v11;
}

uint64_t dyld4::APIs::_dyld_lookup_section_info(void *a1, dyld3::MachOFile *a2, dyld4::Loader *this, uint64_t a4)
{
  if ((int)a4 > 20) {
    return 0;
  }
  v16[49] = v4;
  v16[50] = v5;
  if (this)
  {
    uint64_t v11 = a1[1];
    unint64_t v12 = *(void *)(v11 + 240);
    if (v12)
    {
      unint64_t v13 = DyldSharedCache::mappedSize(*(DyldSharedCache **)(v11 + 240)) + v12;
      BOOL v14 = v12 > (unint64_t)this || v13 >= (unint64_t)this;
      if (!v14 && !a1[121]) {
        return (*(uint64_t (**)(void *, dyld3::MachOFile *, void, uint64_t))(*a1 + 928))(a1, a2, 0, a4);
      }
    }
    if (*(_DWORD *)this != 1815378276 || *(_DWORD *)dyld4::Loader::getSectionLocations(this) != 1) {
      return (*(uint64_t (**)(void *, dyld3::MachOFile *, void, uint64_t))(*a1 + 928))(a1, a2, 0, a4);
    }
    uint64_t v15 = *(void *)(dyld4::Loader::getSectionLocations(this) + 8 * a4 + 8);
    if (v15) {
      return (uint64_t)a2 + v15;
    }
  }
  else
  {
    v16[0] = 1;
    dyld4::JustInTimeLoader::parseSectionLocations(a2, (uint64_t)v16);
    uint64_t v15 = v16[a4 + 1];
    if (v15) {
      return (uint64_t)a2 + v15;
    }
  }
  return 0;
}

uint64_t dyld4::Loader::getSectionLocations(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::getSectionLocations();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::getSectionLocations(this);
  }
  else
  {
    return dyld4::JustInTimeLoader::getSectionLocations(this);
  }
}

uint64_t dyld4::PrebuiltLoader::getSectionLocations(dyld4::PrebuiltLoader *this)
{
  return (uint64_t)this + 104;
}

uint64_t DyldSharedCache::mappedSize(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x18Cu) {
    return *((void *)this + 29);
  }
  uint64_t v8 = 0;
  v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK15DyldSharedCache10mappedSizeEv_block_invoke;
  v3[3] = &unk_1EFF65C80;
  v3[4] = &v8;
  v3[5] = &v4;
  DyldSharedCache::forEachRegion((uint64_t)this, (uint64_t)v3);
  uint64_t v1 = v5[3] - v9[3];
  _Block_object_dispose(&v4, 8);
  _Block_object_dispose(&v8, 8);
  return v1;
}

void dyld4::APIs::_dyld_for_each_objc_protocol(dyld4::RuntimeState *this, char *a2, uint64_t a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_objc_protocol(%s)\n", a2);
  }
  if (!*((void *)this + 124)) {
    goto LABEL_5;
  }
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke;
  v9[3] = &unk_1EFF655F0;
  v9[5] = &v10;
  v9[6] = this;
  v9[4] = a3;
  prebuilt_objc::forEachProtocol(this, (void *)this + 55, a2, (uint64_t)v9);
  int v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
LABEL_5:
    uint64_t v7 = *(unsigned int **)(*((void *)this + 1) + 320);
    if (v7)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke_2;
      v8[3] = &unk_1EFF65618;
      v8[4] = a3;
      v8[5] = this;
      objc::ObjectHashTable::forEachObject(v7, a2, (uint64_t)v8);
    }
  }
}

void dyld4::APIs::_dyld_for_each_objc_class(dyld4::RuntimeState *this, char *a2, uint64_t a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_objc_class(%s)\n", a2);
  }
  if (!*((void *)this + 124)) {
    goto LABEL_5;
  }
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke;
  v9[3] = &unk_1EFF655A0;
  v9[5] = &v10;
  v9[6] = this;
  v9[4] = a3;
  prebuilt_objc::forEachClass(this, (void *)this + 49, a2, (uint64_t)v9);
  int v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
LABEL_5:
    uint64_t v7 = *(unsigned int **)(*((void *)this + 1) + 312);
    if (v7)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke_2;
      v8[3] = &unk_1EFF655C8;
      v8[4] = a3;
      v8[5] = this;
      objc::ObjectHashTable::forEachObject(v7, a2, (uint64_t)v8);
    }
  }
}

void _Block_object_dispose(const void *a1, const int a2)
{
  if (a2 != 8) {
    dyld4::halt("_Block_object_dispose()", 0);
  }
}

uint64_t objc::ObjectHashTable::forEachObject(unsigned int *a1, char *a2, uint64_t a3)
{
  uint64_t result = objc::StringHashTable::tryGetIndex((objc::StringHashTable *)a1, a2);
  if ((result & 0xFF00000000) != 0)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = (uint64_t)&a1[v6 + 264] + v6 + a1[4] + 1;
    unint64_t v8 = *(void *)(v7 + 8 * result);
    uint64_t v9 = (v8 >> 1) & 0x7FFFFFFFFFFFLL;
    if (v8)
    {
      unint64_t v10 = HIWORD(v8);
      if (v10)
      {
        uint64_t v11 = (unint64_t *)(v7 + 8 * v6 + 8 * v9 + 4);
        unint64_t v12 = v10 - 1;
        do
        {
          char v15 = 0;
          unint64_t v13 = *v11++;
          uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, char *))(a3 + 16))(a3, (v13 >> 1) & 0x7FFFFFFFFFFFLL, HIWORD(v13), &v15);
          if (v15) {
            BOOL v14 = 1;
          }
          else {
            BOOL v14 = v12 == 0;
          }
          --v12;
        }
        while (!v14);
      }
    }
    else
    {
      char v16 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, char *))(a3 + 16))(a3, v9, HIWORD(v8), &v16);
    }
  }
  return result;
}

uint64_t ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke_2(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(*(unsigned int **)(*(void *)(*(void *)(a1 + 40) + 8) + 296), a3);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  return result;
}

uint64_t objc::objc_headeropt_rw_t<unsigned long>::isLoaded(unsigned int *a1, unsigned int a2)
{
  if (*a1 <= a2) {
    objc::objc_headeropt_rw_t<unsigned long>::isLoaded();
  }
  return *(unsigned int *)((char *)a1 + a1[1] * a2 + 8) & 1;
}

void prebuilt_objc::forEachClass(dyld4::RuntimeState *a1, void *a2, const char *a3, uint64_t a4)
{
  uint64_t v5 = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN13prebuilt_objc12forEachClassEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke;
  v4[3] = &unk_1EFF65750;
  v4[4] = a4;
  dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>((uint64_t)a2, a2, a2 + 3, a1, &v5, (uint64_t)v4);
}

uint64_t DyldSharedCache::forEachCache(char *a1, uint64_t a2)
{
  char v10 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a2 + 16))(a2, a1, &v10);
  if (!v10 && *((_DWORD *)a1 + 4) >= 0x18Du && *((_DWORD *)a1 + 99))
  {
    int v5 = 0;
    do
    {
      uint64_t v6 = &a1[*((unsigned int *)a1 + 98)];
      uint64_t v7 = (uint64_t)&v6[24 * v5 + 16];
      uint64_t v8 = (uint64_t)&v6[56 * v5 + 16];
      if (*((_DWORD *)a1 + 4) >= 0x1C9u) {
        uint64_t v9 = (void *)v8;
      }
      else {
        uint64_t v9 = (void *)v7;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a2 + 16))(a2, &a1[*v9], &v10);
      if (v10) {
        break;
      }
      ++v5;
    }
    while (v5 != *((_DWORD *)a1 + 99));
  }
  return result;
}

uint64_t ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke_2;
  v3[3] = &unk_1EFF653A0;
  uint64_t v5 = *(void *)(a1 + 48);
  long long v4 = *(_OWORD *)(a1 + 32);
  return DyldSharedCache::forEachRegion(a2, (uint64_t)v3);
}

uint64_t DyldSharedCache::forEachRegion(uint64_t a1, uint64_t a2)
{
  uint64_t result = _platform_strncmp((const char *)a1, "dyld_v1", 7uLL);
  if (!result)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    if (v5 <= 0x400)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 20);
      if (v6 <= 0x14)
      {
        if (v5 > 0x138)
        {
          if (v6)
          {
            uint64_t v10 = a1 + *(unsigned int *)(a1 + 312);
            unint64_t v11 = v10 + 56 * v6;
            unint64_t v12 = v10 + 56;
            do
            {
              char v13 = 0;
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, void, char *))(a2 + 16))(a2, a1 + *(void *)(v12 - 40), *(void *)(v12 - 56), *(void *)(v12 - 48), *(unsigned int *)(v12 - 4), *(unsigned int *)(v12 - 8), *(void *)(v12 - 16), &v13);
              if (v13) {
                break;
              }
              BOOL v9 = v12 >= v11;
              v12 += 56;
            }
            while (!v9);
          }
        }
        else if (v6)
        {
          unint64_t v7 = a1 + v5 + 32 * v6;
          unint64_t v8 = v5 + a1 + 32;
          do
          {
            char v14 = 0;
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, void, char *))(a2 + 16))(a2, a1 + *(void *)(v8 - 16), *(void *)(v8 - 32), *(void *)(v8 - 24), *(unsigned int *)(v8 - 4), *(unsigned int *)(v8 - 8), 0, &v14);
            if (v14) {
              BOOL v9 = 1;
            }
            else {
              BOOL v9 = v8 >= v7;
            }
            v8 += 32;
          }
          while (!v9);
        }
      }
    }
  }
  return result;
}

void *___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke_2(void *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  unint64_t v6 = result[5];
  if (v6 > a2 && (a6 & 2) == 0 && v6 + result[6] < a2 + a4) {
    *(unsigned char *)(*(void *)(result[4] + 8) + 24) = 1;
  }
  return result;
}

int _platform_strncmp(const char *__s1, const char *__s2, size_t __n)
{
  int v3 = 0;
  if (!__n) {
    return v3;
  }
  while ((__s1 & 0xF) != 0)
  {
    unsigned int v5 = *(unsigned __int8 *)__s1++;
    uint64_t v4 = v5;
    int v6 = *(unsigned __int8 *)__s2++;
    int v3 = v4 - v6;
    if (v4 == v6 && v4 != 0)
    {
      if (--__n) {
        continue;
      }
    }
    return v3;
  }
  if ((__s2 & 0xF) == 0) {
    goto LABEL_30;
  }
  unint64_t v9 = -(uint64_t)__s2 & 0xFF0;
  if (!v9) {
    goto LABEL_16;
  }
LABEL_11:
  if (__n > v9)
  {
    size_t v10 = __n - v9;
    while (1)
    {
      int8x16_t v11 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v12 = v11;
      int8x16_t v13 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v15 = vceqq_s8(v12, v13);
      uint8x16_t v14 = (uint8x16_t)vandq_s8(v12, v15);
      v15.i8[0] = vminvq_u8(v14);
      if (!v15.i32[0]) {
        break;
      }
      v9 -= 16;
      if (!v9)
      {
        __n = v10;
LABEL_16:
        while (1)
        {
          unsigned int v17 = *(unsigned __int8 *)__s1++;
          uint64_t v16 = v17;
          int v18 = *(unsigned __int8 *)__s2++;
          int v3 = v16 - v18;
          if (v16 != v18 || v16 == 0) {
            return v3;
          }
          if (!--__n) {
            return v3;
          }
          if ((__s1 & 0xF) == 0)
          {
            unint64_t v9 = 4080;
            goto LABEL_11;
          }
        }
      }
    }
  }
  else
  {
LABEL_30:
    while (1)
    {
      int8x16_t v20 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v21 = v20;
      int8x16_t v22 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v15 = vceqq_s8(v21, v22);
      uint8x16_t v14 = (uint8x16_t)vandq_s8(v21, v15);
      v15.i8[0] = vminvq_u8(v14);
      if (!v15.i32[0]) {
        break;
      }
      BOOL v23 = __n > 0x10;
      __n -= 16;
      if (!v23) {
        return 0;
      }
    }
  }
  uint8x16_t v24 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v14, (uint8x16_t)veorq_s8(v15, v15)), (int8x16_t)xmmword_1A8DFF200);
  v24.i8[0] = vminvq_u8(v24);
  if (v24.u32[0] >= __n) {
    return 0;
  }
  else {
    return __s1[v24.u32[0] - 16] - __s2[v24.u32[0] - 16];
  }
}

uint64_t ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke_2(uint64_t a1, int a2, int a3, int a4, int a5, DyldSharedCache *this, char a7)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

uint64_t ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, unsigned char *a9)
{
  unint64_t v9 = *(void *)(result + 40);
  if (v9 >= a3 && v9 < a4 + a3)
  {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a7;
    *a9 = 1;
  }
  return result;
}

const char *DyldSharedCache::mappingName(DyldSharedCache *this, char a2)
{
  if ((this & 4) != 0)
  {
    if ((a2 & 8) != 0) {
      return "__TEXT_STUBS";
    }
    else {
      return "__TEXT";
    }
  }
  else
  {
    if ((this & 2) != 0)
    {
      uint64_t v2 = "__DATA_DIRTY";
      int v6 = "__TPRO_CONST";
      unint64_t v7 = "__DATA_CONST";
      if ((a2 & 4) == 0) {
        unint64_t v7 = "__DATA";
      }
      if ((a2 & 0x40) == 0) {
        int v6 = v7;
      }
      if ((a2 & 2) == 0) {
        uint64_t v2 = v6;
      }
      int v3 = "__AUTH_DIRTY";
      unint64_t v8 = "__AUTH_TPRO_CONST";
      unint64_t v9 = "__AUTH_CONST";
      if ((a2 & 4) == 0) {
        unint64_t v9 = "__AUTH";
      }
      if ((a2 & 0x40) == 0) {
        unint64_t v8 = v9;
      }
      if ((a2 & 2) == 0) {
        int v3 = v8;
      }
      BOOL v4 = (a2 & 1) == 0;
    }
    else
    {
      uint64_t v2 = "*unknown*";
      int v3 = "__READ_ONLY";
      if ((a2 & 0x20) == 0) {
        int v3 = "__LINKEDIT";
      }
      BOOL v4 = (this & 1) == 0;
    }
    if (v4) {
      return v2;
    }
    else {
      return v3;
    }
  }
}

uint64_t ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke(void *a1, uint64_t a2, unsigned char *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke_2;
  v8[3] = &unk_1EFF65C30;
  uint64_t v6 = a1[6];
  v8[4] = a1[4];
  v8[5] = v6;
  void v8[6] = a2;
  v8[7] = a3;
  uint64_t result = DyldSharedCache::forEachRegion(a2, (uint64_t)v8);
  if (!*a3)
  {
    uint64_t result = a1[5];
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 16))(result, a2, *(unsigned int *)(*(void *)(a1[6] + 8) + 24));
    }
    ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
  }
  return result;
}

void prebuilt_objc::forEachProtocol(dyld4::RuntimeState *a1, void *a2, const char *a3, uint64_t a4)
{
  unsigned int v5 = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN13prebuilt_objc15forEachProtocolEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke;
  v4[3] = &unk_1EFF65778;
  v4[4] = a4;
  dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>((uint64_t)a2, a2, a2 + 3, a1, &v5, (uint64_t)v4);
}

uint64_t ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke_2(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(*(unsigned int **)(*(void *)(*(void *)(a1 + 40) + 8) + 296), a3);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  return result;
}

BOOL dyld4::RuntimeState::inPermanentRange(dyld4::RuntimeState *this, unint64_t a2, unint64_t a3, unsigned __int8 *a4, const Loader **a5)
{
  explicit = (dyld4::RuntimeState::PermanentRanges *)*((void *)this + 128);
  if (!explicit) {
    return 0;
  }
  do
  {
    BOOL result = dyld4::RuntimeState::PermanentRanges::contains(explicit, a2, a3, a4, a5);
    if (result) {
      break;
    }
    explicit = (dyld4::RuntimeState::PermanentRanges *)atomic_load_explicit((atomic_ullong *volatile)explicit, memory_order_acquire);
  }
  while (explicit);
  return result;
}

BOOL dyld4::RuntimeState::PermanentRanges::contains(dyld4::RuntimeState::PermanentRanges *this, unint64_t a2, unint64_t a3, unsigned __int8 *a4, const Loader **a5)
{
  unint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = (void *)((char *)this + 40);
    BOOL v8 = 1;
    while (*(v7 - 3) > a2 || *(v7 - 2) <= a3)
    {
      BOOL v8 = ++v6 < v5;
      v7 += 4;
      if (v5 == v6) {
        return 0;
      }
    }
    *a4 = *v7;
    *a5 = (const Loader *)*(v7 - 1);
  }
  else
  {
    return 0;
  }
  return v8;
}

uint64_t DyldSharedCache::unslidLoadAddress(DyldSharedCache *this)
{
  return *(void *)((char *)this + *((unsigned int *)this + 4));
}

void DyldSharedCache::forEachRange(char *a1, uint64_t a2, uint64_t a3)
{
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x2000000000;
  int v5 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke;
  v3[3] = &unk_1EFF65C58;
  v3[5] = a3;
  void v3[6] = v4;
  void v3[4] = a2;
  DyldSharedCache::forEachCache(a1, (uint64_t)v3);
  _Block_object_dispose(v4, 8);
}

uint64_t DyldSharedCache::forEachImageTextSegment(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 16) >= 0x89u)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 144);
    if (v3)
    {
      uint64_t v4 = *(void *)(result + 136);
      char v8 = 0;
      if (v3 >= 1)
      {
        unint64_t v6 = result + v4 + 32 * v3;
        unint64_t v7 = v4 + result + 32;
        do
        {
          BOOL result = (*(uint64_t (**)(uint64_t, void, void, unint64_t, uint64_t, char *))(a2 + 16))(a2, *(void *)(v7 - 16), *(unsigned int *)(v7 - 8), v7 - 32, v2 + *(unsigned int *)(v7 - 4), &v8);
          if (v7 >= v6) {
            break;
          }
          v7 += 32;
        }
        while (!v8);
      }
    }
  }
  return result;
}

void *___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_2(void *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  unint64_t v6 = result[5];
  if (v6 >= a2 && v6 < a3 + a2)
  {
    char v8 = (void *)result[6];
    if (v8) {
      *char v8 = result[7] + a2;
    }
    unint64_t v9 = (unsigned char *)result[8];
    if (v9) {
      unsigned char *v9 = 1;
    }
    size_t v10 = (void *)result[9];
    if (v10) {
      *size_t v10 = a5;
    }
    int8x16_t v11 = (void *)result[10];
    if (v11) {
      *int8x16_t v11 = result[7] + a2;
    }
    int8x16_t v12 = (void *)result[11];
    if (v12) {
      *int8x16_t v12 = a3;
    }
    int8x16_t v13 = (unsigned char *)result[12];
    if (v13) {
      *int8x16_t v13 = 5;
    }
    uint8x16_t v14 = (void *)result[13];
    if (v14) {
      void *v14 = 0;
    }
    *a6 = 1;
    *(unsigned char *)(*(void *)(result[4] + 8) + 24) = 1;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v10[0] = 2;
  v10[1] = a2;
  v10[2] = a3;
  uint64_t v12 = a5;
  long long v11 = *a4;
  uint64_t v8 = a1 + 32;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v13 = a2 - *(void *)(*(void *)(*(void *)(v8 + 8) + 8) + 24);
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, long long *, uint64_t, uint64_t, uint64_t))(v7 + 16))(v7, v10, a3, a4, a5, a6, a7);
}

uint64_t dyld4::APIs::_dyld_get_image_header(dyld4::APIs *this, int a2)
{
  uint64_t v9 = 0;
  size_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  uint64_t v4 = (uint64_t *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs22_dyld_get_image_headerEj_block_invoke;
  v7[3] = &unk_1EFF65070;
  int v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_header(%u) => %p\n", a2, (const void *)v10[3]);
  }
  uint64_t v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t dyld4::APIs::_dyld_get_image_name(dyld4::APIs *this, int a2)
{
  uint64_t v9 = 0;
  size_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  uint64_t v4 = (uint64_t *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs20_dyld_get_image_nameEj_block_invoke;
  v7[3] = &unk_1EFF650C0;
  int v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_name(%u) => %s\n", a2, (const char *)v10[3]);
  }
  uint64_t v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t dyld4::RuntimeLocks::withLoadersReadLock(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (v4)
  {
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v4 + 104))(v4, a1 + 1, 0);
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)*a1 + 112);
    return v5();
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(a2 + 16);
    return v7(a2);
  }
}

uint64_t ___ZN5dyld44APIs20_dyld_get_image_nameEj_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  unint64_t v2 = *(unsigned int *)(result + 48);
  if (*((void *)v1 + 6) > v2)
  {
    uint64_t v3 = result;
    BOOL result = dyld4::Loader::path(*(dyld4::Loader **)(*((void *)v1 + 5) + 8 * v2), v1);
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs22_dyld_get_image_headerEj_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  unint64_t v2 = *(unsigned int *)(result + 48);
  if (*((void *)v1 + 6) > v2)
  {
    uint64_t v3 = result;
    BOOL result = dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((void *)v1 + 5) + 8 * v2), v1);
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t dyld4::JustInTimeLoader::mf(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke(uint64_t a1, char *a2, unsigned int a3, unsigned char *a4)
{
  if (*(unsigned char *)(a1 + 80) && *(unsigned char *)(a1 + 81) && !*(unsigned char *)(a1 + 82) && *(char **)(a1 + 48) != a2) {
    return;
  }
  int v8 = *(dyld4::RuntimeState **)(a1 + 56);
  if (*(unsigned char *)(*((void *)v8 + 1) + 208))
  {
    uint64_t v9 = dyld4::ProcessConfig::PathOverrides::typeName(a3);
    dyld4::RuntimeState::log(v8, "  possible path(%s): \"%s\"\n", v9, a2);
    int v8 = *(dyld4::RuntimeState **)(a1 + 56);
  }
  uint64_t v10 = 0;
  *(void *)&long long v82 = (char *)v8 + 32;
  *((void *)&v82 + 1) = (char *)v8 + 64;
  while (1)
  {
    uint64_t v11 = *((void *)&v82 + v10);
    if (!*(unsigned char *)(*(void *)(a1 + 64) + 5) || v11 != *(void *)(a1 + 56) + 64)
    {
      uint64_t v12 = *(void *)(v11 + 16);
      if (v12) {
        break;
      }
    }
LABEL_13:
    if (++v10 == 2)
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
      if (!*(unsigned char *)(v17 + 186))
      {
        int v42 = *a2;
        if (v42 != 47 && v42 != 64)
        {
          BOOL v43 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
          char v44 = *(vm_address_t **)(a1 + 72);
          if (v43) {
            Diagnostics::error(v44, "tried: '%s' (relative path not allowed in hardened program)", a2);
          }
          else {
            Diagnostics::appendError(v44, ", '%s' (relative path not allowed in hardened program)");
          }
          return;
        }
      }
      *(_DWORD *)v80 = 0;
      if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(v17 + 240), a2, (unsigned int *)v80))
      {
        uint64_t v18 = 0;
        uint64_t v19 = *(void *)(a1 + 56);
        *(void *)&long long v82 = v19 + 32;
        *((void *)&v82 + 1) = v19 + 64;
        while (1)
        {
          uint64_t v20 = *((void *)&v82 + v18);
          if (!*(unsigned char *)(*(void *)(a1 + 64) + 5) || v20 != *(void *)(a1 + 56) + 64)
          {
            uint64_t v21 = *(void *)(v20 + 16);
            if (v21) {
              break;
            }
          }
LABEL_23:
          if (++v18 == 2) {
            goto LABEL_24;
          }
        }
        int8x16_t v22 = *(dyld4::Loader ***)(v20 + 8);
        uint64_t v23 = 8 * v21;
        uint8x16_t v24 = v22;
        while (1)
        {
          v25 = *v24;
          if (dyld4::Loader::representsCachedDylibIndex(*v24, v80[0])) {
            break;
          }
          ++v24;
          ++v22;
          v23 -= 8;
          if (!v23) {
            goto LABEL_23;
          }
        }
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v25;
        *a4 = 1;
        Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
        uint64_t v41 = *(const dyld4::RuntimeState **)(a1 + 56);
        if (*(unsigned char *)(*((void *)v41 + 1) + 208))
        {
          dyld4::Loader::path(v25, v41);
          dyld4::RuntimeState::log(v41, "  found: already-loaded-by-dylib-index: \"%s\" -> %s\n");
        }
        return;
      }
LABEL_24:
      if (*(unsigned char *)(*(void *)(a1 + 64) + 5)) {
        return;
      }
      uint64_t v26 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v27 = *((void *)v26 + 76);
      if (v27)
      {
        if (!*(unsigned char *)(*((void *)v26 + 1) + 208)
          || (dyld4::RuntimeState::log(v26, "searching %llu pseudo-dylibs:\n", *((void *)v26 + 76)),
              uint64_t v26 = *(dyld4::RuntimeState **)(a1 + 56),
              (uint64_t v27 = *((void *)v26 + 76)) != 0))
        {
          v28 = (dyld4::PseudoDylib **)*((void *)v26 + 75);
          v29 = &v28[v27];
          char v30 = v28;
          while (1)
          {
            unsigned __int8 v31 = dyld4::PseudoDylib::loadableAtPath(*v30, a2);
            if (v31)
            {
              unint64_t v32 = (char *)v31;
              v33 = *(dyld4::RuntimeState **)(a1 + 56);
              if (*(unsigned char *)(*((void *)v33 + 1) + 208)) {
                dyld4::RuntimeState::log(v33, "  found: pseduo-dylib: \"%s\"\n", a2);
              }
              Diagnostics::Diagnostics((Diagnostics *)&v82);
              *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = dyld4::JustInTimeLoader::makePseudoDylibLoader((vm_address_t *)&v82, *(void *)(a1 + 56), v32, *(void *)(a1 + 64), (mach_o::Header **)*v30);
              if (v32 != a2) {
                dyld4::PseudoDylib::disposeString((uint64_t (***)(char *))*v30, v32);
              }
              if (Diagnostics::hasError((Diagnostics *)&v82))
              {
                BOOL v34 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
                v35 = *(vm_address_t **)(a1 + 72);
                v36 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v82);
                if (v34) {
                  Diagnostics::error(v35, "tried: '%s' (%s)", a2, v36);
                }
                else {
                  Diagnostics::appendError(v35, ", '%s' (%s)", a2, v36);
                }
                v37 = *(dyld4::RuntimeState **)(a1 + 56);
                if (*(unsigned char *)(*((void *)v37 + 1) + 208))
                {
                  v38 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v82);
                  dyld4::RuntimeState::log(v37, "  found: pseudo-dylib-error: \"%s\" => \"%s\"\n", a2, v38);
                }
              }
              if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
              {
                Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
                *a4 = 1;
                v58 = (vm_address_t **)&v82;
                goto LABEL_141;
              }
              mach_o::Error::~Error((vm_address_t **)&v82);
            }
            ++v30;
            ++v28;
            if (v30 == v29)
            {
              uint64_t v26 = *(dyld4::RuntimeState **)(a1 + 56);
              break;
            }
          }
        }
        if (*(unsigned char *)(*((void *)v26 + 1) + 208) && !*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
          dyld4::RuntimeState::log(v26, "   no pseudo-dylibs matched\n");
        }
      }
      int v79 = 0;
      long long v82 = 0u;
      long long v83 = 0u;
      if (*(unsigned char *)(a1 + 80))
      {
        if (a3 != 3
          && a3 != 8
          && dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*(void *)(*(void *)(a1 + 56) + 8) + 240), a2, (unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
        {
          if (dyld4::ProcessConfig::DyldCache::isOverridablePath((dyld4::ProcessConfig::DyldCache *)(*(void *)(*(void *)(a1 + 56) + 8) + 240), a2)&& (dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(a1 + 56) + 8), a2, &v82, &v79) & 1) != 0)
          {
            if (BYTE8(v83))
            {
              BOOL v39 = 1;
              goto LABEL_77;
            }
            Diagnostics::Diagnostics((Diagnostics *)&v76);
            goto LABEL_92;
          }
LABEL_101:
          Diagnostics::Diagnostics((Diagnostics *)&v76);
          v60 = *(dyld4::RuntimeState **)(a1 + 56);
          if (*(unsigned char *)(*((void *)v60 + 1) + 208))
          {
            dyld4::RuntimeState::log(v60, "  found: dylib-from-cache: (0x%04X) \"%s\"\n", *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), a2);
            v60 = *(dyld4::RuntimeState **)(a1 + 56);
          }
          *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = dyld4::Loader::makeDyldCacheLoader((vm_address_t *)&v76, v60, a2, *(void *)(a1 + 64), *(_DWORD *)(*(void *)(*(void *)(a1 + 40)+ 8)+ 24));
          if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 208) && Diagnostics::hasError((Diagnostics *)&v76))
          {
            v57 = "  found: dylib-from-cache-error: \"%s\" => \"%s\"\n";
            goto LABEL_131;
          }
          goto LABEL_132;
        }
        if (dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(a1 + 56) + 8), a2, &v82, &v79))
        {
          BOOL v39 = *(unsigned char *)(a1 + 82) != 0;
          goto LABEL_76;
        }
      }
      else
      {
        int v45 = dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(a1 + 56) + 8), a2, &v82, &v79);
        unsigned __int8 v46 = 0;
        if (a3 != 3 && a3 != 8) {
          unsigned __int8 v46 = dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*(void *)(*(void *)(a1 + 56) + 8) + 240), a2, (unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
        }
        if (v45)
        {
          if (*(unsigned char *)(a1 + 81)) {
            BOOL v39 = 1;
          }
          else {
            BOOL v39 = v46;
          }
LABEL_76:
          if (BYTE8(v83))
          {
LABEL_77:
            uint64_t v47 = 0;
            uint64_t v48 = *(void *)(a1 + 56);
            v81[0] = v48 + 32;
            v81[1] = v48 + 64;
            while (1)
            {
              uint64_t v49 = v81[v47];
              if (!*(unsigned char *)(*(void *)(a1 + 64) + 5) || v49 != *(void *)(a1 + 56) + 64)
              {
                uint64_t v50 = *(void *)(v49 + 16);
                if (v50) {
                  break;
                }
              }
LABEL_90:
              if (++v47 == 2) {
                goto LABEL_91;
              }
            }
            v51 = *(dyld4::Loader ***)(v49 + 8);
            uint64_t v52 = 8 * v50;
            v53 = v51;
            while (1)
            {
              v54 = *v53;
              dyld4::Loader::fileID(*v53, &v76);
              if (v78)
              {
                BOOL v55 = *((void *)&v82 + 1) != v76.i64[1] || BYTE8(v83) == 0;
                if (!v55 && (void)v82 == v76.i64[0] && (void)v83 == v77) {
                  break;
                }
              }
              ++v53;
              ++v51;
              v52 -= 8;
              if (!v52) {
                goto LABEL_90;
              }
            }
            *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v54;
            *a4 = 1;
            Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
            v59 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(unsigned char *)(*((void *)v59 + 1) + 208))
            {
              dyld4::Loader::path(v54, *(const dyld4::RuntimeState **)(a1 + 56));
              dyld4::RuntimeState::log(v59, "  found: already-loaded-by-inode-mtime: \"%s\"\n");
            }
            return;
          }
LABEL_91:
          Diagnostics::Diagnostics((Diagnostics *)&v76);
          if (v39)
          {
LABEL_92:
            v56 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(unsigned char *)(*((void *)v56 + 1) + 208))
            {
              dyld4::RuntimeState::log(v56, "  found: dylib-from-disk-to-override-cache: \"%s\"\n", a2);
              v56 = *(dyld4::RuntimeState **)(a1 + 56);
            }
            *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = dyld4::Loader::makeDiskLoader((vm_address_t *)&v76, v56, a2, *(void *)(a1 + 64), 1, *(_DWORD *)(*(void *)(*(void *)(a1 + 40)+ 8)+ 24), 0);
            if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 208)
              && Diagnostics::hasError((Diagnostics *)&v76))
            {
              v57 = "  found: dylib-from-disk-to-override-cache-error: \"%s\" => \"%s\"\n";
              goto LABEL_131;
            }
          }
          else
          {
            v66 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(unsigned char *)(*((void *)v66 + 1) + 208))
            {
              dyld4::RuntimeState::log(v66, "  found: dylib-from-disk: \"%s\"\n", a2);
              v66 = *(dyld4::RuntimeState **)(a1 + 56);
            }
            *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = dyld4::Loader::makeDiskLoader((vm_address_t *)&v76, v66, a2, *(void *)(a1 + 64), 0, 0, 0);
            if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 208)
              && Diagnostics::hasError((Diagnostics *)&v76))
            {
              v57 = "  found: dylib-from-disk-error: \"%s\" => \"%s\"\n";
LABEL_131:
              v67 = *(dyld4::RuntimeState **)(a1 + 56);
              v68 = Diagnostics::errorMessage((Diagnostics *)&v76);
              dyld4::RuntimeState::log(v67, v57, a2, v68);
            }
          }
LABEL_132:
          if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
          {
            *a4 = 1;
            Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
          }
          else
          {
            BOOL v69 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
            v70 = *(vm_address_t **)(a1 + 72);
            v71 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v76);
            if (v69) {
              Diagnostics::error(v70, "tried: '%s' (%s)", a2, v71);
            }
            else {
              Diagnostics::appendError(v70, ", '%s' (%s)", a2, v71);
            }
          }
          v58 = (vm_address_t **)&v76;
LABEL_141:
          mach_o::Error::~Error(v58);
          return;
        }
        if (v46) {
          goto LABEL_101;
        }
      }
      uint64_t v61 = *(void *)(*(void *)(a1 + 64) + 32);
      if (v61 && a3 != 3 && a3 != 8) {
        (*(void (**)(uint64_t, char *))(v61 + 16))(v61, a2);
      }
      BOOL v62 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
      v63 = *(vm_address_t **)(a1 + 72);
      if (v62) {
        Diagnostics::error(v63, "tried: ");
      }
      else {
        Diagnostics::appendError(v63, ", ");
      }
      v64 = (const char *)&unk_1A8E7346B;
      if (a3 != 3
        && a3 != 8
        && (!_platform_strncmp(a2, "/usr/lib/", 9uLL)
         || !_platform_strncmp(a2, "/System/Library/", 0x10uLL)
         || !_platform_strncmp(a2, "/System/iOSSupport/usr/lib/", 0x1BuLL)
         || !_platform_strncmp(a2, "/System/iOSSupport/System/Library/", 0x22uLL)
         || !_platform_strncmp(a2, "/System/DriverKit/", 0x12uLL)))
      {
        if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 240)) {
          v64 = ", not in dyld cache";
        }
        else {
          v64 = ", no dyld cache";
        }
      }
      int v65 = v79;
      if (v79 == 1)
      {
        if (dyld4::SyscallDelegate::sandboxBlockedStat(*(dyld4::SyscallDelegate **)(*(void *)(a1 + 56) + 8), a2))
        {
          Diagnostics::appendError(*(vm_address_t **)(a1 + 72), "'%s' (blocked by sandbox)%s", a2, v64);
          v72 = *(dyld4::RuntimeState **)(a1 + 56);
          if (*(unsigned char *)(*((void *)v72 + 1) + 208)) {
            dyld4::RuntimeState::log(v72, "    stat(\"%s\") blocked by file system sandbox\n");
          }
          return;
        }
        int v65 = v79;
      }
      else if (v79 == 2)
      {
        Diagnostics::appendError(*(vm_address_t **)(a1 + 72), "'%s' (no such file%s)");
        return;
      }
      v73 = *(vm_address_t **)(a1 + 72);
      if (v65 == 666)
      {
        Diagnostics::appendError(v73, "'%s' (not a file%s)", a2, v64);
        v74 = *(dyld4::RuntimeState **)(a1 + 56);
        if (*(unsigned char *)(*((void *)v74 + 1) + 208)) {
          dyld4::RuntimeState::log(v74, "    stat(\"%s\") returned path is not a regular file\n");
        }
      }
      else
      {
        Diagnostics::appendError(v73, "'%s' (errno=%d%s)", a2, v65, v64);
        v75 = *(dyld4::RuntimeState **)(a1 + 56);
        if (*(unsigned char *)(*((void *)v75 + 1) + 208)) {
          dyld4::RuntimeState::log(v75, "    stat(\"%s\") returned: errno=%d\n");
        }
      }
      return;
    }
  }
  uint64_t v13 = *(dyld4::Loader ***)(v11 + 8);
  uint64_t v14 = 8 * v12;
  int8x16_t v15 = v13;
  while (1)
  {
    uint64_t v16 = *v15;
    if (dyld4::Loader::matchesPath(*v15, *(const dyld4::RuntimeState **)(a1 + 56), a2)) {
      break;
    }
    ++v15;
    ++v13;
    v14 -= 8;
    if (!v14) {
      goto LABEL_13;
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v16;
  *a4 = 1;
  Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
  int v40 = *(dyld4::RuntimeState **)(a1 + 56);
  if (*(unsigned char *)(*((void *)v40 + 1) + 208)) {
    dyld4::RuntimeState::log(v40, "  found: already-loaded-by-path: \"%s\"\n");
  }
}

BOOL dyld4::Loader::matchesPath(dyld4::Loader *this, const dyld4::RuntimeState *a2, char *a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::matchesPath();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::matchesPath((uint64_t)this, (int)a2, a3);
  }
  else
  {
    return dyld4::JustInTimeLoader::matchesPath(this, a2, a3);
  }
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>(uint64_t a1, void *a2, uint64_t *a3, dyld4::RuntimeState *a4, const char **a5, uint64_t a6)
{
  if (a3[2])
  {
    uint64_t v11 = (char *)*a5;
    int v12 = _platform_strlen(*a5);
    unint64_t v13 = murmurHash((uint64_t *)v11, v12, 0);
    unint64_t v14 = a2[2];
    unint64_t v15 = (v14 - 1) & v13;
    if (v14 <= v15) {
LABEL_8:
    }
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    uint64_t v16 = 1;
    while (1)
    {
      unint64_t v17 = *(void *)(*a2 + 8 * v15);
      if (v17 == -1) {
        break;
      }
      if (a3[2] <= v17) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
      }
      uint64_t v18 = (dyld4::PrebuiltLoader::BindTargetRef *)(*a3 + 24 * v17);
      int v40 = *a5;
      v41.i64[0] = _platform_strlen(v40);
      if (prebuilt_objc::EqualObjCStringKeyOnDisk::equal(v18, (uint64_t)&v40, a4))
      {
        unint64_t v20 = a3[2];
        if (v20 <= v17) {
          dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
        }
        uint64_t v21 = *a3;
        uint64_t v22 = *a3 + 24 * v17;
        unint64_t v25 = *(void *)(v22 + 16);
        uint8x16_t v24 = (void *)(v22 + 16);
        unint64_t v23 = v25;
        if ((v25 & 7) != 0)
        {
          if (v20 <= v23 >> 3) {
LABEL_15:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
          unint64_t v26 = v23 >> 3;
          int v27 = 2;
          while (1)
          {
            unint64_t v28 = *(void *)(v21 + 24 * v26 + 16);
            if ((v28 & 3) == 0) {
              break;
            }
            unint64_t v26 = v28 >> 3;
            ++v27;
            if (v20 <= v28 >> 3) {
              goto LABEL_15;
            }
          }
          __chkstk_darwin();
          unsigned __int8 v31 = (char *)&v39 - v30;
          if (v29 >= 0x200) {
            size_t v32 = 512;
          }
          else {
            size_t v32 = v29;
          }
          bzero((char *)&v39 - v30, v32);
          *(void *)unsigned __int8 v31 = v21 + 24 * v17 + 8;
          unint64_t v33 = a3[2];
          if (v33 <= *v24 >> 3) {
LABEL_23:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
          uint64_t v34 = *v24 >> 3;
          uint64_t v35 = *a3;
          unsigned int v36 = 2;
          while (1)
          {
            uint64_t v37 = v35 + 24 * v34;
            unint64_t v38 = *(void *)(v37 + 16);
            *(void *)&v31[8 * v36 - 8] = v37 + 8;
            if ((v38 & 3) == 0) {
              break;
            }
            uint64_t v34 = v38 >> 3;
            ++v36;
            if (v33 <= v38 >> 3) {
              goto LABEL_23;
            }
          }
          int v40 = v31;
          v41.i64[0] = v36;
          v41.i64[1] = v36;
          (*(void (**)(uint64_t, const char **))(a6 + 16))(a6, &v40);
        }
        else
        {
          uint64_t v42 = v21 + 24 * v17 + 8;
          int v40 = (const char *)&v42;
          int64x2_t v41 = vdupq_n_s64(1uLL);
          (*(void (**)(uint64_t, const char **))(a6 + 16))(a6, &v40);
        }
        return;
      }
      unint64_t v19 = a2[2];
      unint64_t v15 = (v19 - 1) & (v15 + v16++);
      if (v19 <= v15) {
        goto LABEL_8;
      }
    }
  }
}

uint64_t objc::StringHashTable::tryGetIndex(objc::StringHashTable *this, char *__s)
{
  uint64_t v4 = (const unsigned __int8 *)_platform_strlen(__s);
  char v5 = (char)v4;
  unint64_t v6 = objc::lookup8((objc *)__s, v4, *((void *)this + 3));
  int v7 = *((_DWORD *)this + 3);
  uint64_t v8 = *((unsigned int *)this + 4);
  if (v7 == 64) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v6 >> v7;
  }
  uint64_t v10 = v9 ^ *((_DWORD *)this + *((unsigned __int8 *)this + (v6 & v8) + 1056) + 8);
  uint64_t v11 = (char *)this + (v8 + 1) + 1056;
  if (v11[v10] != (v5 & 0x1F | (32 * *__s)))
  {
LABEL_7:
    LODWORD(v12) = 0;
    goto LABEL_8;
  }
  uint64_t v12 = *(int *)&v11[4 * v10 + *((unsigned int *)this + 1)];
  if (v12)
  {
    if (!_platform_strcmp(__s, (const char *)this + v12))
    {
      int v13 = v10 & 0xFFFFFF00;
      LODWORD(v12) = v10;
      uint64_t v14 = 0x100000000;
      return v14 | v13 | v12;
    }
    goto LABEL_7;
  }
LABEL_8:
  int v13 = 0;
  uint64_t v14 = 0;
  return v14 | v13 | v12;
}

size_t _platform_strnlen(const char *__s1, size_t __n)
{
  if ((__n & 0x8000000000000000) != 0) {
    return _platform_strlen(__s1);
  }
  if (!__n) {
    return 0;
  }
  unint64_t v3 = (unint64_t)__s1 & 0xFFFFFFFFFFFFFFF0;
  uint64_t v4 = (int8x16_t *)&algn_1A8E00DF0[-(__s1 & 0xF)];
  int8x16_t v5 = *v4;
  uint8x16_t v6 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((unint64_t)__s1 & 0xFFFFFFFFFFFFFFF0), *v4);
  size_t v7 = __n + (__s1 & 0xF);
  while (1)
  {
    v5.i8[0] = vminvq_u8(v6);
    if (!v5.i32[0]) {
      break;
    }
    BOOL v9 = v7 > 0x10;
    v7 -= 16;
    if (!v9) {
      return v3 - (void)__s1 + v7 + 16;
    }
    uint8x16_t v8 = *(uint8x16_t *)(v3 + 16);
    v3 += 16;
    uint8x16_t v6 = v8;
  }
  uint8x16_t v10 = (uint8x16_t)veorq_s8(v5, v5);
  v10.i8[0] = vminvq_u8((uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v6, v10), (int8x16_t)xmmword_1A8E00DE0));
  unint64_t v11 = v3 - (void)__s1;
  if (v7 >= v10.u32[0]) {
    size_t v7 = v10.u32[0];
  }
  return v11 + v7;
}

size_t _platform_strlen(const char *__s)
{
  unint64_t v1 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
  unint64_t v2 = (int8x16_t *)&algn_1A8E00DF0[-(__s & 0xF)];
  int8x16_t v3 = *v2;
  for (uint8x16_t i = (uint8x16_t)vorrq_s8(*(int8x16_t *)((unint64_t)__s & 0xFFFFFFFFFFFFFFF0), *v2); ; uint8x16_t i = v5)
  {
    v3.i8[0] = vminvq_u8(i);
    if (!v3.i32[0]) {
      break;
    }
    uint8x16_t v5 = *(uint8x16_t *)(v1 + 16);
    v1 += 16;
  }
  uint8x16_t v6 = (uint8x16_t)veorq_s8(v3, v3);
  v6.i8[0] = vminvq_u8((uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, v6), (int8x16_t)xmmword_1A8E00DE0));
  return v1 - (void)__s + v6.u32[0];
}

BOOL dyld4::PrebuiltLoader::matchesPath(uint64_t a1, int a2, char *__s1)
{
  if (*(_WORD *)(a1 + 32)) {
    uint8x16_t v5 = (const char *)(a1 + *(unsigned __int16 *)(a1 + 32));
  }
  else {
    uint8x16_t v5 = 0;
  }
  return !_platform_strcmp(__s1, v5)
      || *(_WORD *)(a1 + 40) && !_platform_strcmp(__s1, (const char *)(a1 + *(unsigned __int16 *)(a1 + 40)));
}

int _platform_strcmp(const char *__s1, const char *__s2)
{
  while ((__s1 & 0xF) != 0)
  {
    unsigned int v3 = *(unsigned __int8 *)__s1++;
    uint64_t v2 = v3;
    int v4 = *(unsigned __int8 *)__s2++;
    int v5 = v2 - v4;
    if (v2 != v4 || v2 == 0) {
      return v5;
    }
  }
  if ((__s2 & 0xF) != 0)
  {
    uint64_t v8 = -(uint64_t)__s2 & 0xFF0;
    if (!v8) {
      goto LABEL_12;
    }
LABEL_10:
    while (1)
    {
      int8x16_t v9 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v10 = v9;
      int8x16_t v11 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v13 = vceqq_s8(v10, v11);
      uint8x16_t v12 = (uint8x16_t)vandq_s8(v10, v13);
      v13.i8[0] = vminvq_u8(v12);
      if (!v13.i32[0]) {
        break;
      }
      v8 -= 16;
      if (!v8)
      {
LABEL_12:
        while (1)
        {
          unsigned int v15 = *(unsigned __int8 *)__s1++;
          uint64_t v14 = v15;
          int v16 = *(unsigned __int8 *)__s2++;
          int v5 = v14 - v16;
          if (v14 != v16 || v14 == 0) {
            return v5;
          }
          if ((__s1 & 0xF) == 0)
          {
            uint64_t v8 = 4080;
            goto LABEL_10;
          }
        }
      }
    }
  }
  else
  {
    do
    {
      int8x16_t v18 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v19 = v18;
      int8x16_t v20 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v13 = vceqq_s8(v19, v20);
      uint8x16_t v12 = (uint8x16_t)vandq_s8(v19, v13);
      v13.i8[0] = vminvq_u8(v12);
    }
    while (v13.i32[0]);
  }
  uint8x16_t v21 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v12, (uint8x16_t)veorq_s8(v13, v13)), (int8x16_t)xmmword_1A8E00F80);
  v21.i8[0] = vminvq_u8(v21);
  return __s1[v21.u32[0] - 16] - __s2[v21.u32[0] - 16];
}

uint64_t SwiftHashTable::hash<SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, objc *this)
{
  unint64_t v4 = objc::lookup8(this, (const unsigned __int8 *)8, *(void *)(a1 + 24));
  unint64_t v5 = objc::lookup8((objc *)((char *)this + 8), (const unsigned __int8 *)8, *(void *)(a1 + 24));
  int v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (v5 ^ v4) >> v6;
  }
  return v7 ^ *(_DWORD *)(a1 + 4 * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

unint64_t objc::lookup8(objc *this, const unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v3 = 0x9E3779B97F4A7C13;
  if ((unint64_t)a2 < 0x18)
  {
    unint64_t v5 = a3;
    unint64_t v4 = a2;
  }
  else
  {
    unint64_t v4 = a2;
    unint64_t v5 = a3;
    do
    {
      unint64_t v6 = a3
         + ((unint64_t)*((unsigned __int8 *)this + 14) << 48)
         + (*((unsigned int *)this + 2) | ((unint64_t)*((unsigned __int8 *)this + 12) << 32) | ((unint64_t)*((unsigned __int8 *)this + 13) << 40))
         + ((unint64_t)*((unsigned __int8 *)this + 15) << 56);
      unint64_t v7 = v3
         + ((unint64_t)*((unsigned __int8 *)this + 22) << 48)
         + (*((unsigned int *)this + 4) | ((unint64_t)*((unsigned __int8 *)this + 20) << 32) | ((unint64_t)*((unsigned __int8 *)this + 21) << 40))
         + ((unint64_t)*((unsigned __int8 *)this + 23) << 56);
      unint64_t v8 = (v5
          + ((unint64_t)*((unsigned __int8 *)this + 6) << 48)
          + (*(unsigned int *)this | ((unint64_t)*((unsigned __int8 *)this + 4) << 32) | ((unint64_t)*((unsigned __int8 *)this + 5) << 40))
          + ((unint64_t)*((unsigned __int8 *)this + 7) << 56)
          - (v6
           + v7)) ^ (v7 >> 43);
      unint64_t v9 = (v6 - v7 - v8) ^ (v8 << 9);
      unint64_t v10 = (v7 - v8 - v9) ^ (v9 >> 8);
      unint64_t v11 = (v8 - v9 - v10) ^ (v10 >> 38);
      unint64_t v12 = (v9 - v10 - v11) ^ (v11 << 23);
      unint64_t v13 = (v10 - v11 - v12) ^ (v12 >> 5);
      unint64_t v14 = (v11 - v12 - v13) ^ (v13 >> 35);
      unint64_t v15 = (v12 - v13 - v14) ^ (v14 << 49);
      unint64_t v16 = (v13 - v14 - v15) ^ (v15 >> 11);
      unint64_t v5 = (v14 - v15 - v16) ^ (v16 >> 12);
      a3 = (v15 - v16 - v5) ^ (v5 << 18);
      unint64_t v3 = (v16 - v5 - a3) ^ (a3 >> 22);
      this = (objc *)((char *)this + 24);
      v4 -= 24;
    }
    while ((unint64_t)v4 > 0x17);
  }
  unint64_t v17 = (unint64_t)&a2[v3];
  switch((unint64_t)v4)
  {
    case 1uLL:
      goto LABEL_29;
    case 2uLL:
      goto LABEL_28;
    case 3uLL:
      goto LABEL_27;
    case 4uLL:
      goto LABEL_26;
    case 5uLL:
      goto LABEL_25;
    case 6uLL:
      goto LABEL_24;
    case 7uLL:
      goto LABEL_23;
    case 8uLL:
      goto LABEL_22;
    case 9uLL:
      goto LABEL_21;
    case 0xAuLL:
      goto LABEL_20;
    case 0xBuLL:
      goto LABEL_19;
    case 0xCuLL:
      goto LABEL_18;
    case 0xDuLL:
      goto LABEL_17;
    case 0xEuLL:
      goto LABEL_16;
    case 0xFuLL:
      goto LABEL_15;
    case 0x10uLL:
      goto LABEL_14;
    case 0x11uLL:
      goto LABEL_13;
    case 0x12uLL:
      goto LABEL_12;
    case 0x13uLL:
      goto LABEL_11;
    case 0x14uLL:
      goto LABEL_10;
    case 0x15uLL:
      goto LABEL_9;
    case 0x16uLL:
      goto LABEL_8;
    case 0x17uLL:
      v17 += (unint64_t)*((unsigned __int8 *)this + 22) << 56;
LABEL_8:
      v17 += (unint64_t)*((unsigned __int8 *)this + 21) << 48;
LABEL_9:
      v17 += (unint64_t)*((unsigned __int8 *)this + 20) << 40;
LABEL_10:
      v17 += (unint64_t)*((unsigned __int8 *)this + 19) << 32;
LABEL_11:
      v17 += (unint64_t)*((unsigned __int8 *)this + 18) << 24;
LABEL_12:
      v17 += (unint64_t)*((unsigned __int8 *)this + 17) << 16;
LABEL_13:
      v17 += (unint64_t)*((unsigned __int8 *)this + 16) << 8;
LABEL_14:
      a3 += (unint64_t)*((unsigned __int8 *)this + 15) << 56;
LABEL_15:
      a3 += (unint64_t)*((unsigned __int8 *)this + 14) << 48;
LABEL_16:
      a3 += (unint64_t)*((unsigned __int8 *)this + 13) << 40;
LABEL_17:
      a3 += (unint64_t)*((unsigned __int8 *)this + 12) << 32;
LABEL_18:
      a3 += (unint64_t)*((unsigned __int8 *)this + 11) << 24;
LABEL_19:
      a3 += (unint64_t)*((unsigned __int8 *)this + 10) << 16;
LABEL_20:
      a3 += (unint64_t)*((unsigned __int8 *)this + 9) << 8;
LABEL_21:
      a3 += *((unsigned __int8 *)this + 8);
LABEL_22:
      v5 += (unint64_t)*((unsigned __int8 *)this + 7) << 56;
LABEL_23:
      v5 += (unint64_t)*((unsigned __int8 *)this + 6) << 48;
LABEL_24:
      v5 += (unint64_t)*((unsigned __int8 *)this + 5) << 40;
LABEL_25:
      v5 += (unint64_t)*((unsigned __int8 *)this + 4) << 32;
LABEL_26:
      v5 += (unint64_t)*((unsigned __int8 *)this + 3) << 24;
LABEL_27:
      v5 += (unint64_t)*((unsigned __int8 *)this + 2) << 16;
LABEL_28:
      v5 += (unint64_t)*((unsigned __int8 *)this + 1) << 8;
LABEL_29:
      v5 += *(unsigned __int8 *)this;
      break;
    default:
      break;
  }
  unint64_t v18 = (v5 - a3 - v17) ^ (v17 >> 43);
  unint64_t v19 = (a3 - v17 - v18) ^ (v18 << 9);
  unint64_t v20 = (v17 - v18 - v19) ^ (v19 >> 8);
  unint64_t v21 = (v18 - v19 - v20) ^ (v20 >> 38);
  unint64_t v22 = (v19 - v20 - v21) ^ (v21 << 23);
  unint64_t v23 = (v20 - v21 - v22) ^ (v22 >> 5);
  unint64_t v24 = (v21 - v22 - v23) ^ (v23 >> 35);
  unint64_t v25 = (v22 - v23 - v24) ^ (v24 << 49);
  unint64_t v26 = (v23 - v24 - v25) ^ (v25 >> 11);
  unint64_t v27 = (v24 - v25 - v26) ^ (v26 >> 12);
  return (v26 - v27 - ((v25 - v26 - v27) ^ (v27 << 18))) ^ (((v25 - v26 - v27) ^ (v27 << 18)) >> 22);
}

uint64_t dyld4::PrebuiltLoader::hiddenFromFlat(dyld4::PrebuiltLoader *this)
{
  return 0;
}

uint64_t dyld4::Loader::representsCachedDylibIndex(dyld4::Loader *this, int a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::representsCachedDylibIndex();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::hiddenFromFlat(this);
  }
  else
  {
    return dyld4::JustInTimeLoader::representsCachedDylibIndex(this, a2);
  }
}

BOOL prebuilt_objc::EqualObjCStringKeyOnDisk::equal(dyld4::PrebuiltLoader::BindTargetRef *a1, uint64_t a2, dyld4::RuntimeState *a3)
{
  unint64_t v4 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(a1, a3);
  size_t v5 = _platform_strlen(v4);
  return v5 == *(void *)(a2 + 8) && _platform_memcmp(v4, *(const void **)a2, v5) == 0;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::value(dyld4::PrebuiltLoader::BindTargetRef *this, dyld4::RuntimeState *a2)
{
  unint64_t v2 = *(void *)this;
  if ((*(void *)this & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (v2 >> 8) | 0x80000000000000;
    if ((v2 & 0x4000000000000000) == 0) {
      uint64_t v9 = (v2 >> 8) & 0x7FFFFFFFFFFFFFLL;
    }
    return v9 | (v2 << 56);
  }
  else
  {
    __int16 v10 = *(void *)this;
    size_t v5 = (dyld4::PrebuiltLoader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v10, a2);
    uint64_t Address = dyld4::PrebuiltLoader::loadAddress(v5, a2);
    uint64_t v7 = (*(void *)this >> 24) | 0xFFFF8000000000;
    if ((*(void *)this & 0x4000000000000000) == 0) {
      uint64_t v7 = (*(void *)this >> 24) & 0x7FFFFFFFFFLL;
    }
    return Address + (*(void *)this >> 16 << 56) + v7;
  }
}

uint64_t dyld4::PrebuiltLoader::loadAddress(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  int v2 = *((__int16 *)this + 3);
  if (v2 < 0) {
    return dyld4::RuntimeState::appLoadAddress(a2, v2 & 0x7FFF);
  }
  else {
    return dyld4::RuntimeState::cachedDylibLoadAddress(a2, *((unsigned __int16 *)this + 3));
  }
}

uint64_t dyld4::RuntimeState::appLoadAddress(dyld4::RuntimeState *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 124);
  if (!v2) {
    dyld4::RuntimeState::appLoadAddress();
  }
  if (*(_DWORD *)(v2 + 12) <= a2) {
    dyld4::RuntimeState::appLoadAddress();
  }
  return *(void *)(*((void *)this + 126) + 8 * a2);
}

double dyld4::Loader::fileID@<D0>(dyld4::Loader *this@<X0>, int8x16_t *a2@<X8>)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::fileID();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::fileID((uint64_t)this, a2);
  }
  else
  {
    *(void *)&double result = dyld4::JustInTimeLoader::fileID((uint64_t)this, (uint64_t)a2).n128_u64[0];
  }
  return result;
}

double dyld4::PrebuiltLoader::fileID@<D0>(uint64_t a1@<X0>, int8x16_t *a2@<X8>)
{
  if (a1 && *(_WORD *)(a1 + 42))
  {
    uint64_t v2 = a1 + *(unsigned __int16 *)(a1 + 42);
    uint64_t v3 = *(void *)(v2 + 24);
    __int8 v4 = *(unsigned char *)(v2 + 52);
    int8x16_t v5 = vextq_s8(*(int8x16_t *)(v2 + 8), *(int8x16_t *)(v2 + 8), 8uLL);
    *a2 = v5;
    a2[1].i64[0] = v3;
    a2[1].i8[8] = v4;
  }
  else
  {
    v5.i64[0] = 0;
    *a2 = 0u;
    a2[1] = 0u;
  }
  return *(double *)v5.i64;
}

int _platform_memcmp(const void *__s1, const void *__s2, size_t __n)
{
  BOOL v3 = __n >= 0x10;
  size_t v4 = __n - 16;
  if (!v3)
  {
    BOOL v3 = __CFADD__(v4, 8);
    size_t v17 = v4 + 8;
    if (v3)
    {
      unint64_t v19 = *(void *)__s1;
      __s1 = (char *)__s1 + 8;
      unint64_t v18 = v19;
      unint64_t v21 = *(void *)__s2;
      __s2 = (char *)__s2 + 8;
      unint64_t v20 = v21;
      unint64_t v22 = v18 - v21;
      if (v18 != v21) {
        goto LABEL_18;
      }
      v17 -= 8;
    }
    BOOL v3 = __CFADD__(v17, 4);
    size_t v23 = v17 + 4;
    if (!v3)
    {
      v23 += 4;
      LODWORD(v22) = 0;
      goto LABEL_20;
    }
    unsigned int v24 = *(_DWORD *)__s1;
    __s1 = (char *)__s1 + 4;
    unint64_t v18 = v24;
    unsigned int v25 = *(_DWORD *)__s2;
    __s2 = (char *)__s2 + 4;
    unint64_t v20 = v25;
    unint64_t v22 = v18 - v25;
    if (v18 == v25)
    {
      do
      {
LABEL_20:
        BOOL v3 = v23-- != 0;
        if (!v3) {
          break;
        }
        unsigned int v28 = *(unsigned __int8 *)__s1;
        __s1 = (char *)__s1 + 1;
        uint64_t v27 = v28;
        int v29 = *(unsigned __int8 *)__s2;
        __s2 = (char *)__s2 + 1;
        LODWORD(v22) = v27 - v29;
      }
      while (v27 == v29);
      return v22;
    }
LABEL_18:
    unint64_t v26 = __clz(bswap64(v22)) & 0xFFFFFFFFFFFFFFF8;
    return (v18 >> v26) - (v20 >> v26);
  }
  if (v4)
  {
    int8x16_t v5 = (char *)__s1 + v4;
    unint64_t v6 = (char *)__s2 + v4;
    while (1)
    {
      int8x16_t v7 = *(int8x16_t *)__s1;
      __s1 = (char *)__s1 + 16;
      int8x16_t v8 = v7;
      int8x16_t v9 = *(int8x16_t *)__s2;
      __s2 = (char *)__s2 + 16;
      int8x16_t v10 = vceqq_s8(v8, v9);
      v8.i8[0] = vminvq_u8((uint8x16_t)v10);
      if (!v8.i32[0]) {
        break;
      }
      BOOL v11 = v4 > 0x10;
      v4 -= 16;
      if (!v11)
      {
        __s1 = v5;
        __s2 = v6;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    int8x16_t v12 = *(int8x16_t *)__s1;
    __s1 = (char *)__s1 + 16;
    int8x16_t v13 = v12;
    int8x16_t v14 = *(int8x16_t *)__s2;
    __s2 = (char *)__s2 + 16;
    int8x16_t v10 = vceqq_s8(v13, v14);
    v13.i8[0] = vminvq_u8((uint8x16_t)v10);
    if (v13.i32[0]) {
      return 0;
    }
  }
  uint8x16_t v16 = (uint8x16_t)vorrq_s8(v10, (int8x16_t)xmmword_1A8E015E0);
  v16.i8[0] = vminvq_u8(v16);
  return *((unsigned __int8 *)__s1 + v16.u32[0] - 16) - *((unsigned __int8 *)__s2 + v16.u32[0] - 16);
}

void ___ZN13prebuilt_objc15forEachProtocolEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    uint64_t v2 = __chkstk_darwin();
    unint64_t v6 = (char *)v12 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v7 = v3[2];
    v12[0] = v6;
    v12[1] = v7;
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = *v3;
      uint64_t v10 = 8 * v7;
      do
      {
        if (v7 == v8) {
          ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
        }
        uint64_t v11 = v8 + 1;
        *(void *)&v6[8 * v8] = *(void *)(v9 + 8 * v8);
        ++v8;
        v10 -= 8;
      }
      while (v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    v12[2] = v11;
    (*(void (**)(void, void *, uint64_t))(*(void *)(v2 + 32) + 16))(*(void *)(v2 + 32), v12, v4);
  }
}

uint64_t ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(dyld4::RuntimeState **)(result + 48);
    uint64_t v5 = *(dyld4::PrebuiltLoader::BindTargetRef ***)a2;
    uint64_t v6 = 8 * v2 - 8;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v8 = *(void *)(v3 + 32);
      unint64_t v9 = dyld4::PrebuiltLoader::BindTargetRef::value(v7, v4);
      double result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v8 + 16))(v8, v9, 1, *(void *)(*(void *)(v3 + 40) + 8) + 24);
      if (*(unsigned char *)(*(void *)(*(void *)(v3 + 40) + 8) + 24)) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v6 == 0;
      }
      v6 -= 8;
    }
    while (!v10);
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_find_foreign_type_protocol_conformance_on_disk(dyld4::APIs *this, dyld4::PrebuiltLoader::BindTargetRef *a2, dyld4::PrebuiltLoader::BindTargetRef *a3, uint64_t a4)
{
  uint64_t v4 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 124);
  if (!v4) {
    return 2;
  }
  if (!dyld4::PrebuiltLoaderSet::hasOptimizedSwift(*((dyld4::PrebuiltLoaderSet **)this + 124))) {
    return 2;
  }
  if (!dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(v4)) {
    return 2;
  }
  if (!*((void *)this + 63)) {
    return 2;
  }
  v16[0] = 0;
  v16[1] = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a3);
  v16[2] = a4;
  v16[3] = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
  unint64_t v9 = (void *)dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::find(*((void *)this + 63), (uint64_t)v16);
  if (v9 == (void *)(*(void *)(*((void *)this + 63) + 56) + 48 * *(void *)(*((void *)this + 63) + 72))) {
    return 2;
  }
  BOOL v10 = v9;
  if (dyld4::EqualForeignConformanceLookupKey::equal(v9, (const char *)a3, a4, (uint64_t)a2, this))
  {
LABEL_10:
    uint64_t v15 = v10[4];
    unsigned int v13 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)&v15) & 0x7FFF;
    if (*((_DWORD *)v4 + 3) <= v13) {
      dyld4::RuntimeState::findPrebuiltLoader();
    }
    dyld4::PrebuiltLoader::loadAddress((dyld4::PrebuiltLoaderSet *)((char *)v4 + *(unsigned int *)((char *)v4 + 4 * v13 + *((unsigned int *)v4 + 4))), this);
    dyld4::PrebuiltLoader::BindTargetRef::offset((dyld4::PrebuiltLoader::BindTargetRef *)&v15);
    return 0;
  }
  else
  {
    uint64_t v11 = 2;
    while (1)
    {
      unint64_t v12 = v10[5];
      if ((v12 & 3) == 0) {
        break;
      }
      BOOL v10 = (void *)dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(*((void *)this + 63) + 56), v12 >> 3);
      if (dyld4::EqualForeignConformanceLookupKey::equal(v10, (const char *)a3, a4, (uint64_t)a2, this)) {
        goto LABEL_10;
      }
    }
  }
  return v11;
}

uint64_t dyld4::APIs::_dyld_find_protocol_conformance_on_disk(dyld4::PrebuiltLoaderSet **this, dyld4::PrebuiltLoader::BindTargetRef *a2, dyld4::PrebuiltLoader::BindTargetRef *a3, dyld4::PrebuiltLoader::BindTargetRef *a4)
{
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_find_protocol_conformance_on_disk(%p, %p, %p)\n", a2, a3, a4);
  }
  uint64_t v8 = this[124];
  if (!v8 || !dyld4::PrebuiltLoaderSet::hasOptimizedSwift(this[124])) {
    return 2;
  }
  uint64_t v9 = dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(v8);
  if (a4)
  {
    if (v9)
    {
      if (this[61])
      {
        unint64_t Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a4);
        unint64_t v21 = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
        uint64_t v10 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find(this[61], (uint64_t)&Absolute);
        if (v10 != *((void *)this[61] + 7) + 32 * *((void *)this[61] + 9))
        {
          uint64_t v11 = v10;
          if (dyld4::EqualTypeConformanceLookupKey::equal(v10, (uint64_t)a4, (uint64_t)a2, (dyld4::RuntimeState *)this))
          {
LABEL_12:
            unsigned int v13 = (dyld4::PrebuiltLoader::BindTargetRef *)(v11 + 16);
            unsigned int v14 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)(v11 + 16)) & 0x7FFF;
            if (*((_DWORD *)v8 + 3) <= v14) {
              dyld4::RuntimeState::findPrebuiltLoader();
            }
            goto LABEL_22;
          }
          while (1)
          {
            unint64_t v12 = *(void *)(v11 + 24);
            if ((v12 & 3) == 0) {
              break;
            }
            uint64_t v11 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)this[61] + 7, v12 >> 3);
            if (dyld4::EqualTypeConformanceLookupKey::equal(v11, (uint64_t)a4, (uint64_t)a2, (dyld4::RuntimeState *)this)) {
              goto LABEL_12;
            }
          }
        }
      }
    }
  }
  uint64_t v15 = dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(v8);
  uint64_t result = 2;
  if (a3 && v15)
  {
    if (this[62])
    {
      unint64_t Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a3);
      unint64_t v21 = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
      uint64_t v17 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find(this[62], (uint64_t)&Absolute);
      if (v17 != *((void *)this[62] + 7) + 32 * *((void *)this[62] + 9))
      {
        for (uint64_t i = v17;
              !dyld4::EqualMetadataConformanceLookupKey::equal(i, (uint64_t)a3, (uint64_t)a2, (dyld4::RuntimeState *)this);
              uint64_t i = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)this[62] + 7, v19 >> 3))
        {
          unint64_t v19 = *(void *)(i + 24);
          if ((v19 & 3) == 0) {
            return 2;
          }
        }
        unsigned int v13 = (dyld4::PrebuiltLoader::BindTargetRef *)(i + 16);
        unsigned int v14 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)(i + 16)) & 0x7FFF;
        if (*((_DWORD *)v8 + 3) <= v14) {
          dyld4::RuntimeState::findPrebuiltLoader();
        }
LABEL_22:
        dyld4::PrebuiltLoader::loadAddress((dyld4::PrebuiltLoaderSet *)((char *)v8 + *(unsigned int *)((char *)v8 + 4 * v14 + *((unsigned int *)v8 + 4))), (const dyld4::RuntimeState *)this);
        dyld4::PrebuiltLoader::BindTargetRef::offset(v13);
        return 0;
      }
    }
    return 2;
  }
  return result;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(&v2, (uint64_t)this);
  return v2;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *this, uint64_t a2)
{
  uint64_t v2 = __ROR8__(a2, 56);
  *this = v2 | 0x8000000000000000;
  unint64_t v3 = ((v2 | 0x8000000000000000) >> 8) & 0x7FFFFFFFFFFFFFLL;
  if ((v2 & 0x4000000000000000) != 0) {
    unint64_t v3 = (v2 | 0x8000000000000000) >> 8;
  }
  if ((v3 | (v2 << 56)) != a2) {
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  }
  return this;
}

BOOL dyld4::PrebuiltLoaderSet::hasOptimizedSwift(dyld4::PrebuiltLoaderSet *this)
{
  return *((_DWORD *)this + 16) || *((_DWORD *)this + 17) || *((_DWORD *)this + 18) != 0;
}

uint64_t dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 16);
  if (v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 17);
  if (v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0;
  }
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find(void *a1, uint64_t a2)
{
  unint64_t v4 = (a1[4] - 1) & dyld4::HashMetadataConformanceKey::hash(a2);
  unint64_t v5 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](a1 + 2, v4);
  if (v5 == -1) {
    return a1[7] + 32 * a1[9];
  }
  for (uint64_t i = 1; ; ++i)
  {
    uint64_t v7 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](a1 + 7, v5);
    if (dyld4::EqualTypeConformanceKey::equal(v7, a2)) {
      break;
    }
    unint64_t v4 = (a1[4] - 1) & (v4 + i);
    unint64_t v5 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](a1 + 2, v4);
    if (v5 == -1) {
      return a1[7] + 32 * a1[9];
    }
  }

  return dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](a1 + 7, v5);
}

uint64_t dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 8 * a2;
}

uint64_t dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 32 * a2;
}

BOOL dyld4::EqualTypeConformanceKey::equal(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v4 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a1);
  if ((((unsigned __int16)dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a2) ^ v4) & 0xFFF) != 0) {
    return 0;
  }
  int v6 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8));
  return ((dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 8)) ^ v6) & 0xFFFLL) == 0;
}

unint64_t dyld4::HashMetadataConformanceKey::hash(uint64_t a1)
{
  unint64_t v5 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a1) & 0xFFF;
  unint64_t v4 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8)) & 0xFFF;
  unint64_t v2 = murmurHash((uint64_t *)&v5, 8, 0);
  return murmurHash((uint64_t *)&v4, 8, 0) ^ v2;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *(void *)this >> 24;
  if ((*(void *)this & 0x4000000000000000) != 0) {
    v2 |= 0xFFFF8000000000uLL;
  }
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)BYTE2(*(void *)this) << 56);
  uint64_t v4 = ((unint64_t)v1 >> 8) | 0x80000000000000;
  if ((v1 & 0x4000000000000000) == 0) {
    uint64_t v4 = ((unint64_t)v1 >> 8) & 0x7FFFFFFFFFFFFFLL;
  }
  uint64_t v5 = v4 | (v1 << 56);
  if (v1 < 0) {
    return v5;
  }
  else {
    return v3;
  }
}

unint64_t murmurHash(uint64_t *a1, int a2, uint64_t a3)
{
  unint64_t v3 = (0xC6A4A7935BD1E995 * a2) ^ a3;
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 7;
  }
  if ((a2 + 7) >= 0xF)
  {
    uint64_t v5 = 8 * ((uint64_t)v4 >> 3);
    int v6 = (char *)&a1[v4 >> 3];
    do
    {
      uint64_t v7 = *a1++;
      unint64_t v3 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v7) ^ ((0xC6A4A7935BD1E995 * v7) >> 47))) ^ v3);
      v5 -= 8;
    }
    while (v5);
    a1 = (uint64_t *)v6;
  }
  switch(a2 & 7)
  {
    case 1:
      goto LABEL_15;
    case 2:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_11;
    case 6:
      goto LABEL_10;
    case 7:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 6) << 48;
LABEL_10:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 5) << 40;
LABEL_11:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 4) << 32;
LABEL_12:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 3) << 24;
LABEL_13:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 2) << 16;
LABEL_14:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 1) << 8;
LABEL_15:
      v3 ^= *(unsigned __int8 *)a1;
      break;
    default:
      break;
  }
  unint64_t v8 = 0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v3) ^ ((0xC6A4A7935BD1E995 * v3) >> 47));
  return v8 ^ (v8 >> 47);
}

BOOL dyld4::EqualTypeConformanceLookupKey::equal(uint64_t a1, uint64_t a2, uint64_t a3, dyld4::RuntimeState *a4)
{
  if (!a4) {
    dyld4::EqualTypeConformanceLookupKey::equal();
  }
  return dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)a1, a4) == a2
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a4) == a3;
}

uint64_t dyld4::PrebuiltLoader::BindTargetRef::loaderRef(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t result = *(void *)this;
  if (result < 0) {
    dyld4::PrebuiltLoader::BindTargetRef::loaderRef();
  }
  return result;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::offset(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t v1 = *(void *)this >> 16;
  if ((*(void *)this & 0x4000000000000000) != 0) {
    uint64_t v2 = (*(void *)this >> 24) | 0xFFFF8000000000;
  }
  else {
    uint64_t v2 = (*(void *)this >> 24) & 0x7FFFFFFFFFLL;
  }
  return v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v1 << 56);
}

DyldSharedCache *dyld4::ProcessConfig::DyldCache::indexOfPath(DyldSharedCache **this, const char *a2, unsigned int *a3)
{
  uint64_t result = *this;
  if (result) {
    return (DyldSharedCache *)DyldSharedCache::hasImagePath(result, a2, a3);
  }
  return result;
}

uint64_t dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 18);
  if (v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0;
  }
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::find(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (*(void *)(a1 + 32) - 1) & dyld4::HashForeignConformanceKey::hash(a2, *(dyld4::RuntimeState **)(a1 + 96));
  unint64_t v5 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v4);
  if (v5 == -1) {
    return *(void *)(a1 + 56) + 48 * *(void *)(a1 + 72);
  }
  for (uint64_t i = 1; ; ++i)
  {
    uint64_t v7 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v5);
    if (dyld4::EqualForeignConformanceKey::equal(v7, a2, *(dyld4::RuntimeState **)(a1 + 96))) {
      break;
    }
    unint64_t v4 = (*(void *)(a1 + 32) - 1) & (v4 + i);
    unint64_t v5 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v4);
    if (v5 == -1) {
      return *(void *)(a1 + 56) + 48 * *(void *)(a1 + 72);
    }
  }

  return dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v5);
}

unint64_t dyld4::HashForeignConformanceKey::hash(uint64_t a1, dyld4::RuntimeState *a2)
{
  if (a2) {
    unint64_t v3 = (uint64_t *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a2);
  }
  else {
    unint64_t v3 = *(uint64_t **)a1;
  }
  unint64_t v6 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 24)) & 0xFFF;
  unint64_t v4 = murmurHash(v3, *(_DWORD *)(a1 + 16), 0);
  return murmurHash((uint64_t *)&v6, 8, 0) ^ v4;
}

BOOL dyld4::JustInTimeLoader::matchesPath(dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2, char *__s1)
{
  uint64_t v5 = *((void *)this + 5);
  if ((_WORD)v5) {
    unint64_t v6 = (char *)this + (unsigned __int16)*((void *)this + 5);
  }
  else {
    unint64_t v6 = 0;
  }
  if (!_platform_strcmp(__s1, v6)) {
    return 1;
  }
  if ((v5 & 0x100000) != 0)
  {
    uint64_t v7 = dyld3::MachOFile::installName(*((dyld3::MachOFile **)this + 4));
    if (!_platform_strcmp(__s1, v7)) {
      return 1;
    }
  }
  uint64_t v10 = (dyld4::PseudoDylib *)*((void *)this + 13);
  uint64_t v9 = (uint64_t (****)(char *))((char *)this + 104);
  unint64_t v8 = v10;
  if (!v10) {
    return 0;
  }
  uint64_t v11 = (char *)dyld4::PseudoDylib::loadableAtPath(v8, __s1);
  if (v11 == __s1 || v11 == 0) {
    return v11 != 0;
  }
  dyld4::PseudoDylib::disposeString(*v9, v11);
  return 1;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 48 * a2;
}

BOOL dyld4::EqualForeignConformanceKey::equal(uint64_t a1, uint64_t a2, dyld4::RuntimeState *a3)
{
  if (a3)
  {
    unint64_t v6 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a3);
    uint64_t v7 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 8), a3);
  }
  else
  {
    unint64_t v6 = *(const char **)a1;
    uint64_t v7 = *(const char **)a2;
  }
  size_t v8 = *(void *)(a1 + 16);
  if (_platform_strncmp(v6, v7, v8)) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = v8 == *(void *)(a2 + 16);
  }
  if (!v9) {
    return 0;
  }
  int v11 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 24));
  return ((dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 24)) ^ v11) & 0xFFFLL) == 0;
}

BOOL dyld4::JustInTimeLoader::representsCachedDylibIndex(dyld4::JustInTimeLoader *this, int a2)
{
  unint64_t v2 = *((void *)this + 5);
  return (v2 & 0x400000) != 0 && ((v2 >> 24) & 0x7FFF) == a2
      || (*((_WORD *)this + 2) & 2) != 0 && (*((_WORD *)this + 3) & 0x7FFF) == a2;
}

char *dyld3::MachOFile::installName(dyld3::MachOFile *this)
{
  *(void *)unint64_t v2 = 0;
  unint64_t v3 = 0;
  if (dyld3::MachOFile::getDylibInstallName(this, (const char **)&v3, &v2[1], v2)) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t dyld3::MachOFile::getDylibInstallName(dyld3::MachOFile *this, const char **a2, unsigned int *a3, unsigned int *a4)
{
  Diagnostics::Diagnostics((Diagnostics *)&v15);
  uint64_t v11 = 0;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK5dyld39MachOFile19getDylibInstallNameEPPKcPjS4__block_invoke;
  void v10[3] = &unk_1EFF661C0;
  v10[6] = a4;
  v10[7] = a2;
  v10[4] = &v11;
  v10[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v15, (uint64_t)v10);
  Diagnostics::assertNoError((Diagnostics *)&v15);
  uint64_t v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  mach_o::Error::~Error(&v15);
  return v8;
}

uint64_t dyld4::JustInTimeLoader::getSectionLocations(dyld4::JustInTimeLoader *this)
{
  return (uint64_t)this + 120;
}

void dyld4::halt(char *__source, uint64_t *a2)
{
  strlcpy(dyld4::error_string, __source, 0x400uLL);
  qword_1EC3F2750 = (uint64_t)dyld4::error_string;
  dyld4::console((dyld4 *)"%s\n", v4, __source);
  int v12 = 1;
  uint64_t v14 = 0;
  uint64_t v13 = 0;
  if (a2)
  {
    uint64_t v6 = *a2;
    if (*a2 == 4 || v6 == 1) {
      LODWORD(v13) = 1;
    }
    uint64_t v8 = (const char *)a2[2];
    uint64_t v5 = 20;
    if (v8)
    {
      HIDWORD(v13) = 20;
      uint64_t v5 = strlcpy(v15, v8, 0x7ECuLL) + 21;
    }
    BOOL v9 = (const char *)a2[1];
    if (v9)
    {
      LODWORD(v14) = v5;
      uint64_t v5 = v5 + strlcpy((char *)&v12 + (int)v5, v9, 2048 - (int)v5) + 1;
    }
    uint64_t v10 = (const char *)a2[3];
    if (v10)
    {
      HIDWORD(v14) = v5;
      uint64_t v5 = v5 + strlcpy((char *)&v12 + (int)v5, v10, 2048 - (int)v5) + 1;
    }
  }
  else
  {
    uint64_t v5 = 20;
    uint64_t v6 = 9;
  }
  strlcpy(__dst, __source, 0x400uLL);
  abort_with_payload((void *)6, (void *)v6, &v12, (void *)v5, __dst, 0);
}

dyld4::PrebuiltLoader *dyld4::Loader::makeDiskLoader(vm_address_t *a1, dyld4::RuntimeState *this, char *__s2, uint64_t a4, int a5, unsigned int a6, uint64_t a7)
{
  if (*(unsigned char *)(a4 + 5)) {
    return 0;
  }
  uint64_t result = dyld4::RuntimeState::findPrebuiltLoader(this, __s2);
  if (!result)
  {
    if (a5)
    {
      uint64_t v15 = *((void *)this + 1);
      if (*(unsigned char *)(v15 + 157))
      {
        unsigned int v16 = 0;
        if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(v15 + 240), __s2, &v16)) {
          a6 = v16;
        }
      }
    }
    return (dyld4::PrebuiltLoader *)dyld4::JustInTimeLoader::makeJustInTimeLoaderDisk(a1, (uint64_t)this, (dyld3 *)__s2, a4, a5, a6, a7);
  }
  return result;
}

void ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(unsigned int *)(v9 + 48);
  unint64_t v11 = 8 * v10;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v29);
  int v12 = (const void **)((char *)&v29 - ((8 * v10 + 15) & 0xFFFFFFFF0));
  __chkstk_darwin(v13, v14, v15, v16, v17, v18, v19, v20, v29);
  unint64_t v22 = (uint64_t *)((char *)&v29 - v21);
  if (v10)
  {
    if (v11 >= 0x200) {
      size_t v23 = 512;
    }
    else {
      size_t v23 = 8 * v10;
    }
    bzero(v12, v23);
    unint64_t v24 = 0;
    do
    {
      uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*(void *)(v9 + 40) + v24), (const dyld4::RuntimeState *)v9);
      v12[v24 / 8] = Address;
      if ((*(unsigned char *)(*(void *)(*(void *)(v9 + 40) + v24) + 4) & 2) != 0) {
        uint64_t Slide = *(void *)(*(void *)(v9 + 8) + 264);
      }
      else {
        uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
      }
      v22[v24 / 8] = Slide;
      v24 += 8;
    }
    while (v11 != v24);
    do
    {
      uint64_t v27 = *v12;
      if (*(unsigned char *)(*(void *)(v9 + 8) + 205)) {
        dyld4::RuntimeState::log((dyld4::RuntimeState *)v9, "add notifier %p called with mh=%p\n", *(const void **)(a1 + 40), *v12);
      }
      uint64_t v28 = *v22++;
      (*(void (**)(const void *, uint64_t))(a1 + 40))(v27, v28);
      ++v12;
      --v10;
    }
    while (v10);
  }
}

BOOL dyld4::EqualForeignConformanceLookupKey::equal(void *a1, const char *a2, uint64_t a3, uint64_t a4, dyld4::RuntimeState *a5)
{
  if (!a5) {
    dyld4::EqualForeignConformanceLookupKey::equal();
  }
  uint64_t v10 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 1), a5);
  size_t v11 = a1[2];
  int v12 = _platform_strncmp(v10, a2, v11);
  return v11 == a3
      && v12 == 0
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 3), a5) == a4;
}

const char *dyld4::ProcessConfig::PathOverrides::typeName(unsigned int a1)
{
  if (a1 > 0xF) {
    return "unknown";
  }
  else {
    return (&off_1EFF640F0)[a1];
  }
}

uint64_t ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8);
  if (!*(void *)(v3 + 24)) {
    *(void *)(v3 + 24) = a3;
  }
  return result;
}

void dyld4::PrebuiltLoader::BindTargetRef::loaderRef()
{
  __assert_rtn("loaderRef", "PrebuiltLoader.cpp", 153, "_regular.kind == 0");
}

uint64_t ___ZN5dyld44APIs25NSVersionOfRunTimeLibraryEPKc_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    unint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    uint64_t v6 = v4;
    while (1)
    {
      uint64_t Address = (dyld3::MachOFile *)dyld4::Loader::loadAddress(*v6, v1);
      *(void *)uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t result = dyld3::MachOFile::getDylibInstallName(Address, (const char **)&v10, v9, &v9[1]);
      if (result)
      {
        uint64_t result = dyld4::nameMatch(v10, *(const char **)(v3 + 48), v8);
        if (result) {
          break;
        }
      }
      ++v6;
      ++v4;
      v5 -= 8;
      if (!v5) {
        return result;
      }
    }
    *(_DWORD *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = v9[1];
  }
  return result;
}

uint64_t ___ZN5dyld44APIs28_dyld_get_image_vmaddr_slideEj_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  unint64_t v2 = *(unsigned int *)(result + 48);
  if (*((void *)v1 + 6) > v2)
  {
    uint64_t v3 = result;
    uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((void *)v1 + 5) + 8 * v2), v1);
    uint64_t result = dyld3::MachOLoaded::getSlide(Address);
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_find_foreign_type_protocol_conformance(dyld4::APIs *this, char *a2, const char *a3, uint64_t a4)
{
  uint64_t v8 = *((void *)this + 1);
  if (*(unsigned char *)(v8 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_protocol_conformance(%p, %s)\n", a2, a3);
    uint64_t v8 = *((void *)this + 1);
  }
  uint64_t v9 = *(dyld4::objc_headeropt_rw_t **)(v8 + 296);
  uint64_t v10 = *(void *)(v8 + 344);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    return 2;
  }
  uint64_t v12 = *(void *)(v10 + 24);
  if (!v12) {
    return 2;
  }
  uint64_t v13 = *(void *)(v8 + 240);
  v21[0] = a3;
  v21[1] = a4;
  v21[2] = &a2[-v13];
  unsigned int Potential = SwiftHashTable::getPotentialTarget<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>((unsigned int *)(v13 + v12), (uint64_t)v21, v13);
  if (Potential == *(_DWORD *)(v13 + v12 + 16)) {
    return 2;
  }
  unsigned int v16 = Potential;
  unint64_t v17 = *(void *)(v13 + v12 + Potential + 16);
  char isLoaded = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v17));
  if (v17)
  {
    if ((isLoaded & 1) == 0)
    {
      for (uint64_t i = v12 + v16 + v13 + 40; (*(unsigned char *)(i - 24) & 1) != 0; i += 24)
      {
        char v20 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(i + 6));
        if (v20) {
          return 0;
        }
      }
      return 2;
    }
  }
  else if ((isLoaded & 1) == 0)
  {
    return 2;
  }
  return 0;
}

uint64_t SwiftHashTable::getPotentialTarget<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = SwiftHashTable::getIndex<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(a1, a2, a3);
  if (v4 == -1)
  {
    uint64_t v6 = a1 + 4;
  }
  else
  {
    uint64_t v5 = *a1;
    if (v5 <= v4) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    }
    uint64_t v6 = (unsigned int *)((char *)&a1[v4 + 264] + a1[5] + v5);
  }
  return *v6;
}

uint64_t SwiftHashTable::getIndex<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = SwiftHashTable::hash<SwiftForeignTypeProtocolConformanceLookupKey>((uint64_t)a1, a2);
  if (*a1 <= v6) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v7 = v6;
  int v8 = *((unsigned __int8 *)a1 + v6 + a1[5] + 1056);
  if (v8 != SwiftHashTable::checkbyte<SwiftForeignTypeProtocolConformanceLookupKey>((uint64_t)a1, a2)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *a1;
  if (v9 <= v7) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v10 = *(unsigned int *)((char *)&a1[v7 + 264] + a1[5] + v9);
  if (v10 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (SwiftHashTable::equal<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned int *)((char *)a1 + v10), a2, a3))
  {
    return v7;
  }
  return 0xFFFFFFFFLL;
}

uint64_t SwiftHashTable::checkbyte<SwiftForeignTypeProtocolConformanceLookupKey>(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 8) & 0x1F | (32 * (**(unsigned char **)a2 & 7u));
}

uint64_t SwiftHashTable::hash<SwiftForeignTypeProtocolConformanceLookupKey>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = objc::lookup8(*(objc **)a2, *(const unsigned __int8 **)(a2 + 8), *(void *)(a1 + 24));
  unint64_t v5 = objc::lookup8((objc *)(a2 + 16), (const unsigned __int8 *)8, *(void *)(a1 + 24));
  int v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (v5 ^ v4) >> v6;
  }
  return v7 ^ *(_DWORD *)(a1 + 4 * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  size_t v4 = HIWORD(*a2);
  return a2[1] == *(void *)(a3 + 16)
      && v4 == *(void *)(a3 + 8)
      && _platform_memcmp((const void *)(a4 + (*a2 & 0xFFFFFFFFFFFFLL)), *(const void **)a3, v4) == 0;
}

uint64_t dyld4::APIs::_dyld_find_protocol_conformance(dyld4::APIs *this, char *a2, char *a3, char *a4)
{
  uint64_t v8 = *((void *)this + 1);
  if (*(unsigned char *)(v8 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_protocol_conformance(%p, %p, %p)\n", a2, a3, a4);
    uint64_t v8 = *((void *)this + 1);
  }
  uint64_t v9 = *(dyld4::objc_headeropt_rw_t **)(v8 + 296);
  uint64_t v10 = *(void *)(v8 + 344);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    return 2;
  }
  if (!a4) {
    goto LABEL_12;
  }
  uint64_t v12 = *(void *)(v10 + 8);
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v13 = *(void *)(v8 + 240);
  uint64_t v29 = &a4[-v13];
  uint64_t v30 = &a2[-v13];
  unsigned int Potential = SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>((unsigned int *)(v13 + v12), (objc *)&v29);
  if (Potential == *(_DWORD *)(v13 + v12 + 16)) {
    goto LABEL_12;
  }
  unsigned int v15 = Potential;
  unint64_t v16 = *(void *)(v13 + v12 + Potential + 16);
  char isLoaded = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v16));
  if (v16)
  {
    if ((isLoaded & 1) == 0)
    {
      for (uint64_t i = v12 + v15 + v13 + 40; (*(unsigned char *)(i - 24) & 1) != 0; i += 24)
      {
        char v26 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(i + 6));
        if (v26) {
          return 0;
        }
      }
      goto LABEL_12;
    }
    return 0;
  }
  if (isLoaded) {
    return 0;
  }
LABEL_12:
  if (!a3) {
    return 2;
  }
  uint64_t v18 = *(void *)(v10 + 16);
  if (!v18) {
    return 2;
  }
  uint64_t v19 = *(void *)(*((void *)this + 1) + 240);
  uint64_t v29 = &a3[-v19];
  uint64_t v30 = &a2[-v19];
  unsigned int v20 = SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>((unsigned int *)(v19 + v18), (objc *)&v29);
  if (v20 == *(_DWORD *)(v19 + v18 + 16)) {
    return 2;
  }
  unsigned int v22 = v20;
  unint64_t v23 = *(void *)(v19 + v18 + v20 + 16);
  char v24 = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v23));
  if (v23)
  {
    if ((v24 & 1) == 0)
    {
      for (uint64_t j = v18 + v22 + v19 + 40; (*(unsigned char *)(j - 24) & 1) != 0; j += 24)
      {
        char v28 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(j + 6));
        if (v28) {
          return 0;
        }
      }
      return 2;
    }
  }
  else if ((v24 & 1) == 0)
  {
    return 2;
  }
  return 0;
}

uint64_t SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(unsigned int *a1, objc *a2)
{
  unsigned int v3 = SwiftHashTable::getIndex<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(a1, a2);
  if (v3 == -1)
  {
    unint64_t v5 = a1 + 4;
  }
  else
  {
    uint64_t v4 = *a1;
    if (v4 <= v3) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    }
    unint64_t v5 = (unsigned int *)((char *)&a1[v3 + 264] + a1[5] + v4);
  }
  return *v5;
}

uint64_t SwiftHashTable::getIndex<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(unsigned int *a1, objc *a2)
{
  unsigned int v4 = SwiftHashTable::hash<SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, a2);
  if (*a1 <= v4) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v5 = v4;
  int v6 = *((unsigned __int8 *)a1 + v4 + a1[5] + 1056);
  if (v6 != SwiftHashTable::checkbyte<SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned __int8 *)a2))return 0xFFFFFFFFLL; {
  uint64_t v7 = *a1;
  }
  if (v7 <= v5) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v8 = *(unsigned int *)((char *)&a1[v5 + 264] + a1[5] + v7);
  if (v8 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (SwiftHashTable::equal<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned int *)((char *)a1 + v8), a2))
  {
    return v5;
  }
  return 0xFFFFFFFFLL;
}

uint64_t SwiftHashTable::checkbyte<SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, unsigned __int8 *a2)
{
  return (32 * *a2) & 0xE0 | 0x10u;
}

BOOL SwiftHashTable::equal<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

uint64_t dyld4::objc_headeropt_rw_t::isLoaded(dyld4::objc_headeropt_rw_t *this, unsigned int a2)
{
  if (*(_DWORD *)this <= a2) {
    dyld4::objc_headeropt_rw_t::isLoaded();
  }
  return *(_DWORD *)((unsigned char *)this + *((_DWORD *)this + 1) * a2 + 8) & 1;
}

uint64_t dyld4::APIs::_dyld_is_objc_constant(dyld4::RuntimeState *a1, int a2, const void *a3)
{
  if (*(unsigned char *)(*((void *)a1 + 1) + 204)) {
    dyld4::RuntimeState::log(a1, "_dyld_is_objc_constant(%d, %p)\n", a2, a3);
  }
  return 0;
}

void (*dyld4::prepare(dyld4 *this, dyld4::APIs *a2, const dyld3::MachOAnalyzer *a3))(dyld4 *this, int a2, const char *const *a3, const char *const *a4, const char *const *a5)
{
  if (dyld3::kdebug_trace_dyld_enabled((dyld3 *)0x1F070004, a2)) {
    v226 = dyld3::kdebug_trace_dyld_duration_start((void *)0x1F070004, *(void *)(*((void *)this + 1) + 8), 0, 0, 0, 0, 0, v5);
  }
  else {
    v226 = 0;
  }
  uint64_t v6 = *((void *)this + 1);
  if (*(unsigned char *)(v6 + 208))
  {
    if (!*(unsigned char *)(v6 + 185))
    {
      dyld4::RuntimeState::log(this, "Note: DYLD_PRINT_* disabled by AMFI\n", v226);
      uint64_t v6 = *((void *)this + 1);
    }
    if (!*(unsigned char *)(v6 + 190))
    {
      dyld4::RuntimeState::log(this, "Note: interposing disabled by AMFI\n");
      uint64_t v6 = *((void *)this + 1);
    }
  }
  if (*(unsigned char *)(v6 + 209))
  {
    uint64_t v7 = *(const char ***)(v6 + 120);
    uint64_t v8 = *v7;
    if (*v7)
    {
      uint64_t v9 = v7 + 1;
      do
      {
        dyld4::RuntimeState::log(this, "%s\n", v8);
        uint64_t v10 = *v9++;
        uint64_t v8 = v10;
      }
      while (v10);
    }
  }
  dyld4::RuntimeState::initializeClosureMode(this);
  uint64_t v11 = *((void *)this + 124);
  if (v11)
  {
    if (!*(_DWORD *)(v11 + 12)) {
      __assert_rtn("atIndex", "PrebuiltLoader.h", 336, "loaderIndex < loadersArrayCount");
    }
    LaunchLoader = (const dyld4::Loader *)(v11 + *(unsigned int *)(v11 + *(unsigned int *)(v11 + 16)));
    lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve((uint64_t)this + 32, *((unsigned int *)this + 255));
  }
  else
  {
    if (*((void *)this + 7) <= 0x1FFuLL) {
      lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserveExact((uint64_t)this + 32, 0x200uLL);
    }
    Diagnostics::Diagnostics((Diagnostics *)&v233);
    LaunchLoader = (const dyld4::Loader *)dyld4::JustInTimeLoader::makeLaunchLoader((dyld4::JustInTimeLoader *)&v233, this, *(dyld4::RuntimeState **)(*((void *)this + 1) + 8), *(const dyld3::MachOAnalyzer **)(*((void *)this + 1) + 16), 0, v13);
    if (Diagnostics::hasError((Diagnostics *)&v233))
    {
      v225 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v233);
      dyld4::RuntimeState::log(this, "%s in %s\n", v225, *(const char **)(*((void *)this + 1) + 16));
      v220 = (vm_address_t **)&v233;
      goto LABEL_139;
    }
    mach_o::Error::~Error((vm_address_t **)&v233);
  }
  dyld4::RuntimeState::setMainLoader(this, LaunchLoader);
  dyld4::RuntimeState::notifyDebuggerLoad(this, LaunchLoader);
  if (*((_WORD *)LaunchLoader + 2))
  {
    BOOL v230 = 0;
  }
  else
  {
    if (*((unsigned char *)this + 1016)) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = *((unsigned char *)this + 1017) != 0;
    }
    BOOL v230 = v14;
  }
  uint64_t v259 = 0;
  v260 = &v259;
  uint64_t v261 = 0x5002000000;
  v262 = __Block_byref_object_copy__20;
  v263 = __Block_byref_object_dispose__21;
  v264[0] = &v270;
  v264[1] = 16;
  uint64_t v265 = 0;
  vm_size_t v267 = 0;
  vm_address_t v266 = 0;
  dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v264, 1);
  uint64_t v15 = v265++;
  *(void *)(v264[0] + 8 * v15) = LaunchLoader;
  v258[0] = 0;
  v258[1] = LaunchLoader;
  uint64_t v256 = 0;
  uint64_t v257 = 0;
  uint64_t v16 = *((void *)this + 1) + 400;
  v250[0] = _NSConcreteStackBlock;
  v250[1] = 0x40000000;
  v250[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke;
  v250[3] = &unk_1EFF63710;
  __int16 v251 = 257;
  int v252 = 0;
  __int16 v253 = 257;
  uint64_t v254 = 0;
  v255 = v258;
  v250[4] = &v259;
  v250[5] = this;
  dyld4::ProcessConfig::PathOverrides::forEachInsertedDylib(v16, (uint64_t)v250);
  if (v260[7] != 1)
  {
    unint64_t v17 = *((void *)this + 6);
    if (v17 != 1)
    {
      uint64_t v18 = *((void *)this + 5);
      uint64_t v19 = (void *)(v18 + 8);
      uint64_t v20 = 8 * v17 - 8;
      do
      {
        *(v19 - 1) = *v19;
        *v19++ = 0;
        v18 += 8;
        v20 -= 8;
      }
      while (v20);
    }
    *((void *)this + 6) = v17 - 1;
    *(void *)&v233.fsobj_id st_dev = LaunchLoader;
    lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve((uint64_t)this + 32, v17);
    uint64_t v21 = *((void *)this + 5);
    uint64_t v22 = *((void *)this + 6);
    *((void *)this + 6) = v22 + 1;
    *(void *)(v21 + 8 * v22) = *(void *)&v233.st_dev;
  }
  uint64_t v244 = 0;
  v245 = &v244;
  uint64_t v246 = 0x4002000000;
  v247 = __Block_byref_object_copy__26;
  v248 = __Block_byref_object_dispose__27;
  memset(v249, 0, sizeof(v249));
  v243[0] = _NSConcreteStackBlock;
  v243[1] = 0x40000000;
  v243[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_28;
  v243[3] = &unk_1EFF63738;
  v243[4] = &v244;
  Diagnostics::Diagnostics((Diagnostics *)&v242);
  DWORD2(v238) = 0;
  uint64_t v240 = 0;
  v241 = 0;
  *(void *)&long long v238 = 0x100000000000101;
  v239 = v258;
  if (v230) {
    v241 = v243;
  }
  uint64_t v31 = v260[7];
  if (v31)
  {
    size_t v32 = (uint64_t *)v260[5];
    uint64_t v33 = 8 * v31;
    while (1)
    {
      dyld4::Loader::loadDependents(*v32, (vm_address_t *)&v242, this, &v238);
      BOOL hasError = Diagnostics::hasError((Diagnostics *)&v242);
      if (hasError) {
        break;
      }
      ++v32;
      v33 -= 8;
      if (!v33)
      {
        uint64_t v229 = v260[7];
        goto LABEL_39;
      }
    }
    uint64_t v204 = v260[7];
    uint64_t v205 = *((void *)this + 6);
    uint64_t v206 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)hasError);
    __chkstk_darwin(v206, v206 - v204 + 8 * v205 + 64, v207, v208, v209, v210, v211, v212, (uint64_t)v226);
    v214 = (lsl::Allocator *)((char *)&v226 - v213);
    bzero((char *)&v226 - v213, v215);
    uint64_t v216 = *((void *)this + 6);
    uint64_t v218 = lsl::AllocatorLayout::minSize(v217);
    *(void *)&v233.fsobj_id st_dev = lsl::Allocator::stackAllocatorInternal(v214, (char *)(v218 - v204 + 8 * v216 + 64));
    memset(&v233.st_ino, 0, 24);
    lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v233, *((void *)this + 6) - v204);
    if (v204 == *((void *)this + 6))
    {
      unint64_t v219 = *(void *)&v233.st_uid;
    }
    else
    {
      unint64_t v219 = *(void *)&v233.st_uid;
      do
      {
        uint64_t v221 = *(void *)(*((void *)this + 5) + 8 * v204);
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v233, v219 + 1);
        uint64_t v222 = *(void *)&v233.st_uid;
        unint64_t v219 = ++*(void *)&v233.st_uid;
        *(void *)(v233.st_ino + 8 * v222) = v221;
        ++v204;
      }
      while (v204 != *((void *)this + 6));
    }
    __darwin_ino64_t st_ino = v233.st_ino;
    unint64_t v236 = v219;
    dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)&st_ino);
    dyld4::ExternallyViewableState::disableCrashReportBacktrace((uint64_t)this + 536);
    v220 = &v242;
LABEL_139:
    v223 = (char *)Diagnostics::errorMessage((Diagnostics *)v220);
    dyld4::halt(v223, (uint64_t *)this + 78);
  }
  uint64_t v229 = 0;
LABEL_39:
  __chkstk_darwin(hasError, v24, v25, v26, v27, v28, v29, v30, (uint64_t)v226);
  uint64_t v42 = (char *)&v226 - ((v41 + 23) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v43 = *((void *)this + 6);
  __darwin_ino64_t st_ino = (__darwin_ino64_t)v42;
  unint64_t v236 = v43;
  unint64_t v237 = 0;
  if (v43)
  {
    unint64_t v44 = 0;
    int v45 = (uint64_t *)*((void *)this + 5);
    uint64_t v46 = 8 * v43;
    uint64_t v47 = v45;
    do
    {
      uint64_t v48 = *v47;
      if ((*(_WORD *)(*v47 + 4) & 2) == 0)
      {
        if (v44 >= v43) {
LABEL_131:
        }
          __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
        unint64_t v237 = v44 + 1;
        *(void *)(st_ino + 8 * v44++) = v48;
      }
      ++v47;
      ++v45;
      v46 -= 8;
    }
    while (v46);
  }
  uint64_t v228 = v40;
  dyld4::RuntimeState::addPermanentRanges((uint64_t)this, (uint64_t)&st_ino, v34, v35, v36, v37, v38, v39);
  if (*(unsigned char *)(*((void *)this + 1) + 161))
  {
    uint64_t v49 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x60uLL);
    uint64_t v50 = (lsl::AllocatorLayout *)dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)v49);
    *((void *)this + 42) = v50;
    uint64_t v51 = *((void *)this + 6);
    uint64_t v52 = lsl::AllocatorLayout::minSize(v50);
    __chkstk_darwin(v52, v52 + 8 * v51 + 64, v53, v54, v55, v56, v57, v58, (uint64_t)v226);
    v60 = (lsl::Allocator *)((char *)&v226 - v59);
    bzero((char *)&v226 - v59, v61);
    uint64_t v62 = *((void *)this + 6);
    uint64_t v64 = lsl::AllocatorLayout::minSize(v63);
    int v65 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v60, (char *)(v64 + 8 * v62 + 64));
    *(void *)&v233.fsobj_id st_dev = v65;
    memset(&v233.st_ino, 0, 24);
    lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v233, *((void *)this + 6));
    uint64_t v66 = *((void *)this + 6);
    uint64_t v67 = *(void *)&v233.st_uid;
    if (v66)
    {
      v68 = (uint64_t *)*((void *)this + 5);
      uint64_t v69 = 8 * v66;
      v70 = v68;
      do
      {
        uint64_t v71 = *v70++;
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v233, v67 + 1);
        uint64_t v72 = *(void *)&v233.st_uid;
        uint64_t v67 = ++*(void *)&v233.st_uid;
        *(void *)(v233.st_ino + 8 * v72) = v71;
        ++v68;
        v69 -= 8;
      }
      while (v69);
    }
    __darwin_ino64_t v268 = v233.st_ino;
    uint64_t v269 = v67;
    dyld4::Loader::addWeakDefsToMap(this, (uint64_t)&v268);
    if (v233.st_ino) {
      lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v233, 0);
    }
    lsl::Allocator::~Allocator(v65);
  }
  dyld4::RuntimeState::buildInterposingTables(this);
  v233.fsobj_id st_dev = 520552460;
  memset(&v233.st_ino, 0, 104);
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v233, v73, v74, v75, v76, v77, v78, v79);
  dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)&v268, (uint64_t)this);
  dyld4::JustInTimeLoader::handleStrongWeakDefOverrides((uint64_t)this, (dyld4::RuntimeState *)&v268, v80);
  uint64_t v81 = *((void *)this + 6);
  if (v81)
  {
    long long v82 = (dyld4::Loader **)*((void *)this + 5);
    uint64_t v83 = 8 * v81;
    v84 = v82;
    while (1)
    {
      v85 = *v84;
      Diagnostics::Diagnostics((Diagnostics *)v231);
      dyld4::Loader::applyFixups((uint64_t)v85, (uint64_t)v231, (uint64_t)this, (uint64_t)&v268, 1, 0, v86, v87);
      if (Diagnostics::hasError((Diagnostics *)v231)) {
        break;
      }
      dyld4::Loader::applyCachePatches(v85, this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v268);
      mach_o::Error::~Error(v231);
      ++v84;
      ++v82;
      v83 -= 8;
      if (!v83) {
        goto LABEL_56;
      }
    }
    v220 = v231;
    goto LABEL_139;
  }
LABEL_56:
  dyld4::RuntimeState::doSingletonPatching(this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v268);
  dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)&v268);
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v233);
  if (*((void *)this + 22)) {
    dyld4::Loader::applyInterposingToDyldCache(this, v88);
  }
  if (*((_WORD *)LaunchLoader + 2))
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)&v233, (uint64_t)this);
    uint64_t v95 = *((void *)this + 124);
    v234[0] = _NSConcreteStackBlock;
    v234[1] = 0x40000000;
    v234[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_2;
    v234[3] = &__block_descriptor_tmp_35;
    v234[4] = this;
    v234[5] = &v233;
    dyld4::PrebuiltLoaderSet::forEachCachePatch(v95, (uint64_t)v234);
    dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)&v233);
  }
  if (kdebug_is_enabled(0x1F050000u, (uint64_t)v88, v89, v90, v91, v92, v93, v94)
    && (dyld3::MachOFile::inDyldCache(a2) & 1) == 0)
  {
    uint64_t v269 = 0;
    __darwin_ino64_t v268 = 0;
    dyld3::MachOFile::getUuid(a2, (unsigned __int8 *)&v268);
    int v97 = dyld3::stat(*(dyld3 **)(*((void *)this + 1) + 72), &v233, v96);
    if (v97) {
      v99 = 0;
    }
    else {
      v99 = (unsigned __int8 (*)[16])v233.st_ino;
    }
    if (v97) {
      fsobj_id st_dev = 0;
    }
    else {
      fsobj_id st_dev = (fsobj_id)v233.st_dev;
    }
    fsid v101 = (fsid)a2;
    dyld3::kdebug_trace_dyld_image(0, *(void **)(*((void *)this + 1) + 72), (void **)&v268, v99, st_dev, v101, (const void *)*((unsigned int *)a2 + 2), v98, v226);
  }
  v102 = (dyld4::Loader *)*((void *)this + 13);
  if (!v102)
  {
    v224 = "libdyld.dylib not found";
    goto LABEL_143;
  }
  uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(v102, this);
  unint64_t v232 = 0;
  uint64_t SectionContent = dyld3::MachOLoaded::findSectionContent(Address, "__TPRO_CONST", "__dyld4", &v232);
  if (!SectionContent)
  {
    v224 = "compatible libdyld.dylib not found";
    goto LABEL_143;
  }
  uint64_t v105 = SectionContent;
  *(void *)uint64_t SectionContent = this;
  uint64_t v106 = dyld4::ExternallyViewableState::storeProcessInfoPointer((uint64_t)this + 536, (dyld_all_image_infos **)(SectionContent + 8));
  uint64_t v114 = *((void *)this + 1);
  *(void *)(v105 + 16) = *(void *)(v114 + 8);
  v105 += 16;
  *((void *)this + 18) = v105;
  **(void **)(v105 + 32) = *(void *)(v114 + 136);
  uint64_t v115 = *((void *)this + 1);
  uint64_t v116 = *((void *)this + 18);
  **(_DWORD **)(v116 + 8) = *(_DWORD *)(v115 + 104);
  **(void **)(v116 + 16) = *(void *)(v115 + 112);
  **(void **)(*((void *)this + 18) + 24) = *(void *)(*((void *)this + 1) + 120);
  if (!*((void *)this + 12))
  {
    v224 = "program does not link with libSystem.B.dylib";
    goto LABEL_143;
  }
  __chkstk_darwin(v106, v107, v108, v109, v110, v111, v112, v113, (uint64_t)v226);
  v119 = (dyld4::Loader **)((char *)&v226 - ((v118 + 23) & 0xFFFFFFFFFFFFFFF0));
  if (!v117) {
    __assert_rtn("operator[]", "Array.h", 56, "idx < _usedCount");
  }
  uint64_t v120 = 0;
  uint64_t v121 = *((void *)this + 5);
  uint64_t v122 = v121;
  do
  {
    if (v117 == v120) {
      goto LABEL_131;
    }
    uint64_t v123 = v120 + 1;
    v119[v120] = *(dyld4::Loader **)(v121 + 8 * v120);
    v122 += 8;
    ++v120;
    v118 -= 8;
  }
  while (v118);
  v227 = (vm_address_t *)v249;
  if (v229 == -1) {
    uint64_t v124 = v123;
  }
  else {
    uint64_t v124 = v229;
  }
  dyld4::RuntimeState::partitionDelayLoads(this, v119, v123, v119, v124, 0);
  if (*(void *)(*((void *)this + 1) + 232)) {
    BOOL v132 = v124 == 0;
  }
  else {
    BOOL v132 = 1;
  }
  if (!v132)
  {
    uint64_t v133 = 8 * v124;
    do
    {
      v135 = *v119++;
      v134 = v135;
      v136 = (dyld3::MachOFile *)dyld4::Loader::mf(v135, this);
      if (dyld3::MachOFile::isMainExecutable(v136)) {
        v137 = "main";
      }
      else {
        v137 = "insert";
      }
      dyld4::Loader::logChainToLinksWith(v134, this, v137);
      v133 -= 8;
    }
    while (v133);
  }
  uint64_t is_enabled = kdebug_is_enabled(0x1F050000u, v125, v126, v127, v128, v129, v130, v131);
  if (is_enabled)
  {
    uint64_t v146 = *((void *)this + 6);
    if (v146)
    {
      v147 = (dyld4::Loader **)*((void *)this + 5);
      uint64_t v148 = 8 * v146;
      v149 = v147;
      do
      {
        v150 = *v149;
        fsid v151 = (fsid)dyld4::Loader::loadAddress(*v149, this);
        if ((*((_WORD *)v150 + 2) & 2) != 0
          || (v152 = (dyld3 *)dyld4::Loader::path(v150, this), dyld3::stat(v152, &v233, v153)))
        {
          fsobj_id v154 = 0;
          v155 = 0;
        }
        else
        {
          v155 = (unsigned __int8 (*)[16])v233.st_ino;
          fsobj_id v154 = (fsobj_id)v233.st_dev;
        }
        v156 = (void *)dyld4::Loader::path(v150, this);
        fsobj_id v157 = v154;
        fsid v158 = v151;
        uint64_t is_enabled = dyld3::kdebug_trace_dyld_image(0, v156, (void **)v150 + 1, v155, v157, v158, (const void *)*((unsigned int *)v150 + 6), v159, v226);
        ++v149;
        ++v147;
        v148 -= 8;
      }
      while (v148);
    }
  }
  if (v230)
  {
    v233.fsobj_id st_dev = 520552468;
    memset(&v233.st_ino, 0, 104);
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v233, v139, v140, v141, v142, v143, v144, v145);
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "building PrebuiltLoaderSet for main executable\n");
    }
    Diagnostics::Diagnostics((Diagnostics *)&v268);
    vm_address_t LaunchSet = dyld4::PrebuiltLoaderSet::makeLaunchSet(&v268, this, (dyld4::RuntimeState *)(v245 + 5), v160);
    if (LaunchSet && (v162 = (const dyld4::PrebuiltLoaderSet *)LaunchSet, Diagnostics::noError((Diagnostics *)&v268)))
    {
      if (*((unsigned char *)this + 1017))
      {
        v224 = "dyld: PrebuiltLoaderSet expected but not found";
        goto LABEL_143;
      }
      if (dyld4::RuntimeState::saveAppPrebuiltLoaderSet(this, v162)) {
        *((unsigned char *)this + 1136) = 1;
      }
      dyld4::PrebuiltLoaderSet::deallocate((vm_address_t)v162);
      *(_OWORD *)&v233.st_mtimespec.tv_nsec = xmmword_1A8E6FD00;
    }
    else if (*(unsigned char *)(*((void *)this + 1) + 207))
    {
      v163 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v268);
      dyld4::RuntimeState::log(this, "could not build PrebuiltLoaderSet: %s\n", v163);
    }
    mach_o::Error::~Error((vm_address_t **)&v268);
    uint64_t is_enabled = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v233);
  }
  v164 = dyld4::fake_main;
  if (*(unsigned char *)(*((void *)this + 1) + 194)) {
    goto LABEL_124;
  }
  uint64_t v165 = *((void *)this + 6);
  uint64_t v166 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)is_enabled);
  __chkstk_darwin(v166, v166 + 8 * v165 + 64, v167, v168, v169, v170, v171, v172, (uint64_t)v226);
  v174 = (lsl::Allocator *)((char *)&v226 - v173);
  bzero((char *)&v226 - v173, v175);
  uint64_t v176 = *((void *)this + 6);
  uint64_t v178 = lsl::AllocatorLayout::minSize(v177);
  v179 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v174, (char *)(v178 + 8 * v176 + 64));
  *(void *)&v233.fsobj_id st_dev = v179;
  memset(&v233.st_ino, 0, 24);
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v233, *((void *)this + 6));
  uint64_t v180 = *((void *)this + 6);
  uint64_t v181 = *(void *)&v233.st_uid;
  if (v180)
  {
    v182 = (uint64_t *)*((void *)this + 5);
    uint64_t v183 = 8 * v180;
    v184 = v182;
    do
    {
      uint64_t v185 = *v184++;
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v233, v181 + 1);
      uint64_t v186 = *(void *)&v233.st_uid;
      uint64_t v181 = ++*(void *)&v233.st_uid;
      *(void *)(v233.st_ino + 8 * v186) = v185;
      ++v182;
      v183 -= 8;
    }
    while (v183);
  }
  __darwin_ino64_t v268 = v233.st_ino + 8 * v229;
  uint64_t v269 = v181 - v229;
  dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)&v268);
  v231[0] = (vm_address_t *)v233.st_ino;
  v231[1] = *(vm_address_t **)&v233.st_uid;
  dyld4::RuntimeState::notifyDtrace((uint64_t)this, (uint64_t)v231);
  if (v233.st_ino) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v233, 0);
  }
  lsl::Allocator::~Allocator(v179);
  if (dyld4::ExternallyViewableState::notifyMonitorNeeded((dyld4 *)((char *)this + 536))) {
    dyld4::ExternallyViewableState::notifyMonitorOfDyldBeforeInitializers((dyld4 *)((char *)this + 536), v187, v188, v189, v190, v191, v192, v193);
  }
  (*(void (**)(dyld4 *))(*(void *)this + 856))(this);
  if (dyld4::ExternallyViewableState::notifyMonitorNeeded((dyld4 *)((char *)this + 536))) {
    dyld4::ExternallyViewableState::notifyMonitorOfMainCalled((dyld4 *)((char *)this + 536), v194, v195, v196, v197, v198, v199, v200);
  }
  if (dyld3::kdebug_trace_dyld_enabled((dyld3 *)0x1F070004, v194)) {
    dyld3::kdebug_trace_dyld_duration_end((int64_t)v226, (void *)0x1F070004, 0, 0, 0, 0, (void *)4, 0);
  }
  uint64_t v201 = *((void *)this + 1);
  v164 = dyld4::fake_main;
  if (*(unsigned char *)(v201 + 193)) {
    goto LABEL_124;
  }
  if (*(_DWORD *)(v201 + 68) == 10)
  {
    v164 = (void (*)(dyld4 *, int, const char *const *, const char *const *, const char *const *))*((void *)this + 129);
    if (v164)
    {
LABEL_124:
      v202 = v164;
      goto LABEL_125;
    }
    v224 = "DriverKit main entry point not set";
LABEL_143:
    dyld4::halt(v224, 0);
  }
  *(void *)&v233.fsobj_id st_dev = 0;
  LOBYTE(v268) = 0;
  if (!dyld3::MachOFile::getEntry(*(dyld3::MachOFile **)(v201 + 8), (unint64_t *)&v233, (BOOL *)&v268))
  {
    v224 = "main executable has no entry point";
    goto LABEL_143;
  }
  if ((_BYTE)v268)
  {
    v224 = "main executable is missing LC_MAIN";
    goto LABEL_143;
  }
  v202 = (void (*)(dyld4 *, int, const char *const *, const char *const *, const char *const *))(*(void *)&v233.st_dev + *(void *)(*((void *)this + 1) + 8));
LABEL_125:
  mach_o::Error::~Error(&v242);
  _Block_object_dispose(&v244, 8);
  dyld4::BumpAllocator::~BumpAllocator(v227);
  _Block_object_dispose(&v259, 8);
  uint64_t v265 = 0;
  if (v266) {
    vm_deallocate(mach_task_self_, v266, v267);
  }
  return v202;
}

void mach_o::Error::~Error(vm_address_t **this)
{
  unint64_t v2 = *this;
  if (v2) {
    _simple_sfree(v2);
  }
  *this = 0;
}

void Diagnostics::Diagnostics(Diagnostics *this)
{
  *(void *)this = 0;
}

void dyld4::Loader::applyFixups(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::applyFixups();
  }
  if (*(_WORD *)(a1 + 4))
  {
    dyld4::PrebuiltLoader::applyFixups(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    dyld4::JustInTimeLoader::applyFixups(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void dyld4::Loader::applyCachePatches(dyld4::Loader *this, dyld4::RuntimeState *a2, dyld4::DyldCacheDataConstLazyScopedWriter *a3)
{
  unsigned __int16 v18 = 0;
  uint64_t v17 = 0;
  if (dyld4::Loader::overridesDylibInCache((uint64_t)this, &v17, &v18) && v17)
  {
    uint64_t v6 = *(dyld3::MachOFile **)(*((void *)a2 + 1) + 240);
    uint64_t v13 = 0;
    BOOL v14 = &v13;
    uint64_t v15 = 0x2000000000;
    char v16 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000;
    uint64_t v12 = v17;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
    v7[3] = &unk_1EFF64A28;
    void v7[6] = this;
    v7[7] = a2;
    unsigned __int16 v8 = v18;
    v7[8] = v6;
    v7[9] = a3;
    v7[4] = &v9;
    v7[5] = &v13;
    DyldSharedCache::forEachPatchableExport(v6, v18, (uint64_t)v7);
    if (*(void *)v10[3] != -1) {
      dyld4::Loader::applyCachePatches();
    }
    if (*((unsigned char *)v14 + 24)) {
      dyld4::RuntimeState::setVMAccountingSuspending(a2, 0);
    }
    _Block_object_dispose(&v9, 8);
    _Block_object_dispose(&v13, 8);
  }
}

uint64_t dyld4::Loader::overridesDylibInCache(uint64_t a1, void *a2, _WORD *a3)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::overridesDylibInCache();
  }
  if (*(_WORD *)(a1 + 4))
  {
    return dyld4::PrebuiltLoader::overridesDylibInCache(a1, a2, a3);
  }
  else
  {
    return dyld4::JustInTimeLoader::overridesDylibInCache(a1, a2, a3);
  }
}

uint64_t dyld4::PrebuiltLoader::overridesDylibInCache(uint64_t a1, void *a2, _WORD *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a1 + 44);
  if ((v3 & 8) != 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 88);
    if (v4) {
      uint64_t v5 = a1 + v4;
    }
    else {
      uint64_t v5 = 0;
    }
    *a2 = v5;
    *a3 = *(_WORD *)(a1 + 60);
  }
  return (v3 >> 3) & 1;
}

void dyld4::PrebuiltLoader::applyFixups(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v60);
  uint64_t v10 = (uint64_t *)v8;
  uint64_t v12 = v11;
  uint64_t v14 = v13;
  if ((*(_WORD *)(v13 + 4) & 2) != 0)
  {
    if (*(unsigned __int8 *)(v8 + 1134) | *(unsigned __int8 *)(v8 + 1135) && (uint64_t v16 = *(void *)(v8 + 48)) != 0)
    {
      uint64_t v17 = v9;
      unsigned __int16 v18 = *(dyld4::Loader ***)(v8 + 40);
      uint64_t v19 = 8 * v16;
      uint64_t v20 = v18;
      do
      {
        uint64_t v21 = *v20++;
        dyld4::Loader::applyCachePatchesTo(v21, (dyld4::RuntimeState *)v10, (const dyld4::Loader *)v14, v17);
        ++v18;
        v19 -= 8;
      }
      while (v19);
      int v15 = (*(unsigned __int16 *)(v14 + 4) >> 1) & 1;
    }
    else
    {
      int v15 = 1;
    }
  }
  else
  {
    int v15 = 0;
  }
  int v22 = *(__int16 *)(v14 + 6);
  unint64_t v23 = v10 + 125;
  if (v22 >= 0) {
    unint64_t v23 = v10 + 122;
  }
  uint64_t v24 = *v23;
  if (!v15 || v22 < 0)
  {
    uint64_t v46 = *(_WORD *)(v14 + 6) & 0x7FFF;
    uint64_t v47 = v24;
    uint64_t v48 = v12;
    v54[0] = &v59;
    v54[1] = 512;
    vm_address_t v56 = 0;
    vm_size_t v57 = 0;
    uint64_t v55 = 0;
    uint64_t v25 = *(unsigned int *)(v14 + 52);
    if (v25)
    {
      uint64_t v26 = (dyld4::PrebuiltLoader::BindTargetRef *)(v14 + *(unsigned __int16 *)(v14 + 50));
      uint64_t v27 = 8 * v25;
      do
      {
        unint64_t v28 = dyld4::PrebuiltLoader::BindTargetRef::value(v26, (dyld4::RuntimeState *)v10);
        if (*(unsigned char *)(v10[1] + 202))
        {
          uint64_t v29 = *(void *)v26;
          dyld4::Loader::leafName((dyld4::Loader *)v14, (const dyld4::RuntimeState *)v10);
          if (v29 < 0)
          {
            dyld4::RuntimeState::log((dyld4::RuntimeState *)v10, "<%s/bind#%llu> -> %p\n");
          }
          else
          {
            if ((*(void *)v26 & 0x8000000000000000) != 0) {
              dyld4::PrebuiltLoader::BindTargetRef::loaderRef();
            }
            v58[0] = *(void *)v26;
            uint64_t v30 = (dyld4::Loader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)v58, (const dyld4::RuntimeState *)v10);
            dyld4::Loader::leafName(v30, (const dyld4::RuntimeState *)v10);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)v10, "<%s/bind#%llu> -> %p (%s+0x%08llX)\n");
          }
        }
        dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v54, 1);
        uint64_t v31 = v55++;
        *(void *)(v54[0] + 8 * v31) = v28;
        uint64_t v26 = (dyld4::PrebuiltLoader::BindTargetRef *)((char *)v26 + 8);
        v27 -= 8;
      }
      while (v27);
    }
    if (!Diagnostics::hasError((Diagnostics *)v48))
    {
      v50[0] = v58;
      v50[1] = 32;
      vm_address_t address = 0;
      vm_size_t size = 0;
      uint64_t v51 = 0;
      uint64_t v32 = *(unsigned int *)(v14 + 96);
      if (v32)
      {
        uint64_t v33 = (dyld4::PrebuiltLoader::BindTargetRef *)(v14 + *(unsigned int *)(v14 + 92));
        uint64_t v34 = 8 * v32;
        do
        {
          if ((*(void *)v33 & 0x800000000000FFFFLL) == 0x7FFF)
          {
            if (*(unsigned char *)(v10[1] + 202))
            {
              uint64_t v35 = dyld4::Loader::leafName((dyld4::Loader *)v14, (const dyld4::RuntimeState *)v10);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)v10, "<%s/bind#%llu> -> missing-weak-bind\n", v35, v51);
            }
            dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v50, 1);
            uint64_t v36 = v51++;
            *(void *)(v50[0] + 8 * v36) = -1;
          }
          else
          {
            unint64_t v37 = dyld4::PrebuiltLoader::BindTargetRef::value(v33, (dyld4::RuntimeState *)v10);
            if (*(unsigned char *)(v10[1] + 202))
            {
              uint64_t v38 = *(void *)v33;
              dyld4::Loader::leafName((dyld4::Loader *)v14, (const dyld4::RuntimeState *)v10);
              if (v38 < 0)
              {
                dyld4::RuntimeState::log((dyld4::RuntimeState *)v10, "<%s/bind#%llu> -> %p\n");
              }
              else
              {
                if ((*(void *)v33 & 0x8000000000000000) != 0) {
                  dyld4::PrebuiltLoader::BindTargetRef::loaderRef();
                }
                LOWORD(v49[0]) = *(void *)v33;
                uint64_t v39 = (dyld4::Loader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)v49, (const dyld4::RuntimeState *)v10);
                dyld4::Loader::leafName(v39, (const dyld4::RuntimeState *)v10);
                dyld4::RuntimeState::log((dyld4::RuntimeState *)v10, "<%s/bind#%llu> -> %p (%s+0x%08llX)\n");
              }
            }
            dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v50, 1);
            uint64_t v40 = v51++;
            *(void *)(v50[0] + 8 * v40) = v37;
          }
          uint64_t v33 = (dyld4::PrebuiltLoader::BindTargetRef *)((char *)v33 + 8);
          v34 -= 8;
        }
        while (v34);
      }
      if (!Diagnostics::hasError((Diagnostics *)v48))
      {
        if (!v14
          || !*(_WORD *)(v14 + 42)
          || (uint64_t v41 = v14 + *(unsigned __int16 *)(v14 + 42), !*(unsigned char *)(v41 + 52))
          || (uint64_t v42 = *(void *)v41, *(void *)v41 == -1))
        {
          unint64_t v43 = (dyld4::RuntimeState *)dyld4::Loader::analyzer((dyld4::Loader *)v14, (dyld4::RuntimeState *)v10);
          if (*(_WORD *)(v14 + 32)) {
            int v45 = (const dyld3::MachOAnalyzer *)(v14 + *(unsigned __int16 *)(v14 + 32));
          }
          else {
            int v45 = 0;
          }
          uint64_t v42 = dyld4::Loader::getOnDiskBinarySliceOffset((dyld4::Loader *)v10, v43, v45, v44);
        }
        memset(v49, 0, sizeof(v49));
        dyld4::Loader::applyFixupsGeneric((dyld4::Loader *)v14, v48, (dyld4::RuntimeState *)v10, v42, (uint64_t)v54, (uint64_t)v50, 1, (uint64_t)v49);
        dyld4::PrebuiltLoader::applyObjCFixups((dyld4::PrebuiltLoader *)v14, (dyld4::RuntimeState *)v10);
        if (dyld4::Loader::hasConstantSegmentsToProtect((dyld4::Loader *)v14)) {
          dyld4::Loader::makeSegmentsReadOnly((dyld4::Loader *)v14, (dyld4::RuntimeState *)v10);
        }
        *(unsigned char *)(v47 + v46) = 6;
      }
      uint64_t v51 = 0;
      if (address) {
        vm_deallocate(mach_task_self_, address, size);
      }
    }
    uint64_t v55 = 0;
    if (v56) {
      vm_deallocate(mach_task_self_, v56, v57);
    }
  }
  else
  {
    *(unsigned char *)(v24 + (*(_WORD *)(v14 + 6) & 0x7FFF)) = 6;
  }
}

void *dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 8 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    uint64_t result = memmove((void *)v4[3], *v4, 8 * (void)v4[2]);
    uint64_t v9 = (const void *)((unint64_t)v4[4] >> 3);
    *uint64_t v4 = v4[3];
    v4[1] = v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

uint64_t lsl::Vector<dyld4::Loader const*>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<dyld4::Loader const*>::reserveExact(result, v2);
  }
  return result;
}

uint64_t dyld3::kdebug_trace_dyld_image(dyld3 *this, void *a2, void **a3, unsigned __int8 (*a4)[16], fsobj_id a5, fsid a6, const void *a7, uint64_t a8, const void *a9)
{
  int v12 = (int)a7;
  fsobj_id v13 = a5;
  return dyld3::kdebug_trace_dyld_region(this, 16777228, v12, a2, a3, a4, v13, a6, a9);
}

void *dyld3::kdebug_trace_dyld_duration_start(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v11 = a4;
  fsobj_id v13 = (void *)a2;
  if (!kdebug_is_enabled(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  unint64_t add = atomic_fetch_add(&dyld3::trace_pair_id, 1uLL);
  if (a3)
  {
    int64_t v21 = kdebug_trace_string(a1, 0, a3, v15, v16, v17, v18, v19);
    if (v21 == -1) {
      fsobj_id v13 = 0;
    }
    else {
      fsobj_id v13 = (void *)v21;
    }
  }
  int v22 = (void *)(add + 1);
  if (a5)
  {
    int64_t v23 = kdebug_trace_string(a1, 0, a5, v15, v16, v17, v18, v19);
    if (v23 == -1) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (void *)v23;
    }
  }
  if (a7)
  {
    int64_t v24 = kdebug_trace_string(a1, 0, a7, v15, v16, v17, v18, v19);
    if (v24 == -1) {
      unint64_t v28 = 0;
    }
    else {
      unint64_t v28 = (void *)v24;
    }
    kdebug_trace((void *)(a1 | 1), v22, v13, v11, v28, v25, v26, v27);
    if (v28) {
      kdebug_trace_string(a1, v28, 0, v29, v30, v31, v32, v33);
    }
    if (!a5) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }
  kdebug_trace((void *)(a1 | 1), v22, v13, v11, a6, v17, v18, v19);
  if (a5)
  {
LABEL_20:
    if (v11) {
      kdebug_trace_string(a1, v11, 0, v29, v30, v31, v32, v33);
    }
  }
LABEL_22:
  if (a3 && v13) {
    kdebug_trace_string(a1, v13, 0, v29, v30, v31, v32, v33);
  }
  return v22;
}

uint64_t dyld3::kdebug_trace_dyld_region(dyld3 *this, uint64_t a2, int a3, void *a4, void **a5, unsigned __int8 (*a6)[16], fsobj_id a7, fsid a8, const void *a9)
{
  __int16 v15 = 4 * (_WORD)this;
  uint64_t v16 = (void *)((4 * ((unsigned __int16)this & 0x3FFF)) | 0x1F050000u);
  uint64_t v17 = (void *)kdebug_trace_string(v16, 0, a4, a4, a5, a6, *(void **)&a7, *(void **)&a8);
  kdebug_trace(v16, *a5, a5[1], *(void **)&a8, (void *)((int)a7.fid_objno | *(void *)&a7 & 0xFFFFFFFF00000000), v18, v19, v20);
  kdebug_trace((void *)((v15 + 4) & 0xFFFC | 0x1F050000u), a6, v17, (void *)(a3 | (unint64_t)(a2 << 32)), 0, v21, v22, v23);

  return kdebug_trace_string(v16, v17, 0, v24, v25, v26, v27, v28);
}

uint64_t __kdebug_trace64(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_kdebug_trace64, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int64_t kdebug_trace_string(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!kdebug_is_enabled(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  if (a2 != (void *)-1 && (a2 || a3))
  {
    return __kdebug_trace_string(a1, a2, a3, v11, v12, v13, v14, v15);
  }
  else
  {
    uint64_t v17 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (!v17) {
      uint64_t v17 = &errno;
    }
    *uint64_t v17 = 22;
    return -1;
  }
}

uint64_t kdebug_trace(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = kdebug_is_enabled(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return __kdebug_trace64(a1, a2, a3, a4, a5, v14, v15, v16);
  }
  return result;
}

BOOL kdebug_is_enabled(unsigned int a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!MEMORY[0xFFFFFC100]) {
    return 0;
  }
  if ((MEMORY[0xFFFFFC100] & 2) == 0) {
    return 1;
  }
  uint64_t v9 = kdebug_typefilter_typefilter;
  if (!kdebug_typefilter_typefilter)
  {
    uint64_t v12 = 0;
    mach_vm_address_t address = 0;
    if (!__kdebug_typefilter(&address, &v12, a3, a4, a5, a6, a7, a8) && address)
    {
      uint64_t v11 = 0;
      atomic_compare_exchange_strong(&kdebug_typefilter_typefilter, (unint64_t *)&v11, address);
      if (v11) {
        mach_vm_deallocate(mach_task_self_, address, 0x2000uLL);
      }
    }
    uint64_t v9 = kdebug_typefilter_typefilter;
    if (!kdebug_typefilter_typefilter) {
      return 1;
    }
  }
  return ((*(unsigned __int8 *)(v9 + ((unint64_t)a1 >> 19)) >> (BYTE2(a1) & 7)) & 1) != 0;
}

int64_t __kdebug_trace_string(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int64_t result = mac_syscall(SYS_kdebug_trace_string, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void dyld4::RuntimeState::partitionDelayLoads(dyld4::RuntimeState *a1, dyld4::Loader **a2, uint64_t a3, dyld4::Loader **a4, uint64_t a5, uint64_t a6)
{
  vm_map_t v10 = a2;
  uint64_t v12 = 8 * a3;
  if (a3)
  {
    uint64_t v13 = 8 * a3;
    uint64_t v14 = a2;
    do
    {
      __int16 v15 = *v14++;
      dyld4::Loader::setDelayInit(v15, a1, 1);
      v13 -= 8;
    }
    while (v13);
  }
  if (a5)
  {
    uint64_t v16 = 8 * a5;
    do
    {
      uint64_t v17 = *a4++;
      uint64_t v52 = 0;
      uint64_t v53 = v17;
      char v54 = mach_o::LinkedDylibAttributes::regular;
      dyld4::RuntimeState::recursiveMarkNonDelayed((uint64_t)a1, v17, (uint64_t *)&v52, &v52);
      v16 -= 8;
    }
    while (v16);
  }
  if (*((void *)a1 + 22))
  {
    if (*(unsigned char *)(*((void *)a1 + 1) + 190) && a3 != 0)
    {
      uint64_t v19 = v12;
      uint64_t v20 = v10;
      do
      {
        int64_t v21 = *v20;
        int v22 = (dyld3::MachOFile *)dyld4::Loader::mf(*v20, a1);
        if ((*((_WORD *)v21 + 2) & 2) == 0)
        {
          int64_t v23 = v22;
          if (dyld3::MachOFile::isDylib(v22))
          {
            if (dyld3::MachOFile::hasInterposingTuples(v23))
            {
              if (*(unsigned char *)(*((void *)a1 + 1) + 200))
              {
                int64_t v24 = dyld4::Loader::leafName(v21, a1);
                dyld4::RuntimeState::log(a1, "has interposing tuples so cannot be delayed: %s\n", v24);
              }
              uint64_t v52 = 0;
              uint64_t v53 = v21;
              char v54 = mach_o::LinkedDylibAttributes::regular;
              dyld4::RuntimeState::recursiveMarkNonDelayed((uint64_t)a1, v21, (uint64_t *)&v52, &v52);
            }
          }
        }
        ++v20;
        v19 -= 8;
      }
      while (v19);
    }
  }
  uint64_t v25 = a6;
  if (*((void *)a1 + 10))
  {
    unint64_t v26 = 0;
    do
    {
      uint64_t v27 = *(char **)(*((void *)a1 + 9) + 8 * v26);
      if ((dyld4::Loader::isDelayInit((dyld4::Loader *)v27, a1) & 1) == 0)
      {
        uint64_t v52 = v27;
        lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve((uint64_t)a1 + 32, *((void *)a1 + 6) + 1);
        uint64_t v28 = *((void *)a1 + 5);
        uint64_t v29 = *((void *)a1 + 6);
        *((void *)a1 + 6) = v29 + 1;
        *(void *)(v28 + 8 * v29) = v52;
        if (*(unsigned char *)(*((void *)a1 + 1) + 200))
        {
          uint64_t v30 = dyld4::Loader::leafName((dyld4::Loader *)v27, a1);
          dyld4::RuntimeState::log(a1, "move delayed to loaded: %s\n", v30);
        }
        uint64_t v32 = *((void *)a1 + 9);
        uint64_t v31 = *((void *)a1 + 10);
        uint64_t v33 = v32 + 8 * v26;
        uint64_t v34 = (void *)(v33 + 8);
        if (v33 + 8 != v32 + 8 * v31)
        {
          uint64_t v35 = 8 * v31 - 8 * v26 - 8;
          do
          {
            *(v34 - 1) = *v34;
            *v34++ = 0;
            v33 += 8;
            v35 -= 8;
          }
          while (v35);
        }
        *((void *)a1 + 10) = v31 - 1;
        if (v25)
        {
          lsl::Vector<dyld4::Loader const*>::reserve(v25, *(void *)(v25 + 16) + 1);
          uint64_t v36 = *(void *)(v25 + 8);
          uint64_t v37 = *(void *)(v25 + 16);
          *(void *)(v25 + 16) = v37 + 1;
          *(void *)(v36 + 8 * v37) = v27;
        }
        --v26;
      }
      ++v26;
    }
    while (v26 < *((void *)a1 + 10));
  }
  if (*((void *)a1 + 6))
  {
    unint64_t v38 = 0;
    do
    {
      uint64_t v39 = *(char **)(*((void *)a1 + 5) + 8 * v38);
      if (dyld4::Loader::isDelayInit((dyld4::Loader *)v39, a1))
      {
        uint64_t v52 = v39;
        lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve((uint64_t)a1 + 64, *((void *)a1 + 10) + 1);
        uint64_t v40 = *((void *)a1 + 9);
        uint64_t v41 = *((void *)a1 + 10);
        *((void *)a1 + 10) = v41 + 1;
        *(void *)(v40 + 8 * v41) = v52;
        if (*(unsigned char *)(*((void *)a1 + 1) + 200))
        {
          uint64_t v42 = dyld4::Loader::leafName((dyld4::Loader *)v39, a1);
          dyld4::RuntimeState::log(a1, "move loaded to delayed: %s\n", v42);
        }
        uint64_t v44 = *((void *)a1 + 5);
        uint64_t v43 = *((void *)a1 + 6);
        uint64_t v45 = v44 + 8 * v38;
        uint64_t v46 = (void *)(v45 + 8);
        if (v45 + 8 != v44 + 8 * v43)
        {
          uint64_t v47 = 8 * v43 - 8 * v38 - 8;
          do
          {
            *(v46 - 1) = *v46;
            *v46++ = 0;
            v45 += 8;
            v47 -= 8;
          }
          while (v47);
        }
        unint64_t v48 = v43 - 1;
        *((void *)a1 + 6) = v48;
        --v38;
      }
      else
      {
        unint64_t v48 = *((void *)a1 + 6);
      }
      ++v38;
    }
    while (v38 < v48);
  }
  if (v25 && a3)
  {
    do
    {
      uint64_t v49 = *v10;
      if ((dyld4::Loader::isDelayInit(*v10, a1) & 1) == 0)
      {
        lsl::Vector<dyld4::Loader const*>::reserve(v25, *(void *)(v25 + 16) + 1);
        uint64_t v50 = *(void *)(v25 + 8);
        uint64_t v51 = *(void *)(v25 + 16);
        *(void *)(v25 + 16) = v51 + 1;
        *(void *)(v50 + 8 * v51) = v49;
      }
      ++v10;
      v12 -= 8;
    }
    while (v12);
  }
}

uint64_t dyld4::RuntimeState::recursiveMarkNonDelayed(uint64_t a1, dyld4::Loader *a2, uint64_t *a3, char **a4)
{
  uint64_t result = dyld4::Loader::isDelayInit(a2, (dyld4::RuntimeState *)a1);
  if (result)
  {
    dyld4::Loader::setDelayInit(a2, (dyld4::RuntimeState *)a1, 0);
    uint64_t v9 = *(void *)(a1 + 8);
    size_t v10 = *(void *)(v9 + 232);
    if (v10)
    {
      uint64_t v11 = *(const void **)(v9 + 224);
      uint64_t v12 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
      if (v10 == _platform_strlen(v12) && !_platform_memcmp(v11, v12, v10))
      {
        if (*(unsigned char *)(a1 + 656)) {
          strcpy(__dst, "no longer delayed(");
        }
        else {
          strcpy(__dst, "not delayed at launch(");
        }
        uint64_t v13 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
        strlcat(__dst, v13, 0x40uLL);
        strlcat(__dst, ")", 0x40uLL);
        dyld4::RuntimeState::printLinkageChain((dyld4::RuntimeState *)a1, a3, __dst);
      }
    }
    uint64_t result = dyld4::Loader::dependentCount(a2);
    if (result)
    {
      int v14 = result;
      for (unsigned int i = 0; i != v14; ++i)
      {
        char v22 = 0;
        uint64_t result = dyld4::Loader::dependent(a2, (dyld4::RuntimeState *)a1, i, &v22);
        if (result && (v22 & 8) == 0)
        {
          *(void *)__dst = 0;
          *(void *)&__dst[8] = result;
          __dst[16] = v22;
          *a4 = __dst;
          uint64_t result = dyld4::RuntimeState::recursiveMarkNonDelayed(a1, result, a3, __dst);
        }
      }
    }
    uint64_t v16 = *(void *)(a1 + 944);
    if (v16)
    {
      uint64_t v17 = 16 * v16;
      unsigned __int16 v18 = (dyld4::Loader **)(*(void *)(a1 + 936) + 8);
      do
      {
        if (*(v18 - 1) == a2)
        {
          if (*(unsigned char *)(*(void *)(a1 + 8) + 200))
          {
            uint64_t v19 = dyld4::Loader::leafName(*v18, (const dyld4::RuntimeState *)a1);
            uint64_t v20 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "%s has weak-def (or flat lookup) symbol used by %s, so cannot be delayed\n", v19, v20);
          }
          *(void *)__dst = 0;
          *(void *)&__dst[8] = *v18;
          uint64_t v21 = *(void *)&__dst[8];
          __dst[16] = mach_o::LinkedDylibAttributes::regular;
          *a4 = __dst;
          uint64_t result = dyld4::RuntimeState::recursiveMarkNonDelayed(a1, v21, a3, __dst);
        }
        v18 += 2;
        v17 -= 16;
      }
      while (v17);
    }
  }
  return result;
}

void dyld4::Loader::runInitializersBottomUp(dyld4::Loader *a1, dyld4::RuntimeState *a2, uint64_t *a3, uint64_t *a4)
{
  int isDelayInit = dyld4::Loader::isDelayInit(a1, a2);
  char v9 = isDelayInit;
  if (!isDelayInit)
  {
    if (dyld4::Loader::beginInitializers(a1, a2)) {
      return;
    }
    goto LABEL_8;
  }
  uint64_t v10 = a4[2];
  if (!v10)
  {
LABEL_6:
    uint64_t v21 = (uint64_t)a1;
    dyld3::Array<dyld4::Loader const*>::push_back(a4, &v21);
LABEL_8:
    int v13 = dyld4::Loader::dependentCount(a1);
    if (v13)
    {
      int v14 = v13;
      for (unsigned int i = 0; i != v14; ++i)
      {
        char v20 = 0;
        uint64_t v21 = 0;
        uint64_t v16 = dyld4::Loader::dependent(a1, a2, i, &v20);
        uint64_t v21 = v16;
        if (v16)
        {
          if ((v20 & 4) != 0)
          {
            uint64_t v17 = a3[2];
            if (v17)
            {
              unsigned __int16 v18 = (void *)*a3;
              uint64_t v19 = 8 * v17;
              while (*v18 != v16)
              {
                ++v18;
                v19 -= 8;
                if (!v19) {
                  goto LABEL_17;
                }
              }
            }
            else
            {
LABEL_17:
              dyld3::Array<dyld4::Loader const*>::push_back(a3, &v21);
            }
          }
          else
          {
            dyld4::Loader::runInitializersBottomUp();
          }
        }
      }
    }
    if ((v9 & 1) == 0)
    {
      dyld4::RuntimeState::notifyObjCInit(a2, a1);
      dyld4::Loader::runInitializers(a1, a2);
    }
    return;
  }
  uint64_t v11 = (dyld4::Loader **)*a4;
  uint64_t v12 = 8 * v10;
  while (*v11 != a1)
  {
    ++v11;
    v12 -= 8;
    if (!v12) {
      goto LABEL_6;
    }
  }
}

uint64_t dyld4::Loader::isDelayInit(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::isDelayInit();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::isDelayInit((uint64_t)this, (uint64_t)a2);
  }
  else
  {
    return dyld4::JustInTimeLoader::isDelayInit((uint64_t)this);
  }
}

BOOL dyld4::PrebuiltLoader::isDelayInit(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a1 + 6);
  if (v2 >= 0) {
    unint64_t v3 = (void *)(a2 + 976);
  }
  else {
    unint64_t v3 = (void *)(a2 + 1000);
  }
  return *(unsigned char *)(*v3 + (v2 & 0x7FFF)) == 7;
}

uint64_t dyld4::Loader::dependent(dyld4::JustInTimeLoader *a1, dyld4::RuntimeState *a2, unsigned int a3, char *a4)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::dependent();
  }
  if (*((_WORD *)a1 + 2))
  {
    return dyld4::PrebuiltLoader::dependent(a1, a2, a3, a4);
  }
  else
  {
    return dyld4::JustInTimeLoader::dependent(a1, (int)a2, a3, a4);
  }
}

void dyld4::PrebuiltLoader::loadDependents(uint64_t a1, vm_address_t *a2, dyld4::RuntimeState *a3, long long *a4)
{
  __int16 v8 = *(_WORD *)(a1 + 6);
  if (v8 >= 0) {
    char v9 = (uint64_t *)((char *)a3 + 976);
  }
  else {
    char v9 = (uint64_t *)((char *)a3 + 1000);
  }
  uint64_t v10 = *v9;
  uint64_t v11 = v8 & 0x7FFF;
  dyld4::PrebuiltLoader::map((dyld4::Loader *)a1, a2, a3);
  if (*(unsigned __int8 *)(v10 + v11) <= 3u)
  {
    *(unsigned char *)(v10 + v11) = 4;
    __chkstk_darwin(v12, v13, v14, v15, v16, v17, v18, v19, v31);
    char v22 = (char *)&v31 - v21;
    if (v20 >= 0x200) {
      size_t v23 = 512;
    }
    else {
      size_t v23 = v20;
    }
    bzero((char *)&v31 - v21, v23);
    LODWORD(v24) = *(unsigned __int16 *)(a1 + 48);
    if (*(_WORD *)(a1 + 48))
    {
      unint64_t v25 = 0;
      do
      {
        unint64_t v26 = (dyld4::Loader *)dyld4::PrebuiltLoader::dependent((_WORD *)a1, a3, v25, 0);
        *(void *)&v22[8 * v25] = v26;
        if (v26) {
          dyld4::PrebuiltLoader::map(v26, a2, a3);
        }
        ++v25;
        unint64_t v24 = *(unsigned __int16 *)(a1 + 48);
      }
      while (v25 < v24);
    }
    v34[0] = *((void *)a4 + 2);
    v34[1] = a1;
    long long v27 = a4[1];
    long long v31 = *a4;
    long long v32 = v27;
    uint64_t v28 = *((void *)a4 + 4);
    BYTE11(v31) = *(unsigned char *)(a1 + 5) & 1;
    uint64_t v33 = v28;
    *(void *)&long long v32 = v34;
    if (v24)
    {
      unint64_t v29 = 0;
      do
      {
        uint64_t v30 = *(void *)&v22[8 * v29];
        if (v30)
        {
          dyld4::PrebuiltLoader::loadDependents(v30, a2, a3, &v31);
          LODWORD(v24) = *(unsigned __int16 *)(a1 + 48);
        }
        ++v29;
      }
      while (v29 < v24);
    }
    *(unsigned char *)(v10 + v11) = 5;
  }
}

uint64_t dyld4::PrebuiltLoader::dependent(_WORD *a1, dyld4::RuntimeState *a2, unsigned int a3, char *a4)
{
  if ((unsigned __int16)a1[24] <= a3) {
    dyld4::PrebuiltLoader::dependent();
  }
  if (a4)
  {
    if (a1[18]) {
      vm_size_t v6 = (char *)a1 + (unsigned __int16)a1[18] + a3;
    }
    else {
      vm_size_t v6 = &mach_o::LinkedDylibAttributes::regular;
    }
    *a4 = *v6;
  }
  __int16 v10 = *(_WORD *)((char *)&a1[a3] + (unsigned __int16)a1[17]);
  if (v10 == 0x7FFF) {
    return 0;
  }
  uint64_t result = dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v10, a2);
  if ((a1[2] & 2) != 0 && (*(_WORD *)(result + 44) & 4) == 0 && *(unsigned char *)(*((void *)a2 + 1) + 157))
  {
    int v8 = *(unsigned __int16 *)(result + 60);
    if (v8 != 0xFFFF)
    {
      __int16 v9 = v8 & 0x7FFF;
      return dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v9, a2);
    }
  }
  return result;
}

uint64_t dyld4::Loader::LoaderRef::loader(dyld4::Loader::LoaderRef *this, const dyld4::RuntimeState *a2)
{
  int v2 = *(__int16 *)this;
  unsigned int v3 = *(unsigned __int16 *)this;
  if (v2 < 0)
  {
    uint64_t v4 = *((void *)a2 + 124);
    LOWORD(v2) = v3 & 0x7FFF;
    if (*(_DWORD *)(v4 + 12) <= (v3 & 0x7FFF)) {
      dyld4::RuntimeState::findPrebuiltLoader();
    }
  }
  else
  {
    uint64_t v4 = *((void *)a2 + 121);
    if (*(_DWORD *)(v4 + 12) <= v3) {
      dyld4::RuntimeState::findPrebuiltLoader();
    }
  }
  return v4 + *(unsigned int *)(v4 + *(unsigned int *)(v4 + 16) + 4 * (unsigned __int16)v2);
}

void dyld4::PrebuiltLoader::map(dyld4::Loader *this, vm_address_t *a2, dyld4::RuntimeState *a3)
{
  __int16 v3 = *((_WORD *)this + 3);
  if (v3 >= 0) {
    uint64_t v4 = (char *)a3 + 976;
  }
  else {
    uint64_t v4 = (char *)a3 + 1000;
  }
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = v3 & 0x7FFF;
  if (*(unsigned __int8 *)(*(void *)v4 + v6) > 2u) {
    return;
  }
  if (*(unsigned char *)(*((void *)a3 + 1) + 207))
  {
    if (*((_WORD *)this + 16)) {
      __int16 v10 = (char *)this + *((unsigned __int16 *)this + 16);
    }
    else {
      __int16 v10 = 0;
    }
    dyld4::RuntimeState::log(a3, "using PrebuiltLoader %p for %s\n", this, v10);
  }
  unsigned int v11 = *((unsigned __int16 *)this + 2);
  if ((v11 & 2) != 0)
  {
    *(unsigned char *)(v5 + v6) = 3;
    uint64_t v19 = (unsigned char *)*((void *)a3 + 1);
    if (v19[201])
    {
      dyld4::Loader::logSegmentsFromSharedCache(this, a3);
      uint64_t v19 = (unsigned char *)*((void *)a3 + 1);
    }
    if (v19[200])
    {
      if (*((_WORD *)this + 16)) {
        unint64_t v20 = (char *)this + *((unsigned __int16 *)this + 16);
      }
      else {
        unint64_t v20 = 0;
      }
      dyld4::Loader::logLoad(this, a3, v20);
      uint64_t v19 = (unsigned char *)*((void *)a3 + 1);
    }
    if (v19[157] && (*((_WORD *)this + 22) & 8) != 0) {
      *((unsigned char *)a3 + 1135) = 1;
    }
  }
  else if (*((dyld4::Loader **)a3 + 3) == this)
  {
    if (*(unsigned __int8 *)(v5 + v6) <= 2u) {
      *(unsigned char *)(v5 + v6) = 3;
    }
    dyld4::PrebuiltLoader::setLoadAddress((uint64_t)this, (uint64_t)a3, *(void *)(*((void *)a3 + 1) + 8));
  }
  else
  {
    if (*((_WORD *)this + 16)) {
      uint64_t v12 = (dyld4::Loader *)((char *)this + *((unsigned __int16 *)this + 16));
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *((unsigned int *)this + 19);
    unint64_t v14 = (unint64_t)*((unsigned __int16 *)this + 22) >> 4;
    v26[0] = (char *)this + *((unsigned __int16 *)this + 23);
    v26[1] = v14;
    v26[2] = v14;
    uint64_t v15 = (void *)((v11 >> 5) & 1);
    if (*((_WORD *)this + 21)) {
      uint64_t v16 = (char *)this + *((unsigned __int16 *)this + 21);
    }
    else {
      uint64_t v16 = 0;
    }
    LOBYTE(v25) = 1;
    vm_address_t v17 = dyld4::Loader::mapSegments(a2, (dyld4::SyscallDelegate **)a3, v12, v13, (unsigned int *)this + 20, 1, v26, v15, v25, (uint64_t)v16);
    if (Diagnostics::hasError((Diagnostics *)a2)) {
      return;
    }
    dyld4::PrebuiltLoader::setLoadAddress((uint64_t)this, (uint64_t)a3, v17);
    *(unsigned char *)(v5 + v6) = 3;
    if (*(unsigned char *)(*((void *)a3 + 1) + 200))
    {
      if (*((_WORD *)this + 16)) {
        uint64_t v18 = (char *)this + *((unsigned __int16 *)this + 16);
      }
      else {
        uint64_t v18 = 0;
      }
      dyld4::Loader::logLoad(this, a3, v18);
    }
  }
  if (*(_DWORD *)(*((void *)a3 + 1) + 540) && (uint64_t v21 = *((void *)a3 + 6)) != 0)
  {
    char v22 = (dyld4::Loader **)*((void *)a3 + 5);
    uint64_t v23 = 8 * v21;
    unint64_t v24 = v22;
    while (*v24 != this)
    {
      ++v24;
      ++v22;
      v23 -= 8;
      if (!v23) {
        goto LABEL_42;
      }
    }
  }
  else
  {
LABEL_42:
    dyld4::RuntimeState::add(a3, this);
  }
}

uint64_t dyld4::Loader::beginInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::beginInitializers();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::beginInitializers(this, a2);
  }
  else
  {
    return dyld4::JustInTimeLoader::beginInitializers((uint64_t)this);
  }
}

uint64_t dyld4::PrebuiltLoader::beginInitializers(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    __int16 v3 = (char *)a2 + 976;
  }
  else {
    __int16 v3 = (char *)a2 + 1000;
  }
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v2 & 0x7FFF;
  int v6 = *(unsigned __int8 *)(v4 + v5);
  if ((v6 - 8) < 2) {
    return 1;
  }
  if (v6 != 6) {
    dyld4::PrebuiltLoader::beginInitializers();
  }
  uint64_t result = 0;
  *(unsigned char *)(v4 + v5) = 8;
  return result;
}

void __chkstk_darwin_probe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int16 v10 = &a9;
  if (v9 >= 0x1000)
  {
    do
    {
      v10 -= 512;
      v9 -= 4096;
    }
    while (v9 > 0x1000);
  }
}

void ___chkstk_darwin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void __chkstk_darwin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (___chkstk_darwin) {
    ___chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else {
    __chkstk_darwin_probe(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t dyld4::Loader::dependentCount(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::dependentCount();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::dependentCount(this);
  }
  else
  {
    return dyld4::JustInTimeLoader::dependentCount(this);
  }
}

uint64_t dyld4::PrebuiltLoader::dependentCount(dyld4::PrebuiltLoader *this)
{
  return *((unsigned __int16 *)this + 24);
}

uint64_t dyld4::Loader::setDelayInit(dyld4::Loader *this, dyld4::RuntimeState *a2, int a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::setDelayInit();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::setDelayInit((uint64_t)this, (uint64_t)a2, a3);
  }
  else
  {
    return dyld4::JustInTimeLoader::setDelayInit((uint64_t)this, (uint64_t)a2, a3);
  }
}

uint64_t dyld4::PrebuiltLoader::setDelayInit(uint64_t result, uint64_t a2, int a3)
{
  __int16 v3 = *(_WORD *)(result + 6);
  if (v3 >= 0) {
    uint64_t v4 = (uint64_t *)(a2 + 976);
  }
  else {
    uint64_t v4 = (uint64_t *)(a2 + 1000);
  }
  uint64_t v5 = *v4;
  uint64_t v6 = v3 & 0x7FFF;
  int v7 = *(unsigned __int8 *)(v5 + v6);
  if (a3)
  {
    if (v7 != 6) {
      return result;
    }
    char v8 = 7;
  }
  else
  {
    if (v7 != 7) {
      return result;
    }
    char v8 = 6;
  }
  *(unsigned char *)(v5 + v6) = v8;
  return result;
}

void bzero(void *a1, size_t a2)
{
  int8x16_t v3 = veorq_s8(v2, v2);
  if (a2 < 0x40) {
    JUMPOUT(0x1A8E064B4);
  }
  if (a2 < 0x8000) {
    JUMPOUT(0x1A8E0646CLL);
  }
  *(int8x16_t *)a1 = v3;
  *((int8x16_t *)a1 + 1) = v3;
  *((int8x16_t *)a1 + 2) = v3;
  *((int8x16_t *)a1 + 3) = v3;
  unint64_t v4 = ((unint64_t)a1 + 64) & 0xFFFFFFFFFFFFFFC0;
  uint64_t v5 = (char *)a1 + a2 - v4 - 64;
  if ((unint64_t)a1 + a2 > v4 + 64)
  {
    do
    {
      __asm { DC              ZVA, X3 }
      v4 += 64;
      BOOL v10 = (unint64_t)v5 > 0x40;
      v5 -= 64;
    }
    while (v10);
  }
  unsigned int v11 = (int8x16_t *)&v5[v4];
  *unsigned int v11 = v3;
  v11[1] = v3;
  v11[2] = v3;
  v11[3] = v3;
}

void *__cdecl _platform_memset(void *__b, int __c, size_t __len)
{
  unint64_t v3 = 0x101010101010101 * __c;
  int64x2_t v4 = vdupq_n_s64(v3);
  uint64_t v5 = (unint64_t *)__b;
  if (__len < 0x40)
  {
    while (1)
    {
      BOOL v15 = __len >= 8;
      __len -= 8;
      if (!v15) {
        break;
      }
      *v5++ = v3;
    }
    for (size_t i = __len + 8; i; --i)
    {
      *(unsigned char *)uint64_t v5 = v3;
      uint64_t v5 = (unint64_t *)((char *)v5 + 1);
    }
  }
  else if (__len < 0x8000)
  {
    *(int64x2_t *)__b = v4;
    *((int64x2_t *)__b + 1) = v4;
    *((int64x2_t *)__b + 2) = v4;
    *((int64x2_t *)__b + 3) = v4;
    unsigned int v11 = (char *)(((unint64_t)__b + 64) & 0xFFFFFFFFFFFFFFC0);
    uint64_t v12 = (char *)__b + __len;
    BOOL v8 = v12 > v11 + 64;
    for (unint64_t j = v12 - (v11 + 64); v8; j -= 64)
    {
      *(int64x2_t *)unsigned int v11 = v4;
      *((int64x2_t *)v11 + 1) = v4;
      *((int64x2_t *)v11 + 2) = v4;
      *((int64x2_t *)v11 + 3) = v4;
      v11 += 64;
      BOOL v8 = j > 0x40;
    }
    unint64_t v14 = (int64x2_t *)&v11[j];
    int64x2_t *v14 = v4;
    v14[1] = v4;
    v14[2] = v4;
    v14[3] = v4;
  }
  else
  {
    if (!v3) {
      JUMPOUT(0x1A8E063C0);
    }
    *(int64x2_t *)__b = v4;
    *((int64x2_t *)__b + 1) = v4;
    *((int64x2_t *)__b + 2) = v4;
    *((int64x2_t *)__b + 3) = v4;
    uint64_t v6 = (char *)(((unint64_t)__b + 64) & 0xFFFFFFFFFFFFFFC0);
    int v7 = (char *)__b + __len;
    BOOL v8 = v7 > v6 + 64;
    for (unint64_t k = v7 - (v6 + 64); v8; k -= 64)
    {
      *(int64x2_t *)uint64_t v6 = v4;
      *((int64x2_t *)v6 + 1) = v4;
      *((int64x2_t *)v6 + 2) = v4;
      *((int64x2_t *)v6 + 3) = v4;
      v6 += 64;
      BOOL v8 = k > 0x40;
    }
    BOOL v10 = (int64x2_t *)&v6[k];
    *BOOL v10 = v4;
    v10[1] = v4;
    v10[2] = v4;
    void v10[3] = v4;
  }
  return __b;
}

void dyld4::RuntimeState::add(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve((uint64_t)this + 32, *((void *)this + 6) + 1);
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = v5 + 1;
  *(void *)(v4 + 8 * v5) = a2;
  if (!*((void *)this + 13) || !*((void *)this + 12))
  {
    if ((~*((unsigned __int16 *)a2 + 2) & 3) != 0)
    {
      int v7 = (dyld3::MachOFile *)dyld4::Loader::mf(a2, this);
      if (!dyld3::MachOFile::isDylib(v7)) {
        return;
      }
      uint64_t v6 = dyld3::MachOFile::installName(v7);
    }
    else
    {
      uint64_t v6 = (char *)dyld4::Loader::path(a2, this);
    }
    BOOL v8 = v6;
    if (v6)
    {
      uint64_t v9 = *((void *)this + 1);
      int v10 = *(_DWORD *)(v9 + 68);
      if (v10 == 10)
      {
        if (_platform_strcmp(v8, "/System/DriverKit/usr/lib/system/libdyld.dylib"))
        {
          unsigned int v11 = "/System/DriverKit/usr/lib/libSystem.dylib";
          goto LABEL_20;
        }
        goto LABEL_22;
      }
      if (*(unsigned char *)(v9 + 169) && dyld3::MachOFile::isExclaveKitPlatform(v10, 0))
      {
        if (_platform_strlen(v8) < 0x13) {
          return;
        }
        if (_platform_strcmp(v8 + 18, "/usr/lib/system/libdyld.dylib")
          && _platform_strcmp(v8, "/usr/lib/system/libdyld.dylib"))
        {
          if (!_platform_strcmp(v8 + 18, "/usr/lib/libSystem.dylib"))
          {
LABEL_21:
            *((void *)this + 12) = a2;
            return;
          }
          goto LABEL_19;
        }
      }
      else if (_platform_strcmp(v8, "/usr/lib/system/libdyld.dylib"))
      {
LABEL_19:
        unsigned int v11 = "/usr/lib/libSystem.B.dylib";
LABEL_20:
        if (_platform_strcmp(v8, v11)) {
          return;
        }
        goto LABEL_21;
      }
LABEL_22:
      dyld4::RuntimeState::setDyldLoader(this, a2);
    }
  }
}

uint64_t lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserveExact(result, v2);
  }
  return result;
}

const dyld4::RuntimeState *dyld4::RuntimeState::notifyObjCInit(const dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  if ((*((_WORD *)a2 + 2) & 8) != 0)
  {
    uint64_t v2 = (uint64_t)this;
    if (*((void *)this + 86))
    {
      uint64_t Address = (const void *)dyld4::Loader::loadAddress(a2, this);
      uint64_t v5 = (const char *)dyld4::Loader::path(a2, (const dyld4::RuntimeState *)v2);
      int v14 = 520552480;
      BOOL v15 = Address;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v14, v6, v7, v8, v9, v10, v11, v12);
      if (*(unsigned char *)(*(void *)(v2 + 8) + 205)) {
        dyld4::RuntimeState::log((dyld4::RuntimeState *)v2, "objc-init-notifier called with mh=%p, path=%s\n", Address, v5);
      }
      v13[0] = Address;
      v13[1] = v5;
      v13[2] = a2;
      v13[3] = dyld4::Loader::dyldDoesObjCFixups(a2);
      (*(void (**)(void *))(v2 + 688))(v13);
      return (const dyld4::RuntimeState *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v14);
    }
  }
  return this;
}

void dyld4::Loader::runInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::runInitializers();
  }
  if (*((_WORD *)this + 2))
  {
    dyld4::PrebuiltLoader::runInitializers(this, a2);
  }
  else
  {
    dyld4::JustInTimeLoader::runInitializers((dyld4::PseudoDylib **)this, a2);
  }
}

void dyld4::PrebuiltLoader::runInitializers(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  if (*((_WORD *)this + 22)) {
    dyld4::Loader::findAndRunAllInitializers(this, a2);
  }
  __int16 v4 = *((_WORD *)this + 3);
  if (v4 >= 0) {
    uint64_t v5 = (char *)a2 + 976;
  }
  else {
    uint64_t v5 = (char *)a2 + 1000;
  }
  *(unsigned char *)(*(void *)v5 + (v4 & 0x7FFF)) = 9;
}

uint64_t dyld3::MachOFile::isExclaveKitPlatform(int a1, _DWORD *a2)
{
  if (a1 == 20)
  {
    if (a2)
    {
      LODWORD(result) = 3;
LABEL_10:
      *a2 = result;
    }
    return 1;
  }
  if (a1 == 18)
  {
    if (a2)
    {
      LODWORD(result) = 2;
      goto LABEL_10;
    }
    return 1;
  }
  if (a1 != 16) {
    return 0;
  }
  uint64_t result = 1;
  if (a2) {
    goto LABEL_10;
  }
  return result;
}

void dyld4::Loader::findAndRunAllInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  uint64_t Address = (dyld3::MachOAnalyzer *)dyld4::Loader::loadAddress(this, a2);
  dyld3::MachOAnalyzer::makeVMAddrConverter(Address, 1, (uint64_t)v7);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke;
  v6[3] = &__block_descriptor_tmp_104_0;
  v6[4] = this;
  v6[5] = Address;
  v6[6] = a2;
  dyld3::MachOAnalyzer::forEachInitializer(Address, (vm_address_t *)&v8, (uint64_t)v7, (uint64_t)v6);
  if (!dyld3::MachOFile::isArch(Address, "arm64e"))
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_107_0;
    v5[4] = this;
    v5[5] = Address;
    v5[6] = a2;
    dyld3::MachOAnalyzer::forEachTerminator(Address, (vm_address_t *)&v8, (uint64_t)v7, (uint64_t)v5);
  }
  mach_o::Error::~Error(&v8);
}

uint64_t dyld3::MachOAnalyzer::makeVMAddrConverter@<X0>(dyld3::MachOAnalyzer *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)a3 = dyld3::MachOFile::preferredLoadAddress(this);
  *(void *)(a3 + 8) = dyld3::MachOLoaded::getSlide(this);
  uint64_t result = dyld3::MachOFile::hasChainedFixups(this);
  if (result) {
    uint64_t result = dyld3::MachOAnalyzer::chainedPointerFormat(this);
  }
  *(_WORD *)(a3 + 16) = result;
  *(unsigned char *)(a3 + 18) = a2;
  return result;
}

uint64_t dyld3::MachOLoaded::getSlide(dyld3::MachOLoaded *this)
{
  Diagnostics::Diagnostics((Diagnostics *)&v9);
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld311MachOLoaded8getSlideEv_block_invoke;
  void v4[3] = &unk_1EFF668F8;
  v4[4] = &v5;
  void v4[5] = this;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  mach_o::Error::~Error(&v9);
  return v2;
}

uint64_t dyld3::MachOFile::hasChainedFixups(dyld3::MachOFile *this)
{
  if (*((_DWORD *)this + 1) == 16777228
    && (*((_DWORD *)this + 2) & 0xFFFFFF) == 2
    && (dyld3::MachOFile::hasLoadCommand(this, -2147483614) & 1) != 0)
  {
    return 1;
  }

  return dyld3::MachOFile::hasLoadCommand(this, -2147483596);
}

uint64_t dyld3::MachOFile::hasLoadCommand(dyld3::MachOFile *this, int a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld39MachOFile14hasLoadCommandEj_block_invoke;
  v6[3] = &unk_1EFF66398;
  int v7 = a2;
  v6[4] = &v9;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v8, (uint64_t)v6);
  uint64_t v4 = *((unsigned __int8 *)v10 + 24);
  mach_o::Error::~Error(&v8);
  _Block_object_dispose(&v9, 8);
  return v4;
}

void dyld3::MachOAnalyzer::forEachInitializer(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = 0;
  long long v16 = &v15;
  uint64_t v17 = 0x6802000000;
  long long v18 = __Block_byref_object_copy__13;
  long long v19 = __Block_byref_object_dispose__13;
  v20[3] = v20;
  v20[4] = 1;
  uint64_t v21 = 0;
  vm_address_t v22 = 0;
  vm_size_t v23 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke;
  v14[3] = &unk_1EFF66C50;
  v14[4] = &v15;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v14);
  if (v16[10])
  {
    uint64_t Address = dyld3::MachOFile::preferredLoadAddress(a1);
    uint64_t Slide = dyld3::MachOLoaded::getSlide(a1);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_2;
    v13[3] = &unk_1EFF66C78;
    void v13[4] = a4;
    v13[5] = &v15;
    v13[6] = Address;
    v13[7] = a2;
    dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v13);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_3;
    v11[3] = &unk_1EFF66CA0;
    int v12 = dyld3::MachOFile::pointerSize(a1);
    v11[6] = a1;
    v11[7] = a3;
    v11[4] = a4;
    v11[5] = &v15;
    v11[8] = a2;
    v11[9] = Address;
    dyld3::MachOFile::forEachInitializerPointerSection(a1, (uint64_t)a2, (uint64_t)v11);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_4;
    void v10[3] = &unk_1EFF66CC8;
    v10[6] = Slide;
    v10[7] = a2;
    void v10[8] = Address;
    v10[4] = a4;
    v10[5] = &v15;
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v10);
  }
  else
  {
    Diagnostics::error(a2, "no exeutable segments");
  }
  _Block_object_dispose(&v15, 8);
  uint64_t v21 = 0;
  if (v22) {
    vm_deallocate(mach_task_self_, v22, v23);
  }
}

uint64_t dyld3::MachOFile::pointerSize(dyld3::MachOFile *this)
{
  if (*(_DWORD *)this == -17958193) {
    return 8;
  }
  else {
    return 4;
  }
}

BOOL dyld3::MachOFile::isArch(dyld3::MachOFile *this, const char *__s1)
{
  uint64_t v3 = 0;
  uint64_t v4 = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v3 + 1]) != *((_DWORD *)this + 1)
       || (*((_DWORD *)this + 2) & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v3 + 3))
  {
    v3 += 2;
    if (v3 == 26) {
      return _platform_strcmp(__s1, v4) == 0;
    }
  }
  uint64_t v4 = (&dyld3::MachOFile::_s_archInfos)[v3];
  return _platform_strcmp(__s1, v4) == 0;
}

void dyld3::MachOFile::forEachInitializerPointerSection(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a1 == -17958193) {
    int v4 = 8;
  }
  else {
    int v4 = 4;
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile32forEachInitializerPointerSectionER11DiagnosticsU13block_pointerFvjjRbE_block_invoke;
  v5[3] = &unk_1EFF66550;
  int v6 = v4;
  v5[4] = a3;
  v5[5] = a2;
  v5[6] = dyld3::MachOFile::preferredLoadAddress(a1);
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v5);
}

uint64_t dyld4::JustInTimeLoader::isDelayInit(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 46) >> 7;
}

uint64_t lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 8 * a2);
    if (result)
    {
LABEL_12:
      *(void *)(v3 + 24) = a2;
      return result;
    }
    uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 8 * a2);
    uint64_t v4 = result;
    uint64_t v5 = *(void **)(v3 + 8);
    uint64_t v6 = *(void *)(v3 + 16);
    if (v6)
    {
      int v7 = *(void **)(v3 + 8);
      uint64_t v8 = v7;
      uint64_t v9 = (void *)result;
      do
      {
        *v9++ = *v8;
        *v8++ = 0;
        ++v7;
        --v6;
      }
      while (v6);
    }
    else if (!v5)
    {
      unint64_t v10 = 0;
      goto LABEL_9;
    }
    uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v5);
    unint64_t v10 = *(void *)(v3 + 16);
LABEL_9:
    if (v10 >= a2) {
      unint64_t v10 = a2;
    }
    *(void *)(v3 + 8) = v4;
    *(void *)(v3 + 16) = v10;
    goto LABEL_12;
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_find_unwind_sections(dyld4::APIs *this, char *a2, dyld3::MachOLoaded **a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_find_unwind_sections(%p, %p)\n", a2, a3);
  }
  long long v19 = 0;
  long long v20 = 0;
  uint64_t ImageMappedAt = dyld4::APIs::findImageMappedAt(this, a2, &v20, 0, 0, 0, 0, 0, &v19);
  if (ImageMappedAt)
  {
    uint64_t v8 = v19;
    int v7 = v20;
    *a3 = v20;
    *(_OWORD *)(a3 + 1) = 0u;
    *(_OWORD *)(a3 + 3) = 0u;
    if (!v8) {
      goto LABEL_13;
    }
    if (*((_WORD *)v8 + 2)) {
      goto LABEL_13;
    }
    uint64_t v9 = (uint64_t *)*((void *)v8 + 13);
    if (!v9) {
      goto LABEL_13;
    }
    unint64_t v10 = (uint64_t (***)(char *))*((void *)v8 + 13);
    LOBYTE(v18) = 0;
    UnwindSections = (const char *)dyld4::PseudoDylib::findUnwindSections(v9, (uint64_t)a2, (uint64_t)&v18, (uint64_t)a3);
    if (UnwindSections)
    {
      int v12 = (char *)UnwindSections;
      if (*(unsigned char *)(*((void *)this + 1) + 204)) {
        dyld4::RuntimeState::log(this, "_dyld_pseudodylib_find_unwind_sections(%p, %p) returned error: %s", a2, a3, UnwindSections);
      }
      dyld4::PseudoDylib::disposeString(v10, v12);
    }
    if (!(_BYTE)v18)
    {
      int v7 = v20;
LABEL_13:
      unint64_t v18 = 0;
      uint64_t SectionContent = dyld3::MachOLoaded::findSectionContent(v7, "__TEXT", "__eh_frame", &v18);
      if (SectionContent)
      {
        unint64_t v14 = v18;
        a3[1] = (dyld3::MachOLoaded *)SectionContent;
        a3[2] = (dyld3::MachOLoaded *)v14;
      }
      uint64_t v15 = dyld3::MachOLoaded::findSectionContent(v20, "__TEXT", "__unwind_info", &v18);
      if (v15)
      {
        unint64_t v16 = v18;
        a3[3] = (dyld3::MachOLoaded *)v15;
        a3[4] = (dyld3::MachOLoaded *)v16;
      }
    }
  }
  return ImageMappedAt;
}

uint64_t dyld3::MachOLoaded::findSectionContent(dyld3::MachOLoaded *this, const char *a2, const char *a3, unint64_t *a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZNK5dyld311MachOLoaded18findSectionContentEPKcS2_Ry_block_invoke;
  v6[3] = &unk_1EFF66970;
  v6[6] = a3;
  void v6[7] = a2;
  v6[8] = a4;
  v6[4] = &v7;
  void v6[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void dyld4::RuntimeState::notifyDtrace(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = dyld4::SyscallDelegate::dtraceUserProbesEnabled(*(dyld4::SyscallDelegate **)(a1 + 8));
  if (v4)
  {
    v32[1] = (uint64_t)v32;
    __chkstk_darwin(v4, v5, v6, v7, v8, v9, v10, v11, v32[0]);
    uint64_t v13 = (dof_ioctl_data *)((char *)v32 - ((v12 + 1295) & 0xFFFFFFFFFFFFFFF0));
    v13->uint64_t dofiod_count = 0;
    uint64_t v35 = 0;
    uint64_t v36 = &v35;
    uint64_t v37 = 0x2000000000;
    char v38 = 0;
    uint64_t v14 = *(void *)(a2 + 8);
    if (v14)
    {
      uint64_t v15 = *(dyld4::Loader ***)a2;
      uint64_t v16 = 8 * v14;
      do
      {
        uint64_t v17 = *v15++;
        Diagnostics::Diagnostics((Diagnostics *)&v34);
        unint64_t v18 = (_DWORD *)dyld4::Loader::analyzer(v17, (dyld4::RuntimeState *)a1);
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000;
        v33[2] = ___ZN5dyld412RuntimeState12notifyDtraceERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
        v33[3] = &unk_1EFF64390;
        v33[6] = v13;
        v33[7] = v18;
        v33[8] = v17;
        v33[4] = &v35;
        v33[5] = a1;
        dyld3::MachOFile::forEachDOFSection(v18, (uint64_t)&v34, (uint64_t)v33);
        mach_o::Error::~Error(&v34);
        v16 -= 8;
      }
      while (v16);
      if (v13->dofiod_count)
      {
        dyld4::SyscallDelegate::dtraceRegisterUserProbes(*(dyld4::SyscallDelegate **)(a1 + 8), v13);
        if (*((unsigned char *)v36 + 24))
        {
          uint64_t v19 = *(void *)(a2 + 8);
          if (v19)
          {
            long long v20 = *(dyld4::Loader ***)a2;
            uint64_t v21 = *(void *)a2 + 8 * v19;
            v32[0] = (uint64_t)&v13->dofiod_helpers[0].dofhp_dof;
            do
            {
              vm_address_t v22 = *v20;
              if ((*((_WORD *)*v20 + 2) & 0x20) == 0)
              {
                uint64_t v23 = dyld4::Loader::analyzer(*v20, (dyld4::RuntimeState *)a1);
                uint64_t dofiod_count = v13->dofiod_count;
                if (v13->dofiod_count)
                {
                  uint64_t v25 = v23;
                  uint64_t v26 = 0;
                  long long v27 = (uint64_t *)v32[0];
                  do
                  {
                    if (*(v27 - 1) == v25)
                    {
                      uint64_t v28 = *v27;
                      lsl::Vector<dyld4::InterposeTupleAll>::reserve(a1 + 864, *(void *)(a1 + 880) + 1);
                      uint64_t v29 = *(void *)(a1 + 872);
                      uint64_t v30 = *(void *)(a1 + 880);
                      *(void *)(a1 + 880) = v30 + 1;
                      uint64_t v31 = v29 + 16 * v30;
                      *(void *)uint64_t v31 = v22;
                      *(_DWORD *)(v31 + 8) = v28;
                      uint64_t dofiod_count = v13->dofiod_count;
                    }
                    v27 += 10;
                    ++v26;
                  }
                  while (v26 < dofiod_count);
                }
              }
              ++v20;
            }
            while (v20 != (dyld4::Loader **)v21);
          }
        }
      }
    }
    _Block_object_dispose(&v35, 8);
  }
}

uint64_t dyld4::SyscallDelegate::dtraceUserProbesEnabled(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFFC092] & 1;
}

uint64_t dyld4::JustInTimeLoader::setDelayInit(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(result + 40);
  if (a3)
  {
    if ((v3 & 0x40000) != 0) {
      return result;
    }
    unint64_t v4 = v3 | 0x80000000000000;
  }
  else
  {
    unint64_t v4 = v3 & 0xFF7FFFFFFFFFFFFFLL;
  }
  *(void *)(result + 40) = v4;
  return result;
}

uint64_t dyld3::MachOAnalyzer::chainedPointerFormat(dyld3::MachOAnalyzer *this)
{
  uint64_t v2 = (dyld3::MachOFile *)dyld3::MachOAnalyzer::chainedFixupsHeader(this);
  if (v2)
  {
    return dyld3::MachOFile::chainedPointerFormat(v2, v3);
  }
  else
  {
    if (*((_DWORD *)this + 1) != 16777228 || dyld3::MachOFile::maskedCpuSubtype(this) != 2) {
      dyld3::MachOAnalyzer::chainedPointerFormat();
    }
    return 1;
  }
}

uint64_t dyld3::MachOFile::chainedPointerFormat(dyld3::MachOFile *this, const dyld_chained_fixups_header *a2)
{
  uint64_t v2 = *((unsigned int *)this + 1);
  uint64_t v3 = (char *)this + v2;
  uint64_t v4 = *(unsigned int *)((char *)this + v2);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (unsigned int *)((char *)this + v2 + 4);
  while (1)
  {
    unsigned int v7 = *v5++;
    uint64_t v6 = v7;
    if (v7)
    {
      uint64_t v8 = &v3[v6];
      if (*((_WORD *)v8 + 10)) {
        break;
      }
    }
    if (!--v4) {
      return 0;
    }
  }
  return *((unsigned __int16 *)v8 + 3);
}

void dyld4::Loader::makeSegmentsReadOnly(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(this, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld46Loader20makeSegmentsReadOnlyERNS_12RuntimeStateE_block_invoke;
  v5[3] = &__block_descriptor_tmp_116;
  v5[4] = this;
  v5[5] = dyld3::MachOLoaded::getSlide(Address);
  v5[6] = a2;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v5);
}

BOOL dyld4::ExternallyViewableState::notifyMonitorNeeded(dyld4::ExternallyViewableState *this)
{
  return *(_DWORD *)(*((void *)this + 3) + 200) == 1229016646;
}

uint64_t dyld4::JustInTimeLoader::overridesDylibInCache(uint64_t a1, void *a2, _WORD *a3)
{
  unint64_t v3 = *(void *)(a1 + 40);
  if ((v3 & 0x400000) != 0)
  {
    *a2 = *(void *)(a1 + 88);
    *a3 = *(_WORD *)(a1 + 43) & 0x7FFF;
  }
  return (v3 >> 22) & 1;
}

uint64_t dyld4::JustInTimeLoader::beginInitializers(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 40);
  if ((v1 & 0x40000) == 0) {
    *(void *)(a1 + 40) = v1 | 0x40000;
  }
  return (v1 >> 18) & 1;
}

void dyld4::JustInTimeLoader::runInitializers(dyld4::PseudoDylib **this, dyld4::RuntimeState *a2)
{
  dyld4::Loader::findAndRunAllInitializers((dyld4::Loader *)this, a2);
  uint64_t v6 = this[13];
  uint64_t v5 = (uint64_t (****)(char *))(this + 13);
  uint64_t v4 = v6;
  if (v6)
  {
    unsigned int v7 = (const char *)dyld4::PseudoDylib::initialize(v4);
    if (v7)
    {
      uint64_t v8 = (char *)v7;
      dyld4::RuntimeState::log(a2, "error running pseudo-dylib initializers: %s", v7);
      uint64_t v9 = *v5;
      dyld4::PseudoDylib::disposeString(v9, v8);
    }
  }
}

uint64_t __kdebug_typefilter(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_kdebug_typefilter, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t dyld4::PrebuiltLoader::setLoadAddress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(__int16 *)(a1 + 6);
  if ((v3 & 0x80000000) == 0) {
    dyld4::PrebuiltLoader::setLoadAddress();
  }

  return dyld4::RuntimeState::setAppLoadAddress(a2, v3 & 0x7FFF, a3);
}

uint64_t dyld4::RuntimeState::setAppLoadAddress(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 992);
  if (!v3) {
    dyld4::RuntimeState::setAppLoadAddress();
  }
  if (*(_DWORD *)(v3 + 12) <= a2) {
    dyld4::RuntimeState::setAppLoadAddress();
  }
  *(void *)(*(void *)(result + 1008) + 8 * a2) = a3;
  return result;
}

void dyld4::ProcessConfig::PathOverrides::forEachInsertedDylib(uint64_t a1, uint64_t a2)
{
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x2000000000;
  v5[0] = 0;
  uint64_t v2 = *(unsigned char **)(a1 + 96);
  if (v2 && *v2)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000;
    v3[2] = ___ZNK5dyld413ProcessConfig13PathOverrides20forEachInsertedDylibEU13block_pointerFvPKcRbE_block_invoke;
    v3[3] = &unk_1EFF63930;
    void v3[4] = a2;
    v3[5] = v4;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList((uint64_t)v2, 0, v5, (uint64_t)v3);
  }
  _Block_object_dispose(v4, 8);
}

uint64_t dyld4::JustInTimeLoader::handleStrongWeakDefOverrides(uint64_t this, dyld4::RuntimeState *a2, dyld4::DyldCacheDataConstLazyScopedWriter *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
  v5[3] = &__block_descriptor_tmp_17;
  v5[4] = this;
  v5[5] = a2;
  uint64_t v3 = *(void *)(this + 24);
  if (v3)
  {
    if ((*(_WORD *)(v3 + 4) & 0x800) != 0)
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      void v4[3] = &unk_1EFF64B38;
      void v4[5] = v3;
      void v4[6] = this;
      v4[4] = v5;
      return dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v4);
    }
  }
  return this;
}

void dyld4::RuntimeState::notifyDebuggerLoad(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  uint64_t v4 = lsl::AllocatorLayout::minSize(this);
  __chkstk_darwin(v4, v4 + 72, v5, v6, v7, v8, v9, v10, v18);
  uint64_t v12 = (char *)&v19[-1] - ((v11 + 87) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  uint64_t v15 = lsl::AllocatorLayout::minSize(v14);
  uint64_t v16 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v12, (char *)(v15 + 72));
  long long v20 = v16;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v20, 1uLL);
  lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v20, v22 + 1);
  uint64_t v17 = v22++;
  *(void *)(v21 + 8 * v17) = a2;
  v19[0] = v21;
  v19[1] = v17 + 1;
  dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)v19);
  if (v21) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v20, 0);
  }
  lsl::Allocator::~Allocator(v16);
}

void dyld4::RuntimeState::setMainLoader(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  *((void *)this + 3) = a2;
  uint64_t v11 = (dyld3::MachOLoaded *)dyld4::Loader::analyzer(a2, this);
  uint64_t v12 = *((void *)this + 1);
  if (*(unsigned char *)(v12 + 200))
  {
    dyld4::Loader::logLoad(a2, this, *(char **)(v12 + 16));
    uint64_t v12 = *((void *)this + 1);
  }
  if (*(unsigned char *)(v12 + 201))
  {
    dyld4::RuntimeState::log(this, "Kernel mapped %s\n", *(const char **)(v12 + 16));
    *(void *)&v30.fsobj_id st_dev = 0;
    v30.__darwin_ino64_t st_ino = (__darwin_ino64_t)&v30;
    *(void *)&v30.st_uid = 0x2000000000;
    v30.st_rdev = 0;
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 0x40000000;
    uint64_t v32[2] = ___ZN5dyld412RuntimeState13setMainLoaderEPKNS_6LoaderE_block_invoke;
    v32[3] = &unk_1EFF641A0;
    v32[4] = &v30;
    v32[5] = this;
    v32[6] = dyld3::MachOLoaded::getSlide(v11);
    v32[7] = v11;
    dyld3::MachOFile::forEachSegment(v11, (uint64_t)v32);
    _Block_object_dispose(&v30, 8);
    uint64_t v12 = *((void *)this + 1);
  }
  if (*(unsigned char *)(v12 + 156))
  {
    uint64_t v31 = 0;
    if (!rosetta_dyld_get_runtime_info((uint64_t)&v31, v4, v5, v6, v7, v8, v9, v10))
    {
      uint64_t v14 = v31;
      if (v31[2])
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        do
        {
          uint64_t v17 = (fsid *)(v14[1] + v15);
          fsid v18 = *v17;
          uint64_t v19 = (dyld3 *)v17[1];
          long long v20 = (long long *)(v14[3] + v15);
          uint64_t v21 = *((void *)v20 + 2);
          long long v33 = *v20;
          uint64_t v34 = v21;
          uint64_t v22 = (dyld3 *)dyld3::stat(v19, &v30, v13);
          if (!v22)
          {
            fsobj_id st_dev = (fsobj_id)v30.st_dev;
            fsid v25 = v18;
            dyld3::kdebug_trace_dyld_image(v22, v19, (void **)&v33 + 1, (unsigned __int8 (*)[16])v30.st_ino, st_dev, v25, (const void *)*(unsigned int *)(*(void *)&v18 + 8), v23, v29);
          }
          ++v16;
          uint64_t v14 = v31;
          v15 += 24;
        }
        while (v16 < v31[2]);
      }
      uint64_t v26 = (dyld4::RuntimeState *)((char *)this + 536);
      dyld4::ExternallyViewableState::setRosettaSharedCacheInfo(v26, v14[6], (__n128 *)(v14 + 7));
      __darwin_ino64_t v27 = v31[4];
      *(void *)&v30.fsobj_id st_dev = v31[5];
      v30.__darwin_ino64_t st_ino = v27;
      uint64_t v28 = *v31;
      *(void *)&long long v33 = v31[1];
      *((void *)&v33 + 1) = v28;
      dyld4::ExternallyViewableState::addRosettaImages((uint64_t)v26, (uint64_t)&v30, (uint64_t)&v33);
    }
  }
}

void dyld4::RuntimeState::setDyldLoader(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  *((void *)this + 13) = a2;
  long long v5 = xmmword_1EFF64170;
  long long v6 = unk_1EFF64180;
  uint64_t v7 = 2;
  Diagnostics::Diagnostics((Diagnostics *)&v4);
  if (dyld4::Loader::hasExportedSymbol((uint64_t)a2, (vm_address_t *)&v4, this, "__dyld_missing_symbol_abort", 1u, 1, (uint64_t *)&v5, 0))
  {
    *((void *)this + 14) = dyld4::Loader::resolvedAddress(this, (uint64_t)&v5);
    if (v7 != 1) {
      dyld4::RuntimeState::setDyldLoader();
    }
    *((void *)this + 15) = v6;
  }
  mach_o::Error::~Error(&v4);
}

uint64_t dyld4::ExternallyViewableState::storeProcessInfoPointer(uint64_t this, dyld_all_image_infos **a2)
{
  *a2 = *(dyld_all_image_infos **)(this + 24);
  return this;
}

BOOL dyld3::MachOFile::getEntry(dyld3::MachOFile *this, unint64_t *a2, BOOL *a3)
{
  Diagnostics::Diagnostics((Diagnostics *)&v9);
  *a2 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile8getEntryERyRb_block_invoke;
  v8[3] = &__block_descriptor_tmp_104_2;
  v8[4] = this;
  v8[5] = a3;
  void v8[6] = a2;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v8);
  BOOL v6 = *a2 != 0;
  mach_o::Error::~Error(&v9);
  return v6;
}

void dyld4::BumpAllocator::~BumpAllocator(vm_address_t *this)
{
  if (*this)
  {
    vm_deallocate(mach_task_self_, *this, this[1]);
    this[1] = 0;
    this[2] = 0;
    *this = 0;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::forEachCachePatch(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 20))
  {
    uint64_t v3 = result;
    unint64_t v4 = 0;
    uint64_t v5 = result + *(unsigned int *)(result + 24);
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
      ++v4;
      v5 += 16;
    }
    while (v4 < *(unsigned int *)(v3 + 20));
  }
  return result;
}

BOOL dyld4::APIs::dyld_shared_cache_some_image_overridden(dyld4::APIs *this)
{
  int v1 = *((unsigned __int8 *)this + 1134);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_some_image_overridden() => %d\n", *((unsigned __int8 *)this + 1134));
  }
  return v1 != 0;
}

const char *dyld4::APIs::_dyld_get_objc_selector(dyld4::APIs *this, char *__s)
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)(v4 + 304);
  if (v5)
  {
    uint64_t Index = objc::StringHashTable::tryGetIndex(*(objc::StringHashTable **)(v4 + 304), __s);
    if ((Index & 0xFF00000000) != 0)
    {
      Selector = (const char *)(v5
                              + *(int *)(v5
                                       + *(unsigned int *)(v5 + 4)
                                       + (*(_DWORD *)(v5 + 16) + 1)
                                       + 4 * Index
                                       + 1056));
      goto LABEL_6;
    }
  }
  if (*((void *)this + 124))
  {
    Selector = (const char *)prebuilt_objc::findSelector(this, (void *)this + 43, __s);
LABEL_6:
    if (*(unsigned char *)(*((void *)this + 1) + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_get_objc_selector(%s) => %s\n", __s, Selector);
    }
    return Selector;
  }
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_objc_selector(%s) => nullptr\n", __s);
  }
  return 0;
}

unint64_t prebuilt_objc::findSelector(dyld4::RuntimeState *a1, void *a2, const char *a3)
{
  uint64_t v7 = a3;
  uint64_t v5 = (dyld4::PrebuiltLoader::BindTargetRef *)dyld3::MapBase<prebuilt_objc::ObjCStringKeyOnDisk,void,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::const_find<char const*>((uint64_t)a2, a2, a2 + 3, a1, &v7);
  if (v5 == (dyld4::PrebuiltLoader::BindTargetRef *)(a2[3] + 8 * a2[5])) {
    return 0;
  }
  else {
    return dyld4::PrebuiltLoader::BindTargetRef::value(v5, a1);
  }
}

uint64_t dyld3::MapBase<prebuilt_objc::ObjCStringKeyOnDisk,void,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::const_find<char const*>(uint64_t a1, void *a2, void *a3, dyld4::RuntimeState *a4, const char **a5)
{
  if (!a3[2]) {
    return *a3;
  }
  uint64_t v9 = (char *)*a5;
  int v10 = _platform_strlen(*a5);
  unint64_t v11 = murmurHash((uint64_t *)v9, v10, 0);
  unint64_t v12 = a2[2];
  unint64_t v13 = (v12 - 1) & v11;
  if (v12 <= v13) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v14 = 1;
  while (1)
  {
    unint64_t v15 = *(unsigned int *)(*a2 + 4 * v13);
    unint64_t v16 = a3[2];
    if (v15 == -1) {
      return *a3 + 8 * v16;
    }
    if (v16 <= v15) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    }
    uint64_t v17 = (dyld4::PrebuiltLoader::BindTargetRef *)(*a3 + 8 * v15);
    v20[0] = *a5;
    v20[1] = (const char *)_platform_strlen(v20[0]);
    if (prebuilt_objc::EqualObjCStringKeyOnDisk::equal(v17, (uint64_t)v20, a4)) {
      break;
    }
    unint64_t v18 = a2[2];
    unint64_t v13 = (v18 - 1) & (v13 + v14++);
    if (v18 <= v13) {
      goto LABEL_8;
    }
  }
  if (a3[2] <= v15) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  return *a3 + 8 * v15;
}

void dyld4::PrebuiltLoader::applyObjCFixups(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  if (this)
  {
    uint64_t v3 = *((unsigned int *)this + 14);
    if (v3)
    {
      uint64_t v5 = (char *)this + v3;
      uint64_t Address = (dyld3::MachOFile *)dyld4::PrebuiltLoader::loadAddress(this, a2);
      long long v32 = Address;
      long long v33 = Address;
      uint64_t v7 = (dyld3::MachOFile *)dyld4::PrebuiltLoader::loadAddress(this, a2);
      int v8 = dyld3::MachOFile::pointerSize(v7);
      uint64_t v9 = (char *)Address + *(void *)v5;
      *((_DWORD *)v9 + 1) |= 0x80u;
      if (*(unsigned char *)(*((void *)a2 + 1) + 202)) {
        dyld4::RuntimeState::log(a2, "fixup: *0x%012lX = 0x%012lX <objc-info preoptimized>\n", v9, *(void *)v9);
      }
      dyld3::MachOAnalyzer::makeVMAddrConverter(Address, 1, (uint64_t)v31);
      uint64_t v10 = dyld3::MachOFile::preferredLoadAddress(Address);
      uint64_t v11 = v10;
      uint64_t v30 = v10;
      uint64_t v12 = *((unsigned int *)v5 + 16);
      if (v12)
      {
        uint64_t v13 = *(void *)(*((void *)a2 + 124) + 56) + *(void *)(*((void *)a2 + 1) + 240);
        uint64_t v14 = *((unsigned int *)v5 + 13);
        uint64_t v26 = 0;
        __darwin_ino64_t v27 = &v26;
        uint64_t v28 = 0x2000000000;
        int v29 = 0;
        v24[0] = _NSConcreteStackBlock;
        v24[1] = 0x40000000;
        v24[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke;
        v24[3] = &unk_1EFF64D88;
        v24[6] = v14;
        v24[7] = v14;
        v24[4] = &v26;
        v24[5] = &v5[v12];
        v24[8] = v10;
        v24[9] = Address;
        v24[10] = v13;
        v24[11] = a2;
        fsid v25 = v24;
        dyld3::MachOAnalyzer::forEachObjCProtocol(Address, *((void *)v5 + 4), v14, (uint64_t)v31, (uint64_t)&v25);
        _Block_object_dispose(&v26, 8);
      }
      uint64_t v15 = *((unsigned int *)v5 + 18);
      if (v15)
      {
        uint64_t v16 = *(void *)(*((void *)a2 + 1) + 304);
        uint64_t v17 = &v5[*((unsigned int *)v5 + 17)];
        uint64_t v26 = 0;
        __darwin_ino64_t v27 = &v26;
        uint64_t v28 = 0x2000000000;
        int v29 = 0;
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000;
        v23[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_2;
        v23[3] = &unk_1EFF64DB0;
        v23[6] = v15;
        v23[7] = v15;
        v23[4] = &v26;
        v23[5] = v17;
        v23[8] = v16;
        v23[9] = a2;
        v23[10] = Address;
        dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(a2, this, v11, (uint64_t)v5, (uint64_t)v23);
        _Block_object_dispose(&v26, 8);
      }
      if (v5[56])
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_3;
        v22[3] = &__block_descriptor_tmp_35_0;
        v22[4] = v11;
        v22[5] = Address;
        v22[6] = a2;
        uint64_t v26 = v22;
        dyld3::MachOAnalyzer::forEachObjCClass(Address, *((void *)v5 + 2), *((unsigned int *)v5 + 11), (uint64_t)v31, (uint64_t)&v26);
      }
      if (v5[57])
      {
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000;
        v20[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_4;
        v20[3] = &__block_descriptor_tmp_36;
        v20[4] = &v30;
        void v20[5] = &v33;
        v20[6] = &v32;
        v20[7] = a2;
        int v21 = v8;
        uint64_t v26 = v20;
        dyld3::MachOAnalyzer::forEachObjCClass(Address, *((void *)v5 + 2), *((unsigned int *)v5 + 11), (uint64_t)v31, (uint64_t)&v26);
      }
      if (v5[58])
      {
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000;
        void v19[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_5;
        v19[3] = &__block_descriptor_tmp_38;
        v19[4] = &v30;
        v19[5] = &v33;
        v19[6] = &v32;
        v19[7] = a2;
        uint64_t v26 = v19;
        dyld3::MachOAnalyzer::forEachObjCCategory(v33, *((void *)v5 + 3), *((unsigned int *)v5 + 12), (uint64_t)v31, (uint64_t)&v26);
      }
      if (v5[59])
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000;
        v18[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_6;
        v18[3] = &__block_descriptor_tmp_39;
        v18[4] = &v30;
        v18[5] = &v33;
        v18[6] = &v32;
        v18[7] = a2;
        uint64_t v26 = v18;
        dyld3::MachOAnalyzer::forEachObjCProtocol(v33, *((void *)v5 + 4), *((unsigned int *)v5 + 13), (uint64_t)v31, (uint64_t)&v26);
      }
    }
  }
}

uint64_t dyld3::MachOAnalyzer::forEachObjCProtocol(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = dyld3::MachOFile::pointerSize(a1);
  uint64_t result = dyld3::MachOLoaded::getSlide(a1);
  uint64_t v12 = result;
  uint64_t v13 = (uint64_t *)((char *)a1 + a2);
  if (v10 == 8)
  {
    char v29 = 0;
    if (a3)
    {
      uint64_t v14 = a3 - 1;
      do
      {
        uint64_t v15 = v14;
        uint64_t v16 = *v13++;
        uint64_t v17 = (uint64_t *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v16) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v17);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[5]);
        uint64_t v28 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[6]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
        if (v29) {
          break;
        }
        uint64_t v14 = v15 - 1;
      }
      while (v15);
    }
  }
  else
  {
    char v29 = 0;
    if (a3)
    {
      uint64_t v18 = a3 - 1;
      do
      {
        uint64_t v19 = v18;
        unsigned int v20 = *(_DWORD *)v13;
        uint64_t v13 = (uint64_t *)((char *)v13 + 4);
        int v21 = (unsigned int *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v20) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v21);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[5]);
        uint64_t v28 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[6]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
        if (v29) {
          break;
        }
        uint64_t v18 = v19 - 1;
      }
      while (v19);
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v7 = a2;
  if (*(unsigned char *)(a1 + 18))
  {
    if (a2) {
      return a2 - *(void *)(a1 + 8);
    }
  }
  else
  {
    int v4 = *(unsigned __int16 *)(a1 + 16);
    if (*(_WORD *)(a1 + 16) && v2)
    {
      unint64_t v6 = 0;
      if (mach_o::ChainedFixupPointerOnDisk::isRebase((mach_o::ChainedFixupPointerOnDisk *)&v7, v4, *(void *)a1, &v6))return v6 + *(void *)a1; {
      else
      }
        return v7;
    }
  }
  return v2;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_6(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a3[3];
  if (v5)
  {
    uint64_t v6 = v5 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v6) & 1) == 0)
    {
      uint64_t v7 = *(dyld4::RuntimeState **)(a1 + 56);
      int v8 = (_DWORD *)(**(void **)(a1 + 48) + v6);
      uint64_t v9 = *v8 | 1;
      if (*(unsigned char *)(*((void *)v7 + 1) + 202)) {
        dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v8, v9);
      }
      *int v8 = v9;
    }
  }
  uint64_t v10 = a3[4];
  if (v10)
  {
    uint64_t v11 = v10 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v11) & 1) == 0)
    {
      uint64_t v12 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v13 = (_DWORD *)(**(void **)(a1 + 48) + v11);
      uint64_t v14 = *v13 | 1;
      if (*(unsigned char *)(*((void *)v12 + 1) + 202)) {
        dyld4::RuntimeState::log(v12, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v13, v14);
      }
      *uint64_t v13 = v14;
    }
  }
  uint64_t v15 = a3[5];
  if (v15)
  {
    uint64_t v16 = v15 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v16) & 1) == 0)
    {
      uint64_t v17 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v18 = (_DWORD *)(**(void **)(a1 + 48) + v16);
      uint64_t v19 = *v18 | 1;
      if (*(unsigned char *)(*((void *)v17 + 1) + 202)) {
        dyld4::RuntimeState::log(v17, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v18, v19);
      }
      _DWORD *v18 = v19;
    }
  }
  uint64_t v20 = a3[6];
  if (v20)
  {
    uint64_t v21 = v20 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v21) & 1) == 0)
    {
      uint64_t v22 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v23 = (_DWORD *)(**(void **)(a1 + 48) + v21);
      uint64_t v24 = *v23 | 1;
      if (*(unsigned char *)(*((void *)v22 + 1) + 202)) {
        dyld4::RuntimeState::log(v22, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v23, v24);
      }
      *uint64_t v23 = v24;
    }
  }
}

uint64_t dyld3::MachOAnalyzer::objcMethodListIsRelative(dyld3::MachOAnalyzer *this, uint64_t a2)
{
  if (a2) {
    return *(_DWORD *)((char *)this + a2) >> 31;
  }
  else {
    return 0;
  }
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1[4] + 8);
  unint64_t v3 = *(unsigned int *)(v2 + 24);
  *(_DWORD *)(v2 + 24) = v3 + 1;
  if (a1[7] <= v3) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  if (*(unsigned char *)(a1[5] + v3) == 1)
  {
    uint64_t v5 = (uint64_t *)(a1[9] + a2 - a1[8]);
    uint64_t v6 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(a1[10], (unint64_t)v5, (void *)1, 225, 2);
    uint64_t v7 = (dyld4::RuntimeState *)a1[11];
    if (*(unsigned char *)(*((void *)v7 + 1) + 202)) {
      dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <objc-protocol>\n", v5, v6);
    }
    *uint64_t v5 = v6;
  }
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(uint64_t this, unint64_t a2, void *a3, BOOL a4, int a5)
{
  if (this)
  {
    switch(a5)
    {
      case 0:
        uint64_t v5 = this;
        break;
      case 1:
        uint64_t v5 = this;
        break;
      case 2:
        uint64_t v5 = this;
        break;
      case 3:
        uint64_t v5 = this;
        break;
      default:
        mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer();
    }
    return v5;
  }
  return this;
}

void dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(dyld4::RuntimeState *a1, dyld4::Loader *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  Diagnostics::Diagnostics((Diagnostics *)&v12);
  uint64_t v10 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(a2, a1);
  metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v11, v10);
  if (Diagnostics::hasError((Diagnostics *)&v12)) {
    dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique();
  }
  dyld4::forEachSelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachClassSelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachCategorySelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachProtocolSelectorReferenceToUnique(v11, a3, a4, a5);
  mach_o::Error::~Error(&v12);
}

void dyld4::forEachProtocolSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  v6[3] = &unk_1EFF65A08;
  void v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1EFF65A30;
  v5[4] = v6;
  v5[5] = a1;
  if (*(unsigned char *)(a3 + 62))
  {
    if (*(_DWORD *)(a3 + 52))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      void v4[3] = &unk_1EFF65A58;
      v4[4] = v5;
      void v4[5] = a1;
      objc_visitor::Visitor::forEachProtocol(a1, (uint64_t)v4);
    }
  }
}

void dyld4::forEachCategorySelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  v6[3] = &unk_1EFF65990;
  void v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1EFF659B8;
  v5[4] = v6;
  v5[5] = a1;
  if (*(unsigned char *)(a3 + 61))
  {
    if (*(_DWORD *)(a3 + 48))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      void v4[3] = &unk_1EFF659E0;
      v4[4] = v5;
      void v4[5] = a1;
      objc_visitor::Visitor::forEachCategory(a1, (uint64_t)v4);
    }
  }
}

void dyld4::forEachClassSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  v6[3] = &unk_1EFF65918;
  void v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1EFF65940;
  v5[4] = v6;
  v5[5] = a1;
  if (*(unsigned char *)(a3 + 60))
  {
    if (*(_DWORD *)(a3 + 44))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      void v4[3] = &unk_1EFF65968;
      v4[4] = v5;
      void v4[5] = a1;
      objc_visitor::Visitor::forEachClassAndMetaClass(a1, (uint64_t)v4);
    }
  }
}

void dyld4::forEachSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a3 + 40))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___ZN5dyld4L32forEachSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
    void v4[3] = &unk_1EFF658F0;
    v4[4] = a4;
    void v4[5] = a2;
    objc_visitor::Visitor::forEachSelectorReference(a1, (uint64_t)v4);
  }
}

void objc_visitor::Visitor::forEachSelectorReference(unsigned int *a1, uint64_t a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  unsigned int v2[2] = ___ZNK12objc_visitor7Visitor24forEachSelectorReferenceEU13block_pointerFv9VMAddressS1_PKcE_block_invoke;
  v2[3] = &unk_1EFF65DE0;
  v2[4] = a2;
  v2[5] = a1;
  objc_visitor::Visitor::forEachSelectorReference(a1, (uint64_t)v2);
}

{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void v10[3];
  unsigned char v11[24];
  unint64_t v12;
  char v13;

  objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)"__objc_selrefs", (uint64_t)v11);
  if (v13)
  {
    int v4 = v12;
    uint64_t v5 = *a1;
    uint64_t v6 = v12 / v5;
    if (v12 % v5) {
      objc_visitor::Visitor::forEachSelectorReference();
    }
    uint64_t v7 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v11);
    if (v4 >= v5)
    {
      int v8 = v7;
      uint64_t v9 = 0;
      do
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v8 + v9 * *a1), v10);
        (*(void (**)(uint64_t, void *))(a2 + 16))(a2, v10);
        ++v9;
      }
      while (v6 != v9);
    }
  }
}

metadata_visitor::Visitor *metadata_visitor::Visitor::Visitor(metadata_visitor::Visitor *this, const dyld3::MachOAnalyzer *a2)
{
  *(_DWORD *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = dyld3::MachOFile::preferredLoadAddress(a2);
  *((unsigned char *)this + 24) = 1;
  *(_DWORD *)this = dyld3::MachOFile::pointerSize(a2);
  return this;
}

void objc_visitor::Visitor::forEachProtocol(unsigned int *a1, uint64_t a2)
{
  objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)"__objc_protolist", (uint64_t)v18);
  if (v20)
  {
    unint64_t v4 = v19;
    unint64_t v5 = *a1;
    unint64_t v6 = v19 / v5;
    if (v19 % v5) {
      objc_visitor::Visitor::forEachProtocol();
    }
    uint64_t v7 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v18);
    if (v4 >= v5)
    {
      uint64_t v8 = v7;
      uint64_t v9 = 0;
      unint64_t v10 = v6 - 1;
      do
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v8 + v9 * *a1), v17);
        metadata_visitor::Visitor::resolveRebase((uint64_t)a1, v17, &v15);
        long long v13 = v15;
        uint64_t v14 = v16;
        char v12 = 0;
        (*(void (**)(uint64_t, long long *, char *))(a2 + 16))(a2, &v13, &v12);
        if (v12) {
          break;
        }
      }
      while (v10 != v9++);
    }
  }
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3(uint64_t a1, lsl::Allocator::Pool *a2)
{
  objc_visitor::Category::getClassMethods(a2, *(int **)(a1 + 40), (uint64_t)v8);
  objc_visitor::Protocol::getClassMethods(a2, *(int **)(a1 + 40), (uint64_t)v7);
  objc_visitor::Protocol::getOptionalInstanceMethods(a2, *(int **)(a1 + 40), (uint64_t)v6);
  objc_visitor::Protocol::getOptionalClassMethods(a2, *(int **)(a1 + 40), (uint64_t)&v5);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2(uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if (result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if (result)
      {
        int v5 = result;
        for (int i = 0; i != v5; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(a1 + 40), i, (uint64_t)&v8);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16))(Method);
        }
      }
    }
  }
  return result;
}

double objc_visitor::MethodList::getMethod@<D0>(lsl::Allocator::Pool *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (!*((unsigned char *)a1 + 24)) {
    objc_visitor::MethodList::getMethod();
  }
  uint64_t v7 = (int *)lsl::Allocator::Pool::allocator(a1);
  if (!v7) {
    objc_visitor::MethodList::getMethod();
  }
  uint64_t v8 = v7;
  metadata_visitor::Visitor::getField(a2, (char *)v7 + (*v7 & 0xFFFCu) * a3 + 8, &v11);
  if (*v8 >= 0) {
    int v9 = 2;
  }
  else {
    int v9 = (*v8 >> 30) & 1;
  }
  double result = *(double *)&v11;
  *(_OWORD *)(a4 + 8) = v11;
  *(void *)(a4 + 24) = v12;
  *(_DWORD *)a4 = v9;
  return result;
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, int *a2)
{
  objc_visitor::Method::getNameVMAddr(a2, *(void *)(a1 + 40));
  char v5 = v4;
  objc_visitor::Method::getNameField(a2, *(void *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  char v7 = v6;
  objc_visitor::Method::getName(a2, *(void *)(a1 + 40));
  if (!v5 || !v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

int *objc_visitor::Method::getName(int *result, uint64_t a2)
{
  int v3 = *result;
  if (!*result)
  {
    char v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    uint64_t v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1, v9);
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    objc_visitor::Method::getNameField(result, a2, v9);
LABEL_8:
    metadata_visitor::Visitor::resolveRebase(a2, v9, v8);
    return (int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v8);
  }
  if (v3 == 1) {
    objc_visitor::Method::getName();
  }
  return result;
}

int *objc_visitor::Method::getNameField@<X0>(int *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int v4 = *result;
  if (*result == 2)
  {
    uint64_t v6 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    return (int *)metadata_visitor::Visitor::getField(a2, v6, a3);
  }
  else
  {
    if (v4 == 1) {
      objc_visitor::Method::getNameField();
    }
    if (!v4) {
      objc_visitor::Method::getNameField();
    }
  }
  return result;
}

int *objc_visitor::Method::getNameVMAddr(int *result, uint64_t a2)
{
  int v3 = *result;
  if (!*result)
  {
    int v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    uint64_t v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1, v9);
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    objc_visitor::Method::getNameField(result, a2, v9);
LABEL_8:
    metadata_visitor::Visitor::resolveRebase(a2, v9, v8);
    return (int *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v8);
  }
  if (v3 == 1) {
    objc_visitor::Method::getNameVMAddr();
  }
  return result;
}

uint64_t objc_visitor::MethodList::numMethods(objc_visitor::MethodList *this)
{
  if (!*((unsigned char *)this + 24)) {
    return 0;
  }
  uint64_t v1 = lsl::Allocator::Pool::allocator(this);
  if (!v1) {
    objc_visitor::MethodList::numMethods();
  }
  return *(unsigned int *)(v1 + 4);
}

uint64_t objc_visitor::MethodList::usesRelativeOffsets(objc_visitor::MethodList *this)
{
  if (!*((unsigned char *)this + 24)) {
    return 0;
  }
  uint64_t v1 = (_DWORD *)lsl::Allocator::Pool::allocator(this);
  if (!v1) {
    objc_visitor::MethodList::usesRelativeOffsets();
  }
  return *v1 >> 31;
}

uint64_t objc_visitor::Protocol::getOptionalInstanceMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 20);
  }
  else {
    char v7 = (char *)(v6 + 40);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t metadata_visitor::Visitor::resolveOptionalRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = **a2;
  if (v3)
  {
    if (!*(unsigned char *)(this + 24)) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v4 = v3 - *(void *)(this + 8) + *(void *)(this + 16);
    *(void *)a3 = v3;
    *(void *)(a3 + 8) = v4;
    LOBYTE(v3) = 1;
    *(void *)(a3 + 16) = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 24) = v3;
  return this;
}

uint64_t objc_visitor::Category::getClassMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 12);
  }
  else {
    char v7 = (char *)(v6 + 24);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getOptionalClassMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 24);
  }
  else {
    char v7 = (char *)(v6 + 48);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getClassMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 16);
  }
  else {
    char v7 = (char *)(v6 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

void objc_visitor::MethodList::getMethod()
{
}

{
  __assert_rtn("getMethod", "ObjCVisitor.cpp", 1053, "methodList != nullptr");
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  if (!a1) {
    abort_report_np("Assertion failed: (%s), file %s, line %d.\n", a4, a2, a3);
  }
  abort_report_np("Assertion failed: (%s), function %s, file %s, line %d.\n", a4, a1, a2, a3);
}

uint64_t metadata_visitor::Visitor::getField@<X0>(uint64_t this@<X0>, char *a2@<X2>, void *a3@<X8>)
{
  if (!*(unsigned char *)(this + 24)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v4 = &a2[*(void *)(this + 16) - *(void *)(this + 8)];
  *a3 = a2;
  a3[1] = v4;
  a3[2] = 1;
  return this;
}

uint64_t ___ZNK12objc_visitor7Visitor24forEachSelectorReferenceEU13block_pointerFv9VMAddressS1_PKcE_block_invoke(uint64_t a1, uint64_t **a2)
{
  metadata_visitor::Visitor::resolveRebase(*(void *)(a1 + 40), a2, v5);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)a2);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v5);
  lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v5);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t lsl::Allocator::Pool::allocator(lsl::Allocator::Pool *this)
{
  return *(void *)this;
}

uint64_t metadata_visitor::ResolvedValue::vmAddress(metadata_visitor::ResolvedValue *this)
{
  return *((void *)this + 1);
}

uint64_t metadata_visitor::Visitor::resolveRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = **a2;
  if (v3)
  {
    if (!*(unsigned char *)(this + 24)) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v4 = v3 - *(void *)(this + 8) + *(void *)(this + 16);
    *a3 = v3;
    a3[1] = v4;
    a3[2] = 1;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  return this;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v3 = *(unsigned int *)(v2 + 24);
  *(_DWORD *)(v2 + 24) = v3 + 1;
  if (*(void *)(a1 + 56) <= v3) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v6 = (dyld4::PrebuiltLoader::BindTargetRef *)(*(void *)(a1 + 40) + 8 * v3);
  unint64_t v7 = *(void *)v6;
  if ((*(void *)v6 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (v7 >> 8) | 0x80000000000000;
    if ((v7 & 0x4000000000000000) == 0) {
      uint64_t v9 = (v7 >> 8) & 0x7FFFFFFFFFFFFFLL;
    }
    uint64_t v8 = (const char *)(*(void *)(a1 + 64) + (v9 | (v7 << 56)));
  }
  else
  {
    uint64_t v8 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(v6, *(dyld4::RuntimeState **)(a1 + 72));
  }
  unint64_t v10 = *(dyld4::RuntimeState **)(a1 + 72);
  long long v11 = (const char **)(*(void *)(a1 + 80) + a2);
  if (*(unsigned char *)(*((void *)v10 + 1) + 202)) {
    dyld4::RuntimeState::log(v10, "fixup: *0x%012lX = 0x%012lX <objc-selector '%s'>\n", v11, v8, v8);
  }
  *long long v11 = v8;
}

uint64_t ___ZN5dyld4L32forEachSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, uint64_t a2, char a3, uint64_t a4, char a5)
{
  if (!a3 || !a5) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  int v5 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v5();
}

void std::__throw_bad_optional_access[abi:nn180100]()
{
}

void objc_visitor::Visitor::findSection(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = *(_DWORD **)(a1 + 8);
  uint64_t v10 = 0;
  long long v11 = &v10;
  uint64_t v12 = 0x5002000000;
  long long v13 = __Block_byref_object_copy__11;
  uint64_t v14 = __Block_byref_object_dispose__11;
  char v15 = 0;
  char v16 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unsigned int v9[2] = ___ZNK12objc_visitor7Visitor11findSectionENSt3__14spanIPKcLm18446744073709551615EEES4__block_invoke;
  void v9[3] = &unk_1EFF65D68;
  v9[6] = a2;
  void v9[7] = a3;
  v9[8] = a4;
  v9[4] = &v10;
  v9[5] = a1;
  dyld3::MachOFile::forEachSection(v6, (uint64_t)v9);
  unint64_t v7 = v11;
  long long v8 = *(_OWORD *)(v11 + 7);
  *(_OWORD *)a5 = *(_OWORD *)(v11 + 5);
  *(_OWORD *)(a5 + 16) = v8;
  *(void *)(a5 + 32) = v7[9];
  _Block_object_dispose(&v10, 8);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

uint64_t dyld4::APIs::_dyld_dlsym_blocked(dyld4::APIs *this)
{
  return *(unsigned __int8 *)(*((void *)this + 1) + 170);
}

uint64_t dyld4::APIs::NSVersionOfLinkTimeLibrary(dyld4::Loader **this, const char *a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = -1;
  uint64_t Address = (dyld3::MachOFile *)dyld4::Loader::loadAddress(this[3], (const dyld4::RuntimeState *)this);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs26NSVersionOfLinkTimeLibraryEPKc_block_invoke;
  v7[3] = &unk_1EFF650E8;
  v7[4] = &v8;
  v7[5] = a2;
  dyld3::MachOFile::forEachDependentDylib(Address, (uint64_t)v7);
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "NSVersionOfLinkTimeLibrary(%s) =>0x%08X\n", a2, *((_DWORD *)v9 + 6));
  }
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void dyld3::MachOFile::forEachDependentDylib(dyld3::MachOFile *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  uint64_t v12 = 0;
  long long v13 = &v12;
  uint64_t v14 = 0x2000000000;
  int v15 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld39MachOFile21forEachDependentDylibEU13block_pointerFvPKcbbbjjRbE_block_invoke;
  v7[3] = &unk_1EFF66210;
  v7[4] = a2;
  v7[5] = &v12;
  void v7[6] = &v8;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v16, (uint64_t)v7);
  if (!*((_DWORD *)v13 + 6) && !*((unsigned char *)v9 + 24))
  {
    if (dyld3::MachOFile::builtForPlatform(a1, 10, 1))
    {
      if (*((_DWORD *)a1 + 3) != 6
        || ((*(void *)uint64_t v17 = 0,
             uint64_t v18 = 0,
             !dyld3::MachOFile::getDylibInstallName(a1, (const char **)&v18, &v17[1], v17))
          ? (uint64_t v4 = 0)
          : (uint64_t v4 = v18),
            _platform_strncmp(v4, "/System/DriverKit/usr/lib/system/", 0x21uLL)))
      {
        uint64_t v5 = "/System/DriverKit/usr/lib/libSystem.B.dylib";
LABEL_10:
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, uint64_t, uint64_t *))(a2 + 16))(a2, v5, 0, 0, 0, 0x10000, 0x10000, v9 + 3);
      }
    }
    else if (!dyld3::MachOFile::builtForPlatform(a1, 16, 1) {
           && !dyld3::MachOFile::builtForPlatform(a1, 18, 1)
    }
           && !dyld3::MachOFile::builtForPlatform(a1, 20, 1))
    {
      if (*((_DWORD *)a1 + 3) != 6
        || (uint64_t v6 = dyld3::MachOFile::installName(a1), _platform_strncmp(v6, "/usr/lib/system/", 0x10uLL)))
      {
        uint64_t v5 = "/usr/lib/libSystem.B.dylib";
        goto LABEL_10;
      }
    }
  }
  Diagnostics::assertNoError((Diagnostics *)&v16);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  mach_o::Error::~Error(&v16);
}

unint64_t *dyld4::RuntimeState::addPermanentRanges(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double result = dyld4::RuntimeState::PermanentRanges::make((lsl::Lock ***)a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(atomic_ullong **)(a1 + 1024);
  if (v10)
  {
    for (int i = (atomic_ullong *)atomic_load_explicit(v10, memory_order_acquire);
          i;
          int i = (atomic_ullong *)atomic_load_explicit(i, memory_order_acquire))
    {
      uint64_t v10 = i;
    }
    atomic_store((unint64_t)result, (unint64_t *)v10);
  }
  else
  {
    *(void *)(a1 + 1024) = result;
  }
  return result;
}

unint64_t *dyld4::RuntimeState::PermanentRanges::make(lsl::Lock ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, v26);
  uint64_t v31 = 0;
  long long v32 = &v31;
  uint64_t v33 = 0x5002000000;
  uint64_t v34 = __Block_byref_object_copy__0;
  uint64_t v11 = 8 * v10;
  uint64_t v35 = __Block_byref_object_dispose__0;
  uint64_t v36 = (char *)&v27[-1] - v12;
  uint64_t v37 = 8 * v10;
  uint64_t v38 = 0;
  vm_address_t v39 = 0;
  vm_size_t v40 = 0;
  if (v10)
  {
    long long v13 = *v9;
    do
    {
      uint64_t v14 = *v13++;
      uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(v14, (const dyld4::RuntimeState *)a1);
      uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
      v30[0] = 0;
      v30[1] = v30;
      v30[2] = 0x2000000000;
      v30[3] = 0;
      v28[0] = 0;
      v28[1] = v28;
      v28[2] = 0x2000000000;
      char v29 = 0;
      uint64_t v17 = (_DWORD *)dyld4::Loader::loadAddress(v14, (const dyld4::RuntimeState *)a1);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 0x40000000;
      v27[2] = ___ZN5dyld412RuntimeState15PermanentRanges4makeERS0_RKN5dyld35ArrayIPKNS_6LoaderEEE_block_invoke;
      v27[3] = &unk_1EFF641E8;
      v27[4] = v30;
      v27[5] = v28;
      v27[7] = Slide;
      v27[6] = &v31;
      v27[8] = v14;
      dyld3::MachOFile::forEachSegment(v17, (uint64_t)v27);
      _Block_object_dispose(v28, 8);
      _Block_object_dispose(v30, 8);
      v11 -= 8;
    }
    while (v11);
    unint64_t v18 = *((unsigned int *)v32 + 14);
  }
  else
  {
    unint64_t v18 = 0;
  }
  unint64_t v19 = lsl::Allocator::malloc(a1[2], (32 * v18) | 0x10);
  char v20 = v19;
  atomic_store(0, v19);
  v19[1] = v18;
  if (v18)
  {
    unint64_t v21 = 0;
    uint64_t v22 = v19 + 2;
    do
    {
      uint64_t v23 = (_OWORD *)dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v32 + 5, v21);
      long long v24 = v23[1];
      _OWORD *v22 = *v23;
      v22[1] = v24;
      v22 += 2;
      ++v21;
    }
    while (v18 != v21);
  }
  _Block_object_dispose(&v31, 8);
  uint64_t v38 = 0;
  if (v39) {
    vm_deallocate(mach_task_self_, v39, v40);
  }
  return v20;
}

void *dyld4::RuntimeState::_instantiateTLVs(dyld4::RuntimeState *this, uint64_t a2)
{
  uint64_t v12 = 0;
  long long v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  uint64_t v4 = (uint64_t *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld412RuntimeState16_instantiateTLVsEm_block_invoke;
  v7[3] = &unk_1EFF64428;
  void v7[6] = this;
  void v7[7] = a2;
  v7[4] = &v12;
  v7[5] = &v8;
  dyld4::RuntimeLocks::withTLVLock(v4, (uint64_t)v7);
  if (v13[3])
  {
    uint64_t v5 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 8))(*((void *)this + 19), v9[3]);
    memmove(v5, (const void *)v13[3], v9[3]);
    (*(void (**)(void, uint64_t, void *))(**((void **)this + 19) + 72))(*((void *)this + 19), a2, v5);
  }
  else
  {
    uint64_t v5 = 0;
  }
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  return v5;
}

BOOL dyld4::APIs::_dyld_has_preoptimized_swift_protocol_conformances(dyld4::APIs *this, mach_header *a2)
{
  BOOL result = dyld3::MachOAnalyzer::hasSwift((dyld3::MachOAnalyzer *)a2);
  if (result)
  {
    uint64_t v5 = *((void *)this + 124);
    if (!v5) {
      return 0;
    }
    BOOL result = dyld4::PrebuiltLoaderSet::hasOptimizedSwift(*((dyld4::PrebuiltLoaderSet **)this + 124));
    if (!result) {
      return result;
    }
    uint64_t v6 = *(unsigned int *)(v5 + 12);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = v6 - 1;
      do
      {
        if (*(_DWORD *)(v5 + 12) <= (unsigned __int16)v7) {
          dyld4::RuntimeState::findPrebuiltLoader();
        }
        BOOL v9 = dyld4::Loader::analyzer((dyld4::Loader *)(v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4 * (unsigned __int16)v7)), this) == (void)a2;
        BOOL result = v9;
        BOOL v9 = v9 || v8 == v7++;
      }
      while (!v9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL dyld3::MachOAnalyzer::hasSwift(dyld3::MachOAnalyzer *this)
{
  BOOL v2 = 0;
  dyld3::MachOAnalyzer::hasSwiftOrObjC(this, &v2);
  return v2;
}

BOOL dyld3::MachOAnalyzer::neverUnload(dyld3::MachOAnalyzer *this)
{
  BOOL v10 = 0;
  if (dyld3::MachOAnalyzer::hasSwiftOrObjC(this, &v10) && (v10 || !dyld3::MachOFile::isBundle(this))
    || (dyld3::MachOFile::hasThreadLocalVariables(this) & 1) != 0)
  {
    return 1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer11neverUnloadEv_block_invoke;
  void v4[3] = &unk_1EFF66D68;
  v4[4] = &v6;
  dyld3::MachOFile::forEachDOFSection(this, (uint64_t)&v5, (uint64_t)v4);
  BOOL v2 = Diagnostics::noError((Diagnostics *)&v5) && *((unsigned char *)v7 + 24);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t dyld3::MachOAnalyzer::hasSwiftOrObjC(dyld3::MachOAnalyzer *this, BOOL *a2)
{
  if (a2) {
    *a2 = 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer14hasSwiftOrObjCEPb_block_invoke;
  void v5[3] = &unk_1EFF66D40;
  void v5[6] = a2;
  void v5[7] = dyld3::MachOLoaded::getSlide(this);
  v5[4] = &v6;
  v5[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void dyld3::MachOFile::forEachDOFSection(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile17forEachDOFSectionER11DiagnosticsU13block_pointerFvjE_block_invoke;
  v3[3] = &unk_1EFF66610;
  void v3[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v3);
}

double dyld4::RuntimeState::initialize(dyld4::RuntimeState *this)
{
  (*(void (**)(void, char *))(**((void **)this + 19) + 48))(*((void *)this + 19), (char *)this + 1120);
  (*(void (**)(void, char *))(**((void **)this + 19) + 56))(*((void *)this + 19), (char *)this + 1112);
  uint64_t v2 = *((void *)this + 6);
  if (v2)
  {
    uint64_t v3 = (dyld4::Loader **)*((void *)this + 5);
    uint64_t v4 = 8 * v2;
    uint64_t v5 = v3;
    do
    {
      if ((*((_WORD *)*v5 + 2) & 0x1000) != 0)
      {
        uint64_t v6 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*v5, this);
        dyld4::RuntimeState::setUpTLVs(this, v6);
      }
      ++v5;
      ++v3;
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v7 = (__n128 *)*((void *)this + 16);
  uint64_t v8 = *((void *)this + 17) + 40;
  v10.n128_u64[0] = (unint64_t)this;
  v10.n128_u64[1] = v8;
  *(void *)&double result = lsl::MemoryManager::adoptLock(v7, &v10).n128_u64[0];
  return result;
}

void dyld4::RuntimeState::setUpTLVs(dyld4::RuntimeState *this, const dyld3::MachOAnalyzer *a2)
{
  uint64_t v17 = 0;
  unint64_t v18 = &v17;
  uint64_t v19 = 0x4002000000;
  char v20 = __Block_byref_object_copy__102;
  unint64_t v21 = __Block_byref_object_dispose__103;
  uint64_t v22 = a2;
  int v23 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 19) + 144))(*((void *)this + 19));
  BOOL v5 = 0;
  uint64_t v6 = *((void *)this + 1);
  unint64_t v7 = *(void *)(v6 + 240);
  if (v7) {
    BOOL v8 = v7 >= (unint64_t)a2;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    BOOL v5 = v7 + DyldSharedCache::mappedSize(*(DyldSharedCache **)(v6 + 240)) > (unint64_t)a2;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke;
  v14[3] = &unk_1EFF643D8;
  BOOL v15 = v5;
  v14[4] = &v17;
  void v14[5] = this;
  v14[6] = v4;
  v14[7] = v4;
  int v9 = dyld3::MachOAnalyzer::forEachThreadLocalVariable(a2, (uint64_t)&v16, (uint64_t)v14);
  __n128 v10 = v18;
  *((_DWORD *)v18 + 13) = v9;
  *((_DWORD *)v10 + 14) = v11;
  uint64_t v12 = (uint64_t *)*((void *)this + 17);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke_2;
  v13[3] = &unk_1EFF64400;
  void v13[4] = &v17;
  v13[5] = this;
  dyld4::RuntimeLocks::withTLVLock(v12, (uint64_t)v13);
  mach_o::Error::~Error(&v16);
  _Block_object_dispose(&v17, 8);
}

uint64_t dyld4::RuntimeLocks::withTLVLock(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (v4)
  {
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v4 + 104))(v4, a1 + 3, 0);
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    BOOL v5 = *(uint64_t (**)(void))(*(void *)*a1 + 112);
    return v5();
  }
  else
  {
    unint64_t v7 = *(uint64_t (**)(uint64_t))(a2 + 16);
    return v7(a2);
  }
}

__n128 ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v1 + 832, *(void *)(v1 + 848) + 1);
  uint64_t v3 = *(void *)(v1 + 840);
  uint64_t v4 = *(void *)(v1 + 848);
  *(void *)(v1 + 848) = v4 + 1;
  BOOL v5 = (__n128 *)(v3 + 24 * v4);
  __n128 result = *(__n128 *)(v2 + 40);
  v5[1].n128_u64[0] = *(void *)(v2 + 56);
  *BOOL v5 = result;
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariable(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  __n128 v10 = &v9;
  uint64_t v11 = 0x3802000000;
  uint64_t v12 = __Block_byref_object_copy__255;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  long long v13 = __Block_byref_object_dispose__256;
  if (dyld3::MachOFile::hasThreadLocalVariables(a1))
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = ___ZNK5dyld313MachOAnalyzer26forEachThreadLocalVariableER11DiagnosticsU13block_pointerFvPU9__ptrauthILj0ELb0ELj0EEPFPvPNS0_9TLV_ThunkEEPmE_block_invoke;
    void v8[3] = &unk_1EFF66E58;
    void v8[6] = a1;
    void v8[7] = a2;
    v8[4] = a3;
    v8[5] = &v9;
    void v8[8] = dyld3::MachOFile::preferredLoadAddress(a1);
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v8);
  }
  uint64_t v6 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t dyld3::MachOFile::hasThreadLocalVariables(dyld3::MachOFile *this)
{
  return *((unsigned __int8 *)this + 26) >> 7;
}

void dyld4::ExternallyViewableState::addImages(uint64_t a1, lsl::Lock **a2, lsl::Lock **a3, uint64_t *a4)
{
  uint64_t v49 = a2;
  uint64_t v51 = a3;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  os_unfair_lock_t v48 = (os_unfair_lock_t)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a3);
  uint64_t v50 = a4;
  uint64_t v8 = a4[1];
  if (v8)
  {
    uint64_t v9 = *v50;
    uint64_t v10 = 40 * v8;
    do
    {
      int v11 = *(unsigned __int8 *)(v9 + 32);
      uint64_t v12 = *(const mach_header **)(v9 + 16);
      long long v13 = *(const mach_header **)(v9 + 24);
      lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)&v51, v53 + 1);
      uint64_t v14 = v53++;
      uint64_t v15 = (const mach_header **)(v52 + 24 * v14);
      *uint64_t v15 = v13;
      v15[1] = v12;
      v15[2] = 0;
      if (v11)
      {
        if (*(void *)dyld4::Atlas::ProcessSnapshot::sharedCache(*(dyld4::Atlas::ProcessSnapshot **)a1)) {
          dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(*(void *)a1, v13);
        }
      }
      else
      {
        dyld4::ExternallyViewableState::addImageUUID((dyld4::ExternallyViewableState *)a1, (const dyld3::MachOFile *)v13);
        dyld4::recordFromInfo(a3, *(dyld4::FileManager **)(a1 + 8), v9, (uint64_t)v62);
        char v16 = (atomic_uint **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
        dyld4::Atlas::Image::Image((uint64_t)&v55, (uint64_t)a3, (dyld4::FileRecord *)v62, v16, (uint64_t)v13);
        dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Lock ****)a1, (dyld4::Atlas::Image *)&v55);
        uint64_t v17 = v60;
        if (v60 && v61) {
          dyld4::Atlas::Mapper::unmap(v58, (unint64_t)v60, v59);
        }
        if (v57) {
          lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v57, v17);
        }
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v56);
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v62);
      }
      v9 += 40;
      v10 -= 40;
    }
    while (v10);
  }
  dyld4::ExternallyViewableState::commit((const os_unfair_lock *)a1, *(dyld4::Atlas::ProcessSnapshot **)a1, v49, v7);
  dyld4::ExternallyViewableState::release((const os_unfair_lock *)a1, (lsl::Allocator *)a3);
  uint64_t v18 = mach_absolute_time();
  uint64_t v19 = dyld4::ExternallyViewableState::addImagesOld(a1, (uint64_t)&v51, v18);
  if (*(_DWORD *)(*(void *)(a1 + 24) + 200) == 1229016646)
  {
    __chkstk_darwin(v19, v20, v21, v22, v23, v24, v25, v26, v47);
    __chkstk_darwin(v29, v30, *(void *)(v28 + 8), v31, (uint64_t)&v47 - ((v27 + 23) & 0xFFFFFFFFFFFFFFF0), v32, v33, v34, v47);
    uint64_t v42 = (const mach_header **)((char *)&v47 - ((v41 + 23) & 0xFFFFFFFFFFFFFFF0));
    if (!v35) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    uint64_t v43 = 0;
    uint64_t v44 = (const mach_header **)(*v40 + 24);
    uint64_t v45 = 40 * v35;
    do
    {
      if (v35 == v43) {
        ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
      }
      v36[v43] = (const char *)*(v44 - 1);
      uint64_t v46 = *v44;
      v44 += 5;
      v42[v43++] = v46;
      v45 -= 40;
    }
    while (v45);
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges((dyld4::ExternallyViewableState *)a1, 0, v35, v42, v36, v37, v38, v39);
  }
  os_unfair_lock_unlock(v48);
  if (v52) {
    lsl::Vector<dyld_image_info>::resize((const os_unfair_lock *)&v51, 0);
  }
}

uint64_t lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<dyld4::RuntimeState::MissingFlatSymbol>::reserveExact(result, v2);
  }
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::sharedCache(dyld4::Atlas::ProcessSnapshot *this)
{
  return (uint64_t)this + 64;
}

uint64_t dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(uint64_t this, const mach_header *a2)
{
  unint64_t v2 = *(char **)(*(void *)(this + 64) + 160);
  uint64_t v3 = *((void *)v2 + 18);
  unint64_t v4 = &v2[*((void *)v2 + 17)];
  if (v3)
  {
    BOOL v5 = (char *)((char *)a2 - v2 + *((void *)v2 + 28));
    uint64_t v6 = 32 * v3;
    unint64_t v7 = &v2[*((void *)v2 + 17)];
    while (*((char **)v7 + 2) != v5)
    {
      v7 += 32;
      v6 -= 32;
      if (!v6) {
        goto LABEL_5;
      }
    }
  }
  else
  {
    unint64_t v7 = &v2[*((void *)v2 + 17)];
  }
  if (v7 == &v4[32 * v3]) {
LABEL_5:
  }
    dyld4::Atlas::ProcessSnapshot::addSharedCacheImage();
  *(unsigned char *)(*(void *)(*(void *)(this + 56) + 8) + ((unint64_t)((v7 - v4) >> 5) >> 3)) |= 1 << (((v7 - v4) >> 5) & 7);
  return this;
}

uint64_t lsl::Vector<dyld4::RuntimeState::MissingFlatSymbol>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    __n128 result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 24 * a2);
    if ((result & 1) == 0)
    {
      __n128 result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 24 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0;
        for (unint64_t i = 0; i < v5; ++i)
        {
          uint64_t v8 = result + v6;
          uint64_t v9 = (long long *)(*(void *)(v3 + 8) + v6);
          long long v10 = *v9;
          *(void *)(v8 + 16) = *((void *)v9 + 2);
          *(_OWORD *)uint64_t v8 = v10;
          unint64_t v5 = *(void *)(v3 + 16);
          v6 += 24;
        }
      }
      int v11 = *(void **)(v3 + 8);
      if (v11)
      {
        __n128 result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v11);
        unint64_t v5 = *(void *)(v3 + 16);
      }
      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }
    *(void *)(v3 + 24) = a2;
  }
  return result;
}

uint64_t lldb_image_notifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v8 = (uint64_t *)a3;
  unsigned int v9 = a2;
  int v26 = 520552492;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v33 = 0;
  started = dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v26, a2, a3, a4, a5, a6, a7, a8);
  __chkstk_darwin((uint64_t)started, v9, v12, v13, v14, v15, v16, v17, v25);
  uint64_t v20 = (char *)&v25 - v19;
  if (v9)
  {
    uint64_t v21 = v18;
    uint64_t v22 = v20;
    do
    {
      uint64_t v23 = *v8;
      v8 += 3;
      *v22++ = v23;
      --v21;
    }
    while (v21);
  }
  if (a1 <= 3 && a1 != 2) {
    _dyld_debugger_notification(a1);
  }
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v26);
}

const os_unfair_lock *dyld4::ExternallyViewableState::commit(const os_unfair_lock *this, dyld4::Atlas::ProcessSnapshot *a2, lsl::Lock **a3, lsl::Allocator *a4)
{
  if (!a2) {
    return this;
  }
  uint64_t v5 = (uint64_t)this;
  dyld4::Atlas::ProcessSnapshot::serialize(a2, &v39);
  _X2 = v40;
  unint64_t v7 = v41;
  uint64_t v8 = *(void *)(v5 + 24);
  _X20 = *(void **)(v8 + 304);
  long long v10 = _X20;
  do
  {
    _X5 = *(void *)(v8 + 312);
    __asm { CASP            X4, X5, X2, X3, [X8] }
    _ZF = _X4 == v10;
    long long v10 = _X4;
  }
  while (!_ZF);
  if (!_X20) {
    goto LABEL_11;
  }
  if ((lsl::Allocator::owned((lsl::Allocator *)a3, (unint64_t)_X20, 8) & 1) == 0)
  {
    unint64_t v7 = v41;
LABEL_11:
    uint64_t v24 = a3;
    unint64_t v23 = v7;
    goto LABEL_12;
  }
  unint64_t v17 = lsl::Allocator::size((lsl::Allocator *)a3, _X20);
  size_t v22 = v41;
  if (v17 < v41)
  {
    if (lsl::Allocator::realloc(a3, _X20, v41))
    {
LABEL_13:
      size_t v22 = v41;
      goto LABEL_14;
    }
    lsl::Allocator::free(a3, _X20);
    unint64_t v23 = v41;
    uint64_t v24 = a3;
LABEL_12:
    _X20 = lsl::Allocator::malloc(v24, v23);
    goto LABEL_13;
  }
LABEL_14:
  if (v22) {
    memmove(_X20, v40, v22);
  }
  uint64_t v25 = *(void *)(v5 + 24);
  uint64_t v26 = *(void *)(v25 + 304);
  uint64_t v27 = *(void *)(v25 + 312);
  do
  {
    _X3 = *(void *)(v25 + 312);
    __asm { CASP            X2, X3, X20, X21, [X8] }
    _ZF = _X2 == v26;
    uint64_t v26 = _X2;
  }
  while (!_ZF);
  int v31 = 520552496;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v38 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v31, v27, _X2, v27, v18, v19, v20, v21);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v30, *(_DWORD *)(*(void *)(v5 + 24) + 200));
  dyld4::RemoteNotificationResponder::blockOnSynchronousEvent((dyld4::RemoteNotificationResponder *)v30, 0);
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v30);
  this = (const os_unfair_lock *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v31);
  if (v40) {
    return lsl::Vector<std::byte>::resize((const os_unfair_lock *)&v39, 0);
  }
  return this;
}

const os_unfair_lock *dyld4::Atlas::ProcessSnapshot::serialize@<X0>(dyld4::Atlas::ProcessSnapshot *this@<X0>, lsl::Lock ***a2@<X8>)
{
  uint64_t v3 = this;
  uint64_t v5 = (char *)this + 16;
  uint64_t v6 = (char *)this + 64;
  unint64_t v7 = (char *)this + 56;
  int v24 = -1491447450;
  long long v4 = *(_OWORD *)this;
  uint64_t v8 = v4;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  uint64_t v12 = v4;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v16 = v4;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t v20 = v4;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v26 = 0;
  uint64_t v25 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  long long v30 = (char *)this + 80;
  int v31 = (char *)this + 88;
  long long v32 = (char *)this + 96;
  __n128 result = dyld4::Atlas::ProcessSnapshot::Serializer::serialize((dyld4::Atlas::ProcessSnapshot::Serializer *)&v3, a2);
  if (v21) {
    __n128 result = lsl::Vector<unsigned int>::resize((const os_unfair_lock *)&v20, 0);
  }
  if (v17) {
    __n128 result = lsl::Vector<std::byte>::resize((const os_unfair_lock *)&v16, 0);
  }
  if (v13) {
    __n128 result = lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v12, 0);
  }
  if (v9) {
    return lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((const os_unfair_lock *)&v8, 0);
  }
  return result;
}

const os_unfair_lock *lsl::Vector<std::byte>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._os_unfair_lock_opaque = a2;
      *(void *)&result[6]._os_unfair_lock_opaque = a2;
      uint64_t v3 = *(void **)&result[2]._os_unfair_lock_opaque;
      long long v4 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v4, v3, a2);
    }
    else
    {
      uint64_t v6 = result + 2;
      uint64_t v5 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v5) {
        __n128 result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v5);
      }
      *(void *)&v6->_os_unfair_lock_opaque = 0;
      *(void *)&v6[2]._os_unfair_lock_opaque = 0;
      *(void *)&v6[4]._os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<std::byte>::reserve((uint64_t)result, a2);
  }
  return result;
}

void dyld4::RemoteNotificationResponder::~RemoteNotificationResponder(dyld4::RemoteNotificationResponder *this)
{
  if (*((_DWORD *)this + 10))
  {
    unint64_t v2 = 0;
    do
      mach_port_deallocate(mach_task_self_, *(_DWORD *)(*((void *)this + 4) + 4 * v2++));
    while (v2 < *((unsigned int *)this + 10));
    vm_size_t v3 = *((void *)this + 6);
    if (v3) {
      vm_deallocate(mach_task_self_, *((void *)this + 4), v3);
    }
  }
}

mach_port_name_array_t dyld4::RemoteNotificationResponder::RemoteNotificationResponder(mach_port_name_array_t names_addr, int a2)
{
  kern_return_t v5;
  mach_port_name_t v6;
  vm_size_t v7;

  *(_OWORD *)names_addr = 0u;
  *((_OWORD *)names_addr + 1) = 0u;
  *((void *)names_addr + 4) = names_addr;
  names_addr[10] = 8;
  vm_size_t v3 = names_addr + 10;
  *((void *)names_addr + 6) = 0;
  if (a2 != 1229016646) {
    goto LABEL_10;
  }
  long long v4 = (mach_port_name_array_t *)(names_addr + 8);
  uint64_t v5 = task_dyld_process_info_notify_get(names_addr, names_addr + 10);
  while (v5 == 3)
  {
    uint64_t v6 = 2 * names_addr[10];
    if (v6 <= 0x10) {
      uint64_t v6 = 16;
    }
    names_addr[10] = v6;
    unint64_t v7 = 4 * v6;
    *((void *)names_addr + 6) = v7;
    if (vm_allocate(mach_task_self_, (vm_address_t *)names_addr + 4, v7, 1)) {
      goto LABEL_10;
    }
    uint64_t v5 = task_dyld_process_info_notify_get(*v4, v3);
    if (v5)
    {
      vm_deallocate(mach_task_self_, *((void *)names_addr + 4), *((void *)names_addr + 6));
      *((void *)names_addr + 6) = 0;
    }
  }
  if (v5) {
LABEL_10:
  }
    natural_t *v3 = 0;
  return names_addr;
}

uint64_t dyld4::RemoteNotificationResponder::blockOnSynchronousEvent(dyld4::RemoteNotificationResponder *this, int a2)
{
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, a2 + 0x4000, 0x18u, &v3);
}

uint64_t dyld4::RemoteNotificationResponder::sendMessage(uint64_t this, mach_msg_id_t a2, mach_msg_size_t a3, mach_msg_header_t *a4)
{
  if (*(_DWORD *)(this + 40))
  {
    uint64_t v7 = this;
    mach_port_name_t name = 0;
    *(_OWORD *)&options.flags = xmmword_1A8E70938;
    options.reserved[1] = 0;
    this = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)&name, &name);
    if (!this)
    {
      unint64_t v8 = *(unsigned int *)(v7 + 40);
      if (v8)
      {
        for (unint64_t i = 0; i < v8; ++i)
        {
          uint64_t v10 = *(void *)(v7 + 32);
          if (*(_DWORD *)(v10 + 4 * i))
          {
            a4->msgh_bits = 5395;
            a4->msgh_id = a2;
            mach_port_name_t v11 = name;
            a4->msgh_local_port = name;
            mach_port_t v12 = *(_DWORD *)(v10 + 4 * i);
            a4->msgh_voucher_port = 0;
            a4->msgh_vm_size_t size = a3;
            a4->msgh_remote_port = v12;
            if (mach_msg_overwrite(a4, 3, a3, 0x5Cu, v11, 0, 0, &rcv_msg, 0))
            {
              mach_msg_destroy(a4);
              *(_DWORD *)(*(void *)(v7 + 32) + 4 * i) = 0;
            }
            unint64_t v8 = *(unsigned int *)(v7 + 40);
          }
        }
      }
      return mach_port_destruct(mach_task_self_, name, 0, (mach_port_context_t)&name);
    }
  }
  return this;
}

const os_unfair_lock *lsl::Vector<unsigned int>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._os_unfair_lock_opaque = a2;
      *(void *)&result[6]._os_unfair_lock_opaque = a2;
      unint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
      mach_msg_header_t v3 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v3, v2, 4 * a2);
    }
    else
    {
      uint64_t v5 = result + 2;
      long long v4 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v4) {
        __n128 result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v4);
      }
      *(void *)&v5->_os_unfair_lock_opaque = 0;
      *(void *)&v5[2]._os_unfair_lock_opaque = 0;
      *(void *)&v5[4]._os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<unsigned int>::reserve((uint64_t)result, a2);
  }
  return result;
}

uint64_t *dyld4::ExternallyViewableState::ensureSnapshot(uint64_t *this, lsl::Lock **a2)
{
  if (!*this)
  {
    mach_msg_header_t v3 = this;
    uint64_t v4 = this[3];
    uint64_t v5 = *(void *)(v4 + 304);
    uint64_t v6 = *(void *)(v4 + 312);
    uint64_t v7 = this[1];
    unint64_t v8 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x70uLL);
    uint64_t v10 = 0;
    uint64_t *v3 = dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(v8, a2, v7, 1, v5, v6);
    lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(&v10, v9);
    return (uint64_t *)dyld4::Atlas::ProcessSnapshot::setDyldState(*v3, 80);
  }
  return this;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setDyldState(uint64_t this, uint64_t a2)
{
  *(void *)(this + 96) = a2;
  return this;
}

const os_unfair_lock **lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(const os_unfair_lock **a1, void *a2)
{
  mach_msg_header_t v3 = *a1;
  if (*a1)
  {
    uint64_t v4 = *(os_unfair_lock **)&v3[18]._os_unfair_lock_opaque;
    if (v4) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, a2);
    }
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((const os_unfair_lock **)&v3[16], a2);
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v3[14], v5);
    uint64_t v7 = *(void *)&v3[4]._os_unfair_lock_opaque;
    if (v7)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(v7, *(lsl::Lock ***)&v3[6]._os_unfair_lock_opaque);
      *(void *)&v3[4]._os_unfair_lock_opaque = 0;
    }
    *(void *)&v3[10]._os_unfair_lock_opaque = 0;
    LOBYTE(v3[12]._os_unfair_lock_opaque) = 0;
    lsl::Allocator::freeObject(*a1, v6);
  }
  return a1;
}

const os_unfair_lock *lsl::Vector<dyld_image_info>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._os_unfair_lock_opaque = a2;
      *(void *)&result[6]._os_unfair_lock_opaque = a2;
      unint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
      mach_msg_header_t v3 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v3, v2, 24 * a2);
    }
    else
    {
      uint64_t v5 = result + 2;
      uint64_t v4 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v4) {
        __n128 result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v4);
      }
      *(void *)&v5->_os_unfair_lock_opaque = 0;
      *(void *)&v5[2]._os_unfair_lock_opaque = 0;
      *(void *)&v5[4]._os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)result, a2);
  }
  return result;
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  int v5 = 0;
  unsigned int v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)lock, (unsigned int *)&v5, v6, memory_order_acquire, memory_order_acquire);
  if (v5) {
    _os_unfair_lock_lock_slow((atomic_uint *)lock, 0, 0, v6, v1, v2, v3, v4);
  }
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  int v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  unsigned int v7 = atomic_exchange_explicit((atomic_uint *volatile)lock, 0, memory_order_release);
  if (v7 != v6) {
    _os_unfair_lock_unlock_slow(lock, v6, v7, v1, v2, v3, v4, v5);
  }
}

unint64_t lsl::Allocator::size(lsl::Allocator *this, void *a2)
{
  if (a2) {
    return (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL) - (void)a2;
  }
  else {
    return 0;
  }
}

uint64_t dyld4::ExternallyViewableState::addImagesOld(uint64_t a1, uint64_t a2, unint64_t a3)
{
  atomic_store(0, (unint64_t *)(*(void *)(a1 + 24) + 8));
  lsl::Vector<dyld_image_info>::insert<dyld_image_info*>(*(void *)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 8) + 24 * *(void *)(*(void *)(a1 + 32) + 16), *(unsigned char **)(a2 + 8), (unsigned char *)(*(void *)(a2 + 8) + 24 * *(void *)(a2 + 16)));
  uint64_t v6 = *(void *)(a1 + 24);
  *(_DWORD *)(v6 + 4) = *(void *)(*(void *)(a1 + 32) + 16);
  atomic_store(a3, (unint64_t *)(v6 + 184));
  atomic_store(*(void *)(*(void *)(a1 + 32) + 8), (unint64_t *)(*(void *)(a1 + 24) + 8));
  unsigned int v7 = *(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 24) + 16);
  uint64_t v8 = *(unsigned int *)(a2 + 16);
  uint64_t v9 = *(void *)(a2 + 8);

  return v7(0, v8, v9);
}

uint64_t lsl::Vector<dyld_image_info>::insert<dyld_image_info*>(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((a2 - *(void *)(a1 + 8)) >> 3);
  size_t v8 = a4 - a3;
  uint64_t v9 = (a4 - a3) >> 3;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * v9;
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(a1, *(void *)(a1 + 16) - 0x5555555555555555 * v9);
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11 != v7) {
    memmove((void *)(24 * (v11 + v10) - (24 * v11 - (*(void *)(a1 + 8) + 24 * v7))), (const void *)(*(void *)(a1 + 8) + 24 * v7), 24 * v11 - 24 * v7);
  }
  if (a4 != a3) {
    memmove((void *)(*(void *)(a1 + 8) + 24 * v7), a3, v8);
  }
  uint64_t v12 = *(void *)(a1 + 8);
  *(void *)(a1 + 16) += v10;
  return v12 + 24 * v7;
}

void *___ZN5dyld412RuntimeState16_instantiateTLVsEm_block_invoke(void *result)
{
  uint64_t v1 = result[6];
  uint64_t v2 = *(void *)(v1 + 848);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 840);
    uint64_t v4 = 24 * v2;
    int v5 = (unsigned int *)(v3 + 16);
    do
    {
      if (result[7] == *(v5 - 2))
      {
        *(void *)(*(void *)(result[4] + 8) + 24) = *((void *)v5 - 2) + *(v5 - 1);
        *(void *)(*(void *)(result[5] + 8) + 24) = *v5;
      }
      v5 += 6;
      v4 -= 24;
    }
    while (v4);
  }
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::identityMapper(dyld4::Atlas::ProcessSnapshot *this)
{
  return (uint64_t)this + 72;
}

uint64_t dyld4::Atlas::Image::Image(uint64_t a1, uint64_t a2, dyld4::FileRecord *a3, atomic_uint **a4, uint64_t a5)
{
  *(void *)a1 = a2;
  dyld4::FileRecord::FileRecord(a1 + 8, a3);
  size_t v8 = *a4;
  *(void *)(a1 + 88) = *a4;
  if (v8) {
    atomic_fetch_add_explicit(v8, 1u, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 121) = 0u;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 16dyld4::halt((char *)__format, 0) = a5;
  *(_DWORD *)(a1 + 183) = 0;
  return a1;
}

const os_unfair_lock **dyld4::Atlas::ProcessSnapshot::addImage(lsl::Lock ***a1, dyld4::Atlas::Image *a2)
{
  uint64_t v2 = (uint64_t)(a1 + 2);
  lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(*a1, a2, &v4);
  lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert(v2, (uint64_t *)&v4, (uint64_t)v5);
  return lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v4);
}

__n128 dyld4::ExternallyViewableState::addImageUUID(dyld4::ExternallyViewableState *this, const dyld3::MachOFile *a2)
{
  v10.n128_u64[0] = (unint64_t)a2;
  dyld3::MachOFile::getUuid(a2, &v10.n128_u8[8]);
  *(void *)(*((void *)this + 3) + 96) = 0;
  uint64_t v3 = *((void *)this + 5);
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v3, *(void *)(v3 + 16) + 1);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 16);
  *(void *)(v3 + 16) = v5 + 1;
  uint64_t v6 = (__n128 *)(v4 + 24 * v5);
  __n128 result = v10;
  v6[1].n128_u64[0] = v11;
  *uint64_t v6 = result;
  uint64_t v8 = *((void *)this + 5);
  uint64_t v9 = *((void *)this + 3);
  *(void *)(v9 + 88) = *(void *)(v8 + 16);
  *(void *)(v9 + 96) = *(void *)(v8 + 8);
  return result;
}

__n128 lsl::MemoryManager::adoptLock(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

void dyld4::RuntimeState::buildInterposingTables(dyld4::RuntimeState *this)
{
  if (*(unsigned char *)(*((void *)this + 1) + 190))
  {
    uint64_t v28 = 0;
    uint64_t v29 = &v28;
    uint64_t v30 = 0x2000000000;
    int v31 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = &v18;
    uint64_t v20 = 0x5002000000;
    uint64_t v21 = __Block_byref_object_copy__74;
    uint64_t v22 = __Block_byref_object_dispose__75;
    uint64_t v23 = &v32;
    uint64_t v24 = 8;
    uint64_t v25 = 0;
    vm_address_t address = 0;
    vm_size_t size = 0;
    uint64_t v2 = *((void *)this + 6);
    if (v2)
    {
      uint64_t v3 = (dyld4::Loader **)*((void *)this + 5);
      uint64_t v4 = 8 * v2;
      uint64_t v5 = v3;
      do
      {
        uint64_t v6 = *v5;
        unint64_t v7 = (dyld3::MachOFile *)dyld4::Loader::analyzer(*v5, this);
        if ((*((_WORD *)v6 + 2) & 2) == 0)
        {
          uint64_t v8 = (int *)v7;
          if (dyld3::MachOFile::isDylib(v7))
          {
            Diagnostics::Diagnostics((Diagnostics *)&v17);
            v16[0] = _NSConcreteStackBlock;
            v16[1] = 0x40000000;
            v16[2] = ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke;
            v16[3] = &unk_1EFF642F8;
            void v16[4] = &v28;
            v16[5] = &v18;
            v16[6] = v6;
            dyld3::MachOFile::forEachInterposingSection(v8, (uint64_t)&v17, (uint64_t)v16);
            mach_o::Error::~Error(&v17);
          }
        }
        ++v5;
        ++v3;
        v4 -= 8;
      }
      while (v4);
      unint64_t v9 = *((unsigned int *)v29 + 6);
      if (v9)
      {
        lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)this + 160, v9);
        lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)this + 192, *((unsigned int *)v29 + 6));
        uint64_t v10 = v19[7];
        if (v10)
        {
          unint64_t v11 = (dyld4::Loader **)v19[5];
          uint64_t v12 = 8 * v10;
          do
          {
            uint64_t v13 = *v11++;
            Diagnostics::Diagnostics((Diagnostics *)&v17);
            uint64_t v14 = (int *)dyld4::Loader::analyzer(v13, this);
            v15[0] = _NSConcreteStackBlock;
            v15[1] = 0x40000000;
            v15[2] = ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke_2;
            v15[3] = &__block_descriptor_tmp_78;
            v15[4] = this;
            v15[5] = v13;
            v15[6] = v14;
            dyld3::MachOFile::forEachInterposingSection(v14, (uint64_t)&v17, (uint64_t)v15);
            mach_o::Error::~Error(&v17);
            v12 -= 8;
          }
          while (v12);
        }
      }
    }
    _Block_object_dispose(&v18, 8);
    uint64_t v25 = 0;
    if (address) {
      vm_deallocate(mach_task_self_, address, size);
    }
    _Block_object_dispose(&v28, 8);
  }
}

void ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke(uint64_t (***a1)(void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (dyld4::RuntimeState *)a1[4];
  if (*((void *)v8 + 84) && *((void *)v8 + 34))
  {
    a1 = dyld4::RuntimeState::setDyldPatchedObjCClasses((dyld4::RuntimeState *)a1[4]);
    uint64_t v9 = *((void *)v8 + 34);
    if (v9)
    {
      uint64_t v10 = (void *)*((void *)v8 + 33);
      unint64_t v11 = &v10[4 * v9];
      do
      {
        a1 = (uint64_t (***)(void))(*((uint64_t (**)(void, void, void, void))v8 + 84))(*v10, v10[1], v10[2], v10[3]);
        v10 += 4;
      }
      while (v10 != v11);
    }
    if (*(unsigned char *)(*((void *)v8 + 1) + 205)) {
      dyld4::RuntimeState::log(v8, "objc-patch-class-notifier called with %lld patches:\n", *((void *)v8 + 34));
    }
    *((void *)v8 + 34) = 0;
  }
  uint64_t v12 = 8 * *((void *)v8 + 6);
  __chkstk_darwin((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, v57);
  uint64_t v13 = (const void **)((char *)&v57 - ((v12 + 23) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin(v14, v15, v16, v17, v18, v19, v20, v21, v57);
  uint64_t v23 = (const char **)((char *)&v57 - v22);
  __chkstk_darwin(v24, v25, v26, v27, v28, v29, v30, v31, v57);
  uint64_t v66 = 0;
  uint64_t v67 = &v66;
  uint64_t v68 = 0x4002000000;
  uint64_t v69 = __Block_byref_object_copy__164;
  v70 = __Block_byref_object_dispose__165;
  uint64_t v71 = (char *)&v57 - (v33 & 0xFFFFFFFFFFFFFFE0 | 0x10);
  unint64_t v72 = v32;
  uint64_t v73 = 0;
  if (v32)
  {
    unint64_t v58 = v32;
    int v59 = 0;
    unint64_t v34 = 0;
    unint64_t v35 = 0;
    long long v36 = (dyld4::Loader **)*((void *)v8 + 5);
    long long v37 = v36;
    do
    {
      uint64_t v38 = *v37;
      uint64_t Address = dyld4::Loader::loadAddress(*v37, v8);
      if ((*((_WORD *)v38 + 2) & 4) != 0)
      {
        uint64_t v40 = Address;
        uint64_t v41 = dyld4::Loader::path(v38, v8);
        unint64_t v42 = v58;
        if (v35 >= v58) {
          ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
        }
        v23[v35] = (const char *)v41;
        if (v34 >= v42) {
          ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
        }
        v13[v34] = (const void *)v40;
        uint64_t v43 = v8;
        uint64_t v44 = v67 + 5;
        uint64_t v62 = v40;
        uint64_t v45 = v43;
        uint64_t v63 = dyld4::Loader::path(v38, v43);
        uint64_t v64 = v38;
        int DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(v38);
        dyld3::Array<_dyld_objc_notify_mapped_info>::push_back(v44, (uint64_t)&v62);
        BOOL hasConstantSegmentsToProtect = dyld4::Loader::hasConstantSegmentsToProtect(v38);
        __int16 v47 = *((_WORD *)v38 + 2);
        uint64_t v8 = v45;
        if (hasConstantSegmentsToProtect && (v47 & 0x80) != 0)
        {
          dyld4::Loader::makeSegmentsReadWrite(v38, v45);
          __int16 v47 = *((_WORD *)v38 + 2);
        }
        ++v35;
        ++v34;
        v59 |= (v47 & 2) >> 1;
      }
      ++v37;
      ++v36;
      v12 -= 8;
    }
    while (v12);
    if (v34)
    {
      uint64_t v62 = (uint64_t)v8;
      LOBYTE(v63) = 0;
      if (*((void *)v8 + 85))
      {
        if (v59) {
          dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(&v62);
        }
        if (!v67[7]) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
        }
        (*((void (**)(unint64_t, uint64_t))v8 + 85))(v34, v67[5]);
      }
      else
      {
        os_unfair_lock_t v48 = (void (*)(unint64_t, uint64_t, void *))*((void *)v8 + 87);
        if (v48)
        {
          v60[0] = _NSConcreteStackBlock;
          v60[1] = 0x40000000;
          v60[2] = ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166;
          v60[3] = &unk_1EFF644B0;
          char v61 = v59 & 1;
          v60[4] = &v66;
          v60[5] = &v62;
          if (!v67[7]) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
          }
          v48(v34, v67[5], v60);
        }
      }
      if (*(unsigned char *)(*((void *)v8 + 1) + 205))
      {
        dyld4::RuntimeState::log(v8, "objc-mapped-notifier called with %lld images:\n", v34);
        do
        {
          if (!v35) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
          }
          uint64_t v50 = *v13++;
          uint64_t v49 = v50;
          uint64_t v51 = *v23++;
          dyld4::RuntimeState::log(v8, " objc-mapped: %p %s\n", v49, v51);
          --v35;
          --v34;
        }
        while (v34);
      }
      uint64_t v52 = *((void *)v8 + 6);
      if (v52)
      {
        uint64_t v53 = (dyld4::Loader **)*((void *)v8 + 5);
        uint64_t v54 = 8 * v52;
        uint64_t v55 = v53;
        do
        {
          if ((*((_WORD *)*v55 + 2) & 4) != 0)
          {
            uint64_t v56 = *v55;
            if (dyld4::Loader::hasConstantSegmentsToProtect(*v55) && (*((_WORD *)v56 + 2) & 0x80) != 0) {
              dyld4::Loader::makeSegmentsReadOnly(v56, v8);
            }
          }
          ++v55;
          ++v53;
          v54 -= 8;
        }
        while (v54);
      }
      if ((_BYTE)v63) {
        dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(*(void *)(v62 + 8) + 240), *(void *)(v62 + 8) + 200, *(void *)(v62 + 8), 0);
      }
    }
  }
  _Block_object_dispose(&v66, 8);
}

BOOL dyld4::Loader::hasConstantSegmentsToProtect(dyld4::Loader *this)
{
  return (*((_WORD *)this + 2) & 0x12) == 16;
}

uint64_t dyld4::Loader::dyldDoesObjCFixups(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::dyldDoesObjCFixups();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::dyldDoesObjCFixups(this);
  }
  else
  {
    return dyld4::JustInTimeLoader::dyldDoesObjCFixups(this);
  }
}

BOOL dyld4::PrebuiltLoader::dyldDoesObjCFixups(dyld4::PrebuiltLoader *this)
{
  if (this && (uint64_t v1 = *((unsigned int *)this + 14), v1)) {
    return *(void *)((char *)this + v1) != 0;
  }
  else {
    return (*((unsigned __int16 *)this + 2) >> 1) & 1;
  }
}

__n128 dyld3::Array<_dyld_objc_notify_mapped_info>::push_back(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = a1[2];
  if (v2 >= a1[1]) {
    ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
  }
  uint64_t v3 = *a1;
  a1[2] = v2 + 1;
  uint64_t v4 = (_OWORD *)(v3 + 32 * v2);
  __n128 result = *(__n128 *)a2;
  long long v6 = *(_OWORD *)(a2 + 16);
  *uint64_t v4 = *(_OWORD *)a2;
  v4[1] = v6;
  return result;
}

uint64_t ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(const dyld4::RuntimeState **)(a1 + 32);
  uint64_t v10 = *((void *)v9 + 6);
  unint64_t v11 = 8 * v10;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v26);
  uint64_t v12 = (v11 + 15) & 0xFFFFFFFF0;
  uint64_t v13 = (char *)&v26 - v12;
  if (v11 >= 0x200) {
    size_t v14 = 512;
  }
  else {
    size_t v14 = 8 * v10;
  }
  bzero((char *)&v26 - v12, v14);
  __chkstk_darwin(v15, v16, v17, v18, v19, v20, v21, v22, v26);
  uint64_t v23 = (char *)&v26 - v12;
  bzero(v23, v14);
  if (v10)
  {
    uint64_t v24 = 0;
    do
    {
      *(void *)&v13[v24] = dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((void *)v9 + 5) + v24), v9);
      *(void *)&v23[v24] = dyld4::Loader::path(*(dyld4::Loader **)(*((void *)v9 + 5) + v24), v9);
      v24 += 8;
    }
    while (v11 != v24);
  }
  if (*(unsigned char *)(*((void *)v9 + 1) + 205)) {
    dyld4::RuntimeState::log(v9, "add bulk notifier %p called with %d images\n", *(const void **)(a1 + 40), v10);
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(a1 + 40))(v10, v13, v23);
}

uint64_t dyld4::Loader::loadAddress(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::loadAddress();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::loadAddress(this, a2);
  }
  else
  {
    return dyld4::JustInTimeLoader::mf((uint64_t)this);
  }
}

uint64_t dyld4::Loader::path(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::path();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::path((uint64_t)this);
  }
  else
  {
    return dyld4::JustInTimeLoader::path((uint64_t)this);
  }
}

uint64_t dyld4::PrebuiltLoader::path(uint64_t a1)
{
  if (*(_WORD *)(a1 + 32)) {
    return a1 + *(unsigned __int16 *)(a1 + 32);
  }
  else {
    return 0;
  }
}

uint64_t ___ZN5dyld44APIs19findImageContainingEPv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(dyld4::RuntimeState **)(result + 40);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    long long v6 = v4;
    while (1)
    {
      unint64_t v7 = *v6;
      unint64_t v9 = 0;
      uint64_t v10 = 0;
      unsigned __int8 v8 = 0;
      __n128 result = dyld4::Loader::contains(v7, v1, *(char **)(v3 + 48), (const void **)&v10, &v9, &v8);
      if (result) {
        break;
      }
      ++v6;
      ++v4;
      v5 -= 8;
      if (!v5) {
        return result;
      }
    }
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = v7;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_3(uint64_t result)
{
  uint64_t v1 = *(dyld4::RuntimeState **)(result + 40);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    long long v6 = v4;
    while (1)
    {
      unint64_t v7 = *v6;
      if (((*((unsigned __int16 *)*v6 + 2) >> 1) & 1) == *(unsigned char *)(v3 + 112))
      {
        unsigned __int8 v8 = *v6;
        unint64_t v15 = 0;
        uint64_t v16 = 0;
        unsigned __int8 v14 = 0;
        __n128 result = dyld4::Loader::contains(v7, v1, *(char **)(v3 + 48), (const void **)&v16, &v15, &v14);
        if (result) {
          break;
        }
      }
      ++v6;
      ++v4;
      v5 -= 8;
      if (!v5) {
        return result;
      }
    }
    if (*(void *)(v3 + 56))
    {
      __n128 result = dyld4::Loader::loadAddress(v8, v1);
      **(void **)(v3 + 56) = result;
    }
    unint64_t v9 = *(BOOL **)(v3 + 64);
    if (v9) {
      BOOL *v9 = (*((unsigned char *)v8 + 4) & 0x20) != 0;
    }
    if (*(void *)(v3 + 72))
    {
      __n128 result = dyld4::Loader::path(v8, v1);
      **(void **)(v3 + 72) = result;
    }
    uint64_t v10 = *(void ***)(v3 + 80);
    if (v10) {
      *uint64_t v10 = v16;
    }
    unint64_t v11 = *(unint64_t **)(v3 + 88);
    if (v11) {
      *unint64_t v11 = v15;
    }
    uint64_t v12 = *(unsigned __int8 **)(v3 + 96);
    if (v12) {
      *uint64_t v12 = v14;
    }
    uint64_t v13 = *(dyld4::Loader ***)(v3 + 104);
    if (v13) {
      *uint64_t v13 = v8;
    }
    *(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t dyld4::Loader::contains(dyld4::Loader *this, dyld4::RuntimeState *a2, char *a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::contains();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::contains(this, a2, a3, a4, a5, a6);
  }
  else
  {
    return dyld4::JustInTimeLoader::contains(this, a2, (unint64_t)a3, a4, a5, a6);
  }
}

uint64_t dyld4::PrebuiltLoader::contains(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2, char *a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  unint64_t Address = dyld4::PrebuiltLoader::loadAddress(this, a2);
  if (Address > (unint64_t)a3) {
    return 0;
  }
  unint64_t v12 = *((unsigned __int16 *)this + 22);
  if (v12 < 0x10) {
    return 0;
  }
  uint64_t v13 = &a3[-Address];
  unsigned __int8 v14 = (char *)this + *((unsigned __int16 *)this + 23);
  uint64_t v15 = 16 * (v12 >> 4);
  while (1)
  {
    unint64_t v16 = *(void *)v14 & 0x7FFFFFFFFFFFFFFLL;
    if ((unint64_t)v13 >= v16)
    {
      unint64_t v17 = *((unsigned int *)v14 + 3);
      if ((unint64_t)v13 < v16 + v17) {
        break;
      }
    }
    v14 += 16;
    v15 -= 16;
    if (!v15) {
      return 0;
    }
  }
  *a4 = (const void *)(Address + v16);
  *a5 = v17;
  *a6 = (*(void *)v14 >> 59) & 7;
  return 1;
}

uint64_t dyld4::RuntimeState::cachedDylibLoadAddress(dyld4::RuntimeState *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (*(_DWORD *)(v2 + 392) <= a2) {
    dyld4::RuntimeState::cachedDylibLoadAddress();
  }
  unint64_t v4 = 0;
  unint64_t v5 = 0;
  return DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(v2 + 240), a2, &v5, &v4);
}

uint64_t DyldSharedCache::getIndexedImageEntry(DyldSharedCache *this, int a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v4 = *((unsigned int *)this + 4);
  uint64_t v5 = 24;
  if (v4 > 0x1C3) {
    uint64_t v5 = 448;
  }
  long long v6 = (void *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v5));
  *a3 = v6[1];
  *a4 = v6[2];
  return (uint64_t)this + *v6 - *(void *)((char *)this + v4);
}

BOOL dyld4::JustInTimeLoader::contains(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2, unint64_t a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  long long v6 = (dyld3::MachOFile *)*((void *)this + 4);
  if ((unint64_t)v6 > a3) {
    return 0;
  }
  unsigned __int8 v8 = (unint64_t *)*((void *)this + 13);
  if (v8 && *v8 <= a3 && *v8 + v8[1] > a3) {
    return 1;
  }
  uint64_t v11 = 0;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK5dyld416JustInTimeLoader8containsERNS_12RuntimeStateEPKvPS4_PyPh_block_invoke;
  void v10[3] = &unk_1EFF64AA0;
  v10[6] = a3;
  v10[7] = a4;
  void v10[8] = a5;
  void v10[9] = a6;
  v10[4] = &v11;
  v10[5] = (char *)v6 - dyld3::MachOFile::preferredLoadAddress(v6);
  dyld3::MachOFile::forEachSegment(v6, (uint64_t)v10);
  BOOL v7 = *((unsigned char *)v12 + 24) != 0;
  _Block_object_dispose(&v11, 8);
  return v7;
}

void dyld4::RuntimeState::notifyLoad(const dyld4::RuntimeState *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v90 = a2;
  uint64_t v9 = *(void *)(a2 + 8);
  if (kdebug_is_enabled(0x1F050000u, a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v10 = *(void *)(v90 + 8);
    if (v10)
    {
      uint64_t v11 = *(dyld4::Loader ***)v90;
      uint64_t v12 = 8 * v10;
      do
      {
        uint64_t v13 = *v11;
        unint64_t Address = (unsigned int *)dyld4::Loader::loadAddress(*v11, a1);
        if ((*((_WORD *)v13 + 2) & 2) != 0
          || (uint64_t v15 = (dyld3 *)dyld4::Loader::path(v13, a1), dyld3::stat(v15, &v98, v16)))
        {
          __darwin_ino64_t st_ino = 0;
          fsobj_id st_dev = 0;
        }
        else
        {
          __darwin_ino64_t st_ino = (unsigned __int8 (*)[16])v98.st_ino;
          fsobj_id st_dev = (fsobj_id)v98.st_dev;
        }
        *(void *)fsid v101 = 0;
        uint64_t v102 = 0;
        dyld3::MachOFile::getUuid((dyld3::MachOFile *)Address, (unsigned __int8 *)v101);
        uint64_t v19 = (void *)dyld4::Loader::path(v13, a1);
        fsobj_id v20 = st_dev;
        fsid v21 = (fsid)Address;
        dyld3::kdebug_trace_dyld_image(0, v19, (void **)v101, st_ino, v20, v21, (const void *)Address[2], v22, v89[0]);
        ++v11;
        v12 -= 8;
      }
      while (v12);
    }
  }
  uint64_t v23 = (uint64_t *)*((void *)a1 + 17);
  v96[0] = _NSConcreteStackBlock;
  v96[1] = 0x40000000;
  v96[2] = ___ZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
  v96[3] = &__block_descriptor_tmp_94;
  uint64_t v24 = v90;
  v96[4] = a1;
  v96[5] = v90;
  int v97 = v9;
  Locunint64_t k = dyld4::RuntimeLocks::withNotifiersReadLock(v23, (uint64_t)v96);
  unsigned int v95 = 0;
  char v94 = 0;
  __chkstk_darwin(Lock, v26, v27, v28, v29, v30, v31, v32, (uint64_t)v89[0]);
  uint64_t v33 = (8 * v9 + 15) & 0xFFFFFFFF0;
  unint64_t v34 = (char *)v89 - v33;
  if (8 * (unint64_t)v9 >= 0x200) {
    size_t v35 = 512;
  }
  else {
    size_t v35 = 8 * v9;
  }
  bzero((char *)v89 - v33, v35);
  __chkstk_darwin(v36, v37, v38, v39, v40, v41, v42, v43, (uint64_t)v89[0]);
  uint64_t v44 = (char *)v89 - v33;
  bzero((char *)v89 - v33, v35);
  __chkstk_darwin(v45, v46, v47, v48, v49, v50, v51, v52, (uint64_t)v89[0]);
  uint64_t v60 = &v89[-4 * v9];
  if (*((void *)a1 + 85) || *((void *)a1 + 87))
  {
    v89[1] = v89;
    uint64_t v61 = *(void *)(v24 + 8);
    if (v61)
    {
      uint64_t v62 = *(dyld4::Loader ***)v90;
      uint64_t v63 = 8 * v61;
      do
      {
        uint64_t v64 = *v62;
        if ((*((_WORD *)*v62 + 2) & 4) != 0)
        {
          uint64_t v65 = dyld4::Loader::path(*v62, a1);
          *(void *)&v34[8 * v95] = v65;
          uint64_t v66 = dyld4::Loader::loadAddress(v64, a1);
          *(void *)&v44[8 * v95] = v66;
          uint64_t v67 = dyld4::Loader::path(v64, a1);
          int DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(v64);
          unsigned int v69 = v95;
          v70 = &v60[4 * v95];
          uint64_t *v70 = (const void *)v66;
          v70[1] = (const void *)v67;
          v70[2] = v64;
          *((_DWORD *)v70 + 6) = DoesObjCFixups;
          unsigned int v95 = v69 + 1;
          BOOL hasConstantSegmentsToProtect = dyld4::Loader::hasConstantSegmentsToProtect(v64);
          __int16 v72 = *((_WORD *)v64 + 2);
          if (hasConstantSegmentsToProtect && (v72 & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadWrite(v64, a1);
            __int16 v72 = *((_WORD *)v64 + 2);
          }
          if ((v72 & 2) != 0) {
            char v94 = 1;
          }
        }
        ++v62;
        v63 -= 8;
      }
      while (v63);
    }
    uint64_t v73 = v90;
    if (!v95) {
      goto LABEL_75;
    }
    char v93 = 0;
    v91 = &v92;
    v92 = a1;
    uint64_t v100 = *((void *)a1 + 16);
    unint64_t v99 = 0;
    if (v100) {
      uint64_t v74 = v100;
    }
    else {
      uint64_t v74 = 0;
    }
    if (*(unsigned char *)(v74 + 32))
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_83;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_83;
      }
      unint64_t v99 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
      if (!v99)
      {
        if (!MEMORY[0xFFFFFC10C]) {
          goto LABEL_83;
        }
        if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_83;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v53 = 0xFFFFFC0D0;
        uint64_t v75 = MEMORY[0xFFFFFC0D0];
        if (v75 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
          goto LABEL_83;
        }
      }
    }
    else
    {
      unint64_t v99 = 1;
      lsl::MemoryManager::lockGuard((lsl::Lock *)v74, (lsl::Lock **)&v98);
      uint64_t v76 = *(void *)(v74 + 24);
      if (!v76)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v74, 0);
        uint64_t v76 = *(void *)(v74 + 24);
      }
      *(void *)(v74 + 24) = v76 + 1;
      lsl::Lock::unlock(*(lsl::Lock **)&v98.st_dev);
    }
    v98.fsobj_id st_dev = 520552484;
    memset(&v98.st_ino, 0, 104);
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v98, v53, v54, v55, v56, v57, v58, v59);
    uint64_t v77 = (void (*)(void, const void **))*((void *)a1 + 85);
    if (v77)
    {
      if (v94)
      {
        dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(v91);
        uint64_t v77 = (void (*)(void, const void **))*((void *)a1 + 85);
      }
      v77(v95, v60);
    }
    else
    {
      uint64_t v78 = (void (*)(void, const void **, char *))*((void *)a1 + 87);
      if (v78)
      {
        *(void *)fsid v101 = _NSConcreteStackBlock;
        uint64_t v102 = 0x40000000;
        v103 = ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke;
        v104 = &__block_descriptor_tmp_161;
        uint64_t v107 = &v95;
        uint64_t v108 = &v94;
        uint64_t v105 = v60;
        uint64_t v106 = &v91;
        v78(v95, v60, v101);
      }
    }
    if (*(unsigned char *)(*((void *)a1 + 1) + 205))
    {
      dyld4::RuntimeState::log(a1, "objc-mapped-notifier called with %d images:\n", v95);
      if (v95)
      {
        for (unint64_t i = 0; i < v95; ++i)
          dyld4::RuntimeState::log(a1, " objc-mapped: %p %s\n", *(const void **)&v44[8 * i], *(const char **)&v34[8 * i]);
      }
    }
    dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v98);
    if (v100) {
      uint64_t v80 = v100;
    }
    else {
      uint64_t v80 = 0;
    }
    if (!*(unsigned char *)(v80 + 32))
    {
      lsl::MemoryManager::lockGuard((lsl::Lock *)v80, (lsl::Lock **)&v98);
      if (v99 == 1)
      {
        uint64_t v84 = *(void *)(v80 + 24) - 1;
        *(void *)(v80 + 24) = v84;
        if (!v84) {
          lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v80, 1);
        }
      }
      else if (v99 == 0xFFFFFFFF)
      {
        uint64_t v83 = *(void *)(v80 + 24);
        if (!v83)
        {
          lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v80, 0);
          uint64_t v83 = *(void *)(v80 + 24);
        }
        *(void *)(v80 + 24) = v83 + 1;
      }
      lsl::Lock::unlock(*(lsl::Lock **)&v98.st_dev);
      goto LABEL_73;
    }
    if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
    {
      if (v99 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        goto LABEL_73;
      }
      if (v99 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_83;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v81 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_83;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v81 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v81 == StatusReg)
      {
LABEL_73:
        if (v93) {
          dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(*((void *)v92 + 1) + 240), *((void *)v92 + 1) + 200, *((void *)v92 + 1), 0);
        }
LABEL_75:
        uint64_t v85 = *(void *)(v73 + 8);
        if (v85)
        {
          uint64_t v86 = *(dyld4::Loader ***)v73;
          uint64_t v87 = 8 * v85;
          do
          {
            v88 = *v86;
            if ((*((_WORD *)*v86 + 2) & 4) != 0
              && dyld4::Loader::hasConstantSegmentsToProtect(*v86)
              && (*((_WORD *)v88 + 2) & 0x80) != 0)
            {
              dyld4::Loader::makeSegmentsReadOnly(v88, a1);
            }
            ++v86;
            v87 -= 8;
          }
          while (v87);
        }
        return;
      }
    }
LABEL_83:
    __break(1u);
  }
}

uint64_t dyld4::JustInTimeLoader::path(uint64_t a1)
{
  if (*(_WORD *)(a1 + 40)) {
    return a1 + *(unsigned __int16 *)(a1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t dyld4::RuntimeLocks::withNotifiersReadLock(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (v4)
  {
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v4 + 104))(v4, a1 + 2, 0);
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)*a1 + 112);
    return v5();
  }
  else
  {
    BOOL v7 = *(uint64_t (**)(uint64_t))(a2 + 16);
    return v7(a2);
  }
}

uint64_t ___ZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  uint64_t v9 = *(const dyld4::RuntimeState **)(result + 32);
  uint64_t v10 = *((void *)v9 + 90);
  if (v10)
  {
    uint64_t v11 = (const void **)*((void *)v9 + 89);
    uint64_t v12 = &v11[v10];
    do
    {
      uint64_t v13 = *(void *)(v8 + 40);
      uint64_t v14 = *(void *)(v13 + 8);
      if (v14)
      {
        uint64_t v15 = *v11;
        unint64_t v16 = *(dyld4::Loader ***)v13;
        uint64_t v17 = 8 * v14;
        do
        {
          uint64_t v18 = *v16;
          unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v16, v9);
          int v73 = 520552472;
          uint64_t v74 = Address;
          uint64_t v75 = 0;
          uint64_t v76 = v15;
          long long v77 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v73, v20, v21, v22, v23, v24, v25, v26);
          if (*(unsigned char *)(*((void *)v9 + 1) + 205)) {
            dyld4::RuntimeState::log(v9, "notifier %p called with mh=%p\n", v15, Address);
          }
          if ((*((_WORD *)v18 + 2) & 2) != 0) {
            uint64_t Slide = *(void *)(*((void *)v9 + 1) + 264);
          }
          else {
            uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
          }
          ((void (*)(dyld3::MachOLoaded *, uint64_t))v15)(Address, Slide);
          __n128 result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v73);
          ++v16;
          v17 -= 8;
        }
        while (v17);
      }
      ++v11;
    }
    while (v11 != v12);
  }
  uint64_t v28 = *((void *)v9 + 98);
  if (v28)
  {
    uint64_t v29 = (const void **)*((void *)v9 + 97);
    __int16 v72 = &v29[v28];
    do
    {
      uint64_t v30 = *(void *)(v8 + 40);
      uint64_t v31 = *(void *)(v30 + 8);
      if (v31)
      {
        uint64_t v32 = *v29;
        uint64_t v33 = *(dyld4::Loader ***)v30;
        uint64_t v34 = 8 * v31;
        do
        {
          size_t v35 = *v33;
          uint64_t v36 = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v33, v9);
          int v73 = 520552472;
          uint64_t v74 = v36;
          uint64_t v75 = 0;
          uint64_t v76 = v32;
          long long v77 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v73, v37, v38, v39, v40, v41, v42, v43);
          if (*(unsigned char *)(*((void *)v9 + 1) + 205)) {
            dyld4::RuntimeState::log(v9, "notifier %p called with mh=%p\n", v32, v36);
          }
          uint64_t v44 = dyld4::Loader::path(v35, v9);
          ((void (*)(dyld3::MachOLoaded *, uint64_t, BOOL))v32)(v36, v44, (*((_WORD *)v35 + 2) & 0x20) == 0);
          __n128 result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v73);
          ++v33;
          v34 -= 8;
        }
        while (v34);
      }
      ++v29;
    }
    while (v29 != v72);
  }
  uint64_t v45 = *((void *)v9 + 102);
  if (v45)
  {
    uint64_t v46 = (const void **)*((void *)v9 + 101);
    __int16 v72 = &v46[v45];
    do
    {
      uint64_t v47 = *v46;
      __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, (uint64_t)v72);
      uint64_t v49 = (dyld3::MachOLoaded **)((char *)&v72 - ((v48 + 15) & 0xFFFFFFFF0));
      if (v48 >= 0x200) {
        size_t v50 = 512;
      }
      else {
        size_t v50 = v48;
      }
      bzero((char *)&v72 - ((v48 + 15) & 0xFFFFFFFF0), v50);
      int v51 = *(_DWORD *)(v8 + 48);
      __chkstk_darwin(v52, v53, v54, v55, v56, v57, v58, v59, (uint64_t)v72);
      uint64_t v61 = (char *)&v72 - ((v60 + 15) & 0xFFFFFFFF0);
      if (v60 >= 0x200) {
        size_t v62 = 512;
      }
      else {
        size_t v62 = v60;
      }
      bzero((char *)&v72 - ((v60 + 15) & 0xFFFFFFFF0), v62);
      if (v51)
      {
        unint64_t v70 = 0;
        do
        {
          v49[v70] = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(**(void **)(v8 + 40) + 8 * v70), v9);
          *(void *)&v61[8 * v70] = dyld4::Loader::path(*(dyld4::Loader **)(**(void **)(v8 + 40) + 8 * v70), v9);
          ++v70;
        }
        while (v70 < *(unsigned int *)(v8 + 48));
      }
      uint64_t v71 = *v49;
      int v73 = 520552472;
      uint64_t v74 = v71;
      uint64_t v75 = 0;
      uint64_t v76 = v47;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v73, v63, v64, v65, v66, v67, v68, v69);
      if (*(unsigned char *)(*((void *)v9 + 1) + 205)) {
        dyld4::RuntimeState::log(v9, "bulk notifier %p called with %d images\n", v47, *(_DWORD *)(v8 + 48));
      }
      ((void (*)(void, dyld3::MachOLoaded **, char *))v47)(*(unsigned int *)(v8 + 48), v49, v61);
      __n128 result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v73);
      ++v46;
    }
    while (v46 != v72);
  }
  return result;
}

void dyld4::APIs::_dyld_images_for_addresses(dyld4::RuntimeState *this, unsigned int a2, char **a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = a3;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_images_for_addresses(%d, %p, %p)\n", a2, a3, a4);
  }
  uint64_t v18 = 0;
  BOOL v17 = 0;
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  unint64_t v14 = 0;
  if (a2)
  {
    uint64_t v8 = 0;
    for (uint64_t i = a2; i; --i)
    {
      uint64_t v10 = *v5;
      bzero(v4, 0x20uLL);
      uint64_t v11 = v18;
      if (v18) {
        BOOL v12 = v18 > (dyld3::MachOFile *)v10;
      }
      else {
        BOOL v12 = 1;
      }
      if (!v12 && v8 >= v10) {
        goto LABEL_14;
      }
      if ((dyld4::APIs::findImageMappedAt(this, v10, &v18, &v17, (const char **)&v16, &v15, &v14, 0, 0) & 1) == 0)
      {
        uint64_t v18 = 0;
        goto LABEL_16;
      }
      uint64_t v11 = v18;
      uint64_t v8 = (char *)v18 + v14;
      if (v18)
      {
LABEL_14:
        v4[2] = v10 - (char *)v11;
        void v4[3] = v11;
        dyld3::MachOFile::getUuid(v11, (unsigned __int8 *)v4);
      }
LABEL_16:
      ++v5;
      v4 += 4;
    }
  }
}

BOOL dyld3::MachOFile::getUuid(dyld3::MachOFile *this, unsigned __int8 *a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v12);
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld39MachOFile7getUuidEPh_block_invoke;
  v7[3] = &unk_1EFF661E8;
  v7[4] = &v8;
  v7[5] = a2;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v12, (uint64_t)v7);
  Diagnostics::assertNoError((Diagnostics *)&v12);
  uint64_t v4 = v9;
  if (*((unsigned char *)v9 + 24))
  {
    BOOL v5 = 1;
  }
  else
  {
    bzero(a2, 0x10uLL);
    BOOL v5 = *((unsigned char *)v4 + 24) != 0;
  }
  _Block_object_dispose(&v8, 8);
  mach_o::Error::~Error(&v12);
  return v5;
}

void dyld4::Loader::makeSegmentsReadWrite(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(this, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld46Loader21makeSegmentsReadWriteERNS_12RuntimeStateE_block_invoke;
  void v5[3] = &__block_descriptor_tmp_118_0;
  v5[4] = this;
  v5[5] = dyld3::MachOLoaded::getSlide(Address);
  void v5[6] = a2;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v5);
}

BOOL dyld3::MachOFile::isBundle(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 8;
}

uint64_t dyld4::JustInTimeLoader::dyldDoesObjCFixups(dyld4::JustInTimeLoader *this)
{
  return (*((unsigned __int16 *)this + 2) >> 1) & 1;
}

void dyld3::MachOFile::forEachInterposingSection(int *a1, uint64_t a2, uint64_t a3)
{
  int v3 = *a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke;
  void v5[3] = &unk_1EFF662F8;
  v5[5] = a1;
  void v5[6] = a2;
  if (v3 == -17958193) {
    int v4 = 8;
  }
  else {
    int v4 = 4;
  }
  int v6 = 2 * v4;
  int v7 = v4;
  v5[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v5);
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1()
{
}

BOOL dyld_parse_boot_arg_cstr(char *a1, const char *a2, char *a3, size_t a4)
{
  while (1)
  {
    _platform_memset(v28, 170, 0x400uLL);
    uint64_t v8 = _platform_strchr(a1, 32);
    if (v8)
    {
      unint64_t v16 = v8;
      int64_t v17 = v8 - a1;
      if (v17 < 0) {
        dyld_halt("value not representable as size_t", v9, v10, v11, v12, v13, v14, v15, v28[0]);
      }
      uint64_t v18 = v16 + 1;
    }
    else
    {
      int64_t v17 = _platform_strlen(a1);
      uint64_t v18 = 0;
    }
    BOOL v19 = (unint64_t)(v17 + 1) < 0x400;
    if ((unint64_t)(v17 + 1) > 0x3FF) {
      break;
    }
    strlcpy((char *)v28, a1, v17 + 1);
    uint64_t v20 = _platform_strchr((char *)v28, 61);
    if (v20)
    {
      char *v20 = 0;
      int v22 = v20[1];
      uint64_t v21 = v20 + 1;
      if (v22) {
        uint64_t v23 = v21;
      }
      else {
        uint64_t v23 = 0;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    if (v23) {
      BOOL v24 = 0;
    }
    else {
      BOOL v24 = LOBYTE(v28[0]) == 45;
    }
    if (v24) {
      uint64_t v25 = (char *)v28 + 1;
    }
    else {
      uint64_t v25 = (const char *)v28;
    }
    if (!_platform_strcmp(v25, a2))
    {
      if (a3)
      {
        if (v23) {
          uint64_t v26 = v23;
        }
        else {
          uint64_t v26 = (const char *)&unk_1A8E7346B;
        }
        strlcpy(a3, v26, a4);
      }
      return v19;
    }
    a1 = v18;
    if (!v18) {
      return 0;
    }
  }
  return v19;
}

char *__cdecl _platform_strchr(char *__s, int __c)
{
  int8x16_t v2 = vdupq_n_s8(__c);
  uint64_t v3 = __s & 0xF;
  unint64_t v4 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
  int8x16_t v5 = *(int8x16_t *)&algn_1A8E0E0D0[-v3];
  for (uint8x16_t i = (uint8x16_t)vorrq_s8(vbicq_s8(*(int8x16_t *)v4, vceqq_s8(*(int8x16_t *)v4, v2)), v5);
        ;
        uint8x16_t i = (uint8x16_t)vbicq_s8(v7, v5))
  {
    v5.i8[0] = vminvq_u8(i);
    if (!v5.i32[0]) {
      break;
    }
    int8x16_t v7 = *(int8x16_t *)(v4 + 16);
    v4 += 16;
    int8x16_t v5 = vceqq_s8(v7, v2);
  }
  uint8x16_t v8 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, (uint8x16_t)veorq_s8(v5, v5)), (int8x16_t)xmmword_1A8E0E0C0);
  v8.i8[0] = vminvq_u8(v8);
  __n128 result = (char *)(v4 + v8.u32[0]);
  if (__c != (unint64_t)*result) {
    return 0;
  }
  return result;
}

uint64_t DyldSharedCache::hasImagePath(DyldSharedCache *this, const char *__s2, unsigned int *a3)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  if (*(void *)((char *)this + v3 + 16)) {
    return 0;
  }
  if (v3 < 0x118)
  {
    uint64_t v12 = *((unsigned int *)this + 7);
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = (unsigned int *)((char *)this + *((unsigned int *)this + 6) + 24);
      while (1)
      {
        unsigned int v15 = *v14;
        v14 += 8;
        if (!_platform_strcmp((const char *)this + v15, __s2)) {
          break;
        }
        if (v12 == ++v13) {
          return 0;
        }
      }
      *a3 = v13;
      return 1;
    }
  }
  else
  {
    uint8x16_t v8 = (const unsigned __int8 **)((char *)this + *((void *)this + 33) - *(void *)((char *)this + v3));
    uint64_t v9 = (Diagnostics *)((char *)v8 + *((void *)this + 34));
    Diagnostics::Diagnostics((Diagnostics *)&v17);
    unint64_t v16 = dyld3::MachOFile::trieWalk((vm_address_t *)&v17, v8, v9, (const unsigned __int8 *)__s2, v10);
    if (v16)
    {
      *a3 = dyld3::MachOFile::read_uleb128((vm_address_t *)&v17, &v16, (const unsigned __int8 **)v9, v11);
      mach_o::Error::~Error(&v17);
      return 1;
    }
    mach_o::Error::~Error(&v17);
  }
  return 0;
}

const void *dyld4::APIs::dlsym(dyld4::APIs *this, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v82 = 520617996;
  uint64_t v83 = a2;
  uint64_t v84 = 0;
  uint64_t v85 = 0;
  uint64_t v86 = a3;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  uint64_t v91 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v82, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dlsym(%p, \"%s\")\n", (const void *)a2, a3);
  }
  dyld4::APIs::clearErrorString((uint64_t)this);
  if (!_platform_strcmp(a3, "pthread_jit_write_with_callback_np")
    || !_platform_strncmp(a3, "se_memory_inline_jit", 0x14uLL))
  {
    goto LABEL_8;
  }
  if (dyld4::APIs::addressLookupsDisabled(this, a3))
  {
    if (*(unsigned char *)(*((void *)this + 1) + 204)) {
      dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL (blocked)\n", a3);
    }
LABEL_8:
    uint64_t v12 = 0;
    goto LABEL_9;
  }
  size_t v14 = _platform_strlen(a3);
  __chkstk_darwin(v14, v15, v16, v17, v18, v19, v20, v21, v64);
  uint64_t v23 = (char *)&v65[-1] - ((v22 + 17) & 0xFFFFFFFFFFFFFFF0);
  *uint64_t v23 = 95;
  strlcpy(v23 + 1, a3, v22 + 1);
  uint64_t v76 = 0;
  long long v77 = &v76;
  uint64_t v78 = 0x3002000000;
  long long v79 = __Block_byref_object_copy__6;
  long long v80 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v81);
  uint64_t v70 = 0;
  uint64_t v71 = &v70;
  uint64_t v72 = 0x5002000000;
  int v73 = __Block_byref_object_copy__96;
  uint64_t v74 = __Block_byref_object_dispose__97;
  int v24 = 0;
  uint64_t v25 = 0;
  switch(a2)
  {
    case -5:
      if (dyld4::Loader::hasExportedSymbol(*((void *)this + 3), (vm_address_t *)v77 + 5, this, (const unsigned __int8 *)v23, 0, 1, v75, 0))goto LABEL_27; {
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_MAIN_ONLY, %s): symbol not found");
      }
      goto LABEL_47;
    case -3:
      uint64_t ImageContaining = dyld4::APIs::findImageContaining(this, v8);
      if (!ImageContaining)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_SELF, %s): called by unknown image (caller=%p)");
        goto LABEL_47;
      }
      __chkstk_darwin(ImageContaining, v27, v28, v29, v30, v31, v32, v33, v64);
      size_t v35 = (uint64_t *)*((void *)this + 6);
      uint64_t v66 = (uint64_t)&v65[-1] - ((v34 + 23) & 0xFFFFFFFFFFFFFFF0);
      uint64_t v67 = v35;
      uint64_t v68 = 0;
      if (dyld4::Loader::hasExportedSymbol(v36, (vm_address_t *)v77 + 5, this, (const unsigned __int8 *)v23, 3u, 0, v71 + 5, &v66))goto LABEL_27; {
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_SELF, %s): symbol not found");
      }
      goto LABEL_50;
    case -2:
      uint64_t v66 = 0;
      uint64_t v67 = &v66;
      uint64_t v68 = 0x2000000000;
      char v69 = 0;
      uint64_t v37 = (uint64_t *)*((void *)this + 17);
      v65[0] = _NSConcreteStackBlock;
      v65[1] = 0x40000000;
      v65[2] = ___ZN5dyld44APIs5dlsymEPvPKc_block_invoke;
      v65[3] = &unk_1EFF65490;
      v65[7] = this;
      v65[8] = v23;
      v65[4] = &v76;
      v65[5] = &v70;
      v65[6] = &v66;
      dyld4::RuntimeLocks::withLoadersReadLock(v37, (uint64_t)v65);
      if (*((unsigned char *)v67 + 24))
      {
        _Block_object_dispose(&v66, 8);
        goto LABEL_27;
      }
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_DEFAULT, %s): symbol not found", a3);
      if (*(unsigned char *)(*((void *)this + 1) + 204)) {
        dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL\n", a3);
      }
      _Block_object_dispose(&v66, 8);
      goto LABEL_52;
    case -1:
      uint64_t v38 = dyld4::APIs::findImageContaining(this, v8);
      if (!v38)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_NEXT, %s): called by unknown image (caller=%p)");
        goto LABEL_47;
      }
      __chkstk_darwin(v38, v39, v40, v41, v42, v43, v44, v45, v64);
      uint64_t v47 = (uint64_t *)*((void *)this + 6);
      uint64_t v66 = (uint64_t)&v65[-1] - ((v46 + 23) & 0xFFFFFFFFFFFFFFF0);
      uint64_t v67 = v47;
      uint64_t v68 = 0;
      if (dyld4::Loader::hasExportedSymbol(v48, (vm_address_t *)v77 + 5, this, (const unsigned __int8 *)v23, 2u, 0, v71 + 5, &v66))goto LABEL_27; {
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_NEXT, %s): symbol not found");
      }
LABEL_50:
      if (*(unsigned char *)(*((void *)this + 1) + 204)) {
        goto LABEL_51;
      }
      goto LABEL_52;
    case 0:
      goto LABEL_22;
    default:
      int v24 = a2 & 1;
      uint64_t v25 = (const dyld4::Loader *)(a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A8DFD000);
LABEL_22:
      BOOL valid = dyld4::APIs::validLoader((lsl::Allocator **)this, v25);
      if (!valid)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%p, %s): invalid handle");
        goto LABEL_47;
      }
      __chkstk_darwin(valid, v50, v51, v52, v53, v54, v55, v56, v64);
      uint64_t v58 = (uint64_t *)*((void *)this + 6);
      uint64_t v66 = (uint64_t)&v65[-1] - ((v57 + 23) & 0xFFFFFFFFFFFFFFF0);
      uint64_t v67 = v58;
      uint64_t v68 = 0;
      if (v24) {
        unsigned int v59 = 0;
      }
      else {
        unsigned int v59 = 3;
      }
      if ((dyld4::Loader::hasExportedSymbol((uint64_t)v25, (vm_address_t *)v77 + 5, this, (const unsigned __int8 *)v23, v59, 0, v71 + 5, &v66) & 1) == 0)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%p, %s): symbol not found", (const void *)a2, a3);
        if (*(unsigned char *)(*((void *)this + 1) + 204)) {
          dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL\n", a3);
        }
        goto LABEL_52;
      }
LABEL_27:
      uint64_t v60 = v71[5];
      if (!v60)
      {
LABEL_47:
        if (*(unsigned char *)(*((void *)this + 1) + 204)) {
LABEL_51:
        }
          dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL\n", a3);
        goto LABEL_52;
      }
      uint64_t v12 = (const void *)v71[8];
      if (*((unsigned char *)v71 + 79))
      {
        if (*(_WORD *)(v60 + 4)) {
          uint64_t v60 = 0;
        }
        uint64_t v61 = *(uint64_t (****)(char *))(v60 + 104);
        size_t v62 = (const char *)dyld4::PseudoDylib::finalizeRequestedSymbols(v61, (uint64_t)(v71 + 6), 1);
        if (v62)
        {
          uint64_t v63 = (char *)v62;
          if (*(unsigned char *)(*((void *)this + 1) + 204)) {
            dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => NULL, error finalizing pseudo-dylib symbols: %s", a3, v62);
          }
          dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%s): error finalizing pseudo-dylib symbols: %s", a3, v63);
          dyld4::PseudoDylib::disposeString(v61, v63);
LABEL_52:
          uint64_t v12 = 0;
          goto LABEL_53;
        }
      }
      if (*(unsigned char *)(*((void *)this + 1) + 204)) {
        dyld4::RuntimeState::log(this, "     dlsym(\"%s\") => %p\n", a3, v12);
      }
      long long v88 = (unint64_t)v12;
LABEL_53:
      _Block_object_dispose(&v70, 8);
      _Block_object_dispose(&v76, 8);
      mach_o::Error::~Error(&v81);
LABEL_9:
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v82);
      return v12;
  }
}

uint64_t dyld4::Loader::hasExportedSymbol(uint64_t a1, vm_address_t *a2, const dyld4::RuntimeState *a3, const unsigned __int8 *a4, unsigned int a5, int a6, uint64_t *a7, uint64_t *a8)
{
  int v73 = a6;
  if (a8)
  {
    uint64_t v15 = a8[2];
    if (v15)
    {
      uint64_t v16 = (void *)*a8;
      uint64_t v17 = 8 * v15;
      while (*v16 != a1)
      {
        ++v16;
        v17 -= 8;
        if (!v17) {
          goto LABEL_6;
        }
      }
      return 0;
    }
LABEL_6:
    uint64_t v78 = a1;
    dyld3::Array<dyld4::Loader const*>::push_back(a8, &v78);
  }
  uint64_t v72 = a7;
  switch(a5)
  {
    case 0u:
      char v18 = 0;
      HIDWORD(v71) = 0;
      int v19 = 1;
      break;
    case 1u:
      char v18 = 0;
      HIDWORD(v71) = 0;
      int v19 = 0;
      break;
    case 2u:
      char v18 = 1;
      HIDWORD(v71) = 1;
      goto LABEL_14;
    case 3u:
      char v18 = 0;
      HIDWORD(v71) = 1;
LABEL_14:
      int v19 = 1;
      break;
    default:
      HIDWORD(v71) = 0;
      int v19 = 0;
      char v18 = 1;
      break;
  }
  uint64_t Address = dyld4::Loader::loadAddress((dyld4::Loader *)a1, a3);
  unint64_t v76 = 0;
  unsigned int v75 = 0;
  if (!dyld4::Loader::getExportsTrie((dyld4::Loader *)a1, &v76, &v75))
  {
    uint64_t v40 = dyld4::Loader::mf((dyld4::Loader *)a1, a3);
    uint64_t v78 = 0;
    long long v79 = &v78;
    uint64_t v80 = 0x2000000000;
    char v81 = 0;
    v74[0] = _NSConcreteStackBlock;
    v74[1] = 0x40000000;
    v74[2] = ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke;
    v74[3] = &unk_1EFF64948;
    v74[6] = a2;
    v74[7] = a4;
    v74[8] = v72;
    v74[9] = v40;
    v74[10] = a3;
    v74[4] = &v78;
    v74[5] = a1;
    dyld4::Loader::withLayout((dyld4::Loader *)a1, a2, a3, (uint64_t)v74);
    int v41 = *((unsigned __int8 *)v79 + 24);
    _Block_object_dispose(&v78, 8);
    if (v41) {
      return 1;
    }
    goto LABEL_33;
  }
  uint64_t v22 = (const unsigned __int8 **)(Address + v76);
  uint64_t v23 = (Diagnostics *)(Address + v76 + v75);
  int v24 = dyld3::MachOFile::trieWalk(a2, v22, v23, a4, v21);
  if (v24) {
    char v26 = v18;
  }
  else {
    char v26 = 1;
  }
  if (v26)
  {
LABEL_33:
    if (!a1) {
      goto LABEL_42;
    }
    if (*(_WORD *)(a1 + 4)) {
      goto LABEL_42;
    }
    uint64_t v43 = *(uint64_t **)(a1 + 104);
    if (!v43) {
      goto LABEL_42;
    }
    uint64_t v44 = *(uint64_t (****)(char *))(a1 + 104);
    uint64_t v77 = 0;
    uint64_t v78 = (uint64_t)a4;
    int v82 = 0;
    uint64_t v45 = (char *)dyld4::PseudoDylib::lookupSymbols(v43, (uint64_t)&v78, 1, (uint64_t)&v82, 1, (uint64_t)&v77, 1);
    uint64_t v42 = v45 == 0;
    if (v45)
    {
      uint64_t v46 = v45;
      Diagnostics::error(a2, "pseudo-dylib lookup error: %s", v45);
      dyld4::PseudoDylib::disposeString(v44, v46);
      return v42;
    }
    if ((v77 & 1) == 0)
    {
LABEL_42:
      if (v19)
      {
        uint64_t v42 = dyld4::Loader::dependentCount((dyld4::Loader *)a1);
        if (!v42) {
          return v42;
        }
        unsigned int v50 = 0;
        while (1)
        {
          LOBYTE(v78) = 0;
          if (dyld4::Loader::dependent((dyld4::JustInTimeLoader *)a1, a3, v50, (char *)&v78))
          {
            if ((v78 & 2) != 0 || ((v78 & 0xC) != 0 ? (char v51 = 1) : (char v51 = BYTE4(v71) ^ 1), (v51 & 1) == 0))
            {
              if (dyld4::Loader::hasExportedSymbol()) {
                break;
              }
            }
          }
          if (v42 == ++v50) {
            return 0;
          }
        }
        return 1;
      }
      return 0;
    }
    uint64_t v65 = (uint64_t)v72;
    uint64_t *v72 = a1;
    *(void *)(v65 + 8) = a4;
    uint64_t v66 = v82;
    *(void *)(v65 + 16) = (char *)v66 - dyld4::Loader::mf((dyld4::Loader *)a1, a3);
    *(_DWORD *)(v65 + 32) = 1;
    *(unsigned char *)(v65 + 36) = (v77 & 4) != 0;
    uint64_t v67 = dyld4::Loader::resolvedAddress(a3, v65);
    *(void *)(v65 + 24) = v67;
    char v69 = dyld4::Loader::interpose(a3, v67, 0, v68);
    *(void *)(v65 + 24) = v69;
    if (*(unsigned char *)(v65 + 36)) {
      *(void *)(v65 + 24) = v69;
    }
    char v70 = v77;
    *(unsigned char *)(v65 + 37) = (v77 & 2) != 0;
    *(unsigned char *)(v65 + 38) = 0;
    *(unsigned char *)(v65 + 39) = (v70 & 8) != 0;
    return v42;
  }
  int v82 = v24;
  char v28 = dyld3::MachOFile::read_uleb128(a2, &v82, (const unsigned __int8 **)v23, v25);
  if ((v28 & 8) == 0)
  {
    uint64_t v30 = (uint64_t)v72;
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      uint64_t v31 = dyld3::MachOFile::read_uleb128(a2, &v82, (const unsigned __int8 **)v23, v29);
      if (!v73 && (v28 & 0x10) != 0)
      {
        uint64_t v33 = dyld3::MachOFile::read_uleb128(a2, &v82, (const unsigned __int8 **)v23, v32);
        uint64_t v34 = dyld4::Loader::loadAddress((dyld4::Loader *)a1, a3);
        uint64_t v31 = ((uint64_t (*)(void))(v34 + v33))() - v34;
        uint64_t v30 = (uint64_t)v72;
      }
      *(void *)uint64_t v30 = a1;
      *(void *)(v30 + 8) = a4;
      *(void *)(v30 + 16) = v31;
      if ((v28 & 3) == 2) {
        int v35 = 2;
      }
      else {
        int v35 = 1;
      }
      *(_DWORD *)(v30 + 32) = v35;
      uint64_t v36 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)a1, a3);
      *(unsigned char *)(v30 + 36) = dyld3::MachOFile::inCodeSection(v36, *(_DWORD *)(v30 + 16));
      uint64_t v37 = dyld4::Loader::resolvedAddress(a3, v30);
      *(void *)(v30 + 24) = v37;
      uint64_t v39 = dyld4::Loader::interpose(a3, v37, 0, v38);
      *(void *)(v30 + 24) = v39;
      if (*(unsigned char *)(v30 + 36)) {
        *(void *)(v30 + 24) = v39;
      }
      *(unsigned char *)(v30 + 37) = (v28 & 4) != 0;
      *(_WORD *)(v30 + 38) = 0;
      return 1;
    }
    return 0;
  }
  uint64_t v47 = dyld3::MachOFile::read_uleb128(a2, &v82, (const unsigned __int8 **)v23, v27);
  unint64_t v48 = v47;
  if (*(unsigned char *)v82)
  {
    BOOL v49 = _platform_strcmp((const char *)v82, (const char *)a4) != 0;
    if (!v48) {
      goto LABEL_56;
    }
  }
  else
  {
    BOOL v49 = 0;
    if (!v47)
    {
LABEL_56:
      uint64_t v52 = (const char *)dyld4::Loader::path((dyld4::Loader *)a1, a3);
      Diagnostics::error(a2, "re-export ordinal %lld in %s out of range for %s", v48, v52, (const char *)a4);
      return 0;
    }
  }
  if (v48 > dyld4::Loader::dependentCount((dyld4::Loader *)a1)) {
    goto LABEL_56;
  }
  LOBYTE(v77) = 0;
  uint64_t v54 = dyld4::Loader::dependent((dyld4::JustInTimeLoader *)a1, a3, (int)v48 - 1, (char *)&v77);
  if (!v54) {
    return 0;
  }
  if (a5 == 1 && v49) {
    uint64_t v61 = 0;
  }
  else {
    uint64_t v61 = a5;
  }
  char v62 = !v49;
  if (!a8) {
    char v62 = 1;
  }
  if (v62) {
    return dyld4::Loader::hasExportedSymbol();
  }
  __chkstk_darwin(v54, v55, v56, v57, v61, v58, v59, v60, v71);
  uint64_t v64 = (uint64_t *)*((void *)a3 + 6);
  uint64_t v78 = (uint64_t)&v71 - ((v63 + 23) & 0xFFFFFFFFFFFFFFF0);
  long long v79 = v64;
  uint64_t v80 = 0;
  return dyld4::Loader::hasExportedSymbol();
}

uint64_t *dyld3::Array<dyld4::Loader const*>::push_back(uint64_t *result, uint64_t *a2)
{
  unint64_t v2 = result[2];
  if (v2 >= result[1]) {
    ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
  }
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  result[2] = v2 + 1;
  *(void *)(v4 + 8 * v2) = v3;
  return result;
}

const unsigned __int8 **dyld3::MachOFile::trieWalk(vm_address_t *this, const unsigned __int8 **a2, Diagnostics *a3, const unsigned __int8 *a4, const char *a5)
{
  v34[0] = &v38;
  v34[1] = 128;
  vm_address_t address = 0;
  vm_size_t size = 0;
  uint64_t v35 = 0;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v34, 1);
  uint64_t v10 = 0;
  uint64_t v11 = v35++;
  *(_DWORD *)(v34[0] + 4 * v11) = 0;
  if (a2 >= (const unsigned __int8 **)a3) {
    goto LABEL_38;
  }
  uint64_t v12 = a2;
  while (2)
  {
    int v13 = *(char *)v12;
    uint64_t v33 = (const unsigned __int8 **)((char *)v12 + 1);
    if (v13 < 0)
    {
      uint64_t v33 = v12;
      uint64_t v14 = dyld3::MachOFile::read_uleb128(this, &v33, (const unsigned __int8 **)a3, v9);
      if (Diagnostics::hasError((Diagnostics *)this))
      {
LABEL_37:
        uint64_t v10 = 0;
        break;
      }
    }
    else
    {
      uint64_t v14 = v13;
    }
    uint64_t v10 = v33;
    if (*a4) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v14 == 0;
    }
    if (!v15) {
      break;
    }
    uint64_t v16 = (unsigned __int8 *)v33 + v14;
    if ((char *)v33 + v14 > (char *)a3) {
      goto LABEL_37;
    }
    int v19 = *v16;
    uint64_t v17 = (const unsigned __int8 **)(v16 + 1);
    int v18 = v19;
    uint64_t v33 = v17;
    if (!v19) {
      goto LABEL_37;
    }
    while (1)
    {
      int v20 = *(unsigned __int8 *)v17;
      if (!*(unsigned char *)v17) {
        break;
      }
      BOOL v21 = 0;
      uint64_t v22 = (const unsigned __int8 **)((char *)v17 + 1);
      uint64_t v23 = (const unsigned __int8 **)((char *)v17 + 2);
      int v24 = a4;
      do
      {
        uint64_t v17 = v23;
        if (v21)
        {
          BOOL v21 = 1;
        }
        else
        {
          int v25 = *v24++;
          BOOL v21 = v20 != v25;
        }
        uint64_t v33 = v22;
        int v26 = *(unsigned __int8 *)v22;
        uint64_t v22 = (const unsigned __int8 **)((char *)v22 + 1);
        int v20 = v26;
        uint64_t v23 = (const unsigned __int8 **)((char *)v23 + 1);
      }
      while (v26);
      if (!v21)
      {
        uint64_t v17 = (const unsigned __int8 **)((char *)v22 - 1);
        a4 = v24;
        break;
      }
      do
      {
        int v27 = *(char *)v17;
        uint64_t v17 = (const unsigned __int8 **)((char *)v17 + 1);
      }
      while (v27 < 0);
      uint64_t v33 = v17;
      if (v17 > (const unsigned __int8 **)a3)
      {
        Diagnostics::error(this, "malformed trie node, child node extends past end of trie\n");
        goto LABEL_37;
      }
      if (!(_BYTE)--v18) {
        goto LABEL_37;
      }
    }
    uint64_t v33 = (const unsigned __int8 **)((char *)v17 + 1);
    unint64_t v28 = dyld3::MachOFile::read_uleb128(this, &v33, (const unsigned __int8 **)a3, v9);
    if (Diagnostics::hasError((Diagnostics *)this)) {
      goto LABEL_37;
    }
    if (!v28
      || (uint64_t v12 = (const unsigned __int8 **)((char *)a2 + v28), (char *)a2 + v28 > (char *)a3)
      || v28 > a3 - (Diagnostics *)a2)
    {
      Diagnostics::error(this, "malformed trie child, nodeOffset=0x%llX out of range\n");
      goto LABEL_37;
    }
    if (v35)
    {
      uint64_t v29 = (_DWORD *)v34[0];
      uint64_t v30 = 4 * v35;
      while (v28 != *v29)
      {
        ++v29;
        v30 -= 4;
        if (!v30) {
          goto LABEL_33;
        }
      }
      Diagnostics::error(this, "malformed trie child, cycle to nodeOffset=0x%llX\n");
      goto LABEL_37;
    }
LABEL_33:
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v34, 1);
    uint64_t v10 = 0;
    uint64_t v31 = v35++;
    *(_DWORD *)(v34[0] + 4 * v31) = v28;
    uint64_t v33 = (const unsigned __int8 **)((char *)a2 + v28);
    if (v12 < (const unsigned __int8 **)a3) {
      continue;
    }
    break;
  }
LABEL_38:
  uint64_t v35 = 0;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  return v10;
}

BOOL Diagnostics::hasError(Diagnostics *this)
{
  return *(void *)this != 0;
}

void *dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 4 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    __n128 result = memmove((void *)v4[3], *v4, 4 * (void)v4[2]);
    uint64_t v9 = (const void *)((unint64_t)v4[4] >> 2);
    *uint64_t v4 = v4[3];
    v4[1] = v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::read_uleb128(vm_address_t *this, const unsigned __int8 ***a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  unint64_t v5 = 0;
  uint64_t v6 = 0;
  unint64_t v7 = *a2;
  vm_size_t v8 = "malformed uleb128";
  while (v7 != a3)
  {
    if (v5 > 0x3F)
    {
      vm_size_t v8 = "uleb128 too big for uint64";
      break;
    }
    v6 |= (unint64_t)(*(unsigned char *)v7 & 0x7F) << v5;
    v5 += 7;
    *a2 = (const unsigned __int8 **)((char *)v7 + 1);
    int v9 = *(char *)v7;
    unint64_t v7 = (const unsigned __int8 **)((char *)v7 + 1);
    if ((v9 & 0x80000000) == 0) {
      return v6;
    }
  }
  Diagnostics::error(this, v8);
  return v6;
}

BOOL dyld4::Loader::getExportsTrie(dyld4::Loader *this, unint64_t *a2, unsigned int *a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::getExportsTrie();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::getExportsTrie(this, a2, a3);
  }
  else
  {
    return dyld4::JustInTimeLoader::getExportsTrie(this, a2, a3);
  }
}

BOOL dyld4::PrebuiltLoader::getExportsTrie(dyld4::PrebuiltLoader *this, unint64_t *a2, unsigned int *a3)
{
  *a2 = *((void *)this + 8);
  unsigned int v3 = *((_DWORD *)this + 18);
  *a3 = v3;
  return v3 != 0;
}

void *___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v9 = *(void *)(a1 + 40);
  vm_map_t v10 = *(const dyld4::RuntimeState **)(a1 + 48);
  uint64_t v11 = (const void *)(v9 + a2);
  if (*(unsigned char *)(*((void *)v10 + 1) + 203))
  {
    uint64_t v12 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 32), v10);
    dyld4::RuntimeState::log(v10, "running initializer %p in %s\n", v11, v12);
    uint64_t v9 = *(void *)(a1 + 40);
  }
  int v23 = 520552448;
  uint64_t v24 = v9;
  uint64_t v25 = 0;
  int v26 = v11;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  __n128 result = dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v23, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v14 = *(void *)(a1 + 48);
  if (!*(unsigned char *)(v14 + 656))
  {
    ((void (*)(void, void, void, void, void))v11)(*(unsigned int *)(*(void *)(v14 + 8) + 104), *(void *)(*(void *)(v14 + 8) + 112), *(void *)(*(void *)(v14 + 8) + 120), *(void *)(*(void *)(v14 + 8) + 128), *(void *)(v14 + 144));
    return (void *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v23);
  }
  uint64_t v33 = *(void *)(v14 + 128);
  unint64_t v32 = 0;
  if (v33) {
    uint64_t v15 = v33;
  }
  else {
    uint64_t v15 = 0;
  }
  if (*(unsigned char *)(v15 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_44;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    unint64_t v32 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (v32 == 1)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_44;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      __n128 result = (void *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v16 = MEMORY[0xFFFFFC0D8];
      if (v16 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_44;
      }
    }
  }
  else
  {
    unint64_t v32 = 0xFFFFFFFFLL;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v15, &v34);
    uint64_t v17 = *(void *)(v15 + 24) - 1;
    *(void *)(v15 + 24) = v17;
    if (!v17) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v15, 1);
    }
    lsl::Lock::unlock(v34);
  }
  __n128 result = (void *)((uint64_t (*)(void, void, void, void, void))v11)(*(unsigned int *)(*(void *)(v14 + 8) + 104), *(void *)(*(void *)(v14 + 8) + 112), *(void *)(*(void *)(v14 + 8) + 120), *(void *)(*(void *)(v14 + 8) + 128), *(void *)(v14 + 144));
  if (v33) {
    uint64_t v18 = v33;
  }
  else {
    uint64_t v18 = 0;
  }
  if (!*(unsigned char *)(v18 + 32))
  {
    lsl::MemoryManager::lockGuard((lsl::Lock *)v18, &v34);
    if (v32 == 1)
    {
      uint64_t v22 = *(void *)(v18 + 24) - 1;
      *(void *)(v18 + 24) = v22;
      if (!v22) {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v18, 1);
      }
    }
    else if (v32 == 0xFFFFFFFF)
    {
      uint64_t v21 = *(void *)(v18 + 24);
      if (!v21)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v18, 0);
        uint64_t v21 = *(void *)(v18 + 24);
      }
      *(void *)(v18 + 24) = v21 + 1;
    }
    lsl::Lock::unlock(v34);
    return (void *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v23);
  }
  if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
    goto LABEL_44;
  }
  if (v32 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
    return (void *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v23);
  }
  if (v32 == 1)
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    __n128 result = (void *)MEMORY[0xFFFFFC0D0];
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
    __isb(0xFu);
    uint64_t v19 = MEMORY[0xFFFFFC0D0];
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
  }
  else
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    __n128 result = (void *)MEMORY[0xFFFFFC0D8];
    _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
    __isb(0xFu);
    uint64_t v19 = MEMORY[0xFFFFFC0D8];
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
  }
  if (v19 == StatusReg) {
    return (void *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v23);
  }
LABEL_44:
  __break(1u);
  return result;
}

int64_t dyld3::kdebug_trace_dyld_duration_end(int64_t result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!result) {
    return result;
  }
  uint64_t v11 = a5;
  int v13 = a3;
  uint64_t v15 = (void *)result;
  __n128 result = kdebug_is_enabled(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!result) {
    return result;
  }
  if (a4)
  {
    int64_t v21 = kdebug_trace_string(a2, 0, a4, v16, v17, v18, v19, v20);
    if (v21 == -1) {
      int v13 = 0;
    }
    else {
      int v13 = (void *)v21;
    }
  }
  if (a6)
  {
    int64_t v22 = kdebug_trace_string(a2, 0, a6, v16, v17, v18, v19, v20);
    if (v22 == -1) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (void *)v22;
    }
  }
  if (a8)
  {
    int64_t v23 = kdebug_trace_string(a2, 0, a8, v16, v17, v18, v19, v20);
    if (v23 == -1) {
      long long v27 = 0;
    }
    else {
      long long v27 = (void *)v23;
    }
    __n128 result = kdebug_trace((void *)(a2 | 2), v15, v13, v11, v27, v24, v25, v26);
    if (v27) {
      __n128 result = kdebug_trace_string(a2, v27, 0, v28, v29, v30, v31, v32);
    }
    if (!a6) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }
  __n128 result = kdebug_trace((void *)(a2 | 2), v15, v13, v11, a7, v18, v19, v20);
  if (a6)
  {
LABEL_20:
    if (v11) {
      __n128 result = kdebug_trace_string(a2, v11, 0, v28, v29, v30, v31, v32);
    }
  }
LABEL_22:
  if (a4 && v13)
  {
    return kdebug_trace_string(a2, v13, 0, v28, v29, v30, v31, v32);
  }
  return result;
}

void *dyld3::ScopedTimer::startTimer(dyld3::ScopedTimer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  __n128 result = dyld3::kdebug_trace_dyld_duration_start((void *)*(unsigned int *)this, *((void *)this + 1), *((void **)this + 2), *((void **)this + 3), *((void **)this + 4), *((void **)this + 5), *((void **)this + 6), a8);
  *((void *)this + 13) = result;
  return result;
}

uint64_t dyld3::ScopedTimer::endTimer(dyld3::ScopedTimer *this)
{
  return dyld3::kdebug_trace_dyld_duration_end(*((void *)this + 13), (void *)*(unsigned int *)this, *((void **)this + 7), *((void **)this + 8), *((void **)this + 9), *((void **)this + 10), *((void **)this + 11), *((void **)this + 12));
}

const dyld4::RuntimeState *dyld4::Loader::resolvedAddress(const dyld4::RuntimeState *result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 32);
  if (v2 < 2) {
    return (const dyld4::RuntimeState *)(*(void *)(a2 + 16) + dyld4::Loader::loadAddress(*(dyld4::Loader **)a2, result));
  }
  if (v2 == 2) {
    return *(const dyld4::RuntimeState **)(a2 + 16);
  }
  return result;
}

dyld4::RuntimeState *dyld4::Loader::interpose(dyld4::Loader *this, dyld4::RuntimeState *a2, dyld4::Loader *a3, const dyld4::Loader *a4)
{
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v6 = *((void *)this + 30);
    if (v6)
    {
      unint64_t v7 = (dyld4::RuntimeState **)*((void *)this + 29);
      uint64_t v8 = 16 * v6;
      while (v7[1] != a2)
      {
        v7 += 2;
        v8 -= 16;
        if (!v8) {
          goto LABEL_6;
        }
      }
      goto LABEL_21;
    }
LABEL_6:
    uint64_t v9 = *((void *)this + 38);
    if (v9)
    {
      unint64_t v7 = (dyld4::RuntimeState **)*((void *)this + 37);
      uint64_t v10 = 16 * v9;
      while (v7[1] != a2)
      {
        v7 += 2;
        v10 -= 16;
        if (!v10) {
          goto LABEL_10;
        }
      }
LABEL_21:
      uint64_t v11 = *((void *)this + 1);
      goto LABEL_22;
    }
LABEL_10:
    uint64_t v11 = *((void *)this + 1);
    if (*(unsigned char *)(v11 + 190))
    {
      uint64_t v12 = *((void *)this + 26);
      if (v12)
      {
        unint64_t v7 = (dyld4::RuntimeState **)(*((void *)this + 25) + 8);
        uint64_t v13 = 24 * v12;
        while (v7[1] != a2 || *(v7 - 1) != a3)
        {
          v7 += 3;
          v13 -= 24;
          if (!v13) {
            goto LABEL_16;
          }
        }
        if (!*(unsigned char *)(v11 + 206)) {
          return *v7;
        }
        uint64_t v16 = *v7;
        goto LABEL_24;
      }
LABEL_16:
      uint64_t v14 = *((void *)this + 22);
      if (v14)
      {
        unint64_t v7 = (dyld4::RuntimeState **)*((void *)this + 21);
        uint64_t v15 = 16 * v14;
        while (v7[1] != a2)
        {
          v7 += 2;
          v15 -= 16;
          if (!v15) {
            return v4;
          }
        }
LABEL_22:
        if (!*(unsigned char *)(v11 + 206)) {
          return *v7;
        }
        uint64_t v16 = *v7;
        if (!a3)
        {
          uint64_t v17 = "dlsym";
          goto LABEL_26;
        }
LABEL_24:
        uint64_t v17 = (const char *)dyld4::Loader::path(a3, this);
LABEL_26:
        dyld4::RuntimeState::log(this, "  interpose replaced 0x%08lX with 0x%08lX in %s\n", v4, v16, v17);
        return *v7;
      }
    }
  }
  return v4;
}

uint64_t dyld4::Loader::mf(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::mf();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::mf(this, a2);
  }
  else
  {
    return dyld4::JustInTimeLoader::mf((uint64_t)this);
  }
}

BOOL dyld3::MachOFile::inCodeSection(dyld3::MachOFile *this, int a2)
{
  if (*((_DWORD *)this + 1) != 16777228 || (*((_DWORD *)this + 2) & 0xFFFFFF) != 2) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile13inCodeSectionEj_block_invoke;
  void v5[3] = &unk_1EFF66438;
  int v6 = a2;
  v5[4] = &v7;
  v5[5] = dyld3::MachOFile::preferredLoadAddress(this);
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  BOOL v3 = *((unsigned char *)v8 + 24) != 0;
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t dyld3::MachOFile::preferredLoadAddress(dyld3::MachOFile *this)
{
  uint64_t v4 = 0;
  unint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile20preferredLoadAddressEv_block_invoke;
  v3[3] = &unk_1EFF662A8;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void dyld3::MachOFile::forEachSection(_DWORD *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v9);
  BOOL v4 = a1[1] == 7;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  int v8 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile14forEachSectionEU13block_pointerFvRKNS0_11SectionInfoEbRbE_block_invoke;
  void v5[3] = &unk_1EFF662D0;
  void v5[6] = a1;
  void v5[7] = &v10;
  v5[4] = a2;
  v5[5] = v7;
  BOOL v6 = v4;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v9, (uint64_t)v5);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  _Block_object_dispose(v7, 8);
  mach_o::Error::~Error(&v9);
}

void dyld3::MachOFile::forEachSegment(_DWORD *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v9);
  BOOL v4 = a1[1] == 7;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  int v8 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile14forEachSegmentEU13block_pointerFvRKNS0_11SegmentInfoERbE_block_invoke;
  void v5[3] = &unk_1EFF66280;
  v5[5] = v7;
  void v5[6] = a1;
  v5[4] = a2;
  BOOL v6 = v4;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v9, (uint64_t)v5);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  _Block_object_dispose(v7, 8);
  mach_o::Error::~Error(&v9);
}

_DWORD *dyld3::MachOFile::forEachLoadCommand(_DWORD *result, vm_address_t *this, uint64_t a3)
{
  unint64_t v5 = result;
  int v6 = *result;
  if (*result == -17958193)
  {
    uint64_t v7 = 8;
  }
  else
  {
    if (v6 != -17958194)
    {
      if ((v6 & 0xFEFFFFFF) != 0xCEFAEDFE) {
        return (_DWORD *)Diagnostics::error(this, "file does not start with MH_MAGIC[_64]: 0x%08X 0x%08X");
      }
      return result;
    }
    uint64_t v7 = 7;
  }
  if (result[3] >= 0xDu) {
    return (_DWORD *)Diagnostics::error(this, "unknown mach-o filetype (%u)");
  }
  if (result[4])
  {
    unsigned int v8 = 0;
    uint64_t v9 = &result[v7];
    unint64_t v10 = (unint64_t)&result[v7] + result[5];
    unint64_t v11 = (unint64_t)&result[v7];
    while (1)
    {
      if (v11 > v10 - 8) {
        return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, extends past sizeofcmds");
      }
      uint64_t v12 = *(unsigned int *)(v11 + 4);
      if (v12 <= 7) {
        return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, size (0x%X) too small");
      }
      if ((v12 & 3) != 0) {
        break;
      }
      unint64_t v13 = v11 + v12;
      if (v11 + v12 > v10 || v13 < (unint64_t)v9) {
        return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, size (0x%X) is too large, load commands end at %p");
      }
      __n128 result = (_DWORD *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      ++v8;
      unint64_t v11 = v13;
      if (v8 >= v5[4]) {
        return result;
      }
    }
    return (_DWORD *)Diagnostics::error(this, "malformed load command #%u of %u at %p with mh=%p, size (0x%X) not multiple of 4");
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14forEachSectionEU13block_pointerFvRKNS0_11SectionInfoEbRbE_block_invoke(uint64_t result, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = result;
  uint64_t v11 = *(void *)(result + 48);
  if (*(_DWORD *)a2 == 1)
  {
    uint64_t v20 = *(unsigned int *)(a2 + 28);
    unint64_t v21 = a2 + 56;
    unsigned int v22 = *(_DWORD *)(a2 + 48);
    unint64_t v23 = a2 + 56 + 68 * v22;
    if (v22)
    {
      int v24 = 0;
      LOBYTE(v25) = 0;
      do
      {
        if (*(_DWORD *)(v21 + 44) > v25) {
          int v25 = *(_DWORD *)(v21 + 44);
        }
        v24 |= (*(unsigned char *)(v21 + 57) & 3) != 0;
        v21 += 68;
      }
      while (v21 < v23);
      unsigned int v26 = *(_DWORD *)(a2 + 24);
      unsigned int v27 = *(_DWORD *)(v21 - 32) + *(_DWORD *)(v21 - 36) - v26;
      int v28 = v25 << 16;
    }
    else
    {
      int v28 = 0;
      int v24 = 0;
      unsigned int v26 = *(_DWORD *)(a2 + 24);
      unsigned int v27 = *(_DWORD *)(a2 + 28);
    }
    uint64_t v42 = *(void *)(a2 + 32);
    *(void *)&long long v43 = v42;
    *((void *)&v43 + 1) = HIDWORD(v42);
    long long v57 = v43;
    uint64_t v58 = v26;
    uint64_t v59 = v20;
    uint64_t v60 = v27;
    uint64_t v61 = a2 + 8;
    int v44 = *(_DWORD *)(a2 + 44);
    int v62 = a2 - v11;
    int v63 = v44;
    long long v31 = (uint64_t *)(result + 40);
    uint64_t v30 = *(void *)(result + 40);
    BOOL v46 = (v44 & 2) == 0 && *(unsigned char *)(result + 64) != 0;
    int v64 = (*(_DWORD *)(a2 + 52) >> 3) & 2 | v46 & v24 & 0xFF0007 | (*(_DWORD *)(a2 + 52) >> 1) & 4 | v28 & 0xFF0007 | (16 * (*(_DWORD *)(*(void *)(v30 + 8) + 24) & 0xFFF));
    if (*a3 || !v22) {
      goto LABEL_57;
    }
    unint64_t v47 = a2 + 124;
    do
    {
      unint64_t v48 = (const char *)(v47 - 68);
      if (*(unsigned char *)(v47 - 53))
      {
        strlcpy(*(char **)(v10 + 56), v48, 0x11uLL);
        unint64_t v48 = *(const char **)(v10 + 56);
      }
      unsigned int v49 = *(_DWORD *)(a2 + 24);
      unint64_t v50 = *(unsigned int *)(v47 - 36);
      if (v50 >= v49)
      {
        unsigned int v52 = *(_DWORD *)(a2 + 36) + v49;
        BOOL v39 = v52 >= v50;
        unsigned int v53 = v52 - v50;
        uint64_t v51 = !v39 || v53 < *(_DWORD *)(v47 - 32);
      }
      else
      {
        uint64_t v51 = 1;
      }
      uint64_t v66 = *(unsigned int *)(v47 - 32);
      uint64_t v67 = v48;
      int v55 = *(_DWORD *)(v47 - 12);
      int v56 = *(_DWORD *)(v47 - 24);
      int v68 = *(_DWORD *)(v47 - 28);
      int v69 = v55;
      unint64_t v65 = v50;
      int v70 = v56;
      uint64_t v71 = *(void *)(v47 - 8);
      __n128 result = (*(uint64_t (**)(void, long long *, uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 32) + 16))(*(void *)(v10 + 32), &v57, v51, a3, a5, a6, a7, a8);
      if (*a3) {
        break;
      }
      BOOL v39 = v47 >= v23;
      v47 += 68;
    }
    while (!v39);
    goto LABEL_56;
  }
  if (*(_DWORD *)a2 != 25) {
    return result;
  }
  uint64_t v12 = *(void *)(a2 + 32);
  unint64_t v13 = a2 + 72;
  unsigned int v14 = *(_DWORD *)(a2 + 64);
  unint64_t v15 = a2 + 72 + 80 * v14;
  if (v14)
  {
    LOBYTE(v16) = 0;
    do
    {
      if (*(_DWORD *)(v13 + 52) > v16) {
        int v16 = *(_DWORD *)(v13 + 52);
      }
      v13 += 80;
    }
    while (v13 < v15);
    uint64_t v17 = *(void *)(a2 + 24);
    uint64_t v18 = *(void *)(v13 - 40) + *(void *)(v13 - 48) - v17;
    int v19 = v16 << 16;
  }
  else
  {
    int v19 = 0;
    uint64_t v17 = *(void *)(a2 + 24);
    uint64_t v18 = *(void *)(a2 + 32);
  }
  long long v57 = *(_OWORD *)(a2 + 40);
  uint64_t v58 = v17;
  uint64_t v59 = v12;
  uint64_t v60 = v18;
  uint64_t v61 = a2 + 8;
  int v29 = *(_DWORD *)(a2 + 60);
  int v62 = a2 - v11;
  int v63 = v29;
  int v64 = (*(_DWORD *)(a2 + 68) >> 3) & 2 | (*(_DWORD *)(a2 + 68) >> 1) & 4 | v19;
  long long v31 = (uint64_t *)(result + 40);
  uint64_t v30 = *(void *)(result + 40);
  int v64 = v64 & 0xFF0006 | (16 * (*(_DWORD *)(*(void *)(v30 + 8) + 24) & 0xFFF));
  if (!*a3 && v14)
  {
    unint64_t v32 = a2 + 152;
    do
    {
      uint64_t v33 = (const char *)(v32 - 80);
      if (*(unsigned char *)(v32 - 65))
      {
        strlcpy(*(char **)(v10 + 56), v33, 0x11uLL);
        uint64_t v33 = *(const char **)(v10 + 56);
      }
      unint64_t v34 = *(void *)(a2 + 24);
      unint64_t v35 = *(void *)(v32 - 48);
      if (v35 >= v34)
      {
        unint64_t v37 = *(void *)(a2 + 48) + v34;
        BOOL v39 = v37 >= v35;
        unint64_t v38 = v37 - v35;
        BOOL v39 = v39 && v38 >= *(void *)(v32 - 40);
        uint64_t v36 = !v39;
      }
      else
      {
        uint64_t v36 = 1;
      }
      uint64_t v66 = *(void *)(v32 - 40);
      uint64_t v67 = v33;
      int v40 = *(_DWORD *)(v32 - 16);
      int v41 = *(_DWORD *)(v32 - 28);
      int v68 = *(_DWORD *)(v32 - 32);
      int v69 = v40;
      unint64_t v65 = v35;
      int v70 = v41;
      uint64_t v71 = *(void *)(v32 - 12);
      __n128 result = (*(uint64_t (**)(void, long long *, uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 32) + 16))(*(void *)(v10 + 32), &v57, v36, a3, a5, a6, a7, a8);
      if (*a3) {
        break;
      }
      BOOL v39 = v32 >= v15;
      v32 += 80;
    }
    while (!v39);
LABEL_56:
    uint64_t v30 = *v31;
  }
LABEL_57:
  ++*(_DWORD *)(*(void *)(v30 + 8) + 24);
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14forEachSegmentEU13block_pointerFvRKNS0_11SegmentInfoERbE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)(result + 48);
  if (*(_DWORD *)a2 == 1)
  {
    unint64_t v13 = *(unsigned int *)(a2 + 28);
    unsigned int v14 = *(_DWORD *)(a2 + 48);
    if (v14)
    {
      int v15 = 0;
      LOBYTE(v16) = 0;
      unint64_t v17 = a2 + 56;
      unint64_t v18 = a2 + 56 + 68 * v14;
      do
      {
        if (*(_DWORD *)(v17 + 44) > v16) {
          int v16 = *(_DWORD *)(v17 + 44);
        }
        v15 |= (*(unsigned char *)(v17 + 57) & 3) != 0;
        v17 += 68;
      }
      while (v17 < v18);
      int v19 = *(_DWORD *)(v17 - 32) + *(_DWORD *)(v17 - 36);
      unsigned int v20 = *(_DWORD *)(a2 + 24);
      unsigned int v21 = v19 - v20;
      int v22 = v16 << 16;
    }
    else
    {
      int v22 = 0;
      int v15 = 0;
      unsigned int v20 = *(_DWORD *)(a2 + 24);
      unsigned int v21 = *(_DWORD *)(a2 + 28);
    }
    unint64_t v29 = *(unsigned int *)(a2 + 36);
    uint64_t v36 = *(unsigned int *)(a2 + 32);
    unint64_t v37 = v29;
    uint64_t v38 = v20;
    unint64_t v39 = v13;
    uint64_t v40 = v21;
    uint64_t v41 = a2 + 8;
    int v30 = *(_DWORD *)(a2 + 44);
    int v42 = a2 - v3;
    int v43 = v30;
    BOOL v32 = (v30 & 2) == 0 && *(unsigned char *)(result + 56) != 0;
    int v33 = (*(_DWORD *)(a2 + 52) >> 3) & 2 | (*(_DWORD *)(a2 + 52) >> 1) & 4 | v32 & v15;
    if (v29 < v13 && v30 == 3) {
      int v35 = 8;
    }
    else {
      int v35 = 0;
    }
    uint64_t v27 = *(void *)(result + 32);
    int v28 = v35 | v22 | v33 | (16 * (*(_DWORD *)(*(void *)(*(void *)(v2 + 40) + 8) + 24) & 0xFFF));
  }
  else
  {
    if (*(_DWORD *)a2 != 25) {
      return result;
    }
    unint64_t v4 = *(void *)(a2 + 32);
    unsigned int v5 = *(_DWORD *)(a2 + 64);
    if (v5)
    {
      LOBYTE(v6) = 0;
      unint64_t v7 = a2 + 72;
      unint64_t v8 = a2 + 72 + 80 * v5;
      do
      {
        if (*(_DWORD *)(v7 + 52) > v6) {
          int v6 = *(_DWORD *)(v7 + 52);
        }
        v7 += 80;
      }
      while (v7 < v8);
      uint64_t v9 = *(void *)(v7 - 40) + *(void *)(v7 - 48);
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v11 = v9 - v10;
      int v12 = v6 << 16;
    }
    else
    {
      int v12 = 0;
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v11 = *(void *)(a2 + 32);
    }
    unint64_t v23 = *(void *)(a2 + 48);
    uint64_t v36 = *(void *)(a2 + 40);
    unint64_t v37 = v23;
    uint64_t v38 = v10;
    unint64_t v39 = v4;
    uint64_t v40 = v11;
    uint64_t v41 = a2 + 8;
    int v24 = *(_DWORD *)(a2 + 60);
    int v42 = a2 - v3;
    int v43 = v24;
    if (v23 < v4 && v24 == 3) {
      int v26 = 8;
    }
    else {
      int v26 = 0;
    }
    uint64_t v27 = *(void *)(result + 32);
    int v28 = v26 | v12 | (*(_DWORD *)(a2 + 68) >> 3) & 2 | (*(_DWORD *)(a2 + 68) >> 1) & 4 | (16
                                                                                         * (*(_DWORD *)(*(void *)(*(void *)(v2 + 40) + 8) + 24) & 0xFFF));
  }
  int v44 = v28;
  __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *))(v27 + 16))(v27, &v36);
  ++*(_DWORD *)(*(void *)(*(void *)(v2 + 40) + 8) + 24);
  return result;
}

uint64_t ___ZNK5dyld39MachOFile13inCodeSectionEj_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unint64_t v4 = *(void *)(a2 + 64) - *(void *)(result + 40);
  unint64_t v5 = *(unsigned int *)(result + 48);
  if (v4 <= v5 && v4 + *(void *)(a2 + 72) > v5)
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = (*(_DWORD *)(a2 + 92) & 0x80000400) != 0;
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasLoadCommandEj_block_invoke(uint64_t result, _DWORD *a2, unsigned char *a3)
{
  if (*a2 == *(_DWORD *)(result + 40))
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

size_t _platform_strlcpy(void *a1, char *__s, size_t a3)
{
  size_t v6 = _platform_strlen(__s);
  size_t v7 = v6;
  if (v6 >= a3)
  {
    if (a3)
    {
      size_t v8 = a3 - 1;
      memmove(a1, __s, v8);
      *((unsigned char *)a1 + v8) = 0;
    }
  }
  else
  {
    memmove(a1, __s, v6 + 1);
  }
  return v7;
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __n)
{
  if ((unsigned char *)__dst - (unsigned char *)__src < __n)
  {
    if (__dst != __src)
    {
      unint64_t v34 = (char *)__dst + __n;
      int v35 = (char *)__src + __n;
      if (__n < 0x40)
      {
        while (1)
        {
          BOOL v31 = __n >= 8;
          __n -= 8;
          if (!v31) {
            break;
          }
          uint64_t v50 = *((void *)v35 - 1);
          v35 -= 8;
          *((void *)v34 - 1) = v50;
          v34 -= 8;
        }
        for (size_t i = __n + 8; i; --i)
        {
          char v52 = *--v35;
          *--unint64_t v34 = v52;
        }
      }
      else
      {
        if (__n < 0x4000)
        {
          long long v47 = *((_OWORD *)v35 - 2);
          long long v48 = *((_OWORD *)v35 - 1);
          unint64_t v38 = (unint64_t)(v34 - 1) & 0xFFFFFFFFFFFFFFE0;
          uint64_t v49 = v35 - &v34[-v38];
          long long v40 = *(_OWORD *)(v49 - 32);
          long long v41 = *(_OWORD *)(v49 - 16);
          *((_OWORD *)v34 - 2) = v47;
          *((_OWORD *)v34 - 1) = v48;
          uint64_t v42 = v49 - 32;
          unint64_t v43 = v38 - (void)__dst - 64;
          if (v38 - (unint64_t)__dst > 0x40)
          {
            do
            {
              *(_OWORD *)(v38 - 32) = v40;
              *(_OWORD *)(v38 - 16) = v41;
              v38 -= 32;
              long long v40 = *(_OWORD *)(v42 - 32);
              long long v41 = *(_OWORD *)(v42 - 16);
              v42 -= 32;
              BOOL v12 = v43 > 0x20;
              v43 -= 32;
            }
            while (v12);
          }
        }
        else
        {
          long long v36 = *((_OWORD *)v35 - 2);
          long long v37 = *((_OWORD *)v35 - 1);
          unint64_t v38 = (unint64_t)(v34 - 1) & 0xFFFFFFFFFFFFFFE0;
          uint64_t v39 = v35 - &v34[-v38];
          long long v40 = *(_OWORD *)(v39 - 32);
          long long v41 = *(_OWORD *)(v39 - 16);
          *((_OWORD *)v34 - 2) = v36;
          *((_OWORD *)v34 - 1) = v37;
          uint64_t v42 = v39 - 32;
          unint64_t v43 = v38 - (void)__dst - 64;
          if (v38 - (unint64_t)__dst > 0x40)
          {
            do
            {
              *(_OWORD *)(v38 - 32) = v40;
              *(_OWORD *)(v38 - 16) = v41;
              v38 -= 32;
              long long v40 = *(_OWORD *)(v42 - 32);
              long long v41 = *(_OWORD *)(v42 - 16);
              v42 -= 32;
              BOOL v12 = v43 > 0x20;
              v43 -= 32;
            }
            while (v12);
          }
        }
        uint64_t v44 = v42 - v43;
        long long v45 = *(_OWORD *)(v44 - 32);
        long long v46 = *(_OWORD *)(v44 - 16);
        *(_OWORD *)(v38 - 32) = v40;
        *(_OWORD *)(v38 - 16) = v41;
        *(_OWORD *)__dst = v45;
        *((_OWORD *)__dst + 1) = v46;
      }
    }
  }
  else
  {
    uint64_t v3 = __dst;
    if (__n < 0x40)
    {
      while (1)
      {
        BOOL v31 = __n >= 8;
        __n -= 8;
        if (!v31) {
          break;
        }
        uint64_t v30 = *(void *)__src;
        __src = (char *)__src + 8;
        *v3++ = v30;
      }
      for (size_t j = __n + 8; j; --j)
      {
        char v33 = *(unsigned char *)__src;
        __src = (char *)__src + 1;
        *(unsigned char *)uint64_t v3 = v33;
        uint64_t v3 = (void *)((char *)v3 + 1);
      }
    }
    else
    {
      if ((unsigned char *)__src - (unsigned char *)__dst < __n)
      {
        if (__n < 0x4000)
        {
          unint64_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
          long long v22 = *(_OWORD *)__src;
          long long v23 = *((_OWORD *)__src + 1);
          int v24 = (long long *)((char *)__src + v4 - (unsigned char *)__dst);
          long long v8 = *v24;
          long long v9 = v24[1];
          uint64_t v10 = v24 + 2;
          size_t v25 = __n - (v4 - (unsigned char *)__dst);
          *(_OWORD *)__dst = v22;
          *((_OWORD *)__dst + 1) = v23;
          BOOL v12 = v25 > 0x40;
          for (unint64_t k = v25 - 64; v12; k -= 32)
          {
            *(_OWORD *)unint64_t v4 = v8;
            *((_OWORD *)v4 + 1) = v9;
            v4 += 32;
            long long v8 = *v10;
            long long v9 = v10[1];
            v10 += 2;
            BOOL v12 = k > 0x20;
          }
        }
        else
        {
          unint64_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
          long long v18 = *(_OWORD *)__src;
          long long v19 = *((_OWORD *)__src + 1);
          unsigned int v20 = (long long *)((char *)__src + v4 - (unsigned char *)__dst);
          long long v8 = *v20;
          long long v9 = v20[1];
          uint64_t v10 = v20 + 2;
          size_t v21 = __n - (v4 - (unsigned char *)__dst);
          *(_OWORD *)__dst = v18;
          *((_OWORD *)__dst + 1) = v19;
          BOOL v12 = v21 > 0x40;
          for (unint64_t k = v21 - 64; v12; k -= 32)
          {
            *(_OWORD *)unint64_t v4 = v8;
            *((_OWORD *)v4 + 1) = v9;
            v4 += 32;
            long long v8 = *v10;
            long long v9 = v10[1];
            v10 += 2;
            BOOL v12 = k > 0x20;
          }
        }
      }
      else if (__n < 0x4000)
      {
        unint64_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
        long long v14 = *(_OWORD *)__src;
        long long v15 = *((_OWORD *)__src + 1);
        int v16 = (long long *)((char *)__src + v4 - (unsigned char *)__dst);
        long long v8 = *v16;
        long long v9 = v16[1];
        uint64_t v10 = v16 + 2;
        size_t v17 = __n - (v4 - (unsigned char *)__dst);
        *(_OWORD *)__dst = v14;
        *((_OWORD *)__dst + 1) = v15;
        BOOL v12 = v17 > 0x40;
        for (unint64_t k = v17 - 64; v12; k -= 32)
        {
          *(_OWORD *)unint64_t v4 = v8;
          *((_OWORD *)v4 + 1) = v9;
          v4 += 32;
          long long v8 = *v10;
          long long v9 = v10[1];
          v10 += 2;
          BOOL v12 = k > 0x20;
        }
      }
      else
      {
        unint64_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0);
        long long v5 = *(_OWORD *)__src;
        long long v6 = *((_OWORD *)__src + 1);
        size_t v7 = (long long *)((char *)__src + v4 - (unsigned char *)__dst);
        long long v8 = *v7;
        long long v9 = v7[1];
        uint64_t v10 = v7 + 2;
        size_t v11 = __n - (v4 - (unsigned char *)__dst);
        *(_OWORD *)__dst = v5;
        *((_OWORD *)__dst + 1) = v6;
        BOOL v12 = v11 > 0x40;
        for (unint64_t k = v11 - 64; v12; k -= 32)
        {
          *(_OWORD *)unint64_t v4 = v8;
          *((_OWORD *)v4 + 1) = v9;
          v4 += 32;
          long long v8 = *v10;
          long long v9 = v10[1];
          v10 += 2;
          BOOL v12 = k > 0x20;
        }
      }
      int v26 = (long long *)((char *)v10 + k);
      long long v27 = *v26;
      long long v28 = v26[1];
      *(_OWORD *)unint64_t v4 = v8;
      *((_OWORD *)v4 + 1) = v9;
      unint64_t v29 = &v4[k];
      *((_OWORD *)v29 + 2) = v27;
      *((_OWORD *)v29 + 3) = v28;
    }
  }
  return __dst;
}

void *___ZNK5dyld313MachOAnalyzer26forEachThreadLocalVariableER11DiagnosticsU13block_pointerFvPU9__ptrauthILj0ELb0ELj0EEPFPvPNS0_9TLV_ThunkEEPmE_block_invoke(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  int v4 = *(unsigned __int8 *)(a2 + 92);
  if ((v4 - 17) >= 2)
  {
    if (v4 == 19)
    {
      long long v8 = (dyld3::MachOFile *)result[6];
      BOOL v9 = dyld3::MachOFile::is64(v8);
      uint64_t v10 = v3[7];
      uint64_t v11 = v3[4];
      if (v9)
      {
        return (void *)dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<long long>(v8, v10, a2, v11);
      }
      else
      {
        return (void *)dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<int>(v8, v10, a2, v11);
      }
    }
  }
  else
  {
    uint64_t v5 = *(void *)(result[5] + 8);
    uint64_t v6 = *(void *)(v5 + 40);
    uint64_t v7 = *(void *)(a2 + 64);
    if (v6)
    {
      *(void *)(v5 + 48) = v7 + *(void *)(a2 + 72) - result[8] - v6;
    }
    else
    {
      *(void *)(v5 + 4dyld4::halt((char *)__format, 0) = v7 - result[8];
      *(void *)(*(void *)(result[5] + 8) + 48) = *(void *)(a2 + 72);
    }
  }
  return result;
}

__n128 ___ZNK5dyld39MachOFile7getUuidEPh_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (*(_DWORD *)a2 == 27)
  {
    __n128 result = *(__n128 *)(a2 + 8);
    *(__n128 *)*(void *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

Diagnostics *Diagnostics::assertNoError(Diagnostics *this)
{
  if (*(void *)this) {
    Diagnostics::assertNoError(this);
  }
  return this;
}

uint64_t ___ZNK5dyld311MachOLoaded23getLinkEditLoadCommandsER11DiagnosticsRNS0_12LinkEditInfoE_block_invoke(uint64_t result, int *a2)
{
  uint64_t v3 = result;
  int v4 = *a2;
  if (*a2 <= 1)
  {
    switch(v4)
    {
      case -2147483614:
LABEL_12:
        if (a2[1] == 48)
        {
          if (**(void **)(v3 + 72)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DYLD_INFO load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DYLD_INFO load command size wrong");
        }
        **(void **)(v3 + 72) = a2;
        break;
      case -2147483597:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(result + 72) + 8)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(result + 64), "multiple LC_DYLD_EXPORTS_TRIE load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(result + 64), "LC_DYLD_EXPORTS_TRIE load command size wrong");
        }
        *(void *)(*(void *)(v3 + 72) + 8) = a2;
        break;
      case -2147483596:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(result + 72) + 16)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(result + 64), "multiple LC_DYLD_CHAINED_FIXUPS load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(result + 64), "LC_DYLD_CHAINED_FIXUPS load command size wrong");
        }
        *(void *)(*(void *)(v3 + 72) + 16) = a2;
        break;
    }
  }
  else
  {
    __n128 result = *(void *)(result + 56);
    switch(v4)
    {
      case 27:
        if (a2[1] == 24)
        {
          if (*(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + 24)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_UUID load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_UUID load command size wrong");
        }
        uint64_t v5 = *(void *)(v3 + 32);
        goto LABEL_72;
      case 28:
      case 31:
      case 32:
      case 35:
      case 39:
      case 40:
      case 42:
      case 43:
      case 45:
      case 46:
      case 49:
        return result;
      case 29:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 64)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_CODE_SIGNATURE load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_CODE_SIGNATURE load command size wrong");
        }
        *(void *)(*(void *)(v3 + 72) + 64) = a2;
        return result;
      case 30:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 40)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_SEGMENT_SPLIT_INFO load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_SEGMENT_SPLIT_INFO load command size wrong");
        }
        *(void *)(*(void *)(v3 + 72) + 4dyld4::halt((char *)__format, 0) = a2;
        return result;
      case 33:
        if (a2[1] == 20)
        {
          if (*(unsigned char *)(*(void *)(*(void *)(v3 + 48) + 8) + 24))
          {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_ENCRYPTION_INFO load commands");
          }
          else
          {
            __n128 result = dyld3::MachOFile::is64((dyld3::MachOFile *)result);
            if (result) {
              __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO found in 64-bit mach-o");
            }
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO load command size wrong");
        }
        goto LABEL_71;
      case 34:
        goto LABEL_12;
      case 36:
      case 37:
      case 47:
      case 48:
        if (a2[1] == 16)
        {
          if (*(unsigned char *)(*(void *)(*(void *)(v3 + 40) + 8) + 24)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_VERSION_MIN_* load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_VERSION_* load command size wrong");
        }
        uint64_t v5 = *(void *)(v3 + 40);
        goto LABEL_72;
      case 38:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 48)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_FUNCTION_STARTS load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_FUNCTION_STARTS load command size wrong");
        }
        *(void *)(*(void *)(v3 + 72) + 48) = a2;
        return result;
      case 41:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 56)) {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DATA_IN_CODE load commands");
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DATA_IN_CODE load command size wrong");
        }
        *(void *)(*(void *)(v3 + 72) + 56) = a2;
        return result;
      case 44:
        if (a2[1] == 24)
        {
          if (*(unsigned char *)(*(void *)(*(void *)(v3 + 48) + 8) + 24))
          {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_ENCRYPTION_INFO_64 load commands");
          }
          else
          {
            __n128 result = dyld3::MachOFile::is64((dyld3::MachOFile *)result);
            if ((result & 1) == 0) {
              __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO_64 found in 32-bit mach-o");
            }
          }
        }
        else
        {
          __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO_64 load command size wrong");
        }
LABEL_71:
        uint64_t v5 = *(void *)(v3 + 48);
LABEL_72:
        *(unsigned char *)(*(void *)(v5 + 8) + 24) = 1;
        break;
      case 50:
        if (8 * a2[5] + 24 != a2[1])
        {
          uint64_t v6 = *(vm_address_t **)(v3 + 64);
          __n128 result = Diagnostics::error(v6, "LC_BUILD_VERSION load command size wrong");
        }
        break;
      default:
        if (v4 == 2)
        {
          if (a2[1] == 24)
          {
            if (*(void *)(*(void *)(v3 + 72) + 24)) {
              __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_SYMTAB load commands");
            }
          }
          else
          {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_SYMTAB load command size wrong");
          }
          *(void *)(*(void *)(v3 + 72) + 24) = a2;
        }
        else if (v4 == 11)
        {
          if (a2[1] == 80)
          {
            if (*(void *)(*(void *)(v3 + 72) + 32)) {
              __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DYSYMTAB load commands");
            }
          }
          else
          {
            __n128 result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DYSYMTAB load command size wrong");
          }
          *(void *)(*(void *)(v3 + 72) + 32) = a2;
        }
        break;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)a2 == 26)
  {
    uint64_t v8 = *(void *)(*(void *)(result + 40) + 8);
    uint64_t v9 = *(void *)(v8 + 80);
    if (v9)
    {
      unint64_t v4 = *(void *)(a2 + 8);
      uint64_t v10 = *(void *)(v8 + 64);
      uint64_t v11 = 24 * v9;
      for (size_t i = (unint64_t *)(v10 + 8); *(i - 1) > v4 || *i <= v4; i += 3)
      {
        v11 -= 24;
        if (!v11) {
          return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
        }
      }
      return (*(uint64_t (**)(void, void))(*(void *)(result + 32) + 16))(*(void *)(result + 32), (v4 - *(_DWORD *)(result + 48)));
    }
    return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
  }
  if (*(_DWORD *)a2 == 17)
  {
    uint64_t v2 = *(void *)(*(void *)(result + 40) + 8);
    uint64_t v3 = *(void *)(v2 + 80);
    if (v3)
    {
      unint64_t v4 = *(unsigned int *)(a2 + 8);
      uint64_t v5 = *(void *)(v2 + 64);
      uint64_t v6 = 24 * v3;
      for (size_t j = (unint64_t *)(v5 + 8); *(j - 1) > v4 || *j <= v4; j += 3)
      {
        v6 -= 24;
        if (!v6) {
          return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
        }
      }
      return (*(uint64_t (**)(void, void))(*(void *)(result + 32) + 16))(*(void *)(result + 32), (v4 - *(_DWORD *)(result + 48)));
    }
    return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile32forEachInitializerPointerSectionER11DiagnosticsU13block_pointerFvjjRbE_block_invoke(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (*(unsigned char *)(a2 + 92) == 9)
  {
    unint64_t v5 = *(unsigned int *)(result + 56);
    if (*(void *)(a2 + 72) % v5)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s has bad size");
LABEL_8:
      *a4 = 1;
      return result;
    }
    if (a3)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s extends beyond its segment");
      goto LABEL_8;
    }
    unint64_t v6 = *(void *)(a2 + 64);
    if (v6 % v5)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s is not pointer aligned");
      goto LABEL_8;
    }
    uint64_t v7 = (v6 - *(_DWORD *)(result + 48));
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(result + 32) + 16);
    uint64_t v9 = *(void *)(result + 32);
    return v8(v9, v7);
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_4(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (*(unsigned char *)(a2 + 92) == 22)
  {
    uint64_t v5 = result;
    if ((*(unsigned char *)(a2 + 52) & 2) != 0)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s must be in read-only segment");
      goto LABEL_6;
    }
    uint64_t v6 = *(void *)(a2 + 72);
    if ((v6 & 3) != 0)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s has bad size");
LABEL_6:
      *a4 = 1;
      return result;
    }
    if (a3)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s extends beyond the end of the segment");
      goto LABEL_6;
    }
    uint64_t v7 = *(void *)(a2 + 64);
    if ((v7 & 3) != 0)
    {
      __n128 result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s is not 4-byte aligned");
      goto LABEL_6;
    }
    if (v6 >= 1)
    {
      uint64_t v8 = (unsigned int *)(*(void *)(result + 48) + v7);
      uint64_t v9 = (unsigned int *)((char *)v8 + v6);
      while (1)
      {
        uint64_t v10 = *(void *)(*(void *)(v5 + 40) + 8);
        uint64_t v11 = *(void *)(v10 + 80);
        if (!v11) {
          break;
        }
        unint64_t v12 = *(void *)(v5 + 64) + *v8;
        uint64_t v13 = *(void *)(v10 + 64);
        uint64_t v14 = 24 * v11;
        long long v15 = (unint64_t *)(v13 + 8);
        while (*(v15 - 1) > v12 || *v15 <= v12)
        {
          v15 += 3;
          v14 -= 24;
          if (!v14) {
            goto LABEL_22;
          }
        }
        __n128 result = (*(uint64_t (**)(void))(*(void *)(v5 + 32) + 16))();
        if (++v8 >= v9) {
          return result;
        }
      }
LABEL_22:
      __n128 result = Diagnostics::error(*(vm_address_t **)(v5 + 56), "initializer 0x%08X is not an offset to an executable segment");
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile24forEachSupportedPlatformEU13block_pointerFvNS_8PlatformEjjE_block_invoke(uint64_t result, int *a2)
{
  uint64_t v2 = result;
  int v3 = *a2;
  if (*a2 <= 46)
  {
    if (v3 == 36)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16);
    }
    else
    {
      if (v3 != 37) {
        return result;
      }
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16);
    }
    goto LABEL_13;
  }
  if (v3 != 47)
  {
    if (v3 != 48)
    {
      if (v3 != 50) {
        return result;
      }
      unint64_t v4 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16);
      goto LABEL_10;
    }
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16);
LABEL_13:
    __n128 result = v5();
    goto LABEL_14;
  }
  unint64_t v4 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16);
LABEL_10:
  __n128 result = v4();
LABEL_14:
  *(unsigned char *)(*(void *)(*(void *)(v2 + 40) + 8) + 24) = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile20preferredLoadAddressEv_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__TEXT");
  if (!result)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 16);
    *a3 = 1;
  }
  return result;
}

uint64_t dyld4::APIs::clearErrorString(uint64_t this)
{
  if (*(void *)(this + 1120) != -1)
  {
    this = *(void *)(this + 152);
    if (this)
    {
      this = (*(uint64_t (**)(uint64_t))(*(void *)this + 64))(this);
      if (this) {
        *(unsigned char *)(this + 8) = 0;
      }
    }
  }
  return this;
}

uint64_t ___ZNK5dyld311MachOLoaded18findSectionContentEPKcS2_Ry_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v7 = *(dyld3::MachOFile **)(a1 + 40);
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 48));
  if (!result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 56));
    if (!result)
    {
      **(void **)(a1 + 64) = *(void *)(a2 + 72);
      uint64_t result = dyld3::MachOFile::isPreload(v7);
      if (result)
      {
        uint64_t v9 = (char *)v7 + *(unsigned int *)(a2 + 88);
      }
      else
      {
        uint64_t v10 = *(void *)(a2 + 64);
        uint64_t result = dyld3::MachOLoaded::getSlide(v7);
        uint64_t v9 = (char *)(result + v10);
      }
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v9;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t dyld4::APIs::addressLookupsDisabled(dyld4::APIs *this, const char *__s2)
{
  uint64_t v4 = *((void *)this + 1);
  if (__s2 && (uint64_t v5 = *(char **)(v4 + 176)) != 0)
  {
    uint64_t v6 = strstr(v5, __s2);
    if (v6)
    {
      int v7 = *(v6 - 1);
      int v8 = v6[_platform_strlen(__s2)];
      BOOL v9 = v8 == 58 || v8 == 0;
      if (v9 && v7 == 58) {
        return 0;
      }
    }
  }
  else if (*(unsigned char *)(v4 + 170))
  {
    goto LABEL_14;
  }
  uint64_t v10 = (void (*)(const char *))*((void *)this + 120);
  if (v10) {
    v10(__s2);
  }
LABEL_14:
  uint64_t v11 = *((void *)this + 1);
  if (!*(unsigned char *)(v11 + 170)) {
    return 0;
  }
  if (*(unsigned char *)(v11 + 171))
  {
    v13[0] = 10;
    v13[1] = 0;
    v13[2] = 0;
    v13[3] = (uint64_t)__s2;
    dyld4::halt("symbol address lookup (dlsym) disabled in process", v13);
  }
  return 1;
}

BOOL dyld4::Loader::hasMagic(dyld4::Loader *this)
{
  return *(_DWORD *)this == 1815378276;
}

BOOL dyld4::APIs::validLoader(lsl::Allocator **this, const dyld4::Loader *a2)
{
  if (!a2
    || (lsl::Allocator::owned(this[2], (unint64_t)a2, 32) & 1) == 0
    && !dyld4::RuntimeState::inPrebuiltLoader((dyld4::RuntimeState *)this, a2, 32))
  {
    return 0;
  }

  return dyld4::Loader::hasMagic(a2);
}

uint64_t lsl::Allocator::owned(lsl::Allocator *this, unint64_t a2, uint64_t a3)
{
  int v3 = (void *)*((void *)this + 2);
  if (!v3) {
    return 0;
  }
  while (1)
  {
    unint64_t v4 = v3[4];
    if (v4 <= a2 && a2 + a3 <= v3[5] + v4) {
      break;
    }
    int v3 = (void *)v3[2];
    if (!v3) {
      return 0;
    }
  }
  return 1;
}

BOOL dyld4::RuntimeState::inPrebuiltLoader(dyld4::RuntimeState *this, dyld4::PrebuiltLoaderSet *a2, uint64_t a3)
{
  uint64_t v6 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 121);
  BOOL result = 1;
  if (!v6 || !dyld4::PrebuiltLoaderSet::contains(v6, a2, a3))
  {
    int v7 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 124);
    if (!v7 || !dyld4::PrebuiltLoaderSet::contains(v7, a2, a3)) {
      return 0;
    }
  }
  return result;
}

BOOL dyld4::PrebuiltLoaderSet::contains(dyld4::PrebuiltLoaderSet *this, dyld4::PrebuiltLoaderSet *a2, uint64_t a3)
{
  return a2 >= this && (char *)a2 + a3 <= (char *)this + *((unsigned int *)this + 2);
}

uint64_t ___ZNK5dyld39MachOFile33findFairPlayEncryptionLoadCommandEv_block_invoke(uint64_t result, _DWORD *a2, unsigned char *a3)
{
  if (*a2 == 44 || *a2 == 33)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
    *a3 = 1;
  }
  return result;
}

void *___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke(void *result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 52) & 4) != 0)
  {
    uint64_t v2 = *(void *)(result[4] + 8);
    uint64_t v3 = *(void *)(a2 + 16);
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(a2 + 24) + v3;
    BOOL result = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((void *)(v2 + 64), 1);
    uint64_t v6 = *(void *)(v2 + 64);
    uint64_t v7 = *(void *)(v2 + 80);
    *(void *)(v2 + 8dyld4::halt((char *)__format, 0) = v7 + 1;
    uint64_t v8 = v6 + 24 * v7;
    *(void *)uint64_t v8 = v3;
    *(void *)(v8 + 8) = v5;
    *(_DWORD *)(v8 + 16) = v4;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded8getSlideEv_block_invoke(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 40);
  if (*(_DWORD *)a2 == 1)
  {
    BOOL result = _platform_strcmp((const char *)(a2 + 8), "__TEXT");
    if (result) {
      return result;
    }
    uint64_t v7 = *(unsigned int *)(a2 + 24);
    goto LABEL_7;
  }
  if (*(_DWORD *)a2 == 25)
  {
    BOOL result = _platform_strcmp((const char *)(a2 + 8), "__TEXT");
    if (!result)
    {
      uint64_t v7 = *(void *)(a2 + 24);
LABEL_7:
      *(void *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = v6 - v7;
      *a3 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile21forEachDependentDylibEU13block_pointerFvPKcbbbjjRbE_block_invoke(uint64_t result, char *a2, unsigned char *a3)
{
  int v3 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 + 2147483624) <= 0xB && ((1 << (*(_DWORD *)a2 - 24)) & 0x881) != 0 || v3 == 12)
  {
    uint64_t v7 = result;
    BOOL result = (*(uint64_t (**)(void, char *, BOOL, BOOL, BOOL, void, void, unsigned char *))(*(void *)(result + 32)
                                                                                                  + 16))(*(void *)(result + 32), &a2[*((unsigned int *)a2 + 2)], v3 == -2147483624, v3 == -2147483617, v3 == -2147483613, *((unsigned int *)a2 + 5), *((unsigned int *)a2 + 4), a3);
    ++*(_DWORD *)(*(void *)(*(void *)(v7 + 40) + 8) + 24);
    if (*a3) {
      *(unsigned char *)(*(void *)(*(void *)(v7 + 48) + 8) + 24) = 1;
    }
  }
  return result;
}

char *___ZNK5dyld39MachOFile10forDyldEnvEU13block_pointerFvPKcRbE_block_invoke(char *result, _DWORD *a2)
{
  if (*a2 == 39)
  {
    uint64_t v2 = result;
    int v3 = (char *)a2 + a2[2];
    BOOL result = (char *)_platform_strncmp(v3, "DYLD_", 5uLL);
    if (!result)
    {
      BOOL result = _platform_strchr(v3, 61);
      if (result)
      {
        uint64_t v4 = *(uint64_t (**)(void))(*((void *)v2 + 4) + 16);
        return (char *)v4();
      }
    }
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded13getLayoutInfoERNS0_10LayoutInfoE_block_invoke(uint64_t a1, int64x2_t *a2)
{
  uint64_t v4 = (const char *)a2[2].i64[1];
  uint64_t result = _platform_strcmp(v4, "__TEXT");
  if (result)
  {
    uint64_t result = _platform_strcmp(v4, "__LINKEDIT");
    uint64_t v6 = *(int32x2_t **)(a1 + 40);
    if (!result)
    {
      v6[2] = *(int32x2_t *)a2[1].i8;
      v6[3] = vmovn_s64(*a2);
      v6[4].i32[0] = (unsigned __int16)a2[3].i32[2] >> 4;
    }
  }
  else
  {
    uint64_t v7 = a2[1].i64[0];
    uint64_t v6 = *(int32x2_t **)(a1 + 40);
    *uint64_t v6 = (int32x2_t)(*(void *)(a1 + 32) - v7);
    v6[1] = (int32x2_t)v7;
  }
  v6[4].i32[1] = (unsigned __int16)a2[3].i32[2] >> 4;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile19getDylibInstallNameEPPKcPjS4__block_invoke(uint64_t result, _DWORD *a2, unsigned char *a3)
{
  if ((*a2 | 2) == 0xF)
  {
    int v3 = *(_DWORD **)(result + 48);
    **(_DWORD **)(result + 4dyld4::halt((char *)__format, 0) = a2[5];
    _DWORD *v3 = a2[4];
    **(void **)(result + 56) = (char *)a2 + a2[2];
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

BOOL ___ZN5dyld44APIs26NSVersionOfLinkTimeLibraryEPKc_block_invoke(uint64_t a1, dyld4 *this, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  BOOL result = dyld4::nameMatch(this, *(const char **)(a1 + 40), a3);
  if (result) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a7;
  }
  return result;
}

BOOL dyld4::nameMatch(dyld4 *this, const char *a2, const char *a3)
{
  uint64_t v4 = (const char *)this;
  uint64_t v5 = strrchr((char *)this, 47);
  if (v5) {
    uint64_t v4 = v5 + 1;
  }
  if (!_platform_strcmp(v4, a2)) {
    return 1;
  }
  size_t v6 = _platform_strlen(v4);
  size_t v7 = _platform_strlen(a2);
  if (v6 < v7 + 9) {
    return 0;
  }
  size_t v8 = v7;
  return !_platform_strncmp(v4, "lib", 3uLL)
      && !_platform_strcmp(&v4[v6 - 6], ".dylib")
      && !_platform_strncmp(v4 + 3, a2, v8)
      && v4[v8 + 3] == 46;
}

char *__cdecl strrchr(char *__s, int __c)
{
  BOOL result = 0;
  uint64_t v4 = __s;
  do
  {
    int v6 = *v4++;
    int v5 = v6;
    if ((char)__c == v6) {
      BOOL result = __s;
    }
    __s = v4;
  }
  while (v5);
  return result;
}

double ___ZNK12objc_visitor7Visitor11findSectionENSt3__14spanIPKcLm18446744073709551615EEES4__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (v4)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    BOOL v9 = *(const char ***)(a1 + 48);
    uint64_t v10 = 8 * v4;
    uint64_t v11 = *(const char **)(a2 + 40);
    while (_platform_strncmp(v11, *v9, 0x10uLL))
    {
      ++v9;
      v10 -= 8;
      if (!v10) {
        return result;
      }
    }
    if (!_platform_strncmp(*(const char **)(a2 + 80), *(const char **)(a1 + 64), 0x10uLL))
    {
      uint64_t v13 = *(void *)(a2 + 64);
      uint64_t Slide = dyld3::MachOLoaded::getSlide(*(dyld3::MachOLoaded **)(v8 + 8));
      metadata_visitor::ResolvedValue::ResolvedValue(&v17, Slide + v13, *(void *)(a2 + 64), 1);
      uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v16 = *(void *)(a2 + 72);
      double result = *(double *)&v17;
      *(_OWORD *)(v15 + 4dyld4::halt((char *)__format, 0) = v17;
      *(void *)(v15 + 56) = v18;
      *(void *)(v15 + 64) = v16;
      *(unsigned char *)(v15 + 72) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld416JustInTimeLoader8containsERNS_12RuntimeStateEPKvPS4_PyPh_block_invoke(uint64_t result, uint64_t a2, unsigned char *a3)
{
  unint64_t v3 = *(void *)(result + 48);
  unint64_t v4 = *(void *)(result + 40) + *(void *)(a2 + 16);
  if (v4 <= v3)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (v3 < v5 + v4)
    {
      **(void **)(result + 56) = v4;
      int v6 = *(unsigned char **)(result + 72);
      **(void **)(result + 64) = v5;
      *int v6 = *(_DWORD *)(a2 + 52);
      *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *a3 = 1;
    }
  }
  return result;
}

void Diagnostics::assertNoError(Diagnostics *a1)
{
  uint64_t v1 = (const char *)Diagnostics::errorMessageCStr(a1);
  abort_report_np("%s", v1);
}

uint64_t ___ZNK5dyld39MachOFile10hasSectionEPKcS2__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 40));
  if (!result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 48));
    if (!result)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer14hasSwiftOrObjCEPb_block_invoke(void *a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v7 = a1[5];
  uint64_t v8 = *(const char **)(a2 + 80);
  uint64_t result = _platform_strcmp(v8, "__objc_imageinfo");
  if (!result)
  {
    uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!result)
    {
      uint64_t v10 = (unsigned char *)a1[6];
      if (v10 && *(unsigned char *)(a1[7] + *(void *)(a2 + 64) + 5)) {
        *uint64_t v10 = 1;
      }
      *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  if (*(_DWORD *)(v7 + 4) == 7)
  {
    uint64_t result = _platform_strcmp(v8, "__image_info");
    if (!result)
    {
      uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
      if (!result)
      {
        *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
        *a4 = 1;
      }
    }
  }
  return result;
}

double ___ZNK5dyld313MachOAnalyzer17getLinkeditLayoutER11DiagnosticsyPKhRN6mach_o14LinkeditLayoutE_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)a2;
  if (*(int *)a2 > 10)
  {
    switch(v4)
    {
      case 29:
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v11 = *(void **)(a1 + 48);
        uint64_t v12 = *(unsigned int *)(a2 + 8);
        int v13 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v10 + 552) = v12;
        *(void *)(v10 + 56dyld4::halt((char *)__format, 0) = **(void **)(a1 + 56) - *v11 + v12;
        uint64_t v14 = *(void *)(a1 + 40);
        *(_DWORD *)(v14 + 568) = v13;
        *(_DWORD *)(v14 + 576) = 0;
        *(unsigned char *)(v14 + 58dyld4::halt((char *)__format, 0) = 1;
        break;
      case 30:
        uint64_t v56 = *(void *)(a1 + 40);
        long long v57 = *(void **)(a1 + 48);
        uint64_t v58 = *(unsigned int *)(a2 + 8);
        int v59 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v56 + 456) = v58;
        *(void *)(v56 + 464) = **(void **)(a1 + 56) - *v57 + v58;
        uint64_t v60 = *(void *)(a1 + 40);
        *(_DWORD *)(v60 + 472) = v59;
        *(_DWORD *)(v60 + 48dyld4::halt((char *)__format, 0) = 0;
        *(unsigned char *)(v60 + 484) = 1;
        break;
      case 31:
      case 32:
      case 33:
      case 35:
      case 36:
      case 37:
        return result;
      case 34:
        goto LABEL_14;
      case 38:
        uint64_t v61 = *(void *)(a1 + 40);
        int v62 = *(void **)(a1 + 48);
        uint64_t v63 = *(unsigned int *)(a2 + 8);
        int v64 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v61 + 488) = v63;
        *(void *)(v61 + 496) = **(void **)(a1 + 56) - *v62 + v63;
        uint64_t v65 = *(void *)(a1 + 40);
        *(_DWORD *)(v65 + 504) = v64;
        *(_DWORD *)(v65 + 512) = 0;
        *(unsigned char *)(v65 + 516) = 1;
        break;
      default:
        if (v4 == 11)
        {
          uint64_t v66 = *(void *)(a1 + 40);
          uint64_t v67 = *(uint64_t **)(a1 + 48);
          *(unsigned char *)(v66 + 589) = 1;
          uint64_t v68 = *(unsigned int *)(a2 + 72);
          *(_DWORD *)uint64_t v66 = v68;
          uint64_t v69 = *v67;
          int v70 = *(void **)(a1 + 56);
          *(void *)(v66 + 8) = *v70 - v69 + v68;
          uint64_t v71 = *(void *)(a1 + 40);
          *(void *)(v71 + 16) = 0;
          *(_DWORD *)(v71 + 24) = *(_DWORD *)(a2 + 76);
          *(unsigned char *)(v71 + 28) = 1;
          uint64_t v72 = *(unsigned int *)(a2 + 64);
          *(_DWORD *)(v71 + 32) = v72;
          *(void *)(v71 + 4dyld4::halt((char *)__format, 0) = *v70 - v69 + v72;
          uint64_t v73 = *(void *)(a1 + 40);
          *(void *)(v73 + 48) = 0;
          *(_DWORD *)(v73 + 56) = *(_DWORD *)(a2 + 68);
          *(unsigned char *)(v73 + 6dyld4::halt((char *)__format, 0) = 1;
          uint64_t v74 = *(unsigned int *)(a2 + 56);
          *(_DWORD *)(v73 + 64) = v74;
          *(void *)(v73 + 72) = *v70 - v69 + v74;
          uint64_t v75 = *(void *)(a1 + 40);
          *(void *)(v75 + 8dyld4::halt((char *)__format, 0) = 0;
          *(_DWORD *)(v75 + 88) = *(_DWORD *)(a2 + 60);
          *(unsigned char *)(v75 + 92) = 1;
          *(_DWORD *)(v75 + 96) = 0;
          *(void *)(v75 + 104) = 0;
          uint64_t v76 = *(void *)(a1 + 40);
          *(_DWORD *)(v76 + 112) = 0;
          *(void *)(v76 + 116) = *(void *)(a2 + 8);
          *(unsigned char *)(v76 + 124) = 1;
          *(_DWORD *)(v76 + 128) = 0;
          *(void *)(v76 + 136) = 0;
          uint64_t v77 = *(void *)(a1 + 40);
          *(_DWORD *)(v77 + 144) = 0;
          *(void *)(v77 + 148) = *(void *)(a2 + 16);
          *(unsigned char *)(v77 + 156) = 1;
          *(_DWORD *)(v77 + 16dyld4::halt((char *)__format, 0) = 0;
          *(void *)(v77 + 168) = 0;
          uint64_t v78 = *(void *)(a1 + 40);
          *(_DWORD *)(v78 + 176) = 0;
          double result = *(double *)(a2 + 24);
          *(double *)(v78 + 18dyld4::halt((char *)__format, 0) = result;
          *(unsigned char *)(v78 + 188) = 1;
        }
        else if (v4 == 41)
        {
          uint64_t v46 = *(void *)(a1 + 40);
          long long v47 = *(void **)(a1 + 48);
          uint64_t v48 = *(unsigned int *)(a2 + 8);
          int v49 = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v46 + 52dyld4::halt((char *)__format, 0) = v48;
          *(void *)(v46 + 528) = **(void **)(a1 + 56) - *v47 + v48;
          uint64_t v50 = *(void *)(a1 + 40);
          *(_DWORD *)(v50 + 536) = v49;
          *(_DWORD *)(v50 + 544) = 0;
          *(unsigned char *)(v50 + 548) = 1;
        }
        break;
    }
  }
  else if (v4 > -2147483597)
  {
    if (v4 == -2147483596)
    {
      uint64_t v51 = *(void *)(a1 + 40);
      uint64_t v52 = **(void **)(a1 + 56) - **(void **)(a1 + 48);
      uint64_t v53 = *(unsigned int *)(a2 + 8);
      int v54 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v51 + 384) = v53;
      *(void *)(v51 + 392) = v52 + v53;
      uint64_t v55 = *(void *)(a1 + 40);
      *(_DWORD *)(v55 + 40dyld4::halt((char *)__format, 0) = v54;
      *(_DWORD *)(v55 + 408) = 0;
      *(unsigned char *)(v55 + 412) = 1;
      *(void *)(v55 + 416) = a2;
    }
    else if (v4 == 2)
    {
      uint64_t v15 = *(dyld3::MachOFile **)(a1 + 32);
      *(unsigned char *)(*(void *)(a1 + 40) + 588) = 1;
      if (dyld3::MachOFile::is64(v15)) {
        int v17 = 16;
      }
      else {
        int v17 = 12;
      }
      uint64_t v18 = *(void *)(a1 + 40);
      long long v19 = *(uint64_t **)(a1 + 48);
      uint64_t v20 = *(unsigned int *)(a2 + 8);
      int v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v18 + 192) = v20;
      uint64_t v22 = *v19;
      long long v23 = *(void **)(a1 + 56);
      *(void *)(v18 + 20dyld4::halt((char *)__format, 0) = *v23 - v22 + v20;
      uint64_t v24 = *(void *)(a1 + 40);
      *(_DWORD *)(v24 + 208) = v21 * v17;
      *(_DWORD *)(v24 + 216) = v21;
      *(unsigned char *)(v24 + 22dyld4::halt((char *)__format, 0) = 1;
      uint64_t v25 = *(unsigned int *)(a2 + 16);
      LODWORD(v2dyld4::halt((char *)__format, 0) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v24 + 224) = v25;
      *(void *)(v24 + 232) = *v23 - v22 + v25;
      uint64_t v26 = *(void *)(a1 + 40);
      *(_DWORD *)(v26 + 24dyld4::halt((char *)__format, 0) = v20;
      *(unsigned char *)(v26 + 252) = 1;
    }
  }
  else
  {
    if (v4 == -2147483614)
    {
LABEL_14:
      uint64_t v27 = *(void *)(a1 + 40);
      long long v28 = *(uint64_t **)(a1 + 48);
      *(_DWORD *)(v27 + 584) = v4;
      uint64_t v29 = *(unsigned int *)(a2 + 8);
      int v30 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v27 + 256) = v29;
      uint64_t v31 = *v28;
      BOOL v32 = *(void **)(a1 + 56);
      *(void *)(v27 + 264) = *v32 - v31 + v29;
      uint64_t v33 = *(void *)(a1 + 40);
      *(_DWORD *)(v33 + 272) = v30;
      *(unsigned char *)(v33 + 284) = 1;
      uint64_t v34 = *(unsigned int *)(a2 + 16);
      int v35 = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v33 + 288) = v34;
      *(void *)(v33 + 296) = *v32 - v31 + v34;
      uint64_t v36 = *(void *)(a1 + 40);
      *(_DWORD *)(v36 + 304) = v35;
      *(unsigned char *)(v36 + 316) = 1;
      uint64_t v37 = *(unsigned int *)(a2 + 32);
      int v38 = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(v36 + 352) = v37;
      *(void *)(v36 + 36dyld4::halt((char *)__format, 0) = *v32 - v31 + v37;
      uint64_t v39 = *(void *)(a1 + 40);
      *(_DWORD *)(v39 + 368) = v38;
      uint64_t v40 = *(unsigned int *)(a2 + 24);
      int v41 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(v39 + 32dyld4::halt((char *)__format, 0) = v40;
      uint64_t v42 = *v32 - v31;
      *(unsigned char *)(v39 + 38dyld4::halt((char *)__format, 0) = 1;
      *(void *)(v39 + 328) = v42 + v40;
      uint64_t v43 = *(void *)(a1 + 40);
      *(_DWORD *)(v43 + 336) = v41;
      *(unsigned char *)(v43 + 348) = 1;
      uint64_t v44 = *(unsigned int *)(a2 + 40);
      int v45 = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(v43 + 424) = v44;
      *(void *)(v43 + 432) = *v32 - v31 + v44;
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)(v9 + 44dyld4::halt((char *)__format, 0) = v45;
    }
    else
    {
      if (v4 != -2147483597) {
        return result;
      }
      uint64_t v5 = *(void *)(a1 + 40);
      int v6 = *(void **)(a1 + 48);
      uint64_t v7 = *(unsigned int *)(a2 + 8);
      int v8 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v5 + 424) = v7;
      *(void *)(v5 + 432) = **(void **)(a1 + 56) - *v6 + v7;
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)(v9 + 44dyld4::halt((char *)__format, 0) = v8;
      *(_DWORD *)(v9 + 448) = 0;
    }
    *(unsigned char *)(v9 + 452) = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke_2(uint64_t result, int *a2)
{
  int v2 = *a2;
  if (*a2 != 34)
  {
    if (v2 == -2147483597)
    {
      *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2[2];
      unint64_t v3 = a2 + 3;
      goto LABEL_6;
    }
    if (v2 != -2147483614) {
      return result;
    }
  }
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2[10];
  unint64_t v3 = a2 + 11;
LABEL_6:
  **(_DWORD **)(result + 4dyld4::halt((char *)__format, 0) = *v3;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile12isRestrictedEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__RESTRICT");
  if (!result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__restrict");
    if (!result)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke(uint64_t result, _DWORD *a2, unsigned char *a3)
{
  if (*a2 == 29)
  {
    unint64_t v3 = *(_DWORD **)(result + 40);
    **(_DWORD **)(result + 32) = a2[2];
    _DWORD *v3 = a2[3];
    *a3 = 1;
  }
  return result;
}

void *dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    int v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 24 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    uint64_t result = memmove((void *)v4[3], *v4, 24 * (void)v4[2]);
    unint64_t v9 = (unint64_t)v4[4] / 0x18;
    *int v4 = v4[3];
    v4[1] = (const void *)v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile17hasPlusLoadMethodER11Diagnostics_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
  if (!result)
  {
    vm_size_t v8 = *(const char **)(a2 + 80);
    uint64_t result = _platform_strcmp(v8, "__objc_nlclslist");
    if (!result || (uint64_t result = _platform_strcmp(v8, "__objc_nlcatlist"), !result))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v4 = *(const char **)(a2 + 40);
  if (_platform_strcmp(v4, "__TEXT"))
  {
    uint64_t result = _platform_strncmp(v4, "__DATA", 6uLL);
    if (result) {
      return result;
    }
    vm_size_t v8 = *(const char **)(a2 + 80);
    if (_platform_strcmp(v8, "__objc_imageinfo"))
    {
      if (_platform_strcmp(v8, "__objc_selrefs"))
      {
        if (_platform_strcmp(v8, "__objc_msgrefs"))
        {
          if (_platform_strcmp(v8, "__objc_classrefs"))
          {
            if (_platform_strcmp(v8, "__objc_superrefs"))
            {
              if (_platform_strcmp(v8, "__objc_protorefs"))
              {
                if (_platform_strcmp(v8, "__objc_classlist"))
                {
                  if (_platform_strcmp(v8, "__objc_stublist"))
                  {
                    if (_platform_strcmp(v8, "__objc_nlclslist"))
                    {
                      if (_platform_strcmp(v8, "__objc_catlist"))
                      {
                        if (_platform_strcmp(v8, "__objc_catlist2"))
                        {
                          if (_platform_strcmp(v8, "__objc_nlcatlist"))
                          {
                            if (_platform_strcmp(v8, "__objc_protolist"))
                            {
                              if (_platform_strcmp(v8, "__objc_fork_ok"))
                              {
                                uint64_t result = _platform_strcmp(v8, "__objc_rawisa");
                                if (result) {
                                  return result;
                                }
                                unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                              }
                              else
                              {
                                unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                              }
                            }
                            else
                            {
                              unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                            }
                          }
                          else
                          {
                            unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                          }
                        }
                        else
                        {
                          unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                        }
                      }
                      else
                      {
                        unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                      }
                    }
                    else
                    {
                      unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                    }
                  }
                  else
                  {
                    unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                  }
                }
                else
                {
                  unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
                }
              }
              else
              {
                unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
              }
            }
            else
            {
              unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
            }
          }
          else
          {
            unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
          }
        }
        else
        {
          unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
        }
      }
      else
      {
        unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
      }
    }
    else
    {
      unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    }
  }
  else
  {
    vm_size_t v6 = *(const char **)(a2 + 80);
    if (_platform_strcmp(v6, "__swift5_protos"))
    {
      if (_platform_strcmp(v6, "__swift5_proto"))
      {
        if (_platform_strcmp(v6, "__swift5_types"))
        {
          if (_platform_strcmp(v6, "__swift5_replace"))
          {
            if (_platform_strcmp(v6, "__swift5_replac2"))
            {
              uint64_t result = _platform_strcmp(v6, "__swift5_acfuncs");
              if (result) {
                return result;
              }
              unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
            }
            else
            {
              unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
            }
          }
          else
          {
            unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
          }
        }
        else
        {
          unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
        }
      }
      else
      {
        unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
      }
    }
    else
    {
      unint64_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    }
  }

  return v7();
}

uint64_t ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke(uint64_t a1, uint64_t a2, int a3, unsigned char *a4)
{
  vm_size_t v8 = *(dyld3::MachOFile **)(a1 + 40);
  if (*(unsigned char *)(a2 + 92) == 13
    || (uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__interpose"), !result)
    && ((vm_map_t v10 = *(const char **)(a2 + 40), !_platform_strncmp(v10, "__DATA", 6uLL))
     || (uint64_t result = _platform_strncmp(v10, "__AUTH", 6uLL), !result)))
  {
    if (*(void *)(a2 + 72) % (unint64_t)*(unsigned int *)(a1 + 56))
    {
      uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s has bad size");
LABEL_12:
      *a4 = 1;
      return result;
    }
    if (a3)
    {
      uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s extends beyond the end of the segment");
      goto LABEL_12;
    }
    unint64_t v11 = *(void *)(a2 + 64);
    if (v11 % *(unsigned int *)(a1 + 60))
    {
      uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s is not pointer aligned");
      goto LABEL_12;
    }
    uint64_t v12 = *(void *)(a1 + 32);
    uint64_t v13 = v11 - dyld3::MachOFile::preferredLoadAddress(v8);
    uint64_t v14 = *(void *)(a2 + 72);
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(v12 + 16);
    return v15(v12, v13, v14, a4);
  }
  return result;
}

void ___ZNK5dyld46Loader20makeSegmentsReadOnlyERNS_12RuntimeStateE_block_invoke(void *a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 56) & 2) != 0)
  {
    unint64_t v3 = (dyld4::Loader *)a1[4];
    size_t v4 = *(void *)(a2 + 24);
    vm_address_t v5 = (char *)(a1[5] + *(void *)(a2 + 16));
    dyld4::SyscallDelegate::mprotect(*(dyld4::SyscallDelegate **)(a1[6] + 8), v5, v4, 1);
    vm_size_t v6 = (const dyld4::RuntimeState *)a1[6];
    if (*(unsigned char *)(*((void *)v6 + 1) + 201))
    {
      unint64_t v7 = &v5[v4];
      vm_size_t v8 = (char *)dyld4::Loader::path(v3, v6);
      unint64_t v9 = strrchr(v8, 47);
      if (v9) {
        vm_map_t v10 = v9 + 1;
      }
      else {
        vm_map_t v10 = v8;
      }
      dyld4::RuntimeState::log(v6, "mprotect 0x%012lX->0x%012lX to read-only (%s)\n", v5, v7, v10);
    }
  }
}

void *___ZNK5dyld39MachOFile8getEntryERyRb_block_invoke(void *result, uint64_t a2, unsigned char *a3)
{
  unint64_t v3 = result;
  if (*(_DWORD *)a2 == 5)
  {
    vm_size_t v6 = (dyld3::MachOFile *)result[4];
    vm_address_t v5 = (unsigned char *)result[5];
    *a3 = 1;
    *vm_address_t v5 = 1;
    thread_command v7 = dyld3::MachOFile::entryAddrFromThreadCmd(v6, (const thread_command *)a2);
    uint64_t result = (void *)dyld3::MachOFile::preferredLoadAddress(v6);
    *(void *)void v3[6] = *(void *)&v7 - (void)result;
  }
  else if (*(_DWORD *)a2 == -2147483608)
  {
    size_t v4 = (void *)result[6];
    *(unsigned char *)result[5] = 0;
    *size_t v4 = *(void *)(a2 + 8);
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile7hasObjCEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  vm_size_t v8 = *(const char **)(a2 + 80);
  uint64_t result = _platform_strcmp(v8, "__objc_imageinfo");
  if (!result)
  {
    uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!result)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  if (*(_DWORD *)(v7 + 4) == 7)
  {
    uint64_t result = _platform_strcmp(v8, "__image_info");
    if (!result)
    {
      uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
      if (!result)
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
        *a4 = 1;
      }
    }
  }
  return result;
}

void *___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke_2(void *result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = (unsigned __int16)*(_DWORD *)(a2 + 56) >> 4;
  size_t v4 = (_DWORD *)result[9];
  if (v3 < *v4)
  {
    uint64_t v5 = v4[v3 + 1];
    if (v5)
    {
      vm_size_t v8 = result;
      unint64_t v9 = (unsigned __int16 *)((char *)v4 + v5);
      uint64_t v10 = *(void *)(result[4] + 8);
      int v11 = v9[3];
      if (*(_WORD *)(v10 + 24))
      {
        if (*(unsigned __int16 *)(v10 + 24) != v11)
        {
          Diagnostics::error((vm_address_t *)result[10], "pointer_format is different in different segments");
          *a3 = 1;
        }
      }
      else
      {
        *(_WORD *)(v10 + 24) = v11;
      }
      uint64_t v12 = *(void *)(v8[5] + 8);
      int v13 = v9[2];
      if (*(_WORD *)(v12 + 24))
      {
        if (*(unsigned __int16 *)(v12 + 24) != v13)
        {
          Diagnostics::error((vm_address_t *)v8[10], "page_size is different in different segments");
          *a3 = 1;
        }
      }
      else
      {
        *(_WORD *)(v12 + 24) = v13;
      }
      int v14 = *((_DWORD *)v8 + 26);
      int v15 = *(_DWORD *)(a2 + 52);
      uint64_t v16 = v8[11] + *(void *)a2;
      uint64_t v17 = v8[12] + *(void *)(a2 + 16);
      unint64_t v18 = v9[10] * (unint64_t)*(unsigned __int16 *)(*(void *)(v8[5] + 8) + 24);
      uint64_t v19 = *(void *)(a2 + 40);
      if (*((unsigned char *)v8 + 108)
        && ((int v20 = *(_DWORD *)(a2 + 56), (v20 & 2) != 0) || v9[10] >= 2u)
        && (uint64_t v21 = *(void *)(v8[6] + 8), *(void *)(v21 + 56) <= 4uLL))
      {
        uint64_t v22 = (void *)(v21 + 40);
        int v23 = (v20 & 2) << 8;
        if (!*((unsigned char *)v8 + 109)) {
          int v23 = 0;
        }
        v15 |= v23;
      }
      else
      {
        uint64_t v21 = *(void *)(v8[7] + 8);
        uint64_t v22 = (void *)(v21 + 40);
      }
      uint64_t result = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace(v22, 1);
      uint64_t v24 = *(void *)(v21 + 40);
      uint64_t v25 = *(void *)(v21 + 56);
      *(void *)(v21 + 56) = v25 + 1;
      uint64_t v26 = v24 + 48 * v25;
      *(_DWORD *)uint64_t v26 = v14;
      *(_DWORD *)(v26 + 4) = v15;
      *(void *)(v26 + 8) = v16;
      *(void *)(v26 + 16) = v17;
      *(void *)(v26 + 24) = v18;
      *(void *)(v26 + 32) = v19;
      *(void *)(v26 + 4dyld4::halt((char *)__format, 0) = v9;
      *(void *)(*(void *)(v8[8] + 8) + 24) = v9;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile16builtForPlatformENS_8PlatformEb_block_invoke(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 48) == a2) {
    uint64_t v2 = *(void *)(result + 32);
  }
  else {
    uint64_t v2 = *(void *)(result + 40);
  }
  *(unsigned char *)(*(void *)(v2 + 8) + 24) = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile17forEachDOFSectionER11DiagnosticsU13block_pointerFvjE_block_invoke(uint64_t result, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a2 + 92) == 15 && (a3 & 1) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile12segmentCountEv_block_invoke(uint64_t result)
{
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded17findClosestSymbolEyPPKcPy_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unint64_t v4 = *(void *)(result + 40);
  ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24);
  unint64_t v5 = *(void *)(a2 + 64);
  if (v5 <= v4 && v4 < *(void *)(a2 + 72) + v5) {
    *a4 = 1;
  }
  return result;
}

void *___ZN5dyld412RuntimeState15PermanentRanges4makeERS0_RKN5dyld35ArrayIPKNS_6LoaderEEE_block_invoke(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[7] + *(void *)(a2 + 16);
  uint64_t v5 = v4 + *(void *)(a2 + 24);
  uint64_t v6 = *(unsigned int *)(a2 + 52);
  if (v4 == *(void *)(*(void *)(result[4] + 8) + 24)
    && v6 == *(unsigned __int8 *)(*(void *)(result[5] + 8) + 24)
    && (v7 = *(void *)(result[6] + 8), (uint64_t v8 = *(void *)(v7 + 56)) != 0))
  {
    *(void *)(*(void *)(v7 + 40) + 32 * v8 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
  }
  else if (v6)
  {
    uint64_t v9 = result[8];
    uint64_t v10 = *(void *)(result[6] + 8);
    uint64_t result = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((void *)(v10 + 40), 1);
    uint64_t v11 = *(void *)(v10 + 40);
    uint64_t v12 = *(void *)(v10 + 56);
    *(void *)(v10 + 56) = v12 + 1;
    int v13 = (void *)(v11 + 32 * v12);
    *int v13 = v4;
    v13[1] = v5;
    v13[2] = v9;
    v13[3] = v6;
    LODWORD(v6) = *(_DWORD *)(a2 + 52);
  }
  *(void *)(*(void *)(v3[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
  *(unsigned char *)(*(void *)(v3[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6;
  return result;
}

uint64_t ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 48) || (uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__DATA_DIRTY"), result))
  {
    uint64_t v4 = *(void **)(*(void *)(v3 + 32) + 8);
    unint64_t v5 = v4[7];
    if (v5 >= v4[6]) {
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    }
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(v3 + 40) + *(void *)(a2 + 16);
    uint64_t v8 = v4[5];
    void v4[7] = v5 + 1;
    uint64_t v9 = (void *)(v8 + 16 * v5);
    void *v9 = v7;
    v9[1] = v6;
  }
  return result;
}

void ___ZNK5dyld46Loader21makeSegmentsReadWriteERNS_12RuntimeStateE_block_invoke(void *a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 56) & 2) != 0)
  {
    uint64_t v3 = (dyld4::Loader *)a1[4];
    size_t v4 = *(void *)(a2 + 24);
    unint64_t v5 = (char *)(a1[5] + *(void *)(a2 + 16));
    dyld4::SyscallDelegate::mprotect(*(dyld4::SyscallDelegate **)(a1[6] + 8), v5, v4, 3);
    uint64_t v6 = (const dyld4::RuntimeState *)a1[6];
    if (*(unsigned char *)(*((void *)v6 + 1) + 201))
    {
      uint64_t v7 = &v5[v4];
      uint64_t v8 = (char *)dyld4::Loader::path(v3, v6);
      uint64_t v9 = strrchr(v8, 47);
      if (v9) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v8;
      }
      dyld4::RuntimeState::log(v6, "mprotect 0x%012lX->0x%012lX to read-write (%s)\n", v5, v7, v10);
    }
  }
}

uint64_t ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke(void *a1, void *a2, unsigned char *a3)
{
  uint64_t v6 = (const char *)a2[5];
  uint64_t result = _platform_strcmp(v6, "__TEXT");
  if (result)
  {
    uint64_t result = _platform_strcmp(v6, "__LINKEDIT");
    if (!result)
    {
      *(void *)(*(void *)(a1[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2[2];
      *(void *)(*(void *)(a1[6] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a2;
      *a3 = 1;
    }
  }
  else
  {
    *(void *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2[2];
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer12withVMLayoutER11DiagnosticsU13block_pointerFvRKN6mach_o6LayoutEE_block_invoke(void *a1, uint64_t *a2)
{
  uint64_t v4 = a2[2];
  uint64_t v5 = a2[3];
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = a1[6] + v4;
  int v9 = *((_DWORD *)a2 + 13);
  uint64_t v10 = (const char *)a2[5];
  uint64_t result = _platform_strcmp(v10, "__TEXT");
  if (result)
  {
    uint64_t result = _platform_strcmp(v10, "__LINKEDIT");
    if (result)
    {
      int v12 = 0;
    }
    else
    {
      *(void *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6;
      *(void *)(*(void *)(a1[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
      int v12 = 2;
    }
  }
  else
  {
    int v12 = 1;
  }
  uint64_t v13 = a1[7] + 48 * ((unsigned __int16)*((_DWORD *)a2 + 14) >> 4);
  *(void *)uint64_t v13 = v4;
  *(void *)(v13 + 8) = v5;
  *(void *)(v13 + 16) = v6;
  *(void *)(v13 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
  *(void *)(v13 + 32) = v8;
  *(_DWORD *)(v13 + 4dyld4::halt((char *)__format, 0) = v9;
  *(_DWORD *)(v13 + 44) = v12;
  return result;
}

uint64_t ___ZN5dyld4L12hasDataConstEPKN5dyld39MachOFileE_block_invoke(uint64_t result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 56) & 2) != 0) {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile21analyzeSegmentsLayoutERyRb_block_invoke(void *a1, uint64_t a2)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__PAGEZERO");
  if (result)
  {
    if ((*(unsigned char *)(a2 + 52) & 2) != 0)
    {
      uint64_t v5 = *(void *)(a2 + 8);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v5 != v6)
      {
        *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
        uint64_t v5 = v6;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 24);
    }
    if (!v5) {
      *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
    unint64_t v7 = *(void *)(a2 + 16);
    uint64_t v8 = *(void *)(a1[5] + 8);
    if (v7 < *(void *)(v8 + 24))
    {
      *(void *)(v8 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
      unint64_t v7 = *(void *)(a2 + 16);
      uint64_t v5 = *(void *)(a2 + 24);
    }
    unint64_t v9 = v5 + v7;
    uint64_t v10 = *(void *)(a1[6] + 8);
    if (v9 > *(void *)(v10 + 24))
    {
      *(void *)(v10 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;
      uint64_t v5 = *(void *)(a2 + 24);
    }
    *(void *)(*(void *)(a1[7] + 8) + 24) += v5;
  }
  return result;
}

BOOL dyld4::JustInTimeLoader::getExportsTrie(dyld4::JustInTimeLoader *this, unint64_t *a2, unsigned int *a3)
{
  unint64_t v3 = *((unsigned int *)this + 28);
  if (v3)
  {
    *a2 = v3;
    *a3 = *((_DWORD *)this + 29);
  }
  return v3 != 0;
}

void *dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 32 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    uint64_t result = memmove((void *)v4[3], *v4, 32 * (void)v4[2]);
    unint64_t v9 = (const void *)((unint64_t)v4[4] >> 5);
    *uint64_t v4 = v4[3];
    v4[1] = v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

int mprotect(void *a1, size_t a2, int a3)
{
  int result = mac_syscall(SYS_mprotect, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::mprotect(dyld4::SyscallDelegate *this, void *a2, size_t a3, int a4)
{
  return mprotect(a2, a3, a4);
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 48 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    int result = memmove((void *)v4[3], *v4, 48 * (void)v4[2]);
    unint64_t v9 = (unint64_t)v4[4] / 0x30;
    *uint64_t v4 = v4[3];
    v4[1] = (const void *)v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

uint64_t ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 40) + 8 * a2;
  *(void *)(v3 + 8) = *(void *)(a3 + 64) - *(void *)(result + 32);
  *(void *)(v3 + 176) = *(void *)(a3 + 72);
  return result;
}

void *metadata_visitor::ResolvedValue::ResolvedValue(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *int result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile13enforceFormatENS0_9MalformedE_block_invoke(uint64_t result, int a2, uint64_t a3, unsigned int a4)
{
  switch(a2)
  {
    case 1:
      switch(*(_DWORD *)(result + 40))
      {
        case 0:
        case 1:
        case 3:
          if (a4 >> 9 >= 0x507) {
            goto LABEL_23;
          }
          break;
        case 2:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
          unsigned int v6 = 659199;
          goto LABEL_22;
        case 9:
          unsigned int v6 = 659455;
          goto LABEL_22;
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xE:
        case 0xF:
          goto LABEL_15;
        case 0xD:
        case 0x10:
          goto LABEL_20;
        default:
          return result;
      }
      break;
    case 2:
    case 3:
    case 6:
      switch(*(_DWORD *)(result + 40))
      {
        case 0:
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_23;
        case 1:
        case 2:
        case 4:
        case 8:
LABEL_15:
          if (a4 >= 0xD0000) {
            goto LABEL_23;
          }
          break;
        case 9:
LABEL_20:
          int v9 = 851967;
          goto LABEL_21;
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xE:
        case 0xF:
          if (a4 >= 0x100000) {
            goto LABEL_23;
          }
          break;
        case 0xD:
        case 0x10:
          unsigned int v6 = 1114111;
          goto LABEL_22;
        default:
          return result;
      }
      break;
    case 4:
      unsigned int v7 = *(_DWORD *)(result + 40);
      if (v7 <= 0x10)
      {
        int v8 = 1 << v7;
        if ((v8 & 0xDF16) != 0)
        {
          if (a4 >= 0x90000) {
            goto LABEL_23;
          }
        }
        else
        {
          if ((v8 & 0xE9) != 0) {
            goto LABEL_23;
          }
          int v9 = 589823;
LABEL_21:
          unsigned int v6 = v9 | 0x10000;
LABEL_22:
          if (a4 > v6) {
            goto LABEL_23;
          }
        }
      }
      break;
    case 11:
    case 12:
      uint64_t v5 = *(void *)(result + 32);
      result += 32;
      *(unsigned char *)(*(void *)(v5 + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      if (!(a4 >> 17) && *(_DWORD *)(result + 8) == 16)
      {
        char v4 = 0;
        goto LABEL_24;
      }
      break;
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      char v4 = 0;
      result += 32;
      goto LABEL_24;
    default:
LABEL_23:
      result += 32;
      char v4 = 1;
LABEL_24:
      *(unsigned char *)(*(void *)(*(void *)result + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4;
      break;
  }
  return result;
}

uint64_t ___ZN5dyld413ProcessConfig7Process15getMainPlatformEv_block_invoke(uint64_t result, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(_DWORD *)(v4 + 4dyld4::halt((char *)__format, 0) = a4;
  *(_DWORD *)(v4 + 48) = a3;
  return result;
}

uint64_t ___ZN5dyld44APIs15forEachPlatformEPKN5dyld39MachOFileEU13block_pointerFvjjjE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  if (!a4)
  {
    unsigned int v5 = dyld4::APIs::linkedDylibVersion((dyld4::APIs *)a1, *(const dyld3::MachOFile **)(a1 + 56), "/System/Library/Frameworks/Foundation.framework/Foundation");
    if (v5 >= 0x2A61800)
    {
      unsigned int v6 = &unk_1A8E71030;
      do
      {
        unsigned int v7 = v6[3];
        if (!v7) {
          break;
        }
        v6 += 2;
      }
      while (v5 >= v7);
    }
  }
  int v8 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v8();
}

uint64_t ___ZN5dyld413ProcessConfig8SecurityC2ERNS0_7ProcessERNS_15SyscallDelegateE_block_invoke(uint64_t a1, char *__s1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = _platform_strncmp(__s1, "DYLD_DLSYM_RESULT=", 0x12uLL);
  if (result) {
    return result;
  }
  uint64_t result = _platform_strcmp(__s1 + 18, "null");
  if (!result)
  {
    __int16 v6 = 1;
LABEL_10:
    *(_WORD *)(v3 + 2) = v6;
    return result;
  }
  uint64_t result = _platform_strcmp(__s1 + 18, "abort");
  if (!result)
  {
    __int16 v6 = 257;
    goto LABEL_10;
  }
  uint64_t result = _platform_strncmp(__s1 + 18, "null-allow:", 0xBuLL);
  if (result)
  {
    uint64_t result = _platform_strncmp(__s1 + 18, "abort-allow:", 0xCuLL);
    if (result)
    {
      uint64_t result = _platform_strncmp(__s1 + 18, "allow:", 6uLL);
      if (result) {
        return result;
      }
      *(_WORD *)(v3 + 2) = 0;
      unsigned int v5 = __s1 + 24;
    }
    else
    {
      *(_WORD *)(v3 + 2) = 257;
      unsigned int v5 = __s1 + 30;
    }
  }
  else
  {
    *(_WORD *)(v3 + 2) = 1;
    unsigned int v5 = __s1 + 29;
  }
  *(void *)(v3 + 8) = v5;
  return result;
}

dyld3::MachOLoaded *dyld4::APIs::dyld_image_header_containing_address(dyld4::APIs *this, char *a2)
{
  unsigned int v5 = 0;
  dyld4::APIs::findImageMappedAt(this, a2, &v5, 0, 0, 0, 0, 0, 0);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_image_header_containing_address(%p) =>%p\n", a2, v5);
  }
  return v5;
}

uint64_t dyld4::APIs::_dyld_image_count(dyld4::APIs *this)
{
  uint64_t v1 = *((unsigned int *)this + 12);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_image_count() => %d\n", *((_DWORD *)this + 12));
  }
  return v1;
}

void dyld4::recordFromInfo(lsl::Lock **a1@<X0>, dyld4::FileManager *this@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  memset(v14, 0, sizeof(v14));
  uint64_t v15 = 0x1FFFFFFFFLL;
  __int16 v16 = 0;
  char v17 = 1;
  uint64_t v8 = *(void *)a3;
  if (!*(void *)a3 || (uint64_t v9 = *(void *)(a3 + 8)) == 0)
  {
LABEL_9:
    dyld4::FileManager::fileRecordForPath(this, a1, *(const char **)(a3 + 16), a4);
    goto LABEL_10;
  }
  dyld4::FileManager::fileRecordForVolumeDevIDAndObjID(this, v8, v9, (dyld4::FileRecord *)v13);
  dyld4::FileRecord::operator=((dyld4::FileRecord *)v14, (dyld4::FileRecord *)v13);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v13);
  vm_map_t v10 = (unsigned char *)dyld4::FileRecord::volume((dyld4::FileRecord *)v14);
  if (!*v10)
  {
    uint64_t v11 = 1;
    while (v11 != 16)
    {
      if (v10[v11++])
      {
        if ((unint64_t)(v11 - 2) <= 0xE) {
          goto LABEL_4;
        }
        goto LABEL_9;
      }
    }
    goto LABEL_9;
  }
LABEL_4:
  dyld4::FileRecord::FileRecord(a4, (dyld4::FileRecord *)v14);
LABEL_10:
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v14);
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::deserialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  unsigned int v4 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)a2;
  unsigned int v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 18dyld4::halt((char *)__format, 0) = v5;
  *(void *)(a1 + 184) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 208) = *(_DWORD *)(a2 + 20);
  *(void *)(a1 + 20dyld4::halt((char *)__format, 0) = *(void *)(a2 + 24);
  int v6 = *(_DWORD *)(a2 + 32);
  uint64_t v7 = a3 - 36;
  uint64_t v8 = a2 + 36;
  long long v47 = (char *)(a2 + 36);
  uint64_t v48 = a3 - 36;
  *(_DWORD *)(a1 + 212) = v6;
  if (__PAIR64__(v5, v4) != 2803519846) {
    return v3;
  }
  uint64_t v9 = a2;
  lsl::CRC32c::CRC32c((uint64_t)v46);
  lsl::CRC32c::operator()(v46, v9, 32);
  lsl::CRC32c::operator()(v46, 0);
  lsl::CRC32c::operator()(v46, v8, v7);
  LODWORD(v9) = *(_DWORD *)(a1 + 212);
  uint64_t v3 = 0;
  if (v9 != lsl::CRC32c::operator unsigned int((uint64_t)v46)) {
    return v3;
  }
  *(void *)(a1 + 216) = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  **(void **)(a1 + 2++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  **(void **)(a1 + 232) = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  **(void **)(a1 + 24dyld4::halt((char *)__format, 0) = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  uint64_t PVLEUInt64 = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  uint64_t v12 = PVLEUInt64;
  if (PVLEUInt64)
  {
    uint64_t v13 = 0;
    uint64_t v14 = PVLEUInt64;
    do
    {
      v50[0] = *(_OWORD *)&v47[v13];
      lsl::Vector<dyld4::InterposeTupleAll>::reserve(a1 + 48, *(void *)(a1 + 64) + 1);
      uint64_t v15 = *(void *)(a1 + 56);
      uint64_t v16 = *(void *)(a1 + 64);
      *(void *)(a1 + 64) = v16 + 1;
      *(_OWORD *)(v15 + 16 * v16) = v50[0];
      v13 += 16;
      --v14;
    }
    while (v14);
  }
  v47 += 16 * v12;
  v48 -= 16 * v12;
  unint64_t v17 = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  lsl::Vector<std::byte>::reserve(a1 + 112, v17);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<unsigned char *,unsigned char *,std::back_insert_iterator<lsl::Vector<char>>>((uint64_t)v50, v47, &v47[v17], a1 + 112);
  v47 += v17;
  v48 -= v17;
  if (*(unsigned char *)(a1 + 216))
  {
    *(void *)&v60[0] = 0;
    v49[0] = 0uLL;
    memset(v50, 0, sizeof(v50));
    uint64_t v51 = 0x1FFFFFFFFLL;
    __int16 v52 = 0;
    char v53 = 1;
    if (dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo(a1, (unsigned __int8 **)&v47, (uint64_t *)v60, v49, (dyld4::FileRecord *)v50))
    {
      char v29 = 14;
      if ((*(void *)(a1 + 216) & 4) == 0) {
        char v29 = 12;
      }
      *(void *)&v60[0] <<= v29;
      if (*(unsigned char *)(*(void *)a1 + 104))
      {
        int v30 = *(lsl::Allocator **)(*(void *)a1 + 72);
        if (v30) {
          atomic_fetch_add_explicit((atomic_uint *volatile)v30, 1u, memory_order_relaxed);
        }
      }
      else
      {
        lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>(*(lsl::Lock ***)(a1 + 8), *(void *)(a1 + 8), &v45);
        int v30 = v45;
      }
      *(void *)&long long v64 = v30;
      if (v30)
      {
        if (*((void *)v30 + 1))
        {
          BOOL v32 = *(lsl::Lock ***)(a1 + 8);
          uint64_t v44 = (const os_unfair_lock *)(*(void *)(a1 + 216) & 2);
          lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,lsl::Allocator&,dyld4::FileRecord,lsl::SharedPtr<dyld4::Atlas::Mapper> &,unsigned long long &,unsigned long long>(v32, (uint64_t)v32, (dyld4::FileRecord *)v50, (atomic_uint **)&v64, (char **)v60, &v44, (uint64_t *)&v45);
          uint64_t v34 = *(lsl::Allocator ***)(a1 + 32);
          if (&v45 != v34)
          {
            int v35 = *v34;
            *uint64_t v34 = v45;
            int v45 = v35;
          }
          lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((const os_unfair_lock **)&v45, v33);
          uint64_t v36 = *(lsl::Lock ***)(a1 + 8);
          uint64_t v37 = lsl::Allocator::aligned_alloc(v36, 8uLL, 0x10uLL);
          int v38 = (lsl::Allocator *)dyld4::Atlas::Bitmap::Bitmap((uint64_t)v37, v36, (uint64_t)&v47);
          int v45 = v38;
          uint64_t v40 = *(lsl::Allocator ***)(a1 + 40);
          if (&v45 != v40)
          {
            int v41 = *v40;
            *uint64_t v40 = v38;
            int v45 = v41;
          }
          lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v45, v39);
          if ((void)v64) {
            lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v64, v42);
          }
          dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v50);
          goto LABEL_7;
        }
        lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v30, v28);
      }
    }
    uint64_t v31 = (dyld4::FileRecord *)v50;
LABEL_43:
    dyld4::FileRecord::~FileRecord(v31);
    return 0;
  }
LABEL_7:
  uint64_t v18 = lsl::readPVLEUInt64((unsigned __int8 **)&v47);
  uint64_t v3 = 1;
  if (v18)
  {
    uint64_t v19 = v18;
    int v20 = 0;
    while (1)
    {
      int v45 = 0;
      long long v64 = 0uLL;
      memset(v60, 0, sizeof(v60));
      uint64_t v61 = 0x1FFFFFFFFLL;
      __int16 v62 = 0;
      char v63 = 1;
      if (!dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo(a1, (unsigned __int8 **)&v47, (uint64_t *)&v45, &v64, (dyld4::FileRecord *)v60))break; {
      char v21 = 14;
      }
      if ((*(void *)(a1 + 216) & 4) == 0) {
        char v21 = 12;
      }
      int v20 = (lsl::Allocator *)((char *)v20 + ((void)v45 << v21));
      int v45 = v20;
      if (*(unsigned char *)(*(void *)a1 + 104))
      {
        uint64_t v22 = *(os_unfair_lock **)(*(void *)a1 + 72);
        if (v22) {
          atomic_fetch_add_explicit((atomic_uint *volatile)v22, 1u, memory_order_relaxed);
        }
      }
      else
      {
        int v23 = *(lsl::Lock ***)(a1 + 8);
        uint64_t v24 = lsl::Allocator::aligned_alloc(v23, 8uLL, 0x30uLL);
        *uint64_t v24 = v23;
        *(_OWORD *)(v24 + 1) = 0u;
        *(_OWORD *)(v24 + 3) = 0u;
        v24[5] = v23;
        lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v50, (lsl::Allocator::AllocationMetadata *)v24);
        uint64_t v22 = *(os_unfair_lock **)&v50[0];
      }
      *(void *)&v50[0] = *(void *)(a1 + 8);
      dyld4::FileRecord::FileRecord((uint64_t)v50 + 8, (dyld4::FileRecord *)v60);
      int v54 = (lsl::Allocator *)v22;
      if (v22) {
        atomic_fetch_add_explicit((atomic_uint *volatile)v22, 1u, memory_order_relaxed);
      }
      long long v55 = v64;
      memset(v56, 0, 25);
      v56[32] = 0;
      v56[40] = 0;
      long long v57 = v20;
      uint64_t v58 = 0;
      v59[0] = 0;
      *(_DWORD *)((char *)v59 + 7) = 0;
      uint64_t v25 = *(void *)(a1 + 24);
      lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(*(lsl::Lock ***)(a1 + 8), (dyld4::Atlas::Image *)v50, &v44);
      lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert(v25, (uint64_t *)&v44, (uint64_t)v49);
      lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v44);
      dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)v56);
      if (v54) {
        lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v54, v26);
      }
      dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)((char *)v50 + 8));
      if (v22) {
        lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v22, v27);
      }
      dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v60);
      if (!--v19) {
        return 1;
      }
    }
    uint64_t v31 = (dyld4::FileRecord *)v60;
    goto LABEL_43;
  }
  return v3;
}

void dyld4::FileRecord::~FileRecord(dyld4::FileRecord *this, void *a2)
{
  int v3 = *((_DWORD *)this + 16);
  if (v3 != -1)
  {
    close(v3);
    *((_DWORD *)this + 16) = -1;
  }
  unsigned int v4 = (const os_unfair_lock *)*((void *)this + 5);
  if (v4) {
    lsl::Allocator::freeObject(v4, a2);
  }
}

os_unfair_lock *lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(os_unfair_lock *this, void *a2)
{
  if (!atomic_fetch_add((atomic_uint *volatile)this, 0xFFFFFFFF))
  {
    unint64_t v2 = this;
    int v3 = *(dyld4::Atlas::Mapper **)&this[2]._os_unfair_lock_opaque;
    if (v3)
    {
      dyld4::Atlas::Mapper::~Mapper(v3);
      lsl::Allocator::freeObject(*(const os_unfair_lock **)&v2[2]._os_unfair_lock_opaque, v4);
    }
    return (os_unfair_lock *)lsl::Allocator::freeObject(v2, a2);
  }
  return this;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo(uint64_t a1, unsigned __int8 **a2, uint64_t *a3, _OWORD *a4, dyld4::FileRecord *a5)
{
  char PVLEUInt64 = lsl::readPVLEUInt64(a2);
  *a3 = lsl::readPVLEUInt64(a2);
  if ((PVLEUInt64 & 4) != 0)
  {
    *a4 = *(_OWORD *)*a2;
    uint64_t v11 = (uint64_t)(a2[1] - 16);
    *a2 += 16;
    a2[1] = (unsigned __int8 *)v11;
  }
  if (PVLEUInt64)
  {
    unint64_t v12 = lsl::readPVLEUInt64(a2);
    uint64_t v13 = lsl::readPVLEUInt64(a2);
    if (v12 >= *(void *)(a1 + 64)) {
      return 0;
    }
    dyld4::FileManager::fileRecordForVolumeUUIDAndObjID(*(dyld4::FileManager **)(a1 + 16), (const UUID *)(*(void *)(a1 + 56) + 16 * v12), v13, (uint64_t)v16);
    dyld4::FileRecord::operator=(a5, (dyld4::FileRecord *)v16);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v16);
  }
  if ((PVLEUInt64 & 2) == 0) {
    return 1;
  }
  unint64_t v14 = lsl::readPVLEUInt64(a2);
  if (v14 < *(void *)(a1 + 128))
  {
    dyld4::FileManager::fileRecordForPath(*(dyld4::FileManager **)(a1 + 16), *(lsl::Lock ***)(a1 + 8), (const char *)(*(void *)(a1 + 120) + v14), (uint64_t)v16);
    dyld4::FileRecord::operator=(a5, (dyld4::FileRecord *)v16);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v16);
    return 1;
  }
  return 0;
}

uint64_t lsl::readPVLEUInt64(unsigned __int8 **a1)
{
  uint64_t __dst = 0;
  unint64_t v2 = *a1;
  unsigned int v3 = **a1;
  unsigned int v4 = __clz(__rbit32(v3));
  if (**a1) {
    BOOL v5 = v4 == 8;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t result = *(void *)(v2 + 1);
    uint64_t v7 = (uint64_t)(a1[1] - 9);
    *a1 = v2 + 9;
    a1[1] = (unsigned __int8 *)v7;
  }
  else
  {
    uint64_t v8 = v4 + 1;
    char v9 = 7 - v4;
    uint64_t v10 = (v3 >> (v4 + 1)) & ~(-1 << (7 - v4));
    if (v4)
    {
      memmove(&__dst, v2 + 1, v8 - 1);
      uint64_t v11 = __dst;
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t result = (v11 << v9) | v10;
    unint64_t v12 = &a1[1][-v8];
    *a1 = &v2[v8];
    a1[1] = v12;
  }
  return result;
}

dyld4::FileRecord *dyld4::FileRecord::operator=(dyld4::FileRecord *a1, dyld4::FileRecord *a2)
{
  return a1;
}

uint64_t dyld4::FileRecord::FileRecord(uint64_t a1, dyld4::FileRecord *a2)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 74) = 1;
  dyld4::FileRecord::swap((dyld4::FileRecord *)a1, a2);
  return a1;
}

__n128 dyld4::FileRecord::swap(dyld4::FileRecord *this, dyld4::FileRecord *a2)
{
  long long v4 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4;
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)a2 + 1) = v5;
  uint64_t v6 = *((void *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)a2 + 2) = v6;
  uint64_t v7 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  uint64_t v8 = (const os_unfair_lock *)*((void *)a2 + 5);
  if (a2 == this)
  {
    *((void *)a2 + 5) = v7;
    if (v8) {
      lsl::Allocator::freeObject(v8, a2);
    }
  }
  else
  {
    *((void *)this + 5) = v8;
    *((void *)a2 + 5) = v7;
  }
  uint64_t v9 = *(void *)this;
  *(void *)this = *(void *)a2;
  *(void *)a2 = v9;
  __n128 result = *((__n128 *)a2 + 3);
  long long v11 = *((_OWORD *)this + 3);
  *((__n128 *)this + 3) = result;
  *((_OWORD *)a2 + 3) = v11;
  LODWORD(v9) = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)a2 + 16) = v9;
  LODWORD(v9) = *((_DWORD *)this + 17);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  *((_DWORD *)a2 + 17) = v9;
  LOWORD(v9) = *((_WORD *)this + 36);
  *((_WORD *)this + 36) = *((_WORD *)a2 + 36);
  *((_WORD *)a2 + 36) = v9;
  LOBYTE(v9) = *((unsigned char *)this + 74);
  *((unsigned char *)this + 74) = *((unsigned char *)a2 + 74);
  *((unsigned char *)a2 + 74) = v9;
  return result;
}

uint64_t lsl::CRC32c::operator()(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)a1 + 32))(*(void *)a1, a1[2], a2, a3);
  a1[2] = result;
  return result;
}

uint64_t lsl::CRC32cSW::checksum(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  for (uint64_t result = a2; a4; --a4)
  {
    char v5 = *a3++;
    uint64_t result = lsl::CRC32cSW::sCRC32cTable[(v5 ^ result)] ^ (result >> 8);
  }
  return result;
}

double dyld4::FileManager::fileRecordForPath@<D0>(dyld4::FileManager *this@<X0>, lsl::Lock **a2@<X1>, const char *__s@<X2>, uint64_t a4@<X8>)
{
  if (__s) {
    uint64_t v6 = lsl::Allocator::strdup(a2, __s);
  }
  else {
    uint64_t v6 = 0;
  }
  *(void *)a4 = this;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(void *)(a4 + 48) = 0;
  *(void *)(a4 + 56) = 0;
  *(void *)(a4 + 4dyld4::halt((char *)__format, 0) = v6;
  *(void *)&double result = 0x1FFFFFFFFLL;
  *(void *)(a4 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a4 + 72) = 0;
  *(unsigned char *)(a4 + 74) = 1;
  return result;
}

char *lsl::Allocator::strdup(lsl::Lock **this, const char *__s)
{
  unint64_t v4 = _platform_strlen(__s) + 1;
  char v5 = (char *)lsl::Allocator::aligned_alloc(this, 0x10uLL, v4);
  strlcpy(v5, __s, v4);
  return v5;
}

void lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(lsl::Lock **a1@<X0>, dyld4::Atlas::Image *a2@<X1>, void *a3@<X8>)
{
  char v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xC0uLL);
  *char v5 = *(void *)a2;
  *(_OWORD *)(v5 + 7) = 0u;
  *(_OWORD *)(v5 + 5) = 0u;
  *(_OWORD *)(v5 + 3) = 0u;
  *(_OWORD *)(v5 + 1) = 0u;
  v5[9] = 0x1FFFFFFFFLL;
  *((_WORD *)v5 + 4dyld4::halt((char *)__format, 0) = 0;
  *((unsigned char *)v5 + 82) = 1;
  *((unsigned char *)v5 + 144) = 0;
  *((unsigned char *)v5 + 152) = 0;
  *((unsigned char *)v5 + 136) = 0;
  *(_OWORD *)(v5 + 15) = 0u;
  *(_OWORD *)(v5 + 13) = 0u;
  *(_OWORD *)(v5 + 11) = 0u;
  *(_DWORD *)((char *)v5 + 183) = 0;
  v5[21] = 0;
  v5[22] = 0;
  v5[20] = 0;
  dyld4::Atlas::Image::swap((dyld4::Atlas::Image *)v5, a2);
  *a3 = v5;
}

void dyld4::Atlas::Image::swap(dyld4::Atlas::Image *this, dyld4::Atlas::Image *a2)
{
  if (this != a2)
  {
    long long v4 = *((_OWORD *)this + 6);
    *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
    *((_OWORD *)a2 + 6) = v4;
    dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap((uint64_t *)this + 14, (uint64_t *)a2 + 14);
    std::optional<unsigned long long>::swap[abi:nn180100]((uint64_t *)this + 18, (uint64_t *)a2 + 18);
    uint64_t v5 = *((void *)this + 20);
    *((void *)this + 2dyld4::halt((char *)__format, 0) = *((void *)a2 + 20);
    *((void *)a2 + 2dyld4::halt((char *)__format, 0) = v5;
    uint64_t v6 = *((void *)this + 11);
    *((void *)this + 11) = *((void *)a2 + 11);
    *((void *)a2 + 11) = v6;
    uint64_t v7 = *((void *)this + 21);
    *((void *)this + 21) = *((void *)a2 + 21);
    *((void *)a2 + 21) = v7;
    uint64_t v8 = *((void *)this + 22);
    *((void *)this + 22) = *((void *)a2 + 22);
    *((void *)a2 + 22) = v8;
    dyld4::FileRecord::swap((dyld4::Atlas::Image *)((char *)this + 8), (dyld4::Atlas::Image *)((char *)a2 + 8));
    char v9 = *((unsigned char *)this + 184);
    *((unsigned char *)this + 184) = *((unsigned char *)a2 + 184);
    *((unsigned char *)a2 + 184) = v9;
    char v10 = *((unsigned char *)this + 185);
    *((unsigned char *)this + 185) = *((unsigned char *)a2 + 185);
    *((unsigned char *)a2 + 185) = v10;
    char v11 = *((unsigned char *)this + 186);
    *((unsigned char *)this + 186) = *((unsigned char *)a2 + 186);
    *((unsigned char *)a2 + 186) = v11;
  }
}

uint64_t *dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = *result;
    uint64_t v3 = result[1];
    uint64_t v4 = a2[1];
    *double result = *a2;
    result[1] = v4;
    *a2 = v2;
    a2[1] = v3;
    uint64_t v5 = result[2];
    result[2] = a2[2];
    a2[2] = v5;
    LOBYTE(v5) = *((unsigned char *)result + 24);
    *((unsigned char *)result + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((unsigned char *)a2 + 24);
    *((unsigned char *)a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
  }
  return result;
}

uint64_t *std::optional<unsigned long long>::swap[abi:nn180100](uint64_t *result, uint64_t *a2)
{
  if ((*((unsigned char *)result + 8) != 0) != (*((unsigned char *)a2 + 8) != 0))
  {
    if (*((unsigned char *)result + 8))
    {
      *a2 = *result;
      *((unsigned char *)a2 + 8) = 1;
      if (*((unsigned char *)result + 8)) {
        *((unsigned char *)result + 8) = 0;
      }
    }
    else
    {
      *double result = *a2;
      *((unsigned char *)result + 8) = 1;
      if (*((unsigned char *)a2 + 8)) {
        *((unsigned char *)a2 + 8) = 0;
      }
    }
  }
  else if (*((unsigned char *)result + 8))
  {
    uint64_t v2 = *result;
    *double result = *a2;
    *a2 = v2;
  }
  return result;
}

double lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::const_iterator((uint64_t)v19, a1, (uint64_t)a2);
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::insert_internal(a1, (uint64_t)v19, a2, (uint64_t)&v9);
  uint64_t v6 = v9;
  *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v11;
  *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(void *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  char v8 = v17;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 98) = v8;
  *(unsigned char *)(a3 + 104) = v18;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::insert_internal@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v18 = a1;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    memset(v23, 0, sizeof(v23));
    uint64_t result = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v18);
    if ((_BYTE)result
      && (uint64_t v9 = *(unsigned __int8 *)(a2 + 98),
          *(void *)(*a3 + 160) >= *(void *)(*(void *)(*(void *)(a2 + 8 + 8 * (v9 - 1))
                                                          + 8 * *(unsigned __int8 *)(a2 + 88 + v9 - 1))
                                              + 160)))
    {
      char v14 = 0;
      long long v16 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
      long long v17 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = v17;
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + 8) = v16;
      *(void *)(a4 + 88) = *(void *)(a2 + 88);
      *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
      *(unsigned char *)(a4 + 98) = v9;
    }
    else
    {
      uint64_t v18 = a1;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      memset(v23, 0, sizeof(v23));
      if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v18)&& *(unsigned __int8 *)(a2 + 98) == *(unsigned __int8 *)(a1 + 32))
      {
        lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
        uint64_t v10 = a2 + 88;
        uint64_t v11 = *(unsigned __int8 *)(a2 + 98) - 1;
        unsigned __int8 v12 = *(unsigned char *)(a2 + 88 + v11);
      }
      else
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--((uint64_t **)a2);
        lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
        uint64_t v10 = a2 + 88;
        uint64_t v15 = *(unsigned __int8 *)(a2 + 98) + a2 + 88;
        unsigned __int8 v12 = *(unsigned char *)(v15 - 1) + 1;
        *(unsigned char *)(v15 - 1) = v12;
        uint64_t v11 = *(unsigned __int8 *)(a2 + 98) - 1;
      }
      uint64_t result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert(*(void *)(a2 + 8 + 8 * v11), v12, a3);
      ++*(void *)(a1 + 24);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)(a4 + 88) = *(void *)v10;
      *(_WORD *)(a4 + 96) = *(_WORD *)(v10 + 8);
      *(unsigned char *)(a4 + 98) = *(unsigned char *)(a2 + 98);
      char v14 = 1;
    }
  }
  else
  {
    long long v13 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((unsigned char *)v13 + 248) = 0x80;
    *(_OWORD *)long long v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    *((_OWORD *)v13 + 2) = 0u;
    *((_OWORD *)v13 + 3) = 0u;
    *((_OWORD *)v13 + 4) = 0u;
    *((_OWORD *)v13 + 5) = 0u;
    *((_OWORD *)v13 + 6) = 0u;
    *((_OWORD *)v13 + 7) = 0u;
    *((_OWORD *)v13 + 8) = 0u;
    *((_OWORD *)v13 + 9) = 0u;
    *((_OWORD *)v13 + 1dyld4::halt((char *)__format, 0) = 0u;
    *((_OWORD *)v13 + 11) = 0u;
    *((_OWORD *)v13 + 12) = 0u;
    *((_OWORD *)v13 + 13) = 0u;
    *((_OWORD *)v13 + 14) = 0u;
    v13[30] = 0;
    *(void *)a1 = v13;
    char v14 = 1;
    *(unsigned char *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v13;
    *(unsigned char *)(a2 + 98) = 1;
    uint64_t result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert((uint64_t)v13, 0, a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(a4 + 88) = *(void *)(a2 + 88);
    *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
    *(unsigned char *)(a4 + 98) = *(unsigned char *)(a2 + 98);
  }
  *(unsigned char *)(a4 + 104) = v14;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert(uint64_t result, unsigned int a2, uint64_t *a3)
{
  int v3 = *(char *)(result + 248);
  int v4 = v3 & 0x7F;
  if (v3 >= 0) {
    int v5 = 15;
  }
  else {
    int v5 = 31;
  }
  if (v4 == v5) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if (v5 == a2) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  uint64_t v6 = (uint64_t *)(result + 8 * a2);
  if (v4 != a2)
  {
    uint64_t v7 = (uint64_t *)(result + 8 * (v3 & 0x7F));
    uint64_t v10 = *v7;
    char v8 = v7 - 1;
    uint64_t v9 = v10;
    uint64_t v11 = 8 * a2 - 8 * (v3 & 0x7F);
    do
    {
      uint64_t v12 = *v8;
      *char v8 = v9;
      v8[1] = v12;
      --v8;
      v11 += 8;
    }
    while (v11);
  }
  *(unsigned char *)(result + 248) = v3 + 1;
  if (v6 != a3)
  {
    uint64_t v13 = *v6;
    *uint64_t v6 = *a3;
    *a3 = v13;
  }
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::const_iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  if (*(unsigned char *)(a2 + 32))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)a2;
    uint64_t v9 = a1 + 88;
    do
    {
      uint64_t v10 = v9 + 8 * v7;
      *(void *)(v10 - 8dyld4::halt((char *)__format, 0) = v8;
      unsigned int v11 = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::lower_bound_index(v8, a3);
      *(unsigned char *)(v9 + v7) = v11;
      uint64_t v12 = *(void *)(v10 - 80);
      int v13 = *(char *)(v12 + 248);
      if (v11 != (v13 & 0x7F) && *(void *)(*(void *)(v12 + 8 * v11) + 160) < *(void *)(*(void *)a3 + 160))
      {
        *(unsigned char *)(a1 + 98) = v7 + 1;
        return a1;
      }
      unint64_t v14 = *(unsigned __int8 *)(a2 + 32);
      if (v7 + 1 != v14)
      {
        if (v13 < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v8 = *(void *)(v12 + 8 * v11 + 120);
      }
      ++v7;
    }
    while (v7 < v14);
    for (*(unsigned char *)(a1 + 98) = v14; (_BYTE)v14; *(unsigned char *)(a1 + 98) = v14)
    {
      if (*(unsigned char *)(v9 + v14 - 1) != (*(unsigned char *)(*(void *)(v4
                                                                                            + 8 * v14
                                                                                            - 8)
                                                                                + 248) & 0x7F))
        break;
      LOBYTE(v14) = v14 - 1;
    }
  }
  return a1;
}

uint64_t **lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(uint64_t **result)
{
  uint64_t v1 = *((unsigned __int8 *)result + 98);
  uint64_t v2 = *result;
  if (*((unsigned char *)result + 98))
  {
    if (v1 == *((unsigned __int8 *)v2 + 32))
    {
      int v3 = result + 11;
      uint64_t v4 = v1 - 1;
      int v5 = (char *)result + v1 + 87;
      char v6 = *v5;
      if (!*((unsigned char *)result + (v1 - 1) + 88))
      {
        if (!*v5)
        {
          do
          {
            LODWORD(v1) = v1 - 1;
            *((unsigned char *)result + 98) = v1;
            uint64_t v4 = v1 - 1;
            char v6 = *((unsigned char *)v3 + v4);
          }
          while (!v6);
        }
        int v5 = (char *)v3 + v4;
      }
    }
    else
    {
      unint64_t v14 = result + 1;
      uint64_t v15 = result + 11;
      do
      {
        long long v16 = v14[v1 - 1];
        if ((char)v16[31] < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v17 = v16[*((unsigned __int8 *)v15 + v1 - 1) + 15];
        v14[v1] = (uint64_t *)v17;
        *((unsigned char *)v15 + v1) = *(unsigned char *)(v17 + 248) & 0x7F;
        LOBYTE(v1) = *((unsigned char *)result + 98) + 1;
        *((unsigned char *)result + 98) = v1;
      }
      while (*((unsigned __int8 *)v2 + 32) != v1);
      uint64_t v18 = (uint64_t)v15 + v1;
      char v19 = *(unsigned char *)(v18 - 1);
      int v5 = (char *)(v18 - 1);
      char v6 = v19;
    }
  }
  else
  {
    uint64_t v7 = *v2;
    *((unsigned char *)result + 98) = 0;
    if (*((unsigned char *)v2 + 32))
    {
      unsigned __int8 v8 = 0;
      uint64_t v9 = result + 1;
      do
      {
        v9[v8] = (uint64_t *)v7;
        *((unsigned char *)result + v8 + 88) = *(unsigned char *)(v7 + 248) & 0x7F;
        uint64_t v10 = *((unsigned __int8 *)result + 98);
        unsigned int v11 = *((unsigned __int8 *)v2 + 32);
        if (v10 + 1 != v11)
        {
          uint64_t v12 = v9[v10];
          if ((char)v12[31] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          uint64_t v7 = v12[*((unsigned __int8 *)v12 + 248) + 15];
        }
        unsigned __int8 v8 = v10 + 1;
        *((unsigned char *)result + 98) = v8;
      }
      while (v11 > v8);
      uint64_t v13 = v8 - 1;
    }
    else
    {
      uint64_t v13 = -1;
    }
    int v5 = (char *)result + v13 + 88;
    char v6 = *v5;
  }
  *int v5 = v6 - 1;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::lower_bound_index(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned char *)(a1 + 248) & 0x7F;
  if ((*(unsigned char *)(a1 + 248) & 0x7F) != 0)
  {
    int v3 = (void *)a1;
    do
    {
      unint64_t v4 = v2 >> 1;
      int v5 = &v3[v2 >> 1];
      uint64_t v7 = *v5;
      char v6 = v5 + 1;
      v2 += ~(v2 >> 1);
      if (*(void *)(v7 + 160) < *(void *)(*(void *)a2 + 160)) {
        int v3 = v6;
      }
      else {
        unint64_t v2 = v4;
      }
    }
    while (v2);
  }
  else
  {
    LODWORD(v3) = a1 + 8 * v2;
  }
  return ((v3 - a1) >> 3);
}

unsigned __int8 *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion(unsigned __int8 *result)
{
  uint64_t v1 = result[98];
  if (v1 != *(unsigned __int8 *)(*(void *)result + 32)) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion();
  }
  unint64_t v2 = result;
  int v3 = result + 8;
  if (*(char *)(*(void *)&result[8 * v1] + 248) >= 0) {
    int v4 = 15;
  }
  else {
    int v4 = 31;
  }
  if ((*(unsigned char *)(*(void *)&result[8 * v1] + 248) & 0x7F) == v4)
  {
    if (!result[98]) {
      goto LABEL_15;
    }
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    do
    {
      if (*(char *)(v3[v5] + 248) >= 0) {
        int v7 = 15;
      }
      else {
        int v7 = 31;
      }
      if ((*(unsigned char *)(v3[v5] + 248) & 0x7F) != v7) {
        unsigned int v6 = v5;
      }
      ++v5;
    }
    while (v1 != v5);
    if (!v6)
    {
LABEL_15:
      if (*(char *)(*v3 + 248) >= 0) {
        int v8 = 15;
      }
      else {
        int v8 = 31;
      }
      if ((*(unsigned char *)(*v3 + 248) & 0x7F) == v8)
      {
        uint64_t v9 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(*(void *)result + 8), 0x100uLL, 0x100uLL);
        uint64_t result = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::NodeCore((uint64_t)v9, **(void **)v2);
        **(void **)unint64_t v2 = result;
        if (v2[98] && (uint64_t result = (unsigned __int8 *)memmove(v2 + 89, v2 + 88, v2[98]), v2[98]))
        {
          uint64_t result = (unsigned __int8 *)memmove(v3 + 1, v3, 8 * v2[98]);
          LOBYTE(v1) = v2[98] + 1;
        }
        else
        {
          LOBYTE(v1) = 1;
        }
        unsigned int v6 = 0;
        v2[88] = 0;
        uint64_t v10 = *(uint64_t **)v2;
        *((void *)v2 + 1) = **(void **)v2;
        ++*((unsigned char *)v10 + 32);
        v2[98] = v1;
      }
      else
      {
        unsigned int v6 = 0;
      }
    }
    if (v6 + 1 < v1)
    {
      unsigned int v11 = v2 + 88;
      uint64_t v12 = v6;
      do
      {
        int v13 = v12;
        uint64_t result = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::splitChild(v3[v12], v11[v12], *(lsl::Lock ***)(*(void *)v2 + 8));
        uint64_t v14 = v3[v12];
        if (*(char *)(v14 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v15 = v11[v12];
        uint64_t v16 = *(void *)(v14 + 8 * v15 + 120);
        unsigned int v17 = v2[v12 + 89];
        if (v17 > (*(unsigned char *)(v16 + 248) & 0x7Fu))
        {
          unsigned __int8 v18 = v15 + 1;
          v11[v12] = v18;
          v2[v12 + 89] = v17 + (~*(unsigned char *)(v16 + 248) | 0x80);
          uint64_t v19 = v3[v12];
          if (*(char *)(v19 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          *(void *)&v2[8 * v12 + 16] = *(void *)(v19 + 8 * v18 + 120);
        }
        ++v12;
      }
      while (v13 + 2 < v2[98]);
    }
  }
  return result;
}

void dyld4::Atlas::Mapper::~Mapper(dyld4::Atlas::Mapper *this)
{
  if (*((void *)this + 4)) {
    dyld4::Atlas::Mapper::~Mapper();
  }
  uint64_t v15 = *((void *)this + 5);
  uint64_t v16 = 0;
  size_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    size_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 32 * v3;
    int v7 = (__int32 *)(v2 + 24);
    do
    {
      if (*v7 != -1)
      {
        int v8 = &v5[v4];
        uint64_t v9 = wmemchr(v5, *v7, v4);
        uint64_t v10 = v9 ? v9 : v8;
        uint64_t v5 = v16;
        size_t v4 = v17;
        if (v10 == &v16[v17])
        {
          lsl::Vector<unsigned int>::reserve((uint64_t)&v15, v17 + 1);
          __int32 v11 = *v7;
          uint64_t v5 = v16;
          size_t v12 = v17;
          size_t v4 = ++v17;
          v16[v12] = v11;
        }
      }
      v7 += 8;
      v6 -= 32;
    }
    while (v6);
    if (v4)
    {
      uint64_t v13 = 4 * v4;
      do
      {
        int v14 = *v5++;
        close(v14);
        v13 -= 4;
      }
      while (v13);
      uint64_t v5 = v16;
    }
    if (v5) {
      lsl::Vector<unsigned int>::resize((const os_unfair_lock *)&v15, 0);
    }
    uint64_t v2 = *((void *)this + 1);
  }
  if (v2) {
    lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize((const os_unfair_lock *)this, 0);
  }
}

const os_unfair_lock *dyld4::ExternallyViewableState::release(const os_unfair_lock *this, lsl::Allocator *a2)
{
  uint64_t v2 = *(void *)&this->_os_unfair_lock_opaque;
  if (*(void *)&this->_os_unfair_lock_opaque)
  {
    size_t v4 = this;
    uint64_t v5 = *(os_unfair_lock **)(v2 + 72);
    if (v5) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v5, a2);
    }
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((const os_unfair_lock **)(v2 + 64), a2);
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)(v2 + 56), v6);
    uint64_t v7 = *(void *)(v2 + 16);
    if (v7)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(v7, *(lsl::Lock ***)(v2 + 24));
      *(void *)(v2 + 16) = 0;
    }
    *(void *)(v2 + 4dyld4::halt((char *)__format, 0) = 0;
    *(unsigned char *)(v2 + 48) = 0;
    this = lsl::Allocator::free((lsl::Lock **)a2, *(void **)&v4->_os_unfair_lock_opaque);
    *(void *)&v4->_os_unfair_lock_opaque = 0;
  }
  return this;
}

const os_unfair_lock **lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(const os_unfair_lock **a1, void *a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    size_t v4 = *(os_unfair_lock **)&v3[36]._os_unfair_lock_opaque;
    if (v4) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, a2);
    }
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v3[28]);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v3[2]);
    lsl::Allocator::freeObject(*a1, v5);
  }
  return a1;
}

uint64_t *lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  if (v3)
  {
    if (*(void *)(v3 + 8))
    {
      lsl::Allocator::freeObject(*(const os_unfair_lock **)(v3 + 8), a2);
      uint64_t v3 = *a1;
    }
    lsl::Allocator::freeObject((const os_unfair_lock *)v3, a2);
  }
  return a1;
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<unsigned char *,unsigned char *,std::back_insert_iterator<lsl::Vector<char>>>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      char v7 = *v5++;
      lsl::Vector<std::byte>::reserve(a4, *(void *)(a4 + 16) + 1);
      uint64_t v8 = *(void *)(a4 + 8);
      uint64_t v9 = *(void *)(a4 + 16);
      *(void *)(a4 + 16) = v9 + 1;
      *(unsigned char *)(v8 + v9) = v7;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

const os_unfair_lock *dyld4::Atlas::ProcessSnapshot::Serializer::serialize@<X0>(dyld4::Atlas::ProcessSnapshot::Serializer *this@<X0>, lsl::Lock ***a2@<X8>)
{
  *((void *)this + 25) = mach_absolute_time();
  ++*((_DWORD *)this + 52);
  size_t v4 = (lsl::Lock **)*((void *)this + 1);
  *a2 = v4;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  char v93 = 0;
  char v94 = v4;
  uint64_t v95 = 0;
  char v96 = 0;
  uint64_t v89 = 0;
  long long v90 = v4;
  uint64_t v91 = 0;
  char v92 = 0;
  if (vm_page_size == 0x4000) {
    *((void *)this + 27) |= 4uLL;
  }
  uint64_t v5 = **((void **)this + 4);
  if (v5)
  {
    *((void *)this + 27) |= 1uLL;
    uint64_t v6 = (dyld4::FileRecord *)(v5 + 8);
    if (dyld4::FileRecord::persistent((dyld4::FileRecord *)(v5 + 8)))
    {
      char v7 = (__n128 *)dyld4::FileRecord::volume(v6);
      lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert((uint64_t)&v89, v7, (uint64_t)v134);
    }
    else
    {
      Path = (uint64_t *)dyld4::FileRecord::getPath(v6);
      if (Path)
      {
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v93, (char **)&Path, (uint64_t)v134);
      }
      else
      {
        uint64_t v117 = "???";
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v93, &v117, (uint64_t)v134);
      }
    }
  }
  *(void *)&v134[0] = *((void *)this + 3);
  uint64_t v8 = *(char **)&v134[0];
  memset((char *)v134 + 8, 0, 91);
  uint64_t v9 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t **)v134);
  uint64_t v10 = *v9;
  long long v126 = *(_OWORD *)(v9 + 1);
  long long v11 = *(_OWORD *)(v9 + 9);
  long long v12 = *(_OWORD *)(v9 + 7);
  long long v13 = *(_OWORD *)(v9 + 5);
  long long v127 = *(_OWORD *)(v9 + 3);
  long long v128 = v13;
  long long v129 = v12;
  long long v130 = v11;
  int v14 = v9[11];
  __int16 v132 = *((_WORD *)v9 + 48);
  unsigned __int8 v15 = *((unsigned char *)v9 + 98);
  v131 = v14;
  Path = v10;
  unsigned __int8 v133 = v15;
  *(_OWORD *)((char *)&v134[4] + 1dyld4::halt((char *)__format, 0) = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  memset(v122, 0, sizeof(v122));
  uint64_t v117 = v8;
  __int16 v123 = 0;
  char v124 = 0;
  while (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)&v117))
  {
    uint64_t v16 = (dyld4::FileRecord *)(*(void *)(*((void *)&v126 + v133 - 1) + 8 * *((unsigned __int8 *)&v131 + v133 - 1))
                              + 8);
    if (dyld4::FileRecord::persistent(v16))
    {
      size_t v17 = (__n128 *)dyld4::FileRecord::volume(v16);
      lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert((uint64_t)&v89, v17, (uint64_t)v134);
    }
    else
    {
      long long v88 = 0;
      long long v88 = (char *)dyld4::FileRecord::getPath(v16);
      if (v88)
      {
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v93, &v88, (uint64_t)v134);
      }
      else
      {
        long long v87 = "???";
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v93, &v87, (uint64_t)v134);
      }
    }
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(&Path);
  }
  *(void *)&v134[0] = &v89;
  memset((char *)v134 + 8, 0, 109);
  uint64_t v18 = lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++((uint64_t **)v134);
  uint64_t v19 = *v18;
  long long v20 = *(_OWORD *)(v18 + 11);
  long long v21 = *(_OWORD *)(v18 + 9);
  long long v22 = *(_OWORD *)(v18 + 7);
  long long v110 = *(_OWORD *)(v18 + 5);
  long long v111 = v22;
  long long v112 = v21;
  long long v113 = v20;
  long long v23 = *(_OWORD *)(v18 + 3);
  long long v108 = *(_OWORD *)(v18 + 1);
  long long v109 = v23;
  uint64_t v24 = v18[13];
  int v115 = *((_DWORD *)v18 + 28);
  char v25 = *((unsigned char *)v18 + 116);
  uint64_t v114 = v24;
  uint64_t v107 = v19;
  char v116 = v25;
  memset(v134, 0, 108);
  int v97 = &v89;
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  long long v99 = 0u;
  long long v98 = 0u;
  int v105 = 0;
  uint64_t v104 = 0;
  char v106 = 0;
  uint64_t v26 = (const os_unfair_lock *)lsl::Vector<lsl::UUID>::Vector<lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::const_iterator>(v134, (uint64_t)&v107, (uint64_t)&v97, *((void *)this + 1));
  if ((_OWORD *)((char *)this + 48) != v134)
  {
    long long v27 = v134[1];
    v134[1] = *((_OWORD *)this + 4);
    uint64_t v29 = *((void *)this + 6);
    uint64_t v28 = *((void *)this + 7);
    *((_OWORD *)this + 3) = v134[0];
    *((_OWORD *)this + 4) = v27;
    *(void *)&v134[0] = v29;
    *((void *)&v134[0] + 1) = v28;
    if (!v28) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (*((void *)&v134[0] + 1)) {
LABEL_18:
  }
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize(v26, 0);
LABEL_19:
  *(void *)&v134[0] = &v93;
  memset((char *)v134 + 8, 0, 91);
  int v30 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t **)v134);
  uint64_t v31 = *v30;
  long long v126 = *(_OWORD *)(v30 + 1);
  long long v32 = *(_OWORD *)(v30 + 9);
  long long v33 = *(_OWORD *)(v30 + 7);
  long long v34 = *(_OWORD *)(v30 + 5);
  long long v127 = *(_OWORD *)(v30 + 3);
  long long v128 = v34;
  long long v129 = v33;
  long long v130 = v32;
  int v35 = v30[11];
  __int16 v132 = *((_WORD *)v30 + 48);
  unsigned __int8 v36 = *((unsigned char *)v30 + 98);
  v131 = v35;
  Path = v31;
  unsigned __int8 v133 = v36;
  *(_OWORD *)((char *)v122 + 2) = 0u;
  memset((char *)v134 + 8, 0, 91);
  *(void *)&v134[0] = &v93;
  while (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)v134))
  {
    uint64_t v37 = v133 - 1;
    uint64_t v38 = *((void *)&v126 + v37);
    uint64_t v39 = *((unsigned __int8 *)&v131 + v37);
    uint64_t v40 = *((void *)this + 16);
    lsl::Vector<unsigned int>::reserve((uint64_t)this + 144, *((void *)this + 20) + 1);
    uint64_t v41 = *((void *)this + 19);
    uint64_t v42 = *((void *)this + 20);
    *((void *)this + 2dyld4::halt((char *)__format, 0) = v42 + 1;
    *(_DWORD *)(v41 + 4 * v42) = v40;
    uint64_t v43 = *(char **)(v38 + 8 * v39);
    if (*v43)
    {
      uint64_t v44 = 1;
      do
      {
        lsl::Vector<std::byte>::reserve((uint64_t)this + 112, *((void *)this + 16) + 1);
        char v45 = *v43;
        uint64_t v46 = *((void *)this + 15);
        uint64_t v47 = *((void *)this + 16);
        *((void *)this + 16) = v47 + 1;
        *(unsigned char *)(v46 + v47) = v45;
        uint64_t v43 = (char *)(*(void *)(v38 + 8 * v39) + v44++);
      }
      while (*v43);
    }
    lsl::Vector<std::byte>::reserve((uint64_t)this + 112, *((void *)this + 16) + 1);
    uint64_t v48 = *((void *)this + 15);
    uint64_t v49 = *((void *)this + 16);
    *((void *)this + 16) = v49 + 1;
    *(unsigned char *)(v48 + v49) = 0;
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(&Path);
  }
  uint64_t v50 = *((void *)this + 20);
  if (v50)
  {
    uint64_t v51 = (unsigned int *)*((void *)this + 19);
    uint64_t v52 = *((void *)this + 12);
    uint64_t v53 = 4 * v50;
    do
    {
      unsigned int v54 = *v51++;
      uint64_t v55 = *((void *)this + 15) + v54;
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 80, v52 + 1);
      uint64_t v56 = *((void *)this + 11);
      uint64_t v57 = *((void *)this + 12);
      uint64_t v52 = v57 + 1;
      *((void *)this + 12) = v57 + 1;
      *(void *)(v56 + 8 * v57) = v55;
      v53 -= 4;
    }
    while (v53);
  }
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 44), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 45), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(*((void *)this + 23), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 48), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 52), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(*((void *)this + 25), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 53), (uint64_t)a2);
  lsl::emitPVLEUInt64(*((void *)this + 27), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((void **)this + 28), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((void **)this + 29), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((void **)this + 30), (uint64_t)a2);
  lsl::emitPVLEUInt64(*((void *)this + 8), (uint64_t)a2);
  uint64_t v58 = *((void *)this + 8);
  if (v58)
  {
    int v59 = (char *)*((void *)this + 7);
    uint64_t v60 = 16 * v58;
    do
    {
      uint64_t v61 = v59 + 16;
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)v134, v59, v59 + 16, (uint64_t)a2);
      int v59 = v61;
      v60 -= 16;
    }
    while (v60);
  }
  lsl::emitPVLEUInt64(*((void *)this + 16), (uint64_t)a2);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)v134, *((char **)this + 15), (char *)(*((void *)this + 15) + *((void *)this + 16)), (uint64_t)a2);
  if (*((void *)this + 27))
  {
    char v62 = 14;
    if ((*((void *)this + 27) & 4) == 0) {
      char v62 = 12;
    }
    dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo((uint64_t)this, *(void *)(**((void **)this + 4) + 160) >> v62, (char *)(**((void **)this + 4) + 88), (dyld4::FileRecord *)(**((void **)this + 4) + 8), (uint64_t)a2);
    dyld4::Atlas::Bitmap::emit(**((void **)this + 5), (uint64_t)a2);
  }
  lsl::emitPVLEUInt64(*(void *)(*((void *)this + 3) + 24), (uint64_t)a2);
  *(void *)&v134[0] = *((void *)this + 3);
  uint64_t v63 = *(void *)&v134[0];
  memset((char *)v134 + 8, 0, 91);
  long long v64 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t **)v134);
  uint64_t v65 = *v64;
  long long v126 = *(_OWORD *)(v64 + 1);
  long long v66 = *(_OWORD *)(v64 + 9);
  long long v67 = *(_OWORD *)(v64 + 7);
  long long v68 = *(_OWORD *)(v64 + 5);
  long long v127 = *(_OWORD *)(v64 + 3);
  long long v128 = v68;
  long long v129 = v67;
  long long v130 = v66;
  uint64_t v69 = v64[11];
  __int16 v132 = *((_WORD *)v64 + 48);
  unsigned __int8 v70 = *((unsigned char *)v64 + 98);
  v131 = v69;
  Path = v65;
  unsigned __int8 v133 = v70;
  *(_OWORD *)((char *)v122 + 2) = 0u;
  memset((char *)v134 + 8, 0, 91);
  *(void *)&v134[0] = v63;
  if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)v134))
  {
    uint64_t v71 = 0;
    do
    {
      uint64_t v72 = v133 - 1;
      uint64_t v73 = *((void *)&v126 + v72);
      uint64_t v74 = *((unsigned __int8 *)&v131 + v72);
      uint64_t v75 = *(dyld4::Atlas::Image **)(v73 + 8 * v74);
      uint64_t v76 = *((void *)v75 + 20);
      unint64_t v77 = v76 - v71;
      if ((*((void *)this + 27) & 4) != 0) {
        char v78 = 14;
      }
      else {
        char v78 = 12;
      }
      unint64_t v79 = v77 >> v78;
      uint64_t v80 = (char *)dyld4::Atlas::Image::uuid(v75);
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo((uint64_t)this, v79, v80, (dyld4::FileRecord *)(*(void *)(v73 + 8 * v74) + 8), (uint64_t)a2);
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(&Path);
      char v81 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&Path, (uint64_t)v134);
      uint64_t v71 = v76;
    }
    while (v81);
  }
  while (1)
  {
    uint64_t v84 = a2[2];
    if ((v84 & 0xF) == 0) {
      break;
    }
    lsl::Vector<std::byte>::reserve((uint64_t)a2, (unint64_t)v84 + 1);
    int v82 = a2[1];
    uint64_t v83 = a2[2];
    a2[2] = (lsl::Lock **)((char *)v83 + 1);
    *((unsigned char *)v83 + (void)v82) = 0;
  }
  uint64_t v85 = (unsigned int *)lsl::CRC32c::CRC32c((uint64_t)v134);
  lsl::CRC32c::operator()(v85, (uint64_t)a2[1], (uint64_t)a2[2]);
  *((_DWORD *)a2[1] + 8) = lsl::CRC32c::operator unsigned int((uint64_t)v134);
  if (v89) {
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(v89, v90);
  }
  uint64_t result = v93;
  if (v93) {
    return lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate((uint64_t)v93, v94);
  }
  return result;
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      lsl::Vector<std::byte>::reserve(a4, *(void *)(a4 + 16) + 1);
      char v7 = *v5++;
      uint64_t v8 = *(void *)(a4 + 8);
      uint64_t v9 = *(void *)(a4 + 16);
      *(void *)(a4 + 16) = v9 + 1;
      *(unsigned char *)(v8 + v9) = v7;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t lsl::Vector<std::byte>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<std::byte>::reserveExact(result, v2);
  }
  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 98);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 98);
  if (v2 >= v3) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 98);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 98);
  }
  if (v4)
  {
    uint64_t v5 = (unsigned __int8 *)(a1 + 88);
    uint64_t v6 = (unsigned __int8 *)(a2 + 88);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 >= v9;
      if (v7 != v9) {
        break;
      }
      if (!--v4) {
        goto LABEL_8;
      }
    }
    if (v10) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_8:
    BOOL v11 = v3 == v2;
    if (v3 < v2) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v11) {
      return 0;
    }
    else {
      return v12;
    }
  }
}

uint64_t lsl::Vector<std::byte>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), a2);
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        for (unint64_t i = 0; i < v5; ++i)
        {
          *(unsigned char *)(result + i) = *(unsigned char *)(*(void *)(v3 + 8) + i);
          unint64_t v5 = *(void *)(v3 + 16);
        }
      }
      unsigned int v7 = *(void **)(v3 + 8);
      if (v7)
      {
        uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v7);
        unint64_t v5 = *(void *)(v3 + 16);
      }
      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }
    *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

uint64_t **lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(uint64_t **result)
{
  int v1 = *((unsigned __int8 *)result + 98);
  unsigned int v2 = (uint64_t **)*result;
  if (*((unsigned char *)result + 98))
  {
    int v3 = *((unsigned __int8 *)v2 + 32);
    uint64_t v4 = result + 11;
    ++*((unsigned char *)result + (v1 - 1) + 88);
    if (v1 == v3)
    {
      uint64_t v5 = *((unsigned __int8 *)v2 + 32);
      if (v5)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*((unsigned char *)v4 + (v5 + ~(_BYTE)i)) != (result[(v5 + ~(_BYTE)i) + 1][31] & 0x7F)) {
            break;
          }
          *((unsigned char *)result + 98) = v5 + ~(_BYTE)i;
        }
      }
    }
    else
    {
      int v13 = *((unsigned __int8 *)result + 98);
      if (v13 != *((unsigned __int8 *)v2 + 32))
      {
        int v14 = result + 1;
        do
        {
          unsigned __int8 v15 = v14[v13 - 1];
          if ((char)v15[31] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          v14[v13] = (uint64_t *)v15[*((unsigned __int8 *)v4 + v13 - 1) + 15];
          *((unsigned char *)v4 + v13) = 0;
          LOBYTE(v13) = *((unsigned char *)result + 98) + 1;
          *((unsigned char *)result + 98) = v13;
        }
        while (*((unsigned __int8 *)v2 + 32) != v13);
      }
    }
  }
  else
  {
    unsigned int v7 = *v2;
    *((unsigned char *)result + 98) = 0;
    if (*((unsigned char *)v2 + 32))
    {
      unsigned __int8 v8 = 0;
      unsigned int v9 = result + 1;
      do
      {
        v9[v8] = v7;
        *((unsigned char *)result + v8 + 88) = 0;
        uint64_t v10 = *((unsigned __int8 *)result + 98);
        unsigned int v11 = *((unsigned __int8 *)v2 + 32);
        if (v10 + 1 != v11)
        {
          unsigned int v12 = v9[v10];
          if ((char)v12[31] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          unsigned int v7 = (uint64_t *)v12[15];
        }
        unsigned __int8 v8 = v10 + 1;
        *((unsigned char *)result + 98) = v8;
      }
      while (v11 > v8);
    }
  }
  return result;
}

BOOL dyld4::FileRecord::persistent(dyld4::FileRecord *this)
{
  uint64_t v1 = 0;
  unsigned int v2 = (char *)this + 24;
  do
  {
    int v3 = v2[v1];
    if (v2[v1]) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = v1 == 15;
    }
    ++v1;
  }
  while (!v4);
  return v3 && *((void *)this + 1) != 0;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(int a1, uint64_t a2)
{
  uint64_t v3 = 0;
  int v8 = a1;
  do
  {
    uint64_t result = lsl::Vector<std::byte>::reserve(a2, *(void *)(a2 + 16) + 1);
    char v5 = *((unsigned char *)&v8 + v3);
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v7 + 1;
    *(unsigned char *)(v6 + v7) = v5;
    ++v3;
  }
  while (v3 != 4);
  return result;
}

char *dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo(uint64_t a1, unint64_t a2, char *a3, dyld4::FileRecord *this, uint64_t a5)
{
  uint64_t v10 = 0;
  do
  {
    int v11 = a3[v10];
    if (a3[v10]) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = v10 == 15;
    }
    ++v10;
  }
  while (!v12);
  unint64_t v13 = 4 * (v11 != 0);
  if (dyld4::FileRecord::persistent(this))
  {
    v13 |= 1uLL;
  }
  else if (dyld4::FileRecord::getPath(this))
  {
    v13 |= 2uLL;
  }
  lsl::emitPVLEUInt64(v13, a5);
  uint64_t result = lsl::emitPVLEUInt64(a2, a5);
  if ((v13 & 4) != 0) {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)&v31, a3, a3 + 16, a5);
  }
  if (v13)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    unint64_t v16 = *(void *)(a1 + 64);
    uint64_t v17 = dyld4::FileRecord::volume(this);
    if (v16)
    {
      do
      {
        uint64_t v18 = 0;
        unint64_t v19 = v16 >> 1;
        uint64_t v20 = v15 + 16 * (v16 >> 1);
        while (1)
        {
          unsigned int v21 = *(unsigned __int8 *)(v20 + v18);
          unsigned int v22 = *(unsigned __int8 *)(v17 + v18);
          if (v21 < v22) {
            break;
          }
          if (v22 < v21 || v18++ == 15) {
            goto LABEL_24;
          }
        }
        uint64_t v15 = v20 + 16;
        unint64_t v19 = v16 + ~v19;
LABEL_24:
        unint64_t v16 = v19;
      }
      while (v19);
    }
    if (v15 == *(void *)(a1 + 56) + 16 * *(void *)(a1 + 64)) {
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo();
    }
    uint64_t v24 = dyld4::FileRecord::volume(this);
    uint64_t v25 = 0;
    do
    {
      int v26 = *(unsigned __int8 *)(v15 + v25);
      int v27 = *(unsigned __int8 *)(v24 + v25);
    }
    while (v26 == v27 && v25++ != 15);
    if (v26 != v27) {
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo();
    }
    lsl::emitPVLEUInt64((unsigned __int16)((unint64_t)(v15 - *(_DWORD *)(a1 + 56)) >> 4), a5);
    unint64_t v29 = dyld4::FileRecord::objectID(this);
    uint64_t result = lsl::emitPVLEUInt64(v29, a5);
  }
  if ((v13 & 2) != 0)
  {
    uint64_t Path = dyld4::FileRecord::getPath(this);
    return dyld4::Atlas::ProcessSnapshot::Serializer::emitStringRef(a1, Path, a5);
  }
  return result;
}

char *lsl::emitPVLEUInt64(unint64_t a1, uint64_t a2)
{
  unint64_t v11 = a1;
  int v3 = __clz(a1);
  if (v3 == 64) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = 64 - v3;
  }
  if (v4 < 0x39)
  {
    uint64_t v9 = (v4 + 6) / 7;
    unint64_t v11 = (a1 << v9) | (1 << (v9 - 1));
    uint64_t v7 = (char *)&v11 + v9;
    int v8 = (char *)&v12 + 7;
  }
  else
  {
    lsl::Vector<std::byte>::reserve(a2, *(void *)(a2 + 16) + 1);
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v6 + 1;
    *(unsigned char *)(v5 + v6) = 0;
    uint64_t v7 = (char *)&v12;
    int v8 = (char *)&v12 + 6;
  }
  return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)v8, (char *)&v11, v7, a2);
}

uint64_t dyld4::FileRecord::getPath(dyld4::FileRecord *this)
{
  if (!*((void *)this + 5))
  {
    fsid_t v2 = (fsid_t)*((void *)this + 2);
    if (v2) {
      dyld4::FileManager::getPath(*(char **)this, v2, *((void *)this + 1), &v6);
    }
    else {
      dyld4::FileManager::getPath(*(char **)this, (const UUID *)((char *)this + 24), *((void *)this + 1), &v6);
    }
    unsigned int v4 = (const os_unfair_lock *)*((void *)this + 5);
    *((void *)this + 5) = v6;
    if (v4) {
      lsl::Allocator::freeObject(v4, v3);
    }
  }
  return *((void *)this + 5);
}

char *dyld4::Atlas::ProcessSnapshot::Serializer::emitStringRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = a2;
  uint64_t v5 = *(void **)(a1 + 88);
  uint64_t v6 = &v5[*(void *)(a1 + 96)];
  char v11 = 0;
  uint64_t v7 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char const*,std::__identity,lsl::ConstCharStarCompare>(v5, v6, &v10);
  int v8 = *(void **)(a1 + 88);
  if (v7 == &v8[*(void *)(a1 + 96)])
  {
    char v12 = 0;
    uint64_t v7 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char [4],std::__identity,lsl::ConstCharStarCompare>(v8, v7, "???");
  }
  return lsl::emitPVLEUInt64((*(_DWORD *)v7 - *(_DWORD *)(a1 + 120)), a3);
}

void *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char const*,std::__identity,lsl::ConstCharStarCompare>(void *a1, void *a2, void *a3)
{
  if (a2 != a1)
  {
    unint64_t v3 = a2 - a1;
    a2 = a1;
    do
    {
      unint64_t v4 = v3 >> 1;
      uint64_t v5 = &a2[v3 >> 1];
      int v6 = *(char *)*v5;
      if (v6 < *(char *)*a3)
      {
LABEL_9:
        a2 = v5 + 1;
        unint64_t v4 = v3 + ~v4;
      }
      else
      {
        uint64_t v7 = (char *)(*v5 + 1);
        int v8 = (char *)(*a3 + 1);
        int v9 = *(unsigned __int8 *)*a3;
        while (v9 && (char)v9 >= (char)v6)
        {
          if ((_BYTE)v6)
          {
            int v10 = *v7++;
            int v6 = v10;
            int v11 = *v8++;
            int v9 = v11;
            if (v6 >= v11) {
              continue;
            }
          }
          goto LABEL_9;
        }
      }
      unint64_t v3 = v4;
    }
    while (v4);
  }
  return a2;
}

uint64_t lsl::Vector<unsigned int>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<unsigned int>::reserveExact(result, v2);
  }
  return result;
}

double lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert@<D0>(uint64_t *a1@<X0>, char **a2@<X1>, uint64_t a3@<X8>)
{
  int v8 = *a2;
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator((uint64_t)v19, a1, &v8);
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal((uint64_t)a1, (uint64_t)v19, &v8, (uint64_t)&v9);
  uint64_t v5 = v9;
  *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v11;
  *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(void *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  char v7 = v17;
  *(void *)a3 = v5;
  *(unsigned char *)(a3 + 98) = v7;
  *(unsigned char *)(a3 + 104) = v18;
  return result;
}

{
  uint64_t v6;
  double result;
  char v8;
  uint64_t v9;
  long long v10;
  long long v11;
  long long v12;
  long long v13;
  long long v14;
  uint64_t v15;
  __int16 v16;
  char v17;
  char v18;
  unsigned char v19[104];

  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator((uint64_t)v19, a1, a2);
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal((uint64_t)a1, (uint64_t)v19, a2, (uint64_t)&v9);
  int v6 = v9;
  *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v11;
  *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(void *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  int v8 = v17;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 98) = v8;
  *(unsigned char *)(a3 + 104) = v18;
  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v25 = a1;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    memset(v30, 0, sizeof(v30));
    uint64_t result = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v25);
    if ((_BYTE)result
      && (uint64_t v9 = *(unsigned __int8 *)(a2 + 98),
          long long v10 = *(char **)(*(void *)(a2 + 8 + 8 * (v9 - 1)) + 8 * *(unsigned __int8 *)(a2 + 88 + v9 - 1)),
          int v11 = **a3,
          v11 >= *v10))
    {
      int v12 = *v10;
      long long v13 = v10 + 1;
      long long v14 = *a3 + 1;
      while (v12 && (char)v12 >= (char)v11)
      {
        if ((_BYTE)v11)
        {
          int v15 = *v14++;
          int v11 = v15;
          int v16 = *v13++;
          int v12 = v16;
          if (v11 >= v16) {
            continue;
          }
        }
        goto LABEL_9;
      }
      char v21 = 0;
      long long v23 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
      long long v24 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = v24;
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + 8) = v23;
      *(void *)(a4 + 88) = *(void *)(a2 + 88);
      *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
      *(unsigned char *)(a4 + 98) = v9;
    }
    else
    {
LABEL_9:
      uint64_t v25 = a1;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      memset(v30, 0, sizeof(v30));
      if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v25)&& *(unsigned __int8 *)(a2 + 98) == *(unsigned __int8 *)(a1 + 32))
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
        uint64_t v17 = a2 + 88;
        uint64_t v18 = *(unsigned __int8 *)(a2 + 98) - 1;
        unsigned __int8 v19 = *(unsigned char *)(a2 + 88 + v18);
      }
      else
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--((uint64_t **)a2);
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
        uint64_t v17 = a2 + 88;
        uint64_t v20 = *(unsigned __int8 *)(a2 + 98) + a2 + 88;
        unsigned __int8 v19 = *(unsigned char *)(v20 - 1) + 1;
        *(unsigned char *)(v20 - 1) = v19;
        uint64_t v18 = *(unsigned __int8 *)(a2 + 98) - 1;
      }
      uint64_t result = (uint64_t)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(*(char **)(a2 + 8 + 8 * v18), v19, a3);
      ++*(void *)(a1 + 24);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)(a4 + 88) = *(void *)v17;
      *(_WORD *)(a4 + 96) = *(_WORD *)(v17 + 8);
      *(unsigned char *)(a4 + 98) = *(unsigned char *)(a2 + 98);
      char v21 = 1;
    }
  }
  else
  {
    unsigned int v22 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((unsigned char *)v22 + 248) = 0x80;
    *(_OWORD *)unsigned int v22 = 0u;
    *((_OWORD *)v22 + 1) = 0u;
    *((_OWORD *)v22 + 2) = 0u;
    *((_OWORD *)v22 + 3) = 0u;
    *((_OWORD *)v22 + 4) = 0u;
    *((_OWORD *)v22 + 5) = 0u;
    *((_OWORD *)v22 + 6) = 0u;
    *((_OWORD *)v22 + 7) = 0u;
    *((_OWORD *)v22 + 8) = 0u;
    *((_OWORD *)v22 + 9) = 0u;
    *((_OWORD *)v22 + 1dyld4::halt((char *)__format, 0) = 0u;
    *((_OWORD *)v22 + 11) = 0u;
    *((_OWORD *)v22 + 12) = 0u;
    *((_OWORD *)v22 + 13) = 0u;
    *((_OWORD *)v22 + 14) = 0u;
    v22[30] = 0;
    *(void *)a1 = v22;
    char v21 = 1;
    *(unsigned char *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v22;
    *(unsigned char *)(a2 + 98) = 1;
    uint64_t result = (uint64_t)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert((char *)v22, 0, a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(a4 + 88) = *(void *)(a2 + 88);
    *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
    *(unsigned char *)(a4 + 98) = *(unsigned char *)(a2 + 98);
  }
  *(unsigned char *)(a4 + 104) = v21;
  return result;
}

char *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(char *result, unsigned int a2, void *a3)
{
  int v3 = result[248];
  int v4 = v3 & 0x7F;
  if (v3 >= 0) {
    int v5 = 15;
  }
  else {
    int v5 = 31;
  }
  if (v4 == v5) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if (v5 == a2) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  char v7 = result;
  int v8 = &result[8 * a2];
  if (v4 != a2)
  {
    uint64_t result = (char *)memmove(&result[8 * a2 + 8], &result[8 * a2], 8 * (v3 & 0x7F) - 8 * a2);
    LOBYTE(v3) = v7[248];
  }
  v7[248] = v3 + 1;
  *(void *)int v8 = *a3;
  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator(uint64_t a1, uint64_t *a2, void *a3)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  if (*((unsigned char *)a2 + 32))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *a2;
    uint64_t v9 = a1 + 88;
    do
    {
      *(void *)(v4 + 8 * v7) = v8;
      long long v10 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<char const**>,std::__wrap_iter<char const**>,char const*,std::__identity,lsl::ConstCharStarCompare>((void *)v8, (void *)(v8 + 8 * (*(unsigned char *)(v8 + 248) & 0x7F)), a3);
      __int16 v11 = (_WORD)v10 - v8;
      unint64_t v12 = ((unint64_t)v10 - v8) >> 3;
      *(unsigned char *)(v9 + v7) = v12;
      uint64_t v13 = *(void *)(v4 + 8 * v7);
      if ((*(unsigned char *)(v13 + 248) & 0x7F) != v12)
      {
        int v15 = *(char **)(v13 + (v11 & 0x7F8));
        int v16 = *v15;
        if (v16 < *(char *)*a3)
        {
LABEL_15:
          *(unsigned char *)(a1 + 98) = v7 + 1;
          return a1;
        }
        int v17 = *(unsigned __int8 *)*a3;
        uint64_t v18 = (char *)(*a3 + 1);
        unsigned __int8 v19 = v15 + 1;
        while (v17 && (char)v17 >= (char)v16)
        {
          if ((_BYTE)v16)
          {
            int v20 = *v19++;
            int v16 = v20;
            int v21 = *v18++;
            int v17 = v21;
            if (v16 >= v21) {
              continue;
            }
          }
          goto LABEL_15;
        }
      }
      unint64_t v14 = *((unsigned __int8 *)a2 + 32);
      if (v7 + 1 != v14)
      {
        if ((*(unsigned char *)(v13 + 248) & 0x80) != 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v8 = *(void *)(v13 + (v11 & 0x7F8) + 120);
      }
      ++v7;
    }
    while (v7 < v14);
    for (*(unsigned char *)(a1 + 98) = v14; (_BYTE)v14; *(unsigned char *)(a1 + 98) = v14)
    {
      if (*(unsigned char *)(v9 + v14 - 1) != (*(unsigned char *)(*(void *)(v4
                                                                                            + 8 * v14
                                                                                            - 8)
                                                                                + 248) & 0x7F))
        break;
      LOBYTE(v14) = v14 - 1;
    }
  }
  return a1;
}

uint64_t dyld4::Atlas::Image::uuid(dyld4::Atlas::Image *this)
{
  if (!*((unsigned char *)this + 184))
  {
    memset(v5, 0, sizeof(v5));
    unint64_t v2 = (dyld3::MachOFile *)dyld4::Atlas::Image::ml(this);
    if (v2)
    {
      int v3 = v2;
      if (dyld3::MachOFile::hasMachOMagic(v2) && dyld3::MachOFile::getUuid(v3, v5)) {
        *((_OWORD *)this + 6) = *(_OWORD *)v5;
      }
    }
    *((unsigned char *)this + 184) = 1;
  }
  return (uint64_t)this + 96;
}

BOOL dyld3::MachOFile::hasMachOMagic(dyld3::MachOFile *this)
{
  return *(_DWORD *)this >> 1 == 2138504551;
}

uint64_t dyld4::FileRecord::volume(dyld4::FileRecord *this)
{
  return (uint64_t)this + 24;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t v8 = a1;
  do
  {
    uint64_t result = lsl::Vector<std::byte>::reserve(a2, *(void *)(a2 + 16) + 1);
    char v5 = *((unsigned char *)&v8 + v3);
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v7 + 1;
    *(unsigned char *)(v6 + v7) = v5;
    ++v3;
  }
  while (v3 != 8);
  return result;
}

uint64_t mach_absolute_time(void)
{
  if (!MEMORY[0xFFFFFC090]) {
    return mach_absolute_time_kernel();
  }
  if (MEMORY[0xFFFFFC090] == 2)
  {
    do
    {
      uint64_t v3 = MEMORY[0xFFFFFC088];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
    }
    while (v3 != MEMORY[0xFFFFFC088]);
    return StatusReg + v3;
  }
  else if (MEMORY[0xFFFFFC090] == 3)
  {
    do
    {
      uint64_t v5 = MEMORY[0xFFFFFC088];
      unint64_t v6 = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }
    while (v5 != MEMORY[0xFFFFFC088]);
    return v6 + v5;
  }
  else
  {
    __isb(0xFu);
    do
    {
      uint64_t v1 = MEMORY[0xFFFFFC088];
      unint64_t v2 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }
    while (v1 != MEMORY[0xFFFFFC088]);
    return v2 + v1;
  }
}

uint64_t mach_absolute_time_kernel()
{
  return mac_syscall(MACH_ABSOLUTE_TIME_TRAP);
}

int64_t mach_continuous_time_kernel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-4, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t lsl::CRC32c::operator unsigned int(uint64_t a1)
{
  return ~*(_DWORD *)(a1 + 8);
}

uint64_t lsl::CRC32c::CRC32c(uint64_t this)
{
  *(void *)this = &lsl::sCRC32cSW;
  *(_DWORD *)(this + 8) = -1;
  return this;
}

unsigned __int8 *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion(unsigned __int8 *result)
{
  uint64_t v1 = result[98];
  if (v1 != *(unsigned __int8 *)(*(void *)result + 32)) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion();
  }
  unint64_t v2 = result;
  uint64_t v3 = result + 8;
  if (*(char *)(*(void *)&result[8 * v1] + 248) >= 0) {
    int v4 = 15;
  }
  else {
    int v4 = 31;
  }
  if ((*(unsigned char *)(*(void *)&result[8 * v1] + 248) & 0x7F) == v4)
  {
    if (!result[98]) {
      goto LABEL_15;
    }
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    do
    {
      if (*(char *)(v3[v5] + 248) >= 0) {
        int v7 = 15;
      }
      else {
        int v7 = 31;
      }
      if ((*(unsigned char *)(v3[v5] + 248) & 0x7F) != v7) {
        unsigned int v6 = v5;
      }
      ++v5;
    }
    while (v1 != v5);
    if (!v6)
    {
LABEL_15:
      if (*(char *)(*v3 + 248) >= 0) {
        int v8 = 15;
      }
      else {
        int v8 = 31;
      }
      if ((*(unsigned char *)(*v3 + 248) & 0x7F) == v8)
      {
        uint64_t result = (unsigned __int8 *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(*(void *)result + 8), 0x100uLL, 0x100uLL);
        uint64_t v9 = **(void **)v2;
        result[248] = 0;
        *(_OWORD *)uint64_t result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((void *)result + 14) = 0;
        *((void *)result + 15) = v9;
        **(void **)unint64_t v2 = result;
        if (v2[98] && (uint64_t result = (unsigned __int8 *)memmove(v2 + 89, v2 + 88, v2[98]), v2[98]))
        {
          uint64_t result = (unsigned __int8 *)memmove(v3 + 1, v3, 8 * v2[98]);
          LOBYTE(v1) = v2[98] + 1;
        }
        else
        {
          LOBYTE(v1) = 1;
        }
        unsigned int v6 = 0;
        v2[88] = 0;
        long long v10 = *(uint64_t **)v2;
        *((void *)v2 + 1) = **(void **)v2;
        ++*((unsigned char *)v10 + 32);
        v2[98] = v1;
      }
      else
      {
        unsigned int v6 = 0;
      }
    }
    if (v6 + 1 < v1)
    {
      __int16 v11 = v2 + 88;
      uint64_t v12 = v6;
      do
      {
        int v13 = v12;
        uint64_t result = (unsigned __int8 *)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(v3[v12], v11[v12], *(lsl::Lock ***)(*(void *)v2 + 8));
        uint64_t v14 = v3[v12];
        if (*(char *)(v14 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v15 = v11[v12];
        uint64_t v16 = *(void *)(v14 + 8 * v15 + 120);
        unsigned int v17 = v2[v12 + 89];
        if (v17 > (*(unsigned char *)(v16 + 248) & 0x7Fu))
        {
          unsigned __int8 v18 = v15 + 1;
          v11[v12] = v18;
          v2[v12 + 89] = v17 + (~*(unsigned char *)(v16 + 248) | 0x80);
          uint64_t v19 = v3[v12];
          if (*(char *)(v19 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          *(void *)&v2[8 * v12 + 16] = *(void *)(v19 + 8 * v18 + 120);
        }
        ++v12;
      }
      while (v13 + 2 < v2[98]);
    }
  }
  return result;
}

void *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<char const**>,std::__wrap_iter<char const**>,char const*,std::__identity,lsl::ConstCharStarCompare>(void *result, void *a2, void *a3)
{
  if (a2 != result)
  {
    unint64_t v3 = a2 - result;
    do
    {
      unint64_t v4 = v3 >> 1;
      uint64_t v5 = &result[v3 >> 1];
      int v6 = *(char *)*v5;
      if (v6 < *(char *)*a3)
      {
LABEL_9:
        uint64_t result = v5 + 1;
        unint64_t v4 = v3 + ~v4;
      }
      else
      {
        int v7 = (char *)(*v5 + 1);
        int v8 = (char *)(*a3 + 1);
        int v9 = *(unsigned __int8 *)*a3;
        while (v9 && (char)v9 >= (char)v6)
        {
          if ((_BYTE)v6)
          {
            int v10 = *v7++;
            int v6 = v10;
            int v11 = *v8++;
            int v9 = v11;
            if (v6 >= v11) {
              continue;
            }
          }
          goto LABEL_9;
        }
      }
      unint64_t v3 = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t **lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++(uint64_t **result)
{
  int v1 = *((unsigned __int8 *)result + 116);
  unint64_t v2 = (uint64_t **)*result;
  if (*((unsigned char *)result + 116))
  {
    int v3 = *((unsigned __int8 *)v2 + 32);
    unint64_t v4 = result + 13;
    ++*((unsigned char *)result + (v1 - 1) + 104);
    if (v1 == v3)
    {
      uint64_t v5 = *((unsigned __int8 *)v2 + 32);
      if (v5)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*((unsigned char *)v4 + (v5 + ~(_BYTE)i)) != (result[(v5 + ~(_BYTE)i) + 1][31] & 0x7F)) {
            break;
          }
          *((unsigned char *)result + 116) = v5 + ~(_BYTE)i;
        }
      }
    }
    else
    {
      int v13 = *((unsigned __int8 *)result + 116);
      if (v13 != *((unsigned __int8 *)v2 + 32))
      {
        uint64_t v14 = result + 1;
        do
        {
          uint64_t v15 = v14[v13 - 1];
          if ((char)v15[31] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          v14[v13] = (uint64_t *)v15[*((unsigned __int8 *)v4 + v13 - 1) + 20];
          *((unsigned char *)v4 + v13) = 0;
          LOBYTE(v13) = *((unsigned char *)result + 116) + 1;
          *((unsigned char *)result + 116) = v13;
        }
        while (*((unsigned __int8 *)v2 + 32) != v13);
      }
    }
  }
  else
  {
    int v7 = *v2;
    *((unsigned char *)result + 116) = 0;
    if (*((unsigned char *)v2 + 32))
    {
      unsigned __int8 v8 = 0;
      int v9 = result + 1;
      do
      {
        v9[v8] = v7;
        *((unsigned char *)result + v8 + 104) = 0;
        uint64_t v10 = *((unsigned __int8 *)result + 116);
        unsigned int v11 = *((unsigned __int8 *)v2 + 32);
        if (v10 + 1 != v11)
        {
          uint64_t v12 = v9[v10];
          if ((char)v12[31] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          int v7 = (uint64_t *)v12[20];
        }
        unsigned __int8 v8 = v10 + 1;
        *((unsigned char *)result + 116) = v8;
      }
      while (v11 > v8);
    }
  }
  return result;
}

char *dyld4::Atlas::Bitmap::emit(uint64_t a1, uint64_t a2)
{
  lsl::emitPVLEUInt64(*(void *)a1, a2);
  return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>((uint64_t)&v5, *(char **)(a1 + 8), (char *)(*(void *)(a1 + 8) + ((unint64_t)(*(void *)a1 + 7) >> 3)), a2);
}

uint64_t lsl::Vector<unsigned int>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 4 * a2);
    if (result)
    {
LABEL_12:
      *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      return result;
    }
    uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 4 * a2);
    uint64_t v4 = result;
    char v5 = *(void **)(v3 + 8);
    uint64_t v6 = *(void *)(v3 + 16);
    if (v6)
    {
      int v7 = (_DWORD *)result;
      unsigned __int8 v8 = *(int **)(v3 + 8);
      do
      {
        int v9 = *v8++;
        *v7++ = v9;
        --v6;
      }
      while (v6);
    }
    else if (!v5)
    {
      unint64_t v10 = 0;
      goto LABEL_9;
    }
    uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v5);
    unint64_t v10 = *(void *)(v3 + 16);
LABEL_9:
    if (v10 >= a2) {
      unint64_t v10 = a2;
    }
    *(void *)(v3 + 8) = v4;
    *(void *)(v3 + 16) = v10;
    goto LABEL_12;
  }
  return result;
}

void *lsl::Vector<lsl::UUID>::Vector<lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::const_iterator>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = a4;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v12 = *(uint64_t **)a2;
  v13[2] = *(_OWORD *)(a2 + 40);
  v13[3] = *(_OWORD *)(a2 + 56);
  uint64_t v13[4] = *(_OWORD *)(a2 + 72);
  v13[5] = *(_OWORD *)(a2 + 88);
  v13[0] = *(_OWORD *)(a2 + 8);
  v13[1] = *(_OWORD *)(a2 + 24);
  uint64_t v14 = *(void *)(a2 + 104);
  int v15 = *(_DWORD *)(a2 + 112);
  unsigned __int8 v16 = *(unsigned char *)(a2 + 116);
  while (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>((uint64_t)&v12, a3))
  {
    uint64_t v6 = v16 - 1;
    uint64_t v7 = *((void *)v13 + v6);
    uint64_t v8 = *((unsigned __int8 *)&v14 + v6);
    lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)a1, a1[2] + 1);
    uint64_t v9 = a1[1];
    uint64_t v10 = a1[2];
    a1[2] = v10 + 1;
    *(_OWORD *)(v9 + 16 * v1dyld4::halt((char *)__format, 0) = *(_OWORD *)(v7 + 16 * v8);
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++(&v12);
  }
  return a1;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 116);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 116);
  if (v2 >= v3) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 116);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 116);
  }
  if (v4)
  {
    char v5 = (unsigned __int8 *)(a1 + 104);
    uint64_t v6 = (unsigned __int8 *)(a2 + 104);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 >= v9;
      if (v7 != v9) {
        break;
      }
      if (!--v4) {
        goto LABEL_8;
      }
    }
    if (v10) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_8:
    BOOL v11 = v3 == v2;
    if (v3 < v2) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v11) {
      return 0;
    }
    else {
      return v12;
    }
  }
}

uint64_t lsl::Vector<dyld4::InterposeTupleAll>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact(result, v2);
  }
  return result;
}

const os_unfair_lock *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate(uint64_t a1, lsl::Lock **a2)
{
  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    unint64_t v4 = (uint64_t *)(a1 + 120);
    uint64_t v5 = 8 * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      uint64_t v6 = *v4++;
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }

  return lsl::Allocator::free(a2, (void *)a1);
}

uint64_t dyld4::Atlas::SharedCache::SharedCache(uint64_t a1, uint64_t a2, dyld4::FileRecord *a3, atomic_uint **a4, char *a5, char a6)
{
  *(void *)a1 = a2;
  dyld4::FileRecord::FileRecord(a1 + 8, a3);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 112) = 0;
  BOOL v10 = (long long *)(a1 + 112);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 12dyld4::halt((char *)__format, 0) = 0;
  *(void *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  BOOL v11 = *a4;
  *(void *)(a1 + 144) = *a4;
  if (!v11)
  {
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 16dyld4::halt((char *)__format, 0) = a5;
    *(unsigned char *)(a1 + 168) = a6;
    goto LABEL_51;
  }
  atomic_fetch_add_explicit(v11, 1u, memory_order_relaxed);
  uint64_t v12 = *(void *)(a1 + 144);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 16dyld4::halt((char *)__format, 0) = a5;
  *(unsigned char *)(a1 + 168) = a6;
  if (!v12 || (int v13 = *(dyld4::Atlas::Mapper **)(v12 + 8)) == 0) {
LABEL_51:
  }
    dyld4::Atlas::SharedCache::SharedCache();
  vm_size_t v14 = vm_page_size;
  *(void *)&long long v56 = *(void *)(v12 + 8);
  *((void *)&v56 + 1) = vm_page_size;
  int v15 = dyld4::Atlas::Mapper::map(v13, a5, vm_page_size);
  uint64_t v57 = v15;
  char v58 = v16;
  if (v10 != &v56)
  {
    long long v56 = *(_OWORD *)(a1 + 112);
    *(void *)(a1 + 112) = v13;
    *(void *)(a1 + 12dyld4::halt((char *)__format, 0) = v14;
    unsigned int v17 = *(char **)(a1 + 128);
    *(void *)(a1 + 128) = v15;
    uint64_t v57 = v17;
    LOBYTE(v17) = *(unsigned char *)(a1 + 136);
    *(unsigned char *)(a1 + 136) = v16;
    char v58 = (char)v17;
  }
  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v56);
  uint64_t v18 = *(void *)(a1 + 128);
  unsigned int v19 = *(_DWORD *)(v18 + 16);
  if (v19 >= 0x18C) {
    vm_size_t v20 = *(unsigned int *)(v18 + 392) + 56 * *(unsigned int *)(v18 + 396);
  }
  else {
    vm_size_t v20 = *(unsigned int *)(v18 + 24) + 32 * *(unsigned int *)(v18 + 28);
  }
  if (v20 > vm_page_size)
  {
    uint64_t v21 = *(void *)(a1 + 144);
    if (v21) {
      unsigned int v22 = *(dyld4::Atlas::Mapper **)(v21 + 8);
    }
    else {
      unsigned int v22 = 0;
    }
    long long v23 = *(char **)(a1 + 160);
    *(void *)&long long v56 = v22;
    *((void *)&v56 + 1) = v20;
    long long v24 = dyld4::Atlas::Mapper::map(v22, v23, v20);
    uint64_t v57 = v24;
    char v58 = v25;
    if (v10 != &v56)
    {
      long long v56 = *(_OWORD *)(a1 + 112);
      *(void *)(a1 + 112) = v22;
      *(void *)(a1 + 12dyld4::halt((char *)__format, 0) = v20;
      long long v26 = *(char **)(a1 + 128);
      *(void *)(a1 + 128) = v24;
      uint64_t v57 = v26;
      LOBYTE(v26) = *(unsigned char *)(a1 + 136);
      *(unsigned char *)(a1 + 136) = v25;
      char v58 = (char)v26;
    }
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v56);
    uint64_t v18 = *(void *)(a1 + 128);
  }
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(v18 + 88);
  uint64_t v27 = *(void *)(v18 + 224);
  *(void *)(a1 + 152) = *(void *)(a1 + 160) - v27;
  if (*(_DWORD *)(v18 + 16) < 0x18Cu)
  {
    uint64_t v29 = *(unsigned int *)(v18 + 316);
    if (v29)
    {
      unint64_t v30 = 0;
      char v31 = (void *)(*(unsigned int *)(v18 + 312) + v18 + 8);
      do
      {
        if (v30 <= *v31 + *(v31 - 1)) {
          unint64_t v30 = *v31 + *(v31 - 1);
        }
        v31 += 7;
        --v29;
      }
      while (v29);
    }
    else
    {
      unint64_t v30 = 0;
    }
    if (v19 >= 0x18C && *(_DWORD *)(v18 + 396))
    {
      unint64_t v32 = 0;
      uint64_t v33 = v18;
      do
      {
        unsigned int v34 = *(_DWORD *)(v33 + 16);
        uint64_t v35 = v18 + *(unsigned int *)(v33 + 392);
        uint64_t v36 = v35 + 24 * v32 + 16;
        uint64_t v37 = (void *)(v35 + 56 * v32 + 16);
        if (v34 < 0x1C9) {
          uint64_t v37 = (void *)v36;
        }
        uint64_t v38 = *(void *)(a1 + 144);
        if (v38) {
          uint64_t v39 = *(dyld4::Atlas::Mapper **)(v38 + 8);
        }
        else {
          uint64_t v39 = 0;
        }
        uint64_t v40 = &a5[*v37];
        *(void *)&long long v56 = v39;
        *((void *)&v56 + 1) = vm_page_size;
        uint64_t v41 = dyld4::Atlas::Mapper::map(v39, v40, vm_page_size);
        uint64_t v57 = v41;
        char v58 = v42;
        if (*((_DWORD *)v41 + 4) < 0x18Cu) {
          vm_size_t v43 = *((unsigned int *)v41 + 6) + 32 * *((unsigned int *)v41 + 7);
        }
        else {
          vm_size_t v43 = *((unsigned int *)v41 + 98) + 56 * *((unsigned int *)v41 + 99);
        }
        if (v43 > vm_page_size)
        {
          uint64_t v44 = *(void *)(a1 + 144);
          if (v44) {
            char v45 = *(dyld4::Atlas::Mapper **)(v44 + 8);
          }
          else {
            char v45 = 0;
          }
          *(void *)&long long v53 = v45;
          *((void *)&v53 + 1) = v43;
          uint64_t v46 = dyld4::Atlas::Mapper::map(v45, v40, v43);
          long long v47 = v53;
          long long v53 = v56;
          long long v56 = v47;
          uint64_t v48 = v57;
          uint64_t v57 = v46;
          unsigned int v54 = v48;
          LOBYTE(v48) = v58;
          char v58 = v49;
          char v55 = (char)v48;
          dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v53);
          uint64_t v41 = v57;
        }
        uint64_t v50 = *((unsigned int *)v41 + 79);
        if (v50)
        {
          uint64_t v51 = &v41[*((unsigned int *)v41 + 78) + 8];
          do
          {
            if (v30 <= *(void *)v51 + *((void *)v51 - 1)) {
              unint64_t v30 = *(void *)v51 + *((void *)v51 - 1);
            }
            v51 += 56;
            --v50;
          }
          while (v50);
        }
        dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v56);
        ++v32;
        uint64_t v33 = *(void *)(a1 + 128);
      }
      while (v32 < *(unsigned int *)(v33 + 396));
      uint64_t v27 = *(void *)(v33 + 224);
    }
    uint64_t v28 = v30 - v27;
  }
  else
  {
    uint64_t v28 = *(void *)(v18 + 232);
  }
  *(void *)(a1 + 104) = v28;
  return a1;
}

_DWORD *dyld4::Atlas::Image::ml(dyld4::Atlas::Image *this)
{
  if (*((unsigned char *)this + 186)) {
    return 0;
  }
  uint64_t result = (_DWORD *)*((void *)this + 16);
  if (result) {
    return result;
  }
  unint64_t v4 = (long long *)((char *)this + 88);
  unint64_t v3 = (os_unfair_lock *)*((void *)this + 11);
  uint64_t v5 = (char *)*((void *)this + 20);
  if (!v3 || !*(void *)&v3[2]._os_unfair_lock_opaque)
  {
    dyld4::Atlas::Mapper::mapperForMachO(*(lsl::Lock ***)this, (dyld4::Atlas::Image *)((char *)this + 8), (dyld4::Atlas::Image *)((char *)this + 96), *((const UUID **)this + 20), &v19);
    if (&v19 == v4)
    {
      unsigned int v7 = (os_unfair_lock *)v19;
      if (!(void)v19)
      {
LABEL_9:
        unint64_t v3 = *(os_unfair_lock **)v4;
        if (!*(void *)v4)
        {
LABEL_25:
          uint64_t result = 0;
          *((unsigned char *)this + 186) = 1;
          return result;
        }
        goto LABEL_10;
      }
    }
    else
    {
      unsigned int v7 = *(os_unfair_lock **)v4;
      *(void *)unint64_t v4 = v19;
      *(void *)&long long v19 = v7;
      if (!v7) {
        goto LABEL_9;
      }
    }
    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v7, v6);
    goto LABEL_9;
  }
LABEL_10:
  unsigned int v8 = *(dyld4::Atlas::Mapper **)&v3[2]._os_unfair_lock_opaque;
  if (!v8) {
    goto LABEL_25;
  }
  *(void *)&long long v19 = *(void *)&v3[2]._os_unfair_lock_opaque;
  *((void *)&v19 + 1) = 4096;
  unsigned int v9 = dyld4::Atlas::Mapper::map(v8, v5, 4096);
  vm_size_t v20 = v9;
  char v21 = v10;
  if ((long long *)((char *)this + 112) != &v19)
  {
    long long v19 = *((_OWORD *)this + 7);
    *((void *)this + 14) = v8;
    *((void *)this + 15) = 4096;
    BOOL v11 = (char *)*((void *)this + 16);
    *((void *)this + 16) = v9;
    vm_size_t v20 = v11;
    LOBYTE(v11) = *((unsigned char *)this + 136);
    *((unsigned char *)this + 136) = v10;
    char v21 = (char)v11;
  }
  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v19);
  uint64_t result = (_DWORD *)*((void *)this + 16);
  if (!result) {
    goto LABEL_25;
  }
  uint64_t v12 = result[5];
  uint64_t v13 = 28;
  if (*result == -17958193) {
    uint64_t v13 = 32;
  }
  uint64_t v14 = v13 + v12;
  if ((unint64_t)(v13 + v12) > 0x1000)
  {
    int v15 = *(void *)v4 ? *(dyld4::Atlas::Mapper **)(*(void *)v4 + 8) : 0;
    *(void *)&long long v19 = v15;
    *((void *)&v19 + 1) = v13 + v12;
    char v16 = dyld4::Atlas::Mapper::map(v15, v5, v14);
    vm_size_t v20 = v16;
    char v21 = v17;
    if ((long long *)((char *)this + 112) != &v19)
    {
      long long v19 = *((_OWORD *)this + 7);
      *((void *)this + 14) = v15;
      *((void *)this + 15) = v14;
      uint64_t v18 = (char *)*((void *)this + 16);
      *((void *)this + 16) = v16;
      vm_size_t v20 = v18;
      LOBYTE(v18) = *((unsigned char *)this + 136);
      *((unsigned char *)this + 136) = v17;
      char v21 = (char)v18;
    }
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v19);
    uint64_t result = (_DWORD *)*((void *)this + 16);
    if (!result) {
      goto LABEL_25;
    }
  }
  return result;
}

uint64_t dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 && *(unsigned char *)(a1 + 24)) {
    dyld4::Atlas::Mapper::unmap(*(dyld4::Atlas::Mapper **)a1, v2, *(void *)(a1 + 8));
  }
  return a1;
}

char *dyld4::Atlas::Mapper::map(dyld4::Atlas::Mapper *this, char *a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    return &a2[v3 - *(void *)(*((void *)this + 1) + 16)];
  }
  uint64_t v5 = *((void *)this + 2);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 1);
    uint64_t v7 = 32 * v5;
    while (1)
    {
      unint64_t v8 = *(void *)(v6 + 16);
      if (v8 <= (unint64_t)a2)
      {
        unint64_t v9 = *(void *)(v6 + 8) + v8;
        if (v9 > (unint64_t)a2) {
          break;
        }
      }
      v6 += 32;
      v7 -= 32;
      if (!v7) {
        return 0;
      }
    }
    int v10 = *(_DWORD *)(v6 + 24);
    if (v10 == -1)
    {
      return &a2[*(void *)v6 - v8];
    }
    else
    {
      if ((unint64_t)&a2[a3] > v9) {
        dyld4::Atlas::Mapper::map();
      }
      unint64_t v11 = (unint64_t)&a2[*(void *)v6 - v8];
      off_t v12 = v11 & -(uint64_t)vm_page_size;
      uint64_t v13 = (char *)(v11 - v12);
      uint64_t v14 = (char *)mmap(0, v11 - v12 + a3, 1, 2, v10, v12);
      if (v14 == (char *)-1) {
        return 0;
      }
      else {
        return &v14[(void)v13];
      }
    }
  }
  return a2;
}

uint64_t dyld4::Atlas::Bitmap::Bitmap(uint64_t a1, lsl::Lock **a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t PVLEUInt64 = lsl::readPVLEUInt64((unsigned __int8 **)a3);
  *(void *)a1 = PVLEUInt64;
  unint64_t v7 = PVLEUInt64 + 7;
  unint64_t v8 = (unint64_t)(PVLEUInt64 + 7) >> 3;
  int v10 = lsl::Allocator::malloc(a2, v8);
  unint64_t v11 = *(const os_unfair_lock **)(a1 + 8);
  *(void *)(a1 + 8) = v10;
  if (v11) {
    lsl::Allocator::freeObject(v11, v9);
  }
  if (v7 >= 8) {
    memmove(*(void **)(a1 + 8), *(const void **)a3, v8);
  }
  unint64_t v12 = *(void *)(a3 + 8) - v8;
  *(void *)a3 += v8;
  *(void *)(a3 + 8) = v12;
  return a1;
}

void *lsl::Allocator::malloc(lsl::Lock **this, unint64_t a2)
{
  return lsl::Allocator::aligned_alloc(this, 0x10uLL, a2);
}

uint64_t lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,lsl::Allocator&,dyld4::FileRecord,lsl::SharedPtr<dyld4::Atlas::Mapper> &,unsigned long long &,unsigned long long>@<X0>(lsl::Lock **a1@<X0>, uint64_t a2@<X1>, dyld4::FileRecord *a3@<X2>, atomic_uint **a4@<X3>, char **a5@<X4>, void *a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v13 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xB0uLL);
  uint64_t result = dyld4::Atlas::SharedCache::SharedCache((uint64_t)v13, a2, a3, a4, *a5, *a6 != 0);
  *a7 = result;
  return result;
}

uint64_t dyld4::FileRecord::objectID(dyld4::FileRecord *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result)
  {
    dyld4::FileRecord::stat((uint64_t)this);
    return *((void *)this + 1);
  }
  return result;
}

double dyld4::FileManager::fileRecordForVolumeUUIDAndObjID@<D0>(dyld4::FileManager *this@<X0>, const UUID *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)a4 = this;
  *(void *)(a4 + 8) = a3;
  *(void *)(a4 + 16) = 0;
  *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)a2;
  *(void *)(a4 + 48) = 0;
  *(void *)(a4 + 56) = 0;
  *(void *)(a4 + 4dyld4::halt((char *)__format, 0) = 0;
  *(void *)&double result = 0x1FFFFFFFFLL;
  *(void *)(a4 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a4 + 72) = 0;
  *(unsigned char *)(a4 + 74) = 1;
  return result;
}

dyld4::FileRecord *dyld4::FileManager::fileRecordForVolumeDevIDAndObjID@<X0>(dyld4::FileManager *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, dyld4::FileRecord *a4@<X8>)
{
  return dyld4::FileRecord::FileRecord(a4, this, a3, a2, 0);
}

const os_unfair_lock *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(uint64_t a1, lsl::Lock **a2)
{
  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    unint64_t v4 = (uint64_t *)(a1 + 160);
    uint64_t v5 = 8 * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      uint64_t v6 = *v4++;
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }

  return lsl::Allocator::free(a2, (void *)a1);
}

char *dyld4::FileManager::getPath@<X0>(char *this@<X0>, const UUID *a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  uint64_t v5 = this;
  uint64_t v7 = 0;
  do
  {
    int v8 = (*a2)[v7];
    if ((*a2)[v7]) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = v7 == 15;
    }
    ++v7;
  }
  while (!v9);
  if (v8)
  {
    fsid_t v10 = (fsid_t)dyld4::FileManager::fsidForUUID((dyld4::FileManager *)this, a2);
    return dyld4::FileManager::getPath(v5, v10, a3, a4);
  }
  else
  {
    *a4 = 0;
  }
  return this;
}

dyld4::ProcessConfig::Logging *dyld4::ProcessConfig::Logging::Logging(dyld4::ProcessConfig::Logging *this, const char ***a2, const dyld4::ProcessConfig::Security *a3, dyld4::SyscallDelegate *a4)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  if (!*((unsigned char *)a3 + 17))
  {
    *((unsigned char *)this + 1) = 0;
    goto LABEL_14;
  }
  BOOL v8 = _simple_getenv(a2[14], "DYLD_PRINT_SEGMENTS") != 0;
  int v9 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 1) = v8;
  if (!v9)
  {
LABEL_14:
    *(unsigned char *)this = 0;
    *((unsigned char *)this + 2) = 0;
    goto LABEL_15;
  }
  BOOL v10 = _simple_getenv(a2[14], "DYLD_PRINT_LIBRARIES") != 0;
  int v11 = *((unsigned __int8 *)a3 + 17);
  *(unsigned char *)this = v10;
  if (!v11)
  {
    *((_WORD *)this + 1) = 0;
    goto LABEL_20;
  }
  BOOL v12 = _simple_getenv(a2[14], "DYLD_PRINT_BINDINGS") != 0;
  int v13 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 2) = v12;
  if (!v13)
  {
LABEL_15:
    *(_WORD *)((char *)this + 3) = 0;
    goto LABEL_16;
  }
  BOOL v14 = _simple_getenv(a2[14], "DYLD_PRINT_INITIALIZERS") != 0;
  int v15 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 3) = v14;
  if (!v15)
  {
LABEL_20:
    *((_WORD *)this + 2) = 0;
    goto LABEL_21;
  }
  BOOL v16 = _simple_getenv(a2[14], "DYLD_PRINT_APIS") != 0;
  int v17 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 4) = v16;
  if (!v17)
  {
LABEL_16:
    *(_WORD *)((char *)this + 5) = 0;
    goto LABEL_17;
  }
  BOOL v18 = _simple_getenv(a2[14], "DYLD_PRINT_NOTIFICATIONS") != 0;
  int v19 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 5) = v18;
  if (!v19)
  {
LABEL_21:
    *((_WORD *)this + 3) = 0;
    goto LABEL_22;
  }
  BOOL v20 = _simple_getenv(a2[14], "DYLD_PRINT_INTERPOSING") != 0;
  int v21 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 6) = v20;
  if (!v21)
  {
LABEL_17:
    *(_WORD *)((char *)this + 7) = 0;
    goto LABEL_18;
  }
  BOOL v22 = _simple_getenv(a2[14], "DYLD_PRINT_LOADERS") != 0;
  int v23 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 7) = v22;
  if (!v23)
  {
LABEL_22:
    BOOL v28 = 0;
    *((_WORD *)this + 4) = 0;
    goto LABEL_23;
  }
  BOOL v24 = _simple_getenv(a2[14], "DYLD_PRINT_SEARCHING") != 0;
  int v25 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 8) = v24;
  if (!v25)
  {
LABEL_18:
    BOOL v28 = 0;
    *((unsigned char *)this + 9) = 0;
LABEL_23:
    BOOL v29 = 1;
    goto LABEL_24;
  }
  BOOL v26 = _simple_getenv(a2[14], "DYLD_PRINT_ENV") != 0;
  int v27 = *((unsigned __int8 *)a3 + 17);
  *((unsigned char *)this + 9) = v26;
  if (!v27)
  {
    BOOL v28 = 0;
    goto LABEL_23;
  }
  BOOL v28 = _simple_getenv(a2[14], "DYLD_PRINT_TO_STDERR") != 0;
  BOOL v29 = *((unsigned char *)a3 + 17) == 0;
LABEL_24:
  *((unsigned char *)this + 16) = v28;
  *((_DWORD *)this + 3) = 2;
  *((unsigned char *)this + 17) = 0;
  if (!v29)
  {
    if (*((unsigned char *)a3 + 19))
    {
      unint64_t v30 = _simple_getenv(a2[14], "DYLD_PRINT_TO_FILE");
      if (v30)
      {
        int v31 = dyld4::SyscallDelegate::openLogFile(a4, v30);
        if (v31 != -1)
        {
          *((unsigned char *)this + 17) = 1;
          *((_DWORD *)this + 3) = v31;
        }
      }
    }
  }
  if (*((unsigned char *)a3 + 17))
  {
    unint64_t v32 = _simple_getenv(a2[14], "DYLD_PRINT_LINKS_WITH");
    if (v32)
    {
      uint64_t v33 = v32;
      size_t v34 = _platform_strlen(v32);
      *((void *)this + 3) = v33;
      *((void *)this + 4) = v34;
    }
  }
  return this;
}

long long *dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(long long *a1, lsl::Lock **this, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = this;
  *((void *)a1 + 1) = a3;
  *((void *)a1 + 2) = 0;
  int v11 = (uint64_t *)(a1 + 1);
  *((void *)a1 + 3) = this;
  *((void *)a1 + 5) = 0;
  *((unsigned char *)a1 + 48) = 0;
  *((void *)a1 + 7) = 0;
  BOOL v12 = (const os_unfair_lock **)a1 + 7;
  int v13 = (void *)a1 + 9;
  *((void *)a1 + 8) = 0;
  BOOL v14 = (const os_unfair_lock **)(a1 + 4);
  int v15 = lsl::Allocator::aligned_alloc(this, 8uLL, 0x30uLL);
  *int v15 = this;
  *(_OWORD *)(v15 + 1) = 0u;
  *(_OWORD *)(v15 + 3) = 0u;
  v15[5] = this;
  lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v13, (lsl::Allocator::AllocationMetadata *)v15);
  *((void *)a1 + 1dyld4::halt((char *)__format, 0) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 11) = 0;
  *((unsigned char *)a1 + 104) = a4;
  *((unsigned char *)a1 + 105) = 1;
  BOOL v22 = a1;
  long long v23 = *a1;
  BOOL v24 = v11;
  int v25 = v14;
  BOOL v26 = v12;
  uint64_t v27 = v23;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  uint64_t v31 = v23;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v32 = 0;
  uint64_t v35 = v23;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v36 = 0;
  uint64_t v39 = v23;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  int v43 = -1491447450;
  uint64_t v45 = 0;
  uint64_t v44 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  char v49 = a1 + 5;
  uint64_t v50 = (uint64_t)a1 + 88;
  uint64_t v51 = a1 + 6;
  if ((dyld4::Atlas::ProcessSnapshot::Serializer::deserialize((uint64_t)&v22, a5, a6) & 1) == 0)
  {
    if (*v11)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(*v11, *((lsl::Lock ***)a1 + 3));
      *((void *)a1 + 2) = 0;
    }
    *((void *)a1 + 5) = 0;
    *((unsigned char *)a1 + 48) = 0;
    int v21 = 0;
    if (&v21 != v12)
    {
      int v17 = *v12;
      *BOOL v12 = 0;
      int v21 = v17;
    }
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v21, v16);
    int v21 = 0;
    if (&v21 != v14)
    {
      int v19 = *v14;
      char *v14 = 0;
      int v21 = v19;
    }
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(&v21, v18);
    *((unsigned char *)a1 + 105) = 0;
    *((void *)a1 + 11) = 0;
    *((void *)a1 + 12) = 0;
    *((void *)a1 + 1dyld4::halt((char *)__format, 0) = 0;
  }
  if (v40) {
    lsl::Vector<unsigned int>::resize((const os_unfair_lock *)&v39, 0);
  }
  if (v36) {
    lsl::Vector<std::byte>::resize((const os_unfair_lock *)&v35, 0);
  }
  if (v32) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v31, 0);
  }
  if (v28) {
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((const os_unfair_lock *)&v27, 0);
  }
  return a1;
}

void *lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(void *a1, lsl::Allocator::AllocationMetadata *this)
{
  *a1 = 0;
  unint64_t v4 = (lsl::Allocator::AllocationMetadata *)lsl::Allocator::AllocationMetadata::forPtr(this, this);
  uint64_t v5 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(v4, 1);
  uint64_t v6 = (lsl::Lock **)lsl::Allocator::Pool::allocator(v5);
  uint64_t v7 = lsl::Allocator::aligned_alloc(v6, 8uLL, 0x10uLL);
  *(_DWORD *)uint64_t v7 = 0;
  v7[1] = this;
  *a1 = v7;
  return a1;
}

uint64_t lsl::Allocator::AllocationMetadata::forPtr(lsl::Allocator::AllocationMetadata *this, void *a2)
{
  return (uint64_t)this - 16;
}

void dyld4::RuntimeState::notifyDebuggerLoad(lsl::AllocatorLayout *a1, uint64_t a2)
{
  uint64_t v4 = lsl::AllocatorLayout::minSize(a1);
  __chkstk_darwin(v4, v4, v5, v6, v7, v8, v9, v10, (uint64_t)v44);
  BOOL v12 = (char *)&v44 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  int v15 = (char *)lsl::AllocatorLayout::minSize(v14);
  uint64_t v44 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v12, v15);
  uint64_t v16 = *(void *)(a2 + 8);
  uint64_t v17 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)v44);
  __chkstk_darwin(v17, v17 + 40 * v16 + 64, v18, v19, v20, v21, v22, v23, (uint64_t)v44);
  int v25 = (lsl::Allocator *)((char *)&v44 - v24);
  bzero((char *)&v44 - v24, v26);
  uint64_t v27 = *(void *)(a2 + 8);
  uint64_t v29 = lsl::AllocatorLayout::minSize(v28);
  uint64_t v30 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v25, (char *)(v29 + 40 * v27 + 64));
  uint64_t v46 = v30;
  int8x16_t v47 = 0uLL;
  uint64_t v48 = 0;
  lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact((uint64_t)&v46, *(void *)(a2 + 8));
  uint64_t v31 = *(void *)(a2 + 8);
  if (v31)
  {
    uint64_t v32 = *(dyld4::Loader ***)a2;
    uint64_t v33 = 8 * v31;
    do
    {
      uint64_t v34 = *v32;
      if (*v32 != *((dyld4::Loader **)a1 + 3))
      {
        if ((*((_WORD *)v34 + 2) & 2) != 0)
        {
          uint64_t v36 = 0;
          uint64_t v35 = 0;
        }
        else
        {
          dyld4::Loader::fileID(*v32, v45);
          uint64_t v35 = v45[0].i64[1];
          uint64_t v36 = v45[0].i64[0];
        }
        uint64_t v37 = dyld4::Loader::path(v34, a1);
        uint64_t Address = dyld4::Loader::loadAddress(v34, a1);
        int v39 = (*((unsigned __int8 *)v34 + 4) >> 1) & 1;
        lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve((uint64_t)&v46, v47.i64[1] + 1);
        uint64_t v40 = v47.i64[1]++;
        uint64_t v41 = v47.i64[0] + 40 * v40;
        *(void *)uint64_t v41 = v35;
        *(void *)(v41 + 8) = v36;
        *(void *)(v41 + 16) = v37;
        *(void *)(v41 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = Address;
        *(unsigned char *)(v41 + 32) = v39;
      }
      ++v32;
      v33 -= 8;
    }
    while (v33);
  }
  uint64_t v42 = (lsl::Allocator *)v44;
  if (v47.i64[1])
  {
    int v43 = (lsl::Lock **)*((void *)a1 + 2);
    v45[0] = v47;
    dyld4::ExternallyViewableState::addImages((uint64_t)a1 + 536, v43, v44, v45[0].i64);
  }
  if (v47.i64[0]) {
    lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::resize((const os_unfair_lock *)&v46, 0);
  }
  lsl::Allocator::~Allocator(v30);
  lsl::Allocator::~Allocator(v42);
}

uint64_t lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact(result, v2);
  }
  return result;
}

unint64_t dyld4::APIs::dlopen_from(dyld4::RuntimeLocks **this, dyld4::Loader *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v9 = a3;
  v153 = a2;
  int v152 = a3;
  int v143 = 520617984;
  uint64_t v144 = 0;
  v145 = a2;
  uint64_t v146 = (int)a3;
  long long v147 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v143, (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "dlopen(\"%s\", 0x%08X)\n", (const char *)a2, v9);
  }
  dyld4::APIs::clearErrorString((uint64_t)this);
  int v12 = v152;
  unsigned __int8 v142 = BYTE1(v152) & 1;
  if (!v153)
  {
    if ((v152 & 0x100) != 0) {
      unint64_t v16 = -5;
    }
    else {
      unint64_t v16 = -2;
    }
    goto LABEL_109;
  }
  size_t v13 = this[121];
  if (v13)
  {
    LODWORD(v135) = 0;
    if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)this[1] + 30, (const char *)v153, (unsigned int *)&v135))
    {
      if (*((_DWORD *)v13 + 3) <= (unsigned __int16)v135) {
        dyld4::RuntimeState::findPrebuiltLoader();
      }
      unint64_t v14 = (unint64_t)v13
          + *(unsigned int *)((char *)v13 + 4 * (unsigned __int16)v135 + *((unsigned int *)v13 + 4));
      if (dyld4::PrebuiltLoader::isInitialized(v14, (uint64_t)this))
      {
        unint64_t v16 = dyld4::handleFromLoader(v14, (const dyld4::Loader *)v142);
        if (*((unsigned char *)this[1] + 204))
        {
          uint64_t v17 = dyld4::Loader::leafName(v153, v15);
          dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => %p\n", (const char *)v17, (const void *)v16);
        }
        *((void *)&v148 + 1) = v16;
        *(void *)&long long v149 = 0;
        goto LABEL_109;
      }
    }
    int v12 = v152;
  }
  uint64_t v18 = this[17];
  if ((v12 & 0x10) == 0) {
    dyld4::RuntimeLocks::takeDlopenLockBeforeFork(this[17]);
  }
  uint64_t ImageContaining = 0;
  uint64_t ImageContaining = (lsl::AllocatorLayout *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a4);
  uint64_t v139 = 0;
  unint64_t v140 = 0;
  uint64_t v19 = lsl::AllocatorLayout::minSize(ImageContaining);
  __chkstk_darwin(v19, v19 + 1088, v20, v21, v22, v23, v24, v25, v116);
  uint64_t v27 = (char *)&v116 - ((v26 + 1103) & 0xFFFFFFFFFFFFFFF0);
  bzero(v27, v28);
  uint64_t v30 = lsl::AllocatorLayout::minSize(v29);
  uint64_t v31 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v27, (char *)(v30 + 1088));
  v135 = v31;
  v136 = 0;
  v137 = 0;
  uint64_t v138 = 0;
  uint64_t v32 = (lsl::AllocatorLayout *)lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v135, 0x80uLL);
  uint64_t v33 = lsl::AllocatorLayout::minSize(v32);
  __chkstk_darwin(v33, v33 + 192, v34, v35, v36, v37, v38, v39, v116);
  uint64_t v41 = (char *)&v116 - ((v40 + 207) & 0xFFFFFFFFFFFFFFF0);
  bzero(v41, v42);
  uint64_t v44 = lsl::AllocatorLayout::minSize(v43);
  long long v121 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v41, (char *)(v44 + 192));
  v131 = v121;
  uint64_t v132 = 0;
  uint64_t v133 = 0;
  uint64_t v134 = 0;
  lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact((uint64_t)&v131, 8uLL);
  uint64_t v45 = this[16];
  uint64_t v46 = this[17];
  v130[0] = this;
  v130[1] = &ImageContaining;
  v130[2] = &v152;
  v130[3] = &v139;
  v130[4] = &v153;
  v130[5] = &v140;
  v130[6] = &v142;
  v130[7] = &v131;
  v130[8] = &v135;
  uint64_t v122 = v45;
  unint64_t v154 = 0;
  if (v45) {
    int8x16_t v47 = v45;
  }
  else {
    int8x16_t v47 = 0;
  }
  if (*((unsigned char *)v47 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_111;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_111;
    }
    unint64_t v154 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v154)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_111;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_111;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v48 = MEMORY[0xFFFFFC0D0];
      if (v48 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_111;
      }
    }
  }
  else
  {
    unint64_t v154 = 1;
    lsl::MemoryManager::lockGuard(v47, &v126);
    uint64_t v49 = *((void *)v47 + 3);
    if (!v49)
    {
      lsl::MemoryManager::writeProtect(v47, 0);
      uint64_t v49 = *((void *)v47 + 3);
    }
    *((void *)v47 + 3) = v49 + 1;
    lsl::Lock::unlock(v126);
  }
  if (*(void *)v46)
  {
    (*(void (**)(void, void *, void))(**(void **)v46 + 104))(*(void *)v46, (void *)v46 + 1, 0);
    dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()((uint64_t)v130);
    uint64_t v50 = (lsl::AllocatorLayout *)(*(uint64_t (**)(void, void *))(**(void **)v46 + 112))(*(void *)v46, (void *)v46 + 1);
  }
  else
  {
    dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()((uint64_t)v130);
  }
  if (v122) {
    uint64_t v57 = v122;
  }
  else {
    uint64_t v57 = 0;
  }
  if (!*((unsigned char *)v57 + 32))
  {
    lsl::MemoryManager::lockGuard(v57, &v126);
    if (v154 == 1)
    {
      uint64_t v61 = *((void *)v57 + 3) - 1;
      *((void *)v57 + 3) = v61;
      if (!v61) {
        lsl::MemoryManager::writeProtect(v57, 1);
      }
    }
    else if (v154 == 0xFFFFFFFF)
    {
      uint64_t v60 = *((void *)v57 + 3);
      if (!v60)
      {
        lsl::MemoryManager::writeProtect(v57, 0);
        uint64_t v60 = *((void *)v57 + 3);
      }
      *((void *)v57 + 3) = v60 + 1;
    }
    uint64_t v50 = (lsl::AllocatorLayout *)lsl::Lock::unlock(v126);
    goto LABEL_58;
  }
  if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
LABEL_111:
  }
    __break(1u);
  if (v154 != ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1))
  {
    if (v154 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_111;
      }
      uint64_t v50 = (lsl::AllocatorLayout *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v58 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_111;
      }
      uint64_t v50 = (lsl::AllocatorLayout *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v58 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v58 == StatusReg) {
      goto LABEL_58;
    }
    goto LABEL_111;
  }
LABEL_58:
  if (!v133) {
    goto LABEL_89;
  }
  uint64_t v62 = lsl::AllocatorLayout::minSize(v50);
  __chkstk_darwin(v62, v62 + 128, v63, v64, v65, v66, v67, v68, v116);
  unsigned __int8 v70 = (char *)&v116 - ((v69 + 143) & 0xFFFFFFFFFFFFFFF0);
  bzero(v70, v71);
  uint64_t v73 = lsl::AllocatorLayout::minSize(v72);
  uint64_t v74 = (lsl::Lock *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v70, (char *)(v73 + 128));
  long long v126 = v74;
  long long v127 = 0;
  uint64_t v128 = 0;
  uint64_t v129 = 0;
  uint64_t v75 = (lsl::AllocatorLayout *)lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v126, 8uLL);
  uint64_t v76 = v133;
  if (!v133) {
    goto LABEL_86;
  }
  uint64_t v117 = v74;
  long long v118 = v31;
  long long v119 = v18;
  int v120 = v12;
  uint64_t v77 = 0;
  char v78 = 0;
  while (1)
  {
    uint64_t v79 = v132;
    uint64_t v80 = (uint64_t *)(v132 + 16 * v77);
    if (v128)
    {
      uint64_t v81 = 8 * v128;
      int v82 = v127;
      while (*v82 != *v80)
      {
        ++v82;
        v81 -= 8;
        if (!v81)
        {
          int v82 = &v127[v128];
          break;
        }
      }
    }
    else
    {
      int v82 = v127;
    }
    if (v128 == v82 - v127) {
      break;
    }
    uint64_t v99 = v77 + 1;
LABEL_83:
    uint64_t v77 = v99;
    if (v99 == v76) {
      goto LABEL_84;
    }
  }
  uint64_t v83 = lsl::AllocatorLayout::minSize(v75);
  __chkstk_darwin(v83, v83 + 128, v84, v85, v86, v87, v88, v89, v116);
  uint64_t v91 = (char *)&v116 - ((v90 + 143) & 0xFFFFFFFFFFFFFFF0);
  bzero(v91, v92);
  uint64_t v94 = lsl::AllocatorLayout::minSize(v93);
  uint64_t v95 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v91, (char *)(v94 + 128));
  uint64_t v122 = v95;
  uint64_t v124 = 0;
  uint64_t v125 = 0;
  uint64_t v123 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v122, 8uLL);
  lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v122, v124 + 1);
  uint64_t v96 = *(void *)(v79 + 16 * v77 + 8);
  uint64_t v97 = v124;
  uint64_t v98 = ++v124;
  *(void *)(v123 + 8 * v97) = v96;
  uint64_t v99 = v77 + 1;
  uint64_t v100 = v133;
  if (v77 + 1 != v133)
  {
    uint64_t v101 = 16 * v77;
    uint64_t v102 = v99;
    do
    {
      uint64_t v103 = v132 + v101;
      if (*(void *)(v132 + v101 + 16) == *v80)
      {
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v122, v98 + 1);
        uint64_t v104 = *(void *)(v103 + 24);
        uint64_t v105 = v124;
        uint64_t v98 = ++v124;
        *(void *)(v123 + 8 * v105) = v104;
        uint64_t v100 = v133;
      }
      ++v102;
      v101 += 16;
    }
    while (v102 != v100);
  }
  uint64_t v106 = *v80;
  if (*(_WORD *)(*v80 + 4)) {
    uint64_t v106 = 0;
  }
  uint64_t v107 = *(uint64_t (****)(char *))(v106 + 104);
  long long v108 = (const char *)dyld4::PseudoDylib::finalizeRequestedSymbols(v107, v123, v98);
  long long v109 = (char *)v108;
  if (v108)
  {
    dyld4::APIs::setErrorString((vm_address_t *)this, "dlopen(%s, 0x%04X): %s", (const char *)v153, v152, v108);
    dyld4::PseudoDylib::disposeString(v107, v109);
    char v78 = 1;
  }
  else
  {
    lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v126, v128 + 1);
    uint64_t v110 = *v80;
    uint64_t v111 = v128++;
    v127[v111] = v110;
  }
  if (v123) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v122, 0);
  }
  lsl::Allocator::~Allocator(v95);
  if (!v109)
  {
    uint64_t v76 = v133;
    goto LABEL_83;
  }
LABEL_84:
  LOBYTE(v12) = v120;
  uint64_t v31 = v118;
  uint64_t v18 = v119;
  uint64_t v74 = v117;
  if (v78)
  {
    uint64_t v139 = 0;
    unint64_t v140 = 0;
  }
LABEL_86:
  if (v127) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v126, 0);
  }
  lsl::Allocator::~Allocator(v74);
LABEL_89:
  if (v139 && (v152 & 0x10) == 0)
  {
    if (v137)
    {
      long long v126 = v136;
      long long v127 = v137;
      dyld4::RuntimeState::notifyLoad((const dyld4::RuntimeState *)this, (uint64_t)&v126, v51, v52, v53, v54, v55, v56);
    }
    if (*((unsigned char *)this + 656))
    {
      dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(v139, (uint64_t)this, (uint64_t)v51, (uint64_t)v52, (uint64_t)v53, (uint64_t)v54, (uint64_t)v55, (uint64_t)v56);
    }
    else if (*((unsigned char *)this[1] + 203))
    {
      long long v112 = (const char *)dyld4::Loader::path(v139, (const dyld4::RuntimeState *)this);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "dlopen() within libSystem's initializer, so skipping initialization of %s\n", v112);
    }
    unint64_t v140 = dyld4::handleFromLoader((unint64_t)v139, (const dyld4::Loader *)v142);
  }
  if (*((unsigned char *)this[1] + 204))
  {
    uint64_t v113 = (*(uint64_t (**)(dyld4::RuntimeLocks *, dyld4::RuntimeLocks *))(*(void *)this[19] + 64))(this[19], this[140]);
    if (v113 && *(unsigned char *)(v113 + 8))
    {
      dyld4::Loader::leafName(v153, v114);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => NULL, '%s'\n");
    }
    else
    {
      dyld4::Loader::leafName(v153, v114);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => %p\n");
    }
  }
  unint64_t v16 = v140;
  *((void *)&v148 + 1) = v140;
  *(void *)&long long v149 = 0;
  if (v132) {
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((const os_unfair_lock *)&v131, 0);
  }
  lsl::Allocator::~Allocator(v121);
  if (v136) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v135, 0);
  }
  lsl::Allocator::~Allocator(v31);
  if ((v12 & 0x10) == 0) {
    dyld4::RuntimeLocks::releaseDlopenLockInForkParent(v18);
  }
LABEL_109:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v143);
  return v16;
}

uint64_t lsl::AllocatorLayout::minSize(lsl::AllocatorLayout *this)
{
  return 256;
}

_OWORD *lsl::Allocator::stackAllocatorInternal(lsl::Allocator *this, char *a2)
{
  if (!this) {
    lsl::Allocator::stackAllocatorInternal();
  }
  if (!a2) {
    lsl::Allocator::stackAllocatorInternal();
  }
  if ((unint64_t)a2 < 0xB0
    || (unint64_t v3 = (char *)(((unint64_t)this + 15) & 0xFFFFFFFFFFFFFFF0),
        unint64_t v4 = (char *)(v3 - (char *)this),
        v4 > a2 - 176))
  {
    lsl::Allocator::stackAllocatorInternal();
  }
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 1dyld4::halt((char *)__format, 0) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *(_OWORD *)unint64_t v3 = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  uint64_t v5 = v3 + 80;
  lsl::AllocatorLayout::init((lsl::AllocatorLayout *)v3, a2 - v4, 0, 0, 0);
  return v5;
}

lsl::Allocator::Pool *lsl::AllocatorLayout::init(lsl::AllocatorLayout *this, unint64_t a2, const char **a3, const char **a4, void *a5)
{
  if (a2 <= 0xAF) {
    lsl::AllocatorLayout::init();
  }
  uint64_t v7 = (unint64_t *)((char *)this + 176);
  uint64_t v8 = a2 - 176;
  lsl::AllocatorLayout::configure(this, a3, a4, a5);
  double result = lsl::Allocator::Pool::Pool((unint64_t)this + 128, (uint64_t)this + 80, 0, (unint64_t)this, a2, v7, v8);
  *((void *)this + 1dyld4::halt((char *)__format, 0) = this;
  *((void *)this + 11) = result;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = result;
  *((unsigned char *)this + 12dyld4::halt((char *)__format, 0) = 0;
  return result;
}

lsl::Allocator::Pool *lsl::Allocator::Pool::Pool(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  *(void *)(a1 + 32) = a4;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = a5;
  if ((unint64_t)a6 < a4 || (unint64_t)a6 + a7 > a5 + a4) {
    lsl::Allocator::Pool::Pool();
  }
  *a6 = a1 | 1;
  a6[1] = ((unint64_t)a6 + (a7 & 0xFFFFFFFFFFFFFFF0)) | 2;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a6;
  uint64_t v8 = lsl::Allocator::Pool::aligned_alloc((lsl::Allocator::Pool *)a1, 16, 48);
  *uint64_t v8 = 0u;
  v8[1] = 0u;
  v8[2] = 0u;
  *(void *)(a1 + 8) = v8;
  return (lsl::Allocator::Pool *)a1;
}

lsl::MemoryManager *lsl::AllocatorLayout::configure(lsl::AllocatorLayout *this, const char **a2, const char **a3, void *a4)
{
  if (a2 && a3)
  {
    return lsl::MemoryManager::MemoryManager(this, a2, a3, a4);
  }
  else
  {
    uint64_t v5 = 0;
    return lsl::MemoryManager::MemoryManager(this, &v5, &v5, a4);
  }
}

lsl::MemoryManager *lsl::MemoryManager::MemoryManager(lsl::MemoryManager *this, const char **a2, const char **a3, void *a4)
{
  *((unsigned char *)this + 32) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 4dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((void *)this + 9) = 0;
  if (_simple_getenv(a3, "dyld_hw_tpro"))
  {
    if (vm_page_size == 0x4000)
    {
      uint64_t v7 = _simple_getenv(a2, "DYLD_SHARED_REGION");
      if (!v7 || _platform_strcmp(v7, "private")) {
        *((unsigned char *)this + 32) = 1;
      }
    }
  }
  *((void *)this + 5) = a4;
  return this;
}

const char *_simple_getenv(const char **a1, char *__s)
{
  size_t v4 = _platform_strlen(__s);
  if (!a1) {
    return 0;
  }
  size_t v5 = v4;
  double result = *a1;
  if (!*a1) {
    return result;
  }
  while (1)
  {
    if (_platform_strlen(result) >= v5)
    {
      uint64_t v7 = *a1;
      if (v5)
      {
        size_t v8 = v5;
        int v9 = *a1;
        uint64_t v10 = __s;
        while (*(unsigned __int8 *)v9 == *v10)
        {
          ++v10;
          ++v9;
          if (!--v8) {
            goto LABEL_8;
          }
        }
        goto LABEL_9;
      }
LABEL_8:
      if (v7[v5] == 61) {
        return &v7[v5 + 1];
      }
    }
LABEL_9:
    uint64_t v11 = a1[1];
    ++a1;
    double result = v11;
    if (!v11) {
      return result;
    }
  }
}

void lsl::Allocator::~Allocator(lsl::Allocator *this)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 0x40000000;
  v1[2] = ___ZN3lsl9AllocatorD2Ev_block_invoke;
  v1[3] = &__block_descriptor_tmp_21;
  v1[4] = this;
  lsl::Allocator::forEachVMAllocatedBuffer((uint64_t)this, (uint64_t)v1);
}

uint64_t lsl::Allocator::forEachVMAllocatedBuffer(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void **)(result + 16);
  if (v2)
  {
    while (1)
    {
      unint64_t v4 = v2[4];
      if ((unint64_t)v2 < v4) {
        break;
      }
      uint64_t v5 = v2[5];
      if ((unint64_t)(v2 + 6) > v5 + v4) {
        goto LABEL_5;
      }
LABEL_6:
      unint64_t v2 = (void *)v2[2];
      if (!v2) {
        return result;
      }
    }
    uint64_t v5 = v2[5];
LABEL_5:
    v6[0] = v2[4];
    v6[1] = v5;
    double result = (*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v6);
    goto LABEL_6;
  }
  return result;
}

unint64_t dyld4::handleFromLoader(unint64_t this, const dyld4::Loader *a2)
{
  if (this) {
    dyld4::handleFromLoader();
  }
  if (this ^ (unint64_t)&dword_1A8DFD000 | a2) {
    return this ^ (unint64_t)&dword_1A8DFD000 | a2;
  }
  else {
    return 0;
  }
}

BOOL dyld4::PrebuiltLoader::isInitialized(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a1 + 6);
  if (v2 >= 0) {
    unint64_t v3 = (void *)(a2 + 976);
  }
  else {
    unint64_t v3 = (void *)(a2 + 1000);
  }
  return *(unsigned char *)(*v3 + (v2 & 0x7FFF)) == 9;
}

uint64_t lsl::Vector<dyld4::Loader const*>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    double result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 8 * a2);
    if ((result & 1) == 0)
    {
      double result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 8 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0;
        uint64_t v7 = (void *)result;
        do
          *v7++ = *(void *)(*(void *)(v3 + 8) + 8 * v6++);
        while (v5 != v6);
      }
      size_t v8 = *(void **)(v3 + 8);
      if (v8)
      {
        double result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v8);
        unint64_t v5 = *(void *)(v3 + 16);
      }
      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }
    *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

const os_unfair_lock *lsl::Vector<dyld4::Loader const*>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._os_unfair_lock_opaque = a2;
      *(void *)&result[6]._os_unfair_lock_opaque = a2;
      __int16 v2 = *(void **)&result[2]._os_unfair_lock_opaque;
      uint64_t v3 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v3, v2, 8 * a2);
    }
    else
    {
      unint64_t v5 = result + 2;
      uint64_t v4 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v4) {
        double result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v4);
      }
      *(void *)&v5->_os_unfair_lock_opaque = 0;
      *(void *)&v5[2]._os_unfair_lock_opaque = 0;
      *(void *)&v5[4]._os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)result, a2);
  }
  return result;
}

uint64_t lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    double result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 16 * a2);
    if ((result & 1) == 0)
    {
      double result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 16 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0;
        for (unint64_t i = 0; i < v5; ++i)
        {
          *(_OWORD *)(result + v6) = *(_OWORD *)(*(void *)(v3 + 8) + v6);
          unint64_t v5 = *(void *)(v3 + 16);
          v6 += 16;
        }
      }
      size_t v8 = *(void **)(v3 + 8);
      if (v8)
      {
        double result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v8);
        unint64_t v5 = *(void *)(v3 + 16);
      }
      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }
    *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

const os_unfair_lock *lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._os_unfair_lock_opaque = a2;
      *(void *)&result[6]._os_unfair_lock_opaque = a2;
      __int16 v2 = *(void **)&result[2]._os_unfair_lock_opaque;
      uint64_t v3 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v3, v2, 16 * a2);
    }
    else
    {
      unint64_t v5 = result + 2;
      uint64_t v4 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v4) {
        double result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v4);
      }
      *(void *)&v5->_os_unfair_lock_opaque = 0;
      *(void *)&v5[2]._os_unfair_lock_opaque = 0;
      *(void *)&v5[4]._os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)result, a2);
  }
  return result;
}

vm_address_t *Diagnostics::clearError(vm_address_t **this)
{
  double result = *this;
  if (result) {
    double result = _simple_sfree(result);
  }
  *this = 0;
  return result;
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  kern_return_t v6;
  uint64_t reply_port;
  kern_return_t v8;
  mach_msg_header_t v11;
  uint64_t v12;
  mach_vm_address_t v13;
  mach_vm_size_t v14;

  uint64_t v6 = _kernelrpc_mach_vm_deallocate_trap(target, address, size);
  if (v6 == 268435459)
  {
    int v12 = 0x100000000;
    size_t v13 = address;
    unint64_t v14 = size;
    reply_port = mig_get_reply_port();
    *(void *)&v11.msgh_bits = 0x3000001513;
    *(void *)&v11.msgh_remote_port = __PAIR64__(reply_port, target);
    *(void *)&v11.msgh_voucher_port = 0x12C100000000;
    size_t v8 = mach_msg2_internal(&v11, 0x200000003uLL, (void *)0x3000001513, (void *)__PAIR64__(reply_port, target), (void *)0x12C100000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    uint64_t v6 = v8;
    if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
    {
      if (v8)
      {
        mig_dealloc_reply_port(v11.msgh_local_port);
        return v6;
      }
      if (v11.msgh_id == 71)
      {
        uint64_t v6 = -308;
      }
      else if (v11.msgh_id == 4901)
      {
        uint64_t v6 = -300;
        if ((v11.msgh_bits & 0x80000000) == 0 && *(void *)&v11.msgh_size == 36)
        {
          uint64_t v6 = v13;
          if (!v13) {
            return v6;
          }
        }
      }
      else
      {
        uint64_t v6 = -301;
      }
      mach_msg_destroy(&v11);
    }
  }
  return v6;
}

kern_return_t _kernelrpc_mach_vm_allocate_trap(mach_port_name_t target, mach_vm_offset_t *addr, mach_vm_size_t size, int flags)
{
  return mac_syscall(KERNELRPC_MACH_VM_ALLOCATE_TRAP, target, addr, size, flags);
}

kern_return_t _kernelrpc_mach_vm_purgable_control_trap(mach_port_name_t target, mach_vm_offset_t address, vm_purgable_t control, int *state)
{
  return mac_syscall(-11, *(void **)&target, (void *)address, *(void **)&control, state, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_vm_deallocate_trap(mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return mac_syscall(KERNELRPC_MACH_VM_DEALLOCATE_TRAP, target, address, size);
}

kern_return_t task_dyld_process_info_notify_get(mach_port_name_array_t names_addr, natural_t *names_count_addr)
{
  return mac_syscall(-13, names_addr, names_count_addr, v2, v3, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_vm_protect_trap(mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return mac_syscall(KERNELRPC_MACH_VM_PROTECT_TRAP, target, address, size, set_maximum, new_protection);
}

kern_return_t _kernelrpc_mach_vm_map_trap(mach_port_name_t target, mach_vm_offset_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_prot_t cur_protection)
{
  return mac_syscall(KERNELRPC_MACH_VM_MAP_TRAP, target, address, size, (mach_vm_offset_t *)mask, flags, cur_protection);
}

kern_return_t _kernelrpc_mach_port_allocate_trap(mach_port_name_t target, mach_port_right_t right, mach_port_name_t *name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_ALLOCATE_TRAP, target, right, name);
}

kern_return_t _kernelrpc_mach_port_deallocate_trap(mach_port_name_t target, mach_port_name_t name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_DEALLOCATE_TRAP, target, name);
}

kern_return_t _kernelrpc_mach_port_mod_refs_trap(mach_port_name_t target, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return mac_syscall(KERNELRPC_MACH_PORT_MOD_REFS_TRAP, target, name, right, delta);
}

kern_return_t _kernelrpc_mach_port_move_member_trap(mach_port_name_t target, mach_port_name_t member, mach_port_name_t after)
{
  return mac_syscall(KERNELRPC_MACH_PORT_MOVE_MEMBER_TRAP, target, member, after);
}

kern_return_t _kernelrpc_mach_port_insert_right_trap(mach_port_name_t target, mach_port_name_t name, mach_port_name_t poly, mach_msg_type_name_t polyPoly)
{
  return mac_syscall(KERNELRPC_MACH_PORT_INSERT_RIGHT_TRAP, target, name, poly, polyPoly);
}

kern_return_t _kernelrpc_mach_port_insert_member_trap(mach_port_name_t target, mach_port_name_t name, mach_port_name_t pset)
{
  return mac_syscall(KERNELRPC_MACH_PORT_INSERT_MEMBER_TRAP, target, name, pset);
}

kern_return_t _kernelrpc_mach_port_extract_member_trap(mach_port_name_t target, mach_port_name_t name, mach_port_name_t pset)
{
  return mac_syscall(KERNELRPC_MACH_PORT_EXTRACT_MEMBER_TRAP, target, name, pset);
}

kern_return_t _kernelrpc_mach_port_construct_trap(mach_port_name_t target, mach_port_options_t *options, uint64_t context, mach_port_name_t *name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_CONSTRUCT_TRAP, target, options, context, name);
}

kern_return_t _kernelrpc_mach_port_destruct_trap(mach_port_name_t target, mach_port_name_t name, mach_port_delta_t srdelta, uint64_t guard)
{
  return mac_syscall(KERNELRPC_MACH_PORT_DESTRUCT_TRAP, target, name, srdelta, guard);
}

mach_port_name_t mach_reply_port()
{
  return mac_syscall(MACH_REPLY_PORT_TRAP);
}

mach_port_name_t thread_self_trap()
{
  return mac_syscall(THREAD_SELF_TRAP);
}

mach_port_name_t task_self_trap(void)
{
  return mac_syscall(TASK_SELF_TRAP);
}

mach_port_name_t host_self_trap()
{
  return mac_syscall(HOST_SELF_TRAP);
}

mach_msg_return_t mach_msg_trap(mach_msg_header_t *a1, mach_msg_option_t a2, mach_msg_size_t a3, mach_msg_size_t a4, mach_port_name_t a5, mach_msg_timeout_t a6, mach_port_name_t a7)
{
  return mac_syscall(MACH_MSG_TRAP, a1, a2, a3, a4, a5, a6, a7);
}

mach_msg_return_t mach_msg_overwrite_trap(mach_msg_header_t *a1, mach_msg_option_t a2, mach_msg_size_t a3, mach_msg_size_t a4, mach_port_name_t a5, mach_msg_timeout_t a6, mach_port_name_t a7, mach_msg_header_t *a8)
{
  return mac_syscall(MACH_MSG_OVERWRITE_TRAP, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t semaphore_signal_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_SIGNAL_TRAP, a1);
}

kern_return_t semaphore_signal_all_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_SIGNAL_ALL_TRAP, a1);
}

kern_return_t semaphore_signal_thread_trap(mach_port_name_t a1, mach_port_name_t a2)
{
  return mac_syscall(SEMAPHORE_SIGNAL_THREAD_TRAP, a1, a2);
}

kern_return_t semaphore_wait_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_WAIT_TRAP, a1);
}

kern_return_t semaphore_wait_signal_trap(mach_port_name_t a1, mach_port_name_t a2)
{
  return mac_syscall(SEMAPHORE_WAIT_SIGNAL_TRAP, a1, a2);
}

kern_return_t semaphore_timedwait_trap(mach_port_name_t a1, unsigned int a2, clock_res_t a3)
{
  return mac_syscall(SEMAPHORE_TIMEDWAIT_TRAP, a1, a2, a3);
}

kern_return_t semaphore_timedwait_signal_trap(mach_port_name_t a1, mach_port_name_t a2, unsigned int a3, clock_res_t a4)
{
  return mac_syscall(SEMAPHORE_TIMEDWAIT_SIGNAL_TRAP, a1, a2, a3, a4);
}

kern_return_t _kernelrpc_mach_port_get_attributes_trap(mach_port_name_t target, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return mac_syscall(-40, *(void **)&target, *(void **)&name, *(void **)&flavor, port_info_out, port_info_outCnt, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_guard_trap(mach_port_name_t target, mach_port_name_t name, uint64_t guard, BOOLean_t strict)
{
  return mac_syscall(KERNELRPC_MACH_PORT_GUARD_TRAP, target, name, guard, strict);
}

kern_return_t _kernelrpc_mach_port_unguard_trap(mach_port_name_t target, mach_port_name_t name, uint64_t guard)
{
  return mac_syscall(KERNELRPC_MACH_PORT_UNGUARD_TRAP, target, name, guard);
}

kern_return_t mach_generate_activity_id(mach_port_name_t target, int count, uint64_t *activity_id)
{
  return mac_syscall(MAP_FD_TRAP, target, *(vm_offset_t *)&count, activity_id, v3, v4);
}

kern_return_t task_name_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *tn)
{
  return mac_syscall(TASK_NAME_FOR_PID_TRAP, target_tport, pid, tn);
}

kern_return_t task_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  return mac_syscall(TASK_FOR_PID_TRAP, target_tport, pid, t);
}

kern_return_t pid_for_task(mach_port_name_t t, int *x)
{
  return mac_syscall(PID_FOR_TASK_TRAP, t, x);
}

int64_t mach_msg2_trap(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-47, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t macx_swapon(uint64_t filename, int flags, int size, int priority)
{
  return mac_syscall(MACX_SWAPON_TRAP, filename, flags, size, priority);
}

kern_return_t macx_swapoff(uint64_t filename, int flags)
{
  return mac_syscall(MACX_SWAPOFF_TRAP, filename, flags);
}

int64_t thread_get_special_reply_port(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-50, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t macx_triggers(int hi_water, int low_water, int flags, mach_port_t alert_port)
{
  return mac_syscall(MACX_TRIGGERS_TRAP, hi_water, low_water, flags, alert_port);
}

kern_return_t macx_backing_store_suspend(BOOLean_t suspend)
{
  return mac_syscall(MACX_BACKING_STORE_SUSPEND_TRAP, suspend);
}

kern_return_t macx_backing_store_recovery(int pid)
{
  return mac_syscall(MACX_BACKING_STORE_RECOVERY_TRAP, pid);
}

BOOLean_t swtch_pri(int pri)
{
  return mac_syscall(SWTCH_PRI_TRAP, pri);
}

BOOLean_t swtch(void)
{
  return mac_syscall(SWTCH_TRAP);
}

kern_return_t syscall_thread_switch(mach_port_name_t a1, int a2, mach_msg_timeout_t a3)
{
  return mac_syscall(THREAD_SWITCH_TRAP, a1, a2, a3);
}

kern_return_t clock_sleep_trap(mach_port_name_t clock_name, sleep_type_t sleep_type, int sleep_sec, int sleep_nsec, mach_timespec_t *wakeup_time)
{
  return mac_syscall(CLOCK_SLEEP_TRAP, clock_name, sleep_type, sleep_sec, sleep_nsec, (mach_timespec_t)wakeup_time);
}

kern_return_t host_create_mach_voucher_trap(mach_port_name_t host, mach_voucher_attr_raw_recipe_array_t recipes, int recipes_size, mach_port_name_t *voucher)
{
  return mac_syscall(-70, *(void **)&host, recipes, *(void **)&recipes_size, voucher, v4, v5, v6, v7);
}

kern_return_t mach_voucher_extract_attr_recipe_trap(mach_port_name_t voucher_name, mach_voucher_attr_key_t key, mach_voucher_attr_raw_recipe_t recipe, mach_msg_type_number_t *recipe_size)
{
  return mac_syscall(-72, *(void **)&voucher_name, *(void **)&key, recipe, recipe_size, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_type_trap(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return mac_syscall(-76, *(void **)&task, *(void **)&name, ptype, v3, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_request_notification_trap(ipc_space_t task, mach_port_name_t name, mach_msg_id_t msgid, mach_port_mscount_t sync, mach_port_name_t notify, mach_msg_type_name_t notifyPoly, mach_port_name_t *previous)
{
  return mac_syscall(-77, *(void **)&task, *(void **)&name, *(void **)&msgid, *(void **)&sync, *(void **)&notify, *(void **)&notifyPoly, previous, v7);
}

int64_t _exclaves_ctl_trap(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-88, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t mach_timebase_info_trap(mach_timebase_info *a1)
{
  return mac_syscall(MACH_TIMEBASE_INFO_TRAP, a1);
}

kern_return_t mach_wait_until(uint64_t deadline)
{
  return mac_syscall(MACH_WAIT_UNTIL_TRAP, deadline);
}

mach_port_name_t mk_timer_create()
{
  return mac_syscall(MK_TIMER_CREATE_TRAP);
}

kern_return_t mk_timer_destroy(mach_port_name_t a1)
{
  return mac_syscall(MK_TIMER_DESTROY_TRAP, a1);
}

kern_return_t mk_timer_arm(mach_port_name_t a1, uint64_t a2)
{
  return mac_syscall(MK_TIMER_ARM_TRAP, a1, a2);
}

kern_return_t mk_timer_cancel(mach_port_name_t a1, uint64_t a2)
{
  return mac_syscall(MK_TIMER_CANCEL_TRAP, a1, a2);
}

int64_t mk_timer_arm_leeway(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-95, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t debug_control_port_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  return mac_syscall(-96, *(void **)&target_tport, *(void **)&pid, t, v3, v4, v5, v6, v7);
}

vm_address_t *_simple_sfree(vm_address_t *address)
{
  if (address)
  {
    vm_address_t v1 = (vm_address_t)address;
    if (((vm_page_size - 1) & *address) != 0)
    {
      uint64_t v2 = address[2] - (void)address + 1;
    }
    else
    {
      vm_deallocate(mach_task_self_, *address, address[2] - *address + 1);
      uint64_t v2 = vm_page_size;
    }
    vm_map_t v3 = mach_task_self_;
    return (vm_address_t *)vm_deallocate(v3, v1, v2);
  }
  return address;
}

uint64_t dyld4::APIs::findImageContaining(dyld4::APIs *this, void *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  uint64_t v2 = (uint64_t *)*((void *)this + 17);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs19findImageContainingEPv_block_invoke;
  void v5[3] = &unk_1EFF65418;
  v5[5] = this;
  void v5[6] = a2;
  v5[4] = &v6;
  dyld4::RuntimeLocks::withLoadersReadLock(v2, (uint64_t)v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t dyld3::MachOLoaded::findClosestSymbol(dyld3::MachOLoaded *this, uint64_t a2, const char **a3, unint64_t *a4)
{
  Diagnostics::Diagnostics((Diagnostics *)&v46);
  dyld3::MachOLoaded::getLinkEditPointers(this, (vm_address_t *)&v46, (uint64_t)v40);
  uint64_t v8 = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v46))
  {
    uint64_t v8 = 0;
    if (v41)
    {
      if (v42)
      {
        unint64_t v9 = a2 - v43;
        uint64_t v36 = 0;
        uint64_t v37 = &v36;
        uint64_t v38 = 0x2000000000;
        int v39 = 0;
        v35[0] = _NSConcreteStackBlock;
        v35[1] = 0x40000000;
        v35[2] = ___ZNK5dyld311MachOLoaded17findClosestSymbolEyPPKcPy_block_invoke;
        v35[3] = &unk_1EFF66948;
        v35[4] = &v36;
        v35[5] = v9;
        dyld3::MachOFile::forEachSection(this, (uint64_t)v35);
        int v10 = v41[4];
        unsigned int v11 = v41[5];
        int v12 = v45;
        uint64_t v13 = v43 + v44;
        uint64_t v14 = v43 + v44 + (v41[2] - v45);
        BOOL v15 = dyld3::MachOFile::is64(this);
        uint64_t v16 = v42[4];
        uint64_t v17 = v42[5];
        uint64_t v18 = 0;
        if (v15)
        {
          if (v17)
          {
            uint64_t v19 = (unsigned int *)(v14 + 16 * v16);
            uint64_t v20 = &v19[4 * v17];
            do
            {
              if ((~*((unsigned __int8 *)v19 + 4) & 0xE) == 0)
              {
                unint64_t v21 = *((void *)v19 + 1);
                if (v18)
                {
                  if (v21 <= v9 && *((void *)v18 + 1) < v21)
                  {
LABEL_13:
                    if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v19 + 5)) {
                      uint64_t v18 = v19;
                    }
                  }
                }
                else if (v21 <= v9)
                {
                  goto LABEL_13;
                }
              }
              v19 += 4;
            }
            while (v19 < v20);
          }
          uint64_t v22 = v42[3];
          if (v22)
          {
            uint64_t v23 = (unsigned int *)(v14 + 16 * v42[2]);
            uint64_t v24 = &v23[4 * v22];
            do
            {
              if ((v23[1] & 0xEE) == 0xE)
              {
                unint64_t v25 = *((void *)v23 + 1);
                if (v18)
                {
                  if (v25 <= v9 && *((void *)v18 + 1) < v25)
                  {
LABEL_24:
                    if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v23 + 5)) {
                      uint64_t v18 = v23;
                    }
                  }
                }
                else if (v25 <= v9)
                {
                  goto LABEL_24;
                }
              }
              v23 += 4;
            }
            while (v23 < v24);
          }
          if (v18)
          {
            uint64_t v26 = *((void *)v18 + 1);
LABEL_53:
            *a4 = v43 + v26;
            if (*v18 < v11) {
              *a3 = (const char *)(v13 + (v10 - v12) + *v18);
            }
            uint64_t v8 = 1;
            goto LABEL_57;
          }
          goto LABEL_56;
        }
        if (v17)
        {
          uint64_t v27 = (unsigned int *)(v14 + 12 * v16);
          size_t v28 = &v27[3 * v17];
          do
          {
            if ((~*((unsigned __int8 *)v27 + 4) & 0xE) == 0)
            {
              unint64_t v29 = v27[2];
              if (v18)
              {
                if (v9 >= v29 && v18[2] < v29)
                {
LABEL_37:
                  if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v27 + 5)) {
                    uint64_t v18 = v27;
                  }
                }
              }
              else if (v9 >= v29)
              {
                goto LABEL_37;
              }
            }
            v27 += 3;
          }
          while (v27 < v28);
        }
        unsigned int v30 = v42[3];
        if (!v30)
        {
LABEL_51:
          if (v18)
          {
            uint64_t v26 = v18[2];
            goto LABEL_53;
          }
LABEL_56:
          uint64_t v8 = 0;
LABEL_57:
          _Block_object_dispose(&v36, 8);
          goto LABEL_58;
        }
        uint64_t v31 = (unsigned int *)(v14 + 12 * v42[2]);
        uint64_t v32 = &v31[3 * v30];
        while (1)
        {
          if ((v31[1] & 0xEE) == 0xE)
          {
            unint64_t v33 = v31[2];
            if (v18)
            {
              if (v9 >= v33 && v18[2] < v33)
              {
LABEL_48:
                if (*((_DWORD *)v37 + 6) == *((unsigned __int8 *)v31 + 5)) {
                  uint64_t v18 = v31;
                }
              }
            }
            else if (v9 >= v33)
            {
              goto LABEL_48;
            }
          }
          v31 += 3;
          if (v31 >= v32) {
            goto LABEL_51;
          }
        }
      }
    }
  }
LABEL_58:
  mach_o::Error::~Error(&v46);
  return v8;
}

BOOL dyld3::MachOFile::is64(dyld3::MachOFile *this)
{
  return *(_DWORD *)this == -17958193;
}

void dyld3::MachOLoaded::getLinkEditPointers(_DWORD *a1, vm_address_t *a2, uint64_t a3)
{
  dyld3::MachOLoaded::getLinkEditLoadCommands(a1, a2, a3);
  if (Diagnostics::noError((Diagnostics *)a2))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    void v6[2] = ___ZNK5dyld311MachOLoaded13getLayoutInfoERNS0_10LayoutInfoE_block_invoke;
    v6[3] = &__block_descriptor_tmp_34_1;
    v6[4] = a1;
    void v6[5] = a3 + 72;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v6);
  }
}

void dyld3::MachOLoaded::getLinkEditLoadCommands(_DWORD *a1, vm_address_t *a2, uint64_t a3)
{
  *(void *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2000000000;
  char v11 = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  char v9 = 0;
  v6[0] = 0;
  v6[1] = v6;
  void v6[2] = 0x2000000000;
  char v7 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld311MachOLoaded23getLinkEditLoadCommandsER11DiagnosticsRNS0_12LinkEditInfoE_block_invoke;
  void v5[3] = &unk_1EFF66820;
  void v5[8] = a2;
  v5[9] = a3;
  v5[4] = v10;
  v5[5] = v8;
  void v5[6] = v6;
  void v5[7] = a1;
  dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v5);
  if (Diagnostics::noError((Diagnostics *)a2) && *(void *)(a3 + 32) && !*(void *)(a3 + 24)) {
    Diagnostics::error(a2, "LC_DYSYMTAB but no LC_SYMTAB load command");
  }
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v10, 8);
}

void dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  unint64_t v3 = *(void *)(*(void *)a1 + 48);
  unint64_t v4 = *(void *)(*(void *)a1 + 240);
  unint64_t v5 = *(void *)(*(void *)a1 + 304);
  Diagnostics::Diagnostics((Diagnostics *)&v111);
  uint64_t v6 = *(void *)(v2 + 24);
  v110[0] = 0;
  v110[1] = v6;
  char v7 = (void **)v110;
  long long v108 = v110;
  uint64_t v8 = *(_DWORD **)(a1 + 16);
  uint64_t v109 = **(void **)(a1 + 8);
  LOBYTE(v9) = v109;
  uint64_t v107 = 0;
  uint64_t v100 = 0;
  LODWORD(v8) = *v8;
  *(_DWORD *)((char *)&v100 + 3) = (v8 & 4) != 0;
  WORD2(v10dyld4::halt((char *)__format, 0) = (v8 & 0x80) != 0;
  BYTE5(v10dyld4::halt((char *)__format, 0) = (v8 & 0x10) != 0;
  HIBYTE(v10dyld4::halt((char *)__format, 0) = 1;
  char v101 = 1;
  BOOL v102 = *(_DWORD *)(*(void *)(v2 + 8) + 68) == 1;
  BOOL v103 = (int)v8 < 0;
  if (v109)
  {
    int v9 = HIBYTE(*(unsigned __int16 *)(v109 + 4)) & 1;
    char v7 = &v108;
  }
  char v104 = v9;
  uint64_t v105 = v7;
  uint64_t v106 = 0;
  **(void **)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = dyld4::Loader::getLoader(&v111, (DyldSharedCache ***)v2, **(const char ***)(a1 + 32), (uint64_t)&v100);
  int v10 = **(dyld4::Loader ***)(a1 + 24);
  if (!v10)
  {
    uint64_t v85 = **(const char ***)(a1 + 32);
    int v86 = **(_DWORD **)(a1 + 16);
    uint64_t v87 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v111);
    dyld4::APIs::setErrorString((vm_address_t *)v2, "dlopen(%s, 0x%04X): %s", v85, v86, v87);
    goto LABEL_68;
  }
  if ((**(unsigned char **)(a1 + 16) & 4) == 0 && dyld4::Loader::hiddenFromFlat(v10, 0)) {
    dyld4::Loader::hiddenFromFlat(**(dyld4::Loader ***)(a1 + 24), 1);
  }
  char v11 = *(_DWORD **)(a1 + 16);
  if ((*v11 & 0x10) != 0)
  {
    dyld4::RuntimeState::incDlRefCount(v2, **(const dyld4::Loader ***)(a1 + 24));
    **(void **)(a1 + 4dyld4::halt((char *)__format, 0) = dyld4::handleFromLoader(**(void **)(a1 + 24), (const dyld4::Loader *)**(unsigned __int8 **)(a1 + 48));
    goto LABEL_68;
  }
  int v12 = *(uint64_t **)(a1 + 24);
  if ((*v11 & 0x80) != 0 && (*(_WORD *)(*v12 + 4) & 0x63) == 0)
  {
    *(void *)(*v12 + 40) |= 0x200000uLL;
    char v11 = *(_DWORD **)(a1 + 16);
    int v12 = *(uint64_t **)(a1 + 24);
  }
  uint64_t v98 = v105;
  uint64_t v99 = 0;
  uint64_t v99 = *v12;
  *(void *)&long long v94 = 256;
  DWORD2(v94) = 0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  uint64_t v95 = 0;
  BYTE4(v94) = (*v11 & 0x80) != 0;
  BYTE7(v94) = 1;
  BYTE11(v94) = *(unsigned char *)(*v12 + 5) & 1;
  uint64_t v95 = &v98;
  dyld4::Loader::loadDependents(*v12, (vm_address_t *)&v111, (dyld4::RuntimeState *)v2, &v94);
  uint64_t v13 = *(void *)(v2 + 48);
  uint64_t v15 = lsl::AllocatorLayout::minSize(v14);
  __chkstk_darwin(v15, v15 - v3 + 8 * v13 + 64, v16, v17, v18, v19, v20, v21, v88);
  uint64_t v23 = (lsl::Allocator *)&v89[-v22 - 8];
  bzero(&v89[-v22 - 8], v24);
  uint64_t v25 = *(void *)(v2 + 48);
  uint64_t v27 = lsl::AllocatorLayout::minSize(v26);
  size_t v28 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v23, (char *)(v27 - v3 + 8 * v25 + 64));
  uint64_t v90 = v28;
  uint64_t v91 = 0;
  unint64_t v92 = 0;
  uint64_t v93 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v90, *(void *)(v2 + 48) - v3);
  if (v3 != *(void *)(v2 + 48))
  {
    uint64_t v29 = v92;
    unint64_t v30 = v3;
    do
    {
      uint64_t v31 = *(dyld4::Loader **)(*(void *)(v2 + 40) + 8 * v30);
      lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v90, v29 + 1);
      uint64_t v32 = v92;
      uint64_t v29 = ++v92;
      v91[v32] = v31;
      ++v30;
    }
    while (v30 != *(void *)(v2 + 48));
  }
  dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)v89, v2);
  if (Diagnostics::noError((Diagnostics *)&v111) && v92)
  {
    if (*(unsigned char *)(*(void *)(v2 + 8) + 161))
    {
      long long v112 = v91;
      *(void *)&long long v113 = v92;
      dyld4::Loader::addWeakDefsToMap((dyld4::RuntimeState *)v2, (uint64_t)&v112);
    }
    LODWORD(v112) = 520552460;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    uint64_t v119 = 0;
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v112, v33, v34, v35, v36, v37, v38, v39);
    if (v92)
    {
      size_t v42 = (uint64_t *)v91;
      uint64_t v43 = 8 * v92;
      do
      {
        uint64_t v44 = (dyld4::Loader *)*v42;
        dyld4::Loader::applyFixups(*v42, (uint64_t)&v111, v2, (uint64_t)v89, (**(_DWORD **)(a1 + 16) & 2) == 0, *(void *)(a1 + 56), v40, v41);
        if (Diagnostics::hasError((Diagnostics *)&v111)) {
          break;
        }
        dyld4::Loader::applyCachePatches(v44, (dyld4::RuntimeState *)v2, (dyld4::DyldCacheDataConstLazyScopedWriter *)v89);
        ++v42;
        v43 -= 8;
      }
      while (v43);
    }
    dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v112);
    BOOL v45 = Diagnostics::noError((Diagnostics *)&v111);
    if (v45)
    {
      __chkstk_darwin(v45, v46, v47, v48, v49, v50, v51, v52, v88);
      uint64_t v60 = (dyld4::Loader **)&v89[-((v59 + 23) & 0xFFFFFFFFFFFFFFF0) - 8];
      unint64_t v61 = v92;
      long long v112 = v60;
      long long v113 = v92;
      if (v92)
      {
        unint64_t v62 = 0;
        uint64_t v63 = v91;
        uint64_t v64 = 8 * v92;
        do
        {
          uint64_t v65 = *v63;
          if ((*((_WORD *)*v63 + 2) & 0x22) == 0x20)
          {
            if (v62 >= v61) {
              ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
            }
            *((void *)&v113 + 1) = v62 + 1;
            v112[v62++] = v65;
          }
          ++v63;
          v64 -= 8;
        }
        while (v64);
        if (v62)
        {
          dyld4::RuntimeState::addPermanentRanges(v2, (uint64_t)&v112, v53, v54, v55, v56, v57, v58);
          unint64_t v61 = v92;
        }
      }
      int v120 = v91;
      uint64_t v121 = v61;
      dyld4::RuntimeState::notifyDtrace(v2, (uint64_t)&v120);
      int v120 = v91;
      uint64_t v121 = v92;
      dyld4::RuntimeState::rebindMissingFlatLazySymbols(v2, &v120);
    }
  }
  if (Diagnostics::noError((Diagnostics *)&v111)) {
    dyld4::RuntimeState::incDlRefCount(v2, **(const dyld4::Loader ***)(a1 + 24));
  }
  if (Diagnostics::hasError((Diagnostics *)&v111))
  {
    uint64_t v66 = **(const char ***)(a1 + 32);
    int v67 = **(_DWORD **)(a1 + 16);
    uint64_t v68 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v111);
    dyld4::APIs::setErrorString((vm_address_t *)v2, "dlopen(%s, 0x%04X): %s", v66, v67, v68);
    long long v112 = v91;
    *(void *)&long long v113 = v92;
    dyld4::RuntimeState::removeMissingFlatLazySymbols(v2, (uint64_t)&v112);
    unsigned __int8 v70 = v91;
    uint64_t v69 = v92;
    if (*(void *)(v2 + 336))
    {
      if (!v92)
      {
LABEL_43:
        if (*(void *)(v2 + 48) > v3) {
          *(void *)(v2 + 48) = v3;
        }
        **(void **)(a1 + 4dyld4::halt((char *)__format, 0) = 0;
        **(void **)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
        *(void *)(v2 + 272) = 0;
        if (*(void *)(v2 + 240) > v4) {
          *(void *)(v2 + 24dyld4::halt((char *)__format, 0) = v4;
        }
        if (*(void *)(v2 + 304) > v5) {
          *(void *)(v2 + 304) = v5;
        }
        goto LABEL_49;
      }
      uint64_t v71 = 8 * v92;
      do
      {
        uint64_t v72 = *v70++;
        dyld4::RuntimeState::removeDynamicDependencies((void *)v2, v72);
        v71 -= 8;
      }
      while (v71);
      unsigned __int8 v70 = v91;
      uint64_t v69 = v92;
    }
    if (v69)
    {
      uint64_t v73 = 8 * v69;
      do
      {
        uint64_t v74 = *v70++;
        dyld4::Loader::unmap(v74, (dyld4::RuntimeState *)v2, 1);
        v73 -= 8;
      }
      while (v73);
    }
    goto LABEL_43;
  }
LABEL_49:
  if (**(void **)(a1 + 24) && (**(unsigned char **)(a1 + 16) & 0x10) == 0 && Diagnostics::noError((Diagnostics *)&v111))
  {
    int v120 = **(dyld4::Loader ****)(a1 + 24);
    dyld4::RuntimeState::partitionDelayLoads((dyld4::RuntimeState *)v2, v91, v92, (dyld4::Loader **)&v120, 1, *(void *)(a1 + 64));
    if (*(void *)(*(void *)(v2 + 8) + 232))
    {
      strcpy((char *)&v112, "dlopen");
      uint64_t v75 = **(dyld4::Loader ***)(a1 + 8);
      if (v75)
      {
        uint64_t v76 = dyld4::Loader::leafName(v75, (const dyld4::RuntimeState *)v2);
        strlcpy((char *)&v112, v76, 0x100uLL);
        strlcat((char *)&v112, ": dlopen(", 0x100uLL);
        uint64_t v77 = dyld4::Loader::leafName(**(dyld4::Loader ***)(a1 + 24), (const dyld4::RuntimeState *)v2);
        strlcat((char *)&v112, v77, 0x100uLL);
        strlcat((char *)&v112, ")", 0x100uLL);
      }
      dyld4::Loader::logChainToLinksWith(**(dyld4::Loader ***)(a1 + 24), (dyld4::RuntimeState *)v2, (const char *)&v112);
    }
    uint64_t v78 = *(void *)(a1 + 64);
    uint64_t v79 = *(void *)(v78 + 16);
    if (v79)
    {
      long long v112 = *(dyld4::Loader ***)(v78 + 8);
      *(void *)&long long v113 = v79;
      dyld4::RuntimeState::notifyDebuggerLoad((lsl::AllocatorLayout *)v2, (uint64_t)&v112);
      uint64_t v80 = *(void *)(a1 + 64);
      uint64_t v81 = *(void *)(v80 + 16);
      if (v81)
      {
        int v82 = *(dyld4::Loader ***)(v80 + 8);
        uint64_t v83 = 8 * v81;
        do
        {
          if ((*((_WORD *)*v82 + 2) & 0x1000) != 0)
          {
            uint64_t v84 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*v82, (dyld4::RuntimeState *)v2);
            dyld4::RuntimeState::setUpTLVs((dyld4::RuntimeState *)v2, v84);
          }
          ++v82;
          v83 -= 8;
        }
        while (v83);
      }
    }
    dyld4::RuntimeState::doSingletonPatching((dyld4::RuntimeState *)v2, (dyld4::DyldCacheDataConstLazyScopedWriter *)v89);
    dyld4::RuntimeState::notifyObjCPatching((dyld4::RuntimeState *)v2);
  }
  dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)v89);
  if (v91) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v90, 0);
  }
  lsl::Allocator::~Allocator(v28);
LABEL_68:
  mach_o::Error::~Error(&v111);
}

BOOL Diagnostics::noError(Diagnostics *this)
{
  return *(void *)this == 0;
}

uint64_t dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter(uint64_t result, uint64_t a2)
{
  *(void *)double result = a2;
  *(unsigned char *)(result + 8) = 0;
  return result;
}

void dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter(dyld4::DyldCacheDataConstLazyScopedWriter *this)
{
  if (*((unsigned char *)this + 8)) {
    dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(*(void *)(*(void *)this + 8) + 240), *(void *)(*(void *)this + 8) + 200, *(void *)(*(void *)this + 8), 0);
  }
}

uint64_t dyld4::RuntimeLocks::takeDlopenLockBeforeFork(dyld4::RuntimeLocks *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(uint64_t, char *, void))(*(void *)result + 104))(result, (char *)this + 32, 0);
  }
  return result;
}

uint64_t dyld4::RuntimeLocks::releaseDlopenLockInForkParent(dyld4::RuntimeLocks *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(uint64_t, char *))(*(void *)result + 112))(result, (char *)this + 32);
  }
  return result;
}

uint64_t ___ZN3lsl9AllocatorD2Ev_block_invoke(uint64_t a1, vm_address_t *a2)
{
  return vm_deallocate(mach_task_self_, *a2, a2[1]);
}

const os_unfair_lock *lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._os_unfair_lock_opaque = a2;
      *(void *)&result[6]._os_unfair_lock_opaque = a2;
      uint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
      unint64_t v3 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v3, v2, 40 * a2);
    }
    else
    {
      unint64_t v5 = result + 2;
      unint64_t v4 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v4) {
        uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v4);
      }
      *(void *)&v5->_os_unfair_lock_opaque = 0;
      *(void *)&v5[2]._os_unfair_lock_opaque = 0;
      *(void *)&v5[4]._os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve((uint64_t)result, a2);
  }
  return result;
}

const os_unfair_lock *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(uint64_t a1, lsl::Lock **a2)
{
  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    unint64_t v4 = (uint64_t *)(a1 + 120);
    uint64_t v5 = 8 * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      uint64_t v6 = *v4++;
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }
  unint64_t v7 = 0;
  uint64_t v8 = (const os_unfair_lock **)a1;
  do
  {
    int v9 = lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(v8);
    ++v7;
    if (*(char *)(a1 + 248) >= 0) {
      unint64_t v10 = 15;
    }
    else {
      unint64_t v10 = 31;
    }
    uint64_t v8 = v9 + 1;
  }
  while (v7 < v10);

  return lsl::Allocator::free(a2, (void *)a1);
}

const os_unfair_lock **lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(const os_unfair_lock **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v2[28]);
    unint64_t v4 = *(os_unfair_lock **)&v2[22]._os_unfair_lock_opaque;
    if (v4) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, v3);
    }
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v2[2]);
    lsl::Allocator::freeObject(*a1, v5);
  }
  return a1;
}

const os_unfair_lock *lsl::Allocator::free(lsl::Lock **this, void *a2)
{
  unint64_t v4 = *this;
  lsl::Lock::lock(*this);
  if (a2)
  {
    this[3] = (lsl::Lock *)((char *)this[3] + (void)a2 - (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL));
    lsl::Allocator::AllocationMetadata::deallocate((lsl::Allocator::AllocationMetadata *)(a2 - 2));
  }

  return lsl::Lock::unlock(v4);
}

void *lsl::Allocator::AllocationMetadata::coalesce(lsl::Allocator::AllocationMetadata *this, lsl::Allocator::Pool *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if ((v3 & 2) == 0 && (v3 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    uint64_t v4 = *(void *)((v3 & 0xFFFFFFFFFFFFFFFCLL) + 8);
    if ((v4 & 1) == 0)
    {
      *((void *)this + 1) = v4;
      if ((v4 & 2) == 0) {
        *(void *)(v4 & 0xFFFFFFFFFFFFFFFCLL) = this;
      }
      uint64_t v3 = v4;
    }
  }
  uint64_t v5 = *(lsl::Allocator::AllocationMetadata **)this;
  if (*(void *)this) {
    BOOL v6 = (*(void *)this & 1) == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6 || (*((unsigned char *)v5 + 8) & 1) != 0)
  {
    uint64_t v5 = this;
  }
  else
  {
    *((void *)v5 + 1) = v3;
    if ((v3 & 2) == 0)
    {
      uint64_t v7 = *((void *)this + 1);
      if ((v7 & 2) != 0) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = (void *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
      }
      *uint64_t v8 = v5;
    }
  }
  uint64_t result = lsl::Allocator::AllocationMetadata::setPoolHint(v5, a2);
  if ((*((unsigned char *)v5 + 8) & 2) != 0) {
    *((void *)a2 + 3) = v5;
  }
  return result;
}

void *lsl::Allocator::AllocationMetadata::setPoolHint(void *this, lsl::Allocator::Pool *a2)
{
  uint64_t v2 = this[1];
  if ((v2 & 1) == 0)
  {
    uint64_t v3 = this;
    if ((((v2 & 0xFFFFFFFFFFFFFFFCLL) - (void)this) & 0xFFFFFFFFFFFFFFF8) != 0x10)
    {
      if (!a2)
      {
        if (*this) {
          uint64_t v4 = 0;
        }
        else {
          uint64_t v4 = (lsl::Allocator::AllocationMetadata *)*this;
        }
        this = (void *)lsl::Allocator::AllocationMetadata::pool(v4, 1);
        a2 = (lsl::Allocator::Pool *)this;
        if (!this) {
          lsl::Allocator::AllocationMetadata::setPoolHint();
        }
      }
      v3[2] = a2;
    }
  }
  return this;
}

void *lsl::Allocator::AllocationMetadata::deallocate(lsl::Allocator::AllocationMetadata *this)
{
  uint64_t v1 = *((void *)this + 1);
  if ((v1 & 1) == 0) {
    lsl::Allocator::AllocationMetadata::deallocate();
  }
  uint64_t v3 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(this, 1);
  *((void *)this + 1) = v1 & 0xFFFFFFFFFFFFFFFCLL;

  return lsl::Allocator::AllocationMetadata::coalesce(this, v3);
}

uint64_t lsl::Allocator::realloc(lsl::Lock **this, void *a2, unint64_t a3)
{
  BOOL v6 = *this;
  lsl::Lock::lock(*this);
  if (!a2) {
    goto LABEL_6;
  }
  uint64_t v7 = (lsl::Allocator::AllocationMetadata *)(a2 - 2);
  uint64_t v8 = 16;
  if (a3 > 0x10) {
    uint64_t v8 = a3;
  }
  unint64_t v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v10 = (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL) - (void)v7;
  if (v10 - 16 >= v9)
  {
    if (v10 - 16 > v9) {
      lsl::Allocator::AllocationMetadata::returnToNext(v7, v9);
    }
    goto LABEL_9;
  }
  if (lsl::Allocator::AllocationMetadata::consumeFromNext(v7, v9))
  {
LABEL_9:
    this[3] = (lsl::Lock *)((char *)this[3] + v9 - v10 + 16);
    uint64_t v11 = 1;
    goto LABEL_10;
  }
LABEL_6:
  uint64_t v11 = 0;
LABEL_10:
  lsl::Lock::unlock(v6);
  return v11;
}

void *lsl::Allocator::aligned_alloc(lsl::Lock **this, unint64_t a2, unint64_t a3)
{
  BOOL v6 = *this;
  lsl::Lock::lock(*this);
  uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] != 1) {
    lsl::Allocator::aligned_alloc();
  }
  uint64_t v8 = 16;
  if (a2 <= 0x10) {
    uint64_t v9 = 16;
  }
  else {
    uint64_t v9 = a2;
  }
  if (a3 > 0x10) {
    uint64_t v8 = a3;
  }
  uint64_t v10 = (v9 + v8 - 1) & -v9;
  uint64_t v11 = *this;
  *((void *)v11 + 6) = a2;
  *((void *)v11 + 7) = a3;
  *((void *)v11 + 8) = v9;
  *((void *)v11 + 9) = v10;
  int v12 = this[2];
  if (*((unsigned char *)this + 40)) {
    uint64_t v13 = lsl::Allocator::Pool::aligned_alloc_best_fit(v12, v9, v10);
  }
  else {
    uint64_t v13 = lsl::Allocator::Pool::aligned_alloc(v12, v9, v10);
  }
  uint64_t v14 = v13;
  if (!v13)
  {
    uint64_t v15 = (uint64_t)this[2];
    if (((v9 + v10 + 16463) & 0xFFFFFFFFFFFFC000) <= 0x40000) {
      unint64_t v16 = 0x40000;
    }
    else {
      unint64_t v16 = (v9 + v10 + 16463) & 0xFFFFFFFFFFFFC000;
    }
    unint64_t v17 = *(void *)(v15 + 8);
    bytes = (unint64_t *)lsl::MemoryManager::vm_allocate_bytes(*this, v16);
    lsl::Allocator::Pool::Pool(v17, (uint64_t)this, v15, (unint64_t)bytes, v19, bytes, v19);
    *(void *)(v15 + 8) = v17;
    uint64_t v20 = (lsl::Allocator::Pool *)*((void *)this[2] + 1);
    this[2] = v20;
    uint64_t v14 = lsl::Allocator::Pool::aligned_alloc(v20, v9, v10);
    if (!v14) {
      lsl::Allocator::aligned_alloc();
    }
  }
  this[3] = (lsl::Lock *)((char *)this[3] + v10);
  lsl::Lock::unlock(v6);
  return v14;
}

const os_unfair_lock *lsl::Lock::lock(lsl::Lock *this)
{
  uint64_t result = (const os_unfair_lock *)*((void *)this + 1);
  if (result)
  {
    os_unfair_lock_assert_not_owner(result);
    if (!*(void *)this) {
      lsl::Lock::lock();
    }
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(*(void *)this + 152) + 184);
    return (const os_unfair_lock *)v3();
  }
  return result;
}

const os_unfair_lock *lsl::Lock::unlock(lsl::Lock *this)
{
  uint64_t result = (const os_unfair_lock *)*((void *)this + 1);
  if (result)
  {
    os_unfair_lock_assert_owner(result);
    if (!*(void *)this) {
      lsl::Lock::unlock();
    }
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(*(void *)this + 152) + 192);
    return (const os_unfair_lock *)v3();
  }
  return result;
}

void *lsl::Allocator::Pool::aligned_alloc(lsl::Allocator::Pool *this, uint64_t a2, uint64_t a3)
{
  BOOL v6 = (lsl::Allocator::AllocationMetadata *)*((void *)this + 3);
  if ((lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(v6, 1) != this) {
    lsl::Allocator::Pool::aligned_alloc();
  }
  unint64_t v7 = (*((void *)v6 + 1) & 0xFFFFFFFFFFFFFFFCLL) - (void)v6 - 16;
  uint64_t v8 = 0;
  if (v7 >= a3 + 16)
  {
    uint64_t v9 = ((unint64_t)v6 + a2 + 15) & -a2;
    if (v9 - ((uint64_t)v6 + 16) <= v7 - (a3 + 16))
    {
      if ((lsl::Allocator::AllocationMetadata *)((char *)v6 + 16) != (lsl::Allocator::AllocationMetadata *)v9)
      {
        lsl::Allocator::AllocationMetadata::reserve(v6, (unsigned __int16)(v9 - (_WORD)v6 - 32), 0);
        BOOL v6 = (lsl::Allocator::AllocationMetadata *)*((void *)this + 3);
      }
      uint64_t v8 = (void *)((char *)v6 + 16);
      lsl::Allocator::AllocationMetadata::reserve(v6, a3, 1u);
      if ((lsl::Allocator::AllocationMetadata *)((char *)v6 + 16) == this) {
        lsl::Allocator::Pool::aligned_alloc();
      }
    }
  }
  return v8;
}

unint64_t lsl::Allocator::AllocationMetadata::AllocationMetadata(unint64_t this, lsl::Allocator::AllocationMetadata *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  unint64_t v10 = lsl::Allocator::AllocationMetadata::pool(a2, 1);
  if (!v10) {
    lsl::Allocator::AllocationMetadata::AllocationMetadata();
  }
  *(void *)this = a2;
  if ((a4 & 2) != 0)
  {
    *(void *)(v10 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = this;
  }
  else
  {
    uint64_t v11 = *((void *)a2 + 1);
    if ((v11 & 2) != 0) {
      int v12 = 0;
    }
    else {
      int v12 = (void *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
    }
    *int v12 = this;
  }
  *((void *)a2 + 1) = this | a5;
  unint64_t v13 = (this + 16 + a3) | a4;
  *(void *)(this + 8) = v13;
  if ((v13 & 1) == 0 && (((v13 & 0xFFFFFFFFFFFFFFFCLL) - this) & 0xFFFFFFFFFFFFFFF8) != 0x10) {
    *(void *)(this + 16) = v10;
  }
  if ((v13 & 2) == 0) {
    *(void *)(v13 & 0xFFFFFFFFFFFFFFFCLL) = this;
  }
  return this;
}

unint64_t lsl::Allocator::AllocationMetadata::pool(lsl::Allocator::AllocationMetadata *this, int a2)
{
  for (unint64_t i = *(lsl::Allocator::AllocationMetadata **)this;
        i && (i & 1) == 0;
        unint64_t i = *(lsl::Allocator::AllocationMetadata **)i)
  {
    if (a2)
    {
      uint64_t v4 = *((void *)this + 1);
      if ((v4 & 1) == 0 && (((v4 & 0xFFFFFFFFFFFFFFFCLL) - (void)this) & 0xFFFFFFFFFFFFFFF8) != 0x10)
      {
        unint64_t result = *((void *)this + 2);
        if (result) {
          return result;
        }
      }
    }
    this = i;
  }
  return (unint64_t)i & 0xFFFFFFFFFFFFFFFELL;
}

unint64_t lsl::Allocator::AllocationMetadata::reserve(lsl::Allocator::AllocationMetadata *this, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    lsl::Allocator::AllocationMetadata::reserve();
  }
  uint64_t v5 = (v3 & 0xFFFFFFFFFFFFFFFCLL) - ((void)this + a2) - 32;
  BOOL v6 = (char *)this + a2 + 16;

  return lsl::Allocator::AllocationMetadata::AllocationMetadata((unint64_t)v6, this, v5, 2, a3);
}

uint64_t lsl::Allocator::AllocationMetadata::consumeFromNext(lsl::Allocator::AllocationMetadata *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v2 & 2) != 0) {
    unint64_t v4 = 0;
  }
  else {
    unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFFCLL;
  }
  uint64_t v5 = *(void *)(v4 + 8);
  if (v5) {
    return 0;
  }
  unint64_t v7 = (char *)this + a2 + 16;
  uint64_t v8 = &v7[-v3];
  unint64_t v9 = (v5 & 0xFFFFFFFFFFFFFFFCLL) - v4;
  if (v9 - 16 >= (unint64_t)&v7[-v3])
  {
    lsl::Allocator::AllocationMetadata::AllocationMetadata((unint64_t)v7, this, v9 - 16 - (void)&v7[-v3], v5 & 3, v2 & 3);
    return 1;
  }
  uint64_t result = 0;
  if ((v5 & 2) == 0 && v8 == (char *)v9)
  {
    *((void *)this + 1) = v5 | 1;
    *(void *)(v5 & 0xFFFFFFFFFFFFFFFCLL) = this;
    return 1;
  }
  return result;
}

const os_unfair_lock *lsl::Allocator::freeObject(const os_unfair_lock *this, void *a2)
{
  if (this)
  {
    uint64_t v2 = (os_unfair_lock *)this;
    unint64_t v3 = *(lsl::Lock ***)lsl::Allocator::AllocationMetadata::pool((lsl::Allocator::AllocationMetadata *)&this[-4], 1);
    return lsl::Allocator::free(v3, v2);
  }
  return this;
}

lsl::Allocator::Pool *lsl::Allocator::Pool::aligned_alloc_best_fit(lsl::Allocator::Pool *this, uint64_t a2, unint64_t a3)
{
  if (a2 == 16 && (unint64_t v4 = (void *)**((void **)this + 3), (v4 & 1) == 0) && v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = -1;
    do
    {
      uint64_t v7 = v4[1];
      if ((v7 & 1) == 0)
      {
        unint64_t v8 = (v7 & 0xFFFFFFFFFFFFFFFCLL) - (void)v4 - 16;
        if (v8 >= a3)
        {
          if (v8 - a3 < v6)
          {
            uint64_t v5 = v4;
            unint64_t v6 = v8 - a3;
          }
          if (v8 == a3)
          {
            uint64_t v5 = v4;
            goto LABEL_18;
          }
        }
      }
      unint64_t v4 = (void *)*v4;
    }
    while ((v4 & 1) == 0 && v4);
    if (!v5)
    {
      a2 = 16;
      goto LABEL_14;
    }
LABEL_18:
    uint64_t v10 = v5[1];
    if (v10) {
      lsl::Allocator::Pool::aligned_alloc_best_fit();
    }
    uint64_t v11 = (lsl::Allocator::Pool *)(v5 + 2);
    v5[1] = v10 | 1;
    if ((v10 & 0xFFFFFFFFFFFFFFFCLL) - (unint64_t)v5 - 16 > a3) {
      lsl::Allocator::AllocationMetadata::returnToNext((lsl::Allocator::AllocationMetadata *)v5, a3);
    }
    if (v11 == this) {
      lsl::Allocator::Pool::aligned_alloc_best_fit();
    }
    return v11;
  }
  else
  {
LABEL_14:
    return (lsl::Allocator::Pool *)lsl::Allocator::Pool::aligned_alloc(this, a2, a3);
  }
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
  int v1 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  uint32_t os_unfair_lock_opaque = lock->_os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque | 1) != v1) {
    os_unfair_lock_assert_owner_cold_1(os_unfair_lock_opaque);
  }
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
  int v1 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  uint32_t os_unfair_lock_opaque = lock->_os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque | 1) == v1) {
    os_unfair_lock_assert_not_owner_cold_1(os_unfair_lock_opaque);
  }
}

mach_vm_address_t lsl::MemoryManager::vm_allocate_bytes(lsl::MemoryManager *this, uint64_t a2)
{
  kern_return_t v6;
  mach_vm_address_t address;
  char v9[1024];

  unint64_t v3 = (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
  vm_address_t address = 0x100000000;
  if (*((unsigned char *)this + 32)) {
    int v4 = 1006637057;
  }
  else {
    int v4 = 1006632961;
  }
  if (mach_vm_map(mach_task_self_, &address, v3, vm_page_mask, v4, 0, 0, 0, 3, 7, 1u))
  {
    if (*((unsigned char *)this + 32)) {
      int v5 = 1006637057;
    }
    else {
      int v5 = 1006632961;
    }
    unint64_t v6 = vm_allocate(mach_task_self_, &address, v3, v5);
    if (v6) {
      lsl::MemoryManager::vm_allocate_bytes(v9, v3, (uint64_t *)this, v6);
    }
  }
  return address;
}

kern_return_t mach_vm_map(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, mem_entry_name_port_t object, memory_object_offset_t offset, BOOLean_t copy, vm_prot_t cur_protection, vm_prot_t max_protection, vm_inherit_t inheritance)
{
  kern_return_t v20;
  kern_return_t v21;
  mach_vm_address_t *v22;
  mach_vm_address_t v23;
  uint64_t reply_port;
  kern_return_t v25;
  BOOL v26;
  mach_msg_header_t v29;
  int v30;
  mem_entry_name_port_t v31;
  long long v32;
  mach_vm_address_t v33;
  mach_vm_size_t v34;
  mach_vm_offset_t v35;
  int v36;
  memory_object_offset_t v37;
  BOOLean_t v38;
  vm_prot_t v39;
  vm_prot_t v40;
  vm_inherit_t v41;

  vm_map_t v12 = target_task;
  if (object) {
    goto LABEL_9;
  }
  if (max_protection != 7 || inheritance != 1) {
    goto LABEL_9;
  }
  uint64_t v14 = address;
  mach_vm_size_t v15 = size;
  mach_vm_offset_t v16 = mask;
  int v17 = flags;
  BOOLean_t v18 = copy;
  memory_object_offset_t v19 = offset;
  uint64_t v20 = _kernelrpc_mach_vm_map_trap(target_task, address, size, mask, flags, cur_protection);
  vm_size_t size = v15;
  masunint64_t k = v16;
  flags = v17;
  offset = v19;
  vm_map_t v12 = target_task;
  copy = v18;
  vm_address_t address = v14;
  uint64_t v21 = v20;
  if (v20 == 268435459)
  {
LABEL_9:
    unint64_t v30 = 1;
    uint64_t v31 = object;
    *(void *)&uint64_t v32 = 0x13000000000000;
    uint64_t v22 = address;
    uint64_t v23 = *address;
    *((void *)&v32 + 1) = 0x100000000;
    uint64_t v33 = v23;
    uint64_t v34 = size;
    uint64_t v35 = mask;
    uint64_t v36 = flags;
    uint64_t v37 = offset;
    uint64_t v38 = copy;
    int v39 = cur_protection;
    uint64_t v40 = max_protection;
    uint64_t v41 = inheritance;
    reply_port = mig_get_reply_port();
    *(void *)&v29.msgh_bits = 0x6480001513;
    *(void *)&v29.msgh_remote_port = __PAIR64__(reply_port, v12);
    *(void *)&v29.msgh_voucher_port = 0x12CB00000000;
    uint64_t v25 = mach_msg2_internal(&v29, 0x200000003uLL, (void *)0x6480001513, (void *)__PAIR64__(reply_port, v12), (void *)0x12CB00000000, (void *)((reply_port << 32) | 1), (void *)0x34, 0);
    uint64_t v21 = v25;
    if ((v25 - 268435458) > 0xE || ((1 << (v25 - 2)) & 0x4003) == 0)
    {
      if (!v25)
      {
        if (v29.msgh_id == 71)
        {
          uint64_t v21 = -308;
        }
        else if (v29.msgh_id == 4911)
        {
          if ((v29.msgh_bits & 0x80000000) == 0)
          {
            if (v29.msgh_size == 44)
            {
              if (!v29.msgh_remote_port)
              {
                uint64_t v21 = v32;
                if (!v32)
                {
                  long long *v22 = *(void *)((char *)&v32 + 4);
                  return v21;
                }
                goto LABEL_27;
              }
            }
            else if (v29.msgh_size == 36)
            {
              if (v29.msgh_remote_port) {
                uint64_t v26 = 1;
              }
              else {
                uint64_t v26 = v32 == 0;
              }
              if (v26) {
                uint64_t v21 = -300;
              }
              else {
                uint64_t v21 = v32;
              }
              goto LABEL_27;
            }
          }
          uint64_t v21 = -300;
        }
        else
        {
          uint64_t v21 = -301;
        }
LABEL_27:
        mach_msg_destroy(&v29);
        return v21;
      }
      mig_dealloc_reply_port(v29.msgh_local_port);
    }
  }
  return v21;
}

uint64_t lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 40 * a2);
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 40 * a2);
      uint64_t v4 = result;
      if (*(void *)(v3 + 16))
      {
        uint64_t v5 = 0;
        unint64_t v6 = 0;
        do
        {
          uint64_t v7 = result + v5;
          unint64_t v8 = (long long *)(*(void *)(v3 + 8) + v5);
          long long v9 = *v8;
          long long v10 = v8[1];
          *(void *)(v7 + 32) = *((void *)v8 + 4);
          *(_OWORD *)uint64_t v7 = v9;
          *(_OWORD *)(v7 + 16) = v10;
          ++v6;
          unint64_t v11 = *(void *)(v3 + 16);
          v5 += 40;
        }
        while (v11 > v6);
      }
      else
      {
        unint64_t v11 = 0;
      }
      vm_map_t v12 = *(void **)(v3 + 8);
      if (v12)
      {
        uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v12);
        unint64_t v11 = *(void *)(v3 + 16);
      }
      if (v11 >= a2) {
        unint64_t v13 = a2;
      }
      else {
        unint64_t v13 = v11;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v13;
    }
    *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

void dyld4::RuntimeState::doSingletonPatching(dyld4::RuntimeState *this, dyld4::DyldCacheDataConstLazyScopedWriter *a2)
{
  if (*((void *)this + 38) != *((void *)this + 40))
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(a2);
    dyld4::RuntimeState::setDyldPatchedObjCClasses(this);
    unint64_t v3 = *((void *)this + 40);
    for (unint64_t i = *((void *)this + 38); v3 < i; *((void *)this + 40) = v3)
    {
      uint64_t v5 = *((void *)this + 37) + 16 * v3;
      unint64_t v6 = *(void **)v5;
      uint64_t v7 = *(void **)(v5 + 8);
      uint64_t v8 = v7[1];
      *unint64_t v6 = *v7;
      v6[1] = v8;
      if (*(unsigned char *)(*((void *)this + 1) + 202))
      {
        dyld4::RuntimeState::log(this, "cache singleton fixup: *0x%012lX = 0x%012lX\n", v6, v7);
        unint64_t v3 = *((void *)this + 40);
        unint64_t i = *((void *)this + 38);
      }
      ++v3;
    }
  }
}

void dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::Loader *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 128);
  v18[0] = a2;
  v18[1] = (uint64_t)this;
  uint64_t v17 = v8;
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if (*(unsigned char *)(v9 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_36;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_36;
    }
    unint64_t v16 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v16)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_36;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      a2 = 0xFFFFFC0D0;
      uint64_t v10 = MEMORY[0xFFFFFC0D0];
      if (v10 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v16 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v9, &v19);
    uint64_t v11 = *(void *)(v9 + 24);
    if (!v11)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v9, 0);
      uint64_t v11 = *(void *)(v9 + 24);
    }
    *(void *)(v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v11 + 1;
    lsl::Lock::unlock(v19);
  }
  dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::RuntimeState &)const::$_0::operator()(v18, a2, a3, a4, a5, a6, a7, a8);
  if (v17) {
    uint64_t v12 = v17;
  }
  else {
    uint64_t v12 = 0;
  }
  if (*(unsigned char *)(v12 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_36;
    }
    if (v16 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return;
    }
    if (v16 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v13 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v13 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v13 == StatusReg) {
      return;
    }
LABEL_36:
    __break(1u);
    return;
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v12, &v19);
  if (v16 == 1)
  {
    uint64_t v15 = *(void *)(v12 + 24) - 1;
    *(void *)(v12 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v15;
    if (!v15) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v12, 1);
    }
  }
  lsl::Lock::unlock(v19);
}

void dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::RuntimeState &)const::$_0::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1[1], *a1, a3, a4, a5, a6, a7, a8, v39[0]);
  v42[0] = (uint64_t)v39 - v10;
  v42[1] = v9;
  uint64_t v43 = 0;
  __chkstk_darwin(v11, v12, v13, v14, v15, v16, v17, v18, v39[0]);
  v41[0] = (uint64_t)v39 - ((v19 + 23) & 0xFFFFFFFFFFFFFFF0);
  v41[1] = v20;
  v41[2] = 0;
  dyld4::Loader::runInitializersBottomUp(v21, v22, v42, v41);
  __chkstk_darwin(v23, v24, v25, v26, v27, v28, v29, v30, v39[0]);
  v39[0] = (uint64_t)v39 - v32;
  v39[1] = v31;
  uint64_t v40 = 0;
  if (v43)
  {
    uint64_t v33 = (dyld4::Loader **)v42[0];
    uint64_t v34 = 8 * v43;
    do
    {
      uint64_t v35 = *v33++;
      dyld4::Loader::runInitializersBottomUp(v35, (dyld4::RuntimeState *)*a1, v39, v41);
      v34 -= 8;
    }
    while (v34);
    if (v40)
    {
      uint64_t v43 = 0;
      uint64_t v36 = (dyld4::Loader **)v39[0];
      uint64_t v37 = 8 * v40;
      do
      {
        uint64_t v38 = *v36++;
        dyld4::Loader::runInitializersBottomUp(v38, (dyld4::RuntimeState *)*a1, v42, v41);
        v37 -= 8;
      }
      while (v37);
    }
  }
}

void *lsl::Allocator::AllocationMetadata::returnToNext(lsl::Allocator::AllocationMetadata *this, uint64_t a2)
{
  uint64_t v4 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(this, 1);
  lsl::Allocator::AllocationMetadata::AllocationMetadata((unint64_t)this + a2 + 16, this, (*((void *)this + 1) & 0xFFFFFFFFFFFFFFFCLL) - ((void)this + a2) - 32, 0, *((void *)this + 1) & 3);
  uint64_t v5 = *((void *)this + 1);
  if ((v5 & 2) != 0) {
    unint64_t v6 = 0;
  }
  else {
    unint64_t v6 = (lsl::Allocator::AllocationMetadata *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
  }

  return lsl::Allocator::AllocationMetadata::coalesce(v6, v4);
}

uint64_t dyld4::RuntimeState::incDlRefCount(uint64_t this, const dyld4::Loader *a2)
{
  if ((*((_WORD *)a2 + 2) & 0x20) == 0)
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 1056);
    if (v4)
    {
      uint64_t v5 = (void *)(*(void *)(this + 1048) + 8);
      uint64_t v6 = 16 * v4;
      while ((const dyld4::Loader *)*(v5 - 1) != a2)
      {
        v5 += 2;
        v6 -= 16;
        if (!v6) {
          goto LABEL_6;
        }
      }
      ++*v5;
    }
    else
    {
LABEL_6:
      this = lsl::Vector<dyld4::InterposeTupleAll>::reserve(this + 1040, v4 + 1);
      uint64_t v7 = *(void *)(v3 + 1048);
      uint64_t v8 = *(void *)(v3 + 1056);
      *(void *)(v3 + 1056) = v8 + 1;
      uint64_t v9 = (void *)(v7 + 16 * v8);
      void *v9 = a2;
      v9[1] = 1;
    }
  }
  return this;
}

void dyld4::RuntimeState::notifyObjCPatching(dyld4::RuntimeState *this)
{
  if (*((void *)this + 84) && *((void *)this + 34))
  {
    dyld4::RuntimeState::setDyldPatchedObjCClasses(this);
    uint64_t v2 = *((void *)this + 34);
    if (v2)
    {
      uint64_t v3 = (void *)*((void *)this + 33);
      uint64_t v4 = &v3[4 * v2];
      do
      {
        (*((void (**)(void, void, void, void))this + 84))(*v3, v3[1], v3[2], v3[3]);
        v3 += 4;
      }
      while (v3 != v4);
    }
    if (*(unsigned char *)(*((void *)this + 1) + 205)) {
      dyld4::RuntimeState::log(this, "objc-patch-class-notifier called with %lld patches:\n", *((void *)this + 34));
    }
    *((void *)this + 34) = 0;
  }
}

void dyld4::RuntimeState::rebindMissingFlatLazySymbols(uint64_t a1, dyld4::Loader ***a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v12);
  uint64_t v4 = *(void *)(a1 + 904);
  uint64_t v5 = *(void *)(a1 + 912);
  uint64_t v6 = v4 + 24 * v5;
  v11[0] = a2;
  v11[1] = (dyld4::Loader ***)&v12;
  v11[2] = (dyld4::Loader ***)a1;
  if (v5)
  {
    uint64_t v7 = 24 * v5;
    while ((dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()(v11, v4) & 1) == 0)
    {
      v4 += 24;
      v7 -= 24;
      if (!v7)
      {
        uint64_t v4 = v6;
        goto LABEL_13;
      }
    }
  }
  uint64_t v8 = v4 + 24;
  if (v4 != v6 && v8 != v6)
  {
    do
    {
      if ((dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()(v11, v8) & 1) == 0)
      {
        long long v10 = *(_OWORD *)v8;
        *(void *)(v4 + 16) = *(void *)(v8 + 16);
        *(_OWORD *)uint64_t v4 = v10;
        v4 += 24;
      }
      v8 += 24;
    }
    while (v8 != v6);
  }
LABEL_13:
  *(void *)(a1 + 912) += 0x5555555555555555 * ((*(void *)(a1 + 904) + 24 * *(void *)(a1 + 912) - v4) >> 3);
  mach_o::Error::~Error(&v12);
}

void *Diagnostics::errorMessage(Diagnostics *this)
{
  int v1 = *(unsigned char ***)this;
  if (v1) {
    return (void *)_simple_string(v1);
  }
  else {
    return &unk_1A8E7346B;
  }
}

char *dyld4::APIs::dyld_image_path_containing_address(dyld4::APIs *this, char *a2)
{
  uint64_t v7 = 0;
  BOOL v6 = 0;
  uint64_t v5 = 0;
  dyld4::APIs::findImageMappedAt(this, a2, &v7, &v6, (const char **)&v5, 0, 0, 0, 0);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_image_path_containing_address(%p) => '%s'\n", a2, v5);
  }
  return v5;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<long long>(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = dyld3::MachOFile::preferredLoadAddress(a1);
  int v8 = *(void *)(a3 + 72) / 0x18uLL;
  if (v8)
  {
    uint64_t v9 = (char *)a1 + *(void *)(a3 + 64) - result;
    long long v10 = &v9[24 * v8];
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, v9, v9 + 8);
      v9 += 24;
    }
    while (v9 < v10);
  }
  return result;
}

unint64_t ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke(unint64_t result, void *a2, void *a3)
{
  uint64_t v5 = (void *)result;
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(unsigned int *)a3;
  if (*(unsigned char *)(result + 64)) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8 || (uint64_t result = (***(uint64_t (****)(void))(v6 + 152))(*(void *)(v6 + 152)), result < 4))
  {
    LODWORD(v1dyld4::halt((char *)__format, 0) = *(_DWORD *)(*(void *)(v5[4] + 8) + 48);
    if (!v10)
    {
      uint64_t v11 = 0;
      uint64_t result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(v6 + 152) + 48))(*(void *)(v6 + 152), &v11);
      if (result) {
        dyld4::halt("could not create thread local variables pthread key", 0);
      }
      *(_DWORD *)(*(void *)(v5[4] + 8) + 48) = v11;
      LODWORD(v1dyld4::halt((char *)__format, 0) = *(_DWORD *)(*(void *)(v5[4] + 8) + 48);
    }
    uint64_t v10 = v10;
    goto LABEL_13;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 152) + 168))(*(void *)(v6 + 152), v7);
  uint64_t v9 = *(void *)(v5[4] + 8);
  uint64_t v10 = *(unsigned int *)(v9 + 48);
  if (!v10)
  {
    *(_DWORD *)(v9 + 48) = v7;
    goto LABEL_14;
  }
  if (v10 != v7) {
LABEL_13:
  }
    *a3 = v10;
LABEL_14:
  if (v5[6] != *a2) {
    *a2 = v5[7];
  }
  return result;
}

uint64_t dyld4::APIs::dlopen(dyld4::APIs *this, const char *a2, uint64_t a3)
{
  return (*(uint64_t (**)(dyld4::APIs *, const char *, uint64_t, uint64_t))(*(void *)this + 776))(this, a2, a3, v3);
}

unsigned char *___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166(unsigned char *result, unsigned int a2)
{
  uint64_t v2 = *(void *)(*((void *)result + 4) + 8);
  if (*(void *)(v2 + 56) <= (unint64_t)a2) {
    ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166_cold_1();
  }
  if ((*(_WORD *)(*(void *)(*(void *)(v2 + 40) + 32 * a2 + 16) + 4) & 2) != 0 && result[48])
  {
    uint64_t v3 = (unsigned char *)*((void *)result + 5);
    return dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(v3);
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_get_image_slide(dyld4::APIs *this, mach_header *a2)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_slide(%p)", a2);
  }
  BOOL hasMachOMagic = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)a2);
  uint64_t v6 = *((void *)this + 1);
  if (hasMachOMagic)
  {
    if (DyldSharedCache::inDyldCache(*(DyldSharedCache **)(v6 + 240), (const DyldSharedCache *)a2, v5))
    {
      uint64_t v6 = *((void *)this + 1);
      uint64_t Slide = *(void *)(v6 + 264);
    }
    else
    {
      uint64_t Slide = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)a2);
      uint64_t v6 = *((void *)this + 1);
    }
  }
  else
  {
    uint64_t Slide = 0;
  }
  if (*(unsigned char *)(v6 + 204)) {
    dyld4::RuntimeState::log(this, " => 0x%lX\n", Slide);
  }
  return Slide;
}

uint64_t dyld4::APIs::dyld_get_base_platform(dyld4::APIs *this, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = dyld3::MachOFile::basePlatform(a2);
  uint64_t v5 = v4;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_base_platform(%d) => %d\n", v2, v4);
  }
  return v5;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_version(dyld4::APIs *this)
{
  uint64_t SdkVersion = dyld4::APIs::getSdkVersion(this, *(const mach_header **)(*((void *)this + 1) + 8));
  uint64_t v3 = SdkVersion;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_version() => 0x%08X\n", SdkVersion);
  }
  return v3;
}

uint64_t dyld4::APIs::getSdkVersion(dyld4::APIs *this, const mach_header *a2)
{
  v9[0] = 0;
  v9[1] = v9;
  unsigned int v9[2] = 0x2000000000;
  char v10 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld44APIs13getSdkVersionEPK11mach_header_block_invoke;
  void v4[3] = &unk_1EFF651D8;
  void v4[5] = &v5;
  void v4[6] = this;
  v4[4] = v9;
  dyld4::APIs::forEachImageVersion((uint64_t)this, &a2->magic, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(v9, 8);
  return v2;
}

uint64_t dyld4::APIs::dyld_sdk_at_least(dyld4::RuntimeState *a1, unsigned int *a2, unint64_t a3)
{
  unint64_t v6 = dyld4::APIs::mapFromVersionSet((uint64_t)a1, a3, *(unsigned int *)(*((void *)a1 + 1) + 68));
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unsigned int v9[2] = ___ZN5dyld44APIs17dyld_sdk_at_leastEPK11mach_header20dyld_build_version_t_block_invoke;
  void v9[3] = &unk_1EFF65228;
  v9[4] = &v10;
  v9[5] = v6;
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)v9);
  if (*(unsigned char *)(*((void *)a1 + 1) + 204)) {
    dyld4::RuntimeState::log(a1, "dyld_sdk_at_least(%p, <%d,0x%08X>) => %d\n", a2, a3, HIDWORD(a3), *((unsigned __int8 *)v11 + 24));
  }
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void dyld4::APIs::forEachImageVersion(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(unsigned int **)(v7 + 8) == a2)
  {
    (*(void (**)(uint64_t, void, void, void))(a3 + 16))(a3, *(unsigned int *)(v7 + 68), *(unsigned int *)(v7 + 48), *(unsigned int *)(v7 + 56));
  }
  else if (DyldSharedCache::inDyldCache(*(DyldSharedCache **)(v7 + 240), (const DyldSharedCache *)a2, v6))
  {
    (*(void (**)(uint64_t, void, void, void))(a3 + 16))(a3, *(unsigned int *)(*(void *)(a1 + 8) + 384), *(unsigned int *)(*(void *)(a1 + 8) + 388), *(unsigned int *)(*(void *)(a1 + 8) + 388));
  }
  else if (dyld3::MachOFile::isMachO((dyld3::MachOFile *)a2, (vm_address_t *)&v8, a2[5] + 32))
  {
    dyld4::APIs::forEachPlatform(a1, (const dyld3::MachOFile *)a2, a3);
  }
  mach_o::Error::~Error(&v8);
}

unint64_t dyld4::APIs::mapFromVersionSet(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = HIDWORD(a2);
  if (a2 == -1)
  {
    int v4 = dyld3::MachOFile::basePlatform(a3);
    LODWORD(a2) = v4;
    uint64_t v5 = 0;
    while (dyld3::sVersionMap[v5] < v3)
    {
      v5 += 9;
      if (v5 == 441)
      {
        LODWORD(a2) = 0;
        unint64_t v3 = 0;
        return a2 | (v3 << 32);
      }
    }
    unint64_t v3 = 0;
    switch(v4)
    {
      case 1:
        unint64_t v6 = &dyld3::sVersionMap[v5 + 1];
        goto LABEL_13;
      case 2:
        unint64_t v6 = &dyld3::sVersionMap[v5 + 2];
        goto LABEL_13;
      case 3:
        unint64_t v6 = &dyld3::sVersionMap[v5 + 4];
        goto LABEL_13;
      case 4:
        unint64_t v6 = &dyld3::sVersionMap[v5 + 3];
        goto LABEL_13;
      case 5:
        unint64_t v6 = &dyld3::sVersionMap[v5 + 5];
        goto LABEL_13;
      case 11:
        unint64_t v6 = &dyld3::sVersionMap[v5 + 7];
LABEL_13:
        unint64_t v3 = *v6;
        break;
      default:
        return a2 | (v3 << 32);
    }
  }
  return a2 | (v3 << 32);
}

BOOL DyldSharedCache::inDyldCache(DyldSharedCache *this, const DyldSharedCache *a2, const dyld3::MachOFile *a3)
{
  int v5 = dyld3::MachOFile::inDyldCache(a2);
  BOOL result = 0;
  if (a2 >= this && this)
  {
    if (v5) {
      return (DyldSharedCache *)((char *)this + DyldSharedCache::mappedSize(this)) > a2;
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::inDyldCache(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 6) >> 31;
}

uint64_t ___ZN5dyld44APIs13getSdkVersionEPK11mach_header_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8);
  if (!*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = result;
    int v5 = *(_DWORD *)(*(void *)(*(void *)(result + 48) + 8) + 68);
    if (v5 == a2)
    {
      *(unsigned char *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      BOOL result = dyld3::MachOFile::basePlatform(a2);
      int v7 = a3 + 458752;
      int v8 = a3 + 589824;
      if (result != 5) {
        int v8 = a3;
      }
      if (result != 4) {
        int v7 = v8;
      }
      goto LABEL_10;
    }
    if (a2 == 7 && v5 == 6)
    {
      *(unsigned char *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      int v7 = 786432;
LABEL_10:
      *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
    }
  }
  return result;
}

uint64_t dyld4::ProcessConfig::Process::findVersionSetEquivalent(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  unsigned int v7 = 0;
  int v8 = dyld3::sVersionMap;
  while (1)
  {
    int v9 = dyld3::MachOFile::basePlatform(a2);
    unsigned int v10 = -1;
    switch(v9)
    {
      case 1:
        uint64_t v11 = v8 + 1;
        goto LABEL_9;
      case 2:
        uint64_t v11 = v8 + 2;
        goto LABEL_9;
      case 3:
        uint64_t v11 = v8 + 4;
        goto LABEL_9;
      case 4:
        uint64_t v11 = v8 + 3;
        goto LABEL_9;
      case 5:
        uint64_t v11 = v8 + 5;
        goto LABEL_9;
      case 11:
        uint64_t v11 = &dyld3::sVersionMap[v5 + 7];
LABEL_9:
        unsigned int v10 = *v11;
        break;
      default:
        break;
    }
    if (v10 > a3) {
      break;
    }
    unsigned int v6 = dyld3::sVersionMap[v5];
    v8 += 9;
    v5 += 9;
    unsigned int v7 = v10;
    if (v5 == 441)
    {
      unsigned int v7 = v10;
      break;
    }
  }
  if (v10 == -1 && v7 == 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v6;
  }
}

uint64_t ___ZN5dyld44APIs17dyld_sdk_at_leastEPK11mach_header20dyld_build_version_t_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6 = dyld3::MachOFile::basePlatform(a2);
  uint64_t result = dyld3::MachOFile::basePlatform(*(unsigned int *)(a1 + 40));
  if (v6 == result)
  {
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if (result)
    {
      if (*(_DWORD *)(a1 + 44) <= a3) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      }
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::basePlatform(uint64_t result)
{
  if result <= 0x1E && ((0x7E1F9FFFu >> result)) {
    return dword_1A8E711A4[(int)result];
  }
  return result;
}

void dyld4::APIs::forEachPlatform(uint64_t a1, const dyld3::MachOFile *a2, uint64_t a3)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZN5dyld44APIs15forEachPlatformEPKN5dyld39MachOFileEU13block_pointerFvjjjE_block_invoke;
  void v10[3] = &unk_1EFF652A0;
  v10[6] = a1;
  v10[7] = a2;
  v10[4] = a3;
  v10[5] = &v11;
  dyld3::MachOFile::forEachSupportedPlatform(a2, (uint64_t)v10);
  if (!*((unsigned char *)v12 + 24))
  {
    unsigned int v6 = dyld4::APIs::linkedDylibVersion(v5, a2, "/System/Library/Frameworks/Foundation.framework/Foundation");
    if (v6 >= 0x2A61800)
    {
      unsigned int v7 = (unsigned int *)&unk_1A8E71030;
      do
      {
        unsigned int v8 = v7[3];
        if (!v8)
        {
          uint64_t v9 = 458752;
          goto LABEL_9;
        }
        v7 += 2;
      }
      while (v6 >= v8);
      uint64_t v9 = *v7;
      if (!v9) {
        goto LABEL_10;
      }
LABEL_9:
      (*(void (**)(uint64_t, uint64_t, uint64_t, void))(a3 + 16))(a3, 2, v9, 0);
    }
  }
LABEL_10:
  _Block_object_dispose(&v11, 8);
}

uint64_t dyld4::dyld_map_with_linking_np(dyld4 *this, const mwl_region *a2, unsigned int a3, const mwl_info_hdr *a4, const unsigned int *a5, ptrauth_key a6)
{
  if (*(_DWORD *)this != 7) {
    return 0xFFFFFFFFLL;
  }
  int v7 = *((_DWORD *)this + 2);
  int v8 = *((_DWORD *)this + 3);
  if (*((_WORD *)this + 3) == 3) {
    char v9 = 2;
  }
  else {
    char v9 = 3;
  }
  if ((v8 << v9) + v7 > a2)
  {
    fprintf(__stderrp, "bind table extends past blob, blobSize=%d, offset=%d, count=%d\n", a2, v7, v8);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *((unsigned int *)this + 4);
  if (*((_DWORD *)this + 5) + (int)v10 > a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = (char *)this + v10;
  unint64_t v13 = *(unsigned int *)((char *)this + v10);
  if (v13)
  {
    unint64_t v14 = 0;
    uint64_t v40 = v12;
    do
    {
      uint64_t v15 = *(unsigned int *)&v12[4 * v14 + 4];
      if (v15)
      {
        uint64_t v16 = &v12[v15];
        if (*(_WORD *)&v12[v15 + 20])
        {
          unsigned int v17 = 0;
          uint64_t v18 = *((void *)v16 + 1) + *((void *)this + 4);
          do
          {
            uint64_t v19 = *((unsigned int *)this + 4);
            uint64_t v20 = (char *)this + v19;
            uint64_t v21 = *(unsigned int *)((char *)this + v19);
            if (!v21) {
LABEL_37:
            }
              dyld4::dyld_map_with_linking_np();
            unint64_t v22 = v18 + v17 * *((unsigned __int16 *)this + 2);
            uint64_t v23 = v19 + 4;
            while (1)
            {
              uint64_t v24 = &v20[*(unsigned int *)((char *)this + v23)];
              unint64_t v25 = *((void *)v24 + 1) + *((void *)this + 4);
              if (v25 <= v22
                && v25 + *((unsigned __int16 *)v24 + 10) * (unint64_t)*((unsigned __int16 *)v24 + 2) > v22)
              {
                break;
              }
              v23 += 4;
              if (!--v21) {
                goto LABEL_37;
              }
            }
            unint64_t v26 = (v22 - v25) / *((unsigned __int16 *)v24 + 2);
            switch(*((_WORD *)this + 3))
            {
              case 1:
                unint64_t v27 = v18 + v17 * *((unsigned __int16 *)this + 2);
                uint64_t v28 = this;
                uint64_t v29 = (const mwl_info_hdr *)&v20[*(unsigned int *)((char *)this + v23)];
                int v30 = 0;
                goto LABEL_23;
              case 2:
                uint64_t v31 = v18 + v17 * *((unsigned __int16 *)this + 2);
                uint64_t v32 = this;
                uint64_t v33 = (const mwl_info_hdr *)&v20[*(unsigned int *)((char *)this + v23)];
                int v34 = 0;
                goto LABEL_29;
              case 3:
                uint64_t v35 = *(unsigned __int16 *)&v24[2 * v26 + 22];
                if (v35 != 0xFFFF)
                {
                  uint64_t v36 = *((unsigned int *)this + 2);
                  uint64_t v37 = (const dyld_chained_starts_in_segment *)((char *)this + v36);
                  if ((v35 & 0x8000) != 0)
                  {
                    int v38 = v35 & 0x7FFF;
                    do
                    {
                      __int16 v39 = *(_WORD *)&v24[2 * v38 + 22];
                      dyld4::fixupChain32((_DWORD *)(v22 + (v39 & 0x7FFF)), (unsigned int *)this, (const mwl_info_hdr *)v24, v37, a5);
                      ++v38;
                    }
                    while ((v39 & 0x8000) == 0);
                  }
                  else
                  {
                    dyld4::fixupChain32((_DWORD *)(v22 + v35), (unsigned int *)this, (const mwl_info_hdr *)v24, (const dyld_chained_starts_in_segment *)((char *)this + v36), a5);
                  }
                }
                break;
              case 6:
                uint64_t v31 = v18 + v17 * *((unsigned __int16 *)this + 2);
                uint64_t v32 = this;
                uint64_t v33 = (const mwl_info_hdr *)&v20[*(unsigned int *)((char *)this + v23)];
                int v34 = 1;
LABEL_29:
                dyld4::fixupPage64(v31, v32, v33, (const dyld_chained_starts_in_segment *)v26, v34);
                break;
              case 9:
              case 0xC:
                unint64_t v27 = v18 + v17 * *((unsigned __int16 *)this + 2);
                uint64_t v28 = this;
                uint64_t v29 = (const mwl_info_hdr *)&v20[*(unsigned int *)((char *)this + v23)];
                int v30 = 1;
LABEL_23:
                dyld4::fixupPageAuth64(v27, v28, v29, (const dyld_chained_starts_in_segment *)v26, v30, a6);
                break;
              default:
                break;
            }
            ++v17;
          }
          while (v17 < *((unsigned __int16 *)v16 + 10));
          uint64_t v12 = v40;
          unint64_t v13 = *(unsigned int *)v40;
        }
      }
      ++v14;
    }
    while (v14 < v13);
  }
  return 0;
}

unint64_t dyld4::fixupPageAuth64(unint64_t this, _DWORD *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, int a5, ptrauth_key a6)
{
  uint64_t v6 = *((unsigned __int16 *)&a3->mwli_chains_size + a4 + 1);
  if (v6 != 0xFFFF)
  {
    int v8 = (char *)a2 + a2[2];
    char v9 = (unint64_t *)(this + v6);
    uint64_t v10 = 6;
    if (a5) {
      uint64_t v10 = 8;
    }
    uint64_t v11 = *(void *)&a2[v10];
    do
    {
      unint64_t v12 = *v9;
      if ((*v9 & 0x8000000000000000) != 0)
      {
        if ((v12 & 0x4000000000000000) != 0)
        {
          unsigned int v17 = a2[3];
          if ((v12 & 0xFFFFFF) >= v17) {
            return fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v12 & 0xFFFFFF, v17);
          }
          unint64_t v13 = (void *)(HIWORD(v12) & 1);
          uint64_t v14 = *(void *)&v8[8 * (v12 & 0xFFFFFF)];
        }
        else
        {
          unint64_t v13 = (void *)(HIWORD(v12) & 1);
          uint64_t v14 = *((void *)a2 + 4) + v12;
        }
        this = dyld4::signPointer(v14, (unint64_t)v9, v13, SBYTE4(v12), (v12 >> 49) & 3, a6);
      }
      else if ((v12 & 0x4000000000000000) != 0)
      {
        unsigned int v15 = a2[3];
        if ((v12 & 0xFFFFFF) >= v15) {
          return fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v12 & 0xFFFFFF, v15);
        }
        unint64_t v16 = HIDWORD(v12) | 0xFFFFFFFFFFFC0000;
        if ((v12 & 0x4000000000000) == 0) {
          unint64_t v16 = HIDWORD(v12) & 0x7FFFF;
        }
        this = *(void *)&v8[8 * (v12 & 0xFFFFFF)] + v16;
      }
      else
      {
        this = (v12 & 0x7FFFFFFFFFFLL) + v11 + (v12 >> 43 << 56);
      }
      uint64_t v18 = (v12 >> 51) & 0x7FF;
      unint64_t *v9 = this;
      v9 += v18;
    }
    while (v18);
  }
  return this;
}

uint64_t dyld4::signPointer(uint64_t this, unint64_t a2, void *a3, BOOL a4, int a5, ptrauth_key a6)
{
  if (this)
  {
    switch(a5)
    {
      case 0:
        uint64_t v6 = this;
        break;
      case 1:
        uint64_t v6 = this;
        break;
      case 2:
        uint64_t v6 = this;
        break;
      case 3:
        uint64_t v6 = this;
        break;
      default:
        dyld4::signPointer();
    }
    return v6;
  }
  return this;
}

__n128 dyld4::JustInTimeLoader::fileID@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)(a1 + 56);
  long long v3 = *(_OWORD *)(a1 + 72);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t lsl::CRC32c::operator()(unsigned int *a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t))(**(void **)a1 + 16))(*(void *)a1, a1[2], a2);
  a1[2] = result;
  return result;
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, int *, uint64_t))(*(void *)this + 32))(this, a2, &v4, 4);
}

const void *dyld4::APIs::_dyld_get_prog_image_header(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(const void **)(v1 + 8);
  if (*(unsigned char *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_prog_image_header() => %p\n", v2);
  }
  return v2;
}

DyldSharedCache *dyld4::APIs::_dyld_shared_cache_real_path(DyldSharedCache ***this, const char *a2)
{
  int v4 = dyld4::ProcessConfig::canonicalDylibPathInCache(this[1], a2);
  uint64_t v5 = v4;
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_shared_cache_real_path(%s) => '%s'\n", a2, (const char *)v4);
  }
  return v5;
}

void dyld4::JustInTimeLoader::loadDependents(uint64_t a1, Diagnostics *a2, dyld4::RuntimeState *a3, long long *a4)
{
  if ((*(unsigned char *)(a1 + 42) & 1) == 0)
  {
    uint64_t v22 = 0;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2000000000;
    int v25 = 0;
    int v8 = *(mach_o::Error **)(a1 + 32);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = ___ZN5dyld416JustInTimeLoader14loadDependentsER11DiagnosticsRNS_12RuntimeStateERKNS_6Loader11LoadOptionsE_block_invoke;
    void v21[3] = &unk_1EFF64AF0;
    v21[4] = &v22;
    v21[5] = a1;
    v21[6] = a3;
    v21[7] = a4;
    v21[8] = a2;
    mach_o::Header::forEachLinkedDylib(v8, (uint64_t)v21);
    *(void *)(a1 + 40) |= 0x10000uLL;
    if (!Diagnostics::hasError(a2))
    {
      v20[0] = *((void *)a4 + 2);
      v20[1] = a1;
      long long v9 = a4[1];
      uint64_t v10 = *((void *)a4 + 4);
      long long v16 = *a4;
      uint64_t v18 = *((void *)&v9 + 1);
      uint64_t v19 = v10;
      unsigned int v17 = v20;
      uint64_t v11 = v23;
      *((_DWORD *)v23 + 6) = 0;
      unint64_t v12 = *(void *)(a1 + 40);
      if ((v12 & 0x7FFF8000000000) != 0)
      {
        int v13 = 0;
        do
        {
          uint64_t v14 = *(void *)(a1 + 8 * v13 + 464);
          if (v14)
          {
            dyld4::Loader::loadDependents(v14, a2, a3, &v16);
            uint64_t v11 = v23;
          }
          int v13 = *((_DWORD *)v11 + 6) + 1;
          *((_DWORD *)v11 + 6) = v13;
          unint64_t v12 = *(void *)(a1 + 40);
        }
        while (v13 < (unsigned __int16)(v12 >> 39));
      }
      if ((v12 & 0x400000) != 0)
      {
        *(void *)(a1 + 88) = dyld4::JustInTimeLoader::makePatchTable((dyld4::JustInTimeLoader *)a1, a3, (v12 >> 24) & 0x7FFF);
        *(void *)(a1 + 96) = 0;
        if (*(unsigned char *)(*((void *)a3 + 1) + 157))
        {
          unsigned int v15 = dyld4::Loader::indexOfUnzipperedTwin(a3, (const dyld4::RuntimeState *)(*(_DWORD *)(a1 + 43) & 0x7FFF));
          if (v15 != 0xFFFF) {
            *(void *)(a1 + 96) = dyld4::JustInTimeLoader::makePatchTable((dyld4::JustInTimeLoader *)a1, a3, v15);
          }
        }
      }
    }
    _Block_object_dispose(&v22, 8);
  }
}

void dyld4::Loader::loadDependents(uint64_t a1, vm_address_t *a2, dyld4::RuntimeState *a3, long long *a4)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::loadDependents();
  }
  if (*(_WORD *)(a1 + 4))
  {
    dyld4::PrebuiltLoader::loadDependents(a1, a2, a3, a4);
  }
  else
  {
    dyld4::JustInTimeLoader::loadDependents(a1, (Diagnostics *)a2, a3, a4);
  }
}

void dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(dyld4::RuntimeState *this, int a2)
{
  int v4 = dyld4::ProcessConfig::Process::environ((const char ***)(*((void *)this + 1) + 8), "DYLD_CLOSURE_DIR");
  uint64_t v5 = *((void *)this + 1);
  if (*(unsigned char *)(v5 + 169)) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    strlcpy(__dst, v4, 0x400uLL);
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "using DYLD_CLOSURE_DIR to find loaders\n");
    }
    goto LABEL_16;
  }
  int v7 = (char *)dyld4::ProcessConfig::Process::environ((const char ***)(v5 + 8), "HOME");
  int v8 = (dyld4::SyscallDelegate *)*((void *)this + 1);
  if (!v7)
  {
    if (!*((unsigned char *)v8 + 207)) {
      return;
    }
    int v13 = "did not look for saved PrebuiltLoaderSet because $DYLD_CLOSURE_DIR and $HOME are not set\n";
    goto LABEL_41;
  }
  BOOL isMaybeContainerized = dyld4::SyscallDelegate::isMaybeContainerized(v8, v7);
  uint64_t v10 = *((void *)this + 1);
  if (!isMaybeContainerized)
  {
    if (*(unsigned char *)(v10 + 169))
    {
      uint64_t v14 = dyld4::ProcessConfig::Process::environ((const char ***)(v10 + 8), "DYLD_USE_CLOSURES");
      unsigned int v15 = (dyld4::SyscallDelegate *)*((void *)this + 1);
      if (v14)
      {
        if (dyld4::SyscallDelegate::realpathdir(v15, (dyld3 *)v7, __dst))
        {
          strlcat(__dst, "/Library/Caches/com.apple.dyld/", 0x400uLL);
          strlcat(__dst, *(const char **)(*((void *)this + 1) + 136), 0x400uLL);
          strlcat(__dst, "/", 0x400uLL);
          if (!a2
            || dyld4::SyscallDelegate::dirExists(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)__dst, v16)
            || dyld4::SyscallDelegate::mkdirs(*((dyld4::SyscallDelegate **)this + 1), __dst))
          {
            unsigned int v17 = dyld4::ProcessConfig::Process::appleParam((const char ***)(*((void *)this + 1) + 8), "executable_cdhash");
            if (v17)
            {
              strlcat(__dst, v17, 0x400uLL);
              strlcat(__dst, "-", 0x400uLL);
            }
            uint64_t v18 = *(char **)(*((void *)this + 1) + 16);
            size_t v19 = _platform_strlen(v18);
            unint64_t v21 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)__source, (uint64_t *)v18, v19);
            uint64_t v23 = __source;
            int v22 = 8;
            do
            {
              dyld4::Loader::appendHexByte(v21, &v23, v20);
              v21 >>= 8;
              --v22;
            }
            while (v22);
            *uint64_t v23 = 0;
            unint64_t v12 = __source;
            goto LABEL_31;
          }
          goto LABEL_44;
        }
        goto LABEL_32;
      }
      if (!*((unsigned char *)v15 + 207)) {
        return;
      }
      int v13 = "did not look for saved PrebuiltLoaderSet because DYLD_USE_CLOSURES is not set\n";
    }
    else
    {
      if (!*(unsigned char *)(v10 + 207)) {
        return;
      }
      int v13 = "did not look for saved PrebuiltLoaderSet because $HOME is not containerized and this is not an internal install\n";
    }
LABEL_41:
    dyld4::RuntimeState::log(this, v13);
    return;
  }
  if (!dyld4::SyscallDelegate::realpathdir((dyld4::SyscallDelegate *)v10, (dyld3 *)v7, __dst))
  {
LABEL_32:
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME failed realpath\n");
    }
    return;
  }
  strlcat(__dst, "/Library/Caches/com.apple.dyld/", 0x400uLL);
  if (dyld4::SyscallDelegate::isContainerized(*((dyld4::SyscallDelegate **)this + 1), __dst))
  {
    if (!a2
      || dyld4::SyscallDelegate::dirExists(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)__dst, v11)
      || dyld4::SyscallDelegate::mkdirs(*((dyld4::SyscallDelegate **)this + 1), __dst))
    {
      unint64_t v12 = *(char **)(*((void *)this + 1) + 136);
LABEL_31:
      strlcat(__dst, v12, 0x400uLL);
      strlcat(__dst, ".dyld4", 0x400uLL);
LABEL_16:
      *((void *)this + 123) = lsl::Allocator::strdup(*((lsl::Lock ***)this + 2), __dst);
      return;
    }
LABEL_44:
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "failed to make directory for PrebuiltLoaderSet\n");
    }
    return;
  }
  if (*(unsigned char *)(*((void *)this + 1) + 207)) {
    dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME is not containerized\n");
  }
}

const char *dyld4::ProcessConfig::Process::environ(const char ***this, char *a2)
{
  return _simple_getenv(this[14], a2);
}

uint64_t mach_o::Header::linkedDylibCount(mach_o::Header *this, BOOL *a2)
{
  if (a2) {
    *a2 = 1;
  }
  uint64_t v5 = 0;
  BOOL v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK6mach_o6Header16linkedDylibCountEPb_block_invoke;
  void v4[3] = &unk_1EFF65728;
  v4[4] = &v5;
  void v4[5] = a2;
  mach_o::Header::forEachLinkedDylib(this, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void mach_o::Header::forEachLinkedDylib(mach_o::Error *a1, uint64_t a2)
{
  uint64_t v15 = 0;
  long long v16 = &v15;
  uint64_t v17 = 0x2000000000;
  int v18 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZNK6mach_o6Header18forEachLinkedDylibEU13block_pointerFvPKcNS_21LinkedDylibAttributesENS_9Version32ES4_RbE_block_invoke;
  void v10[3] = &unk_1EFF61F88;
  v10[4] = a2;
  v10[5] = &v15;
  v10[6] = &v11;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v10, (mach_o::Error *)v19);
  mach_o::Error::~Error(v19);
  if (!*((_DWORD *)v16 + 6) && !*((unsigned char *)v12 + 24))
  {
    mach_o::Header::platformAndVersions(a1, (uint64_t)v19);
    if (v19[0] == (vm_address_t *)&mach_o::PlatformInfo_driverKit::singleton)
    {
      if (*((_DWORD *)a1 + 3) != 6
        || ((v19[0] = 0,
             int v20 = 0x10000,
             int v21 = 0x10000,
             !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
          ? (int v8 = 0)
          : (int v8 = (const char *)v19[0]),
            _platform_strncmp(v8, "/System/DriverKit/usr/lib/system/", 0x21uLL)))
      {
        uint64_t v7 = "/System/DriverKit/usr/lib/libSystem.B.dylib";
        goto LABEL_23;
      }
    }
    else
    {
      mach_o::Header::platformAndVersions(a1, (uint64_t)v19);
      BOOL isExclaveKit = mach_o::Platform::isExclaveKit((mach_o::Platform *)v19);
      int v5 = *((_DWORD *)a1 + 3);
      if (isExclaveKit)
      {
        if (v5 != 6
          || ((v19[0] = 0,
               int v20 = 0x10000,
               int v21 = 0x10000,
               !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
            ? (BOOL v6 = 0)
            : (BOOL v6 = (const char *)v19[0]),
              _platform_strncmp(v6, "/System/ExclaveKit/usr/lib/system/", 0x22uLL)))
        {
          uint64_t v7 = "/System/ExclaveKit/usr/lib/libSystem.dylib";
LABEL_23:
          (*(void (**)(uint64_t, const char *, void, uint64_t, uint64_t, uint64_t *))(a2 + 16))(a2, v7, 0, 0x10000, 0x10000, v12 + 3);
        }
      }
      else if (v5 != 6 {
             || ((v19[0] = 0,
      }
                  int v20 = 0x10000,
                  int v21 = 0x10000,
                  !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
               ? (long long v9 = 0)
               : (long long v9 = (const char *)v19[0]),
                 _platform_strncmp(v9, "/usr/lib/system/", 0x10uLL)))
      {
        uint64_t v7 = "/usr/lib/libSystem.B.dylib";
        goto LABEL_23;
      }
    }
  }
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
}

mach_o::Error *mach_o::Header::forEachLoadCommand@<X0>(mach_o::Error *result@<X0>, uint64_t a2@<X1>, mach_o::Error *a3@<X8>)
{
  int v4 = result;
  int v6 = *(_DWORD *)result;
  if (*(_DWORD *)result == -17958193)
  {
    uint64_t v7 = 32;
  }
  else
  {
    if (v6 != -17958194)
    {
      if ((v6 & 0xFEFFFFFF) != 0xCEFAEDFE) {
        return mach_o::Error::Error(a3, "file does not start with MH_MAGIC[_64]: 0x%08X 0x%08X");
      }
      return mach_o::Error::Error(a3, "big endian mach-o file");
    }
    uint64_t v7 = 28;
  }
  if (*((_DWORD *)result + 3) >= 0xDu) {
    return mach_o::Error::Error(a3, "unknown mach-o filetype (%u)");
  }
  if (*((_DWORD *)result + 4))
  {
    int v8 = (char *)result + v7;
    long long v9 = (char *)result + v7 + *((unsigned int *)result + 5);
    unsigned int v10 = 1;
    uint64_t v11 = (char *)result + v7;
    while (1)
    {
      if (v11 >= v9) {
        return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, off end of load commands");
      }
      uint64_t v12 = *((unsigned int *)v11 + 1);
      if (v12 <= 7) {
        return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, size (0x%X) too small");
      }
      uint64_t v13 = &v11[v12];
      if (&v11[v12] > v9 || v13 < v8) {
        return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, size (0x%X) is too large, load commands end at %p");
      }
      uint64_t result = (mach_o::Error *)(*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
      ++v10;
      uint64_t v11 = v13;
      if (v10 > *((_DWORD *)v4 + 4)) {
        goto LABEL_21;
      }
    }
  }
  else
  {
LABEL_21:
    *(void *)a3 = 0;
  }
  return result;
}

uint64_t ___ZNK6mach_o6Header18forEachLinkedDylibEU13block_pointerFvPKcNS_21LinkedDylibAttributesENS_9Version32ES4_RbE_block_invoke(uint64_t result, mach_o::Header *this, unsigned char *a3)
{
  if ((*(_DWORD *)this + 2147483624) <= 0xB && ((1 << (*(_DWORD *)this - 24)) & 0x881) != 0
    || *(_DWORD *)this == 12)
  {
    uint64_t v7 = result;
    int v8 = (char *)this + *((unsigned int *)this + 2);
    uint64_t v9 = *(void *)(result + 32);
    unsigned __int8 CommandToDylibKind = mach_o::Header::loadCommandToDylibKind(this, (const dylib_command *)this);
    uint64_t result = (*(uint64_t (**)(uint64_t, char *, void, void, void, unsigned char *))(v9 + 16))(v9, v8, CommandToDylibKind, *((unsigned int *)this + 5), *((unsigned int *)this + 4), a3);
    ++*(_DWORD *)(*(void *)(*(void *)(v7 + 40) + 8) + 24);
    if (*a3) {
      *(unsigned char *)(*(void *)(*(void *)(v7 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

uint64_t mach_o::Header::loadCommandToDylibKind(mach_o::Header *this, const dylib_command *a2)
{
  if (*((_DWORD *)this + 3) == 443815936 && *((_DWORD *)this + 2) == 28) {
    return *((unsigned int *)this + 6);
  }
  int v3 = *(_DWORD *)this;
  if (*(int *)this > -2147483614)
  {
    if (v3 == -2147483613)
    {
      return 4;
    }
    else
    {
      if (v3 != 12) {
        goto LABEL_14;
      }
      return 0;
    }
  }
  else
  {
    if (v3 != -2147483624)
    {
      if (v3 == -2147483617) {
        return 2;
      }
LABEL_14:
      mach_o::Header::loadCommandToDylibKind();
    }
    return 1;
  }
}

uint64_t ___ZNK6mach_o6Header16linkedDylibCountEPb_block_invoke(uint64_t result, uint64_t a2, char a3)
{
  int v3 = *(unsigned char **)(result + 40);
  if (v3) {
    BOOL v4 = a3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    unsigned char *v3 = 0;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24);
  return result;
}

void ___ZN5dyld416JustInTimeLoader14loadDependentsER11DiagnosticsRNS_12RuntimeStateERKNS_6Loader11LoadOptionsE_block_invoke(uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  int v9 = a3;
  uint64_t v10 = *(void *)(a1 + 40);
  if ((~a3 & 0xA) == 0) {
    int v9 = a3 & 0xF7;
  }
  if ((~v9 & 3) != 0) {
    char v11 = v9;
  }
  else {
    char v11 = v9 & 0xFE;
  }
  if ((*(unsigned char *)(v10 + 42) & 0x80) == 0) {
    *(unsigned char *)dyld4::JustInTimeLoader::dependentAttrs(*(dyld4::JustInTimeLoader **)(a1 + 40), *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) = v11;
  }
  char v12 = v11 & 1;
  if ((*(_WORD *)(v10 + 4) & 2) != 0
    && (v11 & 1) != 0
    && (uint64_t v13 = *(void *)(*(void *)(a1 + 48) + 8),
        uint64_t v15 = *(void *)(v13 + 240),
        char v14 = (DyldSharedCache **)(v13 + 240),
        *(_DWORD *)uint64_t v43 = 0,
        v15)
    && (dyld4::ProcessConfig::DyldCache::indexOfPath(v14, a2, (unsigned int *)v43) & 1) == 0)
  {
    int v22 = *(dyld4::RuntimeState **)(a1 + 48);
    if (*(unsigned char *)(*((void *)v22 + 1) + 207))
    {
      if (*(_WORD *)(v10 + 40)) {
        uint64_t v23 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
      }
      else {
        uint64_t v23 = 0;
      }
      dyld4::RuntimeState::log(v22, "Skipping shared cache weak-linked dylib '%s' from '%s'\n", a2, v23);
    }
    uint64_t v24 = v10 + 8 * *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v25 = 0;
  }
  else
  {
    if (*a2 != 47) {
      goto LABEL_25;
    }
    uint64_t v16 = *(void *)(a1 + 48);
    uint64_t v17 = *(void *)(v16 + 48);
    if (!v17) {
      goto LABEL_25;
    }
    int v18 = *(dyld4::Loader ***)(v16 + 40);
    uint64_t v19 = 8 * v17;
    int v20 = v18;
    while (1)
    {
      int v21 = *v20;
      if (dyld4::Loader::matchesPath(*v20, *(const dyld4::RuntimeState **)(a1 + 48), a2)) {
        break;
      }
      ++v20;
      ++v18;
      v19 -= 8;
      if (!v19) {
        goto LABEL_25;
      }
    }
    if (!v21)
    {
LABEL_25:
      v42[0] = *(void *)(*(void *)(a1 + 56) + 16);
      v42[1] = v10;
      Diagnostics::Diagnostics((Diagnostics *)&v41);
      unint64_t v26 = *(long long **)(a1 + 56);
      long long v27 = *v26;
      long long v28 = v26[1];
      uint64_t v40 = *((void *)v26 + 4);
      long long v38 = v27;
      long long v39 = v28;
      BYTE11(v38) = *(unsigned char *)(v10 + 5) & 1;
      *(void *)&long long v39 = v42;
      BYTE2(v38) = v12;
      uint64_t v29 = *((void *)v26 + 3);
      if (v29) {
        Loader = (dyld4::Loader *)(*(uint64_t (**)(uint64_t, vm_address_t **, void, char *, long long *))(v29 + 16))(v29, &v41, *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8) + 68), a2, &v38);
      }
      else {
        Loader = dyld4::Loader::getLoader(&v41, *(DyldSharedCache ****)(a1 + 48), a2, (uint64_t)&v38);
      }
      int v21 = Loader;
      if (Diagnostics::hasError((Diagnostics *)&v41))
      {
        dyld4::Loader::getUuidStr((unsigned __int8 *)v10, v43, v31);
        Diagnostics::Diagnostics((Diagnostics *)&v37);
        dyld4::Loader::tooNewErrorAddendum((dyld4::Loader *)v10, (Diagnostics *)&v37, *(dyld4::RuntimeState **)(a1 + 48));
        uint64_t v32 = *(vm_address_t **)(a1 + 64);
        if (*(_WORD *)(v10 + 40)) {
          uint64_t v33 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
        }
        else {
          uint64_t v33 = 0;
        }
        int v34 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v37);
        uint64_t v35 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v41);
        Diagnostics::error(v32, "Library not loaded: %s\n  Referenced from: <%s> %s%s\n  Reason: %s", a2, v43, v33, v34, v35);
        if (**(unsigned char **)(a1 + 56))
        {
          if (*(_WORD *)(v10 + 40)) {
            uint64_t v36 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
          }
          else {
            uint64_t v36 = 0;
          }
          dyld4::RuntimeState::setLaunchMissingDylib(*(void **)(a1 + 48), a2, v36);
        }
        *a6 = 1;
        mach_o::Error::~Error(&v37);
      }
      mach_o::Error::~Error(&v41);
    }
    uint64_t v24 = v10 + 8 * *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v25 = v21;
  }
  *(void *)(v24 + 464) = v25;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL dyld4::SyscallDelegate::realpath(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3)
{
  BOOL v4 = (const char *)a2;
  int v5 = dyld3::open(a2, 0, 0);
  if (v5 == -1)
  {
    strlcpy(__dst, v4, 0x400uLL);
    int v8 = strrchr(__dst, 47);
    if (v8)
    {
      *int v8 = 0;
      v4 += v8 - __dst + 1;
    }
    else
    {
      strcpy(__dst, ".");
    }
    int v9 = dyld3::open((dyld3 *)__dst, (const char *)0x100000, 0);
    if (v9 == -1) {
      return 0;
    }
    int v10 = v9;
    int v11 = fcntl(v9, 50, a3);
    close(v10);
    if (v11)
    {
      return 0;
    }
    else
    {
      strlcat(a3, "/", 0x400uLL);
      strlcat(a3, v4, 0x400uLL);
      return 1;
    }
  }
  else
  {
    int v6 = v5;
    BOOL v7 = fcntl(v5, 50, a3) == 0;
    close(v6);
  }
  return v7;
}

BOOL dyld4::APIs::_dyld_shared_cache_contains_path(DyldSharedCache ***this, const char *a2)
{
  BOOL v4 = dyld4::ProcessConfig::canonicalDylibPathInCache(this[1], a2);
  int v5 = v4;
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_shared_cache_contains_path(%s) => %d\n", a2, v4 != 0);
  }
  return v5 != 0;
}

dyld4::Loader *dyld4::Loader::getLoader(vm_address_t **a1, DyldSharedCache ***a2, const char *a3, uint64_t a4)
{
  int v5 = (char *)a3;
  uint64_t v73 = 0;
  uint64_t v74 = &v73;
  uint64_t v75 = 0x2000000000;
  uint64_t v76 = 0;
  int v8 = a2[1];
  if (v8[30]) {
    BOOL v9 = *((unsigned char *)v8 + 396) == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (*((unsigned char *)v8 + 208)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "find path \"%s\"\n", a3);
  }
  int v10 = _platform_strncmp(v5, "@rpath/", 7uLL);
  int v11 = *v5;
  if (v11 == 47)
  {
    BOOL v13 = 0;
    if (!v10) {
      goto LABEL_38;
    }
  }
  else if (v11 == 46 && ((int v12 = v5[1], v12 == 47) || v12 == 46 && v5[2] == 47))
  {
    BOOL v13 = 1;
    if (!v10)
    {
LABEL_38:
      BOOL v63 = v13;
      BOOL v64 = v9;
      uint64_t v65 = a4;
      uint64_t v29 = a1;
      uint64_t v30 = 0;
      uint64_t v77 = a2 + 4;
      uint64_t v78 = (DyldSharedCache ****)(a2 + 8);
      while (1)
      {
        uint64_t v31 = (&v77)[v30];
        uint64_t v32 = v31[2];
        if (v32) {
          break;
        }
LABEL_43:
        if (++v30 == 2) {
          goto LABEL_44;
        }
      }
      uint64_t v33 = v31[1];
      uint64_t v34 = 8 * (void)v32;
      uint64_t v35 = v33;
      while (1)
      {
        uint64_t v36 = *v35;
        if (dyld4::Loader::matchesPath(*v35, (const dyld4::RuntimeState *)a2, v5)) {
          break;
        }
        ++v35;
        ++v33;
        v34 -= 8;
        if (!v34) {
          goto LABEL_43;
        }
      }
      if (*((unsigned char *)a2[1] + 208))
      {
        uint64_t v37 = (const char *)dyld4::Loader::path(v36, (const dyld4::RuntimeState *)a2);
        dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found: already-loaded-by-rpath: %s\n", v37);
      }
      goto LABEL_88;
    }
  }
  else
  {
    BOOL v13 = v11 != 64;
    if (!v10) {
      goto LABEL_38;
    }
  }
  if (*(unsigned char *)(a4 + 1) || v11 == 47 || v11 == 64 || _platform_strchr(v5, 47))
  {
LABEL_15:
    char v14 = dyld4::ProcessConfig::canonicalDylibPathInCache(a2[1], v5);
    if (v14)
    {
      uint64_t v15 = (const char *)v14;
      if (_platform_strcmp((const char *)v14, v5))
      {
        if (*((unsigned char *)a2[1] + 208)) {
          dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  switch to canonical cache path: %s\n", v15);
        }
        int v5 = (char *)v15;
      }
    }
    v71[0] = 0;
    v71[1] = v71;
    v71[2] = 0x2000000000;
    unsigned int v72 = 0;
    unsigned int v16 = dyld4::ProcessConfig::DyldCache::indexOfPath(a2[1] + 30, v5, &v72);
    isOverridableuint64_t Path = 0;
    if (v16) {
      isOverridableuint64_t Path = dyld4::ProcessConfig::DyldCache::isOverridablePath((dyld4::ProcessConfig::DyldCache *)(a2[1] + 30), v5);
    }
    v67[0] = _NSConcreteStackBlock;
    v67[1] = 0x40000000;
    v67[2] = ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke;
    v67[3] = &unk_1EFF645D8;
    BOOL v68 = v9;
    char v69 = v16;
    BOOL v70 = isOverridablePath;
    v67[6] = v5;
    v67[7] = a2;
    v67[8] = a4;
    v67[9] = a1;
    v67[4] = &v73;
    v67[5] = v71;
    dyld4::Loader::forEachPath(isOverridablePath, (uint64_t)a2, (dyld4::Utils *)v5, a4, (uint64_t)v67);
    if (!v74[3])
    {
      int v18 = (dyld4::SyscallDelegate *)a2[1];
      char v19 = !v13;
      if (*((unsigned char *)v18 + 186)) {
        char v19 = 1;
      }
      if (v19)
      {
        if ((*(unsigned char *)(a4 + 1) || _platform_strchr(v5, 47))
          && *v5 != 64
          && dyld4::SyscallDelegate::realpath(v18, (dyld3 *)v5, (char *)&v77))
        {
          size_t v55 = _platform_strlen((const char *)&v77);
          if (_platform_strncmp(v5, (const char *)&v77, v55))
          {
            if (*((unsigned char *)a2[1] + 208)) {
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  switch to realpath: \"%s\"\n", (const char *)&v77);
            }
            uint64_t Loader = dyld4::Loader::getLoader(a1, a2, &v77, a4);
            v74[3] = Loader;
          }
        }
      }
      else
      {
        uint64_t v65 = a4;
        int v20 = a1;
        uint64_t v21 = 0;
        uint64_t v77 = a2 + 4;
        uint64_t v78 = (DyldSharedCache ****)(a2 + 8);
        do
        {
          int v22 = (&v77)[v21];
          uint64_t v23 = v22[2];
          if (v23)
          {
            uint64_t v24 = v22[1];
            uint64_t v25 = 8 * (void)v23;
            unint64_t v26 = v24;
            while (1)
            {
              long long v27 = *v26;
              if (dyld4::Loader::matchesPath(*v26, (const dyld4::RuntimeState *)a2, v5)) {
                break;
              }
              ++v26;
              ++v24;
              v25 -= 8;
              if (!v25) {
                goto LABEL_35;
              }
            }
            if (*((unsigned char *)a2[1] + 208))
            {
              long long v28 = (const char *)dyld4::Loader::path(v27, (const dyld4::RuntimeState *)a2);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found existing image by install name: \"%s\"\n", v28);
            }
            v74[3] = (uint64_t)v27;
            Diagnostics::clearError(v20);
          }
LABEL_35:
          ++v21;
        }
        while (v21 != 2);
        a1 = v20;
        a4 = v65;
      }
    }
    uint64_t v57 = v74;
    if (*((unsigned char *)a2[1] + 208) && !v74[3])
    {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  not found: \"%s\"\n", v5);
      uint64_t v57 = v74;
    }
    if (!v57[3])
    {
      if (*v5 != 64
        || *((unsigned char *)a2[1] + 184)
        || (Diagnostics::appendError((vm_address_t *)a1, ", (security policy does not allow @ path expansion)"), !v74[3]))
      {
        if (*(unsigned __int8 *)(a4 + 2) | *(unsigned __int8 *)(a4 + 5))
        {
          Diagnostics::clearError(a1);
        }
        else if (Diagnostics::noError((Diagnostics *)a1) && !_platform_strncmp(v5, "@rpath/", 7uLL))
        {
          uint64_t v77 = 0;
          uint64_t v78 = &v77;
          uint64_t v79 = 0x2000000000;
          char v80 = 0;
          uint64_t v58 = *(uint64_t ***)(a4 + 16);
          if (v58)
          {
            while (!*((unsigned char *)v78 + 24))
            {
              uint64_t v59 = (_DWORD *)dyld4::Loader::mf((dyld4::Loader *)v58[1], (const dyld4::RuntimeState *)a2);
              v66[0] = _NSConcreteStackBlock;
              v66[1] = 0x40000000;
              v66[2] = ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke_2;
              v66[3] = &unk_1EFF64600;
              v66[4] = &v77;
              dyld3::MachOFile::forEachRPath(v59, (uint64_t)v66);
              uint64_t v58 = (uint64_t **)*v58;
              if (!v58)
              {
                if (!*((unsigned char *)v78 + 24)) {
                  goto LABEL_85;
                }
                break;
              }
            }
            Diagnostics::error((vm_address_t *)a1, "no LC_RPATH's used.  They may be invalid, eg, not start with '@loader_path' or '@executable_path'");
          }
          else
          {
LABEL_85:
            Diagnostics::error((vm_address_t *)a1, "no LC_RPATH's found");
          }
          _Block_object_dispose(&v77, 8);
        }
      }
    }
    uint64_t v36 = (dyld4::Loader *)v74[3];
    _Block_object_dispose(v71, 8);
  }
  else
  {
    BOOL v63 = v13;
    BOOL v64 = v9;
    uint64_t v65 = a4;
    uint64_t v29 = a1;
    size_t v38 = _platform_strlen(v5);
    v62[1] = (uint64_t)v62;
    size_t v39 = v38 + 8;
    __chkstk_darwin(v38, v40, v41, v42, v43, v44, v45, v46, v62[0]);
    uint64_t v48 = (char *)v62 - ((v47 + 23) & 0xFFFFFFFFFFFFFFF0);
    strlcpy(v48, "@rpath/", v39);
    strlcat(v48, v5, v39);
    uint64_t v49 = 0;
    uint64_t v77 = a2 + 4;
    uint64_t v78 = (DyldSharedCache ****)(a2 + 8);
    while (1)
    {
      uint64_t v50 = (&v77)[v49];
      uint64_t v51 = v50[2];
      if (v51) {
        break;
      }
LABEL_55:
      if (++v49 == 2)
      {
LABEL_44:
        a1 = v29;
        a4 = v65;
        LOBYTE(v13) = v63;
        LOBYTE(v9) = v64;
        goto LABEL_15;
      }
    }
    uint64_t v52 = v50[1];
    uint64_t v53 = 8 * (void)v51;
    uint64_t v54 = v52;
    while (1)
    {
      uint64_t v36 = *v54;
      if (dyld4::Loader::matchesPath(*v54, (const dyld4::RuntimeState *)a2, v48)) {
        break;
      }
      ++v54;
      ++v52;
      v53 -= 8;
      if (!v53) {
        goto LABEL_55;
      }
    }
    if (*((unsigned char *)a2[1] + 208))
    {
      uint64_t v60 = (const char *)dyld4::Loader::path(v36, (const dyld4::RuntimeState *)a2);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found: already-loaded-by-rpath: %s\n", v60);
    }
  }
LABEL_88:
  _Block_object_dispose(&v73, 8);
  return v36;
}

DyldSharedCache *dyld4::ProcessConfig::DyldCache::getCanonicalPath(DyldSharedCache **this, const char *a2)
{
  uint64_t result = *this;
  if (result)
  {
    unsigned int v4 = 0;
    if (DyldSharedCache::hasImagePath(result, a2, &v4)) {
      return (DyldSharedCache *)DyldSharedCache::getIndexedImagePath(*this, v4);
    }
    else {
      return 0;
    }
  }
  return result;
}

DyldSharedCache *dyld4::ProcessConfig::canonicalDylibPathInCache(DyldSharedCache **this, const char *a2)
{
  return dyld4::ProcessConfig::DyldCache::getCanonicalPath(this + 30, a2);
}

BOOL dyld4::ProcessConfig::DyldCache::isOverridablePath(dyld4::ProcessConfig::DyldCache *this, const char *__s1)
{
  return *((unsigned char *)this + 156) || _platform_strcmp(__s1, "/usr/lib/system/libdispatch.dylib") == 0;
}

uint64_t DyldSharedCache::getIndexedImagePath(DyldSharedCache *this, int a2)
{
  uint64_t v2 = 24;
  if (*((_DWORD *)this + 4) > 0x1C3u) {
    uint64_t v2 = 448;
  }
  return (uint64_t)this + *(unsigned int *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v2) + 24);
}

void dyld4::Loader::forEachPath(int a1, uint64_t a2, dyld4::Utils *__s, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = 0;
  int v18 = &v17;
  uint64_t v19 = 0x2000000000;
  char v20 = 0;
  uint64_t v9 = *(void *)(a2 + 8);
  if (*(unsigned char *)(a4 + 1))
  {
    BOOL v10 = 0;
    uint64_t v11 = *(void *)(a2 + 8);
    int v12 = &v17;
  }
  else if (_platform_strchr((char *)__s, 47))
  {
    BOOL v10 = dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath((dyld4::ProcessConfig::PathOverrides *)(v9 + 400), __s, v13) == 0;
    uint64_t v11 = *(void *)(a2 + 8);
    int v12 = v18;
  }
  else
  {
    BOOL v10 = 0;
    int v12 = &v17;
    uint64_t v11 = v9;
  }
  char v14 = (const char *)*(unsigned int *)(v11 + 68);
  int v15 = *(unsigned __int8 *)(a4 + 11);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = ___ZN5dyld46Loader11forEachPathER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsEU13block_pointerFvS6_NS_13ProcessConfig13PathOverrides4TypeERbE_block_invoke;
  v16[3] = &unk_1EFF645B0;
  v16[6] = a4;
  void v16[7] = __s;
  v16[8] = a2;
  void v16[4] = a5;
  v16[5] = &v17;
  dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v9 + 400, __s, v14, v15, v10, (unsigned char *)v12 + 24, (uint64_t)v16);
  _Block_object_dispose(&v17, 8);
}

const char *dyld4::ProcessConfig::PathOverrides::forEachPathVariant(uint64_t a1, dyld4::Utils *a2, const char *a3, int a4, int a5, unsigned char *a6, uint64_t a7)
{
  int v101 = a5;
  unsigned int v10 = a3;
  uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath((dyld4::ProcessConfig::PathOverrides *)a1, a2, a3);
  char v14 = result;
  if (result)
  {
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = *(void *)(a1 + 56);
    if (!(v15 | v16)) {
      goto LABEL_10;
    }
    v105[0] = _NSConcreteStackBlock;
    v105[1] = 0x40000000;
    v105[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke;
    v105[3] = &unk_1EFF639F8;
    v105[6] = _platform_strlen(result);
    v105[7] = v14;
    v105[8] = a6;
    v105[4] = a7;
    v105[5] = a1;
    uint64_t v17 = v105;
    uint64_t v18 = v15;
    uint64_t v19 = v16;
  }
  else
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v21 = *(void *)(a1 + 48);
    if (!(*(void *)a1 | v21)) {
      goto LABEL_10;
    }
    int v22 = strrchr((char *)a2, 47);
    uint64_t v100 = a6;
    uint64_t v23 = a7;
    unsigned int v24 = v10;
    int v25 = a4;
    if (v22) {
      unint64_t v26 = v22 + 1;
    }
    else {
      unint64_t v26 = (const char *)a2;
    }
    v104[0] = _NSConcreteStackBlock;
    v104[1] = 0x40000000;
    v104[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_2;
    v104[3] = &unk_1EFF63A20;
    v104[6] = _platform_strlen(v26);
    v104[7] = v26;
    a4 = v25;
    unsigned int v10 = v24;
    a7 = v23;
    char v14 = 0;
    a6 = v100;
    v104[8] = v100;
    v104[4] = a7;
    v104[5] = a1;
    uint64_t v17 = v104;
    uint64_t v18 = v20;
    uint64_t v19 = v21;
  }
  uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachInColonList(v18, v19, a6, (uint64_t)v17);
LABEL_10:
  if (*a6) {
    return result;
  }
  uint64_t v27 = a1 + 128;
  while (1)
  {
    uint64_t v27 = *(void *)v27;
    if (!v27) {
      break;
    }
    if (!_platform_strcmp(*(const char **)(v27 + 8), (const char *)a2)) {
      return (const char *)(*(uint64_t (**)(uint64_t, void, uint64_t, unsigned char *))(a7 + 16))(a7, *(void *)(v27 + 16), 1, a6);
    }
  }
  if (*(unsigned char *)a2 == 64) {
    goto LABEL_17;
  }
  if (v10 == 6)
  {
    int v29 = _platform_strncmp((const char *)a2, "/System/iOSSupport/", 0x13uLL);
    if (*(void *)(a1 + 120))
    {
      if (v29)
      {
        size_t v30 = _platform_strlen((const char *)a2);
        size_t v31 = v30 + 26;
        __chkstk_darwin(v30, v32, v33, v34, v35, v36, v37, v38, (uint64_t)v100);
        LODWORD(v10dyld4::halt((char *)__format, 0) = a4;
        uint64_t v40 = (char *)&v100 - ((v39 + 41) & 0xFFFFFFFFFFFFFFF0);
        strlcpy(v40, "/System/iOSSupport", v31);
        strlcat(v40, (const char *)a2, v31);
        uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)v40, 3, a6, a7);
        if (*a6) {
          return result;
        }
        size_t v41 = _platform_strlen(*(const char **)(a1 + 120));
        size_t v42 = _platform_strlen((const char *)a2);
        size_t v43 = v41 + v42 + 26;
        __chkstk_darwin(v42, v44, v45, v46, v47, v48, v49, v50, (uint64_t)v100);
        uint64_t v52 = (char *)&v100 - v51;
        strlcpy((char *)&v100 - v51, *(const char **)(a1 + 120), v43);
        strlcat(v52, "/System/iOSSupport", v43);
        strlcat(v52, (const char *)a2, v43);
        uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)v52, 6, a6, a7);
        if (*a6) {
          return result;
        }
        size_t v53 = _platform_strlen((const char *)a2);
        size_t v54 = v53 + 26;
        __chkstk_darwin(v53, v55, v56, v57, v58, v59, v60, v61, (uint64_t)v100);
        BOOL v63 = (char *)&v100 - ((v62 + 41) & 0xFFFFFFFFFFFFFFF0);
        strlcpy(v63, "/System/iOSSupport", v54);
        strlcat(v63, (const char *)a2, v54);
        uint64_t v64 = (uint64_t)v63;
        a4 = (int)v100;
        uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, v64, 4, a6, a7);
        if (*a6) {
          return result;
        }
      }
      goto LABEL_29;
    }
    if (v29)
    {
      size_t v88 = _platform_strlen((const char *)a2);
      size_t v89 = v88 + 26;
      __chkstk_darwin(v88, v90, v91, v92, v93, v94, v95, v96, (uint64_t)&v100);
      uint64_t v75 = a6;
      int v98 = a4;
      uint64_t v99 = (char *)&v100 - ((v97 + 41) & 0xFFFFFFFFFFFFFFF0);
      strlcpy(v99, "/System/iOSSupport", v89);
      strlcat(v99, (const char *)a2, v89);
      uint64_t v82 = a1;
      uint64_t v83 = (uint64_t)v99;
      a4 = v98;
      unsigned int v10 = 6;
      uint64_t v84 = 4;
      goto LABEL_37;
    }
  }
  else if (*(void *)(a1 + 120))
  {
LABEL_29:
    uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)a2, 8, a6, a7);
    if (*a6) {
      return result;
    }
    size_t v65 = _platform_strlen(*(const char **)(a1 + 120));
    size_t v66 = _platform_strlen((const char *)a2);
    size_t v67 = v65 + v66 + 8;
    __chkstk_darwin(v66, v68, v69, v70, v71, v72, v73, v74, (uint64_t)&v100);
    uint64_t v75 = a6;
    uint64_t v76 = v14;
    uint64_t v77 = a7;
    unsigned int v78 = v10;
    int v79 = a4;
    uint64_t v81 = (char *)&v100 - v80;
    strlcpy((char *)&v100 - v80, *(const char **)(a1 + 120), v67);
    strlcat(v81, (const char *)a2, v67);
    uint64_t v82 = a1;
    uint64_t v83 = (uint64_t)v81;
    a4 = v79;
    unsigned int v10 = v78;
    a7 = v77;
    char v14 = v76;
    a6 = v75;
    uint64_t v84 = 7;
LABEL_37:
    uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v82, v83, v84, v75, a7);
    if (*v75) {
      return result;
    }
  }
LABEL_17:
  uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)a2, 9, a6, a7);
  if (!*a6 && (v101 & 1) == 0)
  {
    if (v14)
    {
      size_t v28 = _platform_strlen(v14);
      v103[0] = _NSConcreteStackBlock;
      v103[1] = 0x40000000;
      v103[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_3;
      v103[3] = &unk_1EFF63A48;
      v103[6] = v28;
      v103[7] = v14;
      v103[8] = a2;
      v103[9] = a6;
      v103[4] = a7;
      v103[5] = a1;
      return (const char *)dyld4::ProcessConfig::PathOverrides::forEachFrameworkFallback(a1, v10, a4, a6, (uint64_t)v103);
    }
    else
    {
      uint64_t v85 = strrchr((char *)a2, 47);
      if (v85) {
        int v86 = v85 + 1;
      }
      else {
        int v86 = (const char *)a2;
      }
      size_t v87 = _platform_strlen(v86);
      v102[0] = _NSConcreteStackBlock;
      v102[1] = 0x40000000;
      v102[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_4;
      v102[3] = &unk_1EFF63A70;
      v102[6] = v87;
      v102[7] = v86;
      v102[8] = a2;
      v102[9] = a6;
      v102[4] = a7;
      v102[5] = a1;
      return (const char *)dyld4::ProcessConfig::PathOverrides::forEachDylibFallback(a1, v10, a4, a6, (uint64_t)v102);
    }
  }
  return result;
}

void dyld4::Loader::forEachResolvedAtPathVar(const dyld4::RuntimeState *a1, char *__s1, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6)
{
  int v12 = _platform_strncmp(__s1, "@rpath/", 7uLL);
  if (v12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = *(unsigned char *)(a3 + 6) == 0;
  }
  if (v13)
  {
    int v14 = v12;
    if (dyld4::Loader::expandAtLoaderPath(a1, __s1, a3, *(dyld4::Loader **)(*(void *)(a3 + 16) + 8), 0, v23))
    {
      (*(void (**)(uint64_t, char *, uint64_t, unsigned char *))(a6 + 16))(a6, v23, 11, a5);
    }
    else if (dyld4::Loader::expandAtExecutablePath(a1, __s1, v15, 0, v23))
    {
      (*(void (**)(uint64_t, char *, uint64_t, unsigned char *))(a6 + 16))(a6, v23, 12, a5);
    }
    else
    {
      if (v14) {
        goto LABEL_22;
      }
      if (a4 == 13) {
        int v17 = 13;
      }
      else {
        int v17 = 10;
      }
      uint64_t v18 = *(uint64_t ***)(a3 + 16);
      for (BOOL i = *a5 == 0; v18 && !*a5; BOOL i = *a5 == 0)
      {
        uint64_t v20 = (_DWORD *)dyld4::Loader::mf((dyld4::Loader *)v18[1], a1);
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 0x40000000;
        v21[2] = ___ZN5dyld46Loader24forEachResolvedAtPathVarERNS_12RuntimeStateEPKcRKNS0_11LoadOptionsENS_13ProcessConfig13PathOverrides4TypeERbU13block_pointerFvS4_SA_SB_E_block_invoke;
        void v21[3] = &unk_1EFF64628;
        v21[6] = v18;
        v21[7] = a3;
        v21[8] = v23;
        void v21[9] = __s1 + 6;
        v21[4] = a6;
        v21[5] = a1;
        int v22 = v17;
        v21[10] = a5;
        dyld3::MachOFile::forEachRPath(v20, (uint64_t)v21);
        uint64_t v18 = (uint64_t **)*v18;
      }
      if (i)
      {
LABEL_22:
        if (*__s1 != 64) {
          (*(void (**)(uint64_t, char *, uint64_t, unsigned char *))(a6 + 16))(a6, __s1, a4, a5);
        }
      }
    }
  }
  else
  {
    uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t, unsigned char *))(a6 + 16);
    v16(a6, __s1, a4, a5);
  }
}

char *dyld4::Loader::expandAtExecutablePath(dyld4::RuntimeState *a1, char *__s1, uint64_t a3, uint64_t a4, char *a5)
{
  if (_platform_strncmp(__s1, "@executable_path", 0x10uLL)) {
    return 0;
  }
  int v10 = __s1[16];
  if (v10 != 47 && v10 != 0) {
    return 0;
  }
  uint64_t v12 = *((void *)a1 + 1);
  if (!*(unsigned char *)(v12 + 184))
  {
    if (*(unsigned char *)(v12 + 208)) {
      dyld4::RuntimeState::log(a1, "    @executable_path not expanded due to security policy\n");
    }
    return 0;
  }
  BOOL v13 = *(dyld4::Loader **)(v12 + 16);

  return dyld4::Loader::expandAndNormalizeAtExecutablePath(v13, __s1, a5, v8);
}

uint64_t dyld4::Loader::expandAtLoaderPath(dyld4::RuntimeState *a1, char *__s1, uint64_t a3, dyld4::Loader *a4, int a5, char *a6)
{
  if (_platform_strncmp(__s1, "@loader_path", 0xCuLL)) {
    return 0;
  }
  int v15 = __s1[12];
  int v14 = __s1 + 12;
  int v13 = v15;
  if (v15 != 47 && v13 != 0) {
    return 0;
  }
  uint64_t v17 = *((void *)a1 + 1);
  if (*(unsigned char *)(a3 + 6))
  {
    if (*(unsigned char *)(v17 + 208)) {
      dyld4::RuntimeState::log(a1, "    @loader_path not allowed in DYLD_INSERT_LIBRARIES\n");
    }
    return 0;
  }
  if (*(unsigned char *)(v17 + 184)) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = a5 == 0;
  }
  if (!v18 && *((void *)a1 + 3) == (void)a4)
  {
    if (*(unsigned char *)(v17 + 208)) {
      dyld4::RuntimeState::log(a1, "    @loader_path in LC_RPATH from main executable not expanded due to security policy\n");
    }
    return 0;
  }
  uint64_t v20 = (const char *)dyld4::Loader::path(a4, a1);
  strlcpy(a6, v20, 0x400uLL);
  uint64_t result = (uint64_t)strrchr(a6, 47);
  if (result)
  {
    strlcpy((char *)result, v14, (size_t)&a6[-result + 1024]);
    return 1;
  }
  return result;
}

void ___ZN5dyld46Loader11forEachPathER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsEU13block_pointerFvS6_NS_13ProcessConfig13PathOverrides4TypeERbE_block_invoke(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 48);
  if (a3 != 9 || *(unsigned char *)(v5 + 1) || (int v6 = **(unsigned __int8 **)(a1 + 56), v6 == 47) || v6 == 64)
  {
    BOOL v7 = *(const dyld4::RuntimeState **)(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = (unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    dyld4::Loader::forEachResolvedAtPathVar(v7, a2, v5, a3, v9, v8);
  }
  else
  {
    strcpy(__dst, "@rpath/");
    strlcat(__dst, a2, 0x400uLL);
    dyld4::Loader::forEachResolvedAtPathVar(*(const dyld4::RuntimeState **)(a1 + 64), __dst, *(void *)(a1 + 48), 13, (unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), *(void *)(a1 + 32));
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      strcpy(v10, "/usr/lib/");
      strlcat(v10, *(const char **)(a1 + 56), 0x400uLL);
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 184)) {
          (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        }
      }
    }
  }
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 104);
  if (v10)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachImageSuffixEPKcNS1_4TypeERbU13block_pointerFvS3_S4_S5_E_block_invoke;
    v13[3] = &unk_1EFF639D0;
    uint64_t v13[4] = a5;
    v13[5] = a1;
    _OWORD v13[6] = a2;
    v13[7] = a4;
    uint64_t result = dyld4::ProcessConfig::PathOverrides::forEachInColonList(v10, 0, a4, (uint64_t)v13);
    if (!*a4) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(a5 + 16))(a5, a2, a3, a4);
    }
  }
  else
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t))(a5 + 16);
    return v12(a5);
  }
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath(dyld4::ProcessConfig::PathOverrides *this, dyld4::Utils *a2, const char *a3)
{
  uint64_t v5 = dyld4::Utils::strrstr(a2, ".framework/", a3);
  if (v5) {
    BOOL v12 = v5 >= (char *)a2;
  }
  else {
    BOOL v12 = 0;
  }
  if (!v12) {
    return 0;
  }
  int v13 = (dyld4::Utils *)v5;
  for (uint64_t i = 0; ; ++i)
  {
    if (v13 == a2 || *(unsigned char *)v13 == 47)
    {
      BOOL v15 = v13 != a2;
      uint64_t v16 = v13 == a2 ? (uint64_t)v13 : (uint64_t)v13 + 1;
      size_t v17 = i - v15;
      __chkstk_darwin((uint64_t)v5, v16, v6, v7, v8, v9, v10, v11, v26);
      uint64_t v19 = (char *)&v26 - v18;
      strncpy((char *)&v26 - v18, v20, i - v15);
      v19[i - v15] = 0;
      uint64_t v5 = strrchr((char *)a2, 47);
      if (v5)
      {
        uint64_t v21 = v5;
        int v22 = v5 + 1;
        uint64_t v5 = (char *)_platform_strcmp(v19, v5 + 1);
        if (!v5) {
          break;
        }
        uint64_t v23 = (const char *)*((void *)this + 13);
        if (v23)
        {
          uint64_t v5 = (char *)_platform_strncmp(v19, v22, v17);
          if (!v5)
          {
            uint64_t v5 = (char *)_platform_strcmp(v23, &v21[v17 + 1]);
            if (!v5) {
              break;
            }
          }
        }
      }
    }
    int v13 = (dyld4::Utils *)((char *)v13 - 1);
    if (v13 < a2) {
      return 0;
    }
  }
  if (v13 == a2) {
    char v25 = 2;
  }
  else {
    char v25 = 1;
  }
  return (uint64_t)v13 + (v25 & 1);
}

char *dyld4::Utils::strrstr(dyld4::Utils *this, const char *__s, const char *a3)
{
  size_t v5 = _platform_strlen(__s);
  size_t v6 = _platform_strlen((const char *)this);
  if (!v6) {
    return 0;
  }
  size_t v7 = v6;
  while (1)
  {
    uint64_t v8 = (char *)this + v7;
    if (!_platform_strncmp((const char *)this + v7, __s, v5)) {
      break;
    }
    if (!--v7) {
      return 0;
    }
  }
  return v8;
}

char *_platform_strncpy(char *a1, char *__s1, size_t __n)
{
  size_t v6 = _platform_strnlen(__s1, __n);
  size_t v7 = __n - v6;
  if (__n <= v6)
  {
    memmove(a1, __s1, __n);
  }
  else
  {
    size_t v8 = v6;
    memmove(a1, __s1, v6);
    _platform_memset(&a1[v8], 0, v7);
  }
  return a1;
}

size_t _platform_strlcat(const char *a1, char *__s, size_t a3)
{
  size_t v6 = _platform_strlen(__s);
  size_t v7 = _platform_strnlen(a1, a3);
  size_t v8 = a3 - v7;
  if (a3 == v7)
  {
    size_t v9 = a3;
  }
  else
  {
    size_t v9 = v7;
    uint64_t v10 = (char *)&a1[v7];
    if (v6 >= v8)
    {
      memmove(v10, __s, v8 - 1);
      a1[a3 - 1] = 0;
    }
    else
    {
      memmove(v10, __s, v6 + 1);
    }
  }
  return v9 + v6;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachFrameworkFallback(uint64_t a1, unsigned int a2, int a3, unsigned char *a4, uint64_t a5)
{
  uint64_t result = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 72);
  if (result | v10)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___ZNK5dyld413ProcessConfig13PathOverrides24forEachFrameworkFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke;
    v13[3] = &unk_1EFF639A8;
    uint64_t v13[4] = a5;
    v13[5] = a4;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v10, a4, (uint64_t)v13);
  }
  if (a3 && a2 <= 0xC)
  {
    if (((1 << a2) & 0x1BFD) != 0)
    {
      if (*(_DWORD *)(a1 + 136) == 2) {
        return result;
      }
    }
    else
    {
      if (a2 != 1) {
        return result;
      }
      int v12 = *(_DWORD *)(a1 + 136);
      if (v12 != 1)
      {
        if (v12) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, unsigned char *))(a5 + 16))(a5, "/Library/Frameworks", 15, a4);
        if (*a4) {
          return result;
        }
      }
    }
    uint64_t v11 = *(uint64_t (**)(uint64_t, const char *, uint64_t, unsigned char *))(a5 + 16);
    return v11(a5, "/System/Library/Frameworks", 15, a4);
  }
  return result;
}

BOOL dyld4::SyscallDelegate::isMaybeContainerized(dyld4::SyscallDelegate *this, char *__s1)
{
  return __s1 && strstr(__s1, "/var/mobile/Containers/Data/") != 0;
}

BOOL dyld4::SyscallDelegate::isContainerized(dyld4::SyscallDelegate *this, const char *__s1)
{
  return __s1 && _platform_strncmp(__s1, "/private/var/mobile/Containers/Data/", 0x24uLL) == 0;
}

void *dyld4::JustInTimeLoader::makeLaunchLoader(dyld4::JustInTimeLoader *this, Diagnostics *a2, dyld4::RuntimeState *a3, const dyld3::MachOAnalyzer *a4, const char *a5, const mach_o::Layout *a6)
{
  memset(v11, 0, sizeof(v11));
  uint64_t v9 = dyld4::Loader::getOnDiskBinarySliceOffset(a2, a3, a4, (const char *)a4);
  dyld4::SyscallDelegate::fileExists(*((void *)a2 + 1), a4, (uint64_t)v11, 0);
  return dyld4::JustInTimeLoader::make((uint64_t)a2, a3, (const char *)a4, v11, v9, 1, 0, 0, 0);
}

uint64_t dyld4::Loader::getOnDiskBinarySliceOffset(dyld4::Loader *this, dyld4::RuntimeState *a2, const dyld3::MachOAnalyzer *a3, const char *a4)
{
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x3002000000;
  uint64_t v18 = __Block_byref_object_copy__169;
  uint64_t v19 = __Block_byref_object_dispose__170;
  Diagnostics::Diagnostics((Diagnostics *)&v20);
  uint64_t v11 = 0;
  int v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  uint64_t v7 = *((void *)this + 1);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke;
  void v10[3] = &unk_1EFF64A78;
  v10[5] = &v11;
  v10[6] = a2;
  v10[4] = &v15;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v7, (vm_address_t *)v16 + 5, a3, 0, (uint64_t)v10);
  uint64_t v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  mach_o::Error::~Error(&v20);
  return v8;
}

int *dyld3::MachOFile::compatibleSlice(vm_address_t *a1, unint64_t *a2, dyld3::FatFile *this, unint64_t a4, const char *a5, unsigned int a6, int a7, dyld3::GradedArchs *a8, unsigned __int8 a9)
{
  uint64_t v14 = (int *)this;
  unsigned int v17 = *(_DWORD *)this;
  if ((*(_DWORD *)this | 0x1000000) == 0xBFBAFECA)
  {
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    if (!dyld3::FatFile::isFatFileWithSlice(this, a1, a4, a8, a7, &v27, &v26, &v25))
    {
      LOBYTE(v33) = 0;
      *(void *)size_t v28 = _NSConcreteStackBlock;
      uint64_t v29 = 0x40000000;
      size_t v30 = ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke;
      size_t v31 = &__block_descriptor_tmp_211;
      uint64_t v32 = &v33;
      dyld3::GradedArchs::forEachArch((uint64_t)a8, a7, (uint64_t)v28);
      dyld3::FatFile::archNames((dyld3::FatFile *)v14, v28, a4);
      Diagnostics::error(a1, "fat file, but missing compatible architecture (have '%s', need '%s')");
      return 0;
    }
    uint64_t v14 = (int *)((char *)v14 + v27);
    *a2 = v26;
    unsigned int v17 = *v14;
  }
  else
  {
    *a2 = a4;
  }
  if (v17 >> 1 != 2138504551 || !dyld3::MachOFile::isMachO((dyld3::MachOFile *)v14, a1, a4))
  {
    if (Diagnostics::noError((Diagnostics *)a1)) {
      Diagnostics::error(a1, "not a mach-o file");
    }
    return 0;
  }
  if (!dyld3::GradedArchs::grade(a8, v14[1], v14[2], a7))
  {
    LOBYTE(v33) = 0;
    *(void *)size_t v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000;
    size_t v30 = ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke;
    size_t v31 = &__block_descriptor_tmp_211;
    uint64_t v32 = &v33;
    dyld3::GradedArchs::forEachArch((uint64_t)a8, a7, (uint64_t)v28);
    for (uint64_t i = 0; i != 26; i += 2)
    {
      if (LODWORD((&dyld3::MachOFile::_s_archInfos)[i + 1]) == v14[1]
        && (v14[2] & 0xFFFFFF) == *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * i + 3))
      {
        break;
      }
    }
    Diagnostics::error(a1, "mach-o file, but is an incompatible architecture (have '%s', need '%s')");
    return 0;
  }
  if ((dyld3::MachOFile::loadableIntoProcess(v14, a6, a5, a9) & 1) == 0)
  {
    uint64_t v33 = 0;
    uint64_t v34 = &v33;
    uint64_t v35 = 0x2000000000;
    int v36 = 0;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = ___ZN5dyld39MachOFile15compatibleSliceER11DiagnosticsRyPKvmPKcNS_8PlatformEbRKNS_11GradedArchsEb_block_invoke;
    v24[3] = &unk_1EFF663E8;
    v24[4] = &v33;
    dyld3::MachOFile::forEachSupportedPlatform(v14, (uint64_t)v24);
    uint64_t v18 = 0;
    uint64_t v19 = "unknown";
    while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v18 + 1]) != *((_DWORD *)v34 + 6))
    {
      v18 += 2;
      if (v18 == 48) {
        goto LABEL_24;
      }
    }
    uint64_t v19 = (&dyld3::MachOFile::_s_platformInfos)[v18];
LABEL_24:
    uint64_t v22 = 0;
    uint64_t v23 = "unknown";
    while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v22 + 1]) != a6)
    {
      v22 += 2;
      if (v22 == 48) {
        goto LABEL_29;
      }
    }
    uint64_t v23 = (&dyld3::MachOFile::_s_platformInfos)[v22];
LABEL_29:
    Diagnostics::error(a1, "mach-o file (%s), but incompatible platform (have '%s', need '%s')", a5, v19, v23);
    _Block_object_dispose(&v33, 8);
    return 0;
  }
  return v14;
}

uint64_t dyld3::GradedArchs::grade(dyld3::GradedArchs *this, int a2, int a3, char a4)
{
  uint64_t v4 = 0;
  while (1)
  {
    int v5 = *(_DWORD *)((char *)this + v4);
    if (!v5) {
      return 0;
    }
    if (v5 == a2
      && *(_DWORD *)((char *)this + v4 + 4) == (a3 & 0xFFFFFF)
      && (!*((unsigned char *)this + v4 + 8) || (a4 & 1) != 0))
    {
      break;
    }
    v4 += 12;
    if (v4 == 48) {
      return 0;
    }
  }
  return *(unsigned __int16 *)((char *)this + v4 + 10);
}

void dyld4::JustInTimeLoader::withRegions(dyld3::MachOFile *a1, uint64_t a2)
{
  int v4 = dyld3::MachOFile::segmentCount(a1);
  uint64_t Address = dyld3::MachOFile::preferredLoadAddress(a1);
  __chkstk_darwin(Address, v6, v7, v8, v9, v10, v11, v12, v16[0]);
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x4002000000;
  uint64_t v21 = __Block_byref_object_copy__77;
  uint64_t v22 = __Block_byref_object_dispose__78;
  uint64_t v23 = (char *)v16 - v13;
  uint64_t v24 = v14;
  uint64_t v25 = 0;
  v16[0] = (uint64_t)_NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = (uint64_t)___ZN5dyld416JustInTimeLoader11withRegionsEPKN5dyld39MachOFileEU13block_pointerFvRKNS1_5ArrayINS_6Loader6RegionEEEE_block_invoke;
  v16[3] = (uint64_t)&unk_1EFF64C80;
  int v17 = v4;
  void v16[4] = (uint64_t)&v18;
  v16[5] = v15;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v16);
  (*(void (**)(uint64_t, uint64_t *))(a2 + 16))(a2, v19 + 5);
  _Block_object_dispose(&v18, 8);
}

void dyld3::MachOAnalyzer::withVMLayout(dyld3::MachOLoaded *a1, vm_address_t *a2, uint64_t a3)
{
  uint64_t v19 = a2;
  uint64_t Slide = dyld3::MachOLoaded::getSlide(a1);
  uint64_t v82 = 0;
  uint64_t v83 = &v82;
  uint64_t v84 = 0x2000000000;
  uint64_t v85 = 0;
  uint64_t v78 = 0;
  int v79 = &v78;
  uint64_t v80 = 0x2000000000;
  uint64_t v81 = 0;
  uint64_t v6 = dyld3::MachOFile::segmentCount(a1);
  uint64_t v7 = v6;
  __chkstk_darwin(v6, v8, v9, v10, v11, v12, v13, v14, v18);
  uint64_t v16 = &v18 - 2 * v15;
  if (v17) {
    bzero(v16, 48 * ((48 * (unint64_t)v7 - 48) / 0x30) + 48);
  }
  v77[0] = _NSConcreteStackBlock;
  v77[1] = 0x40000000;
  v77[2] = ___ZNK5dyld313MachOAnalyzer12withVMLayoutER11DiagnosticsU13block_pointerFvRKN6mach_o6LayoutEE_block_invoke;
  v77[3] = &unk_1EFF67028;
  v77[4] = &v82;
  v77[5] = &v78;
  v77[6] = Slide;
  v77[7] = v16;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v77);
  int v21 = 0;
  uint64_t v22 = 0;
  v23[0] = 0;
  *(void *)((char *)v23 + 5) = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  v26[0] = 0;
  *(void *)((char *)v26 + 5) = 0;
  int v27 = 0;
  uint64_t v28 = 0;
  v29[0] = 0;
  *(void *)((char *)v29 + 5) = 0;
  int v30 = 0;
  uint64_t v31 = 0;
  v32[0] = 0;
  *(void *)((char *)v32 + 5) = 0;
  int v33 = 0;
  *(void *)((char *)v35 + 5) = 0;
  uint64_t v34 = 0;
  v35[0] = 0;
  int v36 = 0;
  uint64_t v37 = 0;
  v38[0] = 0;
  *(void *)((char *)v38 + 5) = 0;
  int v39 = 0;
  uint64_t v40 = 0;
  v41[0] = 0;
  *(void *)((char *)v41 + 5) = 0;
  int v42 = 0;
  uint64_t v43 = 0;
  v44[0] = 0;
  *(void *)((char *)v44 + 5) = 0;
  int v45 = 0;
  *(void *)((char *)v47 + 5) = 0;
  uint64_t v46 = 0;
  v47[0] = 0;
  int v48 = 0;
  *(void *)((char *)v50 + 5) = 0;
  uint64_t v49 = 0;
  v50[0] = 0;
  int v51 = 0;
  *(void *)((char *)v53 + 5) = 0;
  uint64_t v52 = 0;
  v53[0] = 0;
  int v54 = 0;
  *(void *)((char *)v56 + 5) = 0;
  uint64_t v55 = 0;
  v56[0] = 0;
  int v57 = 0;
  *(void *)((char *)v59 + 5) = 0;
  uint64_t v58 = 0;
  v59[0] = 0;
  void v59[2] = 0;
  int v60 = 0;
  *(void *)((char *)v62 + 5) = 0;
  uint64_t v61 = 0;
  v62[0] = 0;
  int v63 = 0;
  *(void *)((char *)v65 + 5) = 0;
  v65[0] = 0;
  uint64_t v64 = 0;
  int v66 = 0;
  *(void *)((char *)v68 + 5) = 0;
  v68[0] = 0;
  uint64_t v67 = 0;
  int v69 = 0;
  *(void *)((char *)v71 + 5) = 0;
  v71[0] = 0;
  uint64_t v70 = 0;
  int v72 = 0;
  *(void *)((char *)v74 + 5) = 0;
  v74[0] = 0;
  uint64_t v73 = 0;
  int v75 = 0;
  __int16 v76 = 0;
  dyld3::MachOAnalyzer::getLinkeditLayout(a1, v19, v83[3], v79[3], (uint64_t)&v21);
  mach_o::Layout::Layout(v20, (uint64_t)a1, (uint64_t)v16, v7, (uint64_t)&v21);
  (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v20);
  _Block_object_dispose(&v78, 8);
  _Block_object_dispose(&v82, 8);
}

uint64_t dyld3::MachOFile::segmentCount(dyld3::MachOFile *this)
{
  uint64_t v4 = 0;
  int v5 = &v4;
  uint64_t v6 = 0x2000000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile12segmentCountEv_block_invoke;
  v3[3] = &unk_1EFF665E8;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = (dyld3::MachOFile ***)mach_o::SymbolTable::SymbolTable(&v18, a2);
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2000000000;
  int v17 = 0;
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2000000000;
  int v15 = 0;
  char v5 = *(unsigned char *)(a1 + 80);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2;
  void v8[3] = &unk_1EFF64788;
  uint64_t v10 = v16;
  uint64_t v11 = v3;
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v12 = *(vm_address_t **)(a1 + 64);
  uint64_t v13 = v6;
  long long v9 = *(_OWORD *)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3;
  void v7[3] = &unk_1EFF647B0;
  void v7[7] = v3;
  void v7[8] = v6;
  v7[4] = v9;
  v7[5] = *(void *)(a1 + 48);
  void v7[6] = v14;
  mach_o::Fixups::forEachBindTarget(v4, v12, v5, 0, (uint64_t)v8, (uint64_t)v7);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(v16, 8);
}

void mach_o::Fixups::forEachBindTarget(dyld3::MachOFile ***a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!dyld3::MachOFile::isPreload(**a1))
  {
    if (dyld3::MachOFile::hasChainedFixups(**a1))
    {
      mach_o::Fixups::forEachBindTarget_ChainedFixups(a1, a2, a5);
    }
    else if (dyld3::MachOFile::hasOpcodeFixups(**a1))
    {
      mach_o::Fixups::forEachBindTarget_Opcodes(a1, (Diagnostics *)a2, a3, a5, a6);
    }
  }
}

BOOL dyld3::MachOFile::isPreload(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 5;
}

uint64_t dyld3::MachOAnalyzer::getLinkeditLayout(_DWORD *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a4;
  uint64_t v8 = a3;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = ___ZNK5dyld313MachOAnalyzer17getLinkeditLayoutER11DiagnosticsyPKhRN6mach_o14LinkeditLayoutE_block_invoke;
  void v6[3] = &__block_descriptor_tmp_277;
  v6[4] = a1;
  void v6[5] = a5;
  void v6[6] = &v8;
  void v6[7] = &v7;
  dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v6);
  return 1;
}

void *mach_o::Layout::Layout(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

void *mach_o::SymbolTable::SymbolTable(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

void mach_o::Fixups::forEachBindTarget_ChainedFixups(dyld3::MachOFile ***a1, vm_address_t *a2, uint64_t a3)
{
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  int v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke;
  void v7[3] = &unk_1EFF669E8;
  v7[4] = a3;
  v7[5] = v8;
  mach_o::Fixups::forEachChainedFixupTarget(a1, a2, (uint64_t)v7);
  if (Diagnostics::noError((Diagnostics *)a2)
    && dyld3::MachOFile::isMainExecutable(**a1)
    && dyld3::MachOFile::hasWeakDefs(**a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    void v6[2] = ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2;
    void v6[3] = &unk_1EFF66A10;
    v6[4] = a3;
    void v6[5] = v8;
    dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v6);
  }
  _Block_object_dispose(v8, 8);
}

BOOL dyld3::MachOFile::isMainExecutable(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 2;
}

dyld3::MachOFile ***mach_o::Fixups::forEachChainedFixupTarget(dyld3::MachOFile ***result, vm_address_t *this, uint64_t a3)
{
  uint64_t v4 = (*result)[3];
  if (*((unsigned char *)v4 + 316))
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = ___ZNK6mach_o6Fixups25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke;
    void v8[3] = &unk_1EFF66A38;
    void v8[4] = a3;
    return (dyld3::MachOFile ***)mach_o::Fixups::parseOrgArm64eChainedFixups(result, this, 0, (uint64_t)v8, 0);
  }
  else if (*((unsigned char *)v4 + 412))
  {
    uint64_t v5 = *((void *)v4 + 52);
    uint64_t v7 = (unsigned int *)*((void *)v4 + 49);
    return (dyld3::MachOFile ***)dyld3::MachOFile::forEachChainedFixupTarget(this, v7, v5, a3);
  }
  return result;
}

void ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke_2(uint64_t a1, void *a2)
{
  BOOL hasCodeSignature = dyld3::MachOFile::hasCodeSignature(*(dyld3::MachOFile **)(a1 + 40), &v9, &v10);
  LOBYTE(v8) = 0;
  uint64_t v5 = (mach_o::Header *)dyld4::Loader::mapSegments(*(vm_address_t **)(a1 + 48), *(dyld4::SyscallDelegate ***)(a1 + 56), *(dyld3 **)(a1 + 64), *(void *)(a1 + 72), &v9, hasCodeSignature, a2, (void *)*(unsigned __int8 *)(a1 + 164), v8, a1 + 80);
  if (v5)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = dyld4::JustInTimeLoader::make(*(void *)(a1 + 56), v5, *(const char **)(a1 + 64), *(long long **)(a1 + 136), *(void *)(a1 + 80), *(unsigned char *)(a1 + 164), *(unsigned char *)(a1 + 165), *(unsigned __int8 *)(a1 + 166), *(_DWORD *)(a1 + 160));
    uint64_t v6 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(unsigned char *)(*((void *)v6 + 1) + 200)) {
      dyld4::Loader::logLoad(*(dyld4::Loader **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v6, *(char **)(a1 + 64));
    }
    if (*(unsigned char *)(*(void *)(a1 + 152) + 3))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      *(void *)(v7 + 40) |= 0x80000uLL;
    }
  }
}

void *dyld4::JustInTimeLoader::make(uint64_t a1, mach_o::Header *this, const char *a3, long long *a4, uint64_t a5, char a6, char a7, int a8, __int16 a9)
{
  BOOL v57 = 1;
  unsigned int v16 = mach_o::Header::linkedDylibCount(this, &v57);
  unsigned int v17 = v16 - 1;
  if (!v16) {
    unsigned int v17 = 1;
  }
  uint64_t v18 = 8 * v17 + 472;
  uint64_t v19 = v16;
  if (v57) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = v16;
  }
  uint64_t v44 = a3;
  size_t v21 = _platform_strlen(a3);
  __int16 v41 = v18;
  uint64_t v22 = lsl::Allocator::malloc(*(lsl::Lock ***)(a1 + 16), v21 + v20 + v18 + 1);
  memset(v63, 0, sizeof(v63));
  dyld4::Loader::InitialOptions::InitialOptions((uint64_t)&v45);
  BOOL v45 = DyldSharedCache::inDyldCache(*(DyldSharedCache **)(*(void *)(a1 + 8) + 240), this, v23);
  char hasObjC = dyld3::MachOFile::hasObjC(this);
  Diagnostics::Diagnostics((Diagnostics *)v58);
  hasPlusLoaddouble Method = dyld3::MachOFile::hasPlusLoadMethod(this, (Diagnostics *)v58);
  mach_o::Error::~Error(v58);
  char v47 = hasPlusLoadMethod;
  uint64_t v59 = 0;
  int v60 = &v59;
  uint64_t v61 = 0x2000000000;
  char v62 = 0;
  v58[0] = (vm_address_t *)_NSConcreteStackBlock;
  v58[1] = (vm_address_t *)0x40000000;
  v58[2] = (vm_address_t *)___ZN5dyld4L12hasDataConstEPKN5dyld39MachOFileE_block_invoke;
  v58[3] = (vm_address_t *)&unk_1EFF64D38;
  v58[4] = (vm_address_t *)&v59;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v58);
  char v25 = *((unsigned char *)v60 + 24);
  _Block_object_dispose(&v59, 8);
  char v48 = v25;
  char v43 = a8;
  char v49 = a6 | a8;
  char v50 = a7;
  if (hasObjC) {
    char hasConstObjCSection = dyld3::MachOFile::hasConstObjCSection(this);
  }
  else {
    char hasConstObjCSection = 0;
  }
  char v51 = hasConstObjCSection;
  char v52 = dyld3::MachOFile::enforceFormat(this, 16) ^ 1;
  BOOL Uuid = dyld3::MachOFile::getUuid(this, v63);
  char hasWeakDefs = dyld3::MachOFile::hasWeakDefs(this);
  char hasThreadLocalVariables = dyld3::MachOFile::hasThreadLocalVariables(this);
  if (dyld3::MachOFile::isDylib(this))
  {
    int v27 = dyld3::MachOFile::installName(this);
    BOOL v28 = _platform_strncmp(v27, "/usr/lib/system/lib", 0x13uLL) == 0;
  }
  else
  {
    BOOL v28 = 0;
  }
  BOOL v56 = v28;
  dyld4::Loader::Loader((uint64_t)v22, &v45, 0, 0, 0, 0);
  v22[4] = this;
  v22[6] = 0;
  long long v29 = *a4;
  long long v30 = a4[1];
  *((_OWORD *)v22 + 7) = xmmword_1A8E704D0;
  *(_OWORD *)(v22 + 9) = v30;
  *(_OWORD *)(v22 + 7) = v29;
  v22[11] = 0;
  v22[12] = 0;
  v22[13] = 0;
  v22[58] = 0;
  if (v57) {
    __int16 v31 = 0;
  }
  else {
    __int16 v31 = v19;
  }
  v22[5] = v22[5] & 0xFFFFFFFFFFF00000 | (unsigned __int16)(v31 + v41);
  BOOL isDylib = dyld3::MachOFile::isDylib(this);
  unint64_t v33 = 0;
  if (isDylib)
  {
    uint64_t v34 = dyld3::MachOFile::installName(this);
    unint64_t v33 = (unint64_t)(_platform_strcmp(v34, v44) != 0) << 20;
  }
  v22[5] = v22[5] & 0xFFFFFFFF4FFFFFLL | v33 | ((unint64_t)v57 << 23);
  v22[6] = a5;
  uint64_t v35 = v22 + 1;
  if (Uuid) {
    _OWORD *v35 = *(_OWORD *)v63;
  }
  else {
    bzero(v35, 0x10uLL);
  }
  *((_DWORD *)v22 + 6) = *((_DWORD *)this + 2);
  dyld4::JustInTimeLoader::parseSectionLocations(this, (uint64_t)(v22 + 15));
  if ((dyld3::MachOFile::hasExportTrie(this, (unsigned int *)v22 + 28, (unsigned int *)v22 + 29) & 1) == 0) {
    v22[14] = 0;
  }
  v22[11] = 0;
  v22[13] = 0;
  uint64_t v36 = 0x400000;
  if (!a8) {
    uint64_t v36 = 0;
  }
  unint64_t v37 = v36 & 0xFFFFFF8000FFFFFFLL | ((unint64_t)(a9 & 0x7FFF) << 24) | ((unint64_t)(unsigned __int16)v19 << 39) | v22[5] & 0xFF80000000BFFFFFLL;
  v22[5] = v37;
  if (v19)
  {
    uint64_t v38 = 0;
    int v39 = v22 + 58;
    do
    {
      v22[v38 + 58] = 0;
      if (!v57) {
        *(unsigned char *)dyld4::JustInTimeLoader::dependentAttrs((dyld4::JustInTimeLoader *)v22, v38) = mach_o::LinkedDylibAttributes::regular;
      }
      ++v38;
      ++v39;
    }
    while (v19 != v38);
    LOWORD(v37) = *((_WORD *)v22 + 20);
  }
  strlcpy((char *)v22 + (unsigned __int16)v37, v44, 0x400uLL);
  v22[5] &= ~0x80000000000000uLL;
  dyld4::RuntimeState::add((dyld4::RuntimeState *)a1, (const dyld4::Loader *)v22);
  if (v43)
  {
    if (v45) {
      *(unsigned char *)(a1 + 1135) = 1;
    }
    else {
      *(unsigned char *)(a1 + 1134) = 1;
    }
  }
  if (*(unsigned char *)(*(void *)(a1 + 8) + 207)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "using JustInTimeLoader %p for %s\n", v22, v44);
  }
  return v22;
}

BOOL dyld3::MachOFile::isDylib(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 6;
}

uint64_t dyld3::MachOFile::hasWeakDefs(dyld3::MachOFile *this)
{
  return *((unsigned __int8 *)this + 25) >> 7;
}

uint64_t dyld3::MachOFile::hasExportTrie(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  uint64_t v24 = 0;
  char v25 = &v24;
  uint64_t v26 = 0x2000000000;
  uint64_t v27 = 0;
  uint64_t v20 = 0;
  size_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  uint64_t v23 = 0;
  uint64_t v16 = 0;
  unsigned int v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke;
  v15[3] = &unk_1EFF66638;
  v15[4] = &v24;
  v15[5] = &v20;
  v15[6] = &v16;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v15);
  Diagnostics::Diagnostics((Diagnostics *)&v14);
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = -1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unsigned int v9[2] = ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke_2;
  void v9[3] = &unk_1EFF66660;
  v9[4] = &v10;
  v9[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v14, (uint64_t)v9);
  uint64_t v6 = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v14))
  {
    int v7 = *((_DWORD *)v11 + 6);
    if (v7 == -1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      *a2 = *((_DWORD *)v21 + 6) + v7 - (*((_DWORD *)v17 + 6) + *((_DWORD *)v25 + 6));
      uint64_t v6 = 1;
    }
  }
  _Block_object_dispose(&v10, 8);
  mach_o::Error::~Error(&v14);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  return v6;
}

uint64_t dyld3::MachOFile::hasObjC(dyld3::MachOFile *this)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile7hasObjCEv_block_invoke;
  v3[3] = &unk_1EFF66170;
  void v3[4] = &v4;
  void v3[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t dyld3::MachOFile::hasPlusLoadMethod(dyld3::MachOFile *this, Diagnostics *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile17hasPlusLoadMethodER11Diagnostics_block_invoke;
  void v4[3] = &unk_1EFF66488;
  v4[4] = &v5;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t dyld3::MachOFile::enforceFormat(_DWORD *a1, int a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile13enforceFormatENS0_9MalformedE_block_invoke;
  void v4[3] = &unk_1EFF667B0;
  int v5 = a2;
  v4[4] = &v6;
  dyld3::MachOFile::forEachSupportedPlatform(a1, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v2;
}

dyld4::Loader *dyld4::Loader::makeDyldCacheLoader(vm_address_t *a1, dyld4::RuntimeState *this, char *__s2, uint64_t a4, int a5)
{
  if (*(unsigned char *)(a4 + 5)) {
    return 0;
  }
  int v8 = a4;
  Prebuiltuint64_t Loader = dyld4::RuntimeState::findPrebuiltLoader(this, __s2);
  if (PrebuiltLoader)
  {
    int v5 = PrebuiltLoader;
    int v13 = (_DWORD *)dyld4::PrebuiltLoader::mf(PrebuiltLoader, this);
    if (dyld3::MachOFile::loadableIntoProcess(v13, *(_DWORD *)(*((void *)this + 1) + 68), __s2, *(unsigned __int8 *)(*((void *)this + 1) + 168)))return v5; {
  }
    }

  return dyld4::JustInTimeLoader::makeJustInTimeLoaderDyldCache(a1, this, __s2, v8, a5);
}

dyld4::PrebuiltLoader *dyld4::RuntimeState::findPrebuiltLoader(dyld4::RuntimeState *this, const char *__s2)
{
  unsigned int v21 = 0;
  if (!*((void *)this + 121)
    || !DyldSharedCache::hasImagePath(*(DyldSharedCache **)(*((void *)this + 1) + 240), __s2, &v21))
  {
    goto LABEL_5;
  }
  uint64_t v10 = *((void *)this + 121);
  if (*(_DWORD *)(v10 + 12) <= (unsigned __int16)v21) {
    dyld4::RuntimeState::findPrebuiltLoader();
  }
  uint64_t v11 = (dyld4::PrebuiltLoader *)(v10
                                + *(unsigned int *)(v10 + *(unsigned int *)(v10 + 16) + 4 * (unsigned __int16)v21));
  if (!dyld4::PrebuiltLoader::isValid(v11, this, v4, v5, v6, v7, v8, v9))
  {
LABEL_5:
    uint64_t v12 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 124);
    if (!v12) {
      return 0;
    }
    uint64_t Loader = (dyld4::PrebuiltLoader *)dyld4::PrebuiltLoaderSet::findLoader(v12, this, __s2);
    if (!Loader) {
      return 0;
    }
    uint64_t v11 = Loader;
    if (!dyld4::PrebuiltLoader::isValid(Loader, this, v14, v15, v16, v17, v18, v19)) {
      return 0;
    }
  }
  return v11;
}

uint64_t dyld3::MachOFile::loadableIntoProcess(_DWORD *a1, unsigned int a2, const char *a3, int a4)
{
  if (!dyld3::MachOFile::builtForPlatform(a1, a2, 0))
  {
    if (a2 <= 0xC && ((1 << a2) & 0x1380) != 0)
    {
      if (dyld3::MachOFile::builtForPlatform(a1, 1, 0))
      {
        uint64_t v10 = 0;
        while (_platform_strcmp(dyld3::MachOFile::loadableIntoProcess(dyld3::Platform,char const*,BOOL)const::macOSHost[v10], a3))
        {
          if (++v10 == 6) {
            goto LABEL_10;
          }
        }
        return 1;
      }
    }
    else
    {
LABEL_10:
      if (a2 == 1 && a1[3] == 2)
      {
        uint64_t v8 = 1;
        uint64_t v11 = a1;
        int v12 = 6;
        goto LABEL_17;
      }
    }
    if (a2 == 7)
    {
      uint64_t v8 = 1;
      uint64_t v11 = a1;
      int v12 = 12;
    }
    else
    {
      if (a2 != 2) {
        goto LABEL_18;
      }
      uint64_t v8 = 1;
      uint64_t v11 = a1;
      int v12 = 11;
    }
LABEL_17:
    if (dyld3::MachOFile::builtForPlatform(v11, v12, 1)) {
      return v8;
    }
LABEL_18:
    if (!a4)
    {
LABEL_33:
      if (a2 == 6)
      {
LABEL_34:
        uint64_t v8 = 1;
        if (dyld3::MachOFile::builtForPlatform(a1, 1, 1)) {
          return v8;
        }
      }
      return 0;
    }
    if (a2 == 12)
    {
      uint64_t v8 = 1;
      int v13 = a1;
      int v14 = 7;
    }
    else
    {
      if (a2 != 11) {
        goto LABEL_24;
      }
      uint64_t v8 = 1;
      int v13 = a1;
      int v14 = 2;
    }
    if (dyld3::MachOFile::builtForPlatform(v13, v14, 1)) {
      return v8;
    }
LABEL_24:
    HIDWORD(v15) = a2;
    LODWORD(v15) = a2 - 6;
    switch((v15 >> 1))
    {
      case 0u:
        goto LABEL_34;
      case 5u:
        uint64_t v8 = 1;
        if (dyld3::MachOFile::builtForPlatform(a1, 1, 0)) {
          return v8;
        }
        if (a2 == 6) {
          goto LABEL_34;
        }
        if (a2 == 20) {
          goto LABEL_32;
        }
        if (a2 != 18) {
          return 0;
        }
LABEL_29:
        uint64_t v8 = 1;
        if (dyld3::MachOFile::builtForPlatform(a1, 2, 1)) {
          return v8;
        }
        if (a2 == 6) {
          goto LABEL_34;
        }
        if (a2 != 20) {
          return 0;
        }
LABEL_32:
        uint64_t v8 = 1;
        if (!dyld3::MachOFile::builtForPlatform(a1, 3, 1)) {
          goto LABEL_33;
        }
        return v8;
      case 6u:
        goto LABEL_29;
      case 7u:
        goto LABEL_32;
      default:
        return 0;
    }
  }
  return 1;
}

BOOL dyld3::MachOFile::builtForPlatform(_DWORD *a1, int a2, int a3)
{
  uint64_t v14 = 0;
  unint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  char v17 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile16builtForPlatformENS_8PlatformEb_block_invoke;
  void v8[3] = &unk_1EFF660D0;
  int v9 = a2;
  void v8[4] = &v14;
  void v8[5] = &v10;
  dyld3::MachOFile::forEachSupportedPlatform(a1, (uint64_t)v8);
  if (!*((unsigned char *)v11 + 24) || (BOOL v6 = 0, !a3))
  {
    if (*((unsigned char *)v15 + 24))
    {
      BOOL v6 = 1;
    }
    else
    {
      BOOL v6 = 0;
      if (a2 == 1 && !*((unsigned char *)v11 + 24)) {
        BOOL v6 = ((a1[1] - 7) & 0xFEFFFFFF) == 0;
      }
    }
  }
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  return v6;
}

void dyld3::MachOFile::forEachSupportedPlatform(_DWORD *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v7);
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  char v6 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile24forEachSupportedPlatformEU13block_pointerFvNS_8PlatformEjjE_block_invoke;
  void v4[3] = &unk_1EFF66128;
  void v4[5] = v5;
  void v4[6] = a1;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v7, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v7);
  _Block_object_dispose(v5, 8);
  mach_o::Error::~Error(&v7);
}

BOOL dyld4::PrebuiltLoader::isValid(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin((uint64_t)this, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v57);
  __int16 v10 = v8[3];
  __int16 v11 = v10;
  uint64_t v12 = v9 + 125;
  if (v10 >= 0) {
    uint64_t v12 = v9 + 122;
  }
  int v13 = *(unsigned __int8 *)(*v12 + (v10 & 0x7FFF));
  if ((v13 - 2) < 8) {
    return 1;
  }
  if (v13 == 255) {
    return 0;
  }
  uint64_t v16 = v9;
  char v17 = v8;
  int v18 = *(unsigned __int8 *)(v9[1] + 399);
  if (!v13)
  {
    dyld4::PrebuiltLoader::recursiveMarkBeingValidated(v8, (const dyld4::RuntimeState *)v9, v18 == 0);
    __int16 v11 = v17[3];
  }
  uint64_t v19 = 0;
  v52[0] = &v56;
  v52[1] = 1024;
  vm_address_t address = 0;
  vm_size_t size = 0;
  uint64_t v53 = 0;
  if ((v11 & 0x8000) == 0)
  {
LABEL_19:
    if (!v18) {
      goto LABEL_29;
    }
    goto LABEL_20;
  }
  uint64_t v20 = v16[124];
  unsigned int v21 = *(_DWORD *)(v20 + 12);
  if (v21)
  {
    uint64_t v19 = 0;
    for (unsigned int i = 0; i < v21; ++i)
    {
      if (v21 <= (unsigned __int16)i) {
        dyld4::RuntimeState::findPrebuiltLoader();
      }
      uint64_t v23 = v20 + *(unsigned int *)(v20 + *(unsigned int *)(v20 + 16) + 4 * (unsigned __int16)i);
      __int16 v24 = *(_WORD *)(v23 + 6);
      if (v24 >= 0) {
        char v25 = v16 + 122;
      }
      else {
        char v25 = v16 + 125;
      }
      if (*(unsigned char *)(*v25 + (v24 & 0x7FFF)) == 1)
      {
        dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v52, 1);
        uint64_t v26 = v53;
        uint64_t v19 = ++v53;
        *(void *)(v52[0] + 8 * v26) = v23;
        unsigned int v21 = *(_DWORD *)(v20 + 12);
      }
    }
    goto LABEL_19;
  }
  uint64_t v19 = 0;
  if (!v18) {
    goto LABEL_29;
  }
LABEL_20:
  uint64_t v27 = v16[121];
  unsigned int v28 = *(_DWORD *)(v27 + 12);
  if (v28)
  {
    for (unsigned int j = 0; j < v28; ++j)
    {
      if (v28 <= (unsigned __int16)j) {
        dyld4::RuntimeState::findPrebuiltLoader();
      }
      uint64_t v30 = v27 + *(unsigned int *)(v27 + *(unsigned int *)(v27 + 16) + 4 * (unsigned __int16)j);
      __int16 v31 = *(_WORD *)(v30 + 6);
      if (v31 >= 0) {
        uint64_t v32 = v16 + 122;
      }
      else {
        uint64_t v32 = v16 + 125;
      }
      if (*(unsigned char *)(*v32 + (v31 & 0x7FFF)) == 1)
      {
        dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v52, 1);
        uint64_t v33 = v53;
        uint64_t v19 = ++v53;
        *(void *)(v52[0] + 8 * v33) = v30;
        unsigned int v28 = *(_DWORD *)(v27 + 12);
      }
    }
  }
LABEL_29:
  if (v19)
  {
    uint64_t v34 = (dyld4::PrebuiltLoader **)v52[0];
    uint64_t v35 = 8 * v19;
    do
    {
      uint64_t v36 = *v34++;
      dyld4::PrebuiltLoader::invalidateInIsolation(v36, (const dyld4::RuntimeState *)v16);
      v35 -= 8;
    }
    while (v35);
  }
  while (v53)
  {
    char v37 = 0;
    uint64_t v38 = (_WORD **)v52[0];
    uint64_t v39 = 8 * v53;
    do
    {
      __int16 v40 = (*v38)[3];
      if (v40 >= 0) {
        __int16 v41 = v16 + 122;
      }
      else {
        __int16 v41 = v16 + 125;
      }
      uint64_t v42 = *v41;
      uint64_t v43 = v40 & 0x7FFF;
      if (*(unsigned char *)(*v41 + v43) == 1)
      {
        dyld4::PrebuiltLoader::invalidateShallow(*v38, (const dyld4::RuntimeState *)v16);
        if (*(unsigned char *)(v42 + v43) != 1) {
          char v37 = 1;
        }
      }
      ++v38;
      v39 -= 8;
    }
    while (v39);
    if ((v37 & 1) == 0)
    {
      if (v53)
      {
        uint64_t v44 = v52[0];
        uint64_t v45 = 8 * v53;
        do
        {
          __int16 v46 = *(_WORD *)(*(void *)v44 + 6);
          if (v46 >= 0) {
            char v47 = v16 + 122;
          }
          else {
            char v47 = v16 + 125;
          }
          uint64_t v48 = *v47;
          uint64_t v49 = v46 & 0x7FFF;
          if (*(unsigned char *)(v48 + v49) == 1) {
            *(unsigned char *)(v48 + v49) = 2;
          }
          v44 += 8;
          v45 -= 8;
        }
        while (v45);
      }
      break;
    }
  }
  __int16 v50 = v17[3];
  if (v50 >= 0) {
    char v51 = v16 + 122;
  }
  else {
    char v51 = v16 + 125;
  }
  BOOL v14 = *(unsigned __int8 *)(*v51 + (v50 & 0x7FFF)) != 255;
  uint64_t v53 = 0;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  return v14;
}

_WORD *dyld4::PrebuiltLoader::recursiveMarkBeingValidated(_WORD *this, const dyld4::RuntimeState *a2, BOOL a3)
{
  __int16 v3 = this[3];
  if (v3 >= 0) {
    uint64_t v4 = (char *)a2 + 976;
  }
  else {
    uint64_t v4 = (char *)a2 + 1000;
  }
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = v3 & 0x7FFF;
  if (!*(unsigned char *)(v5 + v6))
  {
    BOOL v7 = a3;
    int v9 = this;
    if (!a3 || (this[2] & 2) == 0)
    {
      *(unsigned char *)(v5 + v6) = 1;
      if (this[24])
      {
        unsigned int v10 = 0;
        char v11 = 0;
        do
        {
          this = (_WORD *)dyld4::PrebuiltLoader::dependent(v9, a2, v10, 0);
          if (this)
          {
            uint64_t v12 = this;
            if ((this[2] & 1) == 0) {
              dyld4::PrebuiltLoader::recursiveMarkBeingValidated();
            }
            this = (_WORD *)dyld4::PrebuiltLoader::recursiveMarkBeingValidated((dyld4::PrebuiltLoader *)this, a2, v7);
            __int16 v13 = v12[3];
            if (v13 >= 0) {
              BOOL v14 = (char *)a2 + 976;
            }
            else {
              BOOL v14 = (char *)a2 + 1000;
            }
            v11 |= *(unsigned __int8 *)(*(void *)v14 + (v13 & 0x7FFF)) == 255;
          }
          ++v10;
        }
        while (v10 < (unsigned __int16)v9[24]);
        if (v11)
        {
          __int16 v15 = v9[3];
          if (v15 >= 0) {
            uint64_t v16 = (char *)a2 + 976;
          }
          else {
            uint64_t v16 = (char *)a2 + 1000;
          }
          *(unsigned char *)(*(void *)v16 + (v15 & 0x7FFF)) = -1;
        }
      }
    }
  }
  return this;
}

uint64_t dyld4::Loader::Loader(uint64_t result, unsigned char *a2, __int16 a3, int a4, __int16 a5, int a6)
{
  *(_DWORD *)uint64_t result = 1815378276;
  __int16 v6 = *(_WORD *)(result + 4) & 0xFFFE | a3;
  *(_WORD *)(result + 4) = v6;
  __int16 v7 = v6 & 0xFFFD | (2 * (*a2 & 0x7F));
  *(_WORD *)(result + 4) = v7;
  __int16 v8 = v7 & 0xFFFB | (4 * (a2[1] & 0x3F));
  *(_WORD *)(result + 4) = v8;
  __int16 v9 = v8 & 0xFFF7 | (8 * (a2[2] & 0x1F));
  *(_WORD *)(result + 4) = v9;
  __int16 v10 = v9 & 0xFFEF | (16 * (a2[3] & 0xF));
  *(_WORD *)(result + 4) = v10;
  __int16 v11 = v10 & 0xFFDF | (32 * (a2[4] & 7));
  *(_WORD *)(result + 4) = v11;
  __int16 v12 = v11 & 0xFFBF | ((a2[5] & 3) << 6);
  *(_WORD *)(result + 4) = v12;
  __int16 v13 = v12 & 0xFF7F | ((a2[6] & 1) << 7);
  *(_WORD *)(result + 4) = v13;
  __int16 v14 = v13 & 0xFCFF | (a2[7] << 8);
  if (a6) {
    __int16 v15 = 512;
  }
  else {
    __int16 v15 = 0;
  }
  __int16 v16 = v14 | v15;
  *(_WORD *)(result + 4) = v16;
  __int16 v17 = v16 & 0xFBFF | (a2[8] << 10);
  *(_WORD *)(result + 4) = v17;
  __int16 v18 = v17 & 0xF7FF | (a2[9] << 11);
  *(_WORD *)(result + 4) = v18;
  __int16 v19 = v18 & 0xEFFF | (a2[10] << 12);
  *(_WORD *)(result + 4) = v19;
  *(_WORD *)(result + 4) = v19 & 0x1FFF | (a2[11] << 13);
  if (a4) {
    __int16 v20 = 0x8000;
  }
  else {
    __int16 v20 = 0;
  }
  *(_WORD *)(result + 6) = v20 | a5;
  *(void *)(result + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  return result;
}

uint64_t dyld4::Loader::InitialOptions::InitialOptions(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(void *)this = 0;
  return this;
}

void dyld4::JustInTimeLoader::parseSectionLocations(dyld3::MachOFile *a1, uint64_t a2)
{
  *(_OWORD *)(a2 + 248) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 20dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 12dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *(_OWORD *)(a2 + 328) = 0u;
  *(_OWORD *)(a2 + 28dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 264) = 0u;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke;
  void v5[3] = &__block_descriptor_tmp_48;
  v5[4] = dyld3::MachOFile::preferredLoadAddress(a1);
  v5[5] = a2;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke_2;
  void v4[3] = &unk_1EFF64C30;
  v4[4] = v5;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v4);
}

vm_address_t *dyld3::MachOFile::forEachChainedFixupTarget(vm_address_t *this, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = this;
  uint64_t v5 = a2[2];
  unsigned int v6 = *(_DWORD *)(a3 + 12);
  if (v5 <= v6)
  {
    uint64_t v8 = a2[3];
    if (v6 >= v8)
    {
      char v26 = 0;
      __int16 v11 = (char *)a2 + v8;
      unsigned int v12 = v6 - v8;
      unsigned int v13 = a2[5];
      switch(v13)
      {
        case 3u:
          if (!a2[4]) {
            return this;
          }
          uint64_t v18 = 0;
          __int16 v19 = (void *)((char *)a2 + v5 + 8);
          while (1)
          {
            unint64_t v20 = *(v19 - 1);
            if (v12 < HIDWORD(v20)) {
              break;
            }
            if ((unsigned __int16)*(v19 - 1) <= 0xFFF0u) {
              uint64_t v21 = (unsigned __int16)*(v19 - 1);
            }
            else {
              uint64_t v21 = (__int16)v20;
            }
            this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, void, unint64_t, char *))(a4 + 16))(a4, v21, &v11[HIDWORD(v20)], *v19, (v20 >> 16) & 1, &v26);
            if (!v26)
            {
              v19 += 2;
              if (++v18 < (unint64_t)a2[4]) {
                continue;
              }
            }
            return this;
          }
          break;
        case 2u:
          if (!a2[4]) {
            return this;
          }
          uint64_t v22 = 0;
          uint64_t v23 = (int *)((char *)a2 + v5 + 4);
          while (1)
          {
            unint64_t v24 = *(v23 - 1);
            if (*(v23 - 1) >> 9 > v12) {
              break;
            }
            if (*(v23 - 1) <= 0xF0u) {
              uint64_t v25 = *(v23 - 1);
            }
            else {
              uint64_t v25 = (char)v24;
            }
            this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, void, void, char *))(a4 + 16))(a4, v25, &v11[v24 >> 9], *v23, (v24 >> 8) & 1, &v26);
            if (!v26)
            {
              v23 += 2;
              if (++v22 < (unint64_t)a2[4]) {
                continue;
              }
            }
            return this;
          }
          break;
        case 1u:
          if (!a2[4]) {
            return this;
          }
          uint64_t v14 = 0;
          __int16 v15 = (char *)a2 + v5;
          while (1)
          {
            unint64_t v16 = *(unsigned int *)&v15[4 * v14];
            if (*(_DWORD *)&v15[4 * v14] >> 9 > v12) {
              break;
            }
            if (*(_DWORD *)&v15[4 * v14] <= 0xF0u) {
              uint64_t v17 = *(_DWORD *)&v15[4 * v14];
            }
            else {
              uint64_t v17 = (char)v16;
            }
            this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, void, void, char *))(a4 + 16))(a4, v17, &v11[v16 >> 9], 0, (v16 >> 8) & 1, &v26);
            if (!v26 && ++v14 < (unint64_t)a2[4]) {
              continue;
            }
            return this;
          }
          break;
        default:
          __int16 v9 = "unknown imports format";
          goto LABEL_4;
      }
      return (vm_address_t *)Diagnostics::error(v4, "malformed import table, string overflow");
    }
  }
  __int16 v9 = "malformed import table";
LABEL_4:

  return (vm_address_t *)Diagnostics::error(this, v9);
}

uint64_t ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v8 = a1 + 32;
  uint64_t v7 = *(void *)(a1 + 32);
  v10[0] = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 8) + 24);
  v10[1] = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  char v13 = a5;
  char v14 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(v7 + 16))(v7, v10, a6, a4);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

BOOL ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) != *(_DWORD *)a2) {
    ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2_cold_1();
  }
  uint64_t v9 = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  dyld4::Loader::resolveSymbol(*(dyld4::Loader **)(a1 + 56), *(dyld4::RuntimeState **)(a1 + 72), *(vm_address_t **)(a1 + 64), *(unsigned int *)(a2 + 4), *(const char **)(a2 + 8), *(unsigned __int8 *)(a2 + 24), *(unsigned __int8 *)(a2 + 25), *(void *)(a1 + 32), (uint64_t)&v7);
  *(void *)&long long v8 = v8 + *(void *)(a2 + 16);
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40));
  BOOL result = Diagnostics::hasError(*(Diagnostics **)(a1 + 64));
  if (result) {
    *a3 = 1;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  return result;
}

void *___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_28(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(dyld4::Loader **)(a1 + 48);
  uint64_t v4 = *(const dyld4::RuntimeState **)(a1 + 56);
  unsigned int v6 = dyld4::Loader::resolvedAddress(v4, a2);
  long long v8 = dyld4::Loader::interpose(v4, v6, v5, v7);
  uint64_t v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(unsigned char *)(*((void *)v9 + 1) + 202))
  {
    if (*(void *)a2)
    {
      __int16 v10 = dyld4::Loader::leafName(*(dyld4::Loader **)a2, *(const dyld4::RuntimeState **)(a1 + 56));
      uint64_t v9 = *(const dyld4::RuntimeState **)(a1 + 56);
    }
    else
    {
      __int16 v10 = "<none>";
    }
    uint64_t v11 = dyld4::Loader::leafName(v5, v9);
    dyld4::RuntimeState::log(v9, "<%s/bind#%llu> -> %p (%s/%s)\n", v11, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 56), v8, v10, *(const char **)(a2 + 8));
  }
  if (*(unsigned char *)(a2 + 38))
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 56);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(v12 + 40), 1);
    uint64_t v15 = *(void *)(v12 + 40);
    uint64_t v16 = *(void *)(v12 + 56);
    *(void *)(v12 + 56) = v16 + 1;
    uint64_t v17 = v15 + 16 * v16;
    *(void *)uint64_t v17 = v13;
    *(_DWORD *)(v17 + 8) = v14;
  }
  if (*(unsigned char *)(a2 + 39))
  {
    uint64_t v18 = *(void *)(a1 + 64);
    if (v18)
    {
      long long v25 = *(_OWORD *)a2;
      lsl::Vector<dyld4::InterposeTupleAll>::reserve(v18, *(void *)(v18 + 16) + 1);
      uint64_t v19 = *(void *)(v18 + 8);
      uint64_t v20 = *(void *)(v18 + 16);
      *(void *)(v18 + 16) = v20 + 1;
      *(_OWORD *)(v19 + 16 * v2dyld4::halt((char *)__format, 0) = v25;
    }
  }
  uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
  BOOL result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v21 + 40), 1);
  uint64_t v23 = *(void *)(v21 + 40);
  uint64_t v24 = *(void *)(v21 + 56);
  *(void *)(v21 + 56) = v24 + 1;
  *(void *)(v23 + 8 * v++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
  return result;
}

void dyld4::Loader::resolveSymbol(dyld4::Loader *this@<X0>, dyld4::RuntimeState *a2@<X2>, vm_address_t *a3@<X1>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  HIDWORD(v55) = a7;
  int v10 = a6;
  int v12 = a4;
  uint64_t v62 = 0;
  int v63 = &v62;
  uint64_t v64 = 0x5002000000;
  size_t v65 = __Block_byref_object_copy__124;
  int v66 = __Block_byref_object_dispose__125;
  uint64_t v67 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  uint64_t v68 = a5;
  uint64_t v71 = 2;
  unsigned int v17 = a4 - 1;
  if ((int)a4 >= 1 && dyld4::Loader::dependentCount(this) >= a4)
  {
    uint64_t v18 = (dyld4::Loader *)dyld4::Loader::dependent(this, a2, v17, 0);
LABEL_16:
    v63[5] = (uint64_t)v18;
    if (v18
      && (__chkstk_darwin((uint64_t)v18, (uint64_t)a3, (uint64_t)a2, a4, (uint64_t)a5, a6, a7, a8, v55),
          uint64_t v31 = *((void *)a2 + 6),
          *(void *)&long long v76 = (char *)&v55 - ((v30 + 23) & 0xFFFFFFFFFFFFFFF0),
          *((void *)&v76 + 1) = v31,
          uint64_t v77 = 0,
          dyld4::Loader::hasExportedSymbol(v63[5], a3, a2, (const unsigned __int8 *)a5, 0, 1, v63 + 5, (uint64_t *)&v76)))
    {
      uint64_t v32 = v63;
      long long v33 = *(_OWORD *)(v63 + 7);
      *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
      *(_OWORD *)(a9 + 16) = v33;
      *(void *)(a9 + 32) = v32[9];
    }
    else
    {
      uint64_t v58 = 0;
      __int16 v57 = 0;
      if (v10)
      {
        uint64_t v34 = v63;
        *((_DWORD *)v63 + 18) = 2;
        v34[7] = 0;
      }
      else if (HIDWORD(v55) && (uint64_t v35 = *((void *)a2 + 15)) != 0)
      {
        uint64_t v34 = v63;
        v63[5] = *((void *)a2 + 13);
        v34[6] = (uint64_t)a5;
        v34[7] = v35;
        v34[9] = 1;
      }
      else
      {
        int v36 = dyld4::Loader::overridesDylibInCache((uint64_t)this, &v58, &v57);
        uint64_t v34 = v63;
        if (v36)
        {
          *((_DWORD *)v63 + 18) = 2;
          v34[7] = 195903495;
        }
        else
        {
          uint64_t v38 = (dyld4::Loader *)v63[5];
          if (v38) {
            uint64_t v39 = (const char *)dyld4::Loader::path(v38, a2);
          }
          else {
            uint64_t v39 = "unknown";
          }
          if (!*((void *)a2 + 19))
          {
            uint64_t v42 = (const char *)dyld4::Loader::path(this, a2);
            dyld4::RuntimeState::setLaunchMissingSymbol(a2, a5, v39, v42);
          }
          if ((*((_WORD *)this + 2) & 0x400) != 0) {
            dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)&v76, v37);
          }
          else {
            strcpy((char *)&v76, "no uuid");
          }
          uint64_t v43 = v63[5];
          if (v43 && (*(_WORD *)(v43 + 4) & 0x400) != 0) {
            dyld4::Loader::uuidToStr((unsigned __int8 *)(v43 + 8), v72, v37);
          }
          else {
            strcpy((char *)v72, "no uuid");
          }
          Diagnostics::Diagnostics((Diagnostics *)&v56);
          dyld4::Loader::tooNewErrorAddendum(this, (Diagnostics *)&v56, a2);
          __int16 v46 = (const char *)dyld4::Loader::path(this, a2);
          char v47 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v56);
          Diagnostics::error(a3, "Symbol not found: %s\n  Referenced from: <%s> %s%s\n  Expected in:     <%s> %s", a5, (const char *)&v76, v46, v47, (const char *)v72, v39);
          mach_o::Error::~Error(&v56);
LABEL_48:
          uint64_t v34 = v63;
        }
      }
      long long v48 = *(_OWORD *)(v34 + 7);
      *(_OWORD *)a9 = *(_OWORD *)(v34 + 5);
      *(_OWORD *)(a9 + 16) = v48;
      *(void *)(a9 + 32) = v34[9];
    }
  }
  else
  {
    uint64_t v18 = this;
    switch(v12)
    {
      case -3:
        char v19 = *(unsigned char *)(*((void *)a2 + 1) + 202);
        *(void *)int v72 = 0;
        uint64_t v73 = v72;
        uint64_t v74 = 0x2000000000;
        char v75 = 0;
        uint64_t v20 = (uint64_t *)*((void *)a2 + 17);
        v59[0] = _NSConcreteStackBlock;
        v59[1] = 0x40000000;
        void v59[2] = ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke_2;
        void v59[3] = &unk_1EFF648A8;
        char v60 = v19;
        v59[8] = a2;
        v59[9] = a5;
        v59[6] = v72;
        v59[7] = this;
        v59[10] = a3;
        v59[4] = a8;
        v59[5] = &v62;
        dyld4::RuntimeLocks::withLoadersReadLock(v20, (uint64_t)v59);
        if (v73[24])
        {
          uint64_t v22 = (const dyld4::Loader *)v63[5];
          if (v22 != this) {
            dyld4::RuntimeState::addDynamicReference(a2, this, v22);
          }
          if (*((void *)a2 + 42) && (dyld4::Loader::hiddenFromFlat((dyld4::Loader *)v63[5], 0) & 1) == 0)
          {
            uint64_t v23 = v63[5];
            unint64_t v24 = v63[7] & 0x3FFFFFFFFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)v63 + 76) << 62) | ((unint64_t)*((unsigned __int8 *)v63 + 77) << 63);
            uint64_t v25 = *((void *)a2 + 42);
            uint64_t v77 = 0;
            long long v76 = (unint64_t)a5;
            uint64_t v26 = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert(v25, &v76);
            *(void *)(v26 + 8) = v23;
            *(void *)(v26 + 16) = v24;
          }
        }
        else if (v10)
        {
          __int16 v40 = v63;
          *((_DWORD *)v63 + 18) = 2;
          v40[7] = 0;
        }
        else
        {
          if ((*((_WORD *)this + 2) & 0x400) != 0) {
            dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)&v76, v21);
          }
          else {
            strcpy((char *)&v76, "no uuid");
          }
          char v52 = (const char *)dyld4::Loader::path(this, a2);
          Diagnostics::error(a3, "Symbol not found: %s\n  Referenced from: <%s> %s\n  Expected as weak-def export from some loaded dylib", a5, (const char *)&v76, v52);
        }
        uint64_t v53 = v63;
        long long v54 = *(_OWORD *)(v63 + 7);
        *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
        *(_OWORD *)(a9 + 16) = v54;
        *(void *)(a9 + 32) = v53[9];
        char v51 = v72;
        break;
      case -2:
        *(void *)&long long v76 = 0;
        *((void *)&v76 + 1) = &v76;
        uint64_t v77 = 0x2000000000;
        char v78 = 0;
        unsigned int v28 = (uint64_t *)*((void *)a2 + 17);
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 0x40000000;
        v61[2] = ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke;
        v61[3] = &unk_1EFF64880;
        v61[6] = this;
        v61[7] = a2;
        v61[8] = a3;
        v61[9] = a5;
        v61[4] = &v62;
        v61[5] = &v76;
        dyld4::RuntimeLocks::withLoadersReadLock(v28, (uint64_t)v61);
        if (*(unsigned char *)(*((void *)&v76 + 1) + 24))
        {
          long long v29 = (const dyld4::Loader *)v63[5];
          if (v29 != this) {
            dyld4::RuntimeState::addDynamicReference(a2, this, v29);
          }
        }
        else if (v10)
        {
          __int16 v41 = v63;
          *((_DWORD *)v63 + 18) = 2;
          v41[7] = 0;
        }
        else if (HIDWORD(v55) && (uint64_t v44 = *((void *)a2 + 15)) != 0)
        {
          uint64_t v45 = v63;
          v63[5] = *((void *)a2 + 13);
          v45[6] = (uint64_t)a5;
          v45[7] = v44;
          v45[8] = 0;
          *((_DWORD *)v45 + 18) = 1;
          *((_DWORD *)v45 + 19) = 0x10000;
        }
        else
        {
          Diagnostics::error(a3, "symbol not found in flat namespace '%s'", a5);
        }
        uint64_t v49 = v63;
        long long v50 = *(_OWORD *)(v63 + 7);
        *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
        *(_OWORD *)(a9 + 16) = v50;
        *(void *)(a9 + 32) = v49[9];
        char v51 = &v76;
        break;
      case -1:
        uint64_t v18 = (dyld4::Loader *)*((void *)a2 + 3);
        goto LABEL_16;
      case 0:
        goto LABEL_16;
      default:
        uint64_t v27 = (const char *)dyld4::Loader::path(this, a2);
        Diagnostics::error(a3, "unknown library ordinal %d in %s when binding '%s'", v12, v27, a5);
        goto LABEL_48;
    }
    _Block_object_dispose(v51, 8);
  }
  _Block_object_dispose(&v62, 8);
}

uint64_t dyld4::JustInTimeLoader::dependent(dyld4::JustInTimeLoader *this, int a2, unsigned int a3, char *a4)
{
  unint64_t v4 = *((void *)this + 5);
  if (a3 >= (unsigned __int16)(v4 >> 39)) {
    dyld4::JustInTimeLoader::dependent();
  }
  if (a4)
  {
    if ((v4 & 0x800000) != 0) {
      long long v8 = &mach_o::LinkedDylibAttributes::regular;
    }
    else {
      long long v8 = (char *)dyld4::JustInTimeLoader::dependentAttrs(this, a3);
    }
    *a4 = *v8;
  }
  return *((void *)this + a3 + 58);
}

uint64_t dyld4::JustInTimeLoader::dependentCount(dyld4::JustInTimeLoader *this)
{
  return (unsigned __int16)(*((void *)this + 5) >> 39);
}

uint64_t dyld4::JustInTimeLoader::dependentAttrs(dyld4::JustInTimeLoader *this, unsigned int a2)
{
  unint64_t v2 = *((void *)this + 5);
  uint64_t v3 = (unsigned __int16)(v2 >> 39);
  if (v3 <= a2) {
    dyld4::JustInTimeLoader::dependentAttrs();
  }
  if ((v2 & 0x800000) != 0) {
    dyld4::JustInTimeLoader::dependentAttrs();
  }
  return (uint64_t)this + 8 * v3 + a2 + 464;
}

BOOL dyld3::MachOFile::hasCodeSignature(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  *a2 = 0;
  *a3 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v18);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  unsigned int v17[2] = ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke;
  v17[3] = &__block_descriptor_tmp_157;
  v17[4] = a2;
  v17[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v18, (uint64_t)v17);
  Diagnostics::assertNoError((Diagnostics *)&v18);
  if (*a2)
  {
    if ((*((_DWORD *)this + 1) | 0x1000000) == 0x1000007)
    {
      uint64_t v13 = 0;
      uint64_t v14 = &v13;
      uint64_t v15 = 0x2000000000;
      char v16 = 0;
      uint64_t v9 = 0;
      int v10 = &v9;
      uint64_t v11 = 0x2000000000;
      char v12 = 0;
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke_2;
      void v8[3] = &unk_1EFF66598;
      void v8[4] = &v13;
      void v8[5] = &v9;
      dyld3::MachOFile::forEachSupportedPlatform(this, (uint64_t)v8);
      if (*((unsigned char *)v14 + 24)) {
        BOOL v6 = *((unsigned char *)v10 + 24) == 0;
      }
      else {
        BOOL v6 = 0;
      }
      _Block_object_dispose(&v9, 8);
      _Block_object_dispose(&v13, 8);
    }
    else
    {
      BOOL v6 = 1;
    }
  }
  else
  {
    BOOL v6 = 0;
  }
  mach_o::Error::~Error(&v18);
  return v6;
}

void dyld4::PrebuiltLoader::invalidateInIsolation(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    uint64_t v3 = (char *)a2 + 976;
  }
  else {
    uint64_t v3 = (char *)a2 + 1000;
  }
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v2 & 0x7FFF;
  if (*(unsigned __int8 *)(*(void *)v3 + v5) > 1u) {
    return;
  }
  if ((*((_WORD *)this + 2) & 2) != 0)
  {
    uint64_t v19 = *((void *)a2 + 1);
    if (!*(void *)(v19 + 240))
    {
      *(unsigned char *)(v4 + v5) = -1;
      return;
    }
    if ((*((_WORD *)this + 22) & 2) != 0)
    {
      if (!*(unsigned char *)(v19 + 396))
      {
        if (*((_WORD *)this + 16)) {
          uint64_t v20 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
        }
        else {
          uint64_t v20 = 0;
        }
        if (!dyld4::ProcessConfig::DyldCache::isAlwaysOverridablePath(v20, (const char *)a2)) {
          return;
        }
        uint64_t v19 = *((void *)a2 + 1);
      }
      *(void *)&long long v36 = 0;
      *((void *)&v36 + 1) = &v36;
      *(void *)&long long v37 = 0x2000000000;
      BYTE8(v37) = 0;
      char v35 = 0;
      if (*((_WORD *)this + 16)) {
        uint64_t v21 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = (const char *)*(unsigned int *)(v19 + 68);
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 0x40000000;
      void v34[2] = ___ZNK5dyld414PrebuiltLoader21invalidateInIsolationERKNS_12RuntimeStateE_block_invoke;
      v34[3] = &unk_1EFF64D60;
      v34[5] = this;
      v34[6] = a2;
      v34[4] = &v36;
      dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v19 + 400, v21, v22, 0, 1, &v35, (uint64_t)v34);
      if (*(unsigned char *)(*((void *)&v36 + 1) + 24))
      {
        if (*(unsigned char *)(*((void *)a2 + 1) + 207))
        {
          uint64_t v23 = dyld4::Loader::leafName(this, a2);
          dyld4::console((dyld4 *)"PrebuiltLoader %p '%s' not used because a file was found that overrides it\n", v24, this, v23);
        }
        *(unsigned char *)(v4 + v5) = -1;
      }
      _Block_object_dispose(&v36, 8);
    }
  }
  else if (*((_WORD *)this + 21) && (long long v8 = (char *)this + *((unsigned __int16 *)this + 21), v8[52]))
  {
    uint64_t v10 = *((void *)v8 + 1);
    uint64_t v9 = *((void *)v8 + 2);
    uint64_t v11 = *((void *)v8 + 3);
    long long v36 = 0u;
    long long v37 = 0u;
    uint64_t v12 = *((void *)a2 + 1);
    if (*((_WORD *)this + 16)) {
      uint64_t v13 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
    }
    else {
      uint64_t v13 = 0;
    }
    if (!dyld4::SyscallDelegate::fileExists(v12, v13, (uint64_t)&v36, 0))
    {
      *(unsigned char *)(v4 + v5) = -1;
      if (!*(unsigned char *)(*((void *)a2 + 1) + 207)) {
        return;
      }
      uint64_t v18 = "PrebuiltLoader %p not used because file missing\n";
LABEL_56:
      dyld4::console((dyld4 *)v18, v14, this);
      return;
    }
    if (*((void *)&v36 + 1) != v10 || BYTE8(v37) == 0 || (void)v36 != v9 || (void)v37 != v11)
    {
      *(unsigned char *)(v4 + v5) = -1;
      if (*(unsigned char *)(*((void *)a2 + 1) + 207))
      {
        uint64_t v18 = "PrebuiltLoader %p not used because file inode/mtime does not match\n";
        goto LABEL_56;
      }
    }
  }
  else
  {
    if (*((_WORD *)this + 16)) {
      uint64_t v25 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
    }
    else {
      uint64_t v25 = 0;
    }
    uint64_t v26 = (const char **)*((void *)a2 + 1);
    if (_platform_strcmp((const char *)v25, v26[2]))
    {
      int v27 = dyld4::SyscallDelegate::open((dyld4::SyscallDelegate *)v26, v25, 0, 0);
      if (v27 == -1)
      {
        *(unsigned char *)(v4 + v5) = -1;
        if (*(unsigned char *)(*((void *)a2 + 1) + 207)) {
          dyld4::console((dyld4 *)"PrebuiltLoader %p not used because file '%s' cannot be opened\n", v28, this, v25);
        }
      }
      else
      {
        int v29 = v27;
        Diagnostics::Diagnostics((Diagnostics *)&v36);
        if (*((_WORD *)this + 21)) {
          uint64_t v30 = (char *)this + *((unsigned __int16 *)this + 21);
        }
        else {
          uint64_t v30 = 0;
        }
        size_t v32 = dyld4::Loader::validateFile((vm_address_t *)&v36, (uint64_t)a2, v29, (const char *)v25, (unsigned int *)this + 20, (uint64_t)v30);
        long long v33 = (dyld4::SyscallDelegate *)*((void *)a2 + 1);
        if (v32 == -1)
        {
          *(unsigned char *)(v4 + v5) = -1;
          if (*((unsigned char *)v33 + 207))
          {
            dyld4::console((dyld4 *)"PrebuiltLoader %p not used because file '%s' cdHash changed\n", v31, this, v25);
            long long v33 = (dyld4::SyscallDelegate *)*((void *)a2 + 1);
          }
        }
        dyld4::SyscallDelegate::close(v33, v29);
        mach_o::Error::~Error((vm_address_t **)&v36);
      }
    }
  }
}

_WORD *dyld4::PrebuiltLoader::invalidateShallow(_WORD *this, const dyld4::RuntimeState *a2)
{
  if (this[24])
  {
    uint64_t v3 = this;
    unsigned int v4 = 0;
    do
    {
      this = (_WORD *)dyld4::PrebuiltLoader::dependent(v3, a2, v4, 0);
      if (this && (this[2] & 1) != 0)
      {
        __int16 v5 = this[3];
        uint64_t v6 = *((void *)a2 + 125);
        uint64_t v7 = v5 >= 0 ? *((void *)a2 + 122) : *((void *)a2 + 125);
        if (*(unsigned __int8 *)(v7 + (v5 & 0x7FFF)) == 255)
        {
          __int16 v8 = v3[3];
          if (v8 >= 0) {
            uint64_t v6 = *((void *)a2 + 122);
          }
          *(unsigned char *)(v6 + (v8 & 0x7FFF)) = -1;
        }
      }
      ++v4;
    }
    while (v4 < (unsigned __int16)v3[24]);
  }
  return this;
}

uint64_t dyld4::PrebuiltLoaderSet::findLoader(dyld4::PrebuiltLoaderSet *this, const dyld4::RuntimeState *a2, const char *a3)
{
  unsigned __int16 v5 = 0;
  if (!dyld4::PrebuiltLoaderSet::findIndex(this, a2, a3, &v5)) {
    return 0;
  }
  if (*((_DWORD *)this + 3) <= v5) {
    dyld4::RuntimeState::findPrebuiltLoader();
  }
  return (uint64_t)this + *(unsigned int *)((char *)this + 4 * v5 + *((unsigned int *)this + 4));
}

BOOL dyld4::PrebuiltLoaderSet::findIndex(dyld4::PrebuiltLoaderSet *this, const dyld4::RuntimeState *a2, const char *__s2, unsigned __int16 *a4)
{
  unsigned int v4 = *((_DWORD *)this + 3);
  if (v4)
  {
    int v8 = 0;
    BOOL v9 = 1;
    while (1)
    {
      if (v4 <= (unsigned __int16)v8) {
        dyld4::RuntimeState::findPrebuiltLoader();
      }
      uint64_t v10 = (char *)this + *(unsigned int *)((char *)this + 4 * (unsigned __int16)v8 + *((unsigned int *)this + 4));
      uint64_t v11 = *((unsigned __int16 *)v10 + 16);
      uint64_t v12 = &v10[v11];
      uint64_t v13 = v11 ? v12 : 0;
      if (!_platform_strcmp(v13, __s2)) {
        break;
      }
      BOOL v9 = ++v8 < v4;
      if (v4 == v8) {
        return 0;
      }
    }
    *a4 = v8;
  }
  else
  {
    return 0;
  }
  return v9;
}

uint64_t dyld3::MachOFile::hasConstObjCSection(dyld3::MachOFile *this)
{
  if ((dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_selrefs") & 1) != 0
    || (dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_classrefs") & 1) != 0
    || (dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_protorefs") & 1) != 0)
  {
    return 1;
  }

  return dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_superrefs");
}

uint64_t dyld3::MachOFile::hasSection(dyld3::MachOFile *this, const char *a2, const char *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile10hasSectionEPKcS2__block_invoke;
  void v5[3] = &unk_1EFF66198;
  v5[5] = a2;
  void v5[6] = a3;
  v5[4] = &v6;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

dyld4::RuntimeState *dyld4::RuntimeState::addDynamicReference(dyld4::RuntimeState *this, const dyld4::Loader *a2, const dyld4::Loader *a3)
{
  unsigned __int16 v5 = this;
  if ((*((_WORD *)a3 + 2) & 0x20) == 0
    || (this = (dyld4::RuntimeState *)dyld4::Loader::isDelayInit(a3, this), this))
  {
    uint64_t v6 = *((void *)v5 + 16);
    uint64_t v7 = (void *)*((void *)v5 + 17);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    unsigned int v17 = (void (*)(void *))___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke;
    uint64_t v18 = &__block_descriptor_tmp_45;
    uint64_t v19 = v5;
    uint64_t v20 = a2;
    uint64_t v23 = v6;
    uint64_t v21 = a3;
    unint64_t v22 = 0;
    if (v6) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = 0;
    }
    if (*(unsigned char *)(v8 + 32))
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_45;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_45;
      }
      unint64_t v22 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
      if (!v22)
      {
        if (!MEMORY[0xFFFFFC10C]) {
          goto LABEL_45;
        }
        if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_45;
        }
        this = (dyld4::RuntimeState *)MEMORY[0xFFFFFC0D0];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v9 = MEMORY[0xFFFFFC0D0];
        if (v9 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
          goto LABEL_45;
        }
      }
    }
    else
    {
      unint64_t v22 = 1;
      lsl::MemoryManager::lockGuard((lsl::Lock *)v8, &v24);
      uint64_t v10 = *(void *)(v8 + 24);
      if (!v10)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v8, 0);
        uint64_t v10 = *(void *)(v8 + 24);
      }
      *(void *)(v8 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10 + 1;
      lsl::Lock::unlock(v24);
    }
    if (*v7)
    {
      (*(void (**)(void, void *, void))(*(void *)*v7 + 104))(*v7, v7 + 1, 0);
      v17(v16);
      this = (dyld4::RuntimeState *)(*(uint64_t (**)(void, void *))(*(void *)*v7 + 112))(*v7, v7 + 1);
    }
    else
    {
      this = (dyld4::RuntimeState *)((uint64_t (*)(void *))v17)(v16);
    }
    if (v23) {
      uint64_t v11 = v23;
    }
    else {
      uint64_t v11 = 0;
    }
    if (*(unsigned char *)(v11 + 32))
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_45;
      }
      if (v22 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        return this;
      }
      if (v22 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_45;
        }
        this = (dyld4::RuntimeState *)MEMORY[0xFFFFFC0D0];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v12 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_45;
        }
        this = (dyld4::RuntimeState *)MEMORY[0xFFFFFC0D8];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v12 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v12 == StatusReg) {
        return this;
      }
LABEL_45:
      __break(1u);
      return this;
    }
    lsl::MemoryManager::lockGuard((lsl::Lock *)v11, &v24);
    if (v22 == 1)
    {
      uint64_t v15 = *(void *)(v11 + 24) - 1;
      *(void *)(v11 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v15;
      if (!v15) {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v11, 1);
      }
    }
    else if (v22 == 0xFFFFFFFF)
    {
      uint64_t v14 = *(void *)(v11 + 24);
      if (!v14)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v11, 0);
        uint64_t v14 = *(void *)(v11 + 24);
      }
      *(void *)(v11 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14 + 1;
    }
    return (dyld4::RuntimeState *)lsl::Lock::unlock(v24);
  }
  return this;
}

void ___ZN13prebuilt_objc12forEachClassEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    uint64_t v2 = __chkstk_darwin();
    uint64_t v6 = (char *)v12 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v7 = v3[2];
    v12[0] = v6;
    v12[1] = v7;
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = *v3;
      uint64_t v10 = 8 * v7;
      do
      {
        if (v7 == v8) {
          ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
        }
        uint64_t v11 = v8 + 1;
        *(void *)&v6[8 * v8] = *(void *)(v9 + 8 * v8);
        ++v8;
        v10 -= 8;
      }
      while (v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    v12[2] = v11;
    (*(void (**)(void, void *, uint64_t))(*(void *)(v2 + 32) + 16))(*(void *)(v2 + 32), v12, v4);
  }
}

uint64_t ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(dyld4::RuntimeState **)(result + 48);
    uint64_t v5 = *(dyld4::PrebuiltLoader::BindTargetRef ***)a2;
    uint64_t v6 = 8 * v2 - 8;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v8 = *(void *)(v3 + 32);
      unint64_t v9 = dyld4::PrebuiltLoader::BindTargetRef::value(v7, v4);
      BOOL result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v8 + 16))(v8, v9, 1, *(void *)(*(void *)(v3 + 40) + 8) + 24);
      if (*(unsigned char *)(*(void *)(*(void *)(v3 + 40) + 8) + 24)) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v6 == 0;
      }
      v6 -= 8;
    }
    while (!v10);
  }
  return result;
}

BOOL dyld4::APIs::_dyld_get_image_uuid(dyld4::APIs *this, mach_header *a2, unsigned __int8 *a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_uuid(%p, %p)\n", a2, a3);
  }
  BOOL result = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)a2);
  if (result)
  {
    return dyld3::MachOFile::getUuid((dyld3::MachOFile *)a2, a3);
  }
  return result;
}

BOOL dyld4::APIs::dyld_program_minos_at_least(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  int v3 = v2[16];
  BOOL v4 = v3 != 0;
  if (a2 == -1)
  {
    unsigned int v5 = v2[15];
  }
  else if (v3 == a2 || v2[17] == a2)
  {
    unsigned int v5 = v2[14];
  }
  else
  {
    unsigned int v5 = 0;
    BOOL v4 = 0;
  }
  return v5 >= HIDWORD(a2) && v4;
}

void ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = *(dyld4::Loader **)(a1 + 56);
  if (*(unsigned char *)(a1 + 88)) {
    dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 64), "looking for weak-def symbol '%s':\n", v61);
  }
  uint64_t v10 = *(void *)(a1 + 64);
  unint64_t v11 = *(void *)(v10 + 328) + 1;
  *(void *)(v10 + 328) = v11;
  if (v11 >= 0x1389 && !*(void *)(v10 + 336))
  {
    uint64_t v12 = lsl::Allocator::malloc(*(lsl::Lock ***)(v10 + 16), 0x60uLL);
    *(void *)(*(void *)(a1 + 64) + 336) = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)v12);
    uint64_t v10 = *(void *)(a1 + 64);
  }
  uint64_t v13 = *(const char ***)(v10 + 336);
  if (v13
    && (uint64_t v13 = dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>((uint64_t)v13, (uint64_t *)v13 + 2, v13 + 7, 0, (const char **)(a1 + 72)), v13 != (const char **)(*(void *)(*(void *)(*(void *)(a1 + 64) + 336) + 56)+ 24 * *(void *)(*(void *)(*(void *)(a1 + 64) + 336) + 72)))&& (v14 = v13[1]) != 0)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 4dyld4::halt((char *)__format, 0) = v14;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = *(void *)(a1 + 72);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56) = (unint64_t)v13[2] & 0x3FFFFFFFFFFFFFFFLL;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 64) = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 72) = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 76) = ((unint64_t)v13[2] & 0x4000000000000000) != 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 77) = (uint64_t)v13[2] < 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 78) = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 79) = 0;
    if (*(unsigned char *)(a1 + 88))
    {
      uint64_t v15 = *(const dyld4::RuntimeState **)(a1 + 64);
      char v16 = *(const char **)(a1 + 72);
      unsigned int v17 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v15);
      dyld4::RuntimeState::log(v15, "  found %s in map, using impl from %s\n", v16, v17);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  else
  {
    __chkstk_darwin((uint64_t)v13, a2, a3, a4, a5, a6, a7, a8, (uint64_t)&v62);
    size_t v65 = (char *)&v62 - ((v18 + 23) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v19 = *(const dyld4::RuntimeState **)(a1 + 64);
    unint64_t v64 = *((void *)v19 + 6);
    if ((*((_WORD *)v9 + 2) & 2) != 0)
    {
      int hasOpcodeFixups = 0;
    }
    else
    {
      uint64_t v20 = (dyld3::MachOFile *)dyld4::Loader::mf(v9, v19);
      int hasOpcodeFixups = dyld3::MachOFile::hasOpcodeFixups(v20);
      uint64_t v19 = *(const dyld4::RuntimeState **)(a1 + 64);
    }
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    v69[0] = (char *)v19 + 32;
    v69[1] = (char *)v19 + 64;
    int v63 = v65 + 8;
    do
    {
      uint64_t v24 = v69[v22];
      uint64_t v25 = *(void *)(v24 + 16);
      if (v25)
      {
        uint64_t v26 = *(dyld4::Loader ***)(v24 + 8);
        uint64_t v27 = 8 * v25;
        unsigned int v28 = v26;
        do
        {
          if ((*((_WORD *)*v28 + 2) & 0x800) != 0)
          {
            int v29 = *v28;
            if ((dyld4::Loader::hiddenFromFlat(*v28, 0) & 1) == 0)
            {
              if (dyld4::Loader::hasExportedSymbol((uint64_t)v29, *(vm_address_t **)(a1 + 80), *(const dyld4::RuntimeState **)(a1 + 64), *(const unsigned __int8 **)(a1 + 72), 1u, 1, (uint64_t *)v66, 0))
              {
                int v30 = BYTE5(v68) ? 0 : hasOpcodeFixups;
                if (v30 != 1 || (*((_WORD *)v29 + 2) & 2) == 0)
                {
                  if ((*(_WORD *)(*(void *)v66 + 4) & 2) != 0
                    && (dyld4::Loader::hasBeenFixedUp(v29, *(dyld4::RuntimeState **)(a1 + 64)) & 1) == 0)
                  {
                    if (v23 >= v64) {
                      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
                    }
                    uint64_t v31 = v67;
                    size_t v32 = &v65[16 * v23++];
                    *(void *)size_t v32 = *(void *)v66;
                    *((void *)v32 + 1) = v31;
                  }
                  uint64_t v33 = *(void *)(*(void *)(a1 + 48) + 8);
                  if (!*(unsigned char *)(v33 + 24))
                  {
                    *(unsigned char *)(v33 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
                    uint64_t v34 = *(void *)(*(void *)(a1 + 40) + 8);
                    long long v35 = v67;
                    *(_OWORD *)(v34 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)v66;
                    *(_OWORD *)(v34 + 56) = v35;
                    *(void *)(v34 + 72) = v68;
                    if (*(unsigned char *)(a1 + 88))
                    {
                      long long v37 = *(const dyld4::RuntimeState **)(a1 + 64);
                      long long v36 = *(const char **)(a1 + 72);
                      uint64_t v38 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)v66, v37);
                      dyld4::RuntimeState::log(v37, "  using '%s' in %s\n", v36, v38);
                    }
                  }
                  if (!BYTE5(v68))
                  {
                    uint64_t v39 = *(void *)(*(void *)(a1 + 40) + 8);
                    if (*(unsigned char *)(v39 + 77))
                    {
                      long long v40 = v67;
                      *(_OWORD *)(v39 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)v66;
                      *(_OWORD *)(v39 + 56) = v40;
                      *(void *)(v39 + 72) = v68;
                      if (*(unsigned char *)(a1 + 88))
                      {
                        uint64_t v42 = *(const dyld4::RuntimeState **)(a1 + 64);
                        __int16 v41 = *(const char **)(a1 + 72);
                        uint64_t v43 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)v66, v42);
                        dyld4::RuntimeState::log(v42, "  using non-weak '%s' in %s\n", v41, v43);
                      }
                    }
                  }
                }
              }
            }
          }
          ++v28;
          ++v26;
          v27 -= 8;
        }
        while (v27);
      }
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)
        && dyld4::Loader::hiddenFromFlat(v9, 0))
      {
        if (*(unsigned char *)(a1 + 88))
        {
          uint64_t v45 = *(const dyld4::RuntimeState **)(a1 + 64);
          uint64_t v44 = *(const char **)(a1 + 72);
          __int16 v46 = (char *)dyld4::Loader::path(v9, v45);
          char v47 = strrchr(v46, 47);
          if (v47) {
            long long v48 = v47 + 1;
          }
          else {
            long long v48 = v46;
          }
          dyld4::RuntimeState::log(v45, "  did not find unhidden '%s', trying self (%s)\n", v44, v48);
        }
        if (dyld4::Loader::hasExportedSymbol((uint64_t)v9, *(vm_address_t **)(a1 + 80), *(const dyld4::RuntimeState **)(a1 + 64), *(const unsigned __int8 **)(a1 + 72), 1u, 1, (uint64_t *)v66, 0))
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
          uint64_t v49 = *(void *)(*(void *)(a1 + 40) + 8);
          long long v50 = v67;
          *(_OWORD *)(v49 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)v66;
          *(_OWORD *)(v49 + 56) = v50;
          *(void *)(v49 + 72) = v68;
        }
      }
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
        BOOL v51 = v23 == 0;
      }
      else {
        BOOL v51 = 1;
      }
      if (!v51
        && (*(_WORD *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) + 4) & 2) == 0
        && *(void *)(a1 + 32))
      {
        uint64_t v52 = 0;
        uint64_t v53 = 16 * v23;
        long long v54 = v63;
        do
        {
          uint64_t v55 = (dyld3::MachOFile *)dyld4::Loader::mf(*((dyld4::Loader **)v54 - 1), *(const dyld4::RuntimeState **)(a1 + 64));
          v66[0] = 0;
          if (dyld4::ProcessConfig::DyldCache::findMachHeaderImageIndex((DyldSharedCache **)(*(void *)(*(void *)(a1 + 64) + 8) + 240), (const mach_header *)v55, v66))
          {
            uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v55);
            __int16 v57 = *(dyld4::RuntimeState **)(a1 + 64);
            uint64_t v58 = *(void *)v54 + Address - *(void *)(*((void *)v57 + 1) + 272);
            if (v58 != v52)
            {
              if (*(unsigned char *)(a1 + 88))
              {
                uint64_t v59 = *(const char **)(a1 + 72);
                char v60 = (const char *)dyld4::Loader::path(*((dyld4::Loader **)v54 - 1), *(const dyld4::RuntimeState **)(a1 + 64));
                dyld4::RuntimeState::log(v57, "  found use of '%s' in cache, need to override: %s\n", v59, v60);
              }
              (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
              uint64_t v52 = v58;
            }
          }
          v54 += 16;
          v53 -= 16;
        }
        while (v53);
      }
      ++v22;
    }
    while (v22 != 2);
  }
}

unint64_t ___ZN5dyld44APIs5dlsymEPvPKc_block_invoke(unint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 56);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    unint64_t v3 = result;
    BOOL v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    uint64_t v6 = v4;
    while (1)
    {
      uint64_t v7 = *v6;
      BOOL result = dyld4::Loader::hiddenFromFlat(*v6, 0);
      if ((result & 1) == 0)
      {
        BOOL result = dyld4::Loader::hasExportedSymbol((uint64_t)v7, (vm_address_t *)(*(void *)(*(void *)(v3 + 32) + 8) + 40), v1, *(const unsigned __int8 **)(v3 + 64), 1u, 0, (uint64_t *)(*(void *)(*(void *)(v3 + 40) + 8) + 40), 0);
        if (result) {
          break;
        }
      }
      ++v6;
      ++v4;
      v5 -= 8;
      if (!v5) {
        return result;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(v3 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

unint64_t dyld4::Loader::hiddenFromFlat(dyld4::Loader *this, char a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::hiddenFromFlat();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::hiddenFromFlat(this);
  }
  else
  {
    return dyld4::JustInTimeLoader::hiddenFromFlat(this, a2);
  }
}

unint64_t dyld4::JustInTimeLoader::hiddenFromFlat(dyld4::JustInTimeLoader *this, char a2)
{
  unint64_t v2 = *((void *)this + 5);
  if ((a2 & 1) == 0) {
    return (v2 >> 19) & 1;
  }
  unint64_t result = 0;
  *((void *)this + 5) = v2 & 0xFFFFFFFFFFF7FFFFLL;
  return result;
}

uint64_t dyld4::Loader::hasBeenFixedUp(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::hasBeenFixedUp();
  }
  if (*((_WORD *)this + 2))
  {
    return dyld4::PrebuiltLoader::hasBeenFixedUp((uint64_t)this, (uint64_t)a2);
  }
  else
  {
    return dyld4::JustInTimeLoader::hasBeenFixedUp(this, a2);
  }
}

BOOL dyld4::PrebuiltLoader::hasBeenFixedUp(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a1 + 6);
  if (v2 >= 0) {
    unint64_t v3 = (void *)(a2 + 976);
  }
  else {
    unint64_t v3 = (void *)(a2 + 1000);
  }
  return *(unsigned __int8 *)(*v3 + (v2 & 0x7FFF)) > 5u;
}

uint64_t dyld3::MachOFile::hasOpcodeFixups(dyld3::MachOFile *this)
{
  if (dyld3::MachOFile::hasLoadCommand(this, -2147483614)) {
    return 1;
  }

  return dyld3::MachOFile::hasLoadCommand(this, 34);
}

uint64_t _graft_fetch_fire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v47 = -1;
  int v4 = openat(*(_DWORD *)(a3 + 16), "System/Cryptexes/OS", 0x100000);
  int v48 = v4;
  uint64_t v5 = __error();
  if (v4 < 0)
  {
    if (!*v5) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v6, v7, v8, v9, v10, v11, v12, (int)"cnl");
    }
  }
  else
  {
    *uint64_t v5 = 0;
  }
  int v13 = *__error();
  if (v13 == 2)
  {
    pid_t v19 = getpid();
    dlog(-1, "libignition: %d: %12s: no os cryptex available; continuing\n", v20, v21, v22, v23, v24, v25, v19);
    goto LABEL_8;
  }
  if (!v13)
  {
    int v47 = dupfd(v4, (int)"os cryptex canonical directory");
LABEL_8:
    boot_set_root(a3, (uint64_t)&_boot_root_canonical_os, &v48, v14, v15, v16, v17, v18);
    boot_set_root(a3, (uint64_t)&_boot_root_cryptex_os, &v47, v26, v27, v28, v29, v30);
    uint64_t v31 = 0;
    goto LABEL_10;
  }
  uint64_t v31 = *__error();
  pid_t v32 = getpid();
  dlog(-1, "libignition: %d: %12s: failed to open os cryptex canonical directory: %d\n", v33, v34, v35, v36, v37, v38, v32);
LABEL_10:
  closefd_optional(&v48, (int)"os cryptex canonical directory");
  closefd_optional(&v47, (int)"os cryptex canonical directory [dup]");
  if (v31 >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v39, v40, v41, v42, v43, v44, v45, v31);
  }
  return v31;
}

uint64_t boot_set_root(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 16);
  if (v8 < 0) {
    dyld_halt("invalid offset: %lld", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 16));
  }
  uint64_t v10 = (_DWORD *)(a1 + v8);
  closefd_optional((int *)(a1 + v8), (int)"old root");
  uint64_t result = xferfd(a3);
  *uint64_t v10 = result;
  return result;
}

void dyld4::JustInTimeLoader::applyFixups(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v61);
  uint64_t v14 = v11;
  uint64_t v15 = (dyld4::RuntimeState *)v10;
  uint64_t v16 = (const dyld4::Loader *)v8;
  if ((*(_WORD *)(v8 + 4) & 2) != 0)
  {
    if (*(unsigned char *)(v10 + 1134))
    {
      uint64_t v19 = *(void *)(v10 + 48);
      if (v19)
      {
        uint64_t v20 = *(dyld4::Loader ***)(v10 + 40);
        uint64_t v21 = 8 * v19;
        uint64_t v22 = v20;
        do
        {
          uint64_t v23 = *v22++;
          dyld4::Loader::applyCachePatchesTo(v23, v15, v16, v14);
          ++v20;
          v21 -= 8;
        }
        while (v21);
      }
    }
    *((void *)v16 + 5) |= 0x20000uLL;
  }
  else if (!*(void *)(v8 + 104))
  {
    uint64_t v17 = v9;
    v57[0] = _NSConcreteStackBlock;
    v57[1] = 0x40000000;
    v57[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke;
    v57[3] = &__block_descriptor_tmp_23;
    v57[4] = v10;
    v57[5] = v11;
    uint64_t v47 = 0;
    int v48 = &v47;
    uint64_t v49 = 0x5002000000;
    long long v50 = __Block_byref_object_copy__24;
    BOOL v51 = __Block_byref_object_dispose__25;
    uint64_t v52 = &v60;
    uint64_t v53 = 512;
    uint64_t v54 = 0;
    vm_address_t v55 = 0;
    vm_size_t v56 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = &v37;
    uint64_t v39 = 0x5002000000;
    uint64_t v40 = __Block_byref_object_copy__24;
    uint64_t v41 = __Block_byref_object_dispose__25;
    uint64_t v42 = &v59;
    uint64_t v43 = 32;
    uint64_t v44 = 0;
    vm_address_t v45 = 0;
    vm_size_t v46 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = &v27;
    uint64_t v29 = 0x5002000000;
    uint64_t v30 = __Block_byref_object_copy__26_0;
    uint64_t v31 = __Block_byref_object_dispose__27_0;
    pid_t v32 = &v58;
    uint64_t v33 = 4;
    uint64_t v34 = 0;
    vm_address_t address = 0;
    vm_size_t size = 0;
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000;
    void v26[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_28;
    void v26[3] = &unk_1EFF64BA0;
    v26[6] = v8;
    v26[7] = v10;
    v26[4] = &v47;
    v26[5] = &v27;
    v26[8] = v13;
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 0x40000000;
    v25[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_2;
    v25[3] = &unk_1EFF64BC8;
    v25[6] = v8;
    v25[7] = v10;
    v25[4] = &v37;
    v25[5] = &v27;
    dyld4::Loader::forEachBindTarget((dyld4::Loader *)v8, v9, (dyld4::RuntimeState *)v10, (uint64_t)v57, v12, (uint64_t)v26, (uint64_t)v25);
    if (!Diagnostics::hasError((Diagnostics *)v17))
    {
      dyld4::Loader::applyFixupsGeneric(v16, v17, v15, *((void *)v16 + 6), (uint64_t)(v48 + 5), (uint64_t)(v38 + 5), 1, (uint64_t)(v28 + 5));
      if (*(_DWORD *)(*((void *)v15 + 1) + 68) == 1)
      {
        if (*((void *)v15 + 13))
        {
          uint64_t v18 = (dyld3::MachOFile *)*((void *)v16 + 4);
          if ((dyld3::MachOFile::inDyldCache(v18) & 1) == 0)
          {
            v24[0] = _NSConcreteStackBlock;
            v24[1] = 0x40000000;
            v24[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_3;
            v24[3] = &__block_descriptor_tmp_40_0;
            v24[4] = v18;
            void v24[5] = v15;
            dyld3::MachOFile::forEachSupportedPlatform(v18, (uint64_t)v24);
          }
        }
      }
      if (dyld4::Loader::hasConstantSegmentsToProtect(v16)) {
        dyld4::Loader::makeSegmentsReadOnly(v16, v15);
      }
      if (Diagnostics::noError((Diagnostics *)v17)) {
        *((void *)v16 + 5) |= 0x20000uLL;
      }
    }
    _Block_object_dispose(&v27, 8);
    uint64_t v34 = 0;
    if (address) {
      vm_deallocate(mach_task_self_, address, size);
    }
    _Block_object_dispose(&v37, 8);
    uint64_t v44 = 0;
    if (v45) {
      vm_deallocate(mach_task_self_, v45, v46);
    }
    _Block_object_dispose(&v47, 8);
    uint64_t v54 = 0;
    if (v55) {
      vm_deallocate(mach_task_self_, v55, v56);
    }
  }
}

void dyld4::Loader::applyFixupsGeneric(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(a1, a3);
  uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
  if (dyld3::MachOFile::hasChainedFixups(Address))
  {
    if (!*(_DWORD *)(*((void *)a3 + 1) + 164)
      || !dyld3::MachOFile::hasChainedFixupsLoadCommand(Address)
      || *(void *)(a5 + 16) >> 4 > 0x270uLL
      || (dyld4::Loader::setUpPageInLinking(a1, a2, a3, Slide, a4, a5),
          BOOL hasError = Diagnostics::hasError((Diagnostics *)a2),
          Diagnostics::clearError((vm_address_t **)a2),
          hasError))
    {
      uint64_t v18 = dyld3::MachOAnalyzer::chainStartsOffset(Address);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 0x40000000;
      v22[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke;
      v22[3] = &__block_descriptor_tmp_92;
      v22[4] = Address;
      v22[5] = a2;
      v22[6] = Slide;
      void v22[7] = a5;
      v22[8] = a3;
      dyld3::MachOAnalyzer::withChainStarts(Address, a2, v18, (uint64_t)v22);
    }
  }
  else if (dyld3::MachOFile::hasOpcodeFixups(Address))
  {
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_3;
    void v21[3] = &__block_descriptor_tmp_95;
    v21[4] = Address;
    v21[5] = Slide;
    v21[6] = a3;
    dyld3::MachOAnalyzer::forEachRebaseLocation_Opcodes(Address, a2, (uint64_t)v21);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      void v20[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_4;
      v20[3] = &__block_descriptor_tmp_98_0;
      void v20[4] = a1;
      void v20[5] = Address;
      v20[6] = a5;
      v20[7] = a3;
      void v20[8] = a8;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000;
      void v19[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_5;
      v19[3] = &__block_descriptor_tmp_101;
      v19[4] = a1;
      v19[5] = Address;
      v19[6] = a6;
      v19[7] = a3;
      dyld3::MachOAnalyzer::forEachBindLocation_Opcodes(Address, a2, (uint64_t)v20, (uint64_t)v19);
    }
  }
}

uint64_t dyld3::MachOFile::hasChainedFixupsLoadCommand(dyld3::MachOFile *this)
{
  return dyld3::MachOFile::hasLoadCommand(this, -2147483596);
}

dyld3::MachOAnalyzer *dyld4::SyscallDelegate::withReadOnlyMappedFile(int a1, vm_address_t *a2, dyld3 *a3, int a4, uint64_t a5)
{
  size_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  unsigned __int8 v9 = 0;
  if (a4) {
    uint64_t v6 = &v9;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t result = dyld4::SyscallDelegate::mapFileReadOnly(a1, a2, a3, (off_t *)&v11, (uint64_t)v10, v6, (uint64_t)v12);
  if (result)
  {
    uint64_t v8 = result;
    (*(void (**)(uint64_t, dyld3::MachOAnalyzer *, size_t, void, _OWORD *, unsigned char *))(a5 + 16))(a5, result, v11, v9, v10, v12);
    return (dyld3::MachOAnalyzer *)munmap(v8, v11);
  }
  return result;
}

dyld3::MachOAnalyzer *dyld4::SyscallDelegate::mapFileReadOnly(int a1, vm_address_t *a2, dyld3 *this, off_t *a4, uint64_t a5, unsigned char *a6, uint64_t a7)
{
  if (dyld3::stat(this, &v41, (stat *)this) == -1)
  {
    int v20 = *__error();
    if (v20 == 2)
    {
      Diagnostics::error(a2, "no such file");
    }
    else if (v20 == 1 {
           && (pid_t v21 = getpid(),
    }
               (int)sandbox_check(v21, (vm_address_t *)"file-read-metadata", 1073741825, v22, v23, v24, v25, v26, this) >= 1))
    {
      Diagnostics::error(a2, "file system sandbox blocked stat()", v37);
    }
    else
    {
      __error();
      Diagnostics::error(a2, "stat() failed with errno=%d");
    }
    return 0;
  }
  if (!v41.st_size) {
    return 0;
  }
  int v13 = dyld3::open(this, 0, 0);
  if (v13 < 0)
  {
    if (*__error() == 1
      && (pid_t v27 = getpid(),
          (int)sandbox_check(v27, (vm_address_t *)"file-read-data", 1073741825, v28, v29, v30, v31, v32, this) >= 1))
    {
      Diagnostics::error(a2, "file system sandbox blocked open()", v38);
    }
    else
    {
      Diagnostics::error(a2, "open() failed with errno=%d");
    }
    return 0;
  }
  int v14 = v13;
  uint64_t v15 = (dyld3::MachOAnalyzer *)mmap(0, v41.st_size, 1, 2, v13, 0);
  if (v15 == (dyld3::MachOAnalyzer *)-1)
  {
    st_vm_size_t size = v41.st_size;
    uint64_t v35 = __error();
    Diagnostics::error(a2, "mmap(size=0x%0lX) failed with errno=%d", st_size, *v35);
    close(v14);
    return 0;
  }
  uint64_t v16 = v15;
  if (a4) {
    *a4 = v41.st_size;
  }
  if (a5)
  {
    __darwin_time_t tv_sec = v41.st_mtimespec.tv_sec;
    uint64_t st_dev = v41.st_dev;
    *(void *)a5 = v41.st_ino;
    *(void *)(a5 + 8) = st_dev;
    *(void *)(a5 + 16) = tv_sec;
    *(unsigned char *)(a5 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  if (a7) {
    fcntl(v14, 50, a7);
  }
  if (a6)
  {
    *a6 = 0;
    if (dyld3::MachOFile::hasMachOMagic(v16))
    {
      if (*((_DWORD *)v16 + 1) == 16777228
        && (*((_DWORD *)v16 + 2) & 0xFFFFFF) == 2
        && dyld3::MachOAnalyzer::isOSBinary(v16, v14, 0))
      {
        *a6 = 1;
      }
    }
    else
    {
      uint64_t v36 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(v16, v19);
      if (v36)
      {
        v39[0] = _NSConcreteStackBlock;
        v39[1] = 0x40000000;
        uint64_t v39[2] = ___ZNK5dyld415SyscallDelegate15mapFileReadOnlyER11DiagnosticsPKcPmPNS_6FileIDEPbPc_block_invoke;
        v39[3] = &__block_descriptor_tmp_14;
        int v40 = v14;
        v39[4] = v16;
        v39[5] = a6;
        dyld3::FatFile::forEachSlice(v36, a2, v41.st_size, (uint64_t)v39);
      }
    }
  }
  close(v14);
  return v16;
}

vm_address_t dyld4::Loader::mapSegments(vm_address_t *a1, dyld4::SyscallDelegate **a2, dyld3 *a3, uint64_t a4, unsigned int *a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10)
{
  int v11 = a6;
  vm_size_t v13 = a4;
  int v69 = 520552456;
  uint64_t v70 = 0;
  uint64_t v71 = a3;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  uint64_t v77 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v69, (uint64_t)a2, (uint64_t)a3, a4, (uint64_t)a5, a6, (uint64_t)a7, a8);
  uint64_t v17 = dyld4::SyscallDelegate::open(a2[1], a3, 0, 0);
  if (v17 == -1)
  {
    int v30 = *__error();
    if (v30 == 2)
    {
      Diagnostics::error(a1, "no such file");
    }
    else if (v30 == 1 && dyld4::SyscallDelegate::sandboxBlockedOpen(a2[1], (const char *)a3))
    {
      Diagnostics::error(a1, "file system sandbox blocked open(\"%s\", O_RDONLY)");
    }
    else
    {
      Diagnostics::error(a1, "open(\"%s\", O_RDONLY) failed with errno=%d");
    }
    goto LABEL_27;
  }
  uint64_t v18 = (dyld4::RuntimeState *)v17;
  off_t v19 = dyld4::Loader::validateFile(a1, (uint64_t)a2, v17, (const char *)a3, a5, a10);
  if (Diagnostics::hasError((Diagnostics *)a1)) {
    goto LABEL_26;
  }
  if (v11 && a5[1])
  {
    int v78 = 520552464;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    uint64_t v85 = 0;
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v78, v20, v21, v22, v23, v24, v25, v26);
    uint64_t v27 = *a5;
    uint64_t v28 = (int *)a5[1];
    *(void *)uint64_t v90 = v19;
    uint64_t v91 = v27;
    uint64_t v92 = v28;
    if (dyld4::SyscallDelegate::fcntl(a2[1], (int)v18, 97, v90) == -1)
    {
      int v31 = *__error();
      dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v86, v32);
      if (v31 == 85 || v31 == 1) {
        Diagnostics::error(a1, "code signature invalid in <%s> '%s' (errno=%d) sliceOffset=0x%08llX, codeBlobOffset=0x%08X, codeBlobSize=0x%08X");
      }
      else {
        Diagnostics::error(a1, "fcntl(fd, F_ADDFILESIGS_RETURN) failed with errno=%d in <%s> '%s', sliceOffset=0x%08llX, codeBlobOffset=0x%08X, codeBlobSize=0x%08X");
      }
      goto LABEL_75;
    }
    if (*(void *)v90 < (unint64_t)*a5)
    {
      dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v86, v29);
      Diagnostics::error(a1, "code signature does not cover entire file up to signature in <%s> '%s' (signed 0x%08llX, expected 0x%08X) for '%s'");
LABEL_75:
      dyld4::SyscallDelegate::close(a2[1], (int)v18);
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v78);
      goto LABEL_27;
    }
    dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v78);
  }
  LOBYTE(v78) = 0;
  *(void *)uint64_t v90 = v19;
  uint64_t v91 = 512;
  uint64_t v92 = &v78;
  if (dyld4::SyscallDelegate::fcntl(a2[1], (int)v18, 98, v90) == -1)
  {
    dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v86, v33);
    Diagnostics::error(a1, "code signature in <%s> '%s' not valid for use in process: %s");
    goto LABEL_26;
  }
  uint64_t v68 = 0;
  if (*((unsigned char *)a2[1] + 156))
  {
    if (rosetta_dyld_get_aot_size(v18, (uint64_t)a3, (uint64_t)&v68, (uint64_t)&v78, (void *)0x400, v34, v35, v36))
    {
      uint64_t v68 = 0;
      LOBYTE(v78) = 0;
    }
    else
    {
      v13 += v68;
    }
  }
  vm_address_t address = 0;
  if (vm_allocate(mach_task_self_, &address, v13, 1))
  {
    Diagnostics::error(a1, "vm_allocate(size=0x%0llX) failed with result=%d");
    goto LABEL_26;
  }
  if (*((unsigned char *)a2[1] + 201))
  {
    if (v19) {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "Mapping %s (slice offset=0x%llX)\n");
    }
    else {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "Mapping %s\n");
    }
  }
  uint64_t v39 = a7[2];
  if (!v39)
  {
LABEL_61:
    v86[0] = 0;
    v90[0] = 0;
    vm_address_t v57 = address;
    if (dyld3::MachOFile::isFairPlayEncrypted((dyld3::MachOFile *)address, v86, v90)
      && dyld4::SyscallDelegate::mremap_encrypted(a2[1], (void *)(address + v86[0]), (void *)v90[0], (void *)1, (void *)*(unsigned int *)(v57 + 4), (void *)*(unsigned int *)(v57 + 8), v58, v59))
    {
      Diagnostics::error(a1, "could not register fairplay decryption, mremap_encrypted() => %d");
      goto LABEL_64;
    }
    char v60 = a2[1];
    if (*((unsigned char *)v60 + 156)) {
      BOOL v61 = v68 == 0;
    }
    else {
      BOOL v61 = 1;
    }
    if (!v61)
    {
      uint64_t v62 = v13 - v68 + address;
      if (!rosetta_dyld_map_aot((uint64_t)a3, address, v62, (uint64_t)&v87, &v88, &v89, v58, v59))
      {
        *(void *)int v86 = address;
        *(void *)uint64_t v90 = v86;
        uint64_t v91 = 1;
        v66[0] = 0;
        v66[1] = 0;
        dyld4::ExternallyViewableState::addRosettaImages((uint64_t)(a2 + 67), (uint64_t)v90, (uint64_t)v66);
        if (*((unsigned char *)a2[1] + 201)) {
          dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "%14s (r.x) 0x%012llX->0x%012llX\n", "ROSETTA", v62, v68 + v62);
        }
      }
      char v60 = a2[1];
    }
    dyld4::SyscallDelegate::close(v60, (int)v18);
    vm_address_t v37 = address;
    goto LABEL_28;
  }
  int v40 = 0;
  int v65 = *((unsigned __int8 *)a2[1] + 159);
  stat v41 = (unsigned int *)(*a7 + 12);
  uint64_t v42 = 16 * v39;
  off_t v64 = v19;
  while (1)
  {
    uint64_t v43 = *(void *)(v41 - 3);
    if ((v43 & 0x4000000000000000) != 0) {
      goto LABEL_60;
    }
    size_t v44 = *v41;
    if (!v44) {
      goto LABEL_60;
    }
    if ((v43 & 0x7FFFFFFFFFFFFFFLL) == 0 && v40 != 0) {
      goto LABEL_60;
    }
    BOOL v46 = v43 > -1 || v65 == 0;
    int v47 = v46 ? 18 : 524306;
    int v48 = (dyld3::MachOFile *)dyld4::SyscallDelegate::mmap(a2[1], (void *)(address + (v43 & 0x7FFFFFFFFFFFFFFLL)), v44, ((unint64_t)v43 >> 59) & 7, v47, (int)v18, v19 + *(v41 - 1));
    uint64_t v49 = __error();
    if (v48 == (dyld3::MachOFile *)-1) {
      break;
    }
    if (!v40 && !dyld3::MachOFile::isMachO(v48, a1, *v41)) {
      goto LABEL_64;
    }
    if (*((unsigned char *)a2[1] + 201))
    {
      vm_size_t v50 = v13;
      vm_size_t v51 = (vm_size_t)v48 + ((vm_page_size + *v41 - 1) & -(uint64_t)vm_page_size);
      uint64_t v52 = (const char *)dyld3::MachOLoaded::segmentName((dyld3::MachOLoaded *)address, v40);
      uint64_t v53 = *(void *)(v41 - 3) >> 59;
      vm_size_t v63 = v51;
      vm_size_t v13 = v50;
      off_t v19 = v64;
      uint64_t v54 = 120;
      if ((v53 & 4) == 0) {
        uint64_t v54 = 46;
      }
      uint64_t v55 = 119;
      if ((v53 & 2) == 0) {
        uint64_t v55 = 46;
      }
      uint64_t v56 = 114;
      if ((*(void *)(v41 - 3) & 0x800000000000000) == 0) {
        uint64_t v56 = 46;
      }
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "%14s (%c%c%c) 0x%012lX->0x%012lX\n", v52, v56, v55, v54, v48, v63);
    }
    ++v40;
LABEL_60:
    v41 += 4;
    v42 -= 16;
    if (!v42) {
      goto LABEL_61;
    }
  }
  if (*v49 == 1)
  {
    if (dyld4::SyscallDelegate::sandboxBlockedMmap(a2[1], (const char *)a3)) {
      Diagnostics::error(a1, "file system sandbox blocked mmap() of '%s'");
    }
    else {
      Diagnostics::error(a1, "code signing blocked mmap() of '%s'");
    }
  }
  else
  {
    Diagnostics::error(a1, "mmap(addr=0x%0llX, size=0x%08X) failed with errno=%d for %s");
  }
LABEL_64:
  vm_deallocate(mach_task_self_, address, v13);
LABEL_26:
  dyld4::SyscallDelegate::close(a2[1], (int)v18);
LABEL_27:
  vm_address_t v37 = 0;
LABEL_28:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v69);
  return v37;
}

uint64_t dyld3::open(dyld3 *this, const char *a2, uint64_t a3)
{
  int v4 = (int)a2;
  do
  {
    if ((v4 & 0x200) != 0) {
      uint64_t v6 = open((const char *)this, v4, a3);
    }
    else {
      uint64_t v6 = open_with_subsystem((const char *)this, v4);
    }
    uint64_t v7 = v6;
  }
  while (v6 == -1 && (*__error() == 35 || *__error() == 4));
  return v7;
}

uint64_t dyld4::SyscallDelegate::fileExists(int a1, dyld3 *this, uint64_t a3, int *a4)
{
  if (dyld3::stat(this, &v11, (stat *)a3))
  {
    if (a4)
    {
      uint64_t v6 = __error();
      uint64_t result = 0;
      int v8 = *v6;
LABEL_9:
      *a4 = v8;
      return result;
    }
    return 0;
  }
  if ((v11.st_mode & 0xF000) != 0x8000)
  {
    if (a4)
    {
      uint64_t result = 0;
      int v8 = 666;
      goto LABEL_9;
    }
    return 0;
  }
  uint64_t result = 1;
  if (a3)
  {
    __darwin_time_t tv_sec = v11.st_mtimespec.tv_sec;
    uint64_t st_dev = v11.st_dev;
    *(void *)a3 = v11.st_ino;
    *(void *)(a3 + 8) = st_dev;
    *(void *)(a3 + 16) = tv_sec;
    *(unsigned char *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t dyld3::stat(dyld3 *this, stat *a2, stat *a3)
{
  unint64_t v3 = (const char *)a2;
  int v4 = this;
  while (1)
  {
    uint64_t result = stat_with_subsystem((const char *)this, a2);
    if (result != -1) {
      break;
    }
    if (*__error() != 35 && *__error() != 4) {
      return 0xFFFFFFFFLL;
    }
    this = v4;
    a2 = (stat *)v3;
  }
  return result;
}

int *__error(void)
{
  v0 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v0) {
    return v0;
  }
  else {
    return &errno;
  }
}

uint64_t stat_with_subsystem(const char *a1, stat *a2)
{
  uint64_t v4 = stat64(a1, a2);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v5 = __error();
    uint64_t v6 = (char *)subsystem_root_path;
    if (*v5 == 2 && subsystem_root_path != 0)
    {
      while (1)
      {
        next_subsystem_root_path = extract_next_subsystem_root_path(__dst, v6);
        if (strlcat(__dst, a1, 0x400uLL) > 0x3FF) {
          break;
        }
        uint64_t v4 = stat64(__dst, a2);
        if ((v4 & 0x80000000) == 0) {
          return v4;
        }
        __error();
        if (!next_subsystem_root_path) {
          return v4;
        }
        uint64_t v6 = next_subsystem_root_path;
      }
      *__error() = 63;
    }
  }
  return v4;
}

int stat64(const char *a1, stat *a2)
{
  int64_t v9 = mac_syscall(SYS_stat64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

uint64_t cerror_nocancel(int a1)
{
  errno = a1;
  uint64_t v1 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v1) {
    *uint64_t v1 = a1;
  }
  return -1;
}

uint64_t open_with_subsystem(const char *a1, int a2)
{
  if ((a2 & 0x200) != 0)
  {
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v4 = open(a1, a2);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v5 = __error();
      uint64_t v6 = (char *)subsystem_root_path;
      if (*v5 == 2 && subsystem_root_path != 0)
      {
        while (1)
        {
          next_subsystem_root_path = extract_next_subsystem_root_path(__dst, v6);
          if (strlcat(__dst, a1, 0x400uLL) > 0x3FF) {
            break;
          }
          uint64_t v4 = open(__dst, a2);
          if ((v4 & 0x80000000) == 0) {
            return v4;
          }
          __error();
          if (!next_subsystem_root_path) {
            return v4;
          }
          uint64_t v6 = next_subsystem_root_path;
        }
        *__error() = 63;
      }
    }
  }
  return v4;
}

int open(const char *a1, int a2, ...)
{
  va_start(va, a2);
  uint64_t v9 = va_arg(va, void);
  if ((a2 & 0x200) != 0) {
    unsigned __int16 v7 = v9;
  }
  else {
    unsigned __int16 v7 = 0;
  }
  return __open(a1, *(void **)&a2, (void *)v7, v2, v3, v4, v5, v6);
}

int __open(const char *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_open, a1, (int)a2, a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

void *__mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  uint64_t result = mac_syscall(SYS_mmap, a1, a2, a3, a4, a5, a6);
  if (v6) {
    return (void *)cerror_nocancel((int)result);
  }
  return result;
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  if ((a4 & 2) != 0)
  {
    if (a2) {
      goto LABEL_4;
    }
LABEL_8:
    cerror_nocancel(22);
    return (void *)-1;
  }
  if (!a2 || (a4 & 1) == 0) {
    goto LABEL_8;
  }
LABEL_4:
  int v7 = a4 | 0x40000;
  return __mmap(a1, a2, a3, v7, a5, a6);
}

void *dyld4::SyscallDelegate::mmap(dyld4::SyscallDelegate *this, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t dyld4::SyscallDelegate::fcntl(dyld4::SyscallDelegate *this, int a2, int a3, void *a4)
{
  return fcntl(a2, a3, a4);
}

int fcntl(int a1, int a2, ...)
{
  va_start(va, a2);
  uint64_t v9 = va_arg(va, void *);
  switch(a2)
  {
    case '*':
    case '+':
    case ',':
    case '1':
    case '2':
    case '4':
    case '8':
    case '9':
    case ';':
    case '=':
    case 'A':
    case 'B':
    case 'G':
    case 'H':
    case 'K':
    case 'N':
    case 'S':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'l':
    case 'o':
    case 'q':
      goto LABEL_2;
    case '-':
    case '.':
    case '/':
    case '0':
    case '3':
    case '5':
    case '6':
    case '7':
    case ':':
    case '<':
    case '>':
    case '?':
    case '@':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'I':
    case 'J':
    case 'L':
    case 'M':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case '_':
    case 'j':
    case 'k':
    case 'm':
    case 'n':
    case 'p':
      goto LABEL_5;
    default:
      if ((a2 - 7) < 4) {
LABEL_2:
      }
        int v7 = v9;
      else {
LABEL_5:
      }
        int v7 = (void *)(int)v9;
      return __fcntl(a1, *(void **)&a2, v7, v2, v3, v4, v5, v6);
  }
}

int __fcntl(int a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_fcntl, a1, (int)a2, a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

BOOL dyld3::MachOFile::isMachO(dyld3::MachOFile *this, vm_address_t *a2, unint64_t a3)
{
  if (a3 <= 0x1B)
  {
    Diagnostics::error(a2, "MachO header exceeds file length");
    return 0;
  }
  int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this >> 1 != 2138504551)
  {
    if ((v4 & 0xFEFFFFFF) != 0xCEFAEDFE) {
      Diagnostics::error(a2, "file does not start with MH_MAGIC[_64]");
    }
    return 0;
  }
  BOOL v5 = v4 == -17958193;
  uint64_t v6 = 28;
  if (v5) {
    uint64_t v6 = 32;
  }
  if (v6 + (unint64_t)*((unsigned int *)this + 5) > a3)
  {
    Diagnostics::error(a2, "load commands exceed length of first segment");
    return 0;
  }
  dyld3::MachOFile::forEachLoadCommand(this, a2, (uint64_t)&__block_literal_global_2);

  return Diagnostics::noError((Diagnostics *)a2);
}

vm_address_t *dyld4::APIs::setErrorString(vm_address_t *this, char *a2, ...)
{
  va_start(va, a2);
  if (this[140] != -1)
  {
    char v2 = this;
    if (this[19])
    {
      this = (vm_address_t *)_simple_salloc();
      if (this)
      {
        int v4 = this;
        _simple_vsprintf((uint64_t)this, a2, (int *)va);
        BOOL v5 = (const char *)_simple_string((unsigned char **)v4);
        size_t v6 = _platform_strlen(v5) + 17;
        int v7 = (size_t *)(*(uint64_t (**)(vm_address_t, vm_address_t))(*(void *)v2[19] + 64))(v2[19], v2[140]);
        if (v7)
        {
          uint64_t v8 = (uint64_t)v7;
          if (*v7 >= v6)
          {
LABEL_10:
            uint64_t v9 = (const char *)_simple_string((unsigned char **)v4);
            strcpy((char *)(v8 + 9), v9);
            *(unsigned char *)(v8 + 8) = 1;
            return _simple_sfree(v4);
          }
          (*(void (**)(vm_address_t, size_t *))(*(void *)v2[19] + 16))(v2[19], v7);
        }
        if (v6 <= 0x100) {
          size_t v6 = 256;
        }
        uint64_t v8 = (*(uint64_t (**)(vm_address_t, size_t))(*(void *)v2[19] + 8))(v2[19], v6);
        *(void *)uint64_t v8 = v6;
        *(unsigned char *)(v8 + 8) = 0;
        (*(void (**)(vm_address_t, vm_address_t, uint64_t))(*(void *)v2[19] + 72))(v2[19], v2[140], v8);
        goto LABEL_10;
      }
    }
  }
  return this;
}

uint64_t Diagnostics::error(vm_address_t *this, char *a2, ...)
{
  va_start(va, a2);
  return Diagnostics::error(this, a2, va);
}

uint64_t Diagnostics::appendError(vm_address_t *this, char *__s, ...)
{
  va_start(va, __s);
  uint64_t v4 = *this;
  if (v4) {
    _simple_sresize(v4);
  }
  return Diagnostics::error(this, __s, va);
}

uint64_t _simple_vsprintf(uint64_t a1, char *__s, int *a3)
{
  return 0;
}

uint64_t __simple_bprintf(uint64_t result, uint64_t (*a2)(uint64_t), char *__s, int *a4)
{
  if (!*__s) {
    return result;
  }
  uint64_t v4 = __s;
  uint64_t v6 = result;
  do
  {
    uint64_t result = (uint64_t)_platform_strchr(v4, 37);
    if (!result)
    {
      while (1)
      {
        char v85 = *v4;
        if (!*v4) {
          break;
        }
        if (a2 && (uint64_t result = a2(*v4)) != 0)
        {
          char v80 = *(unsigned char *)result;
          if (*(unsigned char *)result)
          {
            long long v81 = (unsigned __int8 *)(result + 1);
            do
            {
              long long v82 = *(unsigned char **)(v6 + 8);
              if ((unint64_t)v82 >= *(void *)(v6 + 16))
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                long long v82 = *(unsigned char **)(v6 + 8);
              }
              *(void *)(v6 + 8) = v82 + 1;
              *long long v82 = v80;
              int v83 = *v81++;
              char v80 = v83;
            }
            while (v83);
          }
        }
        else
        {
          long long v84 = *(char **)(v6 + 8);
          if ((unint64_t)v84 >= *(void *)(v6 + 16))
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
            long long v84 = *(char **)(v6 + 8);
          }
          *(void *)(v6 + 8) = v84 + 1;
          *long long v84 = v85;
        }
        ++v4;
      }
      return result;
    }
    uint64_t v7 = result;
    uint64_t v8 = result - (void)v4;
    if (result - (uint64_t)v4 >= 1)
    {
      do
      {
        unsigned int v10 = *v4++;
        uint64_t v9 = v10;
        if (a2 && (uint64_t result = a2(v9)) != 0)
        {
          char v11 = *(unsigned char *)result;
          if (*(unsigned char *)result)
          {
            char v12 = (unsigned __int8 *)(result + 1);
            do
            {
              vm_size_t v13 = *(unsigned char **)(v6 + 8);
              if ((unint64_t)v13 >= *(void *)(v6 + 16))
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                vm_size_t v13 = *(unsigned char **)(v6 + 8);
              }
              *(void *)(v6 + 8) = v13 + 1;
              *vm_size_t v13 = v11;
              int v14 = *v12++;
              char v11 = v14;
            }
            while (v14);
          }
        }
        else
        {
          uint64_t v15 = *(unsigned char **)(v6 + 8);
          if ((unint64_t)v15 >= *(void *)(v6 + 16))
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
            uint64_t v15 = *(unsigned char **)(v6 + 8);
          }
          *(void *)(v6 + 8) = v15 + 1;
          *uint64_t v15 = v9;
        }
        BOOL v16 = v8-- <= 1;
      }
      while (!v16);
    }
    uint64_t v17 = (const char *)(v7 + 1);
    if (*(unsigned char *)(v7 + 1) == 37)
    {
      if (a2 && (uint64_t result = a2(37)) != 0)
      {
        char v18 = *(unsigned char *)result;
        if (*(unsigned char *)result)
        {
          off_t v19 = (unsigned __int8 *)(result + 1);
          do
          {
            uint64_t v20 = *(unsigned char **)(v6 + 8);
            if ((unint64_t)v20 >= *(void *)(v6 + 16))
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              uint64_t v20 = *(unsigned char **)(v6 + 8);
            }
            *(void *)(v6 + 8) = v20 + 1;
            unsigned char *v20 = v18;
            int v21 = *v19++;
            char v18 = v21;
          }
          while (v21);
        }
      }
      else
      {
        int v30 = *(unsigned char **)(v6 + 8);
        if ((unint64_t)v30 >= *(void *)(v6 + 16))
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
          int v30 = *(unsigned char **)(v6 + 8);
        }
        *(void *)(v6 + 8) = v30 + 1;
        *int v30 = 37;
      }
      uint64_t v4 = (char *)(v7 + 2);
      continue;
    }
    uint64_t result = _platform_strncmp((const char *)(v7 + 1), ".*s", 3uLL);
    if (!result)
    {
LABEL_44:
      int v31 = a4;
      int v32 = *a4;
      a4 += 4;
      if (v32 >= 1)
      {
        uint64_t v33 = (unsigned __int8 *)*((void *)v31 + 1);
        do
        {
          unsigned int v35 = *v33++;
          uint64_t v34 = v35;
          if (a2 && (uint64_t result = a2(v34)) != 0)
          {
            char v36 = *(unsigned char *)result;
            if (*(unsigned char *)result)
            {
              vm_address_t v37 = (unsigned __int8 *)(result + 1);
              do
              {
                uint64_t v38 = *(unsigned char **)(v6 + 8);
                if ((unint64_t)v38 >= *(void *)(v6 + 16))
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                  uint64_t v38 = *(unsigned char **)(v6 + 8);
                }
                *(void *)(v6 + 8) = v38 + 1;
                unsigned char *v38 = v36;
                int v39 = *v37++;
                char v36 = v39;
              }
              while (v39);
            }
          }
          else
          {
            int v40 = *(unsigned char **)(v6 + 8);
            if ((unint64_t)v40 >= *(void *)(v6 + 16))
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              int v40 = *(unsigned char **)(v6 + 8);
            }
            *(void *)(v6 + 8) = v40 + 1;
            *int v40 = v34;
          }
          BOOL v16 = v32-- <= 1;
        }
        while (!v16);
      }
      v17 += 2;
      goto LABEL_148;
    }
    int v22 = 0;
    int v23 = 0;
    int v24 = 0;
    while (1)
    {
      int v25 = *v17;
      int v26 = *(unsigned __int8 *)v17;
      if (v25 > 98)
      {
        switch(*v17)
        {
          case 'c':
            if (v24 >= 2)
            {
              if (v23) {
                uint64_t v42 = 48;
              }
              else {
                uint64_t v42 = 32;
              }
              do
              {
                if (a2 && (uint64_t result = a2(v42)) != 0)
                {
                  char v43 = *(unsigned char *)result;
                  if (*(unsigned char *)result)
                  {
                    size_t v44 = (unsigned __int8 *)(result + 1);
                    do
                    {
                      vm_address_t v45 = *(unsigned char **)(v6 + 8);
                      if ((unint64_t)v45 >= *(void *)(v6 + 16))
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                        vm_address_t v45 = *(unsigned char **)(v6 + 8);
                      }
                      *(void *)(v6 + 8) = v45 + 1;
                      *vm_address_t v45 = v43;
                      int v46 = *v44++;
                      char v43 = v46;
                    }
                    while (v46);
                  }
                }
                else
                {
                  int v47 = *(unsigned char **)(v6 + 8);
                  if ((unint64_t)v47 >= *(void *)(v6 + 16))
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    int v47 = *(unsigned char **)(v6 + 8);
                  }
                  *(void *)(v6 + 8) = v47 + 1;
                  *int v47 = v42;
                }
                BOOL v16 = v24-- <= 2;
              }
              while (!v16);
            }
            int v48 = a4;
            a4 += 2;
            int v49 = *v48;
            if (a2 && (uint64_t result = a2(*v48)) != 0)
            {
              char v50 = *(unsigned char *)result;
              if (*(unsigned char *)result)
              {
                vm_size_t v51 = (unsigned __int8 *)(result + 1);
                do
                {
                  uint64_t v52 = *(unsigned char **)(v6 + 8);
                  if ((unint64_t)v52 >= *(void *)(v6 + 16))
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    uint64_t v52 = *(unsigned char **)(v6 + 8);
                  }
                  *(void *)(v6 + 8) = v52 + 1;
                  *uint64_t v52 = v50;
                  int v53 = *v51++;
                  char v50 = v53;
                }
                while (v53);
              }
            }
            else
            {
              int v78 = *(unsigned char **)(v6 + 8);
              if ((unint64_t)v78 >= *(void *)(v6 + 16))
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                int v78 = *(unsigned char **)(v6 + 8);
              }
              *(void *)(v6 + 8) = v78 + 1;
              *int v78 = v49;
            }
            break;
          case 'd':
          case 'i':
            a4 += 2;
            uint64_t result = (uint64_t)dec((std::ios_base *)v6);
            break;
          case 'l':
            ++v22;
            ++v17;
            goto LABEL_32;
          case 'o':
            a4 += 2;
            uint64_t result = (uint64_t)oct((std::ios_base *)v6);
            break;
          case 'p':
            a4 += 2;
            stat v41 = (std::ios_base *)v6;
            goto LABEL_90;
          case 's':
            uint64_t v54 = (const char **)a4;
            a4 += 2;
            uint64_t v55 = *v54;
            if (v55) {
              uint64_t v56 = v55;
            }
            else {
              uint64_t v56 = "(null)";
            }
            uint64_t result = _platform_strlen(v56);
            int v57 = v24 - result;
            if (v24 - (int)result >= 1)
            {
              if (v23) {
                uint64_t v58 = 48;
              }
              else {
                uint64_t v58 = 32;
              }
              do
              {
                if (a2 && (uint64_t result = a2(v58)) != 0)
                {
                  char v59 = *(unsigned char *)result;
                  if (*(unsigned char *)result)
                  {
                    char v60 = (unsigned __int8 *)(result + 1);
                    do
                    {
                      BOOL v61 = *(unsigned char **)(v6 + 8);
                      if ((unint64_t)v61 >= *(void *)(v6 + 16))
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                        BOOL v61 = *(unsigned char **)(v6 + 8);
                      }
                      *(void *)(v6 + 8) = v61 + 1;
                      *BOOL v61 = v59;
                      int v62 = *v60++;
                      char v59 = v62;
                    }
                    while (v62);
                  }
                }
                else
                {
                  vm_size_t v63 = *(unsigned char **)(v6 + 8);
                  if ((unint64_t)v63 >= *(void *)(v6 + 16))
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    vm_size_t v63 = *(unsigned char **)(v6 + 8);
                  }
                  *(void *)(v6 + 8) = v63 + 1;
                  unsigned char *v63 = v58;
                }
                BOOL v16 = v57-- <= 1;
              }
              while (!v16);
            }
            while (1)
            {
              char v69 = *v56;
              if (!*v56) {
                break;
              }
              if (a2 && (uint64_t result = a2(*(unsigned __int8 *)v56)) != 0)
              {
                char v64 = *(unsigned char *)result;
                if (*(unsigned char *)result)
                {
                  int v65 = (unsigned __int8 *)(result + 1);
                  do
                  {
                    int v66 = *(unsigned char **)(v6 + 8);
                    if ((unint64_t)v66 >= *(void *)(v6 + 16))
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                      int v66 = *(unsigned char **)(v6 + 8);
                    }
                    *(void *)(v6 + 8) = v66 + 1;
                    unsigned char *v66 = v64;
                    int v67 = *v65++;
                    char v64 = v67;
                  }
                  while (v67);
                }
              }
              else
              {
                uint64_t v68 = *(char **)(v6 + 8);
                if ((unint64_t)v68 >= *(void *)(v6 + 16))
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                  uint64_t v68 = *(char **)(v6 + 8);
                }
                *(void *)(v6 + 8) = v68 + 1;
                char *v68 = v69;
              }
              ++v56;
            }
            break;
          case 'u':
            uint64_t v70 = (unint64_t *)a4;
            a4 += 2;
            if (v22) {
              unint64_t v71 = *v70;
            }
            else {
              unint64_t v71 = *(unsigned int *)v70;
            }
            uint64_t result = (uint64_t)udec(v6, a2, v71, v24, v23);
            break;
          case 'x':
            goto LABEL_62;
          case 'y':
            long long v72 = (unint64_t *)a4;
            a4 += 2;
            if (v22) {
              unint64_t v73 = *v72;
            }
            else {
              unint64_t v73 = *(unsigned int *)v72;
            }
            uint64_t result = (uint64_t)ydec(v6, a2, v73, v24, v23);
            break;
          default:
            goto LABEL_130;
        }
        goto LABEL_148;
      }
      if ((v25 - 49) >= 9) {
        break;
      }
LABEL_35:
      if ((v26 - 48) <= 9)
      {
        do
        {
          int v27 = 10 * v24 + v26;
          int v28 = *(unsigned __int8 *)++v17;
          LOBYTE(v26) = v28;
          int v24 = v27 - 48;
        }
        while ((v28 - 48) < 0xA);
      }
LABEL_32:
      uint64_t result = _platform_strncmp(v17, ".*s", 3uLL);
      if (!result) {
        goto LABEL_44;
      }
    }
    if (v25 == 48)
    {
      ++v23;
      int v29 = *(unsigned __int8 *)++v17;
      int v26 = v29;
      goto LABEL_35;
    }
    if (v25 == 88)
    {
LABEL_62:
      a4 += 2;
      stat v41 = (std::ios_base *)v6;
LABEL_90:
      uint64_t result = (uint64_t)hex(v41);
    }
    else
    {
LABEL_130:
      if (a2 && (uint64_t result = a2(*(unsigned __int8 *)v17)) != 0)
      {
        char v74 = *(unsigned char *)result;
        if (*(unsigned char *)result)
        {
          long long v75 = (unsigned __int8 *)(result + 1);
          do
          {
            long long v76 = *(unsigned char **)(v6 + 8);
            if ((unint64_t)v76 >= *(void *)(v6 + 16))
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              long long v76 = *(unsigned char **)(v6 + 8);
            }
            *(void *)(v6 + 8) = v76 + 1;
            *long long v76 = v74;
            int v77 = *v75++;
            char v74 = v77;
          }
          while (v77);
        }
      }
      else
      {
        long long v79 = *(unsigned char **)(v6 + 8);
        if ((unint64_t)v79 >= *(void *)(v6 + 16))
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
          long long v79 = *(unsigned char **)(v6 + 8);
        }
        *(void *)(v6 + 8) = v79 + 1;
        *long long v79 = v26;
      }
    }
LABEL_148:
    uint64_t v4 = (char *)(v17 + 1);
  }
  while (*v4);
  return result;
}

uint64_t Diagnostics::error(vm_address_t *this, char *__s, char *a3)
{
  vm_address_t v6 = *this;
  if (!v6)
  {
    vm_address_t v6 = _simple_salloc();
    *this = v6;
  }

  return _simple_vsprintf(v6, __s, (int *)a3);
}

size_t _simple_sresize(uint64_t a1)
{
  char v2 = *(const char **)a1;
  size_t result = _platform_strlen(*(const char **)a1);
  *(void *)(a1 + 8) = &v2[result];
  return result;
}

vm_address_t _simple_salloc()
{
  if (vm_allocate(mach_task_self_, &address, vm_page_size, 1)) {
    return 0;
  }
  vm_address_t v1 = address + 40;
  *(void *)vm_address_t address = address + 40;
  vm_address_t result = address;
  vm_address_t v2 = address + vm_page_size - 1;
  *(void *)(address + 8) = v1;
  *(void *)(result + 16) = v2;
  *(void *)(result + 32) = _enlarge;
  return result;
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  kern_return_t v8;
  vm_address_t v9;
  uint64_t reply_port;
  kern_return_t v11;
  kern_return_t v12;
  BOOL v13;
  mach_vm_offset_t v15;
  mach_msg_header_t v16;
  uint64_t v17;
  long long v18;
  int v19;

  uint64_t v15 = *address;
  uint64_t v8 = _kernelrpc_mach_vm_allocate_trap(target_task, &v15, size, flags);
  uint64_t v9 = v15;
  if (v8 == 268435459)
  {
    uint64_t v17 = 0x100000000;
    *(void *)&char v18 = v15;
    *((void *)&v18 + 1) = size;
    off_t v19 = flags;
    reply_port = mig_get_reply_port();
    *(void *)&v16.msgh_bits = 0x3400001513;
    *(void *)&v16.msgh_remote_port = __PAIR64__(reply_port, target_task);
    *(void *)&v16.msgh_voucher_port = 0x12C000000000;
    char v11 = mach_msg2_internal(&v16, 0x200000003uLL, (void *)0x3400001513, (void *)__PAIR64__(reply_port, target_task), (void *)0x12C000000000, (void *)(reply_port << 32), (void *)0x34, 0);
    char v12 = v11;
    if ((v11 - 268435458) <= 0xE && ((1 << (v11 - 2)) & 0x4003) != 0) {
      goto LABEL_23;
    }
    if (v11)
    {
      mig_dealloc_reply_port(v16.msgh_local_port);
LABEL_23:
      uint64_t v9 = v15;
      goto LABEL_24;
    }
    if (v16.msgh_id == 71)
    {
      char v12 = -308;
    }
    else if (v16.msgh_id == 4900)
    {
      if ((v16.msgh_bits & 0x80000000) == 0)
      {
        if (v16.msgh_size == 44)
        {
          if (!v16.msgh_remote_port)
          {
            char v12 = v18;
            if (!v18)
            {
              uint64_t v15 = *(void *)((char *)&v18 + 4);
              goto LABEL_23;
            }
            goto LABEL_22;
          }
        }
        else if (v16.msgh_size == 36)
        {
          if (v16.msgh_remote_port) {
            vm_size_t v13 = 1;
          }
          else {
            vm_size_t v13 = v18 == 0;
          }
          if (v13) {
            char v12 = -300;
          }
          else {
            char v12 = v18;
          }
          goto LABEL_22;
        }
      }
      char v12 = -300;
    }
    else
    {
      char v12 = -301;
    }
LABEL_22:
    mach_msg_destroy(&v16);
    goto LABEL_23;
  }
  char v12 = v8;
LABEL_24:
  *vm_address_t address = v9;
  return v12;
}

uint64_t _simple_string(unsigned char **a1)
{
  *a1[1] = 0;
  return (uint64_t)*a1;
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  size_t v4 = _platform_strlen(__src);
  memmove(__dst, __src, v4 + 1);
  return __dst;
}

std::ios_base *__cdecl hex(std::ios_base *__str)
{
  int v7 = v4;
  int v8 = v3;
  uint64_t v9 = v1;
  char v11 = "0123456789ABCDEF";
  if (!v5) {
    char v11 = "0123456789abcdef";
  }
  char v48 = 0;
  if (v2)
  {
    char v12 = &v48;
    do
    {
      *--char v12 = v11[v2 & 0xF];
      BOOL v13 = v2 >= 0x10;
      v2 >>= 4;
    }
    while (v13);
    if (!v6) {
      goto LABEL_23;
    }
  }
  else
  {
    char v12 = &v47;
    char v47 = 48;
    if (!v6)
    {
LABEL_23:
      char v23 = 1;
      goto LABEL_25;
    }
  }
  int v8 = v3 - 2;
  if (v4)
  {
    int v14 = (char *)&_0x;
    unsigned __int8 v15 = 48;
    do
    {
      if (v9 && (BOOL v16 = (unsigned char *)v9(v15)) != 0)
      {
        char v17 = *v16;
        if (*v16)
        {
          char v18 = v16 + 1;
          do
          {
            off_t v19 = *(unsigned char **)&__str->__fmtflags_;
            if ((unint64_t)v19 >= __str->__precision_)
            {
              (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
              off_t v19 = *(unsigned char **)&__str->__fmtflags_;
            }
            *(void *)&__str->__fmtflags_ = v19 + 1;
            *off_t v19 = v17;
            int v20 = *v18++;
            char v17 = v20;
          }
          while (v20);
        }
      }
      else
      {
        int v21 = *(unsigned __int8 **)&__str->__fmtflags_;
        if ((unint64_t)v21 >= __str->__precision_)
        {
          (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
          int v21 = *(unsigned __int8 **)&__str->__fmtflags_;
        }
        *(void *)&__str->__fmtflags_ = v21 + 1;
        *int v21 = v15;
      }
      unsigned __int8 v22 = *++v14;
      unsigned __int8 v15 = v22;
    }
    while (v14 != (char *)&unk_1A8E712BA);
    goto LABEL_23;
  }
  char v23 = 0;
LABEL_25:
  vm_address_t result = (std::ios_base *)_platform_strlen(v12);
  int v25 = v8 - result;
  if (v25 >= 1)
  {
    if (v7) {
      uint64_t v26 = 48;
    }
    else {
      uint64_t v26 = 32;
    }
    do
    {
      if (v9 && (vm_address_t result = (std::ios_base *)v9(v26)) != 0)
      {
        char v27 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          int v28 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            int v29 = *(unsigned char **)&__str->__fmtflags_;
            if ((unint64_t)v29 >= __str->__precision_)
            {
              vm_address_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              int v29 = *(unsigned char **)&__str->__fmtflags_;
            }
            *(void *)&__str->__fmtflags_ = v29 + 1;
            *int v29 = v27;
            int v30 = *v28++;
            char v27 = v30;
          }
          while (v30);
        }
      }
      else
      {
        int v31 = *(unsigned char **)&__str->__fmtflags_;
        if ((unint64_t)v31 >= __str->__precision_)
        {
          vm_address_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          int v31 = *(unsigned char **)&__str->__fmtflags_;
        }
        *(void *)&__str->__fmtflags_ = v31 + 1;
        *int v31 = v26;
      }
    }
    while (v25-- > 1);
  }
  if ((v23 & 1) == 0)
  {
    uint64_t v33 = (char *)&_0x;
    unsigned __int8 v34 = 48;
    do
    {
      if (v9 && (vm_address_t result = (std::ios_base *)v9(v34)) != 0)
      {
        char v35 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          char v36 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            vm_address_t v37 = *(unsigned char **)&__str->__fmtflags_;
            if ((unint64_t)v37 >= __str->__precision_)
            {
              vm_address_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              vm_address_t v37 = *(unsigned char **)&__str->__fmtflags_;
            }
            *(void *)&__str->__fmtflags_ = v37 + 1;
            unsigned char *v37 = v35;
            int v38 = *v36++;
            char v35 = v38;
          }
          while (v38);
        }
      }
      else
      {
        int v39 = *(unsigned __int8 **)&__str->__fmtflags_;
        if ((unint64_t)v39 >= __str->__precision_)
        {
          vm_address_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          int v39 = *(unsigned __int8 **)&__str->__fmtflags_;
        }
        *(void *)&__str->__fmtflags_ = v39 + 1;
        *int v39 = v34;
      }
      unsigned __int8 v40 = *++v33;
      unsigned __int8 v34 = v40;
    }
    while (v33 != (char *)&unk_1A8E712BA);
  }
  while (1)
  {
    char v46 = *v12;
    if (!*v12) {
      break;
    }
    if (v9 && (vm_address_t result = (std::ios_base *)v9(*(unsigned __int8 *)v12)) != 0)
    {
      char v41 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        uint64_t v42 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          char v43 = *(unsigned char **)&__str->__fmtflags_;
          if ((unint64_t)v43 >= __str->__precision_)
          {
            vm_address_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            char v43 = *(unsigned char **)&__str->__fmtflags_;
          }
          *(void *)&__str->__fmtflags_ = v43 + 1;
          *char v43 = v41;
          int v44 = *v42++;
          char v41 = v44;
        }
        while (v44);
      }
    }
    else
    {
      vm_address_t v45 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v45 >= __str->__precision_)
      {
        vm_address_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        vm_address_t v45 = *(char **)&__str->__fmtflags_;
      }
      *(void *)&__str->__fmtflags_ = v45 + 1;
      *vm_address_t v45 = v46;
    }
    ++v12;
  }
  return result;
}

uint64_t cerror(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int v8 = a1;
  _pthread_exit_if_canceled(a1, a2, a3, a4, a5, a6, a7, a8);
  cerror_nocancel(v8);
  return -1;
}

uint64_t _pthread_exit_if_canceled(uint64_t result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (result == 4)
  {
    int v8 = result;
    vm_address_t result = __pthread_canceled(0, a2, a3, a4, a5, a6, a7, a8);
    if (!result)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      uint64_t v12 = *(void *)(StatusReg - 224);
      unint64_t v11 = StatusReg - 224;
      if ((_pthread_ptr_munge_token ^ v12) == v11)
      {
        *(_DWORD *)(v11 + 168) = v8;
        *(unsigned char *)(v11 + 165) = 1;
        pthread_exit((void *)1);
      }
      _pthread_exit_if_canceled_cold_1(result, v9);
    }
  }
  return result;
}

void dyld4::Loader::setUpPageInLinking(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (dyld4::SyscallDelegate *)*((void *)a3 + 1);
  BOOL v13 = (dyld3 *)dyld4::Loader::path(a1, a3);
  int v14 = dyld4::SyscallDelegate::open(v12, v13, 0, 0);
  if (v14 == -1)
  {
    off_t v19 = (const char *)dyld4::Loader::path(a1, a3);
    int v20 = __error();
    Diagnostics::error(a2, "open(\"%s\", O_RDONLY) failed with errno=%d", v19, *v20);
  }
  else
  {
    int v15 = v14;
    BOOL v16 = (int *)*((void *)a3 + 1);
    BOOL v18 = v16[41] >= 2
       && *((void *)a3 + 19) == 0
       && !dyld4::SyscallDelegate::sandboxBlockedPageInLinking((dyld4::SyscallDelegate *)v16);
    int v21 = (dyld3::MachOAnalyzer *)dyld4::Loader::loadAddress(a1, a3);
    char v22 = *(unsigned char *)(*((void *)a3 + 1) + 159);
    v38[0] = 0;
    v38[1] = v38;
    void v38[2] = 0x2000000000;
    __int16 v39 = 0;
    v36[0] = 0;
    v36[1] = v36;
    v36[2] = 0x2000000000;
    __int16 v37 = 0;
    v32[0] = 0;
    v32[1] = v32;
    void v32[2] = 0x5002000000;
    v32[3] = __Block_byref_object_copy__2;
    v32[4] = __Block_byref_object_dispose__2;
    v32[5] = &v41;
    v32[6] = 8;
    uint64_t v33 = 0;
    vm_address_t v34 = 0;
    vm_size_t v35 = 0;
    v28[0] = 0;
    v28[1] = v28;
    v28[2] = 0x5002000000;
    void v28[3] = __Block_byref_object_copy__2;
    v28[4] = __Block_byref_object_dispose__2;
    v28[5] = &v40;
    v28[6] = 8;
    uint64_t v29 = 0;
    vm_address_t address = 0;
    vm_size_t size = 0;
    uint64_t v23 = dyld3::MachOAnalyzer::chainStartsOffset(v21);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke;
    v24[3] = &unk_1EFF646A0;
    v24[8] = a1;
    v24[9] = v21;
    v24[4] = v38;
    void v24[5] = v36;
    int v25 = v15;
    v24[10] = a2;
    v24[11] = a5;
    BOOL v26 = v18;
    char v27 = v22;
    void v24[6] = v32;
    v24[7] = v28;
    void v24[12] = a4;
    v24[13] = a3;
    v24[14] = a6;
    dyld3::MachOAnalyzer::withChainStarts(v21, a2, v23, (uint64_t)v24);
    dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)a3 + 1), v15);
    _Block_object_dispose(v28, 8);
    uint64_t v29 = 0;
    if (address) {
      vm_deallocate(mach_task_self_, address, size);
    }
    _Block_object_dispose(v32, 8);
    uint64_t v33 = 0;
    if (v34) {
      vm_deallocate(mach_task_self_, v34, v35);
    }
    _Block_object_dispose(v36, 8);
    _Block_object_dispose(v38, 8);
  }
}

uint64_t dyld4::SyscallDelegate::close(dyld4::SyscallDelegate *this, int a2)
{
  return close(a2);
}

uint64_t dyld4::SyscallDelegate::open(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3, uint64_t a4)
{
  return dyld3::open(a2, a3, a4);
}

void ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = 0;
  int v20 = &v19;
  uint64_t v21 = 0x2000000000;
  uint64_t v22 = 0;
  int v4 = *(dyld4::Loader **)(a1 + 64);
  int v3 = *(_DWORD **)(a1 + 72);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unsigned int v9[2] = ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke_2;
  void v9[3] = &unk_1EFF64678;
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v13 = a2;
  uint64_t v14 = v5;
  int v16 = *(_DWORD *)(a1 + 120);
  long long v15 = *(_OWORD *)(a1 + 88);
  char v17 = *(unsigned char *)(a1 + 124);
  char v18 = *(unsigned char *)(a1 + 125);
  long long v6 = *(_OWORD *)(a1 + 48);
  long long v10 = *(_OWORD *)(a1 + 32);
  long long v11 = v6;
  uint64_t v12 = &v19;
  dyld3::MachOFile::forEachSegment(v3, (uint64_t)v9);
  if (v20[3])
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(void *)(v7 + 56)
      && dyld4::setUpPageInLinkingRegions(*(const dyld4::RuntimeState **)(a1 + 104), v4, *(void *)(a1 + 96), *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), *(_DWORD *)(*(void *)(*(void *)(a1 + 104) + 8) + 164) == 1, (const mwl_region *)(v7 + 40), *(void *)(a1 + 112)))
    {
      dyld4::setUpPageInLinkingRegions(*(const dyld4::RuntimeState **)(a1 + 104), v4, *(void *)(a1 + 96), *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 1, (const mwl_region *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), *(void *)(a1 + 112));
    }
    uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
    if (*(void *)(v8 + 56)) {
      dyld4::setUpPageInLinkingRegions(*(const dyld4::RuntimeState **)(a1 + 104), v4, *(void *)(a1 + 96), *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 1, (const mwl_region *)(v8 + 40), *(void *)(a1 + 112));
    }
  }
  _Block_object_dispose(&v19, 8);
}

uint64_t dyld3::MachOAnalyzer::chainStartsOffset(dyld3::MachOAnalyzer *this)
{
  uint64_t result = dyld3::MachOAnalyzer::chainedFixupsHeader(this);
  if (result) {
    return result - (void)this + *(unsigned int *)(result + 4);
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::chainedFixupsHeader(dyld3::MachOAnalyzer *this)
{
  Diagnostics::Diagnostics((Diagnostics *)&v7);
  dyld3::MachOLoaded::getLinkEditPointers(this, (vm_address_t *)&v7, (uint64_t)v4);
  uint64_t LinkEditContent = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v7) && v5) {
    uint64_t LinkEditContent = dyld3::MachOLoaded::getLinkEditContent((uint64_t)this, (uint64_t)&v6, *(_DWORD *)(v5 + 8));
  }
  mach_o::Error::~Error(&v7);
  return LinkEditContent;
}

uint64_t dyld3::MachOLoaded::getLinkEditContent(uint64_t a1, uint64_t a2, int a3)
{
  return *(void *)a2 + *(void *)(a2 + 16) + (a3 - *(_DWORD *)(a2 + 24));
}

void dyld3::MachOAnalyzer::withChainStarts(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v6 = *(void (**)(uint64_t, char *))(a4 + 16);
    v6(a4, (char *)a1 + a3);
  }
  else
  {
    dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v28);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      if (v29)
      {
        uint64_t LinkEditContent = dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v30, *(_DWORD *)(v29 + 8));
        (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, LinkEditContent + *(unsigned int *)(LinkEditContent + 4));
      }
      else if (v28 && *((_DWORD *)a1 + 1) == 16777228 && dyld3::MachOFile::maskedCpuSubtype(a1) == 2)
      {
        uint64_t Address = dyld3::MachOFile::preferredLoadAddress(a1);
        unint64_t v10 = dyld3::MachOFile::mappedSize(a1);
        __chkstk_darwin(v10, v11, v12, v13, v14, v15, v16, v17, v23);
        uint64_t v19 = (char *)&v24[-1] - v18;
        uint64_t v21 = (char *)&v24[-1] + v20 - v18;
        uint64_t v22 = v31;
        *(_DWORD *)((char *)&v24[-1] - v18) = v31;
        if (v22) {
          bzero(v19 + 4, 4 * v22);
        }
        else {
          uint64_t v22 = 0;
        }
        v26[0] = 0;
        v26[1] = v26;
        void v26[2] = 0x2000000000;
        char v27 = 0;
        v25[0] = 0;
        v25[1] = v25;
        v25[2] = 0x2000000000;
        v25[3] = &v19[4 * v22 + 4];
        v24[0] = _NSConcreteStackBlock;
        v24[1] = 0x40000000;
        v24[2] = ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke;
        v24[3] = &unk_1EFF66D90;
        v24[4] = v26;
        void v24[5] = v25;
        void v24[6] = v19;
        v24[7] = v19;
        v24[8] = v21;
        v24[9] = Address;
        dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups(a1, a2, 0, 0, (uint64_t)v24);
        (*(void (**)(uint64_t, char *))(a4 + 16))(a4, v19);
        _Block_object_dispose(v25, 8);
        _Block_object_dispose(v26, 8);
      }
      else
      {
        Diagnostics::error(a2, "image does not use chained fixups");
      }
    }
  }
}

uint64_t dyld3::MachOFile::isFairPlayEncrypted(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  FairPlayEncryptionLoadCommand = (_DWORD *)dyld3::MachOFile::findFairPlayEncryptionLoadCommand(this);
  if (FairPlayEncryptionLoadCommand && FairPlayEncryptionLoadCommand[4] == 1)
  {
    *a2 = FairPlayEncryptionLoadCommand[2];
    unsigned int v6 = FairPlayEncryptionLoadCommand[3];
    uint64_t result = 1;
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t result = 0;
    *a2 = 0;
  }
  *a3 = v6;
  return result;
}

uint64_t dyld3::MachOFile::findFairPlayEncryptionLoadCommand(dyld3::MachOFile *this)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile33findFairPlayEncryptionLoadCommandEv_block_invoke;
  void v4[3] = &unk_1EFF66370;
  v4[4] = &v6;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v5, (uint64_t)v4);
  uint64_t v2 = 0;
  if (Diagnostics::noError((Diagnostics *)&v5)) {
    uint64_t v2 = v7[3];
  }
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedPageInLinking(dyld4::SyscallDelegate *this)
{
  pid_t v1 = getpid();
  return (int)sandbox_check(v1, (vm_address_t *)"syscall-unix", 1073741838, v2, v3, v4, v5, v6, 0x226u) > 0;
}

uint64_t sandbox_check(int a1, vm_address_t *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  char v27 = a2;
  sandbox_operation_fixup(&v27);
  v17[0] = 0;
  long long v18 = 0u;
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  v17[1] = a1;
  *(void *)&long long v18 = v27;
  BOOL v26 = &a9;
  return sandbox_check_common(v17, a3, &a9, v11, v12, v13, v14, v15);
}

vm_address_t *sandbox_operation_fixup(vm_address_t **a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = (vm_address_t *)_platform_strcmp((const char *)result, "iokit-open");
    if (!result)
    {
      uint64_t result = sandbox_warn("sandbox operation \"%s\" is obsolete; replace with \"%s\"",
                 v3,
                 v4,
                 v5,
                 v6,
                 v7,
                 v8,
                 v9,
                 (int)"iokit-open");
      *a1 = (vm_address_t *)"iokit-open-user-client";
    }
  }
  return result;
}

uint64_t sandbox_check_common(void *a1, int a2, unsigned int *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  long long v23 = a3;
  *a1 = &v18;
  if ((a2 & 0x40000000) != 0)
  {
    a1[5] |= 1uLL;
    if ((a2 & 0x20000000) == 0)
    {
LABEL_3:
      if ((a2 & 0x10000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((a2 & 0x20000000) == 0)
  {
    goto LABEL_3;
  }
  a1[5] |= 2uLL;
  if ((a2 & 0x10000000) == 0)
  {
LABEL_4:
    if ((a2 & 0x8000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  a1[5] |= 8uLL;
  if ((a2 & 0x8000000) == 0)
  {
LABEL_5:
    if ((a2 & 0x4000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  a1[5] |= 0x10uLL;
  if ((a2 & 0x4000000) == 0)
  {
LABEL_6:
    if ((a2 & 0x2000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_14:
  a1[5] |= 0x20uLL;
  if ((a2 & 0x2000000) != 0) {
LABEL_7:
  }
    a1[5] |= 0x40uLL;
LABEL_8:
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v8 = a2 & 0x81FFFFFF;
  uint64_t v18 = 0;
  uint64_t v9 = 240;
  switch((int)v8)
  {
    case 0:
      a1[3] = 0;
      a1[4] = 0;
      goto LABEL_36;
    case 1:
      goto LABEL_32;
    case 2:
      uint64_t v8 = 6;
      goto LABEL_32;
    case 3:
      uint64_t v8 = 7;
      goto LABEL_32;
    case 4:
      uint64_t v8 = 25;
      goto LABEL_32;
    case 5:
      uint64_t v8 = 27;
      goto LABEL_32;
    case 6:
      uint64_t v8 = 28;
      goto LABEL_32;
    case 7:
      uint64_t v8 = 33;
      goto LABEL_32;
    case 8:
      uint64_t v8 = 34;
      goto LABEL_32;
    case 9:
      unint64_t v10 = v23;
      v23 += 2;
      uint64_t v21 = *(void *)v10;
      long long v23 = v10 + 4;
      uint64_t v22 = (int)v10[2];
      a1[3] = 35;
      a1[4] = &v21;
      goto LABEL_36;
    case 10:
      goto LABEL_34;
    case 11:
      uint64_t v11 = v23;
      v23 += 2;
      uint64_t v12 = *(_DWORD **)v11;
      long long v23 = v11 + 4;
      uint64_t v13 = (uint64_t *)*((void *)v11 + 1);
      a1[3] = 241;
      LODWORD(v2dyld4::halt((char *)__format, 0) = *v12;
      uint64_t v19 = *v13;
      uint64_t v14 = &v19;
      goto LABEL_35;
    case 12:
      uint64_t v8 = 50;
      goto LABEL_32;
    case 13:
      uint64_t v8 = 19;
      goto LABEL_32;
    case 14:
      uint64_t v9 = 65;
      goto LABEL_34;
    case 15:
      uint64_t v8 = 45;
      goto LABEL_32;
    case 16:
      uint64_t v9 = 75;
      goto LABEL_34;
    case 17:
      uint64_t v8 = 5;
LABEL_32:
      a1[3] = v8;
      uint64_t v15 = (uint64_t **)v23;
      v23 += 2;
      uint64_t v14 = *v15;
      goto LABEL_35;
    case 18:
      uint64_t v9 = 52;
LABEL_34:
      a1[3] = v9;
      uint64_t v16 = v23;
      v23 += 2;
      uint64_t v14 = (uint64_t *)*v16;
LABEL_35:
      a1[4] = v14;
LABEL_36:
      if (__sandbox_ms("Sandbox", (void *)2, a1, a4, a5, a6, a7, a8)) {
        goto LABEL_37;
      }
      uint64_t result = v18 != 0;
      break;
    default:
      *__error() = 22;
LABEL_37:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t __sandbox_ms(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___mac_syscall, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

size_t dyld4::Loader::validateFile(vm_address_t *a1, uint64_t a2, int a3, const char *a4, unsigned int *a5, uint64_t a6)
{
  if (dyld4::SyscallDelegate::fstat(*(dyld4::SyscallDelegate **)(a2 + 8), a3, &v27))
  {
    int v12 = *__error();
    if (v12 == 2)
    {
      Diagnostics::error(a1, "no such file");
    }
    else if (v12 == 1 && dyld4::SyscallDelegate::sandboxBlockedStat(*(dyld4::SyscallDelegate **)(a2 + 8), a4))
    {
      Diagnostics::error(a1, "file system sandbox blocked stat(\"%s\")");
    }
    else
    {
      Diagnostics::error(a1, "stat(\"%s\") failed with errno=%d");
    }
    return -1;
  }
  if (*(unsigned char *)(a6 + 52))
  {
    if (v27.st_ino != *(void *)(a6 + 16))
    {
      Diagnostics::error(a1, "file inode changed from 0x%llX to 0x%llX since Loader was built for '%s'");
      return -1;
    }
    if (v27.st_mtimespec.tv_sec != *(void *)(a6 + 24))
    {
      Diagnostics::error(a1, "file mtime changed from 0x%llX to 0x%lX since Loader was built for '%s'");
      return -1;
    }
    size_t v13 = *(void *)a6;
    if (v27.st_size < *(void *)a6)
    {
      Diagnostics::error(a1, "file too small for slice offset '%s'");
      return -1;
    }
  }
  else
  {
    if (!a5[1]) {
      return -1;
    }
    uint64_t v14 = (dyld3::FatFile *)dyld4::SyscallDelegate::mmap(*(dyld4::SyscallDelegate **)(a2 + 8), 0, v27.st_size, 1, 2, a3, 0);
    if (v14 == (dyld3::FatFile *)-1)
    {
      Diagnostics::error(a1, "could not mmap() '%s'");
      return -1;
    }
    uint64_t v15 = v14;
    unint64_t v26 = 0;
    uint64_t v16 = dyld3::MachOFile::compatibleSlice(a1, &v26, v14, v27.st_size, a4, *(_DWORD *)(*(void *)(a2 + 8) + 68), 0, *(dyld3::GradedArchs **)(*(void *)(a2 + 8) + 144), *(unsigned char *)(*(void *)(a2 + 8) + 169));
    if (v16)
    {
      uint64_t v17 = v16;
      uint64_t v22 = 0;
      long long v23 = &v22;
      uint64_t v24 = 0x2000000000;
      char v25 = 0;
      unint64_t v18 = a5[1];
      uint64_t v19 = (int *)((char *)v16 + *a5);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 0x40000000;
      v21[2] = ___ZN5dyld46Loader12validateFileER11DiagnosticsRKNS_12RuntimeStateEiPKcRKNS0_19CodeSignatureInFileERKNS0_18FileValidationInfoE_block_invoke;
      void v21[3] = &unk_1EFF64650;
      v21[4] = &v22;
      v21[5] = a6;
      dyld3::MachOFile::forEachCDHashOfCodeSignature((uint64_t)v16, v19, v18, (uint64_t)v21);
      if (*((unsigned char *)v23 + 24))
      {
        size_t v13 = (char *)v17 - (char *)v15;
      }
      else
      {
        Diagnostics::error(a1, "file cdHash not as expected '%s'", a4);
        size_t v13 = -1;
      }
      _Block_object_dispose(&v22, 8);
    }
    else
    {
      size_t v13 = -1;
    }
    dyld4::SyscallDelegate::unmapFile(*(dyld4::SyscallDelegate **)(a2 + 8), v15, *(void *)a6);
  }
  return v13;
}

int fstat64(int a1, stat *a2)
{
  int64_t v9 = mac_syscall(SYS_fstat64, *(void **)&a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

uint64_t dyld4::SyscallDelegate::fstat(dyld4::SyscallDelegate *this, int a2, stat *a3)
{
  return fstat64(a2, a3);
}

uint64_t dyld4::setUpPageInLinkingRegions(const dyld4::RuntimeState *a1, dyld4::Loader *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const mwl_region *a7, uint64_t a8)
{
  int v80 = a6;
  __int16 v9 = a5;
  __int16 v10 = a4;
  int v83 = a2;
  mwlr_vm_address_t address = a7->mwlr_address;
  unsigned int v14 = 4 * mwlr_address + 4;
  const mwl_region *__attribute__((__org_arrdim(0,0))) v82 = a7;
  if (mwlr_address)
  {
    uint64_t v15 = 48 * mwlr_address;
    uint64_t v16 = (_DWORD **)(*(void *)&a7->mwlr_fd + 40);
    do
    {
      uint64_t v17 = *v16;
      v16 += 6;
      unsigned int v14 = (v14 + *v17 + 3) & 0xFFFFFFFC;
      v15 -= 48;
    }
    while (v15);
  }
  uint64_t v18 = (v14 + 47) & 0xFFFFFFF8;
  uint64_t v19 = *(void *)(a8 + 16);
  if (a4 == 3) {
    char v20 = 2;
  }
  else {
    char v20 = 3;
  }
  if (a4 == 3) {
    char v21 = 2;
  }
  else {
    char v21 = 3;
  }
  __chkstk_darwin((uint64_t)a1, (v19 << v20) + v18, a3, a4, a5, a6, (uint64_t)a7, a8, v79);
  long long v23 = (char *)&v79 - v22;
  long long v81 = (const mwl_region *)v24;
  bzero((char *)&v79 - v22, v24);
  *(_DWORD *)long long v23 = 7;
  *((_WORD *)v23 + 2) = v9;
  *((_WORD *)v23 + 3) = v10;
  *((_DWORD *)v23 + 2) = v18;
  *((_DWORD *)v23 + 3) = v19;
  *((_DWORD *)v23 + 4) = 40;
  *((_DWORD *)v23 + 5) = v14;
  *((void *)v23 + 3) = a3;
  *((void *)v23 + 4) = dyld4::Loader::loadAddress(v83, a1);
  char v25 = memmove(&v23[v18], *(const void **)a8, (v19 << v21));
  const mwl_region *__attribute__((__org_arrdim(0,0))) v33 = v82;
  mach_vm_address_t v34 = v82->mwlr_address;
  vm_size_t v35 = &v23[*((unsigned int *)v23 + 4)];
  *(_DWORD *)vm_size_t v35 = v34;
  if (v34)
  {
    int v36 = 0;
    __int16 v37 = *(_OWORD **)&v33->mwlr_fd;
    int v38 = 4 * v34 + 4;
    uint64_t v39 = 48 * v34;
    char v40 = (unsigned int **)v37 + 5;
    do
    {
      *(_DWORD *)&v35[4 * v36 + 4] = v38;
      char v41 = *v40;
      v40 += 6;
      int v42 = *v41;
      char v43 = memmove(&v23[*((_DWORD *)v23 + 4) + v38], v41, *v41);
      ++v36;
      v38 += v42;
      v39 -= 48;
    }
    while (v39);
    __chkstk_darwin((uint64_t)v43, v44, v45, v46, v47, v48, v49, v50, v79);
    uint64_t v56 = (const mwl_region *)((char *)&v79 - (v55 & 0xFFFFFFFFFFFFFFE0 | 0x10));
    uint64_t v57 = 0;
    uint64_t v58 = 48 * v34;
    char v59 = (mwl_region *)v56;
    const mwl_region *__attribute__((__org_arrdim(0,0))) v33 = v82;
    do
    {
      if (v34 == v57) {
        ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
      }
      ++v57;
      long long v60 = *v37;
      long long v61 = v37[1];
      v37 += 3;
      *(_OWORD *)&v59->mwlr_fd = v60;
      *(_OWORD *)&v59->mwlr_vm_address_t address = v61;
      ++v59;
      v58 -= 48;
    }
    while (v58);
  }
  else
  {
    __chkstk_darwin((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32, v79);
    uint64_t v56 = (const mwl_region *)((char *)&v79 - (v62 & 0xFFFFFFFFFFFFFFE0 | 0x10));
    LODWORD(v57) = 0;
  }
  if (v80)
  {
    vm_size_t v63 = v81;
    return dyld4::dyld_map_with_linking_np((dyld4 *)v23, v63, v51, v52, v53, v54);
  }
  const mwl_region *__attribute__((__org_arrdim(0,0))) v82 = v56;
  uint64_t v64 = *((void *)a1 + 1);
  if (*(unsigned char *)(v64 + 202) || *(unsigned char *)(v64 + 201))
  {
    int v65 = (const char *)dyld4::Loader::path(v83, a1);
    dyld4::RuntimeState::log(a1, "Setting up kernel page-in linking for %s\n", v65);
    mach_vm_address_t v66 = v33->mwlr_address;
    if (v66)
    {
      uint64_t v67 = 48 * v66;
      uint64_t v68 = *(void *)&v33->mwlr_fd + 16;
      do
      {
        unint64_t v69 = *(void *)(v68 + 8);
        int v70 = *(_DWORD *)(v68 - 12);
        unint64_t v78 = v69 >> 10;
        uint64_t v77 = v69 + *(void *)v68;
        if ((v70 & 4) != 0) {
          uint64_t v71 = 120;
        }
        else {
          uint64_t v71 = 46;
        }
        if ((v70 & 2) != 0) {
          uint64_t v72 = 119;
        }
        else {
          uint64_t v72 = 46;
        }
        if (v70) {
          uint64_t v73 = 114;
        }
        else {
          uint64_t v73 = 46;
        }
        dyld4::RuntimeState::log(a1, "%14s (%c%c%c) 0x%012llX->0x%012llX (fileOffset=0x%0llX, size=%lluKB)\n", *(const char **)(v68 + 16), v73, v72, v71, *(void *)v68, v77, *(void *)(v68 - 8), v78);
        v68 += 48;
        v67 -= 48;
      }
      while (v67);
    }
  }
  vm_size_t v63 = v81;
  uint64_t result = __map_with_linking_np(v82, v57, (const mwl_info_hdr *)v23, (uint32_t)v81);
  if (result)
  {
    uint64_t v75 = *((void *)a1 + 1);
    if (*(unsigned char *)(v75 + 202) || *(unsigned char *)(v75 + 201))
    {
      long long v76 = (const char *)dyld4::Loader::path(v83, a1);
      dyld4::RuntimeState::log(a1, "__map_with_linking_np(%s) failed, falling back to linking in-process\n", v76);
    }
    return dyld4::dyld_map_with_linking_np((dyld4 *)v23, v63, v51, v52, v53, v54);
  }
  return result;
}

void dyld4::Loader::forEachBindTarget(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke;
  void v7[3] = &unk_1EFF647D8;
  char v8 = a5;
  void v7[8] = a2;
  void v7[9] = a3;
  v7[4] = a4;
  v7[5] = a6;
  void v7[6] = a7;
  void v7[7] = a1;
  dyld4::Loader::withLayout(a1, a2, a3, (uint64_t)v7);
}

void dyld4::Loader::withLayout(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::withLayout();
  }
  if (*((_WORD *)a1 + 2))
  {
    dyld4::PrebuiltLoader::withLayout(a1, a2, a3, a4);
  }
  else
  {
    dyld4::JustInTimeLoader::withLayout((uint64_t)a1, a2, (uint64_t)a3, a4);
  }
}

void dyld4::JustInTimeLoader::withLayout(uint64_t a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
}

void ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke(uint64_t a1, dyld3::FatFile *this, unint64_t a3, int a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v22 = 0;
  __int16 v10 = dyld3::MachOFile::compatibleSlice(*(vm_address_t **)(a1 + 40), &v22, this, a3, *(const char **)(a1 + 48), *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 68), a4, *(dyld3::GradedArchs **)(*(void *)(*(void *)(a1 + 56) + 8) + 144), *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 169));
  if (v10)
  {
    uint64_t v11 = (dyld3::MachOFile *)v10;
    if (dyld3::MachOFile::isDylib((dyld3::MachOFile *)v10))
    {
      int v12 = *(unsigned char **)(a1 + 64);
      if (!v12[7])
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "cannot load dylib '%s'");
        return;
      }
    }
    else if (dyld3::MachOFile::isBundle(v11))
    {
      int v12 = *(unsigned char **)(a1 + 64);
      if (!v12[8])
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "cannot link against bundle '%s'");
        return;
      }
    }
    else
    {
      if (!dyld3::MachOFile::isMainExecutable(v11))
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "unloadable mach-o file type %d '%s'");
        return;
      }
      int v12 = *(unsigned char **)(a1 + 64);
      if (!v12[9])
      {
        char v21 = *(vm_address_t **)(a1 + 40);
        if (v12[1]) {
          Diagnostics::error(v21, "cannot link against a main executable '%s'");
        }
        else {
          Diagnostics::error(v21, "cannot dlopen a main executable '%s'");
        }
        return;
      }
    }
    char v13 = v12[4];
    if (v12[10])
    {
      BOOL v14 = 0;
    }
    else if (*v12)
    {
      BOOL v14 = 1;
    }
    else
    {
      BOOL v14 = dyld3::MachOAnalyzer::neverUnload(v11);
    }
    unint64_t v15 = dyld3::MachOFile::mappedSize(v11);
    char v16 = *((unsigned char *)a5 + 24);
    uint64_t v17 = *a5;
    uint64_t v18 = a5[2];
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 0x40000000;
    void v23[2] = ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke_2;
    v23[3] = &unk_1EFF64CA8;
    uint64_t v19 = *(void *)(a1 + 56);
    uint64_t v20 = *(void *)(a1 + 32);
    v23[6] = *(void *)(a1 + 40);
    v23[7] = v19;
    v23[8] = a6;
    v23[9] = v15;
    BOOL v28 = v14;
    v23[10] = v11 - this;
    v23[12] = v17;
    v23[13] = v18;
    char v24 = v16;
    v23[4] = v20;
    v23[5] = v11;
    char v25 = a5;
    char v29 = v13;
    char v30 = *(unsigned char *)(a1 + 84);
    int v27 = *(_DWORD *)(a1 + 80);
    int8x16_t v26 = vextq_s8(*(int8x16_t *)(a1 + 64), *(int8x16_t *)(a1 + 64), 8uLL);
    dyld4::JustInTimeLoader::withRegions(v11, (uint64_t)v23);
  }
}

int __map_with_linking_np(const mwl_region regions[], uint32_t regionCount, const mwl_info_hdr *blob, uint32_t blobSize)
{
  int result = mac_syscall(SYS_map_with_linking_np, regions, regionCount, blob, blobSize);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

void ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke(uint64_t a1, dyld3::FatFile *this, unint64_t a3)
{
  uint64_t v6 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(this, this);
  if (v6)
  {
    uint64_t v7 = (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke_2;
    void v8[3] = &unk_1EFF64A50;
    long long v9 = *(_OWORD *)(a1 + 40);
    __int16 v10 = this;
    dyld3::FatFile::forEachSlice(v6, v7, a3, (uint64_t)v8);
  }
}

_DWORD *dyld3::FatFile::isFatFile(_DWORD *this, const void *a2)
{
  if ((*this | 0x1000000) != 0xBFBAFECA) {
    return 0;
  }
  return this;
}

double ___ZN5dyld416JustInTimeLoader11withRegionsEPKN5dyld39MachOFileEU13block_pointerFvRKNS1_5ArrayINS_6Loader6RegionEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 56);
  uint64_t v5 = *(void *)(a2 + 8);
  if ((v4 & 8) != 0 && !v5) {
    goto LABEL_10;
  }
  int v6 = *(_DWORD *)(a2 + 52);
  v13.n128_u64[0] = (v4 << 62) & 0x8000000000000000 | ((unint64_t)(v6 & 7) << 59) | (*(void *)(a2 + 16)
                                                                                            - *(void *)(a1 + 40)) & 0x7FFFFFFFFFFFFFFLL;
  v13.n128_u32[2] = *(void *)a2;
  v13.n128_u32[3] = v5;
  if ((unsigned __int16)v4 >> 4 == *(_DWORD *)(a1 + 48) - 1 && v6 == 1) {
    v13.n128_u32[3] = *(void *)(a2 + 24);
  }
  *(void *)&double result = dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back((uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), &v13).n128_u64[0];
  if ((*(unsigned char *)(a2 + 56) & 8) != 0)
  {
LABEL_10:
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(a1 + 32);
    v12.n128_u64[0] = (*(void *)(a2 + 16) - *(void *)(a1 + 40) + v9) & 0x7FFFFFFFFFFFFFFLL | ((unint64_t)(*(_DWORD *)(a2 + 52) & 7) << 59) | 0x4000000000000000;
    unsigned __int32 v11 = *(_DWORD *)(a2 + 24) - v9;
    v12.n128_u32[2] = 0;
    v12.n128_u32[3] = v11;
    *(void *)&double result = dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back((uint64_t *)(*(void *)(v10 + 8) + 40), &v12).n128_u64[0];
  }
  return result;
}

__n128 dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back(uint64_t *a1, __n128 *a2)
{
  unint64_t v2 = a1[2];
  if (v2 >= a1[1]) {
    ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
  }
  uint64_t v3 = *a1;
  a1[2] = v2 + 1;
  __n128 result = *a2;
  *(__n128 *)(v3 + 16 * v2) = *a2;
  return result;
}

uint64_t dyld4::APIs::_dyld_swift_optimizations_version(dyld4::APIs *this)
{
  return 1;
}

uint64_t dyld4::APIs::_NSGetExecutablePath(dyld4::APIs *this, char *a2, unsigned int *a3)
{
  uint64_t v5 = *((void *)this + 1);
  if (*(unsigned char *)(v5 + 204))
  {
    dyld4::RuntimeState::log(this, "_NSGetExecutablePath(%p, %p)\n", a2, a3);
    uint64_t v5 = *((void *)this + 1);
  }
  uint64_t v7 = 16;
  if (*(_DWORD *)(v5 + 68) == 1) {
    uint64_t v7 = 24;
  }
  char v8 = *(const char **)(v5 + v7);
  size_t v9 = _platform_strlen(v8);
  size_t v10 = *a3;
  if (v9 + 1 <= v10)
  {
    strlcpy(a2, v8, v10);
    return 0;
  }
  else
  {
    *a3 = v9 + 1;
    return 0xFFFFFFFFLL;
  }
}

const void *dyld4::APIs::_dyld_get_shared_cache_range(dyld4::APIs *this, unint64_t *a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (*(unsigned char *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_shared_cache_range(%p)", a2);
    uint64_t v4 = *((void *)this + 1);
  }
  *a2 = 0;
  uint64_t v5 = *(const void **)(v4 + 240);
  if (v5)
  {
    unint64_t v6 = DyldSharedCache::mappedSize(*(DyldSharedCache **)(v4 + 240));
    *a2 = v6;
    uint64_t v4 = *((void *)this + 1);
  }
  else
  {
    unint64_t v6 = 0;
  }
  if (*(unsigned char *)(v4 + 204)) {
    dyld4::RuntimeState::log(this, " => %p,0x%lX\n", v5, v6);
  }
  return v5;
}

BOOL dyld4::SyscallDelegate::realpathdir(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3)
{
  int v4 = dyld3::open(a2, (const char *)0x100000, 0);
  if (v4 == -1) {
    return 0;
  }
  int v5 = v4;
  BOOL v6 = fcntl(v4, 50, a3) == 0;
  close(v5);
  return v6;
}

dyld4::CacheFinder *dyld4::CacheFinder::CacheFinder(dyld4::CacheFinder *this, const dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Logging *a3, dyld4::SyscallDelegate *a4)
{
  *(_DWORD *)this = -1;
  *((void *)this + 1) = a4;
  *((_DWORD *)this + 4) = 4;
  uint64_t v7 = (int *)((char *)this + 16);
  *(void *)((char *)this + 2dyld4::halt((char *)__format, 0) = -1;
  *(void *)((char *)this + 28) = -1;
  *(void *)((char *)this + 36) = -1;
  *((_DWORD *)this + 11) = -1;
  *((unsigned char *)this + 48) = 0;
  *((_DWORD *)this + 13) = -1;
  char v8 = (dyld3 *)_simple_getenv(*((const char ***)a2 + 14), "DYLD_SHARED_CACHE_DIR");
  if (v8)
  {
    int v9 = dyld4::SyscallDelegate::open(*((dyld4::SyscallDelegate **)this + 1), v8, 0, 0);
    *(_DWORD *)this = v9;
    if (v9 == -1) {
      return this;
    }
  }
  if ((*((unsigned char *)a2 + 88) & 8) != 0) {
    goto LABEL_31;
  }
  int v10 = *((_DWORD *)a2 + 24);
  v24[0] = 1;
  v24[1] = v10;
  long long v25 = *(_OWORD *)((char *)a2 + 104);
  uint64_t v26 = *((void *)a2 + 15);
  int v11 = *((_DWORD *)a2 + 15);
  int v27 = -1;
  int v28 = v11;
  uint64_t v12 = ignite((uint64_t)v24, v7);
  if (v12)
  {
    int v14 = v12;
    if (*((_DWORD *)a2 + 36) == 1)
    {
      dyld4::console((dyld4 *)"ignite() returned %d\n", v13, v12);
      if (v14 <= 84)
      {
        if (v14 == 8)
        {
          char v16 = "ignition disabled\n";
        }
        else
        {
          if (v14 != 19) {
            goto LABEL_23;
          }
          char v16 = "no shared cache available\n";
        }
        goto LABEL_22;
      }
      switch(v14)
      {
        case 'Y':
          char v16 = "ignition partially disabled\n";
LABEL_22:
          dyld4::console((dyld4 *)v16, v15, v23);
          break;
        case 'U':
          unint64_t v22 = "no shared cache in cryptex";
LABEL_41:
          dyld4::halt(v22, 0);
        case 'Z':
          unint64_t v22 = "ignition failed";
          goto LABEL_41;
      }
    }
    else if (v12 == 85 && *((unsigned char *)a3 + 1))
    {
      dyld4::console((dyld4 *)"ignite() returned %d\n", v13, 85);
    }
  }
  else
  {
    int v17 = *((_DWORD *)this + 6);
    if ((v17 & 0x80000000) == 0)
    {
      if (*(_DWORD *)this == -1)
      {
        *(_DWORD *)this = v17;
        *((unsigned char *)this + 48) = 1;
      }
      else
      {
        dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)this + 1), v17);
      }
    }
    int v18 = *((_DWORD *)this + 8);
    if ((v18 & 0x80000000) == 0) {
      *((_DWORD *)this + 13) = v18;
    }
  }
LABEL_23:
  if (*((unsigned char *)this + 48))
  {
    if (*((_DWORD *)a2 + 15) == 10) {
      uint64_t v19 = (*((void *)a2 + 11) >> 5) & 1;
    }
    else {
      uint64_t v19 = *((void *)a2 + 11) & 0x10;
    }
    if (!v19) {
      return this;
    }
    if (*(_DWORD *)this != -1) {
      dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)this + 1), *(_DWORD *)this);
    }
    *(_DWORD *)this = -1;
    *((unsigned char *)this + 48) = 0;
  }
LABEL_31:
  if (*(_DWORD *)this == -1)
  {
    if (*((_DWORD *)a2 + 15) == 10) {
      uint64_t v20 = "/System/DriverKit/System/Library/dyld/";
    }
    else {
      uint64_t v20 = "/System/Library/Caches/com.apple.dyld/";
    }
    *(_DWORD *)this = dyld4::SyscallDelegate::open(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)v20, 0, 0);
  }
  return this;
}

uint64_t ignite(uint64_t a1, int *a2)
{
  uint64_t v191 = 0xFFFFFFFFLL;
  memset(v190, 0, sizeof(v190));
  LODWORD(v190[0]) = 1;
  uint64_t v189 = 0;
  bzero(v188, 0x4C0uLL);
  size_t v187 = 1216;
  uint64_t v193 = 1;
  int v192 = 2;
  if (getpid() == 1)
  {
    int v11 = _open_as(0x20000, (int *)&v193 + 1);
    if (v11)
    {
      int v160 = v11;
      v161 = boot_get();
      ignition_halt((*v161)[1], v160, (unint64_t)(*v161)[2], "failed to reserve stdin descriptor: %s: %d", v162, v163, v164, v165, (int)"/dev/null");
    }
    int v12 = _open_as(131073, (int *)&v193);
    if (v12)
    {
      int v166 = v12;
      uint64_t v167 = boot_get();
      ignition_halt((*v167)[1], v166, (unint64_t)(*v167)[2], "failed to reserve stdout descriptor: %s: %d", v168, v169, v170, v171, (int)"/dev/null");
    }
    int v13 = _open_as(131074, &v192);
    if (v13)
    {
      int v172 = v13;
      uint64_t v173 = boot_get();
      ignition_halt((*v173)[1], v172, (unint64_t)(*v173)[2], "failed to reserve stderr descriptor: %s: %d", v174, v175, v176, v177, (int)"/dev/null");
    }
  }
  int v14 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    if (v14 != 1) {
      dyld_halt("unsupported parameter struct version: 0x%x", v4, v5, v6, v7, v8, v9, v10, v14);
    }
    HIDWORD(v191) = *(_DWORD *)(a1 + 36);
  }
  int v15 = *(_DWORD *)(a1 + 4);
  LODWORD(v190[0]) = 1;
  DWORD1(v190[0]) = v15;
  *(_OWORD *)((char *)v190 + 8) = *(_OWORD *)(a1 + 8);
  *((void *)&v190[1] + 1) = *(void *)(a1 + 24);
  LODWORD(v191) = *(_DWORD *)(a1 + 32);
  log_init((uint64_t)v190);
  dlog(-1, "%s\n", v16, v17, v18, v19, v20, v21, (int)__darwin_version_string[0]);
  int v22 = sysctlbyname("kern.bootargs", v188, &v187, 0, 0);
  uint64_t v23 = __error();
  if (v22 < 0)
  {
    if (!*v23) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v24, v25, v26, v27, v28, v29, v30, (int)"ret");
    }
  }
  else
  {
    *uint64_t v23 = 0;
  }
  int v38 = *__error();
  if (v38 > 11)
  {
    if (v38 != 22)
    {
      if (v38 != 12) {
        goto LABEL_32;
      }
      pid_t v39 = getpid();
      __error();
      dlog(-1, "libignition: %d: boot-arg buff not large enough: actual = %lu, expected >= %lu: %d\n", v40, v41, v42, v43, v44, v45, v39);
    }
    goto LABEL_18;
  }
  if ((v38 - 1) < 2)
  {
LABEL_18:
    v188[0] = 0;
    goto LABEL_19;
  }
  if (v38)
  {
LABEL_32:
    uint64_t v178 = boot_get();
    v179 = (*v178)[1];
    unint64_t v180 = (unint64_t)(*v178)[2];
    int v181 = *__error();
    v182 = __error();
    ignition_halt(v179, v181, v180, "failed to read boot args: %d", v183, v184, v185, v186, *v182);
  }
LABEL_19:
  size_t v46 = arguments_init(v188, v31, v32, v33, v34, v35, v36, v37);
  arguments(v46, v47, v48, v49, v50, v51, v52, v53);
  arguments_dump();
  BOOL v54 = configuration_init((uint64_t)v190, v188);
  uint64_t v62 = configuration(v54, v55, v56, v57, v58, v59, v60, v61);
  configuration_dump(v62);
  if (getpid() == 1)
  {
    pid_t v63 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v64, v65, v66, v67, v68, v69, v63);
    pid_t v70 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v71, v72, v73, v74, v75, v76, v70);
    pid_t v77 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v78, v79, v80, v81, v82, v83, v77);
    pid_t v84 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v85, v86, v87, v88, v89, v90, v84);
    pid_t v91 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v92, v93, v94, v95, v96, v97, v91);
  }
  int v98 = boot_select_spec(v62);
  boot_dump_spec();
  uint64_t v106 = boot_init(v98, v99, v100, v101, v102, v103, v104, v105);
  uint64_t v189 = v106;
  uint64_t v119 = boot_boot(v106, v107, v108, v109, v110, v111, v112, v113);
  if (v119)
  {
    pid_t v120 = getpid();
    dlog(-1, "libignition: %d: ignition boot failed: %d\n", v121, v122, v123, v124, v125, v126, v120);
  }
  else
  {
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_preboot, a2, v114, v115, v116, v117, v118);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_dylib_cache, a2, v127, v128, v129, v130, v131);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_xart, a2, v132, v133, v134, v135, v136);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_cryptex_app, a2, v137, v138, v139, v140, v141);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_cryptex_os, a2, v142, v143, v144, v145, v146);
    boot_set_payload((uint64_t)v106, (uint64_t)&_boot_root_preboot_groupdir, a2, v147, v148, v149, v150, v151);
  }
  if (getpid() == 1)
  {
    close(0);
    close(1);
    close(2);
  }
  boot_destroy(&v189, v152, v153, v154, v155, v156, v157, v158);
  log_destroy();
  return v119;
}

uint64_t boot_set_payload(uint64_t result, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 >= 5) {
    dyld_halt("unsupported payload version: actual = %u, expected <= %u", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
  }
  if (*a3 >= *(_DWORD *)(a2 + 8))
  {
    uint64_t v8 = *(void *)(a2 + 16);
    if (v8 < 0) {
      dyld_halt("invalid offset: %lld", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 16));
    }
    uint64_t v9 = *(void *)(a2 + 24);
    if (v9 < 0) {
      dyld_halt("invalid offset: %lld", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 24));
    }
    int v11 = dupfd_optional(*(_DWORD *)(result + v8), (int)"boot root");
    __n128 result = xferfd(&v11);
    *(int *)((char *)a3 + v9) = result;
  }
  return result;
}

uint64_t xferfd(_DWORD *a1)
{
  uint64_t v1 = *a1;
  *a1 = -1;
  return v1;
}

uint64_t dupfd_optional(int a1, int a2)
{
  if (a1 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dupfd(a1, a2);
  }
}

uint64_t dupfd(int a1, int a2)
{
  uint64_t result = dup(a1);
  if (a1 < 0)
  {
    uint64_t v5 = boot_get();
    uint64_t v6 = (*v5)[1];
    unint64_t v7 = (unint64_t)(*v5)[2];
    int v8 = *__error();
    __error();
    ignition_halt(v6, v8, v7, "failed to dup %s: fd = %d: %d", v9, v10, v11, v12, a2);
  }
  return result;
}

int dup(int a1)
{
  int result = mac_syscall(SYS_dup, a1);
  if (v1) {
    return cerror_nocancel(result);
  }
  return result;
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  uint64_t v14 = 0x300000000;
  size_t v12 = 56;
  size_t v10 = _platform_strlen(a1);
  int result = __sysctl((int *)&v14, 2u, v13, &v12, (void *)a1, v10);
  if ((result & 0x80000000) == 0) {
    return __sysctl(v13, v12 >> 2, a2, a3, a4, a5);
  }
  return result;
}

int __sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  int result = mac_syscall(SYS_sysctl, a1, a2, a3, a4, a5, a6);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t log_init(uint64_t a1)
{
  __g = a1;
  dword_1EB1CFD04 = *(_DWORD *)(a1 + 32);
  uint64_t result = _open_console();
  dword_1EB1CFD00 = result;
  qword_1EB1CFD08 = *(void *)(a1 + 16);
  return result;
}

int *log_destroy()
{
  return closefd_optional(&dword_1EB1CFD00, (int)"console");
}

BOOL configuration_init(uint64_t a1, char *a2)
{
  unint64_t v63 = 0;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  *(_OWORD *)__source = 0u;
  bzero(v58, 0x400uLL);
  ignition_test_BRA(1);
  __config[0] = a1;
  uint64_t v4 = 0x36Fu;
  LOBYTE(__config[v4]) = getpid() == 1;
  _derive_proc_name(a1, byte_1EB1CFDA8);
  qword_1EB1CFDA0 = (uint64_t)byte_1EB1CFDA8;
  if (!LOBYTE(__config[v4])) {
    goto LABEL_60;
  }
  uint64_t v91 = 0;
  long long v90 = 0u;
  long long v89 = 0u;
  long long v88 = 0u;
  long long v87 = 0u;
  long long v86 = 0u;
  long long v85 = 0u;
  long long v84 = 0u;
  long long v83 = 0u;
  long long v82 = 0u;
  long long v81 = 0u;
  long long v80 = 0u;
  long long v79 = 0u;
  long long v78 = 0u;
  long long v77 = 0u;
  long long v76 = 0u;
  *(_OWORD *)__s1 = 0u;
  size_t v74 = 256;
  int v73 = -1431699456;
  long long v72 = 0u;
  long long v71 = 0u;
  long long v70 = 0u;
  long long v69 = 0u;
  long long v68 = 0u;
  long long v67 = 0u;
  long long v66 = 0u;
  long long v65 = 0u;
  size_t v64 = 132;
  int v5 = sysctlbyname("security.mac.img4.ignition_blob", &v65, &v64, 0, 0);
  char v6 = __error();
  if (v5 < 0)
  {
    if (!*v6) {
      goto LABEL_75;
    }
  }
  else
  {
    *char v6 = 0;
  }
  int v14 = *__error();
  if (v14 == 2)
  {
    pid_t v15 = getpid();
    dlog(-1, "libignition: %d: ignition blob not available\n", v16, v17, v18, v19, v20, v21, v15);
  }
  else
  {
    if (v14)
    {
      int v50 = *__error();
      int v57 = *__error();
      uint64_t v55 = "failed to query ignition blob: %d";
      goto LABEL_83;
    }
    xmmword_1EB1D1898 = v71;
    unk_1EB1D18A8 = v72;
    dword_1EB1D18B8 = v73;
    xmmword_1EB1D1858 = v67;
    unk_1EB1D1868 = v68;
    xmmword_1EB1D1878 = v69;
    unk_1EB1D1888 = v70;
    xmmword_1EB1D1838 = v65;
    unk_1EB1D1848 = v66;
    qword_1EB1D18C0 = (uint64_t)&xmmword_1EB1D1838;
    qword_1EB1D1828 = (uint64_t)&unk_1EB1D184A;
  }
  __s1[0] = 0;
  size_t v74 = 256;
  int v22 = sysctlbyname("hw.osenvironment", __s1, &v74, 0, 0);
  uint64_t v23 = __error();
  if (v22 < 0)
  {
    if (!*v23) {
      goto LABEL_75;
    }
  }
  else
  {
    *uint64_t v23 = 0;
  }
  int v24 = *__error();
  if ((v24 - 1) >= 2 && v24 != 22)
  {
    if (v24)
    {
      int v50 = *__error();
      int v57 = *__error();
      uint64_t v55 = "failed to read os environment: %d";
      goto LABEL_83;
    }
    if (_platform_strcmp(__s1, (const char *)&unk_1A8E7346B))
    {
      strlcpy(byte_1EB1CFEE0, __s1, 0x40uLL);
      qword_1EB1CFEA8 = (uint64_t)byte_1EB1CFEE0;
      uint64_t v25 = &qword_1EB1CFEB0;
      if (_platform_strcmp(__s1, "kcgen"))
      {
        if (_platform_strcmp(__s1, "fvunlock"))
        {
          if (_platform_strcmp(__s1, "recoveryos"))
          {
            if (_platform_strcmp(__s1, "diagnostics"))
            {
              if (_platform_strcmp(__s1, "migration"))
              {
                if (_platform_strcmp(__s1, "eacs")) {
                  goto LABEL_28;
                }
                uint64_t v25 = &qword_1EB1CFED8;
              }
              else
              {
                uint64_t v25 = &qword_1EB1CFED0;
              }
            }
            else
            {
              uint64_t v25 = &qword_1EB1CFEC8;
            }
          }
          else
          {
            uint64_t v25 = &qword_1EB1CFEC0;
          }
        }
        else
        {
          uint64_t v25 = &qword_1EB1CFEB8;
        }
      }
      uint64_t *v25 = qword_1EB1CFEA8;
    }
  }
LABEL_28:
  __s1[0] = 0;
  size_t v74 = 256;
  int v26 = sysctlbyname("hw.target", __s1, &v74, 0, 0);
  uint64_t v27 = __error();
  if (v26 < 0)
  {
    if (!*v27) {
      goto LABEL_75;
    }
  }
  else
  {
    int *v27 = 0;
  }
  int v32 = *__error();
  if (v32 != 2)
  {
    if (v32 == 1)
    {
      uint64_t v33 = "unknownap";
      goto LABEL_39;
    }
    if (v32)
    {
      int v50 = *__error();
      int v57 = *__error();
      uint64_t v55 = "failed to query hardware target: %d";
      goto LABEL_83;
    }
    if (v74 >= 0x40) {
      ignition_halt((void *)6, 0, 0x40uLL, "hardware target string too long: actual = %lu, expected < %lu", v28, v29, v30, v31, v74);
    }
    if (v74 >= 2)
    {
      dyld_tolower_cstr(__s1, (uint64_t)byte_1EB1D18D0, v74);
      goto LABEL_40;
    }
  }
  uint64_t v33 = "x86legacyap";
LABEL_39:
  strlcpy(byte_1EB1D18D0, v33, 0x40uLL);
LABEL_40:
  qword_1EB1D18C8 = (uint64_t)byte_1EB1D18D0;
  int v34 = fsctl("/", 0x40084A6AuLL, &v91, 0);
  uint64_t v35 = __error();
  if (v34 < 0)
  {
    if (*v35) {
      goto LABEL_43;
    }
LABEL_75:
    dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v7, v8, v9, v10, v11, v12, v13, (int)"ret");
  }
  int *v35 = 0;
LABEL_43:
  int v36 = *__error();
  if (v36 != 25 && v36 != 1)
  {
    if (!v36)
    {
      qword_1EB1D0F98 = v91;
      goto LABEL_47;
    }
    int v50 = *__error();
    int v57 = *__error();
    uint64_t v55 = "failed to query root device status: %d";
LABEL_83:
    ignition_halt((void *)6, v50, 0x40uLL, v55, v51, v52, v53, v54, v57);
  }
LABEL_47:
  if (statfs64("/", &stru_1EB1D0FA8))
  {
    int v50 = *__error();
    int v57 = *__error();
    uint64_t v55 = "statfs failed: %d";
    goto LABEL_83;
  }
  qword_1EB1D1820 = (uint64_t)&stru_1EB1D0FA8;
  uint64_t v37 = *(const char ***)(a1 + 16);
  if (v37)
  {
    if (_simple_getenv(v37, "XPC_USERSPACE_REBOOTED")) {
      byte_1EB1D1912 = 1;
    }
    int v38 = _simple_getenv(*(const char ***)(a1 + 16), "XPC_USERSPACE_PIVOTEDROOT");
    if (v38)
    {
      strlcpy(byte_1EB1D0B90, v38, 0x400uLL);
      qword_1EB1D0B88 = (uint64_t)byte_1EB1D0B90;
    }
  }
  uint64_t v39 = *(unsigned int *)(a1 + 4);
  if ((int)v39 >= 1)
  {
    uint64_t v40 = *(unsigned char ***)(a1 + 8);
    do
    {
      uint64_t v41 = *v40;
      if (**v40 == 45) {
        uint64_t v41 = *v40 + 1;
      }
      if (*v41 == 115) {
        byte_1EB1D1911 = 1;
      }
      ++v40;
      --v39;
    }
    while (v39);
  }
LABEL_60:
  if (dyld_parse_boot_arg_cstr(a2, "rd", __source, 0x40uLL))
  {
    strlcpy(byte_1EB1CFF30, __source, 0x40uLL);
    qword_1EB1CFF20 = (uint64_t)byte_1EB1CFF30;
    if (!_platform_strcmp(__source, "md0")) {
      qword_1EB1CFF28 = (uint64_t)byte_1EB1CFF30;
    }
  }
  if (dyld_parse_boot_arg_cstr(a2, "arp0", v58, 0x400uLL))
  {
    strlcpy(byte_1EB1CFF78, v58, 0x400uLL);
    qword_1EB1CFF70 = (uint64_t)byte_1EB1CFF78;
  }
  if (dyld_parse_boot_arg_cstr(a2, "rp", v58, 0x400uLL))
  {
    strlcpy(byte_1EB1D0380, v58, 0x400uLL);
    qword_1EB1D0378 = (uint64_t)byte_1EB1D0380;
  }
  if (dyld_parse_boot_arg_cstr(a2, "rp0", v58, 0x400uLL))
  {
    strlcpy(byte_1EB1D0788, v58, 0x400uLL);
    qword_1EB1D0780 = (uint64_t)byte_1EB1D0788;
  }
  if (dyld_parse_boot_arg_int(a2, "rootdmg-ramdisk", &v63))
  {
    if (HIDWORD(v63)) {
      dyld_halt("value not representable as uint32_t", v42, v43, v44, v45, v46, v47, v48, v56);
    }
    dword_1EB1D0F90 = v63;
  }
  BOOL result = dyld_parse_boot_arg_int(a2, "restore", 0);
  if (result) {
    byte_1EB1D0F94 = 1;
  }
  dword_1EB1D0FA0 = MEMORY[0xFFFFF4084];
  _config = (uint64_t)__config;
  return result;
}

BOOL dyld_parse_boot_arg_int(char *a1, const char *a2, unint64_t *a3)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v17 = v4;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  int v5 = (const char *)&v17;
  BOOL v6 = dyld_parse_boot_arg_cstr(a1, a2, (char *)&v17, 0x18uLL);
  if (!v6) {
    return v6;
  }
  if (strstr((char *)&v17, "0x") == (char *)&v17) {
    int v5 = (char *)&v17 + 2;
  }
  if (!a3) {
    return v6;
  }
  size_t v7 = _platform_strlen(v5);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  unint64_t v20 = 0;
  while (1)
  {
    strcpy(__dst, "00");
    if (v7 == 1)
    {
      int v13 = v5[v10];
      __dst[0] = v5[v10];
      __dst[1] = 48;
      v8 += 4;
      uint64_t v11 = 1;
    }
    else
    {
      if (!v7)
      {
        uint64_t v11 = 0;
        char v12 = 0;
        v8 += 8;
        goto LABEL_16;
      }
      strlcpy(__dst, &v5[v10], 3uLL);
      int v13 = __dst[0];
      uint64_t v11 = 2;
    }
    char v12 = v13 - 48;
    if ((v13 - 48) >= 0xA)
    {
      if ((v13 - 97) > 5)
      {
        if ((v13 - 65) > 5) {
          goto LABEL_23;
        }
        char v12 = v13 - 55;
      }
      else
      {
        char v12 = v13 - 87;
      }
    }
LABEL_16:
    unsigned int v14 = __dst[1] - 48;
    if (v14 >= 0xA) {
      break;
    }
LABEL_21:
    *((unsigned char *)&v20 + v9) = v14 | (16 * v12);
    v7 -= v11;
    v10 += v11;
    if (++v9 == 8)
    {
      unint64_t v15 = bswap64(v20) >> v8;
      goto LABEL_24;
    }
  }
  if (__dst[1] - 97 <= 5)
  {
    LOBYTE(v14) = __dst[1] - 87;
    goto LABEL_21;
  }
  if (__dst[1] - 65 <= 5)
  {
    LOBYTE(v14) = __dst[1] - 55;
    goto LABEL_21;
  }
LABEL_23:
  unint64_t v15 = 0;
LABEL_24:
  *a3 = v15;
  return v6;
}

ssize_t configuration_dump(uint64_t a1)
{
  ssize_t result = getpid();
  if ((int)result <= 1)
  {
    uint64_t v3 = *(void *)(a1 + 6952);
    if (v3) {
      _platform_strcmp((const char *)(v3 + 50), (const char *)&unk_1A8E7346B);
    }
    pid_t v4 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v5, v6, v7, v8, v9, v10, v4);
    pid_t v11 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v12, v13, v14, v15, v16, v17, v11);
    pid_t v18 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v19, v20, v21, v22, v23, v24, v18);
    pid_t v25 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v26, v27, v28, v29, v30, v31, v25);
    pid_t v32 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v33, v34, v35, v36, v37, v38, v32);
    pid_t v39 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v40, v41, v42, v43, v44, v45, v39);
    pid_t v46 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v47, v48, v49, v50, v51, v52, v46);
    pid_t v53 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v54, v55, v56, v57, v58, v59, v53);
    pid_t v60 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v61, v62, v63, v64, v65, v66, v60);
    pid_t v67 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v68, v69, v70, v71, v72, v73, v67);
    pid_t v74 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v75, v76, v77, v78, v79, v80, v74);
    pid_t v81 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v82, v83, v84, v85, v86, v87, v81);
    pid_t v88 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v89, v90, v91, v92, v93, v94, v88);
    pid_t v95 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v96, v97, v98, v99, v100, v101, v95);
    pid_t v102 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v103, v104, v105, v106, v107, v108, v102);
    pid_t v109 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v110, v111, v112, v113, v114, v115, v109);
    pid_t v116 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v117, v118, v119, v120, v121, v122, v116);
    pid_t v123 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v124, v125, v126, v127, v128, v129, v123);
    pid_t v130 = getpid();
    return dlog(-1, "libignition: %d:   %s : %s\n", v131, v132, v133, v134, v135, v136, v130);
  }
  return result;
}

char **boot_select_spec(uint64_t a1)
{
  unint64_t v2 = (unsigned char *)(a1 + 4604);
  ignition_test_BRA(2);
  if (!v2[2428]) {
    return &_boot_spec_post_initproc;
  }
  if (*(void *)(a1 + 400)) {
    return &_boot_spec_remote_ramdisk;
  }
  if (*(_DWORD *)(a1 + 4600) || *(void *)(a1 + 472) || *(void *)(a1 + 1504) || *(void *)(a1 + 2536)) {
    return &_boot_spec_remote_nerd;
  }
  if (*v2) {
    return &_boot_spec_remote_ramdisk;
  }
  if (*(void *)(a1 + 280) || *(void *)(a1 + 288) || *(void *)(a1 + 296)) {
    return &_boot_spec_remote_dmg;
  }
  ssize_t result = &_boot_spec_local;
  if (!*(void *)(a1 + 304))
  {
    if (*(void *)(a1 + 312)) {
      return &_boot_spec_remote_dmg;
    }
    ssize_t result = &_boot_spec_remote_dmg;
    if (!*(void *)(a1 + 320) && (*(unsigned char *)(a1 + 4608) & 1) == 0) {
      return &_boot_spec_local;
    }
  }
  return result;
}

char ***boot_init(char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = 0; i != 9; ++i)
  {
    unint64_t v9 = (unint64_t)(&__roots)[i][2];
    if ((v9 & 0x8000000000000000) != 0) {
      dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, (int)(&__roots)[i][2]);
    }
    *(_DWORD *)((char *)__boot + v9) = -1;
  }
  __boot[0] = a1;
  return __boot;
}

ssize_t boot_dump_spec()
{
  ssize_t result = getpid();
  if (result == 1)
  {
    pid_t v1 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v2, v3, v4, v5, v6, v7, v1);
    pid_t v8 = getpid();
    dlog(-1, "libignition: %d:   %s : %s\n", v9, v10, v11, v12, v13, v14, v8);
    pid_t v15 = getpid();
    return dlog(-1, "libignition: %d:   %s : 0x%llx\n", v16, v17, v18, v19, v20, v21, v15);
  }
  return result;
}

uint64_t boot_boot(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  arguments((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  v29[0] = *a1 + 24;
  v29[1] = 0;
  int v30 = open("/", 537919488);
  if (v30 < 0)
  {
    uint64_t v22 = __boot[0][1];
    uint64_t v23 = __boot[0][2];
    int v24 = *__error();
    __error();
    ignition_halt(v22, v24, (unint64_t)v23, "failed to open root directory: %s: %d", v25, v26, v27, v28, (int)"/");
  }
  boot_set_root((uint64_t)a1, (uint64_t)&_boot_root_fs, &v30, v9, v10, v11, v12, v13);
  uint64_t result = stage_next(v29);
  if (!result)
  {
    LODWORD(result) = -1;
    goto LABEL_10;
  }
  while (1)
  {
    a1[1] = result;
    uint64_t result = stage_fire(result, (uint64_t)a1, v16, v17, v18, v19, v20, v21);
    if (result) {
      break;
    }
    uint64_t result = stage_next(v29);
    if (!result) {
      return result;
    }
  }
  if (result >= 0x6A) {
LABEL_10:
  }
    dyld_halt("error not set to valid posix code: %d", v15, v16, v17, v18, v19, v20, v21, result);
  return result;
}

uint64_t stage_next(void *a1)
{
  unint64_t v1 = a1[1];
  if (v1 >= *(void *)(*a1 + 64)) {
    return 0;
  }
  uint64_t v2 = *(void *)(*a1 + 8 * v1);
  a1[1] = v1 + 1;
  return v2;
}

uint64_t stage_fire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)arguments(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*v10 >= *(void *)(a1 + 40))
  {
    pid_t v19 = getpid();
    dlog(-1, "libignition: %d: %12s: %s\n", v20, v21, v22, v23, v24, v25, v19);
    uint64_t v26 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(a1 + 48))(a1, v10, a2);
    if (v26)
    {
      uint64_t v11 = v26;
      pid_t v27 = getpid();
      dlog(-1, "libignition: %d: %12s: ignition failed: %d\n", v28, v29, v30, v31, v32, v33, v27);
    }
    else
    {
      if ((*(void *)(a1 + 32) & 0x8000000000000000) == 0
        && !(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 56))(a1, a2))
      {
        dyld_halt("stage did not set payload: %s", v43, v44, v45, v46, v47, v48, v49, *(void *)a1);
      }
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = ~(*(uint64_t *)(a1 + 32) >> 63) & 0x59;
    pid_t v12 = getpid();
    dlog(-1, "libignition: %d: %12s: ignition level insufficient: actual = %llu, required >= %llu\n", v13, v14, v15, v16, v17, v18, v12);
  }
  uint64_t v34 = (const char *)v10[3];
  if (v34 && !_platform_strcmp(v34, *(const char **)a1)) {
    dyld_halt("halting after %s ignition stage; if you did not intend to do this, clear the ignition_halt_after boot-arg",
  }
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      *(void *)a1);
  return v11;
}

ssize_t dlog(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return vdlog(a1, a2, &a9, a4, a5, a6, a7, a8);
}

ssize_t vdlog(int a1, char *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!__g) {
    dyld_halt("logging not yet initialized", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
  }
  ssize_t result = getpid();
  if ((int)result <= 1)
  {
    if (a1 < 0)
    {
      a1 = dword_1EB1CFD04;
      if (dword_1EB1CFD04 < 0) {
        a1 = _open_console();
      }
    }
    return _simple_vdprintf(a1, a2, a3);
  }
  return result;
}

pid_t getpid(void)
{
  pid_t result = _current_pid;
  if (_current_pid <= 0) {
    return cerror_nocancel(mac_syscall(SYS_getpid));
  }
  return result;
}

uint64_t arguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _args;
  if (!_args) {
    dyld_halt("arguments not initialized", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return result;
}

size_t arguments_init(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  if (_args) {
    dyld_halt("arguments already initialized", a2, a3, a4, a5, a6, a7, a8, v12[0]);
  }
  if (dyld_parse_boot_arg_int(a1, "ignition_level", (unint64_t *)&v13)) {
    __args = v13;
  }
  if (dyld_parse_boot_arg_cstr(a1, "ignition_force_dylib_root", (char *)v12, 0x40uLL))
  {
    if (_platform_strcmp((const char *)v12, "none"))
    {
      if (_platform_strcmp((const char *)v12, "cryptex"))
      {
        if (_platform_strcmp((const char *)v12, "livefs"))
        {
          if (_platform_strcmp((const char *)v12, "rootfs")) {
            goto LABEL_14;
          }
          uint64_t v9 = 3;
        }
        else
        {
          uint64_t v9 = 2;
        }
      }
      else
      {
        uint64_t v9 = 1;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    qword_1EC3F26B0 = v9;
  }
LABEL_14:
  if (!dyld_parse_boot_arg_cstr(a1, "ignition_live_app_graft", (char *)v12, 0x40uLL)) {
    goto LABEL_22;
  }
  if (_platform_strcmp((const char *)v12, "skip"))
  {
    if (_platform_strcmp((const char *)v12, "optional"))
    {
      if (_platform_strcmp((const char *)v12, "require")) {
        goto LABEL_22;
      }
      uint64_t v10 = 2;
    }
    else
    {
      uint64_t v10 = 1;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  qword_1EC3F26B8 = v10;
LABEL_22:
  size_t result = dyld_parse_boot_arg_cstr(a1, "ignition_halt_after", (char *)v12, 0x40uLL);
  if (result)
  {
    size_t result = strlcpy(byte_1EC3F26C8, (const char *)v12, 0x40uLL);
    qword_1EC3F26C0 = (uint64_t)byte_1EC3F26C8;
  }
  _args = (uint64_t)&__args;
  return result;
}

ssize_t arguments_dump()
{
  ssize_t result = getpid();
  if ((int)result <= 1)
  {
    pid_t v1 = getpid();
    dlog(-1, "libignition: %d: %s   :\n", v2, v3, v4, v5, v6, v7, v1);
    pid_t v8 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v9, v10, v11, v12, v13, v14, v8);
    pid_t v15 = getpid();
    dlog(-1, "libignition: %d:   %s : 0x%llx\n", v16, v17, v18, v19, v20, v21, v15);
    pid_t v22 = getpid();
    return dlog(-1, "libignition: %d:   %s : %s\n", v23, v24, v25, v26, v27, v28, v22);
  }
  return result;
}

uint64_t _open_console()
{
  uint64_t v0 = dword_1EB1CFD00;
  if (dword_1EB1CFD00 < 0 && getpid() == 1)
  {
    uint64_t v0 = open("/dev/console", 131073);
    dword_1EB1CFD00 = v0;
  }
  return v0;
}

uint64_t _hello_fire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  pid_t v8 = getpid();
  getpid();
  dlog(-1, "libignition: %d: %12s: hello from %s.%d\n", v9, v10, v11, v12, v13, v14, v8);
  return 0;
}

uint64_t _graft_select_fire(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v5 = a3[4];
  int dylib_root = boot_get_dylib_root((uint64_t)a3);
  bzero(&v70, 0x400uLL);
  memset(&v69, 0, sizeof(v69));
  if (dylib_root < 0)
  {
    pid_t v30 = getpid();
    dlog(-1, "libignition: %d: %12s: cryptex graft point not present; not using fallback\n",
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v30);
    return 0;
  }
  ignition_get_shared_cache_directory(&v70, v7, v8, v9, v10, v11, v12, v13);
  if (v71[0] == 47) {
    dyld_halt("bogus shared cache path: %s", v14, v15, v16, v17, v18, v19, v20, (int)&v70);
  }
  int v21 = fstatat64(dylib_root, v71, &v69, 0);
  pid_t v22 = __error();
  if (v21 < 0)
  {
    if (!*v22) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v23, v24, v25, v26, v27, v28, v29, (int)"ret");
    }
  }
  else
  {
    int *v22 = 0;
  }
  int v37 = *__error();
  if (v37 != 2)
  {
    if (v37)
    {
      pid_t v45 = getpid();
      __error();
      pid_t v67 = v45;
      uint64_t v44 = "libignition: %d: %12s: failed to stat dylib cache directory: %d\n";
    }
    else
    {
      if ((v69.st_mode & 0xF000) != 0x4000) {
        goto LABEL_14;
      }
      pid_t v67 = getpid();
      uint64_t v44 = "libignition: %d: %12s: dylib cache directory present; not overriding\n";
    }
    int v5 = -1;
    dlog(-1, v44, v38, v39, v40, v41, v42, v43, v67);
  }
LABEL_14:
  switch(*(void *)(a2 + 8))
  {
    case 0:
      pid_t v46 = getpid();
      dlog(-1, "libignition: %d: %12s: not forcing root fallback\n", v47, v48, v49, v50, v51, v52, v46);
      if ((v5 & 0x80000000) == 0) {
        goto LABEL_21;
      }
      return 0;
    case 1:
      int v5 = a3[8];
      if ((v5 & 0x80000000) == 0) {
        goto LABEL_21;
      }
      return 0;
    case 2:
      int v5 = a3[11];
      goto LABEL_20;
    case 3:
      int v5 = a3[4];
      if (v5 < 0) {
        return 0;
      }
      goto LABEL_21;
    default:
LABEL_20:
      if ((v5 & 0x80000000) == 0)
      {
LABEL_21:
        pid_t v53 = getpid();
        dlog(-1, "libignition: %d: %12s: overriding os cryptex root: %s\n", v54, v55, v56, v57, v58, v59, v53);
        int v68 = dupfd(v5, (int)"fallback root");
        boot_set_dylib_root((uint64_t)a3, &v68, v60, v61, v62, v63, v64, v65);
      }
      break;
  }
  return 0;
}

int fstatat64(int a1, const char *a2, stat *a3, int a4)
{
  int64_t v9 = mac_syscall(SYS_fstatat64, *(void **)&a1, (void *)a2, a3, *(void **)&a4, v5, v6, v7, v8);
  if (v4) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

uint64_t _goodbye_fire()
{
  return 0;
}

uint64_t _dylib_cache_payload_check(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(void *)(a1 + 32) & 0x8000000000000000) != 0) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (v8 < 0) {
    dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, *(void *)(a1 + 24));
  }
  return a2 + v8;
}

uint64_t _dylib_cache_fire(uint64_t a1, void *a2, uint64_t a3)
{
  int dylib_root = boot_get_dylib_root(a3);
  bzero(&v73, 0x400uLL);
  if (*a2 < 3uLL || dylib_root < 0)
  {
    int dylib_root = *(_DWORD *)(a3 + 16);
    uint64_t v13 = 19;
  }
  else
  {
    uint64_t v13 = 85;
  }
  ignition_get_shared_cache_directory(&v73, v6, v7, v8, v9, v10, v11, v12);
  if (v74[0] == 47) {
    dyld_halt("bogus shared cache path: %s", v14, v15, v16, v17, v18, v19, v20, (int)&v73);
  }
  pid_t v21 = getpid();
  dlog(-1, "libignition: %d: %12s: finding shared cache on %s: ignition level = %llu, search root fd = %d, subpath = %s\n", v22, v23, v24, v25, v26, v27, v21);
  int v28 = openat(dylib_root, v74, 0x100000);
  int v72 = v28;
  uint64_t v29 = __error();
  if (v28 < 0)
  {
    if (!*v29) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v30, v31, v32, v33, v34, v35, v36, (int)"dycash");
    }
  }
  else
  {
    *uint64_t v29 = 0;
  }
  int v37 = *__error();
  if (v37 == 2)
  {
    pid_t v50 = getpid();
    dlog(-1, "libignition: %d: %12s: shared cache not found: root = %s, path = %s\n", v51, v52, v53, v54, v55, v56, v50);
    goto LABEL_13;
  }
  if (!v37)
  {
    realpathfd(v28, (uint64_t)&v73, (int)"dylib cache path");
    pid_t v38 = getpid();
    dlog(-1, "libignition: %d: %12s: opened shared cache directory: %s\n", v39, v40, v41, v42, v43, v44, v38);
    boot_set_root(a3, (uint64_t)&_boot_root_dylib_cache, &v72, v45, v46, v47, v48, v49);
    uint64_t v13 = 0;
LABEL_13:
    closefd_optional(&v72, (int)"shared cache directory");
    return v13;
  }
  uint64_t v13 = *__error();
  pid_t v57 = getpid();
  dlog(-1, "libignition: %d: %12s: failed to open shared cache: %s: %d\n", v58, v59, v60, v61, v62, v63, v57);
  closefd_optional(&v72, (int)"shared cache directory");
  if (v13 >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v64, v65, v66, v67, v68, v69, v70, v13);
  }
  return v13;
}

int openat(int a1, const char *a2, int a3, ...)
{
  va_start(va, a3);
  uint64_t v9 = va_arg(va, void);
  if ((a3 & 0x200) != 0) {
    unsigned __int16 v7 = v9;
  }
  else {
    unsigned __int16 v7 = 0;
  }
  return __openat(a1, (char *)a2, *(void **)&a3, (void *)v7, v3, v4, v5, v6);
}

int __openat(int a1, char *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_openat, a1, a2, (int)a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

char *ignition_get_shared_cache_directory(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(*(void *)configuration((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8) + 36) == 10) {
    uint64_t v9 = "/System/DriverKit/System/Library/dyld/";
  }
  else {
    uint64_t v9 = "/System/Library/Caches/com.apple.dyld/";
  }
  strlcpy(a1, v9, 0x400uLL);
  return a1;
}

uint64_t configuration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _config;
  if (!_config) {
    dyld_halt("configuration not initialized", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return result;
}

uint64_t boot_get_dylib_root(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t realpathfd(int a1, uint64_t a2, int a3)
{
  if (fcntl(a1, 50, a2) == -1)
  {
    uint64_t v6 = boot_get();
    unsigned __int16 v7 = (*v6)[1];
    unint64_t v8 = (unint64_t)(*v6)[2];
    int v9 = *__error();
    __error();
    ignition_halt(v7, v9, v8, "failed to realpath %s: %d: %d", v10, v11, v12, v13, a3);
  }
  return a2;
}

char *_derive_proc_name(uint64_t a1, char *a2)
{
  char v4 = _simple_getenv(*(const char ***)(a1 + 24), "executable_path");
  if (v4)
  {
    int v5 = (char *)v4;
LABEL_5:
    uint64_t v6 = strrchr(v5, 47);
    goto LABEL_6;
  }
  if (*(_DWORD *)(a1 + 4))
  {
    int v5 = **(char ***)(a1 + 8);
    goto LABEL_5;
  }
  uint64_t v6 = 0;
  int v5 = "unknown proc";
LABEL_6:
  if (v6) {
    unsigned __int16 v7 = v6 + 1;
  }
  else {
    unsigned __int16 v7 = v5;
  }
  strlcpy(a2, v7, 0xFFuLL);
  return a2;
}

void dyld4::CacheFinder::~CacheFinder(dyld4::SyscallDelegate **this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned char *)this + 48))
  {
    unint64_t v8 = (int *)(this + 2);
    jettison(&v8, a2, a3, a4, a5, a6, a7, a8);
  }
  else if (*(_DWORD *)this != -1)
  {
    dyld4::SyscallDelegate::close(this[1], *(_DWORD *)this);
  }
}

int **jettison(int **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *result;
  if (*result)
  {
    int v9 = result;
    switch(*v8)
    {
      case 0:
        goto LABEL_7;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_5;
      case 3:
        goto LABEL_4;
      case 4:
        closefd_optional(v8 + 7, (int)"prereboot os graft point");
LABEL_4:
        closefd_optional(v8 + 6, (int)"group dir");
LABEL_5:
        closefd_optional(v8 + 4, (int)"os graft point");
        closefd_optional(v8 + 5, (int)"app graft point");
LABEL_6:
        closefd_optional(v8 + 3, (int)"xART");
LABEL_7:
        closefd_optional(v8 + 1, (int)"preboot");
        uint64_t result = (int **)closefd(v8 + 2, (int)"shared cache");
        const char *v9 = 0;
        break;
      default:
        dyld_halt("unsupported payload version: 0x%x", a2, a3, a4, a5, a6, a7, a8, *v8);
    }
  }
  return result;
}

uint64_t closefd(int *a1, int a2)
{
  uint64_t result = close(*a1);
  if (result)
  {
    int v5 = boot_get();
    uint64_t v6 = (*v5)[1];
    unint64_t v7 = (unint64_t)(*v5)[2];
    int v8 = *__error();
    __error();
    ignition_halt(v6, v8, v7, "failed to close %s: fd = %d: %d", v9, v10, v11, v12, a2);
  }
  *a1 = -1;
  return result;
}

void *boot_destroy(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *result;
  if (*result)
  {
    uint64_t v9 = result;
    for (uint64_t i = 0; i != 9; ++i)
    {
      uint64_t v11 = (&__roots)[i];
      unint64_t v12 = (unint64_t)v11[2];
      if ((v12 & 0x8000000000000000) != 0) {
        dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, (int)v11[2]);
      }
      closefd_optional((int *)(v8 + v12), (int)*v11);
    }
    uint64_t result = (void *)ignition_test_BRA(4);
    void *v9 = 0;
  }
  return result;
}

int *closefd_optional(int *result, int a2)
{
  if ((*result & 0x80000000) == 0)
  {
    uint64_t v3 = result;
    uint64_t result = (int *)close(*result);
    if (result)
    {
      char v4 = boot_get();
      int v5 = (*v4)[1];
      unint64_t v6 = (unint64_t)(*v4)[2];
      int v7 = *__error();
      __error();
      ignition_halt(v5, v7, v6, "failed to close %s [optional]: fd = %d: %d", v8, v9, v10, v11, a2);
    }
    _DWORD *v3 = -1;
  }
  return result;
}

int close(int a1)
{
  LODWORD(v9) = mac_syscall(SYS_close, a1);
  if (v1) {
    LODWORD(v9) = cerror(v9, v2, v3, v4, v5, v6, v7, v8);
  }
  return v9;
}

void dyld_halt(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  vm_address_t v10 = _simple_salloc();
  if (v10)
  {
    unint64_t v12 = (unsigned char **)v10;
    _simple_vsprintf(v10, a1, &a9);
    uint64_t v11 = (const char *)_simple_string(v12);
  }
  else
  {
    uint64_t v11 = "panic: [failed to allocate panic message]";
  }
  if (getpid() == 1) {
    syscall(55, 3072, v11);
  }
  qword_1EC3F2750 = (uint64_t)v11;
  __break(1u);
}

double lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert@<D0>(uint64_t a1@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v19 = *a2;
  lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::const_iterator((uint64_t)v20, a1, (uint64_t)&v19);
  lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::insert_internal(a1, (uint64_t)v20, &v19, (uint64_t)&v8);
  uint64_t v5 = v8;
  *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = v11;
  *(_OWORD *)(a3 + 56) = v12;
  *(_OWORD *)(a3 + 72) = v13;
  *(_OWORD *)(a3 + 88) = v14;
  *(_OWORD *)(a3 + 8) = v9;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10;
  *(void *)(a3 + 104) = v15;
  *(_DWORD *)(a3 + 112) = v16;
  char v7 = v17;
  *(void *)a3 = v5;
  *(unsigned char *)(a3 + 116) = v7;
  *(unsigned char *)(a3 + 12dyld4::halt((char *)__format, 0) = v18;
  return result;
}

void lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::insert_internal(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v22 = a1;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    memset(v28, 0, sizeof(v28));
    if (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>(a2, (uint64_t)&v22))
    {
      uint64_t v8 = 0;
      uint64_t v9 = *(unsigned __int8 *)(a2 + 116);
      while (1)
      {
        unsigned int v10 = a3->n128_u8[v8];
        unsigned int v11 = *(unsigned __int8 *)(*(void *)(a2 + 8 + 8 * (v9 - 1))
                                 + 16 * *(unsigned __int8 *)(a2 + 104 + v9 - 1)
                                 + v8);
        if (v10 < v11) {
          break;
        }
        if (v11 < v10 || v8++ == 15)
        {
          char v13 = 0;
          long long v14 = *(_OWORD *)(a2 + 56);
          *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
          *(_OWORD *)(a4 + 56) = v14;
          long long v15 = *(_OWORD *)(a2 + 88);
          *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
          *(_OWORD *)(a4 + 88) = v15;
          long long v16 = *(_OWORD *)(a2 + 24);
          *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
          *(void *)a4 = *(void *)a2;
          *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16;
          *(void *)(a4 + 104) = *(void *)(a2 + 104);
          *(_DWORD *)(a4 + 112) = *(_DWORD *)(a2 + 112);
          *(unsigned char *)(a4 + 116) = v9;
          goto LABEL_17;
        }
      }
    }
    uint64_t v22 = a1;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    memset(v28, 0, sizeof(v28));
    if (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>(a2, (uint64_t)&v22)&& *(unsigned __int8 *)(a2 + 116) == *(unsigned __int8 *)(a1 + 32))
    {
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      uint64_t v17 = a2 + 104;
      uint64_t v18 = *(unsigned __int8 *)(a2 + 116) - 1;
      unsigned __int8 v19 = *(unsigned char *)(a2 + 104 + v18);
    }
    else
    {
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator--((uint64_t **)a2);
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      uint64_t v17 = a2 + 104;
      uint64_t v21 = *(unsigned __int8 *)(a2 + 116) + a2 + 104;
      unsigned __int8 v19 = *(unsigned char *)(v21 - 1) + 1;
      *(unsigned char *)(v21 - 1) = v19;
      uint64_t v18 = *(unsigned __int8 *)(a2 + 116) - 1;
    }
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert(*(void *)(a2 + 8 + 8 * v18), v19, a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a4 + 104) = *(void *)v17;
    *(_DWORD *)(a4 + 112) = *(_DWORD *)(v17 + 8);
    *(unsigned char *)(a4 + 116) = *(unsigned char *)(a2 + 116);
    char v13 = 1;
  }
  else
  {
    uint64_t v20 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((unsigned char *)v20 + 248) = 0x80;
    *(_OWORD *)uint64_t v20 = 0u;
    *((_OWORD *)v20 + 1) = 0u;
    *((_OWORD *)v20 + 2) = 0u;
    *((_OWORD *)v20 + 3) = 0u;
    *((_OWORD *)v20 + 4) = 0u;
    *((_OWORD *)v20 + 5) = 0u;
    *((_OWORD *)v20 + 6) = 0u;
    *((_OWORD *)v20 + 7) = 0u;
    *((_OWORD *)v20 + 8) = 0u;
    *((_OWORD *)v20 + 9) = 0u;
    *((_OWORD *)v20 + 1dyld4::halt((char *)__format, 0) = 0u;
    *((_OWORD *)v20 + 11) = 0u;
    *((_OWORD *)v20 + 12) = 0u;
    *((_OWORD *)v20 + 13) = 0u;
    *((_OWORD *)v20 + 14) = 0u;
    *(void *)a1 = v20;
    char v13 = 1;
    *(unsigned char *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v20;
    *(unsigned char *)(a2 + 116) = 1;
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert((uint64_t)v20, 0, a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a4 + 104) = *(void *)(a2 + 104);
    *(_DWORD *)(a4 + 112) = *(_DWORD *)(a2 + 112);
    *(unsigned char *)(a4 + 116) = *(unsigned char *)(a2 + 116);
  }
LABEL_17:
  *(unsigned char *)(a4 + 12dyld4::halt((char *)__format, 0) = v13;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::const_iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 101) = 0u;
  if (*(unsigned char *)(a2 + 32))
  {
    uint64_t v7 = 0;
    uint64_t v8 = *(void *)a2;
    uint64_t v9 = a1 + 104;
    while (1)
    {
      *(void *)(v4 + 8 * v7) = v8;
      unsigned int v10 = lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::lower_bound_index(v8, a3);
      *(unsigned char *)(v9 + v7) = v10;
      uint64_t v11 = *(void *)(v4 + 8 * v7);
      int v12 = *(char *)(v11 + 248);
      if (v10 != (v12 & 0x7F)) {
        break;
      }
LABEL_11:
      unint64_t v17 = *(unsigned __int8 *)(a2 + 32);
      if (v7 + 1 != v17)
      {
        if (v12 < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v8 = *(void *)(v11 + 8 * v10 + 160);
      }
      if (++v7 >= v17)
      {
        for (*(unsigned char *)(a1 + 116) = v17; (_BYTE)v17; *(unsigned char *)(a1 + 116) = v17)
        {
          if (*(unsigned char *)(v9 + v17 - 1) != (*(unsigned char *)(*(void *)(v4
                                                                                                + 8
                                                                                                * v17
                                                                                                - 8)
                                                                                    + 248) & 0x7F))
            break;
          LOBYTE(v17) = v17 - 1;
        }
        return a1;
      }
    }
    uint64_t v13 = 0;
    while (1)
    {
      unsigned int v14 = *(unsigned __int8 *)(v11 + 16 * v10 + v13);
      unsigned int v15 = *(unsigned __int8 *)(a3 + v13);
      if (v14 < v15) {
        break;
      }
      if (v15 < v14 || v13++ == 15) {
        goto LABEL_11;
      }
    }
    *(unsigned char *)(a1 + 116) = v7 + 1;
  }
  return a1;
}

__n128 lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert(uint64_t a1, unsigned int a2, __n128 *a3)
{
  int v3 = *(char *)(a1 + 248);
  int v4 = v3 & 0x7F;
  if (v3 >= 0) {
    int v5 = 10;
  }
  else {
    int v5 = 15;
  }
  if (v4 == v5) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if (v5 == a2) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  uint64_t v8 = (__n128 *)(a1 + 16 * a2);
  if (v4 != a2)
  {
    memmove((void *)(a1 + 16 * a2 + 16), (const void *)(a1 + 16 * a2), 16 * (v3 & 0x7F) - 16 * a2);
    LOBYTE(v3) = *(unsigned char *)(a1 + 248);
  }
  *(unsigned char *)(a1 + 248) = v3 + 1;
  __n128 result = *a3;
  *uint64_t v8 = *a3;
  return result;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::lower_bound_index(uint64_t a1, uint64_t a2)
{
  LODWORD(v2) = a1;
  unint64_t v3 = *(unsigned char *)(a1 + 248) & 0x7F;
  if ((*(unsigned char *)(a1 + 248) & 0x7F) != 0)
  {
    uint64_t v2 = a1;
    do
    {
      uint64_t v4 = 0;
      unint64_t v5 = v3 >> 1;
      uint64_t v6 = v2 + 16 * (v3 >> 1);
      while (1)
      {
        unsigned int v7 = *(unsigned __int8 *)(v6 + v4);
        unsigned int v8 = *(unsigned __int8 *)(a2 + v4);
        if (v7 < v8) {
          break;
        }
        if (v8 < v7 || v4++ == 15) {
          goto LABEL_12;
        }
      }
      uint64_t v2 = v6 + 16;
      unint64_t v5 = v3 + ~v5;
LABEL_12:
      unint64_t v3 = v5;
    }
    while (v5);
  }
  return ((v2 - a1) >> 4);
}

void start(dyld4::KernelArgs *a1, unsigned int *a2, DyldSharedCache *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  unsigned int v10 = a1;
  uint64_t v89 = a1;
  dyld3::kdebug_trace_dyld_marker((void *)0x1F070034, 0, 0, 0, 0, 0, 0, a8, 0, 0);
  pid_t v88 = (dyld3::MachOFile *)&dword_1A8DFD000;
  if ((dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_1A8DFD000) & 1) == 0)
  {
    if ((dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)&dword_1A8DFD000) & 1) == 0) {
      goto LABEL_112;
    }
    __darwin_time_t Slide = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)&dword_1A8DFD000);
    uint64_t v99 = 0;
    uint64_t v100 = &v99;
    uint64_t v101 = 0x3002000000;
    pid_t v102 = __Block_byref_object_copy_;
    uint64_t v103 = __Block_byref_object_dispose_;
    Diagnostics::Diagnostics((Diagnostics *)&v104);
    *(void *)&v106.fsobj_id st_dev = _NSConcreteStackBlock;
    v106.__darwin_ino64_t st_ino = 0x40000000;
    *(void *)&v106.st_uid = ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke;
    *(void *)&v106.st_rdev = &unk_1EFF636A0;
    v106.st_atimespec.__darwin_time_t tv_sec = (__darwin_time_t)&v99;
    v106.st_atimespec.tv_nsec = (uint64_t)&dword_1A8DFD000;
    v106.st_mtimespec.__darwin_time_t tv_sec = Slide;
    dyld3::MachOAnalyzer::withChainStarts((dyld3::MachOFile *)&dword_1A8DFD000, (vm_address_t *)v100 + 5, 0, (uint64_t)&v106);
    Diagnostics::assertNoError((Diagnostics *)(v100 + 5));
    uint64_t v92 = (DyldSharedCache *)_NSConcreteStackBlock;
    uint64_t v93 = 0x40000000;
    uint64_t v94 = ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke_2;
    pid_t v95 = &__block_descriptor_tmp_4;
    uint64_t v96 = (lsl::Lock **)Slide;
    dyld3::MachOFile::forEachSegment(&dword_1A8DFD000, (uint64_t)&v92);
    _Block_object_dispose(&v99, 8);
    mach_o::Error::~Error((vm_address_t **)&v104);
    a3 = 0;
    a2 = 0;
    unsigned int v10 = v89;
  }
  mach_init();
  Envp = (const char **)dyld4::KernelArgs::findEnvp(v10);
  Apple = (const char **)dyld4::KernelArgs::findApple(v10);
  unsigned int v14 = _simple_getenv(Apple, "vm_force_4k_pages");
  if (v14 && *v14 == 49) {
    vm_page_vm_size_t size = 4096;
  }
  lsl::MemoryManager::MemoryManager((lsl::MemoryManager *)&v106, Envp, Apple, a3);
  unsigned int v15 = 0;
  uint64_t v92 = (DyldSharedCache *)&v106;
  unint64_t v91 = 0;
  if (&v85 != (const void **)-232) {
    unsigned int v15 = &v106;
  }
  if (LOBYTE(v15->st_atimespec.tv_sec))
  {
    if (!MEMORY[0xFFFFFC10C]
      || (MEMORY[0xFFFFFC10C] & 0xFE) != 2
      || (unint64_t v91 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1) == 0
      && (!MEMORY[0xFFFFFC10C]
       || (MEMORY[0xFFFFFC10C] & 0xFE) != 2
       || (_WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]),
           __isb(0xFu),
           uint64_t v18 = MEMORY[0xFFFFFC0D0],
           v18 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)))))
    {
LABEL_111:
      __break(1u);
LABEL_112:
      __assert_rtn("rebaseSelf", "dyldMain.cpp", 1116, "dyldMA->hasChainedFixups()");
    }
  }
  else
  {
    unint64_t v91 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v15, &v99);
    uint64_t v16 = *(void *)&v15->st_rdev;
    if (!v16)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v15, 0);
      uint64_t v16 = *(void *)&v15->st_rdev;
    }
    *(void *)&v15->st_rdev = v16 + 1;
    lsl::Lock::unlock(v99);
  }
  __guard_setup(Apple);
  if (v92) {
    unint64_t v17 = v92;
  }
  else {
    unint64_t v17 = 0;
  }
  if (!*((unsigned char *)v17 + 32))
  {
    lsl::MemoryManager::lockGuard(v17, &v99);
    if (v91 == 1)
    {
      uint64_t v22 = *((void *)v17 + 3) - 1;
      *((void *)v17 + 3) = v22;
      if (!v22) {
        lsl::MemoryManager::writeProtect(v17, 1);
      }
    }
    else if (v91 == 0xFFFFFFFF)
    {
      uint64_t v19 = *((void *)v17 + 3);
      if (!v19)
      {
        lsl::MemoryManager::writeProtect(v17, 0);
        uint64_t v19 = *((void *)v17 + 3);
      }
      *((void *)v17 + 3) = v19 + 1;
    }
    lsl::Lock::unlock(v99);
    goto LABEL_36;
  }
  uint64_t v20 = 0xFFFFFC10CLL;
  if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
  {
    unint64_t v21 = v91;
    if (v91 != ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      goto LABEL_94;
    }
    while (1)
    {
LABEL_36:
      _subsystem_init(Apple);
      long long v23 = (unsigned int *)v88;
      long long v24 = v89;
      if (dyld3::MachOFile::inDyldCache(v88))
      {
        mach_port_mod_refs(mach_task_self_, mach_task_self_, 0, -1);
        char v26 = dyld4::ExternallyViewableState::switchToDyldInDyldCache((dyld4::ExternallyViewableState *)v23, v25);
        if (kdebug_is_enabled(0x1F050014u, v27, v28, v29, v30, v31, v32, v33))
        {
          uint64_t v99 = 0;
          uint64_t v100 = 0;
          dyld3::MachOFile::getUuid((dyld3::MachOFile *)v23, (unsigned __int8 *)&v99);
          int v42 = dyld3::stat((dyld3 *)"/usr/lib/dyld", &v106, v41);
          if (v42) {
            __darwin_ino64_t st_ino = 0;
          }
          else {
            __darwin_ino64_t st_ino = (unsigned __int8 (*)[16])v106.st_ino;
          }
          if (v42) {
            fsobj_id st_dev = 0;
          }
          else {
            fsobj_id st_dev = (fsobj_id)v106.st_dev;
          }
          fsid v46 = (fsid)a2;
          dyld3::kdebug_trace_dyld_image((dyld3 *)5, "/usr/lib/dyld", (void **)&v99, st_ino, st_dev, v46, (const void *)a2[2], v43, v85);
        }
        if (kdebug_is_enabled(0x1F050000u, v34, v35, v36, v37, v38, v39, v40))
        {
          *(void *)&v106.fsobj_id st_dev = 0;
          v106.__darwin_ino64_t st_ino = 0;
          dyld3::MachOFile::getUuid((dyld3::MachOFile *)v23, (unsigned __int8 *)&v106);
          fsobj_id v47 = 0;
          fsid v48 = (fsid)v23;
          dyld3::kdebug_trace_dyld_image(0, "/usr/lib/dyld", (void **)&v106, 0, v47, v48, (const void *)v23[2], v49, v85);
        }
        uint64_t v99 = 0;
        uint64_t v100 = &v99;
        uint64_t v101 = 0x4002000000;
        pid_t v102 = __Block_byref_object_copy__7;
        uint64_t v103 = (void (*)(uint64_t))__Block_byref_object_dispose__8;
        uint64_t v104 = &v106;
        long long v105 = xmmword_1A8E6FCF0;
        uint64_t v50 = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)a2);
        uint64_t v92 = (DyldSharedCache *)_NSConcreteStackBlock;
        uint64_t v93 = 0x40000000;
        uint64_t v94 = ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke;
        pid_t v95 = &unk_1EFF636E8;
        char v98 = v26;
        uint64_t v96 = &v99;
        uint64_t v97 = v50;
        dyld3::MachOFile::forEachSegment(a2, (uint64_t)&v92);
        uint64_t v51 = v100[7];
        if (v51)
        {
          uint64_t v52 = v100[5];
          uint64_t v53 = (lsl::Lock *)((char *)v52 + 16 * (void)v51);
          do
          {
            uint64_t v54 = *(void **)v52;
            size_t v55 = *((void *)v52 + 1);
            uint64_t v52 = (lsl::Lock *)((char *)v52 + 16);
            munmap(v54, v55);
          }
          while (v52 != v53);
        }
        _Block_object_dispose(&v99, 8);
      }
      else
      {
        uint64_t v56 = (const char **)dyld4::KernelArgs::findEnvp(v24);
        if (!_simple_getenv(v56, "DYLD_SHARED_REGION"))
        {
          *(void *)&v106.fsobj_id st_dev = 0;
          v106.__darwin_ino64_t st_ino = 0;
          if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)v23, (unsigned __int8 *)&v106))
          {
            unint64_t v91 = 0;
            uint64_t v92 = 0;
            unint64_t v90 = 0;
            if (dyld4::SyscallDelegate::hasExistingDyldCache((dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate, (unint64_t *)&v92, &v91, &v90))
            {
              pid_t v57 = v92;
              uint64_t v58 = DyldSharedCache::slide(v92);
              uint64_t v59 = *((void *)v57 + 15);
              if (v59)
              {
                uint64_t v60 = v58;
                uint64_t v61 = v59 + v58;
                uint64_t v99 = 0;
                uint64_t v100 = 0;
                if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)(v59 + v58), (unsigned __int8 *)&v99)
                  && *(lsl::Lock **)&v106.st_dev == v99
                  && v106.st_ino == (void)v100)
                {
                  uint64_t v63 = (const char **)dyld4::KernelArgs::findEnvp(v24);
                  uint64_t v64 = _simple_getenv(v63, "DYLD_IN_CACHE");
                  if (!v64 || _platform_strcmp(v64, "0"))
                  {
                    dyld4::ExternallyViewableState::switchDyldLoadAddress(v61, v65);
                    fsobj_id v66 = (fsobj_id)v91;
                    dyld3::kdebug_trace_dyld_cache((unsigned __int8 (*)[16])v90, v66, v92, (char *)v57 + 88, v67, v68, v69, v70);
                    dyld4::restartWithDyldInCache(v24, (const dyld4::KernelArgs *)v23, v57, (const DyldSharedCache *)(*((void *)v57 + 16) + v60), v71);
                  }
                }
              }
            }
          }
        }
      }
      dyld4::RuntimeLocks::RuntimeLocks((dyld4::RuntimeLocks *)&v106);
      int v72 = (const char **)dyld4::KernelArgs::findEnvp(v89);
      char v73 = (const char **)dyld4::KernelArgs::findApple(v89);
      Apple = (const char **)&dyld4::preallocator;
      lsl::PreallocatedAllocatorLayout<278528ull>::init((lsl::AllocatorLayout *)&dyld4::preallocator, v72, v73, a3);
      a2 = (unsigned int *)lsl::AllocatorLayout::allocator((lsl::AllocatorLayout *)&dyld4::preallocator);
      unint64_t v90 = 0;
      uint64_t v87 = 0;
      pid_t v74 = (DyldSharedCache *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)a2);
      uint64_t v75 = 0;
      v86[0] = a2;
      v86[1] = &v89;
      unsigned int v86[2] = &v90;
      v86[3] = &v106;
      v86[4] = &v88;
      v86[5] = &v87;
      uint64_t v92 = v74;
      unint64_t v91 = 0;
      if (v74) {
        uint64_t v75 = v74;
      }
      if (*((unsigned char *)v75 + 32))
      {
        if (!MEMORY[0xFFFFFC10C]) {
          goto LABEL_111;
        }
        if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_111;
        }
        unint64_t v91 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
        if (!v91)
        {
          if (!MEMORY[0xFFFFFC10C]) {
            goto LABEL_111;
          }
          if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_111;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
          __isb(0xFu);
          uint64_t v77 = MEMORY[0xFFFFFC0D0];
          if (v77 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
            goto LABEL_111;
          }
        }
      }
      else
      {
        unint64_t v91 = 1;
        lsl::MemoryManager::lockGuard(v75, &v99);
        uint64_t v76 = *((void *)v75 + 3);
        if (!v76)
        {
          lsl::MemoryManager::writeProtect(v75, 0);
          uint64_t v76 = *((void *)v75 + 3);
        }
        *((void *)v75 + 3) = v76 + 1;
        lsl::Lock::unlock(v99);
      }
      dyld4::start(dyld4::KernelArgs *,void *,void *)::$_0::operator()((uint64_t)v86);
      if (v92) {
        a3 = v92;
      }
      else {
        a3 = 0;
      }
      if (*((unsigned char *)a3 + 32))
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_111;
        }
        if (v91 != ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1))
        {
          if (v91 == 1)
          {
            if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
              goto LABEL_111;
            }
            _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
            __isb(0xFu);
            uint64_t v83 = MEMORY[0xFFFFFC0D0];
            unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
          }
          else
          {
            if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
              goto LABEL_111;
            }
            _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
            __isb(0xFu);
            uint64_t v83 = MEMORY[0xFFFFFC0D8];
            unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
          }
          if (v83 != StatusReg) {
            goto LABEL_111;
          }
        }
      }
      else
      {
        lsl::MemoryManager::lockGuard(a3, &v99);
        if (v91 == 1)
        {
          uint64_t v79 = *((void *)a3 + 3) - 1;
          *((void *)a3 + 3) = v79;
          if (!v79) {
            lsl::MemoryManager::writeProtect(a3, 1);
          }
        }
        else if (v91 == 0xFFFFFFFF)
        {
          uint64_t v78 = *((void *)a3 + 3);
          if (!v78)
          {
            lsl::MemoryManager::writeProtect(a3, 0);
            uint64_t v78 = *((void *)a3 + 3);
          }
          *((void *)a3 + 3) = v78 + 1;
        }
        lsl::Lock::unlock(v99);
      }
      uint64_t v80 = v87(*(unsigned int *)(*(void *)(v90 + 8) + 104), *(void *)(*(void *)(v90 + 8) + 112), *(void *)(*(void *)(v90 + 8) + 120), *(void *)(*(void *)(v90 + 8) + 128));
      (*(void (**)(void, uint64_t))(**(void **)(v90 + 152) + 120))(*(void *)(v90 + 152), v80);
LABEL_94:
      if (v21 == 1)
      {
        if (!*(unsigned char *)v20 || (*(unsigned char *)v20 & 0xFE) != 2) {
          goto LABEL_111;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v81 = MEMORY[0xFFFFFC0D0];
        unint64_t v82 = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!*(unsigned char *)v20 || (*(unsigned char *)v20 & 0xFE) != 2) {
          goto LABEL_111;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v81 = MEMORY[0xFFFFFC0D8];
        unint64_t v82 = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v81 != v82) {
        goto LABEL_111;
      }
    }
  }
  goto LABEL_111;
}

int __munmap(void *a1, size_t a2)
{
  int result = mac_syscall(SYS_munmap, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

void *dyld4::KernelArgs::findApple(dyld4::KernelArgs *this)
{
  int result = (void *)((char *)this + 8 * *((void *)this + 1) + 24);
  while (*result++)
    ;
  return result;
}

uint64_t dyld4::KernelArgs::findEnvp(dyld4::KernelArgs *this)
{
  return (uint64_t)this + 8 * *((void *)this + 1) + 24;
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  mach_msg_header_t v13;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_right_t v16;
  mach_port_delta_t v17;

  unsigned int v8 = _kernelrpc_mach_port_mod_refs_trap(task, name, right, delta);
  if (v8 == 268435459)
  {
    unsigned int v14 = 0x100000000;
    unsigned int v15 = name;
    uint64_t v16 = right;
    unint64_t v17 = delta;
    reply_port = mig_get_reply_port();
    *(void *)&v13.msgh_bits = 0x2C00001513;
    *(void *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v13.msgh_voucher_port = 0xC8800000000;
    unsigned int v10 = mach_msg2_internal(&v13, 0x200000003uLL, (void *)0x2C00001513, (void *)__PAIR64__(reply_port, task), (void *)0xC8800000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    unsigned int v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (v10)
      {
        mig_dealloc_reply_port(v13.msgh_local_port);
        return v8;
      }
      if (v13.msgh_id == 71)
      {
        unsigned int v8 = -308;
      }
      else if (v13.msgh_id == 3308)
      {
        unsigned int v8 = -300;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(void *)&v13.msgh_size == 36)
        {
          unsigned int v8 = v15;
          if (!v15) {
            return v8;
          }
        }
      }
      else
      {
        unsigned int v8 = -301;
      }
      mach_msg_destroy(&v13);
    }
  }
  return v8;
}

uint64_t mach_init()
{
  if ((mach_init_mach_init_inited & 1) == 0)
  {
    mach_task_self_ = task_self_trap();
    _task_reply_port = mach_reply_port();
    if (!vm_kernel_page_shift) {
      vm_kernel_page_shift = MEMORY[0xFFFFF4037];
    }
    if (!vm_page_shift)
    {
      vm_page_shift = MEMORY[0xFFFFF4025];
      vm_page_vm_size_t size = 1 << MEMORY[0xFFFFF4025];
      vm_page_masunint64_t k = vm_page_size - 1;
    }
    _pthread_set_self(0, v0, v1, v2, v3, v4, v5, v6);
    mach_init_mach_init_inited = 1;
  }
  return 0;
}

int64_t _thread_set_tsd_base(void *a1)
{
  return mac_syscall(MACHDEP_SYSCALL_TRAP, 2, a1);
}

const char *_subsystem_init(const char **a1)
{
  int result = _simple_getenv(a1, "subsystem_root_path");
  if (result) {
    subsystem_root_path = (uint64_t)result;
  }
  return result;
}

uint64_t _pthread_set_self_dyld(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = __thread_selfid(a1, a2, a3, a4, a5, a6, a7, a8);
  qword_1EB1D1A58 = result;
  if (result == -1)
  {
    qword_1EC3F2750 = (uint64_t)"BUG IN LIBPTHREAD: failed to set thread_id";
    __break(1u);
  }
  else
  {
    qword_1EB1D1A60 = (uint64_t)&_main_thread;
    unk_1EB1D1A68 = &unk_1EB1D1A2C;
    return _thread_set_tsd_base(&qword_1EB1D1A60);
  }
  return result;
}

uint64_t _pthread_set_self(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (a1)
  {
    uint64_t result = __thread_selfid(a1, a2, a3, a4, a5, a6, a7, a8);
    a1[27] = result;
    if (result == -1)
    {
      qword_1EC3F2750 = (uint64_t)"BUG IN LIBPTHREAD: failed to set thread_id";
      __break(1u);
    }
    else
    {
      return _thread_set_tsd_base(a1 + 28);
    }
  }
  else
  {
    return _pthread_set_self_dyld(0, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

int64_t __thread_selfid(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int64_t result = mac_syscall(SYS_thread_selfid, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t __guard_setup(void *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    char v2 = a1;
    uint64_t v3 = __stack_chk_guard;
    while (1)
    {
      uint64_t result = _platform_strncmp((const char *)v1, "stack_guard=", 0xCuLL);
      if (!result)
      {
        char v5 = *(unsigned char *)(v1 + 12);
        if (v5)
        {
          uint64_t v6 = (unsigned __int8 *)(v1 + 13);
          do
          {
            int v7 = v5;
            unsigned int v8 = (v5 - 97);
            unsigned int v9 = v7 - 48;
            if ((v7 - 48) >= 0xA) {
              unsigned int v9 = 0;
            }
            if ((v7 - 65) <= 5) {
              unsigned int v10 = v7 - 55;
            }
            else {
              unsigned int v10 = v9;
            }
            unsigned int v11 = v7 - 87;
            if (v8 <= 5) {
              uint64_t v12 = v11;
            }
            else {
              uint64_t v12 = v10;
            }
            uint64_t v3 = v12 | (16 * v3);
            __stack_chk_guard = v3;
            int v13 = *v6++;
            char v5 = v13;
          }
          while (v13);
        }
        if (v3) {
          break;
        }
      }
      uint64_t v14 = v2[1];
      ++v2;
      uint64_t v1 = v14;
      if (!v14) {
        goto LABEL_17;
      }
    }
  }
  else
  {
LABEL_17:
    uint64_t v15 = arc4random();
    uint64_t result = arc4random();
    __stack_chk_guard = result | (unint64_t)(v15 << 32);
  }
  return result;
}

void dyld4::start(dyld4::KernelArgs *,void *,void *)::$_0::operator()(uint64_t a1)
{
  char v2 = (lsl::AllocatorLayout *)lsl::Allocator::setBestFit(*(void *)a1, 1);
  uint64_t v3 = lsl::AllocatorLayout::minSize(v2);
  __chkstk_darwin(v3, v3 + 0x10000, v4, v5, v6, v7, v8, v9, v28);
  unsigned int v11 = (lsl::Allocator *)((char *)&v28 - v10);
  bzero((char *)&v28 - v10, v12);
  uint64_t v14 = lsl::AllocatorLayout::minSize(v13);
  uint64_t v15 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal(v11, (char *)(v14 + 0x10000));
  uint64_t v16 = (dyld4::ProcessConfig *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)a1, 8uLL, 0x220uLL);
  dyld4::ProcessConfig::ProcessConfig(v16, **(const dyld4::KernelArgs ***)(a1 + 8), (dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate, *(lsl::Allocator **)a1);
  unint64_t v17 = (dyld4::RuntimeState *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)a1, 8uLL, 0x480uLL);
  uint64_t v18 = dyld4::RuntimeState::RuntimeState(v17, v16, *(dyld4::RuntimeLocks **)(a1 + 24), *(lsl::Allocator **)a1);
  *(void *)uint64_t v18 = &unk_1EFF62700;
  **(void **)(a1 + 16) = v18;
  uint64_t v19 = lsl::Allocator::Pool::allocator(*(lsl::Allocator::Pool **)a1);
  lsl::MemoryManager::setDyldCacheAddr(v19, *(void **)(*(void *)(**(void **)(a1 + 16) + 8) + 240));
  dyld4::ExternallyViewableState::init((uint64_t *)(**(void **)(a1 + 16) + 536), *(lsl::Lock ***)(**(void **)(a1 + 16) + 16), v15, (dyld4::FileManager *)(**(void **)(a1 + 16) + 512), *(_DWORD *)(*(void *)(**(void **)(a1 + 16) + 8) + 68));
  uint64_t v20 = **(void **)(a1 + 16);
  uint64_t v21 = **(void **)(a1 + 32);
  uint64_t v22 = *(void *)(v20 + 8);
  uint64_t v23 = *(void *)(v22 + 240);
  if (v23)
  {
    uint64_t v24 = *(void *)(v22 + 264);
    long long v28 = *(_OWORD *)(v22 + 248);
    v29.i64[0] = *(void *)(v22 + 280);
    v29.i64[1] = v23;
    char v30 = 0;
    dyld4::ExternallyViewableState::setSharedCacheInfo(v20 + 536, v15, v24, (uint64_t)&v28, *(unsigned __int8 *)(v22 + 398));
    uint64_t v22 = *(void *)(v20 + 8);
  }
  long long v28 = *(_OWORD *)(v22 + 80);
  v29.i64[0] = *(void *)(v22 + 72);
  v29.i64[1] = v21;
  char v30 = 0;
  dyld4::ExternallyViewableState::setDyld(v20 + 536, v15, (uint64_t)&v28);
  uint64_t v25 = *(void *)(v20 + 8);
  long long v28 = *(_OWORD *)(v25 + 32);
  int8x16_t v29 = vextq_s8(*(int8x16_t *)(v25 + 8), *(int8x16_t *)(v25 + 8), 8uLL);
  char v30 = 0;
  dyld4::ExternallyViewableState::addImageInfo(v20 + 536, v15, (uint64_t)&v28);
  *(_DWORD *)(v20 + 102dyld4::halt((char *)__format, 0) = 1;
  dyld4::ExternallyViewableState::setInitialImageCount((dyld4::ExternallyViewableState *)(v20 + 536), 1u);
  if ((dyld3::MachOFile::isSimulatorPlatform(*(_DWORD *)(*(void *)(v20 + 8) + 68), 0) & 1) == 0) {
    dyld4::ExternallyViewableState::commit((const os_unfair_lock *)(v20 + 536), *(lsl::Lock ***)(v20 + 16), (lsl::Allocator *)v15, v27);
  }
  **(void **)(a1 + 4dyld4::halt((char *)__format, 0) = dyld4::prepare(**(dyld4 ***)(a1 + 16), **(dyld4::APIs ***)(a1 + 32), v26);
  lsl::Allocator::~Allocator((lsl::Allocator *)v15);
}

double dyld4::ExternallyViewableState::setDyld(uint64_t a1, lsl::Lock **a2, uint64_t a3)
{
  uint64_t v6 = *(mach_header **)(a3 + 24);
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a2);
  if (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)v6)
    && *(void *)dyld4::Atlas::ProcessSnapshot::sharedCache(*(dyld4::Atlas::ProcessSnapshot **)a1))
  {
    dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(*(void *)a1, v6);
  }
  else
  {
    dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a3, (uint64_t)v17);
    uint64_t v7 = (atomic_uint **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
    dyld4::Atlas::Image::Image((uint64_t)v10, (uint64_t)a2, (dyld4::FileRecord *)v17, v7, *(void *)(a3 + 24));
    dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Lock ****)a1, (dyld4::Atlas::Image *)v10);
    uint64_t v8 = v15;
    if (v15 && v16) {
      dyld4::Atlas::Mapper::unmap(v13, (unint64_t)v15, v14);
    }
    if (v12) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v12, v8);
    }
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v11);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v17);
  }
  return dyld4::ExternallyViewableState::setDyldOld((dyld4::ExternallyViewableState *)a1, a3);
}

const os_unfair_lock *dyld4::ExternallyViewableState::commit(const os_unfair_lock *this, lsl::Lock **a2, lsl::Allocator *a3, lsl::Allocator *a4)
{
  dyld4::ExternallyViewableState::commit(this, *(dyld4::Atlas::ProcessSnapshot **)&this->_os_unfair_lock_opaque, a2, a4);

  return dyld4::ExternallyViewableState::release(this, a3);
}

void *dyld4::ExternallyViewableState::init(uint64_t *a1, lsl::Lock **a2, lsl::Lock **this, dyld4::FileManager *a4, unsigned int a5)
{
  a1[1] = (uint64_t)a4;
  uint64_t v10 = (dyld4::Atlas::ProcessSnapshot *)lsl::Allocator::aligned_alloc(this, 8uLL, 0x70uLL);
  int v13 = 0;
  *a1 = dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(v10, (lsl::Allocator *)this, a4, 1);
  lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(&v13, v11);
  dyld4::Atlas::ProcessSnapshot::setDyldState(*a1, 16);
  dyld4::Atlas::ProcessSnapshot::setPlatform(*a1, a5);
  dyld4::ExternallyViewableState::initOld(a1, a2, a5);
  uint64_t result = lsl::Allocator::malloc(a2, 0x20uLL);
  *uint64_t result = a2;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  a1[6] = (uint64_t)result;
  return result;
}

dyld4::Atlas::ProcessSnapshot *dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(dyld4::Atlas::ProcessSnapshot *this, lsl::Lock **a2, dyld4::FileManager *a3, char a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = a2;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 0;
  uint64_t v7 = (void *)((char *)this + 72);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  uint64_t v8 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x30uLL);
  *uint64_t v8 = a2;
  *(_OWORD *)(v8 + 1) = 0u;
  *(_OWORD *)(v8 + 3) = 0u;
  void v8[5] = a2;
  lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v7, (lsl::Allocator::AllocationMetadata *)v8);
  *((void *)this + 1dyld4::halt((char *)__format, 0) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = a4;
  *((unsigned char *)this + 105) = 1;
  return this;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setPlatform(uint64_t this, uint64_t a2)
{
  *(void *)(this + 8dyld4::halt((char *)__format, 0) = a2;
  return this;
}

void *dyld4::ExternallyViewableState::initOld(void *a1, lsl::Lock **this, int a3)
{
  uint64_t v5 = sProcessInfo;
  a1[3] = sProcessInfo;
  v5[80] = a3;
  uint64_t v6 = lsl::Allocator::malloc(this, 0x20uLL);
  *uint64_t v6 = this;
  v6[1] = 0;
  void v6[2] = 0;
  void v6[3] = 0;
  a1[4] = v6;
  uint64_t result = lsl::Allocator::malloc(this, 0x20uLL);
  *uint64_t result = this;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  a1[5] = result;
  return result;
}

uint64_t dyld4::ExternallyViewableState::switchToDyldInDyldCache(dyld4::ExternallyViewableState *this, const dyld3::MachOFile *a2)
{
  mach_msg_type_number_t task_info_outCnt = 5;
  if (task_info(mach_task_self_, 0x11u, task_info_out, &task_info_outCnt)) {
    return 0;
  }
  uint64_t v3 = *(void *)task_info_out;
  if (proc_set_dyld_all_image_info(&dyld_all_image_infos, (void *)0x170))
  {
    sProcessInfo = (_UNKNOWN *)v3;
    uint64_t v4 = *(void (**)(uint64_t, uint64_t, dyld4::ExternallyViewableState **))(v3 + 16);
    *(void *)(v3 + 32) = this;
    *(void *)(v3 + 192) = "/usr/lib/dyld";
    *(void *)(v3 + 16) = lldb_image_notifier;
    *(void *)(v3 + 48) = "cache";
    uint64_t v8 = this;
    uint64_t v9 = "/usr/lib/dyld";
    uint64_t v10 = 0;
    v4(3, 1, &v8);
    return 0;
  }
  if (*(_DWORD *)(v3 + 200)) {
    dword_1EB1CFC48 = *(_DWORD *)(v3 + 200);
  }
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, dyld4::ExternallyViewableState **))(v3 + 16);
  uint64_t v8 = this;
  uint64_t v9 = "/usr/lib/dyld";
  uint64_t v10 = 0;
  uint64_t v5 = 1;
  v7(3, 1, &v8);
  return v5;
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  kern_return_t v9;
  kern_return_t v10;
  BOOL v11;
  mach_msg_type_number_t v14;
  uint64_t v15;
  mach_msg_header_t v16;
  uint64_t v17;
  task_flavor_t v18;
  mach_msg_size_t v19;
  _OWORD v20[24];

  unint64_t v17 = 0x100000000;
  mach_msg_type_number_t v7 = *task_info_outCnt;
  if (*task_info_outCnt >= 0x5E) {
    mach_msg_type_number_t v7 = 94;
  }
  memset(v20, 0, sizeof(v20));
  uint64_t v18 = flavor;
  uint64_t v19 = v7;
  uint64_t reply_port = mig_get_reply_port();
  *(void *)&v16.msgh_bits = 0x2800001513;
  *(void *)&v16.msgh_remote_port = __PAIR64__(reply_port, target_task);
  *(void *)&v16.msgh_voucher_port = 0xD4D00000000;
  uint64_t v9 = mach_msg2_internal(&v16, 0x200000003uLL, (void *)0x2800001513, (void *)__PAIR64__(reply_port, target_task), (void *)0xD4D00000000, (void *)(reply_port << 32), (void *)0x1A8, 0);
  uint64_t v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (v9)
    {
      mig_dealloc_reply_port(v16.msgh_local_port);
      return v10;
    }
    if (v16.msgh_id == 71)
    {
      uint64_t v10 = -308;
    }
    else if (v16.msgh_id == 3505)
    {
      if ((v16.msgh_bits & 0x80000000) == 0)
      {
        if (v16.msgh_size - 417 <= 0xFFFFFE86)
        {
          if (v16.msgh_remote_port) {
            uint64_t v11 = 1;
          }
          else {
            uint64_t v11 = v18 == 0;
          }
          if (!v11 && v16.msgh_size == 36) {
            uint64_t v10 = v18;
          }
          else {
            uint64_t v10 = -300;
          }
          goto LABEL_24;
        }
        if (!v16.msgh_remote_port)
        {
          uint64_t v10 = v18;
          if (v18) {
            goto LABEL_24;
          }
          uint64_t v14 = v19;
          if (v19 <= 0x5E && v19 <= (v16.msgh_size - 40) >> 2 && v16.msgh_size == 4 * v19 + 40)
          {
            uint64_t v15 = *task_info_outCnt;
            if (v19 <= v15)
            {
              memmove(task_info_out, v20, 4 * v19);
              uint64_t v10 = 0;
              *mach_msg_type_number_t task_info_outCnt = v14;
            }
            else
            {
              memmove(task_info_out, v20, 4 * v15);
              *mach_msg_type_number_t task_info_outCnt = v14;
              return -307;
            }
            return v10;
          }
        }
      }
      uint64_t v10 = -300;
    }
    else
    {
      uint64_t v10 = -301;
    }
LABEL_24:
    mach_msg_destroy(&v16);
  }
  return v10;
}

uint64_t proc_set_dyld_all_image_info(void *a1, void *a2)
{
  uint64_t v4 = (void *)getpid();

  return __proc_info((void *)0xF, v4, 0, 0, a1, a2, v5, v6);
}

mach_port_t mig_get_reply_port(void)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  mach_port_t result = *(_DWORD *)(StatusReg + 16);
  mach_port_name_t name = result;
  if (!result)
  {
    v2.reserved[1] = 0;
    *(_OWORD *)&v2.flags = xmmword_1A8E71948;
    mach_port_t result = mach_port_construct(mach_task_self_, &v2, 0, &name);
    if (result)
    {
      qword_1EC3F2750 = (uint64_t)"mach_port_construct for mig_get_reply_port failed";
      qword_1EC3F2780 = (int)result;
      __break(1u);
    }
    else
    {
      mach_port_t result = name;
      *(void *)(StatusReg + 16) = name;
    }
  }
  return result;
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  BOOL v11;
  mach_msg_header_t v13;
  int v14;
  mach_port_options_ptr_t v15;
  uint64_t v16;
  uint64_t v17;
  mach_port_context_t v18;

  uint64_t v8 = _kernelrpc_mach_port_construct_trap(task, options, context, name);
  if (v8 == 268435459)
  {
    uint64_t v14 = 1;
    uint64_t v15 = options;
    char v16 = 0x1801000100;
    unint64_t v17 = 0x100000000;
    uint64_t v18 = context;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v13.msgh_bits = 0x3C80001513;
    *(void *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v13.msgh_voucher_port = 0xC9F00000000;
    uint64_t v10 = mach_msg2_internal(&v13, 0x200000003uLL, (void *)0x3C80001513, (void *)__PAIR64__(reply_port, task), (void *)0xC9F00000000, (void *)((reply_port << 32) | 1), (void *)0x30, 0);
    uint64_t v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (!v10)
      {
        if (v13.msgh_id == 71)
        {
          uint64_t v8 = -308;
        }
        else if (v13.msgh_id == 3331)
        {
          if ((v13.msgh_bits & 0x80000000) == 0)
          {
            if (v13.msgh_size == 40)
            {
              if (!v13.msgh_remote_port)
              {
                uint64_t v8 = HIDWORD(v15);
                if (!HIDWORD(v15))
                {
                  *mach_port_name_t name = v16;
                  return v8;
                }
                goto LABEL_21;
              }
            }
            else if (v13.msgh_size == 36)
            {
              if (v13.msgh_remote_port) {
                uint64_t v11 = 1;
              }
              else {
                uint64_t v11 = HIDWORD(v15) == 0;
              }
              if (v11) {
                uint64_t v8 = -300;
              }
              else {
                uint64_t v8 = HIDWORD(v15);
              }
              goto LABEL_21;
            }
          }
          uint64_t v8 = -300;
        }
        else
        {
          uint64_t v8 = -301;
        }
LABEL_21:
        mach_msg_destroy(&v13);
        return v8;
      }
      mig_dealloc_reply_port(v13.msgh_local_port);
    }
  }
  return v8;
}

int64_t mach_msg2_internal(void *a1, unint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  char v16 = (void *)(a2 & 0xFFFFFFFFFFFFFBBFLL);
  int64_t result = mach_msg2_trap(a1, (void *)(a2 & 0xFFFFFFFFFFFFFBBFLL), a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if ((a2 & 0x40) == 0)
    {
      while (result == 268435463)
        int64_t result = mach_msg2_trap(a1, v16, a3, a4, a5, a6, a7, a8);
    }
    if ((a2 & 0x400) == 0 && result == 268451845)
    {
      if ((~(_BYTE)a2 & 3) != 0) {
        unint64_t v18 = a2;
      }
      else {
        unint64_t v18 = a2 & 0xFFFFFFFFFFFFBBBELL;
      }
      uint64_t v19 = (void *)(v18 & 0xFFFFFFFFFFFFFBBELL);
      do
        int64_t result = mach_msg2_trap(a1, v19, (void *)a3, a4, a5, a6, a7, a8);
      while (result == 268451845);
    }
  }
  return result;
}

uint64_t __proc_info(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_proc_info, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

const os_unfair_lock *dyld4::ExternallyViewableState::setInitialImageCount(dyld4::ExternallyViewableState *this, unsigned int a2)
{
  unint64_t v3 = a2;
  dyld4::Atlas::ProcessSnapshot::setInitialImageCount(*(void *)this, a2);
  uint64_t v4 = (const os_unfair_lock *)*((void *)this + 4);
  *(void *)(*((void *)this + 3) + 112) = v3;

  return lsl::Vector<dyld_image_info>::resize(v4, v3);
}

uint64_t dyld4::Atlas::ProcessSnapshot::setInitialImageCount(uint64_t this, uint64_t a2)
{
  *(void *)(this + 88) = a2;
  return this;
}

void dyld4::ExternallyViewableState::setSharedCacheInfo(uint64_t a1, lsl::Lock **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a4, (uint64_t)v19);
  if (dyld4::FileRecord::exists((dyld4::FileRecord *)v19))
  {
    uint64_t v10 = dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
    dyld4::Atlas::SharedCache::SharedCache(v14, a2, v19, v10, *(void *)(a4 + 24), a5);
    dyld4::Atlas::ProcessSnapshot::addSharedCache(*(void *)a1, (uint64_t)v14);
    if (v18) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v18, v11);
    }
    if (v16 && v17) {
      dyld4::Atlas::Mapper::unmap(v15[13], (unint64_t)v16, (uint64_t)v15[14]);
    }
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v15);
  }
  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(v12 + 152) = a3;
  int v13 = *(DyldSharedCache **)(a4 + 24);
  *(void *)(v12 + 176) = v13;
  *(_OWORD *)(v12 + 288) = *(_OWORD *)a4;
  *(unsigned char *)(v12 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a5;
  if (v13) {
    DyldSharedCache::getUUID(v13, (__n128 *)(v12 + 160));
  }
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v19);
}

BOOL dyld4::APIs::_dyld_get_shared_cache_uuid(dyld4::APIs *this, __n128 *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if (*(unsigned char *)(v3 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_shared_cache_uuid(%p)\n", a2);
    uint64_t v3 = *((void *)this + 1);
  }
  uint64_t v5 = *(void *)(v3 + 240);
  if (v5) {
    DyldSharedCache::getUUID(*(DyldSharedCache **)(v3 + 240), a2);
  }
  return v5 != 0;
}

__n128 DyldSharedCache::getUUID(DyldSharedCache *this, __n128 *a2)
{
  __n128 result = *(__n128 *)((char *)this + 88);
  *a2 = result;
  return result;
}

BOOL dyld4::FileRecord::exists(dyld4::FileRecord *this)
{
  return *((_DWORD *)this + 17) == 0;
}

uint64_t dyld4::FileRecord::stat(uint64_t this)
{
  if (*(_DWORD *)(this + 68) == 1)
  {
    uint64_t v1 = this;
    int v2 = *(_DWORD *)(this + 64);
    if (v2 == -1)
    {
      uint64_t Path = (const char *)dyld4::FileRecord::getPath((dyld4::FileRecord *)v1);
      this = stat64(Path, &v9);
    }
    else
    {
      this = fstat64(v2, &v9);
    }
    *(_DWORD *)(v1 + 68) = this;
    if (!this)
    {
      __darwin_time_t tv_sec = v9.st_mtimespec.tv_sec;
      *(void *)(v1 + 48) = v9.st_size;
      *(void *)(v1 + 56) = tv_sec;
      *(_WORD *)(v1 + 72) = v9.st_mode;
      if (!*(void *)(v1 + 8))
      {
        uint64_t v5 = 24;
        do
        {
          int v6 = *(unsigned __int8 *)(v1 + v5);
          if (*(unsigned char *)(v1 + v5)) {
            break;
          }
        }
        while (v5++ != 39);
        if (!v6)
        {
          *(void *)(v1 + 8) = v9.st_ino;
          this = dyld4::FileManager::uuidForFileSystem(*(dyld4::FileManager **)v1, v9.st_dev);
          *(void *)(v1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = this;
          *(void *)(v1 + 32) = v8;
        }
      }
    }
  }
  return this;
}

dyld4::FileRecord *dyld4::FileRecord::FileRecord(dyld4::FileRecord *this, dyld4::FileManager *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = dyld4::FileManager::uuidForFileSystem(a2, a4);
  *((void *)this + 4) = v7;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = a5;
  *((void *)this + 8) = 0x1FFFFFFFFLL;
  *((_WORD *)this + 36) = 0;
  *((unsigned char *)this + 74) = 1;
  if (*((void *)this + 1) && a5 && *((void *)this + 2)) {
    *((_DWORD *)this + 17) = 0;
  }
  return this;
}

uint64_t dyld4::FileManager::uuidForFileSystem(dyld4::FileManager *this, unsigned int a2)
{
  uint64_t v3 = (uint64_t *)*((void *)this + 2);
  *(void *)&v23[8] = 0;
  *(void *)&void v23[16] = 0;
  unint64_t v4 = a2;
  *(void *)uint64_t v23 = a2;
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v3, (unint64_t *)v23, (uint64_t)&v12);
  v26[4] = v17;
  v26[5] = v18;
  v26[6] = v19;
  uint64_t v25 = v12;
  v26[0] = v13;
  v26[1] = v14;
  void v26[2] = v15;
  void v26[3] = v16;
  *(void *)&void v28[7] = *(void *)&v21[7];
  uint64_t v27 = v20;
  *(void *)long long v28 = *(void *)v21;
  unsigned __int8 v29 = v22;
  uint64_t v5 = *((void *)this + 2);
  memset(v23, 0, 135);
  uint64_t v12 = v5;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v20 = 0;
  memset(v21, 0, sizeof(v21));
  unsigned __int8 v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v25, (uint64_t)&v12))
  {
    dyld4::FileManager::reloadFSInfos((uint64_t **)this);
    int v6 = (uint64_t *)*((void *)this + 2);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    unint64_t v30 = v4;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v6, &v30, (uint64_t)&v12);
    *(_OWORD *)&v23[72] = v17;
    *(_OWORD *)&v23[88] = v18;
    *(_OWORD *)&v23[104] = v19;
    *(void *)uint64_t v23 = v12;
    *(_OWORD *)&v23[8] = v13;
    *(_OWORD *)&v23[24] = v14;
    *(_OWORD *)&v23[40] = v15;
    *(_OWORD *)&v23[56] = v16;
    *(void *)&v23[135] = *(void *)&v21[7];
    *(void *)&v23[120] = v20;
    *(void *)&v23[128] = *(void *)v21;
    unsigned __int8 v24 = v22;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap(&v25, (uint64_t *)v23);
  }
  uint64_t v7 = *((void *)this + 2);
  memset(v23, 0, 135);
  uint64_t v12 = v7;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v20 = 0;
  memset(v21, 0, sizeof(v21));
  unsigned __int8 v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v25, (uint64_t)&v12))
  {
    uint64_t v8 = (uint64_t *)*((void *)this + 2);
    *(void *)&v23[8] = 0;
    *(void *)&void v23[16] = 0;
    *(void *)uint64_t v23 = v4;
    lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert(v8, (uint64_t)v23, (uint64_t)&v12);
    stat v9 = (uint64_t *)*((void *)this + 2);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    unint64_t v30 = v4;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v9, &v30, (uint64_t)&v12);
    *(_OWORD *)&v23[72] = v17;
    *(_OWORD *)&v23[88] = v18;
    *(_OWORD *)&v23[104] = v19;
    *(void *)uint64_t v23 = v12;
    *(_OWORD *)&v23[8] = v13;
    *(_OWORD *)&v23[24] = v14;
    *(_OWORD *)&v23[40] = v15;
    *(_OWORD *)&v23[56] = v16;
    *(void *)&v23[135] = *(void *)&v21[7];
    *(void *)&v23[120] = v20;
    *(void *)&v23[128] = *(void *)v21;
    unsigned __int8 v24 = v22;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap(&v25, (uint64_t *)v23);
  }
  uint64_t v10 = *((void *)this + 2);
  memset(v23, 0, 135);
  uint64_t v12 = v10;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v20 = 0;
  memset(v21, 0, sizeof(v21));
  unsigned __int8 v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v25, (uint64_t)&v12))dyld4::FileManager::uuidForFileSystem(); {
  return *(void *)(*((void *)v26 + v29 - 1) + 24 * v28[v29 - 1] + 8);
  }
}

void dyld4::FileManager::reloadFSInfos(uint64_t **this)
{
  uint64_t v2 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)this);
  __chkstk_darwin(v2, v2, v3, v4, v5, v6, v7, v8, v34);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v10, v11);
  long long v13 = (char *)lsl::AllocatorLayout::minSize(v12);
  long long v14 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v10, v13);
  int v15 = dyld4::SyscallDelegate::getfsstat((dyld4::SyscallDelegate *)*this, 0, 0, 2);
  if (v15 != -1)
  {
    LODWORD(v16) = v15;
    while (1)
    {
      long long v17 = (statfs *)lsl::Allocator::malloc(v14, 2168 * (int)v16);
      if (dyld4::SyscallDelegate::getfsstat((dyld4::SyscallDelegate *)*this, v17, 2168 * (int)v16, 2) == v16) {
        break;
      }
      lsl::Allocator::free(v14, v17);
      LODWORD(v16) = dyld4::SyscallDelegate::getfsstat((dyld4::SyscallDelegate *)*this, 0, 0, 2);
      if (v16 == -1) {
        goto LABEL_20;
      }
    }
    if ((int)v16 >= 1)
    {
      uint64_t v39 = &v59[8];
      int v37 = (uint64_t *)&v65[8];
      pid_t v38 = v58;
      uint64_t v35 = (_OWORD *)((char *)v56 + 8);
      uint64_t v36 = &v41;
      _X22 = v17;
      uint64_t v16 = v16;
      do
      {
        __asm { PRFM            #0, [X22,#0x1998] }
        unsigned __int8 v24 = (uint64_t *)_X22->f_fsid.val[0];
        uint64_t v25 = this[2];
        char v26 = v39;
        *uint64_t v39 = 0;
        v26[1] = 0;
        *(void *)uint64_t v59 = v24;
        lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find(v25, (unint64_t *)v59, (uint64_t)&v42);
        uint64_t v53 = v42;
        void v56[2] = v47;
        v56[3] = v48;
        v56[4] = v49;
        uint64_t v57 = v50;
        long long v54 = v43;
        long long v55 = v44;
        v56[0] = v45;
        v56[1] = v46;
        uint64_t v27 = *(void *)v51;
        long long v28 = v38;
        *(void *)(v38 + 7) = *(void *)&v51[7];
        *long long v28 = v27;
        v58[15] = v52;
        unsigned __int8 v29 = this[2];
        long long v64 = 0u;
        memset(v65, 0, 23);
        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        memset(v59, 0, sizeof(v59));
        int v42 = v29;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        uint64_t v50 = 0;
        uint64_t v30 = *v37;
        *(void *)&v51[7] = *(uint64_t *)((char *)v37 + 7);
        *(void *)uint64_t v51 = v30;
        char v52 = 0;
        if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v53, (uint64_t)&v42))
        {
          if ((_X22->f_flags & 0x4000) != 0)
          {
            *(_DWORD *)uint64_t v59 = 5;
            *(_DWORD *)&v59[12] = 0;
            *(void *)&v59[16] = 0;
            *(void *)&v59[4] = 0x8006000000000006;
            if (!dyld4::SyscallDelegate::getattrlist((dyld4::SyscallDelegate *)*this, _X22->f_mntonname, (attrlist *)v59, &v53, 0x40uLL, 0)&& (BYTE8(v54) & 1) != 0)
            {
              uint64_t v31 = this[2];
              uint64_t v40 = v24;
              *(_OWORD *)uint64_t v36 = *v35;
            }
            else
            {
              uint64_t v31 = this[2];
              uint64_t v33 = v36;
              uint64_t *v36 = 0;
              v33[1] = 0;
              uint64_t v40 = v24;
            }
            uint64_t v32 = (uint64_t *)&v40;
          }
          else
          {
            uint64_t v31 = this[2];
            long long v54 = 0uLL;
            uint64_t v53 = v24;
            uint64_t v32 = (uint64_t *)&v53;
          }
          lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert(v31, (uint64_t)v32, (uint64_t)&v42);
        }
        ++_X22;
        --v16;
      }
      while (v16);
    }
    lsl::Allocator::free(v14, v17);
  }
LABEL_20:
  lsl::Allocator::~Allocator((lsl::Allocator *)v14);
}

double lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find@<D0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator((uint64_t)&v23, a1, a2);
  long long v13 = a1;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v23, (uint64_t)&v13)&& (unsigned __int8 v6 = v32, *a2 >= *(void *)(*((void *)v24 + v32 - 1) + 24 * v31[v32 - 1])))
  {
    long long v8 = v28;
    *(_OWORD *)(a3 + 72) = v27;
    *(_OWORD *)(a3 + 88) = v8;
    *(_OWORD *)(a3 + 104) = v29;
    long long v9 = v24[1];
    *(_OWORD *)(a3 + 8) = v24[0];
    *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;
    double result = *(double *)&v25;
    long long v10 = v26;
    *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = v25;
    *(void *)a3 = v23;
    uint64_t v11 = v30;
    *(_OWORD *)(a3 + 56) = v10;
    *(void *)(a3 + 135) = *(void *)&v31[7];
    uint64_t v12 = *(void *)v31;
    *(void *)(a3 + 12dyld4::halt((char *)__format, 0) = v11;
    *(void *)(a3 + 128) = v12;
    *(unsigned char *)(a3 + 143) = v6;
  }
  else
  {
    *(void *)a3 = a1;
    double result = 0.0;
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
    *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 72) = 0u;
    *(_OWORD *)(a3 + 88) = 0u;
    *(_OWORD *)(a3 + 104) = 0u;
    *(_OWORD *)(a3 + 12dyld4::halt((char *)__format, 0) = 0u;
    *(void *)(a3 + 136) = 0;
  }
  return result;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator(uint64_t result, uint64_t *a2, unint64_t *a3)
{
  *(void *)double result = a2;
  *(_OWORD *)(result + 8) = 0u;
  uint64_t v3 = result + 8;
  *(_OWORD *)(result + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(result + 4dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_OWORD *)(result + 104) = 0u;
  *(_OWORD *)(result + 12dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(result + 136) = 0;
  if (*((unsigned char *)a2 + 32))
  {
    unint64_t v4 = 0;
    uint64_t v5 = *a2;
    uint64_t v6 = result + 128;
    do
    {
      *(void *)(v3 + 8 * v4) = v5;
      unint64_t v7 = *(unsigned char *)(v5 + 240) & 0x7F;
      if ((*(unsigned char *)(v5 + 240) & 0x7F) != 0)
      {
        long long v8 = (void *)v5;
        do
        {
          unint64_t v9 = v7 >> 1;
          long long v10 = &v8[3 * (v7 >> 1)];
          unint64_t v12 = *v10;
          uint64_t v11 = v10 + 3;
          v7 += ~(v7 >> 1);
          if (v12 < *a3) {
            long long v8 = v11;
          }
          else {
            unint64_t v7 = v9;
          }
        }
        while (v7);
      }
      else
      {
        long long v8 = (void *)(v5 + 24 * (*(unsigned char *)(v5 + 240) & 0x7F));
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v8 - v5) >> 3);
      *(unsigned char *)(v6 + v4) = v13;
      uint64_t v14 = *(void *)(v3 + 8 * v4);
      if ((*(unsigned char *)(v14 + 240) & 0x7F) != v13
        && *(void *)(v14 + 24 * v13) < *a3)
      {
        *(unsigned char *)(result + 143) = v4 + 1;
        return result;
      }
      unint64_t v15 = *((unsigned __int8 *)a2 + 32);
      if (v4 + 1 != v15)
      {
        if ((*(unsigned char *)(v14 + 240) & 0x80) != 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v5 = *(void *)(v14 + 8 * v13 + 168);
      }
      ++v4;
    }
    while (v4 < v15);
    for (*(unsigned char *)(result + 143) = v15; (_BYTE)v15; *(unsigned char *)(result + 143) = v15)
    {
      if (*(unsigned char *)(v6 + v15 - 1) != (*(unsigned char *)(*(void *)(result
                                                                                            + 8 * v15)
                                                                                + 240) & 0x7F))
        break;
      LOBYTE(v15) = v15 - 1;
    }
  }
  return result;
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::insert_internal(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v24 = a1;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    uint64_t v33 = 0;
    if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>(a2, (uint64_t)&v24))
    {
      uint64_t v8 = *(unsigned __int8 *)(a2 + 143);
      if (*a3 >= *(void *)(*(void *)(a2 + 8 + 8 * (v8 - 1)) + 24 * *(unsigned __int8 *)(a2 + 128 + v8 - 1)))
      {
        char v13 = 0;
        long long v19 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a4 + 88) = v19;
        *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
        long long v20 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v20;
        long long v21 = *(_OWORD *)(a2 + 56);
        *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
        *(void *)a4 = *(void *)a2;
        *(void *)(a4 + 135) = *(void *)(a2 + 135);
        uint64_t v22 = *(void *)(a2 + 120);
        *(_OWORD *)(a4 + 56) = v21;
        uint64_t v23 = *(void *)(a2 + 128);
        *(void *)(a4 + 12dyld4::halt((char *)__format, 0) = v22;
        *(void *)(a4 + 128) = v23;
        *(unsigned char *)(a4 + 143) = v8;
        goto LABEL_11;
      }
    }
    uint64_t v24 = a1;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    uint64_t v33 = 0;
    if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>(a2, (uint64_t)&v24)&& *(unsigned __int8 *)(a2 + 143) == *(unsigned __int8 *)(a1 + 32))
    {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      unint64_t v9 = (uint64_t *)(a2 + 128);
      uint64_t v10 = *(unsigned __int8 *)(a2 + 143) - 1;
      unsigned __int8 v11 = *(unsigned char *)(a2 + 128 + v10);
    }
    else
    {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator--((uint64_t **)a2);
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      unint64_t v9 = (uint64_t *)(a2 + 128);
      uint64_t v16 = *(unsigned __int8 *)(a2 + 143) + a2 + 128;
      unsigned __int8 v11 = *(unsigned char *)(v16 - 1) + 1;
      *(unsigned char *)(v16 - 1) = v11;
      uint64_t v10 = *(unsigned __int8 *)(a2 + 143) - 1;
    }
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert(*(void *)(a2 + 8 + 8 * v10), v11, (uint64_t)a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
    uint64_t v17 = *(void *)(a2 + 120);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    uint64_t v18 = *v9;
    *(void *)(a4 + 135) = *(uint64_t *)((char *)v9 + 7);
    *(void *)(a4 + 12dyld4::halt((char *)__format, 0) = v17;
    *(void *)(a4 + 128) = v18;
    char v15 = *(unsigned char *)(a2 + 143);
    char v13 = 1;
  }
  else
  {
    unint64_t v12 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((unsigned char *)v12 + 24dyld4::halt((char *)__format, 0) = 0x80;
    *(_OWORD *)unint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 6) = 0u;
    *((_OWORD *)v12 + 7) = 0u;
    *((_OWORD *)v12 + 8) = 0u;
    *((_OWORD *)v12 + 9) = 0u;
    *((_OWORD *)v12 + 1dyld4::halt((char *)__format, 0) = 0u;
    *((_OWORD *)v12 + 11) = 0u;
    *((_OWORD *)v12 + 12) = 0u;
    *((_OWORD *)v12 + 13) = 0u;
    *((_OWORD *)v12 + 14) = 0u;
    *(void *)a1 = v12;
    char v13 = 1;
    *(unsigned char *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v12;
    *(unsigned char *)(a2 + 143) = 1;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert((uint64_t)v12, 0, (uint64_t)a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(void *)(a4 + 135) = *(void *)(a2 + 135);
    uint64_t v14 = *(void *)(a2 + 128);
    *(void *)(a4 + 12dyld4::halt((char *)__format, 0) = *(void *)(a2 + 120);
    *(void *)(a4 + 128) = v14;
    char v15 = *(unsigned char *)(a2 + 143);
  }
  *(unsigned char *)(a4 + 143) = v15;
LABEL_11:
  *(unsigned char *)(a4 + 144) = v13;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 143);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 143);
  if (v2 >= v3) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 143);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 143);
  }
  if (v4)
  {
    uint64_t v5 = (unsigned __int8 *)(a1 + 128);
    uint64_t v6 = (unsigned __int8 *)(a2 + 128);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 >= v9;
      if (v7 != v9) {
        break;
      }
      if (!--v4) {
        goto LABEL_8;
      }
    }
    if (v10) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_8:
    BOOL v11 = v3 == v2;
    if (v3 < v2) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v11) {
      return 0;
    }
    else {
      return v12;
    }
  }
}

__n128 lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert(uint64_t a1, unsigned int a2, uint64_t a3)
{
  char v3 = *(unsigned char *)(a1 + 240);
  char v4 = v3;
  uint64_t v5 = v3 & 0x7F;
  if (v3 >= 0) {
    int v6 = 7;
  }
  else {
    int v6 = 10;
  }
  if (v5 == v6) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if (v6 == a2) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if (v5 != a2)
  {
    uint64_t v7 = 3 * v5;
    uint64_t v8 = a1 + 8 * v7;
    uint64_t v9 = 24 * a2 - 8 * v7;
    uint64_t v10 = v8;
    do
    {
      uint64_t v11 = *(void *)(v10 - 24);
      v10 -= 24;
      *(void *)uint64_t v8 = v11;
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(v8 - 16);
      uint64_t v8 = v10;
      v9 += 24;
    }
    while (v9);
    char v4 = *(unsigned char *)(a1 + 240);
  }
  *(unsigned char *)(a1 + 24dyld4::halt((char *)__format, 0) = v4 + 1;
  *(void *)(a1 + 24 * a2) = *(void *)a3;
  __n128 result = *(__n128 *)(a3 + 8);
  *(__n128 *)(a1 + 24 * a2 + 8) = result;
  return result;
}

double lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v9 = *(void *)a2;
  long long v10 = *(_OWORD *)(a2 + 8);
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator((uint64_t)v22, a1, &v9);
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::insert_internal((uint64_t)a1, (uint64_t)v22, &v9, (uint64_t)&v11);
  uint64_t v5 = v11;
  *(_OWORD *)(a3 + 72) = v16;
  *(_OWORD *)(a3 + 88) = v17;
  *(_OWORD *)(a3 + 104) = v18;
  *(_OWORD *)(a3 + 8) = v12;
  *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v13;
  *(_OWORD *)(a3 + 4dyld4::halt((char *)__format, 0) = v14;
  double result = *(double *)&v15;
  *(_OWORD *)(a3 + 56) = v15;
  *(void *)(a3 + 135) = *(void *)&v20[7];
  uint64_t v7 = *(void *)v20;
  *(void *)(a3 + 12dyld4::halt((char *)__format, 0) = v19;
  *(void *)(a3 + 128) = v7;
  __int16 v8 = v21;
  *(void *)a3 = v5;
  *(_WORD *)(a3 + 143) = v8;
  return result;
}

unsigned __int8 *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion(unsigned __int8 *result)
{
  uint64_t v1 = result[143];
  if (v1 != *(unsigned __int8 *)(*(void *)result + 32)) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion();
  }
  unsigned int v2 = result;
  char v3 = result + 8;
  if (*(char *)(*(void *)&result[8 * v1] + 240) >= 0) {
    int v4 = 7;
  }
  else {
    int v4 = 10;
  }
  if ((*(unsigned char *)(*(void *)&result[8 * v1] + 240) & 0x7F) == v4)
  {
    if (!result[143]) {
      goto LABEL_15;
    }
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    do
    {
      if (*(char *)(v3[v5] + 240) >= 0) {
        int v7 = 7;
      }
      else {
        int v7 = 10;
      }
      if ((*(unsigned char *)(v3[v5] + 240) & 0x7F) != v7) {
        unsigned int v6 = v5;
      }
      ++v5;
    }
    while (v1 != v5);
    if (!v6)
    {
LABEL_15:
      if (*(char *)(*v3 + 240) >= 0) {
        int v8 = 7;
      }
      else {
        int v8 = 10;
      }
      if ((*(unsigned char *)(*v3 + 240) & 0x7F) == v8)
      {
        double result = (unsigned __int8 *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(*(void *)result + 8), 0x100uLL, 0x100uLL);
        uint64_t v9 = **(void **)v2;
        result[240] = 0;
        *(_OWORD *)double result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((void *)result + 2dyld4::halt((char *)__format, 0) = 0;
        *((void *)result + 21) = v9;
        **(void **)unsigned int v2 = result;
        if (v2[143] && (double result = (unsigned __int8 *)memmove(v2 + 129, v2 + 128, v2[143]), v2[143]))
        {
          double result = (unsigned __int8 *)memmove(v3 + 1, v3, 8 * v2[143]);
          LOBYTE(v1) = v2[143] + 1;
        }
        else
        {
          LOBYTE(v1) = 1;
        }
        unsigned int v6 = 0;
        v2[128] = 0;
        long long v10 = *(uint64_t **)v2;
        *((void *)v2 + 1) = **(void **)v2;
        ++*((unsigned char *)v10 + 32);
        v2[143] = v1;
      }
      else
      {
        unsigned int v6 = 0;
      }
    }
    if (v6 + 1 < v1)
    {
      uint64_t v11 = v2 + 128;
      uint64_t v12 = v6;
      do
      {
        int v13 = v12;
        double result = (unsigned __int8 *)lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild(v3[v12], v11[v12], *(lsl::Lock ***)(*(void *)v2 + 8));
        uint64_t v14 = v3[v12];
        if (*(char *)(v14 + 240) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v15 = v11[v12];
        uint64_t v16 = *(void *)(v14 + 8 * v15 + 168);
        unsigned int v17 = v2[v12 + 129];
        if (v17 > (*(unsigned char *)(v16 + 240) & 0x7Fu))
        {
          unsigned __int8 v18 = v15 + 1;
          v11[v12] = v18;
          v2[v12 + 129] = v17 + (~*(unsigned char *)(v16 + 240) | 0x80);
          uint64_t v19 = v3[v12];
          if (*(char *)(v19 + 240) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          *(void *)&v2[8 * v12 + 16] = *(void *)(v19 + 8 * v18 + 168);
        }
        ++v12;
      }
      while (v13 + 2 < v2[143]);
    }
  }
  return result;
}

int getfsstat64(statfs *a1, int a2, int a3)
{
  int64_t v9 = mac_syscall(SYS_getfsstat64, a1, *(void **)&a2, *(void **)&a3, v4, v5, v6, v7, v8);
  if (v3) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

uint64_t dyld4::SyscallDelegate::getfsstat(dyld4::SyscallDelegate *this, statfs *a2, int a3, int a4)
{
  return getfsstat64(a2, a3, a4);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  int result = mac_syscall(SYS_getattrlist, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::getattrlist(dyld4::SyscallDelegate *this, const char *a2, attrlist *a3, void *a4, size_t a5, unsigned int a6)
{
  return getattrlist(a2, a3, a4, a5, a6);
}

uint64_t *dyld4::Atlas::ProcessSnapshot::addSharedCache(uint64_t a1, uint64_t a2)
{
  char v3 = (const os_unfair_lock **)(a1 + 64);
  lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,dyld4::Atlas::SharedCache>(*(lsl::Lock ***)a1, a2, &v13);
  if (&v13 != v3)
  {
    char v5 = *v3;
    void *v3 = v13;
    int v13 = v5;
  }
  lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(&v13, v4);
  unsigned int v6 = *(lsl::Lock ***)a1;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 64) + 128) + 144);
  int v8 = (os_unfair_lock *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)a1, 8uLL, 0x10uLL);
  *(void *)&v8->_uint32_t os_unfair_lock_opaque = v7;
  *(void *)&v8[2]._uint32_t os_unfair_lock_opaque = lsl::Allocator::malloc(v6, (unint64_t)(v7 + 7) >> 3);
  int v13 = v8;
  long long v10 = (const os_unfair_lock **)(a1 + 56);
  if (&v13 != (const os_unfair_lock **)(a1 + 56))
  {
    uint64_t v11 = *v10;
    *long long v10 = v8;
    int v13 = v11;
  }
  return lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v13, v9);
}

void dyld4::ExternallyViewableState::addImageInfo(uint64_t a1, lsl::Lock **a2, uint64_t a3)
{
  dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a3, (uint64_t)v24);
  unsigned int v6 = (atomic_uint **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
  dyld4::Atlas::Image::Image((uint64_t)v17, (uint64_t)a2, (dyld4::FileRecord *)v24, v6, *(void *)(a3 + 24));
  dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Lock ****)a1, (dyld4::Atlas::Image *)v17);
  uint64_t v7 = mach_absolute_time();
  int v8 = (dyld4::FileRecord *)dyld4::Atlas::Image::file((dyld4::Atlas::Image *)v17);
  uint64_t v9 = dyld4::FileRecord::mtime(v8);
  dyld4::ExternallyViewableState::addImageInfoOld((dyld4::ExternallyViewableState *)a1, (int8x16_t *)a3, v7, v9);
  if (*(_DWORD *)(*(void *)(a1 + 24) + 200) == 1229016646)
  {
    int v13 = *(mach_header **)(a3 + 24);
    uint64_t v15 = *(char **)(a3 + 16);
    uint64_t v16 = v13;
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges((dyld4::ExternallyViewableState *)a1, 0, 1, (const mach_header **)&v16, (const char **)&v15, v10, v11, v12);
  }
  uint64_t v14 = v22;
  if (v22 && v23) {
    dyld4::Atlas::Mapper::unmap(v20, (unint64_t)v22, v21);
  }
  if (v19) {
    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock *)v19, v14);
  }
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v18);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v24);
}

uint64_t dyld4::Atlas::Image::file(dyld4::Atlas::Image *this)
{
  return (uint64_t)this + 8;
}

uint64_t dyld4::FileRecord::mtime(dyld4::FileRecord *this)
{
  uint64_t result = *((void *)this + 7);
  if (!result)
  {
    dyld4::FileRecord::stat((uint64_t)this);
    return *((void *)this + 7);
  }
  return result;
}

uint64_t dyld4::ExternallyViewableState::addImageInfoOld(dyld4::ExternallyViewableState *a1, int8x16_t *a2, unint64_t a3, uint64_t a4)
{
  atomic_store(0, (unint64_t *)(*((void *)a1 + 3) + 8));
  uint64_t v8 = *((void *)a1 + 4);
  int8x16_t v17 = a2[1];
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v8, *(void *)(v8 + 16) + 1);
  uint64_t v9 = *(void *)(v8 + 8);
  uint64_t v10 = *(void *)(v8 + 16);
  *(void *)(v8 + 16) = v10 + 1;
  uint64_t v11 = (int8x16_t *)(v9 + 24 * v10);
  *uint64_t v11 = vextq_s8(v17, v17, 8uLL);
  v11[1].i64[0] = a4;
  uint64_t v12 = *((void *)a1 + 3);
  *(_DWORD *)(v12 + 4) = *(void *)(*((void *)a1 + 4) + 16);
  atomic_store(a3, (unint64_t *)(v12 + 184));
  atomic_store(*(void *)(*((void *)a1 + 4) + 8), (unint64_t *)(*((void *)a1 + 3) + 8));
  __n128 v13 = dyld4::ExternallyViewableState::addImageUUID(a1, (const dyld3::MachOFile *)a2[1].i64[1]);
  uint64_t v14 = *(uint64_t (**)(void, uint64_t, uint64_t, __n128))(*((void *)a1 + 3) + 16);
  uint64_t v15 = *(void *)(*((void *)a1 + 4) + 8) + 24 * *(void *)(*((void *)a1 + 4) + 16) - 24;

  return v14(0, 1, v15, v13);
}

double dyld4::ExternallyViewableState::setDyldOld(dyld4::ExternallyViewableState *a1, uint64_t a2)
{
  char v3 = *(const dyld3::MachOFile **)(a2 + 24);
  *(void *)(*((void *)a1 + 3) + 192) = *(void *)(a2 + 16);
  if ((dyld3::MachOFile::inDyldCache(v3) & 1) == 0)
  {
    *(void *)&double result = dyld4::ExternallyViewableState::addImageUUID(a1, v3).n128_u64[0];
  }
  return result;
}

dyld4::RuntimeState *dyld4::RuntimeState::RuntimeState(dyld4::RuntimeState *this, const dyld4::ProcessConfig *a2, dyld4::RuntimeLocks *a3, lsl::Allocator *a4)
{
  *(void *)this = &unk_1EFF626E0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = a4;
  *((void *)this + 5) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = a4;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = lsl::Allocator::Pool::allocator(a4);
  *((void *)this + 17) = a3;
  *((_OWORD *)this + 9) = 0u;
  *((void *)this + 2dyld4::halt((char *)__format, 0) = a4;
  *((void *)this + 21) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((void *)this + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a4;
  *((void *)this + 25) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 28) = a4;
  *((void *)this + 29) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 32) = a4;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((void *)this + 35) = 0;
  *((void *)this + 36) = a4;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 36dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 4++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)((char *)this + 44dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((void *)this + 63) = 0;
  dyld4::FileManager::FileManager((dyld4::RuntimeState *)((char *)this + 512), *((lsl::Lock ***)this + 2), *((const dyld4::SyscallDelegate **)this + 1));
  *((_DWORD *)this + 138) = 0;
  *(_OWORD *)((char *)this + 536) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((void *)this + 74) = a4;
  *(_OWORD *)((char *)this + 60dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 641) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 68dyld4::halt((char *)__format, 0) = 0u;
  *((void *)this + 87) = 0;
  *((void *)this + 88) = a4;
  *((void *)this + 89) = 0;
  *((_OWORD *)this + 45) = 0u;
  *((void *)this + 92) = a4;
  *((void *)this + 95) = 0;
  *(_OWORD *)((char *)this + 744) = 0u;
  *((void *)this + 96) = a4;
  *((void *)this + 99) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *((void *)this + 10dyld4::halt((char *)__format, 0) = a4;
  *((void *)this + 103) = 0;
  *(_OWORD *)((char *)this + 808) = 0u;
  *((void *)this + 104) = a4;
  *((void *)this + 107) = 0;
  *(_OWORD *)((char *)this + 84dyld4::halt((char *)__format, 0) = 0u;
  *((void *)this + 108) = a4;
  *((void *)this + 111) = 0;
  *(_OWORD *)((char *)this + 872) = 0u;
  *((void *)this + 112) = a4;
  *((void *)this + 115) = 0;
  *(_OWORD *)((char *)this + 904) = 0u;
  *((void *)this + 116) = a4;
  *(_OWORD *)((char *)this + 936) = 0u;
  *(_OWORD *)((char *)this + 952) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 100dyld4::halt((char *)__format, 0) = 0u;
  *((_DWORD *)this + 255) = 256;
  *((_OWORD *)this + 64) = 0u;
  *((void *)this + 13dyld4::halt((char *)__format, 0) = a4;
  *((void *)this + 132) = 0;
  *((void *)this + 131) = 0;
  *((void *)this + 133) = 0;
  *((void *)this + 134) = a4;
  *((void *)this + 136) = 0;
  *((void *)this + 135) = 0;
  *((_DWORD *)this + 276) = 0;
  *((void *)this + 137) = 0;
  *((void *)this + 14dyld4::halt((char *)__format, 0) = -1;
  *((void *)this + 139) = -1;
  *((void *)this + 141) = 0xFFFFFFFFLL;
  *((void *)this + 143) = 0;
  *((_WORD *)this + 568) = 0;
  return this;
}

double dyld4::RuntimeLocks::RuntimeLocks(dyld4::RuntimeLocks *this)
{
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

dyld4::FileManager *dyld4::FileManager::FileManager(dyld4::FileManager *this, lsl::Lock **a2, const dyld4::SyscallDelegate *a3)
{
  *(void *)this = a3;
  *((void *)this + 1) = a2;
  char v5 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x28uLL);
  *char v5 = 0;
  v5[1] = a2;
  void v5[3] = 0;
  *((unsigned char *)v5 + 32) = 0;
  *((void *)this + 2) = v5;
  return this;
}

uint64_t dyld3::MachOFile::isSimulatorPlatform(int a1, int *a2)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 7:
      if (!a2) {
        return 1;
      }
      int v4 = 2;
      break;
    case 8:
      if (!a2) {
        return 1;
      }
      int v4 = 3;
      break;
    case 9:
      if (!a2) {
        return 1;
      }
      int v4 = 4;
      break;
    case 12:
      if (!a2) {
        return 1;
      }
      int v4 = 11;
      break;
    default:
      return result;
  }
  *a2 = v4;
  return 1;
}

uint64_t lsl::Allocator::setBestFit(uint64_t this, char a2)
{
  *(unsigned char *)(this + 4dyld4::halt((char *)__format, 0) = a2;
  return this;
}

__n128 lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,dyld4::Atlas::SharedCache>@<Q0>(lsl::Lock **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  char v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xB0uLL);
  *char v5 = *(void *)a2;
  dyld4::FileRecord::FileRecord((uint64_t)(v5 + 1), (dyld4::FileRecord *)(a2 + 8));
  long long v6 = *(_OWORD *)(a2 + 88);
  v5[13] = *(void *)(a2 + 104);
  *(_OWORD *)(v5 + 11) = v6;
  v5[15] = 0;
  unsigned __int8 v5[16] = 0;
  *((unsigned char *)v5 + 136) = 0;
  v5[14] = 0;
  dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap(v5 + 14, (uint64_t *)(a2 + 112));
  v5[18] = 0;
  if (v5 != (void *)a2)
  {
    v5[18] = *(void *)(a2 + 144);
    *(void *)(a2 + 144) = 0;
  }
  __n128 result = *(__n128 *)(a2 + 152);
  *((unsigned char *)v5 + 168) = *(unsigned char *)(a2 + 168);
  *(__n128 *)(v5 + 19) = result;
  *a3 = v5;
  return result;
}

uint64_t *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *__n128 result = *a2;
  *a2 = v2;
  for (uint64_t i = 1; i != 16; ++i)
  {
    uint64_t v4 = result[i];
    result[i] = a2[i];
    a2[i] = v4;
  }
  uint64_t v5 = 0;
  long long v6 = result + 16;
  uint64_t v7 = a2 + 16;
  do
  {
    char v8 = *((unsigned char *)v6 + v5);
    *((unsigned char *)v6 + v5) = *((unsigned char *)v7 + v5);
    *((unsigned char *)v7 + v5++) = v8;
  }
  while (v5 != 15);
  char v9 = *((unsigned char *)result + 143);
  *((unsigned char *)result + 143) = *((unsigned char *)a2 + 143);
  *((unsigned char *)a2 + 143) = v9;
  return result;
}

lsl::Allocator::Pool *lsl::PreallocatedAllocatorLayout<278528ull>::init(lsl::AllocatorLayout *a1, const char **a2, const char **a3, void *a4)
{
  __n128 result = (lsl::Allocator::Pool *)lsl::MemoryManager::MemoryManager((lsl::MemoryManager *)v17, a2, a3, a4);
  uint64_t v19 = (lsl::Lock *)v17;
  unint64_t v18 = 0;
  if (v17) {
    char v9 = (lsl::Lock *)v17;
  }
  else {
    char v9 = 0;
  }
  if (*((unsigned char *)v9 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_39;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_39;
    }
    unint64_t v18 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v18)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_39;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_39;
      }
      __n128 result = (lsl::Allocator::Pool *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v10 = MEMORY[0xFFFFFC0D0];
      if (v10 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_39;
      }
    }
  }
  else
  {
    unint64_t v18 = 1;
    lsl::MemoryManager::lockGuard(v9, &v20);
    uint64_t v11 = *((void *)v9 + 3);
    if (!v11)
    {
      lsl::MemoryManager::writeProtect(v9, 0);
      uint64_t v11 = *((void *)v9 + 3);
    }
    *((void *)v9 + 3) = v11 + 1;
    lsl::Lock::unlock(v20);
  }
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 1dyld4::halt((char *)__format, 0) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  __n128 result = lsl::AllocatorLayout::init(a1, 0x44000uLL, a2, a3, a4);
  if (v19) {
    uint64_t v12 = v19;
  }
  else {
    uint64_t v12 = 0;
  }
  if (*((unsigned char *)v12 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_39;
    }
    if (v18 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return result;
    }
    if (v18 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_39;
      }
      __n128 result = (lsl::Allocator::Pool *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v13 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_39;
      }
      __n128 result = (lsl::Allocator::Pool *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v13 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v13 == StatusReg) {
      return result;
    }
LABEL_39:
    __break(1u);
    return result;
  }
  lsl::MemoryManager::lockGuard(v12, &v20);
  if (v18 == 1)
  {
    uint64_t v16 = *((void *)v12 + 3) - 1;
    *((void *)v12 + 3) = v16;
    if (!v16) {
      lsl::MemoryManager::writeProtect(v12, 1);
    }
  }
  else if (v18 == 0xFFFFFFFF)
  {
    uint64_t v15 = *((void *)v12 + 3);
    if (!v15)
    {
      lsl::MemoryManager::writeProtect(v12, 0);
      uint64_t v15 = *((void *)v12 + 3);
    }
    *((void *)v12 + 3) = v15 + 1;
  }
  return (lsl::Allocator::Pool *)lsl::Lock::unlock(v20);
}

uint64_t lsl::AllocatorLayout::allocator(lsl::AllocatorLayout *this)
{
  return (uint64_t)this + 80;
}

uint64_t lsl::MemoryManager::setDyldCacheAddr(uint64_t this, void *a2)
{
  *(void *)(this + 4dyld4::halt((char *)__format, 0) = a2;
  return this;
}

uint64_t **lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator--(uint64_t **result)
{
  uint64_t v1 = *((unsigned __int8 *)result + 143);
  uint64_t v2 = *result;
  if (*((unsigned char *)result + 143))
  {
    if (v1 == *((unsigned __int8 *)v2 + 32))
    {
      char v3 = result + 16;
      uint64_t v4 = v1 - 1;
      uint64_t v5 = (char *)result + v1 + 127;
      char v6 = *v5;
      if (!*((unsigned char *)result + (v1 - 1) + 128))
      {
        if (!*v5)
        {
          do
          {
            LODWORD(v1) = v1 - 1;
            *((unsigned char *)result + 143) = v1;
            uint64_t v4 = v1 - 1;
            char v6 = *((unsigned char *)v3 + v4);
          }
          while (!v6);
        }
        uint64_t v5 = (char *)v3 + v4;
      }
    }
    else
    {
      uint64_t v14 = result + 1;
      uint64_t v15 = result + 16;
      do
      {
        uint64_t v16 = v14[v1 - 1];
        if ((char)v16[30] < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v17 = v16[*((unsigned __int8 *)v15 + v1 - 1) + 21];
        v14[v1] = (uint64_t *)v17;
        *((unsigned char *)v15 + v1) = *(unsigned char *)(v17 + 240) & 0x7F;
        LOBYTE(v1) = *((unsigned char *)result + 143) + 1;
        *((unsigned char *)result + 143) = v1;
      }
      while (*((unsigned __int8 *)v2 + 32) != v1);
      uint64_t v18 = (uint64_t)v15 + v1;
      char v19 = *(unsigned char *)(v18 - 1);
      uint64_t v5 = (char *)(v18 - 1);
      char v6 = v19;
    }
  }
  else
  {
    uint64_t v7 = *v2;
    *((unsigned char *)result + 143) = 0;
    if (*((unsigned char *)v2 + 32))
    {
      unsigned __int8 v8 = 0;
      char v9 = result + 1;
      do
      {
        v9[v8] = (uint64_t *)v7;
        *((unsigned char *)result + v8 + 128) = *(unsigned char *)(v7 + 240) & 0x7F;
        uint64_t v10 = *((unsigned __int8 *)result + 143);
        unsigned int v11 = *((unsigned __int8 *)v2 + 32);
        if (v10 + 1 != v11)
        {
          uint64_t v12 = v9[v10];
          if ((char)v12[30] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          uint64_t v7 = v12[*((unsigned __int8 *)v12 + 240) + 21];
        }
        unsigned __int8 v8 = v10 + 1;
        *((unsigned char *)result + 143) = v8;
      }
      while (v11 > v8);
      uint64_t v13 = v8 - 1;
    }
    else
    {
      uint64_t v13 = -1;
    }
    uint64_t v5 = (char *)result + v13 + 128;
    char v6 = *v5;
  }
  *uint64_t v5 = v6 - 1;
  return result;
}

const os_unfair_lock *lsl::MemoryManager::lockGuard@<X0>(lsl::Lock *this@<X0>, lsl::Lock **a2@<X8>)
{
  *a2 = this;
  return lsl::Lock::lock(this);
}

uint64_t dyld4::APIs::dladdr(dyld4::APIs *this, int *a2, dl_info *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v32 = 520618000;
  uint64_t v33 = a2;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v32, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dladdr(%p, %p)\n", a2, a3);
  }
  if (a3)
  {
    BOOL v31 = 0;
    long long v29 = 0;
    long long v30 = 0;
    long long v27 = 0;
    long long v28 = 0;
    unint64_t v26 = 0;
    unsigned __int8 v25 = 0;
    if (dyld4::APIs::findImageMappedAt(this, (char *)a2, &v30, &v31, (const char **)&v28, &v27, &v26, &v25, &v29))
    {
      unsigned int v11 = v30;
      a3->dli_fmach_port_name_t name = v28;
      a3->dli_fbase = v11;
      unint64_t v21 = 0;
      if (v11 == (dyld3::MachOLoaded *)a2)
      {
        a3->dli_smach_port_name_t name = "__dso_handle";
        a3->dli_saddr = a2;
      }
      else
      {
        p_dli_smach_port_name_t name = &a3->dli_sname;
        if (dyld3::MachOLoaded::findClosestSymbol(v11, (uint64_t)a2, &a3->dli_sname, &v21))
        {
          uint64_t v13 = (void *)v21;
          a3->dli_saddr = (void *)v21;
          if (a3->dli_fbase == v13)
          {
            *p_dli_smach_port_name_t name = 0;
            a3->dli_saddr = 0;
          }
          else
          {
            uint64_t v14 = *p_dli_sname;
            if (*p_dli_sname && *v14 == 95) {
              *p_dli_smach_port_name_t name = v14 + 1;
            }
          }
        }
        else
        {
          *p_dli_smach_port_name_t name = 0;
          a3->dli_saddr = 0;
          if (v29)
          {
            if ((*((_WORD *)v29 + 2) & 1) == 0)
            {
              uint64_t v17 = (dyld4::PseudoDylib *)*((void *)v29 + 13);
              if (v17) {
                dyld4::PseudoDylib::lookupAddress(v17, a2, a3);
              }
            }
          }
        }
      }
      uint64_t v15 = 1;
    }
    else
    {
      uint64_t v15 = 0;
      if (a2 >= &dword_1A8DFD000 && (unint64_t)a2 < 0x1A8FFD000)
      {
        unint64_t v21 = 0;
        uint64_t v22 = &v21;
        uint64_t v23 = 0x2000000000;
        char v24 = 0;
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000;
        void v20[2] = ___ZN5dyld44APIs6dladdrEPKvP7dl_info_block_invoke;
        v20[3] = &unk_1EFF653F0;
        void v20[5] = &dword_1A8DFD000;
        v20[6] = a2;
        void v20[4] = &v21;
        dyld3::MachOFile::forEachSegment(&dword_1A8DFD000, (uint64_t)v20);
        if (*((unsigned char *)v22 + 24))
        {
          a3->dli_fmach_port_name_t name = "/usr/lib/dyld";
          a3->dli_fbase = &dword_1A8DFD000;
          unint64_t v19 = 0;
          if (dyld3::MachOLoaded::findClosestSymbol((dyld3::MachOLoaded *)&dword_1A8DFD000, (uint64_t)a2, &a3->dli_sname, &v19))
          {
            a3->dli_saddr = (void *)v19;
            dli_smach_port_name_t name = a3->dli_sname;
            if (*dli_sname == 95) {
              a3->dli_smach_port_name_t name = ++dli_sname;
            }
            if (!_platform_strcmp(dli_sname, "_ZN5dyld45startEPKNS_10KernelArgsE"))
            {
              a3->dli_smach_port_name_t name = "start";
              a3->dli_saddr = a2;
            }
          }
        }
        _Block_object_dispose(&v21, 8);
        uint64_t v15 = 0;
      }
    }
    *((void *)&v36 + 1) = v15;
    *(void *)&long long v37 = 0;
    *((void *)&v37 + 1) = a3->dli_fbase;
    *(void *)&long long v38 = 0;
    *((void *)&v38 + 1) = a3->dli_saddr;
    *(void *)&long long v39 = 0;
  }
  else
  {
    uint64_t v15 = 0;
  }
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v32);
  return v15;
}

uint64_t dyld4::JustInTimeLoader::makeJustInTimeLoaderDisk(vm_address_t *a1, uint64_t a2, dyld3 *a3, uint64_t a4, char a5, int a6, uint64_t a7)
{
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = 0;
  int v14 = dyld3::GradedArchs::checksOSBinary(*(dyld3::GradedArchs **)(*(void *)(a2 + 8) + 144));
  uint64_t v15 = *(void *)(a2 + 8);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  uint64_t v18[2] = ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke;
  v18[3] = &unk_1EFF64CD0;
  v18[6] = a3;
  v18[7] = a2;
  v18[4] = &v21;
  v18[5] = a1;
  char v20 = a5;
  int v19 = a6;
  void v18[8] = a4;
  v18[9] = a7;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v15, a1, a3, v14, (uint64_t)v18);
  uint64_t v16 = v22[3];
  _Block_object_dispose(&v21, 8);
  return v16;
}

uint64_t dyld3::GradedArchs::checksOSBinary(dyld3::GradedArchs *this)
{
  for (uint64_t i = 0; i != 48; i += 12)
  {
    int v2 = *(_DWORD *)((char *)this + i);
    if (!v2) {
      break;
    }
    LOBYTE(v2) = *((unsigned char *)this + i + 8);
    if ((_BYTE)v2)
    {
      LOBYTE(v2) = 1;
      return v2 & 1;
    }
  }
  return v2 & 1;
}

unint64_t dyld3::MachOFile::mappedSize(dyld3::MachOFile *this)
{
  unint64_t v3 = 0;
  dyld3::MachOFile::analyzeSegmentsLayout(this, &v3, &v2);
  return v3;
}

void dyld3::MachOFile::analyzeSegmentsLayout(dyld3::MachOFile *this, unint64_t *a2, BOOL *a3)
{
  uint64_t v25 = 0;
  unint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000;
  char v28 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = -1;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  uint64_t v20 = 0;
  uint64_t v13 = 0;
  int v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___ZNK5dyld39MachOFile21analyzeSegmentsLayoutERyRb_block_invoke;
  void v12[3] = &unk_1EFF665C0;
  _OWORD v12[4] = &v25;
  v12[5] = &v21;
  v12[6] = &v17;
  v12[7] = &v13;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v12);
  int v6 = *((_DWORD *)this + 1);
  if (v6 == 33554444 || v6 == 16777228 || v6 == 12 && *((_DWORD *)this + 3) != 11 && *((_DWORD *)this + 2) == 12) {
    uint64_t v7 = 0x3FFFLL;
  }
  else {
    uint64_t v7 = 4095;
  }
  unint64_t v8 = (v18[3] - v22[3] + v7) & ~v7;
  uint64_t v9 = v14[3];
  *a2 = v8;
  if (*((unsigned char *)v26 + 24)) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v8 == v9;
  }
  BOOL v11 = !v10;
  *a3 = v11;
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
}

uint64_t dyld4::APIs::_dyld_launch_mode(dyld4::APIs *this)
{
  unint64_t v1 = *((void *)this + 3);
  int v2 = *(_WORD *)(v1 + 4) & 1;
  if (*((unsigned char *)this + 1016))
  {
    int v3 = v2 | 4;
    if (!*((unsigned char *)this + 1136)) {
      int v3 = *(_WORD *)(v1 + 4) & 1;
    }
  }
  else
  {
    int v3 = *(_WORD *)(v1 + 4) & 1;
  }
  uint64_t v4 = *((void *)this + 1);
  unint64_t v5 = *(void *)(v4 + 240);
  BOOL v6 = v1 <= v5 || v5 == 0;
  int v7 = v3 | 8;
  if (v6) {
    int v7 = v3;
  }
  if (v2) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = v3;
  }
  if (*((void *)this + 22)) {
    uint64_t v9 = v8 | 0x20;
  }
  else {
    uint64_t v9 = v8;
  }
  if (v5)
  {
    if (*(void *)(v5 + 104) == 1) {
      uint64_t v9 = v9 | 0x40;
    }
    else {
      uint64_t v9 = v9;
    }
  }
  if (*(unsigned char *)(v4 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_launch_mode() => 0x%08X\n", v9);
  }
  return v9;
}

BOOL dyld4::APIs::dyld_process_is_restricted(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(unsigned char *)(v1 + 204)) {
    return *(unsigned char *)(v1 + 186) == 0;
  }
  dyld4::RuntimeState::log(this, "dyld_process_is_restricted()");
  uint64_t v3 = *((void *)this + 1);
  int v4 = *(unsigned __int8 *)(v3 + 204);
  int v5 = *(unsigned __int8 *)(v3 + 186);
  BOOL v6 = v5 == 0;
  if (v4) {
    dyld4::RuntimeState::log(this, " => %d\n", v5 == 0);
  }
  return v6;
}

void dyld4::RuntimeState::loadAppPrebuiltLoaderSet(dyld4::RuntimeState *this)
{
  if (dyld4::SyscallDelegate::fileExists(*((void *)this + 1), *((dyld3 **)this + 123), 0, 0))
  {
    uint64_t v20 = &v22;
    long long v21 = xmmword_1A8E70420;
    if (dyld4::RuntimeState::buildBootToken((uint64_t)this, (uint64_t *)&v20))
    {
      if (dyld4::RuntimeState::fileAlreadyHasBootToken((uint64_t)this, v2, (uint64_t)&v20))
      {
        Diagnostics::Diagnostics((Diagnostics *)&v19);
        Only = dyld4::SyscallDelegate::mapFileReadOnly(*((void *)this + 1), (vm_address_t *)&v19, *((dyld3 **)this + 123), 0, 0, 0, 0);
        *((void *)this + 1++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = Only;
        if (Only)
        {
          dyld4::RuntimeState::allocateProcessArrays(this, *((unsigned int *)Only + 3));
          **((void **)this + 126) = *(void *)(*((void *)this + 1) + 8);
          if (*((void *)this + 124))
          {
            int v11 = 520552504;
            long long v12 = 0u;
            long long v13 = 0u;
            long long v14 = 0u;
            long long v15 = 0u;
            long long v16 = 0u;
            long long v17 = 0u;
            uint64_t v18 = 0;
            dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, v4, v5, v6, v7, v8, v9, v10);
            if ((dyld4::PrebuiltLoaderSet::isValid(*((dyld4::PrebuiltLoaderSet **)this + 124), this) & 1) == 0)
            {
              dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), *((void **)this + 124), *(unsigned int *)(*((void *)this + 124) + 8));
              *((void *)this + 1++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
            }
            dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
          }
        }
        mach_o::Error::~Error(&v19);
      }
      else if (*(unsigned char *)(*((void *)this + 1) + 207))
      {
        dyld4::RuntimeState::log(this, "existing PrebuiltLoaderSet file not used because boot-token differs\n");
      }
    }
    else if (*(unsigned char *)(*((void *)this + 1) + 207))
    {
      dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because main executable is not codesigned\n");
    }
  }
}

char *DyldSharedCache::findLaunchLoaderSetWithCDHash(DyldSharedCache *this, const char *__s)
{
  if (!__s || _platform_strlen(__s) > 0x7F) {
    return 0;
  }
  strcpy(__dst, "/cdhash/");
  strlcat(__dst, __s, 0x8CuLL);
  return DyldSharedCache::findLaunchLoaderSet(this, __dst);
}

uint64_t dyld4::PrebuiltLoaderSet::isValid(dyld4::PrebuiltLoaderSet *this, dyld4::RuntimeState *a2)
{
  if (!dyld4::PrebuiltLoaderSet::validHeader(this, a2)) {
    return 0;
  }
  uint64_t v5 = *((unsigned int *)this + 7);
  if (v5)
  {
    long long v6 = *(_OWORD *)((char *)this + v5);
    long long v30 = v6;
    uint64_t v7 = *((void *)a2 + 1);
    uint64_t v8 = *(DyldSharedCache **)(v7 + 240);
    if (!v8)
    {
      if (*(unsigned char *)(v7 + 207)) {
        dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because process does not have a dyld cache\n", v4, *(double *)&v6, this);
      }
      return 0;
    }
    __n128 v27 = 0uLL;
    *(void *)&double v10 = DyldSharedCache::getUUID(v8, &v27).n128_u64[0];
    if ((void)v30 != v27.n128_u64[0] || *((void *)&v30 + 1) != v27.n128_u64[1])
    {
      if (*(unsigned char *)(*((void *)a2 + 1) + 207)) {
        dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because cache UUID does not match\n", v9, v10, this);
      }
      return 0;
    }
  }
  v27.n128_u64[0] = 0;
  v27.n128_u64[1] = (unint64_t)&v27;
  uint64_t v28 = 0x2000000000;
  char v29 = 0;
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 0x40000000;
  void v26[2] = ___ZNK5dyld417PrebuiltLoaderSet7isValidERNS_12RuntimeStateE_block_invoke;
  void v26[3] = &unk_1EFF64EC0;
  v26[5] = this;
  v26[6] = a2;
  v26[4] = &v27;
  dyld4::PrebuiltLoaderSet::forEachMustBeMissingPath((size_t)this, (uint64_t)v26);
  uint64_t v18 = 0;
  if (!*(unsigned char *)(v27.n128_u64[1] + 24))
  {
    unsigned int v19 = *((_DWORD *)this + 3);
    if (!v19) {
      goto LABEL_20;
    }
    unsigned int v20 = 0;
    int v21 = 0;
    do
    {
      if (v19 <= (unsigned __int16)v20) {
        dyld4::RuntimeState::findPrebuiltLoader();
      }
      v21 |= !dyld4::PrebuiltLoader::isValid((dyld4::PrebuiltLoaderSet *)((char *)this+ *(unsigned int *)((char *)this+ 4 * (unsigned __int16)v20+++ *((unsigned int *)this + 4))), a2, v12, v13, v14, v15, v16, v17);
      unsigned int v19 = *((_DWORD *)this + 3);
    }
    while (v20 < v19);
    if (v21)
    {
      uint64_t v18 = 0;
    }
    else
    {
LABEL_20:
      uint64_t v22 = *(unsigned int *)(*((void *)a2 + 1) + 392);
      if (v22)
      {
        uint64_t v23 = (unsigned __int8 *)*((void *)a2 + 122);
        do
        {
          if (*v23++) {
            ++v19;
          }
          --v22;
        }
        while (v22);
      }
      *((_DWORD *)a2 + 255) = v19;
      uint64_t v18 = 1;
    }
  }
  _Block_object_dispose(&v27, 8);
  return v18;
}

void dyld4::APIs::runAllInitializersForMain(dyld4::APIs *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (!*(unsigned char *)(v2 + 169) || *(_DWORD *)(v2 + 164) != 3) {
    dyld4::SyscallDelegate::disablePageInLinking((dyld4::SyscallDelegate *)v2);
  }
  if (!*((void *)this + 19))
  {
    dyld4::Loader::beginInitializers(*((dyld4::Loader **)this + 12), this);
    dyld4::Loader::runInitializers(*((dyld4::Loader **)this + 12), this);
    *((unsigned char *)this + 656) = 1;
  }
  dyld4::ExternallyViewableState::setLibSystemInitialized((dyld4::APIs *)((char *)this + 536));
  dyld4::RuntimeState::notifyObjCInit(this, *((const dyld4::Loader **)this + 12));
  uint64_t v9 = *((void *)this + 6);
  if (v9)
  {
    uint64_t v10 = 0;
    unsigned int v11 = 1;
    do
    {
      uint64_t v12 = *(dyld4::Loader **)(*((void *)this + 5) + 8 * v10);
      if ((*((_WORD *)v12 + 2) & 0x2000) != 0)
      {
        uint64_t v13 = *(const dyld4::Loader **)(*((void *)this + 5) + 8 * v10);
        dyld4::Loader::beginInitializers(v12, this);
        dyld4::RuntimeState::notifyObjCInit(this, v13);
        dyld4::Loader::runInitializers(v13, this);
        uint64_t v9 = *((void *)this + 6);
      }
      uint64_t v10 = v11;
      BOOL v14 = v9 == v11++;
    }
    while (!v14);
    if (v9)
    {
      uint64_t v15 = 0;
      unsigned int v16 = 1;
      do
      {
        uint64_t v17 = *(dyld4::Loader **)(*((void *)this + 5) + 8 * v15);
        dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(v17, (uint64_t)this, v3, v4, v5, v6, v7, v8);
        uint64_t v18 = (dyld3::MachOFile *)dyld4::Loader::analyzer(v17, this);
        if (dyld3::MachOFile::isMainExecutable(v18)) {
          break;
        }
        uint64_t v15 = v16;
        BOOL v14 = *((void *)this + 6) == v16++;
      }
      while (!v14);
    }
  }
}

uint64_t dyld4::SyscallDelegate::disablePageInLinking(dyld4::SyscallDelegate *this)
{
  return __shared_region_check_np((uint64_t *)0xFFFFFFFFFFFFFFFFLL);
}

const void *dyld4::APIs::_dyld_get_swift_prespecialized_data(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(unsigned char *)(v1 + 97)) {
    return 0;
  }
  if (*(unsigned char *)(v1 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_swift_prespecialized_data()\n");
    uint64_t v1 = *((void *)this + 1);
  }
  uint64_t v3 = *(DyldSharedCache **)(v1 + 240);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = DyldSharedCache::swiftOpt(v3);
  if (!v4) {
    return 0;
  }
  if (*(_DWORD *)v4 < 2u) {
    return 0;
  }
  uint64_t v5 = *(void *)(v4 + 32);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = (const void *)(*(void *)(v6 + 240) + v5);
  if (*(unsigned char *)(v6 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_swift_prespecialized_data() => %p\n", v7);
  }
  return v7;
}

void dyld4::RuntimeState::initializeClosureMode(dyld4::RuntimeState *this)
{
  uint64_t v2 = (void *)((char *)this + 968);
  long long v3 = 0uLL;
  *(_OWORD *)((char *)this + 968) = 0u;
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)(v4 + 240);
  if (v5)
  {
    if (*(_DWORD *)(v5 + 16) >= 0x170u)
    {
      uint64_t v6 = (unsigned int *)(*(void *)(v4 + 264) + *(void *)(v5 + 328));
      int valid = dyld4::PrebuiltLoaderSet::validHeader((dyld4::PrebuiltLoaderSet *)v6, this);
      long long v3 = 0uLL;
      if (valid)
      {
        *((void *)this + 121) = v6;
        uint64_t v8 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), v6[3]);
        *((void *)this + 122) = v8;
        bzero(v8, *(unsigned int *)(*((void *)this + 121) + 12));
        long long v3 = 0uLL;
      }
    }
  }
  *((void *)this + 123) = 0;
  *((unsigned char *)this + 1016) = 0;
  *(_OWORD *)((char *)this + 100dyld4::halt((char *)__format, 0) = v3;
  uint64_t v9 = *((void *)this + 1);
  if (!*(void *)(v9 + 240))
  {
    if (*(unsigned char *)(v9 + 207)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoaders not being used because there is no dyld shared cache\n");
    }
    goto LABEL_33;
  }
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp((dyld4::ProcessConfig::PathOverrides *)(v9 + 400)))
  {
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoaders not being used because DYLD_ env vars are set\n");
    }
    goto LABEL_33;
  }
  if (!*v2 || !*((void *)this + 122))
  {
LABEL_33:
    int v20 = 0;
    int v19 = 0;
    uint64_t v22 = (dyld4::PrebuiltLoaderSet **)((char *)this + 992);
    goto LABEL_34;
  }
  LaunchLoaderSet = DyldSharedCache::findLaunchLoaderSet(*(DyldSharedCache **)(*((void *)this + 1) + 240), *(const char **)(*((void *)this + 1) + 16));
  uint64_t v11 = *((void *)this + 1);
  if (LaunchLoaderSet)
  {
    uint64_t v12 = (dyld4::PrebuiltLoaderSet *)LaunchLoaderSet;
LABEL_18:
    char v16 = 0;
    goto LABEL_19;
  }
  if (!_platform_strncmp(*(const char **)(v11 + 16), "/System/", 8uLL))
  {
    uint64_t v50 = *(DyldSharedCache **)(v11 + 240);
    uint64_t v51 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v11 + 8), "executable_cdhash");
    LaunchLoaderSetWithCDHash = DyldSharedCache::findLaunchLoaderSetWithCDHash(v50, v51);
    uint64_t v11 = *((void *)this + 1);
    if (LaunchLoaderSetWithCDHash)
    {
      uint64_t v12 = (dyld4::PrebuiltLoaderSet *)LaunchLoaderSetWithCDHash;
      long long v54 = dyld4::Loader::leafName(*(dyld4::Loader **)(v11 + 16), v53);
      if (!*((_DWORD *)v12 + 3)) {
        dyld4::RuntimeState::findPrebuiltLoader();
      }
      long long v55 = (const char *)v54;
      uint64_t v56 = (dyld4::Loader *)dyld4::PrebuiltLoader::path((uint64_t)v12 + *(unsigned int *)((char *)v12
                                                                                        + *((unsigned int *)v12 + 4)));
      uint64_t v58 = dyld4::Loader::leafName(v56, v57);
      int v59 = _platform_strcmp(v55, (const char *)v58);
      uint64_t v11 = *((void *)this + 1);
      if (!v59) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v13 = *(DyldSharedCache **)(v11 + 240);
  BOOL v14 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v11 + 8), "executable_cdhash");
  BOOL hasLaunchLoaderSetWithCDHash = DyldSharedCache::hasLaunchLoaderSetWithCDHash(v13, v14);
  uint64_t v11 = *((void *)this + 1);
  if (hasLaunchLoaderSetWithCDHash)
  {
    uint64_t v12 = 0;
    goto LABEL_18;
  }
  unsigned int v21 = *(_DWORD *)(v11 + 68);
  if (v21 <= 0xB && (char v16 = 1, ((1 << v21) & 0x81C) != 0))
  {
    uint64_t v12 = 0;
  }
  else
  {
    dyld4::ProcessConfig::Process::appleParam((const char ***)(v11 + 8), "executable_cdhash");
    uint64_t v12 = 0;
    char v16 = 0;
    uint64_t v11 = *((void *)this + 1);
  }
LABEL_19:
  if (!*(unsigned char *)(v11 + 169)) {
    goto LABEL_24;
  }
  uint64_t v17 = dyld4::ProcessConfig::Process::environ((const char ***)(v11 + 8), "DYLD_USE_CLOSURES");
  if (!v17) {
    goto LABEL_24;
  }
  uint64_t v18 = v17;
  if (!_platform_strcmp(v17, "0"))
  {
    *uint64_t v2 = 0;
    goto LABEL_33;
  }
  if (_platform_strcmp(v18, "1"))
  {
    if (!_platform_strcmp(v18, "2"))
    {
      uint64_t v66 = *((void *)this + 1);
      unsigned int v67 = *(_DWORD *)(v66 + 68) - 2;
      if (v67 >= 0xA || ((0x207u >> v67) & 1) == 0)
      {
        dyld4::ProcessConfig::Process::appleParam((const char ***)(v66 + 8), "executable_cdhash");
        if (*(unsigned char *)(*((void *)this + 1) + 207)) {
          dyld4::RuntimeState::log(this, "PrebuiltLoaders cannot be used with unsigned or old format programs\n");
        }
      }
      int v20 = 0;
      int v19 = 1;
LABEL_26:
      dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(this, 0);
      if (*((void *)this + 123))
      {
        dyld4::RuntimeState::loadAppPrebuiltLoaderSet(this);
        goto LABEL_73;
      }
      goto LABEL_72;
    }
LABEL_24:
    int v19 = 0;
    if ((v16 & 1) == 0)
    {
      int v20 = 0;
      goto LABEL_73;
    }
    int v20 = 1;
    goto LABEL_26;
  }
  uint64_t v60 = *((void *)this + 1);
  unsigned int v61 = *(_DWORD *)(v60 + 68) - 2;
  if (v61 >= 0xA || ((0x207u >> v61) & 1) == 0)
  {
    dyld4::ProcessConfig::Process::appleParam((const char ***)(v60 + 8), "executable_cdhash");
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoaders cannot be used with unsigned or old format programs\n");
    }
    int v19 = 0;
LABEL_72:
    int v20 = 0;
    goto LABEL_73;
  }
  int v19 = 0;
  int v20 = 1;
LABEL_73:
  uint64_t v22 = (dyld4::PrebuiltLoaderSet **)((char *)this + 992);
  uint64_t v23 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 124);
  if (!v12 || v23)
  {
LABEL_35:
    if (v23)
    {
      uint64_t v24 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcSelectorMap(v23);
      if (v24)
      {
        uint64_t v25 = *v24;
        unint64_t v26 = (char *)v24 + 4 * *v24;
        uint64_t v27 = *((void *)v26 + 1);
        *((void *)this + 43) = v24 + 1;
        *((void *)this + 44) = v25;
        *((void *)this + 45) = v25;
        *((void *)this + 46) = v26 + 16;
        *((void *)this + 47) = v27;
        *((void *)this + 48) = v27;
      }
      uint64_t v28 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcClassMap(*v22);
      if (v28)
      {
        uint64_t v29 = *v28;
        long long v30 = &v28[*v28];
        uint64_t v31 = v30[1];
        *((void *)this + 49) = v28 + 1;
        *((void *)this + 5dyld4::halt((char *)__format, 0) = v29;
        *((void *)this + 51) = v29;
        *((void *)this + 52) = v30 + 2;
        *((void *)this + 53) = v31;
        *((void *)this + 54) = v31;
      }
      int v32 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcProtocolMap(*v22);
      if (v32)
      {
        uint64_t v33 = *v32;
        long long v34 = &v32[*v32];
        uint64_t v35 = v34[1];
        *((void *)this + 55) = v32 + 1;
        *((void *)this + 56) = v33;
        *((void *)this + 57) = v33;
        *((void *)this + 58) = v34 + 2;
        *((void *)this + 59) = v35;
        *((void *)this + 6dyld4::halt((char *)__format, 0) = v35;
      }
      uint64_t v36 = dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(*v22);
      if (v36)
      {
        long long v37 = (void *)v36;
        long long v38 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x68uLL);
        *((void *)this + 61) = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)v38, (uint64_t)this, v37);
      }
      uint64_t v39 = dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(*v22);
      if (v39)
      {
        uint64_t v40 = (void *)v39;
        uint64_t v41 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x68uLL);
        *((void *)this + 62) = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)v41, (uint64_t)this, v40);
      }
      uint64_t v42 = dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(*v22);
      if (v42)
      {
        long long v43 = (void *)v42;
        long long v44 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x68uLL);
        *((void *)this + 63) = dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap((uint64_t)v44, (uint64_t)this, v43);
      }
    }
    long long v45 = *v22;
    if (!*v22)
    {
      *((unsigned char *)this + 1016) = v20;
      if (v20) {
        goto LABEL_50;
      }
      long long v45 = 0;
    }
LABEL_54:
    *((unsigned char *)this + 1017) = 0;
    if (!v19) {
      return;
    }
    long long v46 = (char *)this + 1017;
    if (v45) {
      return;
    }
    goto LABEL_56;
  }
  if (!dyld4::PrebuiltLoaderSet::validHeader(v12, this)) {
    goto LABEL_34;
  }
  dyld4::RuntimeState::allocateProcessArrays(this, *((unsigned int *)v12 + 3));
  **((void **)this + 126) = *(void *)(*((void *)this + 1) + 8);
  if (!*((_DWORD *)v12 + 3)) {
    dyld4::RuntimeState::findPrebuiltLoader();
  }
  long long v62 = (dyld4::PrebuiltLoaderSet *)((char *)v12 + *(unsigned int *)((char *)v12 + *((unsigned int *)v12 + 4)));
  uint64_t v63 = *((void *)this + 1);
  if (*(unsigned char *)(v63 + 207))
  {
    dyld4::RuntimeState::log(this, "PrebuiltLoader %p found for %s in the dyld cache\n", (char *)v12 + *(unsigned int *)((char *)v12 + *((unsigned int *)v12 + 4)), *(const char **)(v63 + 16));
    uint64_t v63 = *((void *)this + 1);
  }
  long long v64 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v63 + 8), "executable_cdhash");
  if (!v64 || (unsigned int v68 = 0, !hexStringToBytes(v64, v69, 0x14u, &v68)) || !dyld4::PrebuiltLoader::recordedCdHashIs(v62, v69))
  {
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoader %p not used because cdHash does not match\n", v62);
    }
    goto LABEL_34;
  }
  *((void *)this + 1++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12;
  if (dyld4::PrebuiltLoaderSet::isValid(v12, this))
  {
LABEL_34:
    uint64_t v23 = *v22;
    goto LABEL_35;
  }
  if (*(unsigned char *)(*((void *)this + 1) + 207))
  {
    uint64_t v65 = (const char *)dyld4::PrebuiltLoader::path((uint64_t)v62);
    dyld4::RuntimeState::log(this, "PrebuiltLoader %p not used because Loader for %s is invalid\n", v12, v65);
  }
  *((void *)this + 1++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  *((unsigned char *)this + 1016) = v20;
  if ((v20 & 1) == 0)
  {
    long long v45 = 0;
    LOBYTE(v2dyld4::halt((char *)__format, 0) = 0;
    goto LABEL_54;
  }
LABEL_50:
  dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(this, 1);
  *((unsigned char *)this + 1017) = 0;
  if (!v19) {
    return;
  }
  long long v46 = (char *)this + 1017;
  LOBYTE(v2dyld4::halt((char *)__format, 0) = 1;
  if (*v22) {
    return;
  }
LABEL_56:
  uint64_t v47 = *((void *)this + 1);
  char v48 = v20 ^ 1;
  if (!*(void *)(v47 + 240)) {
    char v48 = 1;
  }
  if ((v48 & 1) == 0)
  {
    long long v49 = (const char *)*((void *)this + 123);
    if (v49)
    {
      *long long v46 = 1;
      if (*(unsigned char *)(v47 + 207)) {
        dyld4::RuntimeState::log(this, "PrebuiltLoaderSet required for '%s' but not found at '%s'\n", *(const char **)(v47 + 136), v49);
      }
    }
  }
}

uint64_t dyld4::PrebuiltLoaderSet::validHeader(dyld4::PrebuiltLoaderSet *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this == 1936733284)
  {
    if (*((_DWORD *)this + 1) == 389703534) {
      return 1;
    }
    if (*(unsigned char *)(*((void *)a2 + 1) + 207)) {
      dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because versionHash (0x%08X) does not match dyld (0x%08X)\n", (const char *)a2, this, *((unsigned int *)this + 1), 389703534);
    }
  }
  else if (*(unsigned char *)(*((void *)a2 + 1) + 207))
  {
    dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because magic at start does not match\n", (const char *)a2, this);
  }
  return 0;
}

char *DyldSharedCache::findLaunchLoaderSet(DyldSharedCache *this, const char *a2)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  if (v2 < 0x168) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 44);
  if (!v4) {
    return 0;
  }
  uint64_t v6 = (char *)this - *(void *)((char *)this + v2);
  uint64_t v7 = (const unsigned __int8 **)&v6[v4];
  uint64_t v8 = (Diagnostics *)&v6[v4 + *((unsigned int *)this + 90)];
  uint64_t v9 = *((void *)this + 42);
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  uint64_t v15 = dyld3::MachOFile::trieWalk((vm_address_t *)&v16, v7, v8, (const unsigned __int8 *)a2, v10);
  if (v15
    && (unint64_t v12 = dyld3::MachOFile::read_uleb128((vm_address_t *)&v16, &v15, (const unsigned __int8 **)v8, v11), v12 < *((void *)this + 43)))
  {
    uint64_t v13 = &v6[v9 + v12];
  }
  else
  {
    uint64_t v13 = 0;
  }
  mach_o::Error::~Error(&v16);
  return v13;
}

const char *dyld4::ProcessConfig::Process::appleParam(const char ***this, char *a2)
{
  return _simple_getenv(this[15], a2);
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(uint64_t a1, uint64_t a2, void *a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v5 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)a1 = *a3;
  *(void *)(a1 + 8) = a3[1];
  uint64_t v6 = a3 + 3;
  unint64_t v7 = a3[2];
  *uint64_t v5 = a3 + 3;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
  if (v7)
  {
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v5, v7);
    uint64_t v8 = *(void *)(a1 + 72);
    *(void *)(a1 + 32) = v7;
    if (v8) {
      dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap();
    }
  }
  uint64_t v9 = &v6[v7];
  unint64_t v10 = *v9;
  *(void *)(a1 + 56) = v9 + 1;
  *(void *)(a1 + 64) = v10;
  if (v10)
  {
    dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve((void *)(a1 + 56), v10);
    *(void *)(a1 + 72) = v10;
  }
  *(void *)(a1 + 96) = a2;
  return a1;
}

void *dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    long long v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 8 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    __n128 result = memmove((void *)v3[3], *v3, 8 * (void)v3[2]);
    uint64_t v8 = (const void *)((unint64_t)v3[4] >> 3);
    DyldSharedCache *v3 = v3[3];
    v3[1] = v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

void *dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    long long v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 32 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    __n128 result = memmove((void *)v3[3], *v3, 32 * (void)v3[2]);
    uint64_t v8 = (const void *)((unint64_t)v3[4] >> 5);
    DyldSharedCache *v3 = v3[3];
    v3[1] = v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

dyld4::ProcessConfig *dyld4::ProcessConfig::ProcessConfig(dyld4::ProcessConfig *this, const dyld4::KernelArgs *a2, dyld4::SyscallDelegate *a3, lsl::Lock **a4)
{
  vm_size_t v7 = (const char ***)((char *)this + 8);
  dyld4::ProcessConfig::Process::Process((dyld4::ProcessConfig *)((char *)this + 8), a2, a3, a4);
  dyld4::ProcessConfig::Security::Security((dyld4::ProcessConfig *)((char *)this + 168), v7, a3);
  dyld4::ProcessConfig::Logging::Logging((dyld4::ProcessConfig *)((char *)this + 200), v7, (dyld4::ProcessConfig *)((char *)this + 168), a3);
  dyld4::ProcessConfig::DyldCache::DyldCache((dyld4::ProcessConfig *)((char *)this + 240), (dyld4::ProcessConfig::Process *)v7, (dyld4::ProcessConfig *)((char *)this + 168), (dyld4::ProcessConfig *)((char *)this + 200), a3, a4);
  uint64_t v8 = dyld4::ProcessConfig::PathOverrides::PathOverrides((dyld4::ProcessConfig *)((char *)this + 400), (const dyld4::ProcessConfig::Process *)v7, (dyld4::ProcessConfig *)((char *)this + 168), (dyld4::ProcessConfig *)((char *)this + 200), (dyld4::ProcessConfig *)((char *)this + 240), a3, a4);
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp(v8)) {
    *((unsigned char *)this + 399) = 1;
  }
  return this;
}

BOOL dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp(dyld4::ProcessConfig::PathOverrides *this)
{
  return *(void *)this
      || *((void *)this + 1)
      || *((void *)this + 4)
      || *((void *)this + 5)
      || *((void *)this + 12)
      || *((void *)this + 13)
      || *((void *)this + 11)
      || *((void *)this + 10)
      || *((void *)this + 6)
      || *((void *)this + 7) != 0;
}

dyld4::ProcessConfig::DyldCache *dyld4::ProcessConfig::DyldCache::DyldCache(dyld4::ProcessConfig::DyldCache *this, dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, const dyld4::ProcessConfig::Logging *a4, dyld4::SyscallDelegate *a5, lsl::Lock **a6)
{
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  unint64_t v12 = *((void *)a2 + 11);
  dyld4::CacheFinder::CacheFinder((dyld4::CacheFinder *)v55, a2, a4, a5);
  if (*((_DWORD *)a2 + 36) == 1)
  {
    if (*((unsigned char *)a3 + 1))
    {
      unint64_t v13 = ((unint64_t)(*((void *)a2 + 11) | v12) >> 2) & 1;
      BOOL v14 = (*((void *)a2 + 11) & 5) == 1;
    }
    else
    {
      LOBYTE(v13) = 0;
      BOOL v14 = 1;
    }
  }
  else
  {
    BOOL v14 = v12 & 1;
    unint64_t v13 = (v12 >> 2) & 1;
  }
  uint64_t v15 = _simple_getenv(*((const char ***)a2 + 14), "DYLD_SHARED_REGION");
  char v16 = v15;
  BOOL v17 = 0;
  LODWORD(v53) = v55[0];
  if (*((unsigned char *)a3 + 19) && v15) {
    BOOL v17 = _platform_strcmp(v15, "private") == 0;
  }
  BYTE4(v53) = v17;
  char v18 = dyld4::PrebuiltLoader::hiddenFromFlat(a5);
  BOOL v24 = 0;
  BYTE5(v53) = v18;
  WORD3(v53) = *((unsigned __int8 *)a4 + 1);
  BYTE8(v53) = *((unsigned char *)a2 + 150);
  BYTE9(v53) = v14;
  BYTE10(v53) = v13;
  BYTE11(v53) = *((unsigned char *)a2 + 148);
  if (*((int *)a2 + 39) >= 2) {
    BOOL v24 = !dyld4::SyscallDelegate::sandboxBlockedPageInLinking(a5);
  }
  BYTE12(v53) = v24;
  int v54 = *((_DWORD *)a2 + 15);
  *(void *)this = 0;
  *((_WORD *)this + 78) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((unsigned char *)this + 159) = 1;
  *((unsigned char *)this + 158) = v17;
  *(_OWORD *)((char *)this + 4dyld4::halt((char *)__format, 0) = 0u;
  uint64_t v25 = (size_t *)((char *)this + 40);
  *((void *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  char v50 = 0;
  uint64_t v49 = 0;
  v51[0] = 0;
  v51[1] = 0;
  char v52 = 0;
  size_t DyldCache = (size_t)dyld4::SyscallDelegate::getDyldCache((uint64_t)a5, &v53, (uint64_t)&v47, v19, v20, v21, v22, v23);
  uint64_t v34 = v47;
  if (v47)
  {
    *(void *)this = v47;
    *(_OWORD *)((char *)this + 8) = *(_OWORD *)v51;
    *((unsigned char *)this + 156) = v52;
    *((unsigned char *)this + 157) = *(unsigned char *)(v34 + 221) & 1;
    *((void *)this + 3) = v48;
    dyld4::ProcessConfig::DyldCache::setPlatformOSVersion(this, a2);
    *((void *)this + 4) = DyldSharedCache::unslidLoadAddress(*(DyldSharedCache **)this);
    *((void *)this + 6) = DyldSharedCache::objcHeaderInfoRO(*(DyldSharedCache **)this);
    *((void *)this + 7) = DyldSharedCache::objcHeaderInfoRW(*(DyldSharedCache **)this);
    *((void *)this + 8) = DyldSharedCache::objcSelectorHashTable(*(DyldSharedCache **)this);
    *((void *)this + 9) = DyldSharedCache::objcClassHashTable(*(DyldSharedCache **)this);
    *((void *)this + 1dyld4::halt((char *)__format, 0) = DyldSharedCache::objcProtocolHashTable(*(DyldSharedCache **)this);
    *((void *)this + 13) = DyldSharedCache::swiftOpt(*(DyldSharedCache **)this);
    *((_DWORD *)this + 38) = DyldSharedCache::imagesCount(*(DyldSharedCache **)this);
    *((void *)this + 14) = 0;
    uint64_t v35 = *((void *)this + 6);
    uint64_t v36 = *(DyldSharedCache **)this;
    if (v35) {
      *((void *)this + 14) = v35 - (void)v36 + *((void *)this + 4);
    }
    *((void *)this + 15) = 0;
    uint64_t v37 = DyldSharedCache::patchTable(v36);
    long long v38 = *(char **)this;
    uint64_t v39 = *(void *)(*(void *)this + 152);
    *((void *)this + 16) = v37;
    *((void *)this + 17) = v39;
    if (!BYTE8(v53))
    {
      *(void *)__s = _NSConcreteStackBlock;
      uint64_t v58 = 0x40000000;
      int v59 = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke;
      uint64_t v60 = &__block_descriptor_tmp_72;
      unsigned int v61 = this;
      long long v62 = a4;
      int v64 = 19;
      uint64_t v63 = a5;
      DyldSharedCache::forEachCache(v38, (uint64_t)__s);
    }
    if (!_simple_getenv(*((const char ***)a2 + 15), "dyld_hw_tpro") || vm_page_size != 0x4000 || *((unsigned char *)this + 158))
    {
      uint64_t v40 = *(unsigned int **)this;
      v46[0] = _NSConcreteStackBlock;
      v46[1] = 0x40000000;
      v46[2] = ___ZN5dyld413ProcessConfig9DyldCacheC2ERNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke;
      v46[3] = &__block_descriptor_tmp_57;
      unsigned int v46[4] = this;
      DyldSharedCache::forEachTPRORegion(v40, (uint64_t)v46);
    }
    if (!*((unsigned char *)this + 156)) {
      *((unsigned char *)this + 159) = 0;
    }
    fsid_t v41 = (fsid_t)v51[0];
    if (v51[0] && v51[1])
    {
      size_t DyldCache = dyld4::SyscallDelegate::fsgetpath(a5, __s, 0x400uLL, v41, v51[1]);
      if (DyldCache != -1)
      {
        size_t DyldCache = (size_t)lsl::Allocator::strdup(a6, __s);
        size_t *v25 = DyldCache;
      }
      goto LABEL_31;
    }
    long long v45 = "dyld shared region dynamic config data was not set\n";
LABEL_39:
    dyld4::halt(v45, 0);
  }
  if (v50) {
    size_t DyldCache = dyld4::console((dyld4 *)"dyld cache '%s' not loaded: %s\n", v27, *v25, v49);
  }
  if (v16)
  {
    size_t DyldCache = _platform_strcmp(v16, "private");
    if (!DyldCache && !v50)
    {
      long long v45 = "dyld private shared cache could not be found\n";
      goto LABEL_39;
    }
  }
LABEL_31:
  uint64_t v42 = v56;
  if (v56 != -1)
  {
    size_t DyldCache = dyld4::SyscallDelegate::getpath(a5, v56, __s);
    if (DyldCache)
    {
      long long v43 = lsl::Allocator::strdup(a6, __s);
      size_t DyldCache = _platform_strlen(v43);
      *((void *)this + 11) = v43;
      *((void *)this + 12) = DyldCache;
    }
  }
  if (*((_DWORD *)a2 + 36) == 1) {
    dyld4::ProcessConfig::DyldCache::setupDyldCommPage((dyld4::ProcessConfig::DyldCache *)DyldCache, a2, a3, a5);
  }
  dyld4::CacheFinder::~CacheFinder(v55, v42, v28, v29, v30, v31, v32, v33);
  return this;
}

uint64_t DyldSharedCache::swiftOpt(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) < 0x181u) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 47);
  if (v2) {
    return (uint64_t)this + v2;
  }
  else {
    return 0;
  }
}

BOOL dyld4::SyscallDelegate::getpath(dyld4::SyscallDelegate *this, int a2, char *a3)
{
  return fcntl(a2, 50, a3) == 0;
}

DyldSharedCache *dyld4::SyscallDelegate::getDyldCache(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v15 = *a2;
  int v16 = *((_DWORD *)a2 + 4);
  BYTE5(v15) = 0;
  dyld3::loadDyldCache((uint64_t)&v15, (void *)a3, a3, a4, a5, a6, a7, a8);
  __n128 result = *(DyldSharedCache **)a3;
  if (*(void *)a3)
  {
    __n128 v17 = 0uLL;
    DyldSharedCache::getUUID(result, &v17);
    fsobj_id v10 = *(fsobj_id *)(a3 + 32);
    return (DyldSharedCache *)dyld3::kdebug_trace_dyld_cache(*(unsigned __int8 (**)[16])(a3 + 40), v10, *(void **)a3, &v17, v11, v12, v13, v14);
  }
  return result;
}

dyld3::MachOLoaded *DyldSharedCache::objcSelectorHashTable(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 24);
    long long v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }
  else
  {
    __n128 result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 2);
    long long v3 = (char *)result + v2;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcProtocolHashTable(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 40);
    long long v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }
  else
  {
    __n128 result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 9);
    long long v3 = (char *)result + v2;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcClassHashTable(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 32);
    long long v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }
  else
  {
    __n128 result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 8);
    long long v3 = (char *)result + v2;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcHeaderInfoRW(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 16);
    long long v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }
  else
  {
    __n128 result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 6);
    long long v3 = (char *)result + v2;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcHeaderInfoRO(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 8);
    long long v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }
  else
  {
    __n128 result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 3);
    long long v3 = (char *)result + v2;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

uint64_t DyldSharedCache::imagesCount(DyldSharedCache *this)
{
  uint64_t v1 = 28;
  if (*((_DWORD *)this + 4) > 0x1C3u) {
    uint64_t v1 = 452;
  }
  return *(unsigned int *)((char *)this + v1);
}

uint64_t DyldSharedCache::patchTable(DyldSharedCache *this)
{
  return (uint64_t)this + *((void *)this + 19) - *(void *)((char *)this + *((unsigned int *)this + 4));
}

dyld4::ProcessConfig::Security *dyld4::ProcessConfig::Security::Security(dyld4::ProcessConfig::Security *this, const char ***a2, dyld4::SyscallDelegate *a3)
{
  int v6 = dyld4::SyscallDelegate::internalInstall(a3);
  *((unsigned char *)this + 1) = v6;
  *(unsigned char *)this = v6;
  if (v6) {
    BOOL v7 = _simple_getenv(a2[14], "DYLD_SKIP_MAIN") != 0;
  }
  else {
    BOOL v7 = 0;
  }
  *((unsigned char *)this + 25) = v7;
  *((unsigned char *)this + 26) = _simple_getenv(a2[14], "DYLD_JUST_BUILD_CLOSURE") != 0;
  if (*((_DWORD *)a2 + 36) == 1)
  {
    if (*((unsigned char *)this + 1))
    {
      uint64_t v8 = _simple_getenv(a2[15], "dyld_flags");
      if (v8) {
        *((_DWORD *)a2 + 22) = hexToUInt64(v8, 0);
      }
    }
  }
  unsigned int AMFI = dyld4::ProcessConfig::Security::getAMFI(this, (const dyld4::ProcessConfig::Process *)a2, a3);
  *((unsigned char *)this + 16) = AMFI & 1;
  v10.i64[0] = *(void *)&vshl_u16((uint16x4_t)(*(void *)&vdup_n_s16(AMFI) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFDFFFEFFFFFFFCLL) & 0xFF01FF01FF01FF01;
  *(_DWORD *)((char *)this + 17) = vmovn_s16(v10).u32[0];
  *((unsigned char *)this + 21) = (AMFI & 0x20) != 0;
  *((unsigned char *)this + 22) = (AMFI & 0x40) != 0;
  *((unsigned char *)this + 23) = (AMFI & 0x80) != 0;
  *((unsigned char *)this + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = BYTE1(AMFI) & 1;
  *((_WORD *)this + 1) = 0;
  *((void *)this + 1) = 0;
  uint64_t v11 = *a2;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = ___ZN5dyld413ProcessConfig8SecurityC2ERNS0_7ProcessERNS_15SyscallDelegateE_block_invoke;
  v15[3] = &__block_descriptor_tmp_31;
  v15[4] = this;
  dyld3::MachOFile::forDyldEnv(v11, (uint64_t)v15);
  unsigned int v13 = *((_DWORD *)a2 + 15);
  if (v13 <= 0xA
    && ((1 << v13) & 0x442) != 0
    && !*((unsigned char *)this + 17)
    && !*((unsigned char *)this + 18)
    && !*((unsigned char *)this + 19))
  {
    dyld4::ProcessConfig::Security::pruneEnvVars(v12, (dyld4::ProcessConfig::Process *)a2);
  }
  return this;
}

void dyld3::MachOFile::forDyldEnv(_DWORD *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile10forDyldEnvEU13block_pointerFvPKcRbE_block_invoke;
  void v4[3] = &unk_1EFF66238;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v5, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v5);
  mach_o::Error::~Error(&v5);
}

unint64_t dyld4::ProcessConfig::Security::getAMFI(dyld4::ProcessConfig::Security *this, const dyld4::ProcessConfig::Process *a2, dyld4::SyscallDelegate *a3)
{
  *(void *)char v18 = 0;
  int isRestricted = dyld3::MachOFile::isRestricted(*(dyld3::MachOFile **)a2);
  uint64_t isFairPlayEncrypted = dyld3::MachOFile::isFairPlayEncrypted(*(dyld3::MachOFile **)a2, &v18[1], v18);
  unint64_t v13 = dyld4::SyscallDelegate::amfiFlags(a3, isRestricted, isFairPlayEncrypted, v8, v9, v10, v11, v12);
  uint64_t v14 = *((void *)a2 + 11);
  long long v15 = _simple_getenv(*((const char ***)a2 + 14), "DYLD_AMFI_FAKE");
  if (v15) {
    BOOL v16 = (v14 & 2) == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16 && *((unsigned char *)this + 1)) {
    return hexToUInt64(v15, 0);
  }
  return v13;
}

unint64_t dyld4::SyscallDelegate::amfiFlags(dyld4::SyscallDelegate *this, int a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v11 = 0;
  uint64_t v8 = 2;
  if (!a2) {
    uint64_t v8 = 0;
  }
  if (a3) {
    uint64_t v9 = v8 | 4;
  }
  else {
    uint64_t v9 = v8;
  }
  if (amfi_check_dyld_policy_self(v9, &v11, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  else {
    return v11;
  }
}

uint64_t amfi_check_dyld_policy_self(uint64_t a1, unint64_t *a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!a2) {
    return 22;
  }
  *a2 = 0;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = a1;
  v11[1] = &v10;
  uint64_t result = __sandbox_ms("AMFI", (void *)0x5A, v11, a4, a5, a6, a7, a8);
  if (result) {
    uint64_t result = *__error();
  }
  *a2 = v10;
  return result;
}

uint64_t dyld3::MachOFile::isRestricted(dyld3::MachOFile *this)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile12isRestrictedEv_block_invoke;
  v3[3] = &unk_1EFF66320;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::Process(dyld4::ProcessConfig::Process *this, const dyld4::KernelArgs *a2, dyld4::SyscallDelegate *a3, lsl::Lock **a4)
{
  uint64_t v8 = (void *)((char *)this + 88);
  dyld4::SyscallDelegate::DyldCommPage::DyldCommPage((dyld4::ProcessConfig::Process *)((char *)this + 88));
  uint64_t v9 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  *((_DWORD *)this + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;
  unint64_t v10 = (void *)((char *)a2 + 8 * v9 + 24);
  *((void *)this + 13) = (char *)a2 + 16;
  *((void *)this + 14) = v10;
  while (*v10++)
    ;
  *((void *)this + 15) = v10;
  *((_DWORD *)this + 36) = dyld4::SyscallDelegate::getpid();
  *((void *)this + 11) = dyld4::SyscallDelegate::dyldCommPageFlags(a3);
  *((unsigned char *)this + 148) = dyld4::SyscallDelegate::isTranslated(a3, v12, v13, v14, v15, v16, v17, v18);
  *((void *)this + 3) = dyld4::ProcessConfig::Process::getMainFileID((const char ***)this);
  *((void *)this + 4) = v19;
  *((void *)this + 9) = dyld4::ProcessConfig::Process::getDyldFileID((const char ***)this);
  *((void *)this + 1dyld4::halt((char *)__format, 0) = v20;
  *((void *)this + 2) = dyld4::ProcessConfig::Process::getMainUnrealPath((const char ***)this, a3, a4);
  *((void *)this + 1) = dyld4::ProcessConfig::Process::getMainPath(this, a3, a4);
  uint64_t v21 = (char *)*((void *)this + 2);
  uint64_t v22 = strrchr(v21, 47);
  if (v22) {
    uint64_t v23 = v22 + 1;
  }
  else {
    uint64_t v23 = v21;
  }
  *((void *)this + 16) = v23;
  *((void *)this + 8) = dyld4::ProcessConfig::Process::getDyldPath((fsid_t *)this, a3, a4);
  if (*((_DWORD *)this + 36) == 1) {
    *uint64_t v8 = *(unsigned int *)v8;
  }
  *((_DWORD *)this + 15) = dyld4::ProcessConfig::Process::getMainPlatform(this);
  *((unsigned char *)this + 149) = 0;
  *((void *)this + 17) = dyld4::ProcessConfig::Process::getMainArchs(this, a3);
  *((unsigned char *)this + 15dyld4::halt((char *)__format, 0) = (*((void *)this + 11) & 0x200000) == 0;
  if (_simple_getenv(*((const char ***)this + 15), "dyld_hw_tpro_pagers")) {
    BOOL v24 = vm_page_size == 0x4000;
  }
  else {
    BOOL v24 = 0;
  }
  char v25 = v24;
  *((unsigned char *)this + 151) = v25;
  *((unsigned char *)this + 152) = (*((void *)this + 11) & 0xC0000) != 0x80000;
  *((unsigned char *)this + 153) = 0;
  *((_DWORD *)this + 39) = 2;
  if (!dyld4::SyscallDelegate::internalInstall(a3))
  {
LABEL_21:
    if (*((int *)this + 39) <= 1) {
      goto LABEL_25;
    }
LABEL_22:
    if (!dyld4::SyscallDelegate::sandboxBlockedPageInLinking(a3)) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  if ((*(unsigned char *)v8 & 0x80) == 0)
  {
    unint64_t v26 = _simple_getenv(*((const char ***)this + 14), "DYLD_PAGEIN_LINKING");
    if (!v26) {
      goto LABEL_21;
    }
    uint64_t v27 = v26;
    if (_platform_strcmp(v26, "0"))
    {
      if (!_platform_strcmp(v27, "1"))
      {
        int v28 = 1;
        goto LABEL_24;
      }
      if (_platform_strcmp(v27, "2"))
      {
        if (_platform_strcmp(v27, "3")) {
          goto LABEL_21;
        }
        int v38 = 3;
      }
      else
      {
        int v38 = 2;
      }
      *((_DWORD *)this + 39) = v38;
      goto LABEL_22;
    }
  }
LABEL_23:
  int v28 = 0;
LABEL_24:
  *((_DWORD *)this + 39) = v28;
LABEL_25:
  uint64_t v29 = (const char *)*((void *)this + 1);
  if (!_platform_strcmp(v29, "/usr/libexec/adid")) {
    *((_DWORD *)this + 39) = 0;
  }
  if (!_platform_strcmp(v29, "/usr/libexec/fairplaydeviceidentityd")) {
    *((_DWORD *)this + 39) = 0;
  }
  if (!_platform_strcmp(v29, "/System/Library/PrivateFrameworks/CoreADI.framework/Versions/A/adid")) {
    *((_DWORD *)this + 39) = 0;
  }
  if (!_platform_strncmp(v29, "/usr/sbin/fairplayd", 0x13uLL)) {
    *((_DWORD *)this + 39) = 0;
  }
  uint64_t v30 = (const char *)*((void *)this + 16);
  int v31 = *((_DWORD *)this + 15);
  unsigned int v32 = *((_DWORD *)this + 10);
  int v33 = *((unsigned __int8 *)this + 150);
  if (v31 == 2 && *((unsigned char *)this + 150))
  {
    uint64_t v34 = 0;
    while (_platform_strcmp(v30, (&dyld4::dataConstApps_iOS14_5_arm64)[v34]))
    {
      if (++v34 == 37) {
        goto LABEL_40;
      }
    }
    if (v32 >> 8 < 0xE0F) {
      goto LABEL_53;
    }
LABEL_40:
    uint64_t v35 = 0;
    while (_platform_strcmp(v30, (&dyld4::dataConstApps_iOS14_5_Intune_arm64)[v35]))
    {
      if (++v35 == 137) {
        goto LABEL_45;
      }
    }
    if (v32 >> 8 < 0xE0F) {
      goto LABEL_53;
    }
LABEL_45:
    int v33 = 1;
  }
  if (v31 == 2 && v33)
  {
    uint64_t v36 = 0;
    while (_platform_strcmp(v30, (&dyld4::dataConstApps_iOS15_0)[v36]))
    {
      if (++v36 == 30) {
        return this;
      }
    }
    if (HIWORD(v32) <= 0xEu) {
LABEL_53:
    }
      *((unsigned char *)this + 15dyld4::halt((char *)__format, 0) = 0;
  }
  return this;
}

uint64_t dyld4::SyscallDelegate::internalInstall(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFF4084] & 1;
}

uint64_t dyld4::SyscallDelegate::dyldCommPageFlags(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFFC160];
}

void *dyld4::SyscallDelegate::getGradedArchs(dyld4::SyscallDelegate *this, const char *a2, dyld3::GradedArchs *a3, int a4)
{
  return dyld3::GradedArchs::forCurrentOS(a3, a4);
}

BOOL dyld4::SyscallDelegate::isTranslated(dyld4::SyscallDelegate *this, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  char v10 = 0;
  if (rosetta_dyld_is_translated((uint64_t)&v10, a2, a3, a4, a5, a6, a7, a8)) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v10 == 0;
  }
  return !v8;
}

int64_t rosetta_dyld_is_translated(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v9 = a1;
  return _crossarch_trap(0, 0, 0, &v9, a5, a6, a7, a8);
}

int64_t _crossarch_trap(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(SYS_crossarch_trap, a1, a2, a3, a4, a5, a6, a7, a8);
}

dyld4::SyscallDelegate::DyldCommPage *dyld4::SyscallDelegate::DyldCommPage::DyldCommPage(dyld4::SyscallDelegate::DyldCommPage *this)
{
  return this;
}

char *dyld4::ProcessConfig::Process::getMainUnrealPath(const char ***this, dyld4::SyscallDelegate *a2, lsl::Lock **a3)
{
  uint64_t v6 = _simple_getenv(this[15], "executable_path");
  if (!v6) {
    uint64_t v6 = *this[13];
  }
  int v7 = *(unsigned __int8 *)v6;
  if (v7 != 47)
  {
    if (v7 == 46) {
      v6 += 2 * (v6[1] == 47);
    }
    if (dyld4::SyscallDelegate::getCWD(a2, __dst))
    {
      strlcat(__dst, "/", 0x400uLL);
      strlcat(__dst, v6, 0x400uLL);
      return lsl::Allocator::strdup(a3, __dst);
    }
  }
  return (char *)v6;
}

uint64_t dyld4::ProcessConfig::Process::getMainPlatform(dyld4::ProcessConfig::Process *this)
{
  *((_DWORD *)this + 1dyld4::halt((char *)__format, 0) = 0;
  *((_DWORD *)this + 12) = 0;
  uint64_t v15 = 0;
  BOOL v16 = &v15;
  uint64_t v17 = 0x2000000000;
  int v18 = 0;
  uint64_t v2 = *(_DWORD **)this;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___ZN5dyld413ProcessConfig7Process15getMainPlatformEv_block_invoke;
  void v14[3] = &unk_1EFF637A0;
  _OWORD v14[4] = &v15;
  void v14[5] = this;
  dyld3::MachOFile::forEachSupportedPlatform(v2, (uint64_t)v14);
  if (*((_DWORD *)v16 + 6) != 1) {
    goto LABEL_20;
  }
  long long v3 = _simple_getenv(*((const char ***)this + 14), "DYLD_FORCE_PLATFORM");
  if (!v3) {
    goto LABEL_20;
  }
  uint64_t v4 = v3;
  if (!dyld3::MachOFile::allowsAlternatePlatform(*(dyld3::MachOFile **)this)) {
    goto LABEL_20;
  }
  int v5 = *(unsigned __int8 *)v4;
  if (v5 == 54)
  {
    int v7 = 6;
    goto LABEL_9;
  }
  if (v5 == 50)
  {
    uint64_t v6 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);
    if (!_platform_strcmp(v6, "arm64"))
    {
      int v7 = 2;
LABEL_9:
      *((_DWORD *)v16 + 6) = v7;
    }
  }
  uint64_t v8 = 0;
  while (dyld3::sVersionMap[v8 + 1] != *((_DWORD *)this + 10))
  {
    v8 += 9;
    if (v8 == 441) {
      goto LABEL_15;
    }
  }
  *((_DWORD *)this + 1dyld4::halt((char *)__format, 0) = dyld3::sVersionMap[v8 + 2];
LABEL_15:
  uint64_t v9 = 0;
  while (dyld3::sVersionMap[v9 + 1] != *((_DWORD *)this + 12))
  {
    v9 += 9;
    if (v9 == 441) {
      goto LABEL_20;
    }
  }
  *((_DWORD *)this + 12) = dyld3::sVersionMap[v9 + 2];
LABEL_20:
  uint64_t v10 = dyld3::MachOFile::basePlatform(*((unsigned int *)v16 + 6));
  *((_DWORD *)this + 14) = v10;
  uint64_t VersionSetEquivalent = dyld4::ProcessConfig::Process::findVersionSetEquivalent(v10, v10, *((_DWORD *)this + 10));
  *((_DWORD *)this + 11) = VersionSetEquivalent;
  *((_DWORD *)this + 13) = dyld4::ProcessConfig::Process::findVersionSetEquivalent(VersionSetEquivalent, *((unsigned int *)this + 14), *((_DWORD *)this + 12));
  uint64_t v12 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  return v12;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::getDyldFileID(const char ***this)
{
  uint64_t result = (dyld4::ProcessConfig::Process *)_simple_getenv(this[15], "dyld_file");
  if (result) {
    return (dyld4::ProcessConfig::Process *)dyld4::ProcessConfig::Process::fileIDFromFileHexStrings(result, (const char *)result);
  }
  return result;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::getMainFileID(const char ***this)
{
  uint64_t result = (dyld4::ProcessConfig::Process *)_simple_getenv(this[15], "executable_file");
  if (result) {
    return (dyld4::ProcessConfig::Process *)dyld4::ProcessConfig::Process::fileIDFromFileHexStrings(result, (const char *)result);
  }
  return result;
}

uint64_t dyld4::ProcessConfig::Process::fileIDFromFileHexStrings(dyld4::ProcessConfig::Process *this, const char *a2)
{
  int v5 = 0;
  uint64_t v2 = hexToUInt64(a2, (const char **)&v5);
  if (!v5) {
    return 0;
  }
  uint64_t v3 = v2;
  hexToUInt64(v5 + 1, (const char **)&v5);
  if (v5) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t hexToUInt64(const char *a1, const char **a2)
{
  if (!a1) {
    return 0;
  }
  if (*a1 == 48) {
    a1 += 2 * (a1[1] == 120);
  }
  if (a2) {
    *a2 = a1 + 16;
  }
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  while (1)
  {
    int v4 = a1[v2];
    unsigned __int8 v5 = v4 - 48;
    if ((v4 - 48) >= 0xA) {
      break;
    }
LABEL_12:
    uint64_t v3 = 16 * v3 + v5;
    if (++v2 == 16) {
      return v3;
    }
  }
  if ((v4 - 65) <= 5)
  {
    unsigned __int8 v5 = v4 - 55;
    goto LABEL_12;
  }
  if ((v4 - 97) <= 5)
  {
    unsigned __int8 v5 = v4 - 87;
    goto LABEL_12;
  }
  if (a2) {
    *a2 = &a1[v2];
  }
  return v3;
}

void *dyld4::ProcessConfig::Process::getMainArchs(dyld4::ProcessConfig::Process *this, dyld4::SyscallDelegate *a2)
{
  int v4 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);
  if (_platform_strcmp(v4, "arm64"))
  {
    unsigned __int8 v5 = _simple_getenv(*((const char ***)this + 15), "ptrauth_disabled");
    if (v5) {
      BOOL v6 = _platform_strcmp(v5, "1") == 0;
    }
    else {
      BOOL v6 = 0;
    }
  }
  else
  {
    BOOL v6 = 1;
  }
  int v7 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);

  return dyld4::SyscallDelegate::getGradedArchs(a2, v7, (dyld3::GradedArchs *)v6, 0);
}

const char *dyld3::MachOFile::archName(dyld3::MachOFile *this)
{
  uint64_t v1 = 0;
  int v2 = *((_DWORD *)this + 1);
  int v3 = *((_DWORD *)this + 2) & 0xFFFFFF;
  uint64_t result = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v1 + 1]) != v2
       || v3 != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v1 + 3))
  {
    v1 += 2;
    if (v1 == 26) {
      return result;
    }
  }
  return (&dyld3::MachOFile::_s_archInfos)[v1];
}

char *dyld4::ProcessConfig::Process::getMainPath(dyld4::ProcessConfig::Process *this, dyld4::SyscallDelegate *a2, lsl::Lock **a3)
{
  fsid_t v6 = (fsid_t)*((void *)this + 3);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 4);
    if (v7)
    {
      if (dyld4::SyscallDelegate::fsgetpath(a2, __s, 0x400uLL, v6, v7) != -1) {
        return lsl::Allocator::strdup(a3, __s);
      }
    }
  }
  if (dyld4::SyscallDelegate::realpath(a2, *((dyld3 **)this + 2), __s)) {
    return lsl::Allocator::strdup(a3, __s);
  }
  else {
    return (char *)*((void *)this + 2);
  }
}

char *dyld4::ProcessConfig::Process::getDyldPath(fsid_t *this, dyld4::SyscallDelegate *a2, lsl::Lock **a3)
{
  fsid_t v3 = this[9];
  if (*(void *)&v3
    && (uint64_t v4 = (uint64_t)this[10]) != 0
    && dyld4::SyscallDelegate::fsgetpath(a2, __s, 0x400uLL, v3, v4) != -1)
  {
    return lsl::Allocator::strdup(a3, __s);
  }
  else
  {
    return "/usr/lib/dyld";
  }
}

ssize_t dyld4::SyscallDelegate::fsgetpath(dyld4::SyscallDelegate *this, char *a2, size_t a3, fsid_t a4, uint64_t a5)
{
  fsid_t v6 = a4;
  return fsgetpath(a2, a3, &v6, a5);
}

ssize_t fsgetpath(char *a1, size_t a2, fsid_t *a3, uint64_t a4)
{
  ssize_t result = mac_syscall(SYS_fsgetpath, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

dyld4::ProcessConfig::PathOverrides *dyld4::ProcessConfig::PathOverrides::PathOverrides(dyld4::ProcessConfig::PathOverrides *this, const dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, const dyld4::ProcessConfig::Logging *a4, const dyld4::ProcessConfig::DyldCache *a5, dyld4::SyscallDelegate *a6, lsl::Lock **a7)
{
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 34) = *((unsigned char *)a3 + 20) == 0;
  if (*((unsigned char *)a3 + 18))
  {
    strcpy((char *)&__s, "dyld config: ");
    uint64_t v14 = (char **)*((void *)a2 + 14);
    uint64_t v15 = *v14;
    if (*v14)
    {
      BOOL v16 = v14 + 1;
      do
      {
        dyld4::ProcessConfig::PathOverrides::addEnvVar((char **)this, a2, a3, a7, v15, 0, (char *)&__s);
        uint64_t v17 = *v16++;
        uint64_t v15 = v17;
      }
      while (v17);
    }
    if (_platform_strlen((const char *)&__s) > 0xF) {
      qword_1EC3F2768 = (uint64_t)lsl::Allocator::strdup(a7, (const char *)&__s);
    }
  }
  else if (*((unsigned char *)a4 + 8))
  {
    int v18 = (const char **)*((void *)a2 + 14);
    uint64_t v19 = *v18;
    if (*v18)
    {
      char v20 = 0;
      uint64_t v21 = v18 + 1;
      do
      {
        v20 |= _platform_strncmp(v19, "DYLD_", 5uLL) == 0;
        uint64_t v22 = *v21++;
        uint64_t v19 = v22;
      }
      while (v22);
      if (v20) {
        dyld4::console((dyld4 *)"Note: DYLD_*_PATH env vars disabled by AMFI\n", (const char *)a2);
      }
    }
  }
  if (*((unsigned char *)a3 + 23))
  {
    uint64_t v23 = *(_DWORD **)a2;
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 0x40000000;
    v28[2] = ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke;
    void v28[3] = &__block_descriptor_tmp_76;
    v28[4] = this;
    v28[5] = a2;
    v28[6] = a3;
    void v28[7] = a7;
    dyld3::MachOFile::forDyldEnv(v23, (uint64_t)v28);
  }
  else if (*((unsigned char *)a4 + 8))
  {
    *(void *)&long long __s = 0;
    *((void *)&__s + 1) = &__s;
    uint64_t v30 = 0x2000000000;
    char v31 = 0;
    BOOL v24 = *(_DWORD **)a2;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000;
    v27[2] = ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke_2;
    v27[3] = &unk_1EFF63888;
    v27[4] = &__s;
    dyld3::MachOFile::forDyldEnv(v24, (uint64_t)v27);
    if (*(unsigned char *)(*((void *)&__s + 1) + 24)) {
      dyld4::console((dyld4 *)"Note: LC_DYLD_ENVIRONMENT env vars disabled by AMFI\n", v25);
    }
    _Block_object_dispose(&__s, 8);
  }
  if (*((void *)a5 + 12)) {
    *((void *)this + 15) = *((void *)a5 + 11);
  }
  dyld4::ProcessConfig::PathOverrides::processVersionedPaths(this, (uint64_t)a2, (uint64_t)a6, (uint64_t)a5, *((_DWORD *)a2 + 15), *((void *)a2 + 17), (uint64_t)a7);
  return this;
}

uint64_t dyld4::ProcessConfig::PathOverrides::processVersionedPaths(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  char v21 = 0;
  uint64_t v13 = a1[4];
  uint64_t v14 = a1[11];
  if (v13 | v14)
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 0x40000000;
    void v19[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke;
    v19[3] = &__block_descriptor_tmp_86;
    v19[4] = a1;
    v19[5] = a3;
    v19[6] = a4;
    v19[7] = a7;
    int v20 = a5;
    void v19[8] = a6;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList(v13, v14, &v21, (uint64_t)v19);
  }
  uint64_t result = a1[5];
  uint64_t v16 = a1[10];
  if (result | v16)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    void v17[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_3;
    v17[3] = &__block_descriptor_tmp_89;
    v17[4] = a1;
    v17[5] = a3;
    void v17[6] = a4;
    v17[7] = a7;
    int v18 = a5;
    unsigned char v17[8] = a6;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v16, &v21, (uint64_t)v17);
  }
  return result;
}

uint64_t dyld3::kdebug_trace_dyld_cache(unsigned __int8 (*this)[16], fsobj_id a2, void *a3, void *a4, unsigned __int8 *a5, void *a6, void *a7, void *a8)
{
  fsobj_id v14 = a2;
  uint64_t result = kdebug_is_enabled(0x1F050028u, *(void *)&a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t result = dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_1A8DFD000);
    if ((result & 1) == 0)
    {
      bzero(v15, 0x400uLL);
      if (fsgetpath(v15, 0x400uLL, (fsid_t *)&v14, (uint64_t)this) == -1) {
        v15[0] = 0;
      }
      fsobj_id v12 = v14;
      fsid v13 = (fsid)a3;
      return dyld3::kdebug_trace_dyld_region((dyld3 *)0xA, 0, 0, v15, (void **)a4, this, v12, v13, *(const void **)&v14);
    }
  }
  return result;
}

uint64_t dyld3::loadDyldCache(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(unsigned char *)(a1 + 4))
  {
    return dyld3::mapSplitCachePrivate(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
  else if (dyld3::reuseExistingCache(a1, (uint64_t)a2))
  {
    return a2[2] == 0;
  }
  else
  {
    return dyld3::mapSplitCacheSystemWide(a1, (uint64_t)a2, v11, v12, v13, v14, v15, v16);
  }
}

uint64_t dyld3::reuseExistingCache(uint64_t a1, uint64_t a2)
{
  __s1 = 0;
  if (__shared_region_check_np((uint64_t *)&__s1)) {
    return 0;
  }
  unsigned __int8 v5 = __s1;
  if (_platform_strcmp(__s1, "dyld_v1  arm64e"))
  {
    uint64_t result = 0;
    *(void *)(a2 + 16) = "existing shared cache in memory is not compatible";
  }
  else
  {
    *(void *)a2 = v5;
    *(void *)(a2 + 8) = DyldSharedCache::slide((DyldSharedCache *)v5);
    uint64_t v6 = *((void *)v5 + 13);
    BOOL v7 = v6 == 2 && *((_DWORD *)v5 + 114) == 0;
    if (v6) {
      char v8 = v7;
    }
    else {
      char v8 = 1;
    }
    *(unsigned char *)(a2 + 48) = v8;
    uint64_t v9 = *((void *)v5 + 62) + *(void *)a2;
    if (_platform_strncmp((const char *)v9, "dyld_data    v0", 0x10uLL)) {
      dyld4::console((dyld4 *)"mapped cache does not contain dynamic config data\n", v10);
    }
    else {
      *(_OWORD *)(a2 + 32) = *(_OWORD *)(v9 + 16);
    }
    if (*(unsigned char *)(a1 + 6))
    {
      if (fsgetpath(v13, 0x400uLL, (fsid_t *)(a2 + 32), *(void *)(a2 + 40)) >= 1) {
        dyld4::console((dyld4 *)"re-using existing shared cache (%s):\n", v11, v13);
      }
      dyld3::verboseSharedCacheMappings((dyld3 *)v5, (const DyldSharedCache *)v11);
    }
    return 1;
  }
  return result;
}

int __shared_region_check_np(uint64_t *a1)
{
  int result = mac_syscall(SYS_shared_region_check_np, a1);
  if (v1) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t DyldSharedCache::slide(DyldSharedCache *this)
{
  return (uint64_t)this - *(void *)((char *)this + *((unsigned int *)this + 4));
}

void *dyld3::GradedArchs::forCurrentOS(dyld3::GradedArchs *this, int a2)
{
  int v2 = &dyld3::GradedArchs::arm64e_pb;
  if (this) {
    int v2 = &dyld3::GradedArchs::arm64e_keysoff_pb;
  }
  fsid_t v3 = &dyld3::GradedArchs::arm64e;
  if (this) {
    fsid_t v3 = &dyld3::GradedArchs::arm64e_keysoff;
  }
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

uint64_t dyld4::ExternallyViewableState::setLibSystemInitialized(dyld4::ExternallyViewableState *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    uint64_t result = dyld4::Atlas::ProcessSnapshot::setDyldState(result, 48);
  }
  *(unsigned char *)(*((void *)this + 3) + 25) = 1;
  return result;
}

size_t dyld4::PrebuiltLoaderSet::forEachMustBeMissingPath(size_t result, uint64_t a2)
{
  size_t v3 = result;
  char v6 = 0;
  char v4 = (const char *)(result + *(unsigned int *)(result + 36));
  int v5 = -1;
  do
  {
    if (++v5 >= *(_DWORD *)(v3 + 32)) {
      break;
    }
    (*(void (**)(uint64_t, const char *, char *))(a2 + 16))(a2, v4, &v6);
    uint64_t result = _platform_strlen(v4);
    v4 += result + 1;
  }
  while (!v6);
  return result;
}

uint64_t dyld4::PrebuiltLoaderSet::objcSelectorMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 10);
  if (v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::objcProtocolMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 12);
  if (v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::objcClassMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 11);
  if (v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0;
  }
}

void dyld4::ProcessConfig::DyldCache::setPlatformOSVersion(dyld4::ProcessConfig::DyldCache *this, const dyld4::ProcessConfig::Process *a2)
{
  uint64_t v3 = *(void *)this;
  int v4 = *((_DWORD *)a2 + 15);
  if (*(_DWORD *)(v3 + 16) < 0x170u)
  {
    if (v4 == 10) {
      BOOL v7 = "/System/DriverKit/usr/lib/system/libdyld.dylib";
    }
    else {
      BOOL v7 = "/usr/lib/system/libdyld.dylib";
    }
    ImageFromuint64_t Path = (_DWORD *)DyldSharedCache::getImageFromPath((DyldSharedCache *)v3, v7);
    if (ImageFromPath)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      _OWORD v10[2] = ___ZN5dyld413ProcessConfig9DyldCache20setPlatformOSVersionERKNS0_7ProcessE_block_invoke;
      void v10[3] = &__block_descriptor_tmp_65;
      v10[4] = this;
      v10[5] = a2;
      dyld3::MachOFile::forEachSupportedPlatform(ImageFromPath, (uint64_t)v10);
    }
    else
    {
      dyld4::console((dyld4 *)"initializeCachePlatformOSVersion(): libdyld.dylib not found for OS version info\n", v9);
    }
  }
  else if (v4 == *(_DWORD *)(v3 + 216))
  {
    int v5 = *(_DWORD *)(v3 + 364);
    *((_DWORD *)this + 36) = v4;
    *((_DWORD *)this + 37) = v5;
  }
  else
  {
    *((void *)this + 18) = *(void *)(v3 + 368);
  }
}

void dyld4::RuntimeState::allocateProcessArrays(dyld4::RuntimeState *this, unint64_t a2)
{
  *((void *)this + 125) = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), a2);
  *((void *)this + 126) = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 8 * a2);
  bzero(*((void **)this + 125), a2);
  int v4 = (void *)*((void *)this + 126);

  bzero(v4, 8 * a2);
}

BOOL hexStringToBytes(const char *a1, unsigned __int8 *a2, unsigned int a3, unsigned int *a4)
{
  *a4 = 0;
  char v4 = *a1;
  if (!*a1) {
    return 1;
  }
  int v5 = 0;
  char v6 = a1 + 1;
  char v7 = 1;
  while (1)
  {
    char v8 = v4 - 48;
    if ((v4 - 48) < 0xAu) {
      goto LABEL_6;
    }
    if ((v4 - 65) <= 5u)
    {
      char v8 = v4 - 55;
LABEL_6:
      if (v7) {
        goto LABEL_7;
      }
      goto LABEL_10;
    }
    if ((v4 - 97) > 5u) {
      return 0;
    }
    char v8 = v4 - 87;
    if (v7)
    {
LABEL_7:
      unsigned __int8 v9 = 16 * v8;
      goto LABEL_11;
    }
LABEL_10:
    *a4 = v5 + 1;
    unsigned __int8 v9 = a2[v5] | v8;
LABEL_11:
    a2[v5] = v9;
    int v10 = *(unsigned __int8 *)v6++;
    char v4 = v10;
    BOOL result = v10 == 0;
    if (v10)
    {
      v7 ^= 1u;
      int v5 = *a4;
      if (*a4 <= a3) {
        continue;
      }
    }
    return result;
  }
}

BOOL DyldSharedCache::hasLaunchLoaderSetWithCDHash(DyldSharedCache *this, const char *a2)
{
  return DyldSharedCache::findLaunchLoaderSetWithCDHash(this, a2) != 0;
}

BOOL dyld4::PrebuiltLoader::recordedCdHashIs(dyld4::PrebuiltLoader *this, const unsigned __int8 *a2)
{
  BOOL result = 0;
  if (this && *((_WORD *)this + 21))
  {
    char v4 = (char *)this + *((unsigned __int16 *)this + 21);
    if (v4[53])
    {
      uint64_t v5 = *((void *)v4 + 4);
      uint64_t v6 = *((void *)v4 + 5);
      uint64_t v7 = *((unsigned int *)v4 + 12);
      return v5 == *(void *)a2 && v6 == *((void *)a2 + 1) && v7 == *((_DWORD *)a2 + 4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

size_t dyld4::ProcessConfig::PathOverrides::addEnvVar(char **this, const dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, lsl::Lock **a4, char *__s, int a6, char *a7)
{
  size_t result = (size_t)_platform_strchr(__s, 61);
  if (!result) {
    return result;
  }
  uint64_t v15 = (char *)(result + 1);
  if (a6 && _platform_strchr((char *)(result + 1), 64))
  {
    size_t v16 = _platform_strlen(__s);
    __chkstk_darwin(v16, v17, v18, v19, v20, v21, v22, v23, v34);
    char v25 = (char *)&v35[-1] - ((v24 + 1039) & 0xFFFFFFFFFFFFFFF0);
    v37[0] = 0;
    v37[1] = v37;
    v37[2] = 0x2000000000;
    char v38 = 0;
    const char *v25 = 0;
    char v36 = 0;
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 0x40000000;
    void v35[2] = ___ZN5dyld413ProcessConfig13PathOverrides9addEnvVarERKNS0_7ProcessERKNS0_8SecurityERN3lsl9AllocatorEPKcbPc_block_invoke;
    v35[3] = &unk_1EFF63958;
    v35[4] = v37;
    v35[5] = a3;
    void v35[6] = v25;
    v35[7] = v26;
    v35[8] = a2;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList((uint64_t)v15, 0, &v36, (uint64_t)v35);
    uint64_t v15 = lsl::Allocator::strdup(a4, v25);
    _Block_object_dispose(v37, 8);
  }
  size_t result = _platform_strncmp(__s, "DYLD_LIBRARY_PATH", 0x11uLL);
  if (!result)
  {
    if (a6) {
      int v28 = this + 6;
    }
    else {
      int v28 = this;
    }
    goto LABEL_27;
  }
  size_t result = _platform_strncmp(__s, "DYLD_FRAMEWORK_PATH", 0x13uLL);
  if (!result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 8;
    uint64_t v31 = 56;
LABEL_24:
    if (!v29) {
      uint64_t v30 = v31;
    }
    int v28 = (char **)((char *)this + v30);
    goto LABEL_27;
  }
  size_t result = _platform_strncmp(__s, "DYLD_FALLBACK_FRAMEWORK_PATH", 0x1CuLL);
  if (!result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 24;
    uint64_t v31 = 72;
    goto LABEL_24;
  }
  size_t result = _platform_strncmp(__s, "DYLD_FALLBACK_LIBRARY_PATH", 0x1AuLL);
  if (!result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 16;
    uint64_t v31 = 64;
    goto LABEL_24;
  }
  size_t result = _platform_strncmp(__s, "DYLD_VERSIONED_FRAMEWORK_PATH", 0x1CuLL);
  if (!result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 40;
    uint64_t v31 = 80;
    goto LABEL_24;
  }
  size_t result = _platform_strncmp(__s, "DYLD_VERSIONED_LIBRARY_PATH", 0x1AuLL);
  if (!result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 32;
    uint64_t v31 = 88;
    goto LABEL_24;
  }
  uint64_t v27 = (dyld4::ProcessConfig::PathOverrides *)_platform_strncmp(__s, "DYLD_INSERT_LIBRARIES", 0x15uLL);
  if (!v27)
  {
    size_t result = (size_t)dyld4::ProcessConfig::PathOverrides::setString(v27, a4, this + 12, v15);
    unsigned int v32 = this[12];
    if (*v32)
    {
      int v33 = 1;
      *((_DWORD *)this + 35) = 1;
      while (1)
      {
        if (*v32 == 58)
        {
          *((_DWORD *)this + 35) = ++v33;
        }
        else if (!*v32)
        {
          goto LABEL_28;
        }
        ++v32;
      }
    }
    goto LABEL_28;
  }
  size_t result = _platform_strncmp(__s, "DYLD_IMAGE_SUFFIX", 0x11uLL);
  if (!result)
  {
    int v28 = this + 13;
    goto LABEL_27;
  }
  size_t result = _platform_strncmp(__s, "DYLD_ROOT_PATH", 0xEuLL);
  if (!result)
  {
    size_t result = dyld3::MachOFile::isSimulatorPlatform(*((_DWORD *)a2 + 15), 0);
    if (result)
    {
      int v28 = this + 14;
LABEL_27:
      size_t result = (size_t)dyld4::ProcessConfig::PathOverrides::setString((dyld4::ProcessConfig::PathOverrides *)result, a4, v28, v15);
    }
  }
LABEL_28:
  if (a7)
  {
    size_t result = _platform_strncmp(__s, "DYLD_", 5uLL);
    if (!result)
    {
      strlcat(a7, __s, 0x800uLL);
      return strlcat(a7, " ", 0x800uLL);
    }
  }
  return result;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap(uint64_t a1, uint64_t a2, void *a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v5 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)a1 = *a3;
  *(void *)(a1 + 8) = a3[1];
  uint64_t v6 = a3 + 3;
  unint64_t v7 = a3[2];
  *uint64_t v5 = a3 + 3;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
  if (v7)
  {
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v5, v7);
    uint64_t v8 = *(void *)(a1 + 72);
    *(void *)(a1 + 32) = v7;
    if (v8) {
      dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap();
    }
  }
  unsigned __int8 v9 = &v6[v7];
  unint64_t v10 = *v9;
  *(void *)(a1 + 56) = v9 + 1;
  *(void *)(a1 + 64) = v10;
  if (v10)
  {
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve((void *)(a1 + 56), v10);
    *(void *)(a1 + 72) = v10;
  }
  *(void *)(a1 + 96) = a2;
  return a1;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 48 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    size_t result = memmove((void *)v3[3], *v3, 48 * (void)v3[2]);
    unint64_t v8 = (unint64_t)v3[4] / 0x30;
    void *v3 = v3[3];
    v3[1] = (const void *)v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

BOOL dyld4::RuntimeState::fileAlreadyHasBootToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __s2 = &v7;
  *(_OWORD *)__n = xmmword_1A8E70420;
  BOOL result = dyld4::SyscallDelegate::getFileAttribute(*(void *)(a1 + 8), *(char **)(a1 + 984), "com.apple.dyld", (uint64_t)&__s2);
  if (result) {
    return __n[1] == *(void *)(a3 + 16) && _platform_memcmp(*(const void **)a3, __s2, __n[1]) == 0;
  }
  return result;
}

BOOL dyld4::SyscallDelegate::getFileAttribute(int a1, char *path, char *name, uint64_t a4)
{
  unint64_t v5 = getxattr(path, name, *(void **)a4, *(void *)(a4 + 8), 0, 0);
  if (v5 != -1)
  {
    if (*(void *)(a4 + 8) < v5) {
      dyld4::SyscallDelegate::getFileAttribute();
    }
    *(void *)(a4 + 16) = v5;
  }
  return v5 != -1;
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  ssize_t result = mac_syscall(SYS_getxattr, path, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

const char *dyld4::RuntimeState::buildBootToken(uint64_t a1, uint64_t *a2)
{
  unsigned int v12 = 0;
  ssize_t result = dyld4::ProcessConfig::Process::appleParam((const char ***)(*(void *)(a1 + 8) + 8), "executable_boothash");
  if (result)
  {
    ssize_t result = (const char *)hexStringToBytes(result, v16, 0x80u, &v12);
    if (result)
    {
      uint64_t v5 = v12;
      if (v12)
      {
        char v6 = v16;
        do
        {
          dyld3::Array<unsigned char>::push_back(a2, (char *)v6++);
          --v5;
        }
        while (v5);
      }
      *(void *)uint64_t v14 = 0;
      uint64_t v15 = 0;
      if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_1A8DFD000, v14))
      {
        for (uint64_t i = 0; i != 16; ++i)
          dyld3::Array<unsigned char>::push_back(a2, (char *)&v14[i]);
      }
      unint64_t v8 = *(char **)(*(void *)(a1 + 8) + 24);
      size_t v9 = _platform_strlen(v8);
      unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v13, (uint64_t *)v8, v9);
      int v11 = 8;
      do
      {
        char v13 = v10;
        dyld3::Array<unsigned char>::push_back(a2, &v13);
        v10 >>= 8;
        --v11;
      }
      while (v11);
      return (const char *)1;
    }
  }
  return result;
}

uint64_t *dyld3::Array<unsigned char>::push_back(uint64_t *result, char *a2)
{
  unint64_t v2 = result[2];
  if (v2 >= result[1]) {
    ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
  }
  char v3 = *a2;
  uint64_t v4 = *result;
  result[2] = v2 + 1;
  *(unsigned char *)(v4 + v2) = v3;
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v11 = v7 + v9;
      unint64_t v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      unint64_t v14 = v8 + a3 + v7 + v4;
      uint64_t v15 = v14 + v5;
      unint64_t v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      uint64_t v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v18 = v17 + v6 + v9;
      uint64_t v19 = __ROR8__(v18, 44);
      uint64_t v20 = v18 + v10;
      uint64_t v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      uint64_t v23 = *a2;
      uint64_t v22 = a2 + 4;
      unint64_t v24 = v23 - 0x4B6D499041670D8DLL * v5;
      uint64_t v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v26 = *(v22 - 3);
        uint64_t v27 = v24 + v15 + v11 + v26;
        uint64_t v28 = v22[2];
        uint64_t v29 = v22[3];
        uint64_t v30 = v22[1];
        unint64_t v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        uint64_t v31 = v13 + v20;
        uint64_t v32 = *(v22 - 2);
        uint64_t v33 = *(v22 - 1);
        uint64_t v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        uint64_t v35 = v34 + v20 + v33;
        uint64_t v36 = v34 + v26 + v32;
        uint64_t v15 = v36 + v33;
        uint64_t v37 = __ROR8__(v36, 44) + v34;
        unint64_t v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        unint64_t v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        unint64_t v16 = v37 + __ROR8__(v35 + v38, 21);
        unint64_t v39 = v24 + v21 + *v22;
        uint64_t v20 = v39 + v30 + v28 + v29;
        uint64_t v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        unint64_t v13 = v38;
        v25 += 64;
      }
      while (v25);
      unint64_t v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      unint64_t v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)((char *)a1 + a2 - 16);
  uint64_t v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = __ROR8__(v3 + v4, 52);
  uint64_t v7 = v3 + a1[1];
  uint64_t v8 = __ROR8__(v7, 7);
  uint64_t v9 = v7 + v5;
  uint64_t v10 = *(void *)((char *)a1 + a2 - 32) + v5;
  uint64_t v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  uint64_t v12 = *(void *)((char *)a1 + a2 - 24) + v10 + v2;
  unint64_t v13 = 0xC3A5C85C97CB3127 * (v12 + *(void *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(void *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(void *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

BOOL dyld4::APIs::dyld_has_inserted_or_interposing_libraries(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*((void *)this + 22)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)(v1 + 540) != 0;
  }
  if (*(unsigned char *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "dyld_has_inserted_or_interposing_libraries() => %d\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::_dyld_for_objc_header_opt_rw(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(void *)(v1 + 240))
  {
    if (*(unsigned char *)(v1 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw(): no dyld shared cache\n");
    }
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 296);
  int v3 = *(unsigned __int8 *)(v1 + 204);
  if (!v2)
  {
    if (v3) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw(): no objC RW header\n");
    }
    return 0;
  }
  if (v3) {
    dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw() => 0x%llx\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::_dyld_for_objc_header_opt_ro(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(void *)(v1 + 240))
  {
    if (*(unsigned char *)(v1 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro(): no dyld shared cache\n");
    }
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 288);
  int v3 = *(unsigned __int8 *)(v1 + 204);
  if (!v2)
  {
    if (v3) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro(): no objC RO header\n");
    }
    return 0;
  }
  if (v3) {
    dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro() => 0x%llx\n", v2);
  }
  return v2;
}

const os_unfair_lock *dyld4::APIs::_dyld_register_for_bulk_image_loads(uint64_t **this, void (*a2)(unsigned int, const mach_header **, const char **))
{
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_for_bulk_image_loads(%p)\n", a2);
  }
  uint64_t v4 = this[17];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  void v23[2] = ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke;
  v23[3] = &__block_descriptor_tmp_122;
  v23[4] = this;
  v23[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v23);
  uint64_t ImageContaining = dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  uint64_t v6 = this[16];
  uint64_t v7 = this[17];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  uint64_t v18 = ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke_2;
  uint64_t v19 = &__block_descriptor_tmp_123_0;
  uint64_t v20 = (dyld4::APIs *)this;
  uint64_t v21 = ImageContaining;
  uint64_t v22 = a2;
  uint64_t v25 = v6;
  unint64_t v24 = 0;
  if (v6) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0;
  }
  if (*((unsigned char *)v8 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_44;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    unint64_t v24 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v24)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_44;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v9 = MEMORY[0xFFFFFC0D0];
      if (v9 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_44;
      }
    }
  }
  else
  {
    unint64_t v24 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v8, &v26);
    uint64_t v10 = v8[3];
    if (!v10)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v8, 0);
      uint64_t v10 = v8[3];
    }
    void v8[3] = v10 + 1;
    lsl::Lock::unlock(v26);
  }
  if (*v7)
  {
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)*v7 + 104))(*v7, v7 + 2, 0);
    v18((uint64_t)v17);
    ssize_t result = (const os_unfair_lock *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)*v7 + 112))(*v7, v7 + 2);
  }
  else
  {
    ssize_t result = (const os_unfair_lock *)v18((uint64_t)v17);
  }
  if (v25) {
    uint64_t v12 = v25;
  }
  else {
    uint64_t v12 = 0;
  }
  if (*((unsigned char *)v12 + 32))
  {
    if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
    {
      if (v24 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        return result;
      }
      if (v24 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_44;
        }
        ssize_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v13 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_44;
        }
        ssize_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D8];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v13 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v13 == StatusReg) {
        return result;
      }
    }
LABEL_44:
    __break(1u);
    JUMPOUT(0x1A8E34DF8);
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v12, &v26);
  if (v24 == 1)
  {
    uint64_t v16 = v12[3] - 1;
    void v12[3] = v16;
    if (!v16) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v12, 1);
    }
  }
  else if (v24 == 0xFFFFFFFF)
  {
    uint64_t v15 = v12[3];
    if (!v15)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v12, 0);
      uint64_t v15 = v12[3];
    }
    void v12[3] = v15 + 1;
  }
  return lsl::Lock::unlock(v26);
}

uint64_t ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke_2(uint64_t a1)
{
  return dyld4::RuntimeState::addNotifyBulkLoadImage(*(dyld4::RuntimeState **)(a1 + 32), *(const dyld4::Loader **)(a1 + 40), *(void (**)(unsigned int, const mach_header **, const char **))(a1 + 48));
}

uint64_t dyld4::RuntimeState::addNotifyBulkLoadImage(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(unsigned int, const mach_header **, const char **))
{
  uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 800, *((void *)this + 102) + 1);
  uint64_t v7 = *((void *)this + 101);
  uint64_t v8 = *((void *)this + 102);
  *((void *)this + 102) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1072, *((void *)this + 136) + 1);
      uint64_t v9 = *((void *)this + 135);
      uint64_t v10 = *((void *)this + 136);
      *((void *)this + 136) = v10 + 1;
      *(void *)(v9 + 8 * v1dyld4::halt((char *)__format, 0) = a2;
    }
  }
  return result;
}

unsigned char *___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke(unsigned char *result, unsigned int a2)
{
  if (**((_DWORD **)result + 6) <= a2) {
    ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke_cold_1();
  }
  if ((*(_WORD *)(*(void *)(*((void *)result + 4) + 32 * a2 + 16) + 4) & 2) != 0 && **((unsigned char **)result + 7))
  {
    uint64_t v2 = (unsigned char *)**((void **)result + 5);
    return dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(v2);
  }
  return result;
}

unint64_t dyld4::APIs::dyld_get_program_sdk_version_token(dyld4::APIs *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 68) | ((unint64_t)*(unsigned int *)(*((void *)this + 1)
                                                                                              + 48) << 32);
}

void dyld4::APIs::_libdyld_initialize(dyld4::RuntimeState *a1, uint64_t a2)
{
  uint64_t v12 = *((void *)a1 + 16);
  if (v12) {
    uint64_t v4 = *((void *)a1 + 16);
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(unsigned char *)(v4 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_36;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_36;
    }
    unint64_t v11 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v11)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_36;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v5 = MEMORY[0xFFFFFC0D0];
      if (v5 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v11 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v4, &v13);
    uint64_t v6 = *(void *)(v4 + 24);
    if (!v6)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v4, 0);
      uint64_t v6 = *(void *)(v4 + 24);
    }
    *(void *)(v4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6 + 1;
    lsl::Lock::unlock(v13);
  }
  dyld4::RuntimeState::setHelpers((uint64_t)a1, a2);
  dyld4::RuntimeState::initialize(a1);
  if (v12) {
    uint64_t v7 = v12;
  }
  else {
    uint64_t v7 = 0;
  }
  if (*(unsigned char *)(v7 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_36;
    }
    if (v11 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return;
    }
    if (v11 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v8 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v8 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v8 == StatusReg) {
      return;
    }
LABEL_36:
    __break(1u);
    return;
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v7, &v13);
  if (v11 == 1)
  {
    uint64_t v10 = *(void *)(v7 + 24) - 1;
    *(void *)(v7 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10;
    if (!v10) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v7, 1);
    }
  }
  lsl::Lock::unlock(v13);
}

uint64_t dyld4::RuntimeState::setHelpers(uint64_t result, uint64_t a2)
{
  **(void **)(result + 136) = a2;
  *(void *)(result + 152) = a2;
  return result;
}

void dyld4::PrebuiltLoaderSet::logDuplicateObjCClasses(dyld4::PrebuiltLoaderSet *this, dyld4::Loader **a2)
{
  if (this)
  {
    uint64_t v2 = *((unsigned int *)this + 11);
    if (v2)
    {
      if ((*((unsigned char *)this + 52) & 1) != 0 && *((unsigned char *)a2[1] + 203))
      {
        uint64_t v4 = (uint64_t *)((char *)this + v2);
        uint64_t v5 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(a2[3], (const dyld4::RuntimeState *)a2);
        v14[0] = 0;
        v14[1] = v14;
        v14[2] = 0x8802000000;
        void v14[3] = __Block_byref_object_copy__64;
        _OWORD v14[4] = __Block_byref_object_dispose__65;
        dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v15);
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        v13[2] = ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke;
        v13[3] = &unk_1EFF64EE8;
        uint64_t v13[4] = v14;
        dyld3::MachOAnalyzer::forEachObjCDuplicateClassToIgnore(v5, (uint64_t)v13);
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 0x40000000;
        v12[2] = ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke_2;
        void v12[3] = &unk_1EFF64F10;
        _OWORD v12[4] = v14;
        v12[5] = a2;
        prebuilt_objc::forEachClass(v4, (uint64_t)v12, v6, v7, v8, v9, v10, v11);
        _Block_object_dispose(v14, 8);
        uint64_t v18 = 0;
        if (address) {
          vm_deallocate(mach_task_self_, address, size);
        }
        v15[4] = 0;
        if (v16) {
          vm_deallocate(mach_task_self_, v16, v17);
        }
      }
    }
  }
}

const os_unfair_lock *dyld4::APIs::_dyld_register_func_for_remove_image(dyld4::APIs *this, void (*a2)(const mach_header *, uint64_t))
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_register_func_for_remove_image(%p)\n", a2);
  }
  uint64_t result = (const os_unfair_lock *)dyld4::APIs::findImageContaining(this, a2);
  uint64_t v5 = *((void *)this + 16);
  uint64_t v6 = (void *)*((void *)this + 17);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  vm_address_t v16 = ___ZN5dyld44APIs36_dyld_register_func_for_remove_imageEPFvPK11mach_headerlE_block_invoke;
  vm_size_t v17 = &__block_descriptor_tmp_48_0;
  uint64_t v18 = this;
  uint64_t v19 = result;
  uint64_t v20 = a2;
  uint64_t v22 = v5;
  unint64_t v21 = 0;
  if (v5) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = 0;
  }
  if (*(unsigned char *)(v7 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_44;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    unint64_t v21 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v21)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_44;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v8 = MEMORY[0xFFFFFC0D0];
      if (v8 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_44;
      }
    }
  }
  else
  {
    unint64_t v21 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v7, &v23);
    uint64_t v9 = *(void *)(v7 + 24);
    if (!v9)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v7, 0);
      uint64_t v9 = *(void *)(v7 + 24);
    }
    *(void *)(v7 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9 + 1;
    lsl::Lock::unlock(v23);
  }
  if (*v6)
  {
    (*(void (**)(void, void *, void))(*(void *)*v6 + 104))(*v6, v6 + 2, 0);
    v16((uint64_t)v15);
    uint64_t result = (const os_unfair_lock *)(*(uint64_t (**)(void, void *))(*(void *)*v6 + 112))(*v6, v6 + 2);
  }
  else
  {
    uint64_t result = (const os_unfair_lock *)v16((uint64_t)v15);
  }
  if (v22) {
    uint64_t v10 = v22;
  }
  else {
    uint64_t v10 = 0;
  }
  if (*(unsigned char *)(v10 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    if (v21 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return result;
    }
    if (v21 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v11 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v11 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v11 == StatusReg) {
      return result;
    }
LABEL_44:
    __break(1u);
    return result;
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v10, &v23);
  if (v21 == 1)
  {
    uint64_t v14 = *(void *)(v10 + 24) - 1;
    *(void *)(v10 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14;
    if (!v14) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 1);
    }
  }
  else if (v21 == 0xFFFFFFFF)
  {
    uint64_t v13 = *(void *)(v10 + 24);
    if (!v13)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 0);
      uint64_t v13 = *(void *)(v10 + 24);
    }
    *(void *)(v10 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v13 + 1;
  }
  return lsl::Lock::unlock(v23);
}

uint64_t ___ZN5dyld44APIs36_dyld_register_func_for_remove_imageEPFvPK11mach_headerlE_block_invoke(uint64_t a1)
{
  return dyld4::RuntimeState::addNotifyRemoveFunc(*(dyld4::RuntimeState **)(a1 + 32), *(const dyld4::Loader **)(a1 + 40), *(void (**)(const mach_header *, uint64_t))(a1 + 48));
}

uint64_t dyld4::RuntimeState::addNotifyRemoveFunc(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, uint64_t))
{
  uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 736, *((void *)this + 94) + 1);
  uint64_t v7 = *((void *)this + 93);
  uint64_t v8 = *((void *)this + 94);
  *((void *)this + 94) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1072, *((void *)this + 136) + 1);
      uint64_t v9 = *((void *)this + 135);
      uint64_t v10 = *((void *)this + 136);
      *((void *)this + 136) = v10 + 1;
      *(void *)(v9 + 8 * v1dyld4::halt((char *)__format, 0) = a2;
    }
  }
  return result;
}

const os_unfair_lock *dyld4::APIs::_dyld_register_func_for_add_image(uint64_t **this, void (*a2)(const mach_header *, uint64_t))
{
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_func_for_add_image(%p)\n", a2);
  }
  uint64_t v4 = this[17];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  void v23[2] = ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke;
  v23[3] = &__block_descriptor_tmp_45_0;
  v23[4] = this;
  v23[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v23);
  uint64_t ImageContaining = dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  uint64_t v6 = this[16];
  uint64_t v7 = this[17];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  uint64_t v18 = ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke_2;
  uint64_t v19 = &__block_descriptor_tmp_46_2;
  uint64_t v20 = (dyld4::APIs *)this;
  uint64_t v21 = ImageContaining;
  uint64_t v22 = a2;
  uint64_t v25 = v6;
  unint64_t v24 = 0;
  if (v6) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0;
  }
  if (*((unsigned char *)v8 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_44;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    unint64_t v24 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v24)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_44;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v9 = MEMORY[0xFFFFFC0D0];
      if (v9 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_44;
      }
    }
  }
  else
  {
    unint64_t v24 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v8, &v26);
    uint64_t v10 = v8[3];
    if (!v10)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v8, 0);
      uint64_t v10 = v8[3];
    }
    void v8[3] = v10 + 1;
    lsl::Lock::unlock(v26);
  }
  if (*v7)
  {
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)*v7 + 104))(*v7, v7 + 2, 0);
    v18((uint64_t)v17);
    uint64_t result = (const os_unfair_lock *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)*v7 + 112))(*v7, v7 + 2);
  }
  else
  {
    uint64_t result = (const os_unfair_lock *)v18((uint64_t)v17);
  }
  if (v25) {
    uint64_t v12 = v25;
  }
  else {
    uint64_t v12 = 0;
  }
  if (*((unsigned char *)v12 + 32))
  {
    if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
    {
      if (v24 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        return result;
      }
      if (v24 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_44;
        }
        uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v13 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_44;
        }
        uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D8];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v13 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v13 == StatusReg) {
        return result;
      }
    }
LABEL_44:
    __break(1u);
    JUMPOUT(0x1A8E35F18);
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v12, &v26);
  if (v24 == 1)
  {
    uint64_t v16 = v12[3] - 1;
    void v12[3] = v16;
    if (!v16) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v12, 1);
    }
  }
  else if (v24 == 0xFFFFFFFF)
  {
    uint64_t v15 = v12[3];
    if (!v15)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v12, 0);
      uint64_t v15 = v12[3];
    }
    void v12[3] = v15 + 1;
  }
  return lsl::Lock::unlock(v26);
}

uint64_t ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke_2(uint64_t a1)
{
  return dyld4::RuntimeState::addNotifyAddFunc(*(dyld4::RuntimeState **)(a1 + 32), *(const dyld4::Loader **)(a1 + 40), *(void (**)(const mach_header *, uint64_t))(a1 + 48));
}

uint64_t dyld4::RuntimeState::addNotifyAddFunc(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, uint64_t))
{
  uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 704, *((void *)this + 90) + 1);
  uint64_t v7 = *((void *)this + 89);
  uint64_t v8 = *((void *)this + 90);
  *((void *)this + 9dyld4::halt((char *)__format, 0) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1072, *((void *)this + 136) + 1);
      uint64_t v9 = *((void *)this + 135);
      uint64_t v10 = *((void *)this + 136);
      *((void *)this + 136) = v10 + 1;
      *(void *)(v9 + 8 * v1dyld4::halt((char *)__format, 0) = a2;
    }
  }
  return result;
}

uint64_t dyld4::RuntimeState::exitTLV(dyld4::RuntimeState *this)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 19) + 64))(*((void *)this + 19), *((void *)this + 139));
  if (result)
  {
    uint64_t v3 = result;
    (*(void (**)(void, void, void))(**((void **)this + 19) + 72))(*((void *)this + 19), *((void *)this + 139), 0);
    uint64_t v4 = **(uint64_t (***)(dyld4::RuntimeState *, uint64_t))this;
    return v4(this, v3);
  }
  return result;
}

BOOL dyld4::APIs::dlopen_preflight(dyld4::APIs *this, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v34 = 520617988;
  uint64_t v35 = 0;
  uint64_t v36 = a2;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  uint64_t v42 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v34, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *((void *)this + 1);
  if (*(unsigned char *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "dlopen_preflight(%s)\n", a2);
    uint64_t v10 = *((void *)this + 1);
  }
  unsigned int v33 = 0;
  uint64_t v11 = *(DyldSharedCache **)(v10 + 240);
  if (v11)
  {
    if (DyldSharedCache::hasImagePath(*(DyldSharedCache **)(v10 + 240), a2, &v33))
    {
LABEL_12:
      long long v39 = xmmword_1A8E6FD00;
      BOOL v14 = 1;
      goto LABEL_19;
    }
    uint64_t v10 = *((void *)this + 1);
  }
  if (dyld4::SyscallDelegate::realpath((dyld4::SyscallDelegate *)v10, (dyld3 *)a2, __s2))
  {
    int v12 = _platform_strcmp(a2, __s2);
    BOOL v13 = !v11 || v12 == 0;
    if (!v13 && DyldSharedCache::hasImagePath(v11, __s2, &v33)) {
      goto LABEL_12;
    }
  }
  char v32 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2000000000;
  char v31 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x3002000000;
  uint64_t v25 = __Block_byref_object_copy__6;
  uint64_t v26 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v27);
  uint64_t v15 = *((void *)this + 1);
  uint64_t v16 = (const char *)*(unsigned int *)(v15 + 68);
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000;
  v21[2] = ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke;
  void v21[3] = &unk_1EFF65468;
  void v21[6] = this;
  void v21[7] = a2;
  v21[4] = &v28;
  v21[5] = &v22;
  dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v15 + 400, (dyld4::Utils *)a2, v16, 0, 1, &v32, (uint64_t)v21);
  if (!*((unsigned char *)v29 + 24) && Diagnostics::hasError((Diagnostics *)(v23 + 5)))
  {
    uint64_t v18 = (const char *)Diagnostics::errorMessage((Diagnostics *)(v23 + 5));
    dyld4::APIs::setErrorString((vm_address_t *)this, "dlopen_preflight(%s) => false, %s", a2, v18);
  }
  if (*(unsigned char *)(*((void *)this + 1) + 204))
  {
    uint64_t v19 = dyld4::Loader::leafName((dyld4::Loader *)a2, v17);
    dyld4::RuntimeState::log(this, "      dlopen_preflight(%s) => %d\n", (const char *)v19, *((unsigned __int8 *)v29 + 24));
  }
  BOOL v14 = *((unsigned char *)v29 + 24) != 0;
  long long v39 = *((unsigned __int8 *)v29 + 24);
  _Block_object_dispose(&v22, 8);
  mach_o::Error::~Error(&v27);
  _Block_object_dispose(&v28, 8);
LABEL_19:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v34);
  return v14;
}

void dyld4::APIs::_dyld_objc_register_callbacks(dyld4::PrebuiltLoaderSet **this, uint64_t a2)
{
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_objc_register_callbacks(%lu, %p, %p, %p, %p)\n", *(void *)a2, *(const void **)(a2 + 8), *(const void **)(a2 + 16), *(const void **)(a2 + 248), *(const void **)(a2 + 32));
  }
  switch(*(void *)a2)
  {
    case 1:
      uint64_t v11 = "_dyld_objc_register_callbacks v1 is no longer supported";
      goto LABEL_26;
    case 2:
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t v5 = *(void *)(a2 + 32);
      uint64_t v6 = *(void *)(a2 + 8);
      uint64_t v7 = *(void *)(a2 + 16);
      uint64_t v8 = (const os_unfair_lock *)this;
      uint64_t v9 = 0;
      goto LABEL_19;
    case 3:
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t v5 = *(void *)(a2 + 32);
      uint64_t v9 = *(void *)(a2 + 8);
      uint64_t v7 = *(void *)(a2 + 16);
      goto LABEL_18;
    case 4:
      if (*(void *)(a2 + 24)) {
        uint64_t v4 = *(void *)(a2 + 24);
      }
      else {
        uint64_t v4 = 0;
      }
      if (*(void *)(a2 + 32)) {
        uint64_t v5 = *(void *)(a2 + 32);
      }
      else {
        uint64_t v5 = 0;
      }
      if (*(void *)(a2 + 16)) {
        uint64_t v7 = *(void *)(a2 + 16);
      }
      else {
        uint64_t v7 = 0;
      }
      if (*(void *)(a2 + 8)) {
        uint64_t v9 = *(void *)(a2 + 8);
      }
      else {
        uint64_t v9 = 0;
      }
LABEL_18:
      uint64_t v8 = (const os_unfair_lock *)this;
      uint64_t v6 = 0;
LABEL_19:
      dyld4::RuntimeState::setObjCNotifiers(v8, v4, v5, v6, v7, v9);
      uint64_t v10 = this[124];
      if (v10)
      {
        dyld4::PrebuiltLoaderSet::logDuplicateObjCClasses(v10, this);
      }
      return;
    default:
      uint64_t v11 = "_dyld_objc_register_callbacks unknown version";
LABEL_26:
      dyld4::halt(v11, 0);
  }
}

const os_unfair_lock *dyld4::RuntimeState::setObjCNotifiers(const os_unfair_lock *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = result;
  uint64_t v21 = *(void *)&result[32]._os_unfair_lock_opaque;
  if (v21) {
    uint64_t v12 = *(void *)&result[32]._os_unfair_lock_opaque;
  }
  else {
    uint64_t v12 = 0;
  }
  if (*(unsigned char *)(v12 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_36;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_36;
    }
    unint64_t v20 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v20)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_36;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v13 = MEMORY[0xFFFFFC0D0];
      if (v13 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v20 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v12, v22);
    uint64_t v14 = *(void *)(v12 + 24);
    if (!v14)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v12, 0);
      uint64_t v14 = *(void *)(v12 + 24);
    }
    *(void *)(v12 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14 + 1;
    lsl::Lock::unlock(v22[0]);
  }
  *(void *)&v11[166]._uint32_t os_unfair_lock_opaque = a2;
  *(void *)&v11[168]._uint32_t os_unfair_lock_opaque = a3;
  *(void *)&v11[170]._uint32_t os_unfair_lock_opaque = a4;
  *(void *)&v11[172]._uint32_t os_unfair_lock_opaque = a5;
  *(void *)&v11[174]._uint32_t os_unfair_lock_opaque = a6;
  uint64_t v15 = *(uint64_t **)&v11[34]._os_unfair_lock_opaque;
  v22[0] = (lsl::Lock *)_NSConcreteStackBlock;
  v22[1] = (lsl::Lock *)0x40000000;
  v22[2] = (lsl::Lock *)___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke;
  v22[3] = (lsl::Lock *)&__block_descriptor_tmp_170;
  v22[4] = (lsl::Lock *)v11;
  uint64_t result = (const os_unfair_lock *)dyld4::RuntimeLocks::withLoadersReadLock(v15, (uint64_t)v22);
  if (v21) {
    uint64_t v16 = v21;
  }
  else {
    uint64_t v16 = 0;
  }
  if (*(unsigned char *)(v16 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_36;
    }
    if (v20 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return result;
    }
    if (v20 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v17 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_36;
      }
      uint64_t result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v17 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v17 == StatusReg) {
      return result;
    }
LABEL_36:
    __break(1u);
    return result;
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v16, v22);
  if (v20 == 1)
  {
    uint64_t v19 = *(void *)(v16 + 24) - 1;
    *(void *)(v16 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v19;
    if (!v19) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v16, 1);
    }
  }
  return lsl::Lock::unlock(v22[0]);
}

void dyld4::RuntimeState::addTLVTerminationFunc(dyld4::RuntimeState *this, void (*a2)(void *), void *a3)
{
  uint64_t v6 = (void *)(*(uint64_t (**)(void, void))(**((void **)this + 19) + 64))(*((void *)this + 19), *((void *)this + 139));
  if (!v6)
  {
    uint64_t v6 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 8))(*((void *)this + 19), 128);
    bzero(v6, 0x80uLL);
    (*(void (**)(void, void, void *))(**((void **)this + 19) + 72))(*((void *)this + 19), *((void *)this + 139), v6);
  }
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6);
  uint64_t v8 = v7[1];
  if (v8 == 7)
  {
    uint64_t v9 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 8))(*((void *)this + 19), 128);
    bzero(v9, 0x80uLL);
    void *v7 = v9;
    uint64_t v8 = v9[1];
    uint64_t v7 = v9;
  }
  v7[1] = v8 + 1;
  uint64_t v10 = &v7[2 * v8];
  _OWORD v10[2] = a2;
  void v10[3] = a3;
}

uint64_t dyld4::APIs::dyld_shared_cache_iterate_text(dyld4::RuntimeState *this, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_iterate_text()\n");
  }
  uint64_t v7 = 0;
  return (*(uint64_t (**)(dyld4::RuntimeState *, uint64_t, uint64_t *, uint64_t))(*(void *)this + 528))(this, a2, &v7, a3);
}

uint64_t dyld4::APIs::dyld_shared_cache_find_iterate_text(dyld4::RuntimeState *this, dyld4::RuntimeState *a2, char **a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v9 = *((void *)this + 1);
  if (*(unsigned char *)(v9 + 204))
  {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_find_iterate_text()\n");
    uint64_t v9 = *((void *)this + 1);
  }
  size_t v25 = 0;
  CacheInDirAndMap = *(DyldSharedCache **)(v9 + 240);
  if (!CacheInDirAndMap
    || ((__n128 v26 = 0uLL, DyldSharedCache::getUUID(CacheInDirAndMap, &v26), v26.n128_u64[0] == *(void *)a2)
      ? (BOOL v11 = v26.n128_u64[1] == *((void *)a2 + 1))
      : (BOOL v11 = 0),
        !v11))
  {
    CacheInDirAndMap = (DyldSharedCache *)dyld4::findCacheInDirAndMap(this, a2, "/System/Library/Caches/com.apple.dyld/", (const char *)&v25, a5);
    if (!CacheInDirAndMap)
    {
      uint64_t v12 = 0;
      while (1)
      {
        uint64_t v13 = cryptexPrefixes[v12];
        v26.n128_u8[0] = 0;
        if (dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, v13, (const char *)0x400) <= 0x3FF
          && dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, "/System/Library/Caches/com.apple.dyld/", (const char *)0x400) <= 0x3FF)
        {
          uint64_t v15 = dyld4::findCacheInDirAndMap(this, a2, (char *)&v26, (const char *)&v25, v14);
          if (v15) {
            break;
          }
        }
        if (++v12 == 3)
        {
          CacheInDirAndMap = (DyldSharedCache *)dyld4::findCacheInDirAndMap(this, a2, "/System/DriverKit/System/Library/dyld/", (const char *)&v25, v14);
          if (CacheInDirAndMap) {
            goto LABEL_26;
          }
          uint64_t v16 = 0;
          while (1)
          {
            uint64_t v17 = cryptexPrefixes[v16];
            v26.n128_u8[0] = 0;
            if (dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, v17, (const char *)0x400) <= 0x3FF
              && dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, "/System/DriverKit/System/Library/dyld/", (const char *)0x400) <= 0x3FF)
            {
              uint64_t v15 = dyld4::findCacheInDirAndMap(this, a2, (char *)&v26, (const char *)&v25, v18);
              if (v15) {
                goto LABEL_25;
              }
            }
            if (++v16 == 3)
            {
              uint64_t v19 = *a3;
              if (!*a3) {
                return 0xFFFFFFFFLL;
              }
              unint64_t v20 = a3 + 1;
              while (1)
              {
                uint64_t v15 = dyld4::findCacheInDirAndMap(this, a2, v19, (const char *)&v25, v18);
                if (v15) {
                  break;
                }
                uint64_t v21 = *v20++;
                uint64_t v19 = v21;
                uint64_t result = 0xFFFFFFFFLL;
                if (!v21) {
                  return result;
                }
              }
              goto LABEL_25;
            }
          }
        }
      }
LABEL_25:
      CacheInDirAndMap = (DyldSharedCache *)v15;
    }
  }
LABEL_26:
  v26.n128_u64[0] = 0;
  v26.n128_u64[1] = (unint64_t)&v26;
  uint64_t v27 = 0x2000000000;
  uint64_t v28 = 0;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000;
  _OWORD v24[2] = ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke;
  v24[3] = &unk_1EFF65550;
  v24[4] = &v26;
  DyldSharedCache::forEachRegion((uint64_t)CacheInDirAndMap, (uint64_t)v24);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  void v23[2] = ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke_2;
  v23[3] = &unk_1EFF65578;
  v23[4] = a4;
  v23[5] = &v26;
  DyldSharedCache::forEachImageTextSegment((uint64_t)CacheInDirAndMap, (uint64_t)v23);
  if (v25) {
    munmap(CacheInDirAndMap, v25);
  }
  _Block_object_dispose(&v26, 8);
  return 0;
}

uint64_t dyld4::APIs::dlerror(dyld4::APIs *this)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dlerror()");
  }
  if (*((void *)this + 140) == -1) {
    return 0;
  }
  uint64_t result = *((void *)this + 19);
  if (!result) {
    return result;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 64))(result);
  if (!v3 || (uint64_t v4 = v3, !*(unsigned char *)(v3 + 8)))
  {
    if (*(unsigned char *)(*((void *)this + 1) + 204)) {
      dyld4::RuntimeState::log(this, " => NULL\n");
    }
    return 0;
  }
  *(unsigned char *)(v3 + 8) = 0;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, " => '%s'\n", (const char *)(v3 + 9));
  }
  return v4 + 9;
}

uint64_t dyld4::APIs::NSVersionOfRunTimeLibrary(dyld4::APIs *this, const char *a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = -1;
  uint64_t v4 = (uint64_t *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs25NSVersionOfRunTimeLibraryEPKc_block_invoke;
  void v7[3] = &unk_1EFF65110;
  v7[5] = this;
  void v7[6] = a2;
  v7[4] = &v8;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "NSVersionOfRunTimeLibrary(%s) => 0x%08X\n", a2, *((_DWORD *)v9 + 6));
  }
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

const os_unfair_lock *dyld4::APIs::_dyld_register_dlsym_notifier(const os_unfair_lock *this, void (*a2)(const char *))
{
  uint64_t v2 = *(void *)&this[32]._os_unfair_lock_opaque;
  uint64_t v3 = *(void **)&this[34]._os_unfair_lock_opaque;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  uint64_t v13 = ___ZN5dyld44APIs29_dyld_register_dlsym_notifierEPFvPKcE_block_invoke;
  uint64_t v14 = &__block_descriptor_tmp_195;
  uint64_t v15 = this;
  uint64_t v16 = a2;
  uint64_t v18 = v2;
  unint64_t v17 = 0;
  if (v2) {
    uint64_t v4 = v2;
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(unsigned char *)(v4 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_42;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_42;
    }
    unint64_t v17 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v17)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_42;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_42;
      }
      this = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v5 = MEMORY[0xFFFFFC0D0];
      if (v5 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_42;
      }
    }
  }
  else
  {
    unint64_t v17 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v4, &v19);
    uint64_t v6 = *(void *)(v4 + 24);
    if (!v6)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v4, 0);
      uint64_t v6 = *(void *)(v4 + 24);
    }
    *(void *)(v4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6 + 1;
    lsl::Lock::unlock(v19);
  }
  if (*v3)
  {
    (*(void (**)(void, void *, void))(*(void *)*v3 + 104))(*v3, v3 + 2, 0);
    v13((uint64_t)v12);
    this = (const os_unfair_lock *)(*(uint64_t (**)(void, void *))(*(void *)*v3 + 112))(*v3, v3 + 2);
  }
  else
  {
    this = (const os_unfair_lock *)v13((uint64_t)v12);
  }
  if (v18) {
    uint64_t v7 = v18;
  }
  else {
    uint64_t v7 = 0;
  }
  if (*(unsigned char *)(v7 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_42;
    }
    if (v17 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return this;
    }
    if (v17 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_42;
      }
      this = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v8 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_42;
      }
      this = (const os_unfair_lock *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v8 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v8 == StatusReg) {
      return this;
    }
LABEL_42:
    __break(1u);
    return this;
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v7, &v19);
  if (v17 == 1)
  {
    uint64_t v11 = *(void *)(v7 + 24) - 1;
    *(void *)(v7 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v11;
    if (!v11) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v7, 1);
    }
  }
  else if (v17 == 0xFFFFFFFF)
  {
    uint64_t v10 = *(void *)(v7 + 24);
    if (!v10)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v7, 0);
      uint64_t v10 = *(void *)(v7 + 24);
    }
    *(void *)(v7 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10 + 1;
  }
  return lsl::Lock::unlock(v19);
}

uint64_t ___ZN5dyld44APIs29_dyld_register_dlsym_notifierEPFvPKcE_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 96dyld4::halt((char *)__format, 0) = *(void *)(result + 40);
  return result;
}

uint64_t dyld4::APIs::_dyld_get_image_vmaddr_slide(dyld4::APIs *this, int a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  uint64_t v4 = (uint64_t *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZN5dyld44APIs28_dyld_get_image_vmaddr_slideEj_block_invoke;
  void v7[3] = &unk_1EFF65098;
  int v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_vmaddr_slide(%u) => 0x%lX\n", a2, v10[3]);
  }
  uint64_t v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

void dyld4::APIs::dyld_get_image_versions(dyld4::RuntimeState *this, unsigned int *a2, const void *a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_image_versions(%p, %p)\n", a2, a3);
  }

  dyld4::APIs::forEachImageVersion((uint64_t)this, a2, (uint64_t)a3);
}

uint64_t dyld4::APIs::dlclose(dyld4::APIs *this, unint64_t a2)
{
  uint64_t v4 = (dyld4::RuntimeLocks *)*((void *)this + 17);
  dyld4::RuntimeLocks::takeDlopenLockBeforeFork(v4);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dlclose(%p)\n", (const void *)a2);
  }
  int v21 = 520617992;
  unint64_t v22 = a2;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v21, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v12 = 0;
  if (a2 != -5 && a2 != -2)
  {
    if (a2) {
      uint64_t v13 = (const dyld4::Loader *)(a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A8DFD000);
    }
    else {
      uint64_t v13 = 0;
    }
    if (dyld4::APIs::validLoader((lsl::Allocator **)this, v13))
    {
      dyld4::RuntimeState::decDlRefCount(this, (uint64_t)v13, v14, v15, v16, v17, v18, v19);
      dyld4::APIs::clearErrorString((uint64_t)this);
      uint64_t v12 = 0;
    }
    else
    {
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlclose(%p): invalid handle", (const void *)a2);
      uint64_t v12 = 0xFFFFFFFFLL;
    }
  }
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v21);
  dyld4::RuntimeLocks::releaseDlopenLockInForkParent(v4);
  return v12;
}

void dyld4::RuntimeState::decDlRefCount(dyld4::RuntimeState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a2 + 4) & 0x20) == 0)
  {
    uint64_t v8 = a2;
    uint64_t v22 = *((void *)this + 16);
    if (v22) {
      uint64_t v10 = *((void *)this + 16);
    }
    else {
      uint64_t v10 = 0;
    }
    if (*(unsigned char *)(v10 + 32))
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_49;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_49;
      }
      unint64_t v21 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
      if (!v21)
      {
        if (!MEMORY[0xFFFFFC10C]) {
          goto LABEL_49;
        }
        if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_49;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        a2 = 0xFFFFFC0D0;
        uint64_t v11 = MEMORY[0xFFFFFC0D0];
        if (v11 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
          goto LABEL_49;
        }
      }
    }
    else
    {
      unint64_t v21 = 1;
      lsl::MemoryManager::lockGuard((lsl::Lock *)v10, &v23);
      uint64_t v12 = *(void *)(v10 + 24);
      if (!v12)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 0);
        uint64_t v12 = *(void *)(v10 + 24);
      }
      *(void *)(v10 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12 + 1;
      lsl::Lock::unlock(v23);
    }
    uint64_t v13 = *((void *)this + 132);
    if (v13)
    {
      uint64_t v14 = (void *)(*((void *)this + 131) + 8);
      uint64_t v15 = 16 * v13 - 16;
      while (*(v14 - 1) != v8)
      {
        v14 += 2;
        v15 -= 16;
        if (v15 == -16) {
          goto LABEL_27;
        }
      }
      if ((*v14)-- == 1)
      {
        if (v15)
        {
          memmove(v14 - 1, v14 + 1, v15);
          uint64_t v13 = *((void *)this + 132);
        }
        *((void *)this + 132) = v13 - 1;
        if (!atomic_fetch_add_explicit((atomic_uint *volatile)this + 276, 1u, memory_order_relaxed))
        {
          do
            dyld4::RuntimeState::garbageCollectInner((lsl::Lock ***)this, a2, v15, a4, a5, a6, a7, a8);
          while ((int)atomic_fetch_add_explicit((atomic_uint *volatile)this + 276, 0xFFFFFFFF, memory_order_relaxed) > 1);
        }
      }
    }
LABEL_27:
    if (v22) {
      uint64_t v17 = v22;
    }
    else {
      uint64_t v17 = 0;
    }
    if (*(unsigned char *)(v17 + 32))
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_49;
      }
      if (v21 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        return;
      }
      if (v21 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_49;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v18 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_49;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v18 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v18 == StatusReg) {
        return;
      }
LABEL_49:
      __break(1u);
      return;
    }
    lsl::MemoryManager::lockGuard((lsl::Lock *)v17, &v23);
    if (v21 == 1)
    {
      uint64_t v20 = *(void *)(v17 + 24) - 1;
      *(void *)(v17 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v20;
      if (!v20) {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v17, 1);
      }
    }
    lsl::Lock::unlock(v23);
  }
}

int64_t dyld3::kdebug_trace_dyld_marker(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10)
{
  uint64_t v11 = a6;
  uint64_t v13 = a4;
  uint64_t v15 = (void *)a2;
  int64_t result = kdebug_is_enabled(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!result) {
    return result;
  }
  if (a3)
  {
    int64_t v23 = kdebug_trace_string(a1, 0, a3, v18, v19, v20, v21, v22);
    if (v23 == -1) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = (void *)v23;
    }
  }
  if (a5)
  {
    int64_t v24 = kdebug_trace_string(a1, 0, a5, v18, v19, v20, v21, v22);
    if (v24 == -1) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = (void *)v24;
    }
  }
  if (a7)
  {
    int64_t v25 = kdebug_trace_string(a1, 0, a7, v18, v19, v20, v21, v22);
    if (v25 == -1) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (void *)v25;
    }
  }
  if (a10)
  {
    int64_t v26 = kdebug_trace_string(a1, 0, a10, v18, v19, v20, v21, v22);
    if (v26 == -1) {
      uint64_t v30 = 0;
    }
    else {
      uint64_t v30 = (void *)v26;
    }
    int64_t result = kdebug_trace(a1, v15, v13, v11, v30, v27, v28, v29);
    if (v30) {
      int64_t result = kdebug_trace_string(a1, v30, 0, v31, v32, v33, v34, v35);
    }
    if (!a7) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  int64_t result = kdebug_trace(a1, v15, v13, v11, a9, v20, v21, v22);
  if (a7)
  {
LABEL_23:
    if (v11) {
      int64_t result = kdebug_trace_string(a1, v11, 0, v31, v32, v33, v34, v35);
    }
  }
LABEL_25:
  if (a5 && v13) {
    int64_t result = kdebug_trace_string(a1, v13, 0, v31, v32, v33, v34, v35);
  }
  if (a3 && v15)
  {
    return kdebug_trace_string(a1, v15, 0, v31, v32, v33, v34, v35);
  }
  return result;
}

void lsl::Lock::lock()
{
  __assert_rtn("lock", "Allocator.cpp", 100, "_runtimeState != nullptr");
}

void _dyld_start(uint64_t a1, unsigned int *a2, DyldSharedCache *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9)
{
}

uint64_t dyld4::restartWithDyldInCache(dyld4 *this, const dyld4::KernelArgs *a2, const dyld3::MachOFile *a3, const DyldSharedCache *a4, void *a5)
{
  return ((uint64_t (*)(void))a4)();
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

uint64_t ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke(void *a1, unsigned int *a2)
{
  uint64_t v3 = a1[5];
  uint64_t v4 = (vm_address_t *)(*(void *)(a1[4] + 8) + 40);
  uint64_t v5 = a1[6];
  uint64_t v8 = 0;
  long long v7 = 0uLL;
  return dyld3::MachOLoaded::fixupAllChainedFixups(v3, v4, a2, v5, &v7, 0);
}

uint64_t ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 56) & 2) != 0) {
    return dyld4::SyscallDelegate::mprotect((dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate, (void *)(*(void *)(result + 32) + *(void *)(a2 + 16)), *(void *)(a2 + 24), 1);
  }
  return result;
}

__n128 __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

double __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__21(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke(uint64_t a1, const char *a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  uint64_t Loader = dyld4::Loader::getLoader(&v16, *(DyldSharedCache ****)(a1 + 40), a2, a1 + 48);
  if (Loader)
  {
    uint64_t v5 = Loader;
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    long long v7 = *(dyld4::Loader ***)(v6 + 40);
    uint64_t v8 = *(void *)(v6 + 56);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      while (*v7 != Loader)
      {
        ++v7;
        v9 -= 8;
        if (!v9) {
          goto LABEL_6;
        }
      }
      uint64_t v15 = *(dyld4::RuntimeState **)(a1 + 40);
      if (*(unsigned char *)(*((void *)v15 + 1) + 200)) {
        dyld4::RuntimeState::log(v15, "skipping duplicate inserted dylib '%s'\n", a2);
      }
    }
    else
    {
LABEL_6:
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v6 + 40), 1);
      uint64_t v10 = *(void *)(v6 + 40);
      uint64_t v11 = *(void *)(v6 + 56);
      *(void *)(v6 + 56) = v11 + 1;
      *(void *)(v10 + 8 * v11) = v5;
      dyld4::RuntimeState::notifyDebuggerLoad(*(dyld4::RuntimeState **)(a1 + 40), v5);
      if (*((_WORD *)v5 + 2)) {
        dyld4::RuntimeState::add(*(dyld4::RuntimeState **)(a1 + 40), v5);
      }
    }
  }
  else if (Diagnostics::hasError((Diagnostics *)&v16))
  {
    uint64_t v12 = *(dyld4::RuntimeState **)(a1 + 40);
    if (!*(unsigned char *)(*((void *)v12 + 1) + 189))
    {
      uint64_t v13 = (const char *)Diagnostics::errorMessageCStr((Diagnostics *)&v16);
      dyld4::RuntimeState::log(v12, "terminating because inserted dylib '%s' could not be loaded: %s\n", a2, v13);
      uint64_t v14 = (char *)Diagnostics::errorMessage((Diagnostics *)&v16);
      dyld4::halt(v14, 0);
    }
  }
  mach_o::Error::~Error(&v16);
}

__n128 __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
}

void *___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_28(uint64_t a1, const char *a2)
{
  return dyld4::MissingPaths::addPath((dyld4::MissingPaths *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
}

dyld3::MachOFile *___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t a1, unsigned int *a2)
{
  unint64_t v4 = dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 2), *(dyld4::RuntimeState **)(a1 + 32));
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(dyld3::MachOFile **)(*(void *)(v5 + 8) + 240);
  unsigned int v7 = *a2;
  unsigned int v8 = a2[1];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  _OWORD v10[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_3;
  void v10[3] = &__block_descriptor_tmp_33;
  v10[4] = v5;
  v10[5] = v4;
  void v10[6] = *(void *)(a1 + 40);
  return DyldSharedCache::forEachPatchableUseOfExport(v6, v7, v8, (uint64_t)v10);
}

void ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_3(uint64_t a1, uint64_t a2, BOOL a3, uint64_t a4)
{
  uint64_t v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 240) + a2);
  uint64_t v6 = *(void *)(a1 + 40) + a4;
  if ((a3 & 0x1000000) != 0) {
    uint64_t v6 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(v6, (unint64_t)v5, (void *)((a3 >> 27) & 1), a3, (a3 >> 25) & 3);
  }
  if (*v5 != v6)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(unsigned char **)(a1 + 48));
    unsigned int v7 = *(dyld4::RuntimeState **)(a1 + 32);
    if (*(unsigned char *)(*((void *)v7 + 1) + 202)) {
      dyld4::RuntimeState::log(v7, "cache patch: %p = 0x%0lX\n", v5, v6);
    }
    *uint64_t v5 = v6;
  }
}

void dyld4::fake_main(dyld4 *this, int a2, const char *const *a3, const char *const *a4, const char *const *a5)
{
}

uint64_t dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  uint64_t v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve((void *)(a1 + 56), 0x20uLL);
  return a1;
}

void *dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 4 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    __n128 result = memmove((void *)v3[3], *v3, 4 * (void)v3[2]);
    unsigned int v8 = (const void *)((unint64_t)v3[4] >> 2);
    void *v3 = v3[3];
    v3[1] = v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

void *dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 24 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    __n128 result = memmove((void *)v3[3], *v3, 24 * (void)v3[2]);
    unint64_t v8 = (unint64_t)v3[4] / 0x18;
    void *v3 = v3[3];
    v3[1] = (const void *)v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

void dyld4::ProcessConfig::Security::pruneEnvVars(dyld4::ProcessConfig::Security *this, dyld4::ProcessConfig::Process *a2)
{
  unint64_t v2 = (const char **)*((void *)a2 + 14);
  uint64_t v3 = *v2;
  if (*v2)
  {
    int v5 = 0;
    unint64_t v6 = v2 + 1;
    do
    {
      if (_platform_strncmp(v3, "DYLD_", 5uLL)) {
        *v2++ = v3;
      }
      else {
        ++v5;
      }
      vm_size_t v7 = *v6++;
      uint64_t v3 = v7;
    }
    while (v7);
    *unint64_t v2 = 0;
    if (v5 > 0)
    {
      unint64_t v8 = v2 + 1;
      *((void *)a2 + 15) = v2 + 1;
      do
      {
        uint64_t v9 = v8[v5];
        *v8++ = v9;
      }
      while (v9);
      bzero(v8, 8 * v5);
    }
  }
  else
  {
    *unint64_t v2 = 0;
  }
}

ssize_t dyld4::console(dyld4 *this, const char *a2, ...)
{
  va_start(va, a2);
  if (getpid() == 1)
  {
    int v3 = open("/dev/console", 131073, 0);
    pid_t v4 = getpid();
    _simple_dprintf(2, "dyld[%d]: ", v5, v6, v7, v8, v9, v10, v4);
    _simple_vdprintf(v3, (char *)this, (int *)va);
    return close(v3);
  }
  else
  {
    pid_t v12 = getpid();
    _simple_dprintf(2, "dyld[%d]: ", v13, v14, v15, v16, v17, v18, v12);
    return _simple_vdprintf(2, (char *)this, (int *)va);
  }
}

uint64_t dyld4::ProcessConfig::DyldCache::makeDataConstWritable(char **a1, uint64_t a2, uint64_t a3, int a4)
{
  pid_t v4 = *a1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke;
  void v7[3] = &__block_descriptor_tmp_72;
  v7[4] = a1;
  v7[5] = a2;
  if (a4) {
    int v5 = 19;
  }
  else {
    int v5 = 1;
  }
  int v8 = v5;
  void v7[6] = a3;
  return DyldSharedCache::forEachCache(v4, (uint64_t)v7);
}

uint64_t ___ZN5dyld413ProcessConfig9DyldCacheC2ERNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke(uint64_t a1, int a2, uint64_t a3, vm_size_t size)
{
  return vm_protect(mach_task_self_, *(void *)(*(void *)(a1 + 32) + 24) + a3, size, 0, 19);
}

uint64_t dyld4::ProcessConfig::DyldCache::setupDyldCommPage(dyld4::ProcessConfig::DyldCache *this, dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, dyld4::SyscallDelegate *a4)
{
  BOOL v7 = dyld4::SyscallDelegate::bootVolumeWritable(a4);
  uint64_t v8 = *((void *)a2 + 11);
  uint64_t v9 = 0x800000000;
  if (!v7) {
    uint64_t v9 = 0;
  }
  unint64_t v10 = v8 & 0xFFFFFFF7FFFFFFFFLL | v9;
  *((void *)a2 + 11) = v10;
  if (!*((unsigned char *)a3 + 1))
  {
    unint64_t v10 = v8 & 0xFFFFFFE7FFFFFFB8 | 1;
    *((void *)a2 + 11) = v10;
  }

  return dyld4::SyscallDelegate::setDyldCommPageFlags((uint64_t)a4, v10);
}

uint64_t ___ZN5dyld413ProcessConfig9DyldCache20setPlatformOSVersionERKNS0_7ProcessE_block_invoke(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(void *)(result + 32);
  uint64_t v4 = *(void *)(result + 40);
  if (*(_DWORD *)(v4 + 60) == a2) {
    goto LABEL_5;
  }
  if (a2 == 6 && *(unsigned char *)(v4 + 149))
  {
    a2 = 6;
LABEL_5:
    *(_DWORD *)(v3 + 144) = a2;
    *(_DWORD *)(v3 + 148) = a3;
  }
  return result;
}

BOOL dyld4::ProcessConfig::DyldCache::findMachHeaderImageIndex(DyldSharedCache **this, const mach_header *a2, unsigned int *a3)
{
  return DyldSharedCache::findMachHeaderImageIndex(*this, a2, a3);
}

uint64_t ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke_2;
  v3[3] = &__block_descriptor_tmp_70;
  long long v4 = *(_OWORD *)(a1 + 32);
  int v6 = *(_DWORD *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 48);
  return DyldSharedCache::forEachRegion(a2, (uint64_t)v3);
}

ssize_t ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke_2(ssize_t result, const char *a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 0x40) == 0 && (a7 & 4) != 0)
  {
    ssize_t v8 = result;
    vm_address_t v9 = *(void *)(*(void *)(result + 32) + 24) + a3;
    if (*(unsigned char *)(*(void *)(result + 40) + 1)) {
      dyld4::console((dyld4 *)"marking shared cache range 0x%x permissions: 0x%09lX -> 0x%09lX\n", a2, *(unsigned int *)(result + 56), *(void *)(*(void *)(result + 32) + 24) + a3, v9 + size);
    }
    __n128 result = dyld4::SyscallDelegate::vm_protect(*(dyld4::SyscallDelegate **)(v8 + 48), mach_task_self_, v9, size, 0, *(_DWORD *)(v8 + 56));
    if (result)
    {
      if (*(unsigned char *)(*(void *)(v8 + 40) + 1)) {
        return dyld4::console((dyld4 *)"failed to mprotect shared cache due to: %d\n", v10, result);
      }
    }
  }
  return result;
}

BOOL dyld4::ProcessConfig::DyldCache::isAlwaysOverridablePath(dyld4::ProcessConfig::DyldCache *this, const char *a2)
{
  return _platform_strcmp((const char *)this, "/usr/lib/system/libdispatch.dylib") == 0;
}

uint64_t dyld4::ProcessConfig::DyldCache::getIndexedImagePath(DyldSharedCache **this, int a2)
{
  return DyldSharedCache::getIndexedImagePath(*this, a2);
}

uint64_t dyld4::ProcessConfig::DyldCache::getIndexedImageEntry(DyldSharedCache **this, int a2, unint64_t *a3, unint64_t *a4)
{
  return DyldSharedCache::getIndexedImageEntry(*this, a2, a3, a4);
}

size_t ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke(uint64_t a1, char *__s)
{
  return dyld4::ProcessConfig::PathOverrides::addEnvVar(*(char ***)(a1 + 32), *(const dyld4::ProcessConfig::Process **)(a1 + 40), *(const dyld4::ProcessConfig::Security **)(a1 + 48), *(lsl::Lock ***)(a1 + 56), __s, 1, 0);
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke_2(uint64_t a1, char *__s1)
{
  uint64_t result = _platform_strncmp(__s1, "DYLD_", 5uLL);
  if (!result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

size_t dyld4::ProcessConfig::PathOverrides::checkVersionedPath(dyld4::ProcessConfig::PathOverrides *a1, int a2, DyldSharedCache **a3, lsl::Lock **a4, dyld3 *a5, int a6, uint64_t a7)
{
  unsigned int v23 = 0;
  size_t result = dyld4::SyscallDelegate::getDylibInfo(a2, a5, a6, a7, (uint64_t)&v23, (uint64_t)v26);
  if (!result) {
    return result;
  }
  unsigned int v21 = 0;
  unsigned int v22 = 0;
  size_t result = dyld4::SyscallDelegate::getDylibInfo(a2, (dyld3 *)v26, a6, a7, (uint64_t)&v22, (uint64_t)__s2);
  if ((result & 1) == 0)
  {
    if (!*a3
      || !DyldSharedCache::hasImagePath(*a3, v26, &v21)
      || (v24[0] = 0,
          unint64_t v20 = 0,
          IndexedImageEntry = (dyld3::MachOFile *)DyldSharedCache::getIndexedImageEntry(*a3, v21, v24, &v20),
          __source = 0,
          unsigned int v18 = 0,
          !dyld3::MachOFile::getDylibInstallName(IndexedImageEntry, (const char **)&__source, &v18, &v22)))
    {
      uint64_t v17 = v26;
      return (size_t)dyld4::ProcessConfig::PathOverrides::addPathOverride(a1, a4, v17, (const char *)a5);
    }
    size_t result = strlcpy(__s2, __source, 0x400uLL);
  }
  if (v23 > v22)
  {
    uint64_t v15 = (char *)a1 + 128;
    do
    {
      uint64_t v15 = *(char **)v15;
      if (!v15)
      {
        uint64_t v17 = __s2;
        return (size_t)dyld4::ProcessConfig::PathOverrides::addPathOverride(a1, a4, v17, (const char *)a5);
      }
    }
    while (_platform_strcmp(*((const char **)v15 + 1), __s2));
    LODWORD(v2dyld4::halt((char *)__format, 0) = 0;
    size_t result = dyld4::SyscallDelegate::getDylibInfo(a2, *((dyld3 **)v15 + 2), a6, a7, (uint64_t)&v20, (uint64_t)v24);
    if (result)
    {
      if (v23 > v20)
      {
        size_t result = (size_t)lsl::Allocator::strdup(a4, (const char *)a5);
        *((void *)v15 + 2) = result;
      }
    }
  }
  return result;
}

char *dyld4::ProcessConfig::PathOverrides::addPathOverride(dyld4::ProcessConfig::PathOverrides *this, lsl::Lock **a2, const char *a3, const char *a4)
{
  ssize_t v8 = lsl::Allocator::malloc(a2, 0x18uLL);
  *ssize_t v8 = 0;
  v8[1] = lsl::Allocator::strdup(a2, a3);
  size_t result = lsl::Allocator::strdup(a2, a4);
  v8[2] = result;
  pid_t v12 = (void *)*((void *)this + 16);
  uint64_t v11 = (void *)((char *)this + 128);
  for (uint64_t i = v12; i; uint64_t i = (void *)*i)
    uint64_t v11 = i;
  *uint64_t v11 = v8;
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachInColonList(uint64_t result, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v6 = 0;
  v21[0] = result;
  v21[1] = a2;
  while (2)
  {
    BOOL v7 = (char *)v21[v6];
    if (!v7) {
      goto LABEL_10;
    }
    size_t v8 = _platform_strlen((const char *)v21[v6]);
    __chkstk_darwin(v8, v9, v10, v11, v12, v13, v14, v15, v20);
    uint64_t v17 = (char *)&v21[-1] - ((v16 + 16) & 0xFFFFFFFFFFFFFFF0);
    unsigned int v18 = v7 + 1;
    uint64_t v19 = v7;
    while (*(v18 - 1) == 58)
    {
      memmove(v17, v19, v7 - v19);
      v7[v17 - v19] = 0;
      size_t result = (*(uint64_t (**)(uint64_t, char *, unsigned char *))(a4 + 16))(a4, v17, a3);
      uint64_t v19 = v18;
      if (*a3) {
        return result;
      }
LABEL_8:
      ++v18;
      ++v7;
    }
    if (*(v18 - 1)) {
      goto LABEL_8;
    }
    size_t result = (*(uint64_t (**)(uint64_t, char *, unsigned char *))(a4 + 16))(a4, v19, a3);
    if (!*a3)
    {
LABEL_10:
      if (++v6 == 2) {
        return result;
      }
      continue;
    }
    return result;
  }
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_2;
  void v4[3] = &__block_descriptor_tmp_85;
  v4[4] = v2;
  long long v5 = *(_OWORD *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 72);
  long long v6 = *(_OWORD *)(a1 + 56);
  return dyld4::SyscallDelegate::forEachInDirectory(v5, a2, 0, (uint64_t)v4);
}

size_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_2(uint64_t a1, dyld3 *a2)
{
  return dyld4::ProcessConfig::PathOverrides::checkVersionedPath(*(dyld4::ProcessConfig::PathOverrides **)(a1 + 32), *(void *)(a1 + 40), *(DyldSharedCache ***)(a1 + 48), *(lsl::Lock ***)(a1 + 56), a2, *(_DWORD *)(a1 + 72), *(void *)(a1 + 64));
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_3(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_4;
  void v4[3] = &__block_descriptor_tmp_88;
  v4[4] = v2;
  long long v5 = *(_OWORD *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 72);
  long long v6 = *(_OWORD *)(a1 + 56);
  return dyld4::SyscallDelegate::forEachInDirectory(v5, a2, 1, (uint64_t)v4);
}

unint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_4(uint64_t a1, char *__s)
{
  long long v4 = *(dyld4::ProcessConfig::PathOverrides **)(a1 + 32);
  unint64_t result = _platform_strlen(__s);
  if (result >= 0xA)
  {
    unint64_t result = _platform_strcmp(&__s[result - 10], ".framework");
    if (!result)
    {
      strlcpy(__dst, __s, 0x400uLL);
      long long v6 = strrchr(__s, 47);
      strlcat(__dst, v6, 0x400uLL);
      *strrchr(__dst, 46) = 0;
      return dyld4::ProcessConfig::PathOverrides::checkVersionedPath(v4, *(void *)(a1 + 40), *(DyldSharedCache ***)(a1 + 48), *(lsl::Lock ***)(a1 + 56), (dyld3 *)__dst, *(_DWORD *)(a1 + 72), *(void *)(a1 + 64));
    }
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides20forEachInsertedDylibEU13block_pointerFvPKcRbE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2, *(void *)(*(void *)(a1 + 40) + 8) + 24);
}

char *dyld4::ProcessConfig::PathOverrides::setString(dyld4::ProcessConfig::PathOverrides *this, lsl::Lock **a2, char **a3, const char *__s)
{
  if (*a3)
  {
    _platform_strlen(*a3);
    size_t v7 = _platform_strlen(__s);
    __chkstk_darwin(v7, v8, v9, v10, v11, v12, v13, v14, v19);
    uint64_t v16 = (char *)&v19 - v15;
    uint64_t v17 = strcpy((char *)&v19 - v15, *a3);
    *(_WORD *)&v16[_platform_strlen(v17)] = 58;
    strcat(v16, __s);
    unint64_t result = lsl::Allocator::strdup(a2, v16);
  }
  else
  {
    unint64_t result = lsl::Allocator::strdup(a2, __s);
  }
  *a3 = result;
  return result;
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides9addEnvVarERKNS0_7ProcessERKNS0_8SecurityERN3lsl9AllocatorEPKcbPc_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(*(void *)(result + 40) + 16) || *__s1 != 64)
  {
    if (*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24)) {
      strlcat(*(char **)(result + 48), ":", *(void *)(result + 56));
    }
    if (_platform_strncmp(__s1, "@executable_path/", 0x11uLL))
    {
      int v4 = _platform_strncmp(__s1, "@loader_path/", 0xDuLL);
      size_t v5 = *(void *)(v3 + 56);
      long long v6 = *(const char **)(*(void *)(v3 + 64) + 8);
      size_t v7 = *(char **)(v3 + 48);
      if (v4)
      {
LABEL_12:
        unint64_t result = strlcpy(v7, v6, v5);
        *(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
        return result;
      }
      strlcat(v7, v6, v5);
      uint64_t v8 = *(char **)(v3 + 48);
      unint64_t result = (uint64_t)strrchr(v8, 47);
      if (!result) {
        return result;
      }
      size_t v7 = (char *)(result + 1);
      long long v6 = __s1 + 13;
    }
    else
    {
      strlcat(*(char **)(v3 + 48), *(const char **)(*(void *)(v3 + 64) + 8), *(void *)(v3 + 56));
      uint64_t v8 = *(char **)(v3 + 48);
      unint64_t result = (uint64_t)strrchr(v8, 47);
      if (!result) {
        return result;
      }
      size_t v7 = (char *)(result + 1);
      long long v6 = __s1 + 17;
    }
    size_t v5 = *(void *)(v3 + 56) + v8 - v7;
    goto LABEL_12;
  }
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachDylibFallback(uint64_t a1, unsigned int a2, int a3, unsigned char *a4, uint64_t a5)
{
  uint64_t result = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 64);
  if (result | v10)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___ZNK5dyld413ProcessConfig13PathOverrides20forEachDylibFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke;
    v13[3] = &unk_1EFF63980;
    uint64_t v13[4] = a5;
    void v13[5] = a4;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v10, a4, (uint64_t)v13);
  }
  if (a3 && a2 <= 0xC)
  {
    if (((1 << a2) & 0x83D) != 0)
    {
      if (*(_DWORD *)(a1 + 136) != 2)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, unsigned char *))(a5 + 16))(a5, "/usr/local/lib", 15, a4);
        if (*a4) {
          return result;
        }
      }
    }
    else if (((1 << a2) & 0x13C0) == 0)
    {
      if (a2 != 1) {
        return result;
      }
      int v11 = *(_DWORD *)(a1 + 136);
      if (v11 != 1)
      {
        if (v11) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, unsigned char *))(a5 + 16))(a5, "/usr/local/lib", 15, a4);
        if (*a4) {
          return result;
        }
      }
      goto LABEL_16;
    }
    if (*(_DWORD *)(a1 + 136) == 2) {
      return result;
    }
LABEL_16:
    uint64_t v12 = *(uint64_t (**)(uint64_t, const char *, uint64_t, unsigned char *))(a5 + 16);
    return v12(a5, "/usr/lib", 15, a4);
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides20forEachDylibFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2, 14, *(void *)(a1 + 40));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides24forEachFrameworkFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2, 14, *(void *)(a1 + 40));
}

size_t dyld4::ProcessConfig::PathOverrides::addSuffix(dyld4::ProcessConfig::PathOverrides *this, const char *a2, const char *a3, char *__dst)
{
  strlcpy(__dst, a2, 0x400uLL);
  size_t v7 = strrchr(__dst, 47);
  if (v7) {
    uint64_t v8 = v7 + 1;
  }
  else {
    uint64_t v8 = __dst;
  }
  uint64_t v9 = strrchr(v8, 46);
  if (v9)
  {
    uint64_t v10 = v9;
    strlcpy(v9, a3, 0x400uLL);
    int v11 = &v10[_platform_strlen(a3)];
    uint64_t v12 = &a2[v10 - __dst];
  }
  else
  {
    int v11 = __dst;
    uint64_t v12 = a3;
  }

  return strlcat(v11, v12, 0x400uLL);
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachImageSuffixEPKcNS1_4TypeERbU13block_pointerFvS3_S4_S5_E_block_invoke(uint64_t a1, const char *a2)
{
  int v4 = *(const char **)(a1 + 48);
  size_t v5 = _platform_strlen(v4);
  long long v6 = (dyld4::ProcessConfig::PathOverrides *)_platform_strlen(a2);
  dyld4::ProcessConfig::PathOverrides::addSuffix(v6, v4, a2, (char *)&v8 - (((unint64_t)v6 + v5 + 23) & 0xFFFFFFFFFFFFFFF0));
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke(uint64_t a1, char *__s)
{
  uint64_t v4 = *(void *)(a1 + 40);
  size_t v5 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v6 = v5 + 8;
  size_t v7 = (char *)&v9 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v7, __s, v5 + 8);
  strlcat(v7, "/", v6);
  strlcat(v7, *(const char **)(a1 + 56), v6);
  return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v4, (uint64_t)v7, 0, *(unsigned char **)(a1 + 64), *(void *)(a1 + 32));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_2(uint64_t a1, char *__s)
{
  uint64_t v4 = *(void *)(a1 + 40);
  size_t v5 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v6 = v5 + 8;
  size_t v7 = (char *)&v9 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v7, __s, v5 + 8);
  strlcat(v7, "/", v6);
  strlcat(v7, *(const char **)(a1 + 56), v6);
  return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v4, (uint64_t)v7, 0, *(unsigned char **)(a1 + 64), *(void *)(a1 + 32));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_3(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  size_t v7 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v8 = v7 + 8;
  uint64_t v9 = (char *)&v11 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v9, __s, v7 + 8);
  strlcat(v9, "/", v8);
  strlcat(v9, *(const char **)(a1 + 56), v8);
  uint64_t result = _platform_strcmp(*(const char **)(a1 + 64), v9);
  if (result) {
    return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v6, (uint64_t)v9, a3, *(unsigned char **)(a1 + 72), *(void *)(a1 + 32));
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_4(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  size_t v7 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v8 = v7 + 8;
  uint64_t v9 = (char *)&v11 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0);
  strlcpy(v9, __s, v7 + 8);
  strlcat(v9, "/", v8);
  strlcat(v9, *(const char **)(a1 + 56), v8);
  uint64_t result = _platform_strcmp(v9, *(const char **)(a1 + 64));
  if (result) {
    return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v6, (uint64_t)v9, a3, *(unsigned char **)(a1 + 72), *(void *)(a1 + 32));
  }
  return result;
}

void *dyld4::PseudoDylib::create(lsl::Lock **a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    dyld4::PseudoDylib::create();
  }
  if (!a5) {
    dyld4::PseudoDylib::create();
  }
  if (a2 <= a3 || a2 - a4 >= a3) {
    dyld4::PseudoDylib::create();
  }
  uint64_t result = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x28uLL);
  *uint64_t result = a3;
  result[1] = a4;
  result[2] = a5;
  result[3] = a6;
  result[4] = a2;
  return result;
}

const char *dyld4::PseudoDylib::loadableAtPath(dyld4::PseudoDylib *this, const char *__s2)
{
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    uint64_t v4 = *((void *)this + 2);
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(void *)(v4 + 48))
  {
    if (v3) {
      uint64_t v5 = *((void *)this + 2);
    }
    else {
      uint64_t v5 = 0;
    }
    size_t v7 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(v5 + 48);
    uint64_t v8 = *(void *)this;
    uint64_t v9 = *((void *)this + 3);
    return (const char *)v7(v9, v8, __s2);
  }
  else if (_platform_strcmp(*((const char **)this + 4), __s2))
  {
    return 0;
  }
  else
  {
    return __s2;
  }
}

uint64_t dyld4::PseudoDylib::disposeString(uint64_t (***this)(char *), char *a2)
{
  return (*this[2])(a2);
}

uint64_t dyld4::PseudoDylib::initialize(dyld4::PseudoDylib *this)
{
  if (*((void *)this + 2)) {
    uint64_t v1 = *((void *)this + 2);
  }
  else {
    uint64_t v1 = 0;
  }
  return (*(uint64_t (**)(void, void))(v1 + 8))(*((void *)this + 3), *(void *)this);
}

uint64_t dyld4::PseudoDylib::lookupSymbols(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5) {
    dyld4::PseudoDylib::lookupSymbols();
  }
  if (a3 != a7) {
    dyld4::PseudoDylib::lookupSymbols();
  }
  if (a1[2]) {
    uint64_t v10 = a1[2];
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 24);
  uint64_t v12 = *a1;
  uint64_t v13 = a1[3];

  return v11(v13, v12, a2, a3, a4);
}

uint64_t dyld4::PseudoDylib::finalizeRequestedSymbols(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[2];
  if (v3) {
    uint64_t v4 = a1[2];
  }
  else {
    uint64_t v4 = 0;
  }
  if (!*(void *)(v4 + 56)) {
    return 0;
  }
  if (v3) {
    uint64_t v5 = a1[2];
  }
  else {
    uint64_t v5 = 0;
  }
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(v5 + 56))(a1[3], *a1, a2, a3);
}

uint64_t dyld4::PseudoDylib::lookupAddress(dyld4::PseudoDylib *this, const void *a2, dl_info *a3)
{
  if (*((void *)this + 2)) {
    uint64_t v3 = *((void *)this + 2);
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(void, void, const void *, dl_info *))(v3 + 32))(*((void *)this + 3), *(void *)this, a2, a3);
}

uint64_t dyld4::PseudoDylib::findUnwindSections(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    dyld4::PseudoDylib::findUnwindSections();
  }
  if (!a4) {
    dyld4::PseudoDylib::findUnwindSections();
  }
  if (a1[2]) {
    uint64_t v7 = a1[2];
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v9 = *a1;
  uint64_t v10 = a1[3];

  return v8(v10, v9, a2, a3);
}

unint64_t dyld4::RuntimeLocks::takeLockBeforeFork(dyld4::RuntimeLocks *this)
{
  unint64_t result = *(void *)this;
  if (result)
  {
    (*(void (**)(unint64_t, char *, void))(*(void *)result + 104))(result, (char *)this + 8, 0);
    (*(void (**)(void, char *, void))(**(void **)this + 104))(*(void *)this, (char *)this + 16, 0);
    (*(void (**)(void, char *, void))(**(void **)this + 104))(*(void *)this, (char *)this + 24, 0);
    unint64_t result = (***(uint64_t (****)(void))this)();
    if (result >= 6)
    {
      (*(void (**)(void, char *, void))(**(void **)this + 184))(*(void *)this, (char *)this + 40, 0);
      uint64_t v3 = *(uint64_t (**)(void))(**(void **)this + 184);
      return v3();
    }
  }
  return result;
}

unint64_t dyld4::RuntimeLocks::releaseLockInForkParent(dyld4::RuntimeLocks *this)
{
  unint64_t result = *(void *)this;
  if (result)
  {
    (*(void (**)(unint64_t, char *))(*(void *)result + 112))(result, (char *)this + 8);
    (*(void (**)(void, char *))(**(void **)this + 112))(*(void *)this, (char *)this + 16);
    (*(void (**)(void, char *))(**(void **)this + 112))(*(void *)this, (char *)this + 24);
    unint64_t result = (***(uint64_t (****)(void))this)();
    if (result >= 6)
    {
      (*(void (**)(void, char *))(**(void **)this + 192))(*(void *)this, (char *)this + 40);
      uint64_t v3 = *(uint64_t (**)(void))(**(void **)this + 192);
      return v3();
    }
  }
  return result;
}

uint64_t (***dyld4::RuntimeLocks::resetLockInForkChild(dyld4::RuntimeLocks *this))(void)
{
  unint64_t result = *(uint64_t (****)(void))this;
  if (result)
  {
    unint64_t result = (uint64_t (***)(void))(**result)(result);
    if ((unint64_t)result >= 2)
    {
      (*(void (**)(void, char *))(**(void **)this + 152))(*(void *)this, (char *)this + 8);
      (*(void (**)(void, char *))(**(void **)this + 152))(*(void *)this, (char *)this + 16);
      unint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void, char *))(**(void **)this + 152))(*(void *)this, (char *)this + 24);
      *((void *)this + 5) = 0;
    }
  }
  return result;
}

uint64_t (***dyld4::RuntimeLocks::resetDlopenLockInForkChild(dyld4::RuntimeLocks *this))(void)
{
  unint64_t result = *(uint64_t (****)(void))this;
  if (result)
  {
    unint64_t result = (uint64_t (***)(void))(**result)(result);
    if ((unint64_t)result >= 2)
    {
      uint64_t v3 = *(uint64_t (**)(void))(**(void **)this + 152);
      return (uint64_t (***)(void))v3();
    }
  }
  return result;
}

void dyld4::RuntimeState::printLinkageChain(dyld4::RuntimeState *this, uint64_t *a2, const char *a3)
{
  v10[0] = 0;
  if (a2)
  {
    uint64_t v6 = a2;
    while (v6 == a2)
    {
LABEL_10:
      uint64_t v8 = dyld4::Loader::leafName((dyld4::Loader *)v6[1], this);
      strlcat(v10, v8, 0x800uLL);
      uint64_t v6 = (uint64_t *)*v6;
      if (!v6) {
        goto LABEL_16;
      }
    }
    __dst[0] = 0;
    char v7 = *((unsigned char *)v6 + 16);
    if ((v7 & 2) != 0)
    {
      strlcat(__dst, "r", 8uLL);
      char v7 = *((unsigned char *)v6 + 16);
      if ((v7 & 1) == 0)
      {
LABEL_6:
        if ((v7 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }
    else if ((v6[2] & 1) == 0)
    {
      goto LABEL_6;
    }
    strlcat(__dst, "w", 8uLL);
    char v7 = *((unsigned char *)v6 + 16);
    if ((v7 & 4) == 0)
    {
LABEL_7:
      if ((v7 & 8) == 0)
      {
LABEL_9:
        strlcat(v10, " -", 0x800uLL);
        strlcat(v10, __dst, 0x800uLL);
        strlcat(v10, "-> ", 0x800uLL);
        goto LABEL_10;
      }
LABEL_8:
      strlcat(__dst, "d", 8uLL);
      goto LABEL_9;
    }
LABEL_14:
    strlcat(__dst, "u", 8uLL);
    if ((v6[2] & 8) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_16:
  dyld4::RuntimeState::log(this, "%s: %s\n", a3, v10);
}

void dyld4::RuntimeState::log(dyld4::RuntimeState *this, char *a2, ...)
{
  va_start(va, a2);
  dyld4::RuntimeState::vlog(this, a2, va);
}

void ___ZN5dyld412RuntimeState13setMainLoaderEPKNS_6LoaderE_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v3 = (dyld4::RuntimeState *)a1[5];
  vm_size_t v4 = (*(void *)(a2 + 8) + vm_page_size - 1) & -(uint64_t)vm_page_size;
  if (!v4)
  {
    if (*(_DWORD *)(*(void *)(a1[4] + 8) + 24)) {
      vm_size_t v4 = 0;
    }
    else {
      vm_size_t v4 = a1[7];
    }
  }
  if (*(unsigned char *)(*((void *)v3 + 1) + 201))
  {
    uint64_t v5 = a1[6] + *(void *)(a2 + 16);
    int v6 = *(_DWORD *)(a2 + 52);
    char v7 = (const char *)dyld3::MachOLoaded::segmentName((dyld3::MachOLoaded *)a1[7], *(_DWORD *)(*(void *)(a1[4] + 8) + 24));
    uint64_t v8 = 120;
    if ((v6 & 4) == 0) {
      uint64_t v8 = 46;
    }
    uint64_t v9 = 119;
    if ((v6 & 2) == 0) {
      uint64_t v9 = 46;
    }
    uint64_t v11 = v8;
    uint64_t v10 = 114;
    if ((v6 & 1) == 0) {
      uint64_t v10 = 46;
    }
    dyld4::RuntimeState::log(v3, "%14s (%c%c%c) 0x%012llX->0x%012llX \n", v7, v10, v9, v11, v5, v4 + v5);
  }
  ++*(_DWORD *)(*(void *)(a1[4] + 8) + 24);
}

void dyld4::RuntimeState::vlog(dyld4::RuntimeState *this, char *a2, char *a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*((void *)this + 17) + 44));
  if (!*((unsigned char *)this + 1133)) {
    dyld4::RuntimeState::setUpLogging(this);
  }
  if (*((unsigned char *)this + 1132))
  {
    if (snprintf(__str, 0x800uLL, "<%d>%s[%d]: ", 13, *(const char **)(*((void *)this + 1) + 136), *(_DWORD *)(*((void *)this + 1) + 152)) >= 1)
    {
      size_t v12 = _platform_strlen(__str);
      if (vsnprintf(&__str[v12], 2048 - v12, a2, a3) >= 1)
      {
        int v13 = *((_DWORD *)this + 282);
        size_t v14 = _platform_strlen(__str);
        sendto(v13, __str, v14, 0, 0, 0);
      }
    }
  }
  else
  {
    int v15 = *((_DWORD *)this + 282);
    if (v15 != -1)
    {
      _simple_dprintf(v15, "dyld[%d]: ", v6, v7, v8, v9, v10, v11, *(_DWORD *)(*((void *)this + 1) + 152));
      _simple_vdprintf(*((_DWORD *)this + 282), a2, (int *)a3);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(*((void *)this + 17) + 44));
}

uint64_t dyld4::RuntimeState::setUpLogging(dyld4::RuntimeState *this)
{
  uint64_t v12 = *((void *)this + 16);
  if (v12) {
    uint64_t v2 = *((void *)this + 16);
  }
  else {
    uint64_t v2 = 0;
  }
  if (*(unsigned char *)(v2 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_55;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_55;
    }
    unint64_t v11 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v11)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_55;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_55;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v3 = MEMORY[0xFFFFFC0D0];
      if (v3 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_55;
      }
    }
  }
  else
  {
    unint64_t v11 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v2, (lsl::Lock **)&v13);
    uint64_t v4 = *(void *)(v2 + 24);
    if (!v4)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v2, 0);
      uint64_t v4 = *(void *)(v2 + 24);
    }
    *(void *)(v2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4 + 1;
    lsl::Lock::unlock(*(lsl::Lock **)&v13.st_dev);
  }
  uint64_t result = *((void *)this + 1);
  if (*(unsigned char *)(result + 216) || *(unsigned char *)(result + 217))
  {
    *((_DWORD *)this + 282) = *(_DWORD *)(result + 212);
    *((_WORD *)this + 566) = 256;
    goto LABEL_18;
  }
  if (*(_DWORD *)(result + 152) == 1)
  {
    uint64_t result = dyld4::SyscallDelegate::open((dyld4::SyscallDelegate *)result, (dyld3 *)"/dev/console", (char *)0x20001, 0);
LABEL_43:
    char v10 = 0;
    *((_DWORD *)this + 282) = result;
LABEL_44:
    *((unsigned char *)this + 1132) = v10;
    *((unsigned char *)this + 1133) = 1;
    goto LABEL_45;
  }
  if ((dyld4::SyscallDelegate::fstat((dyld4::SyscallDelegate *)result, *(_DWORD *)(result + 212), &v13) & 0x80000000) == 0)
  {
    uint64_t result = *(unsigned int *)(*((void *)this + 1) + 212);
    goto LABEL_43;
  }
  uint64_t result = *((void *)this + 19);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 96))(result);
    if (result)
    {
      char v10 = 1;
      goto LABEL_44;
    }
  }
LABEL_45:
  if (!*((unsigned char *)this + 1132)) {
    goto LABEL_18;
  }
  uint64_t result = dyld4::SyscallDelegate::socket(*((dyld4::SyscallDelegate **)this + 1), 1, 2, 0);
  *((_DWORD *)this + 282) = result;
  if (result != -1)
  {
    dyld4::SyscallDelegate::fcntl(*((dyld4::SyscallDelegate **)this + 1), result, 2, (void *)1);
    strcpy((char *)&v14[1], "/var/run/syslog");
    HIBYTE(v14[0]) = 1;
    uint64_t v15 = 0;
    memset(&v14[9], 0, 80);
    uint64_t result = dyld4::SyscallDelegate::connect(*((dyld4::SyscallDelegate **)this + 1), *((_DWORD *)this + 282), (const sockaddr *)v14, 0x6Au);
    if (result == -1)
    {
      uint64_t result = dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)this + 1), *((_DWORD *)this + 282));
      *((_DWORD *)this + 282) = -1;
    }
    else if (*((_DWORD *)this + 282) != -1)
    {
      goto LABEL_18;
    }
  }
  *((unsigned char *)this + 1132) = 0;
LABEL_18:
  if (v12) {
    uint64_t v6 = v12;
  }
  else {
    uint64_t v6 = 0;
  }
  if (*(unsigned char *)(v6 + 32))
  {
    if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
    {
      if (v11 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        return result;
      }
      if (v11 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_55;
        }
        uint64_t result = MEMORY[0xFFFFFC0D0];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v7 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_55;
        }
        uint64_t result = MEMORY[0xFFFFFC0D8];
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v7 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v7 == StatusReg) {
        return result;
      }
    }
LABEL_55:
    __break(1u);
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v6, (lsl::Lock **)&v13);
  if (v11 == 1)
  {
    uint64_t v9 = *(void *)(v6 + 24) - 1;
    *(void *)(v6 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;
    if (!v9) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v6, 1);
    }
  }
  return (uint64_t)lsl::Lock::unlock(*(lsl::Lock **)&v13.st_dev);
}

void *___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke(void *result)
{
  uint64_t v1 = result[4];
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v1 + 944);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = (void *)(*(void *)(v1 + 936) + 8);
    while (*(v5 - 1) != v2 || *v5 != result[6])
    {
      v5 += 2;
      v4 -= 16;
      if (!v4) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v6 = result[6];
    uint64_t result = (void *)lsl::Vector<dyld4::InterposeTupleAll>::reserve(v1 + 928, v3 + 1);
    uint64_t v7 = *(void *)(v1 + 936);
    uint64_t v8 = *(void *)(v1 + 944);
    *(void *)(v1 + 944) = v8 + 1;
    uint64_t v9 = (void *)(v7 + 16 * v8);
    void *v9 = v2;
    v9[1] = v6;
  }
  return result;
}

uint64_t dyld4::RuntimeState::addMissingFlatLazySymbol(dyld4::RuntimeState *this, const dyld4::Loader *a2, const char *a3, unint64_t *a4)
{
  uint64_t result = lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)this + 896, *((void *)this + 114) + 1);
  uint64_t v9 = *((void *)this + 113);
  uint64_t v10 = *((void *)this + 114);
  *((void *)this + 114) = v10 + 1;
  unint64_t v11 = (void *)(v9 + 24 * v10);
  *unint64_t v11 = a2;
  v11[1] = a3;
  void v11[2] = a4;
  return result;
}

uint64_t dyld4::RuntimeState::removeMissingFlatLazySymbols(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 904);
  uint64_t v3 = *(void *)(result + 912);
  uint64_t v4 = &v2[3 * v3];
  uint64_t v5 = v2;
  if (v3)
  {
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v5 = *(void **)(result + 904);
    while (1)
    {
      if (v6)
      {
        uint64_t v7 = 8 * v6;
        uint64_t v8 = *(void **)a2;
        while (*v8 != *v5)
        {
          ++v8;
          v7 -= 8;
          if (!v7)
          {
            uint64_t v8 = (void *)(*(void *)a2 + 8 * v6);
            break;
          }
        }
      }
      else
      {
        uint64_t v8 = *(void **)a2;
      }
      if (v6 != ((uint64_t)v8 - *(void *)a2) >> 3) {
        break;
      }
      v5 += 3;
      if (v5 == v4) {
        goto LABEL_24;
      }
    }
  }
  if (v5 == v4)
  {
LABEL_24:
    uint64_t v5 = &v2[3 * v3];
  }
  else
  {
    uint64_t v9 = v5 + 3;
    if (v5 + 3 != v4)
    {
      do
      {
        uint64_t v10 = *(void **)a2;
        uint64_t v11 = *(void *)(a2 + 8);
        if (v11)
        {
          uint64_t v12 = 8 * v11;
          stat v13 = *(void **)a2;
          while (*v13 != *v9)
          {
            ++v13;
            v12 -= 8;
            if (!v12)
            {
              stat v13 = &v10[v11];
              break;
            }
          }
        }
        else
        {
          stat v13 = *(void **)a2;
        }
        if (v11 == v13 - v10)
        {
          long long v14 = *(_OWORD *)v9;
          v5[2] = v9[2];
          *(_OWORD *)uint64_t v5 = v14;
          v5 += 3;
        }
        v9 += 3;
      }
      while (v9 != v4);
      uint64_t v2 = *(void **)(result + 904);
      uint64_t v3 = *(void *)(result + 912);
    }
  }
  *(void *)(result + 912) = v3 + 0x5555555555555555 * (&v2[3 * v3] - v5);
  return result;
}

double __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__0(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

dyld3::MachOFile *dyld4::RuntimeState::checkHiddenCacheAddr(dyld3::MachOFile *result, uint64_t a2, uint64_t a3, const unsigned __int8 *a4, uint64_t *a5)
{
  if (a2)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0)
    {
      uint64_t v8 = result;
      memset(v17, 0, sizeof(v17));
      double result = (dyld3::MachOFile *)dyld4::JustInTimeLoader::overridesDylibInCache(a2, &v17[1], v17);
      if (result)
      {
        unint64_t v15 = 0;
        unint64_t v16 = 0;
        double result = (dyld3::MachOFile *)DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(*((void *)v8 + 1) + 240), v17[0], &v16, &v15);
        if (result)
        {
          uint64_t v14 = 0;
          char v13 = 0;
          double result = (dyld3::MachOFile *)dyld3::MachOLoaded::hasExportedSymbol(result, a4, 0, &v14, &v13);
          if (result)
          {
            uint64_t v9 = v14;
            double result = (dyld3::MachOFile *)dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace(a5, 1);
            uint64_t v10 = *a5;
            uint64_t v11 = a5[2];
            a5[2] = v11 + 1;
            uint64_t v12 = (void *)(v10 + 16 * v11);
            *uint64_t v12 = v9;
            v12[1] = a3;
          }
        }
      }
    }
  }
  return result;
}

void dyld4::RuntimeState::appendInterposingTuples(uint64_t **this, const dyld4::Loader *a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned char *)this[1] + 190))
  {
    __chkstk_darwin((uint64_t)this, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)v49[0]);
    uint64_t v70 = 0;
    uint64_t v71 = &v70;
    uint64_t v72 = 0x4002000000;
    char v73 = __Block_byref_object_copy__47;
    pid_t v74 = __Block_byref_object_dispose__48;
    uint64_t v75 = (char *)v49 - v12;
    uint64_t v76 = v13;
    uint64_t v77 = 0;
    if (v11)
    {
      int v14 = v11;
      do
      {
        unint64_t v15 = v71[7];
        if (v15 >= v71[6]) {
          ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
        }
        uint64_t v16 = v71[5];
        v71[7] = v15 + 1;
        uint64_t v17 = (_OWORD *)(v16 + 32 * v15);
        *uint64_t v17 = 0uLL;
        v17[1] = 0uLL;
        --v14;
      }
      while (v14);
    }
    unsigned int v18 = &a3[16 * v11];
    uint64_t v60 = 0;
    unsigned int v61 = &v60;
    uint64_t v62 = 0x5002000000;
    uint64_t v63 = __Block_byref_object_copy__49;
    int v64 = __Block_byref_object_dispose__50;
    uint64_t v65 = &v78;
    uint64_t v66 = 32;
    uint64_t v67 = 0;
    vm_address_t v68 = 0;
    vm_size_t v69 = 0;
    uint64_t v54 = 0;
    long long v55 = &v54;
    uint64_t v56 = 0x3002000000;
    uint64_t v57 = __Block_byref_object_copy__51;
    uint64_t v58 = __Block_byref_object_dispose__52;
    Diagnostics::Diagnostics((Diagnostics *)&v59);
    uint64_t v19 = (dyld3::MachOFile *)dyld4::Loader::analyzer(a2, (dyld4::RuntimeState *)this);
    char hasChainedFixups = dyld3::MachOFile::hasChainedFixups(v19);
    v49[0] = (vm_address_t **)&v59;
    v49[1] = (vm_address_t **)v49;
    if (hasChainedFixups)
    {
      v53[0] = _NSConcreteStackBlock;
      v53[1] = 0x40000000;
      void v53[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke;
      v53[3] = &unk_1EFF64260;
      v53[8] = v19;
      v53[9] = a2;
      v53[4] = &v54;
      v53[5] = &v60;
      v53[10] = a3;
      v53[11] = v18;
      v53[6] = &v70;
      v53[7] = this;
      dyld3::MachOAnalyzer::withChainStarts(v19, (vm_address_t *)v55 + 5, 0, (uint64_t)v53);
    }
    else
    {
      uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v19);
      v52[0] = _NSConcreteStackBlock;
      v52[1] = 0x40000000;
      void v52[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_3;
      v52[3] = &unk_1EFF64288;
      v52[6] = a3;
      v52[7] = v18;
      v52[4] = &v70;
      v52[5] = v19;
      v52[8] = (char *)v19 - Address;
      v52[9] = a2;
      dyld3::MachOAnalyzer::forEachRebase(v19, (vm_address_t *)v55 + 5, 0, (uint64_t)v52);
      v51[0] = _NSConcreteStackBlock;
      v51[1] = 0x40000000;
      uint64_t v51[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_4;
      v51[3] = &unk_1EFF642B0;
      v51[8] = v19;
      v51[9] = a3;
      v51[10] = v18;
      v51[11] = a2;
      v51[4] = &v54;
      v51[5] = &v70;
      v51[6] = &v60;
      v51[7] = this;
      dyld3::MachOAnalyzer::forEachBind(v19, (vm_address_t *)v55 + 5, (uint64_t)v51, (uint64_t)&__block_literal_global);
    }
    uint64_t v22 = v71[7];
    if (v22)
    {
      uint64_t v23 = v71[5];
      uint64_t v24 = v23 + 32 * v22;
      char v50 = this + 24;
      do
      {
        uint64_t v25 = *(void *)(v23 + 16);
        if (v25)
        {
          uint64_t v26 = *(void *)(v23 + 8);
          if (v26)
          {
            long long v27 = this[22];
            if (!v27) {
              goto LABEL_20;
            }
            uint64_t v28 = 0;
            uint64_t v29 = this[21];
            uint64_t v30 = 16 * (void)v27;
            do
            {
              if (v29[1] == v25)
              {
                uint64_t v28 = *v29;
                *uint64_t v29 = v26;
              }
              v29 += 2;
              v30 -= 16;
            }
            while (v30);
            if (v28)
            {
              char v31 = 0;
            }
            else
            {
LABEL_20:
              lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)(this + 20), (unint64_t)v27 + 1);
              uint64_t v28 = 0;
              char v32 = this[21];
              unsigned int v33 = this[22];
              this[22] = (uint64_t *)((char *)v33 + 1);
              int v34 = &v32[2 * (void)v33];
              *int v34 = v26;
              v34[1] = v25;
              char v31 = 1;
            }
            if (*((unsigned char *)this[1] + 206))
            {
              uint64_t v35 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)this);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "%s has interposed '%s' to replacing binds to 0x%08lX with 0x%08lX\n", v35, *(const char **)(v23 + 24), *(void *)(v23 + 16), *(void *)(v23 + 8));
            }
            uint64_t v36 = *(void *)(v23 + 16);
            lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)v50, (unint64_t)this[26] + 1);
            long long v37 = this[25];
            long long v38 = this[26];
            this[26] = (uint64_t *)((char *)v38 + 1);
            long long v39 = &v37[3 * (void)v38];
            *long long v39 = (uint64_t)a2;
            if (v31)
            {
              v39[1] = v36;
              uint64_t v39[2] = v36;
            }
            else
            {
              v39[1] = v28;
              uint64_t v39[2] = v36;
              if (*((unsigned char *)this[1] + 206)) {
                dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "   '%s' was previously interposed, so chaining 0x%08lX to call through to 0x%08lX\n", *(const char **)(v23 + 24), *(void *)(v23 + 8), v28);
              }
            }
            uint64_t v40 = v61[7];
            if (v40)
            {
              long long v41 = (void *)v61[5];
              uint64_t v42 = 16 * v40;
              do
              {
                if (v41[1] == *(void *)(v23 + 16))
                {
                  uint64_t v43 = *(void *)(v23 + 8);
                  uint64_t v44 = *v41;
                  lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)(this + 20), (unint64_t)this[22] + 1);
                  long long v45 = this[21];
                  long long v46 = this[22];
                  this[22] = (uint64_t *)((char *)v46 + 1);
                  uint64_t v47 = &v45[2 * (void)v46];
                  *uint64_t v47 = v43;
                  v47[1] = v44;
                  if (*((unsigned char *)this[1] + 206))
                  {
                    uint64_t v48 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)this);
                    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "%s has interposed '%s' so need to patch cache uses of 0x%08lX\n", v48, *(const char **)(v23 + 24), *v41);
                  }
                }
                v41 += 2;
                v42 -= 16;
              }
              while (v42);
            }
          }
        }
        v23 += 32;
      }
      while (v23 != v24);
    }
    _Block_object_dispose(&v54, 8);
    mach_o::Error::~Error(v49[0]);
    _Block_object_dispose(&v60, 8);
    uint64_t v67 = 0;
    if (v68) {
      vm_deallocate(mach_task_self_, v68, v69);
    }
    _Block_object_dispose(&v70, 8);
  }
}

__n128 __Block_byref_object_copy__47(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

double __Block_byref_object_copy__49(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__50(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

uint64_t __Block_byref_object_copy__51(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  v23[0] = 0;
  v23[1] = v23;
  void v23[2] = 0x5002000000;
  v23[3] = __Block_byref_object_copy__53;
  v23[4] = __Block_byref_object_dispose__54;
  v23[5] = &v28;
  void v23[6] = 128;
  uint64_t v24 = 0;
  vm_address_t v25 = 0;
  vm_size_t v26 = 0;
  v19[0] = 0;
  v19[1] = v19;
  void v19[2] = 0x5002000000;
  v19[3] = __Block_byref_object_copy__55;
  v19[4] = __Block_byref_object_dispose__56;
  v19[5] = &v27;
  v19[6] = 128;
  uint64_t v20 = 0;
  vm_address_t address = 0;
  vm_size_t size = 0;
  uint64_t v5 = *(dyld3::MachOFile **)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (vm_address_t *)(*(void *)(v6 + 8) + 40);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  unsigned int v18[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57;
  v18[3] = &unk_1EFF64210;
  uint64_t v8 = *(void *)(a1 + 72);
  void v18[8] = v4;
  v18[9] = v8;
  v18[4] = v6;
  v18[5] = v23;
  v18[6] = *(void *)(a1 + 40);
  v18[7] = v19;
  dyld3::MachOAnalyzer::forEachChainedFixupTarget(v5, v7, (uint64_t)v18);
  if (!Diagnostics::hasError((Diagnostics *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)))
  {
    uint64_t v9 = dyld3::MachOFile::preferredLoadAddress(*(dyld3::MachOFile **)(a1 + 64));
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    long long v11 = *(_OWORD *)(a1 + 64);
    long long v15 = *(_OWORD *)(a1 + 80);
    uint64_t v12 = (vm_address_t *)(v10 + 40);
    v14[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2;
    void v14[3] = &unk_1EFF64238;
    uint64_t v16 = v9;
    uint64_t v13 = *(void *)(a1 + 48);
    long long v17 = v11;
    _OWORD v14[4] = v13;
    void v14[5] = v23;
    void v14[6] = v19;
    dyld3::MachOLoaded::forEachFixupInAllChains(v11, v12, a2, 0, (uint64_t)v14);
  }
  _Block_object_dispose(v19, 8);
  uint64_t v20 = 0;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  _Block_object_dispose(v23, 8);
  uint64_t v24 = 0;
  if (v25) {
    vm_deallocate(mach_task_self_, v25, v26);
  }
}

double __Block_byref_object_copy__53(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__54(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

double __Block_byref_object_copy__55(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__56(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  uint64_t v10 = *(dyld4::RuntimeState **)(a1 + 64);
  dyld4::Loader::resolveSymbol(*(dyld4::Loader **)(a1 + 72), v10, (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2, a3, a5, 0, 0, (uint64_t)v21);
  if (Diagnostics::hasError((Diagnostics *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)))
  {
    long long v11 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 72), v10);
    dyld4::RuntimeState::log(v10, "warning could not apply interposing tuples in %s\n", v11);
    *a6 = 1;
  }
  else
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v13 = (char *)dyld4::Loader::resolvedAddress(v10, (uint64_t)v21) + a4;
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v12 + 40), 1);
    uint64_t v14 = *(void *)(v12 + 40);
    uint64_t v15 = *(void *)(v12 + 56);
    *(void *)(v12 + 56) = v15 + 1;
    *(void *)(v14 + 8 * v15) = v13;
    uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v17 = *(void *)(v16 + 56);
    if (!v17) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    dyld4::RuntimeState::checkHiddenCacheAddr(v10, *(uint64_t *)&v21[0], *(void *)(*(void *)(v16 + 40) + 8 * v17 - 8), (const unsigned __int8 *)a3, (uint64_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
    uint64_t v18 = *(void *)(*(void *)(a1 + 56) + 8);
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v18 + 40), 1);
    uint64_t v19 = *(void *)(v18 + 40);
    uint64_t v20 = *(void *)(v18 + 56);
    *(void *)(v18 + 56) = v20 + 1;
    *(void *)(v19 + 8 * v2dyld4::halt((char *)__format, 0) = a3;
  }
}

void *___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2(void *result, mach_o::ChainedFixupPointerOnDisk *this, uint64_t a3)
{
  unint64_t v3 = result[7];
  if (v3 <= (unint64_t)this)
  {
    uint64_t v4 = result;
    if (result[8] > (unint64_t)this)
    {
      uint64_t v5 = (uint64_t)this - v3;
      unint64_t v6 = (v5 >> 3) / 2;
      if ((((v5 >> 3) + (v5 >> 3 < 0)) & 0xFFFFFFFFFFFFFFFELL) == v5 >> 3)
      {
        unint64_t v13 = 0;
        double result = (void *)mach_o::ChainedFixupPointerOnDisk::isRebase(this, *(unsigned __int16 *)(a3 + 6), result[9], &v13);
        if (result)
        {
          uint64_t v7 = *(void *)(v4[4] + 8);
          if (*(void *)(v7 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
          }
          *(void *)(*(void *)(v7 + 40) + 32 * v6 + 8) = v13 + v4[10];
          uint64_t v8 = *(void *)(v4[4] + 8);
          if (*(void *)(v8 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
          }
          *(void *)(*(void *)(v8 + 40) + 32 * v6) = v4[11];
        }
      }
      else
      {
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        double result = (void *)mach_o::ChainedFixupPointerOnDisk::isBind(this, *(unsigned __int16 *)(a3 + 6), &v12, &v13);
        if (result)
        {
          uint64_t v9 = (void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(*(void *)(v4[5] + 8) + 40), v12);
          uint64_t v10 = *(void *)(v4[4] + 8);
          if (*(void *)(v10 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
          }
          *(void *)(*(void *)(v10 + 40) + 32 * v6 + 16) = *v9;
          double result = (void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(*(void *)(v4[6] + 8) + 40), v12);
          uint64_t v11 = *(void *)(v4[4] + 8);
          if (*(void *)(v11 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
          }
          *(void *)(*(void *)(v11 + 40) + 32 * v6 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *result;
        }
      }
    }
  }
  return result;
}

void *___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_3(void *result, uint64_t a2)
{
  unint64_t v2 = result[6];
  unint64_t v3 = (void *)(result[5] + a2);
  if (v2 <= (unint64_t)v3 && result[7] > (unint64_t)v3)
  {
    uint64_t v4 = (uint64_t)((uint64_t)v3 - v2) >> 3;
    uint64_t v5 = *(void *)(result[4] + 8);
    if (*(void *)(v5 + 56) <= (unint64_t)(v4 / 2)) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    *(void *)(*(void *)(v5 + 40) + 32 * (v4 / 2) + 8) = result[8] + *v3;
    uint64_t v6 = *(void *)(result[4] + 8);
    if (*(void *)(v6 + 56) <= (unint64_t)(v4 / 2)) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    *(void *)(*(void *)(v6 + 40) + 32 * (v4 / 2)) = result[9];
  }
  return result;
}

dyld3::MachOFile *___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_4(dyld3::MachOFile *result, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *((void *)result + 8) + a2;
  if (*((void *)result + 9) <= v8)
  {
    uint64_t v9 = result;
    if (*((void *)result + 10) > v8)
    {
      unsigned int v12 = (dyld4::RuntimeState *)*((void *)result + 7);
      uint64_t v19 = 0;
      memset(v18, 0, sizeof(v18));
      dyld4::Loader::resolveSymbol(*((dyld4::Loader **)result + 11), v12, (vm_address_t *)(*(void *)(*((void *)result + 4) + 8) + 40), a3, a5, a6, a7, 0, (uint64_t)v18);
      double result = (dyld3::MachOFile *)Diagnostics::noError((Diagnostics *)(*(void *)(v9[4] + 8) + 40));
      if (result)
      {
        uint64_t v13 = (uint64_t)(v8 - v9[9]) >> 3;
        if (v13 >= 0) {
          uint64_t v14 = (uint64_t)(v8 - v9[9]) >> 3;
        }
        else {
          uint64_t v14 = v13 + 1;
        }
        uint64_t v15 = dyld4::Loader::resolvedAddress(v12, (uint64_t)v18);
        uint64_t v16 = *(void *)(v9[5] + 8);
        if (*(void *)(v16 + 56) <= (unint64_t)(v14 >> 1)) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
        }
        *(void *)(*(void *)(v16 + 40) + 32 * (v14 >> 1) + 16) = (char *)v15 + a8;
        uint64_t v17 = *(void *)(v9[5] + 8);
        if (*(void *)(v17 + 56) <= (unint64_t)(v14 >> 1)) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
        }
        *(void *)(*(void *)(v17 + 40) + 32 * (v14 >> 1) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a5;
        return dyld4::RuntimeState::checkHiddenCacheAddr(v12, *(uint64_t *)&v18[0], (uint64_t)v15 + a8, (const unsigned __int8 *)a5, (uint64_t *)(*(void *)(v9[6] + 8) + 40));
      }
    }
  }
  return result;
}

double __Block_byref_object_copy__74(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__75(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke(void *a1, uint64_t a2, unint64_t a3)
{
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) += a3 >> 4;
  uint64_t v4 = *(void *)(a1[5] + 8);
  double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v4 + 40), 1);
  uint64_t v6 = a1[6];
  uint64_t v7 = *(void *)(v4 + 40);
  uint64_t v8 = *(void *)(v4 + 56);
  *(void *)(v4 + 56) = v8 + 1;
  *(void *)(v7 + 8 * v8) = v6;
  return result;
}

void ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void *dyld4::RuntimeState::setLaunchMissingDylib(void *this, const char *a2, const char *a3)
{
  this[78] = 1;
  this[79] = a3;
  this[80] = a2;
  this[81] = 0;
  return this;
}

void *dyld4::RuntimeState::setLaunchMissingSymbol(void *this, const char *a2, const char *a3, const char *a4)
{
  this[78] = 4;
  this[79] = a4;
  this[80] = a3;
  this[81] = a2;
  return this;
}

BOOL dyld4::RuntimeState::hasMissingFlatLazySymbols(dyld4::RuntimeState *this)
{
  return *((void *)this + 114) != 0;
}

void dyld4::RuntimeState::setVMAccountingSuspending(dyld4::RuntimeState *this, int a2)
{
  if (*((unsigned __int8 *)this + 1137) != a2)
  {
    if (*(unsigned char *)(*((void *)this + 1) + 202)) {
      dyld4::RuntimeState::log(this, "set vm.footprint_suspend=%d\n", a2);
    }
    int v9 = 0;
    int v10 = a2;
    size_t v8 = 4;
    int v4 = sysctlbyname("vm.footprint_suspend", &v9, &v8, &v10, 4uLL);
    if (*(unsigned char *)(*((void *)this + 1) + 202)) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      int v6 = v4;
      uint64_t v7 = __error();
      dyld4::RuntimeState::log(this, "vm.footprint_suspend => %d, errno=%d\n", v6, *v7);
    }
    *((unsigned char *)this + 1137) = a2;
  }
}

void *dyld4::Reaper::markDirectlyDlopenedImagesAsUsed(void *this)
{
  uint64_t v1 = *(void *)(*this + 1056);
  if (v1)
  {
    unint64_t v2 = *(void **)(*this + 1048);
    uint64_t v3 = &v2[2 * v1];
    do
    {
      if (v2[1])
      {
        int v4 = (void *)this[1];
        uint64_t v5 = v4[2];
        if (v5)
        {
          int v6 = (unsigned char *)(*v4 + 8);
          uint64_t v7 = 16 * v5;
          while (*((void *)v6 - 1) != *v2)
          {
            v6 += 16;
            v7 -= 16;
            if (!v7) {
              goto LABEL_10;
            }
          }
          *int v6 = 1;
        }
      }
LABEL_10:
      v2 += 2;
    }
    while (v2 != v3);
  }
  return this;
}

void *dyld4::Reaper::markDynamicNeverUnloadImagesAsUsed(void *this)
{
  uint64_t v1 = *(void *)(*this + 1088);
  if (v1)
  {
    unint64_t v2 = *(void **)(*this + 1080);
    uint64_t v3 = &v2[v1];
    int v4 = (uint64_t *)this[1];
    uint64_t v5 = *v4;
    uint64_t v6 = v4[2];
    uint64_t v7 = (unsigned char *)(v5 + 8);
    do
    {
      if (v6)
      {
        uint64_t v8 = 16 * v6;
        int v9 = v7;
        while (*((void *)v9 - 1) != *v2)
        {
          v9 += 16;
          v8 -= 16;
          if (!v8) {
            goto LABEL_9;
          }
        }
        unsigned char *v9 = 1;
      }
LABEL_9:
      ++v2;
    }
    while (v2 != v3);
  }
  return this;
}

uint64_t dyld4::Reaper::markDependentsOf(dyld4::RuntimeState **this, const dyld4::Loader *a2)
{
  uint64_t result = dyld4::Loader::dependentCount(a2);
  if (result)
  {
    int v5 = result;
    for (unsigned int i = 0; i != v5; ++i)
    {
      uint64_t result = dyld4::Loader::dependent(a2, *this, i, 0);
      uint64_t v7 = this[1];
      uint64_t v8 = *((void *)v7 + 2);
      if (v8)
      {
        int v9 = (unsigned char *)(*(void *)v7 + 8);
        uint64_t v10 = 16 * v8;
        while (*v9 || *((void *)v9 - 1) != result)
        {
          v9 += 16;
          v10 -= 16;
          if (!v10) {
            goto LABEL_10;
          }
        }
        unsigned char *v9 = 1;
      }
LABEL_10:
      ;
    }
  }
  uint64_t v11 = *((void *)*this + 118);
  if (v11)
  {
    uint64_t v12 = *((void *)*this + 117);
    uint64_t v13 = v12 + 16 * v11;
    do
    {
      if (*(const dyld4::Loader **)v12 == a2)
      {
        uint64_t v14 = this[1];
        uint64_t v15 = *((void *)v14 + 2);
        if (v15)
        {
          uint64_t v16 = (unsigned char *)(*(void *)v14 + 8);
          uint64_t v17 = 16 * v15;
          while (*((void *)v16 - 1) != *(void *)(v12 + 8))
          {
            v16 += 16;
            v17 -= 16;
            if (!v17) {
              goto LABEL_14;
            }
          }
          *uint64_t v16 = 1;
        }
      }
LABEL_14:
      v12 += 16;
    }
    while (v12 != v13);
  }
  return result;
}

uint64_t dyld4::Reaper::markDependentOfInUseImages(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 8);
  uint64_t v2 = v1[2];
  if (v2)
  {
    uint64_t v3 = (dyld4::RuntimeState **)this;
    uint64_t v4 = 16 * v2;
    int v5 = (const dyld4::Loader **)(*v1 + 8);
    do
    {
      if (*(unsigned char *)v5) {
        this = dyld4::Reaper::markDependentsOf(v3, *(v5 - 1));
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
  }
  return this;
}

uint64_t dyld4::Reaper::garbageCollect(dyld4::Reaper *this)
{
  dyld4::Reaper::markDirectlyDlopenedImagesAsUsed(this);
  dyld4::Reaper::markDynamicNeverUnloadImagesAsUsed(this);
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  uint64_t v3 = v2[2];
  if (v3)
  {
    int v4 = 0;
    uint64_t v5 = *v2;
    uint64_t v6 = 16 * v3;
    uint64_t v7 = (unsigned __int8 *)(v5 + 8);
    do
    {
      int v8 = *v7;
      v7 += 16;
      v4 += v8;
      v6 -= 16;
    }
    while (v6);
  }
  else
  {
    int v4 = 0;
  }
  do
  {
    while (1)
    {
      int v9 = v4;
      uint64_t result = dyld4::Reaper::markDependentOfInUseImages((uint64_t)this);
      uint64_t v11 = (uint64_t *)*((void *)this + 1);
      uint64_t v12 = v11[2];
      if (v12) {
        break;
      }
      int v4 = 0;
      if (!v9) {
        goto LABEL_15;
      }
    }
    int v4 = 0;
    uint64_t v13 = *v11;
    uint64_t v14 = 16 * v12;
    uint64_t v15 = (unsigned __int8 *)(v13 + 8);
    uint64_t v16 = 16 * v12;
    do
    {
      int v17 = *v15;
      v15 += 16;
      v4 += v17;
      v16 -= 16;
    }
    while (v16);
  }
  while (v4 != v9);
  int v18 = 0;
  uint64_t v19 = (unsigned __int8 *)(v13 + 8);
  do
  {
    int v20 = *v19;
    v19 += 16;
    v18 += v20;
    v14 -= 16;
  }
  while (v14);
  LODWORD(v12) = v12 - v18;
LABEL_15:
  *((_DWORD *)this + 4) = v12;
  return result;
}

void dyld4::Reaper::finalizeDeadImages(dyld4::Reaper *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)this + 4) && *(void *)(*(void *)this + 152))
  {
    __chkstk_darwin((uint64_t)this, a2, a3, a4, a5, a6, a7, a8, v16);
    uint64_t v18 = 0;
    uint64_t v19 = &v18;
    uint64_t v20 = 0x5002000000;
    unsigned int v21 = __Block_byref_object_copy__84;
    uint64_t v10 = *((unsigned int *)this + 4);
    uint64_t v22 = __Block_byref_object_dispose__85;
    uint64_t v23 = (char *)&v17[-1] - ((v9 + 23) & 0x1FFFFFFFF0);
    uint64_t v24 = v10;
    uint64_t v25 = 0;
    vm_address_t v26 = 0;
    vm_size_t v27 = 0;
    uint64_t v11 = (uint64_t *)*((void *)this + 1);
    uint64_t v12 = v11[2];
    if (v12)
    {
      uint64_t v13 = *v11;
      uint64_t v14 = 16 * v12;
      do
      {
        if (!*(unsigned char *)(v13 + 8))
        {
          uint64_t v15 = (_DWORD *)dyld4::Loader::analyzer(*(dyld4::Loader **)v13, *(dyld4::RuntimeState **)this);
          if ((*(_WORD *)(*(void *)v13 + 4) & 2) == 0)
          {
            v17[0] = _NSConcreteStackBlock;
            v17[1] = 0x40000000;
            void v17[2] = ___ZN5dyld46Reaper18finalizeDeadImagesEv_block_invoke;
            v17[3] = &unk_1EFF64340;
            v17[4] = &v18;
            _WORD v17[5] = v15;
            dyld3::MachOFile::forEachSegment(v15, (uint64_t)v17);
          }
        }
        v13 += 16;
        v14 -= 16;
      }
      while (v14);
      if (v19[7]) {
        (*(void (**)(void, uint64_t))(**(void **)(*(void *)this + 152) + 88))(*(void *)(*(void *)this + 152), v19[5]);
      }
    }
    _Block_object_dispose(&v18, 8);
    uint64_t v25 = 0;
    if (v26) {
      vm_deallocate(mach_task_self_, v26, v27);
    }
  }
}

double __Block_byref_object_copy__84(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__85(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZN5dyld46Reaper18finalizeDeadImagesEv_block_invoke(void *result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 52) & 4) != 0)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(a2 + 16);
    uint64_t v5 = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)result[5]) + v4;
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(v3[4] + 8);
    double result = dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(v7 + 40), 1);
    uint64_t v8 = *(void *)(v7 + 40);
    uint64_t v9 = *(void *)(v7 + 56);
    *(void *)(v7 + 56) = v9 + 1;
    uint64_t v10 = (void *)(v8 + 16 * v9);
    *uint64_t v10 = v5;
    v10[1] = v6;
  }
  return result;
}

void dyld4::RuntimeState::garbageCollectInner(lsl::Lock ***this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin((uint64_t)this, a2, a3, a4, a5, a6, a7, a8, v43);
  uint64_t v52 = 0;
  long long v53 = &v52;
  uint64_t v54 = 0x4002000000;
  long long v55 = __Block_byref_object_copy__87;
  uint64_t v56 = __Block_byref_object_dispose__88;
  uint64_t v57 = (char *)&v43 - ((v9 + 23) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v58 = v10;
  uint64_t v59 = 0;
  uint64_t v12 = *(uint64_t **)(v11 + 136);
  v51[0] = _NSConcreteStackBlock;
  v51[1] = 0x40000000;
  uint64_t v51[2] = ___ZN5dyld412RuntimeState19garbageCollectInnerEv_block_invoke;
  v51[3] = &unk_1EFF64368;
  v51[4] = &v52;
  v51[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v12, (uint64_t)v51);
  v49[0] = this;
  v49[1] = v53 + 5;
  int v50 = 0;
  dyld4::Reaper::garbageCollect((dyld4::Reaper *)v49);
  dyld4::Reaper::finalizeDeadImages((dyld4::Reaper *)v49, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v20 = v53[7];
  uint64_t v22 = lsl::AllocatorLayout::minSize(v21);
  __chkstk_darwin(v22, v22 + 8 * v20 + 64, v23, v24, v25, v26, v27, v28, v43);
  uint64_t v30 = (lsl::Allocator *)((char *)&v43 - v29);
  bzero((char *)&v43 - v29, v31);
  uint64_t v32 = v53[7];
  uint64_t v34 = lsl::AllocatorLayout::minSize(v33);
  uint64_t v35 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v30, (char *)(v34 + 8 * v32 + 64));
  long long v45 = v35;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  lsl::Vector<dyld4::Loader const*>::reserveExact((uint64_t)&v45, v53[7]);
  uint64_t v36 = v53[7];
  if (v36)
  {
    uint64_t v37 = 16 * v36;
    uint64_t v38 = v53[5] + 8;
    long long v39 = (unsigned __int8 *)v38;
    do
    {
      int v40 = *v39;
      v39 += 16;
      if (!v40)
      {
        lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)&v45, v47 + 1);
        uint64_t v41 = *(void *)(v38 - 8);
        uint64_t v42 = v47++;
        *(void *)(v46 + 8 * v42) = v41;
      }
      uint64_t v38 = (uint64_t)v39;
      v37 -= 16;
    }
    while (v37);
  }
  if (v47)
  {
    uint64_t v43 = v46;
    uint64_t v44 = v47;
    dyld4::RuntimeState::notifyUnload((uint64_t)this, &v43);
    uint64_t v43 = v46;
    uint64_t v44 = v47;
    dyld4::RuntimeState::removeLoaders(this, (uint64_t)&v43);
  }
  if (v46) {
    lsl::Vector<dyld4::Loader const*>::resize((const os_unfair_lock *)&v45, 0);
  }
  lsl::Allocator::~Allocator(v35);
  _Block_object_dispose(&v52, 8);
}

__n128 __Block_byref_object_copy__87(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

void ___ZN5dyld412RuntimeState19garbageCollectInnerEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 48);
  if (v2)
  {
    uint64_t v4 = *(void *)(v1 + 40);
    uint64_t v5 = 8 * v2;
    uint64_t v6 = v4;
    do
    {
      __int16 v7 = *(_WORD *)(*(void *)v6 + 4);
      if ((v7 & 2) == 0)
      {
        uint64_t v8 = (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
        v9.n128_u64[0] = *(void *)v6;
        v9.n128_u8[8] = (v7 & 0x20) != 0;
        dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back(v8, &v9);
      }
      v6 += 8;
      v4 += 8;
      v5 -= 8;
    }
    while (v5);
  }
}

void dyld4::RuntimeState::notifyUnload(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 136);
  v88[0] = _NSConcreteStackBlock;
  v88[1] = 0x40000000;
  v88[2] = ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
  v88[3] = &__block_descriptor_tmp_96;
  v88[4] = a1;
  v88[5] = a2;
  dyld4::RuntimeLocks::withNotifiersReadLock(v4, (uint64_t)v88);
  if (*(void *)(a1 + 664))
  {
    uint64_t v12 = a2[1];
    if (v12)
    {
      uint64_t v13 = (dyld4::Loader **)*a2;
      uint64_t v14 = 8 * v12;
      do
      {
        uint64_t v15 = *v13;
        if ((*((_WORD *)*v13 + 2) & 4) != 0)
        {
          uint64_t v16 = *(void (**)(uint64_t, uint64_t))(a1 + 664);
          uint64_t v17 = dyld4::Loader::path(*v13, (const dyld4::RuntimeState *)a1);
          uint64_t Address = dyld4::Loader::loadAddress(v15, (const dyld4::RuntimeState *)a1);
          v16(v17, Address);
          if (*(unsigned char *)(*(void *)(a1 + 8) + 205))
          {
            uint64_t v19 = (const void *)dyld4::Loader::loadAddress(v15, (const dyld4::RuntimeState *)a1);
            uint64_t v20 = (const char *)dyld4::Loader::path(v15, (const dyld4::RuntimeState *)a1);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "objc-unmapped-notifier called with image %p %s\n", v19, v20);
          }
        }
        ++v13;
        v14 -= 8;
      }
      while (v14);
    }
  }
  if (kdebug_is_enabled(0x1F050000u, v5, v6, v7, v8, v9, v10, v11))
  {
    uint64_t v21 = a2[1];
    if (v21)
    {
      uint64_t v22 = (dyld4::Loader **)*a2;
      uint64_t v23 = 8 * v21;
      do
      {
        uint64_t v25 = *v22++;
        uint64_t v24 = (unsigned int *)v25;
        *(void *)unint64_t v90 = 0;
        uint64_t v91 = 0;
        uint64_t v26 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(v25, (const dyld4::RuntimeState *)a1);
        dyld3::MachOFile::getUuid(v26, (unsigned __int8 *)v90);
        uint64_t v27 = (dyld3 *)dyld4::Loader::path(v25, (const dyld4::RuntimeState *)a1);
        int v29 = dyld3::stat(v27, &v87, v28);
        if (v29) {
          __darwin_ino64_t st_ino = 0;
        }
        else {
          __darwin_ino64_t st_ino = (unsigned __int8 (*)[16])v87.st_ino;
        }
        if (v29) {
          fsobj_id st_dev = 0;
        }
        else {
          fsobj_id st_dev = (fsobj_id)v87.st_dev;
        }
        uint64_t v32 = (void *)dyld4::Loader::path((dyld4::Loader *)v24, (const dyld4::RuntimeState *)a1);
        fsid v33 = (fsid)dyld4::Loader::loadAddress((dyld4::Loader *)v24, (const dyld4::RuntimeState *)a1);
        fsobj_id v34 = st_dev;
        dyld3::kdebug_trace_dyld_image((dyld3 *)5, v32, (void **)v90, st_ino, v34, v33, (const void *)v24[6], v35, v81);
        v23 -= 8;
      }
      while (v23);
    }
  }
  if (dyld4::SyscallDelegate::dtraceUserProbesEnabled(*(dyld4::SyscallDelegate **)(a1 + 8)))
  {
    uint64_t v36 = a2[1];
    if (v36)
    {
      uint64_t v37 = (uint64_t *)*a2;
      uint64_t v38 = *a2 + 8 * v36;
      uint64_t v39 = *(void *)(a1 + 872);
      uint64_t v40 = *(void *)(a1 + 880);
      do
      {
        uint64_t v41 = *v37;
        uint64_t v42 = (_OWORD *)(v39 + 16 * v40);
        if (v40)
        {
          uint64_t v43 = 16 * v40;
          while (*(void *)v39 != v41)
          {
            v39 += 16;
            v43 -= 16;
            if (!v43)
            {
              uint64_t v44 = v42;
              goto LABEL_34;
            }
          }
          dyld4::SyscallDelegate::dtraceUnregisterUserProbe(*(dyld4::SyscallDelegate **)(a1 + 8), *(unsigned int *)(v39 + 8));
        }
        uint64_t v44 = v42;
        if ((_OWORD *)v39 != v42)
        {
          uint64_t v45 = v39 + 16;
          uint64_t v44 = (_OWORD *)v39;
          while ((_OWORD *)v45 != v42)
          {
            if (*(void *)v45 == v41) {
              dyld4::SyscallDelegate::dtraceUnregisterUserProbe(*(dyld4::SyscallDelegate **)(a1 + 8), *(unsigned int *)(v45 + 8));
            }
            else {
              *v44++ = *(_OWORD *)v45;
            }
            v45 += 16;
          }
        }
LABEL_34:
        uint64_t v39 = *(void *)(a1 + 872);
        uint64_t v40 = *(void *)(a1 + 880) - ((v39 + 16 * *(void *)(a1 + 880) - (uint64_t)v44) >> 4);
        *(void *)(a1 + 88dyld4::halt((char *)__format, 0) = v40;
        ++v37;
      }
      while (v37 != (uint64_t *)v38);
    }
  }
  dyld4::RuntimeState::removeMissingFlatLazySymbols(a1, (uint64_t)a2);
  uint64_t v46 = *(void *)(a1 + 128);
  uint64_t v47 = *(void **)(a1 + 136);
  v82[0] = _NSConcreteStackBlock;
  v82[1] = 0x40000000;
  uint64_t v83 = (void (*)(void *))___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2;
  uint64_t v84 = &__block_descriptor_tmp_98;
  uint64_t v85 = a1;
  uint64_t v86 = a2;
  *(void *)unint64_t v90 = v46;
  unint64_t v89 = 0;
  if (v46) {
    uint64_t v48 = v46;
  }
  else {
    uint64_t v48 = 0;
  }
  if (*(unsigned char *)(v48 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_145;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_145;
    }
    unint64_t v89 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v89)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_145;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_145;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v49 = MEMORY[0xFFFFFC0D0];
      if (v49 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_145;
      }
    }
  }
  else
  {
    unint64_t v89 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v48, (lsl::Lock **)&v87);
    uint64_t v50 = *(void *)(v48 + 24);
    if (!v50)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v48, 0);
      uint64_t v50 = *(void *)(v48 + 24);
    }
    *(void *)(v48 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v50 + 1;
    lsl::Lock::unlock(*(lsl::Lock **)&v87.st_dev);
  }
  if (*v47)
  {
    (*(void (**)(void, void *, void))(*(void *)*v47 + 104))(*v47, v47 + 1, 0);
    v83(v82);
    (*(void (**)(void, void *))(*(void *)*v47 + 112))(*v47, v47 + 1);
  }
  else
  {
    v83(v82);
  }
  if (*(void *)v90) {
    uint64_t v51 = *(void *)v90;
  }
  else {
    uint64_t v51 = 0;
  }
  if (*(unsigned char *)(v51 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_145;
    }
    if (v89 != ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1))
    {
      if (v89 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_145;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v52 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_145;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v52 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v52 != StatusReg) {
        goto LABEL_145;
      }
    }
  }
  else
  {
    lsl::MemoryManager::lockGuard((lsl::Lock *)v51, (lsl::Lock **)&v87);
    if (v89 == 1)
    {
      uint64_t v55 = *(void *)(v51 + 24) - 1;
      *(void *)(v51 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v55;
      if (!v55) {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v51, 1);
      }
    }
    else if (v89 == 0xFFFFFFFF)
    {
      uint64_t v54 = *(void *)(v51 + 24);
      if (!v54)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v51, 0);
        uint64_t v54 = *(void *)(v51 + 24);
      }
      *(void *)(v51 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v54 + 1;
    }
    lsl::Lock::unlock(*(lsl::Lock **)&v87.st_dev);
  }
  uint64_t v56 = *(void **)(a1 + 136);
  *(void *)unint64_t v90 = *(void *)(a1 + 128);
  unint64_t v89 = 0;
  if (*(void *)v90) {
    uint64_t v57 = *(void *)v90;
  }
  else {
    uint64_t v57 = 0;
  }
  if (*(unsigned char *)(v57 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_145;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_145;
    }
    unint64_t v89 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v89)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_145;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_145;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v58 = MEMORY[0xFFFFFC0D0];
      if (v58 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_145;
      }
    }
  }
  else
  {
    unint64_t v89 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v57, (lsl::Lock **)&v87);
    uint64_t v59 = *(void *)(v57 + 24);
    if (!v59)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v57, 0);
      uint64_t v59 = *(void *)(v57 + 24);
    }
    *(void *)(v57 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v59 + 1;
    lsl::Lock::unlock(*(lsl::Lock **)&v87.st_dev);
  }
  if (*v56)
  {
    (*(void (**)(void, void *, void))(*(void *)*v56 + 104))(*v56, v56 + 1, 0);
    uint64_t v60 = a2[1];
    if (v60)
    {
      uint64_t v61 = *a2;
      uint64_t v62 = 8 * v60;
      do
      {
        if (*(void *)v61) {
          BOOL v63 = (*(_WORD *)(*(void *)v61 + 4) & 1) == 0;
        }
        else {
          BOOL v63 = 0;
        }
        if (v63)
        {
          uint64_t v64 = *(void *)(*(void *)v61 + 104);
          if (v64)
          {
            uint64_t v66 = (void (***)(void))(v64 + 16);
            uint64_t v65 = *(void *)(v64 + 16);
            uint64_t v67 = v65 ? v65 : 0;
            if ((*(uint64_t (**)(void, void))(v67 + 16))(*(void *)(*(void *)(*(void *)v61 + 104) + 24), **(void **)(*(void *)v61 + 104)))
            {
              (**v66)();
            }
          }
        }
        v61 += 8;
        v62 -= 8;
      }
      while (v62);
    }
    (*(void (**)(void, void *))(*(void *)*v56 + 112))(*v56, v56 + 1);
  }
  else
  {
    uint64_t v68 = a2[1];
    if (v68)
    {
      uint64_t v69 = *a2;
      uint64_t v70 = 8 * v68;
      do
      {
        if (*(void *)v69) {
          BOOL v71 = (*(_WORD *)(*(void *)v69 + 4) & 1) == 0;
        }
        else {
          BOOL v71 = 0;
        }
        if (v71)
        {
          uint64_t v72 = *(void *)(*(void *)v69 + 104);
          if (v72)
          {
            pid_t v74 = (void (***)(void))(v72 + 16);
            uint64_t v73 = *(void *)(v72 + 16);
            uint64_t v75 = v73 ? v73 : 0;
            if ((*(uint64_t (**)(void, void))(v75 + 16))(*(void *)(*(void *)(*(void *)v69 + 104) + 24), **(void **)(*(void *)v69 + 104)))
            {
              (**v74)();
            }
          }
        }
        v69 += 8;
        v70 -= 8;
      }
      while (v70);
    }
  }
  if (*(void *)v90) {
    uint64_t v76 = *(void *)v90;
  }
  else {
    uint64_t v76 = 0;
  }
  if (*(unsigned char *)(v76 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_145;
    }
    if (v89 != ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1))
    {
      if (v89 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_145;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v77 = MEMORY[0xFFFFFC0D0];
        unint64_t v78 = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_145;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v77 = MEMORY[0xFFFFFC0D8];
        unint64_t v78 = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v77 == v78) {
        goto LABEL_144;
      }
LABEL_145:
      __break(1u);
    }
  }
  else
  {
    lsl::MemoryManager::lockGuard((lsl::Lock *)v76, (lsl::Lock **)&v87);
    if (v89 == 1)
    {
      uint64_t v80 = *(void *)(v76 + 24) - 1;
      *(void *)(v76 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v80;
      if (!v80) {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v76, 1);
      }
    }
    else if (v89 == 0xFFFFFFFF)
    {
      uint64_t v79 = *(void *)(v76 + 24);
      if (!v79)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v76, 0);
        uint64_t v79 = *(void *)(v76 + 24);
      }
      *(void *)(v76 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v79 + 1;
    }
    lsl::Lock::unlock(*(lsl::Lock **)&v87.st_dev);
  }
LABEL_144:
  dyld4::RuntimeState::notifyDebuggerUnload(a1, a2);
}

void dyld4::RuntimeState::removeLoaders(lsl::Lock ***a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v4 = *(dyld4::Loader ***)a2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      __int16 v7 = *((_WORD *)*v4 + 2);
      if ((v7 & 0x42) == 0)
      {
        if (v7)
        {
          dyld4::Loader::unmap(*v4, (dyld4::RuntimeState *)a1, 0);
        }
        else if ((*((unsigned char *)v6 + 42) & 0x20) == 0)
        {
          dyld4::Loader::unmap(*v4, (dyld4::RuntimeState *)a1, 0);
          *(_DWORD *)uint64_t v6 = 2053923954;
          lsl::Allocator::free(a1[2], v6);
        }
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
}

size_t ___ZN5dyld412RuntimeState12notifyDtraceERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke(void *a1, unsigned int a2)
{
  uint64_t v3 = (const dyld4::RuntimeState *)a1[5];
  uint64_t v4 = a1[6] + 80 * *(void *)a1[6];
  uint64_t v5 = (char *)(v4 + 8);
  uint64_t v7 = a1[7];
  uint64_t v6 = (dyld4::Loader *)a1[8];
  *(int64x2_t *)(v4 + 72) = vdupq_n_s64(v7 + (unint64_t)a2);
  uint64_t v8 = dyld4::Loader::leafName(v6, v3);
  size_t result = strlcpy(v5, v8, 0x40uLL);
  ++*(void *)a1[6];
  if ((*(unsigned char *)(a1[8] + 4) & 0x20) == 0) {
    *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void dyld4::RuntimeState::notifyDebuggerUnload(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)a1);
  __chkstk_darwin(v4, v4, v5, v6, v7, v8, v9, v10, v32);
  uint64_t v12 = (char *)&v33[-1] - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  uint64_t v15 = (char *)lsl::AllocatorLayout::minSize(v14);
  uint64_t v16 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal((lsl::Allocator *)v12, v15);
  __chkstk_darwin((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23, v32);
  uint64_t v25 = (uint64_t *)((char *)&v33[-1] - ((v24 + 23) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v26 = a2[1];
  if (!v26) {
    ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
  }
  uint64_t v27 = 0;
  uint64_t v28 = *a2;
  uint64_t v29 = 8 * v26;
  do
  {
    uint64_t Address = dyld4::Loader::loadAddress(*(dyld4::Loader **)(v28 + 8 * v27), (const dyld4::RuntimeState *)a1);
    if (v26 == v27) {
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    }
    size_t v31 = (uint64_t *)(v27 + 1);
    v25[v27++] = Address;
    v29 -= 8;
  }
  while (v29);
  v33[0] = v25;
  v33[1] = v31;
  dyld4::ExternallyViewableState::removeImages(a1 + 536, *(lsl::Lock ***)(a1 + 16), v16, v33);
  if (*(unsigned char *)(*(void *)(a1 + 8) + 156)) {
    dyld4::ExternallyViewableState::removeRosettaImages(a1 + 536, (uint64_t)v33);
  }
  lsl::Allocator::~Allocator((lsl::Allocator *)v16);
}

uint64_t ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke(uint64_t result)
{
  uint64_t v20 = result;
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 32);
  uint64_t v2 = *((void *)v1 + 94);
  if (v2)
  {
    uint64_t v3 = (const void **)*((void *)v1 + 93);
    uint64_t v19 = &v3[v2];
    do
    {
      uint64_t v4 = *(void *)(v20 + 40);
      uint64_t v5 = *(void *)(v4 + 8);
      if (v5)
      {
        uint64_t v6 = *v3;
        uint64_t v7 = *(dyld4::Loader ***)v4;
        uint64_t v8 = 8 * v5;
        do
        {
          uint64_t v9 = *v7;
          uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v7, v1);
          int v21 = 520552476;
          uint64_t v22 = Address;
          uint64_t v23 = 0;
          uint64_t v24 = v6;
          long long v25 = 0u;
          long long v26 = 0u;
          long long v27 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v21, v11, v12, v13, v14, v15, v16, v17);
          if (*(unsigned char *)(*((void *)v1 + 1) + 205)) {
            dyld4::RuntimeState::log(v1, "remove notifier %p called with mh=%p\n", v6, Address);
          }
          if ((*((_WORD *)v9 + 2) & 2) != 0) {
            uint64_t Slide = *(void *)(*((void *)v1 + 1) + 264);
          }
          else {
            uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
          }
          ((void (*)(dyld3::MachOLoaded *, uint64_t))v6)(Address, Slide);
          size_t result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v21);
          ++v7;
          v8 -= 8;
        }
        while (v8);
      }
      ++v3;
    }
    while (v3 != v19);
  }
  return result;
}

void *___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)result[4];
    uint64_t v4 = *(const dyld4::Loader ***)v1;
    uint64_t v5 = *(void *)v1 + 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      uint64_t v7 = v3[6];
      if (v7)
      {
        uint64_t v8 = (const dyld4::Loader **)v3[5];
        uint64_t v9 = 8 * v7;
        uint64_t v10 = v8;
        uint64_t v11 = v8;
        while (1)
        {
          uint64_t v12 = *v11++;
          if (v6 == v12) {
            break;
          }
          ++v8;
          uint64_t v10 = v11;
          v9 -= 8;
          if (!v9) {
            goto LABEL_12;
          }
        }
        uint64_t v13 = v9 - 8;
        if (v13)
        {
          for (unint64_t i = 0; i != v13; i += 8)
          {
            uint64_t v15 = &v10[i / 8];
            *uint64_t v15 = v10[i / 8 + 1];
            v15[1] = 0;
          }
        }
        void v3[6] = v7 - 1;
      }
LABEL_12:
      size_t result = dyld4::RuntimeState::removeDynamicDependencies(v3, v6);
      ++v4;
    }
    while (v4 != (const dyld4::Loader **)v5);
  }
  return result;
}

void *dyld4::RuntimeState::removeDynamicDependencies(void *this, const dyld4::Loader *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = (_OWORD *)this[117];
  uint64_t v5 = this[118];
  uint64_t v6 = &v4[v5];
  uint64_t v7 = v4;
  if (v5)
  {
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v7 = &v4[v8];
      if (*(const dyld4::Loader **)&v4[v8] == a2 || *((void *)&v4[v8] + 1) == (void)a2) {
        break;
      }
      if (v5 == ++v8)
      {
        uint64_t v7 = &v4[v5];
        goto LABEL_20;
      }
    }
  }
  uint64_t v10 = v7 + 1;
  if (v7 != v6 && v10 != v6)
  {
    do
    {
      if (*(const dyld4::Loader **)v10 != a2 && *((void *)v10 + 1) != (void)a2) {
        *v7++ = *v10;
      }
      ++v10;
    }
    while (v10 != v6);
    uint64_t v4 = (_OWORD *)this[117];
    uint64_t v5 = this[118];
  }
LABEL_20:
  this[118] = v5 - (&v4[v5] - v7);
  if (this[42])
  {
    uint64_t v13 = (dyld3::MachOFile *)dyld4::Loader::analyzer(a2, (dyld4::RuntimeState *)this);
    if ((dyld3::MachOFile::hasWeakDefs(v13) & 1) != 0
      || (this = (void *)dyld3::MachOFile::usesWeakDefs(v13), this))
    {
      this = (void *)dyld3::MachOFile::mappedSize(v13);
      uint64_t v14 = v3[42];
      uint64_t v15 = *(void *)(v14 + 72);
      if (v15)
      {
        uint64_t v16 = (char *)this + (void)v13;
        uint64_t v17 = (const dyld4::Loader **)(*(void *)(v14 + 56) + 8);
        uint64_t v18 = 24 * v15;
        do
        {
          if (*v17 == a2) {
            *uint64_t v17 = 0;
          }
          uint64_t v19 = (const char *)*(v17 - 1);
          if (v19 >= (const char *)v13 && v19 < v16)
          {
            this = lsl::Allocator::strdup((lsl::Lock **)v3[2], v19);
            *(v17 - 1) = (const dyld4::Loader *)this;
          }
          v17 += 3;
          v18 -= 24;
        }
        while (v18);
      }
    }
  }
  return this;
}

unsigned char *dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(unsigned char *this)
{
  if (!this[8])
  {
    uint64_t v1 = *(void *)(*(void *)this + 8);
    if (*(unsigned char *)(v1 + 158))
    {
      if (*(void *)(v1 + 240))
      {
        this[8] = 1;
        return (unsigned char *)dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(v1 + 240), v1 + 200, v1, 1);
      }
    }
  }
  return this;
}

uint64_t (***dyld4::RuntimeState::setDyldPatchedObjCClasses(dyld4::RuntimeState *this))(void)
{
  size_t result = (uint64_t (***)(void))*((void *)this + 19);
  if (result)
  {
    size_t result = (uint64_t (***)(void))(**result)(result);
    if ((unint64_t)result >= 3)
    {
      uint64_t v3 = *(uint64_t (**)(void))(**((void **)this + 19) + 160);
      return (uint64_t (***)(void))v3();
    }
  }
  return result;
}

uint64_t dyld4::RuntimeState::addNotifyLoadImage(dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, const char *, BOOL))
{
  uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 768, *((void *)this + 98) + 1);
  uint64_t v7 = *((void *)this + 97);
  uint64_t v8 = *((void *)this + 98);
  *((void *)this + 98) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<dyld4::Loader const*>::reserve((uint64_t)this + 1072, *((void *)this + 136) + 1);
      uint64_t v9 = *((void *)this + 135);
      uint64_t v10 = *((void *)this + 136);
      *((void *)this + 136) = v10 + 1;
      *(void *)(v9 + 8 * v1dyld4::halt((char *)__format, 0) = a2;
    }
  }
  return result;
}

__n128 __Block_byref_object_copy__102(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

uint64_t dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(v4, a2);
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t *))(a2 + 16);

  return v5(a2, a1);
}

uint64_t dyld4::RuntimeState::_finalizeListTLV(dyld4::RuntimeState *this, uint64_t *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke;
  void v6[3] = &__block_descriptor_tmp_110;
  v6[4] = this;
  dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(a2, (uint64_t)v6);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke_2;
  void v5[3] = &__block_descriptor_tmp_111;
  v5[4] = this;
  return dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(a2, (uint64_t)v5);
}

uint64_t ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = (void *)(a2 + 16 * v2 + 8);
    do
    {
      uint64_t v5 = (void (*)(void))*(v4 - 1);
      if (v5) {
        v5(*v4);
      }
      __n128 result = (*(uint64_t (**)(void, void))(**(void **)(v3 + 152) + 64))(*(void *)(v3 + 152), *(void *)(v3 + 1112));
      if (result)
      {
        uint64_t v6 = result;
        (*(void (**)(void, void, void))(**(void **)(v3 + 152) + 72))(*(void *)(v3 + 152), *(void *)(v3 + 1112), 0);
        __n128 result = (**(uint64_t (***)(uint64_t, uint64_t))v3)(v3, v6);
      }
      v4 -= 2;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 152) + 16))();
}

uint64_t dyld4::RuntimeState::saveAppPrebuiltLoaderSet(dyld4::RuntimeState *this, const dyld4::PrebuiltLoaderSet *a2)
{
  uint64_t v15 = &v17;
  long long v16 = xmmword_1A8E70420;
  if (dyld4::RuntimeState::buildBootToken((uint64_t)this, (uint64_t *)&v15))
  {
    if (*((void *)this + 123))
    {
      Diagnostics::Diagnostics((Diagnostics *)&v14);
      Only = (unsigned int *)dyld4::SyscallDelegate::mapFileReadOnly(*((void *)this + 1), (vm_address_t *)&v14, *((dyld3 **)this + 123), 0, 0, 0, 0);
      if (!Only)
      {
LABEL_9:
        Diagnostics::Diagnostics((Diagnostics *)&v13);
        uint64_t v8 = dyld4::SyscallDelegate::saveFileWithAttribute(*((void *)this + 1), (vm_address_t *)&v13, *((const std::__fs::filesystem::path **)this + 123), a2, *((unsigned int *)a2 + 2), "com.apple.dyld", (uint64_t)&v15);
        if (v8)
        {
          if (*(unsigned char *)(*((void *)this + 1) + 207)) {
            dyld4::RuntimeState::log(this, "wrote PrebuiltLoaderSet to file '%s'\n");
          }
        }
        else if (*(unsigned char *)(*((void *)this + 1) + 207))
        {
          Diagnostics::errorMessage((Diagnostics *)&v13);
          dyld4::RuntimeState::log(this, "tried but failed (%s) to write PrebuiltLoaderSet to file '%s'\n");
        }
        mach_o::Error::~Error(&v13);
        goto LABEL_20;
      }
      uint64_t v5 = Only;
      size_t v6 = Only[2];
      if (v6 != *((_DWORD *)a2 + 2) || _platform_memcmp(Only, a2, Only[2]))
      {
        dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), v5, v6);
LABEL_7:
        dyld4::SyscallDelegate::unlink(*((dyld4::SyscallDelegate **)this + 1), *((const char **)this + 123));
        if (*(unsigned char *)(*((void *)this + 1) + 207)) {
          dyld4::RuntimeState::log(this, "deleting existing out of date PrebuiltLoaderSet file '%s'\n", *((const char **)this + 123));
        }
        goto LABEL_9;
      }
      BOOL HasBootToken = dyld4::RuntimeState::fileAlreadyHasBootToken((uint64_t)this, v7, (uint64_t)&v15);
      uint64_t v11 = (dyld4::SyscallDelegate *)*((void *)this + 1);
      if (HasBootToken)
      {
        if (*((unsigned char *)v11 + 207))
        {
          dyld4::RuntimeState::log(this, "PrebuiltLoaderSet already saved as file '%s'\n", *((const char **)this + 123));
          uint64_t v11 = (dyld4::SyscallDelegate *)*((void *)this + 1);
        }
        dyld4::SyscallDelegate::unmapFile(v11, v5, v5[2]);
      }
      else
      {
        if (*((unsigned char *)v11 + 207))
        {
          dyld4::RuntimeState::log(this, "updating boot attribute on existing PrebuiltLoaderSet file '%s'\n", *((const char **)this + 123));
          uint64_t v11 = (dyld4::SyscallDelegate *)*((void *)this + 1);
        }
        BOOL v12 = dyld4::SyscallDelegate::setFileAttribute((int)v11, *((char **)this + 123), "com.apple.dyld", (uint64_t)&v15);
        dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), v5, v5[2]);
        if (!v12) {
          goto LABEL_7;
        }
      }
      uint64_t v8 = 1;
LABEL_20:
      mach_o::Error::~Error(&v14);
      return v8;
    }
    if (*(unsigned char *)(*((void *)this + 1) + 207)) {
      dyld4::RuntimeState::log(this, "no path to save PrebuiltLoaderSet file\n");
    }
  }
  else if (*(unsigned char *)(*((void *)this + 1) + 207))
  {
    dyld4::RuntimeState::log(this, "could not save PrebuiltLoaderSet because main executable is not codesigned\n");
  }
  return 0;
}

dyld4::DyldCacheDataConstScopedWriter *dyld4::DyldCacheDataConstScopedWriter::DyldCacheDataConstScopedWriter(dyld4::DyldCacheDataConstScopedWriter *this, dyld4::RuntimeState *a2)
{
  *(void *)this = a2;
  *((unsigned char *)this + 8) = 0;
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(this);
  return this;
}

uint64_t dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()(dyld4::Loader ****a1, uint64_t a2)
{
  uint64_t v2 = (const dyld4::RuntimeState *)a1[2];
  uint64_t v3 = *(dyld4::Loader **)(a2 + 8);
  v14[0] = 0;
  v14[1] = v3;
  v14[2] = 0;
  void v14[3] = 0;
  _OWORD v14[4] = (dyld4::Loader *)2;
  uint64_t v4 = (*a1)[1];
  if (!v4) {
    return 0;
  }
  uint64_t v7 = **a1;
  uint64_t v8 = 8 * (void)v4;
  while (1)
  {
    uint64_t v9 = *v7;
    if ((dyld4::Loader::hiddenFromFlat(*v7, 0) & 1) == 0)
    {
      if (dyld4::Loader::hasExportedSymbol((uint64_t)v9, (vm_address_t *)a1[1], v2, *(const unsigned __int8 **)(a2 + 8), 1u, 1, (uint64_t *)v14, 0))break; {
    }
      }
    ++v7;
    v8 -= 8;
    if (!v8) {
      return 0;
    }
  }
  uint64_t v11 = dyld4::Loader::resolvedAddress(v2, (uint64_t)v14);
  if (*(unsigned char *)(*((void *)v2 + 1) + 202))
  {
    uint64_t v12 = *(void *)(a2 + 16);
    uint64_t v13 = dyld4::Loader::leafName(v9, v2);
    dyld4::RuntimeState::log(v2, "fixup: *0x%012lX = 0x%012lX <%s>\n", v12, v11, v13);
  }
  **(void **)(a2 + 16) = v11;
  dyld4::RuntimeState::addDynamicReference(v2, *(const dyld4::Loader **)a2, v14[0]);
  return 1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](_DWORD *a1, unint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        unint64_t v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      uint64_t v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    uint64_t v3 = *(void *)((char *)a1 + a2 - 8);
    uint64_t v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = 0xB492B66FBE98F273 * *a1;
  uint64_t v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  unint64_t v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8);
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(void *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

void *dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 16 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    unint64_t result = memmove((void *)v4[3], *v4, 16 * (void)v4[2]);
    uint64_t v9 = (const void *)((unint64_t)v4[4] >> 4);
    *uint64_t v4 = v4[3];
    v4[1] = v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

__n128 __Block_byref_object_copy__164(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

uint64_t SwiftHashTable::hash<PointerHashTableBuilderKey>(uint64_t a1, objc **a2)
{
  unint64_t v4 = objc::lookup8((objc *)(a2 + 1), (const unsigned __int8 *)4, *(void *)(a1 + 24));
  unint64_t v5 = objc::lookup8(*a2, (const unsigned __int8 *)(8 * *((_DWORD *)a2 + 2)), *(void *)(a1 + 24));
  int v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (v5 ^ v4) >> v6;
  }
  return v7 ^ *(_DWORD *)(a1 + 4 * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v3 = a2[1];
  return v3 == *(_DWORD *)(a3 + 8) && _platform_memcmp((const void *)(a1 + *a2), *(const void **)a3, 8 * v3) == 0;
}

uint64_t SwiftHashTable::checkbyte<PointerHashTableBuilderKey>(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 8) & 0x1F | (32 * (**(_DWORD **)a2 & 7u));
}

const char *getForeignFullIdentity(const char *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = &a1[_platform_strlen(a1)];
  size_t v3 = _platform_strlen(v2 + 1);
  if (v3)
  {
    uint64_t v4 = (uint64_t)&v2[v3 + 1];
    unint64_t v5 = v2;
    do
    {
      int v6 = (const char *)v4;
      int v7 = v5[1];
      unsigned int v8 = v7 - 82;
      BOOL v9 = v7 == 78;
      vm_map_t v10 = v5 + 2;
      if (v9)
      {
        uint64_t v11 = v6;
      }
      else
      {
        vm_map_t v10 = v1;
        uint64_t v11 = v2;
      }
      if (v8 < 2)
      {
        unint64_t v2 = v6;
      }
      else
      {
        uint64_t v1 = v10;
        unint64_t v2 = v11;
      }
      size_t v12 = _platform_strlen(v6 + 1);
      uint64_t v4 = (uint64_t)&v6[v12 + 1];
      unint64_t v5 = v6;
    }
    while (v12);
  }
  return v1;
}

BOOL dyld4::PrebuiltSwift::findProtocolConformances(dyld4::PrebuiltSwift *this, vm_address_t *a2, dyld4::PrebuiltObjC *a3, dyld4::RuntimeState *a4)
{
  if (!*((void *)a3 + 2))
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc class optimisations from the on-disk binary");
    return 0;
  }
  int v6 = (void *)*((void *)a4 + 1);
  uint64_t v20 = v6[39];
  if (!v20)
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc class optimisations");
    return 0;
  }
  if (v6[36]) {
    BOOL v7 = v6[37] == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc header infos");
    return 0;
  }
  uint64_t v9 = *((void *)a4 + 6);
  if (v9)
  {
    uint64_t v19 = v6[34];
    vm_map_t v10 = (dyld4::Loader **)*((void *)a4 + 5);
    uint64_t v11 = 8 * v9;
    size_t v12 = v10;
    do
    {
      if ((*((_WORD *)*v12 + 2) & 1) == 0)
      {
        uint64_t v13 = *v12;
        uint64_t v14 = (dyld3::MachOFile *)dyld4::Loader::mf(*v12, a4);
        uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v14);
        long long v16 = (dyld3::MachOFile *)dyld4::Loader::analyzer(v13, a4);
        int v17 = dyld3::MachOFile::pointerSize(v16);
        v34[0] = _NSConcreteStackBlock;
        v34[1] = 0x40000000;
        void v34[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke;
        v34[3] = &__block_descriptor_tmp_2;
        int v35 = v17;
        v34[4] = Address;
        v34[5] = v16;
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 0x40000000;
        void v32[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2;
        v32[3] = &__block_descriptor_tmp_5;
        v32[4] = Address;
        v32[5] = v13;
        int v33 = v17;
        v32[6] = v16;
        void v32[7] = a4;
        uint64_t v26 = 0;
        long long v27 = &v26;
        uint64_t v28 = 0x4802000000;
        long long v29 = __Block_byref_object_copy__1;
        uint64_t v30 = __Block_byref_object_dispose__1;
        uint64_t v18 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(v13, a4);
        metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v31, v18);
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000;
        void v23[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_6;
        v23[3] = &unk_1EFF64588;
        v23[8] = v14;
        v23[9] = a2;
        void v23[6] = &v26;
        void v23[7] = this;
        v23[4] = v34;
        v23[5] = v32;
        v23[10] = Address;
        void v23[11] = v13;
        v23[12] = a4;
        v23[13] = a3;
        v23[14] = v20;
        v23[15] = v19;
        char v24 = 1;
        *(_DWORD *)&v25[3] = *(_DWORD *)((char *)v36 + 3);
        *(_DWORD *)long long v25 = v36[0];
        metadata_visitor::SwiftVisitor::forEachProtocolConformance((metadata_visitor::SwiftVisitor *)(v27 + 5), (uint64_t)v23);
        _Block_object_dispose(&v26, 8);
      }
      ++v12;
      ++v10;
      v11 -= 8;
    }
    while (v11);
  }
  return !Diagnostics::hasError((Diagnostics *)a2);
}

BOOL ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    return 0;
  }
  uint64_t v4 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)(a2 + 8));
  if (!v5) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = v4 - *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 48) == 8) {
    uint64_t v8 = *(void *)(v6 + v7);
  }
  else {
    uint64_t v8 = *(unsigned int *)(v6 + v7);
  }
  return v8 == 0;
}

uint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2@<X0>(metadata_visitor::ResolvedValue *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  int v5 = *(unsigned __int8 *)this;
  uint64_t result = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)((char *)this + 8));
  if (v5)
  {
    if (v7)
    {
      uint64_t v8 = (char *)(result - *(void *)(a2 + 32));
      *(void *)a3 = *(void *)(a2 + 40);
LABEL_4:
      *(void *)(a3 + 8) = v8;
      *(unsigned char *)(a3 + 16) = 1;
      return result;
    }
LABEL_16:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (!v7) {
    goto LABEL_16;
  }
  uint64_t v9 = result - *(void *)(a2 + 32);
  uint64_t v10 = *(void *)(a2 + 48);
  if (*(_DWORD *)(a2 + 64) == 8)
  {
    uint64_t v11 = *(char **)(v10 + v9);
    if (!v11) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v11 = (char *)*(unsigned int *)(v10 + v9);
    if (!*(_DWORD *)(v10 + v9)) {
      goto LABEL_14;
    }
  }
  size_t v12 = *(dyld4::RuntimeState **)(a2 + 56);
  uint64_t v13 = *((void *)v12 + 6);
  if (v13)
  {
    uint64_t v14 = (dyld4::Loader **)*((void *)v12 + 5);
    uint64_t v15 = 8 * v13;
    long long v16 = v14;
    while (1)
    {
      int v17 = *v16;
      unint64_t v19 = 0;
      uint64_t v20 = 0;
      unsigned __int8 v18 = 0;
      uint64_t result = dyld4::Loader::contains(v17, v12, v11, (const void **)&v20, &v19, &v18);
      if (result) {
        break;
      }
      ++v16;
      ++v14;
      v15 -= 8;
      if (!v15) {
        goto LABEL_14;
      }
    }
    uint64_t result = dyld4::Loader::loadAddress(v17, v12);
    uint64_t v8 = &v11[-result];
    *(void *)a3 = v17;
    goto LABEL_4;
  }
LABEL_14:
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 16) = 0;
  return result;
}

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

void ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_6(uint64_t a1, metadata_visitor::SwiftConformance *this, unsigned char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  if (metadata_visitor::SwiftConformance::isNull(this)
    && (dyld3::MachOFile::enforceFormat(*(_DWORD **)(a1 + 64), 14) & 1) == 0)
  {
    uint64_t v11 = *(vm_address_t **)(a1 + 72);
    metadata_visitor::SwiftConformance::getLocation(this);
    Diagnostics::error(v11, "Skipped optimizing Swift protocols due to null conformance at 0x%llx");
    goto LABEL_17;
  }
  metadata_visitor::SwiftConformance::getProtocolPointer(this, (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), (uint64_t)v64);
  if ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))()) {
    return;
  }
  metadata_visitor::SwiftConformance::getTypeRef(this, (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), (uint64_t)v63);
  metadata_visitor::SwiftConformance::getProtocolConformanceFlags(this, (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v62);
  metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getTargetPointer((metadata_visitor::ResolvedValue *)v63, (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), (uint64_t)v61);
  if ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))()) {
    return;
  }
  LOBYTE(v59.vardyld4::halt((char *)__format, 0) = 0;
  char v60 = 0;
  (*(void (**)(BindTarget *__return_ptr))(*(void *)(a1 + 40) + 16))(&v44);
  char v60 = v45;
  BindTarget v59 = v44;
  if (!(_BYTE)v45)
  {
    Diagnostics::error(*(vm_address_t **)(a1 + 72), "Skipped optimizing Swift protocols, could not find image for type conformance pointer");
    goto LABEL_17;
  }
  LOBYTE(v57.vardyld4::halt((char *)__format, 0) = 0;
  LOBYTE(v58) = 0;
  (*(void (**)(BindTarget *__return_ptr))(*(void *)(a1 + 40) + 16))(&v44);
  LOBYTE(v58) = v45;
  BindTarget v57 = v44;
  if (!(_BYTE)v45)
  {
    Diagnostics::error(*(vm_address_t **)(a1 + 72), "Skipped optimizing Swift protocols, could not find image for type protocol pointer");
    goto LABEL_17;
  }
  VMuint64_t Address = objc_visitor::Protocol::getVMAddress(this);
  if (!v8) {
    goto LABEL_41;
  }
  unint64_t v9 = VMAddress - *(void *)(a1 + 80);
  unsigned int v10 = metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags::typeReferenceKind((metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags *)v62);
  if (v10 < 2)
  {
    LOBYTE(v55.vardyld4::halt((char *)__format, 0) = 0;
    char v56 = 0;
    if (v59.var0 == *(Loader **)(a1 + 88))
    {
      v44.var0 = *(Loader **)(a1 + 80);
      int v14 = 1;
      LOBYTE(v44.var1) = 1;
      v50.var0 = (Loader *)v59.var1;
      LOBYTE(v50.var1) = 1;
      uint64_t v23 = operator+((uint64_t)&v44, (uint64_t)&v50);
      metadata_visitor::Visitor::getValueFor(*(void *)(*(void *)(a1 + 48) + 8) + 40, v23, v24, &v44);
      BindTarget v50 = v44;
      *(void *)&long long v51 = v45;
      if (metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v50))
      {
        int hasImportInfo = metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v50);
        unsigned __int8 v18 = (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
        unint64_t v19 = &v50;
        goto LABEL_27;
      }
    }
    else
    {
      size_t v12 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer((dyld4::Loader *)v59.var0, *(dyld4::RuntimeState **)(a1 + 96));
      metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v44, v12);
      uint64_t v13 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)v59.var0, *(const dyld4::RuntimeState **)(a1 + 96));
      v54.var0 = (Loader *)dyld3::MachOFile::preferredLoadAddress(v13);
      int v14 = 1;
      LOBYTE(v54.var1) = 1;
      v50.var0 = (Loader *)v59.var1;
      LOBYTE(v50.var1) = 1;
      uint64_t v15 = operator+((uint64_t)&v54, (uint64_t)&v50);
      metadata_visitor::Visitor::getValueFor((uint64_t)&v44, v15, v16, &v50);
      BindTarget v52 = v50;
      uint64_t v53 = v51;
      if (metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v52))
      {
        int hasImportInfo = metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v52);
        unsigned __int8 v18 = (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
        unint64_t v19 = &v52;
LABEL_27:
        metadata_visitor::SwiftConformance::TypeContextDescriptor::getName((metadata_visitor::SwiftConformance::TypeContextDescriptor *)v19, v18, &v55);
        char v56 = 1;
LABEL_29:
        if (!v14)
        {
LABEL_37:
          if (!v60) {
            goto LABEL_41;
          }
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50, &v59);
          if (!(_BYTE)v58) {
            goto LABEL_41;
          }
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50.var1, &v57);
          v52.var0 = *(Loader **)(a1 + 88);
          v52.var1 = v9;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v54, &v52);
          LOBYTE(v49.vardyld4::halt((char *)__format, 0) = 0;
          BindTarget v44 = v50;
          *(void *)&long long v45 = v54.var0;
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v6, (uint64_t)&v44, &v49);
          return;
        }
        long long v25 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v55);
        v52.var0 = (Loader *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)&v55);
        v52.var1 = v26;
        size_t v27 = _platform_strlen(v25);
        if (hasImportInfo)
        {
          ForeignFullIdentity = getForeignFullIdentity(v25);
          size_t v30 = v29;
          v44.var0 = (Loader *)(ForeignFullIdentity - v25);
          LOBYTE(v44.var1) = 1;
          operator+=((uint64_t)&v52, (uint64_t)&v44);
          long long v25 = (char *)ForeignFullIdentity;
        }
        else
        {
          size_t v30 = v27;
        }
        if (!(v30 >> 16))
        {
          uint64_t v31 = *(Loader **)(a1 + 88);
          v54.var0 = v31;
          if (!LOBYTE(v52.var1)) {
            goto LABEL_41;
          }
          var0 = v52.var0;
          int v33 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)v31, *(const dyld4::RuntimeState **)(a1 + 96));
          v54.var1 = (unint64_t)var0 - dyld3::MachOFile::preferredLoadAddress(v33);
          v50.var0 = (Loader *)v25;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50.var1, &v54);
          *(void *)&long long v51 = v30;
          if (!(_BYTE)v58) {
            goto LABEL_41;
          }
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v51 + 8), &v57);
          v49.var0 = *(Loader **)(a1 + 88);
          v49.var1 = v9;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v48, &v49);
          char v47 = 0;
          BindTarget v44 = v50;
          long long v45 = v51;
          uint64_t v46 = v48;
          dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(v6 + 208, (uint64_t)&v44, &v47);
          goto LABEL_37;
        }
        Diagnostics::error(*(vm_address_t **)(a1 + 72), "Protocol conformance exceeded name length of 16-bits");
LABEL_17:
        *a3 = 1;
        return;
      }
    }
    int v14 = 0;
    int hasImportInfo = 0;
    goto LABEL_29;
  }
  if (v10 == 2)
  {
    ClassName = (Loader *)metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName((metadata_visitor::SwiftConformance::SwiftTypeRefPointer *)v63, (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
    v55.var0 = *(Loader **)(a1 + 88);
    v55.var1 = v9;
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v52, &v55);
    v44.var0 = 0;
    v44.var1 = (unint64_t)&v44;
    *(void *)&long long v45 = 0x2000000000;
    BYTE8(v45) = 0;
    v50.var0 = ClassName;
    v50.var1 = _platform_strlen((const char *)ClassName);
    int v21 = *(uint64_t **)(a1 + 104);
    v40[0] = _NSConcreteStackBlock;
    v40[1] = 0x40000000;
    v40[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2_11;
    v40[3] = &unk_1EFF64538;
    v40[4] = &v44;
    v40[5] = v6;
    BindTarget v41 = v57;
    uint64_t v42 = v58;
    uint64_t v43 = v52.var0;
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>((uint64_t)(v21 + 17), v21 + 19, v21 + 24, v21[29], (const void **)&v50.var0, (uint64_t)v40);
    uint64_t v22 = *(unsigned int **)(a1 + 112);
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 0x40000000;
    void v34[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_3;
    v34[3] = &unk_1EFF64560;
    long long v35 = *(_OWORD *)(a1 + 120);
    uint64_t v36 = *(void *)(a1 + 96);
    v34[4] = &v44;
    v34[5] = v6;
    BindTarget v37 = v57;
    uint64_t v38 = v58;
    uint64_t v39 = v52.var0;
    objc::ObjectHashTable::forEachObject(v22, (char *)ClassName, (uint64_t)v34);
    if (!*(unsigned char *)(v44.var1 + 24))
    {
      Diagnostics::error(*(vm_address_t **)(a1 + 72), "Skipped optimizing Swift protocols, could not find image for ObjCClassName pointer at all");
      *a3 = 1;
    }
    _Block_object_dispose(&v44, 8);
  }
  else if (v10 == 3)
  {
    if (v60)
    {
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v55, &v59);
      if ((_BYTE)v58)
      {
        dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v55.var1, &v57);
        v50.var0 = *(Loader **)(a1 + 88);
        v50.var1 = v9;
        dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v52, &v50);
        LOBYTE(v54.vardyld4::halt((char *)__format, 0) = 0;
        BindTarget v44 = v55;
        *(void *)&long long v45 = v52.var0;
        dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v6 + 104, (uint64_t)&v44, &v54);
        return;
      }
    }
LABEL_41:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
}

uint64_t operator+(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 8) || !*(unsigned char *)(a2 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return *(void *)a2 + *(void *)a1;
}

uint64_t operator+=(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(result + 8) || !*(unsigned char *)(a2 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  *(void *)result += *(void *)a2;
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)a1)
  {
    unint64_t v7 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v6;
    vm_size_t size = 0;
    memset(v41, 0, sizeof(v41));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v41, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v41, 1);
      uint64_t v8 = (*(void *)&v41[1])++;
      *(void *)(*(void *)&v41[0] + 8 * v8) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v9 = 0;
      do
      {
        if ((*(unsigned char *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v9)+ 40) & 6) == 0)
        {
          uint64_t v10 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v9);
          unint64_t v11 = dyld4::HashForeignConformanceKey::hash(v10, *(dyld4::RuntimeState **)(a1 + 96));
          unint64_t v12 = (*(void *)&v41[1] - 1) & v11;
          if (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v41, v12) != -1)
          {
            uint64_t v13 = 1;
            do
              unint64_t v12 = (*(void *)&v41[1] - 1) & (v12 + v13++);
            while (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v41, v12) != -1);
          }
          *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v41, v12) = v9;
        }
        ++v9;
      }
      while (v9 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v41)
    {
      *(void *)&v41[1] = 0;
      if (*((void *)&v41[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v41[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v14 = *(void *)(a1 + 40);
      if (v14) {
        vm_deallocate(mach_task_self_, v14, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v41[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v41 + 8);
      vm_size_t v15 = size;
      *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *((void *)&v41[1] + 1);
      *(void *)(a1 + 48) = v15;
    }
  }
  unint64_t v16 = (*(void *)(a1 + 32) - 1) & dyld4::HashForeignConformanceKey::hash(a2, *(dyld4::RuntimeState **)(a1 + 96));
  unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
  if (v17 == -1)
  {
LABEL_22:
    unsigned __int8 v18 = (void *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 72);
    *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16) = v21;
    ++*(void *)(a1 + 8);
    long long v22 = *(_OWORD *)(a2 + 16);
    v41[0] = *(_OWORD *)a2;
    v41[1] = v22;
    uint64_t v23 = *(void *)(a2 + 32);
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v24 = *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v25 + 1;
    uint64_t v26 = v24 + 48 * v25;
    *(_OWORD *)uint64_t v26 = v41[0];
    *(_OWORD *)(v26 + 16) = v41[1];
    *(void *)(v26 + 32) = v23;
    *(void *)(v26 + 4dyld4::halt((char *)__format, 0) = 0;
    *a3 = 0;
    uint64_t v27 = *(void *)(a1 + 72);
    if (!v27) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
  }
  else
  {
    unsigned __int8 v18 = (void *)(a1 + 56);
    uint64_t v19 = 1;
    while (1)
    {
      uint64_t v20 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v17);
      if (dyld4::EqualForeignConformanceKey::equal(v20, a2, *(dyld4::RuntimeState **)(a1 + 96))) {
        break;
      }
      unint64_t v16 = (*(void *)(a1 + 32) - 1) & (v16 + v19++);
      unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
      if (v17 == -1) {
        goto LABEL_22;
      }
    }
    while (1)
    {
      char v28 = *(unsigned char *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v17)+ 40);
      size_t v29 = (void *)(a1 + 56);
      if ((v28 & 3) == 0) {
        break;
      }
      unint64_t v17 = *(void *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[](v29, v17)+ 40) >> 3;
    }
    uint64_t v30 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[](v29, v17);
    uint64_t v31 = *(void *)(v30 + 40);
    if ((v31 & 7) != 0)
    {
      if ((v31 & 4) == 0) {
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert();
      }
      unint64_t v32 = v31 & 0xFFFFFFFFFFFFFFF9 | 2;
      *(void *)(v30 + 4dyld4::halt((char *)__format, 0) = v32;
      uint64_t v33 = v32 & 3 | (8 * *(void *)(a1 + 72));
    }
    else
    {
      uint64_t v34 = v31 | 1;
      *(void *)(v30 + 4dyld4::halt((char *)__format, 0) = v34;
      uint64_t v33 = v34 & 7 | (8 * *(void *)(a1 + 72));
    }
    *(void *)(v30 + 4dyld4::halt((char *)__format, 0) = v33;
    long long v35 = *(_OWORD *)(a2 + 16);
    v41[0] = *(_OWORD *)a2;
    v41[1] = v35;
    uint64_t v36 = *(void *)(a2 + 32);
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v37 = *(void *)(a1 + 56);
    uint64_t v38 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v38 + 1;
    uint64_t v39 = v37 + 48 * v38;
    *(_OWORD *)uint64_t v39 = v41[0];
    *(_OWORD *)(v39 + 16) = v41[1];
    *(void *)(v39 + 32) = v36;
    *(void *)(v39 + 4dyld4::halt((char *)__format, 0) = 4;
    *a3 = 1;
    uint64_t v27 = *(void *)(a1 + 72);
    if (!v27) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
  }
  return *v18 + 48 * v27 - 48;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)a1)
  {
    unint64_t v7 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v6;
    vm_size_t size = 0;
    memset(v39, 0, sizeof(v39));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v39, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v39, 1);
      uint64_t v8 = (*(void *)&v39[1])++;
      *(void *)(*(void *)&v39[0] + 8 * v8) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v9 = 0;
      do
      {
        if ((*(unsigned char *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v9)+ 24) & 6) == 0)
        {
          uint64_t v10 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v9);
          unint64_t v11 = dyld4::HashMetadataConformanceKey::hash(v10);
          unint64_t v12 = (*(void *)&v39[1] - 1) & v11;
          if (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v39, v12) != -1)
          {
            uint64_t v13 = 1;
            do
              unint64_t v12 = (*(void *)&v39[1] - 1) & (v12 + v13++);
            while (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v39, v12) != -1);
          }
          *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v39, v12) = v9;
        }
        ++v9;
      }
      while (v9 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v39)
    {
      *(void *)&v39[1] = 0;
      if (*((void *)&v39[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v39[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v14 = *(void *)(a1 + 40);
      if (v14) {
        vm_deallocate(mach_task_self_, v14, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v39[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v39 + 8);
      vm_size_t v15 = size;
      *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *((void *)&v39[1] + 1);
      *(void *)(a1 + 48) = v15;
    }
  }
  unint64_t v16 = (*(void *)(a1 + 32) - 1) & dyld4::HashMetadataConformanceKey::hash(a2);
  unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
  if (v17 == -1)
  {
LABEL_22:
    unsigned __int8 v18 = (void *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 72);
    *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16) = v21;
    ++*(void *)(a1 + 8);
    v39[0] = *(_OWORD *)a2;
    uint64_t v22 = *(void *)(a2 + 16);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v23 = *(void *)(a1 + 56);
    uint64_t v24 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v24 + 1;
    uint64_t v25 = v23 + 32 * v24;
    *(_OWORD *)uint64_t v25 = v39[0];
    *(void *)(v25 + 16) = v22;
    *(void *)(v25 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    *a3 = 0;
    uint64_t v26 = *(void *)(a1 + 72);
    if (!v26) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
  }
  else
  {
    unsigned __int8 v18 = (void *)(a1 + 56);
    uint64_t v19 = 1;
    while (1)
    {
      uint64_t v20 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v17);
      if (dyld4::EqualTypeConformanceKey::equal(v20, a2)) {
        break;
      }
      unint64_t v16 = (*(void *)(a1 + 32) - 1) & (v16 + v19++);
      unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
      if (v17 == -1) {
        goto LABEL_22;
      }
    }
    while (1)
    {
      char v27 = *(unsigned char *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v17)+ 24);
      char v28 = (void *)(a1 + 56);
      if ((v27 & 3) == 0) {
        break;
      }
      unint64_t v17 = *(void *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v28, v17)+ 24) >> 3;
    }
    uint64_t v29 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v28, v17);
    uint64_t v30 = *(void *)(v29 + 24);
    if ((v30 & 7) != 0)
    {
      if ((v30 & 4) == 0) {
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert();
      }
      unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFF9 | 2;
      *(void *)(v29 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v31;
      uint64_t v32 = v31 & 3 | (8 * *(void *)(a1 + 72));
    }
    else
    {
      uint64_t v33 = v30 | 1;
      *(void *)(v29 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v33;
      uint64_t v32 = v33 & 7 | (8 * *(void *)(a1 + 72));
    }
    *(void *)(v29 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v32;
    v39[0] = *(_OWORD *)a2;
    uint64_t v34 = *(void *)(a2 + 16);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v35 = *(void *)(a1 + 56);
    uint64_t v36 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v36 + 1;
    uint64_t v37 = v35 + 32 * v36;
    *(_OWORD *)uint64_t v37 = v39[0];
    *(void *)(v37 + 16) = v34;
    *(void *)(v37 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 4;
    *a3 = 1;
    uint64_t v26 = *(void *)(a1 + 72);
    if (!v26) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
  }
  return *v18 + 32 * v26 - 32;
}

uint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2_11(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(const BindTarget ***)a2;
    int v5 = (const BindTarget *)(result + 48);
    uint64_t v6 = *(void *)(result + 40) + 104;
    uint64_t v7 = 8 * v2;
    do
    {
      uint64_t v8 = *v4;
      *(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v12, v8 + 1);
      if (!*(unsigned char *)(v3 + 64)) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v12 + 8), v5);
      char v11 = 0;
      long long v9 = v12;
      uint64_t v10 = *(void *)(v3 + 72);
      __n128 result = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v6, (uint64_t)&v9, &v11);
      ++v4;
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

unint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_3(unint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(result + 56)) {
    goto LABEL_13;
  }
  unint64_t v2 = result;
  uint64_t v3 = *(const dyld4::RuntimeState **)(result + 64);
  uint64_t v4 = *((void *)v3 + 6);
  if (!v4) {
    return result;
  }
  uint64_t v5 = *(void *)(result + 40);
  unint64_t v6 = *(void *)(result + 48) + a2;
  uint64_t v7 = (dyld4::Loader **)*((void *)v3 + 5);
  uint64_t v8 = 8 * v4;
  long long v9 = v7;
  while (1)
  {
    uint64_t v10 = *v9;
    char v11 = (dyld3::MachOFile *)dyld4::Loader::mf(*v9, v3);
    unint64_t Address = dyld3::MachOFile::preferredLoadAddress(v11);
    __n128 result = dyld3::MachOFile::mappedSize(v11);
    if (v6 >= Address && result + Address > v6) {
      break;
    }
    ++v9;
    ++v7;
    v8 -= 8;
    if (!v8) {
      return result;
    }
  }
  v18.var0 = (Loader *)v10;
  v18.var1 = v6 - Address;
  *(unsigned char *)(*(void *)(*(void *)(v2 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v17, &v18);
  if (!*(unsigned char *)(v2 + 88)) {
LABEL_13:
  }
    std::__throw_bad_optional_access[abi:nn180100]();
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v17 + 8), (const BindTarget *)(v2 + 72));
  char v16 = 0;
  long long v14 = v17;
  uint64_t v15 = *(void *)(v2 + 96);
  return dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert(v5 + 104, (uint64_t)&v14, &v16);
}

BOOL dyld4::PrebuiltSwift::make(dyld4::PrebuiltSwift *this, vm_address_t *a2, dyld4::PrebuiltObjC *a3, dyld4::RuntimeState *a4)
{
  BOOL result = dyld4::PrebuiltSwift::findProtocolConformances(this, a2, a3, a4);
  if (result) {
    *((unsigned char *)this + 312) = 1;
  }
  return result;
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, const void **a5, uint64_t a6)
{
  uint64_t v46 = a6;
  char v47 = a3;
  if (a3[2])
  {
    unint64_t v8 = prebuilt_objc::hashStringKey((uint64_t)a5);
    unint64_t v9 = a2[2];
    unint64_t v10 = (v9 - 1) & v8;
    if (v9 <= v10) {
LABEL_9:
    }
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    uint64_t v11 = *a2;
    unint64_t v12 = v47[2];
    uint64_t v13 = *v47;
    uint64_t v14 = 1;
    long long v17 = a5;
    char v16 = *a5;
    size_t v15 = (size_t)v17[1];
    while (1)
    {
      unint64_t v18 = *(void *)(v11 + 8 * v10);
      if (v18 == -1) {
        break;
      }
      if (v12 <= v18) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
      }
      uint64_t v19 = v13 + 56 * v18;
      if (*(void *)(v19 + 8) == v15)
      {
        uint64_t v20 = _platform_memcmp(*(const void **)v19, v16, v15);
        if (!v20)
        {
          uint64_t v28 = v13 + 56 * v18;
          unint64_t v31 = *(void *)(v28 + 48);
          uint64_t v30 = (void *)(v28 + 48);
          unint64_t v29 = v31;
          if ((v31 & 7) != 0)
          {
            if (v12 <= v29 >> 3) {
LABEL_15:
            }
              dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
            unint64_t v32 = v29 >> 3;
            int v33 = 2;
            while (1)
            {
              unint64_t v34 = *(void *)(v13 + 56 * v32 + 48);
              if ((v34 & 3) == 0) {
                break;
              }
              unint64_t v32 = v34 >> 3;
              ++v33;
              if (v12 <= v34 >> 3) {
                goto LABEL_15;
              }
            }
            __chkstk_darwin(v20, v21, v22, v23, v24, v25, v26, v27, v45);
            uint64_t v37 = (uint64_t *)((char *)&v45 - v36);
            if (v35 >= 0x200) {
              size_t v38 = 512;
            }
            else {
              size_t v38 = v35;
            }
            bzero((char *)&v45 - v36, v38);
            uint64_t *v37 = v13 + 56 * v18 + 16;
            unint64_t v39 = v47[2];
            if (v39 <= *v30 >> 3) {
LABEL_23:
            }
              dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
            uint64_t v40 = *v30 >> 3;
            uint64_t v41 = *v47;
            unsigned int v42 = 2;
            while (1)
            {
              uint64_t v43 = v41 + 56 * v40;
              unint64_t v44 = *(void *)(v43 + 48);
              v37[v42 - 1] = v43 + 16;
              if ((v44 & 3) == 0) {
                break;
              }
              uint64_t v40 = v44 >> 3;
              ++v42;
              if (v39 <= v44 >> 3) {
                goto LABEL_23;
              }
            }
            uint64_t v48 = v37;
            v49.i64[0] = v42;
            v49.i64[1] = v42;
            (*(void (**)(uint64_t, uint64_t **))(v46 + 16))(v46, &v48);
          }
          else
          {
            uint64_t v50 = v13 + 56 * v18 + 16;
            uint64_t v48 = &v50;
            int64x2_t v49 = vdupq_n_s64(1uLL);
            (*(void (**)(uint64_t, uint64_t **))(v46 + 16))(v46, &v48);
          }
          return;
        }
      }
      unint64_t v10 = (v9 - 1) & (v10 + v14++);
      if (v9 <= v10) {
        goto LABEL_9;
      }
    }
  }
}

BOOL *dyld4::Loader::InitialOptions::InitialOptions(BOOL *this, const dyld4::Loader *a2)
{
  *this = (*((unsigned char *)a2 + 4) & 2) != 0;
  this[1] = (*((unsigned char *)a2 + 4) & 4) != 0;
  this[2] = (*((unsigned char *)a2 + 4) & 8) != 0;
  this[3] = (*((unsigned char *)a2 + 4) & 0x10) != 0;
  this[4] = (*((unsigned char *)a2 + 4) & 0x20) != 0;
  this[5] = (*((unsigned char *)a2 + 4) & 0x40) != 0;
  this[6] = (*((_WORD *)a2 + 2) & 0x80) != 0;
  this[7] = *((unsigned char *)a2 + 5) & 1;
  this[8] = (*((_WORD *)a2 + 2) & 0x400) != 0;
  this[9] = (*((_WORD *)a2 + 2) & 0x800) != 0;
  this[10] = (*((_WORD *)a2 + 2) & 0x1000) != 0;
  this[11] = (*((_WORD *)a2 + 2) & 0x2000) != 0;
  return this;
}

void dyld4::Loader::unmap(dyld4::Loader *this, dyld4::RuntimeState *a2, char a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::unmap();
  }
  if (*((_WORD *)this + 2))
  {
    dyld4::PrebuiltLoader::unmap((uint64_t)this, a2);
  }
  else
  {
    dyld4::JustInTimeLoader::unmap(this, (dyld4::SyscallDelegate **)a2, a3);
  }
}

dyld4::Loader *dyld4::Loader::leafName(dyld4::Loader *this, const char *a2)
{
  uint64_t v3 = strrchr((char *)this, 47);
  if (v3) {
    return (dyld4::Loader *)(v3 + 1);
  }
  else {
    return this;
  }
}

char *dyld4::Loader::leafName(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  unint64_t v2 = (char *)dyld4::Loader::path(this, a2);
  uint64_t v3 = strrchr(v2, 47);
  if (v3) {
    return v3 + 1;
  }
  else {
    return v2;
  }
}

uint64_t dyld4::Loader::appendHexByte(uint64_t this, void *a2, char **a3)
{
  uint64_t v3 = (unsigned char *)(*a2)++;
  if (this >= 0xA0) {
    char v4 = 55;
  }
  else {
    char v4 = 48;
  }
  unsigned char *v3 = v4 + (this >> 4);
  uint64_t v5 = (unsigned char *)(*a2)++;
  if ((this & 0xFu) >= 0xA) {
    char v6 = 55;
  }
  else {
    char v6 = 48;
  }
  *uint64_t v5 = v6 + (this & 0xF);
  return this;
}

unsigned __int8 *dyld4::Loader::uuidToStr(unsigned __int8 *this, unsigned __int8 *a2, char *a3)
{
  unsigned int v3 = *this;
  if (v3 >= 0xA0) {
    char v4 = 55;
  }
  else {
    char v4 = 48;
  }
  *a2 = v4 + (*this >> 4);
  unsigned int v5 = v3 & 0xF;
  if (v5 >= 0xA) {
    char v6 = 55;
  }
  else {
    char v6 = 48;
  }
  a2[1] = v6 + v5;
  unsigned int v7 = this[1];
  if (v7 >= 0xA0) {
    char v8 = 55;
  }
  else {
    char v8 = 48;
  }
  a2[2] = v8 + (this[1] >> 4);
  unsigned int v9 = v7 & 0xF;
  if (v9 >= 0xA) {
    char v10 = 55;
  }
  else {
    char v10 = 48;
  }
  a2[3] = v10 + v9;
  unsigned int v11 = this[2];
  if (v11 >= 0xA0) {
    char v12 = 55;
  }
  else {
    char v12 = 48;
  }
  a2[4] = v12 + (this[2] >> 4);
  unsigned int v13 = v11 & 0xF;
  if (v13 >= 0xA) {
    char v14 = 55;
  }
  else {
    char v14 = 48;
  }
  a2[5] = v14 + v13;
  unsigned int v15 = this[3];
  if (v15 >= 0xA0) {
    char v16 = 55;
  }
  else {
    char v16 = 48;
  }
  a2[6] = v16 + (this[3] >> 4);
  unsigned int v17 = v15 & 0xF;
  if (v17 >= 0xA) {
    char v18 = 55;
  }
  else {
    char v18 = 48;
  }
  a2[7] = v18 + v17;
  a2[8] = 45;
  unsigned int v19 = this[4];
  if (v19 >= 0xA0) {
    char v20 = 55;
  }
  else {
    char v20 = 48;
  }
  a2[9] = v20 + (this[4] >> 4);
  unsigned int v21 = v19 & 0xF;
  if (v21 >= 0xA) {
    char v22 = 55;
  }
  else {
    char v22 = 48;
  }
  a2[10] = v22 + v21;
  unsigned int v23 = this[5];
  if (v23 >= 0xA0) {
    char v24 = 55;
  }
  else {
    char v24 = 48;
  }
  a2[11] = v24 + (this[5] >> 4);
  unsigned int v25 = v23 & 0xF;
  if (v25 >= 0xA) {
    char v26 = 55;
  }
  else {
    char v26 = 48;
  }
  a2[12] = v26 + v25;
  a2[13] = 45;
  unsigned int v27 = this[6];
  if (v27 >= 0xA0) {
    char v28 = 55;
  }
  else {
    char v28 = 48;
  }
  a2[14] = v28 + (this[6] >> 4);
  unsigned int v29 = v27 & 0xF;
  if (v29 >= 0xA) {
    char v30 = 55;
  }
  else {
    char v30 = 48;
  }
  a2[15] = v30 + v29;
  unsigned int v31 = this[7];
  if (v31 >= 0xA0) {
    char v32 = 55;
  }
  else {
    char v32 = 48;
  }
  a2[16] = v32 + (this[7] >> 4);
  unsigned int v33 = v31 & 0xF;
  if (v33 >= 0xA) {
    char v34 = 55;
  }
  else {
    char v34 = 48;
  }
  a2[17] = v34 + v33;
  a2[18] = 45;
  unsigned int v35 = this[8];
  if (v35 >= 0xA0) {
    char v36 = 55;
  }
  else {
    char v36 = 48;
  }
  a2[19] = v36 + (this[8] >> 4);
  unsigned int v37 = v35 & 0xF;
  if (v37 >= 0xA) {
    char v38 = 55;
  }
  else {
    char v38 = 48;
  }
  a2[20] = v38 + v37;
  unsigned int v39 = this[9];
  if (v39 >= 0xA0) {
    char v40 = 55;
  }
  else {
    char v40 = 48;
  }
  a2[21] = v40 + (this[9] >> 4);
  unsigned int v41 = v39 & 0xF;
  if (v41 >= 0xA) {
    char v42 = 55;
  }
  else {
    char v42 = 48;
  }
  a2[22] = v42 + v41;
  a2[23] = 45;
  unsigned int v43 = this[10];
  if (v43 >= 0xA0) {
    char v44 = 55;
  }
  else {
    char v44 = 48;
  }
  a2[24] = v44 + (this[10] >> 4);
  unsigned int v45 = v43 & 0xF;
  if (v45 >= 0xA) {
    char v46 = 55;
  }
  else {
    char v46 = 48;
  }
  a2[25] = v46 + v45;
  unsigned int v47 = this[11];
  if (v47 >= 0xA0) {
    char v48 = 55;
  }
  else {
    char v48 = 48;
  }
  a2[26] = v48 + (this[11] >> 4);
  unsigned int v49 = v47 & 0xF;
  if (v49 >= 0xA) {
    char v50 = 55;
  }
  else {
    char v50 = 48;
  }
  a2[27] = v50 + v49;
  unsigned int v51 = this[12];
  if (v51 >= 0xA0) {
    char v52 = 55;
  }
  else {
    char v52 = 48;
  }
  a2[28] = v52 + (this[12] >> 4);
  unsigned int v53 = v51 & 0xF;
  if (v53 >= 0xA) {
    char v54 = 55;
  }
  else {
    char v54 = 48;
  }
  a2[29] = v54 + v53;
  unsigned int v55 = this[13];
  if (v55 >= 0xA0) {
    char v56 = 55;
  }
  else {
    char v56 = 48;
  }
  a2[30] = v56 + (this[13] >> 4);
  unsigned int v57 = v55 & 0xF;
  if (v57 >= 0xA) {
    char v58 = 55;
  }
  else {
    char v58 = 48;
  }
  a2[31] = v58 + v57;
  unsigned int v59 = this[14];
  if (v59 >= 0xA0) {
    char v60 = 55;
  }
  else {
    char v60 = 48;
  }
  a2[32] = v60 + (this[14] >> 4);
  unsigned int v61 = v59 & 0xF;
  if (v61 >= 0xA) {
    char v62 = 55;
  }
  else {
    char v62 = 48;
  }
  a2[33] = v62 + v61;
  unsigned int v63 = this[15];
  if (v63 >= 0xA0) {
    char v64 = 55;
  }
  else {
    char v64 = 48;
  }
  a2[34] = v64 + (this[15] >> 4);
  unsigned int v65 = v63 & 0xF;
  if (v65 >= 0xA) {
    char v66 = 55;
  }
  else {
    char v66 = 48;
  }
  *(_WORD *)(a2 + 35) = (v66 + v65);
  return this;
}

unsigned __int8 *dyld4::Loader::getUuidStr(unsigned __int8 *this, char *a2, char *a3)
{
  if ((*((_WORD *)this + 2) & 0x400) != 0) {
    return dyld4::Loader::uuidToStr(this + 8, (unsigned __int8 *)a2, a3);
  }
  *(void *)a2 = 0x64697575206F6ELL;
  return this;
}

void dyld4::Loader::logLoad(dyld4::Loader *this, dyld4::RuntimeState *a2, char *a3)
{
  if ((*((_WORD *)this + 2) & 0x400) != 0) {
    dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)v5, a3);
  }
  else {
    strcpy(v5, "no uuid");
  }
  dyld4::RuntimeState::log(a2, "<%s> %s\n", v5, a3);
}

uint64_t ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke_2(uint64_t result, uint64_t a2, unsigned char *a3)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *a3 = 1;
  return result;
}

char *dyld4::Loader::expandAndNormalizeAtExecutablePath(dyld4::Loader *this, const char *__s1, char *a3, char *a4)
{
  if (_platform_strncmp(__s1, "@executable_path", 0x10uLL)) {
    return 0;
  }
  int v10 = *((unsigned __int8 *)__s1 + 16);
  unsigned int v9 = __s1 + 16;
  int v8 = v10;
  if (v10 != 47 && v8 != 0) {
    return 0;
  }
  strlcpy(a3, (const char *)this, 0x400uLL);
  BOOL result = strrchr(a3, 47);
  if (result)
  {
    if (*v9 == 47)
    {
      do
      {
        char v12 = v9;
        unsigned int v13 = result;
        if (_platform_strncmp(v9, "/..", 3uLL)) {
          break;
        }
        char v14 = v13 - 1;
        do
        {
          BOOL result = v14;
          if (v14 <= a3) {
            break;
          }
          --v14;
        }
        while (*result != 47);
        v9 += 3;
      }
      while (result != a3);
    }
    else
    {
      unsigned int v13 = result + 1;
      char v12 = v9;
    }
    strlcpy(v13, v12, a3 - v13 + 1024);
    return (char *)1;
  }
  return result;
}

char *___ZN5dyld46Loader24forEachResolvedAtPathVarERNS_12RuntimeStateEPKcRKNS0_11LoadOptionsENS_13ProcessConfig13PathOverrides4TypeERbU13block_pointerFvS4_SA_SB_E_block_invoke(uint64_t a1, char *__s1, unsigned char *a3)
{
  char v6 = *(const dyld4::RuntimeState **)(a1 + 40);
  if (*(unsigned char *)(*((void *)v6 + 1) + 208))
  {
    unsigned int v7 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(*(void *)(a1 + 48) + 8), v6);
    dyld4::RuntimeState::log(v6, "  LC_RPATH '%s' from '%s'\n", __s1, v7);
    char v6 = *(const dyld4::RuntimeState **)(a1 + 40);
  }
  if (dyld4::Loader::expandAtLoaderPath(v6, __s1, *(void *)(a1 + 56), *(dyld4::Loader **)(*(void *)(a1 + 48) + 8), 1, *(char **)(a1 + 64)))goto LABEL_5; {
  BOOL result = dyld4::Loader::expandAtExecutablePath(*(dyld4::RuntimeState **)(a1 + 40), __s1, v8, 0, *(char **)(a1 + 64));
  }
  if (result) {
    goto LABEL_5;
  }
  if (*__s1 != 47)
  {
LABEL_6:
    if (!*a3) {
      return result;
    }
    goto LABEL_7;
  }
  strlcpy(*(char **)(a1 + 64), __s1, 0x400uLL);
  dyld4::Utils::concatenatePaths(*(dyld4::Utils **)(a1 + 64), *(char **)(a1 + 72), (const char *)0x400);
  BOOL result = (char *)(*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (*a3)
  {
LABEL_7:
    **(unsigned char **)(a1 + 8dyld4::halt((char *)__format, 0) = 1;
    return result;
  }
  int v10 = *(const char **)(*(void *)(*(void *)(a1 + 40) + 8) + 520);
  if (v10)
  {
    strlcpy(*(char **)(a1 + 64), v10, 0x400uLL);
    strlcat(*(char **)(a1 + 64), __s1, 0x400uLL);
LABEL_5:
    dyld4::Utils::concatenatePaths(*(dyld4::Utils **)(a1 + 64), *(char **)(a1 + 72), (const char *)0x400);
    BOOL result = (char *)(*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    goto LABEL_6;
  }
  return result;
}

uint64_t ___ZN5dyld46Loader12validateFileER11DiagnosticsRKNS_12RuntimeStateEiPKcRKNS0_19CodeSignatureInFileERKNS0_18FileValidationInfoE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 40);
  uint64_t v3 = *(void *)(v2 + 32);
  uint64_t v4 = *(void *)(v2 + 40);
  uint64_t v5 = *(unsigned int *)(v2 + 48);
  if (*(void *)a2 == v3 && *(void *)(a2 + 8) == v4 && *(_DWORD *)(a2 + 16) == v5) {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t dyld4::getUuidFromFd(dyld4::SyscallDelegate **this, dyld4::RuntimeState *a2, off_t a3, unsigned __int8 *a4, char *a5)
{
  int v7 = (int)a2;
  *(void *)a4 = 0x64697575206F6ELL;
  uint64_t result = dyld4::SyscallDelegate::pread(this[1], (int)a2, __buf, 0x1CuLL, a3);
  if (result == 28)
  {
    uint64_t result = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)__buf);
    if (result)
    {
      size_t v17 = v23 + 32;
      __chkstk_darwin(result, v10, v11, v12, v13, v14, v15, v16, v21);
      unsigned int v19 = &__buf[-((v18 + 47) & 0x1FFFFFFF0) - 4];
      uint64_t result = dyld4::SyscallDelegate::pread(this[1], v7, v19, v17, a3);
      if (result == v17)
      {
        *(void *)char v24 = 0;
        uint64_t v25 = 0;
        uint64_t result = dyld3::MachOFile::getUuid((dyld3::MachOFile *)v19, v24);
        if (result) {
          return (uint64_t)dyld4::Loader::uuidToStr(v24, a4, v20);
        }
      }
    }
  }
  return result;
}

double __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__2(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

uint64_t ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke(void *a1, unsigned int *a2)
{
  uint64_t v4 = a1[4];
  uint64_t v3 = (vm_address_t *)a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = a1[7];
  uint64_t v7 = *(void *)(v6 + 16);
  long long v10 = *(_OWORD *)v6;
  uint64_t v11 = v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unsigned int v9[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_2;
  void v9[3] = &__block_descriptor_tmp_91_0;
  void v9[4] = a1[8];
  return dyld3::MachOLoaded::fixupAllChainedFixups(v4, v3, a2, v5, &v10, (uint64_t)v9);
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_2(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(dyld4::RuntimeState **)(a1 + 32);
  if (*(unsigned char *)(*((void *)v5 + 1) + 202)) {
    dyld4::RuntimeState::log(v5, "fixup: *0x%012lX = 0x%012lX\n", a2, a3);
  }
  *a2 = a3;
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_3(void *a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(a1[4] + a2);
  uint64_t v3 = a1[5] + *v2;
  uint64_t v4 = (dyld4::RuntimeState *)a1[6];
  if (*(unsigned char *)(*((void *)v4 + 1) + 202)) {
    dyld4::RuntimeState::log(v4, "fixup: *0x%012lX = 0x%012lX <rebase>\n", v2, v3);
  }
  *uint64_t v2 = v3;
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3[2] <= (unint64_t)a3) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v6 = *(const dyld4::Loader **)(a1 + 32);
  uint64_t v7 = (unint64_t *)(*(void *)(a1 + 40) + a2);
  unint64_t v8 = *(void *)(*v3 + 8 * a3);
  unsigned int v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(unsigned char *)(*((void *)v9 + 1) + 202))
  {
    long long v10 = (char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 32), v9);
    uint64_t v11 = strrchr(v10, 47);
    if (v11) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v10;
    }
    dyld4::RuntimeState::log(v9, "fixup: *0x%012lX = 0x%012lX <%s/bind#%u>\n", v7, v8, v12, a3);
    unsigned int v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  }
  unint64_t *v7 = v8;
  if (v8 == *((void *)v9 + 14))
  {
    uint64_t v13 = *(void **)(a1 + 64);
    uint64_t v14 = v13[2];
    if (v14)
    {
      uint64_t v15 = (_DWORD *)(*v13 + 8);
      uint64_t v16 = 16 * v14;
      while (*v15 != a3)
      {
        v15 += 4;
        v16 -= 16;
        if (!v16) {
          return;
        }
      }
      size_t v17 = (const char *)*((void *)v15 - 1);
      dyld4::RuntimeState::addMissingFlatLazySymbol(v9, v6, v17, v7);
    }
  }
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_5(void *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (void *)a1[6];
  if (v3[2] <= (unint64_t)a3) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v6 = (dyld4::Loader *)a1[4];
  uint64_t v7 = (uint64_t *)(a1[5] + a2);
  uint64_t v8 = *(void *)(*v3 + 8 * a3);
  unsigned int v9 = (const dyld4::RuntimeState *)a1[7];
  if (v8 == -1)
  {
    if (*(unsigned char *)(*((void *)v9 + 1) + 202))
    {
      uint64_t v13 = (char *)dyld4::Loader::path(v6, v9);
      uint64_t v14 = strrchr(v13, 47);
      if (v14) {
        uint64_t v15 = v14 + 1;
      }
      else {
        uint64_t v15 = v13;
      }
      dyld4::RuntimeState::log(v9, "fixup: *0x%012lX (skipping missing weak bind) <%s/weak-bind#%u>\n", v7, v15, a3);
    }
  }
  else
  {
    if (*(unsigned char *)(*((void *)v9 + 1) + 202))
    {
      long long v10 = (char *)dyld4::Loader::path(v6, v9);
      uint64_t v11 = strrchr(v10, 47);
      if (v11) {
        uint64_t v12 = v11 + 1;
      }
      else {
        uint64_t v12 = v10;
      }
      dyld4::RuntimeState::log(v9, "fixup: *0x%012lX = 0x%012lX <%s/weak-bind#%u>\n", v7, v8, v12, a3);
    }
    uint64_t *v7 = v8;
  }
}

void ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke_2(void *a1, unsigned int a2)
{
  uint64_t v3 = (dyld4::Loader *)a1[4];
  uint64_t v4 = (const void *)(a1[5] + a2);
  (*(void (**)(void, const void *, void))(**(void **)(a1[6] + 152) + 80))(*(void *)(a1[6] + 152), v4, 0);
  uint64_t v5 = (const dyld4::RuntimeState *)a1[6];
  if (*(unsigned char *)(*((void *)v5 + 1) + 203))
  {
    uint64_t v6 = (const char *)dyld4::Loader::path(v3, v5);
    dyld4::RuntimeState::log(v5, "registering old style destructor %p for %s\n", v4, v6);
  }
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) != *(_DWORD *)a2) {
    ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3_cold_1();
  }
  uint64_t v4 = *(dyld4::Loader **)(a1 + 56);
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  dyld4::Loader::resolveSymbol(v4, *(dyld4::RuntimeState **)(a1 + 64), (vm_address_t *)&v8, *(unsigned int *)(a2 + 4), *(const char **)(a2 + 8), *(unsigned __int8 *)(a2 + 24), *(unsigned __int8 *)(a2 + 25), *(void *)(a1 + 32), (uint64_t)&v5);
  if (Diagnostics::hasError((Diagnostics *)&v8))
  {
    *(void *)&long long v5 = 0;
    *(void *)&long long v6 = 0;
    uint64_t v7 = 1;
  }
  else
  {
    *(void *)&long long v6 = v6 + *(void *)(a2 + 16);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40));
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  mach_o::Error::~Error(&v8);
}

void dyld4::Loader::logSegmentsFromSharedCache(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  uint64_t v4 = (const char *)dyld4::Loader::path(this, a2);
  dyld4::RuntimeState::log(a2, "Using mapping in dyld cache for %s\n", v4);
  uint64_t v5 = *(void *)(*((void *)a2 + 1) + 264);
  unint64_t Address = (_DWORD *)dyld4::Loader::loadAddress(this, a2);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader26logSegmentsFromSharedCacheERNS_12RuntimeStateE_block_invoke;
  void v7[3] = &__block_descriptor_tmp_121;
  v7[4] = a2;
  v7[5] = v5;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v7);
}

void ___ZNK5dyld46Loader26logSegmentsFromSharedCacheERNS_12RuntimeStateE_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 52);
  uint64_t v3 = 120;
  if ((v2 & 4) == 0) {
    uint64_t v3 = 46;
  }
  uint64_t v4 = 119;
  if ((v2 & 2) == 0) {
    uint64_t v4 = 46;
  }
  uint64_t v5 = 114;
  if ((*(_DWORD *)(a2 + 52) & 1) == 0) {
    uint64_t v5 = 46;
  }
  dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 32), "%14s (%c%c%c) 0x%012llX->0x%012llX \n", *(const char **)(a2 + 40), v5, v4, v3, *(void *)(a1 + 40) + *(void *)(a2 + 16), *(void *)(a1 + 40) + *(void *)(a2 + 16) + *(void *)(a2 + 24));
}

void dyld4::Loader::addWeakDefsToMap(dyld4::RuntimeState *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v4 = *(dyld4::Loader ***)a2;
    uint64_t v5 = 8 * v2;
    do
    {
      long long v6 = *v4;
      uint64_t Address = dyld4::Loader::loadAddress(*v4, a1);
      if ((*(unsigned char *)(Address + 25) & 0x80) != 0)
      {
        uint64_t v8 = (dyld3::MachOFile *)Address;
        if ((dyld4::Loader::hiddenFromFlat(v6, 0) & 1) == 0)
        {
          Diagnostics::Diagnostics((Diagnostics *)&v11);
          uint64_t v9 = dyld3::MachOFile::preferredLoadAddress(v8);
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 0x40000000;
          _OWORD v10[2] = ___ZN5dyld46Loader16addWeakDefsToMapERNS_12RuntimeStateERKNSt3__14spanIPKS0_Lm18446744073709551615EEE_block_invoke;
          void v10[3] = &__block_descriptor_tmp_123;
          v10[4] = a1;
          v10[5] = v6;
          void v10[6] = v9;
          dyld3::MachOLoaded::forEachGlobalSymbol(v8, (vm_address_t *)&v11, (uint64_t)v10);
          mach_o::Error::~Error(&v11);
        }
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
}

void *___ZN5dyld46Loader16addWeakDefsToMapERNS_12RuntimeStateERKNSt3__14spanIPKS0_Lm18446744073709551615EEE_block_invoke(void *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v11 = a2;
  if (a6 < 0)
  {
    uint64_t v7 = result;
    uint64_t v8 = dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(*(void *)(result[4] + 336), (uint64_t *)(*(void *)(result[4] + 336) + 16), (void *)(*(void *)(result[4] + 336) + 56), 0, &v11);
    double result = *(void **)(v7[4] + 336);
    if (v8 == (const char **)(result[7] + 24 * result[9]))
    {
      uint64_t v9 = v7[5];
      unint64_t v10 = (a3 - v7[6]) & 0x3FFFFFFFFFFFFFFFLL | 0x8000000000000000;
      uint64_t v13 = 0;
      long long v12 = (unint64_t)v11;
      double result = (void *)dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert((uint64_t)result, &v12);
      result[1] = v9;
      result[2] = v10;
    }
  }
  return result;
}

__n128 __Block_byref_object_copy__124(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  long long v3 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

unint64_t ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke(unint64_t result)
{
  unint64_t v1 = result;
  uint64_t v2 = 0;
  uint64_t v4 = *(dyld4::Loader **)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  v12[0] = v3 + 32;
  v12[1] = v3 + 64;
  while (1)
  {
    uint64_t v5 = v12[v2];
    uint64_t v6 = *(void *)(v5 + 16);
    if (v6) {
      break;
    }
LABEL_11:
    if (++v2 == 2) {
      return result;
    }
  }
  uint64_t v7 = *(dyld4::Loader ***)(v5 + 8);
  uint64_t v8 = 8 * v6;
  uint64_t v9 = v7;
  while (1)
  {
    unint64_t v10 = *v9;
    __n128 result = dyld4::Loader::hiddenFromFlat(*v9, 0);
    if (!result || v4 == v10)
    {
      __n128 result = dyld4::Loader::hasExportedSymbol((uint64_t)v10, *(vm_address_t **)(v1 + 64), *(const dyld4::RuntimeState **)(v1 + 56), *(const unsigned __int8 **)(v1 + 72), 1u, 1, (uint64_t *)(*(void *)(*(void *)(v1 + 32) + 8) + 40), 0);
      if (result) {
        break;
      }
    }
    ++v9;
    ++v7;
    v8 -= 8;
    if (!v8) {
      goto LABEL_11;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(v1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

void dyld4::Loader::tooNewErrorAddendum(dyld4::Loader *this, Diagnostics *a2, dyld4::RuntimeState *a3)
{
  v11[0] = 0;
  v11[1] = v11;
  void v11[2] = 0x2000000000;
  int v12 = 0;
  v9[0] = 0;
  v9[1] = v9;
  unsigned int v9[2] = 0x2000000000;
  int v10 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke;
  void v8[3] = &unk_1EFF648D0;
  void v8[4] = v11;
  void v8[5] = v9;
  dyld3::MachOFile::forEachSupportedPlatform(&dword_1A8DFD000, (uint64_t)v8);
  uint64_t v6 = (_DWORD *)dyld4::Loader::mf(this, a3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke_2;
  void v7[3] = &unk_1EFF648F8;
  v7[4] = v11;
  v7[5] = v9;
  void v7[6] = a2;
  dyld3::MachOFile::forEachSupportedPlatform(v6, (uint64_t)v7);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v11, 8);
}

uint64_t ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  return result;
}

uint64_t ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke_2(uint64_t result, int a2, dyld3::MachOFile *this)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) == a2)
  {
    uint64_t v3 = result;
    if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) < this)
    {
      dyld3::MachOFile::packedVersionToString(this, v6, (char *)this);
      uint64_t v4 = *(vm_address_t **)(v3 + 48);
      uint64_t v5 = dyld3::MachOFile::platformName(*(_DWORD *)(*(void *)(*(void *)(v3 + 32) + 8) + 24));
      return Diagnostics::error(v4, " (built for %s %s which is newer than running OS)", v5, v6);
    }
  }
  return result;
}

uint64_t ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (dyld3::MachOFile ***)mach_o::SymbolTable::SymbolTable(&v12, a2);
  uint64_t v5 = *(void *)(a1 + 48);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke_2;
  void v8[3] = &unk_1EFF64920;
  long long v9 = *(_OWORD *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 72);
  uint64_t v11 = v6;
  void v8[4] = *(void *)(a1 + 32);
  void v8[5] = v3;
  return mach_o::SymbolTable::forEachGlobalSymbol(v4, v5, (uint64_t)v8);
}

dyld4::RuntimeState *___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke_2(dyld4::RuntimeState *result, char *__s1, uint64_t a3, int a4, uint64_t a5, char a6, unsigned char *a7)
{
  if ((~a4 & 0xF) == 0)
  {
    uint64_t v10 = (uint64_t)result;
    uint64_t v11 = *((void *)result + 5);
    __n128 result = (dyld4::RuntimeState *)_platform_strcmp(__s1, *((const char **)result + 6));
    if (!result)
    {
      uint64_t v12 = *(dyld3::MachOFile **)(v10 + 64);
      **(void **)(v10 + 56) = v11;
      *(void *)(*(void *)(v10 + 56) + 8) = *(void *)(v10 + 48);
      uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v12);
      uint64_t v14 = *(void *)(v10 + 56);
      *(void *)(v14 + 16) = a3 - Address;
      *(_DWORD *)(v14 + 32) = 1;
      *(unsigned char *)(v14 + 36) = 0;
      *(unsigned char *)(v14 + 37) = a6 < 0;
      *(_WORD *)(v14 + 38) = 0;
      uint64_t v15 = dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(v10 + 72), v14);
      *(void *)(*(void *)(v10 + 56) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v15;
      __n128 result = dyld4::Loader::interpose(*(dyld4::Loader **)(v10 + 72), v15, 0, v16);
      *(void *)(*(void *)(v10 + 56) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
      *a7 = 1;
      *(unsigned char *)(*(void *)(*(void *)(v10 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

void dyld4::Loader::applyInterposingToDyldCache(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  uint64_t v2 = *(DyldSharedCache **)(*((void *)this + 1) + 240);
  if (v2 && *((void *)this + 22))
  {
    dyld4::DyldCacheDataConstScopedWriter::DyldCacheDataConstScopedWriter((dyld4::DyldCacheDataConstScopedWriter *)v18, this);
    dyld4::RuntimeState::setVMAccountingSuspending(this, 1);
    uint64_t v4 = *((void *)this + 22);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 21);
      uint64_t v6 = 16 * v4;
      do
      {
        unsigned int v17 = 0;
        uint64_t v7 = *(void *)(v5 + 8) - (void)v2;
        if (DyldSharedCache::addressInText(v2, v7, &v17))
        {
          unint64_t v15 = 0;
          unint64_t v16 = 0;
          uint64_t IndexedImageEntry = DyldSharedCache::getIndexedImageEntry(v2, v17, &v16, &v15);
          if (IndexedImageEntry)
          {
            long long v9 = (dyld3::MachOFile *)IndexedImageEntry;
            int v10 = DyldSharedCache::unslidLoadAddress(v2) + v7;
            int Address = dyld3::MachOFile::preferredLoadAddress(v9);
            v12[0] = _NSConcreteStackBlock;
            v12[1] = 0x40000000;
            void v12[2] = ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke;
            void v12[3] = &__block_descriptor_tmp_155;
            _OWORD v12[4] = v5;
            v12[5] = v2;
            int v13 = v10 - Address;
            unsigned int v14 = v17;
            void v12[6] = this;
            DyldSharedCache::forEachPatchableExport(v2, v17, (uint64_t)v12);
          }
        }
        v5 += 16;
        v6 -= 16;
      }
      while (v6);
    }
    dyld4::RuntimeState::setVMAccountingSuspending(this, 0);
    dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)v18);
  }
}

dyld3::MachOFile *___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke(dyld3::MachOFile *result, unsigned int a2, uint64_t a3)
{
  if (*((_DWORD *)result + 14) == a2)
  {
    uint64_t v4 = (dyld3::MachOFile *)*((void *)result + 5);
    uint64_t v5 = **((void **)result + 4);
    unsigned int v6 = *((_DWORD *)result + 15);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke_2;
    void v7[3] = &__block_descriptor_tmp_153;
    v7[4] = v4;
    v7[5] = v5;
    void v7[6] = *((void *)result + 6);
    void v7[7] = a3;
    return DyldSharedCache::forEachPatchableUseOfExport(v4, v6, a2, (uint64_t)v7);
  }
  return result;
}

void ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke_2(uint64_t a1, uint64_t a2, BOOL a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (uint64_t *)(v6 + a2);
  uint64_t v8 = *(void *)(a1 + 40) + a4;
  if ((a3 & 0x1000000) != 0)
  {
    uint64_t v10 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(v8, v6 + a2, (void *)((a3 >> 27) & 1), a3, (a3 >> 25) & 3);
    uint64_t *v7 = v10;
    uint64_t v11 = *(dyld4::RuntimeState **)(a1 + 48);
    if (*(unsigned char *)(*((void *)v11 + 1) + 206))
    {
      uint64_t v12 = (const void *)v10;
      int v13 = mach_o::ChainedFixupPointerOnDisk::Arm64e::keyName((mach_o::ChainedFixupPointerOnDisk::Arm64e *)((a3 >> 25) & 3));
      dyld4::RuntimeState::log(v11, "interpose: *%p = %p (JOP: diversity 0x%04X, addr-div=%d, key=%s)\n", v7, v12, a3, (a3 >> 27) & 1, v13);
    }
  }
  else
  {
    long long v9 = *(dyld4::RuntimeState **)(a1 + 48);
    if (*(unsigned char *)(*((void *)v9 + 1) + 206)) {
      dyld4::RuntimeState::log(v9, "interpose: *%p = 0x%0llX (dyld cache patch) to %s\n", v7, v8, *(const char **)(a1 + 56));
    }
    uint64_t *v7 = v8;
  }
}

void dyld4::Loader::applyCachePatchesToOverride(uint64_t a1, const dyld4::RuntimeState *a2, dyld4::Loader *this, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(DyldSharedCache **)(*((void *)a2 + 1) + 240);
  uint64_t Address = dyld4::Loader::loadAddress(this, a2);
  int v14 = *((_WORD *)this + 3) & 0x7FFF;
  if (DyldSharedCache::shouldPatchClientOfImage(v12, a4, v14))
  {
    if (DyldSharedCache::patchInfoVersion(v12) - 2 >= 3) {
      dyld4::Loader::applyCachePatchesToOverride();
    }
    uint64_t v22 = 0;
    unsigned int v23 = &v22;
    uint64_t v24 = 0x2000000000;
    char v25 = 0;
    uint64_t v18 = 0;
    unsigned int v19 = &v18;
    uint64_t v20 = 0x2000000000;
    uint64_t v21 = a5;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    void v15[2] = ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
    v15[3] = &unk_1EFF649D8;
    v15[6] = a1;
    void v15[7] = a2;
    __int16 v17 = a4;
    int v16 = v14;
    v15[8] = v12;
    v15[9] = a6;
    v15[4] = &v18;
    void v15[5] = &v22;
    v15[10] = Address;
    v15[11] = this;
    DyldSharedCache::forEachPatchableExport(v12, a4, (uint64_t)v15);
    if (*(void *)v19[3] != -1) {
      dyld4::Loader::applyCachePatchesToOverride();
    }
    if (*((unsigned char *)v23 + 24)) {
      dyld4::RuntimeState::setVMAccountingSuspending(a2, 0);
    }
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }
}

void ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v7 = *(dyld4::Loader **)(a1 + 48);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  long long v9 = *(uint64_t **)(v8 + 24);
  *(void *)(v8 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9 + 1;
  if (a4 != 8)
  {
    if (a4 != 1)
    {
      if (*v9) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    uint64_t v10 = *v9;
    if (*v9 == 2) {
      return;
    }
LABEL_4:
    if (v10)
    {
LABEL_5:
      uint64_t v11 = *v9 + dyld4::Loader::loadAddress(v7, *(const dyld4::RuntimeState **)(a1 + 56));
LABEL_10:
      unsigned int v12 = *(unsigned __int16 *)(a1 + 100);
      int v13 = *(_DWORD *)(a1 + 96);
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000;
      void v17[2] = ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v17[3] = &unk_1EFF649B0;
      v17[4] = *(void *)(a1 + 40);
      _WORD v17[5] = v7;
      uint64_t v15 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 64);
      uint64_t v16 = *(void *)(a1 + 80);
      void v17[6] = *(void *)(a1 + 72);
      v17[7] = v15;
      unsigned char v17[8] = v16;
      void v17[9] = v11;
      __int16 v18 = v12;
      v17[10] = v14;
      v17[11] = a3;
      v17[12] = *(void *)(a1 + 88);
      v17[13] = v9;
      DyldSharedCache::forEachPatchableUseOfExportInImage(v14, v12, a2, v13, (uint64_t)v17);
      return;
    }
LABEL_9:
    uint64_t v11 = 195903495;
    goto LABEL_10;
  }
  uint64_t v10 = *v9;
  if (*v9 != 1) {
    goto LABEL_4;
  }
}

void ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2(uint64_t a1, unsigned int a2, BOOL a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t v10 = *(dyld4::Loader **)(a1 + 40);
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(unsigned char **)(a1 + 48));
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    dyld4::RuntimeState::setVMAccountingSuspending(*(dyld4::RuntimeState **)(a1 + 56), 1);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  uint64_t v11 = *(void *)(a1 + 72);
  if ((a5 & (v11 == 195903495)) != 0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v11 + a4;
  }
  uint64_t v13 = *(void *)(a1 + 56);
  uint64_t v14 = *(void *)(v13 + 176);
  if (v14)
  {
    uint64_t v15 = *(void *)(v13 + 168);
    uint64_t v16 = 16 * v14;
    __int16 v17 = (void *)(v15 + 8);
    do
    {
      if (*v17 == v12) {
        uint64_t v12 = *(v17 - 1);
      }
      v17 += 2;
      v16 -= 16;
    }
    while (v16);
  }
  __int16 v18 = (uint64_t *)(*(void *)(a1 + 64) + a2);
  if ((a5 & 1) == 0 && v11 == 195903495)
  {
    IndexedImageuint64_t Path = (const char *)DyldSharedCache::getIndexedImagePath(*(DyldSharedCache **)(a1 + 80), *(unsigned __int16 *)(a1 + 112));
    uint64_t v20 = *(const dyld4::RuntimeState **)(a1 + 56);
    uint64_t v21 = *(const char **)(a1 + 88);
    uint64_t v22 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), v20);
    dyld4::RuntimeState::log(v20, "symbol '%s' missing from root that overrides %s. Use of that symbol in %s is being set to 0xBAD4007.\n", v21, IndexedImagePath, v22);
  }
  if ((a3 & 0x1000000) != 0 && v12)
  {
    unsigned int v23 = (mach_o::ChainedFixupPointerOnDisk::Arm64e *)((a3 >> 25) & 3);
    uint64_t v24 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(v12, (unint64_t)v18, (void *)((a3 >> 27) & 1), a3, (a3 >> 25) & 3);
    if (*v18 != v24)
    {
      uint64_t v25 = v24;
      uint64_t *v18 = v24;
      char v26 = *(dyld4::RuntimeState **)(a1 + 56);
      if (*(unsigned char *)(*((void *)v26 + 1) + 202))
      {
        unsigned int v27 = (char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), *(const dyld4::RuntimeState **)(a1 + 56));
        strrchr(v27, 47);
        char v28 = (char *)dyld4::Loader::path(v10, *(const dyld4::RuntimeState **)(a1 + 56));
        strrchr(v28, 47);
        mach_o::ChainedFixupPointerOnDisk::Arm64e::keyName(v23);
        dyld4::RuntimeState::log(v26, "cache fixup: *0x%012lX = 0x%012lX (*%s+0x%012lX = %s+0x%012lX) (JOP: diversity=0x%04X, addr-div=%d, key=%s)\n", v18, v25);
      }
    }
  }
  else if (*v18 != v12)
  {
    uint64_t *v18 = v12;
    unsigned int v29 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(unsigned char *)(*((void *)v29 + 1) + 202))
    {
      char v30 = (char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), *(const dyld4::RuntimeState **)(a1 + 56));
      strrchr(v30, 47);
      unsigned int v31 = (char *)dyld4::Loader::path(v10, *(const dyld4::RuntimeState **)(a1 + 56));
      strrchr(v31, 47);
      dyld4::RuntimeState::log(v29, "cache fixup: *0x%012lX = 0x%012lX (*%s+0x%012lX = %s+0x%012lX)\n");
    }
  }
}

void dyld4::Loader::applyCachePatchesTo(dyld4::Loader *this, dyld4::RuntimeState *a2, const dyld4::Loader *a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4)
{
  LOWORD(v12) = 0;
  uint64_t v11 = 0;
  if (dyld4::Loader::overridesDylibInCache((uint64_t)this, &v11, &v12))
  {
    if (v11) {
      dyld4::Loader::applyCachePatchesToOverride((uint64_t)this, a2, a3, (unsigned __int16)v12, v11, (uint64_t)a4);
    }
    if ((*((_WORD *)this + 2) & 1) == 0)
    {
      if (*(unsigned char *)(*((void *)a2 + 1) + 157))
      {
        uint64_t CatalystMacTwinPatches = dyld4::JustInTimeLoader::getCatalystMacTwinPatches(this);
        if (CatalystMacTwinPatches)
        {
          uint64_t v9 = CatalystMacTwinPatches;
          unsigned int v10 = dyld4::Loader::indexOfUnzipperedTwin(a2, (const dyld4::RuntimeState *)(unsigned __int16)v12);
          if (v10 != 0xFFFF) {
            dyld4::Loader::applyCachePatchesToOverride((uint64_t)this, a2, a3, v10, v9, (uint64_t)a4);
          }
        }
      }
    }
  }
}

uint64_t dyld4::Loader::indexOfUnzipperedTwin(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (!*(unsigned char *)(v2 + 157)) {
    return (unsigned __int16)-1;
  }
  uint64_t v4 = *((void *)this + 121);
  if (!v4)
  {
    IndexedImageuint64_t Path = (const char *)dyld4::ProcessConfig::DyldCache::getIndexedImagePath((DyldSharedCache **)(v2 + 240), (int)a2);
    if (!_platform_strncmp(IndexedImagePath, "/System/iOSSupport/", 0x13uLL))
    {
      unsigned int v9 = 0;
      if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*((void *)this + 1) + 240), IndexedImagePath + 18, &v9))return (unsigned __int16)v9; {
    }
      }
    return (unsigned __int16)-1;
  }
  if (*(_DWORD *)(v4 + 12) <= a2) {
    dyld4::RuntimeState::findPrebuiltLoader();
  }
  uint64_t v5 = (_WORD *)(v4 + *(unsigned int *)(v4 + *(unsigned int *)(v4 + 16) + 4 * a2));
  if ((v5[2] & 1) == 0 || (v5[22] & 4) == 0) {
    return (unsigned __int16)-1;
  }
  return (unsigned __int16)v5[30];
}

uint64_t ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke(uint64_t result, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v5 = result;
  uint64_t v6 = *(dyld4::Loader **)(result + 48);
  uint64_t v7 = *(void *)(*(void *)(result + 32) + 8);
  uint64_t v8 = *(uint64_t **)(v7 + 24);
  *(void *)(v7 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8 + 1;
  if (a4 != 8)
  {
    if (a4 != 1)
    {
      if (*v8) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    uint64_t v9 = *v8;
    if (*v8 == 2) {
      return result;
    }
LABEL_4:
    if (v9)
    {
LABEL_5:
      uint64_t v10 = *v8 + dyld4::Loader::loadAddress(v6, *(const dyld4::RuntimeState **)(result + 56));
LABEL_10:
      unsigned int v11 = *(unsigned __int16 *)(v5 + 80);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 0x40000000;
      void v15[2] = ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v15[3] = &unk_1EFF64A00;
      uint64_t v12 = *(void *)(v5 + 64);
      uint64_t v13 = *(void *)(v5 + 72);
      v15[4] = *(void *)(v5 + 40);
      void v15[5] = v6;
      uint64_t v14 = *(void *)(v5 + 56);
      v15[6] = v13;
      void v15[7] = v14;
      v15[8] = v12;
      v15[9] = v10;
      v15[10] = v8;
      return DyldSharedCache::forEachPatchableGOTUseOfExport(v12, v11, a2, (uint64_t)v15);
    }
LABEL_9:
    uint64_t v10 = 195903495;
    goto LABEL_10;
  }
  uint64_t v9 = *v8;
  if (*v8 != 1) {
    goto LABEL_4;
  }
  return result;
}

void ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2(uint64_t a1, uint64_t a2, BOOL a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t v10 = *(dyld4::Loader **)(a1 + 40);
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(unsigned char **)(a1 + 48));
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    dyld4::RuntimeState::setVMAccountingSuspending(*(dyld4::RuntimeState **)(a1 + 56), 1);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  uint64_t v11 = *(void *)(a1 + 72);
  uint64_t v12 = (uint64_t *)(*(void *)(a1 + 64) + a2);
  if ((a5 & (v11 == 195903495)) != 0) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = v11 + a4;
  }
  if ((a3 & 0x1000000) != 0 && v13)
  {
    uint64_t v14 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(v13, *(void *)(a1 + 64) + a2, (void *)((a3 >> 27) & 1), a3, (a3 >> 25) & 3);
    if (*v12 != v14)
    {
      uint64_t v15 = v14;
      *uint64_t v12 = v14;
      uint64_t v16 = *(dyld4::RuntimeState **)(a1 + 56);
      if (*(unsigned char *)(*((void *)v16 + 1) + 202))
      {
        __int16 v17 = (char *)dyld4::Loader::path(v10, *(const dyld4::RuntimeState **)(a1 + 56));
        strrchr(v17, 47);
        mach_o::ChainedFixupPointerOnDisk::Arm64e::keyName((mach_o::ChainedFixupPointerOnDisk::Arm64e *)((a3 >> 25) & 3));
        dyld4::RuntimeState::log(v16, "cache GOT fixup: *0x%012lX = 0x%012lX (*cache+0x%012lX = %s+0x%012lX) (JOP: diversity=0x%04X, addr-div=%d, key=%s)\n", v12, v15);
      }
    }
  }
  else if (*v12 != v13)
  {
    *uint64_t v12 = v13;
    __int16 v18 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(unsigned char *)(*((void *)v18 + 1) + 202))
    {
      unsigned int v19 = (char *)dyld4::Loader::path(v10, *(const dyld4::RuntimeState **)(a1 + 56));
      strrchr(v19, 47);
      dyld4::RuntimeState::log(v18, "cache GOT fixup: *0x%012lX = 0x%012lX (*cache+0x%012lX = %s+0x%012lX)\n");
    }
  }
}

uint64_t __Block_byref_object_copy__169(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__170(uint64_t a1)
{
}

uint64_t ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke_2(uint64_t a1, int a2, int a3, char *__s2, uint64_t a5, unsigned char *a6)
{
  uint64_t result = _platform_memcmp(*(const void **)(a1 + 40), __s2, 0x40uLL);
  if (!result)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = &__s2[-*(void *)(a1 + 48)];
    *a6 = 1;
  }
  return result;
}

void dyld4::Loader::recursivelyLogChainToLinksWith(dyld4::Loader *a1, dyld4::RuntimeState *a2, const char *a3, dyld4::Loader *a4, uint64_t *a5, void *a6, uint64_t *a7)
{
  if (a1 == a4)
  {
    dyld4::RuntimeState::printLinkageChain(a2, a5, a3);
  }
  else
  {
    uint64_t v14 = a7[2];
    if (v14)
    {
      uint64_t v15 = (dyld4::Loader **)*a7;
      uint64_t v16 = 8 * v14;
      while (*v15 != a1)
      {
        ++v15;
        v16 -= 8;
        if (!v16) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      v21[0] = (uint64_t)a1;
      dyld3::Array<dyld4::Loader const*>::push_back(a7, v21);
      int v17 = dyld4::Loader::dependentCount(a1);
      if (v17)
      {
        int v18 = v17;
        for (unsigned int i = 0; i != v18; ++i)
        {
          char v23 = 0;
          uint64_t v20 = dyld4::Loader::dependent(a1, a2, i, &v23);
          if (v20)
          {
            v21[0] = 0;
            v21[1] = v20;
            char v22 = v23;
            *a6 = v21;
            dyld4::Loader::recursivelyLogChainToLinksWith(v20, a2, a3, a4, a5, v21, a7);
          }
        }
      }
    }
  }
}

void dyld4::Loader::logChainToLinksWith(dyld4::Loader *this, dyld4::RuntimeState *a2, const char *a3)
{
  uint64_t v6 = *((void *)a2 + 6);
  if (v6)
  {
    uint64_t v7 = (dyld4::Loader **)*((void *)a2 + 5);
    uint64_t v8 = 8 * v6;
    uint64_t v9 = v7;
    while (1)
    {
      uint64_t v10 = *v9;
      uint64_t v11 = *((void *)a2 + 1);
      uint64_t v13 = *(const void **)(v11 + 224);
      size_t v12 = *(void *)(v11 + 232);
      uint64_t v14 = (char *)dyld4::Loader::path(*v9, a2);
      uint64_t v15 = strrchr(v14, 47);
      if (v15) {
        uint64_t v14 = v15 + 1;
      }
      if (v12 == _platform_strlen(v14))
      {
        uint64_t v16 = _platform_memcmp(v13, v14, v12);
        if (!v16) {
          break;
        }
      }
      ++v9;
      ++v7;
      v8 -= 8;
      if (!v8) {
        goto LABEL_8;
      }
    }
    if (v10) {
      goto LABEL_19;
    }
  }
LABEL_8:
  uint64_t v24 = *((void *)a2 + 10);
  if (v24)
  {
    uint64_t v25 = (dyld4::Loader **)*((void *)a2 + 9);
    uint64_t v26 = 8 * v24;
    unsigned int v27 = v25;
    while (1)
    {
      uint64_t v10 = *v27;
      uint64_t v28 = *((void *)a2 + 1);
      char v30 = *(const void **)(v28 + 224);
      size_t v29 = *(void *)(v28 + 232);
      unsigned int v31 = (char *)dyld4::Loader::path(*v27, a2);
      char v32 = strrchr(v31, 47);
      if (v32) {
        unsigned int v31 = v32 + 1;
      }
      if (v29 == _platform_strlen(v31))
      {
        uint64_t v16 = _platform_memcmp(v30, v31, v29);
        if (!v16) {
          break;
        }
      }
      ++v27;
      ++v25;
      v26 -= 8;
      if (!v26) {
        return;
      }
    }
    if (v10)
    {
LABEL_19:
      __chkstk_darwin(v16, v17, v18, v19, v20, v21, v22, v23, v35);
      uint64_t v33 = *((void *)a2 + 10) + *((void *)a2 + 6);
      v38[0] = (uint64_t)&v36[-1] - v34;
      v38[1] = v33;
      void v38[2] = 0;
      v36[0] = 0;
      v36[1] = (uint64_t)this;
      char v37 = mach_o::LinkedDylibAttributes::regular;
      dyld4::Loader::recursivelyLogChainToLinksWith(this, a2, a3, v10, v36, v36, v38);
    }
  }
}

uint64_t dyld4::fixupPage64(uint64_t this, _DWORD *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, int a5)
{
  uint64_t v5 = *((unsigned __int16 *)&a3->mwli_chains_size + a4 + 1);
  if (v5 != 0xFFFF)
  {
    uint64_t v6 = (char *)a2 + a2[2];
    uint64_t v7 = (uint64_t *)(this + v5);
    uint64_t v8 = 6;
    if (a5) {
      uint64_t v8 = 8;
    }
    uint64_t v9 = *(void *)&a2[v8];
    do
    {
      unint64_t v10 = *v7;
      if (*v7 < 0)
      {
        unsigned int v12 = a2[3];
        if ((v10 & 0xFFFFFF) >= v12) {
          return fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v10 & 0xFFFFFF, v12);
        }
        uint64_t v11 = *(void *)&v6[8 * (v10 & 0xFFFFFF)] + BYTE3(v10);
      }
      else
      {
        uint64_t v11 = (v10 & 0xFFFFFFFFFLL) + v9 + (v10 >> 36 << 56);
      }
      uint64_t v13 = (v10 >> 51) & 0xFFF;
      uint64_t *v7 = v11;
      uint64_t v7 = (uint64_t *)((char *)v7 + 4 * v13);
    }
    while (v13);
  }
  return this;
}

_DWORD *dyld4::fixupChain32(_DWORD *this, unsigned int *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, const unsigned int *a5)
{
  while (1)
  {
    unint64_t v5 = *this;
    if ((v5 & 0x80000000) != 0) {
      break;
    }
    int v6 = v5 & 0x3FFFFFF;
    uint32_t mwli_chains_offset = a3->mwli_chains_offset;
    if ((v5 & 0x3FFFFFF) <= mwli_chains_offset)
    {
      unsigned int v10 = a2[6];
      goto LABEL_7;
    }
    int v8 = v6 - ((mwli_chains_offset + 0x4000000) >> 1);
LABEL_8:
    uint64_t v11 = (v5 >> 26) & 0x1F;
    *this = v8;
    this += v11;
    if (!v11) {
      return this;
    }
  }
  unsigned int v9 = a2[3];
  if ((v5 & 0xFFFFF) < v9)
  {
    unsigned int v10 = (v5 >> 20) & 0x3F;
    int v6 = *(&a4->size + (v5 & 0xFFFFF));
LABEL_7:
    int v8 = v6 + v10;
    goto LABEL_8;
  }
  return (_DWORD *)fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v5 & 0xFFFFF, v9);
}

const char **dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return (const char **)*a3;
  }
  int v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v23, (uint64_t *)v8, v9);
  unint64_t v11 = a2[2];
  unint64_t v12 = v11 - 1;
  unint64_t v13 = v10 & (v11 - 1);
  if (v11 <= v13) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v14 = *a2;
  unint64_t v15 = a3[2];
  uint64_t v16 = *a3;
  uint64_t v17 = 1;
  uint64_t v18 = *a5;
  while (1)
  {
    unint64_t v19 = *(unsigned int *)(v14 + 4 * v13);
    if (v19 == -1) {
      return (const char **)(v16 + 24 * v15);
    }
    if (v15 <= v19) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    uint64_t v20 = (const char **)(v16 + 24 * v19);
    if (!_platform_strcmp(*v20, v18)) {
      return v20;
    }
    unint64_t v21 = v13 + v17++;
    unint64_t v13 = v21 & v12;
    if (v11 <= (v21 & v12)) {
      goto LABEL_8;
    }
  }
}

uint64_t dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0;
    memset(v28, 0, sizeof(v28));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v28, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v28, 1);
      uint64_t v6 = (*(void *)&v28[1])++;
      *(_DWORD *)(*(void *)&v28[0] + 4 * v6) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0;
      do
      {
        int v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v7);
        size_t v9 = _platform_strlen(v8);
        unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v30, (uint64_t *)v8, v9);
        unint64_t v11 = (*(void *)&v28[1] - 1) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) != -1)
        {
          uint64_t v12 = 1;
          do
            unint64_t v11 = (*(void *)&v28[1] - 1) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) = v7++;
      }
      while (v7 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v28)
    {
      *(void *)&v28[1] = 0;
      if (*((void *)&v28[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v28[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v13 = *(void *)(a1 + 40);
      if (v13) {
        vm_deallocate(mach_task_self_, v13, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v28[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v28 + 8);
      vm_size_t v14 = size;
      *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *((void *)&v28[1] + 1);
      *(void *)(a1 + 48) = v14;
    }
  }
  unint64_t v15 = *(char **)a2;
  size_t v16 = _platform_strlen(*(const char **)a2);
  unint64_t v17 = (*(void *)(a1 + 32) - 1) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v28, (uint64_t *)v15, v16);
  unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
  if (v18 == -1)
  {
LABEL_20:
    uint64_t v21 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17) = v21;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v23 + 1;
    uint64_t v24 = v22 + 24 * v23;
    long long v25 = *a2;
    *(void *)(v24 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v24 = v25;
    uint64_t v26 = *(void *)(a1 + 72);
    if (!v26) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 24 * v26 - 24;
  }
  else
  {
    uint64_t v19 = 1;
    while (1)
    {
      uint64_t v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v18);
      if (!_platform_strcmp(*v20, *(const char **)a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v18);
      }
      unint64_t v17 = (*(void *)(a1 + 32) - 1) & (v17 + v19++);
      unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
      if (v18 == -1) {
        goto LABEL_20;
      }
    }
  }
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 24 * a2;
}

uint64_t dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 4 * a2;
}

mach_o::Error *mach_o::Error::Error(mach_o::Error *this, char *__s, ...)
{
  va_start(va, __s);
  *(void *)this = 0;
  vm_address_t v4 = _simple_salloc();
  *(void *)this = v4;
  _simple_vsprintf(v4, __s, (int *)va);
  return this;
}

void *dyld4::JustInTimeLoader::makePatchTable(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2, unsigned int a3)
{
  uint64_t v3 = *((void *)a2 + 1);
  if (!*(void *)(v3 + 368)) {
    dyld4::JustInTimeLoader::makePatchTable();
  }
  unint64_t v7 = (void *)(v3 + 368);
  int v8 = PatchTable::patchableExportCount((int **)(v3 + 368), a3);
  if (!v8) {
    return 0;
  }
  size_t v9 = lsl::Allocator::malloc(*((lsl::Lock ***)a2 + 2), 8 * (v8 + 1));
  uint64_t v50 = 0;
  unsigned int v51 = &v50;
  uint64_t v52 = 0x2000000000;
  int v53 = 0;
  uint64_t v37 = *((void *)this + 4);
  uint64_t IndexedImageEntry = DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(*((void *)a2 + 1) + 240), a3);
  uint64_t v39 = 0;
  char v40 = &v39;
  uint64_t v41 = 0x8802000000;
  char v42 = __Block_byref_object_copy__3;
  unsigned int v43 = __Block_byref_object_dispose__3;
  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v44);
  IndexedImageuint64_t Path = (char *)DyldSharedCache::getIndexedImagePath(*(DyldSharedCache **)(*((void *)a2 + 1) + 240), a3);
  if (IndexedImagePath)
  {
    uint64_t v12 = IndexedImagePath;
    if (!strstr(IndexedImagePath, "libdispatch.dylib") && !strstr(v12, "libxpc.dylib"))
    {
      if (_platform_strcmp(v12, "/usr/lib/libodmodule.dylib"))
      {
        if (_platform_strcmp(v12, "/usr/lib/log/liblog_odtypes.dylib"))
        {
          size_t v16 = (vm_address_t *)*((void *)this + 4);
          unint64_t v17 = v40;
          if (dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)v16))
          {
            Diagnostics::Diagnostics((Diagnostics *)&v72);
            char v62 = 0;
            uint64_t v63 = (uint64_t)&v62;
            uint64_t v64 = 0x5002000000;
            unsigned int v65 = __Block_byref_object_copy__24;
            char v66 = (dyld3::MachOFile *)__Block_byref_object_dispose__25;
            uint64_t v67 = &v73;
            uint64_t v68 = 32;
            uint64_t v69 = 0;
            vm_address_t v70 = 0;
            vm_size_t v71 = 0;
            v60[0] = (vm_address_t *)_NSConcreteStackBlock;
            v60[1] = (vm_address_t *)1174405120;
            v60[2] = (vm_address_t *)___ZN5dyld4L19getObjCPatchClassesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke;
            v60[3] = (vm_address_t *)&unk_1EFF61E48;
            v61[0] = v72;
            v61[1] = v16;
            _OWORD v60[4] = (vm_address_t *)&v62;
            dyld3::MachOAnalyzer::forEachBindTarget((dyld3::MachOFile *)v16, (vm_address_t *)&v72, 0, (uint64_t)v60, (uint64_t)&__block_literal_global_0);
            if (!Diagnostics::hasError((Diagnostics *)&v72))
            {
              unint64_t v58 = 0;
              unint64_t v59 = 0;
              if (dyld3::MachOFile::findObjCDataSection((dyld3::MachOFile *)v16, "__objc_classlist", &v59, &v58))
              {
                unint64_t v18 = v17;
                unsigned int v19 = dyld3::MachOFile::pointerSize((dyld3::MachOFile *)v16);
                unint64_t v20 = v19;
                if (v58 % v19)
                {
                  Diagnostics::error((vm_address_t *)&v72, "Invalid objc class section size");
                }
                else
                {
                  unint64_t v31 = v58;
                  unint64_t v32 = v58 / v19;
                  uint64_t v35 = (uint64_t)(v18 + 5);
                  int v36 = dyld3::MachOAnalyzer::chainedPointerFormat((dyld3::MachOAnalyzer *)v16);
                  uint64_t v21 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v16 + v59);
                  if (v20 == 8)
                  {
                    BOOL v22 = v31 >= v20;
                    unint64_t v23 = v32;
                    if (v22)
                    {
                      do
                      {
                        unsigned int v57 = 0;
                        uint64_t v56 = 0;
                        if (mach_o::ChainedFixupPointerOnDisk::isBind(v21, v36, &v57, (unint64_t *)&v56))
                        {
                          if (*(void *)(v63 + 56) > (unint64_t)v57)
                          {
                            uint64_t v24 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(v63 + 40), v57);
                            long long v25 = *v24;
                            if (*v24)
                            {
                              char v54 = *v24;
                              char v55 = 1;
                              uint64_t v33 = v25;
                              dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v35, &v54);
                              unsigned int v57 = 0;
                              uint64_t v56 = 0;
                              if (mach_o::ChainedFixupPointerOnDisk::isBind(v33, v36, &v57, (unint64_t *)&v56))
                              {
                                if (*(void *)(v63 + 56) > (unint64_t)v57)
                                {
                                  uint64_t v26 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(v63 + 40), v57);
                                  if (*v26)
                                  {
                                    char v54 = *v26;
                                    char v55 = 1;
                                    dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v35, &v54);
                                  }
                                }
                              }
                            }
                          }
                        }
                        uint64_t v21 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v21 + 8);
                        --v23;
                      }
                      while (v23);
                    }
                  }
                  else
                  {
                    BOOL v22 = v31 >= v20;
                    unint64_t v27 = v32;
                    if (v22)
                    {
                      do
                      {
                        unsigned int v57 = 0;
                        uint64_t v56 = 0;
                        if (mach_o::ChainedFixupPointerOnDisk::isBind(v21, v36, &v57, (unint64_t *)&v56))
                        {
                          if (*(void *)(v63 + 56) > (unint64_t)v57)
                          {
                            uint64_t v28 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(v63 + 40), v57);
                            size_t v29 = *v28;
                            if (*v28)
                            {
                              char v54 = *v28;
                              char v55 = 1;
                              uint64_t v34 = v29;
                              dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v35, &v54);
                              unsigned int v57 = 0;
                              uint64_t v56 = 0;
                              if (mach_o::ChainedFixupPointerOnDisk::isBind(v34, v36, &v57, (unint64_t *)&v56))
                              {
                                if (*(void *)(v63 + 56) > (unint64_t)v57)
                                {
                                  char v30 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(v63 + 40), v57);
                                  if (*v30)
                                  {
                                    char v54 = *v30;
                                    char v55 = 1;
                                    dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v35, &v54);
                                  }
                                }
                              }
                            }
                          }
                        }
                        uint64_t v21 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v21 + 4);
                        --v27;
                      }
                      while (v27);
                    }
                  }
                }
              }
            }
            mach_o::Error::~Error(v61);
            _Block_object_dispose(&v62, 8);
            uint64_t v69 = 0;
            if (v70) {
              vm_deallocate(mach_task_self_, v70, v71);
            }
            mach_o::Error::~Error(&v72);
          }
        }
      }
    }
  }
  uint64_t v73 = 0;
  pid_t v74 = &v73;
  uint64_t v75 = 0x8802000000;
  uint64_t v76 = __Block_byref_object_copy__3;
  uint64_t v77 = __Block_byref_object_dispose__3;
  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v78);
  vm_address_t v13 = (dyld3::MachOFile *)*((void *)this + 4);
  vm_size_t v14 = v74 + 5;
  Diagnostics::Diagnostics((Diagnostics *)v60);
  char v62 = _NSConcreteStackBlock;
  uint64_t v63 = 0x40000000;
  uint64_t v64 = (uint64_t)___ZN5dyld4L19getSingletonPatchesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke;
  unsigned int v65 = (double (*)(uint64_t, uint64_t))&__block_descriptor_tmp_104_1;
  char v66 = v13;
  uint64_t v67 = v14;
  dyld3::MachOFile::forEachSingletonPatch(v13, (uint64_t)v60, (uint64_t)&v62);
  mach_o::Error::~Error(v60);
  v38[0] = _NSConcreteStackBlock;
  v38[1] = 0x40000000;
  void v38[2] = ___ZNK5dyld416JustInTimeLoader14makePatchTableERNS_12RuntimeStateEj_block_invoke;
  uint64_t v38[3] = &unk_1EFF64AC8;
  v38[8] = a2;
  v38[9] = IndexedImageEntry;
  v38[4] = &v73;
  v38[5] = &v39;
  v38[6] = &v50;
  v38[7] = this;
  v38[10] = v9;
  v38[11] = v37;
  PatchTable::forEachPatchableExport(v7, a3, (uint64_t)v38);
  v9[*((unsigned int *)v51 + 6)] = -1;
  _Block_object_dispose(&v73, 8);
  uint64_t v81 = 0;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  v78[4] = 0;
  if (v79) {
    vm_deallocate(mach_task_self_, v79, v80);
  }
  _Block_object_dispose(&v39, 8);
  uint64_t v47 = 0;
  if (v48) {
    vm_deallocate(mach_task_self_, v48, v49);
  }
  v44[4] = 0;
  if (v45) {
    vm_deallocate(mach_task_self_, v45, v46);
  }
  _Block_object_dispose(&v50, 8);
  return v9;
}

double __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 88) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v3 = *(void *)(a2 + 88);
  *(void *)(a1 + 8dyld4::halt((char *)__format, 0) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v3;
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  uint64_t v4 = *(void *)(a2 + 128);
  *(void *)(a1 + 12dyld4::halt((char *)__format, 0) = *(void *)(a2 + 120);
  *(void *)(a1 + 128) = v4;
  *(void *)(a2 + 128) = 0;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return result;
}

uint64_t __Block_byref_object_dispose__3(uint64_t result)
{
  unint64_t v1 = (void *)result;
  *(void *)(result + 112) = 0;
  vm_address_t v2 = *(void *)(result + 120);
  if (v2) {
    double result = vm_deallocate(mach_task_self_, v2, *(void *)(result + 128));
  }
  v1[9] = 0;
  vm_address_t v3 = v1[10];
  if (v3)
  {
    vm_map_t v4 = mach_task_self_;
    vm_size_t v5 = v1[11];
    return vm_deallocate(v4, v3, v5);
  }
  return result;
}

void ___ZNK5dyld416JustInTimeLoader14makePatchTableERNS_12RuntimeStateEj_block_invoke(uint64_t a1, unsigned int a2, const unsigned __int8 *a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 56);
  Diagnostics::Diagnostics((Diagnostics *)&v33);
  int hasExportedSymbol = dyld4::Loader::hasExportedSymbol(v8, (vm_address_t *)&v33, *(const dyld4::RuntimeState **)(a1 + 64), a3, 0, 1, (uint64_t *)&v31, 0);
  uint64_t v10 = 0;
  if (hasExportedSymbol)
  {
    uint64_t Address = dyld4::Loader::loadAddress(v31, *(const dyld4::RuntimeState **)(a1 + 64));
    uint64_t v12 = (dyld3::MachOAnalyzer *)(Address + v32);
    if (a4 == 8)
    {
      unsigned int v19 = (dyld3::MachOAnalyzer *)Address;
      uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v34 = Address + v32;
      if (dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>(v20 + 40, (void *)(v20 + 56), (void *)(v20 + 96), 0, &v34) != *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 96)+ 16 * *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 112))
      {
        uint64_t v21 = *(dyld3::MachOAnalyzer **)(a1 + 72);
        if (!dyld3::MachOAnalyzer::isSwiftClass(v19, v12))
        {
          BOOL v22 = (dyld3::MachOAnalyzer *)((char *)v21 + a2);
          if (!dyld3::MachOAnalyzer::isSwiftClass(v21, v22))
          {
            uint64_t v23 = *(void *)(a1 + 64);
            lsl::Vector<dyld4::InterposeTupleAll>::reserve(v23 + 224, *(void *)(v23 + 240) + 1);
            uint64_t v24 = *(void *)(v23 + 232);
            uint64_t v25 = *(void *)(v23 + 240);
            *(void *)(v23 + 24dyld4::halt((char *)__format, 0) = v25 + 1;
            uint64_t v26 = (dyld3::MachOAnalyzer **)(v24 + 16 * v25);
            *uint64_t v26 = v22;
            v26[1] = v12;
            uint64_t v27 = *(void *)(a1 + 64);
            lsl::Vector<dyld4::ObjCClassReplacement>::reserve(v27 + 256, *(void *)(v27 + 272) + 1);
            uint64_t v28 = *(void *)(v27 + 264);
            uint64_t v29 = *(void *)(v27 + 272);
            *(void *)(v27 + 272) = v29 + 1;
            char v30 = (dyld3::MachOAnalyzer **)(v28 + 32 * v29);
            *char v30 = v21;
            v30[1] = v22;
            v30[2] = v19;
            v30[3] = v12;
            uint64_t v10 = 1;
            goto LABEL_10;
          }
        }
      }
    }
    else if (a4 == 1)
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v34 = Address + v32;
      if (dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>(v13 + 40, (void *)(v13 + 56), (void *)(v13 + 96), 0, &v34) != *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 96)+ 16 * *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 112))
      {
        uint64_t v14 = *(void *)(a1 + 64);
        uint64_t v15 = *(void *)(a1 + 72) + a2;
        lsl::Vector<dyld4::InterposeTupleAll>::reserve(v14 + 288, *(void *)(v14 + 304) + 1);
        uint64_t v16 = *(void *)(v14 + 296);
        uint64_t v17 = *(void *)(v14 + 304);
        *(void *)(v14 + 304) = v17 + 1;
        unint64_t v18 = (void *)(v16 + 16 * v17);
        void *v18 = v15;
        v18[1] = v12;
        uint64_t v10 = 2;
        goto LABEL_10;
      }
    }
    uint64_t v10 = (uint64_t)v12 - *(void *)(a1 + 88);
  }
LABEL_10:
  *(void *)(*(void *)(a1 + 80) + 8 * (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))++) = v10;
  mach_o::Error::~Error(&v33);
}

dyld3::MachOFile *___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(dyld3::MachOFile **)(*(void *)(v4 + 8) + 240);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke;
  void v8[3] = &__block_descriptor_tmp_22;
  void v8[4] = v6;
  void v8[5] = v4;
  void v8[6] = a4;
  void v8[7] = v5;
  return DyldSharedCache::forEachPatchableUseOfExport(v6, a2, a3, (uint64_t)v8);
}

void ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2(uint64_t a1, const char *a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  dyld4::Loader::resolveSymbol(*(dyld4::Loader **)(a1 + 40), *(dyld4::RuntimeState **)(a1 + 48), (vm_address_t *)&v5, 4294967293, a2, 1, 0, *(void *)(a1 + 32), (uint64_t)v4);
  mach_o::Error::~Error(&v5);
}

void ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke(uint64_t a1, uint64_t a2, BOOL a3, uint64_t a4)
{
  uint64_t v6 = (char **)(*(void *)(a1 + 32) + a2);
  unint64_t v7 = (char *)dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(a1 + 40), *(void *)(a1 + 48)) + a4;
  if ((a3 & 0x1000000) != 0) {
    unint64_t v7 = (char *)mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer((uint64_t)v7, (unint64_t)v6, (void *)((a3 >> 27) & 1), a3, (a3 >> 25) & 3);
  }
  if (*v6 != v7)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(unsigned char **)(a1 + 56));
    uint64_t v8 = *(dyld4::RuntimeState **)(a1 + 40);
    if (*(unsigned char *)(*((void *)v8 + 1) + 202)) {
      dyld4::RuntimeState::log(v8, "cache patch: %p = 0x%0lX\n", v6, v7);
    }
    *uint64_t v6 = v7;
  }
}

dyld3::MachOFile *___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(dyld3::MachOFile **)(*(void *)(v4 + 8) + 240);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke;
  void v8[3] = &__block_descriptor_tmp_22;
  void v8[4] = v6;
  void v8[5] = v4;
  void v8[6] = a4;
  void v8[7] = v5;
  return DyldSharedCache::forEachPatchableUseOfExport(v6, a2, a3, (uint64_t)v8);
}

double __Block_byref_object_copy__24(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__25(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

double __Block_byref_object_copy__26_0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__27_0(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(dyld4::Loader **)(a1 + 48);
  uint64_t v4 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(_DWORD *)(a2 + 32) == 1 && *(void *)a2 == 0)
  {
    if (*(unsigned char *)(*((void *)v4 + 1) + 202))
    {
      uint64_t v12 = dyld4::Loader::leafName(*(dyld4::Loader **)(a1 + 48), v4);
      dyld4::RuntimeState::log(v4, "<%s/bind#%llu> -> missing-weak-bind (%s)\n", v12, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 56), *(const char **)(a2 + 8));
    }
    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
    double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v13 + 40), 1);
    uint64_t v15 = *(void *)(v13 + 40);
    uint64_t v16 = *(void *)(v13 + 56);
    *(void *)(v13 + 56) = v16 + 1;
    *(void *)(v15 + 8 * v16) = -1;
  }
  else
  {
    unint64_t v7 = dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(a1 + 56), a2);
    size_t v9 = dyld4::Loader::interpose(v4, v7, v5, v8);
    uint64_t v10 = *(const dyld4::RuntimeState **)(a1 + 56);
    if (*(unsigned char *)(*((void *)v10 + 1) + 202))
    {
      if (*(void *)a2)
      {
        unint64_t v11 = dyld4::Loader::leafName(*(dyld4::Loader **)a2, *(const dyld4::RuntimeState **)(a1 + 56));
        uint64_t v10 = *(const dyld4::RuntimeState **)(a1 + 56);
      }
      else
      {
        unint64_t v11 = "<none>";
      }
      uint64_t v17 = dyld4::Loader::leafName(v5, v10);
      dyld4::RuntimeState::log(v10, "<%s/bind#%llu> -> %p (%s/%s)\n", v17, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 56), v9, v11, *(const char **)(a2 + 8));
    }
    if (*(unsigned char *)(a2 + 38))
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v19 = *(void *)(a2 + 8);
      uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 56);
      dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(v18 + 40), 1);
      uint64_t v21 = *(void *)(v18 + 40);
      uint64_t v22 = *(void *)(v18 + 56);
      *(void *)(v18 + 56) = v22 + 1;
      uint64_t v23 = v21 + 16 * v22;
      *(void *)uint64_t v23 = v19;
      *(_DWORD *)(v23 + 8) = v20;
    }
    uint64_t v24 = *(void *)(*(void *)(a1 + 32) + 8);
    double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v24 + 40), 1);
    uint64_t v25 = *(void *)(v24 + 40);
    uint64_t v26 = *(void *)(v24 + 56);
    *(void *)(v24 + 56) = v26 + 1;
    *(void *)(v25 + 8 * v26) = v9;
  }
  return result;
}

uint64_t ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_3(uint64_t result, int a2, unsigned int a3)
{
  if (a2 == 1 && a3 <= 0xA0900)
  {
    void v9[3] = v3;
    void v9[4] = v4;
    uint64_t v5 = result;
    v9[0] = 0;
    double result = dyld3::MachOLoaded::findSectionContent(*(dyld3::MachOLoaded **)(result + 32), "__DATA", "__dyld", v9);
    if (result)
    {
      uint64_t v6 = (void *)result;
      unint64_t v8 = 0;
      uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*(void *)(v5 + 40) + 104), *(const dyld4::RuntimeState **)(v5 + 40));
      double result = dyld3::MachOLoaded::findSectionContent(Address, "__TPRO_CONST", "__dyld4", &v8);
      if (result)
      {
        *uint64_t v6 = 0;
        v6[1] = *(void *)(result + 56);
      }
    }
  }
  return result;
}

void dyld4::JustInTimeLoader::unmap(dyld4::JustInTimeLoader *this, dyld4::SyscallDelegate **a2, char a3)
{
  __int16 v3 = *((_WORD *)this + 2);
  if ((v3 & 2) == 0 && !*((void *)this + 13))
  {
    if ((v3 & 0x20) != 0 && (a3 & 1) == 0)
    {
      uint64_t v6 = *((_WORD *)this + 20) ? (char *)this + *((unsigned __int16 *)this + 20) : 0;
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "trying to unmap %s\n", v6);
      if ((*((_WORD *)this + 2) & 0x20) != 0) {
        dyld4::JustInTimeLoader::unmap();
      }
    }
    size_t v7 = dyld3::MachOFile::mappedSize(*((dyld3::MachOFile **)this + 4));
    unint64_t v8 = (char *)*((void *)this + 4);
    dyld4::SyscallDelegate::unmapFile(a2[1], v8, v7);
    if (*((unsigned char *)a2[1] + 201))
    {
      if (*((_WORD *)this + 20)) {
        size_t v9 = (char *)this + *((unsigned __int16 *)this + 20);
      }
      else {
        size_t v9 = 0;
      }
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "unmapped 0x%012lX->0x%012lX for %s\n", v8, &v8[v7], v9);
    }
  }
}

uint64_t dyld4::JustInTimeLoader::hasBeenFixedUp(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2)
{
  return (*((unsigned __int8 *)this + 42) >> 1) & 1;
}

void dyld4::JustInTimeLoader::getFileValidationInfo(dyld4::JustInTimeLoader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v10 = 0;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x6002000000;
  uint64_t v13 = __Block_byref_object_copy__73;
  uint64_t v14 = __Block_byref_object_dispose__74;
  bzero(&v15, 0x38uLL);
  if (*((unsigned char *)this + 80))
  {
    uint64_t v5 = v11;
    *((unsigned char *)v11 + 92) = 1;
    void v5[5] = *((void *)this + 6);
    void v5[7] = *((void *)this + 7);
    void v5[8] = *((void *)this + 9);
  }
  if ((*((_WORD *)this + 2) & 2) != 0)
  {
    size_t v7 = v11;
  }
  else
  {
    uint64_t v6 = (_DWORD *)*((void *)this + 4);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    unsigned int v9[2] = ___ZNK5dyld416JustInTimeLoader21getFileValidationInfoERNS_12RuntimeStateE_block_invoke;
    void v9[3] = &unk_1EFF64C58;
    void v9[4] = &v10;
    dyld3::MachOAnalyzer::forEachCDHash(v6, (uint64_t)v9);
    size_t v7 = v11;
    v11[6] = *((void *)this + 8);
  }
  long long v8 = *(_OWORD *)(v7 + 7);
  *(_OWORD *)a2 = *(_OWORD *)(v7 + 5);
  *(_OWORD *)(a2 + 16) = v8;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v7 + 9);
  *(void *)(a2 + 48) = v7[11];
  _Block_object_dispose(&v10, 8);
}

__n128 __Block_byref_object_copy__73(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  long long v3 = *(_OWORD *)(a2 + 56);
  long long v4 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

__n128 ___ZNK5dyld416JustInTimeLoader21getFileValidationInfoERNS_12RuntimeStateE_block_invoke(uint64_t a1, __n128 *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 93) = 1;
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  __n128 result = *a2;
  *(_DWORD *)(v2 + 88) = a2[1].n128_u32[0];
  *(__n128 *)(v2 + 72) = result;
  return result;
}

uint64_t dyld4::JustInTimeLoader::getCatalystMacTwinPatches(dyld4::JustInTimeLoader *this)
{
  return *((void *)this + 12);
}

__n128 __Block_byref_object_copy__77(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

dyld4::Loader *dyld4::JustInTimeLoader::makeJustInTimeLoaderDyldCache(vm_address_t *a1, dyld4::RuntimeState *a2, char *a3, int a4, int a5)
{
  __int16 v5 = a5;
  unint64_t v23 = 0;
  unint64_t v22 = 0;
  uint64_t IndexedImageEntry = (mach_o::Header *)dyld4::ProcessConfig::DyldCache::getIndexedImageEntry((DyldSharedCache **)(*((void *)a2 + 1) + 240), a5, &v23, &v22);
  uint64_t v10 = *((void *)a2 + 1);
  char v11 = *(unsigned char *)(v10 + 397);
  long long v19 = v22;
  unint64_t v20 = v23;
  char v21 = v11;
  if (dyld3::MachOFile::loadableIntoProcess(IndexedImageEntry, *(_DWORD *)(v10 + 68), a3, *(unsigned __int8 *)(v10 + 168)))
  {
    if (_platform_strncmp(a3, "/System/iOSSupport/", 0x13uLL))
    {
      int v12 = 0;
      __int16 v13 = 0;
    }
    else
    {
      unsigned int v18 = 0;
      int v12 = dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(*((void *)a2 + 1) + 240), a3 + 18, &v18);
      __int16 v13 = v18;
      if (!v12) {
        __int16 v13 = 0;
      }
    }
    uint64_t v15 = (dyld4::Loader *)dyld4::JustInTimeLoader::make((uint64_t)a2, IndexedImageEntry, a3, &v19, 0, 1, 0, v12, v13);
    uint64_t v14 = v15;
    *((_WORD *)v15 + 3) = *((_WORD *)v15 + 3) & 0x8000 | v5 & 0x7FFF;
    uint64_t v16 = *((void *)a2 + 1);
    if (*(unsigned char *)(v16 + 201))
    {
      dyld4::Loader::logSegmentsFromSharedCache(v15, a2);
      uint64_t v16 = *((void *)a2 + 1);
    }
    if (*(unsigned char *)(v16 + 200)) {
      dyld4::Loader::logLoad(v14, a2, a3);
    }
  }
  else
  {
    Diagnostics::error(a1, "wrong platform to load into process");
    return 0;
  }
  return v14;
}

void *dyld4::JustInTimeLoader::makePseudoDylibLoader(vm_address_t *a1, uint64_t a2, const char *a3, uint64_t a4, mach_o::Header **a5)
{
  size_t v9 = *a5;
  memset(v11, 0, sizeof(v11));
  if (dyld3::MachOFile::loadableIntoProcess(v9, *(_DWORD *)(*(void *)(a2 + 8) + 68), a3, 0))
  {
    __n128 result = dyld4::JustInTimeLoader::make(a2, v9, a3, v11, 0, 0, 0, 0, 0);
    result[13] = a5;
  }
  else
  {
    Diagnostics::error(a1, "wrong platform to load into process");
    return 0;
  }
  return result;
}

void *___ZN5dyld4L19getObjCPatchClassesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  __n128 result = (void *)Diagnostics::hasError((Diagnostics *)(a1 + 40));
  if (result)
  {
    *a3 = 1;
    return result;
  }
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v7 + 40), 1);
  }
  else
  {
    uint64_t v15 = 0;
    char v14 = 0;
    int hasExportedSymbol = dyld3::MachOLoaded::hasExportedSymbol(*(dyld3::MachOFile **)(a1 + 48), *(const unsigned __int8 **)(a2 + 8), 0, &v15, &v14);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v7 + 40), 1);
    if (hasExportedSymbol)
    {
      uint64_t v9 = v15;
      uint64_t v10 = *(void *)(v7 + 40);
      uint64_t v11 = *(void *)(v7 + 56);
      *(void *)(v7 + 56) = v11 + 1;
      *(void *)(v10 + 8 * v11) = v9;
      return result;
    }
  }
  uint64_t v12 = *(void *)(v7 + 40);
  uint64_t v13 = *(void *)(v7 + 56);
  *(void *)(v7 + 56) = v13 + 1;
  *(void *)(v12 + 8 * v13) = 0;
  return result;
}

void __destroy_helper_block_8_40c17_ZTS11Diagnostics(uint64_t a1)
{
}

uint64_t dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0;
    memset(v21, 0, sizeof(v21));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v21, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v21, 1);
      uint64_t v6 = (*(void *)&v21[1])++;
      *(_DWORD *)(*(void *)&v21[0] + 4 * v6) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0;
      do
      {
        long long v8 = (void *)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v7);
        unint64_t v9 = (*(void *)&v21[1] - 1) & *v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) != -1)
        {
          uint64_t v10 = 1;
          do
            unint64_t v9 = (*(void *)&v21[1] - 1) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) = v7++;
      }
      while (v7 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v21)
    {
      *(void *)&v21[1] = 0;
      if (*((void *)&v21[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v21[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v11 = *(void *)(a1 + 40);
      if (v11) {
        vm_deallocate(mach_task_self_, v11, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v21[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v21 + 8);
      vm_size_t v12 = size;
      *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *((void *)&v21[1] + 1);
      *(void *)(a1 + 48) = v12;
    }
  }
  unint64_t v13 = (*(void *)(a1 + 32) - 1) & *a2;
  unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
  if (v14 == -1)
  {
LABEL_20:
    uint64_t v16 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13) = v16;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v17 = *(void *)(a1 + 56);
    uint64_t v18 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v18 + 1;
    *(_OWORD *)(v17 + 16 * v18) = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a1 + 72);
    if (!v19) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 16 * v19 - 16;
  }
  else
  {
    uint64_t v15 = 1;
    while (*(void *)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v14) != *a2)
    {
      unint64_t v13 = (*(void *)(a1 + 32) - 1) & (v13 + v15++);
      unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
      if (v14 == -1) {
        goto LABEL_20;
      }
    }
    return dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v14);
  }
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 16 * a2;
}

void *dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    long long v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 16 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    __n128 result = memmove((void *)v3[3], *v3, 16 * (void)v3[2]);
    long long v8 = (const void *)((unint64_t)v3[4] >> 4);
    dyld4::Loader *v3 = v3[3];
    v3[1] = v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L19getSingletonPatchesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke(uint64_t result, int a2, uint64_t a3)
{
  if (a2 == 1)
  {
    uint64_t v9 = v3;
    uint64_t v10 = v4;
    uint64_t v6 = *(void *)(result + 32);
    uint64_t v5 = *(void *)(result + 40);
    uint64_t v7 = v6 + a3;
    char v8 = 1;
    return dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v5, &v7);
  }
  return result;
}

uint64_t dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  uint64_t v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve((void *)(a1 + 56), 0x20uLL);
  return a1;
}

uint64_t dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  unint64_t v5 = a3[2];
  if (!v5) {
    return *a3;
  }
  unint64_t v6 = a2[2];
  unint64_t v7 = (v6 - 1) & *a5;
  if (v6 <= v7) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v8 = *a3;
  uint64_t v9 = 1;
  while (1)
  {
    unint64_t v10 = *(unsigned int *)(*a2 + 4 * v7);
    if (v10 == -1) {
      return v8 + 16 * v5;
    }
    if (v5 <= v10) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    if (*(void *)(v8 + 16 * v10) == *a5) {
      return v8 + 16 * v10;
    }
    unint64_t v7 = (v7 + v9++) & (v6 - 1);
    if (v6 <= v7) {
      goto LABEL_8;
    }
  }
}

uint64_t lsl::Vector<dyld4::ObjCClassReplacement>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<dyld4::ObjCClassReplacement>::reserveExact(result, v2);
  }
  return result;
}

uint64_t lsl::Vector<dyld4::ObjCClassReplacement>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    __n128 result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 32 * a2);
    if ((result & 1) == 0)
    {
      __n128 result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 32 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0;
        for (unint64_t i = 0; i < v5; ++i)
        {
          uint64_t v8 = (_OWORD *)(result + v6);
          uint64_t v9 = (_OWORD *)(*(void *)(v3 + 8) + v6);
          long long v10 = v9[1];
          *uint64_t v8 = *v9;
          v8[1] = v10;
          unint64_t v5 = *(void *)(v3 + 16);
          v6 += 32;
        }
      }
      vm_address_t v11 = *(void **)(v3 + 8);
      if (v11)
      {
        __n128 result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v11);
        unint64_t v5 = *(void *)(v3 + 16);
      }
      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }
    *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *a1, vm_address_t *this, uint64_t a3)
{
  int v4 = *(_DWORD *)(a3 + 32);
  if (v4 == 1)
  {
    if (*(void *)a3) {
      uint64_t v8 = *(unsigned __int16 *)(*(void *)a3 + 6);
    }
    else {
      uint64_t v8 = 0x7FFFLL;
    }
    unint64_t v9 = *(void *)(a3 + 16);
    *a1 = (v8 | (HIBYTE(v9) << 16)) & 0x8000000000FFFFFFLL | ((v9 & 0x7FFFFFFFFFLL) << 24);
    uint64_t v10 = v9 & 0x7FFFFFFFFFLL;
    if ((v9 & 0x4000000000) != 0) {
      uint64_t v10 = v9 & 0x7FFFFFFFFFLL | 0xFFFF8000000000;
    }
    if ((v10 | v9 & 0xFF00000000000000) != *(void *)(a3 + 16)) {
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
    }
  }
  else if (v4 == 2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = __ROR8__(v5, 56);
    *a1 = v6 | 0x8000000000000000;
    if ((v6 & 0x4000000000000000) != 0) {
      unint64_t v7 = (v6 | 0x8000000000000000) >> 8;
    }
    else {
      unint64_t v7 = ((v6 | 0x8000000000000000) >> 8) & 0x7FFFFFFFFFFFFFLL;
    }
    if ((v7 | (v6 << 56)) != *(void *)(a3 + 16)) {
      Diagnostics::error(this, "unencodeable absolute value (0x%llx) for symbol '%s'", *(void *)(a3 + 16), *(const char **)(a3 + 8));
    }
  }
  return a1;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *this, const BindTarget *a2)
{
  if (a2->var0) {
    uint64_t v2 = *((unsigned __int16 *)a2->var0 + 3);
  }
  else {
    uint64_t v2 = 0x7FFFLL;
  }
  unint64_t var1 = a2->var1;
  *this = (v2 | (HIBYTE(var1) << 16)) & 0x8000000000FFFFFFLL | ((var1 & 0x7FFFFFFFFFLL) << 24);
  uint64_t v4 = var1 & 0x7FFFFFFFFFLL;
  if ((var1 & 0x4000000000) != 0) {
    uint64_t v4 = var1 & 0x7FFFFFFFFFLL | 0xFFFF8000000000;
  }
  if ((v4 | var1 & 0xFF00000000000000) != a2->var1) {
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  }
  return this;
}

uint64_t dyld4::PrebuiltLoader::unmap(uint64_t this, dyld4::RuntimeState *a2)
{
  __int16 v2 = *(_WORD *)(this + 6);
  if (v2 >= 0) {
    uint64_t v3 = (char *)a2 + 976;
  }
  else {
    uint64_t v3 = (char *)a2 + 1000;
  }
  *(unsigned char *)(*(void *)v3 + (v2 & 0x7FFF)) = 2;
  return this;
}

ssize_t ___ZNK5dyld414PrebuiltLoader21invalidateInIsolationERKNS_12RuntimeStateE_block_invoke(ssize_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (a3 >= 10)
  {
    *a4 = 1;
    return result;
  }
  ssize_t v6 = result;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v7 = *(void *)(result + 40);
  __n128 result = dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(result + 48) + 8), a2, &v19, 0);
  if (result)
  {
    if (!v7 || !*(_WORD *)(v7 + 42) || (uint64_t v9 = v7 + *(unsigned __int16 *)(v7 + 42), !*(unsigned char *)(v9 + 52)))
    {
      if (*(unsigned char *)(*(void *)(*(void *)(v6 + 48) + 8) + 207))
      {
        uint64_t v17 = "found '%s' which invalidates PrebuiltLoader for '%s'\n";
        goto LABEL_21;
      }
LABEL_25:
      *(unsigned char *)(*(void *)(*(void *)(v6 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *a4 = 1;
      return result;
    }
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v13 = v9 + 16;
    uint64_t v11 = *(void *)(v9 + 16);
    uint64_t v12 = *(void *)(v13 + 8);
    if (*((void *)&v19 + 1) != v10 || BYTE8(v20) == 0 || (void)v19 != v11 || (void)v20 != v12)
    {
      if (*(unsigned char *)(*(void *)(*(void *)(v6 + 48) + 8) + 207))
      {
        uint64_t v17 = "found '%s' with different inode/mtime than PrebuiltLoader for '%s'\n";
LABEL_21:
        if (*(_WORD *)(v7 + 32)) {
          uint64_t v18 = v7 + *(unsigned __int16 *)(v7 + 32);
        }
        else {
          uint64_t v18 = 0;
        }
        __n128 result = dyld4::console((dyld4 *)v17, v8, a2, v18);
        goto LABEL_25;
      }
      goto LABEL_25;
    }
  }
  return result;
}

double dyld4::PrebuiltLoader::PrebuiltLoader(dyld4::PrebuiltLoader *this, const dyld4::Loader *a2)
{
  dyld4::Loader::InitialOptions::InitialOptions((dyld4::Loader::InitialOptions *)v4, a2);
  dyld4::Loader::Loader((uint64_t)this, v4, 1, 0, 0, 0);
  *(void *)&double result = 1;
  *((void *)this + 13) = 1;
  return result;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_3(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  if ((a6 & 1) == 0 && *(unsigned char *)(a5 + 36) && (*(unsigned char *)(a5 + 32) & 1) == 0)
  {
    ssize_t v6 = (unint64_t *)(a1[5] + a4 - a1[4]);
    unint64_t v7 = *v6 & 0xFFFFFFFFFFFFFFFCLL | 2;
    uint64_t v8 = (dyld4::RuntimeState *)a1[6];
    if (*(unsigned char *)(*((void *)v8 + 1) + 202)) {
      dyld4::RuntimeState::log(v8, "fixup: *0x%012lX = 0x%012lX <mark swift stable>\n", v6, v7);
    }
    *ssize_t v6 = v7;
  }
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t OnlyDataField = dyld3::MachOAnalyzer::ObjCClassInfo::getReadOnlyDataField(a5, 2, *(_DWORD *)(a1 + 64));
  if (OnlyDataField)
  {
    uint64_t v7 = OnlyDataField - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v7) & 1) == 0)
    {
      uint64_t v8 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v9 = (_DWORD *)(**(void **)(a1 + 48) + v7);
      uint64_t v10 = *v9 | 1;
      if (*(unsigned char *)(*((void *)v8 + 1) + 202)) {
        dyld4::RuntimeState::log(v8, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v9, v10);
      }
      _DWORD *v9 = v10;
    }
  }
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  if (v5)
  {
    uint64_t v6 = v5 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v6) & 1) == 0)
    {
      uint64_t v7 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v8 = (_DWORD *)(**(void **)(a1 + 48) + v6);
      uint64_t v9 = *v8 | 1;
      if (*(unsigned char *)(*((void *)v7 + 1) + 202)) {
        dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v8, v9);
      }
      *uint64_t v8 = v9;
    }
  }
  uint64_t v10 = *(void *)(a3 + 24);
  if (v10)
  {
    uint64_t v11 = v10 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v11) & 1) == 0)
    {
      uint64_t v12 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v13 = (_DWORD *)(**(void **)(a1 + 48) + v11);
      uint64_t v14 = *v13 | 1;
      if (*(unsigned char *)(*((void *)v12 + 1) + 202)) {
        dyld4::RuntimeState::log(v12, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v13, v14);
      }
      *uint64_t v13 = v14;
    }
  }
}

void dyld4::PrebuiltLoader::serialize(vm_address_t *a1, dyld4::RuntimeState *a2, const dyld4::Loader *a3, __int16 a4, uint64_t a5, dyld4::PrebuiltObjC *a6, int a7, dyld4::BumpAllocator *this)
{
  uint64_t v8 = this;
  stat v106 = a1;
  uint64_t v14 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 0x1C0uLL);
  dyld4::PrebuiltLoader::PrebuiltLoader((dyld4::PrebuiltLoader *)(*(void *)v8 + v14), a3);
  *(_WORD *)(*(void *)v8 + v14 + 6) = a4;
  uint64_t v15 = (dyld3::MachOFile *)dyld4::JustInTimeLoader::mf((uint64_t)a3);
  __int16 FixupsLoadCommandFileOffset = dyld3::MachOFile::getFixupsLoadCommandFileOffset(v15);
  uint64_t v17 = *(void *)v8;
  uint64_t v18 = *(void *)v8 + v14;
  *(_WORD *)(v18 + 38) = FixupsLoadCommandFileOffset;
  *(_WORD *)(v18 + 32) = *((_DWORD *)v8 + 4) - v17 - v14;
  uint64_t v108 = a2;
  long long v19 = (const char *)dyld4::JustInTimeLoader::path((uint64_t)a3);
  unint64_t v20 = _platform_strlen(v19) + 1;
  uint64_t v21 = *((void *)v8 + 2) - *(void *)v8;
  dyld4::BumpAllocator::zeroFill(v8, v20);
  memmove((void *)(*(void *)v8 + v21), v19, v20);
  *(_WORD *)(*(void *)v8 + v14 + 4dyld4::halt((char *)__format, 0) = 0;
  unint64_t v22 = dyld3::MachOFile::installName(v15);
  long long v105 = v15;
  uint64_t v107 = v8;
  if (dyld3::MachOFile::isDylib(v15) && _platform_strcmp(v22, v19))
  {
    uint64_t v23 = *((void *)v8 + 2) - *(void *)v8;
    *(_WORD *)(*(void *)v8 + v14 + 4dyld4::halt((char *)__format, 0) = v23 - v14;
    unint64_t v24 = _platform_strlen(v22) + 1;
    dyld4::BumpAllocator::zeroFill(v107, v24);
    size_t v25 = v24;
    uint64_t v8 = v107;
    memmove((void *)(*(void *)v107 + v23), v22, v25);
  }
  if ((*((_WORD *)a3 + 2) & 2) != 0)
  {
    if (dyld4::ProcessConfig::DyldCache::isOverridablePath((dyld4::ProcessConfig::DyldCache *)(*((void *)v108 + 1) + 240), v19))
    {
      __int16 v26 = 2;
    }
    else
    {
      __int16 v26 = 0;
    }
  }
  else
  {
    __int16 v26 = 0;
  }
  *(_WORD *)(*(void *)v8 + v14 + 44) = *(_WORD *)(*(void *)v8 + v14 + 44) & 0xFFFD | v26;
  unsigned int v27 = dyld4::JustInTimeLoader::dependentCount(a3);
  uint64_t v28 = *(void *)v8;
  *(_WORD *)(*(void *)v8 + v14 + 48) = v27;
  uint64_t v29 = *((void *)v8 + 2);
  pid_t v102 = v19;
  uint64_t v103 = a6;
  uint64_t v101 = a5;
  if (((_BYTE)v29 - (_BYTE)v28))
  {
    dyld4::BumpAllocator::zeroFill(v8, 2 - (((_BYTE)v29 - (_BYTE)v28) & 1));
    uint64_t v29 = *((void *)v8 + 2);
    uint64_t v28 = *(void *)v8;
  }
  __int16 v30 = v29 - v28;
  unsigned __int16 v31 = v30 - v14;
  *(_WORD *)(v28 + v14 + 34) = v30 - v14;
  uint64_t v32 = dyld4::BumpAllocator::zeroFill(v8, 2 * v27);
  __chkstk_darwin(v32, v27 + 1, v33, v34, v35, v36, v37, v38, v101);
  char v40 = (char *)&v101 - ((v39 + 15) & 0x1FFFFFFF0);
  if ((v41 & 1) != 0 || (bzero((char *)&v101 - ((v39 + 15) & 0x1FFFFFFF0), v39), v27))
  {
    uint64_t v42 = 0;
    char v43 = 0;
    uint64_t v104 = v14;
    uint64_t v44 = v14 + v31;
    do
    {
      uint64_t v45 = dyld4::JustInTimeLoader::dependent(a3, (int)v108, v42, &v40[v42]);
      int v46 = v40[v42];
      if (v45)
      {
        *(_WORD *)(*(void *)v107 + v44 + 2 * v42) = *(_WORD *)(v45 + 6);
      }
      else
      {
        if ((v46 & 1) == 0) {
          dyld4::PrebuiltLoader::serialize();
        }
        *(_WORD *)(*(void *)v107 + v44 + 2 * v42) = 0x7FFF;
      }
      v43 |= v46 != mach_o::LinkedDylibAttributes::regular;
      ++v42;
    }
    while (v27 != v42);
    uint64_t v8 = v107;
    uint64_t v47 = *(void *)v107;
    uint64_t v14 = v104;
    uint64_t v48 = *(void *)v107 + v104;
    *(_WORD *)(v48 + 36) = 0;
    if (v43)
    {
      unsigned __int16 v49 = *((void *)v8 + 2) - (v14 + v47);
      *(_WORD *)(v48 + 36) = v49;
      dyld4::BumpAllocator::zeroFill(v8, v27);
      memmove((void *)(*(void *)v8 + v14 + v49), v40, v27);
      uint64_t v47 = *(void *)v8;
    }
  }
  else
  {
    uint64_t v47 = *(void *)v8;
    *(_WORD *)(*(void *)v8 + v14 + 36) = 0;
  }
  uint64_t v50 = (uint64_t)a3;
  dyld4::JustInTimeLoader::getExportsTrie(a3, (unint64_t *)(v47 + v14 + 64), (unsigned int *)(v47 + v14 + 72));
  unsigned int v51 = v105;
  uint64_t v52 = (Diagnostics *)v106;
  *(_WORD *)(*(void *)v8 + v14 + 44) = *(_WORD *)(*(void *)v8 + v14 + 44) & 0xFFFE | dyld3::MachOFile::hasInitializer(v105, v106);
  if (!Diagnostics::hasError(v52))
  {
    *(void *)(*(void *)v8 + v14 + 8dyld4::halt((char *)__format, 0) = 0;
    if ((*((unsigned char *)a3 + 4) & 2) == 0)
    {
      LODWORD(v124[0]) = 0;
      LODWORD(v113) = 0;
      if (dyld3::MachOFile::hasCodeSignature(v51, (unsigned int *)v124, (unsigned int *)&v113))
      {
        uint64_t v53 = *(void *)v8 + v14;
        *(_DWORD *)(v53 + 8dyld4::halt((char *)__format, 0) = v124[0];
        *(_DWORD *)(v53 + 84) = v113;
      }
      if ((*((_WORD *)a3 + 2) & 2) == 0) {
        goto LABEL_28;
      }
    }
    if (*(unsigned char *)(*((void *)v108 + 1) + 397))
    {
LABEL_28:
      if (((*((_DWORD *)v8 + 4) - *(_DWORD *)v8) & 7) != 0) {
        dyld4::BumpAllocator::zeroFill(v8, 8 - ((*((_DWORD *)v8 + 4) - *(_DWORD *)v8) & 7));
      }
      uint64_t v126 = 0;
      long long v125 = 0u;
      memset(v124, 0, sizeof(v124));
      dyld4::JustInTimeLoader::getFileValidationInfo(a3, (uint64_t)v124);
      uint64_t v54 = *((void *)v8 + 2) - *(void *)v8;
      *(_WORD *)(*(void *)v8 + v14 + 42) = v54 - v14;
      if ((unint64_t)(v54 - v14) >= 0x10000) {
        dyld4::PrebuiltLoader::serialize();
      }
      dyld4::BumpAllocator::zeroFill(v8, 0x38uLL);
      uint64_t v55 = *(void *)v8 + v54;
      long long v56 = v124[0];
      long long v57 = v124[1];
      long long v58 = v125;
      *(void *)(v55 + 48) = v126;
      *(_OWORD *)(v55 + 16) = v57;
      *(_OWORD *)(v55 + 32) = v58;
      *(_OWORD *)uint64_t v55 = v56;
    }
    *(_DWORD *)(*(void *)v8 + v14 + 76) = dyld3::MachOFile::mappedSize(v51);
    v123[0] = _NSConcreteStackBlock;
    v123[1] = 0x40000000;
    v123[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke;
    v123[3] = &__block_descriptor_tmp_46_1;
    v123[4] = v8;
    v123[5] = v14;
    v123[6] = v8;
    v123[7] = v14;
    dyld4::JustInTimeLoader::withRegions(v51, (uint64_t)v123);
    SectionLocations = (const void *)dyld4::JustInTimeLoader::getSectionLocations(a3);
    memmove((void *)(*(void *)v8 + v14 + 104), SectionLocations, 0x158uLL);
    int v60 = *(_DWORD *)(*((void *)v108 + 1) + 64);
    if (v60 == 1 || v60 == 6) {
      int v62 = (*((unsigned __int16 *)a3 + 2) >> 1) & 1;
    }
    else {
      int v62 = 0;
    }
    if (v62 == 1)
    {
      if (dyld3::MachOFile::builtForPlatform(v51, 6, 0)) {
        __int16 v63 = 4;
      }
      else {
        __int16 v63 = 0;
      }
    }
    else
    {
      __int16 v63 = 0;
    }
    *(_WORD *)(*(void *)v8 + v14 + 44) = *(_WORD *)(*(void *)v8 + v14 + 44) & 0xFFFB | v63;
    *(_WORD *)(*(void *)v8 + v14 + 44) &= ~8u;
    uint64_t v64 = v14;
    uint64_t v65 = *(void *)v8 + v14;
    *(_DWORD *)(v65 + 6dyld4::halt((char *)__format, 0) = 0xFFFF;
    if (v62)
    {
      if ((*(_WORD *)(v65 + 44) & 4) != 0)
      {
        if (!_platform_strncmp(v102, "/System/iOSSupport/", 0x13uLL))
        {
          uint64_t v71 = *((void *)v108 + 6);
          if (v71)
          {
            uint64_t v72 = (char *)(v102 + 18);
            uint64_t v73 = (dyld4::Loader **)*((void *)v108 + 5);
            uint64_t v74 = 8 * v71;
            uint64_t v75 = v73;
            while (1)
            {
              uint64_t v76 = *v75;
              if (dyld4::Loader::matchesPath(*v75, v108, v72)) {
                break;
              }
              ++v75;
              ++v73;
              v74 -= 8;
              uint64_t v8 = v107;
              if (!v74) {
                goto LABEL_58;
              }
            }
            __int16 v99 = *((_WORD *)v76 + 3) & 0x7FFF;
            uint64_t v8 = v107;
            uint64_t v100 = *(void *)v107 + v64;
            *(_WORD *)(v100 + 6dyld4::halt((char *)__format, 0) = v99;
            *(_WORD *)(v100 + 44) |= 8u;
          }
        }
      }
      else
      {
        strcpy((char *)v124, "/System/iOSSupport");
        strlcat((char *)v124, v102, 0x400uLL);
        uint64_t v66 = *((void *)v108 + 6);
        if (v66)
        {
          uint64_t v67 = (dyld4::Loader **)*((void *)v108 + 5);
          uint64_t v68 = 8 * v66;
          uint64_t v69 = v67;
          while (1)
          {
            vm_address_t v70 = *v69;
            if (dyld4::Loader::matchesPath(*v69, v108, (char *)v124)) {
              break;
            }
            ++v69;
            ++v67;
            v68 -= 8;
            if (!v68) {
              goto LABEL_57;
            }
          }
          *(_WORD *)(*(void *)v107 + v14 + 6dyld4::halt((char *)__format, 0) = *((_WORD *)v70 + 3) & 0x7FFF;
        }
LABEL_57:
        uint64_t v8 = v107;
      }
    }
LABEL_58:
    uint64_t v113 = 0;
    uint64_t v114 = &v113;
    uint64_t v115 = 0x5002000000;
    pid_t v116 = __Block_byref_object_copy__4;
    uint64_t v117 = __Block_byref_object_dispose__4;
    uint64_t v118 = v124;
    uint64_t v119 = 16;
    uint64_t v120 = 0;
    vm_address_t v121 = 0;
    vm_size_t v122 = 0;
    if ((*(unsigned char *)(v50 + 4) & 2) == 0)
    {
      uint64_t v77 = *((void *)v8 + 2);
      uint64_t v78 = *(void *)v8;
      if ((((_BYTE)v77 - *(void *)v8) & 7) != 0)
      {
        dyld4::BumpAllocator::zeroFill(v8, 8 - (((_BYTE)v77 - *(void *)v8) & 7));
        uint64_t v77 = *((void *)v8 + 2);
        uint64_t v78 = *(void *)v8;
      }
      unint64_t v79 = v77 - (v64 + v78);
      *(_WORD *)(v78 + v64 + 5dyld4::halt((char *)__format, 0) = v79;
      if (v79 >= 0x10000) {
        dyld4::PrebuiltLoader::serialize();
      }
      *(_DWORD *)(v78 + v64 + 52) = 0;
      v112[0] = _NSConcreteStackBlock;
      v112[1] = 0x40000000;
      v112[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51;
      v112[3] = &__block_descriptor_tmp_55;
      vm_size_t v80 = (Diagnostics *)v106;
      v112[4] = v106;
      v112[5] = v8;
      v112[6] = v8;
      v112[7] = v64;
      v111[0] = _NSConcreteStackBlock;
      v111[1] = 0x40000000;
      v111[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_2;
      v111[3] = &unk_1EFF64E98;
      v111[4] = &v113;
      v111[5] = v106;
      dyld4::Loader::forEachBindTarget((dyld4::Loader *)v50, v106, v108, v101, 1, (uint64_t)v112, (uint64_t)v111);
      if (Diagnostics::hasError(v80)) {
        goto LABEL_79;
      }
      if (v114[7])
      {
        uint64_t v81 = *((void *)v8 + 2);
        uint64_t v82 = *(void *)v8;
        if ((((_BYTE)v81 - *(void *)v8) & 7) != 0)
        {
          dyld4::BumpAllocator::zeroFill(v8, 8 - (((_BYTE)v81 - *(void *)v8) & 7));
          uint64_t v81 = *((void *)v8 + 2);
          uint64_t v82 = *(void *)v8;
        }
        uint64_t v83 = v82 + v64;
        *(_DWORD *)(v83 + 92) = v81 - (v64 + v82);
        *(_DWORD *)(v83 + 96) = v114[7];
        uint64_t v84 = v114;
        uint64_t v85 = v114[7];
        if (!v85)
        {
          dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v114 + 5, 1uLL);
          v84[7] = 1;
          uint64_t v85 = v114[7];
          uint64_t v81 = *((void *)v8 + 2);
          uint64_t v82 = *(void *)v8;
        }
        uint64_t v86 = (const void *)v84[5];
        uint64_t v87 = 8 * v85;
        uint64_t v88 = v81 - v82;
        dyld4::BumpAllocator::zeroFill(v107, 8 * v85);
        size_t v89 = v87;
        uint64_t v8 = v107;
        memmove((void *)(*(void *)v107 + v88), v86, v89);
      }
    }
    int v90 = dyld4::PrebuiltObjC::serializeFixups(v103, (const dyld4::Loader *)v50, v8);
    int v91 = v90 - v64;
    if (!v90) {
      int v91 = 0;
    }
    uint64_t v92 = *(void *)v8 + v64;
    *(_DWORD *)(v92 + 56) = v91;
    *(_OWORD *)(v92 + 8) = *(_OWORD *)(v50 + 8);
    uint64_t v93 = *(void *)v8 + v64;
    *(_DWORD *)(v93 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((_DWORD *)v51 + 2);
    *(_DWORD *)(v93 + 88) = 0;
    uint64_t v110 = 0;
    __int16 v109 = 0;
    if (dyld4::JustInTimeLoader::overridesDylibInCache(v50, &v110, &v109))
    {
      uint64_t v94 = v110;
      if (v110)
      {
        uint64_t v95 = *((void *)v8 + 2) - *(void *)v8;
        *(_DWORD *)(*(void *)v8 + v64 + 88) = v95 - v64;
        if (*v94 == -1)
        {
          unint64_t v98 = 8;
        }
        else
        {
          uint64_t v96 = 1;
          do
            uint64_t v97 = v94[v96++];
          while (v97 != -1);
          unint64_t v98 = (v96 * 8);
        }
        dyld4::BumpAllocator::zeroFill(v8, v98);
        memmove((void *)(*(void *)v8 + v95), v94, v98);
      }
    }
LABEL_79:
    _Block_object_dispose(&v113, 8);
    uint64_t v120 = 0;
    if (v121) {
      vm_deallocate(mach_task_self_, v121, v122);
    }
  }
}

uint64_t dyld4::BumpAllocator::zeroFill(dyld4::BumpAllocator *this, unint64_t a2)
{
  vm_size_t v5 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2);
  uint64_t result = *(void *)this;
  if (v5 - v4 + result < a2)
  {
    unint64_t v7 = 0x100000;
    if (v5 > 0x100000) {
      unint64_t v7 = v5;
    }
    if (v7 < a2) {
      unint64_t v7 = (a2 & 0xFFFFFFFFFFF00000) + 0x100000;
    }
    vm_address_t address = 0;
    v5 += v7;
    vm_allocate(mach_task_self_, &address, v5, 1006632961);
    uint64_t result = address;
    if (!address) {
      dyld4::BumpAllocator::zeroFill();
    }
    uint64_t v8 = *((void *)this + 2);
    uint64_t v9 = v8 - *(void *)this;
    if (*(void *)this)
    {
      memmove((void *)address, *(const void **)this, v8 - *(void *)this);
      vm_deallocate(mach_task_self_, *(void *)this, *((void *)this + 1));
      uint64_t result = address;
    }
    uint64_t v4 = result + v9;
    *((void *)this + 1) = v5;
    *((void *)this + 2) = result + v9;
    *(void *)this = result;
  }
  unint64_t v10 = v4 + a2;
  if (v10 > result + v5) {
    dyld4::BumpAllocator::zeroFill();
  }
  *((void *)this + 2) = v10;
  return result;
}

void *dyld4::BumpAllocator::append(dyld4::BumpAllocator *this, const void *a2, unint64_t a3)
{
  uint64_t v6 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, a3);
  unint64_t v7 = (void *)(*(void *)this + v6);

  return memmove(v7, a2, a3);
}

dyld4::BumpAllocator *dyld4::BumpAllocator::align(dyld4::BumpAllocator *this, unsigned int a2)
{
  unint64_t v2 = (*((void *)this + 2) - *(void *)this) % (unint64_t)a2;
  if (v2) {
    return (dyld4::BumpAllocator *)dyld4::BumpAllocator::zeroFill(this, a2 - v2);
  }
  return this;
}

void *___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(dyld4::BumpAllocator **)(a1 + 32);
  uint64_t v5 = *((void *)v4 + 2);
  uint64_t v6 = *(void *)v4;
  if ((((_BYTE)v5 - *(void *)v4) & 7) != 0)
  {
    dyld4::BumpAllocator::zeroFill(v4, 8 - (((_BYTE)v5 - *(void *)v4) & 7));
    unint64_t v7 = *(uint64_t **)(a1 + 32);
    uint64_t v5 = v7[2];
    uint64_t v6 = *v7;
  }
  unint64_t v8 = v5 - *(void *)(a1 + 40) - v6;
  uint64_t v9 = **(void **)(a1 + 48) + *(void *)(a1 + 56);
  *(_WORD *)(v9 + 46) = v8;
  if (v8 >= 0x10000) {
    ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_cold_2();
  }
  *(_WORD *)(v9 + 44) = *(_WORD *)(v9 + 44) & 0xF | (16 * *(_WORD *)(a2 + 16));
  uint64_t v10 = *(void *)(a2 + 16);
  if (!v10) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v11 = *(dyld4::BumpAllocator **)(a1 + 32);
  uint64_t v12 = *(const void **)a2;
  size_t v13 = 16 * v10;
  uint64_t v14 = *((void *)v11 + 2) - *(void *)v11;
  dyld4::BumpAllocator::zeroFill(v11, 16 * v10);
  uint64_t v15 = (void *)(*(void *)v11 + v14);

  return memmove(v15, v12, v13);
}

double __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__4(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

uint64_t ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(&v10, *(vm_address_t **)(a1 + 32), a2);
  uint64_t result = Diagnostics::hasError(*(Diagnostics **)(a1 + 32));
  if (result)
  {
    *a3 = 1;
  }
  else
  {
    uint64_t v6 = *(dyld4::BumpAllocator **)(a1 + 40);
    uint64_t v7 = *((void *)v6 + 2) - *(void *)v6;
    uint64_t result = dyld4::BumpAllocator::zeroFill(v6, 8uLL);
    *(void *)(*(void *)v6 + v7) = v10;
    uint64_t v8 = **(void **)(a1 + 48) + *(void *)(a1 + 56);
    int v9 = *(_DWORD *)(v8 + 52);
    *(_DWORD *)(v8 + 52) = v9 + 1;
    if (v9 == -1) {
      ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51_cold_1();
    }
  }
  return result;
}

void *___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_2(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(&v9, *(vm_address_t **)(a1 + 40), a2);
  uint64_t result = (void *)Diagnostics::hasError(*(Diagnostics **)(a1 + 40));
  if (result)
  {
    *a3 = 1;
  }
  else
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v6 + 40), 1);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = *(void *)(v6 + 56);
    *(void *)(v6 + 56) = v8 + 1;
    *(void *)(v7 + 8 * v8) = v9;
  }
  return result;
}

void dyld4::PrebuiltLoader::withLayout(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4)
{
  uint64_t v6 = (dyld3::MachOLoaded *)dyld4::Loader::analyzer(a1, a3);

  dyld3::MachOAnalyzer::withVMLayout(v6, a2, a4);
}

uint64_t ___ZNK5dyld417PrebuiltLoaderSet7isValidERNS_12RuntimeStateE_block_invoke(void *a1, dyld3 *a2, unsigned char *a3)
{
  uint64_t v6 = a1[5];
  uint64_t result = dyld4::SyscallDelegate::fileExists(*(void *)(a1[6] + 8), a2, 0, 0);
  if (result)
  {
    if (*(unsigned char *)(*(void *)(a1[6] + 8) + 207)) {
      uint64_t result = dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because existence of file '%s' invalids the PrebuiltLoaderSet\n", v8, v6, a2);
    }
    *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

double __Block_byref_object_copy__64(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 88) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v3 = *(void *)(a2 + 88);
  *(void *)(a1 + 8dyld4::halt((char *)__format, 0) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v3;
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  uint64_t v4 = *(void *)(a2 + 128);
  *(void *)(a1 + 12dyld4::halt((char *)__format, 0) = *(void *)(a2 + 120);
  *(void *)(a1 + 128) = v4;
  *(void *)(a2 + 128) = 0;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return result;
}

uint64_t __Block_byref_object_dispose__65(uint64_t result)
{
  vm_address_t v1 = (void *)result;
  *(void *)(result + 112) = 0;
  vm_address_t v2 = *(void *)(result + 120);
  if (v2) {
    double result = vm_deallocate(mach_task_self_, v2, *(void *)(result + 128));
  }
  v1[9] = 0;
  vm_address_t v3 = v1[10];
  if (v3)
  {
    vm_map_t v4 = mach_task_self_;
    vm_size_t v5 = v1[11];
    return vm_deallocate(v4, v3, v5);
  }
  return result;
}

uint64_t ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8) + 40;
  vm_map_t v4 = a2;
  char v5 = 0;
  uint64_t result = dyld3::Map<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::insert(v2, &v4);
  *(unsigned char *)(result + 8) = 1;
  return result;
}

void ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke_2(uint64_t a1, dyld4::PrebuiltLoader::BindTargetRef *this, uint64_t a3)
{
  if (*(void *)(a3 + 16) != 1)
  {
    uint64_t v18 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(this, *(dyld4::RuntimeState **)(a1 + 40));
    if (dyld3::MapBase<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(*(void *)(*(void *)(a1 + 32) + 8) + 40, (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 56), (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 96), 0, &v18) == *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 96)+ 16 * *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 112))
    {
      if (!*(void *)(a3 + 16)) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
      }
      if ((***(void ***)a3 & 0x8000000000000000) != 0) {
        dyld4::PrebuiltLoader::BindTargetRef::loaderRef();
      }
      __int16 v17 = ***(void ***)a3;
      uint64_t v5 = dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v17, *(const dyld4::RuntimeState **)(a1 + 40));
      if (*(_WORD *)(v5 + 32)) {
        uint64_t v6 = (const char *)(v5 + *(unsigned __int16 *)(v5 + 32));
      }
      else {
        uint64_t v6 = 0;
      }
      if (!*(void *)(a3 + 16)) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
      }
      unint64_t v7 = dyld4::PrebuiltLoader::BindTargetRef::value(**(dyld4::PrebuiltLoader::BindTargetRef ***)a3, *(dyld4::RuntimeState **)(a1 + 40));
      uint64_t v8 = *(void *)(a3 + 16);
      if (v8 != 1)
      {
        unint64_t v9 = (const void *)v7;
        unint64_t v10 = (dyld4::PrebuiltLoader::BindTargetRef **)(*(void *)a3 + 8);
        uint64_t v11 = 8 * v8 - 8;
        do
        {
          uint64_t v12 = *v10;
          if ((*(void *)*v10 & 0x8000000000000000) != 0) {
            dyld4::PrebuiltLoader::BindTargetRef::loaderRef();
          }
          __int16 v16 = *(void *)*v10;
          uint64_t v13 = dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v16, *(const dyld4::RuntimeState **)(a1 + 40));
          if (*(_WORD *)(v13 + 32)) {
            uint64_t v14 = (const char *)(v13 + *(unsigned __int16 *)(v13 + 32));
          }
          else {
            uint64_t v14 = 0;
          }
          uint64_t v15 = (const void *)dyld4::PrebuiltLoader::BindTargetRef::value(v12, *(dyld4::RuntimeState **)(a1 + 40));
          dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 40), "Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.\n", v18, v6, v9, v14, v15);
          ++v10;
          v11 -= 8;
        }
        while (v11);
      }
    }
  }
}

vm_address_t dyld4::PrebuiltLoaderSet::makeLaunchSet(vm_address_t *this, Diagnostics *a2, dyld4::RuntimeState *a3, const dyld4::MissingPaths *a4)
{
  if (*((void *)a2 + 22)) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = *((void *)a2 + 30) == 0;
  }
  if (!v5 || *((void *)a2 + 38) != 0)
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that uses interposing", a3, a4);
    return 0;
  }
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp((dyld4::ProcessConfig::PathOverrides *)(*((void *)a2 + 1) + 400)))
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that uses DYLD_* env vars", v9, v10);
    return 0;
  }
  BOOL hasMissingFlatLazySymbols = dyld4::RuntimeState::hasMissingFlatLazySymbols(a2);
  if (hasMissingFlatLazySymbols)
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that has missing flat lazy symbols", v13, v14);
    return 0;
  }
  __chkstk_darwin(hasMissingFlatLazySymbols, v12, v13, v14, v15, v16, v17, v18, v73);
  unint64_t v22 = (char *)&v74[-1] - ((v21 + 23) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v23 = *((void *)a2 + 6);
  if (!v23)
  {
    unint64_t v25 = 0;
LABEL_29:
    uint64_t v73 = (uint64_t)&v73;
    dyld4::PrebuiltObjC::PrebuiltObjC((dyld4::PrebuiltObjC *)v99);
    dyld4::PrebuiltSwift::PrebuiltSwift((dyld4::PrebuiltSwift *)v94);
    Diagnostics::Diagnostics((Diagnostics *)v104);
    dyld4::PrebuiltObjC::make((dyld4::PrebuiltObjC *)v99, (Diagnostics *)v104, a2);
    if (!Diagnostics::hasError((Diagnostics *)v104))
    {
      Diagnostics::Diagnostics((Diagnostics *)&v76);
      dyld4::PrebuiltSwift::make((dyld4::PrebuiltSwift *)v94, (vm_address_t *)&v76, (dyld4::PrebuiltObjC *)v99, a2);
      mach_o::Error::~Error(&v76);
    }
    mach_o::Error::~Error((vm_address_t **)v104);
    uint64_t v86 = 0;
    uint64_t v87 = &v86;
    uint64_t v88 = 0x4002000000;
    size_t v89 = __Block_byref_object_copy__76;
    int v90 = __Block_byref_object_dispose__77;
    vm_address_t v91 = 0;
    vm_size_t v92 = 0;
    uint64_t v93 = 0;
    dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)&v91, 0x50uLL);
    uint64_t v34 = v87[5];
    uint64_t v33 = v87 + 5;
    *(void *)uint64_t v34 = 0x173A676E73703464;
    *(_DWORD *)(v34 + 12) = v25;
    *(_OWORD *)(v34 + 16) = xmmword_1A8E704F0;
    *(_OWORD *)(v34 + 4dyld4::halt((char *)__format, 0) = 0u;
    *(_OWORD *)(v34 + 56) = 0u;
    *(_DWORD *)(v34 + 72) = 0;
    dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 4 * v25);
    uint64_t v36 = *(DyldSharedCache **)(*((void *)a2 + 1) + 240);
    if (v36)
    {
      *(_DWORD *)(*v33 + 28) = *((_DWORD *)v87 + 14) - *((_DWORD *)v87 + 10);
      v104[0] = 0uLL;
      DyldSharedCache::getUUID(v36, v104);
      uint64_t v37 = v87 + 5;
      uint64_t v38 = v87[7] - v87[5];
      dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 0x10uLL);
      *(__n128 *)(*v37 + v38) = v104[0];
    }
    uint64_t v76 = 0;
    uint64_t v77 = &v76;
    uint64_t v78 = 0x5002000000;
    unint64_t v79 = __Block_byref_object_copy__78;
    vm_size_t v80 = __Block_byref_object_dispose__79;
    uint64_t v81 = v104;
    uint64_t v82 = 16;
    uint64_t v83 = 0;
    vm_address_t v84 = 0;
    vm_size_t v85 = 0;
    v75[0] = _NSConcreteStackBlock;
    v75[1] = 0x40000000;
    v75[2] = ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke;
    v75[3] = &unk_1EFF64F38;
    v75[4] = &v76;
    uint64_t v75[5] = this;
    if (v25)
    {
      uint64_t v39 = 0;
      while (1)
      {
        *(_DWORD *)(*v33 + *(unsigned int *)(*v33 + 16) + 4 * v39) = *((_DWORD *)v87 + 14) - *((_DWORD *)v87 + 10);
        dyld4::PrebuiltLoader::serialize(this, a2, *(const dyld4::Loader **)&v22[8 * v39], v39 & 0x7FFF | 0x8000, (uint64_t)v75, (dyld4::PrebuiltObjC *)v99, v35, (dyld4::BumpAllocator *)(v87 + 5));
        if (Diagnostics::hasError((Diagnostics *)this)) {
          break;
        }
        if (v25 == ++v39) {
          goto LABEL_37;
        }
      }
      vm_address_t v19 = 0;
    }
    else
    {
LABEL_37:
      if (v101)
      {
        if (v99[14])
        {
          *(_DWORD *)(*v33 + 4dyld4::halt((char *)__format, 0) = dyld4::PrebuiltObjC::serializeSelectorMap((dyld4::PrebuiltObjC *)v99, (dyld4::BumpAllocator *)(v87 + 5));
          int v40 = *((_DWORD *)v87 + 10);
          int v41 = *((_DWORD *)v87 + 14);
          uint64_t v42 = ((_BYTE)v41 - (_BYTE)v40) & 7;
          if ((((_BYTE)v41 - (_BYTE)v40) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 8 - v42);
          }
        }
        if (v99[26])
        {
          *(_DWORD *)(*v33 + 44) = dyld4::PrebuiltObjC::serializeClassMap((dyld4::PrebuiltObjC *)v99, (dyld4::BumpAllocator *)(v87 + 5));
          int v43 = *((_DWORD *)v87 + 10);
          int v44 = *((_DWORD *)v87 + 14);
          uint64_t v45 = ((_BYTE)v44 - (_BYTE)v43) & 7;
          if ((((_BYTE)v44 - (_BYTE)v43) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 8 - v45);
          }
        }
        if (v99[39])
        {
          *(_DWORD *)(*v33 + 48) = dyld4::PrebuiltObjC::serializeProtocolMap((dyld4::PrebuiltObjC *)v99, (dyld4::BumpAllocator *)(v87 + 5));
          int v46 = *((_DWORD *)v87 + 10);
          int v47 = *((_DWORD *)v87 + 14);
          uint64_t v48 = ((_BYTE)v47 - (_BYTE)v46) & 7;
          if ((((_BYTE)v47 - (_BYTE)v46) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 8 - v48);
          }
        }
        if (!v103) {
          std::__throw_bad_optional_access[abi:nn180100]();
        }
        uint64_t v49 = *v33;
        *(void *)(*v33 + 56) = v102;
        if (v100) {
          *(_DWORD *)(v49 + 52) |= 1u;
        }
      }
      if (v98)
      {
        if (v94[9])
        {
          uint64_t v50 = (dyld4::BumpAllocator *)(v87 + 5);
          *(_DWORD *)(*v33 + 64) = *((_DWORD *)v87 + 14) - *((_DWORD *)v87 + 10);
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize(v94, v50);
          int v51 = *((_DWORD *)v87 + 10);
          int v52 = *((_DWORD *)v87 + 14);
          uint64_t v53 = ((_BYTE)v52 - (_BYTE)v51) & 7;
          if ((((_BYTE)v52 - (_BYTE)v51) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 8 - v53);
          }
        }
        if (v95[9])
        {
          uint64_t v54 = (dyld4::BumpAllocator *)(v87 + 5);
          *(_DWORD *)(*v33 + 68) = *((_DWORD *)v87 + 14) - *((_DWORD *)v87 + 10);
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize(v95, v54);
          int v55 = *((_DWORD *)v87 + 10);
          int v56 = *((_DWORD *)v87 + 14);
          uint64_t v57 = ((_BYTE)v56 - (_BYTE)v55) & 7;
          if ((((_BYTE)v56 - (_BYTE)v55) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 8 - v57);
          }
        }
        if (v97)
        {
          long long v58 = (void *)v96[7];
          uint64_t v59 = 48 * v97;
          do
          {
            *long long v58 = 0;
            v58 += 6;
            v59 -= 48;
          }
          while (v59);
          int v60 = (dyld4::BumpAllocator *)(v87 + 5);
          *(_DWORD *)(*v33 + 72) = *((_DWORD *)v87 + 14) - *((_DWORD *)v87 + 10);
          dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::serialize(v96, v60);
          int v61 = *((_DWORD *)v87 + 10);
          int v62 = *((_DWORD *)v87 + 14);
          uint64_t v63 = ((_BYTE)v62 - (_BYTE)v61) & 7;
          if ((((_BYTE)v62 - (_BYTE)v61) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 8 - v63);
          }
        }
      }
      uint64_t v64 = v77;
      uint64_t v65 = v77[7];
      uint64_t v66 = v87;
      uint64_t v67 = (_DWORD *)*v33;
      if (v65)
      {
        v67[6] = *((_DWORD *)v87 + 14) - *((_DWORD *)v87 + 10);
        uint64_t v68 = v64[5];
        uint64_t v69 = 16 * (void)v65;
        do
        {
          vm_address_t v70 = v87 + 5;
          uint64_t v71 = v87[7] - v87[5];
          dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v87 + 5), 0x10uLL);
          long long v72 = *(_OWORD *)v68;
          v68 += 2;
          *(_OWORD *)(*v70 + v71) = v72;
          uint64_t v67 = (_DWORD *)*v33;
          ++*(_DWORD *)(*v33 + 20);
          v69 -= 16;
        }
        while (v69);
        uint64_t v66 = v87;
      }
      if (*((void *)a3 + 2) != *(void *)a3)
      {
        v67[9] = *((_DWORD *)v66 + 14) - *((_DWORD *)v66 + 10);
        v74[0] = _NSConcreteStackBlock;
        v74[1] = 0x40000000;
        void v74[2] = ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke_3;
        v74[3] = &unk_1EFF64F60;
        v74[4] = &v86;
        v74[5] = v33;
        v74[6] = 0;
        dyld4::MissingPaths::forEachPath((size_t)a3, (uint64_t)v74);
        uint64_t v66 = v87;
        uint64_t v67 = (_DWORD *)*v33;
      }
      v67[2] = *((_DWORD *)v66 + 14) - *((_DWORD *)v66 + 10);
      vm_address_t v19 = dyld4::BumpAllocator::finalize((dyld4::BumpAllocator *)(v87 + 5));
    }
    _Block_object_dispose(&v76, 8);
    uint64_t v83 = 0;
    if (v84) {
      vm_deallocate(mach_task_self_, v84, v85);
    }
    _Block_object_dispose(&v86, 8);
    if (v91) {
      vm_deallocate(mach_task_self_, v91, v92);
    }
    dyld4::PrebuiltSwift::~PrebuiltSwift((dyld4::PrebuiltSwift *)v94);
    dyld4::PrebuiltObjC::~PrebuiltObjC((dyld4::PrebuiltObjC *)v99);
    return v19;
  }
  int v24 = 0;
  unint64_t v25 = 0;
  __int16 v26 = (uint64_t *)*((void *)a2 + 5);
  uint64_t v27 = 8 * v23;
  uint64_t v28 = v26;
  while (1)
  {
    uint64_t v29 = *v28;
    __int16 v30 = *(_WORD *)(*v28 + 4);
    if (*v28 && (v30 & 1) == 0) {
      break;
    }
LABEL_26:
    ++v28;
    ++v26;
    v27 -= 8;
    if (!v27) {
      goto LABEL_29;
    }
  }
  if ((v30 & 2) != 0)
  {
    dyld4::JustInTimeLoader::path(v29);
    Diagnostics::error(this, "cannot make PrebuiltLoader for dylib that is in dyld cache (%s)");
    return 0;
  }
  if ((*(unsigned char *)(v29 + 42) & 0x40) == 0)
  {
    if (v25 >= v23) {
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    }
    *(void *)&v22[8 * v25++] = v29;
    __int16 v32 = v24++ | 0x8000;
    *(_WORD *)(v29 + 6) = v32;
    goto LABEL_26;
  }
  dyld4::JustInTimeLoader::path(v29);
  Diagnostics::error(this, "cannot make PrebuiltLoader for dylib that overrides dylib in dyld cache (%s)");
  return 0;
}

__n128 __Block_byref_object_copy__76(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt((char *)__format, 0) = result;
  return result;
}

uint64_t __Block_byref_object_dispose__77(uint64_t result)
{
  uint64_t v2 = (void *)(result + 40);
  vm_address_t v1 = *(void *)(result + 40);
  if (v1)
  {
    __n128 result = vm_deallocate(mach_task_self_, v1, *(void *)(result + 48));
    v2[1] = 0;
    unsigned int v2[2] = 0;
    *uint64_t v2 = 0;
  }
  return result;
}

double __Block_byref_object_copy__78(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt((char *)__format, 0) = 0u;
  *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt((char *)__format, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__79(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

double ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  *(void *)&long long v9 = __PAIR64__(a3, a2);
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((unint64_t *)&v9 + 1, *(vm_address_t **)(a1 + 40), a4);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(v5 + 40), 1);
  uint64_t v6 = *(void *)(v5 + 40);
  uint64_t v7 = *(void *)(v5 + 56);
  *(void *)(v5 + 56) = v7 + 1;
  double result = *(double *)&v9;
  *(_OWORD *)(v6 + 16 * v7) = v9;
  return result;
}

void *dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize(void *a1, dyld4::BumpAllocator *this)
{
  uint64_t v4 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v4) = *a1;
  uint64_t v5 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v5) = a1[1];
  unint64_t v6 = a1[4];
  uint64_t v7 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v7) = v6;
  uint64_t v8 = (const void *)a1[2];
  v6 *= 8;
  uint64_t v9 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v6);
  memmove((void *)(*(void *)this + v9), v8, v6);
  uint64_t v10 = a1[9];
  uint64_t v11 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v11) = v10;
  uint64_t v12 = (const void *)a1[7];
  unint64_t v13 = 32 * v10;
  uint64_t v14 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v13);
  uint64_t v15 = (void *)(*(void *)this + v14);

  return memmove(v15, v12, v13);
}

void *dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::serialize(void *a1, dyld4::BumpAllocator *this)
{
  uint64_t v4 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v4) = *a1;
  uint64_t v5 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v5) = a1[1];
  unint64_t v6 = a1[4];
  uint64_t v7 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v7) = v6;
  uint64_t v8 = (const void *)a1[2];
  v6 *= 8;
  uint64_t v9 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v6);
  memmove((void *)(*(void *)this + v9), v8, v6);
  uint64_t v10 = a1[9];
  uint64_t v11 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v11) = v10;
  uint64_t v12 = (const void *)a1[7];
  unint64_t v13 = 48 * v10;
  uint64_t v14 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v13);
  uint64_t v15 = (void *)(*(void *)this + v14);

  return memmove(v15, v12, v13);
}

size_t dyld4::MissingPaths::forEachPath(size_t result, uint64_t a2)
{
  uint64_t v2 = *(const char **)result;
  if (*(void *)result < *(void *)(result + 16))
  {
    size_t v4 = result;
    do
    {
      (*(void (**)(uint64_t, const char *))(a2 + 16))(a2, v2);
      double result = _platform_strlen(v2);
      v2 += result + 1;
    }
    while ((unint64_t)v2 < *(void *)(v4 + 16));
  }
  return result;
}

void *___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke_3(uint64_t a1, char *__s)
{
  size_t v4 = *(dyld4::BumpAllocator **)(*(void *)(a1 + 32) + 8);
  unint64_t v5 = _platform_strlen(__s) + 1;
  uint64_t v6 = *((void *)v4 + 5);
  size_t v4 = (dyld4::BumpAllocator *)((char *)v4 + 40);
  uint64_t v7 = *((void *)v4 + 2) - v6;
  dyld4::BumpAllocator::zeroFill(v4, v5);
  double result = memmove((void *)(*(void *)v4 + v7), __s, v5);
  uint64_t v9 = **(void **)(a1 + 40) + *(void *)(a1 + 48);
  ++*(_DWORD *)(v9 + 32);
  return result;
}

vm_address_t dyld4::BumpAllocator::finalize(dyld4::BumpAllocator *this)
{
  unint64_t v2 = *((void *)this + 1);
  vm_address_t v3 = *(void *)this;
  vm_size_t v4 = (~*(void *)this + *((void *)this + 2) + vm_page_size) & -(uint64_t)vm_page_size;
  if (v2 > v4)
  {
    vm_deallocate(mach_task_self_, v4 + v3, v2 - v4);
    *((void *)this + 1) = v4;
    *((void *)this + 2) = 0;
  }
  vm_protect(mach_task_self_, v3, v4, 0, 1);
  *(void *)this = 0;
  return v3;
}

uint64_t dyld4::PrebuiltLoaderSet::deallocate(vm_address_t address)
{
  return vm_deallocate(mach_task_self_, address, (vm_page_size + *(unsigned int *)(address + 8) - 1) & -(uint64_t)vm_page_size);
}

void *dyld4::MissingPaths::addPath(dyld4::MissingPaths *this, const char *__s)
{
  unint64_t v4 = _platform_strlen(__s) + 1;
  uint64_t v5 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v4);
  uint64_t v6 = (void *)(*(void *)this + v5);

  return memmove(v6, __s, v4);
}

dyld4::PrebuiltObjC *dyld4::PrebuiltObjC::PrebuiltObjC(dyld4::PrebuiltObjC *this)
{
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map((uint64_t)this + 40);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap((uint64_t)this + 136, 0);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap((uint64_t)this + 240, 0);
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 344);
  *((_WORD *)this + 22dyld4::halt((char *)__format, 0) = 0;
  *((unsigned char *)this + 448) = 0;
  *((unsigned char *)this + 456) = 0;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 3dyld4::halt((char *)__format, 0) = 0u;
  *((void *)this + 62) = 0;
  return this;
}

uint64_t dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  uint64_t v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve((void *)(a1 + 56), 0x20uLL);
  return a1;
}

uint64_t dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  int v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1);
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v7 + 1;
    *(void *)(v6 + 8 * v7) = -1;
    --v5;
  }
  while (v5);
  dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve((void *)(a1 + 56), 0x20uLL);
  *(void *)(a1 + 96) = a2;
  return a1;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 56 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    double result = memmove((void *)v3[3], *v3, 56 * (void)v3[2]);
    unint64_t v8 = (unint64_t)v3[4] / 0x38;
    char *v3 = v3[3];
    v3[1] = (const void *)v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

dyld4::PrebuiltSwift *dyld4::PrebuiltSwift::PrebuiltSwift(dyld4::PrebuiltSwift *this)
{
  uint64_t v2 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap((uint64_t)this, 0);
  dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(v2 + 104, 0);
  dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap((uint64_t)this + 208, 0);
  *((unsigned char *)this + 312) = 0;
  return this;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  vm_address_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  int v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1);
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v7 + 1;
    *(void *)(v6 + 8 * v7) = -1;
    --v5;
  }
  while (v5);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve((void *)(a1 + 56), 0x20uLL);
  *(void *)(a1 + 96) = a2;
  return a1;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  vm_address_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt((char *)__format, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  int v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1);
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v7 + 1;
    *(void *)(v6 + 8 * v7) = -1;
    --v5;
  }
  while (v5);
  dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve((void *)(a1 + 56), 0x20uLL);
  *(void *)(a1 + 96) = a2;
  return a1;
}

void dyld4::PrebuiltSwift::~PrebuiltSwift(dyld4::PrebuiltSwift *this)
{
  *((void *)this + 35) = 0;
  vm_address_t v2 = *((void *)this + 36);
  if (v2) {
    vm_deallocate(mach_task_self_, v2, *((void *)this + 37));
  }
  *((void *)this + 3dyld4::halt((char *)__format, 0) = 0;
  vm_address_t v3 = *((void *)this + 31);
  if (v3) {
    vm_deallocate(mach_task_self_, v3, *((void *)this + 32));
  }
  *((void *)this + 22) = 0;
  vm_address_t v4 = *((void *)this + 23);
  if (v4) {
    vm_deallocate(mach_task_self_, v4, *((void *)this + 24));
  }
  *((void *)this + 17) = 0;
  vm_address_t v5 = *((void *)this + 18);
  if (v5) {
    vm_deallocate(mach_task_self_, v5, *((void *)this + 19));
  }
  *((void *)this + 9) = 0;
  vm_address_t v6 = *((void *)this + 10);
  if (v6) {
    vm_deallocate(mach_task_self_, v6, *((void *)this + 11));
  }
  *((void *)this + 4) = 0;
  vm_address_t v7 = *((void *)this + 5);
  if (v7) {
    vm_deallocate(mach_task_self_, v7, *((void *)this + 6));
  }
}

void dyld4::PrebuiltObjC::~PrebuiltObjC(dyld4::PrebuiltObjC *this)
{
  if (*((void *)this + 60))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *((void *)this + 58);
      vm_address_t v5 = (void *)(v4 + v2);
      *(void *)(v4 + v2 + 136) = 0;
      vm_address_t v6 = *(void *)(v4 + v2 + 144);
      if (v6) {
        vm_deallocate(mach_task_self_, v6, v5[19]);
      }
      v5[12] = 0;
      vm_address_t v7 = v5[13];
      if (v7) {
        vm_deallocate(mach_task_self_, v7, *(void *)(v4 + v2 + 112));
      }
      ++v3;
      v2 += 160;
    }
    while (v3 != *((void *)this + 60));
  }
  *((void *)this + 6dyld4::halt((char *)__format, 0) = 0;
  vm_address_t v8 = *((void *)this + 61);
  if (v8) {
    vm_deallocate(mach_task_self_, v8, *((void *)this + 62));
  }
  *((void *)this + 52) = 0;
  vm_address_t v9 = *((void *)this + 53);
  if (v9) {
    vm_deallocate(mach_task_self_, v9, *((void *)this + 54));
  }
  *((void *)this + 47) = 0;
  vm_address_t v10 = *((void *)this + 48);
  if (v10) {
    vm_deallocate(mach_task_self_, v10, *((void *)this + 49));
  }
  *((void *)this + 39) = 0;
  vm_address_t v11 = *((void *)this + 40);
  if (v11) {
    vm_deallocate(mach_task_self_, v11, *((void *)this + 41));
  }
  *((void *)this + 34) = 0;
  vm_address_t v12 = *((void *)this + 35);
  if (v12) {
    vm_deallocate(mach_task_self_, v12, *((void *)this + 36));
  }
  *((void *)this + 26) = 0;
  vm_address_t v13 = *((void *)this + 27);
  if (v13) {
    vm_deallocate(mach_task_self_, v13, *((void *)this + 28));
  }
  *((void *)this + 21) = 0;
  vm_address_t v14 = *((void *)this + 22);
  if (v14) {
    vm_deallocate(mach_task_self_, v14, *((void *)this + 23));
  }
  *((void *)this + 14) = 0;
  vm_address_t v15 = *((void *)this + 15);
  if (v15) {
    vm_deallocate(mach_task_self_, v15, *((void *)this + 16));
  }
  *((void *)this + 9) = 0;
  vm_address_t v16 = *((void *)this + 10);
  if (v16) {
    vm_deallocate(mach_task_self_, v16, *((void *)this + 11));
  }
  if (*((void *)this + 2))
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    do
    {
      dyld4::PrebuiltObjC::ObjCOptimizerImage::~ObjCOptimizerImage((dyld4::PrebuiltObjC::ObjCOptimizerImage *)(*(void *)this + v17));
      ++v18;
      v17 += 568;
    }
    while (v18 != *((void *)this + 2));
  }
  *((void *)this + 2) = 0;
  vm_address_t v19 = *((void *)this + 3);
  if (v19) {
    vm_deallocate(mach_task_self_, v19, *((void *)this + 4));
  }
}

void dyld4::PrebuiltObjC::ObjCOptimizerImage::~ObjCOptimizerImage(dyld4::PrebuiltObjC::ObjCOptimizerImage *this)
{
  *((void *)this + 58) = 0;
  vm_address_t v2 = *((void *)this + 59);
  if (v2) {
    vm_deallocate(mach_task_self_, v2, *((void *)this + 60));
  }
  *((void *)this + 53) = 0;
  vm_address_t v3 = *((void *)this + 54);
  if (v3) {
    vm_deallocate(mach_task_self_, v3, *((void *)this + 55));
  }
  *((void *)this + 46) = 0;
  vm_address_t v4 = *((void *)this + 47);
  if (v4) {
    vm_deallocate(mach_task_self_, v4, *((void *)this + 48));
  }
  *((void *)this + 41) = 0;
  vm_address_t v5 = *((void *)this + 42);
  if (v5) {
    vm_deallocate(mach_task_self_, v5, *((void *)this + 43));
  }
  *((void *)this + 36) = 0;
  vm_address_t v6 = *((void *)this + 37);
  if (v6) {
    vm_deallocate(mach_task_self_, v6, *((void *)this + 38));
  }
  *((void *)this + 29) = 0;
  vm_address_t v7 = *((void *)this + 30);
  if (v7) {
    vm_deallocate(mach_task_self_, v7, *((void *)this + 31));
  }
  *((void *)this + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  vm_address_t v8 = *((void *)this + 25);
  if (v8) {
    vm_deallocate(mach_task_self_, v8, *((void *)this + 26));
  }
  *((void *)this + 17) = 0;
  vm_address_t v9 = *((void *)this + 18);
  if (v9) {
    vm_deallocate(mach_task_self_, v9, *((void *)this + 19));
  }
  *((void *)this + 12) = 0;
  vm_address_t v10 = *((void *)this + 13);
  if (v10) {
    vm_deallocate(mach_task_self_, v10, *((void *)this + 14));
  }
  *((void *)this + 7) = 0;
  vm_address_t v11 = *((void *)this + 8);
  if (v11) {
    vm_deallocate(mach_task_self_, v11, *((void *)this + 9));
  }
  mach_o::Error::~Error((vm_address_t **)this + 4);
}

uint64_t dyld3::Map<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::insert(uint64_t a1, const char **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0;
    memset(v26, 0, sizeof(v26));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v26, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v26, 1);
      uint64_t v6 = (*(void *)&v26[1])++;
      *(_DWORD *)(*(void *)&v26[0] + 4 * v6) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0;
      do
      {
        vm_address_t v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v7);
        size_t v9 = _platform_strlen(v8);
        unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v28, (uint64_t *)v8, v9);
        unint64_t v11 = (*(void *)&v26[1] - 1) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) != -1)
        {
          uint64_t v12 = 1;
          do
            unint64_t v11 = (*(void *)&v26[1] - 1) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) = v7++;
      }
      while (v7 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v26)
    {
      *(void *)&v26[1] = 0;
      if (*((void *)&v26[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v26[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v13 = *(void *)(a1 + 40);
      if (v13) {
        vm_deallocate(mach_task_self_, v13, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v26[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v26 + 8);
      vm_size_t v14 = size;
      *(void *)(a1 + 4dyld4::halt((char *)__format, 0) = *((void *)&v26[1] + 1);
      *(void *)(a1 + 48) = v14;
    }
  }
  vm_address_t v15 = (char *)*a2;
  size_t v16 = _platform_strlen(*a2);
  unint64_t v17 = (*(void *)(a1 + 32) - 1) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v26, (uint64_t *)v15, v16);
  unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
  if (v18 == -1)
  {
LABEL_20:
    uint64_t v21 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17) = v21;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v23 + 1;
    *(_OWORD *)(v22 + 16 * v23) = *(_OWORD *)a2;
    uint64_t v24 = *(void *)(a1 + 72);
    if (!v24) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 16 * v24 - 16;
  }
  else
  {
    uint64_t v19 = 1;
    while (1)
    {
      unint64_t v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v18);
      if (!_platform_strcmp(*v20, *a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v18);
      }
      unint64_t v17 = (*(void *)(a1 + 32) - 1) & (v17 + v19++);
      unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
      if (v18 == -1) {
        goto LABEL_20;
      }
    }
  }
}

uint64_t dyld3::MapBase<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return *a3;
  }
  vm_address_t v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v22, (uint64_t *)v8, v9);
  unint64_t v11 = a2[2];
  unint64_t v12 = v11 - 1;
  unint64_t v13 = v10 & (v11 - 1);
  if (v11 <= v13) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v14 = *a2;
  unint64_t v15 = a3[2];
  uint64_t v16 = *a3;
  uint64_t v17 = 1;
  unint64_t v18 = *a5;
  while (1)
  {
    unint64_t v19 = *(unsigned int *)(v14 + 4 * v13);
    if (v19 == -1) {
      return v16 + 16 * v15;
    }
    if (v15 <= v19) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    if (!_platform_strcmp(*(const char **)(v16 + 16 * v19), v18)) {
      return v16 + 16 * v19;
    }
    unint64_t v20 = v13 + v17++;
    unint64_t v13 = v20 & v12;
    if (v11 <= (v20 & v12)) {
      goto LABEL_8;
    }
  }
}

BOOL dyld4::SyscallDelegate::getCWD(dyld4::SyscallDelegate *this, char *a2)
{
  int v3 = open(".", 0x100000, 0);
  if (v3 == -1) {
    return 0;
  }
  int v4 = v3;
  int v5 = fcntl(v3, 50, a2);
  close(v4);
  return v5 != -1;
}

uint64_t dyld4::SyscallDelegate::openLogFile(dyld4::SyscallDelegate *this, const char *a2)
{
  return open(a2, 521, 420);
}

uint64_t dyld4::SyscallDelegate::dtraceRegisterUserProbes(dyld4::SyscallDelegate *this, dof_ioctl_data *a2)
{
  uint64_t result = open("/dev/dtracehelper", 2);
  if (result != -1)
  {
    int v4 = result;
    int v5 = a2;
    ioctl(result, 0x80086804uLL, &v5);
    return close(v4);
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::dtraceUnregisterUserProbe(dyld4::SyscallDelegate *this, uint64_t a2)
{
  uint64_t result = open("/dev/dtracehelper", 2, 0);
  if (result != -1)
  {
    int v4 = result;
    ioctl(result, 0x20006802uLL, a2);
    return close(v4);
  }
  return result;
}

BOOL dyld4::SyscallDelegate::hasExistingDyldCache(dyld4::SyscallDelegate *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  int v7 = __shared_region_check_np(a2);
  if (!v7)
  {
    unint64_t v8 = *(void *)(*a2 + 496) + *a2;
    if (_platform_strncmp((const char *)v8, "dyld_data    v0", 0x10uLL))
    {
      unint64_t v9 = 0;
      *a3 = 0;
    }
    else
    {
      *a3 = *(void *)(v8 + 16);
      unint64_t v9 = *(void *)(v8 + 24);
    }
    *a4 = v9;
  }
  return v7 == 0;
}

uint64_t dyld4::SyscallDelegate::forEachInDirectory(int a1, char *a2, int a3, uint64_t a4)
{
  uint64_t result = open(a2, 0x100000, 0);
  if (result != -1)
  {
    int v8 = result;
    bzero(v14, 0x18uLL);
    v14[0] = 5;
    int v15 = -2147483639;
    int v9 = getattrlistbulk(v8, v14, v17, 0x200uLL, 0);
    if (v9 < 1) {
      return close(v8);
    }
    int v10 = v9;
    while (1)
    {
      unint64_t v11 = v17;
      do
      {
        uint64_t v12 = *((int *)v11 + 6);
        if ((v11[4] & 8) == 0) {
          goto LABEL_15;
        }
        unsigned int v13 = *((_DWORD *)v11 + 8);
        if (v13 == 2)
        {
          if (!a3) {
            goto LABEL_15;
          }
        }
        else if (v13 != 1 || (a3 & 1) != 0)
        {
          goto LABEL_15;
        }
        v16[0] = 0;
        if (dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, a2, (const char *)0x400) > 0x3FF
          || dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, "/", (const char *)0x400) > 0x3FF
          || dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, &v11[v12 + 24], (const char *)0x400) > 0x3FF)
        {
          return close(v8);
        }
        (*(void (**)(uint64_t, unsigned char *, char *))(a4 + 16))(a4, v16, &v11[v12 + 24]);
LABEL_15:
        v11 += *(unsigned int *)v11;
        --v10;
      }
      while (v10);
      int v10 = getattrlistbulk(v8, v14, v17, 0x200uLL, 0);
      if (v10 <= 0) {
        return close(v8);
      }
    }
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::getDylibInfo(int a1, dyld3 *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x3002000000;
  uint64_t v23 = __Block_byref_object_copy__5;
  uint64_t v24 = __Block_byref_object_dispose__5;
  Diagnostics::Diagnostics((Diagnostics *)&v25);
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  _WORD v14[2] = ___ZNK5dyld415SyscallDelegate12getDylibInfoEPKcN5dyld38PlatformERKNS3_11GradedArchsERjPc_block_invoke;
  void v14[3] = &unk_1EFF64F88;
  int v15 = a3;
  void v14[6] = a4;
  void v14[7] = a2;
  unsigned __int8 v14[8] = a5;
  v14[9] = a6;
  _OWORD v14[4] = &v20;
  void v14[5] = &v16;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(a1, (vm_address_t *)v21 + 5, a2, 0, (uint64_t)v14);
  uint64_t v12 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  mach_o::Error::~Error(&v25);
  return v12;
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::halt((char *)__format, 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

uint64_t ___ZNK5dyld415SyscallDelegate12getDylibInfoEPKcN5dyld38PlatformERKNS3_11GradedArchsERjPc_block_invoke(uint64_t a1, dyld3::FatFile *this, unint64_t a3)
{
  int v3 = this;
  BOOL v10 = 0;
  unint64_t v8 = a3;
  unint64_t v9 = 0;
  if (dyld3::FatFile::isFatFileWithSlice(this, (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a3, *(const dyld3::GradedArchs **)(a1 + 48), 1, &v9, &v8, &v10))
  {
    int v3 = (dyld3::MachOFile *)((char *)v3 + v9);
  }
  else
  {
    uint64_t result = dyld3::MachOFile::isMachO(v3, (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v8);
    if (!result) {
      return result;
    }
  }
  uint64_t result = dyld3::MachOFile::isDylib(v3);
  if (result)
  {
    uint64_t result = dyld3::MachOFile::loadableIntoProcess(v3, *(_DWORD *)(a1 + 80), *(const char **)(a1 + 56), 0);
    if (result)
    {
      *(void *)uint64_t v6 = 0;
      __source = 0;
      uint64_t result = dyld3::MachOFile::getDylibInstallName(v3, (const char **)&__source, &v6[1], v6);
      if (result)
      {
        **(_DWORD **)(a1 + 64) = v6[0];
        uint64_t result = strlcpy(*(char **)(a1 + 72), __source, 0x400uLL);
        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      }
    }
  }
  return result;
}

BOOL dyld4::SyscallDelegate::dirExists(dyld4::SyscallDelegate *this, dyld3 *a2, stat *a3)
{
  return !dyld3::stat(a2, &v5, a3) && (v5.st_mode & 0xF000) == 0x4000;
}

BOOL dyld4::SyscallDelegate::mkdirs(dyld4::SyscallDelegate *this, const char *__s)
{
  size_t v3 = _platform_strlen(__s);
  __chkstk_darwin(v3, v4, v5, v6, v7, v8, v9, v10, v19);
  uint64_t v12 = (char *)&v19 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0);
  strcpy(v12, __s);
  unsigned int v13 = strrchr(v12, 47);
  int v15 = v13;
  if (v13)
  {
    v13[1] = 0;
    if (dyld3::stat((dyld3 *)v12, &v20, v14))
    {
      uint64_t v16 = _platform_strchr(v12 + 1, 47);
      if (v16)
      {
        uint64_t v17 = v16;
        do
        {
          *uint64_t v17 = 0;
          mkdir(v12, 0x1EDu);
          *uint64_t v17 = 47;
          uint64_t v17 = _platform_strchr(v17 + 1, 47);
        }
        while (v17);
      }
    }
  }
  return v15 != 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedStat(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2 = a2;
  pid_t v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-read-metadata", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedOpen(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2 = a2;
  pid_t v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-read-data", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

uint64_t ___ZNK5dyld415SyscallDelegate15mapFileReadOnlyER11DiagnosticsPKcPmPNS_6FileIDEPbPc_block_invoke(uint64_t result, int a2, int a3, dyld3::MachOAnalyzer *this)
{
  if (a2 == 16777228 && (a3 & 0xFFFFFF) == 2)
  {
    uint64_t v5 = result;
    uint64_t result = dyld3::MachOAnalyzer::isOSBinary(this, *(_DWORD *)(result + 48), (uint64_t)this - *(void *)(result + 32));
    if (result) {
      **(unsigned char **)(v5 + 4dyld4::halt((char *)__format, 0) = 1;
    }
  }
  return result;
}

uint64_t dyld4::SyscallDelegate::unmapFile(dyld4::SyscallDelegate *this, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

BOOL dyld4::SyscallDelegate::setFileAttribute(int a1, char *a2, const char *a3, uint64_t a4)
{
  if (chmod(a2, 0x180u)) {
    return 0;
  }
  if (setxattr(a2, a3, *(const void **)a4, *(void *)(a4 + 16), 0, 4)) {
    BOOL v8 = setxattr(a2, a3, *(const void **)a4, *(void *)(a4 + 16), 0, 0) == 0;
  }
  else {
    BOOL v8 = 1;
  }
  return !chmod(a2, 0x100u) && v8;
}

uint64_t dyld4::SyscallDelegate::saveFileWithAttribute(int a1, vm_address_t *a2, const std::__fs::filesystem::path *__source, const void *a4, size_t a5, const char *a6, uint64_t a7)
{
  strlcpy((char *)__dst, (const char *)__source, 0x400uLL);
  unsigned int v13 = getpid();
  __sourcea[0] = 46;
  if (HIBYTE(v13) >= 0xA0u) {
    char v14 = 55;
  }
  else {
    char v14 = 48;
  }
  __sourcea[1] = v14 + (v13 >> 28);
  unsigned int v15 = HIBYTE(v13) & 0xF;
  if (v15 >= 0xA) {
    char v16 = 55;
  }
  else {
    char v16 = 48;
  }
  __sourcea[2] = v16 + v15;
  if (BYTE2(v13) >= 0xA0u) {
    char v17 = 55;
  }
  else {
    char v17 = 48;
  }
  __sourcea[3] = v17 + ((v13 >> 20) & 0xF);
  if ((HIWORD(v13) & 0xF) >= 0xAu) {
    char v18 = 55;
  }
  else {
    char v18 = 48;
  }
  __sourcea[4] = v18 + (BYTE2(v13) & 0xF);
  if (BYTE1(v13) >= 0xA0u) {
    char v19 = 55;
  }
  else {
    char v19 = 48;
  }
  __sourcea[5] = v19 + ((unsigned __int16)v13 >> 12);
  unsigned int v20 = (v13 >> 8) & 0xF;
  if (v20 >= 0xA) {
    char v21 = 55;
  }
  else {
    char v21 = 48;
  }
  __sourcea[6] = v21 + v20;
  if (v13 >= 0xA0u) {
    char v22 = 55;
  }
  else {
    char v22 = 48;
  }
  __sourcea[7] = v22 + ((v13 & 0xF0) >> 4);
  if ((v13 & 0xF) >= 0xA) {
    char v23 = 55;
  }
  else {
    char v23 = 48;
  }
  __sourcea[8] = v23 + (v13 & 0xF);
  __sourcea[9] = 0;
  strlcat((char *)__dst, __sourcea, 0x400uLL);
  int v24 = open_dprotected_np((const char *)__dst, 513, 4, 0, 384);
  if (v24 == -1)
  {
    __error();
    Diagnostics::error(a2, "open/open_dprotected_np(%s) failed, errno=%d");
  }
  else
  {
    int v25 = v24;
    if (ftruncate(v24, a5) == -1)
    {
      __error();
      Diagnostics::error(a2, "ftruncate(%lu) failed, errno=%d");
    }
    else if (write(v25, a4, a5) == a5)
    {
      if (fsetxattr(v25, a6, *(const void **)a7, *(void *)(a7 + 16), 0, 0) == -1)
      {
        __error();
        Diagnostics::error(a2, "fsetxattr(%s) failed, errno=%d");
      }
      else if (fchmod(v25, 0x100u) == -1)
      {
        __error();
        Diagnostics::error(a2, "fchmod(S_IRUSR) failed, errno=%d");
      }
      else if (close(v25) == -1)
      {
        __error();
        Diagnostics::error(a2, "close() failed, errno=%d");
      }
      else
      {
        rename(__dst, __source, v26);
        if (v27 != -1) {
          return 1;
        }
        __error();
        Diagnostics::error(a2, "rename(%s, %s) failed, errno=%d");
      }
    }
    else
    {
      __error();
      Diagnostics::error(a2, "write() failed, errno=%d");
    }
  }
  return 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedMmap(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2 = a2;
  pid_t v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-map-executable", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

uint64_t dyld4::SyscallDelegate::setDyldCommPageFlags(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return sysctlbyname("kern.dyld_flags", 0, 0, &v3, 8uLL);
}

BOOL dyld4::SyscallDelegate::bootVolumeWritable(dyld4::SyscallDelegate *this)
{
  return statfs64("/", &v2)
      || *(_DWORD *)v2.f_fstypename ^ 0x73667061 | v2.f_fstypename[4]
      || (~v2.f_flags & 0x40000001) != 0;
}

ssize_t dyld4::SyscallDelegate::pread(dyld4::SyscallDelegate *this, int __fd, void *__buf, size_t __nbyte, off_t a5)
{
  return pread(__fd, __buf, __nbyte, a5);
}

uint64_t dyld4::SyscallDelegate::unlink(dyld4::SyscallDelegate *this, const char *a2)
{
  return unlink(a2);
}

uint64_t dyld4::SyscallDelegate::socket(dyld4::SyscallDelegate *this, int a2, int a3, int a4)
{
  return socket(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::connect(dyld4::SyscallDelegate *this, int a2, const sockaddr *a3, socklen_t a4)
{
  return connect(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::vm_protect(dyld4::SyscallDelegate *this, vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return vm_protect(target_task, address, size, set_maximum, new_protection);
}

uint64_t dyld4::SyscallDelegate::mremap_encrypted(dyld4::SyscallDelegate *this, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mremap_encrypted(a2, a3, a4, a5, a6, a6, a7, a8);
}

uint64_t PatchTable::patchableExportCount(int **this, unsigned int a2)
{
  statfs v2 = *this;
  int v3 = **this;
  if ((v3 == 4 || v3 == 3 || v3 == 2) && *((void *)v2 + 2) > (unint64_t)a2) {
    return *(unsigned int *)((char *)&v2[4 * a2 + 3] + *((void *)v2 + 1) - (void)this[1]);
  }
  else {
    return 0;
  }
}

BOOL PatchTable::imageHasClient(PatchTable *this, unsigned int a2, int a3)
{
  return (**(_DWORD **)this - 2) <= 2 && PatchTableV2::imageHasClient(this, a2, a3);
}

BOOL PatchTableV2::imageHasClient(PatchTableV2 *this, unsigned int a2, int a3)
{
  uint64_t v3 = *(void *)this;
  if (*(void *)(*(void *)this + 16) <= (unint64_t)a2) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = (unsigned int *)(v3 + *(void *)(v3 + 8) - v4 + 16 * a2);
  unsigned int v6 = v5[1];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = (int *)(v3 + *(void *)(v3 + 40) - v4 + 12 * *v5);
  uint64_t v8 = 12 * v6 - 12;
  do
  {
    int v9 = *v7;
    v7 += 3;
    BOOL result = v9 == a3;
    BOOL v11 = v9 == a3 || v8 == 0;
    v8 -= 12;
  }
  while (!v11);
  return result;
}

void *PatchTable::forEachPatchableExport(void *result, unsigned int a2, uint64_t a3)
{
  if ((*(_DWORD *)*result - 2) <= 2) {
    return PatchTableV2::forEachPatchableExport(result, a2, a3);
  }
  return result;
}

void *PatchTableV2::forEachPatchableExport(void *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = (void *)*result;
  if (*(void *)(*result + 16) > (unint64_t)a2)
  {
    uint64_t v4 = result[1];
    uint64_t v5 = (uint64_t)&v3[2 * a2] + v3[1] - v4;
    uint64_t v6 = *(unsigned int *)(v5 + 12);
    if (v6)
    {
      unint64_t v8 = v3[12];
      int v9 = (char *)v3 + v3[11] - v4;
      uint64_t v10 = (_DWORD *)((char *)v3 + v3[3] + 8 * *(unsigned int *)(v5 + 8) - v4 + 4);
      uint64_t v11 = 8 * v6;
      do
      {
        if (v8 < (*v10 & 0xFFFFFFFu)) {
          abort();
        }
        BOOL result = (void *)(*(uint64_t (**)(uint64_t, void, char *, void))(a3 + 16))(a3, *(v10 - 1), &v9[*v10 & 0xFFFFFFF], *v10 >> 28);
        v10 += 2;
        v11 -= 8;
      }
      while (v11);
    }
  }
  return result;
}

PatchTableV2 *PatchTable::forEachPatchableUseOfExportInImage(PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  int v5 = **(_DWORD **)a1;
  if (v5 == 4) {
    return (PatchTableV2 *)PatchTableV4::forEachPatchableUseOfExportInImage(a1, a2, a3, a4, a5);
  }
  if (v5 == 3 || v5 == 2) {
    return (PatchTableV2 *)PatchTableV2::forEachPatchableUseOfExportInImage(a1, a2, a3, a4, a5);
  }
  return a1;
}

char *PatchTableV2::forEachPatchableUseOfExportInImage(PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *((void *)a1 + 1);
  uint64_t v9 = *(void *)(*(void *)a1 + 24);
  uint64_t v10 = *(void *)(*(void *)a1 + 72);
  BOOL result = PatchTableV2::clientsExportsForImageAndClient(a1, a2, a4);
  if (v12)
  {
    unsigned int v13 = (unsigned int *)(result + 8);
    uint64_t v14 = 12 * v12;
    while (*(_DWORD *)(v7 + v9 - v8 + 8 * *(v13 - 2)) != a3)
    {
      v13 += 3;
      v14 -= 12;
      if (!v14) {
        return result;
      }
    }
    uint64_t v15 = *v13;
    if (v15)
    {
      char v16 = (unsigned int *)(v10 + 8 * *(v13 - 1) - v8 + v7 + 4);
      uint64_t v17 = 8 * v15;
      do
      {
        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v19);
        int8x16_t v18 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(*v16), (uint32x4_t)xmmword_1A8E70500), (int8x16_t)xmmword_1A8E70510);
        *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
        unsigned __int32 v19 = v18.i32[0] | v19 & 0xF0000000 | v18.i32[1] | HIWORD(*v16);
        BOOL result = (char *)(*(uint64_t (**)(uint64_t, void))(a5 + 16))(a5, *(v16 - 1));
        v16 += 2;
        v17 -= 8;
      }
      while (v17);
    }
  }
  return result;
}

char *PatchTableV4::forEachPatchableUseOfExportInImage(PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *((void *)a1 + 1);
  uint64_t v9 = *(void *)(*(void *)a1 + 24);
  uint64_t v10 = *(void *)(*(void *)a1 + 72);
  BOOL result = PatchTableV2::clientsExportsForImageAndClient(a1, a2, a4);
  if (v12)
  {
    unsigned int v13 = (unsigned int *)(result + 8);
    uint64_t v14 = 12 * v12;
    while (*(_DWORD *)(v7 + v9 - v8 + 8 * *(v13 - 2)) != a3)
    {
      v13 += 3;
      v14 -= 12;
      if (!v14) {
        return result;
      }
    }
    uint64_t v15 = *v13;
    if (v15)
    {
      char v16 = (unsigned int *)(v7 + v10 - v8 + 8 * *(v13 - 1));
      uint64_t v17 = &v16[2 * v15];
      do
      {
        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v21);
        dyld_cache_patchable_location_v4::getPMD((uint64_t)v16, &v21);
        uint64_t v18 = *v16;
        unsigned int v19 = v16[1];
        v16 += 2;
        if (v19) {
          uint64_t v20 = (v19 >> 9) & 0x1F;
        }
        else {
          uint64_t v20 = v19 >> 9;
        }
        BOOL result = (char *)(*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void))(a5 + 16))(a5, v18, v21, v20, (v19 >> 8) & 1);
      }
      while (v16 != v17);
    }
  }
  return result;
}

void *PatchTable::forEachPatchableCacheUseOfExport(void *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6 = *(_DWORD *)*result;
  if (v6 == 4) {
    return PatchTableV4::forEachPatchableCacheUseOfExport(result, a2, a3, a4, a5, a6);
  }
  if (v6 == 3 || v6 == 2) {
    return PatchTableV2::forEachPatchableCacheUseOfExport(result, a2, a3, a4, a5, a6);
  }
  return result;
}

void *PatchTableV2::forEachPatchableCacheUseOfExport(void *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (void *)*result;
  if (*(void *)(*result + 16) > (unint64_t)a2)
  {
    uint64_t v9 = result[1];
    uint64_t v10 = (unsigned int *)((char *)&v8[2 * a2] + v8[1] - v9);
    unsigned int v12 = *v10;
    uint64_t v11 = v10[1];
    unsigned int v13 = (unsigned int *)((char *)v8 + 12 * v12 + v8[5] - v9);
    if (v11)
    {
      uint64_t v14 = (char *)v8 + v8[3] - v9;
      int v25 = (char *)v8 + v8[7] - v9;
      __int16 v30 = (char *)v8 + v8[9] - v9;
      int v27 = &v13[3 * v11];
      do
      {
        BOOL result = (void *)(*(uint64_t (**)(uint64_t, void))(a5 + 16))(a5, *v13);
        uint64_t v29 = v13;
        unsigned int v15 = v13[2];
        if (v15)
        {
          char v16 = (unsigned int *)&v25[12 * v13[1]];
          uint64_t v17 = &v16[3 * v15];
          uint64_t v18 = (char *)result - a4;
          do
          {
            if (*(_DWORD *)&v14[8 * *v16] == a3)
            {
              uint64_t v19 = v16[2];
              if (v19)
              {
                uint64_t v20 = (unsigned int *)&v30[8 * v16[1]];
                unsigned int v21 = &v20[2 * v19];
                do
                {
                  char v22 = &v18[*v20];
                  dyld3::MachOFile::PointerMetaData::PointerMetaData(&v31);
                  unsigned int v23 = v20[1];
                  int8x16_t v24 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v23), (uint32x4_t)xmmword_1A8E70500), (int8x16_t)xmmword_1A8E70510);
                  *(int8x8_t *)v24.i8 = vorr_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
                  unsigned __int32 v31 = v24.i32[0] | v31 & 0xF0000000 | v24.i32[1] | HIWORD(v23);
                  BOOL result = (void *)(*(uint64_t (**)(uint64_t, char *))(a6 + 16))(a6, v22);
                  v20 += 2;
                }
                while (v20 != v21);
              }
            }
            v16 += 3;
          }
          while (v16 != v17);
        }
        unsigned int v13 = v29 + 3;
      }
      while (v29 + 3 != v27);
    }
  }
  return result;
}

void *PatchTableV4::forEachPatchableCacheUseOfExport(void *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (void *)*result;
  if (*(void *)(*result + 16) > (unint64_t)a2)
  {
    uint64_t v9 = result[1];
    uint64_t v10 = (unsigned int *)((char *)&v8[2 * a2] + v8[1] - v9);
    unsigned int v12 = *v10;
    uint64_t v11 = v10[1];
    unsigned int v13 = (unsigned int *)((char *)v8 + 12 * v12 + v8[5] - v9);
    if (v11)
    {
      uint64_t v14 = (char *)v8 + v8[3] - v9;
      int v25 = (char *)v8 + v8[7] - v9;
      __int16 v30 = (char *)v8 + v8[9] - v9;
      int v27 = &v13[3 * v11];
      do
      {
        BOOL result = (void *)(*(uint64_t (**)(uint64_t, void))(a5 + 16))(a5, *v13);
        uint64_t v29 = v13;
        unsigned int v15 = v13[2];
        if (v15)
        {
          char v16 = (unsigned int *)&v25[12 * v13[1]];
          uint64_t v17 = &v16[3 * v15];
          uint64_t v18 = (char *)result - a4;
          do
          {
            if (*(_DWORD *)&v14[8 * *v16] == a3)
            {
              uint64_t v19 = v16[2];
              if (v19)
              {
                uint64_t v20 = (unsigned int *)&v30[8 * v16[1]];
                unsigned int v21 = &v20[2 * v19];
                do
                {
                  char v22 = &v18[*v20];
                  dyld3::MachOFile::PointerMetaData::PointerMetaData(&v31);
                  dyld_cache_patchable_location_v4::getPMD((uint64_t)v20, &v31);
                  unsigned int v23 = v20[1];
                  if (v23) {
                    uint64_t v24 = (v23 >> 9) & 0x1F;
                  }
                  else {
                    uint64_t v24 = v23 >> 9;
                  }
                  BOOL result = (void *)(*(uint64_t (**)(uint64_t, char *, void, uint64_t, void))(a6 + 16))(a6, v22, v31, v24, (v23 >> 8) & 1);
                  v20 += 2;
                }
                while (v20 != v21);
              }
            }
            v16 += 3;
          }
          while (v16 != v17);
        }
        unsigned int v13 = v29 + 3;
      }
      while (v29 + 3 != v27);
    }
  }
  return result;
}

uint64_t PatchTable::forEachPatchableGOTUseOfExport(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4 = **(_DWORD **)result;
  if (v4 == 4) {
    return (uint64_t)PatchTableV4::forEachPatchableGOTUseOfExport((void *)result, a2, a3, a4);
  }
  if (v4 == 3) {
    return PatchTableV3::forEachPatchableGOTUseOfExport(result, a2, a3, a4);
  }
  return result;
}

uint64_t PatchTableV3::forEachPatchableGOTUseOfExport(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4 = *(void **)result;
  if (*(void *)(*(void *)result + 112) > (unint64_t)a2)
  {
    uint64_t v5 = *(void *)(result + 8);
    int v6 = (unsigned int *)((char *)&v4[a2] + v4[13] - v5);
    uint64_t v7 = v6[1];
    if (v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (uint64_t)v4 + 12 * *v6 + v4[15] - v5;
      uint64_t v11 = v7 - 1;
      while (1)
      {
        uint64_t v12 = v9 + v11;
        if (v9 + v11 < 0 != __OFADD__(v9, v11)) {
          ++v12;
        }
        uint64_t v13 = v12 >> 1;
        BOOL result = *(unsigned int *)((char *)&v4[*(unsigned int *)(v10 + 12 * v13)] + v4[3] - v5);
        if (result == a3) {
          break;
        }
        if (result <= a3) {
          uint64_t v9 = v13 + 1;
        }
        else {
          uint64_t v11 = v13 - 1;
        }
        if (v9 > v11) {
          return result;
        }
      }
      uint64_t v14 = v10 + 12 * v13;
      uint64_t v15 = *(unsigned int *)(v14 + 8);
      if (v15)
      {
        char v16 = (unsigned int *)((char *)v4 + v4[17] + 16 * *(unsigned int *)(v14 + 4) - v5 + 8);
        uint64_t v17 = 16 * v15;
        do
        {
          dyld3::MachOFile::PointerMetaData::PointerMetaData(&v19);
          int8x16_t v18 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(*v16), (uint32x4_t)xmmword_1A8E70500), (int8x16_t)xmmword_1A8E70510);
          *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
          unsigned __int32 v19 = v18.i32[0] | v19 & 0xF0000000 | v18.i32[1] | HIWORD(*v16);
          BOOL result = (*(uint64_t (**)(uint64_t, void))(a4 + 16))(a4, *((void *)v16 - 1));
          v16 += 4;
          v17 -= 16;
        }
        while (v17);
      }
    }
  }
  return result;
}

void *PatchTableV4::forEachPatchableGOTUseOfExport(void *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4 = (void *)*result;
  if (*(void *)(*result + 112) > (unint64_t)a2)
  {
    uint64_t v5 = result[1];
    int v6 = (unsigned int *)((char *)&v4[a2] + v4[13] - v5);
    uint64_t v7 = v6[1];
    if (v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (uint64_t)v4 + 12 * *v6 + v4[15] - v5;
      uint64_t v11 = v4[17] - v5;
      uint64_t v12 = (char *)v4 + v4[3] - v5;
      uint64_t v13 = (char *)v4 + v11;
      uint64_t v14 = v7 - 1;
      while (1)
      {
        uint64_t v15 = v9 + v14;
        if (v9 + v14 < 0 != __OFADD__(v9, v14)) {
          ++v15;
        }
        uint64_t v16 = v15 >> 1;
        unsigned int v17 = *(_DWORD *)&v12[8 * *(unsigned int *)(v10 + 12 * v16)];
        if (v17 == a3) {
          break;
        }
        if (v17 <= a3) {
          uint64_t v9 = v16 + 1;
        }
        else {
          uint64_t v14 = v16 - 1;
        }
        if (v9 > v14) {
          return result;
        }
      }
      uint64_t v18 = v10 + 12 * v16;
      uint64_t v19 = *(unsigned int *)(v18 + 8);
      if (v19)
      {
        uint64_t v20 = (uint64_t)&v13[16 * *(unsigned int *)(v18 + 4)];
        uint64_t v21 = v20 + 16 * v19;
        do
        {
          dyld3::MachOFile::PointerMetaData::PointerMetaData(&v24);
          dyld_cache_patchable_location_v4_got::getPMD(v20, &v24);
          unsigned int v22 = *(_DWORD *)(v20 + 8);
          if (v22) {
            uint64_t v23 = (v22 >> 9) & 0x1F;
          }
          else {
            uint64_t v23 = v22 >> 9;
          }
          BOOL result = (void *)(*(uint64_t (**)(uint64_t, void, void, uint64_t, void))(a4 + 16))(a4, *(void *)v20, v24, v23, (v22 >> 8) & 1);
          v20 += 16;
        }
        while (v20 != v21);
      }
    }
  }
  return result;
}

char *PatchTableV2::clientsExportsForImageAndClient(PatchTableV2 *this, unsigned int a2, int a3)
{
  uint64_t v3 = *(void **)this;
  if (*(void *)(*(void *)this + 16) <= (unint64_t)a2) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = (unsigned int *)((char *)&v3[2 * a2] + v3[1] - v4);
  uint64_t v6 = v5[1];
  if (!v6) {
    return 0;
  }
  unsigned int v7 = *v5;
  uint64_t v8 = (char *)v3 + v3[7] - v4;
  uint64_t v9 = 12 * v6;
  for (uint64_t i = (uint64_t)v3 + v3[5] + 12 * v7 - v4 + 8; *(_DWORD *)(i - 8) != a3; i += 12)
  {
    v9 -= 12;
    if (!v9) {
      return 0;
    }
  }
  return &v8[12 * *(unsigned int *)(i - 4)];
}

uint64_t dyld_cache_patchable_location_v4::getPMD(uint64_t result, unsigned int *a2)
{
  if (*(_DWORD *)(result + 4))
  {
    HIDWORD(v5) = *((unsigned __int16 *)a2 + 1);
    LODWORD(v5) = *(_DWORD *)(result + 4);
    unsigned int v4 = v5 >> 16;
    *a2 = v4;
    unsigned int v6 = v4 & 0xFF00FFFF | (((*(_DWORD *)(result + 4) >> 1) & 0x7F) << 17);
    *a2 = v6;
    unsigned int v7 = v6 & 0xFEFFFFFF | ((*(_DWORD *)(result + 4) & 1) << 24);
    *a2 = v7;
    unsigned int v8 = v7 & 0xF9FFFFFF | (*(_DWORD *)(result + 4) << 11) & 0x4000000;
    *a2 = v8;
    unsigned int v3 = v8 & 0xF7FFFFFF | (*(_DWORD *)(result + 4) << 13) & 0x8000000;
  }
  else
  {
    unsigned int v2 = *a2;
    *a2 &= 0xFFFF0000;
    unsigned int v3 = v2 & 0xF0000000 | (((*(_DWORD *)(result + 4) >> 1) & 0x7F) << 17);
  }
  *a2 = v3;
  return result;
}

uint64_t dyld_cache_patchable_location_v4_got::getPMD(uint64_t result, unsigned int *a2)
{
  if (*(_DWORD *)(result + 8))
  {
    HIDWORD(v5) = *((unsigned __int16 *)a2 + 1);
    LODWORD(v5) = *(_DWORD *)(result + 8);
    unsigned int v4 = v5 >> 16;
    *a2 = v4;
    unsigned int v6 = v4 & 0xFF00FFFF | (((*(_DWORD *)(result + 8) >> 1) & 0x7F) << 17);
    *a2 = v6;
    unsigned int v7 = v6 & 0xFEFFFFFF | ((*(_DWORD *)(result + 8) & 1) << 24);
    *a2 = v7;
    unsigned int v8 = v7 & 0xF9FFFFFF | (*(_DWORD *)(result + 8) << 11) & 0x4000000;
    *a2 = v8;
    unsigned int v3 = v8 & 0xF7FFFFFF | (*(_DWORD *)(result + 8) << 13) & 0x8000000;
  }
  else
  {
    unsigned int v2 = *a2;
    *a2 &= 0xFFFF0000;
    unsigned int v3 = v2 & 0xF0000000 | (((*(_DWORD *)(result + 8) >> 1) & 0x7F) << 17);
  }
  *a2 = v3;
  return result;
}

uint64_t dyld4::FileManager::fsidForUUID(dyld4::FileManager *this, const UUID *a2)
{
  unsigned int v4 = (uint64_t *)*((void *)this + 2);
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  memset(v53, 0, sizeof(v53));
  uint64_t v45 = v4;
  unint64_t v5 = lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(&v45);
  unsigned int v6 = *v5;
  long long v7 = *(_OWORD *)(v5 + 13);
  long long v8 = *(_OWORD *)(v5 + 11);
  uint64_t v9 = v5[15];
  uint64_t v10 = v5[16];
  long long v39 = *(_OWORD *)(v5 + 9);
  long long v40 = v8;
  long long v41 = v7;
  uint64_t v42 = v9;
  long long v11 = *(_OWORD *)(v5 + 7);
  long long v12 = *(_OWORD *)(v5 + 5);
  long long v13 = *(_OWORD *)(v5 + 3);
  long long v35 = *(_OWORD *)(v5 + 1);
  long long v36 = v13;
  long long v37 = v12;
  long long v38 = v11;
  *(void *)&v43[7] = *(uint64_t **)((char *)v5 + 135);
  *(void *)int v43 = v10;
  LOBYTE(v9) = *((unsigned char *)v5 + 143);
  uint64_t v34 = v6;
  unsigned __int8 v44 = v9;
  long long v60 = 0u;
  memset(v61, 0, sizeof(v61));
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  uint64_t v45 = v4;
  memset(v53, 0, sizeof(v53));
  if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v34, (uint64_t)&v45))
  {
    while (1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = *((void *)&v35 + v44 - 1) + 24 * v43[v44 - 1];
      do
      {
        int v16 = *(unsigned __int8 *)(v15 + 8 + v14);
        int v17 = (*a2)[v14];
      }
      while (v16 == v17 && v14++ != 15);
      if (v16 == v17) {
        break;
      }
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(&v34);
      if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v34, (uint64_t)&v45))goto LABEL_10; {
    }
      }
  }
  else
  {
LABEL_10:
    dyld4::FileManager::reloadFSInfos((uint64_t **)this);
    uint64_t v19 = (uint64_t *)*((void *)this + 2);
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    memset(v53, 0, sizeof(v53));
    uint64_t v45 = v19;
    uint64_t v20 = lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(&v45);
    uint64_t v21 = *v20;
    long long v22 = *(_OWORD *)(v20 + 13);
    long long v23 = *(_OWORD *)(v20 + 11);
    unsigned int v24 = v20[15];
    int v25 = v20[16];
    long long v39 = *(_OWORD *)(v20 + 9);
    long long v40 = v23;
    long long v41 = v22;
    uint64_t v42 = v24;
    long long v26 = *(_OWORD *)(v20 + 7);
    long long v27 = *(_OWORD *)(v20 + 5);
    long long v28 = *(_OWORD *)(v20 + 3);
    long long v35 = *(_OWORD *)(v20 + 1);
    long long v36 = v28;
    long long v37 = v27;
    long long v38 = v26;
    *(void *)&v43[7] = *(uint64_t **)((char *)v20 + 135);
    *(void *)int v43 = v25;
    LOBYTE(v++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((unsigned char *)v20 + 143);
    uint64_t v34 = v21;
    unsigned __int8 v44 = v24;
    long long v60 = 0u;
    memset(v61, 0, sizeof(v61));
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    uint64_t v45 = v19;
    memset(v53, 0, sizeof(v53));
    if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v34, (uint64_t)&v45))return 0; {
    while (1)
    }
    {
      uint64_t v29 = 0;
      uint64_t v15 = *((void *)&v35 + v44 - 1) + 24 * v43[v44 - 1];
      do
      {
        int v30 = *(unsigned __int8 *)(v15 + 8 + v29);
        int v31 = (*a2)[v29];
      }
      while (v30 == v31 && v29++ != 15);
      if (v30 == v31) {
        break;
      }
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(&v34);
      if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>((uint64_t)&v34, (uint64_t)&v45))return 0; {
    }
      }
  }
  return *(void *)v15;
}

char *dyld4::FileManager::getPath@<X0>(char *this@<X0>, fsid_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  if (*(void *)&a2 && a3)
  {
    unsigned int v6 = this;
    if (dyld4::SyscallDelegate::fsgetpath(*(dyld4::SyscallDelegate **)this, __s, 0x400uLL, a2, a3) == -1) {
      this = 0;
    }
    else {
      this = lsl::Allocator::strdup(*((lsl::Lock ***)v6 + 1), __s);
    }
    *a4 = this;
  }
  else
  {
    *a4 = 0;
  }
  return this;
}

uint64_t **lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++(uint64_t **result)
{
  int v1 = *((unsigned __int8 *)result + 143);
  unsigned int v2 = (uint64_t **)*result;
  if (*((unsigned char *)result + 143))
  {
    int v3 = *((unsigned __int8 *)v2 + 32);
    unsigned int v4 = result + 16;
    ++*((unsigned char *)result + (v1 - 1) + 128);
    if (v1 == v3)
    {
      uint64_t v5 = *((unsigned __int8 *)v2 + 32);
      if (v5)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*((unsigned char *)v4 + (v5 + ~(_BYTE)i)) != (result[(v5 + ~(_BYTE)i) + 1][30] & 0x7F)) {
            break;
          }
          *((unsigned char *)result + 143) = v5 + ~(_BYTE)i;
        }
      }
    }
    else
    {
      int v13 = *((unsigned __int8 *)result + 143);
      if (v13 != *((unsigned __int8 *)v2 + 32))
      {
        uint64_t v14 = result + 1;
        do
        {
          uint64_t v15 = v14[v13 - 1];
          if ((char)v15[30] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          v14[v13] = (uint64_t *)v15[*((unsigned __int8 *)v4 + v13 - 1) + 21];
          *((unsigned char *)v4 + v13) = 0;
          LOBYTE(v13) = *((unsigned char *)result + 143) + 1;
          *((unsigned char *)result + 143) = v13;
        }
        while (*((unsigned __int8 *)v2 + 32) != v13);
      }
    }
  }
  else
  {
    long long v7 = *v2;
    *((unsigned char *)result + 143) = 0;
    if (*((unsigned char *)v2 + 32))
    {
      unsigned __int8 v8 = 0;
      uint64_t v9 = result + 1;
      do
      {
        v9[v8] = v7;
        *((unsigned char *)result + v8 + 128) = 0;
        uint64_t v10 = *((unsigned __int8 *)result + 143);
        unsigned int v11 = *((unsigned __int8 *)v2 + 32);
        if (v10 + 1 != v11)
        {
          long long v12 = v9[v10];
          if ((char)v12[30] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          long long v7 = (uint64_t *)v12[21];
        }
        unsigned __int8 v8 = v10 + 1;
        *((unsigned char *)result + 143) = v8;
      }
      while (v11 > v8);
    }
  }
  return result;
}

char *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild(uint64_t a1, unsigned int a2, lsl::Lock **this)
{
  if (*(char *)(a1 + 240) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v3 = *(unsigned __int8 *)(a1 + 240);
  if (v3 >= 7) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v5 = a1 + 168;
  uint64_t v6 = a1 + 168 + 8 * a2;
  char v7 = *(unsigned char *)(*(void *)v6 + 240);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 7;
  }
  else {
    int v10 = 10;
  }
  if (v9 != v10) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v12 = a2;
  if (v8 >= 0) {
    uint64_t v13 = 3;
  }
  else {
    uint64_t v13 = 5;
  }
  if (v3 != a2)
  {
    uint64_t v14 = 3 * v3;
    uint64_t v15 = a1 + 24 * v3;
    uint64_t v16 = 24 * a2 - 8 * v14;
    uint64_t v17 = v15;
    do
    {
      uint64_t v18 = *(void *)(v17 - 24);
      v17 -= 24;
      *(void *)uint64_t v15 = v18;
      *(_OWORD *)(v15 + 8) = *(_OWORD *)(v15 - 16);
      uint64_t v15 = v17;
      v16 += 24;
    }
    while (v16);
    a2 = *(unsigned __int8 *)(a1 + 240);
  }
  if ((a2 & 0x80) != 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  uint64_t v19 = v5 + 8 * a2;
  if (v19 != v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v19 - v6);
    LOBYTE(a2) = *(unsigned char *)(a1 + 240);
  }
  *(unsigned char *)(a1 + 24dyld4::halt((char *)__format, 0) = a2 + 1;
  uint64_t v20 = *(void *)v6 + 24 * v13;
  *(void *)(a1 + 24 * v12) = *(void *)v20;
  *(_OWORD *)(a1 + 24 * v12 + 8) = *(_OWORD *)(v20 + 8);
  BOOL result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  long long v22 = result;
  char v23 = *(unsigned char *)(*(void *)v6 + 240);
  result[240] = v23 & 0x80;
  if (v23 < 0)
  {
    long long v24 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 1dyld4::halt((char *)__format, 0) = 0u;
  }
  else
  {
    *((void *)result + 2dyld4::halt((char *)__format, 0) = 0;
    long long v24 = 0uLL;
  }
  *((_OWORD *)result + 8) = v24;
  *((_OWORD *)result + 9) = v24;
  *((_OWORD *)result + 6) = v24;
  *((_OWORD *)result + 7) = v24;
  *((_OWORD *)result + 4) = v24;
  *((_OWORD *)result + 5) = v24;
  *((_OWORD *)result + 2) = v24;
  *((_OWORD *)result + 3) = v24;
  *(_OWORD *)BOOL result = v24;
  *((_OWORD *)result + 1) = v24;
  if (*(char *)(a1 + 240) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  unsigned __int8 v25 = v9 + ~(_BYTE)v13;
  long long v26 = (uint64_t *)(v5 + 8 * v12);
  v26[1] = (uint64_t)result;
  uint64_t v27 = *v26;
  if (v25)
  {
    uint64_t v28 = v27 + 24 * v13;
    uint64_t v29 = v28 + 24 * v25 + 24;
    uint64_t v30 = v28 + 24;
    uint64_t v31 = (uint64_t)result;
    do
    {
      *(void *)uint64_t v31 = *(void *)v30;
      *(_OWORD *)(v31 + 8) = *(_OWORD *)(v30 + 8);
      v30 += 24;
      v31 += 24;
    }
    while (v30 != v29);
    uint64_t v27 = *(void *)v6;
  }
  int v32 = *(char *)(v27 + 240);
  if ((v32 & 0x80000000) == 0)
  {
    if (result[240] < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    BOOL result = (char *)memmove(result + 168, (const void *)(v27 + 8 * v13 + 176), 8 * v25 + 8);
    uint64_t v27 = *(void *)v6;
    LOBYTE(v32) = *(unsigned char *)(*(void *)v6 + 240);
  }
  *(unsigned char *)(v27 + 24dyld4::halt((char *)__format, 0) = v32 + ~v25;
  char v33 = v22[240] + v25;
  v22[240] = v33;
  if (v33 >= 0) {
    int v34 = 7;
  }
  else {
    int v34 = 10;
  }
  if ((v33 & 0x7F) == v34
    || ((char v35 = *(unsigned char *)(v27 + 240), v36 = v35, v37 = v35 & 0x7F, v36 >= 0) ? (v38 = 7) : (v38 = 10), v37 == v38))
  {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  return result;
}

size_t lsl::appendHexToString<unsigned long long>(char *a1, uint64_t a2)
{
  v6.val[0] = (int8x8_t)vsra_n_u8((uint8x8_t)vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)0xA0A0A0A0A0A0A0A0, (uint8x8_t)a2), (int8x8_t)0x3030303030303030, (int8x8_t)0x5757575757575757), (uint8x8_t)a2, 4uLL);
  int8x8_t v2 = vand_s8((int8x8_t)a2, (int8x8_t)0xF0F0F0F0F0F0F0FLL);
  v6.val[1] = vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)0xA0A0A0A0A0A0A0ALL, (uint8x8_t)v2), (int8x8_t)0x3030303030303030, (int8x8_t)0x5757575757575757), v2);
  uint64_t v3 = v5;
  vst2_s8(v3, v6);
  v3 += 16;
  char *v3 = 0;
  return strlcat(a1, v5, 0x400uLL);
}

size_t lsl::appendHexToString<int>(char *a1, __int32 a2, int8x8_t a3)
{
  a3.i32[0] = a2;
  int8x8_t v3 = vzip1_s8(a3, a3);
  int16x4_t v4 = (int16x4_t)vand_s8(v3, (int8x8_t)0xF000F000F000FLL);
  int8x8_t v6 = vtrn1_s8((int8x8_t)vsra_n_u16((uint16x4_t)vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0xA000A000A000A0, (uint16x4_t)(*(void *)&v3 & 0xFF00FF00FF00FFLL)), (int8x8_t)0x30003000300030, (int8x8_t)0x57005700570057), (uint16x4_t)(*(void *)&v3 & 0xFF00FF00FF00FFLL), 4uLL), (int8x8_t)vadd_s16((int16x4_t)vbsl_s8((int8x8_t)vcgt_u16((uint16x4_t)0xA000A000A000ALL, (uint16x4_t)v4), (int8x8_t)0x30003000300030, (int8x8_t)0x57005700570057), v4));
  char v7 = 0;
  return strlcat(a1, (const char *)&v6, 0x400uLL);
}

uint64_t lsl::MemoryManager::writeProtect(lsl::MemoryManager *this, int a2)
{
  char v2 = a2;
  uint64_t v4 = *((void *)this + 5);
  if (v4 && *(_DWORD *)(v4 + 16) >= 0x205u && *(_DWORD *)(v4 + 516))
  {
    unint64_t v5 = 0;
    uint64_t v6 = v4 - *(void *)(v4 + 224);
    if (a2) {
      vm_prot_t v7 = 1;
    }
    else {
      vm_prot_t v7 = 19;
    }
    int v8 = (vm_size_t *)(*(unsigned int *)(v4 + 512) + v4 + 8);
    do
    {
      vm_protect(mach_task_self_, v6 + *(v8 - 1), *v8, 0, v7);
      ++v5;
      v8 += 2;
    }
    while (v5 < *(unsigned int *)(v4 + 516));
  }
  uint64_t result = *((void *)this + 2);
  if (result)
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    _OWORD v10[2] = ___ZN3lsl13MemoryManager12writeProtectEb_block_invoke;
    void v10[3] = &__block_descriptor_tmp_7;
    char v11 = v2;
    return lsl::Allocator::forEachVMAllocatedBuffer(result, (uint64_t)v10);
  }
  return result;
}

uint64_t ___ZN3lsl13MemoryManager12writeProtectEb_block_invoke(uint64_t a1, vm_address_t *a2)
{
  if (*(unsigned char *)(a1 + 32)) {
    vm_prot_t v2 = 1;
  }
  else {
    vm_prot_t v2 = 3;
  }
  return vm_protect(mach_task_self_, *a2, a2[1], 0, v2);
}

size_t OUTLINED_FUNCTION_0(uint64_t a1, const char *a2)
{
  return strlcat(v2, a2, 0x400uLL);
}

uint64_t dyld3::mapSplitCachePrivate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v209);
  uint64_t v9 = v8;
  char v11 = v10;
  char v192 = 0;
  int v193 = 0;
  memset(v208, 0, sizeof(v208));
  LOBYTE(v12) = 0;
  if (!dyld3::preflightMainCacheFile(v10, v8, (uint64_t)v191, (char *)v208, (uint64_t)v190)) {
    return v12 & 1;
  }
  if (*((unsigned char *)v11 + 6) && fsgetpath((char *)v205, 0x400uLL, (fsid_t *)(v9 + 32), *(void *)(v9 + 40)) >= 1) {
    dyld4::console((dyld4 *)"mapped dyld cache file private to process (%s):\n", v13, v205);
  }
  uint64_t v173 = v194;
  if (v194 && !v192)
  {
    LOBYTE(v12) = 0;
    uint64_t v14 = "shared cache is too old, missing subcache suffixes";
LABEL_8:
    *(void *)(v9 + 16) = v14;
    return v12 & 1;
  }
  for (uint64_t i = 0; i != 7168; i += 56)
  {
    uint64_t v16 = &v205[i];
    *((unsigned char *)v16 + 389) = 0;
    *((_DWORD *)v16 + 98) = 0;
  }
  if (v173 >= 2)
  {
    uint64_t v17 = &v207;
    uint64_t v18 = v173 - 1;
    uint64_t v19 = v190;
    while (1)
    {
      memset(v196, 0, sizeof(v196));
      char v197 = 0;
      fsid_t v198 = 0;
      uint64_t v199 = 0;
      char v200 = 0;
      if (!dyld3::preflightSubCacheFile(v11, (uint64_t)v196, (uint64_t)v17, (char *)v208, v19)) {
        break;
      }
      if (*((unsigned char *)v11 + 6))
      {
        bzero(v201, 0x400uLL);
        if (fsgetpath((char *)v201, 0x400uLL, &v198, v199) >= 1) {
          dyld4::console((dyld4 *)"mapped dyld cache file private to process (%s):\n", v20, v201);
        }
      }
      v17 += 56;
      v19 += 32;
      if (!--v18) {
        goto LABEL_18;
      }
    }
LABEL_32:
    LOBYTE(v12) = 0;
    return v12 & 1;
  }
LABEL_18:
  uint64_t v21 = (dyld3 *)memmove(v205, v191, 0x1C0uLL);
  uint64_t v168 = v191[0];
  dyld3::deallocateExistingSharedCache(v21);
  *(void *)uint64_t v9 = v205[0];
  *(void *)(v9 + 8) = 0;
  unint64_t v180 = v11;
  if (v173)
  {
    uint64_t v22 = 0;
    char v23 = v205;
    while (1)
    {
      long long v24 = &v205[56 * v22];
      uint64_t v25 = *((unsigned int *)v24 + 96);
      if (v25) {
        break;
      }
LABEL_24:
      ++v22;
      v23 += 56;
      if (v22 == v173)
      {
        uint64_t v30 = *(void *)(v9 + 8);
        char v11 = v180;
        goto LABEL_35;
      }
    }
    int v26 = *((_DWORD *)v24 + 98);
    uint64_t v27 = *v24;
    uint64_t v28 = *v24 - v168 + 0x180000000;
    uint64_t v29 = v23;
    while (mmap((void *)(v28 + *(void *)(v9 + 8) + *v29 - v27), v29[1], *((_DWORD *)v29 + 11) & 7, 18, v26, v29[2]) != (void *)-1)
    {
      v29 += 6;
      if (!--v25) {
        goto LABEL_24;
      }
    }
    if (!*(void *)(v9 + 16)) {
      *(void *)(v9 + 16) = "mmap() the shared cache region failed";
    }
    uint64_t v31 = (int *)v206;
    uint64_t v32 = v173;
    do
    {
      if (*v31 != -1) {
        close(*v31);
      }
      v31 += 112;
      --v32;
    }
    while (v32);
    goto LABEL_32;
  }
  uint64_t v30 = 0;
LABEL_35:
  int v34 = (char *)(v30 + v195);
  size_t v35 = (vm_page_size + 31) & -(uint64_t)vm_page_size;
  if (mmap((void *)(v30 + v195), v35, 3, 4114, -1, 0) != v34)
  {
    mmap((void *)0x180000000, 0x180000000uLL, 0, 4114, 0, 0);
    LOBYTE(v12) = 0;
    *(void *)uint64_t v9 = 0;
    uint64_t v14 = "could not mmap() dynamic config memory";
    goto LABEL_8;
  }
  strcpy(v34, "dyld_data    v0");
  *((_OWORD *)v34 + 1) = *(_OWORD *)(v9 + 32);
  mprotect(v34, v35, 1);
  if (*((unsigned char *)v11 + 6)) {
    dyld3::verboseSharedCacheMappings(*(dyld3 **)v9, v36);
  }
  if (!v173)
  {
    LOBYTE(v12) = 1;
    return v12 & 1;
  }
  uint64_t v169 = (vm_address_t *)&v186;
  int v166 = v182;
  uint64_t v167 = v189;
  uint64_t v163 = &v185;
  uint64_t v164 = v203;
  uint64_t v162 = &v202;
  uint64_t v12 = 1;
  uint64_t v37 = 0;
  do
  {
    uint64_t v170 = v37;
    uint64_t v38 = (uint64_t)memmove(v201, &v205[56 * v37], 0x1C0uLL);
    if (*((unsigned char *)v11 + 8))
    {
      v188[0] = _NSConcreteStackBlock;
      v188[1] = 0x40000000;
      v189[0] = ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke;
      v189[1] = &__block_descriptor_tmp_8;
      v189[2] = v9;
      uint64_t v38 = DyldSharedCache::forEachRegion(v201[0], (uint64_t)v188);
    }
    unint64_t v46 = v204;
    if (!*((unsigned char *)v11 + 12)) {
      goto LABEL_90;
    }
    unsigned int v47 = 0;
    char v48 = 1;
    if (v204)
    {
      uint64_t v49 = v204;
      long long v50 = (_DWORD **)v164;
      do
      {
        if (*(v50 - 1))
        {
          ++v47;
          if (**v50 != 5) {
            char v48 = 0;
          }
        }
        v50 += 6;
        --v49;
      }
      while (v49);
    }
    if (v47 > 5 || (v48 & 1) == 0) {
      goto LABEL_90;
    }
    uint64_t v183 = (char *)v196;
    vm_size_t v184 = 8;
    long long v51 = v163;
    v163[1] = 0;
    uint64_t v51[2] = 0;
    *long long v51 = 0;
    unint64_t v165 = v46;
    if (v46)
    {
      uint64_t v171 = (unsigned int *)&v203[48 * v170 + 8];
      int v172 = (int *)&v205[56 * v170 + 49];
      uint64_t v52 = (uint64_t)v162;
      do
      {
        if (*(void *)v52)
        {
          uint64_t v53 = v12;
          long long v54 = *(_DWORD **)(v52 + 8);
          if (*v54 != 5) {
            __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1115, "slideInfoHeader->version == 5");
          }
          int v55 = *v172;
          int v177 = *(_DWORD *)(v52 + 20);
          int v178 = v55;
          uint64_t v179 = *(void *)(v52 - 8);
          uint64_t v56 = *(void *)(v52 - 24);
          uint64_t v175 = *(void *)(v9 + 8);
          uint64_t v176 = v56;
          int v57 = v54[2];
          int v174 = v54[1];
          uint64_t v38 = (uint64_t)DyldSharedCache::mappingName((DyldSharedCache *)*v171, 0);
          unint64_t v58 = v185 + 1;
          if (v185 + 1 > v184)
          {
            uint64_t v59 = v38;
            vm_address_t v60 = (vm_address_t)v186;
            vm_size_t v61 = v187;
            if (2 * v184 > v58) {
              unint64_t v58 = 2 * v184;
            }
            vm_size_t v187 = (vm_page_size + 48 * v58 - 1) & -(uint64_t)vm_page_size;
            if (vm_allocate(mach_task_self_, v169, v187, 1006632961)) {
              __assert_rtn("growTo", "Array.h", 184, "0");
            }
            memmove(v186, v183, 48 * v185);
            uint64_t v183 = v186;
            vm_size_t v184 = v187 / 0x30;
            uint64_t v38 = v59;
            if (v60)
            {
              vm_deallocate(mach_task_self_, v60, v61);
              uint64_t v38 = v59;
            }
          }
          int v62 = v177 & 7;
          uint64_t v63 = v175 + v176;
          uint64_t v64 = (v57 * v174);
          uint64_t v65 = v185++;
          uint64_t v66 = &v183[48 * v65];
          *(_DWORD *)uint64_t v66 = v178;
          *((_DWORD *)v66 + 1) = v62;
          *((void *)v66 + 1) = v179;
          *((void *)v66 + 2) = v63;
          *((void *)v66 + 3) = v64;
          *((void *)v66 + 4) = v38;
          *((void *)v66 + 5) = v54;
          uint64_t v12 = v53;
        }
        v52 += 48;
        --v46;
      }
      while (v46);
      unsigned int v67 = 4 * v185 + 4;
      if (v185)
      {
        uint64_t v68 = 48 * v185;
        uint64_t v69 = v183 + 40;
        do
        {
          if (**(_DWORD **)v69 != 5) {
            __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1142, "slideInfoHeader->version == 5");
          }
          unsigned int v67 = (v67 + 2 * *(_DWORD *)(*(void *)v69 + 8) + 25) & 0xFFFFFFFC;
          v69 += 48;
          v68 -= 48;
        }
        while (v68);
      }
    }
    else
    {
      unsigned int v67 = 4;
    }
    size_t v70 = (v67 + 47) & 0xFFFFFFF8;
    __chkstk_darwin(v38, v39, v40, v41, v42, v43, v44, v45, (uint64_t)v162);
    uint64_t v71 = (uint64_t **)((char *)&v162 - ((v70 + 15) & 0x1FFFFFFF0));
    bzero(v71, v70);
    void *v71 = 0xD400000000007;
    *((_DWORD *)v71 + 2) = v70;
    *(void *)((char *)v71 + 12) = 0x2800000000;
    *((_DWORD *)v71 + 5) = v67;
    uint64_t v80 = *(void *)(v9 + 8);
    uint64_t v81 = v168;
    void v71[3] = v80;
    v71[4] = v81;
    uint64_t v82 = v185;
    *((_DWORD *)v71 + 1dyld4::halt((char *)__format, 0) = v185;
    if (v82)
    {
      unsigned int v83 = 0;
      vm_address_t v84 = &v183[48 * v82];
      unsigned int v85 = 4 * v82 + 4;
      uint64_t v86 = v80 + v81;
      uint64_t v87 = v183;
      do
      {
        uint64_t v88 = (_DWORD *)*((void *)v87 + 5);
        if (*v88 != 5) {
          __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1168, "slideInfoHeader->version == 5");
        }
        *((_DWORD *)v71 + v83 + 11) = v85;
        uint64_t v89 = v85 + 40;
        uint64_t v90 = (uint64_t)v71 + v89;
        int v91 = 2 * v88[2] + 22;
        *(_DWORD *)uint64_t v90 = v91;
        *(_DWORD *)(v90 + 4) = 868352;
        *(void *)(v90 + 8) = *((void *)v87 + 2) - v86;
        *(_DWORD *)(v90 + 16) = 0;
        uint64_t v92 = v88[2];
        *(_WORD *)(v90 + 2dyld4::halt((char *)__format, 0) = v92;
        if (v92)
        {
          v88 += 6;
          v89 += (uint64_t)v71 + 22;
          do
          {
            unsigned int v93 = *(unsigned __int16 *)v88;
            uint64_t v88 = (_DWORD *)((char *)v88 + 2);
            uint64_t v90 = v93;
            *(_WORD *)uint64_t v89 = v93;
            v89 += 2;
            --v92;
          }
          while (v92);
        }
        ++v83;
        unsigned int v85 = (v85 + v91 + 3) & 0xFFFFFFFC;
        v87 += 48;
      }
      while (v87 != v84);
      __chkstk_darwin(v92, (uint64_t)v88, v89, v90, v76, v77, v78, v79, (uint64_t)v162);
      char v98 = (const mwl_region *)((char *)&v162 - (v97 & 0xFFFFFFFFFFFFFFE0 | 0x10));
      uint64_t v99 = 0;
      uint64_t v100 = 48 * v95;
      char v101 = (mwl_region *)v98;
      unint64_t v46 = v165;
      do
      {
        if (v95 == v99) {
          __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
        }
        ++v99;
        long long v102 = *v96;
        long long v103 = v96[1];
        v96 += 3;
        *(_OWORD *)&v101->mwlr_fd = v102;
        *(_OWORD *)&v101->mwlr_vm_address_t address = v103;
        ++v101;
        v100 -= 48;
      }
      while (v100);
    }
    else
    {
      __chkstk_darwin(v72, v73, v74, v75, v76, v77, v78, v79, (uint64_t)v162);
      char v98 = (const mwl_region *)((char *)&v162 - (v104 & 0xFFFFFFFFFFFFFFE0 | 0x10));
      LODWORD(v99) = 0;
      unint64_t v46 = v165;
    }
    if (*((unsigned char *)v180 + 6)) {
      dyld4::console((dyld4 *)"Setting up kernel page-in linking for subcache %d\n", v94, v170);
    }
    int v106 = __map_with_linking_np(v98, v99, (const mwl_info_hdr *)((char *)&v162 - ((v70 + 15) & 0x1FFFFFFF0)), v70);
    char v11 = v180;
    if (v106 && *((unsigned char *)v180 + 6)) {
      dyld4::console((dyld4 *)"__map_with_linking_np(subcache %d) failed, falling back to linking in-process\n", v105, v170);
    }
    uint64_t v185 = 0;
    if (v186) {
      vm_deallocate(mach_task_self_, (vm_address_t)v186, v187);
    }
    if (v106)
    {
LABEL_90:
      if (v46)
      {
        uint64_t v107 = 0;
        while (!v201[6 * v107 + 3])
        {
LABEL_141:
          if (++v107 >= v46) {
            goto LABEL_142;
          }
        }
        uint64_t v108 = &v201[6 * v107];
        uint64_t v109 = v108[4];
        if (!v109)
        {
          int v139 = 1;
LABEL_140:
          uint64_t v12 = v12 & v139;
          unint64_t v46 = v204;
          goto LABEL_141;
        }
        uint64_t v110 = *v108;
        int v111 = *(_DWORD *)v109;
        if (*(_DWORD *)v109 == 5)
        {
          unint64_t v140 = *(unsigned int *)(v109 + 8);
          if (v140)
          {
            LODWORD(v179) = v12;
            unint64_t v141 = 0;
            int v142 = *(_DWORD *)(v109 + 4);
            do
            {
              unint64_t v143 = *(unsigned __int16 *)(v109 + 2 * v141 + 24);
              if (v143 != 0xFFFF)
              {
                uint64_t v144 = (unint64_t *)(v110 + (v142 * v141));
                unint64_t v145 = v143 >> 3;
                do
                {
                  v144 += v145;
                  v196[0] = *v144;
                  unint64_t v146 = v196[0];
                  uint64_t v147 = *(void *)(v109 + 16) + *(void *)(v9 + 8);
                  if ((v196[0] & 0x8000000000000000) != 0)
                  {
                    unint64_t v149 = mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer((mach_o::ChainedFixupPointerOnDisk::Cache64e *)v196, (unint64_t)v144, (mach_o::ChainedFixupPointerOnDisk::Cache64e *)(v147 + (v196[0] & 0x3FFFFFFFFLL)));
                  }
                  else
                  {
                    uint64_t v148 = v147 + (v196[0] & 0x3FFFFFFFFLL);
                    unint64_t v149 = mach_o::ChainedFixupPointerOnDisk::Cache64e::high8((mach_o::ChainedFixupPointerOnDisk::Cache64e *)v196) | v148;
                  }
                  unint64_t v145 = (v146 >> 52) & 0x7FF;
                  *uint64_t v144 = v149;
                }
                while (v145);
                unint64_t v140 = *(unsigned int *)(v109 + 8);
              }
              ++v141;
            }
            while (v141 < v140);
            int v139 = 1;
            char v11 = v180;
            LODWORD(v12) = v179;
            goto LABEL_140;
          }
        }
        else if (v111 == 3)
        {
          unint64_t v150 = *(unsigned int *)(v109 + 8);
          if (v150)
          {
            int v151 = v12;
            unint64_t v152 = 0;
            int v153 = *(_DWORD *)(v109 + 4);
            do
            {
              unint64_t v154 = *(unsigned __int16 *)(v109 + 2 * v152 + 24);
              if (v154 != 0xFFFF)
              {
                uint64_t v155 = (uint64_t *)(v110 + (v153 * v152));
                unint64_t v156 = v154 >> 3;
                do
                {
                  v155 += v156;
                  unint64_t v157 = *v155;
                  if (*v155 < 0)
                  {
                    uint64_t v159 = (mach_o::ChainedFixupPointerOnDisk::Arm64e *)(*(void *)(v109 + 16)
                                                                       + v157
                                                                       + *(void *)(v9 + 8));
                    v196[0] = *v155;
                    uint64_t v158 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer((mach_o::ChainedFixupPointerOnDisk::Arm64e *)v196, (unint64_t)v155, v159);
                  }
                  else
                  {
                    v196[0] = *v155;
                    uint64_t v158 = *(void *)(v9 + 8)
                         + mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget((mach_o::ChainedFixupPointerOnDisk::Arm64e *)v196);
                  }
                  unint64_t v156 = (v157 >> 51) & 0x7FF;
                  *uint64_t v155 = v158;
                }
                while (v156);
                unint64_t v150 = *(unsigned int *)(v109 + 8);
              }
              ++v152;
            }
            while (v152 < v150);
            int v139 = 1;
            char v11 = v180;
            LODWORD(v12) = v151;
            goto LABEL_140;
          }
        }
        else
        {
          if (v111 != 2)
          {
            int v139 = 0;
            *(void *)(v9 + 16) = "invalid slide info in cache file";
            goto LABEL_139;
          }
          uint64_t v112 = *(unsigned int *)(v109 + 12);
          if (v112)
          {
            uint64_t v113 = 0;
            int v114 = *(_DWORD *)(v109 + 4);
            uint64_t v115 = v109 + *(unsigned int *)(v109 + 8);
            uint64_t v116 = v109 + *(unsigned int *)(v109 + 16);
            do
            {
              int v117 = *(__int16 *)(v115 + 2 * v113);
              if (v117 != 0x4000)
              {
                uint64_t v118 = v110 + (v114 * v113);
                if (v117 < 0)
                {
                  unsigned __int16 v128 = v117 & 0x3FFF;
                  unint64_t v129 = *(void *)(v109 + 24);
                  uint64_t v130 = *(void *)(v109 + 32);
                  char v131 = __clz(__rbit64(v129)) - 2;
                  do
                  {
                    int v132 = *(__int16 *)(v116 + 2 * v128);
                    unsigned int v133 = 4 * (v132 & 0x3FFF);
                    uint64_t v134 = *(void *)(v9 + 8) + v130;
                    do
                    {
                      uint64_t v135 = *(void *)(v118 + v133);
                      unint64_t v136 = (v135 & v129) >> v131;
                      unint64_t v137 = v135 & ~v129;
                      BOOL v125 = v137 == 0;
                      uint64_t v138 = v134 + v137;
                      if (v125) {
                        uint64_t v138 = 0;
                      }
                      *(void *)(v118 + v133) = v138;
                      v133 += v136;
                    }
                    while (v136);
                    ++v128;
                  }
                  while ((v132 & 0x80000000) == 0);
                }
                else
                {
                  unint64_t v119 = *(void *)(v109 + 24);
                  char v120 = __clz(__rbit64(v119)) - 2;
                  unsigned int v121 = 4 * (v117 & 0x3FFF);
                  uint64_t v122 = *(void *)(v109 + 32) + *(void *)(v9 + 8);
                  do
                  {
                    uint64_t v123 = *(void *)(v118 + v121);
                    unint64_t v124 = (v123 & v119) >> v120;
                    unint64_t v126 = v123 & ~v119;
                    BOOL v125 = v126 == 0;
                    uint64_t v127 = v122 + v126;
                    if (v125) {
                      uint64_t v127 = 0;
                    }
                    *(void *)(v118 + v121) = v127;
                    v121 += v124;
                  }
                  while (v124);
                }
              }
              ++v113;
            }
            while (v113 != v112);
            int v139 = 1;
            char v11 = v180;
            goto LABEL_140;
          }
        }
        int v139 = 1;
LABEL_139:
        char v11 = v180;
        goto LABEL_140;
      }
    }
LABEL_142:
    if (*((unsigned char *)v11 + 8))
    {
      v181[0] = _NSConcreteStackBlock;
      v181[1] = 0x40000000;
      v182[0] = ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke_2;
      v182[1] = &__block_descriptor_tmp_9;
      v182[2] = v9;
      DyldSharedCache::forEachRegion(v201[0], (uint64_t)v181);
    }
    uint64_t v37 = v170 + 1;
  }
  while (v170 + 1 != v173);
  int v160 = (int *)v206;
  uint64_t v161 = v173;
  do
  {
    if (*v160 != -1) {
      close(*v160);
    }
    v160 += 112;
    --v161;
  }
  while (v161);
  return v12 & 1;
}

uint64_t dyld3::mapSplitCacheSystemWide(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v90);
  uint64_t v9 = v8;
  uint64_t v11 = (uint64_t)v10;
  char v82 = 0;
  int v83 = 0;
  memset(v89, 0, 256);
  int v12 = dyld3::preflightMainCacheFile(v10, v8, (uint64_t)v81, v89, (uint64_t)v80);
  uint64_t result = 0;
  if (v12)
  {
    uint64_t v14 = v84;
    if (v84 && !v82)
    {
      uint64_t result = 0;
      uint64_t v15 = "shared cache is too old, missing subcache suffixes";
LABEL_13:
      *(void *)(v9 + 16) = v15;
      return result;
    }
    for (uint64_t i = 0; i != 57344; i += 448)
    {
      uint64_t v17 = &v86[i];
      v17[389] = 0;
      *((_DWORD *)v17 + 98) = 0;
    }
    if (v14 < 2)
    {
LABEL_11:
      v75[0] = 0;
      vm_size_t v21 = (vm_page_size + 31) & -(uint64_t)vm_page_size;
      if (vm_allocate(mach_task_self_, v75, v21, 1))
      {
        uint64_t result = 0;
        uint64_t v15 = "Could not vm_allocate fixed range for dynamic config data";
        goto LABEL_13;
      }
      vm_address_t v22 = v75[0];
      strcpy((char *)v75[0], "dyld_data    v0");
      *(_OWORD *)(v22 + 16) = *(_OWORD *)(v9 + 32);
      memmove(v86, v81, 0x1C0uLL);
      __chkstk_darwin((v14 + 1), v23, v24, v25, v26, v27, v28, v29, v72);
      uint64_t v38 = (char *)&v72 - v37;
      uint64_t v74 = v39;
      if (v14)
      {
        uint64_t v40 = 0;
        int v41 = 0;
        int v42 = v87[6];
        uint64_t v43 = v38 + 4;
        do
        {
          int v44 = *(_DWORD *)&v86[v40 + 384];
          v41 += v44;
          if (v40) {
            int v45 = 0;
          }
          else {
            int v45 = v42;
          }
          *(v43 - 1) = *(_DWORD *)&v86[v40 + 392];
          *uint64_t v43 = v44;
          v43[1] = v45;
          v40 += 448;
          v43 += 3;
        }
        while (448 * v14 != v40);
        uint64_t v46 = v14;
      }
      else
      {
        uint64_t v46 = 0;
        int v41 = 0;
      }
      unsigned int v47 = &v38[12 * v46];
      *(void *)unsigned int v47 = 0x1FFFFFFFFLL;
      *((_DWORD *)v47 + 2) = 0;
      __chkstk_darwin(v30, (uint64_t)v38, v31, v32, v33, v34, v35, v36, v72);
      int v55 = (char *)&v72 - (v41 + 1) * (unint64_t)v54;
      if (*(unsigned char *)(v11 + 6))
      {
        unsigned int v73 = v48;
        vm_size_t v56 = v21;
        int v57 = v49;
        dyld4::console((dyld4 *)"Mapping the shared cache system wide\n", v49);
        uint64_t v49 = v57;
        vm_size_t v21 = v56;
        unint64_t v48 = v73;
      }
      if (v14)
      {
        uint64_t v58 = 0;
        int v59 = 0;
        vm_address_t v60 = v86;
        do
        {
          uint64_t v61 = *(unsigned int *)&v86[448 * v58 + 384];
          int v62 = v60;
          if (v61)
          {
            do
            {
              uint64_t v63 = &v55[48 * v59++];
              long long v64 = v62[1];
              *(_OWORD *)uint64_t v63 = *v62;
              *((_OWORD *)v63 + 1) = v64;
              *((_OWORD *)v63 + 2) = v62[2];
              v62 += 3;
              --v61;
            }
            while (v61);
          }
          ++v58;
          v60 += 448;
        }
        while (v58 != v46);
      }
      vm_address_t v65 = v75[0];
      uint64_t v66 = &v55[48 * v41];
      *(void *)uint64_t v66 = v85;
      *((void *)v66 + 1) = v21;
      *((void *)v66 + 3) = 0;
      *((void *)v66 + 4) = 0;
      *((void *)v66 + 2) = v65;
      *((void *)v66 + 5) = 0x100000001;
      int v67 = __shared_region_map_and_slide_2_np((void *)v48, v49, (void *)(v41 + 1), v55, v50, v51, v52, v53);
      vm_deallocate(mach_task_self_, v75[0], v21);
      if (v14)
      {
        uint64_t v68 = v87;
        do
        {
          if (*v68 != -1) {
            close(*v68);
          }
          v68 += 112;
          --v46;
        }
        while (v46);
      }
      char v69 = dyld3::reuseExistingCache(v11, v9);
      if (v67)
      {
        if (v69)
        {
          return 1;
        }
        else
        {
          uint64_t result = 0;
          if (!*(void *)(v9 + 16)) {
            *(void *)(v9 + 16) = "syscall to map cache into shared region failed";
          }
        }
      }
      else
      {
        if (*(unsigned char *)(v11 + 6)) {
          char v71 = v69;
        }
        else {
          char v71 = 1;
        }
        if ((v71 & 1) == 0) {
          dyld4::console((dyld4 *)"mapped dyld cache file system wide\n", v70);
        }
        return 1;
      }
    }
    else
    {
      uint64_t v18 = &v88;
      uint64_t v19 = v14 - 1;
      uint64_t v20 = v80;
      while (1)
      {
        memset(v75, 0, sizeof(v75));
        char v76 = 0;
        uint64_t v77 = 0;
        uint64_t v78 = 0;
        char v79 = 0;
        if ((dyld3::preflightSubCacheFile((unsigned int *)v11, (uint64_t)v75, (uint64_t)v18, v89, v20) & 1) == 0) {
          return 0;
        }
        v18 += 56;
        v20 += 32;
        if (!--v19) {
          goto LABEL_11;
        }
      }
    }
  }
  return result;
}

uint64_t dyld3::deallocateExistingSharedCache(dyld3 *this)
{
  uint64_t v2 = 0;
  uint64_t result = __shared_region_check_np(&v2);
  if (!result) {
    return __shared_region_check_np(0);
  }
  return result;
}

uint64_t dyld3::preflightMainCacheFile(unsigned int *a1, uint64_t a2, uint64_t a3, char *__dst, uint64_t a5)
{
  uint64_t v9 = (dyld3 *)*a1;
  int v10 = *((unsigned __int8 *)a1 + 9);
  int v11 = *((unsigned __int8 *)a1 + 10);
  strcpy(__source, "dyld_shared_cache_arm64e");
  strlcpy(__dst, __source, 0x100uLL);
  if (!v10)
  {
    strlcpy(__dsta, __source, 0x100uLL);
    strlcat(__dsta, ".development", 0x400uLL);
    if (!dyld3::fstatat(v9, __dsta, &v23, 0))
    {
      int v13 = dyld3::fstatat(v9, __source, &v22, 0);
      if (v11 || v13)
      {
        strlcpy(__source, __dsta, 0x100uLL);
      }
      else if (!dyld3::stat((dyld3 *)"/System/Library/Caches/com.apple.dyld/enable-dylibs-to-override-cache", &v21, v14)&& v21.st_size <= 1023)
      {
        strlcat(__source, ".development", 0x100uLL);
      }
    }
  }
  uint64_t v15 = dyld3::openat((dyld3 *)*a1, __source, v12);
  if (v15 == -1)
  {
    if (*__error() == 2)
    {
      uint64_t result = 0;
      *(unsigned char *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      uint64_t v20 = "no shared cache file";
    }
    else
    {
      uint64_t result = 0;
      uint64_t v20 = "shared cache file open() failed";
    }
    *(void *)(a2 + 16) = v20;
  }
  else
  {
    *(unsigned char *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    return dyld3::preflightCacheFile((uint64_t)a1, a2, a3, v15, a5, v16, v17, v18);
  }
  return result;
}

uint64_t dyld3::preflightSubCacheFile(unsigned int *a1, uint64_t a2, uint64_t a3, char *__source, const char *a5)
{
  uint64_t v9 = (dyld3 *)*a1;
  strlcpy(__dst, __source, 0x100uLL);
  strlcat(__dst, a5, 0x100uLL);
  uint64_t v11 = dyld3::openat(v9, __dst, v10);
  if (v11 == -1)
  {
    if (*__error() == 2)
    {
      uint64_t result = 0;
      *(unsigned char *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      uint64_t v16 = "no shared cache file";
    }
    else
    {
      uint64_t result = 0;
      uint64_t v16 = "shared cache file open() failed";
    }
    *(void *)(a2 + 16) = v16;
  }
  else
  {
    *(unsigned char *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    return dyld3::preflightCacheFile((uint64_t)a1, a2, a3, v11, 0, v12, v13, v14);
  }
  return result;
}

void dyld3::verboseSharedCacheMappings(dyld3 *this, const DyldSharedCache *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZN5dyld3L26verboseSharedCacheMappingsEPK15DyldSharedCache_block_invoke;
  v3[3] = &__block_descriptor_tmp_37;
  void v3[4] = DyldSharedCache::slide(this);
  DyldSharedCache::forEachRange((char *)this, (uint64_t)v3, 0);
}

uint64_t ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke(uint64_t result, int a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 4) != 0) {
    return vm_protect(mach_task_self_, *(void *)(*(void *)(result + 32) + 8) + a3, size, 0, 19);
  }
  return result;
}

uint64_t ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke_2(uint64_t result, int a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 4) != 0) {
    return vm_protect(mach_task_self_, *(void *)(*(void *)(result + 32) + 8) + a3, size, 0, 1);
  }
  return result;
}

uint64_t dyld3::preflightCacheFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v86);
  uint64_t v9 = v8;
  int v11 = v10;
  uint64_t v13 = v12;
  uint64_t v15 = v14;
  uint64_t v17 = v16;
  if (fstat64(v10, &v62))
  {
    uint64_t v18 = "shared cache file stat() failed";
LABEL_10:
    *(void *)(v15 + 16) = v18;
LABEL_11:
    close(v11);
    return 0;
  }
  st_vm_size_t size = v62.st_size;
  __darwin_ino64_t st_ino = v62.st_ino;
  *(void *)(v15 + 32) = v62.st_dev;
  *(void *)(v15 + 4dyld4::halt((char *)__format, 0) = st_ino;
  if (pread(v11, v66, 0x4000uLL, 0) != 0x4000)
  {
    uint64_t v18 = "shared cache file pread() failed";
    goto LABEL_10;
  }
  if (v66[0] != 0x2031765F646C7964 || v66[1] != 0x6534366D726120)
  {
    uint64_t v18 = "shared cache file has wrong magic";
    goto LABEL_10;
  }
  uint64_t v23 = v67;
  if (v67 >= 0xE0)
  {
    int v24 = *(_DWORD *)(v17 + 16);
    if (v75 == v24)
    {
      if ((v76 & 2) != 0)
      {
LABEL_22:
        uint64_t v18 = "shared cache file is for a different platform";
        goto LABEL_10;
      }
    }
    else if (!v80 || v80 != v24)
    {
      goto LABEL_22;
    }
  }
  unsigned int v25 = v68;
  if (v68 - 9 <= 0xFFFFFFF7)
  {
    uint64_t v18 = "shared cache file mappings are invalid";
    goto LABEL_10;
  }
  uint64_t v26 = (char *)v66 + v67;
  uint64_t v27 = v68 - 1;
  uint64_t v28 = *((void *)v26 + 2);
  if (v28)
  {
    uint64_t v29 = "shared cache text file offset is invalid";
    goto LABEL_28;
  }
  if (v71 + v70 != st_size)
  {
    uint64_t v29 = "shared cache code signature size is invalid";
LABEL_28:
    *(void *)(v15 + 16) = v29;
    if (v25 >= 2)
    {
LABEL_29:
      int v30 = *((_DWORD *)v26 + 6) | 4;
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (v68 >= 2)
  {
    if (*(_DWORD *)&v26[32 * v27 + 24] != 1) {
      *(void *)(v15 + 16) = "shared cache linkedit permissions are invalid";
    }
    goto LABEL_29;
  }
LABEL_30:
  int v30 = *((_DWORD *)v26 + 6);
LABEL_31:
  if (v30 != 5) {
    *(void *)(v15 + 16) = "shared cache text permissions are invalid";
  }
  if (*(void *)(v15 + 16)) {
    goto LABEL_11;
  }
  unsigned int v31 = 1;
  while (v25 != v31)
  {
    uint64_t v32 = &v26[32 * v31 - 32];
    uint64_t v34 = *(void *)v32;
    uint64_t v33 = *((void *)v32 + 1);
    if ((unint64_t)(v33 + v34) <= *(void *)&v26[32 * v31])
    {
      v28 += v33;
      uint64_t v35 = *(void *)&v26[32 * v31++ + 16];
      if (v28 == v35) {
        continue;
      }
    }
    uint64_t v18 = "shared cache mappings overlap";
    goto LABEL_10;
  }
  v65[0] = 0;
  v65[1] = v70;
  void v65[2] = v71;
  if (fcntl(v11, 97, v65) == -1)
  {
    uint64_t v18 = "code signature registration for shared cache failed";
    goto LABEL_10;
  }
  if (v65[0] < v70)
  {
    uint64_t v18 = "code signature does not cover entire shared cache file";
    goto LABEL_10;
  }
  uint64_t v36 = mmap(0, 0x4000uLL, 5, 2, v11, 0);
  if (v36 == (void *)-1)
  {
    uint64_t v18 = "first page of shared cache not mmap()able";
    goto LABEL_10;
  }
  uint64_t v61 = v36;
  if (_platform_memcmp(v36, v66, 0x4000uLL))
  {
    uint64_t v18 = "first page of mmap()ed shared cache not valid";
    goto LABEL_10;
  }
  munmap(v61, 0x4000uLL);
  uint64_t v37 = v68;
  *(_DWORD *)(v13 + 384) = v68;
  if (v37)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    unsigned int v40 = v67;
    int v41 = *(unsigned __int8 *)(v17 + 8);
    uint64_t v42 = 48 * v37;
    do
    {
      int v44 = *(_DWORD *)&v69[v23];
      int v43 = *(_DWORD *)&v69[v23 + 4];
      if (v40 > 0x138)
      {
        unint64_t v48 = (void *)((char *)&v66[v38] + v79);
        uint64_t v46 = v48[3];
        uint64_t v47 = v48[4];
        uint64_t v49 = v48[5];
        int v45 = ~(v49 << 6) & 0x40;
        if ((v49 & 4) != 0)
        {
          if (v41) {
            v44 |= 0x200u;
          }
          else {
            v43 |= 2u;
          }
        }
      }
      else if (v39 == 48)
      {
        int v45 = 0;
        uint64_t v46 = v72;
        uint64_t v47 = v73;
      }
      else
      {
        uint64_t v46 = 0;
        uint64_t v47 = 0;
        int v45 = 0;
      }
      uint64_t v50 = v13 + v39;
      *(_OWORD *)uint64_t v50 = *(_OWORD *)((char *)v66 + v23);
      uint64_t v51 = *(void *)((char *)&v66[2] + v23);
      *(void *)(v50 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(void *)(v50 + 32) = 0;
      *(void *)(v50 + 16) = v51;
      *(_DWORD *)(v50 + 4dyld4::halt((char *)__format, 0) = v44;
      *(_DWORD *)(v50 + 44) = v43;
      if (v47)
      {
        if (v25 <= 1)
        {
          *(_DWORD *)(v13 + 392) = v11;
          std::__throw_bad_optional_access[abi:nn180100]();
        }
        uint64_t v52 = v46 - *(void *)&v26[32 * v27 + 16] + *(void *)&v26[32 * v27];
        *(void *)(v50 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v47;
        *(void *)(v50 + 32) = v52;
        *(_DWORD *)(v50 + 4dyld4::halt((char *)__format, 0) = v44 | v45 | 0x20;
        *(_DWORD *)(v50 + 44) = v43 | v45 | 0x20;
      }
      v39 += 48;
      v23 += 32;
      v38 += 7;
    }
    while (v42 != v39);
    *(_DWORD *)(v13 + 392) = v11;
  }
  if (__offset_4 > 0x7F)
  {
    uint64_t v18 = "shared cache file subcache count exceeds limit";
    goto LABEL_10;
  }
  if (!v9 && __offset_4)
  {
    uint64_t v18 = "no shared cache subcache indices";
    goto LABEL_10;
  }
  unsigned int v53 = v67;
  *(unsigned char *)(v13 + 389) = v67 > 0x1C8;
  if (v53 >= 0x1C9)
  {
    if (pread(v11, __buf, 0x1C00uLL, __offseta) != 7168)
    {
      uint64_t v18 = "shared cache file pread() failed, could not read subcache entries";
      goto LABEL_10;
    }
    uint64_t v54 = __offset_4;
    if (__offset_4)
    {
      int v55 = &v64;
      do
      {
        long long v56 = *((_OWORD *)v55 + 1);
        _OWORD *v9 = *(_OWORD *)v55;
        v9[1] = v56;
        v9 += 2;
        v55 += 7;
        --v54;
      }
      while (v54);
    }
  }
  *(_OWORD *)(v13 + 40dyld4::halt((char *)__format, 0) = v77;
  *(void *)(v13 + 416) = v78;
  *(unsigned char *)(v13 + 388) = *(unsigned char *)(v17 + 11);
  *(_DWORD *)(v13 + 4++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = DyldSharedCache::numSubCaches((DyldSharedCache *)v66) + 1;
  uint64_t v57 = v85;
  uint64_t v58 = v74;
  *(void *)(v13 + 432) = v84 + v77;
  *(void *)(v13 + 44dyld4::halt((char *)__format, 0) = v57;
  BOOL v59 = v58 == 2 && v83 == 0;
  if (v58) {
    char v60 = v59;
  }
  else {
    char v60 = 1;
  }
  *(unsigned char *)(v15 + 48) = v60;
  return 1;
}

uint64_t dyld3::openat(dyld3 *this, const char *a2, const char *a3)
{
  int v4 = (int)this;
  for (uint64_t result = openat((int)this, a2, 0, 0); result == -1; uint64_t result = openat(v4, a2, 0, 0))
  {
    if (*__error() != 35 && *__error() != 4) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

ssize_t ___ZN5dyld3L26verboseSharedCacheMappingsEPK15DyldSharedCache_block_invoke(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return dyld4::console((dyld4 *)"        0x%08llX->0x%08llX init=%x, max=%x %s\n", a2, *(void *)(a1 + 32) + a3, a4 + *(void *)(a1 + 32) + a3 - 1, a7, a8, a2);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, unsigned int a2, char a3)
{
  return lsl::CRC32cSW::sCRC32cTable[(a2 ^ a3)] ^ (a2 >> 8);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, __int16 a3)
{
  __int16 v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, __int16 *, uint64_t))(*(void *)this + 32))(this, a2, &v4, 2);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, uint64_t *, uint64_t))(*(void *)this + 32))(this, a2, &v4, 8);
}

BOOL dyld4::RemoteNotificationResponder::active(dyld4::RemoteNotificationResponder *this)
{
  unint64_t v1 = *((unsigned int *)this + 10);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (_DWORD *)*((void *)this + 4);
  if (*v2) {
    return 1;
  }
  uint64_t v4 = 1;
  do
  {
    unint64_t v5 = v4;
    if (v1 == v4) {
      break;
    }
  }
  while (!v2[v4++]);
  return v5 < v1;
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges(dyld4::RemoteNotificationResponder *this, uint64_t a2, uint64_t a3, const mach_header **a4, const char **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    unint64_t v8 = a6;
    uint64_t v9 = a5;
    int v10 = a4;
    mach_msg_size_t v11 = a3;
    BOOL v12 = a2;
    uint64_t v13 = this;
    int v14 = 32 * a3;
    int v15 = 0;
    if (a3)
    {
      uint64_t v16 = a3;
      uint64_t v17 = a5;
      do
      {
        uint64_t v18 = *v17++;
        this = (dyld4::RemoteNotificationResponder *)_platform_strlen(v18);
        v15 += this + 1;
        --v16;
      }
      while (v16);
    }
    mach_msg_size_t v19 = (v14 + 48 + v15 + 127) & 0xFFFFFF80;
    if ((v19 | 0x44) <= 0x8000) {
      break;
    }
    dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges(v13, v12, v11 >> 1, v10, v9, v8);
    a3 = v11 - (v11 >> 1);
    a4 = &v10[v11 >> 1];
    a5 = &v9[v11 >> 1];
    this = v13;
    a2 = v12;
    a6 = v8;
  }
  v33[1] = (uint64_t)v33;
  uint64_t v34 = v13;
  __chkstk_darwin((uint64_t)this, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v33[0]);
  stat v22 = (mach_msg_header_t *)((char *)v33 - ((v21 + 15) & 0x1FFFFFFF0));
  v22[1].msgh_bits = 1;
  v22[1].msgh_vm_size_t size = v11;
  v22[1].msgh_remote_port = 48;
  v22[1].msgh_local_port = v20;
  *(void *)&v22[1].msgh_voucher_port = v8;
  if (v11)
  {
    unsigned int v23 = v22 + (v20 & 0xFFFFFFF0);
    int v24 = (char *)&v22[2];
    uint64_t v25 = v11;
    uint64_t v26 = (char *)v22 + (v20 & 0xFFFFFFF0);
    do
    {
      uint64_t v27 = *v9++;
      uint64_t v28 = strcpy(v26, v27);
      int v29 = _platform_strlen(v28);
      bzero(v24, 0x10uLL);
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)*v10, (unsigned __int8 *)v24);
      int v30 = *v10++;
      *((void *)v24 + 2) = v30;
      *((_DWORD *)v24 + 6) = v26 - v23;
      *((_DWORD *)v24 + 7) = v29;
      v26 += (v29 + 1);
      v24 += 32;
      --v25;
    }
    while (v25);
  }
  if (v12) {
    mach_msg_id_t v31 = 0x2000;
  }
  else {
    mach_msg_id_t v31 = 4096;
  }
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)v34, v31, v19, v22);
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfMainCalled(dyld4::RemoteNotificationResponder *this)
{
  dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3);
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 16385, 0x18u, &v4);
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfDyldBeforeInitializers(dyld4::RemoteNotificationResponder *this)
{
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 16386, 0x18u, &v2);
}

uint64_t dyld4::APIs::_dyld_get_dlopen_image_header(dyld4::Loader **this, dyld4::Loader *a2)
{
  uint64_t v3 = a2;
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_get_dlopen_image_header(%p)\n", a2);
  }
  if (v3 == (const dyld4::Loader *)-5)
  {
    uint64_t ImageContaining = this[3];
    goto LABEL_12;
  }
  if (v3)
  {
    if (v3 == (const dyld4::Loader *)-3)
    {
      uint64_t ImageContaining = (dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, v2);
      if (ImageContaining) {
        goto LABEL_12;
      }
    }
    uint64_t v3 = (const dyld4::Loader *)((unint64_t)v3 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A8DFD000);
  }
  if (!dyld4::APIs::validLoader(this, v3)) {
    return 0;
  }
  uint64_t ImageContaining = v3;
LABEL_12:

  return dyld4::Loader::analyzer(ImageContaining, (dyld4::RuntimeState *)this);
}

uint64_t dyld4::APIs::dyld_get_program_sdk_watch_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  unsigned int v6[2] = 0x2000000000;
  char v7 = 0;
  mach_msg_header_t v2 = *(unsigned int **)(*((void *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs37dyld_get_program_sdk_watch_os_versionEv_block_invoke;
  void v5[3] = &unk_1EFF65138;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_watch_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs37dyld_get_program_sdk_watch_os_versionEv_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v4 = result;
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if (result == 4)
    {
      *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_watch_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  unsigned int v6[2] = 0x2000000000;
  char v7 = 0;
  mach_msg_header_t v2 = *(unsigned int **)(*((void *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs37dyld_get_program_min_watch_os_versionEv_block_invoke;
  void v5[3] = &unk_1EFF65160;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_min_watch_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs37dyld_get_program_min_watch_os_versionEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v5 = result;
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if (result == 4)
    {
      *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a4;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_bridge_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  unsigned int v6[2] = 0x2000000000;
  char v7 = 0;
  mach_msg_header_t v2 = *(unsigned int **)(*((void *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs38dyld_get_program_sdk_bridge_os_versionEv_block_invoke;
  void v5[3] = &unk_1EFF65188;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_bridge_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs38dyld_get_program_sdk_bridge_os_versionEv_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v4 = result;
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if (result == 5)
    {
      *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_bridge_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  v6[0] = 0;
  v6[1] = v6;
  unsigned int v6[2] = 0x2000000000;
  char v7 = 0;
  mach_msg_header_t v2 = *(unsigned int **)(*((void *)this + 1) + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs38dyld_get_program_min_bridge_os_versionEv_block_invoke;
  void v5[3] = &unk_1EFF651B0;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_min_bridge_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs38dyld_get_program_min_bridge_os_versionEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v5 = result;
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if (result == 5)
    {
      *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a4;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_sdk_version(dyld4::APIs *this, const mach_header *a2)
{
  uint64_t SdkVersion = dyld4::APIs::getSdkVersion(this, a2);
  uint64_t v5 = SdkVersion;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_sdk_version(%p) => 0x%08X\n", a2, SdkVersion);
  }
  return v5;
}

uint64_t dyld4::APIs::dyld_get_min_os_version(dyld4::APIs *this, const mach_header *a2)
{
  v11[0] = 0;
  v11[1] = v11;
  long long v11[2] = 0x2000000000;
  char v12 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  int v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZN5dyld44APIs23dyld_get_min_os_versionEPK11mach_header_block_invoke;
  void v6[3] = &unk_1EFF65200;
  void v6[5] = &v7;
  void v6[6] = this;
  v6[4] = v11;
  dyld4::APIs::forEachImageVersion((uint64_t)this, &a2->magic, (uint64_t)v6);
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_min_os_version(%p) => 0x%08X\n", a2, *((_DWORD *)v8 + 6));
  }
  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(v11, 8);
  return v4;
}

uint64_t ___ZN5dyld44APIs23dyld_get_min_os_versionEPK11mach_header_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(result + 32) + 8);
  if (!*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = result;
    int v6 = *(_DWORD *)(*(void *)(*(void *)(result + 48) + 8) + 68);
    if (v6 == a2)
    {
      *(unsigned char *)(v4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      uint64_t result = dyld3::MachOFile::basePlatform(a2);
      int v8 = a4 + 458752;
      int v9 = a4 + 589824;
      if (result != 5) {
        int v9 = a4;
      }
      if (result != 4) {
        int v8 = v9;
      }
      goto LABEL_10;
    }
    if (a2 == 7 && v6 == 6)
    {
      *(unsigned char *)(v4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      int v8 = 786432;
LABEL_10:
      *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
    }
  }
  return result;
}

uint64_t dyld4::APIs::dyld_is_simulator_platform(dyld4::APIs *this, int a2)
{
  uint64_t isSimulatorPlatform = dyld3::MachOFile::isSimulatorPlatform(a2, 0);
  uint64_t v5 = isSimulatorPlatform;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_is_simulator_platform(%d) => %d\n", a2, isSimulatorPlatform);
  }
  return v5;
}

uint64_t dyld4::APIs::dyld_minos_at_least(dyld4::RuntimeState *a1, unsigned int *a2, unint64_t a3)
{
  unint64_t v6 = dyld4::APIs::mapFromVersionSet((uint64_t)a1, a3, *(unsigned int *)(*((void *)a1 + 1) + 68));
  uint64_t v10 = 0;
  int v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unsigned int v9[2] = ___ZN5dyld44APIs19dyld_minos_at_leastEPK11mach_header20dyld_build_version_t_block_invoke;
  void v9[3] = &unk_1EFF65250;
  void v9[4] = &v10;
  void v9[5] = v6;
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)v9);
  if (*(unsigned char *)(*((void *)a1 + 1) + 204)) {
    dyld4::RuntimeState::log(a1, "dyld_minos_at_least(%p, <%d,0x%08X>) => %d\n", a2, a3, HIDWORD(a3), *((unsigned __int8 *)v11 + 24));
  }
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t ___ZN5dyld44APIs19dyld_minos_at_leastEPK11mach_header20dyld_build_version_t_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7 = dyld3::MachOFile::basePlatform(a2);
  uint64_t result = dyld3::MachOFile::basePlatform(*(unsigned int *)(a1 + 40));
  if (v7 == result)
  {
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if (result)
    {
      if (*(_DWORD *)(a1 + 44) <= a4) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      }
    }
  }
  return result;
}

unint64_t dyld4::APIs::dyld_get_program_minos_version_token(dyld4::APIs *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 68) | ((unint64_t)*(unsigned int *)(*((void *)this + 1)
                                                                                              + 56) << 32);
}

uint64_t dyld4::APIs::dyld_version_token_get_platform(dyld4::APIs *this, uint64_t a2)
{
  return a2;
}

BOOL dyld4::APIs::dyld_version_token_at_least(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = dyld4::APIs::mapFromVersionSet(a1, a3, a2);
  BOOL result = 0;
  if (a2)
  {
    unsigned int v5 = HIDWORD(v4);
    if (dyld3::MachOFile::basePlatform(a2) == v4 && HIDWORD(a2) >= v5) {
      return 1;
    }
  }
  return result;
}

uint64_t dyld4::APIs::linkedDylibVersion(dyld4::APIs *this, const dyld3::MachOFile *a2, const char *a3)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZN5dyld44APIs18linkedDylibVersionEPKN5dyld39MachOFileEPKc_block_invoke;
  void v5[3] = &unk_1EFF65278;
  v5[4] = &v6;
  void v5[5] = a3;
  dyld3::MachOFile::forEachDependentDylib(a2, (uint64_t)v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs18linkedDylibVersionEPKN5dyld39MachOFileEPKc_block_invoke(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned char *a8)
{
  uint64_t result = _platform_strcmp(__s1, *(const char **)(a1 + 40));
  if (!result)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a7;
    *a8 = 1;
  }
  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_os_version(dyld4::APIs *this)
{
  return (*(uint64_t (**)(dyld4::APIs *, void))(*(void *)this + 392))(this, *(void *)(*((void *)this + 1) + 8));
}

void dyld4::APIs::_dyld_objc_notify_register(dyld4::APIs *this, void (*a2)(unsigned int, const char *const *, const mach_header *const *), void (*a3)(const char *, const mach_header *), void (*a4)(const char *, const mach_header *))
{
}

void *___ZN5dyld44APIs6dladdrEPKvP7dl_info_block_invoke(void *result, uint64_t a2, unsigned char *a3)
{
  unint64_t v3 = result[6];
  unint64_t v4 = result[5] + *(void *)(a2 + 16);
  if (v4 <= v3 && v3 < *(void *)(a2 + 24) + v4)
  {
    *(unsigned char *)(*(void *)(result[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::halt("_dyld_objc_notify_register is unsupported", 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke(void *a1, dyld3 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1[6];
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x3002000000;
  uint64_t v18 = __Block_byref_object_copy__6;
  mach_msg_size_t v19 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v20);
  uint64_t v8 = *(void *)(v7 + 8);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  _WORD v14[2] = ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke_2;
  void v14[3] = &unk_1EFF65440;
  uint64_t v9 = a1[7];
  void v14[6] = v7;
  void v14[7] = v9;
  uint64_t v10 = a1[4];
  _OWORD v14[4] = &v15;
  void v14[5] = v10;
  unsigned __int8 v14[8] = a4;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v8, (vm_address_t *)v16 + 5, a2, 1, (uint64_t)v14);
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24) && Diagnostics::hasError((Diagnostics *)(v16 + 5)))
  {
    BOOL v11 = Diagnostics::noError((Diagnostics *)(*(void *)(a1[5] + 8) + 40));
    uint64_t v12 = (vm_address_t *)(*(void *)(a1[5] + 8) + 40);
    char v13 = (const char *)Diagnostics::errorMessage((Diagnostics *)(v16 + 5));
    if (v11) {
      Diagnostics::error(v12, "tried: '%s' (%s)", (const char *)a2, v13);
    }
    else {
      Diagnostics::appendError(v12, ", '%s' (%s)", (const char *)a2, v13);
    }
  }
  _Block_object_dispose(&v15, 8);
  mach_o::Error::~Error(&v20);
}

int *___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke_2(uint64_t a1, dyld3::FatFile *this, unint64_t a3, int a4)
{
  unint64_t v6 = 0;
  uint64_t result = dyld3::MachOFile::compatibleSlice((vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), &v6, this, a3, *(const char **)(a1 + 56), *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 68), a4, *(dyld3::GradedArchs **)(*(void *)(*(void *)(a1 + 48) + 8) + 144), *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 169));
  if (result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    **(unsigned char **)(a1 + 64) = 1;
  }
  return result;
}

uint64_t dyld4::APIs::dlopen_audited(dyld4::APIs *this, const char *a2)
{
  return (*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 112))(this, a2);
}

__n128 __Block_byref_object_copy__96(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  long long v3 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::halt("_dyld_objc_notify_register is unsupported", 0) = result;
  return result;
}

BOOL dyld4::APIs::_dyld_shared_cache_optimized(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(void *)(v1 + 240);
  if (v2) {
    BOOL v3 = *(void *)(v2 + 104) == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (*(unsigned char *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_shared_cache_optimized() => %d\n", v3);
  }
  return v3;
}

const os_unfair_lock *dyld4::APIs::_dyld_register_for_image_loads(uint64_t **this, void (*a2)(const mach_header *, const char *, BOOL))
{
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_for_image_loads(%p)\n", a2);
  }
  unint64_t v4 = this[17];
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000;
  v22[2] = ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke;
  v22[3] = &__block_descriptor_tmp_118_1;
  v22[4] = this;
  v22[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v22);
  __n128 result = (const os_unfair_lock *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  unint64_t v6 = this[16];
  uint64_t v7 = this[17];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  uint64_t v17 = ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke_2;
  uint64_t v18 = &__block_descriptor_tmp_119_0;
  mach_msg_size_t v19 = (dyld4::APIs *)this;
  mach_port_t v20 = result;
  uint64_t v21 = a2;
  int v24 = v6;
  unint64_t v23 = 0;
  if (v6) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0;
  }
  if (*((unsigned char *)v8 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_44;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    unint64_t v23 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v23)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_44;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      __n128 result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v9 = MEMORY[0xFFFFFC0D0];
      if (v9 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_44;
      }
    }
  }
  else
  {
    unint64_t v23 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v8, &v25);
    uint64_t v10 = v8[3];
    if (!v10)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v8, 0);
      uint64_t v10 = v8[3];
    }
    void v8[3] = v10 + 1;
    lsl::Lock::unlock(v25);
  }
  if (*v7)
  {
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)*v7 + 104))(*v7, v7 + 2, 0);
    v17((uint64_t)v16);
    __n128 result = (const os_unfair_lock *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)*v7 + 112))(*v7, v7 + 2);
  }
  else
  {
    __n128 result = (const os_unfair_lock *)v17((uint64_t)v16);
  }
  if (v24) {
    BOOL v11 = v24;
  }
  else {
    BOOL v11 = 0;
  }
  if (*((unsigned char *)v11 + 32))
  {
    if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_44;
    }
    if (v23 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
      return result;
    }
    if (v23 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      __n128 result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v12 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_44;
      }
      __n128 result = (const os_unfair_lock *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v12 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v12 == StatusReg) {
      return result;
    }
LABEL_44:
    __break(1u);
    return result;
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v11, &v25);
  if (v23 == 1)
  {
    uint64_t v15 = v11[3] - 1;
    void v11[3] = v15;
    if (!v15) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v11, 1);
    }
  }
  else if (v23 == 0xFFFFFFFF)
  {
    uint64_t v14 = v11[3];
    if (!v14)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v11, 0);
      uint64_t v14 = v11[3];
    }
    void v11[3] = v14 + 1;
  }
  return lsl::Lock::unlock(v25);
}

uint64_t ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 32);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    unint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    unint64_t v6 = v4;
    do
    {
      uint64_t v7 = *v6;
      uint64_t Address = (const void *)dyld4::Loader::loadAddress(*v6, v1);
      uint64_t v9 = Address;
      if (*(unsigned char *)(*((void *)v1 + 1) + 205)) {
        dyld4::RuntimeState::log(v1, "add notifier %p called with mh=%p\n", *(const void **)(v3 + 40), Address);
      }
      uint64_t v10 = *(uint64_t (**)(const void *, uint64_t, BOOL))(v3 + 40);
      uint64_t v11 = dyld4::Loader::path(v7, v1);
      __n128 result = v10(v9, v11, (*((_WORD *)v7 + 2) & 0x20) == 0);
      ++v6;
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  return result;
}

uint64_t ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke_2(uint64_t a1)
{
  return dyld4::RuntimeState::addNotifyLoadImage(*(dyld4::RuntimeState **)(a1 + 32), *(const dyld4::Loader **)(a1 + 40), *(void (**)(const mach_header *, const char *, BOOL))(a1 + 48));
}

const char *dyld4::APIs::dyld_shared_cache_file_path(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(const char **)(v1 + 280);
  if (*(unsigned char *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_file_path() => %s\n", v2);
  }
  return v2;
}

uint64_t dyld4::findCacheInDirAndMap(dyld4 *this, dyld4::RuntimeState *a2, char *a3, const char *a4, unint64_t *a5)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  uint64_t v5 = *((void *)this + 1);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZN5dyld4L20findCacheInDirAndMapERNS_12RuntimeStateEPKhPKcRm_block_invoke;
  void v8[3] = &unk_1EFF65688;
  void v8[4] = &v9;
  void v8[5] = a2;
  void v8[6] = a4;
  dyld4::SyscallDelegate::forEachInDirectory(v5, a3, 0, (uint64_t)v8);
  uint64_t v6 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t (***dyld4::APIs::_dyld_fork_child(dyld4::APIs *this))(void)
{
  mach_task_self_ = task_self_trap();
  dyld4::ExternallyViewableState::fork_child((uint64_t)this + 536);
  uint64_t v2 = (dyld4::RuntimeLocks *)*((void *)this + 17);

  return dyld4::RuntimeLocks::resetLockInForkChild(v2);
}

unint64_t dyld4::APIs::_dyld_atfork_prepare(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::takeLockBeforeFork(this[17]);
}

unint64_t dyld4::APIs::_dyld_atfork_parent(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::releaseLockInForkParent(this[17]);
}

uint64_t dyld4::APIs::_dyld_before_fork_dlopen(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::takeDlopenLockBeforeFork(this[17]);
}

uint64_t dyld4::APIs::_dyld_after_fork_dlopen_parent(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::releaseDlopenLockInForkParent(this[17]);
}

uint64_t (***dyld4::APIs::_dyld_after_fork_dlopen_child(dyld4::RuntimeLocks **this))(void)
{
  return dyld4::RuntimeLocks::resetDlopenLockInForkChild(this[17]);
}

uint64_t dyld4::APIs::_dyld_visit_objc_classes(dyld4::RuntimeState *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (*(unsigned char *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_visit_objc_classes()\n");
    uint64_t v4 = *((void *)this + 1);
  }
  uint64_t result = *(void *)(v4 + 312);
  if (result)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    unsigned int v6[2] = ___ZN5dyld44APIs24_dyld_visit_objc_classesEU13block_pointerFvPKvE_block_invoke;
    void v6[3] = &unk_1EFF65640;
    v6[4] = a2;
    void v6[5] = this;
    return objc::ObjectHashTable::forEachObject(result, (uint64_t)v6);
  }
  return result;
}

uint64_t ___ZN5dyld44APIs24_dyld_visit_objc_classesEU13block_pointerFvPKvE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = a4[2];
  if (v4)
  {
    uint64_t v5 = result;
    uint64_t v6 = *a4;
    uint64_t v7 = 16 * v4;
    do
    {
      v6 += 16;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v5 + 32) + 16))();
      v7 -= 16;
    }
    while (v7);
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_is_preoptimized_objc_image_loaded(dyld4::APIs *this, unsigned int a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (!*(void *)(v4 + 240))
  {
    if (*(unsigned char *)(v4 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : no dyld shared cache\n");
    }
    return 0;
  }
  uint64_t v5 = *(unsigned int **)(v4 + 296);
  if (!v5)
  {
    if (*(unsigned char *)(v4 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : no objC RW header\n");
    }
    return 0;
  }
  if (*v5 <= a2)
  {
    if (*(unsigned char *)(v4 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : imageID is invalid\n");
    }
    return 0;
  }
  uint64_t isLoaded = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(v5, a2);
  uint64_t v7 = isLoaded;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) => %d\n", a2, isLoaded);
  }
  return v7;
}

uint64_t dyld4::APIs::_dyld_objc_uses_large_shared_cache(dyld4::APIs *this)
{
  return 1;
}

BOOL dyld4::EqualMetadataConformanceLookupKey::equal(uint64_t a1, uint64_t a2, uint64_t a3, dyld4::RuntimeState *a4)
{
  if (!a4) {
    dyld4::EqualMetadataConformanceLookupKey::equal();
  }
  return dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)a1, a4) == a2
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a4) == a3;
}

dyld4::RuntimeState *dyld4::APIs::_dyld_pseudodylib_register_callbacks(dyld4::RuntimeState *this, const void *a2)
{
  uint64_t v2 = this;
  uint64_t v16 = a2;
  uint64_t v3 = *((void *)this + 1);
  if (!*(unsigned char *)(v3 + 192))
  {
    if (*(unsigned char *)(v3 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register_callbacks() => nullptr: blocked by security policy");
    }
    return 0;
  }
  _WORD v14[2] = this;
  uint64_t v15 = 0;
  uint64_t v4 = *((void *)this + 16);
  uint64_t v5 = (void *)*((void *)this + 17);
  v14[0] = &v16;
  v14[1] = &v15;
  uint64_t v18 = v4;
  unint64_t v17 = 0;
  if (v4) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = 0;
  }
  if (*(unsigned char *)(v6 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_50;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_50;
    }
    unint64_t v17 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v17)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_50;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_50;
      }
      this = (dyld4::RuntimeState *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v7 = MEMORY[0xFFFFFC0D0];
      if (v7 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_50;
      }
    }
  }
  else
  {
    unint64_t v17 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v6, &v19);
    uint64_t v8 = *(void *)(v6 + 24);
    if (!v8)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v6, 0);
      uint64_t v8 = *(void *)(v6 + 24);
    }
    *(void *)(v6 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8 + 1;
    lsl::Lock::unlock(v19);
  }
  if (*v5)
  {
    (*(void (**)(void, void *, void))(*(void *)*v5 + 104))(*v5, v5 + 1, 0);
    dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(v14);
    this = (dyld4::RuntimeState *)(*(uint64_t (**)(void, void *))(*(void *)*v5 + 112))(*v5, v5 + 1);
  }
  else
  {
    this = (dyld4::RuntimeState *)dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(v14);
  }
  if (v18) {
    uint64_t v9 = v18;
  }
  else {
    uint64_t v9 = 0;
  }
  if (!*(unsigned char *)(v9 + 32))
  {
    lsl::MemoryManager::lockGuard((lsl::Lock *)v9, &v19);
    if (v17 == 1)
    {
      uint64_t v13 = *(void *)(v9 + 24) - 1;
      *(void *)(v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v13;
      if (!v13) {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v9, 1);
      }
    }
    else if (v17 == 0xFFFFFFFF)
    {
      uint64_t v12 = *(void *)(v9 + 24);
      if (!v12)
      {
        lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v9, 0);
        uint64_t v12 = *(void *)(v9 + 24);
      }
      *(void *)(v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12 + 1;
    }
    lsl::Lock::unlock(v19);
    goto LABEL_45;
  }
  if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
    goto LABEL_50;
  }
  if (v17 != ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1))
  {
    if (v17 == 1)
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_50;
      }
      this = (dyld4::RuntimeState *)MEMORY[0xFFFFFC0D0];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v10 = MEMORY[0xFFFFFC0D0];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    else
    {
      if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_50;
      }
      this = (dyld4::RuntimeState *)MEMORY[0xFFFFFC0D8];
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
      __isb(0xFu);
      uint64_t v10 = MEMORY[0xFFFFFC0D8];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
    }
    if (v10 == StatusReg) {
      goto LABEL_45;
    }
LABEL_50:
    __break(1u);
    return this;
  }
LABEL_45:
  this = v15;
  if (v15) {
    return this;
  }
  if (*(unsigned char *)(*((void *)v2 + 1) + 204))
  {
    dyld4::RuntimeState::log(v2, "_dyld_pseudodylib_register_callbacks(%p): callbacks struct version not recognized", v16);
    return v15;
  }
  return 0;
}

void dyld4::APIs::_dyld_pseudodylib_deregister_callbacks(dyld4::RuntimeState *this, void *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if (*(unsigned char *)(v3 + 192))
  {
    if (a2)
    {
      uint64_t v5 = (void *)*((void *)this + 17);
      uint64_t v14 = *((void *)this + 16);
      if (v14) {
        uint64_t v6 = *((void *)this + 16);
      }
      else {
        uint64_t v6 = 0;
      }
      if (*(unsigned char *)(v6 + 32))
      {
        if (!MEMORY[0xFFFFFC10C]) {
          goto LABEL_46;
        }
        if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_46;
        }
        unint64_t v13 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
        if (!v13)
        {
          if (!MEMORY[0xFFFFFC10C]) {
            goto LABEL_46;
          }
          if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_46;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
          __isb(0xFu);
          uint64_t v7 = MEMORY[0xFFFFFC0D0];
          if (v7 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
            goto LABEL_46;
          }
        }
      }
      else
      {
        unint64_t v13 = 1;
        lsl::MemoryManager::lockGuard((lsl::Lock *)v6, &v15);
        uint64_t v8 = *(void *)(v6 + 24);
        if (!v8)
        {
          lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v6, 0);
          uint64_t v8 = *(void *)(v6 + 24);
        }
        *(void *)(v6 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8 + 1;
        lsl::Lock::unlock(v15);
      }
      if (*v5)
      {
        (*(void (**)(void, void *, void))(*(void *)*v5 + 104))(*v5, v5 + 1, 0);
        lsl::Allocator::free(*((lsl::Lock ***)this + 2), a2);
        (*(void (**)(void, void *))(*(void *)*v5 + 112))(*v5, v5 + 1);
      }
      else
      {
        lsl::Allocator::free(*((lsl::Lock ***)this + 2), a2);
      }
      if (v14) {
        uint64_t v9 = v14;
      }
      else {
        uint64_t v9 = 0;
      }
      if (*(unsigned char *)(v9 + 32))
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_46;
        }
        if (v13 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
          return;
        }
        if (v13 == 1)
        {
          if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_46;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
          __isb(0xFu);
          uint64_t v10 = MEMORY[0xFFFFFC0D0];
          unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
        }
        else
        {
          if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_46;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
          __isb(0xFu);
          uint64_t v10 = MEMORY[0xFFFFFC0D8];
          unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
        }
        if (v10 == StatusReg) {
          return;
        }
LABEL_46:
        __break(1u);
        return;
      }
      lsl::MemoryManager::lockGuard((lsl::Lock *)v9, &v15);
      if (v13 == 1)
      {
        uint64_t v12 = *(void *)(v9 + 24) - 1;
        *(void *)(v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12;
        if (!v12) {
          lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v9, 1);
        }
      }
      lsl::Lock::unlock(v15);
    }
  }
  else if (*(unsigned char *)(v3 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_pseudodylib_deregister_callbacks(): blocked by security policy");
  }
}

void dyld4::APIs::_dyld_pseudodylib_register(dyld4::RuntimeState *this, dyld3::MachOFile *a2, uint64_t a3, const void *a4, const void *a5)
{
  uint64_t v28 = a3;
  int v29 = a2;
  uint64_t v26 = a5;
  uint64_t v27 = a4;
  uint64_t v6 = *((void *)this + 1);
  if (*(unsigned char *)(v6 + 192))
  {
    uint64_t v11 = dyld3::MachOFile::installName(a2);
    uint64_t v25 = v11;
    if (v11)
    {
      if (*(unsigned char *)(*((void *)this + 1) + 204)) {
        dyld4::RuntimeState::log(this, "_dyld_register_pseudodylib(%p, %lx, %p, %p): [%p, %p) \"%s\"\n", a2, a3, a4, a5, a2, (char *)a2 + a3, v11);
      }
      uint64_t v24 = 0;
      uint64_t v12 = *((void *)this + 16);
      unint64_t v13 = (void *)*((void *)this + 17);
      v22[0] = this;
      v22[1] = &v25;
      v22[2] = &v23;
      v22[3] = &v29;
      v22[4] = &v28;
      v22[5] = &v27;
      void v22[6] = &v26;
      void v22[7] = &v24;
      uint64_t v23 = 0;
      uint64_t v31 = v12;
      unint64_t v30 = 0;
      if (v12) {
        uint64_t v14 = v12;
      }
      else {
        uint64_t v14 = 0;
      }
      if (*(unsigned char *)(v14 + 32))
      {
        if (!MEMORY[0xFFFFFC10C]) {
          goto LABEL_57;
        }
        if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_57;
        }
        unint64_t v30 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
        if (!v30)
        {
          if (!MEMORY[0xFFFFFC10C]) {
            goto LABEL_57;
          }
          if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_57;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
          __isb(0xFu);
          uint64_t v15 = MEMORY[0xFFFFFC0D0];
          if (v15 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
            goto LABEL_57;
          }
        }
      }
      else
      {
        unint64_t v30 = 1;
        lsl::MemoryManager::lockGuard((lsl::Lock *)v14, &v32);
        uint64_t v16 = *(void *)(v14 + 24);
        if (!v16)
        {
          lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v14, 0);
          uint64_t v16 = *(void *)(v14 + 24);
        }
        *(void *)(v14 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16 + 1;
        lsl::Lock::unlock(v32);
      }
      if (*v13)
      {
        (*(void (**)(void, void *, void))(*(void *)*v13 + 104))(*v13, v13 + 1, 0);
        dyld4::APIs::_dyld_pseudodylib_register(void *,unsigned long,_dyld_pseudodylib_callbacks_opaque *,void *)::$_0::operator()((uint64_t)v22);
        (*(void (**)(void, void *))(*(void *)*v13 + 112))(*v13, v13 + 1);
      }
      else
      {
        dyld4::APIs::_dyld_pseudodylib_register(void *,unsigned long,_dyld_pseudodylib_callbacks_opaque *,void *)::$_0::operator()((uint64_t)v22);
      }
      if (v31) {
        uint64_t v17 = v31;
      }
      else {
        uint64_t v17 = 0;
      }
      if (!*(unsigned char *)(v17 + 32))
      {
        lsl::MemoryManager::lockGuard((lsl::Lock *)v17, &v32);
        if (v30 == 1)
        {
          uint64_t v21 = *(void *)(v17 + 24) - 1;
          *(void *)(v17 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v21;
          if (!v21) {
            lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v17, 1);
          }
        }
        else if (v30 == 0xFFFFFFFF)
        {
          uint64_t v20 = *(void *)(v17 + 24);
          if (!v20)
          {
            lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v17, 0);
            uint64_t v20 = *(void *)(v17 + 24);
          }
          *(void *)(v17 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v20 + 1;
        }
        lsl::Lock::unlock(v32);
        goto LABEL_50;
      }
      if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
      {
        if (v30 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
          goto LABEL_50;
        }
        if (v30 == 1)
        {
          if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_57;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
          __isb(0xFu);
          uint64_t v18 = MEMORY[0xFFFFFC0D0];
          unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
        }
        else
        {
          if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
            goto LABEL_57;
          }
          _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
          __isb(0xFu);
          uint64_t v18 = MEMORY[0xFFFFFC0D8];
          unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
        }
        if (v18 == StatusReg)
        {
LABEL_50:
          if (v23)
          {
            if (*(unsigned char *)(*((void *)this + 1) + 204)) {
              dyld4::RuntimeState::log(this, "_dyld_register_pseudodylib(\"%s\", %p, %lx): identifier conflicts with existing registration covering [%p, %p)", v25, v29, v28, *(const void **)v23, (const void *)(*(void *)v23 + *(void *)(v23 + 8)));
            }
            if (v24) {
              dyld4::APIs::_dyld_pseudodylib_register();
            }
          }
          return;
        }
      }
LABEL_57:
      __break(1u);
      return;
    }
    if (*(unsigned char *)(*((void *)this + 1) + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_register_pseudodylib(%p, %lx, %p, %p): registered range does not contain an install name");
    }
  }
  else if (*(unsigned char *)(v6 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register() => nullptr: blocked by security policy");
  }
}

void dyld4::APIs::_dyld_pseudodylib_deregister(lsl::Lock ***this, const char **a2)
{
  if (*((unsigned char *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_deregister_pseudodylib(<handle for \"%s\">)\n", a2[4]);
  }
  uint64_t v4 = this[17];
  stat v22 = this[16];
  if (v22) {
    uint64_t v5 = this[16];
  }
  else {
    uint64_t v5 = 0;
  }
  if (*((unsigned char *)v5 + 32))
  {
    if (!MEMORY[0xFFFFFC10C]) {
      goto LABEL_60;
    }
    if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
      goto LABEL_60;
    }
    unint64_t v21 = (_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1;
    if (!v21)
    {
      if (!MEMORY[0xFFFFFC10C]) {
        goto LABEL_60;
      }
      if ((MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
        goto LABEL_60;
      }
      _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
      __isb(0xFu);
      uint64_t v6 = MEMORY[0xFFFFFC0D0];
      if (v6 != _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5))) {
        goto LABEL_60;
      }
    }
  }
  else
  {
    unint64_t v21 = 1;
    lsl::MemoryManager::lockGuard((lsl::Lock *)v5, &v23);
    uint64_t v7 = v5[3];
    if (!v7)
    {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v5, 0);
      uint64_t v7 = v5[3];
    }
    void v5[3] = (lsl::Lock *)((char *)v7 + 1);
    lsl::Lock::unlock(v23);
  }
  if (*v4)
  {
    (*(void (**)(lsl::Lock *, lsl::Lock **, void))(*(void *)*v4 + 104))(*v4, v4 + 1, 0);
    uint64_t v8 = this[76];
    if (v8)
    {
      uint64_t v9 = this[75];
      uint64_t v10 = 8 * (void)v8 - 8;
      uint64_t v11 = v9 + 1;
      while ((const char **)*(v11 - 1) != a2)
      {
        ++v9;
        v10 -= 8;
        ++v11;
        if (v10 == -8) {
          goto LABEL_22;
        }
      }
      for (; v10; v10 -= 8)
      {
        *(v11 - 1) = *v11;
        *v11++ = 0;
        ++v9;
      }
      this[76] = (lsl::Lock **)((char *)v8 - 1);
      lsl::Allocator::free(this[2], a2);
      int v12 = 1;
    }
    else
    {
LABEL_22:
      int v12 = 0;
    }
    (*(void (**)(lsl::Lock *, lsl::Lock **))(*(void *)*v4 + 112))(*v4, v4 + 1);
  }
  else
  {
    unint64_t v13 = this[76];
    if (v13)
    {
      uint64_t v14 = this[75];
      uint64_t v15 = 8 * (void)v13 - 8;
      uint64_t v16 = v14 + 1;
      while ((const char **)*(v16 - 1) != a2)
      {
        ++v14;
        v15 -= 8;
        ++v16;
        if (v15 == -8) {
          goto LABEL_27;
        }
      }
      for (; v15; v15 -= 8)
      {
        *(v16 - 1) = *v16;
        *v16++ = 0;
        ++v14;
      }
      this[76] = (lsl::Lock **)((char *)v13 - 1);
      lsl::Allocator::free(this[2], a2);
      int v12 = 1;
    }
    else
    {
LABEL_27:
      int v12 = 0;
    }
  }
  if (v22) {
    uint64_t v17 = v22;
  }
  else {
    uint64_t v17 = 0;
  }
  if (*((unsigned char *)v17 + 32))
  {
    if (MEMORY[0xFFFFFC10C] && (MEMORY[0xFFFFFC10C] & 0xFE) == 2)
    {
      if (v21 == ((_ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5)) >> 36) & 1)) {
        goto LABEL_49;
      }
      if (v21 == 1)
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_60;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D0]);
        __isb(0xFu);
        uint64_t v18 = MEMORY[0xFFFFFC0D0];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      else
      {
        if (!MEMORY[0xFFFFFC10C] || (MEMORY[0xFFFFFC10C] & 0xFE) != 2) {
          goto LABEL_60;
        }
        _WriteStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5), MEMORY[0xFFFFFC0D8]);
        __isb(0xFu);
        uint64_t v18 = MEMORY[0xFFFFFC0D8];
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 6, 15, 1, 5));
      }
      if (v18 == StatusReg)
      {
LABEL_49:
        if (v12) {
          return;
        }
        goto LABEL_54;
      }
    }
LABEL_60:
    __break(1u);
    JUMPOUT(0x1A8E4EB18);
  }
  lsl::MemoryManager::lockGuard((lsl::Lock *)v17, &v23);
  if (v21 == 1)
  {
    uint64_t v20 = (uint64_t)v17[3] - 1;
    v17[3] = (lsl::Lock *)v20;
    if (!v20) {
      lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v17, 1);
    }
  }
  lsl::Lock::unlock(v23);
  if (!v12)
  {
LABEL_54:
    if (*((unsigned char *)this[1] + 204)) {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_deregister_pseudodylib(<handle for \"%s\">): no registered pseudo-dylib for handle", a2[4]);
    }
  }
}

uint64_t dyld4::APIs::_dyld_has_fix_for_radar(dyld4::APIs *this, const char *a2)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_has_fix_for_radar(%s)\n", a2);
  }
  return 0;
}

void dyld4::APIs::_dyld_register_driverkit_main(dyld4::APIs *this, void (*a2)(void))
{
  uint64_t v4 = *((void *)this + 1);
  if (*(unsigned char *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_register_driverkit_main(%p)\n", a2);
    uint64_t v4 = *((void *)this + 1);
  }
  if (*(_DWORD *)(v4 + 68) == 10)
  {
    if (*((void *)this + 129)) {
      dyld4::halt("_dyld_register_driverkit_main() may only be called once", 0);
    }
    *((void *)this + 129) = a2;
  }
  else
  {
    dyld4::RuntimeState::log(this, "_dyld_register_driverkit_main() can only be called in DriverKit processes\n");
  }
}

uint64_t dyld4::APIs::_dyld_shared_cache_is_locally_built(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(void *)(v1 + 240);
  if (v2) {
    uint64_t v3 = (*(unsigned __int8 *)(v2 + 221) >> 2) & 1;
  }
  else {
    uint64_t v3 = 0;
  }
  if (*(unsigned char *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_shared_cache_is_locally_built() => %d\n", v3);
  }
  return v3;
}

uint64_t dyld4::APIs::dyld_need_closure(dyld4::APIs *this, const char *a2, const char *a3)
{
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "dyld_need_closure()\n", a3);
  }
  return 0;
}

void dyld4::APIs::_dyld_missing_symbol_abort(dyld4::APIs *this)
{
}

void dyld4::APIs::_tlv_bootstrap(dyld4::APIs *this)
{
}

void dyld4::APIs::obsolete(dyld4::APIs *this)
{
}

uint64_t dyld4::APIs::NSCreateObjectFileImageFromFile(dyld4::APIs *this, const char *a2, __NSObjectFileImage **a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, __NSObjectFileImage **))(*(void *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSCreateObjectFileImageFromMemory(v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSCreateObjectFileImageFromMemory(dyld4::APIs *this, const void *a2, uint64_t a3, __NSObjectFileImage **a4)
{
  uint64_t v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const void *, uint64_t, __NSObjectFileImage **))(*(void *)this + 800))(this, a2, a3, a4);
  return dyld4::APIs::NSLinkModule(v4, v5, v6, v7);
}

uint64_t dyld4::APIs::NSLinkModule(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *))(*(void *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSUnLinkModule(v3, v4, v5);
}

uint64_t dyld4::APIs::NSUnLinkModule(dyld4::APIs *this, __NSModule *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSModule *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSDestroyObjectFileImage(v2, v3);
}

uint64_t dyld4::APIs::NSDestroyObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSIsSymbolDefinedInObjectFileImage(v2, v3, v4);
}

uint64_t dyld4::APIs::NSIsSymbolDefinedInObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *))(*(void *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSGetSectionDataInObjectFileImage(v3, v4, v5, v6, v7);
}

uint64_t dyld4::APIs::NSGetSectionDataInObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3, const char *a4, unint64_t *a5)
{
  unsigned int v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *, const char *, unint64_t *))(*(void *)this + 800))(this, a2, a3, a4, a5);
  return dyld4::APIs::NSNameOfModule(v5, v6);
}

void dyld4::APIs::NSNameOfModule(dyld4::APIs *this, __NSModule *a2)
{
}

uint64_t dyld4::APIs::NSIsSymbolNameDefined(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSIsSymbolNameDefinedWithHint(v2, v3, v4);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefinedWithHint(dyld4::APIs *this, const char *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *))(*(void *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSIsSymbolNameDefinedInImage(v3, v4, v5);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefinedInImage(dyld4::APIs *this, const mach_header *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const mach_header *, const char *))(*(void *)this
                                                                                                  + 800))(this, a2, a3);
  return dyld4::APIs::NSLookupAndBindSymbol(v3, v4);
}

uint64_t dyld4::APIs::NSLookupAndBindSymbol(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSLookupAndBindSymbolWithHint(v2, v3, v4);
}

uint64_t dyld4::APIs::NSLookupAndBindSymbolWithHint(dyld4::APIs *this, const char *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *))(*(void *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSLookupSymbolInModule(v3, v4, v5);
}

uint64_t dyld4::APIs::NSLookupSymbolInModule(dyld4::APIs *this, __NSModule *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSModule *, const char *))(*(void *)this + 800))(this, a2, a3);
  return dyld4::APIs::NSLookupSymbolInImage(v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSLookupSymbolInImage(dyld4::APIs *this, const mach_header *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const mach_header *, const char *))(*(void *)this
                                                                                                  + 800))(this, a2, a3);
  return dyld4::APIs::NSAddressOfSymbol(v3, v4);
}

uint64_t dyld4::APIs::NSAddressOfSymbol(dyld4::APIs *this, __NSSymbol *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSSymbol *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSModuleForSymbol(v2, v3);
}

uint64_t dyld4::APIs::NSModuleForSymbol(dyld4::APIs *this, __NSSymbol *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSSymbol *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSLinkEditError(v2, v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSLinkEditError(dyld4::APIs *this, NSLinkEditErrors *a2, int *a3, const char **a4, const char **a5)
{
  unsigned int v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, NSLinkEditErrors *, int *, const char **, const char **))(*(void *)this + 800))(this, a2, a3, a4, a5);
  return dyld4::APIs::NSAddLibrary(v5, v6);
}

uint64_t dyld4::APIs::NSAddLibrary(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSAddLibraryWithSearching(v2, v3);
}

uint64_t dyld4::APIs::NSAddLibraryWithSearching(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::NSAddImage(v2, v3, v4);
}

uint64_t dyld4::APIs::NSAddImage(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::_dyld_image_containing_address(v2, v3);
}

uint64_t dyld4::APIs::_dyld_image_containing_address(dyld4::APIs *this, const void *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const void *))(*(void *)this + 800))(this, a2);
  return dyld4::APIs::_dyld_lookup_and_bind(v2, v3, v4, v5);
}

uint64_t dyld4::APIs::_dyld_lookup_and_bind(dyld4::APIs *this, const char *a2, void **a3, __NSModule **a4)
{
  unsigned int v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, void **, __NSModule **))(*(void *)this + 800))(this, a2, a3, a4);
  return dyld4::APIs::_dyld_lookup_and_bind_with_hint(v4, v5, v6, v7, v8);
}

void dyld4::APIs::_dyld_lookup_and_bind_with_hint(dyld4::APIs *this, const char *a2, const char *a3, void **a4, __NSModule **a5)
{
}

BOOL dyld4::APIs::_dyld_is_pseudodylib(dyld4::APIs *this, dyld4::Loader *a2)
{
  unint64_t v2 = (unint64_t)a2;
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_is_pseudodylib(%p)\n", a2);
  }
  if (v2) {
    unint64_t v2 = v2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_1A8DFD000;
  }
  BOOL result = dyld4::APIs::validLoader((lsl::Allocator **)this, (const dyld4::Loader *)v2);
  if (result)
  {
    BOOL result = 0;
    if (v2)
    {
      if ((*(_WORD *)(v2 + 4) & 1) == 0) {
        return *(void *)(v2 + 104) != 0;
      }
    }
  }
  return result;
}

char *dyld4::APIs::_dyld_find_pointer_hash_table_entry(dyld4::APIs *this, unsigned int *a2, DyldSharedCache *a3, unint64_t a4, const void **a5)
{
  uint64_t v10 = *((void *)this + 1);
  if (*(unsigned char *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry(%p, %p, %lu, %p)\n", a2, a3, a4, a5);
    uint64_t v10 = *((void *)this + 1);
  }
  uint64_t v11 = *(DyldSharedCache **)(v10 + 240);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = DyldSharedCache::swiftOpt(v11);
  if (!v12 || *(_DWORD *)v12 < 3u) {
    return 0;
  }
  uint64_t v13 = 0;
  while (1)
  {
    uint64_t v14 = *(void *)(v12 + 40 + v13);
    if (!v14) {
      goto LABEL_16;
    }
    if ((unsigned int *)(*(void *)(*((void *)this + 1) + 240) + v14) == a2) {
      break;
    }
    v13 += 8;
    if (v13 == 64) {
      goto LABEL_16;
    }
  }
  if (!a2)
  {
LABEL_16:
    if (*(unsigned char *)(*((void *)this + 1) + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() invalid table pointer %p\n");
    }
    return 0;
  }
  if (!*(void *)(v12 + 32)) {
    return 0;
  }
  uint64_t v15 = *((void *)this + 1);
  if (a4 >= 0x40)
  {
    if (*(unsigned char *)(v15 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() exceeded key pointers limit: %lu\n");
    }
    return 0;
  }
  uint64_t v18 = *(DyldSharedCache **)(v15 + 240);
  unint64_t v19 = (unint64_t)v18 + DyldSharedCache::mappedSize(v18);
  uint64_t v20 = *((void *)this + 1);
  if (v18 > a3 || v19 <= (unint64_t)a3)
  {
    if (!*(unsigned char *)(v20 + 204)) {
      return 0;
    }
    goto LABEL_40;
  }
  uint64_t v22 = *(void *)(v20 + 240);
  v30[0] = (char *)a3 - v22;
  if (a4)
  {
    uint64_t v23 = 0;
    while (1)
    {
      uint64_t v24 = (DyldSharedCache *)a5[v23];
      if (v24 < v18 || (unint64_t)v24 >= v19) {
        break;
      }
      v30[++v23] = (char *)v24 - v22;
      if (a4 == v23)
      {
        int v26 = v23 + 1;
        goto LABEL_35;
      }
    }
    if (!*(unsigned char *)(v20 + 204)) {
      return 0;
    }
LABEL_40:
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() key %p not in shared cache\n");
    return 0;
  }
  int v26 = 1;
LABEL_35:
  uint64_t v28 = (objc *)v30;
  int v29 = v26;
  unsigned int Potential = SwiftHashTable::getPotentialTarget<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(a2, &v28);
  uint64_t v16 = 0;
  if (Potential != a2[4]) {
    uint64_t v16 = (char *)v18 + (*(void *)((unsigned char *)a2 + Potential + 8) & 0x7FFFFFFFFFFFFFFFLL);
  }
  if (*(unsigned char *)(*((void *)this + 1) + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() => %p\n", v16);
  }
  return v16;
}

void ___ZN5dyld4L20findCacheInDirAndMapERNS_12RuntimeStateEPKhPKcRm_block_invoke(uint64_t a1, dyld3 *a2, DyldSharedCache *this)
{
  if (!DyldSharedCache::isSubCachePath(this, (const char *)a2)
    && !*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (stat64((const char *)a2, &v15) == -1)
    {
      uint64_t v9 = 0;
      st_vm_size_t size = 0x100000;
    }
    else
    {
      if (v15.st_size >= 0x100000uLL) {
        st_vm_size_t size = 0x100000;
      }
      else {
        st_vm_size_t size = v15.st_size;
      }
      int v6 = dyld3::open(a2, 0, 0);
      if (v6 < 0)
      {
        uint64_t v9 = 0;
      }
      else
      {
        int v7 = v6;
        uint64_t v8 = mmap(0, st_size, 1, 2, v6, 0);
        close(v7);
        if (v8 == (void *)-1) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = v8;
        }
      }
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;
    uint64_t v10 = *(DyldSharedCache **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    if (v10)
    {
      *(void *)&v15.fsobj_id st_dev = 0;
      v15.__darwin_ino64_t st_ino = 0;
      DyldSharedCache::getUUID(v10, (__n128 *)&v15);
      uint64_t v11 = *(uint64_t **)(a1 + 40);
      uint64_t v13 = *v11;
      uint64_t v12 = v11[1];
      if (*(void *)&v15.st_dev == v13 && v15.st_ino == v12)
      {
        **(void **)(a1 + 48) = st_size;
      }
      else
      {
        munmap(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), st_size);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
    }
  }
}

uint64_t objc::ObjectHashTable::forEachObject(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 4);
  if (v2)
  {
    uint64_t v4 = result;
    unsigned int v5 = 0;
    int64x2_t v17 = vdupq_n_s64(1uLL);
    do
    {
      uint64_t v6 = v4 + (*(_DWORD *)(v4 + 16) + 1) + v2 + 1056;
      uint64_t v7 = v5;
      uint64_t v8 = *(int *)(v6 + 4 * v5);
      if (v8)
      {
        unint64_t v9 = *(void *)(v6 + 4 * v2 + 8 * v7);
        if (v9)
        {
          __chkstk_darwin();
          if (v10)
          {
            uint64_t v12 = &v17 - v10;
            do
            {
              v12->i64[0] = 0;
              v12->i16[4] = 0;
              ++v12;
            }
            while (v12 != &v17);
          }
          if (v10)
          {
            uint64_t v13 = (unint64_t *)(v4
                                     + *(unsigned int *)(v4 + 4)
                                     + (*(_DWORD *)(v4 + 16) + 1)
                                     + 4 * *(unsigned int *)(v4 + 4)
                                     + 8 * *(unsigned int *)(v4 + 4)
                                     + 8 * ((*(void *)(v11 + 8 * v7) >> 1) & 0x7FFFFFFFFFFFLL)
                                     + 1060);
            uint64_t v14 = &v17.i16[-8 * v10 + 4];
            uint64_t v15 = v10;
            do
            {
              unint64_t v16 = *v13++;
              *((void *)v14 - 1) = (v16 >> 1) & 0x7FFFFFFFFFFFLL;
              __int16 *v14 = HIWORD(v16);
              v14 += 8;
              --v15;
            }
            while (v15);
          }
          uint64_t v18 = &v17.i64[-2 * v10];
          v19.i64[0] = v10;
          v19.i64[1] = v10;
          BOOL result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v7);
        }
        else
        {
          uint64_t v20 = (v9 >> 1) & 0x7FFFFFFFFFFFLL;
          __int16 v21 = HIWORD(v9);
          uint64_t v18 = &v20;
          int64x2_t v19 = v17;
          BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t **))(a2 + 16))(a2, v7, v4 + v8, &v18);
        }
      }
      unsigned int v5 = v7 + 1;
      unsigned int v2 = *(_DWORD *)(v4 + 4);
    }
    while (v7 + 1 != v2);
  }
  return result;
}

void *dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[2];
  uint64_t v3 = *(uint64_t **)*result;
  uint64_t v4 = *v3;
  if (*v3 == 3)
  {
    BOOL result = dyld4::createPseudoDylibCallbacks(*(lsl::Lock ***)(v2 + 16), v3[1], v3[2], v3[3], v3[4], v3[5], v3[6], v3[7], v3[8]);
  }
  else if (v4 == 2)
  {
    BOOL result = dyld4::createPseudoDylibCallbacks(*(lsl::Lock ***)(v2 + 16), v3[1], v3[2], v3[3], v3[4], v3[5], v3[6], v3[7], 0);
  }
  else
  {
    if (v4 != 1) {
      return result;
    }
    BOOL result = dyld4::createPseudoDylibCallbacks(*(lsl::Lock ***)(v2 + 16), v3[1], v3[2], v3[3], v3[4], v3[5], v3[6], 0, 0);
  }
  *(void *)v1[1] = result;
  return result;
}

void *dyld4::createPseudoDylibCallbacks(lsl::Lock **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL result = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x40uLL);
  if (a2) {
    uint64_t v17 = a2;
  }
  else {
    uint64_t v17 = 0;
  }
  *BOOL result = v17;
  if (a3) {
    uint64_t v18 = a3;
  }
  else {
    uint64_t v18 = 0;
  }
  result[1] = v18;
  if (a4) {
    uint64_t v19 = a4;
  }
  else {
    uint64_t v19 = 0;
  }
  result[2] = v19;
  if (a5) {
    uint64_t v20 = a5;
  }
  else {
    uint64_t v20 = 0;
  }
  result[3] = v20;
  if (a6) {
    uint64_t v21 = a6;
  }
  else {
    uint64_t v21 = 0;
  }
  result[4] = v21;
  if (a7) {
    uint64_t v22 = a7;
  }
  else {
    uint64_t v22 = 0;
  }
  result[5] = v22;
  if (a8) {
    uint64_t v23 = a8;
  }
  else {
    uint64_t v23 = 0;
  }
  result[6] = v23;
  if (a9) {
    uint64_t v24 = a9;
  }
  else {
    uint64_t v24 = 0;
  }
  result[7] = v24;
  return result;
}

uint64_t dyld4::APIs::_dyld_pseudodylib_register(void *,unsigned long,_dyld_pseudodylib_callbacks_opaque *,void *)::$_0::operator()(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)result;
  uint64_t v3 = *(void *)(*(void *)result + 608);
  if (v3)
  {
    uint64_t v4 = *(uint64_t **)(v2 + 600);
    uint64_t v5 = 8 * v3;
    uint64_t v6 = v4;
    while (1)
    {
      uint64_t v7 = *v6;
      BOOL result = _platform_strcmp(*(const char **)(*v6 + 32), **(const char ***)(v1 + 8));
      if (!result) {
        break;
      }
      ++v6;
      ++v4;
      v5 -= 8;
      if (!v5) {
        goto LABEL_7;
      }
    }
    **(void **)(v1 + 16) = v7;
  }
LABEL_7:
  if (!**(void **)(v1 + 16))
  {
    uint64_t v10 = dyld4::PseudoDylib::create(*(lsl::Lock ***)(v2 + 16), **(void **)(v1 + 8), **(void **)(v1 + 24), **(void **)(v1 + 32), **(void **)(v1 + 40), **(void **)(v1 + 48));
    BOOL result = lsl::Vector<AuthenticatedValue<dyld4::Loader const*>>::reserve(v2 + 592, *(void *)(v2 + 608) + 1);
    uint64_t v8 = *(void *)(v2 + 600);
    uint64_t v9 = *(void *)(v2 + 608);
    *(void *)(v2 + 608) = v9 + 1;
    *(void *)(v8 + 8 * v9) = v10;
    **(void **)(v1 + 56) = v10;
  }
  return result;
}

uint64_t SwiftHashTable::getPotentialTarget<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(unsigned int *a1, objc **a2)
{
  unsigned int v3 = SwiftHashTable::getIndex<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(a1, a2);
  if (v3 == -1)
  {
    uint64_t v5 = a1 + 4;
  }
  else
  {
    uint64_t v4 = *a1;
    if (v4 <= v3) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    }
    uint64_t v5 = (unsigned int *)((char *)&a1[v3 + 264] + a1[5] + v4);
  }
  return *v5;
}

uint64_t SwiftHashTable::getIndex<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(unsigned int *a1, objc **a2)
{
  unsigned int v4 = SwiftHashTable::hash<PointerHashTableBuilderKey>((uint64_t)a1, a2);
  if (*a1 <= v4) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v5 = v4;
  int v6 = *((unsigned __int8 *)a1 + v4 + a1[5] + 1056);
  if (v6 != SwiftHashTable::checkbyte<PointerHashTableBuilderKey>((uint64_t)a1, (uint64_t)a2)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *a1;
  if (v7 <= v5) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  }
  uint64_t v8 = *(unsigned int *)((char *)&a1[v5 + 264] + a1[5] + v7);
  if (v8 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (SwiftHashTable::equal<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>((uint64_t)a1, (unsigned int *)((char *)a1 + v8), (uint64_t)a2))
  {
    return v5;
  }
  return 0xFFFFFFFFLL;
}

void mach_o::Header::platformAndVersions(mach_o::Header *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x4002000000;
  uint64_t v10 = __Block_byref_object_copy__7;
  uint64_t v11 = __Block_byref_object_dispose__7;
  mach_o::Platform::Platform((mach_o::Platform *)v12, 0);
  *(void *)&long long v4 = 0x1000000010000;
  *((void *)&v4 + 1) = 0x1000000010000;
  *(_OWORD *)&void v12[8] = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke;
  void v6[3] = &unk_1EFF656B0;
  v6[4] = &v7;
  mach_o::Header::forEachPlatformLoadCommand(this, (uint64_t)v6);
  uint64_t v5 = v8;
  *(void *)a2 = v8[5];
  *(_OWORD *)(a2 + 8) = *((_OWORD *)v5 + 3);
  _Block_object_dispose(&v7, 8);
}

__n128 __Block_byref_object_copy__7(__n128 *a1, __n128 *a2)
{
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void mach_o::Header::forEachPlatformLoadCommand(mach_o::Error *a1, uint64_t a2)
{
  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2000000000;
  char v4 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  unsigned int v2[2] = ___ZNK6mach_o6Header26forEachPlatformLoadCommandEU13block_pointerFvNS_8PlatformENS_9Version32ES2_E_block_invoke;
  v2[3] = &unk_1EFF656D8;
  v2[5] = v3;
  void v2[6] = a1;
  v2[4] = a2;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v2, (mach_o::Error *)&v5);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(v3, 8);
}

void ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  char v4 = (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  uint64_t v5 = *a2;
  int v6 = a3;
  int v7 = a4;
  uint64_t v8 = 0x1000000010000;
  mach_o::PlatformAndVersions::zip(v4, &v5, (mach_o::Error *)&v9);
  if (v9) {
    ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke_cold_1();
  }
  mach_o::Error::~Error(&v9);
}

uint64_t ___ZNK6mach_o6Header26forEachPlatformLoadCommandEU13block_pointerFvNS_8PlatformENS_9Version32ES2_E_block_invoke(uint64_t result, int *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 48);
  int v5 = *a2;
  if (*a2 <= 46)
  {
    if (v5 == 36)
    {
      uint64_t v11 = a2[2];
      unsigned int v12 = a2[3];
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v11;
      }
      uint64_t v14 = *(void *)(result + 32);
      uint64_t v21 = 0x1EFF62040;
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v14 + 16))(v14, &v21, v11, v13);
    }
    else
    {
      if (v5 != 37) {
        return result;
      }
      uint64_t v7 = *(void *)(result + 32);
      if ((*(_DWORD *)(v4 + 4) | 0x1000000) == 0x1000007)
      {
        uint64_t v20 = 0x1EFF62270;
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v7 + 16))(v7, &v20, a2[2], a2[3]);
      }
      else
      {
        uint64_t v19 = 0x1EFF61FD0;
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v7 + 16))(v7, &v19, a2[2], a2[3]);
      }
    }
  }
  else
  {
    switch(v5)
    {
      case '/':
        uint64_t v8 = *(void *)(result + 32);
        if (*(_DWORD *)(v4 + 4) == 16777223)
        {
          uint64_t v18 = 0x1EFF62318;
          uint64_t v9 = &v18;
        }
        else
        {
          uint64_t v17 = 0x1EFF62008;
          uint64_t v9 = &v17;
        }
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v8 + 16))(v8, v9, a2[2], a2[3]);
        break;
      case '0':
        uint64_t v10 = *(void *)(result + 32);
        if ((*(_DWORD *)(v4 + 4) | 0x1000000) == 0x1000007)
        {
          uint64_t v16 = 0x1EFF624D8;
          __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v10 + 16))(v10, &v16, a2[2], a2[3]);
        }
        else
        {
          uint64_t v15 = 0x1EFF620B0;
          __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v10 + 16))(v10, &v15, a2[2], a2[3]);
        }
        break;
      case '2':
        uint64_t v6 = *(void *)(result + 32);
        mach_o::Platform::Platform((mach_o::Platform *)v22, a2[2]);
        __n128 result = (*(uint64_t (**)(uint64_t, char *, void, void))(v6 + 16))(v6, v22, a2[3], a2[4]);
        break;
      default:
        return result;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(v3 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

uint64_t mach_o::Header::getDylibInstallName(mach_o::Error *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZNK6mach_o6Header19getDylibInstallNameEPPKcPNS_9Version32ES5__block_invoke;
  void v6[3] = &unk_1EFF65700;
  void v6[6] = a4;
  void v6[7] = a2;
  v6[4] = &v7;
  void v6[5] = a3;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v6, (mach_o::Error *)&v11);
  mach_o::Error::~Error(&v11);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t ___ZNK6mach_o6Header19getDylibInstallNameEPPKcPNS_9Version32ES5__block_invoke(uint64_t result, _DWORD *a2, unsigned char *a3)
{
  if (*a2 == 13)
  {
    uint64_t v3 = *(_DWORD **)(result + 48);
    **(_DWORD **)(result + 4dyld4::halt("obsolete dyld API called", 0) = a2[5];
    _DWORD *v3 = a2[4];
    **(void **)(result + 56) = (char *)a2 + a2[2];
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t prebuilt_objc::forEachClass(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a1;
  v13[0] = a1 + 1;
  v13[1] = v8;
  uint64_t v9 = &a1[v8];
  uint64_t v10 = v9[1];
  v13[2] = v8;
  v14[0] = (uint64_t)(v9 + 2);
  v14[1] = v10;
  _WORD v14[2] = v10;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  void v12[2] = ___ZN13prebuilt_objc12forEachClassEPKvU13block_pointerFvRKN5dyld414PrebuiltLoader13BindTargetRefERKN5dyld35ArrayIPS5_EEE_block_invoke;
  void v12[3] = &unk_1EFF657A0;
  _OWORD v12[4] = a2;
  return dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry((uint64_t)v13, (uint64_t)v13, v14, (uint64_t)v12, a5, a6, a7, a8);
}

uint64_t ___ZN13prebuilt_objc12forEachClassEPKvU13block_pointerFvRKN5dyld414PrebuiltLoader13BindTargetRefERKN5dyld35ArrayIPS5_EEE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v18[0]);
  uint64_t v13 = (char *)v18 - ((v12 + 23) & 0xFFFFFFFFFFFFFFF0);
  v18[0] = (uint64_t)v13;
  v18[1] = v11;
  if (v11)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *v10;
    do
    {
      if (v11 == v14) {
        ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
      }
      uint64_t v16 = v14 + 1;
      *(void *)&v13[8 * v14] = *(void *)(v15 + 8 * v14);
      ++v14;
      v12 -= 8;
    }
    while (v12);
  }
  else
  {
    uint64_t v16 = 0;
  }
  _OWORD v18[2] = v16;
  return (*(uint64_t (**)(void, uint64_t, uint64_t *))(*(void *)(v8 + 32) + 16))(*(void *)(v8 + 32), v9, v18);
}

unint64_t prebuilt_objc::hashStringKey(uint64_t a1)
{
  return murmurHash(*(uint64_t **)a1, *(_DWORD *)(a1 + 8), 0);
}

dyld4::PrebuiltObjC::ObjCOptimizerImage *dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(dyld4::PrebuiltObjC::ObjCOptimizerImage *this, const dyld4::JustInTimeLoader *a2, uint64_t a3, int a4)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a4;
  *((void *)this + 2) = a3;
  *((unsigned char *)this + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  Diagnostics::Diagnostics((dyld4::PrebuiltObjC::ObjCOptimizerImage *)((char *)this + 32));
  *((void *)this + 19) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 12dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 4dyld4::halt("obsolete dyld API called", 0) = 0u;
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 160);
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 256);
  *((void *)this + 48) = 0;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map((uint64_t)this + 392);
  *((void *)this + 69) = 0;
  *((_DWORD *)this + 14dyld4::halt("obsolete dyld API called", 0) = 0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 52dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(_OWORD *)((char *)this + 535) = 0u;
  return this;
}

void *dyld4::PrebuiltObjC::ObjCOptimizerImage::visitReferenceToObjCSelector(uint64_t a1, objc::StringHashTable *this, uint64_t *a3, int a4, int a5, unint64_t a6, char a7, char *__s)
{
  uint64_t Index = objc::StringHashTable::tryGetIndex(this, __s);
  if ((Index & 0xFF00000000) != 0)
  {
    unint64_t Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute((dyld4::PrebuiltLoader::BindTargetRef *)*(int *)((char *)this + 4 * Index + *((unsigned int *)this + 1) + *((_DWORD *)this + 4) + 1 + 1056));
    __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(a1 + 352), 1);
    uint64_t v17 = *(void *)(a1 + 352);
    uint64_t v18 = *(void *)(a1 + 368);
    *(void *)(a1 + 368) = v18 + 1;
    *(void *)(v17 + 8 * v18) = Absolute;
    return result;
  }
  v31.var0 = (Loader *)__s;
  v31.unint64_t var1 = _platform_strlen(__s);
  uint64_t v19 = dyld3::MapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::find<prebuilt_objc::ObjCStringKey>((uint64_t)a3, a3 + 2, a3 + 7, 0, (uint64_t)&v31);
  if (v19 == a3[7] + 32 * a3[9])
  {
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    BindTarget v28 = v31;
    uint64_t v22 = (BindTarget *)dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a1 + 392, (uint64_t)&v28);
    if (v23)
    {
      v28.var0 = *(Loader **)a1;
      if (!a7) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      v28.unint64_t var1 = a6;
      v22[1] = v28;
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v27, &v28);
      __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(a1 + 352), 1);
      uint64_t v24 = *(void *)(a1 + 352);
      uint64_t v25 = *(void *)(a1 + 368);
      *(void *)(a1 + 368) = v25 + 1;
      var0 = v27;
      goto LABEL_8;
    }
    uint64_t v21 = v22 + 1;
    uint64_t v20 = (void *)(a1 + 352);
  }
  else
  {
    uint64_t v20 = (void *)(a1 + 352);
    uint64_t v21 = (const BindTarget *)(v19 + 16);
  }
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v28, v21);
  __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v20, 1);
  uint64_t v24 = *(void *)(a1 + 352);
  uint64_t v25 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = v25 + 1;
  var0 = v28.var0;
LABEL_8:
  *(void *)(v24 + 8 * v25) = var0;
  return result;
}

uint64_t dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0;
    memset(v26, 0, sizeof(v26));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v26, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v26, 1);
      uint64_t v6 = (*(void *)&v26[1])++;
      *(_DWORD *)(*(void *)&v26[0] + 4 * v6) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0;
      do
      {
        uint64_t v8 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v7);
        unint64_t v9 = murmurHash(*(uint64_t **)v8, *(_DWORD *)(v8 + 8), 0);
        unint64_t v10 = (*(void *)&v26[1] - 1) & v9;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v10) != -1)
        {
          uint64_t v11 = 1;
          do
            unint64_t v10 = (*(void *)&v26[1] - 1) & (v10 + v11++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v10) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v1dyld4::halt("obsolete dyld API called", 0) = v7++;
      }
      while (v7 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v26)
    {
      *(void *)&v26[1] = 0;
      if (*((void *)&v26[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v26[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v12 = *(void *)(a1 + 40);
      if (v12) {
        vm_deallocate(mach_task_self_, v12, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v26[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v26 + 8);
      vm_size_t v13 = size;
      *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = *((void *)&v26[1] + 1);
      *(void *)(a1 + 48) = v13;
    }
  }
  unint64_t v14 = (*(void *)(a1 + 32) - 1) & murmurHash(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), 0);
  unint64_t v15 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v14);
  if (v15 == -1)
  {
LABEL_21:
    uint64_t v19 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v14) = v19;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v21 + 1;
    uint64_t v22 = (_OWORD *)(v20 + 32 * v21);
    long long v23 = *(_OWORD *)(a2 + 16);
    _OWORD *v22 = *(_OWORD *)a2;
    v22[1] = v23;
    uint64_t v24 = *(void *)(a1 + 72);
    if (!v24) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 32 * v24 - 32;
  }
  else
  {
    uint64_t v16 = 1;
    while (1)
    {
      uint64_t v17 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v15);
      size_t v18 = *(void *)(v17 + 8);
      if (v18 == *(void *)(a2 + 8) && !_platform_memcmp(*(const void **)v17, *(const void **)a2, v18)) {
        return dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]((void *)(a1 + 56), v15);
      }
      unint64_t v14 = (*(void *)(a1 + 32) - 1) & (v14 + v16++);
      unint64_t v15 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v14);
      if (v15 == -1) {
        goto LABEL_21;
      }
    }
  }
}

void *dyld4::PrebuiltObjC::ObjCOptimizerImage::visitClass(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, char a10, char *a11)
{
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000;
  _OWORD v21[2] = ___ZN5dyld4L22checkForDuplicateClassE9VMAddressPKcPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairIS0_PKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS8_IS2_NSB_10BindTargetENS7_11HashCStringENS7_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
  void v21[3] = &__block_descriptor_tmp_41;
  v21[4] = a5;
  v21[5] = a6;
  void v21[6] = a11;
  void v21[7] = a2;
  void v21[8] = a3;
  void v21[9] = a1;
  objc::ObjectHashTable::forEachObject(a4, a11, (uint64_t)v21);
  if (!a10 || !*(unsigned char *)(a1 + 24) || !a8) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v14 = *(void *)(a1 + 16);
  unint64_t v15 = (char *)(a9 - v14);
  uint64_t v16 = (char *)(a7 - v14);
  __n128 result = dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace((void *)(a1 + 40), 1);
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v19 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v19 + 1;
  uint64_t v20 = (char **)(v18 + 40 * v19);
  void *v20 = a11;
  v20[1] = v15;
  void v20[2] = (char *)1;
  v20[3] = v16;
  void v20[4] = (char *)1;
  return result;
}

void dyld4::PrebuiltObjC::ObjCOptimizerImage::visitProtocol(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, char a7, char *a8)
{
  uint64_t v16 = *(void *)(a1 + 136);
  dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace((void *)(a1 + 120), 1);
  uint64_t v17 = *(void *)(a1 + 120);
  uint64_t v18 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = v18 + 1;
  *(unsigned char *)(v17 + v18) = 0;
  uint64_t v31 = 0;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2000000000;
  char v34 = 0;
  uint64_t v25 = _NSConcreteStackBlock;
  uint64_t v26 = 0x40000000;
  uint64_t v27 = ___ZN5dyld4L23protocolIsInSharedCacheEPKcPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEE_block_invoke;
  BindTarget v28 = &unk_1EFF658C8;
  uint64_t v29 = &v31;
  uint64_t v30 = a3;
  objc::ObjectHashTable::forEachObject(a2, a8, (uint64_t)&v25);
  LODWORD(a3) = *((unsigned __int8 *)v32 + 24);
  _Block_object_dispose(&v31, 8);
  if (!a3)
  {
    if (!a7 || !*(unsigned char *)(a1 + 24) || !a5) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v19 = *(void *)(a1 + 16);
    uint64_t v20 = (char *)(a6 - v19);
    uint64_t v21 = (void **)(a4 - v19);
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace((void *)(a1 + 80), 1);
    uint64_t v22 = *(void *)(a1 + 80);
    uint64_t v23 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = v23 + 1;
    uint64_t v24 = (char **)(v22 + 40 * v23);
    *uint64_t v24 = a8;
    v24[1] = v20;
    _OWORD v24[2] = (char *)1;
    v24[3] = (char *)v21;
    v24[4] = (char *)1;
    uint64_t v25 = v21;
    uint64_t v26 = 1;
    LODWORD(v27) = 0;
    *(_DWORD *)(dyld3::Map<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::insert(a1 + 256, (uint64_t)&v25)+ 16) = v16;
  }
}

__n128 dyld4::PrebuiltObjC::commitImage(dyld4::PrebuiltObjC *this, const dyld4::PrebuiltObjC::ObjCOptimizerImage *a2)
{
  uint64_t v4 = *((void *)a2 + 29);
  if (v4)
  {
    unint64_t v5 = (unint64_t *)*((void *)a2 + 27);
    uint64_t v6 = &v5[3 * v4];
    do
    {
      long long v14 = *v5;
      uint64_t v15 = 0;
      uint64_t v7 = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert((uint64_t)this + 344, &v14);
      __n128 result = *(__n128 *)(v5 + 1);
      *(__n128 *)(v7 + 8) = result;
      v5 += 3;
    }
    while (v5 != v6);
  }
  uint64_t v9 = *((void *)a2 + 58);
  if (v9)
  {
    uint64_t v10 = *((void *)a2 + 56);
    uint64_t v11 = v10 + 32 * v9;
    vm_address_t v12 = (char *)this + 40;
    do
    {
      long long v14 = *(_OWORD *)v10;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      vm_size_t v13 = (__n128 *)dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert((uint64_t)v12, (uint64_t)&v14);
      __n128 result = *(__n128 *)(v10 + 16);
      v13[1] = result;
      v10 += 32;
    }
    while (v10 != v11);
  }
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeSelectorMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,void>((uint64_t)this + 40, a2, (uint64_t)&__block_literal_global_1);
  return v2;
}

ObjCStringKeyOnDisk ___ZNK5dyld412PrebuiltObjC20serializeSelectorMapERNS_13BumpAllocatorE_block_invoke(Absolute a1)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1);
  return (ObjCStringKeyOnDisk)v3;
}

void *dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,void>(uint64_t a1, dyld4::BumpAllocator *this, uint64_t a3)
{
  uint64_t v11 = *(void *)(a1 + 32);
  dyld4::BumpAllocator::append(this, &v11, 8uLL);
  dyld4::BumpAllocator::append(this, *(const void **)(a1 + 16), 4 * v11);
  uint64_t v11 = *(void *)(a1 + 72);
  __n128 result = dyld4::BumpAllocator::append(this, &v11, 8uLL);
  uint64_t v7 = *(void *)(a1 + 72);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = v8 + 32 * v7;
    do
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v8, v8 + 16);
      __n128 result = dyld4::BumpAllocator::append(this, &v10, 8uLL);
      v8 += 32;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeClassMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>((uint64_t)this + 136, a2, (uint64_t)&__block_literal_global_15, (uint64_t)&__block_literal_global_19);
  return v2;
}

ObjCStringKeyOnDisk ___ZNK5dyld412PrebuiltObjC17serializeClassMapERNS_13BumpAllocatorE_block_invoke(Absolute a1)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1);
  return (ObjCStringKeyOnDisk)v3;
}

ObjCObjectOnDiskLocation ___ZNK5dyld412PrebuiltObjC17serializeClassMapERNS_13BumpAllocatorE_block_invoke_2(Absolute a1)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1);
  return (ObjCObjectOnDiskLocation)v3;
}

void *dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>(uint64_t a1, dyld4::BumpAllocator *this, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = *(void *)(a1 + 32);
  dyld4::BumpAllocator::append(this, &v13, 8uLL);
  dyld4::BumpAllocator::append(this, *(const void **)(a1 + 16), 8 * v13);
  uint64_t v13 = *(void *)(a1 + 72);
  __n128 result = dyld4::BumpAllocator::append(this, &v13, 8uLL);
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9)
  {
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = v10 + 56 * v9;
    do
    {
      v12[0] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v10, v10 + 16);
      v12[1] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v10, v10 + 16);
      void v12[2] = *(void *)(v10 + 48);
      __n128 result = dyld4::BumpAllocator::append(this, v12, 0x18uLL);
      v10 += 56;
    }
    while (v10 != v11);
  }
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeProtocolMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>((uint64_t)this + 240, a2, (uint64_t)&__block_literal_global_22, (uint64_t)&__block_literal_global_25);
  return v2;
}

ObjCStringKeyOnDisk ___ZNK5dyld412PrebuiltObjC20serializeProtocolMapERNS_13BumpAllocatorE_block_invoke(Absolute a1)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1);
  return (ObjCStringKeyOnDisk)v3;
}

ObjCObjectOnDiskLocation ___ZNK5dyld412PrebuiltObjC20serializeProtocolMapERNS_13BumpAllocatorE_block_invoke_2(Absolute a1)
{
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1);
  return (ObjCObjectOnDiskLocation)v3;
}

unint64_t dyld4::PrebuiltObjC::generateHashTables(dyld4::PrebuiltObjC *this)
{
  uint64_t v2 = (char *)this + 344;
  dyld4::generateClassOrProtocolHashTable(0, (uint64_t *)this, (uint64_t)this + 344, (uint64_t)this + 136, (unsigned char *)this + 440);
  return dyld4::generateClassOrProtocolHashTable(1uLL, (uint64_t *)this, (uint64_t)v2, (uint64_t)this + 240, &v4);
}

unint64_t dyld4::generateClassOrProtocolHashTable(unint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  int v35 = result;
  unint64_t v5 = a2[2];
  if (v5)
  {
    uint64_t v7 = 0;
    uint64_t v36 = (void *)(a3 + 56);
    uint64_t v37 = (uint64_t *)(a3 + 16);
    unint64_t v8 = a2[2];
    do
    {
      unint64_t v9 = v8 - 1;
      if (v5 <= v9) {
        ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
      }
      uint64_t v42 = v7;
      unint64_t v44 = v9;
      __n128 result = Diagnostics::hasError((Diagnostics *)(*a2 + 568 * v9 + 32));
      if ((result & 1) == 0)
      {
        if (a2[2] <= v44) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
        }
        uint64_t v10 = *a2;
        int v45 = (uint64_t *)(*a2 + 568 * v44);
        if (v35 == 1)
        {
          uint64_t v22 = v10 + 568 * v44;
          uint64_t v23 = *(void *)(v22 + 96);
          if (v23)
          {
            uint64_t v24 = (void *)(v10 + 568 * v44);
            uint64_t v41 = (uint64_t)(v24 + 32);
            unsigned int v40 = v24 + 34;
            uint64_t v25 = v24 + 39;
            uint64_t v39 = v24 + 41;
            uint64_t v26 = v24 + 15;
            uint64_t v27 = 40 * v23;
            uint64_t v28 = *(void *)(v22 + 80) + 16;
            do
            {
              if (!*(unsigned char *)v28 || !*(unsigned char *)(v28 + 16)) {
LABEL_31:
              }
                std::__throw_bad_optional_access[abi:nn180100]();
              uint64_t v29 = *v45;
              uint64_t v30 = *(void *)(v28 + 8);
              uint64_t v32 = *(const char **)(v28 - 16);
              uint64_t v31 = *(void *)(v28 - 8);
              size_t v33 = _platform_strlen(v32);
              v54[0] = 0;
              unint64_t v48 = v32;
              size_t v49 = v33;
              uint64_t v50 = v29;
              uint64_t v51 = v31;
              uint64_t v52 = v29;
              uint64_t v53 = v30;
              __n128 result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a4, (uint64_t)&v48, v54);
              if (!v54[0])
              {
                uint64_t v34 = dyld3::MapBase<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::find<VMOffset>(v41, v40, v25, 0, v28 + 8);
                if (v34 == *v25 + 24 * *v39) {
                  dyld4::generateClassOrProtocolHashTable();
                }
                __n128 result = dyld3::OverflowSafeArray<BOOL,4294967295ull>::operator[](v26, *(unsigned int *)(v34 + 16));
                *(unsigned char *)__n128 result = 1;
              }
              v28 += 40;
              v27 -= 40;
            }
            while (v27);
          }
        }
        else if (!v35)
        {
          uint64_t v11 = v10 + 568 * v44;
          uint64_t v12 = *(void *)(v11 + 56);
          if (v12)
          {
            uint64_t v13 = *(void *)(v11 + 40);
            uint64_t v14 = 40 * v12;
            while (1)
            {
              if (!*(unsigned char *)(v13 + 16) || !*(unsigned char *)(v13 + 32)) {
                goto LABEL_31;
              }
              uint64_t v15 = *v45;
              uint64_t v16 = *(void *)(v13 + 24);
              uint64_t v18 = *(const char **)v13;
              uint64_t v17 = *(void *)(v13 + 8);
              size_t v19 = _platform_strlen(*(const char **)v13);
              v54[0] = 0;
              unint64_t v48 = v18;
              size_t v49 = v19;
              uint64_t v50 = v15;
              uint64_t v51 = v17;
              uint64_t v52 = v15;
              uint64_t v53 = v16;
              __n128 result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a4, (uint64_t)&v48, v54);
              if (v54[0]) {
                goto LABEL_15;
              }
              unint64_t v20 = result;
              __n128 result = (unint64_t)dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::const_find<char const*>(a3, v37, v36, 0, (const char **)v13);
              if (result != *(void *)(a3 + 56) + 24 * *(void *)(a3 + 72)) {
                break;
              }
LABEL_16:
              v13 += 40;
              v14 -= 40;
              if (!v14) {
                goto LABEL_26;
              }
            }
            long long v21 = *(_OWORD *)(result + 8);
            *(void *)(v20 + 16) = v15;
            *(void *)(v20 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v17;
            *(_OWORD *)(v20 + 32) = v21;
            v47[0] = 0;
            unint64_t v48 = v18;
            size_t v49 = v19;
            uint64_t v50 = v15;
            uint64_t v51 = v17;
            uint64_t v52 = v15;
            uint64_t v53 = v16;
            __n128 result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(a4, (uint64_t)&v48, v47);
LABEL_15:
            *a5 = 1;
            goto LABEL_16;
          }
        }
      }
LABEL_26:
      uint64_t v7 = v42 + 1;
      unint64_t v5 = a2[2];
      unint64_t v8 = v44;
    }
    while (v42 + 1 != v5);
  }
  return result;
}

void dyld4::PrebuiltObjC::generatePerImageFixups(vm_address_t *this, dyld4::RuntimeState *a2)
{
  uint64_t v3 = *((void *)a2 + 6);
  if (v3)
  {
    unsigned __int16 v4 = 0;
    uint64_t v5 = *((void *)a2 + 5);
    uint64_t v6 = 8 * v3;
    uint64_t v7 = v5;
    do
    {
      if ((*(_WORD *)(*(void *)v7 + 4) & 1) == 0)
      {
        int v8 = *(__int16 *)(*(void *)v7 + 6);
        if ((v8 & 0x80000000) == 0) {
          dyld4::PrebuiltObjC::generatePerImageFixups();
        }
        unsigned int v9 = v8 & 0x7FFF;
        if (v4 <= v9) {
          unsigned __int16 v4 = v9;
        }
      }
      v7 += 8;
      v5 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  else
  {
    unsigned __int16 v4 = 0;
  }
  uint64_t v10 = this + 58;
  if (this[59] < (unsigned __int16)(v4 + 1)) {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(this + 58, (unsigned __int16)(v4 + 1));
  }
  int v11 = 0;
  do
  {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::default_constuct_back(this + 58);
    int v12 = (unsigned __int16)v11++;
  }
  while (v12 != v4);
  vm_address_t v13 = this[2];
  if (v13)
  {
    vm_address_t v14 = *this;
    uint64_t v15 = *this + 568 * v13;
    do
    {
      if (!Diagnostics::hasError((Diagnostics *)(v14 + 32)))
      {
        uint64_t v16 = dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[](v10, *(_WORD *)(*(void *)v14 + 6) & 0x7FFF);
        uint64_t v17 = (void *)v16;
        *(_OWORD *)uint64_t v16 = *(_OWORD *)(v14 + 488);
        long long v18 = *(_OWORD *)(v14 + 504);
        long long v19 = *(_OWORD *)(v14 + 520);
        long long v20 = *(_OWORD *)(v14 + 536);
        *(_OWORD *)(v16 + 6dyld4::halt("obsolete dyld API called", 0) = *(_OWORD *)(v14 + 548);
        *(_OWORD *)(v16 + 32) = v19;
        *(_OWORD *)(v16 + 48) = v20;
        *(_OWORD *)(v16 + 16) = v18;
        unint64_t v21 = *(void *)(v14 + 136);
        if (v21)
        {
          dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve((void *)(v16 + 80), v21);
          uint64_t v22 = *(void *)(v14 + 136);
          if (v22)
          {
            uint64_t v23 = *(char **)(v14 + 120);
            do
            {
              char v24 = *v23++;
              dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace(v17 + 10, 1);
              uint64_t v25 = v17[10];
              uint64_t v26 = v17[12];
              v17[12] = v26 + 1;
              *(unsigned char *)(v25 + v26) = v24;
              --v22;
            }
            while (v22);
          }
        }
        unint64_t v27 = *(void *)(v14 + 368);
        if (v27)
        {
          dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v17 + 15, v27);
          uint64_t v28 = *(void *)(v14 + 368);
          if (v28)
          {
            uint64_t v29 = *(uint64_t **)(v14 + 352);
            uint64_t v30 = 8 * v28;
            do
            {
              dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v17 + 15, 1);
              uint64_t v31 = v17[15];
              uint64_t v32 = v17[17];
              v17[17] = v32 + 1;
              uint64_t v33 = *v29++;
              *(void *)(v31 + 8 * v32) = v33;
              v30 -= 8;
            }
            while (v30);
          }
        }
      }
      v14 += 568;
    }
    while (v14 != v15);
  }
}

double dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::default_constuct_back(vm_address_t *a1)
{
  vm_address_t v2 = a1[2];
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > a1[1])
  {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(a1, v3);
    vm_address_t v2 = a1[2];
    unint64_t v3 = v2 + 1;
  }
  vm_address_t v4 = *a1;
  a1[2] = v3;
  uint64_t v5 = (_OWORD *)(v4 + 160 * v2);
  double result = 0.0;
  void v5[8] = 0u;
  v5[9] = 0u;
  void v5[6] = 0u;
  void v5[7] = 0u;
  v5[4] = 0u;
  void v5[5] = 0u;
  v5[2] = 0u;
  void v5[3] = 0u;
  *uint64_t v5 = 0u;
  v5[1] = 0u;
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[](vm_address_t *a1, vm_address_t a2)
{
  vm_address_t v4 = a1[2];
  vm_address_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5 && a1[1] < v5) {
      dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 160 * a2;
}

void *dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    unint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (v6 + vm_page_size - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    if (vm_allocate(mach_task_self_, result + 3, v7, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    double result = memmove((void *)v3[3], *v3, (size_t)v3[2]);
    int v8 = v3[4];
    _DWORD *v3 = v3[3];
    v3[1] = v8;
    if (v4)
    {
      vm_map_t v9 = mach_task_self_;
      return (void *)vm_deallocate(v9, v4, v5);
    }
  }
  return result;
}

void dyld4::PrebuiltObjC::make(dyld4::PrebuiltObjC *this, Diagnostics *a2, dyld4::RuntimeState *a3)
{
  uint64_t v3 = *((void *)a3 + 1);
  uint64_t v4 = *(void *)(v3 + 304);
  vm_size_t v5 = *(Diagnostics **)(v3 + 320);
  uint64_t v75 = *(void *)(v3 + 312);
  if (v75) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 && v5 != 0)
  {
    int v8 = a3;
    uint64_t v78 = *(void *)(v3 + 296);
    unsigned int v79 = *(int **)(v3 + 288);
    uint64_t v76 = *(void *)(v3 + 352);
    uint64_t v10 = DyldSharedCache::objcOptPtrs(*(DyldSharedCache **)(v3 + 240));
    if (v10)
    {
      int v11 = (unsigned int *)v10;
      int v12 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(*((dyld4::Loader **)v8 + 3), v8);
      if (dyld3::MachOFile::pointerSize(v12) == 8) {
        uint64_t v13 = *(void *)v11;
      }
      else {
        uint64_t v13 = *v11;
      }
      *((void *)this + 56) = v13 - *(void *)(*((void *)v8 + 1) + 240);
      *((unsigned char *)this + 456) = 1;
    }
    uint64_t v14 = *((void *)v8 + 10);
    if (v14)
    {
      uint64_t v15 = *((void *)v8 + 9);
      uint64_t v16 = 8 * v14;
      uint64_t v17 = v15;
      while (!*(void *)v17 || (*(_WORD *)(*(void *)v17 + 4) & 1) != 0)
      {
        v17 += 8;
        v15 += 8;
        v16 -= 8;
        if (!v16) {
          goto LABEL_20;
        }
      }
    }
    else
    {
LABEL_20:
      uint64_t v73 = v5;
      uint64_t v72 = v4;
      long long v77 = this;
      dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::Map((uint64_t)v87);
      uint64_t v19 = *((void *)v8 + 6);
      if (v19)
      {
        long long v20 = (dyld4::Loader **)*((void *)v8 + 5);
        uint64_t v21 = 8 * v19;
        uint64_t v22 = v20;
        uint64_t v74 = v8;
        do
        {
          uint64_t v23 = *v22;
          char v24 = (dyld3::MachOFile *)dyld4::Loader::mf(*v22, v8);
          int v25 = dyld3::MachOFile::pointerSize(v24);
          uint64_t v94 = 0;
          uint64_t v95 = (uint64_t)&v94;
          uint64_t v96 = 0x4002000000;
          uint64_t v97 = __Block_byref_object_copy__8;
          char v98 = (void ***)__Block_byref_object_dispose__8;
          LOBYTE(v99[0]) = 0;
          LOBYTE(v10dyld4::halt("obsolete dyld API called", 0) = 0;
          long long v105 = _NSConcreteStackBlock;
          uint64_t v106 = 0x40000000;
          uint64_t v107 = (uint64_t)___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke;
          uint64_t v108 = (__n128 (*)(uint64_t, uint64_t))&unk_1EFF65AA8;
          int v111 = a2;
          uint64_t v112 = v8;
          uint64_t v109 = &v94;
          uint64_t v110 = v23;
          dyld3::MachOFile::forEachSection(v24, (uint64_t)&v105);
          uint64_t v26 = *(void *)(v95 + 40);
          int v27 = *(unsigned __int8 *)(v95 + 48);
          int v28 = *(unsigned __int8 *)(v95 + 56);
          _Block_object_dispose(&v94, 8);
          if (v28)
          {
            if ((*((_WORD *)v23 + 2) & 2) != 0)
            {
              uint64_t v38 = (char *)dyld3::MachOFile::preferredLoadAddress(v24);
              BOOL v39 = dyld3::MachOFile::is64(v24);
              if (!v79) {
                dyld4::PrebuiltObjC::make();
              }
              if (!v78) {
                dyld4::PrebuiltObjC::make();
              }
              if (v39)
              {
                unsigned int v40 = objc::objc_headeropt_ro_t<unsigned long long>::get(v79, v76, v38);
                if (!v40) {
                  goto LABEL_72;
                }
                __int16 v41 = objc::objc_headeropt_ro_t<unsigned long long>::index(v79, (unint64_t)v40);
                if (*(_DWORD *)(v78 + 4) != 8) {
                  dyld4::PrebuiltObjC::make();
                }
                unsigned __int8 v42 = v41;
              }
              else
              {
                int v43 = objc::objc_headeropt_ro_t<unsigned int>::get(v79, v76, v38);
                if (!v43) {
                  goto LABEL_72;
                }
                __int16 v41 = objc::objc_headeropt_ro_t<unsigned long long>::index(v79, (unint64_t)v43);
                if (*(_DWORD *)(v78 + 4) != 4) {
                  dyld4::PrebuiltObjC::make();
                }
                unsigned __int8 v42 = v41;
              }
              LOWORD(v94) = v41 & 0xFF00 | v42;
              uint64_t v95 = (uint64_t)v38;
              LOBYTE(v96) = 1;
              uint64_t v97 = (__n128 (*)(uint64_t, uint64_t))v23;
              dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::insert((uint64_t)v87, (unsigned __int16 *)&v94);
            }
            else
            {
              if (dyld4::Loader::matchesPath(v23, v8, "/usr/lib/libobjc.A.dylib")) {
                goto LABEL_72;
              }
              int v29 = v27;
              uint64_t v30 = dyld3::MachOFile::preferredLoadAddress(v24);
              dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage,4294967295ull>::verifySpace((vm_address_t *)v77, 1);
              vm_address_t v31 = *(void *)v77;
              uint64_t v32 = *((void *)v77 + 2);
              *((void *)v77 + 2) = v32 + 1;
              dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage((dyld4::PrebuiltObjC::ObjCOptimizerImage *)(v31 + 568 * v32), v23, v30, v25);
              uint64_t v33 = *((void *)v77 + 2);
              if (!v33) {
                ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
              }
              vm_address_t v34 = *(void *)v77;
              uint64_t v35 = v33 - 1;
              uint64_t v36 = (dyld4::Loader **)(*(void *)v77 + 568 * (v33 - 1));
              void *v36 = v23;
              if (!v29) {
LABEL_82:
              }
                std::__throw_bad_optional_access[abi:nn180100]();
              vm_address_t v37 = v34 + 568 * v35;
              *(void *)(v37 + 488) = v26;
              v81[0] = _NSConcreteStackBlock;
              v81[1] = 0x40000000;
              char v82 = ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke;
              int v83 = &__block_descriptor_tmp_32_2;
              int v86 = v25;
              uint64_t v84 = v24;
              uint64_t v85 = v36;
              ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke((uint64_t)v81, "__objc_selrefs", (unint64_t *)(v37 + 496), (unsigned int *)(v37 + 528));
              v82((uint64_t)v81, "__objc_classlist", (unint64_t *)(v37 + 504), (unsigned int *)(v37 + 532));
              v82((uint64_t)v81, "__objc_catlist", (unint64_t *)(v37 + 512), (unsigned int *)(v37 + 536));
              v82((uint64_t)v81, "__objc_protolist", (unint64_t *)(v37 + 520), (unsigned int *)(v37 + 540));
              int v8 = v74;
            }
          }
          ++v22;
          ++v20;
          v21 -= 8;
        }
        while (v21);
      }
      unint64_t v44 = v77;
      uint64_t v45 = *((void *)v77 + 2);
      if (v45)
      {
        uint64_t v46 = 0;
        vm_address_t v47 = *(void *)v77;
        uint64_t v71 = v126;
        unsigned int v68 = v118;
        char v69 = v120;
        unsigned int v67 = v116;
        unint64_t v70 = v114;
        uint64_t v48 = 568 * v45;
        do
        {
          vm_address_t v49 = v47 + v46;
          if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32)))
          {
            if (*(_DWORD *)(v49 + 532))
            {
              long long v105 = 0;
              uint64_t v106 = (uint64_t)&v105;
              uint64_t v107 = 0x4802000000;
              uint64_t v108 = __Block_byref_object_copy__74_0;
              uint64_t v109 = (void ***)__Block_byref_object_dispose__75_0;
              uint64_t v50 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v49, v8);
              metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v110, v50);
              if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32)))
              {
                uint64_t v51 = *(void *)(*((void *)v8 + 1) + 272);
                uint64_t v94 = _NSConcreteStackBlock;
                uint64_t v95 = 0x40000000;
                uint64_t v96 = (uint64_t)___ZN5dyld4L19optimizeObjCClassesERNS_12RuntimeStateEPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS7_IPKcNSB_10BindTargetENS6_11HashCStringENS6_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                uint64_t v97 = (__n128 (*)(uint64_t, uint64_t))&unk_1EFF65AD0;
                char v98 = &v105;
                v99[0] = v47 + v46;
                v99[1] = v8;
                uint64_t v100 = v51;
                char v101 = 1;
                uint64_t v102 = v75;
                long long v103 = v87;
                uint64_t v104 = (char *)v77 + 344;
                objc_visitor::Visitor::forEachClass((unsigned int *)(v106 + 40), (uint64_t)&v94);
              }
              _Block_object_dispose(&v105, 8);
            }
            if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32)))
            {
              vm_address_t v52 = v47 + v46;
              unint64_t v53 = *(unsigned int *)(v47 + v46 + 540);
              if (v53)
              {
                dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve((void *)(v52 + 120), v53);
                uint64_t v94 = 0;
                uint64_t v95 = (uint64_t)&v94;
                uint64_t v96 = 0x4802000000;
                uint64_t v97 = __Block_byref_object_copy__74_0;
                char v98 = (void ***)__Block_byref_object_dispose__75_0;
                uint64_t v54 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v52, v8);
                metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v99, v54);
                if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32)))
                {
                  long long v105 = _NSConcreteStackBlock;
                  uint64_t v106 = 0x40000000;
                  uint64_t v107 = (uint64_t)___ZN5dyld4L21optimizeObjCProtocolsERNS_12RuntimeStateEPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                  uint64_t v108 = (__n128 (*)(uint64_t, uint64_t))&unk_1EFF65AF8;
                  uint64_t v109 = &v94;
                  uint64_t v110 = (dyld4::Loader *)(v47 + v46);
                  int v111 = v73;
                  uint64_t v112 = (dyld4::RuntimeState *)v87;
                  objc_visitor::Visitor::forEachProtocol((unsigned int *)(v95 + 40), (uint64_t)&v105);
                }
                _Block_object_dispose(&v94, 8);
              }
              if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32)))
              {
                int v55 = (dyld3::MachOFile *)dyld4::JustInTimeLoader::mf(*(void *)v49);
                int v56 = dyld3::MachOFile::pointerSize(v55);
                uint64_t v128 = 0;
                unint64_t v129 = &v128;
                uint64_t v130 = 0x2000000000;
                char v131 = 0;
                v127[0] = _NSConcreteStackBlock;
                v127[1] = 0x40000000;
                v127[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                v127[3] = &unk_1EFF65B20;
                v127[4] = &v128;
                dyld3::MachOFile::forEachSection(v55, (uint64_t)v127);
                if (*((unsigned char *)v129 + 24))
                {
                  Diagnostics::error((vm_address_t *)(v47 + v46 + 32), "Old objc section", v67, v68, v69, v70, v71);
                }
                else if ((dyld3::MachOFile::isArch(v55, "x86_64") || dyld3::MachOFile::isArch(v55, "x86_64h")) {
                       && dyld3::MachOFile::hasObjCMessageReferences(v55))
                }
                {
                  Diagnostics::error((vm_address_t *)(v47 + v46 + 32), "Cannot handle message refs", v67, v68, v69, v70, v71);
                }
                else
                {
                  uint64_t v94 = 0;
                  uint64_t v95 = (uint64_t)&v94;
                  uint64_t v96 = 0x4802000000;
                  uint64_t v97 = __Block_byref_object_copy__74_0;
                  char v98 = (void ***)__Block_byref_object_dispose__75_0;
                  uint64_t v57 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v49, v8);
                  metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v99, v57);
                  if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32)))
                  {
                    vm_address_t v58 = v47 + v46;
                    BOOL v59 = *(Diagnostics **)(v47 + v46 + 496);
                    char v60 = (Diagnostics *)((char *)v59 + (*(_DWORD *)(v47 + v46 + 528) * v56));
                    long long v105 = _NSConcreteStackBlock;
                    uint64_t v106 = 0x40000000;
                    uint64_t v107 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_2;
                    uint64_t v108 = (__n128 (*)(uint64_t, uint64_t))&unk_1EFF65B48;
                    uint64_t v109 = &v94;
                    uint64_t v110 = (dyld4::Loader *)(v47 + v46);
                    int v111 = v59;
                    uint64_t v112 = v60;
                    v125[0] = _NSConcreteStackBlock;
                    v125[1] = 0x40000000;
                    v126[0] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_3;
                    v126[1] = &unk_1EFF65B70;
                    v126[2] = &v105;
                    v126[3] = &v94;
                    if (*(_DWORD *)(v49 + 532))
                    {
                      uint64_t v121 = 0;
                      uint64_t v122 = &v121;
                      uint64_t v123 = 0x2000000000;
                      char v124 = 0;
                      v119[0] = _NSConcreteStackBlock;
                      v119[1] = 0x40000000;
                      v120[0] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_4;
                      v120[1] = &unk_1EFF65B98;
                      v120[3] = &v94;
                      v120[2] = v125;
                      v120[4] = &v121;
                      objc_visitor::Visitor::forEachClassAndMetaClass((unsigned int *)(v95 + 40), (uint64_t)v119);
                      uint64_t v61 = v122;
                      *(unsigned char *)(v58 + 548) = *((unsigned char *)v122 + 24);
                      *(unsigned char *)(v58 + 545) = *((unsigned char *)v61 + 24);
                      _Block_object_dispose(&v121, 8);
                    }
                    if (*(_DWORD *)(v58 + 536))
                    {
                      uint64_t v121 = 0;
                      uint64_t v122 = &v121;
                      uint64_t v123 = 0x2000000000;
                      char v124 = 0;
                      v117[0] = _NSConcreteStackBlock;
                      v117[1] = 0x40000000;
                      v118[0] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_5;
                      v118[1] = &unk_1EFF61FB0;
                      v118[3] = &v94;
                      v118[2] = v125;
                      v118[4] = &v121;
                      objc_visitor::Visitor::forEachCategory((unsigned int *)(v95 + 40), (uint64_t)v117);
                      stat v62 = v122;
                      vm_address_t v63 = v47 + v46;
                      *(unsigned char *)(v63 + 549) = *((unsigned char *)v122 + 24);
                      *(unsigned char *)(v63 + 546) = *((unsigned char *)v62 + 24);
                      _Block_object_dispose(&v121, 8);
                    }
                    if (*(_DWORD *)(v52 + 540))
                    {
                      uint64_t v121 = 0;
                      uint64_t v122 = &v121;
                      uint64_t v123 = 0x2000000000;
                      char v124 = 0;
                      v115[0] = _NSConcreteStackBlock;
                      v115[1] = 0x40000000;
                      v116[0] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_6;
                      v116[1] = &unk_1EFF61E00;
                      v116[3] = &v94;
                      v116[2] = v125;
                      v116[4] = &v121;
                      objc_visitor::Visitor::forEachProtocol((unsigned int *)(v95 + 40), (uint64_t)v115);
                      uint64_t v64 = v122;
                      vm_address_t v65 = v47 + v46;
                      *(unsigned char *)(v65 + 55dyld4::halt("obsolete dyld API called", 0) = *((unsigned char *)v122 + 24);
                      *(unsigned char *)(v65 + 547) = *((unsigned char *)v64 + 24);
                      _Block_object_dispose(&v121, 8);
                    }
                    v113[0] = _NSConcreteStackBlock;
                    v113[1] = 0x40000000;
                    v114[0] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_7;
                    v114[1] = &__block_descriptor_tmp_97;
                    v114[2] = v47 + v46;
                    v114[3] = v72;
                    v114[4] = (char *)v77 + 40;
                    if (!*(unsigned char *)(v47 + v46 + 24)) {
                      goto LABEL_82;
                    }
                    dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(v8, *(dyld4::Loader **)(v47 + v46), *(void *)(v47 + v46 + 16), v58 + 488, (uint64_t)v113);
                  }
                  _Block_object_dispose(&v94, 8);
                }
                _Block_object_dispose(&v128, 8);
                unint64_t v44 = v77;
                if (!Diagnostics::hasError((Diagnostics *)(v47 + v46 + 32))) {
                  dyld4::PrebuiltObjC::commitImage(v77, (const dyld4::PrebuiltObjC::ObjCOptimizerImage *)(v47 + v46));
                }
              }
            }
          }
          v46 += 568;
        }
        while (v48 != v46);
      }
      dyld4::PrebuiltObjC::generateHashTables(v44);
      uint64_t v66 = (dyld3::MachOFile *)dyld4::Loader::mf(*((dyld4::Loader **)v8 + 3), v8);
      dyld3::MachOFile::pointerSize(v66);
      dyld4::PrebuiltObjC::generatePerImageFixups((vm_address_t *)v44, v8);
      *((unsigned char *)v44 + 441) = 1;
LABEL_72:
      uint64_t v91 = 0;
      if (address) {
        vm_deallocate(mach_task_self_, address, size);
      }
      uint64_t v88 = 0;
      if (v89) {
        vm_deallocate(mach_task_self_, v89, v90);
      }
    }
  }
}

uint64_t dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::insert(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0;
    memset(v22, 0, sizeof(v22));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v22, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v22, 1);
      uint64_t v6 = (*(void *)&v22[1])++;
      *(_DWORD *)(*(void *)&v22[0] + 4 * v6) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0;
      do
      {
        int v8 = (unsigned __int16 *)dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v7);
        unint64_t v9 = (LODWORD(v22[1]) - 1) & *v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v22, v9) != -1)
        {
          uint64_t v10 = 1;
          do
            unint64_t v9 = (*(void *)&v22[1] - 1) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v22, v9) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v22, v9) = v7++;
      }
      while (v7 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v22)
    {
      *(void *)&v22[1] = 0;
      if (*((void *)&v22[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v22[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v11 = *(void *)(a1 + 40);
      if (v11) {
        vm_deallocate(mach_task_self_, v11, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v22[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v22 + 8);
      vm_size_t v12 = size;
      *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = *((void *)&v22[1] + 1);
      *(void *)(a1 + 48) = v12;
    }
  }
  unint64_t v13 = (*(_DWORD *)(a1 + 32) - 1) & (unint64_t)*a2;
  unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
  if (v14 == -1)
  {
LABEL_20:
    uint64_t v16 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13) = v16;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::verifySpace(a1 + 56, 1);
    uint64_t v17 = *(void *)(a1 + 56);
    uint64_t v18 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v18 + 1;
    uint64_t v19 = v17 + 32 * v18;
    *(_WORD *)uint64_t v19 = *a2;
    *(_OWORD *)(v19 + 8) = *(_OWORD *)(a2 + 4);
    *(void *)(v19 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((void *)a2 + 3);
    uint64_t v20 = *(void *)(a1 + 72);
    if (!v20) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 32 * v20 - 32;
  }
  else
  {
    uint64_t v15 = 1;
    while (*(unsigned __int16 *)dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v14) != *a2)
    {
      unint64_t v13 = (*(void *)(a1 + 32) - 1) & (v13 + v15++);
      unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
      if (v14 == -1) {
        goto LABEL_20;
      }
    }
    return dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v14);
  }
}

uint64_t ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke(uint64_t a1, const char *a2, unint64_t *a3, unsigned int *a4)
{
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  uint64_t result = dyld3::MachOFile::findObjCDataSection(*(dyld3::MachOFile **)(a1 + 32), a2, &v12, &v11);
  if (result)
  {
    unsigned int v8 = v11;
    unint64_t v9 = *(unsigned int *)(a1 + 48);
    if (v11 % v9) {
      return Diagnostics::error((vm_address_t *)(*(void *)(a1 + 40) + 32), "Invalid objc pointer section size");
    }
    *a3 = v12;
    unsigned int v10 = v8 / v9;
  }
  else
  {
    unsigned int v10 = 0;
    *a3 = 0;
  }
  *a4 = v10;
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeFixups(dyld4::PrebuiltObjC *this, const dyld4::Loader *a2, dyld4::BumpAllocator *a3)
{
  if (!*((unsigned char *)this + 441)) {
    return 0;
  }
  if ((*((__int16 *)a2 + 3) & 0x80000000) == 0) {
    dyld4::PrebuiltObjC::serializeFixups();
  }
  uint64_t v4 = (void *)dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[]((vm_address_t *)this + 58, *((_WORD *)a2 + 3) & 0x7FFF);
  if (!*v4) {
    return 0;
  }
  unint64_t v5 = v4;
  uint64_t v6 = *((void *)a3 + 2);
  uint64_t v7 = v6 - *(void *)a3;
  uint64_t v8 = (v6 - *(_DWORD *)a3);
  dyld4::BumpAllocator::append(a3, v4, 0x50uLL);
  unint64_t v9 = v5[12];
  if (v9)
  {
    if (v9 != *((_DWORD *)v5 + 13)) {
      dyld4::PrebuiltObjC::serializeFixups();
    }
    int v10 = *((_DWORD *)a3 + 4) - *(void *)a3 - v7;
    *(_DWORD *)(*(void *)a3 + v8 + 64) = (unsigned __int16)(*((_WORD *)a3 + 8) - *(void *)a3 - v7);
    dyld4::BumpAllocator::zeroFill(a3, v9);
    dyld4::BumpAllocator::align(a3, 8u);
    memmove((void *)(*(void *)a3 + v7 + (unsigned __int16)v10), (const void *)v5[10], v5[12]);
  }
  uint64_t v11 = v5[17];
  if (v11)
  {
    int v12 = *((_DWORD *)a3 + 4) - *(void *)a3 - v7;
    uint64_t v13 = *(void *)a3 + v8;
    *(_DWORD *)(v13 + 68) = (unsigned __int16)(*((_WORD *)a3 + 8) - *(void *)a3 - v7);
    *(_DWORD *)(v13 + 72) = v11;
    dyld4::BumpAllocator::zeroFill(a3, 8 * v11);
    memmove((void *)(*(void *)a3 + v7 + (unsigned __int16)v12), (const void *)v5[15], 8 * v5[17]);
  }
  return v7;
}

uint64_t ___ZN5dyld4L22checkForDuplicateClassE9VMAddressPKcPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairIS0_PKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS8_IS2_NSB_10BindTargetENS7_11HashCStringENS7_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, uint64_t a2, unsigned __int16 a3, unsigned char *a4)
{
  unsigned __int16 v14 = a3;
  uint64_t result = dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>(*(void *)(a1 + 32), (void *)(*(void *)(a1 + 32) + 16), (void *)(*(void *)(a1 + 32) + 56), 0, &v14);
  if (result != *(void *)(*(void *)(a1 + 32) + 56) + 32 * *(void *)(*(void *)(a1 + 32) + 72))
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)(result + 24);
    uint64_t result = (uint64_t)dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>(*(void *)(a1 + 40), (uint64_t *)(*(void *)(a1 + 40) + 16), (void *)(*(void *)(a1 + 40) + 56), 0, (const char **)(a1 + 48));
    if (result == *(void *)(*(void *)(a1 + 40) + 56) + 24 * *(void *)(*(void *)(a1 + 40) + 72))
    {
      if (!*(unsigned char *)(a1 + 64) || !*(unsigned char *)(v8 + 16)) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      uint64_t v10 = a2 - *(void *)(v8 + 8) + *(void *)(a1 + 56);
      uint64_t v11 = *(void *)(a1 + 72) + 160;
      *(void *)&long long v12 = *(void *)(a1 + 48);
      *((void *)&v12 + 1) = v9;
      uint64_t v13 = v10;
      uint64_t result = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert(v11, &v12);
    }
    *a4 = 1;
  }
  return result;
}

uint64_t dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>(uint64_t a1, void *a2, void *a3, uint64_t a4, unsigned __int16 *a5)
{
  unint64_t v5 = a3[2];
  if (!v5) {
    return *a3;
  }
  uint64_t v6 = *a5;
  unint64_t v7 = a2[2];
  unint64_t v8 = (v7 - 1) & v6;
  if (v7 <= v8) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v9 = *a3;
  uint64_t v10 = 1;
  while (1)
  {
    unint64_t v11 = *(unsigned int *)(*a2 + 4 * v8);
    if (v11 == -1) {
      return v9 + 32 * v5;
    }
    if (v5 <= v11) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    if (*(unsigned __int16 *)(v9 + 32 * v11) == v6) {
      return v9 + 32 * v11;
    }
    unint64_t v8 = (v8 + v10++) & (v7 - 1);
    if (v7 <= v8) {
      goto LABEL_8;
    }
  }
}

uint64_t ___ZN5dyld4L23protocolIsInSharedCacheEPKcPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEE_block_invoke(uint64_t a1, uint64_t a2, unsigned __int16 a3, unsigned char *a4)
{
  unsigned __int16 v7 = a3;
  uint64_t result = dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>(*(void *)(a1 + 40), (void *)(*(void *)(a1 + 40) + 16), (void *)(*(void *)(a1 + 40) + 56), 0, &v7);
  if (result != *(void *)(*(void *)(a1 + 40) + 56) + 32 * *(void *)(*(void *)(a1 + 40) + 72))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

uint64_t dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)a1)
  {
    unint64_t v7 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v6;
    size[0] = 0;
    memset(v40, 0, sizeof(v40));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v40, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v40, 1);
      uint64_t v8 = (*(void *)&v40[1])++;
      *(void *)(*(void *)&v40[0] + 8 * v8) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v9 = 0;
      do
      {
        if ((*(unsigned char *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v9)+ 48) & 6) == 0)
        {
          uint64_t v10 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v9);
          unint64_t v11 = murmurHash(*(uint64_t **)v10, *(_DWORD *)(v10 + 8), 0);
          unint64_t v12 = (*(void *)&v40[1] - 1) & v11;
          if (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v40, v12) != -1)
          {
            uint64_t v13 = 1;
            do
              unint64_t v12 = (*(void *)&v40[1] - 1) & (v12 + v13++);
            while (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v40, v12) != -1);
          }
          *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v40, v12) = v9;
        }
        ++v9;
      }
      while (v9 != *(void *)(a1 + 72));
    }
    if ((_OWORD *)(a1 + 16) == v40)
    {
      *(void *)&v40[1] = 0;
      if (*((void *)&v40[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v40[1] + 1), size[0]);
      }
    }
    else
    {
      vm_address_t v14 = *(void *)(a1 + 40);
      if (v14) {
        vm_deallocate(mach_task_self_, v14, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v40[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v40 + 8);
      vm_size_t v15 = size[0];
      *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = *((void *)&v40[1] + 1);
      *(void *)(a1 + 48) = v15;
    }
  }
  unint64_t v16 = (*(void *)(a1 + 32) - 1) & murmurHash(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), 0);
  unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
  if (v17 == -1)
  {
LABEL_23:
    uint64_t v18 = (void *)(a1 + 56);
    uint64_t v22 = *(void *)(a1 + 72);
    *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16) = v22;
    ++*(void *)(a1 + 8);
    long long v23 = *(_OWORD *)(a2 + 16);
    v40[0] = *(_OWORD *)a2;
    v40[1] = v23;
    *(_OWORD *)vm_size_t size = *(_OWORD *)(a2 + 32);
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v24 = *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v25 + 1;
    uint64_t v26 = v24 + 56 * v25;
    *(_OWORD *)uint64_t v26 = v40[0];
    *(_OWORD *)(v26 + 16) = v40[1];
    *(_OWORD *)(v26 + 32) = *(_OWORD *)size;
    *(void *)(v26 + 48) = 0;
    *a3 = 0;
    uint64_t v27 = *(void *)(a1 + 72);
    if (!v27) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
  }
  else
  {
    uint64_t v18 = (void *)(a1 + 56);
    uint64_t v19 = 1;
    while (1)
    {
      uint64_t v20 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v17);
      size_t v21 = *(void *)(v20 + 8);
      if (v21 == *(void *)(a2 + 8) && !_platform_memcmp(*(const void **)v20, *(const void **)a2, v21)) {
        break;
      }
      unint64_t v16 = (*(void *)(a1 + 32) - 1) & (v16 + v19++);
      unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
      if (v17 == -1) {
        goto LABEL_23;
      }
    }
    while (1)
    {
      char v28 = *(unsigned char *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]((void *)(a1 + 56), v17)+ 48);
      int v29 = (void *)(a1 + 56);
      if ((v28 & 3) == 0) {
        break;
      }
      unint64_t v17 = *(void *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[](v29, v17)+ 48) >> 3;
    }
    uint64_t v30 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[](v29, v17);
    uint64_t v31 = *(void *)(v30 + 48);
    if ((v31 & 7) != 0)
    {
      if ((v31 & 4) == 0) {
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert();
      }
      unint64_t v32 = v31 & 0xFFFFFFFFFFFFFFF9 | 2;
      *(void *)(v30 + 48) = v32;
      uint64_t v33 = v32 & 3 | (8 * *(void *)(a1 + 72));
    }
    else
    {
      uint64_t v34 = v31 | 1;
      *(void *)(v30 + 48) = v34;
      uint64_t v33 = v34 & 7 | (8 * *(void *)(a1 + 72));
    }
    *(void *)(v30 + 48) = v33;
    long long v35 = *(_OWORD *)(a2 + 16);
    v40[0] = *(_OWORD *)a2;
    v40[1] = v35;
    *(_OWORD *)vm_size_t size = *(_OWORD *)(a2 + 32);
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v36 = *(void *)(a1 + 56);
    uint64_t v37 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v37 + 1;
    uint64_t v38 = v36 + 56 * v37;
    *(_OWORD *)uint64_t v38 = v40[0];
    *(_OWORD *)(v38 + 16) = v40[1];
    *(_OWORD *)(v38 + 32) = *(_OWORD *)size;
    *(void *)(v38 + 48) = 4;
    *a3 = 1;
    uint64_t v27 = *(void *)(a1 + 72);
    if (!v27) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
  }
  return *v18 + 56 * v27 - 56;
}

unint64_t dyld3::OverflowSafeArray<BOOL,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + a2;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 56 * a2;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    unint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 56 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    uint64_t result = memmove((void *)v4[3], *v4, 56 * (void)v4[2]);
    unint64_t v9 = (unint64_t)v4[4] / 0x38;
    *unint64_t v4 = v4[3];
    v4[1] = (const void *)v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

const char **dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::const_find<char const*>(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return (const char **)*a3;
  }
  vm_size_t v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v23, (uint64_t *)v8, v9);
  unint64_t v11 = a2[2];
  unint64_t v12 = v11 - 1;
  unint64_t v13 = v10 & (v11 - 1);
  if (v11 <= v13) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v14 = *a2;
  unint64_t v15 = a3[2];
  uint64_t v16 = *a3;
  uint64_t v17 = 1;
  uint64_t v18 = *a5;
  while (1)
  {
    unint64_t v19 = *(unsigned int *)(v14 + 4 * v13);
    if (v19 == -1) {
      return (const char **)(v16 + 24 * v15);
    }
    if (v15 <= v19) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
    }
    uint64_t v20 = (const char **)(v16 + 24 * v19);
    if (!_platform_strcmp(*v20, v18)) {
      return v20;
    }
    unint64_t v21 = v13 + v17++;
    unint64_t v13 = v21 & v12;
    if (v11 <= (v21 & v12)) {
      goto LABEL_8;
    }
  }
}

uint64_t dyld3::MapBase<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::find<VMOffset>(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a3[2]) {
    return *a3;
  }
  if (!*(unsigned char *)(a5 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v8 = a2[2];
  unint64_t v9 = (v8 - 1) & *(void *)a5;
  if (v8 <= v9) {
LABEL_9:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v10 = 1;
  while (1)
  {
    unint64_t v11 = *(unsigned int *)(*a2 + 4 * v9);
    unint64_t v12 = a3[2];
    if (v11 == -1) {
      return *a3 + 24 * v12;
    }
    if (v12 <= v11) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    if (dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(*a3 + 24 * v11, a5)) {
      break;
    }
    unint64_t v13 = a2[2];
    unint64_t v9 = (v13 - 1) & (v9 + v10++);
    if (v13 <= v9) {
      goto LABEL_9;
    }
  }
  if (a3[2] <= v11) {
    ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
  }
  return *a3 + 24 * v11;
}

BOOL dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 8) || !*(unsigned char *)(a2 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return *(void *)a1 == *(void *)a2;
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, int *a2)
{
  objc_visitor::Method::getNameVMAddr(a2, *(void *)(a1 + 40));
  char v5 = v4;
  objc_visitor::Method::getNameField(a2, *(void *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  char v7 = v6;
  objc_visitor::Method::getName(a2, *(void *)(a1 + 40));
  if (!v5 || !v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2(uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if (result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if (result)
      {
        int v5 = result;
        for (int i = 0; i != v5; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(a1 + 40), i, (uint64_t)&v8);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16))(Method);
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  objc_visitor::Class::getBaseMethods(a2, *(int **)(a1 + 40), (uint64_t)&v4);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke(uint64_t a1, int *a2)
{
  objc_visitor::Method::getNameVMAddr(a2, *(void *)(a1 + 40));
  char v5 = v4;
  objc_visitor::Method::getNameField(a2, *(void *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  char v7 = v6;
  objc_visitor::Method::getName(a2, *(void *)(a1 + 40));
  if (!v5 || !v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2(uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if (result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if (result)
      {
        int v5 = result;
        for (int i = 0; i != v5; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(a1 + 40), i, (uint64_t)&v8);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16))(Method);
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3(uint64_t a1, lsl::Allocator::Pool *a2)
{
  objc_visitor::Category::getInstanceMethods(a2, *(int **)(a1 + 40), (uint64_t)v6);
  objc_visitor::Category::getClassMethods(a2, *(int **)(a1 + 40), (uint64_t)&v5);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

__n128 __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

void ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke(void *a1, uint64_t a2, char a3, unsigned char *a4)
{
  if (!_platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL)
    && !_platform_strcmp(*(const char **)(a2 + 80), "__objc_imageinfo"))
  {
    if ((a3 & 1) == 0 && *(void *)(a2 + 72) == 8)
    {
      uint64_t v8 = (dyld4::Loader *)a1[5];
      unint64_t v9 = (vm_address_t *)a1[6];
      uint64_t v10 = (dyld4::RuntimeState *)a1[7];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      long long v11[2] = ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke_2;
      void v11[3] = &unk_1EFF65A80;
      v11[4] = a1[4];
      v11[5] = a2;
      dyld4::Loader::withLayout(v8, v9, v10, (uint64_t)v11);
    }
    *a4 = 1;
  }
}

uint64_t ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke_2(uint64_t result, mach_o::Layout *this)
{
  uint64_t v2 = *(void *)(result + 40);
  unint64_t v3 = (void *)(*((void *)this + 1) + 48 * ((unsigned __int16)*(_DWORD *)(v2 + 56) >> 4));
  uint64_t v4 = *(void *)(v2 + 64);
  if ((*(unsigned char *)(v3[4] + v4 - *v3 + 4) & 0x80) == 0)
  {
    uint64_t v5 = result;
    __n128 result = mach_o::Layout::textUnslidVMAddr(this);
    uint64_t v6 = *(void *)(*(void *)(v5 + 32) + 8);
    int v7 = *(unsigned __int8 *)(v6 + 56);
    *(void *)(v6 + 4dyld4::halt("obsolete dyld API called", 0) = v4 - result;
    *(unsigned char *)(v6 + 48) = 1;
    if (!v7) {
      *(unsigned char *)(v6 + 56) = 1;
    }
  }
  return result;
}

void *objc::objc_headeropt_ro_t<unsigned long long>::get(int *a1, uint64_t a2, char *a3)
{
  if (*a1 < 0) {
    return 0;
  }
  int v3 = 0;
  int v4 = *a1;
  while (1)
  {
    int v5 = v3 + v4;
    if (v3 + v4 < 0 != __OFADD__(v3, v4)) {
      ++v5;
    }
    if (*a1 <= (v5 >> 1)) {
      objc::objc_headeropt_ro_t<unsigned long long>::get();
    }
    int v6 = v5 >> 1;
    int v7 = (void *)((char *)a1 + (a1[1] * (v5 >> 1)) + 8);
    uint64_t v8 = (char *)v7 + a2 - (void)a1 + *v7;
    if (v8 == a3) {
      break;
    }
    if (v8 <= a3) {
      int v3 = v6 + 1;
    }
    else {
      int v4 = v6 - 1;
    }
    if (v3 > v4) {
      return 0;
    }
  }
  return v7;
}

unint64_t objc::objc_headeropt_ro_t<unsigned long long>::index(_DWORD *a1, unint64_t a2)
{
  if (!*a1) {
    objc::objc_headeropt_ro_t<unsigned long long>::get();
  }
  uint64_t v2 = a1 + 2;
  if ((unint64_t)(a1 + 2) > a2
    || (unint64_t v3 = a1[1], (unint64_t)v2 + (v3 * *a1) <= a2))
  {
    objc::objc_headeropt_ro_t<unsigned long long>::index();
  }
  return (a2 - (unint64_t)v2) / v3;
}

int *objc::objc_headeropt_ro_t<unsigned int>::get(int *a1, uint64_t a2, char *a3)
{
  if (*a1 < 0) {
    return 0;
  }
  int v3 = 0;
  int v4 = *a1;
  while (1)
  {
    int v5 = v3 + v4;
    if (v3 + v4 < 0 != __OFADD__(v3, v4)) {
      ++v5;
    }
    if (*a1 <= (v5 >> 1)) {
      objc::objc_headeropt_ro_t<unsigned long long>::get();
    }
    int v6 = v5 >> 1;
    int v7 = (int *)((char *)a1 + (a1[1] * (v5 >> 1)) + 8);
    uint64_t v8 = (char *)v7 + a2 - (void)a1 + *v7;
    if (v8 == a3) {
      break;
    }
    if (v8 <= a3) {
      int v3 = v6 + 1;
    }
    else {
      int v4 = v6 - 1;
    }
    if (v3 > v4) {
      return 0;
    }
  }
  return v7;
}

__n128 __Block_byref_object_copy__74_0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

void *___ZN5dyld4L19optimizeObjCClassesERNS_12RuntimeStateEPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS7_IPKcNSB_10BindTargetENS6_11HashCStringENS6_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, objc_visitor::Class *a2)
{
  if ((objc_visitor::Class::isRootClass((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) & 1) == 0)
  {
    objc_visitor::Class::getSuperclassField((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v16);
    metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v16);
    if (!v4) {
      goto LABEL_11;
    }
    if (!*(void *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v16))
    {
      Name = (const char *)objc_visitor::Class::getName((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
      uint64_t v14 = *(void *)(a1 + 40);
      unint64_t v15 = (const char *)dyld4::JustInTimeLoader::path(*(void *)v14);
      return (void *)Diagnostics::error((vm_address_t *)(v14 + 32), "Missing weak superclass of class %s in %s", Name, v15);
    }
  }
  if (objc_visitor::Class::isUnfixedBackwardDeployingStableSwift((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)))*(unsigned char *)(*(void *)(a1 + 40) + 544) = 1; {
  VMuint64_t Address = objc_visitor::Class::getVMAddress(a2);
  }
  char v7 = v6;
  uint64_t NameVMAddr = objc_visitor::Class::getNameVMAddr((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  char v10 = v9;
  unint64_t v11 = (char *)objc_visitor::Class::getName((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  if (!v7 || !v10) {
LABEL_11:
  }
    std::__throw_bad_optional_access[abi:nn180100]();
  return dyld4::PrebuiltObjC::ObjCOptimizerImage::visitClass(*(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 64), *(unsigned int **)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), VMAddress, 1, NameVMAddr, 1, v11);
}

void ___ZN5dyld4L21optimizeObjCProtocolsERNS_12RuntimeStateEPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, lsl::Allocator::Pool *a2, unsigned char *a3)
{
  objc_visitor::Protocol::getISAVMAddr(a2, *(void *)(*(void *)(a1 + 32) + 8) + 40, (uint64_t)v13);
  if (v13[16])
  {
    Diagnostics::error((vm_address_t *)(*(void *)(a1 + 40) + 32), "Protocol ISA must be null");
    *a3 = 1;
  }
  else
  {
    VMuint64_t Address = objc_visitor::Protocol::getVMAddress(a2);
    char v8 = v7;
    uint64_t NameVMAddr = objc_visitor::Protocol::getNameVMAddr(a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
    char v11 = v10;
    Name = (char *)objc_visitor::Protocol::getName(a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
    if (!v8 || !v11) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    dyld4::PrebuiltObjC::ObjCOptimizerImage::visitProtocol(*(void *)(a1 + 40), *(unsigned int **)(a1 + 48), *(void *)(a1 + 56), VMAddress, 1, NameVMAddr, 1, Name);
  }
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
  if (!result)
  {
    char v8 = *(const char **)(a2 + 80);
    uint64_t result = _platform_strcmp(v8, "__module_info");
    if (!result
      || (uint64_t result = _platform_strcmp(v8, "__protocol"), !result)
      || (uint64_t result = _platform_strcmp(v8, "__message_refs"), !result))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_2(void *a1, int *a2, unsigned char *a3)
{
  uint64_t result = (uint64_t)objc_visitor::Method::getNameSelRefVMAddr(a2, *(void *)(a1[4] + 8) + 40);
  uint64_t v7 = a1[5];
  if (!*(unsigned char *)(v7 + 24) || !v6) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v8 = result - *(void *)(v7 + 16);
  if (v8 < a1[6] || v8 >= a1[7])
  {
    uint64_t result = Diagnostics::error((vm_address_t *)(v7 + 32), "Cannot handle relative method list pointing outside of __objc_selrefs");
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_3(uint64_t a1, objc_visitor::MethodList *this, unsigned char *a3)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if (result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if (result)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if (result)
      {
        int v7 = result;
        for (int i = 0; i != v7; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(*(void *)(a1 + 40) + 8) + 40, i, (uint64_t)&v10);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16))(Method);
        }
      }
    }
    else
    {
      *a3 = 1;
    }
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  objc_visitor::Class::getBaseMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)&v4);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_5(uint64_t a1, lsl::Allocator::Pool *a2, unsigned char *a3)
{
  objc_visitor::Category::getInstanceMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)v8);
  objc_visitor::Category::getClassMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)&v7);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (!*a3) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_6(uint64_t a1, lsl::Allocator::Pool *a2, unsigned char *a3)
{
  objc_visitor::Category::getClassMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)v10);
  objc_visitor::Protocol::getClassMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)v9);
  objc_visitor::Protocol::getOptionalInstanceMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)v8);
  objc_visitor::Protocol::getOptionalClassMethods(a2, (int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), (uint64_t)&v7);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (!*a3)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    if (!*a3)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
      if (!*a3) {
        return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
      }
    }
  }
  return result;
}

void *___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_7(uint64_t a1, int a2, unint64_t a3, char *__s, int a5)
{
  return dyld4::PrebuiltObjC::ObjCOptimizerImage::visitReferenceToObjCSelector(*(void *)(a1 + 32), *(objc::StringHashTable **)(a1 + 40), *(uint64_t **)(a1 + 48), (int)__s, a5, a3, 1, __s);
}

uint64_t dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3[2];
  if (v8)
  {
    uint64_t v11 = *a3;
    uint64_t v12 = *a3 + 24 * v8;
    int64x2_t v33 = vdupq_n_s64(1uLL);
    do
    {
      unint64_t v13 = *(void *)(v11 + 16);
      if ((v13 & 7) != 0)
      {
        if (v13)
        {
          unint64_t v14 = a3[2];
          if (v14 <= v13 >> 3) {
LABEL_22:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
          unint64_t v15 = v13 >> 3;
          uint64_t v16 = 2;
          uint64_t v17 = 16;
          while (1)
          {
            unint64_t v18 = *(void *)(*a3 + 24 * v15 + 16);
            if ((v18 & 3) == 0) {
              break;
            }
            unint64_t v15 = v18 >> 3;
            v17 += 8;
            ++v16;
            if (v14 <= v18 >> 3) {
              goto LABEL_22;
            }
          }
          __chkstk_darwin(result, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v33.i64[0]);
          unint64_t v21 = (v20 + 15) & 0xFFFFFFFFFFFFFFF0;
          uint64_t v22 = (uint64_t *)((char *)v33.i64 - v21);
          if (v19 >= 0x200) {
            size_t v23 = 512;
          }
          else {
            size_t v23 = v19;
          }
          bzero((char *)&v33 - v21, v23);
          uint64_t *v22 = v11 + 8;
          unint64_t v24 = a3[2];
          unint64_t v25 = *(void *)(v11 + 16);
          if (v24 <= v25 >> 3) {
LABEL_23:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
          unint64_t v26 = v25 >> 3;
          uint64_t v27 = *a3;
          uint64_t v28 = 1;
          while (1)
          {
            uint64_t v29 = v27 + 24 * v26;
            uint64_t v31 = *(void *)(v29 + 16);
            uint64_t v30 = (unint64_t *)(v29 + 16);
            v22[v28] = (uint64_t)(v30 - 1);
            if ((v31 & 3) == 0) {
              break;
            }
            unint64_t v32 = *v30;
            unint64_t v26 = *v30 >> 3;
            ++v28;
            if (v24 <= v32 >> 3) {
              goto LABEL_23;
            }
          }
          uint64_t v34 = v22;
          v35.i64[0] = v28 + 1;
          v35.i64[1] = v28 + 1;
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t **))(a4 + 16))(a4, v11, &v34);
        }
      }
      else
      {
        uint64_t v36 = v11 + 8;
        uint64_t v34 = &v36;
        int64x2_t v35 = v33;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t **))(a4 + 16))(a4, v11, &v34);
      }
      v11 += 24;
    }
    while (v11 != v12);
  }
  return result;
}

uint64_t dyld3::MapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::find<prebuilt_objc::ObjCStringKey>(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a3[2]) {
    return *a3;
  }
  unint64_t v8 = murmurHash(*(uint64_t **)a5, *(_DWORD *)(a5 + 8), 0);
  unint64_t v9 = a2[2];
  unint64_t v10 = v9 - 1;
  unint64_t v11 = v8 & (v9 - 1);
  if (v9 <= v11) {
LABEL_9:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>();
  uint64_t v12 = *a2;
  unint64_t v13 = a3[2];
  uint64_t v14 = *a3;
  uint64_t v15 = 1;
  uint64_t v18 = a5;
  uint64_t v17 = *(uint64_t **)a5;
  size_t v16 = *(void *)(v18 + 8);
  while (1)
  {
    unint64_t v19 = *(unsigned int *)(v12 + 4 * v11);
    if (v19 == -1) {
      return v14 + 32 * v13;
    }
    if (v13 <= v19) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    uint64_t v20 = v14 + 32 * v19;
    if (*(void *)(v20 + 8) == v16 && !_platform_memcmp(*(const void **)v20, v17, v16)) {
      return v20;
    }
    unint64_t v21 = v11 + v15++;
    unint64_t v11 = v21 & v10;
    if (v9 <= (v21 & v10)) {
      goto LABEL_9;
    }
  }
}

void *dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 40 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    uint64_t result = memmove((void *)v4[3], *v4, 40 * (void)v4[2]);
    unint64_t v9 = (unint64_t)v4[4] / 0x28;
    *uint64_t v4 = v4[3];
    v4[1] = (const void *)v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

void *dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (v3 + vm_page_size - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    uint64_t result = memmove((void *)v4[3], *v4, (size_t)v4[2]);
    unint64_t v9 = v4[4];
    *uint64_t v4 = v4[3];
    v4[1] = v9;
    if (v5)
    {
      vm_map_t v10 = mach_task_self_;
      return (void *)vm_deallocate(v10, v5, v6);
    }
  }
  return result;
}

uint64_t dyld3::Map<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::insert(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2 * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0;
    memset(v24, 0, sizeof(v24));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v24, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v24, 1);
      uint64_t v6 = (*(void *)&v24[1])++;
      *(_DWORD *)(*(void *)&v24[0] + 4 * v6) = -1;
    }
    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0;
      while (1)
      {
        uint64_t v8 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v7);
        if (!*(unsigned char *)(v8 + 8)) {
          break;
        }
        unint64_t v9 = (*(void *)&v24[1] - 1) & *(void *)v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v24, v9) != -1)
        {
          uint64_t v10 = 1;
          do
            unint64_t v9 = (*(void *)&v24[1] - 1) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v24, v9) != -1);
        }
        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v24, v9) = v7++;
        if (v7 == *(void *)(a1 + 72)) {
          goto LABEL_11;
        }
      }
LABEL_26:
      std::__throw_bad_optional_access[abi:nn180100]();
    }
LABEL_11:
    if ((_OWORD *)(a1 + 16) == v24)
    {
      *(void *)&v24[1] = 0;
      if (*((void *)&v24[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v24[1] + 1), size);
      }
    }
    else
    {
      vm_address_t v11 = *(void *)(a1 + 40);
      if (v11) {
        vm_deallocate(mach_task_self_, v11, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v24[0];
      *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)((char *)v24 + 8);
      vm_size_t v12 = size;
      *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = *((void *)&v24[1] + 1);
      *(void *)(a1 + 48) = v12;
    }
  }
  if (!*(unsigned char *)(a2 + 8)) {
    goto LABEL_26;
  }
  unint64_t v13 = (*(void *)(a1 + 32) - 1) & *(void *)a2;
  unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
  if (v14 == -1)
  {
LABEL_22:
    uint64_t v17 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13) = v17;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((void *)(a1 + 56), 1);
    uint64_t v18 = *(void *)(a1 + 56);
    uint64_t v19 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v19 + 1;
    uint64_t v20 = v18 + 24 * v19;
    long long v21 = *(_OWORD *)a2;
    *(_DWORD *)(v20 + 16) = *(_DWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v20 = v21;
    uint64_t v22 = *(void *)(a1 + 72);
    if (!v22) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 24 * v22 - 24;
  }
  else
  {
    uint64_t v15 = 1;
    while (1)
    {
      uint64_t v16 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v14);
      if (dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(v16, a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]((void *)(a1 + 56), v14);
      }
      unint64_t v13 = (*(void *)(a1 + 32) - 1) & (v13 + v15++);
      unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
      if (v14 == -1) {
        goto LABEL_22;
      }
    }
  }
}

uint64_t dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(vm_address_t *a1, unint64_t a2)
{
  vm_address_t v3 = a1[3];
  vm_size_t v4 = a1[4];
  unint64_t v5 = a1 + 3;
  unint64_t v6 = 2 * a1[1];
  if (v6 <= a2) {
    unint64_t v6 = a2;
  }
  vm_size_t v7 = (vm_page_size + 160 * v6 - 1) & -(uint64_t)vm_page_size;
  a1[4] = v7;
  uint64_t result = vm_allocate(mach_task_self_, v5, v7, 1006632961);
  if (result) {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
  }
  vm_address_t v9 = a1[3];
  if (a1[2])
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      vm_size_t v12 = (long long *)(*a1 + v10);
      vm_address_t v13 = v9 + v10;
      long long v14 = v12[1];
      long long v15 = v12[2];
      long long v16 = v12[4];
      *(_OWORD *)(v13 + 48) = v12[3];
      *(_OWORD *)(v13 + 64) = v16;
      *(_OWORD *)(v13 + 16) = v14;
      *(_OWORD *)(v13 + 32) = v15;
      long long v17 = *v12;
      *(_OWORD *)(v13 + 8dyld4::halt("obsolete dyld API called", 0) = 0uLL;
      *(_OWORD *)(v13 + 96) = 0uLL;
      *(_OWORD *)vm_address_t v13 = v17;
      *(void *)(v13 + 112) = 0;
      uint64_t v18 = *((void *)v12 + 10);
      *(_OWORD *)(v13 + 88) = *(long long *)((char *)v12 + 88);
      uint64_t v19 = *((void *)v12 + 13);
      *(void *)(v13 + 8dyld4::halt("obsolete dyld API called", 0) = v18;
      uint64_t v20 = *((void *)v12 + 14);
      *(void *)(v13 + 104) = v19;
      *(void *)(v13 + 112) = v20;
      *((void *)v12 + 14) = 0;
      void v12[5] = 0uLL;
      void v12[6] = 0uLL;
      *(void *)(v13 + 152) = 0;
      *(_OWORD *)(v13 + 136) = 0uLL;
      *(_OWORD *)(v13 + 12dyld4::halt("obsolete dyld API called", 0) = 0uLL;
      long long v21 = v12[8];
      *(void *)(v13 + 12dyld4::halt("obsolete dyld API called", 0) = *((void *)v12 + 15);
      *(_OWORD *)(v13 + 128) = v21;
      uint64_t v22 = *((void *)v12 + 19);
      *(void *)(v13 + 144) = *((void *)v12 + 18);
      *(void *)(v13 + 152) = v22;
      *((void *)v12 + 19) = 0;
      *(long long *)((char *)v12 + 136) = 0uLL;
      *(long long *)((char *)v12 + 12dyld4::halt("obsolete dyld API called", 0) = 0uLL;
      ++v11;
      v10 += 160;
    }
    while (v11 != a1[2]);
    vm_address_t v9 = *v5;
  }
  unint64_t v23 = a1[4] / 0xA0;
  *a1 = v9;
  a1[1] = v23;
  if (v3)
  {
    vm_map_t v24 = mach_task_self_;
    return vm_deallocate(v24, v3, v4);
  }
  return result;
}

uint64_t dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::Map(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1A8E6FD10;
  uint64_t v3 = 32;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }
  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve(a1 + 56, 0x20uLL);
  return a1;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(void *)(result + 8);
  if (v2 < a2)
  {
    uint64_t v3 = (vm_address_t *)result;
    vm_address_t v4 = *(void *)(result + 24);
    vm_size_t v5 = *(void *)(result + 32);
    unint64_t v6 = (vm_address_t *)(result + 24);
    unint64_t v7 = 2 * v2;
    if (v7 <= a2) {
      unint64_t v7 = a2;
    }
    vm_size_t v8 = (vm_page_size + 32 * v7 - 1) & -(uint64_t)vm_page_size;
    *(void *)(result + 32) = v8;
    uint64_t result = vm_allocate(mach_task_self_, v6, v8, 1006632961);
    if (result) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    vm_address_t v9 = v3[3];
    if (v3[2])
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        vm_size_t v12 = (_OWORD *)(v9 + v10);
        vm_address_t v13 = (_OWORD *)(*v3 + v10);
        long long v14 = v13[1];
        *vm_size_t v12 = *v13;
        v12[1] = v14;
        ++v11;
        v10 += 32;
      }
      while (v11 != v3[2]);
      vm_address_t v9 = *v6;
    }
    vm_address_t v15 = v3[4] >> 5;
    vm_address_t *v3 = v9;
    v3[1] = v15;
    if (v4)
    {
      vm_map_t v16 = mach_task_self_;
      return vm_deallocate(v16, v4, v5);
    }
  }
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve((uint64_t)a1, a2 + 1);
    }
    a1[2] = v5;
  }
  return *a1 + 32 * a2;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::verifySpace(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 8);
  unint64_t v3 = *(void *)(result + 16) + a2;
  if (v3 > v2)
  {
    unint64_t v4 = (vm_address_t *)result;
    vm_address_t v5 = *(void *)(result + 24);
    vm_size_t v6 = *(void *)(result + 32);
    unint64_t v7 = (vm_address_t *)(result + 24);
    unint64_t v8 = 2 * v2;
    if (v8 > v3) {
      unint64_t v3 = v8;
    }
    vm_size_t v9 = (vm_page_size + 32 * v3 - 1) & -(uint64_t)vm_page_size;
    *(void *)(result + 32) = v9;
    uint64_t result = vm_allocate(mach_task_self_, v7, v9, 1006632961);
    if (result) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    vm_address_t v10 = v4[3];
    if (v4[2])
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      do
      {
        vm_address_t v13 = (_OWORD *)(v10 + v11);
        long long v14 = (_OWORD *)(*v4 + v11);
        long long v15 = v14[1];
        *vm_address_t v13 = *v14;
        v13[1] = v15;
        ++v12;
        v11 += 32;
      }
      while (v12 != v4[2]);
      vm_address_t v10 = *v7;
    }
    vm_address_t v16 = v4[4] >> 5;
    *unint64_t v4 = v10;
    v4[1] = v16;
    if (v5)
    {
      vm_map_t v17 = mach_task_self_;
      return vm_deallocate(v17, v5, v6);
    }
  }
  return result;
}

void dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage,4294967295ull>::verifySpace(vm_address_t *a1, uint64_t a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a1[2] + a2;
  if (v3 > v2)
  {
    vm_address_t v5 = a1[3];
    vm_size_t v6 = a1[4];
    unint64_t v7 = a1 + 3;
    unint64_t v8 = 2 * v2;
    if (v8 > v3) {
      unint64_t v3 = v8;
    }
    vm_size_t v9 = (vm_page_size + 568 * v3 - 1) & -(uint64_t)vm_page_size;
    a1[4] = v9;
    if (vm_allocate(mach_task_self_, v7, v9, 1006632961)) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
    }
    vm_address_t v10 = a1[3];
    if (a1[2])
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      do
      {
        dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(v10 + v11, (long long *)(*a1 + v11));
        ++v12;
        v11 += 568;
      }
      while (v12 != a1[2]);
      vm_address_t v10 = *v7;
    }
    unint64_t v13 = a1[4] / 0x238;
    *a1 = v10;
    a1[1] = v13;
    if (v5)
    {
      vm_map_t v14 = mach_task_self_;
      vm_deallocate(v14, v5, v6);
    }
  }
}

__n128 dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = *((void *)a2 + 5);
  *(_OWORD *)(a1 + 48) = a2[3];
  uint64_t v4 = *((void *)a2 + 9);
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *(void *)(a1 + 72) = v4;
  *((void *)a2 + 9) = 0;
  *(long long *)((char *)a2 + 56) = 0u;
  *(long long *)((char *)a2 + 4dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 8dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 8dyld4::halt("obsolete dyld API called", 0) = *((void *)a2 + 10);
  *(_OWORD *)(a1 + 88) = *(long long *)((char *)a2 + 88);
  uint64_t v5 = *((void *)a2 + 14);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(void *)(a1 + 112) = v5;
  *((void *)a2 + 14) = 0;
  a2[5] = 0u;
  a2[6] = 0u;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 12dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(void *)(a1 + 12dyld4::halt("obsolete dyld API called", 0) = *((void *)a2 + 15);
  *(_OWORD *)(a1 + 128) = a2[8];
  uint64_t v6 = *((void *)a2 + 19);
  *(void *)(a1 + 144) = *((void *)a2 + 18);
  *(void *)(a1 + 152) = v6;
  *((void *)a2 + 19) = 0;
  *(long long *)((char *)a2 + 136) = 0u;
  *(long long *)((char *)a2 + 12dyld4::halt("obsolete dyld API called", 0) = 0u;
  long long v7 = a2[10];
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 16dyld4::halt("obsolete dyld API called", 0) = v7;
  *(void *)(a1 + 176) = *((void *)a2 + 22);
  *(_OWORD *)(a1 + 184) = *(long long *)((char *)a2 + 184);
  uint64_t v8 = *((void *)a2 + 26);
  *(void *)(a1 + 20dyld4::halt("obsolete dyld API called", 0) = *((void *)a2 + 25);
  *(void *)(a1 + 208) = v8;
  *((void *)a2 + 26) = 0;
  a2[11] = 0u;
  a2[12] = 0u;
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 216) = *((void *)a2 + 27);
  *(_OWORD *)(a1 + 2++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2[14];
  uint64_t v9 = *((void *)a2 + 31);
  *(void *)(a1 + 24dyld4::halt("obsolete dyld API called", 0) = *((void *)a2 + 30);
  *(void *)(a1 + 248) = v9;
  *((void *)a2 + 31) = 0;
  *(long long *)((char *)a2 + 232) = 0u;
  *(long long *)((char *)a2 + 216) = 0u;
  long long v10 = a2[16];
  *(void *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 256) = v10;
  uint64_t v11 = *((void *)a2 + 35);
  *(void *)(a1 + 272) = *((void *)a2 + 34);
  *(void *)(a1 + 28dyld4::halt("obsolete dyld API called", 0) = v11;
  *(_OWORD *)(a1 + 288) = a2[18];
  *(void *)(a1 + 304) = *((void *)a2 + 38);
  *((void *)a2 + 38) = 0;
  a2[17] = 0u;
  a2[18] = 0u;
  *(void *)(a1 + 344) = 0;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(void *)(a1 + 312) = *((void *)a2 + 39);
  *(_OWORD *)(a1 + 32dyld4::halt("obsolete dyld API called", 0) = a2[20];
  uint64_t v12 = *((void *)a2 + 43);
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  *(void *)(a1 + 344) = v12;
  *((void *)a2 + 43) = 0;
  *(long long *)((char *)a2 + 328) = 0u;
  *(long long *)((char *)a2 + 312) = 0u;
  *(void *)(a1 + 384) = 0;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  uint64_t v13 = *((void *)a2 + 45);
  *(void *)(a1 + 352) = *((void *)a2 + 44);
  *(void *)(a1 + 36dyld4::halt("obsolete dyld API called", 0) = v13;
  *(_OWORD *)(a1 + 368) = a2[23];
  *(void *)(a1 + 384) = *((void *)a2 + 48);
  *((void *)a2 + 48) = 0;
  a2[22] = 0u;
  a2[23] = 0u;
  long long v14 = *(long long *)((char *)a2 + 392);
  *(void *)(a1 + 44dyld4::halt("obsolete dyld API called", 0) = 0;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 4++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(a1 + 392) = v14;
  *(void *)(a1 + 408) = *((void *)a2 + 51);
  *(_OWORD *)(a1 + 416) = a2[26];
  uint64_t v15 = *((void *)a2 + 55);
  *(void *)(a1 + 432) = *((void *)a2 + 54);
  *(void *)(a1 + 44dyld4::halt("obsolete dyld API called", 0) = v15;
  *((void *)a2 + 55) = 0;
  *(long long *)((char *)a2 + 408) = 0u;
  *(long long *)((char *)a2 + 4++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(void *)(a1 + 48dyld4::halt("obsolete dyld API called", 0) = 0;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  uint64_t v16 = *((void *)a2 + 57);
  *(void *)(a1 + 448) = *((void *)a2 + 56);
  *(void *)(a1 + 456) = v16;
  *(_OWORD *)(a1 + 464) = a2[29];
  *(void *)(a1 + 48dyld4::halt("obsolete dyld API called", 0) = *((void *)a2 + 60);
  *((void *)a2 + 6dyld4::halt("obsolete dyld API called", 0) = 0;
  a2[28] = 0u;
  a2[29] = 0u;
  long long v17 = *(long long *)((char *)a2 + 552);
  long long v19 = *(long long *)((char *)a2 + 504);
  long long v18 = *(long long *)((char *)a2 + 520);
  *(_OWORD *)(a1 + 536) = *(long long *)((char *)a2 + 536);
  *(_OWORD *)(a1 + 552) = v17;
  *(_OWORD *)(a1 + 504) = v19;
  *(_OWORD *)(a1 + 52dyld4::halt("obsolete dyld API called", 0) = v18;
  __n128 result = *(__n128 *)((char *)a2 + 488);
  *(__n128 *)(a1 + 488) = result;
  return result;
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges(dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, const mach_header **a4, const char **a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v18 = 520552496;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v25 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v18, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v17, *(_DWORD *)(*((void *)this + 3) + 200));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v17))
  {
    uint64_t v15 = atomic_load((unint64_t *)(*((void *)this + 3) + 184));
    dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges((dyld4::RemoteNotificationResponder *)v17, a2, a3, a4, a5, v15, v13, v14);
  }
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v17);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v18);
}

uint64_t dyld4::ExternallyViewableState::removeImagesOld(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5 = (void *)result;
  atomic_store(0, (unint64_t *)(*(void *)(result + 24) + 8));
  uint64_t v6 = *(void *)(result + 24);
  *(void *)(v6 + 96) = 0;
  uint64_t v7 = *(void *)(a4 + 8);
  if (v7)
  {
    unint64_t v31 = a5;
    long long v10 = *(uint64_t **)a4;
    uint64_t v11 = *(void *)a4 + 8 * v7;
    do
    {
      uint64_t v12 = *v10;
      uint64_t v34 = *v10;
      uint64_t v13 = v5[4];
      uint64_t v14 = *(void *)(v13 + 16);
      if (v14)
      {
        uint64_t v15 = *(void *)(v13 + 8) + 24;
        uint64_t v16 = 24 * v14;
        long long v17 = (void *)v15;
        while (*(v17 - 3) != v12)
        {
          v17 += 3;
          v15 += 24;
          v16 -= 24;
          if (!v16) {
            goto LABEL_11;
          }
        }
        dyld3::Array<dyld4::Loader const*>::push_back(a2, v17 - 2);
        dyld3::Array<dyld4::Loader const*>::push_back(a3, &v34);
        long long v18 = *(_OWORD *)(v17 - 3);
        uint64_t v33 = *(v17 - 1);
        long long v32 = v18;
        uint64_t v19 = v5[4];
        uint64_t v20 = *(void *)(v19 + 16);
        uint64_t v21 = *(void *)(v19 + 8) + 24 * v20;
        if (v17 != (void *)v21)
        {
          memmove(v17 - 3, v17, v21 - v15);
          uint64_t v20 = *(void *)(v19 + 16);
        }
        *(void *)(v19 + 16) = v20 - 1;
      }
LABEL_11:
      uint64_t v22 = v5[5];
      uint64_t v23 = *(void *)(v22 + 16);
      if (v23)
      {
        long long v24 = *(void **)(v22 + 8);
        size_t v25 = 24 * v23 - 24;
        unint64_t v26 = v24;
        while (1)
        {
          uint64_t v27 = *v26;
          v26 += 3;
          if (v27 == v34) {
            break;
          }
          v25 -= 24;
          long long v24 = v26;
          if (v25 == -24) {
            goto LABEL_19;
          }
        }
        if (v25)
        {
          memmove(v24, v24 + 3, v25);
          uint64_t v23 = *(void *)(v22 + 16);
        }
        *(void *)(v22 + 16) = v23 - 1;
      }
LABEL_19:
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t, long long *))(v5[3] + 16))(1, 1, &v32);
      ++v10;
    }
    while (v10 != (uint64_t *)v11);
    uint64_t v6 = v5[3];
    a5 = v31;
  }
  uint64_t v28 = v5[4];
  *(_DWORD *)(v6 + 4) = *(void *)(v28 + 16);
  atomic_store(*(void *)(v28 + 8), (unint64_t *)(v6 + 8));
  atomic_store(a5, (unint64_t *)(v5[3] + 184));
  uint64_t v29 = v5[5];
  uint64_t v30 = v5[3];
  *(void *)(v30 + 88) = *(void *)(v29 + 16);
  *(void *)(v30 + 96) = *(void *)(v29 + 8);
  return result;
}

void dyld4::ExternallyViewableState::removeImages(uint64_t a1, lsl::Lock **a2, lsl::Lock **a3, uint64_t **a4)
{
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a3);
  long long v10 = a4[1];
  if (v10)
  {
    uint64_t v11 = *a4;
    uint64_t v12 = 8 * (void)v10;
    do
    {
      uint64_t v13 = *v11++;
      dyld4::Atlas::ProcessSnapshot::removeImageAtAddress(*(dyld4::Atlas::ProcessSnapshot **)a1, v13);
      v12 -= 8;
    }
    while (v12);
  }
  dyld4::ExternallyViewableState::commit((const os_unfair_lock *)a1, *(dyld4::Atlas::ProcessSnapshot **)a1, a2, v9);
  uint64_t v14 = dyld4::ExternallyViewableState::release((const os_unfair_lock *)a1, (lsl::Allocator *)a3);
  __chkstk_darwin((uint64_t)v14, v15, v16, v17, v18, v19, v20, v21, v39);
  v42[0] = (const char **)((char *)&v40[-1] - ((v22 + 23) & 0xFFFFFFFFFFFFFFF0));
  v42[1] = v23;
  uint64_t v43 = 0;
  __chkstk_darwin(v24, v25, v26, v27, v28, v29, v30, v31, v39);
  v40[0] = (const mach_header **)((char *)&v40[-1] - v33);
  v40[1] = v32;
  uint64_t v41 = 0;
  uint64_t v34 = mach_absolute_time();
  dyld4::ExternallyViewableState::removeImagesOld(a1, (uint64_t *)v42, (uint64_t *)v40, (uint64_t)a4, v34);
  if (*(_DWORD *)(*(void *)(a1 + 24) + 200) == 1229016646 && v41 != 0)
  {
    if (!v43) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1();
    }
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges((dyld4::ExternallyViewableState *)a1, 1, *((unsigned int *)a4 + 2), v40[0], v42[0], v35, v36, v37);
  }
  os_unfair_lock_unlock(v8);
}

uint64_t dyld4::ExternallyViewableState::disableCrashReportBacktrace(uint64_t this)
{
  *(void *)(*(void *)(this + 24) + 64) = 1;
  return this;
}

uint64_t dyld4::ExternallyViewableState::fork_child(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 24);
  *(void *)(v1 + 72) = 0;
  *(void *)(v1 + 8dyld4::halt("obsolete dyld API called", 0) = 0;
  return this;
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfMainCalled(dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v11 = 520552496;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v18 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, a2, a3, a4, a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10, *(_DWORD *)(*((void *)this + 3) + 200));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v10)) {
    dyld4::RemoteNotificationResponder::notifyMonitorOfMainCalled((dyld4::RemoteNotificationResponder *)v10);
  }
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfDyldBeforeInitializers(dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v11 = 520552496;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v18 = 0;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, a2, a3, a4, a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10, *(_DWORD *)(*((void *)this + 3) + 200));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v10)) {
    dyld4::RemoteNotificationResponder::notifyMonitorOfDyldBeforeInitializers((dyld4::RemoteNotificationResponder *)v10);
  }
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
}

__n128 dyld4::ExternallyViewableState::setRosettaSharedCacheInfo(dyld4::ExternallyViewableState *this, unint64_t a2, __n128 *a3)
{
  long long v3 = (__n128 *)*((void *)this + 3);
  v3[21].n128_u64[1] = a2;
  __n128 result = *a3;
  v3[22] = *a3;
  return result;
}

uint64_t dyld4::ExternallyViewableState::addRosettaImages(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (void *)result;
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5)
  {
    *(void *)(*(void *)(result + 24) + 328) = 0;
    lsl::Vector<dyld_aot_image_info>::insert<std::__wrap_iter<dyld_aot_image_info const*>>(*(void *)(result + 48), *(void *)(*(void *)(result + 48) + 8), *(unsigned char **)a2, (unsigned char *)(*(void *)a2 + 56 * v5));
    *(_DWORD *)(v4[3] + 3++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(v4[6] + 16);
    __n128 result = mach_absolute_time();
    uint64_t v6 = v4[3];
    *(void *)(v6 + 328) = *(void *)(v4[6] + 8);
    *(void *)(v6 + 336) = result;
  }
  if (*(void *)(a3 + 8))
  {
    atomic_store(0, (unint64_t *)(v4[3] + 8));
    lsl::Vector<dyld_image_info>::insert<dyld_image_info*>(v4[4], *(void *)(v4[4] + 8), *(unsigned char **)a3, (unsigned char *)(*(void *)a3 + 24 * *(void *)(a3 + 8)));
    *(_DWORD *)(v4[3] + 4) = *(void *)(v4[4] + 16);
    __n128 result = mach_absolute_time();
    atomic_store(result, (unint64_t *)(v4[3] + 184));
    atomic_store(*(void *)(v4[4] + 8), (unint64_t *)(v4[3] + 8));
  }
  return result;
}

uint64_t lsl::Vector<dyld_aot_image_info>::insert<std::__wrap_iter<dyld_aot_image_info const*>>(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  uint64_t v7 = 0x6DB6DB6DB6DB6DB7 * ((a2 - *(void *)(a1 + 8)) >> 3);
  size_t v8 = a4 - a3;
  uint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((a4 - a3) >> 3);
  lsl::Vector<dyld_aot_image_info>::reserve(a1, *(void *)(a1 + 16) + v9);
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10 != v7) {
    memmove((void *)(56 * (v10 + v9) - (56 * v10 - (*(void *)(a1 + 8) + 56 * v7))), (const void *)(*(void *)(a1 + 8) + 56 * v7), 56 * v10 - 56 * v7);
  }
  if (a4 != a3) {
    memmove((void *)(*(void *)(a1 + 8) + 56 * v7), a3, v8);
  }
  uint64_t v11 = *(void *)(a1 + 8);
  *(void *)(a1 + 16) += v9;
  return v11 + 56 * v7;
}

uint64_t dyld4::ExternallyViewableState::removeRosettaImages(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(v3 + 328) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    uint64_t v5 = *(void **)a2;
    uint64_t v6 = *(void *)a2 + 8 * v4;
    do
    {
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v8 = *(void *)(v7 + 16);
      if (v8)
      {
        uint64_t v9 = *(void **)(v7 + 8);
        size_t v10 = 56 * v8 - 56;
        while (v9[1] != *v5)
        {
          v10 -= 56;
          v9 += 7;
          if (v10 == -56) {
            goto LABEL_11;
          }
        }
        if (v10)
        {
          memmove(v9, v9 + 7, v10);
          uint64_t v8 = *(void *)(v7 + 16);
        }
        *(void *)(v7 + 16) = v8 - 1;
      }
LABEL_11:
      ++v5;
    }
    while (v5 != (void *)v6);
    uint64_t v3 = *(void *)(a1 + 24);
  }
  *(_DWORD *)(v3 + 3++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(a1 + 48) + 16);
  uint64_t result = mach_absolute_time();
  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(v12 + 328) = *(void *)(*(void *)(a1 + 48) + 8);
  *(void *)(v12 + 336) = result;
  return result;
}

uint64_t dyld4::ExternallyViewableState::switchDyldLoadAddress(uint64_t this, const dyld3::MachOFile *a2)
{
  *((void *)sProcessInfo + 4) = this;
  return this;
}

uint64_t lsl::Vector<dyld_aot_image_info>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }
    else
    {
      unint64_t v2 = 16;
    }
    return lsl::Vector<dyld_aot_image_info>::reserveExact(result, v2);
  }
  return result;
}

uint64_t lsl::Vector<dyld_aot_image_info>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 56 * a2);
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 56 * a2);
      uint64_t v4 = result;
      if (*(void *)(v3 + 16))
      {
        uint64_t v5 = 0;
        unint64_t v6 = 0;
        do
        {
          uint64_t v7 = result + v5;
          uint64_t v8 = (long long *)(*(void *)(v3 + 8) + v5);
          long long v9 = *v8;
          long long v10 = v8[1];
          long long v11 = v8[2];
          *(void *)(v7 + 48) = *((void *)v8 + 6);
          *(_OWORD *)(v7 + 16) = v10;
          *(_OWORD *)(v7 + 32) = v11;
          *(_OWORD *)uint64_t v7 = v9;
          ++v6;
          unint64_t v12 = *(void *)(v3 + 16);
          v5 += 56;
        }
        while (v12 > v6);
      }
      else
      {
        unint64_t v12 = 0;
      }
      long long v13 = *(void **)(v3 + 8);
      if (v13)
      {
        uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v13);
        unint64_t v12 = *(void *)(v3 + 16);
      }
      if (v12 >= a2) {
        unint64_t v14 = a2;
      }
      else {
        unint64_t v14 = v12;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v14;
    }
    *(void *)(v3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  va_start(va, a2);
  _simple_vdprintf(2, (char *)a2, (int *)va);
  return 0;
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  uint64_t v8 = (vm_address_t *)_simple_salloc();
  LODWORD(a4) = _simple_vsprintf((uint64_t)v8, (char *)__format, (int *)a4);
  long long v9 = (const char *)_simple_string((unsigned char **)v8);
  strlcpy(__str, v9, __size);
  _simple_sfree(v8);
  return (int)a4;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return write(2, __ptr, __nitems * __size);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  va_start(va, __format);
  return vsnprintf(__str, __size, __format, va);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  if (!__s) {
    return 22;
  }
  if (__n >= __smax) {
    size_t v4 = __smax;
  }
  else {
    size_t v4 = __n;
  }
  if (__n <= __smax) {
    errno_t v5 = 0;
  }
  else {
    errno_t v5 = 84;
  }
  _platform_memset(__s, __c, v4);
  return v5;
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  if (!__n) {
    return 0;
  }
  while (*__s != __c)
  {
    ++__s;
    if (!--__n) {
      return 0;
    }
  }
  return __s;
}

uint64_t mach_o::DebugNoteFileInfo::dump(const char **this)
{
  fprintf(__stdoutp, "scrDir:      %s\n", this[1]);
  fprintf(__stdoutp, "scrName:     %s\n", this[3]);
  fprintf(__stdoutp, "objPath:     %s\n", this[5]);
  fprintf(__stdoutp, "objModTime:  0x%08X\n", *(_DWORD *)this);
  fprintf(__stdoutp, "objSubType:  0X%02X\n", *((unsigned __int8 *)this + 4));
  if (this[8]) {
    unint64_t v2 = this[7];
  }
  else {
    unint64_t v2 = "N/A";
  }
  fprintf(__stdoutp, "libPath:     %s\n", v2);
  if (this[10]) {
    uint64_t v3 = this[9];
  }
  else {
    uint64_t v3 = "N/A";
  }
  return fprintf(__stdoutp, "origlibPath: %s\n", v3);
}

void *lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&,lsl::Vector<dyld4::Atlas::Mapper::Mapping> &>@<X0>(lsl::Lock **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = (lsl::Allocator::AllocationMetadata *)lsl::Allocator::aligned_alloc(a1, 8uLL, 0x30uLL);
  uint64_t v8 = lsl::Vector<dyld4::Atlas::Mapper::Mapping>::Vector(v7, a3, a2);
  void v8[4] = 0;
  void v8[5] = a2;

  return lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(a4, v7);
}

void dyld4::Atlas::Mapper::mapperForMachO(lsl::Lock **this@<X0>, lsl::Allocator *a2@<X1>, dyld4::FileRecord *a3@<X2>, const UUID *a4@<X3>, void *a5@<X8>)
{
  uint64_t Path = (dyld3 *)dyld4::FileRecord::getPath(a2);
  int v11 = dyld3::open(Path, 0, 0);
  if (v11 == -1) {
    goto LABEL_20;
  }
  int v12 = v11;
  if (fstat64(v11, &v37) == -1 || (long long v13 = mmap(0, v37.st_size, 1, 8194, v12, 0), v13 == (_DWORD *)-1))
  {
    int v11 = v12;
LABEL_20:
    close(v11);
    *a5 = 0;
    return;
  }
  long long v15 = v13;
  uint64_t v33 = 0;
  uint64_t v34 = &v33;
  uint64_t v35 = 0x2000000000;
  uint64_t v36 = 0;
  long long v16 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(v13, v14);
  v32[0] = 0;
  v32[1] = v32;
  void v32[2] = 0x2000000000;
  v32[3] = 0;
  uint64_t v18 = (void *)&loc_1A8E6F000;
  if (v16)
  {
    uint64_t v19 = v16;
    st_vm_size_t size = v37.st_size;
    Diagnostics::Diagnostics((Diagnostics *)&v41);
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 0x40000000;
    v31[2] = ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke;
    v31[3] = &unk_1EFF65BE0;
    v31[4] = &v33;
    v31[5] = v32;
    v31[6] = a3;
    v31[7] = v19;
    unint64_t v21 = st_size;
    uint64_t v18 = &loc_1A8E6F000;
    dyld3::FatFile::forEachSlice(v19, (vm_address_t *)&v41, v21, (uint64_t)v31);
    Diagnostics::clearError((vm_address_t **)&v41);
    mach_o::Error::~Error((vm_address_t **)&v41);
  }
  if (!v34[3])
  {
    uint64_t v22 = (dyld3::MachOFile *)dyld3::MachOFile::isMachO(v15, v17);
    if (v22)
    {
      uint64_t v23 = v22;
      long long v41 = 0uLL;
      dyld3::MachOFile::getUuid(v22, (unsigned __int8 *)&v41);
      uint64_t v24 = 0;
      long long v38 = v41;
      do
      {
        int v25 = *((unsigned __int8 *)a3 + v24);
        int v26 = *((unsigned __int8 *)&v38 + v24);
      }
      while (v25 == v26 && v24++ != 15);
      if (v25 == v26) {
        v34[3] = (uint64_t)v23;
      }
    }
  }
  uint64_t v28 = (_DWORD *)v34[3];
  if (v28)
  {
    *(void *)&long long v41 = 0;
    *((void *)&v41 + 1) = &v41;
    uint64_t v42 = 0x4802000000;
    uint64_t v43 = __Block_byref_object_copy__9;
    unint64_t v44 = __Block_byref_object_dispose__9;
    uint64_t v45 = this;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    uint64_t v46 = 0;
    *(void *)&long long v38 = 0;
    *((void *)&v38 + 1) = &v38;
    uint64_t v39 = 0x2000000000;
    uint64_t v40 = 0;
    v29[0] = _NSConcreteStackBlock;
    v29[1] = v18[411];
    void v29[2] = ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke_3;
    v29[3] = &unk_1EFF65C08;
    v29[4] = &v38;
    v29[5] = &v41;
    v29[6] = v32;
    v29[7] = a4;
    int v30 = v12;
    dyld3::MachOFile::forEachSegment(v28, (uint64_t)v29);
    munmap(v15, v37.st_size);
    lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&,lsl::Vector<dyld4::Atlas::Mapper::Mapping> &>(this, (uint64_t)this, *((void *)&v41 + 1) + 40, a5);
    _Block_object_dispose(&v38, 8);
    _Block_object_dispose(&v41, 8);
    if (v46) {
      lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize((const os_unfair_lock *)&v45, 0);
    }
  }
  else
  {
    munmap(v15, v37.st_size);
    close(v12);
    *a5 = 0;
  }
  _Block_object_dispose(v32, 8);
  _Block_object_dispose(&v33, 8);
}

BOOL ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke(void *a1, int a2, int a3, dyld3::MachOFile *this, uint64_t a5, unsigned char *a6)
{
  memset(v15, 0, sizeof(v15));
  BOOL result = dyld3::MachOFile::getUuid(this, v15);
  uint64_t v10 = 0;
  long long v14 = *(_OWORD *)v15;
  do
  {
    int v11 = *(unsigned __int8 *)(a1[6] + v10);
    int v12 = v15[v10 - 8];
  }
  while (v11 == v12 && v10++ != 15);
  if (v11 == v12)
  {
    *(void *)(*(void *)(a1[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = this;
    *(void *)(*(void *)(a1[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = (char *)this - a1[7];
    *a6 = 1;
  }
  return result;
}

uint64_t *__Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (uint64_t *)(a2 + 40);
  *(_OWORD *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = 0u;
  BOOL result = (uint64_t *)(a1 + 40);
  *((_OWORD *)result + 1) = 0u;
  if (result != v2)
  {
    uint64_t v4 = *result;
    *BOOL result = *v2;
    *unint64_t v2 = v4;
    uint64_t v6 = result[1];
    uint64_t v5 = result[2];
    uint64_t v7 = v2[2];
    result[1] = v2[1];
    result[2] = v7;
    unsigned int v2[2] = v5;
    uint64_t v8 = result[3];
    result[3] = v2[3];
    v2[3] = v8;
    v2[1] = v6;
  }
  return result;
}

const os_unfair_lock *__Block_byref_object_dispose__9(const os_unfair_lock *result)
{
  if (*(void *)&result[12]._os_unfair_lock_opaque) {
    return lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize(result + 10, 0);
  }
  return result;
}

uint64_t ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (!_platform_strncmp(*(const char **)(a2 + 40), "__TEXT", 0x10uLL)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a1 + 56) - *(void *)(a2 + 16);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) + *(void *)a2;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + *(void *)(a2 + 16);
  int v8 = *(_DWORD *)(a1 + 64);
  uint64_t result = lsl::Vector<dyld4::ObjCClassReplacement>::reserve(v4 + 40, *(void *)(v4 + 56) + 1);
  uint64_t v10 = *(void *)(v4 + 48) + 32 * *(void *)(v4 + 56);
  *(void *)uint64_t v10 = v5;
  *(void *)(v10 + 8) = v6;
  *(void *)(v10 + 16) = v7;
  *(_DWORD *)(v10 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
  ++*(void *)(v4 + 56);
  return result;
}

uint64_t dyld4::Atlas::Mapper::unmap(dyld4::Atlas::Mapper *this, unint64_t a2, uint64_t a3)
{
  return munmap((void *)(-(uint64_t)vm_page_size & a2), a2 + a3 - (-(uint64_t)vm_page_size & a2));
}

void *lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>@<X0>(lsl::Lock **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x30uLL);
  *uint64_t v5 = a2;
  *(_OWORD *)(v5 + 1) = 0u;
  *(_OWORD *)(v5 + 3) = 0u;
  void v5[5] = a2;

  return lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(a3, (lsl::Allocator::AllocationMetadata *)v5);
}

double dyld4::Atlas::ProcessSnapshot::removeImageAtAddress(dyld4::Atlas::ProcessSnapshot *this, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)((char *)this + 16);
  uint64_t v28 = (uint64_t *)((char *)this + 16);
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  memset(v33, 0, 27);
  uint64_t v4 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(&v28);
  uint64_t v5 = *v4;
  long long v12 = *(_OWORD *)(v4 + 1);
  long long v6 = *(_OWORD *)(v4 + 9);
  long long v7 = *(_OWORD *)(v4 + 7);
  long long v8 = *(_OWORD *)(v4 + 5);
  long long v13 = *(_OWORD *)(v4 + 3);
  long long v14 = v8;
  long long v15 = v7;
  long long v16 = v6;
  long long v9 = v4[11];
  __int16 v18 = *((_WORD *)v4 + 48);
  long long v17 = v9;
  LOBYTE(v9) = *((unsigned char *)v4 + 98);
  int v11 = v5;
  unsigned __int8 v19 = v9;
  *(_OWORD *)&v25[2] = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  memset(v33, 0, 27);
  uint64_t v28 = v3;
  if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&v11, (uint64_t)&v28))
  {
    while (*(void *)(*(void *)(*((void *)&v12 + v19 - 1) + 8 * *((unsigned __int8 *)&v17 + v19 - 1)) + 160) != a2)
    {
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(&v11);
      *(_OWORD *)&v25[2] = 0u;
      uint64_t v28 = v3;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      memset(v33, 0, 27);
      if (!lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>((uint64_t)&v11, (uint64_t)&v28))return result; {
    }
      }
    long long v22 = v13;
    long long v23 = v14;
    long long v24 = v15;
    *(_OWORD *)int v25 = v16;
    long long v21 = v12;
    *(void *)&v25[16] = v17;
    __int16 v26 = v18;
    uint64_t v20 = v11;
    unsigned __int8 v27 = v19;
    *(void *)&double result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase((uint64_t)v3, (uint64_t)&v20, (uint64_t)&v28).n128_u64[0];
  }
  return result;
}

void *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char [4],std::__identity,lsl::ConstCharStarCompare>(void *a1, void *a2, unsigned __int8 *a3)
{
  if (a2 != a1)
  {
    unint64_t v3 = a2 - a1;
    int v6 = *a3;
    uint64_t v4 = a3 + 1;
    int v5 = v6;
    a2 = a1;
    do
    {
      unint64_t v7 = v3 >> 1;
      long long v8 = &a2[v3 >> 1];
      int v9 = *(char *)*v8;
      if (v9 < (char)v5)
      {
LABEL_9:
        a2 = v8 + 1;
        unint64_t v7 = v3 + ~v7;
      }
      else
      {
        uint64_t v10 = (char *)(*v8 + 1);
        int v11 = v4;
        int v12 = v5;
        while (v12 && (char)v12 >= (char)v9)
        {
          if ((_BYTE)v9)
          {
            int v13 = *v10++;
            int v9 = v13;
            int v14 = (char)*v11++;
            int v12 = v14;
            if (v9 >= v14) {
              continue;
            }
          }
          goto LABEL_9;
        }
      }
      unint64_t v3 = v7;
    }
    while (v7);
  }
  return a2;
}

const os_unfair_lock *lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize(const os_unfair_lock *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque >= a2)
  {
    if (a2)
    {
      *(void *)&result[4]._uint32_t os_unfair_lock_opaque = a2;
      *(void *)&result[6]._uint32_t os_unfair_lock_opaque = a2;
      unint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
      unint64_t v3 = *(lsl::Lock ***)&result->_os_unfair_lock_opaque;
      return (const os_unfair_lock *)lsl::Allocator::realloc(v3, v2, 32 * a2);
    }
    else
    {
      int v5 = result + 2;
      uint64_t v4 = *(void **)&result[2]._os_unfair_lock_opaque;
      if (v4) {
        double result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v4);
      }
      *(void *)&v5->_uint32_t os_unfair_lock_opaque = 0;
      *(void *)&v5[2]._uint32_t os_unfair_lock_opaque = 0;
      *(void *)&v5[4]._uint32_t os_unfair_lock_opaque = 0;
    }
  }
  else
  {
    return (const os_unfair_lock *)lsl::Vector<dyld4::ObjCClassReplacement>::reserve((uint64_t)result, a2);
  }
  return result;
}

void *lsl::Vector<dyld4::Atlas::Mapper::Mapping>::Vector(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a3;
  a1[1] = 0;
  int v5 = (void **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  lsl::Vector<dyld4::ObjCClassReplacement>::reserve((uint64_t)a1, *(void *)(a2 + 16));
  a1[2] = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6) {
    memmove(*v5, *(const void **)(a2 + 8), 32 * v6);
  }
  return a1;
}

char *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(uint64_t a1, unsigned int a2, lsl::Lock **this)
{
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v3 = *(unsigned __int8 *)(a1 + 248);
  if (v3 >= 0xF) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v5 = a1 + 120;
  uint64_t v6 = a1 + 120 + 8 * a2;
  char v7 = *(unsigned char *)(*(void *)v6 + 248);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 15;
  }
  else {
    int v10 = 31;
  }
  if (v9 != v10) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v12 = a2;
  if (v8 >= 0) {
    uint64_t v13 = 7;
  }
  else {
    uint64_t v13 = 15;
  }
  int v14 = (void *)(a1 + 8 * a2);
  if (v3 != a2)
  {
    memmove((void *)(a1 + 8 * a2 + 8), (const void *)(a1 + 8 * a2), 8 * v3 - 8 * a2);
    a2 = *(unsigned __int8 *)(a1 + 248);
  }
  if ((a2 & 0x80) != 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  uint64_t v15 = v5 + 8 * a2;
  if (v15 != v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v15 - v6);
    LOBYTE(a2) = *(unsigned char *)(a1 + 248);
  }
  *(unsigned char *)(a1 + 248) = a2 + 1;
  void *v14 = *(void *)(*(void *)v6 + 8 * v13);
  double result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  long long v17 = result;
  char v18 = *(unsigned char *)(*(void *)v6 + 248);
  result[248] = v18 & 0x80;
  if (v18 < 0)
  {
    *((void *)result + 3dyld4::halt("obsolete dyld API called", 0) = 0;
    long long v19 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 1dyld4::halt("obsolete dyld API called", 0) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
  }
  else
  {
    *((void *)result + 14) = 0;
    long long v19 = 0uLL;
  }
  *((_OWORD *)result + 5) = v19;
  *((_OWORD *)result + 6) = v19;
  *((_OWORD *)result + 3) = v19;
  *((_OWORD *)result + 4) = v19;
  *((_OWORD *)result + 1) = v19;
  *((_OWORD *)result + 2) = v19;
  *(_OWORD *)double result = v19;
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  char v20 = v9 + ~(_BYTE)v13;
  *(void *)(v5 + 8 * v12 + 8) = result;
  if (v20) {
    double result = (char *)memmove(result, (const void *)(*(void *)v6 + 8 * v13 + 8), 8 * (v9 + ~(_BYTE)v13));
  }
  uint64_t v21 = *(void *)v6;
  int v22 = *(char *)(*(void *)v6 + 248);
  if ((v22 & 0x80000000) == 0)
  {
    if (v17[248] < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    double result = (char *)memmove(v17 + 120, (const void *)(v21 + 8 * v13 + 128), 8 * (v9 + ~(_BYTE)v13) + 8);
    uint64_t v21 = *(void *)v6;
    LOBYTE(v22) = *(unsigned char *)(*(void *)v6 + 248);
  }
  *(unsigned char *)(v21 + 248) = v22 + ~v20;
  char v23 = v17[248] + v20;
  v17[248] = v23;
  if (v23 >= 0) {
    int v24 = 15;
  }
  else {
    int v24 = 31;
  }
  if ((v23 & 0x7F) == v24
    || ((v25 = *(unsigned char *)(v21 + 248), int v26 = v25, v27 = v25 & 0x7F, v26 >= 0) ? (v28 = 15) : (v28 = 31), v27 == v28))
  {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  return result;
}

char *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::splitChild(uint64_t a1, unsigned int a2, lsl::Lock **this)
{
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 248);
  if (v3 >= 0xF) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v5 = a1 + 120;
  uint64_t v6 = a1 + 120 + 8 * a2;
  char v7 = *(unsigned char *)(*(void *)v6 + 248);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 15;
  }
  else {
    int v10 = 31;
  }
  if (v9 != v10) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v12 = *(unsigned __int8 *)(a1 + 248);
  uint64_t v13 = v12 + 1;
  uint64_t v14 = a2;
  if (v8 >= 0) {
    uint64_t v15 = 7;
  }
  else {
    uint64_t v15 = 15;
  }
  if (v3 != a2)
  {
    long long v16 = (uint64_t *)(a1 + 8 * v12);
    uint64_t v19 = *v16;
    long long v17 = v16 - 1;
    uint64_t v18 = v19;
    uint64_t v20 = 8 * a2 - 8 * v12;
    do
    {
      uint64_t v21 = *v17;
      *long long v17 = v18;
      v17[1] = v21;
      --v17;
      v20 += 8;
    }
    while (v20);
  }
  int v22 = (uint64_t *)(a1 + 8 * a2);
  uint64_t v23 = v5 + 8 * v13;
  if (v23 != v6 + 8)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v23 - (v6 + 8));
    LOBYTE(v3) = *(unsigned char *)(a1 + 248);
  }
  *(unsigned char *)(a1 + 248) = v3 + 1;
  int v24 = (uint64_t *)(*(void *)v6 + 8 * v15);
  if (v24 != v22)
  {
    uint64_t v25 = *v22;
    uint64_t *v22 = *v24;
    *int v24 = v25;
  }
  double result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  int v27 = result;
  int v28 = *(char *)(*(void *)v6 + 248);
  result[248] = *(unsigned char *)(*(void *)v6 + 248) & 0x80;
  if (v28 < 0)
  {
    *((void *)result + 3dyld4::halt("obsolete dyld API called", 0) = 0;
    long long v29 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 1dyld4::halt("obsolete dyld API called", 0) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
  }
  else
  {
    *((void *)result + 14) = 0;
    long long v29 = 0uLL;
  }
  *((_OWORD *)result + 5) = v29;
  *((_OWORD *)result + 6) = v29;
  *((_OWORD *)result + 3) = v29;
  *((_OWORD *)result + 4) = v29;
  *((_OWORD *)result + 1) = v29;
  *((_OWORD *)result + 2) = v29;
  *(_OWORD *)double result = v29;
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  char v30 = v9 + ~(_BYTE)v15;
  long long v31 = (uint64_t *)(v5 + 8 * v14);
  v31[1] = (uint64_t)result;
  uint64_t v32 = *v31;
  if (v30)
  {
    uint64_t v33 = (uint64_t *)(v32 + 8 * v15 + 8);
    uint64_t v34 = 8 * (v9 + ~(_BYTE)v15);
    uint64_t v35 = (uint64_t *)result;
    do
    {
      if (v33 != v35)
      {
        uint64_t v36 = *v35;
        uint64_t *v35 = *v33;
        uint64_t *v33 = v36;
      }
      ++v33;
      ++v35;
      v34 -= 8;
    }
    while (v34);
    uint64_t v32 = *(void *)v6;
  }
  int v37 = *(char *)(v32 + 248);
  if ((v37 & 0x80000000) == 0)
  {
    if (v28 < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    double result = (char *)memmove(result + 120, (const void *)(v32 + 8 * v15 + 128), 8 * (v9 + ~(_BYTE)v15) + 8);
    uint64_t v32 = *(void *)v6;
    LOBYTE(v37) = *(unsigned char *)(*(void *)v6 + 248);
  }
  *(unsigned char *)(v32 + 248) = v37 + ~v30;
  char v38 = v27[248] + v30;
  v27[248] = v38;
  if (v38 >= 0) {
    int v39 = 15;
  }
  else {
    int v39 = 31;
  }
  if ((v38 & 0x7F) == v39
    || ((char v40 = *(unsigned char *)(v32 + 248), v41 = v40, v42 = v40 & 0x7F, v41 >= 0) ? (v43 = 15) : (v43 = 31), v42 == v43))
  {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::NodeCore(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  *(unsigned char *)(result + 248) = 0;
  do
  {
    *(void *)(result + v2) = 0;
    v2 += 8;
  }
  while (v2 != 120);
  if (*(char *)(result + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  *(void *)(result + 12dyld4::halt("obsolete dyld API called", 0) = a2;
  return result;
}

__n128 lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(unsigned __int8 *)(a2 + 98);
  int v7 = *(unsigned __int8 *)(a1 + 32);
  unsigned int v8 = v6;
  if (v6 != v7)
  {
    int v9 = (const os_unfair_lock **)(*(void *)(a2 + 8 + 8 * (v6 - 1)) + 8 * *(unsigned __int8 *)(a2 + 88 + v6 - 1));
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t **)a2);
    int v10 = (const os_unfair_lock **)(*(void *)(a2 + 8 + 8 * (*(unsigned __int8 *)(a2 + 98) - 1))
                                  + 8 * *(unsigned __int8 *)(a2 + 88 + *(unsigned __int8 *)(a2 + 98) - 1));
    uint64_t v19 = 0;
    if (&v19 == v9)
    {
      int v11 = 0;
    }
    else
    {
      int v11 = *v9;
      uint64_t v19 = *v9;
      uint64_t *v9 = 0;
    }
    if (v10 != v9)
    {
      uint64_t v12 = *v9;
      uint64_t *v9 = *v10;
      *int v10 = v12;
    }
    if (&v19 != v10)
    {
      uint64_t v13 = *v10;
      *int v10 = v11;
      uint64_t v19 = v13;
    }
    lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v19);
    unsigned int v8 = *(unsigned __int8 *)(a2 + 98);
  }
  uint64_t v14 = v8 - 1;
  uint64_t v15 = *(void *)(a2 + 8 + 8 * v14);
  if ((*(char *)(v15 + 248) & 0x80000000) == 0) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase();
  }
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase(v15, *(unsigned __int8 *)(a2 + 88 + v14));
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure((unsigned __int8 *)a2);
  if (v6 != v7) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--((uint64_t **)a2);
  }
  --*(void *)(a1 + 24);
  long long v16 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 + 24);
  long long v17 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a3 + 4dyld4::halt("obsolete dyld API called", 0) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a3 + 56) = v17;
  __n128 result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a3 + 72) = result;
  *(void *)a3 = *(void *)a2;
  *(_OWORD *)(a3 + 8) = v16;
  *(void *)(a3 + 88) = *(void *)(a2 + 88);
  *(_WORD *)(a3 + 96) = *(_WORD *)(a2 + 96);
  *(unsigned char *)(a3 + 98) = *(unsigned char *)(a2 + 98);
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase(uint64_t result, unsigned int a2)
{
  int v2 = *(char *)(result + 248);
  if ((v2 & 0x80000000) == 0) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase();
  }
  uint64_t v3 = v2 & 0x7F;
  if (v3 <= a2) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase();
  }
  uint64_t v4 = (uint64_t *)(result + 8 * a2);
  uint64_t v5 = v4 + 1;
  if (v4 + 1 != (uint64_t *)(result + 8 * (v2 & 0x7F)))
  {
    uint64_t v6 = *v4;
    uint64_t v7 = 8 * v3 - 8 * a2 - 8;
    do
    {
      *(v5 - 1) = *v5;
      *v5++ = v6;
      v7 -= 8;
    }
    while (v7);
  }
  *(unsigned char *)(result + 248) = v2 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure(unsigned __int8 *__dst)
{
  unsigned int v1 = __dst[98];
  uint64_t v2 = *(void *)__dst;
  if (v1 != *(unsigned __int8 *)(*(void *)__dst + 32)) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure();
  }
  uint64_t v3 = __dst;
  if (v1 >= 2)
  {
    unsigned __int8 v4 = 0;
    uint64_t v5 = __dst + 8;
    uint64_t v6 = __dst + 88;
    do
    {
      uint64_t v7 = (v1 - v4 - 2);
      uint64_t v8 = v7 + 1;
      if (*(char *)(*(void *)&v5[8 * v7 + 8] + 248) >= 0) {
        unsigned int v9 = 7;
      }
      else {
        unsigned int v9 = 15;
      }
      if ((*(unsigned char *)(*(void *)&v5[8 * v7 + 8] + 248) & 0x7Fu) >= v9) {
        break;
      }
      uint64_t v10 = v6[v7];
      uint64_t v11 = *(void *)&v5[8 * v7];
      int v12 = *(char *)(v11 + 248);
      if (v10 == (v12 & 0x7F))
      {
        int v13 = 0;
        if (v6[v7]) {
          goto LABEL_10;
        }
      }
      else
      {
        if (v12 < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        if (*(char *)(*(void *)(v11 + 8 * v10 + 128) + 248) >= 0) {
          int v18 = -7;
        }
        else {
          int v18 = -15;
        }
        int v13 = v18 + (*(unsigned char *)(*(void *)(v11 + 8 * v10 + 128) + 248) & 0x7F);
        if (v6[v7])
        {
LABEL_10:
          if (v12 < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          int v14 = *(char *)(*(void *)(v11 + 8 * v10 + 112) + 248);
          char v15 = v14 & 0x7F;
          if (v14 >= 0) {
            char v16 = -7;
          }
          else {
            char v16 = -15;
          }
          char v17 = v16 + v15;
          goto LABEL_21;
        }
      }
      char v17 = 0;
LABEL_21:
      if (v13 < 1 || v13 < v17)
      {
        if (v17 < 1 || v13 >= v17)
        {
          if (v10 == (v12 & 0x7F))
          {
            if (v12 < 0) {
              lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
            }
            v6[v7] = v10 - 1;
            v6[v8] += (*(unsigned char *)(*(void *)(v11 + 8 * (v10 - 1) + 120) + 248) & 0x7F) + 1;
            uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge(*(void *)&v5[8 * v7], *(lsl::Lock ***)(v2 + 8), (v10 - 1));
            uint64_t v21 = *(void *)&v5[8 * v7];
            if (*(char *)(v21 + 248) < 0) {
              lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
            }
            *(void *)&v5[8 * v8] = *(void *)(v21 + 8 * v6[v7] + 120);
          }
          else
          {
            uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge(v11, *(lsl::Lock ***)(v2 + 8), v10);
          }
        }
        else
        {
          if (v12 < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          char v19 = *(unsigned char *)(*(void *)(v11 + 8 * v10 + 120) + 248);
          uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromLeft((void *)v11, v6[v7]);
          uint64_t v20 = *(void *)&v5[8 * v7];
          if (*(char *)(v20 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          v6[v8] += (*(unsigned char *)(*(void *)(v20 + 8 * v6[v7] + 120) + 248) & 0x7F) - (v19 & 0x7F);
        }
      }
      else
      {
        uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromRight((char *)v11, v6[v7]);
      }
      ++v4;
      uint64_t v2 = *(void *)v3;
      unsigned int v1 = *(unsigned __int8 *)(*(void *)v3 + 32);
    }
    while ((int)(v1 - 1) > v4);
  }
  int v22 = v3 + 8;
  if ((*(unsigned char *)(*((void *)v3 + 1) + 248) & 0x7F) != 0)
  {
    unsigned __int8 v23 = *(unsigned char *)(v2 + 32);
  }
  else
  {
    int v24 = (char *)(v3 + 88);
    if (v3[88]) {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure();
    }
    uint64_t v25 = v3[98];
    if (&v24[v25] != (char *)(v3 + 89))
    {
      memmove(v24, v3 + 89, v25 - 1);
      uint64_t v25 = v3[98];
    }
    int v26 = &v22[v25];
    if (v26 != v3 + 16)
    {
      memmove(v3 + 8, v3 + 16, v26 - (v3 + 16));
      LOBYTE(v25) = v3[98];
    }
    v3[98] = v25 - 1;
    uint64_t __dst = (unsigned __int8 *)lsl::Allocator::free(*(lsl::Lock ***)(v2 + 8), *(void **)v2);
    int v27 = *(void **)v3;
    unsigned __int8 v23 = *(unsigned char *)(*(void *)v3 + 32) - 1;
    *(unsigned char *)(*(void *)v3 + 32) = v23;
    if (v3[98]) {
      void *v27 = *v22;
    }
    else {
      void *v27 = 0;
    }
  }
  if (v23)
  {
    uint64_t v28 = 0;
    do
    {
      if ((*(unsigned char *)(v22[(v23 + ~(_BYTE)v28)] + 248) & 0x7F) != v3[(v23 + ~(_BYTE)v28)
                                                                                      + 88])
        break;
      --v3[98];
      ++v28;
    }
    while (v23 != v28);
  }
  return __dst;
}

char *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromRight(char *result, int a2)
{
  if (result[248] < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  uint64_t v2 = &result[8 * a2];
  uint64_t v4 = *((void *)v2 + 15);
  uint64_t v3 = *((void *)v2 + 16);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 248);
  int v6 = *(char *)(v3 + 248);
  uint64_t v7 = v6 & 0x7F;
  unsigned int v8 = v7 + (v5 & 0x7F);
  int v9 = v7 - (v8 >> 1);
  uint64_t v10 = (char *)(v4 + 8 * (v5 & 0x7F));
  if (v2 != v10)
  {
    uint64_t v11 = *(void *)v10;
    *(void *)uint64_t v10 = *(void *)v2;
    *(void *)uint64_t v2 = v11;
  }
  unsigned int v12 = v8 >> 1;
  uint64_t v13 = ((v6 & 0x7F) - (v8 >> 1));
  int v14 = (char *)(v3 + 8 * v9 - 8);
  if (v14 != v2)
  {
    uint64_t v15 = *(void *)v2;
    *(void *)uint64_t v2 = *(void *)v14;
    *(void *)int v14 = v15;
  }
  size_t v16 = 8 * v13;
  if (v7 != v12)
  {
    char v17 = (uint64_t *)(v4 + 8 * (v5 & 0x7F) + 8);
    uint64_t v18 = 8 * v13;
    char v19 = (uint64_t *)v3;
    do
    {
      if (v19 != v17)
      {
        uint64_t v20 = *v17;
        *char v17 = *v19;
        *char v19 = v20;
      }
      ++v19;
      ++v17;
      v18 -= 8;
    }
    while (v18);
  }
  if (v8 >= 2)
  {
    uint64_t v21 = 8 * v7;
    int v22 = (uint64_t *)v3;
    do
    {
      if (v16)
      {
        uint64_t v23 = *v22;
        uint64_t *v22 = v22[v13];
        v22[v13] = v23;
      }
      ++v22;
      v21 -= 8;
    }
    while (v16 != v21);
  }
  if ((v5 & 0x80) == 0)
  {
    if (v6 < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    if (v7 != v12)
    {
      __n128 result = (char *)memmove((void *)(v4 + 8 * v5 + 128), (const void *)(v3 + 120), v16);
      int v6 = *(char *)(v3 + 248);
      if (v6 < 0) {
        lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
      }
    }
    uint64_t v24 = v6 + 1;
    if (v24 != v13) {
      __n128 result = (char *)memmove((void *)(v3 + 120), (const void *)(v3 + 120 + 8 * v13), 8 * v24 - 8 * v13);
    }
  }
  *(unsigned char *)(v4 + 248) += v9;
  *(unsigned char *)(v3 + 248) -= v9;
  return result;
}

void *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromLeft(void *result, unsigned int a2)
{
  if ((char)result[31] < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  uint64_t v2 = a2 - 1;
  uint64_t v3 = result[v2 + 15];
  uint64_t v4 = result[a2 + 15];
  LOBYTE(v5) = *(unsigned char *)(v3 + 248);
  uint64_t v6 = v5 & 0x7F;
  uint64_t v7 = *(unsigned __int8 *)(v4 + 248);
  unsigned int v8 = (v7 & 0x7F) + (v5 & 0x7F);
  uint64_t v9 = ((v5 & 0x7F) - (v8 >> 1));
  if ((v7 & 0x7F) != 0)
  {
    uint64_t v10 = 8 * (v7 & 0x7F);
    uint64_t v11 = v4 + 8 * v9;
    do
    {
      if (v4 != v11)
      {
        uint64_t v12 = *(void *)(v11 + v10 - 8);
        *(void *)(v11 + v10 - 8) = *(void *)(v4 + v10 - 8);
        *(void *)(v4 + v10 - 8) = v12;
      }
      v10 -= 8;
    }
    while (v10);
  }
  uint64_t v13 = v3 + 8 * v6;
  if (v13 - 8 * v9 + 8 != v13)
  {
    uint64_t v14 = 8 - 8 * v9;
    uint64_t v15 = (uint64_t *)v4;
    do
    {
      size_t v16 = (uint64_t *)(v13 + v14);
      if ((uint64_t *)(v13 + v14) != v15)
      {
        uint64_t v17 = *v15;
        *uint64_t v15 = *v16;
        *size_t v16 = v17;
      }
      ++v15;
      v14 += 8;
    }
    while (v14);
  }
  uint64_t v18 = &result[v2];
  char v19 = (uint64_t *)(v4 + 8 * v9 - 8);
  if (v18 != v19)
  {
    uint64_t v20 = *v19;
    *char v19 = *v18;
    uint64_t *v18 = v20;
  }
  uint64_t v21 = (uint64_t *)(v3 + 8 * ((int)v6 - (int)v9));
  if (v21 != v18)
  {
    uint64_t v22 = *v18;
    uint64_t *v18 = *v21;
    *uint64_t v21 = v22;
  }
  if (((char)v5 & 0x80000000) == 0)
  {
    if ((v7 & 0x80) != 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    __n128 result = memmove((void *)(v4 + 120 + 8 * v7 + 8 + 8 * v9 + 8 * ~v7), (const void *)(v4 + 120), 8 * v7 + 8);
    int v5 = *(char *)(v3 + 248);
    if (v5 < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    if (*(char *)(v4 + 248) < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    if (v6 != v8 >> 1)
    {
      __n128 result = memmove((void *)(v4 + 120), (const void *)(v3 + 8 * *(unsigned __int8 *)(v3 + 248) + 128 - 8 * v9), 8 * v9);
      LOBYTE(v5) = *(unsigned char *)(v3 + 248);
    }
  }
  *(unsigned char *)(v3 + 248) = v5 - v9;
  *(unsigned char *)(v4 + 248) += v9;
  return result;
}

const os_unfair_lock *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge(uint64_t a1, lsl::Lock **this, unsigned int a3)
{
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge();
  }
  uint64_t v3 = *(unsigned __int8 *)(a1 + 248);
  if (*(unsigned __int8 *)(a1 + 248) <= a3) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge();
  }
  uint64_t v6 = (void *)(a1 + 120 + 8 * a3);
  uint64_t v8 = *v6;
  uint64_t v7 = v6[1];
  uint64_t v9 = (uint64_t *)(a1 + 8 * a3);
  unsigned int v10 = *(unsigned __int8 *)(*v6 + 248);
  uint64_t v11 = v10 & 0x7F;
  uint64_t v12 = (uint64_t *)(*v6 + 8 * v11);
  if (v9 != v12)
  {
    uint64_t v13 = *v12;
    *uint64_t v12 = *v9;
    uint64_t *v9 = v13;
  }
  uint64_t v14 = v3 + 1;
  uint64_t v15 = v9 + 1;
  if (v9 + 1 != (uint64_t *)(a1 + 8 * v3))
  {
    uint64_t v16 = *v9;
    uint64_t v17 = 8 * v3 - 8 * a3 - 8;
    do
    {
      *(v15 - 1) = *v15;
      *v15++ = v16;
      v17 -= 8;
    }
    while (v17);
  }
  uint64_t v18 = a1 + 120 + 8 * v14;
  if ((void *)v18 != v6 + 2)
  {
    memmove(v6 + 1, v6 + 2, v18 - (void)(v6 + 2));
    unsigned int v10 = *(unsigned __int8 *)(v8 + 248);
    uint64_t v11 = v10 & 0x7F;
  }
  uint64_t v19 = *(unsigned __int8 *)(v7 + 248);
  uint64_t v20 = v19 & 0x7F;
  if ((v19 & 0x7F) != 0)
  {
    uint64_t v21 = (uint64_t *)(v8 + 8 * v11 + 8);
    uint64_t v22 = 8 * v20;
    uint64_t v23 = (uint64_t *)v7;
    do
    {
      if (v23 != v21)
      {
        uint64_t v24 = *v21;
        *uint64_t v21 = *v23;
        *uint64_t v23 = v24;
      }
      ++v23;
      ++v21;
      v22 -= 8;
    }
    while (v22);
  }
  if ((v10 & 0x80) == 0)
  {
    if ((v19 & 0x80) != 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    memmove((void *)(v8 + 8 * v10 + 128), (const void *)(v7 + 120), 8 * v19 + 8);
    LOBYTE(v1dyld4::halt("obsolete dyld API called", 0) = *(unsigned char *)(v8 + 248);
    LOBYTE(v2dyld4::halt("obsolete dyld API called", 0) = *(unsigned char *)(v7 + 248) & 0x7F;
  }
  *(unsigned char *)(v8 + 248) = v20 + v10 + 1;
  --*(unsigned char *)(a1 + 248);

  return lsl::Allocator::free(this, (void *)v7);
}

uint64_t **lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator--(uint64_t **result)
{
  uint64_t v1 = *((unsigned __int8 *)result + 116);
  uint64_t v2 = *result;
  if (*((unsigned char *)result + 116))
  {
    if (v1 == *((unsigned __int8 *)v2 + 32))
    {
      uint64_t v3 = result + 13;
      uint64_t v4 = v1 - 1;
      int v5 = (char *)result + v1 + 103;
      char v6 = *v5;
      if (!*((unsigned char *)result + (v1 - 1) + 104))
      {
        if (!*v5)
        {
          do
          {
            LODWORD(v1) = v1 - 1;
            *((unsigned char *)result + 116) = v1;
            uint64_t v4 = v1 - 1;
            char v6 = *((unsigned char *)v3 + v4);
          }
          while (!v6);
        }
        int v5 = (char *)v3 + v4;
      }
    }
    else
    {
      uint64_t v14 = result + 1;
      uint64_t v15 = result + 13;
      do
      {
        uint64_t v16 = v14[v1 - 1];
        if ((char)v16[31] < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v17 = v16[*((unsigned __int8 *)v15 + v1 - 1) + 20];
        v14[v1] = (uint64_t *)v17;
        *((unsigned char *)v15 + v1) = *(unsigned char *)(v17 + 248) & 0x7F;
        LOBYTE(v1) = *((unsigned char *)result + 116) + 1;
        *((unsigned char *)result + 116) = v1;
      }
      while (*((unsigned __int8 *)v2 + 32) != v1);
      uint64_t v18 = (uint64_t)v15 + v1;
      char v19 = *(unsigned char *)(v18 - 1);
      int v5 = (char *)(v18 - 1);
      char v6 = v19;
    }
  }
  else
  {
    uint64_t v7 = *v2;
    *((unsigned char *)result + 116) = 0;
    if (*((unsigned char *)v2 + 32))
    {
      unsigned __int8 v8 = 0;
      uint64_t v9 = result + 1;
      do
      {
        v9[v8] = (uint64_t *)v7;
        *((unsigned char *)result + v8 + 104) = *(unsigned char *)(v7 + 248) & 0x7F;
        uint64_t v10 = *((unsigned __int8 *)result + 116);
        unsigned int v11 = *((unsigned __int8 *)v2 + 32);
        if (v10 + 1 != v11)
        {
          uint64_t v12 = v9[v10];
          if ((char)v12[31] < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          uint64_t v7 = v12[*((unsigned __int8 *)v12 + 248) + 20];
        }
        unsigned __int8 v8 = v10 + 1;
        *((unsigned char *)result + 116) = v8;
      }
      while (v11 > v8);
      uint64_t v13 = v8 - 1;
    }
    else
    {
      uint64_t v13 = -1;
    }
    int v5 = (char *)result + v13 + 104;
    char v6 = *v5;
  }
  *int v5 = v6 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion(unsigned __int8 *result)
{
  uint64_t v1 = result[116];
  if (v1 != *(unsigned __int8 *)(*(void *)result + 32)) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion();
  }
  uint64_t v2 = result;
  uint64_t v3 = result + 8;
  if (*(char *)(*(void *)&result[8 * v1] + 248) >= 0) {
    int v4 = 10;
  }
  else {
    int v4 = 15;
  }
  if ((*(unsigned char *)(*(void *)&result[8 * v1] + 248) & 0x7F) == v4)
  {
    if (!result[116]) {
      goto LABEL_15;
    }
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    do
    {
      if (*(char *)(v3[v5] + 248) >= 0) {
        int v7 = 10;
      }
      else {
        int v7 = 15;
      }
      if ((*(unsigned char *)(v3[v5] + 248) & 0x7F) != v7) {
        unsigned int v6 = v5;
      }
      ++v5;
    }
    while (v1 != v5);
    if (!v6)
    {
LABEL_15:
      if (*(char *)(*v3 + 248) >= 0) {
        int v8 = 10;
      }
      else {
        int v8 = 15;
      }
      if ((*(unsigned char *)(*v3 + 248) & 0x7F) == v8)
      {
        __n128 result = (unsigned __int8 *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(*(void *)result + 8), 0x100uLL, 0x100uLL);
        uint64_t v9 = **(void **)v2;
        result[248] = 0;
        *(_OWORD *)__n128 result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((void *)result + 2dyld4::halt("obsolete dyld API called", 0) = v9;
        **(void **)uint64_t v2 = result;
        if (v2[116] && (__n128 result = (unsigned __int8 *)memmove(v2 + 105, v2 + 104, v2[116]), v2[116]))
        {
          __n128 result = (unsigned __int8 *)memmove(v3 + 1, v3, 8 * v2[116]);
          LOBYTE(v1) = v2[116] + 1;
        }
        else
        {
          LOBYTE(v1) = 1;
        }
        unsigned int v6 = 0;
        v2[104] = 0;
        uint64_t v10 = *(uint64_t **)v2;
        *((void *)v2 + 1) = **(void **)v2;
        ++*((unsigned char *)v10 + 32);
        v2[116] = v1;
      }
      else
      {
        unsigned int v6 = 0;
      }
    }
    if (v6 + 1 < v1)
    {
      unsigned int v11 = v2 + 104;
      uint64_t v12 = v6;
      do
      {
        int v13 = v12;
        __n128 result = (unsigned __int8 *)lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::splitChild(v3[v12], v11[v12], *(lsl::Lock ***)(*(void *)v2 + 8));
        uint64_t v14 = v3[v12];
        if (*(char *)(v14 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
        }
        uint64_t v15 = v11[v12];
        uint64_t v16 = *(void *)(v14 + 8 * v15 + 160);
        unsigned int v17 = v2[v12 + 105];
        if (v17 > (*(unsigned char *)(v16 + 248) & 0x7Fu))
        {
          unsigned __int8 v18 = v15 + 1;
          v11[v12] = v18;
          v2[v12 + 105] = v17 + (~*(unsigned char *)(v16 + 248) | 0x80);
          uint64_t v19 = v3[v12];
          if (*(char *)(v19 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
          }
          *(void *)&v2[8 * v12 + 16] = *(void *)(v19 + 8 * v18 + 160);
        }
        ++v12;
      }
      while (v13 + 2 < v2[116]);
    }
  }
  return result;
}

char *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::splitChild(uint64_t a1, unsigned int a2, lsl::Lock **this)
{
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v3 = *(unsigned __int8 *)(a1 + 248);
  if (v3 >= 0xA) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v5 = a1 + 160;
  uint64_t v6 = a1 + 160 + 8 * a2;
  char v7 = *(unsigned char *)(*(void *)v6 + 248);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 10;
  }
  else {
    int v10 = 15;
  }
  if (v9 != v10) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v12 = a2;
  if (v8 >= 0) {
    uint64_t v13 = 5;
  }
  else {
    uint64_t v13 = 7;
  }
  uint64_t v14 = (_OWORD *)(a1 + 16 * a2);
  if (v3 != a2)
  {
    memmove((void *)(a1 + 16 * a2 + 16), (const void *)(a1 + 16 * a2), 16 * v3 - 16 * a2);
    a2 = *(unsigned __int8 *)(a1 + 248);
  }
  if ((a2 & 0x80) != 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  uint64_t v15 = v5 + 8 * a2;
  if (v15 != v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v15 - v6);
    LOBYTE(a2) = *(unsigned char *)(a1 + 248);
  }
  *(unsigned char *)(a1 + 248) = a2 + 1;
  _OWORD *v14 = *(_OWORD *)(*(void *)v6 + 16 * v13);
  __n128 result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  unsigned int v17 = result;
  char v18 = *(unsigned char *)(*(void *)v6 + 248);
  result[248] = v18 & 0x80;
  if (v18 < 0)
  {
    *((_OWORD *)result + 13) = 0uLL;
    *((_OWORD *)result + 14) = 0uLL;
    *((_OWORD *)result + 11) = 0uLL;
    *((_OWORD *)result + 12) = 0uLL;
    *((_OWORD *)result + 1dyld4::halt("obsolete dyld API called", 0) = 0uLL;
  }
  *((_OWORD *)result + 8) = 0uLL;
  *((_OWORD *)result + 9) = 0uLL;
  *((_OWORD *)result + 6) = 0uLL;
  *((_OWORD *)result + 7) = 0uLL;
  *((_OWORD *)result + 4) = 0uLL;
  *((_OWORD *)result + 5) = 0uLL;
  *((_OWORD *)result + 2) = 0uLL;
  *((_OWORD *)result + 3) = 0uLL;
  *(_OWORD *)__n128 result = 0uLL;
  *((_OWORD *)result + 1) = 0uLL;
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
  }
  unsigned __int8 v19 = v9 + ~(_BYTE)v13;
  *(void *)(v5 + 8 * v12 + 8) = result;
  if (v19) {
    __n128 result = (char *)memmove(result, (const void *)(*(void *)v6 + 16 * v13 + 16), 16 * v19);
  }
  uint64_t v20 = *(void *)v6;
  int v21 = *(char *)(*(void *)v6 + 248);
  if ((v21 & 0x80000000) == 0)
  {
    if (v17[248] < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++();
    }
    __n128 result = (char *)memmove(v17 + 160, (const void *)(v20 + 8 * v13 + 168), 8 * v19 + 8);
    uint64_t v20 = *(void *)v6;
    LOBYTE(v21) = *(unsigned char *)(*(void *)v6 + 248);
  }
  *(unsigned char *)(v20 + 248) = v21 + ~v19;
  char v22 = v17[248] + v19;
  v17[248] = v22;
  if (v22 >= 0) {
    int v23 = 10;
  }
  else {
    int v23 = 15;
  }
  if ((v22 & 0x7F) == v23
    || ((char v24 = *(unsigned char *)(v20 + 248), v25 = v24, v26 = v24 & 0x7F, v25 >= 0) ? (v27 = 10) : (v27 = 15), v26 == v27))
  {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  return result;
}

unsigned int *DyldSharedCache::forEachTPRORegion(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = result[4];
  if (v2 >= 0x205)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[129];
    if (v4)
    {
      uint64_t v6 = *(void *)((char *)result + v2);
      char v7 = (uint64_t *)((char *)result + result[128]);
      int v8 = &v7[2 * v4];
      do
      {
        char v11 = 0;
        uint64_t v9 = *v7;
        v7 += 2;
        __n128 result = (unsigned int *)(*(uint64_t (**)(uint64_t, char *))(a2 + 16))(a2, (char *)v3 + v9 - v6);
        if (v11) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = v7 >= v8;
        }
      }
      while (!v10);
    }
  }
  return result;
}

uint64_t DyldSharedCache::numSubCaches(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x18Du) {
    return *((unsigned int *)this + 99);
  }
  else {
    return 0;
  }
}

unsigned int *DyldSharedCache::forEachDylib(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)((char *)result + result[4]);
  if (!v2[2])
  {
    uint64_t v3 = result;
    if (result[113])
    {
      unint64_t v5 = 0;
      uint64_t v6 = *v2;
      uint64_t v7 = (uint64_t)result + result[112] + 16;
      do
      {
        uint64_t v8 = *(void *)(v7 - 8);
        uint64_t v9 = (char *)v3 + *(unsigned int *)(v7 + 8);
        BOOL v10 = (char *)v3 + *(void *)(v7 - 16) - v6;
        char v11 = 0;
        __n128 result = (unsigned int *)(*(uint64_t (**)(uint64_t, char *, char *, unint64_t, void, uint64_t, char *))(a2 + 16))(a2, v10, v9, v5, *(void *)v7, v8, &v11);
        if (v11) {
          break;
        }
        v7 += 32;
        ++v5;
      }
      while (v5 < v3[113]);
    }
  }
  return result;
}

uint64_t DyldSharedCache::getImageFromPath(DyldSharedCache *this, const char *a2)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  uint64_t v4 = 24;
  if (v3 > 0x1C3) {
    uint64_t v4 = 448;
  }
  uint64_t v5 = *(unsigned int *)((char *)this + v4);
  unsigned int v7 = 0;
  if (DyldSharedCache::hasImagePath(this, a2, &v7)) {
    return (uint64_t)this + *(void *)((char *)this + 32 * v7 + v5) - *(void *)((char *)this + v3);
  }
  else {
    return 0;
  }
}

uint64_t DyldSharedCache::getIndexedImageEntry(DyldSharedCache *this, int a2)
{
  unint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 24;
  if (v2 > 0x1C3) {
    uint64_t v3 = 448;
  }
  return (uint64_t)this
       + *(void *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v3))
       - *(void *)((char *)this + v2);
}

uint64_t DyldSharedCache::addressInText(DyldSharedCache *this, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = *((void *)this + 18);
  if (v3 < 1) {
    return 0;
  }
  unsigned int v4 = 0;
  unint64_t v5 = *(void *)((char *)this + *((unsigned int *)this + 4)) + a2;
  uint64_t v6 = (char *)this + *((void *)this + 17);
  unsigned int v7 = &v6[32 * v3];
  while (1)
  {
    unint64_t v8 = *((void *)v6 + 2);
    if (v8 <= v5 && v5 < v8 + *((unsigned int *)v6 + 6)) {
      break;
    }
    v6 += 32;
    ++v4;
    if (v6 >= v7) {
      return 0;
    }
  }
  *a3 = v4;
  return 1;
}

uint64_t ___ZNK15DyldSharedCache10mappedSizeEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(result + 32) + 8);
  if (!*(void *)(v4 + 24)) {
    *(void *)(v4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  }
  uint64_t v5 = *(void *)(*(void *)(result + 40) + 8);
  if ((unint64_t)(a4 + a3) > *(void *)(v5 + 24)) {
    *(void *)(v5 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a4 + a3;
  }
  return result;
}

BOOL DyldSharedCache::findMachHeaderImageIndex(DyldSharedCache *this, const mach_header *a2, unsigned int *a3)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  if (v3 <= 0x1C3) {
    uint64_t v4 = 24;
  }
  else {
    uint64_t v4 = 448;
  }
  uint64_t v5 = 28;
  if (v3 > 0x1C3) {
    uint64_t v5 = 452;
  }
  unint64_t v6 = *(unsigned int *)((char *)this + v5);
  if (!v6) {
    return 0;
  }
  int64_t v7 = (char *)a2 - (char *)this + *(void *)((char *)this + v3);
  uint64_t v8 = *(unsigned int *)((char *)this + v4);
  if (*(void *)((char *)this + v8) != v7)
  {
    unint64_t v9 = 0;
    char v11 = (uint64_t *)((char *)this + v8 + 32);
    while (v6 - 1 != v9)
    {
      uint64_t v12 = *v11;
      v11 += 4;
      ++v9;
      if (v12 == v7)
      {
        BOOL result = v9 < v6;
        goto LABEL_13;
      }
    }
    return 0;
  }
  LODWORD(v9) = 0;
  BOOL result = 1;
LABEL_13:
  *a3 = v9;
  return result;
}

uint64_t DyldSharedCache::patchInfoVersion(DyldSharedCache *this)
{
  uint64_t v1 = *((unsigned int *)this + 4);
  if (v1 >= 0x181) {
    return *(unsigned int *)((char *)this + *((void *)this + 19) - *(void *)((char *)this + v1));
  }
  else {
    return 1;
  }
}

dyld3::MachOFile *DyldSharedCache::forEachPatchableExport(dyld3::MachOFile *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *((void *)result + 19);
  if (v3)
  {
    uint64_t v5 = result;
    uint64_t v6 = *((unsigned int *)result + 4);
    if (v6 < 0x181 || *(_DWORD *)((char *)result + v3 - *(void *)((char *)result + v6)) == 1)
    {
      uint64_t v7 = 24;
      if (v6 > 0x1C3) {
        uint64_t v7 = 448;
      }
      uint64_t v8 = (char *)result + *(void *)((char *)result + 32 * a2 + *(unsigned int *)((char *)result + v7));
      unint64_t v9 = *(char **)((char *)result + v6);
      BOOL result = (dyld3::MachOFile *)(v8 - v9);
      if (v8 != v9)
      {
        unint64_t v10 = a2;
        BOOL result = (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
        uint64_t v11 = *(void *)((char *)v5 + *((unsigned int *)v5 + 4));
        uint64_t v12 = (char *)v5 - v11;
        uint64_t v13 = (void *)((char *)v5 + *((void *)v5 + 19) - v11);
        if (v13[1] >= v10)
        {
          uint64_t v14 = &v12[8 * v10 + *v13];
          unsigned int v15 = *((_DWORD *)v14 + 1);
          if (v13[3] >= (unint64_t)(v15 + *(_DWORD *)v14))
          {
            if (v15)
            {
              uint64_t v16 = 0;
              unsigned int v17 = &v12[v13[2]];
              char v18 = &v12[v13[6]];
              int v19 = v11 - result;
              do
              {
                uint64_t v20 = &v17[16 * v16 + 16 * *(unsigned int *)v14];
                unint64_t v21 = *((unsigned int *)v20 + 3);
                if (v13[7] <= v21) {
                  char v22 = (char *)&unk_1A8E7346B;
                }
                else {
                  char v22 = &v18[v21];
                }
                BOOL result = (dyld3::MachOFile *)(*(uint64_t (**)(uint64_t, void, char *, void))(a3 + 16))(a3, (*(_DWORD *)v20 + v19), v22, 0);
                ++v16;
              }
              while (v16 != *((_DWORD *)v14 + 1));
            }
          }
        }
      }
    }
    else
    {
      v23[0] = (char *)result + v3 - *(void *)((char *)result + v6);
      v23[1] = v3;
      return (dyld3::MachOFile *)PatchTable::forEachPatchableExport(v23, a2, a3);
    }
  }
  return result;
}

BOOL DyldSharedCache::shouldPatchClientOfImage(DyldSharedCache *this, unsigned int a2, int a3)
{
  uint64_t v3 = *((void *)this + 19);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *((unsigned int *)this + 4);
  if (v4 < 0x181) {
    return 0;
  }
  uint64_t v5 = (_DWORD *)((char *)this + v3 - *(void *)((char *)this + v4));
  if (*v5 == 1) {
    return 0;
  }
  v7[0] = v5;
  v7[1] = v3;
  return PatchTable::imageHasClient((PatchTable *)v7, a2, a3);
}

void DyldSharedCache::forEachPatchableUseOfExportInImage(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 152);
  if (v5)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (v8 < 0x181 || *(_DWORD *)(v5 + a1 - *(void *)(a1 + v8)) == 1)
    {
      uint64_t v9 = 24;
      if (v8 > 0x1C3) {
        uint64_t v9 = 448;
      }
      uint64_t v10 = *(void *)(a1 + *(unsigned int *)(a1 + v9) + 32 * a2) + a1;
      uint64_t v11 = *(void *)(v8 + a1);
      if (v10 != v11)
      {
        uint64_t v12 = *(void *)(a1 + v8);
        unint64_t v13 = a2;
        int Address = dyld3::MachOFile::preferredLoadAddress((dyld3::MachOFile *)(v10 - v11));
        uint64_t v15 = *(void *)(a1 + *(unsigned int *)(a1 + 16));
        uint64_t v16 = (void *)(*(void *)(a1 + 152) + a1 - v15);
        if (v16[1] >= v13)
        {
          uint64_t v17 = a1 - v15;
          char v18 = (unsigned int *)(a1 - v15 + *v16 + 8 * v13);
          unsigned int v19 = v18[1];
          uint64_t v47 = v18 + 1;
          if (v16[3] >= (unint64_t)(v19 + *v18))
          {
            uint64_t v60 = 0;
            uint64_t v61 = &v60;
            uint64_t v62 = 0x5002000000;
            vm_address_t v63 = __Block_byref_object_copy__10;
            uint64_t v64 = __Block_byref_object_dispose__10;
            vm_address_t v65 = v70;
            uint64_t v66 = 8;
            uint64_t v67 = 0;
            vm_address_t v68 = 0;
            vm_size_t v69 = 0;
            uint64_t v56 = 0;
            uint64_t v57 = &v56;
            uint64_t v58 = 0x2000000000;
            uint64_t v59 = 0;
            uint64_t v52 = 0;
            unint64_t v53 = &v52;
            uint64_t v54 = 0x2000000000;
            int v55 = -1;
            if (v19)
            {
              uint64_t v20 = 0;
              int v21 = Address - v12 + a3;
              uint64_t v22 = v17 + v16[2];
              uint64_t v23 = v17 + v16[4];
              uint64_t v45 = v18;
              uint64_t v46 = v16;
              int v44 = v21;
              uint64_t v43 = v22;
              do
              {
                uint64_t v24 = v20 + *v18;
                if (*(_DWORD *)(v22 + 16 * v24) == v21)
                {
                  uint64_t v25 = v22 + 16 * v24;
                  int v27 = *(_DWORD *)(v25 + 4);
                  int v26 = (unsigned int *)(v25 + 4);
                  unsigned int v28 = v26[1];
                  if (v16[5] < (unint64_t)(v28 + v27)) {
                    break;
                  }
                  if (v28)
                  {
                    uint64_t v29 = 0;
                    do
                    {
                      uint64_t v30 = v29 + *v26;
                      long long v31 = (_DWORD *)(v23 + 8 * v30);
                      uint64_t v32 = (dyld3::MachOFile *)v57[3];
                      uint64_t v33 = v61;
                      if (v32 && (uint64_t v34 = v61[7]) != 0)
                      {
                        unint64_t v35 = *v31;
                        uint64_t v36 = 16 * v34;
                        int v37 = (unint64_t *)(v61[5] + 8);
                        while (*(v37 - 1) > v35 || *v37 <= v35)
                        {
                          v37 += 2;
                          v36 -= 16;
                          if (!v36) {
                            goto LABEL_21;
                          }
                        }
                      }
                      else
                      {
LABEL_21:
                        v57[3] = 0;
                        *((_DWORD *)v53 + 6) = -1;
                        v33[7] = 0;
                        v51[0] = _NSConcreteStackBlock;
                        v51[1] = 0x40000000;
                        uint64_t v51[2] = ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke;
                        v51[3] = &unk_1EFF65CD0;
                        v51[7] = v12;
                        v51[8] = v23 + 8 * v30;
                        v51[4] = &v60;
                        v51[5] = &v56;
                        void v51[6] = &v52;
                        DyldSharedCache::forEachDylib((unsigned int *)a1, (uint64_t)v51);
                        uint64_t v32 = (dyld3::MachOFile *)v57[3];
                      }
                      if (!v32) {
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      }
                      int v38 = *((_DWORD *)v53 + 6);
                      if (v38 == -1) {
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      }
                      if (!v61[7]) {
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      }
                      if (v38 == a4)
                      {
                        int v39 = v12 + *v31;
                        uint64_t v40 = v39 - dyld3::MachOFile::preferredLoadAddress(v32);
                        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v50);
                        unsigned int v41 = *(_DWORD *)(v23 + 8 * v30 + 4);
                        int8x16_t v42 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v41), (uint32x4_t)xmmword_1A8E70500), (int8x16_t)xmmword_1A8E70510);
                        *(int8x8_t *)v42.i8 = vorr_s8(*(int8x8_t *)v42.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
                        unsigned __int32 v50 = v42.i32[0] | v50 & 0xF0000000 | v42.i32[1] | HIWORD(v41);
                        (*(void (**)(uint64_t, uint64_t))(a5 + 16))(a5, v40);
                      }
                      ++v29;
                    }
                    while (v29 != v26[1]);
                    uint64_t v16 = v46;
                    unsigned int v19 = *v47;
                    char v18 = v45;
                    int v21 = v44;
                    uint64_t v22 = v43;
                  }
                }
                ++v20;
              }
              while (v20 != v19);
            }
            _Block_object_dispose(&v52, 8);
            _Block_object_dispose(&v56, 8);
            _Block_object_dispose(&v60, 8);
            uint64_t v67 = 0;
            if (v68) {
              vm_deallocate(mach_task_self_, v68, v69);
            }
          }
        }
      }
    }
    else
    {
      v70[0] = v5 + a1 - *(void *)(a1 + v8);
      v70[1] = v5;
      PatchTable::forEachPatchableUseOfExportInImage((PatchTableV2 *)v70, a2, a3, a4, a5);
    }
  }
}

double __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::halt("obsolete dyld API called", 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__10(void *result)
{
  result[7] = 0;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke(uint64_t a1, _DWORD *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, unsigned char *a7)
{
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  void v17[2] = ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2;
  v17[3] = &unk_1EFF65CA8;
  uint64_t v11 = *(void *)(a1 + 56);
  v17[4] = *(void *)(a1 + 32);
  _WORD v17[5] = v11;
  dyld3::MachOFile::forEachSegment(a2, (uint64_t)v17);
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v13 = *(void *)(v12 + 56);
  if (v13)
  {
    unint64_t v14 = **(unsigned int **)(a1 + 64);
    uint64_t v15 = 16 * v13;
    uint64_t v16 = (unint64_t *)(*(void *)(v12 + 40) + 8);
    while (*(v16 - 1) > v14 || *v16 <= v14)
    {
      v16 += 2;
      v15 -= 16;
      if (!v15) {
        goto LABEL_6;
      }
    }
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a4;
    *a7 = 1;
  }
  else
  {
LABEL_6:
    *(void *)(v12 + 56) = 0;
  }
}

void *___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2(void *result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 52) & 2) != 0)
  {
    uint64_t v2 = *((void *)result + 5);
    uint64_t v3 = *(void *)(*((void *)result + 4) + 8);
    uint64_t v5 = *(void *)(a2 + 16);
    uint64_t v4 = *(void *)(a2 + 24);
    unint64_t v6 = *(void *)(v3 + 48);
    unint64_t v7 = *(void *)(v3 + 56) + 1;
    if (v7 > v6)
    {
      vm_address_t v8 = *(void *)(v3 + 64);
      vm_size_t v9 = *(void *)(v3 + 72);
      unint64_t v10 = 2 * v6;
      if (v10 > v7) {
        unint64_t v7 = v10;
      }
      vm_size_t v11 = (vm_page_size + 16 * v7 - 1) & -(uint64_t)vm_page_size;
      *(void *)(v3 + 72) = v11;
      if (vm_allocate(mach_task_self_, (vm_address_t *)(v3 + 64), v11, 1006632961)) {
        dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace();
      }
      double result = memmove(*(void **)(v3 + 64), *(const void **)(v3 + 40), 16 * *(void *)(v3 + 56));
      uint64_t v12 = *(void *)(v3 + 72) >> 4;
      *(void *)(v3 + 4dyld4::halt("obsolete dyld API called", 0) = *(void *)(v3 + 64);
      *(void *)(v3 + 48) = v12;
      if (v8) {
        double result = (void *)vm_deallocate(mach_task_self_, v8, v9);
      }
    }
    uint64_t v13 = *(void *)(v3 + 40);
    uint64_t v14 = *(void *)(v3 + 56);
    *(void *)(v3 + 56) = v14 + 1;
    uint64_t v15 = (void *)(v13 + 16 * v14);
    *uint64_t v15 = v5 - v2;
    v15[1] = v5 - v2 + v4;
  }
  return result;
}

dyld3::MachOFile *DyldSharedCache::forEachPatchableUseOfExport(dyld3::MachOFile *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *((void *)result + 19);
  if (v4)
  {
    vm_address_t v8 = result;
    uint64_t v9 = *((unsigned int *)result + 4);
    if (v9 > 0x180)
    {
      int v10 = *(_DWORD *)((char *)result + v4 - *(void *)((char *)result + v9));
      DyldSharedCache::forEachPatchableGOTUseOfExport((uint64_t)result, a2, a3, a4);
      if (v10 != 1)
      {
        v39[0] = _NSConcreteStackBlock;
        v39[1] = 0x40000000;
        _OWORD v39[2] = ___ZNK15DyldSharedCache27forEachPatchableUseOfExportEjjU13block_pointerFvyN5dyld39MachOFile15PointerMetaDataEybE_block_invoke;
        v39[3] = &__block_descriptor_tmp_36_1;
        v39[4] = v8;
        uint64_t v34 = *((void *)v8 + 19);
        uint64_t v35 = *(void *)((char *)v8 + *((unsigned int *)v8 + 4));
        v38[0] = (char *)v8 + v34 - v35;
        v38[1] = v34;
        return (dyld3::MachOFile *)PatchTable::forEachPatchableCacheUseOfExport(v38, a2, a3, v35, (uint64_t)v39, a4);
      }
    }
    else
    {
      DyldSharedCache::forEachPatchableGOTUseOfExport((uint64_t)result, a2, a3, a4);
    }
    unint64_t v11 = *((unsigned int *)v8 + 4);
    uint64_t v12 = 24;
    if (v11 > 0x1C3) {
      uint64_t v12 = 448;
    }
    uint64_t v13 = (char *)v8 + *(void *)((char *)v8 + 32 * a2 + *(unsigned int *)((char *)v8 + v12));
    uint64_t v14 = *(char **)((char *)v8 + v11);
    double result = (dyld3::MachOFile *)(v13 - v14);
    if (v13 != v14)
    {
      int v15 = *(_DWORD *)((char *)v8 + v11);
      double result = (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
      uint64_t v16 = *(void *)((char *)v8 + *((unsigned int *)v8 + 4));
      uint64_t v17 = (void *)((char *)v8 + *((void *)v8 + 19) - v16);
      if (v17[1] >= (unint64_t)a2)
      {
        char v18 = (char *)v8 - v16;
        unsigned int v19 = (unsigned int *)((char *)v8 + 8 * a2 + *v17 - v16);
        unsigned int v20 = v19[1];
        if (v17[3] >= (unint64_t)(v20 + *v19))
        {
          if (v20)
          {
            uint64_t v21 = 0;
            unsigned int v22 = result - v15 + a3;
            uint64_t v23 = &v18[v17[2]];
            uint64_t v24 = &v18[v17[4]];
            int v37 = v17;
            unsigned int v36 = v22;
            do
            {
              uint64_t v25 = v21 + *v19;
              if (*(_DWORD *)&v23[16 * v25] == v22)
              {
                int v26 = &v23[16 * v25];
                int v28 = *((_DWORD *)v26 + 1);
                int v27 = (unsigned int *)(v26 + 4);
                unsigned int v29 = v27[1];
                if (v17[5] < (unint64_t)(v29 + v28)) {
                  return result;
                }
                if (v29)
                {
                  uint64_t v30 = 0;
                  do
                  {
                    long long v31 = &v24[8 * v30 + 8 * *v27];
                    dyld3::MachOFile::PointerMetaData::PointerMetaData(v38);
                    unsigned int v32 = *((_DWORD *)v31 + 1);
                    int8x16_t v33 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v32), (uint32x4_t)xmmword_1A8E70500), (int8x16_t)xmmword_1A8E70510);
                    *(int8x8_t *)v33.i8 = vorr_s8(*(int8x8_t *)v33.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
                    LODWORD(v38[0]) = v33.i32[0] | v38[0] & 0xF0000000 | v33.i32[1] | HIWORD(v32);
                    double result = (dyld3::MachOFile *)(*(uint64_t (**)(uint64_t, void))(a4 + 16))(a4, *(unsigned int *)v31);
                    ++v30;
                  }
                  while (v30 != v27[1]);
                  uint64_t v17 = v37;
                  unsigned int v20 = v19[1];
                  unsigned int v22 = v36;
                }
              }
              ++v21;
            }
            while (v21 != v20);
          }
        }
      }
    }
  }
  return result;
}

uint64_t DyldSharedCache::forEachPatchableGOTUseOfExport(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 152);
  if (v4)
  {
    uint64_t v5 = *(unsigned int *)(result + 16);
    if (v5 >= 0x181)
    {
      unint64_t v6 = (_DWORD *)(v4 + result - *(void *)(result + v5));
      if (*v6 != 1)
      {
        v7[0] = v6;
        v7[1] = v4;
        return PatchTable::forEachPatchableGOTUseOfExport((uint64_t)v7, a2, a3, a4);
      }
    }
  }
  return result;
}

dyld3::MachOFile *___ZNK15DyldSharedCache27forEachPatchableUseOfExportEjjU13block_pointerFvyN5dyld39MachOFile15PointerMetaDataEybE_block_invoke(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(unsigned int *)(v2 + 16);
  uint64_t v4 = 24;
  if (v3 > 0x1C3) {
    uint64_t v4 = 448;
  }
  uint64_t v5 = *(void *)(v2 + *(unsigned int *)(v2 + v4) + 32 * a2) + v2;
  uint64_t v6 = *(void *)(v3 + v2);
  double result = (dyld3::MachOFile *)(v5 - v6);
  if (v5 != v6) {
    return (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
  }
  return result;
}

BOOL DyldSharedCache::isSubCachePath(DyldSharedCache *this, const char *a2)
{
  uint64_t v2 = _platform_strchr((char *)this, 46);
  return v2 && _platform_strcmp(v2, ".development");
}

dyld3::MachOLoaded *DyldSharedCache::oldObjcOpt(DyldSharedCache *this)
{
  unsigned int v14 = 0;
  if (!DyldSharedCache::hasImagePath(this, "/usr/lib/libobjc.A.dylib", &v14)) {
    return 0;
  }
  unint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 24;
  if (v2 > 0x1C3) {
    uint64_t v3 = 448;
  }
  uint64_t v4 = (char *)this + *(void *)((char *)this + 32 * v14 + *(unsigned int *)((char *)this + v3));
  uint64_t v5 = *(char **)((char *)this + v2);
  uint64_t v6 = (dyld3::MachOLoaded *)(v4 - v5);
  if (v4 != v5)
  {
    uint64_t v10 = 0;
    unint64_t v11 = &v10;
    uint64_t v12 = 0x2000000000;
    uint64_t v13 = 0;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    unsigned int v9[2] = ___ZNK15DyldSharedCache10oldObjcOptEv_block_invoke;
    void v9[3] = &unk_1EFF65D18;
    void v9[4] = &v10;
    void v9[5] = dyld3::MachOLoaded::getSlide(v6);
    dyld3::MachOFile::forEachSection(v6, (uint64_t)v9);
    unint64_t v7 = (_DWORD *)v11[3];
    if (v7)
    {
      if ((*v7 - 15) >= 2) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = (dyld3::MachOLoaded *)v11[3];
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    _Block_object_dispose(&v10, 8);
  }
  return v6;
}

uint64_t ___ZNK15DyldSharedCache10oldObjcOptEv_block_invoke(uint64_t a1, uint64_t a2, int a3, unsigned char *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__TEXT");
  if (!result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_opt_ro");
    if (!result)
    {
      if (a3) {
        *a4 = 1;
      }
      else {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a1 + 40) + *(void *)(a2 + 64);
      }
    }
  }
  return result;
}

uint64_t DyldSharedCache::objcOptPtrs(DyldSharedCache *this)
{
  unsigned int v14 = 0;
  if (!DyldSharedCache::hasImagePath(this, "/usr/lib/libobjc.A.dylib", &v14)) {
    return 0;
  }
  unint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 24;
  if (v2 > 0x1C3) {
    uint64_t v3 = 448;
  }
  uint64_t v4 = (DyldSharedCache *)((char *)this
                         + *(void *)((char *)this + 32 * v14 + *(unsigned int *)((char *)this + v3))
                         - *(void *)((char *)this + v2));
  uint64_t v10 = 0;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  uint64_t Slide = dyld3::MachOLoaded::getSlide(v4);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK15DyldSharedCache11objcOptPtrsEv_block_invoke;
  void v8[3] = &unk_1EFF65D40;
  int v9 = dyld3::MachOFile::pointerSize(v4);
  void v8[4] = &v10;
  void v8[5] = Slide;
  dyld3::MachOFile::forEachSection(v4, (uint64_t)v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t ___ZNK15DyldSharedCache11objcOptPtrsEv_block_invoke(uint64_t a1, uint64_t a2, int a3, unsigned char *a4)
{
  vm_address_t v8 = *(const char **)(a2 + 40);
  if (!_platform_strncmp(v8, "__DATA", 6uLL) || (uint64_t result = _platform_strncmp(v8, "__AUTH", 6uLL), !result))
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_opt_ptrs");
    if (!result)
    {
      if (*(void *)(a2 + 72) == *(_DWORD *)(a1 + 48) && !a3) {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a1 + 40) + *(void *)(a2 + 64);
      }
      else {
        *a4 = 1;
      }
    }
  }
  return result;
}

uint64_t objc_visitor::Class::getISA@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, BOOL *a3@<X2>, void *a4@<X8>)
{
  unint64_t v7 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  metadata_visitor::Visitor::getField(a2, v7, v9);
  return metadata_visitor::Visitor::resolveBindOrRebase(a2, v9, a3, a4);
}

uint64_t objc_visitor::Class::getSuperclassField@<X0>(uint64_t a1@<X0>, int *a2@<X1>, void *a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v5 == 4) {
    unint64_t v7 = (char *)(v6 + 4);
  }
  else {
    unint64_t v7 = (char *)(v6 + 8);
  }

  return metadata_visitor::Visitor::getField((uint64_t)a2, v7, a3);
}

uint64_t objc_visitor::Class::isUnfixedBackwardDeployingStableSwift(uint64_t a1, int *a2)
{
  uint64_t result = objc_visitor::Class::isSwiftLegacy(a1, a2);
  if (result)
  {
    uint64_t v5 = objc_visitor::Class::swiftClassFlags(a1, a2);
    return (v5 & 0xFF00000000) != 0 && (v5 & 1) == 0;
  }
  return result;
}

uint64_t objc_visitor::Class::isSwiftLegacy(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v3 == 4) {
    uint64_t v5 = (char *)(v4 + 16);
  }
  else {
    uint64_t v5 = (char *)(v4 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v10);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v10, v9);
  char v6 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  if (!v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return v6 & 1;
}

uint64_t objc_visitor::Class::swiftClassFlags(uint64_t a1, int *a2)
{
  if ((objc_visitor::Class::isSwiftStable(a1, a2) & 1) == 0
    && !objc_visitor::Class::isSwiftLegacy(a1, a2))
  {
    return 0;
  }
  int v4 = *a2;
  uint64_t v5 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  uint64_t v6 = 40;
  if (v4 == 4) {
    uint64_t v6 = 20;
  }
  return *(unsigned int *)(v5 + v6) | 0x100000000;
}

uint64_t objc_visitor::Class::isSwiftStable(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v3 == 4) {
    uint64_t v5 = (char *)(v4 + 16);
  }
  else {
    uint64_t v5 = (char *)(v4 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v10);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v10, v9);
  unint64_t v6 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  if (!v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (v6 >> 1) & 1;
}

__n128 objc_visitor::Class::getClassData@<Q0>(uint64_t a1@<X0>, int *a2@<X1>, __n128 *a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v5 == 4) {
    char v7 = (char *)(v6 + 16);
  }
  else {
    char v7 = (char *)(v6 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v17);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v17, v16);
  uint64_t v8 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v16);
  if (!v9) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v10 = 4294967292;
  if (*a2 != 4) {
    uint64_t v10 = 0x7FFFFFFFFFF8;
  }
  uint64_t v11 = v10 & v8;
  if (v11 == v8)
  {
    uint64_t v12 = (__n128 *)v16;
  }
  else
  {
    uint64_t v13 = (char *)(lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v16) + v11 - v8);
    uint64_t v12 = (__n128 *)v15;
    metadata_visitor::Visitor::getField((uint64_t)a2, v13, v15);
  }
  __n128 result = *v12;
  *a3 = *v12;
  a3[1].n128_u64[0] = v12[1].n128_u64[0];
  return result;
}

uint64_t objc_visitor::Class::isRootClass(uint64_t a1, int *a2)
{
  objc_visitor::Class::getClassData(a1, a2, &v3);
  return (*(_DWORD *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v3) >> 1) & 1;
}

uint64_t objc_visitor::Class::getName(uint64_t a1, int *a2)
{
  objc_visitor::Class::getClassData(a1, a2, &v9);
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v9);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 16);
  }
  else {
    int v5 = (char *)(v4 + 24);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v7);
}

uint64_t objc_visitor::Class::getNameVMAddr(uint64_t a1, int *a2)
{
  objc_visitor::Class::getClassData(a1, a2, &v9);
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v9);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 16);
  }
  else {
    int v5 = (char *)(v4 + 24);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v7);
}

uint64_t objc_visitor::Class::getBaseMethods@<X0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  objc_visitor::Class::getClassData(a1, a2, &v10);
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v10);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 20);
  }
  else {
    char v7 = (char *)(v6 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Class::getVMAddress(objc_visitor::Class *this)
{
  return metadata_visitor::ResolvedValue::vmAddress((objc_visitor::Class *)((char *)this + 8));
}

uint64_t objc_visitor::Category::getInstanceMethods@<X0>(lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 8);
  }
  else {
    char v7 = (char *)(v6 + 16);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getISAVMAddr@<X0>(lsl::Allocator::Pool *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = (char *)lsl::Allocator::Pool::allocator(a1);
  metadata_visitor::Visitor::getField(a2, v5, v11);
  uint64_t result = metadata_visitor::Visitor::resolveOptionalRebase(a2, v11, (uint64_t)v9);
  char v7 = v10;
  if (v10)
  {
    uint64_t result = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
    *(void *)a3 = result;
    *(void *)(a3 + 8) = v8;
    char v7 = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 16) = v7;
  return result;
}

uint64_t objc_visitor::Protocol::getName(lsl::Allocator::Pool *a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator(a1);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 4);
  }
  else {
    int v5 = (char *)(v4 + 8);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v7);
}

uint64_t objc_visitor::Protocol::getNameVMAddr(lsl::Allocator::Pool *a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator(a1);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 4);
  }
  else {
    int v5 = (char *)(v4 + 8);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v7);
}

int *objc_visitor::Method::getNameSelRefVMAddr(int *result, uint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    if (v2 == 1) {
      objc_visitor::Method::getNameSelRefVMAddr();
    }
    if (v2 == 2) {
      objc_visitor::Method::getNameSelRefVMAddr();
    }
  }
  else
  {
    uint64_t v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    uint64_t v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1, v8);
    return (int *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v8);
  }
  return result;
}

uint64_t objc_visitor::ProtocolList::numProtocols(lsl::Allocator::Pool *a1, _DWORD *a2)
{
  if (!*((unsigned char *)a1 + 24)) {
    return 0;
  }
  int v3 = (unsigned int *)lsl::Allocator::Pool::allocator(a1);
  if (!v3) {
    objc_visitor::ProtocolList::numProtocols();
  }
  if (*a2 == 4) {
    return *v3;
  }
  else {
    return *(void *)v3;
  }
}

uint64_t objc_visitor::ProtocolList::getProtocolField@<X0>(lsl::Allocator::Pool *a1@<X0>, _DWORD *a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  if (!*((unsigned char *)a1 + 24)) {
    objc_visitor::ProtocolList::getProtocolField();
  }
  if (objc_visitor::ProtocolList::numProtocols(a1, a2) <= a3) {
    objc_visitor::ProtocolList::getProtocolField();
  }
  if (!*((unsigned char *)a1 + 24)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v8 = lsl::Allocator::Pool::allocator(a1);
  if (!v8) {
    objc_visitor::ProtocolList::getProtocolField();
  }
  if (*a2 == 4) {
    __n128 v9 = (char *)(v8 + 4 * a3 + 4);
  }
  else {
    __n128 v9 = (char *)(v8 + 8 * a3 + 8);
  }

  return metadata_visitor::Visitor::getField((uint64_t)a2, v9, a4);
}

size_t objc_visitor::ProtocolList::dump(lsl::Allocator::Pool *a1, _DWORD *a2)
{
  if (*((unsigned char *)a1 + 24))
  {
    uint64_t v4 = objc_visitor::ProtocolList::numProtocols(a1, a2);
    uint64_t v5 = __stdoutp;
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(a1);
    if (!v7) {
      goto LABEL_11;
    }
    uint64_t v8 = v6;
    __n128 v9 = (const void *)lsl::Allocator::Pool::allocator(a1);
    size_t result = fprintf(v5, "Protocol list (count %lld): vmAddr 0x%llx at %p\n", v4, v8, v9);
    if (v4)
    {
      unint64_t v11 = 0;
      while (1)
      {
        objc_visitor::ProtocolList::getProtocolField(a1, a2, v11, v19);
        metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v19, v18);
        uint64_t v12 = __stdoutp;
        uint64_t v13 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v18);
        if (!v14) {
          break;
        }
        uint64_t v15 = v13;
        uint64_t v16 = (const void *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v18);
        size_t result = fprintf(v12, "  Protocol[%lld]: vmAddr 0x%llx at %p\n", v11++, v15, v16);
        if (v4 == v11) {
          return result;
        }
      }
LABEL_11:
      std::__throw_bad_optional_access[abi:nn180100]();
    }
  }
  else
  {
    uint64_t v17 = __stdoutp;
    return fwrite("no value\n", 9uLL, 1uLL, v17);
  }
  return result;
}

__n128 __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  long long v3 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

uint64_t objc_visitor::Visitor::forEachClass(unsigned int *a1, int a2, lsl::Allocator::Pool *this, uint64_t a4)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = *a1;
  unint64_t v6 = v4 / v5;
  if (v4 % v5) {
    objc_visitor::Visitor::forEachClass();
  }
  uint64_t result = lsl::Allocator::Pool::allocator(this);
  if (v4 >= v5)
  {
    uint64_t v11 = result;
    uint64_t v12 = 0;
    do
    {
      while (1)
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v11 + v12 * *a1), v26);
        BOOL v25 = 0;
        metadata_visitor::Visitor::resolveBindOrRebase((uint64_t)a1, v26, &v25, &v23);
        long long v21 = v23;
        uint64_t v22 = v24;
        v20[0] = 0;
        v20[1] = v25;
        char v19 = 0;
        uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *, void, char *))(a4 + 16))(a4, v20, 0, &v19);
        if (v19 || !a2) {
          break;
        }
        BOOL v18 = 0;
        objc_visitor::Class::getISA((uint64_t)v20, (uint64_t)a1, &v18, &v16);
        long long v14 = v16;
        uint64_t v15 = v17;
        v13[0] = 1;
        v13[1] = v18;
        uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, char *))(a4 + 16))(a4, v13, 1, &v19);
        if (!v19 && ++v12 != v6) {
          continue;
        }
        return result;
      }
      ++v12;
    }
    while (v12 != v6 && !v19);
  }
  return result;
}

void objc_visitor::Visitor::forEachClass(unsigned int *a1, int a2, uint64_t a3)
{
  objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)"__objc_classlist", (uint64_t)v6);
  if (v6[32]) {
    objc_visitor::Visitor::forEachClass(a1, a2, (lsl::Allocator::Pool *)v6, a3);
  }
}

void objc_visitor::Visitor::forEachClass(unsigned int *a1, uint64_t a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  unsigned int v2[2] = ___ZN12objc_visitor7Visitor12forEachClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke;
  v2[3] = &unk_1EFF65D90;
  v2[4] = a2;
  objc_visitor::Visitor::forEachClass(a1, 0, (uint64_t)v2);
}

uint64_t ___ZN12objc_visitor7Visitor12forEachClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void objc_visitor::Visitor::forEachClassAndMetaClass(unsigned int *a1, uint64_t a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  unsigned int v2[2] = ___ZN12objc_visitor7Visitor24forEachClassAndMetaClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke;
  v2[3] = &unk_1EFF65DB8;
  v2[4] = a2;
  objc_visitor::Visitor::forEachClass(a1, 1, (uint64_t)v2);
}

uint64_t ___ZN12objc_visitor7Visitor24forEachClassAndMetaClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void objc_visitor::Visitor::forEachCategory(unsigned int *a1, uint64_t a2)
{
  uint64_t v4 = 0;
  __int16 v25 = 256;
  do
  {
    char v5 = *((unsigned char *)&v25 + v4);
    if (v5) {
      unint64_t v6 = "__objc_catlist2";
    }
    else {
      unint64_t v6 = "__objc_catlist";
    }
    objc_visitor::Visitor::findSection((uint64_t)a1, (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments, 3, (uint64_t)v6, (uint64_t)v22);
    if (v24)
    {
      unint64_t v7 = v23;
      unint64_t v8 = *a1;
      unint64_t v9 = v23 / v8;
      if (v23 % v8) {
        objc_visitor::Visitor::forEachCategory();
      }
      uint64_t v10 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v22);
      if (v7 >= v8)
      {
        uint64_t v11 = v10;
        uint64_t v12 = 0;
        unint64_t v13 = v9 - 1;
        do
        {
          metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v11 + v12 * *a1), v21);
          metadata_visitor::Visitor::resolveRebase((uint64_t)a1, v21, &v19);
          long long v16 = v19;
          uint64_t v17 = v20;
          char v18 = v5;
          char v15 = 0;
          (*(void (**)(uint64_t, long long *, char *))(a2 + 16))(a2, &v16, &v15);
          if (v15) {
            break;
          }
        }
        while (v13 != v12++);
      }
    }
    ++v4;
  }
  while (v4 != 2);
}

void metadata_visitor::SwiftVisitor::forEachProtocolConformance(metadata_visitor::SwiftVisitor *a1, uint64_t a2)
{
  metadata_visitor::SwiftVisitor::getSwiftConformances(a1, (uint64_t)v9);
  if (v10)
  {
    unsigned int v4 = 0;
    int v5 = v10 - 1;
    do
    {
      metadata_visitor::SwiftConformanceList::getConformance((metadata_visitor::SwiftConformanceList *)v9, a1, v4, v8);
      char v7 = 0;
      (*(void (**)(uint64_t, void *, char *))(a2 + 16))(a2, v8, &v7);
      if (v7) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v5 == v4;
      }
      ++v4;
    }
    while (!v6);
  }
}

void metadata_visitor::SwiftVisitor::getSwiftConformances(metadata_visitor::SwiftVisitor *this@<X0>, uint64_t a2@<X8>)
{
  metadata_visitor::SwiftVisitor::findSection(this, "__TEXT", "__swift5_proto", (uint64_t)&v5);
  LODWORD(v3) = v8;
  if (v8)
  {
    if ((v7 & 3) != 0) {
      metadata_visitor::SwiftVisitor::getSwiftConformances();
    }
    unint64_t v3 = v7 >> 2;
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
    char v4 = 1;
  }
  else
  {
    char v4 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4;
  *(_DWORD *)(a2 + 32) = v3;
}

uint64_t metadata_visitor::SwiftConformanceList::getConformance@<X0>(metadata_visitor::SwiftConformanceList *this@<X0>, const metadata_visitor::Visitor *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  uint64_t v8 = *(int *)(lsl::Allocator::Pool::allocator(this) + 4 * a3);
  uint64_t v9 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (!v10) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }

  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v8 + 4 * a3 + v9, 1, a4);
}

void metadata_visitor::SwiftVisitor::findSection(metadata_visitor::SwiftVisitor *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  long long v5 = (_DWORD *)*((void *)this + 1);
  uint64_t v9 = 0;
  char v10 = &v9;
  uint64_t v11 = 0x5002000000;
  uint64_t v12 = __Block_byref_object_copy__12;
  unint64_t v13 = __Block_byref_object_dispose__12;
  char v14 = 0;
  char v15 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK16metadata_visitor12SwiftVisitor11findSectionEPKcS2__block_invoke;
  void v8[3] = &unk_1EFF65E08;
  void v8[6] = a2;
  void v8[7] = a3;
  void v8[4] = &v9;
  void v8[5] = this;
  dyld3::MachOFile::forEachSection(v5, (uint64_t)v8);
  uint64_t v6 = v10;
  long long v7 = *(_OWORD *)(v10 + 7);
  *(_OWORD *)a4 = *(_OWORD *)(v10 + 5);
  *(_OWORD *)(a4 + 16) = v7;
  *(void *)(a4 + 32) = v6[9];
  _Block_object_dispose(&v9, 8);
}

__n128 __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  long long v3 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

double ___ZNK16metadata_visitor12SwiftVisitor11findSectionEPKcS2__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  if (!_platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 48))
    && !_platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 56)))
  {
    uint64_t v9 = *(void *)(a2 + 64);
    uint64_t Slide = dyld3::MachOLoaded::getSlide(*(dyld3::MachOLoaded **)(v7 + 8));
    metadata_visitor::ResolvedValue::ResolvedValue(&v13, Slide + v9, *(void *)(a2 + 64), 1);
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v12 = v14;
    double result = *(double *)&v13;
    *(_OWORD *)(v11 + 4dyld4::halt("obsolete dyld API called", 0) = v13;
    *(void *)(v11 + 56) = v12;
    *(void *)(v11 + 64) = 0;
    *(unsigned char *)(v11 + 72) = 1;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 64) = *(void *)(a2 + 72);
    *a4 = 1;
  }
  return result;
}

uint64_t metadata_visitor::SwiftConformance::getProtocolPointer@<X0>(metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  long long v5 = (char *)lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, &v9);
  long long v7 = v9;
  uint64_t v8 = v10;
  return metadata_visitor::SwiftConformance::SwiftRelativePointer::getTargetPointer((metadata_visitor::SwiftConformance::SwiftRelativePointer *)&v7, a2, a3);
}

uint64_t metadata_visitor::SwiftConformance::SwiftRelativePointer::getTargetPointer@<X0>(metadata_visitor::SwiftConformance::SwiftRelativePointer *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
  uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (v6)
  {
    if (v8)
    {
      char v9 = 0;
      v6 &= ~1u;
      goto LABEL_6;
    }
LABEL_7:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (!v8) {
    goto LABEL_7;
  }
  char v9 = 1;
LABEL_6:
  *(unsigned char *)a3 = v9;
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1, (void *)(a3 + 8));
}

uint64_t metadata_visitor::SwiftConformance::getProtocolConformanceFlags@<X0>(metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, void *a3@<X8>)
{
  long long v5 = (char *)(lsl::Allocator::Pool::allocator(this) + 12);

  return metadata_visitor::Visitor::getField((uint64_t)a2, v5, a3);
}

double metadata_visitor::SwiftConformance::getTypeRef@<D0>(metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v6 + 4), &v11);
  uint64_t v7 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v7 + 12), v10);
  int v8 = (*(_DWORD *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v10) >> 3) & 7;
  double result = *(double *)&v11;
  *(_OWORD *)a3 = v11;
  *(void *)(a3 + 16) = v12;
  *(_DWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
  return result;
}

uint64_t metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags::typeReferenceKind(metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags *this)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator(this) >> 3) & 7;
}

BOOL metadata_visitor::SwiftConformance::isNull(metadata_visitor::SwiftConformance *this)
{
  return *(_OWORD *)lsl::Allocator::Pool::allocator(this) == 0;
}

uint64_t metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName(metadata_visitor::SwiftConformance::SwiftTypeRefPointer *this, const metadata_visitor::SwiftVisitor *a2)
{
  if (*((_DWORD *)this + 6) != 2) {
    metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName();
  }
  uint64_t v4 = *(int *)lsl::Allocator::Pool::allocator(this);
  uint64_t v5 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (!v6) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  metadata_visitor::Visitor::getValueFor((uint64_t)a2, v5 + v4, 1, v8);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v8);
}

metadata_visitor::ResolvedValue *metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getTargetPointer@<X0>(metadata_visitor::ResolvedValue *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = this;
  switch(*((_DWORD *)this + 6))
  {
    case 0:
    case 2:
      signed int v6 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
      uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress(v4);
      if (!v8) {
        goto LABEL_7;
      }
      char v9 = 1;
      goto LABEL_6;
    case 1:
    case 3:
      int v10 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
      uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress(v4);
      if (!v11) {
LABEL_7:
      }
        std::__throw_bad_optional_access[abi:nn180100]();
      char v9 = 0;
      signed int v6 = v10 & 0xFFFFFFFE;
LABEL_6:
      *(unsigned char *)a3 = v9;
      this = (metadata_visitor::ResolvedValue *)metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1, (void *)(a3 + 8));
      break;
    default:
      return this;
  }
  return this;
}

BOOL metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata(metadata_visitor::SwiftConformance::TypeContextDescriptor *this)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator(this) & 0x30000) == 0x20000;
}

uint64_t metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo(metadata_visitor::SwiftConformance::TypeContextDescriptor *this)
{
  return (*(unsigned __int8 *)(lsl::Allocator::Pool::allocator(this) + 2) >> 2) & 1;
}

uint64_t metadata_visitor::SwiftConformance::TypeContextDescriptor::getName@<X0>(metadata_visitor::SwiftConformance::TypeContextDescriptor *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v5 + 8), v10);
  uint64_t v6 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v10);
  uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v10);
  if (!v8) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1, a3);
}

uint64_t dyld3::fstatat(dyld3 *this, const char *a2, stat *a3, stat *a4)
{
  int v4 = (int)a4;
  uint64_t v5 = (const char *)a3;
  uint64_t v6 = a2;
  int v7 = (int)this;
  while (1)
  {
    uint64_t result = fstatat64((int)this, a2, a3, (int)a4);
    if (result != -1) {
      break;
    }
    if (*__error() != 35 && *__error() != 4) {
      return 0xFFFFFFFFLL;
    }
    LODWORD(this) = v7;
    a2 = v6;
    a3 = (stat *)v5;
    LODWORD(a4) = v4;
  }
  return result;
}

BOOL dyld3::FatFile::isValidSlice(dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, unsigned int a4, int a5, int a6, unint64_t a7, unint64_t a8)
{
  if (a3 < a7 || a3 - a7 < a8)
  {
    Diagnostics::error(a2, "slice %d extends beyond end of file");
  }
  else
  {
    uint64_t v12 = (char *)this + a7;
    BOOL result = dyld3::MachOFile::isMachO((dyld3::FatFile *)((char *)this + a7), a2, a8);
    if (!result) {
      return result;
    }
    if (*((_DWORD *)v12 + 1) == a5)
    {
      int v14 = *((_DWORD *)v12 + 2);
      if (((v14 ^ a6) & 0xFFFFFF) != 0)
      {
        Diagnostics::error(a2, "cpu subtype in slice (0x%08X) does not match fat header (0x%08X)");
      }
      else
      {
        if (a5 == 33554444 || a5 == 16777228 || (uint64_t v15 = 4095, a5 == 12) && v14 == 12 && *((_DWORD *)v12 + 3) != 11) {
          uint64_t v15 = 0x3FFFLL;
        }
        if ((v15 & a7) == 0) {
          return 1;
        }
        if (_platform_strncmp(v12, "!<arch>", 7uLL)) {
          Diagnostics::error(a2, "slice is not page aligned");
        }
        else {
          Diagnostics::error(a2, "file is static library");
        }
      }
    }
    else
    {
      Diagnostics::error(a2, "cpu type in slice (0x%08X) does not match fat header (0x%08X)");
    }
  }
  return 0;
}

void dyld3::FatFile::forEachSlice(dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, int a4, uint64_t a5)
{
  if (*(_DWORD *)this == -1078264118)
  {
    unsigned int v10 = *((_DWORD *)this + 1);
    uint64_t v11 = bswap32(v10);
    if (v11 >= 0x80)
    {
      Diagnostics::error(a2, "fat header too large: %u entries", v11);
      return;
    }
    if (((32 * v11) | 8uLL) <= a3)
    {
      char v39 = 0;
      if (v10)
      {
        uint64_t v20 = 0;
        uint64_t v21 = v11 - 1;
        uint64_t v22 = (char *)this + 12;
        do
        {
          uint64_t v23 = bswap32(*((_DWORD *)v22 - 1));
          uint64_t v24 = bswap32(*(_DWORD *)v22);
          unint64_t v25 = bswap64(*(void *)(v22 + 4));
          unint64_t v26 = bswap64(*(void *)(v22 + 12));
          if (!a4 || dyld3::FatFile::isValidSlice(this, a2, a3, v20, v23, v24, v25, v26)) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))(a5, v23, v24, (char *)this + v25, v26, &v39);
          }
          if (v39) {
            break;
          }
          v22 += 32;
        }
        while (v21 != v20++);
      }
      return;
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)this != -1095041334)
  {
    uint64_t v12 = "not a fat file";
LABEL_22:
    Diagnostics::error(a2, v12);
    return;
  }
  unsigned int v8 = *((_DWORD *)this + 1);
  uint64_t v9 = bswap32(v8);
  if (v9 >= 0xCD)
  {
    Diagnostics::error(a2, "fat header too large: %u entries", v9);
    return;
  }
  if (20 * (unint64_t)(v9 + 1) + 8 > a3)
  {
LABEL_21:
    uint64_t v12 = "fat header malformed, architecture slices extend beyond end of file";
    goto LABEL_22;
  }
  char v41 = 0;
  if (!v8) {
    goto LABEL_36;
  }
  unsigned int v34 = v8;
  uint64_t v13 = 0;
  int v14 = (unsigned int *)((char *)this + 20);
  while (1)
  {
    uint64_t v15 = bswap32(*(v14 - 3));
    uint64_t v16 = bswap32(*(v14 - 2));
    unint64_t v17 = bswap32(*(v14 - 1));
    unint64_t v18 = bswap32(*v14);
    Diagnostics::Diagnostics((Diagnostics *)&v40);
    if (!a4 || dyld3::FatFile::isValidSlice(this, (vm_address_t *)&v40, a3, v13, v15, v16, v17, v18)) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))(a5, v15, v16, (char *)this + v17, v18, &v41);
    }
    if (v41) {
      break;
    }
    if (Diagnostics::hasError((Diagnostics *)&v40))
    {
      long long v19 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v40);
      Diagnostics::appendError(a2, "%s, ", v19);
    }
    v14 += 5;
    mach_o::Error::~Error(&v40);
    if (v9 == ++v13) {
      goto LABEL_35;
    }
  }
  mach_o::Error::~Error(&v40);
LABEL_35:
  if (v34 != -872415232)
  {
LABEL_36:
    int v28 = (char *)this + 8;
    unsigned int v29 = (_DWORD *)((char *)this + 20 * v9 + 8);
    uint64_t v30 = bswap32(v29[1]);
    if (*v29 == 201326593 && v30 <= 1)
    {
      unint64_t v32 = bswap32(*(_DWORD *)&v28[20 * v9 + 12]);
      unint64_t v33 = bswap32(*(_DWORD *)&v28[20 * v9 + 8]);
      if (!a4 || dyld3::FatFile::isValidSlice(this, a2, a3, v9, 16777228, v30, v33, v32)) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))(a5, 16777228, v30, (char *)this + v33, v32, &v41);
      }
    }
  }
}

void dyld3::FatFile::forEachSlice(dyld3::FatFile *a1, vm_address_t *a2, unint64_t a3, uint64_t a4)
{
}

char *dyld3::FatFile::archNames(dyld3::FatFile *this, char *a2, unint64_t a3)
{
  *a2 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v10);
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  char v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = ___ZNK5dyld37FatFile9archNamesEPcy_block_invoke;
  void v7[3] = &unk_1EFF65E30;
  v7[4] = v8;
  v7[5] = a2;
  dyld3::FatFile::forEachSlice(this, (vm_address_t *)&v10, a3, 0, (uint64_t)v7);
  _Block_object_dispose(v8, 8);
  mach_o::Error::~Error(&v10);
  return a2;
}

size_t ___ZNK5dyld37FatFile9archNamesEPcy_block_invoke(uint64_t a1, int a2, int a3)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    strlcat(*(char **)(a1 + 40), ",", 0x100uLL);
  }
  uint64_t v6 = 0;
  int v7 = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v6 + 1]) != a2
       || (a3 & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v6 + 3))
  {
    v6 += 2;
    if (v6 == 26) {
      goto LABEL_9;
    }
  }
  int v7 = (&dyld3::MachOFile::_s_archInfos)[v6];
LABEL_9:
  size_t result = strlcat(*(char **)(a1 + 40), v7, 0x100uLL);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

BOOL dyld3::FatFile::isFatFileWithSlice(dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, const dyld3::GradedArchs *a4, char a5, unint64_t *a6, unint64_t *a7, BOOL *a8)
{
  *a8 = 0;
  if ((*(_DWORD *)this | 0x1000000) != 0xBFBAFECA) {
    return 0;
  }
  uint64_t v16 = 0;
  unint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  int v19 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  _WORD v14[2] = ___ZNK5dyld37FatFile18isFatFileWithSliceER11DiagnosticsyRKNS_11GradedArchsEbRyS6_Rb_block_invoke;
  uint64_t v14[3] = &unk_1EFF65E58;
  char v15 = a5;
  _OWORD v14[4] = &v16;
  void v14[5] = this;
  void v14[6] = a4;
  void v14[7] = a6;
  unsigned __int8 v14[8] = a7;
  dyld3::FatFile::forEachSlice(this, a2, a3, 1, (uint64_t)v14);
  BOOL hasError = Diagnostics::hasError((Diagnostics *)a2);
  BOOL v11 = 0;
  if (!hasError)
  {
    int v12 = *((_DWORD *)v17 + 6);
    if (!v12) {
      *a8 = 1;
    }
    BOOL v11 = v12 != 0;
  }
  _Block_object_dispose(&v16, 8);
  return v11;
}

uint64_t ___ZNK5dyld37FatFile18isFatFileWithSliceER11DiagnosticsyRKNS_11GradedArchsEbRyS6_Rb_block_invoke(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t result = dyld3::GradedArchs::grade(*(dyld3::GradedArchs **)(a1 + 48), a2, a3, *(unsigned char *)(a1 + 72));
  if (result)
  {
    if ((int)result > *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      unsigned int v10 = *(void **)(a1 + 64);
      **(void **)(a1 + 56) = a4 - v8;
      *unsigned int v10 = a5;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
    }
  }
  return result;
}

uint64_t dyld3::GradedArchs::forEachArch(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v5 = result;
  for (uint64_t i = 0; i != 4; ++i)
  {
    int v7 = *(_DWORD *)(v5 + 12 * i);
    if (!v7) {
      break;
    }
    if (*(unsigned char *)(v5 + 12 * i + 8)) {
      BOOL v8 = a2 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8)
    {
      uint64_t v9 = 0;
      while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v9 + 1]) != v7
           || (*(_DWORD *)(v5 + 12 * i + 4) & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v9 + 3))
      {
        v9 += 2;
        if (v9 == 26)
        {
          unsigned int v10 = "unknown";
          goto LABEL_13;
        }
      }
      unsigned int v10 = (&dyld3::MachOFile::_s_archInfos)[v9];
LABEL_13:
      uint64_t result = (*(uint64_t (**)(uint64_t, const char *))(a3 + 16))(a3, v10);
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::maskedCpuSubtype(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 2) & 0xFFFFFF;
}

void *dyld3::MachOFile::packedVersionToString(dyld3::MachOFile *this, unsigned char *a2, char *a3)
{
  __int16 v3 = (__int16)this;
  int v7 = a2;
  dyld3::appendNumber(&v7, (char **)(this >> 16));
  int v4 = v7;
  unsigned char *v7 = 46;
  int v7 = v4 + 1;
  uint64_t result = dyld3::appendNumber(&v7, (char **)HIBYTE(v3));
  if ((_BYTE)v3)
  {
    uint64_t v6 = v7;
    unsigned char *v7 = 46;
    int v7 = v6 + 1;
    uint64_t result = dyld3::appendNumber(&v7, (char **)v3);
  }
  unsigned char *v7 = 0;
  return result;
}

void *dyld3::appendNumber(void *this, char **a2)
{
  if (a2 >> 4 > 0x270)
  {
    __int16 v3 = (unsigned char *)(*this)++;
    unsigned char *v3 = a2 / 0x2710 + 48;
    LODWORD(a2) = a2 % 0x2710;
    if (a2 < 0x3E8)
    {
      int v4 = (unsigned char *)(*this)++;
      *int v4 = 48;
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v5 = (unsigned char *)(*this)++;
    *uint64_t v5 = a2 / 0x3E8 + 48;
    LODWORD(a2) = a2 % 0x3E8;
LABEL_10:
    if (a2 < 0x64)
    {
      uint64_t v6 = (unsigned char *)(*this)++;
      *uint64_t v6 = 48;
      goto LABEL_13;
    }
LABEL_12:
    int v7 = (unsigned char *)(*this)++;
    unsigned char *v7 = a2 / 0x64 + 48;
    LODWORD(a2) = a2 % 0x64;
LABEL_13:
    if (a2 < 0xA)
    {
      BOOL v8 = (unsigned char *)(*this)++;
      *BOOL v8 = 48;
      if (!a2) {
        goto LABEL_6;
      }
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (a2 >= 0x3E8) {
    goto LABEL_9;
  }
  if (a2 > 0x63) {
    goto LABEL_12;
  }
  if (a2 >= 0xA)
  {
LABEL_16:
    uint64_t v9 = (unsigned char *)(*this)++;
    unsigned char *v9 = a2 / 0xA + 48;
    LODWORD(a2) = a2 % 0xA;
    if (!a2) {
      goto LABEL_6;
    }
    goto LABEL_17;
  }
  if (!a2)
  {
LABEL_6:
    int v2 = (unsigned char *)(*this)++;
    *int v2 = 48;
    return this;
  }
LABEL_17:
  unsigned int v10 = (unsigned char *)(*this)++;
  *unsigned int v10 = (_BYTE)a2 + 48;
  return this;
}

BOOL dyld3::MachOFile::isFileSet(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 12;
}

const char *dyld3::MachOFile::platformName(int a1)
{
  uint64_t v2 = 0;
  uint64_t result = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v2 + 1]) != a1)
  {
    v2 += 2;
    if (v2 == 48) {
      return result;
    }
  }
  return (&dyld3::MachOFile::_s_platformInfos)[v2];
}

_DWORD *dyld3::MachOFile::isMachO(_DWORD *this, const void *a2)
{
  if (*this >> 1 != 2138504551) {
    return 0;
  }
  return this;
}

thread_command dyld3::MachOFile::entryAddrFromThreadCmd(dyld3::MachOFile *this, const thread_command *a2)
{
  if (a2->cmd != 5) {
    dyld3::MachOFile::entryAddrFromThreadCmd();
  }
  uint64_t v2 = 0;
  int v3 = *((_DWORD *)this + 1);
  if (v3 <= 16777222)
  {
    if (v3 == 7)
    {
      uint64_t v5 = 10;
    }
    else
    {
      if (v3 != 12) {
        return (thread_command)v2;
      }
      uint64_t v5 = 15;
    }
  }
  else if (v3 == 33554444 || v3 == 16777228)
  {
    uint64_t v5 = 32;
  }
  else
  {
    if (v3 != 16777223) {
      return (thread_command)v2;
    }
    uint64_t v5 = 16;
  }
  uint64_t v6 = a2 + 2;
  if (*(_DWORD *)this == -17958193 || dyld3::MachOFile::isArch(this, "arm64_32")) {
    return v6[v5];
  }
  else {
    return (thread_command)*(&v6->cmd + v5);
  }
}

uint64_t dyld3::MachOFile::usesWeakDefs(dyld3::MachOFile *this)
{
  return *((unsigned char *)this + 26) & 1;
}

uint64_t dyld3::MachOFile::hasInterposingTuples(dyld3::MachOFile *this)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile20hasInterposingTuplesEv_block_invoke;
  void v4[3] = &unk_1EFF66348;
  v4[4] = &v6;
  dyld3::MachOFile::forEachInterposingSection((int *)this, (uint64_t)&v5, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v7 + 24);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile20hasInterposingTuplesEv_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *a4 = 1;
  return result;
}

uint64_t dyld3::MachOFile::allowsAlternatePlatform(dyld3::MachOFile *this)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile23allowsAlternatePlatformEv_block_invoke;
  void v3[3] = &unk_1EFF663C0;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile23allowsAlternatePlatformEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__allow_alt_plat");
  if (!result)
  {
    uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!result)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::walkChain(vm_address_t *a1, unsigned int *a2, mach_o::ChainedFixupPointerOnDisk *this, char a4, unsigned int a5, uint64_t a6)
{
  int v9 = (int)this;
  int v12 = mach_o::ChainedFixupPointerOnDisk::strideSize(this);
  char v21 = 0;
  unsigned int v14 = *a2;
  unsigned int v13 = a2[1];
  (*(void (**)(uint64_t, unsigned int *, char *))(a6 + 16))(a6, a2, &v21);
  if (v21) {
    return 1;
  }
  while (2)
  {
    switch(v9)
    {
      case 1:
      case 7:
      case 9:
      case 10:
      case 12:
        int v15 = (v13 >> 19) & 0x7FF;
        if (!v15) {
          return 0;
        }
        goto LABEL_17;
      case 2:
      case 6:
        int v16 = (v13 >> 19) & 0xFFF;
        if (!v16) {
          return 0;
        }
        uint64_t v17 = (4 * v16);
        goto LABEL_18;
      case 3:
        int v18 = (v14 >> 26) & 0x1F;
        if (!v18) {
          return 0;
        }
        a2 = (unsigned int *)((char *)a2 + (4 * v18));
        if ((a4 & 1) == 0)
        {
          while (1)
          {
            unsigned int v19 = *a2;
            if ((*a2 & 0x80000000) != 0 || (v19 & 0x3FFFFFF) <= a5) {
              break;
            }
            a2 = (unsigned int *)((char *)a2 + (HIBYTE(v19) & 0x7CLL));
          }
        }
        goto LABEL_19;
      case 5:
        if (!(v14 >> 26)) {
          return 0;
        }
        uint64_t v17 = HIBYTE(v14) & 0xFC;
        goto LABEL_18;
      case 8:
      case 11:
        int v15 = (v13 >> 19) & 0xFFF;
        if (!v15) {
          return 0;
        }
        goto LABEL_17;
      case 13:
        int v15 = (v13 >> 20) & 0x7FF;
        if (v15)
        {
LABEL_17:
          uint64_t v17 = (v15 * v12);
LABEL_18:
          a2 = (unsigned int *)((char *)a2 + v17);
LABEL_19:
          unsigned int v14 = *a2;
          unsigned int v13 = a2[1];
          (*(void (**)(uint64_t, unsigned int *, char *))(a6 + 16))(a6, a2, &v21);
          if (v21) {
            return 1;
          }
          continue;
        }
        return 0;
      default:
        Diagnostics::error(a1, "unknown pointer format 0x%04X", v9);
        return 1;
    }
  }
}

uint64_t dyld3::MachOFile::read_sleb128(vm_address_t *this, const unsigned __int8 ***a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  uint64_t v4 = *a2;
  if (*a2 == a3)
  {
    uint64_t v6 = 0;
    int v7 = 0;
    unsigned int v9 = 0;
LABEL_7:
    Diagnostics::error(this, "malformed sleb128");
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = 0;
    int v7 = -7 * v4 - a3 + 8 * a3;
    while (1)
    {
      uint64_t v8 = (const unsigned __int8 **)((char *)v4 + 1);
      *a2 = (const unsigned __int8 **)((char *)v4 + 1);
      unsigned int v9 = *(unsigned __int8 *)v4;
      v6 |= (unint64_t)(v9 & 0x7F) << v5;
      if ((v9 & 0x80) == 0) {
        break;
      }
      v5 += 7;
      uint64_t v4 = (const unsigned __int8 **)((char *)v4 + 1);
      if (v8 == a3) {
        goto LABEL_7;
      }
    }
    int v7 = v5 + 7;
  }
  if (((v7 < 64) & (v9 >> 6)) != 0) {
    uint64_t v10 = -1 << v7;
  }
  else {
    uint64_t v10 = 0;
  }
  return v10 | v6;
}

uint64_t ___ZN5dyld39MachOFile15compatibleSliceER11DiagnosticsRyPKvmPKcNS_8PlatformEbRKNS_11GradedArchsEb_block_invoke(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return result;
}

void dyld3::MachOFile::forEachRPath(_DWORD *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile12forEachRPathEU13block_pointerFvPKcRbE_block_invoke;
  void v4[3] = &unk_1EFF66410;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v5, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v5);
  mach_o::Error::~Error(&v5);
}

uint64_t ___ZNK5dyld39MachOFile12forEachRPathEU13block_pointerFvPKcRbE_block_invoke(uint64_t result, _DWORD *a2)
{
  if (*a2 == -2147483620) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

uint64_t dyld3::MachOFile::dependentDylibCount(dyld3::MachOFile *this, BOOL *a2)
{
  uint64_t v10 = 0;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = 0;
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile19dependentDylibCountEPb_block_invoke;
  void v5[3] = &unk_1EFF66460;
  v5[4] = &v10;
  void v5[5] = &v6;
  dyld3::MachOFile::forEachDependentDylib(this, (uint64_t)v5);
  if (a2) {
    *a2 = *((unsigned char *)v7 + 24);
  }
  uint64_t v3 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(&v10, 8);
  return v3;
}

uint64_t ___ZNK5dyld39MachOFile19dependentDylibCountEPb_block_invoke(uint64_t result, uint64_t a2, char a3, char a4, int a5)
{
  if ((a3 & 1) != 0 || (a4 & 1) != 0 || a5) {
    *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  }
  return result;
}

uint64_t dyld3::MachOFile::getFixupsLoadCommandFileOffset(dyld3::MachOFile *this)
{
  Diagnostics::Diagnostics((Diagnostics *)&v9);
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld39MachOFile30getFixupsLoadCommandFileOffsetEv_block_invoke;
  void v4[3] = &unk_1EFF664B0;
  v4[4] = &v5;
  void v4[5] = this;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v4);
  uint64_t v2 = 0;
  if (!Diagnostics::hasError((Diagnostics *)&v9)) {
    uint64_t v2 = *((unsigned int *)v6 + 6);
  }
  _Block_object_dispose(&v5, 8);
  mach_o::Error::~Error(&v9);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile30getFixupsLoadCommandFileOffsetEv_block_invoke(uint64_t result, int *a2)
{
  int v2 = *a2;
  if (*a2 == -2147483614 || (v2 != 34 ? (BOOL v3 = v2 == -2147483596) : (BOOL v3 = 1), v3)) {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2 - *(_DWORD *)(result + 40);
  }
  return result;
}

BOOL dyld3::MachOFile::hasInitializer(dyld3::MachOFile *this, vm_address_t *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke;
  void v8[3] = &unk_1EFF664D8;
  void v8[4] = &v9;
  dyld3::MachOFile::forEachLoadCommand(this, a2, (uint64_t)v8);
  if (*((unsigned char *)v10 + 24)
    || (v7[0] = _NSConcreteStackBlock,
        v7[1] = 0x40000000,
        void v7[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_2,
        void v7[3] = &unk_1EFF66500,
        v7[4] = &v9,
        dyld3::MachOFile::forEachInitializerPointerSection(this, (uint64_t)a2, (uint64_t)v7),
        *((unsigned char *)v10 + 24)))
  {
    BOOL v4 = 1;
  }
  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    unsigned int v6[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_3;
    void v6[3] = &unk_1EFF66528;
    v6[4] = &v9;
    dyld3::MachOFile::forEachSection(this, (uint64_t)v6);
    BOOL v4 = *((unsigned char *)v10 + 24) != 0;
  }
  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke(uint64_t result, _DWORD *a2, unsigned char *a3)
{
  if (*a2 == 26 || *a2 == 17)
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *a4 = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_3(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(unsigned char *)(a2 + 92) == 22)
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke_2(uint64_t result, int a2, uint64_t a3, unsigned int a4)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  if (a2 == 1 && a4 >> 8 <= 0xA08) {
    *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t dyld3::MachOFile::forEachCodeDirectoryBlob(uint64_t result, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  if (a3 >= 0xC && *a2 == -1072898310)
  {
    unsigned int v5 = a2[2];
    unint64_t v6 = bswap32(v5);
    if (v6 <= (a3 - 12) >> 3)
    {
      uint64_t v9 = result;
      uint64_t result = dyld3::MachOFile::builtForPlatform((_DWORD *)result, 4, 0);
      uint64_t v10 = result ? dyld3::hash_rank_watchOS_dylibs : dyld3::hash_rank;
      if (v5)
      {
        uint64_t v11 = 0;
        if (*(_DWORD *)(v9 + 12) == 2) {
          int v12 = result;
        }
        else {
          int v12 = 0;
        }
        int v20 = v12;
        uint64_t result = a4 + 16;
        int v13 = a2 + 4;
        do
        {
          int v14 = *(v13 - 1);
          if (v14) {
            BOOL v15 = (v14 - 0x100000) > 0x5000000;
          }
          else {
            BOOL v15 = 0;
          }
          if (!v15)
          {
            unint64_t v16 = bswap32(*v13);
            if (a3 - 88 >= v16)
            {
              uint64_t v17 = (_DWORD *)((char *)a2 + v16);
              if (a3 - v16 >= bswap32(*(_DWORD *)((char *)a2 + v16 + 4)))
              {
                if (v20)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *))(a4 + 16))(a4, v17);
                }
                else if (*v17 == 34397946)
                {
                  if (!v11
                    || (unsigned int v19 = ((uint64_t (*)(_DWORD *))v10)(v17),
                        uint64_t result = ((uint64_t (*)(_DWORD *))v10)(v11),
                        v19 > result))
                  {
                    uint64_t v11 = v17;
                  }
                }
              }
            }
          }
          v13 += 2;
          --v6;
        }
        while (v6);
        if (v11)
        {
          int v18 = *(uint64_t (**)(uint64_t, _DWORD *))(a4 + 16);
          return v18(a4, v11);
        }
      }
    }
  }
  return result;
}

uint64_t dyld3::hash_rank_watchOS_dylibs(dyld3 *this, const CS_CodeDirectory *a2)
{
  uint64_t v2 = 0;
  while (dyld3::hashPriorities_watchOS_dylibs[v2] != *((unsigned __int8 *)this + 37))
  {
    if (++v2 == 4) {
      return 0;
    }
  }
  return (v2 + 1);
}

uint64_t dyld3::hash_rank(dyld3 *this, const CS_CodeDirectory *a2)
{
  uint64_t v2 = 0;
  while (dyld3::hashPriorities[v2] != *((unsigned __int8 *)this + 37))
  {
    if (++v2 == 4) {
      return 0;
    }
  }
  return (v2 + 1);
}

uint64_t dyld3::MachOFile::forEachCDHashOfCodeSignature(uint64_t a1, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld39MachOFile28forEachCDHashOfCodeSignatureEPKvmU13block_pointerFvPKhE_block_invoke;
  void v5[3] = &unk_1EFF66688;
  v5[4] = a4;
  return dyld3::MachOFile::forEachCodeDirectoryBlob(a1, a2, a3, (uint64_t)v5);
}

uint64_t ___ZNK5dyld39MachOFile28forEachCDHashOfCodeSignatureEPKvmU13block_pointerFvPKhE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  size_t v4 = bswap32(*(_DWORD *)(a2 + 4));
  int v5 = *(unsigned __int8 *)(a2 + 37);
  if ((v5 - 2) < 2)
  {
    unint64_t v6 = (unint64_t *)ccsha256_di();
  }
  else
  {
    if (v5 == 1)
    {
      int v18 = (unint64_t *)ccsha1_di();
      __chkstk_darwin((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, v29);
      int v27 = (void *)((char *)&v29 - v26);
      ccdigest_init(v28, (long long *)((char *)&v29 - v26));
      ccdigest_update(v18, v27, v4, (char *)a2);
      ((void (*)(unint64_t *, void *, long long *))v18[7])(v18, v27, &v31);
      cc_clear(v18[1] + v18[2] + 12, v27);
      return (*(uint64_t (**)(void))(*(void *)(v3 + 32) + 16))();
    }
    if (v5 != 4) {
      return result;
    }
    unint64_t v6 = (unint64_t *)ccsha384_di();
  }
  int v14 = v6;
  __chkstk_darwin((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, v29);
  unint64_t v16 = (void *)((char *)&v29 - v15);
  ccdigest_init(v17, (long long *)((char *)&v29 - v15));
  ccdigest_update(v14, v16, v4, (char *)a2);
  ((void (*)(unint64_t *, void *, long long *))v14[7])(v14, v16, &v29);
  cc_clear(v14[1] + v14[2] + 12, v16);
  int v32 = v30;
  long long v31 = v29;
  return (*(uint64_t (**)(void))(*(void *)(v3 + 32) + 16))();
}

uint64_t dyld3::MachOFile::forEachTreatAsWeakDef(uint64_t a1)
{
  for (uint64_t i = 0; i != 22; ++i)
    uint64_t result = (*(uint64_t (**)(uint64_t, char *))(a1 + 16))(a1, dyld3::sTreatAsWeak[i]);
  return result;
}

_DWORD *dyld3::MachOFile::PointerMetaData::PointerMetaData(_DWORD *this)
{
  *this &= 0xF0000000;
  return this;
}

uint64_t dyld3::MachOFile::hasObjCMessageReferences(dyld3::MachOFile *this)
{
  uint64_t v4 = 0;
  int v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___ZNK5dyld39MachOFile24hasObjCMessageReferencesEv_block_invoke;
  void v3[3] = &unk_1EFF66760;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile24hasObjCMessageReferencesEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
  if (!result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_msgrefs");
    if (!result)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      *a4 = 1;
    }
  }
  return result;
}

uint64_t dyld3::MachOFile::findObjCDataSection(dyld3::MachOFile *this, const char *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___ZNK5dyld39MachOFile19findObjCDataSectionEPKcRyS3__block_invoke;
  void v8[3] = &unk_1EFF66788;
  void v8[4] = &v9;
  void v8[5] = a2;
  void v8[6] = a3;
  void v8[7] = dyld3::MachOFile::preferredLoadAddress(this);
  void v8[8] = a4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v8);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t ___ZNK5dyld39MachOFile19findObjCDataSectionEPKcRyS3__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  char v7 = *(const char **)(a2 + 40);
  if (!_platform_strcmp(v7, "__DATA")
    || !_platform_strcmp(v7, "__DATA_CONST")
    || (uint64_t result = _platform_strcmp(v7, "__DATA_DIRTY"), !result))
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 40));
    if (!result)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      **(void **)(a1 + 48) = *(void *)(a2 + 64) - *(void *)(a1 + 56);
      **(void **)(a1 + 64) = *(void *)(a2 + 72);
      *a4 = 1;
    }
  }
  return result;
}

void dyld3::MachOFile::forEachSingletonPatch(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a1 == -17958193) {
    int v5 = 16;
  }
  else {
    int v5 = 8;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZNK5dyld39MachOFile21forEachSingletonPatchER11DiagnosticsU13block_pointerFvNS0_18SingletonPatchKindEyE_block_invoke;
  void v6[3] = &unk_1EFF667D8;
  int v7 = v5;
  void v6[5] = a2;
  void v6[6] = dyld3::MachOFile::preferredLoadAddress(a1);
  v6[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v6);
}

uint64_t ___ZNK5dyld39MachOFile21forEachSingletonPatchER11DiagnosticsU13block_pointerFvNS0_18SingletonPatchKindEyE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__const_cfobj2");
  if (!result)
  {
    *a4 = 1;
    unint64_t v8 = *(void *)(a2 + 72);
    unint64_t v9 = *(unsigned int *)(a1 + 56);
    if (v8 % v9)
    {
      return Diagnostics::error(*(vm_address_t **)(a1 + 40), "Incorrect patching size (%lld).  Should be a multiple of (2 * ptrSize)");
    }
    else if (*(_DWORD *)(a2 + 104) == v9)
    {
      if (v8)
      {
        uint64_t v10 = 0;
        do
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
          v10 += *(unsigned int *)(a1 + 56);
        }
        while (v10 != *(void *)(a2 + 72));
      }
    }
    else
    {
      return Diagnostics::error(*(vm_address_t **)(a1 + 40), "reserved2 is unsupported value %d.  Expected %d");
    }
  }
  return result;
}

size_t ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke(uint64_t a1, char *__source)
{
  uint64_t v4 = *(char **)(a1 + 32);
  if (*v4)
  {
    strlcat(v4, "' or '", 0x100uLL);
    uint64_t v4 = *(char **)(a1 + 32);
  }

  return strlcat(v4, __source, 0x100uLL);
}

uint64_t dyld3::MachOLoaded::hasExportedSymbol(dyld3::MachOFile *a1, const unsigned __int8 *a2, uint64_t a3, void *a4, unsigned char *a5)
{
  Diagnostics::Diagnostics((Diagnostics *)&v18);
  uint64_t ExportedSymbol = dyld3::MachOLoaded::findExportedSymbol(a1, (vm_address_t *)&v18, a2, 0, (uint64_t)&v14, a3);
  if (ExportedSymbol)
  {
    switch(v14)
    {
      case 2:
        *a4 = ((uint64_t (*)(void))((char *)v15 + v17))();
        *a5 = 1;
        break;
      case 1:
        *a4 = v16;
        *a5 = 0;
        break;
      case 0:
        uint64_t v11 = v15;
        *a4 = (char *)v15 + v16;
        *a5 = 0;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        v13[2] = ___ZNK5dyld311MachOLoaded17hasExportedSymbolEPKcU13block_pointerFPKS0_S4_jEPPvPb_block_invoke;
        void v13[3] = &__block_descriptor_tmp_36_2;
        uint64_t v13[4] = dyld3::MachOLoaded::getSlide(v11);
        void v13[5] = a4;
        void v13[6] = a5;
        dyld3::MachOFile::forEachSection(v15, (uint64_t)v13);
        break;
    }
  }
  mach_o::Error::~Error(&v18);
  return ExportedSymbol;
}

uint64_t dyld3::MachOLoaded::findExportedSymbol(dyld3::MachOFile *a1, vm_address_t *a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v49);
  if (Diagnostics::hasError((Diagnostics *)a2)) {
    return 0;
  }
  if (*((void *)&v49[0] + 1))
  {
    int v14 = (unsigned int *)(*((void *)&v49[0] + 1) + 12);
    uint64_t v15 = (_DWORD *)(*((void *)&v49[0] + 1) + 8);
    if (!a1)
    {
LABEL_18:
      *(void *)(a5 + 8) = 0;
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 0x40000000;
      long long v35 = v49[3];
      long long v36 = v49[4];
      long long v37 = v50;
      long long v38 = v51;
      long long v32 = v49[0];
      long long v33 = v49[1];
      v31[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_2;
      v31[3] = &__block_descriptor_tmp_43;
      v31[4] = a1;
      v31[5] = a3;
      v31[6] = a5;
      long long v34 = v49[2];
      dyld3::MachOLoaded::forEachGlobalSymbol(a1, a2, (uint64_t)v31);
      uint64_t v23 = *(void *)(a5 + 8);
      if (!v23)
      {
        uint64_t v45 = 0;
        uint64_t v46 = &v45;
        uint64_t v47 = 0x2000000000;
        int v48 = 0;
        v29[0] = _NSConcreteStackBlock;
        v29[1] = 0x40000000;
        void v29[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_3;
        v29[3] = &unk_1EFF668D0;
        v29[4] = a6;
        v29[5] = &v45;
        v29[6] = a1;
        v29[7] = a2;
        char v30 = a4;
        void v29[8] = a3;
        v29[9] = a5;
        dyld3::MachOFile::forEachDependentDylib(a1, (uint64_t)v29);
        _Block_object_dispose(&v45, 8);
        uint64_t v23 = *(void *)(a5 + 8);
      }
      return v23 != 0;
    }
  }
  else
  {
    if (!*(void *)&v49[0]) {
      goto LABEL_18;
    }
    int v14 = (unsigned int *)(*(void *)&v49[0] + 44);
    uint64_t v15 = (_DWORD *)(*(void *)&v49[0] + 40);
    if (!a1) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = (const unsigned __int8 **)((char *)a1 + *((void *)&v50 + 1) - v50 + (*v15 - v51));
  unsigned int v17 = (Diagnostics *)((char *)v16 + *v14);
  int v18 = dyld3::MachOFile::trieWalk(a2, v16, v17, a3, v12);
  if (!v18)
  {
    uint64_t v45 = 0;
    uint64_t v46 = &v45;
    uint64_t v47 = 0x2000000000;
    int v48 = 0;
    uint64_t v41 = 0;
    int8x16_t v42 = &v41;
    uint64_t v43 = 0x2000000000;
    char v44 = 0;
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 0x40000000;
    _OWORD v39[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke;
    v39[3] = &unk_1EFF66888;
    v39[4] = a6;
    void v39[5] = &v45;
    v39[8] = a2;
    v39[9] = a3;
    char v40 = a4;
    v39[10] = a5;
    void v39[6] = &v41;
    v39[7] = a1;
    dyld3::MachOFile::forEachDependentDylib(a1, (uint64_t)v39);
    BOOL v13 = *((unsigned char *)v42 + 24) != 0;
    _Block_object_dispose(&v41, 8);
    _Block_object_dispose(&v45, 8);
    return v13;
  }
  uint64_t v45 = v18;
  char v21 = dyld3::MachOFile::read_uleb128(a2, &v45, (const unsigned __int8 **)v17, v19);
  if ((v21 & 8) != 0)
  {
    if (a6)
    {
      unint64_t v25 = dyld3::MachOFile::read_uleb128(a2, &v45, (const unsigned __int8 **)v17, v20);
      int v26 = v25;
      if (*(unsigned char *)v45) {
        int v27 = v45;
      }
      else {
        int v27 = (const unsigned __int8 **)a3;
      }
      if (v25 && v25 <= dyld3::MachOFile::dependentDylibCount(a1, 0))
      {
        uint64_t v28 = (*(uint64_t (**)(uint64_t, dyld3::MachOFile *, void))(a6 + 16))(a6, a1, (v26 - 1));
        if (v28) {
          return dyld3::MachOLoaded::findExportedSymbol(v28, a2, v27, a4, a5, a6);
        }
        if ((a4 & 1) == 0) {
          Diagnostics::error(a2, "dependent dylib %lld not found for re-exported symbol %s");
        }
      }
      else
      {
        Diagnostics::error(a2, "re-export ordinal %lld out of range for %s");
      }
    }
    return 0;
  }
  *(_DWORD *)a5 = 0;
  *(_WORD *)(a5 + 4) = 0;
  *(void *)(a5 + 8) = a1;
  *(void *)(a5 + 16) = dyld3::MachOFile::read_uleb128(a2, &v45, (const unsigned __int8 **)v17, v20);
  *(_DWORD *)(a5 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  *(void *)(a5 + 32) = a3;
  BOOL v13 = 0;
  if (Diagnostics::hasError((Diagnostics *)a2)) {
    return v13;
  }
  if ((v21 & 3) == 2)
  {
    BOOL v13 = 1;
    *(_DWORD *)a5 = 1;
    return v13;
  }
  if ((v21 & 3) == 1)
  {
    BOOL v13 = 1;
    *(unsigned char *)(a5 + 4) = 1;
    return v13;
  }
  if ((v21 & 3) != 0)
  {
    Diagnostics::error(a2, "unsupported exported symbol kind. flags=%llu at node offset=0x%0lX");
    return 0;
  }
  *(_DWORD *)a5 = 0;
  if ((v21 & 0x10) != 0) {
    *(_DWORD *)(a5 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = dyld3::MachOFile::read_uleb128(a2, &v45, (const unsigned __int8 **)v17, v22);
  }
  BOOL v13 = 1;
  if ((v21 & 4) != 0) {
    *(unsigned char *)(a5 + 5) = 1;
  }
  return v13;
}

uint64_t ___ZNK5dyld311MachOLoaded17hasExportedSymbolEPKcU13block_pointerFPKS0_S4_jEPPvPb_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unint64_t v4 = *(void *)(result + 32) + *(void *)(a2 + 64);
  unint64_t v5 = **(void **)(result + 40);
  if (v4 <= v5 && *(void *)(a2 + 72) + v4 > v5)
  {
    **(unsigned char **)(result + 48) = (*(_DWORD *)(a2 + 92) & 0x80000400) != 0;
    *a4 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  uint64_t v8 = result;
  if (a4)
  {
    uint64_t result = *(void *)(result + 32);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(result + 16))(result, *(void *)(v8 + 56), *(unsigned int *)(*(void *)(*(void *)(v8 + 40) + 8) + 24));
      if (result)
      {
        uint64_t result = dyld3::MachOLoaded::findExportedSymbol(result, *(void *)(v8 + 64), *(void *)(v8 + 72), *(unsigned __int8 *)(v8 + 88), *(void *)(v8 + 80), *(void *)(v8 + 32));
        if (result)
        {
          *a8 = 1;
          *(unsigned char *)(*(void *)(*(void *)(v8 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
        }
      }
    }
  }
  ++*(_DWORD *)(*(void *)(*(void *)(v8 + 40) + 8) + 24);
  return result;
}

uint64_t dyld3::MachOLoaded::forEachGlobalSymbol(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v22);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    uint64_t result = dyld3::MachOFile::is64(a1);
    if (v23)
    {
      int v7 = result;
      if (v24)
      {
        int v8 = *(_DWORD *)(v24 + 16);
        unint64_t v9 = (unsigned int *)(v24 + 20);
      }
      else
      {
        int v8 = 0;
        unint64_t v9 = v23 + 3;
      }
      unint64_t v10 = *v9;
      unsigned int v11 = v23[5];
      if (v10)
      {
        uint64_t v12 = v25 + v26 + (v23[4] - v27);
        uint64_t v13 = v25 + v26 + (v23[2] - v27);
        unint64_t v14 = 1;
        int v15 = v8;
        while (1)
        {
          uint64_t v16 = (v15 + v14 - 1);
          if (v7)
          {
            uint64_t v17 = *(unsigned int *)(v13 + 16 * v16);
            if (v17 <= v11)
            {
              uint64_t v18 = v13 + 16 * v16;
              if ((*(unsigned char *)(v18 + 4) & 0xEF) == 0xF)
              {
                uint64_t v19 = v12 + v17;
                uint64_t v20 = *(void *)(v18 + 8);
LABEL_15:
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v19, v20);
              }
            }
          }
          else
          {
            uint64_t v21 = *(unsigned int *)(v13 + 12 * v16);
            if (v21 <= v11 && (*(unsigned char *)(v13 + 12 * v16 + 4) & 0xEF) == 0xF)
            {
              uint64_t v19 = v12 + v21;
              uint64_t v20 = *(unsigned int *)(v13 + 12 * v16 + 8);
              goto LABEL_15;
            }
          }
          if (v14 >= v10) {
            return result;
          }
          ++v14;
        }
      }
    }
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_2(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned char *a7)
{
  uint64_t result = _platform_strcmp(__s1, *(const char **)(a1 + 40));
  if (!result)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 48);
    *(_DWORD *)uint64_t v12 = 0;
    *(unsigned char *)(v12 + 4) = 0;
    *(void *)(v12 + 8) = v11;
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 48);
    *(void *)(v13 + 16) = a3 - *(void *)(a1 + 136);
    *(_DWORD *)(v13 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    *(void *)(v13 + 32) = v14;
    *a7 = 1;
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_3(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  uint64_t v8 = result;
  if (a4)
  {
    uint64_t result = *(void *)(result + 32);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(result + 16))(result, *(void *)(v8 + 48), *(unsigned int *)(*(void *)(*(void *)(v8 + 40) + 8) + 24));
      if (result)
      {
        uint64_t result = dyld3::MachOLoaded::findExportedSymbol(result, *(void *)(v8 + 56), *(void *)(v8 + 64), *(unsigned __int8 *)(v8 + 80), *(void *)(v8 + 72), *(void *)(v8 + 32));
        if (result) {
          *a8 = 1;
        }
      }
    }
  }
  ++*(_DWORD *)(*(void *)(*(void *)(v8 + 40) + 8) + 24);
  return result;
}

uint64_t dyld3::MachOLoaded::segmentName(dyld3::MachOLoaded *this, int a2)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld311MachOLoaded11segmentNameEj_block_invoke;
  void v4[3] = &unk_1EFF66920;
  int v5 = a2;
  v4[4] = &v6;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v4);
  uint64_t v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld311MachOLoaded11segmentNameEj_block_invoke(uint64_t result, uint64_t a2, unsigned char *a3)
{
  if (*(_DWORD *)(result + 40) == (unsigned __int16)*(_DWORD *)(a2 + 56) >> 4)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a2 + 40);
    *a3 = 1;
  }
  return result;
}

uint64_t dyld3::MachOLoaded::fixupAllChainedFixups(uint64_t a1, vm_address_t *a2, unsigned int *a3, uint64_t a4, long long *a5, uint64_t a6)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = ___ZNK5dyld311MachOLoaded21fixupAllChainedFixupsER11DiagnosticsPK28dyld_chained_starts_in_imagemNS_5ArrayIPKvEEU13block_pointerFvPvSA_E_block_invoke;
  void v7[3] = &unk_1EFF66998;
  long long v8 = *a5;
  uint64_t v9 = *((void *)a5 + 2);
  unint64_t v10 = a2;
  uint64_t v11 = a4;
  v7[4] = a6;
  void v7[5] = a1;
  return dyld3::MachOLoaded::forEachFixupInAllChains(a1, a2, a3, 1, (uint64_t)v7);
}

uint64_t dyld3::MachOLoaded::forEachFixupInAllChains(uint64_t result, vm_address_t *a2, unsigned int *a3, char a4, uint64_t a5)
{
  unint64_t v5 = *a3;
  if (v5)
  {
    uint64_t v10 = result;
    uint64_t v11 = 1;
    do
    {
      uint64_t v12 = a3[v11];
      if (v12)
      {
        uint64_t result = dyld3::MachOLoaded::forEachFixupInSegmentChains(v10, a2, (uint64_t)a3 + v12, a4, a5);
        unint64_t v5 = *a3;
      }
      ++v11;
    }
    while (v11 - 1 < v5);
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded21fixupAllChainedFixupsER11DiagnosticsPK28dyld_chained_starts_in_imagemNS_5ArrayIPKvEEU13block_pointerFvPvSA_E_block_invoke(uint64_t a1, mach_o::ChainedFixupPointerOnDisk::Arm64e *this, uint64_t a3, unsigned char *a4)
{
  unsigned int v6 = *(unsigned __int16 *)(a3 + 6);
  if (v6 > 0xC) {
    goto LABEL_18;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (((1 << v6) & 0x1282) == 0)
  {
    if (((1 << v6) & 0x44) != 0)
    {
      uint64_t v11 = *(void *)this;
      if ((*(void *)this & 0x8000000000000000) == 0)
      {
        if (v6 == 2)
        {
          unint64_t v10 = mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(this);
          goto LABEL_11;
        }
        unint64_t v23 = mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(this);
LABEL_30:
        uint64_t v12 = v23 + v8;
        goto LABEL_31;
      }
      if ((v11 & 0xFFFFFFuLL) < *(void *)(a1 + 64))
      {
        uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 8 * (v11 & 0xFFFFFF));
        unint64_t v18 = mach_o::ChainedFixupPointerOnDisk::Generic64::signExtendedAddend(this);
        goto LABEL_21;
      }
      uint64_t v22 = *(vm_address_t **)(a1 + 72);
      goto LABEL_35;
    }
LABEL_18:
    uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 72), "unsupported pointer chain format: 0x%04X");
LABEL_36:
    *a4 = 1;
    return result;
  }
  uint64_t v9 = *(void *)this;
  if ((*(void *)this & 0x8000000000000000) != 0)
  {
    if ((v9 & 0x4000000000000000) != 0)
    {
      BOOL v14 = v6 == 12;
      uint64_t v20 = 0xFFFFLL;
      if (v14) {
        uint64_t v20 = 0xFFFFFFLL;
      }
      unint64_t v21 = v9 & v20;
      if (v21 >= *(void *)(a1 + 64))
      {
LABEL_27:
        uint64_t v22 = *(vm_address_t **)(a1 + 72);
LABEL_35:
        uint64_t result = Diagnostics::error(v22, "out of range bind ordinal %d (max %llu)");
        goto LABEL_36;
      }
      uint64_t v13 = *(mach_o::ChainedFixupPointerOnDisk::Arm64e **)(*(void *)(a1 + 48) + 8 * v21);
      if (!v13)
      {
        uint64_t v12 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v13 = (mach_o::ChainedFixupPointerOnDisk::Arm64e *)(v8 + v9);
    }
    uint64_t v12 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(this, (unint64_t)this, v13);
    goto LABEL_31;
  }
  if ((v9 & 0x4000000000000000) != 0)
  {
    BOOL v14 = v6 == 12;
    uint64_t v15 = 0xFFFFLL;
    if (v14) {
      uint64_t v15 = 0xFFFFFFLL;
    }
    unint64_t v16 = v9 & v15;
    if (v16 < *(void *)(a1 + 64))
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 8 * v16);
      unint64_t v18 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend(this);
LABEL_21:
      uint64_t v12 = v18 + v17;
      goto LABEL_31;
    }
    goto LABEL_27;
  }
  if (v6 != 1)
  {
    unint64_t v23 = mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(this);
    goto LABEL_30;
  }
  unint64_t v10 = mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(this);
LABEL_11:
  uint64_t v12 = *(void *)(a1 + 80) + v10;
LABEL_31:
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, mach_o::ChainedFixupPointerOnDisk::Arm64e *, uint64_t))(result + 16))(result, this, v12);
  }
  *(void *)this = v12;
  return result;
}

uint64_t dyld3::MachOLoaded::forEachFixupInSegmentChains(uint64_t result, vm_address_t *a2, uint64_t a3, char a4, uint64_t a5)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = ___ZNK5dyld311MachOLoaded27forEachFixupInSegmentChainsER11DiagnosticsPK30dyld_chained_starts_in_segmentbU13block_pointerFvPN6mach_o25ChainedFixupPointerOnDiskES5_RbE_block_invoke;
  void v13[3] = &unk_1EFF669C0;
  uint64_t v13[4] = a5;
  void v13[5] = a3;
  if (*(_WORD *)(a3 + 20))
  {
    uint64_t v8 = result;
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(unsigned __int16 *)(a3 + 2 * v9 + 22);
      if (v10 == 0xFFFF)
      {
        uint64_t result = 0;
      }
      else if ((v10 & 0x8000) != 0)
      {
        unsigned int v11 = v10 & 0x7FFF;
        do
        {
          __int16 v12 = *(_WORD *)(a3 + 2 * v11 + 22);
          uint64_t result = dyld3::MachOFile::walkChain(a2, (unsigned int *)(v8 + *(void *)(a3 + 8) + v9 * *(unsigned __int16 *)(a3 + 4) + (v12 & 0x7FFF)), (mach_o::ChainedFixupPointerOnDisk *)*(unsigned __int16 *)(a3 + 6), a4, *(_DWORD *)(a3 + 16), (uint64_t)v13);
          if (v12 < 0) {
            break;
          }
          ++v11;
        }
        while ((result & 1) == 0);
      }
      else
      {
        uint64_t result = dyld3::MachOFile::walkChain(a2, (unsigned int *)(v8 + *(void *)(a3 + 8) + v9 * *(unsigned __int16 *)(a3 + 4) + v10), (mach_o::ChainedFixupPointerOnDisk *)*(unsigned __int16 *)(a3 + 6), a4, *(_DWORD *)(a3 + 16), (uint64_t)v13);
      }
      ++v9;
    }
    while (v9 < *(unsigned __int16 *)(a3 + 20) && (result & 1) == 0);
  }
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded27forEachFixupInSegmentChainsER11DiagnosticsPK30dyld_chained_starts_in_segmentbU13block_pointerFvPN6mach_o25ChainedFixupPointerOnDiskES5_RbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2, *(void *)(a1 + 40), a3);
}

uint64_t mach_o::Layout::textUnslidVMAddr(mach_o::Layout *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (_DWORD *)*((void *)this + 1);
  uint64_t v3 = 48 * v1;
  while (v2[11] != 1)
  {
    v2 += 12;
    v3 -= 48;
    if (!v3) {
      return 0;
    }
  }
  return *(void *)v2;
}

uint64_t mach_o::SymbolTable::forEachGlobalSymbol(dyld3::MachOFile ***a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = dyld3::MachOFile::is64(**a1);
  unsigned int v6 = (*a1)[3];
  if (*((unsigned char *)v6 + 220))
  {
    int v7 = result;
    int v8 = *((unsigned __int8 *)v6 + 156);
    if (*((unsigned char *)v6 + 156))
    {
      int v8 = *((_DWORD *)v6 + 37);
      unint64_t v9 = (unsigned int *)((char *)v6 + 152);
    }
    else
    {
      unint64_t v9 = (unsigned int *)((char *)v6 + 216);
    }
    unint64_t v10 = *v9;
    unsigned int v11 = *((_DWORD *)v6 + 60);
    uint64_t v12 = *((void *)v6 + 29);
    uint64_t v13 = *((void *)v6 + 25);
    char v22 = 0;
    if (v10)
    {
      unint64_t v14 = 1;
      int v15 = v8;
      while (1)
      {
        uint64_t v16 = (v15 + v14 - 1);
        if (v7)
        {
          uint64_t v17 = *(unsigned int *)(v13 + 16 * v16);
          if (v17 > v11) {
            goto LABEL_15;
          }
          uint64_t v18 = v13 + 16 * v16;
          if ((*(unsigned char *)(v18 + 4) & 0xEF) != 0xF) {
            goto LABEL_15;
          }
          uint64_t v19 = v12 + v17;
          uint64_t v20 = *(void *)(v18 + 8);
        }
        else
        {
          uint64_t v21 = *(unsigned int *)(v13 + 12 * v16);
          if (v21 > v11 || (*(unsigned char *)(v13 + 12 * v16 + 4) & 0xEF) != 0xF) {
            goto LABEL_15;
          }
          uint64_t v19 = v12 + v21;
          uint64_t v20 = *(unsigned int *)(v13 + 12 * v16 + 8);
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v19, v20);
LABEL_15:
        if (v14 < v10)
        {
          ++v14;
          if (!v22) {
            continue;
          }
        }
        return result;
      }
    }
  }
  return result;
}

void mach_o::Fixups::forEachBindTarget_Opcodes(dyld3::MachOFile ***a1, Diagnostics *a2, char a3, uint64_t a4, uint64_t a5)
{
  v9[0] = 0;
  v9[1] = v9;
  unsigned int v9[2] = 0x2000000000;
  int v10 = -1;
  v7[0] = 0;
  v7[1] = v7;
  void v7[2] = 0x2000000000;
  int v8 = -1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke;
  void v6[3] = &unk_1EFF66AD0;
  v6[4] = a4;
  void v6[5] = v9;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2;
  void v5[3] = &unk_1EFF66AF8;
  v5[4] = a5;
  void v5[5] = v7;
  mach_o::Fixups::forEachBindUnified_Opcodes(a1, a2, a3, (uint64_t)v6, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(v9, 8);
}

uint64_t ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 32;
  uint64_t v3 = *(void *)(a1 + 32);
  int v7 = *(_DWORD *)(*(void *)(*(void *)(v4 + 8) + 8) + 24);
  int v8 = -3;
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  __int16 v11 = 0;
  char v6 = 0;
  uint64_t result = (*(uint64_t (**)(void))(v3 + 16))();
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t mach_o::Fixups::parseOrgArm64eChainedFixups(dyld3::MachOFile ***a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v32 = 0;
  uint64_t result = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  __int16 v11 = (*a1)[3];
  if (*((unsigned char *)v11 + 316))
  {
    unsigned int v26 = result;
    unsigned __int8 v27 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    char v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v28 = 0;
    uint64_t v15 = 0;
    long long v31 = (const unsigned __int8 **)*((void *)v11 + 37);
    uint64_t v16 = (const unsigned __int8 **)((char *)v31 + *((unsigned int *)v11 + 76));
    while (2)
    {
      if (Diagnostics::noError((Diagnostics *)a2))
      {
        uint64_t v18 = v31;
        if (v31 < v16)
        {
          uint64_t v19 = (char *)v31 + 1;
          unsigned int v20 = *(unsigned __int8 *)v31;
          int v21 = v20 & 0xF;
          long long v31 = (const unsigned __int8 **)((char *)v31 + 1);
          uint64_t v22 = v20 & 0xF;
          switch(v20 >> 4)
          {
            case 0u:
              goto LABEL_6;
            case 1u:
              char v12 = 1;
              uint64_t v22 = v15;
              uint64_t v13 = v20 & 0xF;
              goto LABEL_31;
            case 2u:
              uint64_t v13 = dyld3::MachOFile::read_uleb128(a2, &v31, v16, v17);
              goto LABEL_12;
            case 3u:
              if ((v20 & 0xF) != 0) {
                uint64_t v13 = v20 | 0xFFFFFFF0;
              }
              else {
                uint64_t v13 = 0;
              }
LABEL_12:
              char v12 = 1;
              goto LABEL_30;
            case 4u:
              if (*v19)
              {
                unint64_t v23 = (const unsigned __int8 **)((char *)v18 + 2);
                do
                {
                  long long v31 = v23;
                  int v24 = *(unsigned __int8 *)v23;
                  unint64_t v23 = (const unsigned __int8 **)((char *)v23 + 1);
                }
                while (v24);
                uint64_t v18 = (const unsigned __int8 **)((char *)v23 - 2);
              }
              BYTE4(v29) = v20 & 1;
              long long v31 = (const unsigned __int8 **)((char *)v18 + 2);
              uint64_t v22 = v15;
              unint64_t v14 = v19;
              goto LABEL_31;
            case 5u:
              goto LABEL_31;
            case 6u:
              uint64_t v30 = dyld3::MachOFile::read_sleb128(a2, &v31, v16, v17);
              goto LABEL_30;
            case 7u:
              uint64_t v28 = dyld3::MachOFile::read_uleb128(a2, &v31, v16, v17);
              LOBYTE(v29) = 1;
              uint64_t v22 = v15;
              unsigned __int8 v27 = v21;
              goto LABEL_31;
            case 9u:
              if (a4) {
                (*(void (**)(uint64_t, void, void, uint64_t, void, unsigned char *, uint64_t, void, char *))(a4 + 16))(a4, v12 & 1, v26, v13, v15, v14, v30, BYTE4(v29) & 1, &v32);
              }
              goto LABEL_30;
            case 0xDu:
              if (v21 == 1)
              {
                if (a5) {
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, char *))(a5 + 16))(a5, v27, v29 & 1, v28, 1, &v32);
                }
              }
              else if ((v20 & 0xF) != 0)
              {
                Diagnostics::error(a2, "bad BIND_OPCODE_THREADED sub-opcode 0x%02X");
              }
              else
              {
                unint64_t v25 = dyld3::MachOFile::read_uleb128(a2, &v31, v16, v17);
                if (v25 < 0x10000)
                {
                  if (a3) {
                    (*(void (**)(uint64_t, unint64_t, char *))(a3 + 16))(a3, v25, &v32);
                  }
                }
                else
                {
                  Diagnostics::error(a2, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size too large");
LABEL_6:
                  char v32 = 1;
                }
              }
              goto LABEL_30;
            default:
              Diagnostics::error(a2, "bad bind opcode 0x%02X");
LABEL_30:
              uint64_t v22 = v15;
LABEL_31:
              uint64_t v15 = v22;
              if (v32) {
                return Diagnostics::hasError((Diagnostics *)a2);
              }
              continue;
          }
        }
      }
      return Diagnostics::hasError((Diagnostics *)a2);
    }
  }
  return result;
}

uint64_t ___ZNK6mach_o6Fixups25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void mach_o::Fixups::forEachBindUnified_Opcodes(dyld3::MachOFile ***a1, Diagnostics *a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  int v20 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x4802000000;
  uint64_t v15 = __Block_byref_object_copy__60;
  uint64_t v16 = __Block_byref_object_dispose__61;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  _OWORD v10[2] = ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke;
  void v10[3] = &unk_1EFF66A60;
  void v10[6] = &v17;
  void v10[7] = a1;
  char v11 = a3;
  void v10[4] = a4;
  v10[5] = &v12;
  if (!mach_o::Fixups::forEachBind_OpcodesRegular(a1, a2, (uint64_t)v10))
  {
    BOOL v8 = mach_o::Fixups::forEachBind_OpcodesLazy(a1, a2, (uint64_t)v10);
    _Block_object_dispose(&v12, 8);
    _Block_object_dispose(&v17, 8);
    if (v8) {
      return;
    }
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    int v20 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x4802000000;
    uint64_t v15 = __Block_byref_object_copy__60;
    uint64_t v16 = __Block_byref_object_dispose__61;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    unsigned int v9[2] = ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke_2;
    void v9[3] = &unk_1EFF66A88;
    void v9[6] = &v17;
    void v9[7] = a1;
    void v9[4] = a5;
    void v9[5] = &v12;
    mach_o::Fixups::forEachBind_OpcodesWeak(a1, a2, (uint64_t)v9, (uint64_t)&__block_literal_global_3);
  }
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v17, 8);
}

__n128 __Block_byref_object_copy__60(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

uint64_t ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char a13, uint64_t a14, char a15, uint64_t a16)
{
  uint64_t v16 = **(void **)(a1 + 56);
  uint64_t v18 = *(uint64_t **)(v16 + 8);
  uint64_t v17 = *(void *)(v16 + 16);
  if (v17)
  {
    v17 *= 48;
    uint64_t v19 = v18;
    while (*((_DWORD *)v19 + 11) != 1)
    {
      v19 += 6;
      v17 -= 48;
      if (!v17) {
        goto LABEL_7;
      }
    }
    uint64_t v17 = *v19;
  }
LABEL_7:
  uint64_t v20 = v18[6 * a8];
  if (a15)
  {
    uint64_t v21 = *(void *)(*(void *)(a1 + 48) + 8);
    int v22 = *(_DWORD *)(v21 + 24);
    *(_DWORD *)(v21 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v22 + 1;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 4dyld4::halt("obsolete dyld API called", 0) = v22;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 44) = a6;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = a11;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56) = a14;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 64) = a12;
    if (a13) {
      BOOL v23 = *(unsigned char *)(a1 + 64) != 0;
    }
    else {
      BOOL v23 = 0;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 65) = v23;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v20 + a9 - v17, a8, *(void *)(*(void *)(a1 + 40) + 8) + 40, a16);
}

BOOL mach_o::Fixups::forEachBind_OpcodesRegular(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3)
{
  if (!*((unsigned char *)(*a1)[3] + 316)) {
    return 0;
  }
  unsigned int v6 = dyld3::MachOFile::pointerSize(**a1);
  char v41 = 0;
  unsigned int v34 = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  char v36 = 0;
  uint64_t v39 = 0;
  LOBYTE(v7) = 0;
  char v8 = 0;
  char v9 = 0;
  char v37 = 0;
  uint64_t v10 = 0;
  long long v35 = 0;
  unsigned __int8 v33 = 0;
  uint64_t v11 = 0;
  char v38 = 0;
  uint64_t v12 = (*a1)[3];
  char v40 = (const unsigned __int8 **)*((void *)v12 + 37);
  uint64_t v13 = (const unsigned __int8 **)((char *)v40 + *((unsigned int *)v12 + 76));
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v15 = v40;
    if ((v40 >= v13) | v7 & 1) {
      break;
    }
    uint64_t v16 = (unsigned __int8 *)v40 + 1;
    unsigned int v17 = *(unsigned __int8 *)v40;
    char v40 = (const unsigned __int8 **)((char *)v40 + 1);
    int v18 = v17 & 0xF;
    LOBYTE(v7) = 1;
    switch(v17 >> 4)
    {
      case 0u:
        break;
      case 1u:
        LOBYTE(v7) = 0;
        char v9 = 1;
        uint64_t v10 = v17 & 0xF;
        break;
      case 2u:
        uint64_t v10 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v40, v13, v14);
        LOBYTE(v7) = 0;
        goto LABEL_12;
      case 3u:
        LOBYTE(v7) = 0;
        if ((v17 & 0xF) != 0) {
          uint64_t v10 = v17 | 0xFFFFFFF0;
        }
        else {
          uint64_t v10 = 0;
        }
LABEL_12:
        char v9 = 1;
        break;
      case 4u:
        if (*v16)
        {
          uint64_t v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            char v40 = v19;
            int v20 = *(unsigned __int8 *)v19;
            uint64_t v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }
          while (v20);
          uint64_t v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }
        LOBYTE(v7) = 0;
        char v36 = v17 & 1;
        char v40 = (const unsigned __int8 **)((char *)v15 + 2);
        char v8 = 1;
        long long v35 = v16;
        break;
      case 5u:
        LOBYTE(v7) = 0;
        char v38 = v17 & 0xF;
        break;
      case 6u:
        uint64_t v39 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v40, v13, v14);
        LOBYTE(v7) = 0;
        char v8 = 1;
        break;
      case 7u:
        uint64_t v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v40, v13, v14);
        LOBYTE(v7) = 0;
        char v37 = 1;
        unsigned __int8 v33 = v18;
        break;
      case 8u:
        LOBYTE(v7) = 0;
        v11 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v40, v13, v14);
        break;
      case 9u:
        LOBYTE(v3dyld4::halt("obsolete dyld API called", 0) = v8;
        LOWORD(v29) = v36 & 1;
        LOBYTE(v28) = v38;
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, void, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v37 & 1, v9 & 1, v34, v10, v6, v33, v11, v28, v35, v29, v39, v30, &v41);
        char v8 = 0;
        LOBYTE(v7) = 0;
        v11 += v6;
        break;
      case 0xAu:
        LOBYTE(v3dyld4::halt("obsolete dyld API called", 0) = v8;
        LOWORD(v29) = v36 & 1;
        LOBYTE(v28) = v38;
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, void, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", v37 & 1, v9 & 1, v34, v10, v6, v33, v11, v28, v35, v29, v39, v30, &v41);
        char v8 = 0;
        LOBYTE(v7) = 0;
        v11 += v6 + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v40, v13, v21);
        break;
      case 0xBu:
        LOBYTE(v3dyld4::halt("obsolete dyld API called", 0) = v8;
        LOWORD(v29) = v36 & 1;
        LOBYTE(v28) = v38;
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, void, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", v37 & 1, v9 & 1, v34, v10, v6, v33, v11, v28, v35, v29, v39, v30, &v41);
        char v8 = 0;
        LOBYTE(v7) = 0;
        v11 += v6 + v6 * v18;
        break;
      case 0xCu:
        unint64_t v7 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v40, v13, v14);
        uint64_t v23 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v40, v13, v22);
        if (v7)
        {
          long long v31 = v13;
          char v32 = a2;
          uint64_t v24 = v23 + v6;
          unsigned int v25 = 1;
          do
          {
            LOBYTE(v3dyld4::halt("obsolete dyld API called", 0) = v8;
            LOWORD(v29) = v36 & 1;
            LOBYTE(v28) = v38;
            (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, void, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", v37 & 1, v9 & 1, v34, v10, v6, v33, v11, v28, v35, v29, v39, v30, &v41);
            char v8 = 0;
            v11 += v24;
            if (v41) {
              break;
            }
            unint64_t v26 = v25++;
          }
          while (v7 > v26);
          LOBYTE(v7) = 0;
          uint64_t v13 = v31;
          a2 = v32;
        }
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X", *v16);
        LOBYTE(v7) = 0;
        break;
    }
  }
  while (!v41);
  return v41 != 0;
}

BOOL mach_o::Fixups::forEachBind_OpcodesLazy(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3)
{
  if (!*((unsigned char *)(*a1)[3] + 380)) {
    return 0;
  }
  unsigned int v6 = dyld3::MachOFile::pointerSize(**a1);
  char v29 = 0;
  unsigned int v25 = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  char v7 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  char v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = (*a1)[3];
  uint64_t v13 = (const unsigned __int8 **)(*((void *)v12 + 45) + *((unsigned int *)v12 + 92));
  int v28 = (const unsigned __int8 **)*((void *)v12 + 45);
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v15 = v28;
    if (v28 >= v13) {
      break;
    }
    uint64_t v16 = (char *)v28 + 1;
    unsigned __int8 v17 = *(unsigned char *)v28;
    int v28 = (const unsigned __int8 **)((char *)v28 + 1);
    char v18 = v17 & 0xF;
    switch(v17 >> 4)
    {
      case 0:
        break;
      case 1:
        char v8 = 1;
        uint64_t v9 = v17 & 0xF;
        break;
      case 2:
        uint64_t v9 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v28, v13, v14);
        goto LABEL_11;
      case 3:
        if ((v17 & 0xF) != 0) {
          uint64_t v9 = *(_DWORD *)&v17 | 0xFFFFFFF0;
        }
        else {
          uint64_t v9 = 0;
        }
LABEL_11:
        char v8 = 1;
        break;
      case 4:
        if (*v16)
        {
          uint64_t v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            int v28 = v19;
            int v20 = *(unsigned __int8 *)v19;
            uint64_t v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }
          while (v20);
          uint64_t v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }
        char v7 = v17 & 1;
        int v28 = (const unsigned __int8 **)((char *)v15 + 2);
        uint64_t v10 = v16;
        break;
      case 6:
        uint64_t v27 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v28, v13, v14);
        break;
      case 7:
        uint64_t v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v28, v13, v14);
        LOBYTE(v26) = v18;
        BYTE4(v26) = 1;
        break;
      case 9:
        LOBYTE(v++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
        BYTE1(v23) = 1;
        LOBYTE(v23) = v7 & 1;
        LOBYTE(v22) = 1;
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, void, void, uint64_t, int, unsigned char *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", BYTE4(v26) & 1, v8 & 1, v25, v9, v6, v26, v11, v22, v10, v23, v27, v24, &v29);
        v11 += v6;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad lazy bind opcode 0x%02X", v17 & 0xF0);
        break;
    }
  }
  while (!v29);
  return v29 != 0;
}

uint64_t ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13 = **(void **)(a1 + 56);
  uint64_t v15 = *(void *)(v13 + 8);
  uint64_t v14 = *(void *)(v13 + 16);
  if (v14)
  {
    uint64_t v16 = 48 * v14;
    uint64_t v17 = v15;
    do
    {
      if (*(_DWORD *)(v17 + 44) == 1) {
        break;
      }
      v17 += 48;
      v16 -= 48;
    }
    while (v16);
  }
  uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(void *)(v18 + 48) != a11 || *(void *)(v18 + 56) != a13)
  {
    uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8);
    int v20 = *(_DWORD *)(v19 + 24);
    *(_DWORD *)(v19 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v20 + 1;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 4dyld4::halt("obsolete dyld API called", 0) = v20;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 44) = -3;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = a11;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56) = a13;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 64) = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 65) = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

BOOL mach_o::Fixups::forEachBind_OpcodesWeak(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3, uint64_t a4)
{
  if (!*((unsigned char *)(*a1)[3] + 348)) {
    return 0;
  }
  unsigned int v7 = dyld3::MachOFile::pointerSize(**a1);
  char v40 = 0;
  unsigned int v35 = dyld3::MachOFile::dependentDylibCount(**a1, 0);
  char v8 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v9 = 0;
  unsigned __int8 v33 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = (*a1)[3];
  unsigned int v34 = (unsigned __int8 **)(*((void *)v11 + 41) + *((unsigned int *)v11 + 84));
  uint64_t v39 = (const unsigned __int8 **)*((void *)v11 + 41);
  char v12 = 1;
  char v13 = 1;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v15 = v39;
    if ((v39 >= (const unsigned __int8 **)v34) | v8 & 1) {
      break;
    }
    uint64_t v17 = (char *)v39 + 1;
    unsigned int v16 = *(unsigned __int8 *)v39;
    uint64_t v39 = (const unsigned __int8 **)((char *)v39 + 1);
    unsigned int v18 = v16 & 0xF;
    char v8 = 1;
    switch(v16 >> 4)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 3u:
        Diagnostics::error((vm_address_t *)a2, "unexpected dylib ordinal in weak_bind");
        goto LABEL_16;
      case 4u:
        if (*v17)
        {
          uint64_t v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            uint64_t v39 = v19;
            int v20 = *(unsigned __int8 *)v19;
            uint64_t v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }
          while (v20);
          uint64_t v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }
        LOBYTE(v36) = v16 & 1;
        uint64_t v39 = (const unsigned __int8 **)((char *)v15 + 2);
        if (v18 >= 8) {
          (*(void (**)(uint64_t, unsigned char *))(a4 + 16))(a4, v17);
        }
        char v8 = 0;
        char v12 = 1;
        uint64_t v9 = v17;
        break;
      case 5u:
        char v8 = 0;
        char v13 = v16 & 0xF;
        break;
      case 6u:
        uint64_t v37 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        char v8 = 0;
        char v12 = 1;
        break;
      case 7u:
        uint64_t v10 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        char v8 = 0;
        BYTE4(v36) = 1;
        unsigned __int8 v33 = v18;
        break;
      case 8u:
        char v8 = 0;
        v10 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        break;
      case 9u:
        LOBYTE(v31) = v12;
        LOWORD(v3dyld4::halt("obsolete dyld API called", 0) = v36 & 1;
        LOBYTE(v29) = v13;
        (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, unsigned char *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
        char v12 = 0;
        char v8 = 0;
        v10 += v7;
        break;
      case 0xAu:
        LOBYTE(v31) = v12;
        LOWORD(v3dyld4::halt("obsolete dyld API called", 0) = v36 & 1;
        LOBYTE(v29) = v13;
        (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, unsigned char *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
        char v12 = 0;
        char v8 = 0;
        v10 += v7 + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v21);
        break;
      case 0xBu:
        LOBYTE(v31) = v12;
        LOWORD(v3dyld4::halt("obsolete dyld API called", 0) = v36 & 1;
        LOBYTE(v29) = v13;
        (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, unsigned char *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
        char v12 = 0;
        char v8 = 0;
        v10 += v7 + v7 * v18;
        break;
      case 0xCu:
        unint64_t v22 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        uint64_t v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v23);
        if (!v22) {
          goto LABEL_16;
        }
        uint64_t v32 = a4;
        uint64_t v25 = v24 + v7;
        unsigned int v26 = 1;
        do
        {
          LOBYTE(v31) = v12;
          LOWORD(v3dyld4::halt("obsolete dyld API called", 0) = v36 & 1;
          LOBYTE(v29) = v13;
          (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, unsigned char *, int, uint64_t, int, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", BYTE4(v36) & 1, 1, v35, 4294967293, v7, v33, v10, v29, v9, v30, v37, v31, &v40);
          char v12 = 0;
          v10 += v25;
          if (v40) {
            break;
          }
          unint64_t v27 = v26++;
        }
        while (v22 > v27);
        char v8 = 0;
        a4 = v32;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X");
LABEL_16:
        char v8 = 0;
        break;
    }
  }
  while (!v40);
  return v40 != 0;
}

uint64_t ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) != *a4)
  {
    uint64_t v5 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
    *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a4;
  }
  return result;
}

uint64_t ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) != *a4)
  {
    uint64_t v5 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
    *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a4;
  }
  return result;
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  unint64_t v1 = *(void *)this;
  if ((*(void *)this & 0x4000000000000000) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget();
  }
  if ((v1 & 0x8000000000000000) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget();
  }
  return v1 & 0x7FFFFFFFFFFLL | ((unint64_t)(v1 >> 43) << 56);
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend(mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  unint64_t v1 = *(void *)this;
  if ((*(void *)this & 0x4000000000000000) == 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend();
  }
  if ((v1 & 0x8000000000000000) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend();
  }
  if ((v1 & 0x4000000000000) != 0) {
    return HIDWORD(v1) | 0xFFFFFFFFFFFC0000;
  }
  else {
    return HIDWORD(v1) & 0x7FFFF;
  }
}

char *mach_o::ChainedFixupPointerOnDisk::Arm64e::keyName(mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  if (this >= 4) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::keyName();
  }
  return mach_o::ChainedFixupPointerOnDisk::Kernel64::keyName(void)const::names[this];
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer(mach_o::ChainedFixupPointerOnDisk::Arm64e *this, unint64_t a2, mach_o::ChainedFixupPointerOnDisk::Arm64e *a3)
{
  unint64_t v3 = *(void *)this;
  if ((*(void *)this & 0x8000000000000000) == 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer();
  }

  return mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer((uint64_t)a3, a2, (void *)(HIWORD(v3) & 1), SBYTE4(v3), (v3 >> 49) & 3);
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(mach_o::ChainedFixupPointerOnDisk::Generic64 *this)
{
  return *(void *)this & 0xFFFFFFFFFLL | ((unint64_t)(*(void *)this >> 36) << 56);
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Generic64::signExtendedAddend(mach_o::ChainedFixupPointerOnDisk::Generic64 *this)
{
  return *((unsigned __int8 *)this + 3);
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Cache64e::high8(mach_o::ChainedFixupPointerOnDisk::Cache64e *this)
{
  if ((*(void *)this & 0x8000000000000000) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Cache64e::high8();
  }
  return (*(void *)this << 22) & 0xFF00000000000000;
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer(uint64_t this, unint64_t a2, void *a3, BOOL a4, int a5)
{
  if (this)
  {
    if (a5 == 1) {
      return this;
    }
    if (a5) {
      mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer();
    }
    return this;
  }
  return this;
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer(mach_o::ChainedFixupPointerOnDisk::Cache64e *this, unint64_t a2, mach_o::ChainedFixupPointerOnDisk::Cache64e *a3)
{
  unint64_t v3 = *(void *)this;
  if ((*(void *)this & 0x8000000000000000) == 0) {
    mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer();
  }

  return mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer((uint64_t)a3, a2, (void *)((v3 >> 50) & 1), v3 >> 34, (v3 >> 51) & 1);
}

uint64_t mach_o::ChainedFixupPointerOnDisk::isRebase(mach_o::ChainedFixupPointerOnDisk *this, int a2, uint64_t a3, unint64_t *a4)
{
  switch(a2)
  {
    case 1:
    case 7:
    case 9:
    case 10:
    case 12:
      if ((*(void *)this & 0x4000000000000000) != 0) {
        return 0;
      }
      if ((*(void *)this & 0x8000000000000000) != 0)
      {
        unint64_t v7 = *(void *)this;
      }
      else
      {
        unint64_t v7 = mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(this);
        if (a2 == 10 || a2 == 1) {
          v7 -= a3;
        }
      }
      goto LABEL_19;
    case 2:
    case 6:
      unint64_t v8 = *(void *)this;
      if ((*(void *)this & 0x8000000000000000) != 0) {
        return 0;
      }
      unint64_t v9 = v8 >> 36;
      uint64_t v10 = v8 & 0xFFFFFFFFFLL;
      if (a2 == 2) {
        uint64_t v11 = a3;
      }
      else {
        uint64_t v11 = 0;
      }
      unint64_t v7 = v10 - v11 + (v9 << 56);
      goto LABEL_19;
    case 3:
      int v12 = *(_DWORD *)this;
      if ((*(_DWORD *)this & 0x80000000) == 0) {
        goto LABEL_16;
      }
      return 0;
    case 5:
      int v12 = *(_DWORD *)this;
LABEL_16:
      unint64_t v7 = (v12 & 0x3FFFFFF) - a3;
      goto LABEL_19;
    case 8:
    case 11:
      unint64_t v7 = *(void *)this & 0x3FFFFFFFLL;
      goto LABEL_19;
    case 13:
      unint64_t v7 = *(void *)this & 0x3FFFFFFFFLL;
LABEL_19:
      *a4 = v7;
      return 1;
    default:
      mach_o::ChainedFixupPointerOnDisk::isRebase();
  }
}

uint64_t mach_o::ChainedFixupPointerOnDisk::isBind(mach_o::ChainedFixupPointerOnDisk *this, int a2, unsigned int *a3, unint64_t *a4)
{
  *a4 = 0;
  uint64_t v5 = 0;
  switch(a2)
  {
    case 1:
    case 7:
    case 9:
    case 10:
    case 12:
      uint64_t v6 = *(void *)this;
      if ((*(void *)this & 0x4000000000000000) == 0) {
        return 0;
      }
      if (a2 == 12) {
        int v7 = 0xFFFFFF;
      }
      else {
        int v7 = 0xFFFF;
      }
      *a3 = v7 & v6;
      if (v6 < 0) {
        return 1;
      }
      unint64_t v8 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend(this);
      goto LABEL_13;
    case 2:
    case 6:
      if ((*(void *)this & 0x8000000000000000) == 0) {
        return 0;
      }
      *a3 = *(void *)this & 0xFFFFFF;
      unint64_t v8 = *((unsigned __int8 *)this + 3);
      goto LABEL_13;
    case 3:
      if ((*(_DWORD *)this & 0x80000000) == 0) {
        return 0;
      }
      *a3 = *(_DWORD *)this & 0xFFFFF;
      unint64_t v8 = ((unint64_t)*(unsigned int *)this >> 20) & 0x3F;
LABEL_13:
      *a4 = v8;
      return 1;
    case 8:
    case 11:
      return v5;
    default:
      mach_o::ChainedFixupPointerOnDisk::isBind();
  }
}

uint64_t mach_o::ChainedFixupPointerOnDisk::strideSize(mach_o::ChainedFixupPointerOnDisk *this)
{
  if ((this - 1) >= 0xD) {
    mach_o::ChainedFixupPointerOnDisk::strideSize();
  }
  return dword_1A8E71220[(__int16)((_WORD)this - 1)];
}

size_t dyld4::Utils::concatenatePaths(dyld4::Utils *this, char *a2, const char *a3)
{
  if (*((unsigned char *)this + _platform_strlen((const char *)this) - 1) == 47 && *a2 == 47)
  {
    uint64_t v6 = a2 + 1;
    int v7 = (char *)this;
  }
  else
  {
    int v7 = (char *)this;
    uint64_t v6 = a2;
  }

  return strlcat(v7, v6, (size_t)a3);
}

BOOL dyld3::MachOAnalyzer::isOSBinary(dyld3::MachOAnalyzer *this, int a2, uint64_t a3)
{
  if (a2 == -1) {
    return 0;
  }
  *(void *)uint64_t v10 = 0;
  BOOL hasCodeSignature = dyld3::MachOFile::hasCodeSignature(this, &v10[1], v10);
  BOOL result = 0;
  if (!hasCodeSignature) {
    return result;
  }
  v11[0] = a3;
  v11[1] = v10[1];
  long long v11[2] = v10[0];
  if (fcntl(a2, 97, v11) == -1) {
    return 0;
  }
  uint64_t v9 = 1;
  uint64_t v8 = a3;
  return fcntl(a2, 105, &v8) != -1 && HIDWORD(v9) != 0;
}

__n128 ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 32) + ((unint64_t)((unsigned __int16)*(_DWORD *)(a2 + 56) >> 4) << 6);
  __n128 result = *(__n128 *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 48) = v5;
  *(__n128 *)unint64_t v2 = result;
  *(_OWORD *)(v2 + 16) = v4;
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  long long v4 = (Diagnostics *)a2;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v67);
  uint64_t result = Diagnostics::hasError(v4);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v7, v8, v9, v10, v11, v12, v13, v55);
    uint64_t v15 = &v55 - 8 * v14;
    v69[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v69[1] = (const unsigned __int8 **)0x40000000;
    void v16[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    void v16[3] = &__block_descriptor_tmp_58_0;
    void v16[4] = v15;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v69);
    uint64_t result = Diagnostics::hasError(v4);
    if ((result & 1) == 0)
    {
      uint64_t result = dyld3::MachOFile::is64(a1);
      if (result) {
        int v17 = 2;
      }
      else {
        int v17 = 1;
      }
      if (v67[0])
      {
        int v58 = v17;
        uint64_t v64 = v15;
        uint64_t v59 = &v55;
        uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v68, *(_DWORD *)(v67[0] + 8));
        uint64_t v56 = *(unsigned int *)(v67[0] + 12);
        uint64_t v19 = (const unsigned __int8 **)((char *)LinkEditContent + v56);
        uint64_t v57 = LinkEditContent;
        v69[0] = LinkEditContent;
        unsigned int v20 = dyld3::MachOFile::pointerSize(a1);
        char v21 = 0;
        uint64_t v22 = 0;
        unsigned int v23 = 0;
        int v24 = 0;
        char v66 = 0;
        uint64_t v63 = a3;
        uint64_t v62 = a3 + 16;
        uint64_t v25 = v20;
        unsigned int v26 = "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB";
        uint64_t v60 = v19;
        uint64_t v61 = v4;
        while (2)
        {
          uint64_t result = Diagnostics::noError(v4);
          if (result)
          {
            int v28 = v69[0];
            if (v69[0] < v19)
            {
              unsigned __int8 v29 = *(unsigned char *)v69[0]++;
              unsigned int v30 = v29 & 0xF;
              switch(v29 >> 4)
              {
                case 0:
                  uint64_t v54 = (char *)v28 + 1;
                  if ((char *)v19 - v54 >= 16) {
                    return Diagnostics::error((vm_address_t *)v4, "rebase opcodes terminated early at offset %d of %d", (int)v54 - (int)v57, v56);
                  }
                  return result;
                case 1:
                  if (v30 == 1)
                  {
                    int v24 = v58;
                  }
                  else
                  {
                    if (v30 == 2) {
                      int v31 = 4;
                    }
                    else {
                      int v31 = 0;
                    }
                    if (v30 == 3) {
                      int v24 = 3;
                    }
                    else {
                      int v24 = v31;
                    }
                  }
                  goto LABEL_48;
                case 2:
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v69, v19, v27);
                  uint64_t v22 = result;
                  char v21 = 1;
                  unsigned int v23 = v30;
                  goto LABEL_48;
                case 3:
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v69, v19, v27);
                  v22 += result;
                  goto LABEL_48;
                case 4:
                  v22 += v25 * v30;
                  goto LABEL_48;
                case 5:
                  if ((v29 & 0xF) == 0) {
                    goto LABEL_48;
                  }
                  unsigned int v32 = 1;
                  unsigned int v65 = v23;
                  unsigned __int8 v33 = v64;
                  uint64_t v34 = v63;
                  do
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, uint64_t *, void, uint64_t, void, uint64_t, int, char *))(v34 + 16))(v34, "REBASE_OPCODE_DO_REBASE_IMM_TIMES", v67, v33, v21 & 1, v25, v65, v22, v24, &v66);
                    v22 += v25;
                    if (v66) {
                      BOOL v35 = 1;
                    }
                    else {
                      BOOL v35 = v32 >= v30;
                    }
                    ++v32;
                  }
                  while (!v35);
                  uint64_t v19 = v60;
                  unsigned int v23 = v65;
                  long long v4 = v61;
                  unsigned int v26 = "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB";
                  if (v66) {
                    return result;
                  }
                  continue;
                case 6:
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v69, v19, v27);
                  if (result)
                  {
                    unint64_t v36 = result;
                    unsigned int v37 = 1;
                    unsigned int v65 = v23;
                    char v38 = v64;
                    uint64_t v39 = v26;
                    uint64_t v40 = v63;
                    do
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, uint64_t *, void, uint64_t, void, uint64_t, int, char *))(v40 + 16))(v40, v39, v67, v38, v21 & 1, v25, v65, v22, v24, &v66);
                      v22 += v25;
                      unint64_t v41 = v37++;
                      if (v66) {
                        BOOL v42 = 0;
                      }
                      else {
                        BOOL v42 = v36 > v41;
                      }
                    }
                    while (v42);
                    uint64_t v19 = v60;
                    unsigned int v23 = v65;
                    long long v4 = v61;
                    unsigned int v26 = v39;
                  }
                  goto LABEL_48;
                case 7:
                  (*(void (**)(uint64_t, const char *, void *, uint64_t *, void, uint64_t, void, uint64_t, int, char *))(v63 + 16))(v63, v26, v67, v64, v21 & 1, v25, v23, v22, v24, &v66);
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v69, v19, v43);
                  v22 += v25 + result;
                  goto LABEL_48;
                case 8:
                  uint64_t uleb128 = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v69, v19, v27);
                  uint64_t result = Diagnostics::hasError(v4);
                  if ((result & 1) == 0)
                  {
                    uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v69, v19, v45);
                    if (uleb128)
                    {
                      uint64_t v46 = result + v25;
                      unsigned int v65 = v23;
                      unsigned int v47 = 1;
                      uint64_t v48 = v25;
                      vm_address_t v49 = v64;
                      unint64_t v50 = uleb128;
                      uint64_t v51 = v63;
                      do
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, uint64_t *, void, uint64_t, void, uint64_t, int, char *))(v51 + 16))(v51, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB", v67, v49, v21 & 1, v48, v65, v22, v24, &v66);
                        unint64_t v52 = v47++;
                        v22 += v46;
                        if (v66) {
                          BOOL v53 = 0;
                        }
                        else {
                          BOOL v53 = v50 > v52;
                        }
                      }
                      while (v53);
                      long long v4 = v61;
                      uint64_t v19 = v60;
                      unsigned int v23 = v65;
                      unsigned int v26 = "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB";
                      uint64_t v25 = v48;
                    }
                  }
                  goto LABEL_48;
                default:
                  uint64_t result = Diagnostics::error((vm_address_t *)v4, "unknown rebase opcode 0x%02X", v29 & 0xF0);
LABEL_48:
                  if (v66) {
                    return result;
                  }
                  continue;
              }
            }
          }
          break;
        }
      }
      else if (v67[2])
      {
        return dyld3::MachOFile::isFileSet(a1);
      }
    }
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  v13[0] = 0;
  v13[1] = v13;
  v13[2] = 0x2000000000;
  char v14 = 0;
  v12[0] = 0;
  v12[1] = v12;
  void v12[2] = 0x2000000000;
  void v12[3] = 0;
  v11[0] = 0;
  v11[1] = v11;
  long long v11[2] = 0x2000000000;
  void v11[3] = 0;
  v10[0] = 0;
  v10[1] = v10;
  unsigned int v10[2] = 0x2000000000;
  void v10[3] = 0;
  v9[0] = 0;
  v9[1] = v9;
  unsigned int v9[2] = 0x2000000000;
  void v9[3] = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  void v8[3] = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke;
  void v7[3] = &unk_1EFF66B60;
  v7[4] = v11;
  void v7[5] = v10;
  void v7[6] = v9;
  void v7[7] = v8;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v7);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke_2;
  void v6[3] = &unk_1EFF66B88;
  void v6[6] = v12;
  void v6[7] = v11;
  void v6[8] = v10;
  void v6[9] = v9;
  v6[10] = v8;
  v6[11] = a1;
  v6[4] = a3;
  void v6[5] = v13;
  dyld3::MachOAnalyzer::forEachRebase(a1, a2, (uint64_t)v6);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v13, 8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(_DWORD *)(a2 + 92) == 7)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a2 + 64);
    uint64_t v4 = *(void *)(a2 + 72) + *(void *)(a2 + 64);
    uint64_t v5 = *(void *)(result + 40);
LABEL_3:
    *(void *)(*(void *)(v5 + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4;
    return result;
  }
  if ((*(_DWORD *)(a2 + 92) & 0x80000000) != 0)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__stub_helper");
    if (!result)
    {
      *(void *)(*(void *)(*(void *)(v3 + 48) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a2 + 64);
      uint64_t v4 = *(void *)(a2 + 72) + *(void *)(a2 + 64);
      uint64_t v5 = *(void *)(v3 + 56);
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, unsigned int a9)
{
  if (a9 > 4 || ((1 << a9) & 0x19) == 0)
  {
    char v14 = (void *)result;
    uint64_t v15 = *(dyld3::MachOAnalyzer **)(result + 88);
    if (*(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24)) {
      BOOL v16 = 1;
    }
    else {
      BOOL v16 = a7 == 0;
    }
    if (!v16)
    {
      uint64_t v17 = a7;
      unsigned int v18 = (const char **)(a4 + 40);
      while (_platform_strcmp(*v18, "__TEXT"))
      {
        v18 += 8;
        if (!--v17) {
          goto LABEL_15;
        }
      }
      *(void *)(*(void *)(v14[6] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(v18 - 3);
      *(unsigned char *)(*(void *)(v14[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
LABEL_15:
    unint64_t v19 = *(void *)(a4 + ((unint64_t)a7 << 6) + 16) + a8;
    if (v19 >= *(void *)(*(void *)(v14[7] + 8) + 24) && v19 < *(void *)(*(void *)(v14[8] + 8) + 24))
    {
      uint64_t v20 = *(void *)(*(void *)(v14[6] + 8) + 24);
      uint64_t v21 = v19 - v20;
      unint64_t v22 = a6 == 8 ? *(void *)((char *)v15 + v21) : *(unsigned int *)((char *)v15 + v21);
      if (v22 >= *(void *)(*(void *)(v14[9] + 8) + 24) && v22 < *(void *)(*(void *)(v14[10] + 8) + 24)) {
        dyld3::MachOAnalyzer::contentIsRegularStub(v15, (const unsigned __int8 *)v15 + v22 - v20);
      }
    }
    unsigned int v23 = *(uint64_t (**)(void))(v14[4] + 16);
    return v23();
  }
  return result;
}

BOOL dyld3::MachOAnalyzer::contentIsRegularStub(dyld3::MachOAnalyzer *this, const unsigned __int8 *a2)
{
  BOOL result = 0;
  int v4 = *((_DWORD *)this + 1);
  if (v4 > 16777222)
  {
    if (v4 == 16777228)
    {
      if (*a2 == 80 && !a2[1] && !a2[2])
      {
        int v5 = 24;
        goto LABEL_20;
      }
      return 0;
    }
    if (v4 != 16777223) {
      return result;
    }
    if (*a2 != 104) {
      return 0;
    }
    int v5 = 233;
    uint64_t v6 = 5;
  }
  else
  {
    if (v4 != 7)
    {
      if (v4 != 12) {
        return result;
      }
      if (!*a2 && a2[1] == 192 && a2[2] == 159)
      {
        int v5 = 229;
LABEL_20:
        uint64_t v6 = 3;
        return a2[v6] == v5;
      }
      return 0;
    }
    if (*a2 != 104 || a2[5] != 255) {
      return 0;
    }
    int v5 = 38;
    uint64_t v6 = 2;
  }
  return a2[v6] == v5;
}

void dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsbU13block_pointerFvyRbE_block_invoke;
  void v4[3] = &unk_1EFF66BB0;
  char v5 = a3;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachRebase(a1, a2, (uint64_t)v4);
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsbU13block_pointerFvyRbE_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  if (!a3 || !*(unsigned char *)(result + 40)) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachBind(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v100 = dyld3::MachOFile::pointerSize(a1);
  char v103 = 0;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v101);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    BOOL v16 = (uint64_t *)&v87;
    __chkstk_darwin(result, v9, v10, v11, v12, v13, v14, v15, (uint64_t)v87);
    v104[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v104[1] = (const unsigned __int8 **)0x40000000;
    v104[2] = (const unsigned __int8 **)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v104[3] = (const unsigned __int8 **)&__block_descriptor_tmp_58_0;
    uint64_t v99 = (const unsigned __int8 **)&(&v87)[-8 * v17];
    v104[4] = v99;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v104);
    uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      uint64_t result = dyld3::MachOFile::dependentDylibCount(a1, 0);
      unsigned int v98 = result;
      if (v101[0])
      {
        uint64_t v89 = a4;
        int v18 = *(_DWORD *)(v101[0] + 16);
        vm_size_t v90 = v102;
        uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)v102, v18);
        v104[0] = LinkEditContent;
        if (!v103)
        {
          LODWORD(v93) = 0;
          uint64_t sleb128 = 0;
          LODWORD(v97) = 0;
          LODWORD(v95) = 0;
          uint64_t uleb128 = 0;
          uint64_t v92 = 0;
          LODWORD(v94) = 0;
          uint64_t v57 = 0;
          uint64_t v58 = 0;
          uint64_t v59 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(v101[0] + 20));
          uint64_t v88 = v100;
          do
          {
            if (!Diagnostics::noError((Diagnostics *)a2)) {
              break;
            }
            uint64_t v61 = v104[0];
            if (v104[0] >= v59) {
              break;
            }
            uint64_t v62 = (unsigned __int8 *)v104[0] + 1;
            unsigned int v63 = *(unsigned __int8 *)v104[0]++;
            int v64 = v63 & 0xF;
            uint64_t v65 = v63 & 0xF;
            switch(v63 >> 4)
            {
              case 0u:
                char v103 = 1;
                goto LABEL_85;
              case 1u:
                LODWORD(v97) = 1;
                uint64_t v65 = v58;
                uint64_t v62 = (unsigned __int8 *)(v63 & 0xF);
                char v66 = &v106;
                goto LABEL_77;
              case 2u:
                uint64_t uleb128 = dyld3::MachOFile::read_uleb128(a2, v104, v59, v60);
                goto LABEL_71;
              case 3u:
                LODWORD(v67) = v63 | 0xFFFFFFF0;
                if ((v63 & 0xF) != 0) {
                  uint64_t v67 = v67;
                }
                else {
                  uint64_t v67 = 0;
                }
                uint64_t uleb128 = v67;
LABEL_71:
                LODWORD(v97) = 1;
                goto LABEL_85;
              case 4u:
                if (*v62)
                {
                  uint64_t v68 = (const unsigned __int8 **)((char *)v61 + 2);
                  do
                  {
                    v104[0] = v68;
                    int v69 = *(unsigned __int8 *)v68;
                    uint64_t v68 = (const unsigned __int8 **)((char *)v68 + 1);
                  }
                  while (v69);
                  uint64_t v61 = (const unsigned __int8 **)((char *)v68 - 2);
                }
                LODWORD(v93) = v63 & 1;
                v104[0] = (const unsigned __int8 **)((char *)v61 + 2);
                uint64_t v65 = v58;
                char v66 = &v105;
LABEL_77:
                *(v66 - 32) = (uint64_t)v62;
                break;
              case 5u:
                break;
              case 6u:
                uint64_t sleb128 = dyld3::MachOFile::read_sleb128(a2, v104, v59, v60);
                goto LABEL_85;
              case 7u:
                uint64_t v57 = dyld3::MachOFile::read_uleb128(a2, v104, v59, v60);
                LODWORD(v95) = 1;
                uint64_t v65 = v58;
                LODWORD(v94) = v64;
                break;
              case 8u:
                v57 += dyld3::MachOFile::read_uleb128(a2, v104, v59, v60);
                goto LABEL_85;
              case 9u:
                LOWORD(v85) = v93 & 1;
                LOBYTE(v84) = v58;
                BYTE4(v83) = (_BYTE)v94;
                LODWORD(v83) = v100;
                (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, uint64_t, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v101, v99, v95 & 1, v97 & 1, v98, uleb128, v83, v57, v84, v92, v85, sleb128, &v103);
                uint64_t v70 = v88;
                goto LABEL_84;
              case 0xAu:
                LOWORD(v85) = v93 & 1;
                LOBYTE(v84) = v58;
                BYTE4(v83) = (_BYTE)v94;
                LODWORD(v83) = v100;
                (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, uint64_t, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", v101, v99, v95 & 1, v97 & 1, v98, uleb128, v83, v57, v84, v92, v85, sleb128, &v103);
                uint64_t v72 = dyld3::MachOFile::read_uleb128(a2, v104, v59, v71);
                v57 += v88 + v72;
                goto LABEL_85;
              case 0xBu:
                uint64_t v73 = *(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, uint64_t, int, uint64_t, char *))(a3 + 16);
                uint64_t v86 = sleb128;
                LOWORD(v85) = v93 & 1;
                LOBYTE(v84) = v58;
                BYTE4(v83) = (_BYTE)v94;
                uint64_t v91 = (uint64_t *)sleb128;
                uint64_t v74 = v16;
                uint64_t v75 = v59;
                unsigned int v76 = v100;
                LODWORD(v83) = v100;
                v73(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", v101, v99, v95 & 1, v97 & 1, v98, uleb128, v83, v57, v84, v92, v85, v86, &v103);
                uint64_t v70 = v76 + v76 * v64;
                uint64_t v59 = v75;
                BOOL v16 = v74;
                uint64_t sleb128 = (uint64_t)v91;
LABEL_84:
                v57 += v70;
                goto LABEL_85;
              case 0xCu:
                unint64_t v77 = dyld3::MachOFile::read_uleb128(a2, v104, v59, v60);
                uint64_t v79 = dyld3::MachOFile::read_uleb128(a2, v104, v59, v78);
                if (!v77) {
                  goto LABEL_85;
                }
                uint64_t v87 = v59;
                uint64_t v91 = v16;
                uint64_t v80 = v79 + v88;
                unsigned int v81 = 1;
                do
                {
                  LOWORD(v85) = v93 & 1;
                  LOBYTE(v84) = v58;
                  BYTE4(v83) = (_BYTE)v94;
                  LODWORD(v83) = v100;
                  (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, uint64_t, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", v101, v99, v95 & 1, v97 & 1, v98, uleb128, v83, v57, v84, v92, v85, sleb128, &v103);
                  v57 += v80;
                  if (v103) {
                    break;
                  }
                  unint64_t v82 = v81++;
                }
                while (v77 > v82);
                uint64_t v65 = v58;
                BOOL v16 = v91;
                uint64_t v59 = v87;
                break;
              default:
                Diagnostics::error(a2, "bad bind opcode 0x%02X", *v62);
LABEL_85:
                uint64_t v65 = v58;
                break;
            }
            uint64_t v58 = v65;
          }
          while (!v103);
        }
        uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
        if ((result & 1) == 0)
        {
          uint64_t v91 = v16;
          if (*(_DWORD *)(v101[0] + 36))
          {
            uint64_t v20 = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)v90, *(_DWORD *)(v101[0] + 32));
            char v21 = 0;
            uint64_t v97 = 0;
            char v22 = 0;
            LODWORD(uleb128) = 0;
            uint64_t v23 = 0;
            int v24 = 0;
            LODWORD(v95) = 0;
            uint64_t v25 = 0;
            v104[0] = v20;
            unsigned int v26 = (const unsigned __int8 **)((char *)v20 + *(unsigned int *)(v101[0] + 36));
            char v103 = 0;
            uint64_t v94 = (const unsigned __int8 **)(a3 + 16);
            uint64_t v93 = v100;
            do
            {
              if (!Diagnostics::noError((Diagnostics *)a2)) {
                break;
              }
              int v28 = v104[0];
              if (v104[0] >= v26) {
                break;
              }
              unsigned __int8 v29 = (char *)v104[0] + 1;
              unsigned __int8 v30 = *(unsigned char *)v104[0]++;
              int v31 = v30 & 0xF;
              switch(v30 >> 4)
              {
                case 0:
                  break;
                case 1:
                  char v22 = 1;
                  uint64_t v23 = v30 & 0xF;
                  break;
                case 2:
                  uint64_t v23 = dyld3::MachOFile::read_uleb128(a2, v104, v26, v27);
                  goto LABEL_16;
                case 3:
                  if ((v30 & 0xF) != 0) {
                    uint64_t v23 = *(_DWORD *)&v30 | 0xFFFFFFF0;
                  }
                  else {
                    uint64_t v23 = 0;
                  }
LABEL_16:
                  char v22 = 1;
                  break;
                case 4:
                  if (*v29)
                  {
                    unsigned int v32 = (const unsigned __int8 **)((char *)v28 + 2);
                    do
                    {
                      v104[0] = v32;
                      int v33 = *(unsigned __int8 *)v32;
                      unsigned int v32 = (const unsigned __int8 **)((char *)v32 + 1);
                    }
                    while (v33);
                    int v28 = (const unsigned __int8 **)((char *)v32 - 2);
                  }
                  char v21 = v30 & 1;
                  v104[0] = (const unsigned __int8 **)((char *)v28 + 2);
                  int v24 = v29;
                  break;
                case 6:
                  uint64_t v97 = dyld3::MachOFile::read_sleb128(a2, v104, v26, v27);
                  break;
                case 7:
                  uint64_t v25 = dyld3::MachOFile::read_uleb128(a2, v104, v26, v27);
                  LODWORD(uleb128) = 1;
                  LODWORD(v95) = v31;
                  break;
                case 9:
                  BYTE1(v85) = 1;
                  LOBYTE(v85) = v21 & 1;
                  LOBYTE(v84) = 1;
                  BYTE4(v83) = v95;
                  LODWORD(v83) = v100;
                  (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned char *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v101, v99, uleb128 & 1, v22 & 1, v98, v23, v83, v25, v84, v24, v85, v97, &v103);
                  v25 += v93;
                  break;
                default:
                  Diagnostics::error(a2, "bad lazy bind opcode 0x%02X", v30 & 0xF0);
                  break;
              }
            }
            while (!v103);
          }
          uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
          if ((result & 1) == 0 && *(_DWORD *)(v101[0] + 28))
          {
            uint64_t v34 = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)v90, *(_DWORD *)(v101[0] + 24));
            char v35 = 0;
            uint64_t v36 = 0;
            LODWORD(uleb128) = 0;
            unsigned int v37 = 0;
            LODWORD(v97) = 0;
            uint64_t v38 = 0;
            v104[0] = v34;
            uint64_t v94 = (const unsigned __int8 **)((char *)v34 + *(unsigned int *)(v101[0] + 28));
            char v103 = 0;
            uint64_t v95 = a3 + 16;
            uint64_t v93 = v100;
            uint64_t v92 = v89 + 16;
            uint64_t v39 = 1;
            do
            {
              uint64_t result = Diagnostics::noError((Diagnostics *)a2);
              if (!result) {
                break;
              }
              unint64_t v41 = v104[0];
              if (v104[0] >= v94) {
                break;
              }
              uint64_t v43 = (unsigned __int8 *)v104[0] + 1;
              unsigned int v42 = *(unsigned __int8 *)v104[0]++;
              uint64_t v44 = v42 & 0xF;
              switch(v42 >> 4)
              {
                case 0u:
                  char v103 = 1;
                  goto LABEL_50;
                case 1u:
                case 2u:
                case 3u:
                  uint64_t result = Diagnostics::error(a2, "unexpected dylib ordinal in weak_bind");
                  goto LABEL_50;
                case 4u:
                  if (*v43)
                  {
                    uint64_t v45 = (const unsigned __int8 **)((char *)v41 + 2);
                    do
                    {
                      v104[0] = v45;
                      int v46 = *(unsigned __int8 *)v45;
                      uint64_t v45 = (const unsigned __int8 **)((char *)v45 + 1);
                    }
                    while (v46);
                    unint64_t v41 = (const unsigned __int8 **)((char *)v45 - 2);
                  }
                  char v35 = v42 & 1;
                  v104[0] = (const unsigned __int8 **)((char *)v41 + 2);
                  if (v44 >= 8) {
                    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned __int8 *))(v89 + 16))(v89, v43);
                  }
                  uint64_t v44 = v39;
                  unsigned int v37 = v43;
                  break;
                case 5u:
                  break;
                case 6u:
                  uint64_t result = dyld3::MachOFile::read_sleb128(a2, v104, v94, v40);
                  uint64_t v36 = result;
                  goto LABEL_50;
                case 7u:
                  LODWORD(v97) = v42 & 0xF;
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v104, v94, v40);
                  uint64_t v38 = result;
                  LODWORD(uleb128) = 1;
                  goto LABEL_50;
                case 8u:
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v104, v94, v40);
                  v38 += result;
                  goto LABEL_50;
                case 9u:
                  LOWORD(v85) = v35 & 1;
                  LOBYTE(v84) = v39;
                  BYTE4(v83) = v97;
                  LODWORD(v83) = v100;
                  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND", v101, v99, uleb128 & 1, 1, v98, 4294967293, v83, v38, v84, v37, v85, v36, &v103);
                  uint64_t v47 = v93;
                  goto LABEL_49;
                case 0xAu:
                  LOWORD(v85) = v35 & 1;
                  LOBYTE(v84) = v39;
                  BYTE4(v83) = v97;
                  LODWORD(v83) = v100;
                  (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", v101, v99, uleb128 & 1, 1, v98, 4294967293, v83, v38, v84, v37, v85, v36, &v103);
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v104, v94, v48);
                  v38 += v93 + result;
                  goto LABEL_50;
                case 0xBu:
                  LOWORD(v85) = v35 & 1;
                  LOBYTE(v84) = v39;
                  BYTE4(v83) = v97;
                  unsigned int v49 = v100;
                  LODWORD(v83) = v100;
                  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", v101, v99, uleb128 & 1, 1, v98, 4294967293, v83, v38, v84, v37, v85, v36, &v103);
                  uint64_t v47 = v49 + v49 * v44;
LABEL_49:
                  v38 += v47;
                  goto LABEL_50;
                case 0xCu:
                  unint64_t v50 = v94;
                  unint64_t v51 = dyld3::MachOFile::read_uleb128(a2, v104, v94, v40);
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v104, v50, v52);
                  if (!v51) {
                    goto LABEL_50;
                  }
                  uint64_t v53 = result + v93;
                  unsigned int v54 = 1;
                  do
                  {
                    LOWORD(v85) = v35 & 1;
                    LOBYTE(v84) = v39;
                    BYTE4(v83) = v97;
                    LODWORD(v83) = v100;
                    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))(a3, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", v101, v99, uleb128 & 1, 1, v98, 4294967293, v83, v38, v84, v37, v85, v36, &v103);
                    v38 += v53;
                    if (v103) {
                      break;
                    }
                    unint64_t v55 = v54++;
                  }
                  while (v51 > v55);
                  uint64_t v44 = v39;
                  break;
                default:
                  uint64_t result = Diagnostics::error(a2, "bad bind opcode 0x%02X", *v43);
LABEL_50:
                  uint64_t v44 = v39;
                  break;
              }
              uint64_t v39 = v44;
            }
            while (!v103);
          }
        }
      }
    }
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachBind(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  v7[0] = 0;
  v7[1] = v7;
  void v7[2] = 0x2000000000;
  char v8 = 0;
  v6[0] = 0;
  v6[1] = v6;
  unsigned int v6[2] = 0x2000000000;
  void v6[3] = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke;
  void v5[3] = &unk_1EFF66BD8;
  void v5[5] = v7;
  void v5[6] = v6;
  v5[4] = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke_2;
  void v4[3] = &unk_1EFF66C00;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachBind(a1, a2, (uint64_t)v5, (uint64_t)v4);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(v7, 8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned __int8 a10)
{
  if (!*(unsigned char *)(*(void *)(a1[5] + 8) + 24))
  {
    uint64_t v11 = (const char **)(a4 + 40);
    uint64_t v12 = a10 + 1;
    while (_platform_strcmp(*v11, "__TEXT"))
    {
      v11 += 8;
      if (!--v12) {
        goto LABEL_7;
      }
    }
    *(void *)(*(void *)(a1[6] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(v11 - 3);
    *(unsigned char *)(*(void *)(a1[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
LABEL_7:
  uint64_t v13 = a1[4];
  uint64_t v14 = *(uint64_t (**)(uint64_t))(v13 + 16);

  return v14(v13);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v47 = 0;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v45);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v11, v12, v13, v14, v15, v16, v17, v34);
    unint64_t v19 = (const unsigned __int8 **)(&v34 - 8 * v18);
    v48[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v48[1] = (const unsigned __int8 **)0x40000000;
    v48[2] = (const unsigned __int8 **)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v48[3] = (const unsigned __int8 **)&__block_descriptor_tmp_58_0;
    v48[4] = v19;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v48);
    uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      uint64_t result = dyld3::MachOFile::dependentDylibCount(a1, 0);
      if (v45[0])
      {
        unsigned int v37 = result;
        uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v46, *(_DWORD *)(v45[0] + 16));
        int v42 = 0;
        uint64_t sleb128 = 0;
        int v44 = 0;
        int v40 = 0;
        uint64_t uleb128 = 0;
        unint64_t v41 = 0;
        int v38 = 0;
        uint64_t v39 = 0;
        uint64_t v22 = 0;
        v48[0] = LinkEditContent;
        uint64_t v23 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(v45[0] + 20));
        uint64_t v35 = a5 + 16;
        uint64_t v34 = a3 + 16;
        uint64_t v36 = a4 + 16;
        while (2)
        {
          if (Diagnostics::noError((Diagnostics *)a2))
          {
            uint64_t v25 = v48[0];
            if (v48[0] < v23)
            {
              unsigned int v26 = (char *)v48[0] + 1;
              unsigned int v27 = *(unsigned __int8 *)v48[0];
              int v28 = v27 & 0xF;
              ++v48[0];
              uint64_t v29 = v27 & 0xF;
              switch(v27 >> 4)
              {
                case 0u:
                  goto LABEL_8;
                case 1u:
                  int v44 = 1;
                  uint64_t v29 = v22;
                  uint64_t uleb128 = v27 & 0xF;
                  goto LABEL_33;
                case 2u:
                  uint64_t uleb128 = dyld3::MachOFile::read_uleb128(a2, v48, v23, v24);
                  goto LABEL_14;
                case 3u:
                  if ((v27 & 0xF) != 0) {
                    uint64_t uleb128 = v27 | 0xFFFFFFF0;
                  }
                  else {
                    uint64_t uleb128 = 0;
                  }
LABEL_14:
                  int v44 = 1;
                  goto LABEL_32;
                case 4u:
                  if (*v26)
                  {
                    unsigned __int8 v30 = (const unsigned __int8 **)((char *)v25 + 2);
                    do
                    {
                      v48[0] = v30;
                      int v31 = *(unsigned __int8 *)v30;
                      unsigned __int8 v30 = (const unsigned __int8 **)((char *)v30 + 1);
                    }
                    while (v31);
                    uint64_t v25 = (const unsigned __int8 **)((char *)v30 - 2);
                  }
                  int v42 = v27 & 1;
                  v48[0] = (const unsigned __int8 **)((char *)v25 + 2);
                  uint64_t v29 = v22;
                  unint64_t v41 = v26;
                  goto LABEL_33;
                case 5u:
                  goto LABEL_33;
                case 6u:
                  uint64_t sleb128 = dyld3::MachOFile::read_sleb128(a2, v48, v23, v24);
                  goto LABEL_32;
                case 7u:
                  uint64_t v39 = dyld3::MachOFile::read_uleb128(a2, v48, v23, v24);
                  int v40 = 1;
                  uint64_t v29 = v22;
                  int v38 = v28;
                  goto LABEL_33;
                case 9u:
                  if (a4)
                  {
                    LOBYTE(v33) = v42 & 1;
                    (*(void (**)(uint64_t, void *, const unsigned __int8 **, void, void, uint64_t, void, unsigned char *, uint64_t, int, char *))(a4 + 16))(a4, v45, v19, v44 & 1, v37, uleb128, v22, v41, sleb128, v33, &v47);
                  }
                  goto LABEL_32;
                case 0xDu:
                  if (v28 == 1)
                  {
                    if (a5) {
                      (*(void (**)(uint64_t, void *, const unsigned __int8 **, void, void, uint64_t, uint64_t, char *, uint64_t, uint64_t, uint64_t))(a5 + 16))(a5, v45, v19, v38, v40 & 1, v39, 1, &v47, v34, v35, v36);
                    }
                  }
                  else if ((v27 & 0xF) != 0)
                  {
                    Diagnostics::error(a2, "bad BIND_OPCODE_THREADED sub-opcode 0x%02X");
                  }
                  else
                  {
                    unint64_t v32 = dyld3::MachOFile::read_uleb128(a2, v48, v23, v24);
                    if (v32 < 0x10000)
                    {
                      if (a3) {
                        (*(void (**)(uint64_t, unint64_t, char *))(a3 + 16))(a3, v32, &v47);
                      }
                    }
                    else
                    {
                      Diagnostics::error(a2, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size too large");
LABEL_8:
                      char v47 = 1;
                    }
                  }
                  goto LABEL_32;
                default:
                  Diagnostics::error(a2, "bad bind opcode 0x%02X");
LABEL_32:
                  uint64_t v29 = v22;
LABEL_33:
                  uint64_t v22 = v29;
                  if (v47) {
                    return Diagnostics::hasError((Diagnostics *)a2);
                  }
                  continue;
              }
            }
          }
          return Diagnostics::hasError((Diagnostics *)a2);
        }
      }
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachChainedFixupTarget(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v18);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v7, v8, v9, v10, v11, v12, v13, v16);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    _OWORD v21[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    void v21[3] = &__block_descriptor_tmp_58_0;
    v21[4] = &v17[-8 * v14 - 1];
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v21);
    uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      if (v18)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 0x40000000;
        void v17[2] = ___ZNK5dyld313MachOAnalyzer25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke;
        v17[3] = &unk_1EFF66C28;
        v17[4] = a3;
        return dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups(a1, a2, 0, (uint64_t)v17, 0);
      }
      else if (v19)
      {
        uint64_t LinkEditContent = (unsigned int *)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v20, *(_DWORD *)(v19 + 8));
        return (uint64_t)dyld3::MachOFile::forEachChainedFixupTarget(a2, LinkEditContent, v19, a3);
      }
    }
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

double __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = v2;
  double result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::halt("obsolete dyld API called", 0) = 0u;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  uint64_t v4 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = v4;
  *(void *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 8dyld4::halt("obsolete dyld API called", 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__13(void *result)
{
  result[10] = 0;
  vm_address_t v1 = result[11];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[12]);
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_3(uint64_t result, unsigned int a2, unsigned int a3, unsigned char *a4)
{
  uint64_t v5 = result;
  uint64_t v6 = (uint64_t *)(*(void *)(result + 48) + a2);
  uint64_t v7 = (uint64_t *)((char *)v6 + a3);
  if (*(_DWORD *)(result + 80) == 8)
  {
    if (!a3) {
      return result;
    }
    while (1)
    {
      unint64_t v8 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 56), *v6);
      uint64_t v9 = *(void *)(*(void *)(v5 + 40) + 8);
      uint64_t v10 = *(void *)(v9 + 80);
      if (!v10) {
        break;
      }
      uint64_t v11 = *(void *)(v9 + 64);
      uint64_t v12 = 24 * v10;
      uint64_t v13 = (unint64_t *)(v11 + 8);
      while (*(v13 - 1) > v8 || *v13 <= v8)
      {
        v13 += 3;
        v12 -= 24;
        if (!v12) {
          goto LABEL_20;
        }
      }
      double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16))(*(void *)(v5 + 32), (v8 - *(_DWORD *)(v5 + 72)));
      if (++v6 >= v7) {
        return result;
      }
    }
LABEL_20:
    double result = Diagnostics::error(*(vm_address_t **)(v5 + 64), "initializer 0x%0llX does not point within executable segment");
  }
  else
  {
    if (!a3) {
      return result;
    }
    while (1)
    {
      unsigned int v14 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 56), *(unsigned int *)v6);
      uint64_t v15 = *(void *)(*(void *)(v5 + 40) + 8);
      uint64_t v16 = *(void *)(v15 + 80);
      if (!v16) {
        break;
      }
      uint64_t v17 = *(void *)(v15 + 64);
      uint64_t v18 = 24 * v16;
      uint64_t v19 = (void *)(v17 + 8);
      while (*(v19 - 1) > (unint64_t)v14 || *v19 <= (unint64_t)v14)
      {
        v19 += 3;
        v18 -= 24;
        if (!v18) {
          goto LABEL_21;
        }
      }
      double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16))(*(void *)(v5 + 32), v14 - *(_DWORD *)(v5 + 72));
      uint64_t v6 = (uint64_t *)((char *)v6 + 4);
      if (v6 >= v7) {
        return result;
      }
    }
LABEL_21:
    double result = Diagnostics::error(*(vm_address_t **)(v5 + 64), "initializer 0x%0X does not point within executable segment");
  }
  *a4 = 1;
  return result;
}

void dyld3::MachOAnalyzer::forEachTerminator(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = 0;
  unsigned int v14 = &v13;
  uint64_t v15 = 0x6802000000;
  uint64_t v16 = __Block_byref_object_copy__13;
  uint64_t v17 = __Block_byref_object_dispose__13;
  void v18[3] = v18;
  v18[4] = 1;
  uint64_t v19 = 0;
  vm_address_t address = 0;
  vm_size_t size = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  void v12[2] = ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke;
  void v12[3] = &unk_1EFF66CF0;
  void v12[4] = &v13;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v12);
  if (v14[10])
  {
    uint64_t v8 = dyld3::MachOFile::preferredLoadAddress(a1);
    uint64_t Slide = dyld3::MachOLoaded::getSlide(a1);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    unsigned int v10[2] = ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke_2;
    void v10[3] = &unk_1EFF66D18;
    int v11 = dyld3::MachOFile::pointerSize(a1);
    void v10[6] = Slide;
    void v10[7] = a2;
    void v10[4] = a4;
    v10[5] = &v13;
    void v10[8] = a3;
    void v10[9] = v8;
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v10);
  }
  else
  {
    Diagnostics::error(a2, "no exeutable segments");
  }
  _Block_object_dispose(&v13, 8);
  uint64_t v19 = 0;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
}

void *___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke(void *result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 52) & 4) != 0)
  {
    uint64_t v2 = *(void *)(result[4] + 8);
    uint64_t v3 = *(void *)(a2 + 16);
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(a2 + 24) + v3;
    double result = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace((void *)(v2 + 64), 1);
    uint64_t v6 = *(void *)(v2 + 64);
    uint64_t v7 = *(void *)(v2 + 80);
    *(void *)(v2 + 8dyld4::halt("obsolete dyld API called", 0) = v7 + 1;
    uint64_t v8 = v6 + 24 * v7;
    *(void *)uint64_t v8 = v3;
    *(void *)(v8 + 8) = v5;
    *(_DWORD *)(v8 + 16) = v4;
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke_2(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (*(unsigned char *)(a2 + 92) == 10)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(a2 + 72);
    unint64_t v7 = *(unsigned int *)(result + 80);
    if (v6 % v7)
    {
      double result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s has bad size");
    }
    else if (a3)
    {
      double result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s extends beyond its segment");
    }
    else
    {
      uint64_t v8 = *(void *)(result + 48) + *(void *)(a2 + 64);
      if (v8 % (uint64_t)v7)
      {
        double result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s is not pointer aligned");
      }
      else
      {
        uint64_t v9 = (char *)(v8 + v6);
        if (v7 == 8)
        {
          if (v6 < 1) {
            return result;
          }
          while (1)
          {
            unint64_t v10 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 64), *(void *)v8);
            uint64_t v11 = *(void *)(*(void *)(v5 + 40) + 8);
            uint64_t v12 = *(void *)(v11 + 80);
            if (!v12) {
              break;
            }
            uint64_t v13 = *(void *)(v11 + 64);
            uint64_t v14 = 24 * v12;
            uint64_t v15 = (unint64_t *)(v13 + 8);
            while (*(v15 - 1) > v10 || *v15 <= v10)
            {
              v15 += 3;
              v14 -= 24;
              if (!v14) {
                goto LABEL_27;
              }
            }
            double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16))(*(void *)(v5 + 32), (v10 - *(_DWORD *)(v5 + 72)));
            v8 += 8;
            if (v8 >= (unint64_t)v9) {
              return result;
            }
          }
LABEL_27:
          double result = Diagnostics::error(*(vm_address_t **)(v5 + 56), "terminator 0x%0llX does not point within executable segment");
        }
        else
        {
          if (v6 < 1) {
            return result;
          }
          while (1)
          {
            unsigned int v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 64), *(unsigned int *)v8);
            uint64_t v17 = *(void *)(*(void *)(v5 + 40) + 8);
            uint64_t v18 = *(void *)(v17 + 80);
            if (!v18) {
              break;
            }
            uint64_t v19 = *(void *)(v17 + 64);
            uint64_t v20 = 24 * v18;
            char v21 = (void *)(v19 + 8);
            while (*(v21 - 1) > (unint64_t)v16 || *v21 <= (unint64_t)v16)
            {
              v21 += 3;
              v20 -= 24;
              if (!v20) {
                goto LABEL_28;
              }
            }
            double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16))(*(void *)(v5 + 32), v16 - *(_DWORD *)(v5 + 72));
            v8 += 4;
            if (v8 >= (unint64_t)v9) {
              return result;
            }
          }
LABEL_28:
          double result = Diagnostics::error(*(vm_address_t **)(v5 + 56), "terminator 0x%0X does not point within executable segment");
        }
      }
    }
    *a4 = 1;
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachCDHash(_DWORD *a1, uint64_t a2)
{
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  dyld3::MachOLoaded::getLinkEditPointers(a1, (vm_address_t *)&v8, (uint64_t)v5);
  if (!Diagnostics::hasError((Diagnostics *)&v8) && v6)
  {
    uint64_t LinkEditContent = (_DWORD *)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v7, *(_DWORD *)(v6 + 8));
    dyld3::MachOFile::forEachCDHashOfCodeSignature((uint64_t)a1, LinkEditContent, *(unsigned int *)(v6 + 12), a2);
  }
  mach_o::Error::~Error(&v8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11neverUnloadEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

void *___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke(void *result, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  if (*(unsigned __int8 *)(*(void *)(result[4] + 8) + 24) != a4)
  {
    uint64_t v6 = *(void *)(*(void *)(result[5] + 8) + 24);
    if (*(unsigned char *)(*(void *)(result[4] + 8) + 24))
    {
      uint64_t v7 = result[6];
      unsigned int v8 = v6 + 2 * *(unsigned __int16 *)(v6 + 20) - result[7] + 22;
      *(_DWORD *)(v7 + 4 * a4 + 4) = v8;
      *(void *)(*(void *)(result[5] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7 + v8;
      unint64_t v9 = *(void *)(*(void *)(result[5] + 8) + 24);
      if (v9 >= result[8]) {
        ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke_cold_3();
      }
    }
    else
    {
      *(_DWORD *)(result[6] + 4 * a4 + 4) = v6 - *((_DWORD *)result + 14);
      unint64_t v9 = *(void *)(*(void *)(result[5] + 8) + 24);
    }
    *(_WORD *)(v9 + 2dyld4::halt("obsolete dyld API called", 0) = 0;
    *(unsigned char *)(*(void *)(result[4] + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a4;
  }
  unint64_t v10 = a6 >> 12;
  uint64_t v11 = *(void *)(*(void *)(result[5] + 8) + 24);
  uint64_t v12 = *(unsigned __int16 *)(v11 + 20);
  unint64_t v13 = result[8];
  if (v12 != (a6 >> 12))
  {
    do
    {
      uint64_t v14 = (_WORD *)(v11 + 2 * v12 + 22);
      if ((unint64_t)v14 >= v13) {
        ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke_cold_2();
      }
      _WORD *v14 = -1;
      uint64_t v15 = *(void *)(*(void *)(result[5] + 8) + 24);
      ++*(_WORD *)(v15 + 20);
      uint64_t v11 = *(void *)(*(void *)(result[5] + 8) + 24);
      uint64_t v12 = *(unsigned __int16 *)(v11 + 20);
    }
    while (v12 != v10);
  }
  *(_DWORD *)uint64_t v11 = 2 * v10 + 22;
  *(_WORD *)(*(void *)(*(void *)(result[5] + 8) + 24) + 4) = 4096;
  *(_WORD *)(*(void *)(*(void *)(result[5] + 8) + 24) + 6) = 1;
  *(void *)(*(void *)(*(void *)(result[5] + 8) + 24) + 8) = *(void *)(a3 + ((unint64_t)a4 << 6) + 16)
                                                                      - result[9];
  *(_DWORD *)(*(void *)(*(void *)(result[5] + 8) + 24) + 16) = 0;
  *(_WORD *)(*(void *)(*(void *)(result[5] + 8) + 24) + 2dyld4::halt("obsolete dyld API called", 0) = v10 + 1;
  unsigned int v16 = (_WORD *)(*(void *)(*(void *)(result[5] + 8) + 24) + 2 * v10 + 22);
  if ((unint64_t)v16 >= v13) {
    ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke_cold_1();
  }
  *unsigned int v16 = a6 & 0xFFF;
  return result;
}

uint64_t dyld3::MachOAnalyzer::ObjCClassInfo::getReadOnlyDataField(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = a1 + 40;
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 48) + v4);
  if (a3 == 8)
  {
    switch(a2)
    {
      case 0:
        uint64_t v7 = *((void *)v6 + 3);
        goto LABEL_4;
      case 1:
        uint64_t v7 = *((void *)v6 + 5);
        goto LABEL_4;
      case 2:
        uint64_t v7 = *((void *)v6 + 4);
        goto LABEL_4;
      case 3:
        uint64_t v7 = *((void *)v6 + 8);
        goto LABEL_4;
      case 4:
        goto LABEL_7;
      default:
        return result;
    }
  }
  else
  {
    switch(a2)
    {
      case 0:
        uint64_t v7 = v6[4];
        goto LABEL_4;
      case 1:
        uint64_t v7 = v6[6];
        goto LABEL_4;
      case 2:
        uint64_t v7 = v6[5];
        goto LABEL_4;
      case 3:
        uint64_t v7 = v6[9];
LABEL_4:
        uint64_t result = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(result, v7);
        break;
      case 4:
LABEL_7:
        uint64_t result = *v6;
        break;
      default:
        return result;
    }
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachObjCClass(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (dyld3::MachOFile::pointerSize(a1) == 8)
  {
    uint64_t v20 = 0;
    char v21 = &v20;
    uint64_t v22 = 0x2000000000;
    char v23 = 0;
    if (a3)
    {
      uint64_t v10 = a3 - 1;
      do
      {
        uint64_t v11 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *(void *)((char *)a1 + a2));
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000;
        void v19[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke;
        v19[3] = &unk_1EFF66DE0;
        v19[6] = a5;
        void v19[7] = v11;
        v19[4] = &v20;
        v19[5] = a1;
        void v19[8] = a4;
        memset(&v19[9], 0, 24);
        dyld3::MachOAnalyzer::parseObjCClass(a1, a4, v11, v12, (uint64_t)v19);
        if (*((unsigned char *)v21 + 24)) {
          BOOL v13 = 1;
        }
        else {
          BOOL v13 = v10 == 0;
        }
        --v10;
        a2 += 8;
      }
      while (!v13);
    }
  }
  else
  {
    uint64_t v20 = 0;
    char v21 = &v20;
    uint64_t v22 = 0x2000000000;
    char v23 = 0;
    if (a3)
    {
      uint64_t v14 = a3 - 1;
      do
      {
        uint64_t v15 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *(unsigned int *)((char *)a1 + a2));
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000;
        _OWORD v18[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_3;
        void v18[3] = &unk_1EFF66E30;
        v18[6] = a5;
        v18[7] = v15;
        v18[4] = &v20;
        void v18[5] = a1;
        void v18[8] = a4;
        memset(&v18[9], 0, 24);
        dyld3::MachOAnalyzer::parseObjCClass(a1, a4, v15, v16, (uint64_t)v18);
        if (*((unsigned char *)v21 + 24)) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = v14 == 0;
        }
        --v14;
        a2 += 4;
      }
      while (!v17);
    }
  }
  _Block_object_dispose(&v20, 8);
}

uint64_t dyld3::MachOAnalyzer::parseObjCClass(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = dyld3::MachOFile::pointerSize(a1);
  memset(v21, 0, sizeof(v21));
  uint64_t v10 = (unsigned int *)(dyld3::MachOLoaded::getSlide(a1) + a3);
  if (v9 != 8)
  {
    uint64_t v11 = a3 + 4;
    uint64_t v12 = a3 + 16;
    *(void *)char v21 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *v10);
    *(void *)&void v21[8] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v10[1]);
    uint64_t v15 = v10[3];
    if (v15) {
      uint64_t v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v15);
    }
    else {
      uint64_t v16 = 0;
    }
    *(void *)&v21[16] = v16;
    *(void *)&v21[24] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v10[4]) & 0xFFFFFFFCLL;
    *(_OWORD *)uint64_t v22 = *(_OWORD *)a2;
    *(_DWORD *)&v22[15] = *(_DWORD *)(a2 + 15);
    unsigned int v19 = v10[4];
    v21[36] = v19 & 1;
    v21[37] = (v19 & 2) != 0;
    if ((v19 & 3) != 0)
    {
      unsigned int v18 = v10[5];
      goto LABEL_13;
    }
LABEL_12:
    unsigned int v18 = 0;
    goto LABEL_13;
  }
  uint64_t v11 = a3 + 8;
  uint64_t v12 = a3 + 32;
  *(void *)char v21 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *(void *)v10);
  *(void *)&void v21[8] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *((void *)v10 + 1));
  uint64_t v13 = *((void *)v10 + 3);
  if (v13) {
    uint64_t v14 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v13);
  }
  else {
    uint64_t v14 = 0;
  }
  *(void *)&v21[16] = v14;
  *(void *)&v21[24] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *((void *)v10 + 4)) & 0x7FFFFFFFFFF8;
  *(_OWORD *)uint64_t v22 = *(_OWORD *)a2;
  *(_DWORD *)&v22[15] = *(_DWORD *)(a2 + 15);
  uint64_t v17 = *((void *)v10 + 4);
  v21[36] = v17 & 1;
  v21[37] = (v17 & 2) != 0;
  if ((v17 & 3) == 0) {
    goto LABEL_12;
  }
  unsigned int v18 = v10[10];
LABEL_13:
  *(_DWORD *)&v21[32] = v18;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(a5 + 16))(a5, v11, v12, v21);
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(dyld3::MachOFile **)(a1 + 40);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))();
  uint64_t v9 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(*(void *)(v9 + 8) + 24))
  {
    uint64_t v10 = *a4;
    uint64_t v11 = *(void *)(a1 + 64);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    void v12[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_2;
    void v12[3] = &unk_1EFF66DB8;
    void v12[5] = *(void *)(a1 + 48);
    void v12[6] = v10;
    void v12[4] = v9;
    return dyld3::MachOAnalyzer::parseObjCClass(v6, v11, v10, v8, (uint64_t)v12);
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 40)
                                                                                                + 16))(**(void **)(a1 + 40), *(void *)(a1 + 48), a2, a3, a4, 1, *(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(dyld3::MachOFile **)(a1 + 40);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))();
  uint64_t v9 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(*(void *)(v9 + 8) + 24))
  {
    uint64_t v10 = *a4;
    uint64_t v11 = *(void *)(a1 + 64);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    void v12[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_4;
    void v12[3] = &unk_1EFF66E08;
    void v12[5] = *(void *)(a1 + 48);
    void v12[6] = v10;
    void v12[4] = v9;
    return dyld3::MachOAnalyzer::parseObjCClass(v6, v11, v10, v8, (uint64_t)v12);
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 40)
                                                                                                + 16))(**(void **)(a1 + 40), *(void *)(a1 + 48), a2, a3, a4, 1, *(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL dyld3::MachOAnalyzer::isSwiftClass(dyld3::MachOAnalyzer *this, unsigned char *a2)
{
  if (dyld3::MachOFile::pointerSize(this) == 8) {
    char v3 = a2[32];
  }
  else {
    char v3 = a2[16];
  }
  return (v3 & 3) != 0;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCCategory(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = dyld3::MachOFile::pointerSize(a1);
  uint64_t result = dyld3::MachOLoaded::getSlide(a1);
  uint64_t v12 = result;
  uint64_t v13 = (uint64_t *)((char *)a1 + a2);
  if (v10 == 8)
  {
    char v28 = 0;
    if (a3)
    {
      uint64_t v14 = a3 - 1;
      do
      {
        uint64_t v15 = v14;
        uint64_t v16 = *v13++;
        uint64_t v17 = (uint64_t *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v16) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v17);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[5]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
        if (v28) {
          break;
        }
        uint64_t v14 = v15 - 1;
      }
      while (v15);
    }
  }
  else
  {
    char v28 = 0;
    if (a3)
    {
      uint64_t v18 = a3 - 1;
      do
      {
        uint64_t v19 = v18;
        unsigned int v20 = *(_DWORD *)v13;
        uint64_t v13 = (uint64_t *)((char *)v13 + 4);
        char v21 = (unsigned int *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v20) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v21);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[5]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
        if (v28) {
          break;
        }
        uint64_t v18 = v19 - 1;
      }
      while (v19);
    }
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCDuplicateClassToIgnore(dyld3::MachOFile *a1, uint64_t a2)
{
  unsigned int v4 = dyld3::MachOFile::pointerSize(a1);
  unint64_t v9 = 0;
  uint64_t result = dyld3::MachOLoaded::findSectionContent(a1, "__DATA", "__objc_dupclass", &v9);
  if (result)
  {
    if (v9 % v4) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v9 == 0;
    }
    if (!v6)
    {
      uint64_t v7 = result;
      uint64_t v8 = 0;
      do
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, *(void *)(v7 + v8) + 8);
        v8 += v4;
      }
      while (v8 != v9);
    }
  }
  return result;
}

__n128 __Block_byref_object_copy__255(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<int>(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = dyld3::MachOFile::preferredLoadAddress(a1);
  int v8 = *(void *)(a3 + 72) / 0xCuLL;
  if (v8)
  {
    unint64_t v9 = (char *)a1 + *(void *)(a3 + 64) - result;
    int v10 = &v9[12 * v8];
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, v9, v9 + 4);
      v9 += 12;
    }
    while (v9 < v10);
  }
  return result;
}

void dyld3::MachOAnalyzer::forEachBindTarget(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  if (!dyld3::MachOFile::isPreload(a1))
  {
    if (dyld3::MachOFile::hasChainedFixups(a1))
    {
      dyld3::MachOAnalyzer::forEachBindTarget_ChainedFixups(a1, a2, a4);
    }
    else if (dyld3::MachOFile::hasOpcodeFixups(a1))
    {
      dyld3::MachOAnalyzer::forEachBindTarget_Opcodes(a1, a2, a3, a4, a5);
    }
  }
}

void dyld3::MachOAnalyzer::forEachBindTarget_ChainedFixups(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  int v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke;
  void v7[3] = &unk_1EFF66F40;
  v7[4] = a3;
  void v7[5] = v8;
  dyld3::MachOAnalyzer::forEachChainedFixupTarget(a1, a2, (uint64_t)v7);
  if (Diagnostics::noError((Diagnostics *)a2)
    && dyld3::MachOFile::isMainExecutable(a1)
    && dyld3::MachOFile::hasWeakDefs(a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    unsigned int v6[2] = ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2;
    void v6[3] = &unk_1EFF66F68;
    void v6[4] = a3;
    void v6[5] = v8;
    dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v6);
  }
  _Block_object_dispose(v8, 8);
}

void dyld3::MachOAnalyzer::forEachBindTarget_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  v9[0] = 0;
  v9[1] = v9;
  unsigned int v9[2] = 0x2000000000;
  int v10 = -1;
  v7[0] = 0;
  v7[1] = v7;
  void v7[2] = 0x2000000000;
  int v8 = -1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  unsigned int v6[2] = ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke;
  void v6[3] = &unk_1EFF66EF0;
  void v6[4] = a4;
  void v6[5] = v9;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2;
  void v5[3] = &unk_1EFF66F18;
  v5[4] = a5;
  void v5[5] = v7;
  dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(a1, a2, a3, (uint64_t)v6, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(v9, 8);
}

void dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v48);
  BOOL hasError = Diagnostics::hasError((Diagnostics *)a2);
  if (!hasError)
  {
    __chkstk_darwin(hasError, v11, v12, v13, v14, v15, v16, v17, v21);
    uint64_t v19 = (uint64_t (*)())&v22[-8 * v18 - 1];
    uint64_t v39 = _NSConcreteStackBlock;
    uint64_t v40 = 0x40000000;
    uint64_t v41 = (uint64_t)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    int v42 = (__n128 (*)(uint64_t, uint64_t))&__block_descriptor_tmp_58_0;
    uint64_t v43 = v19;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)&v39);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      uint64_t v44 = 0;
      uint64_t v45 = &v44;
      uint64_t v46 = 0x2000000000;
      int v47 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = (uint64_t)&v39;
      uint64_t v41 = 0x4802000000;
      int v42 = __Block_byref_object_copy__258;
      uint64_t v43 = __Block_byref_object_dispose__259;
      v30[0] = _NSConcreteStackBlock;
      v30[1] = 0x40000000;
      v30[2] = ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke;
      v30[3] = &unk_1EFF66E80;
      long long v33 = v50;
      long long v32 = v49;
      long long v31 = v48;
      long long v37 = v54;
      long long v36 = v53;
      long long v35 = v52;
      long long v34 = v51;
      v30[5] = &v39;
      v30[6] = &v44;
      char v38 = a3;
      void v30[4] = a4;
      if (!dyld3::MachOAnalyzer::forEachBind_OpcodesRegular(a1, (Diagnostics *)a2, (uint64_t)&v48, (uint64_t)v19, (uint64_t)v30))
      {
        BOOL v20 = dyld3::MachOAnalyzer::forEachBind_OpcodesLazy(a1, (Diagnostics *)a2, (uint64_t)&v48, (uint64_t)v19, (uint64_t)v30);
        _Block_object_dispose(&v39, 8);
        _Block_object_dispose(&v44, 8);
        if (v20) {
          return;
        }
        uint64_t v44 = 0;
        uint64_t v45 = &v44;
        uint64_t v46 = 0x2000000000;
        int v47 = 0;
        uint64_t v39 = 0;
        uint64_t v40 = (uint64_t)&v39;
        uint64_t v41 = 0x4802000000;
        int v42 = __Block_byref_object_copy__258;
        uint64_t v43 = __Block_byref_object_dispose__259;
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        _OWORD v22[2] = ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke_2;
        v22[3] = &unk_1EFF66EA8;
        long long v24 = v49;
        long long v23 = v48;
        long long v29 = v54;
        long long v28 = v53;
        long long v27 = v52;
        long long v25 = v50;
        long long v26 = v51;
        void v22[6] = &v44;
        void v22[7] = v19;
        v22[4] = a5;
        v22[5] = &v39;
        dyld3::MachOAnalyzer::forEachBind_OpcodesWeak(a1, (Diagnostics *)a2, (uint64_t)&v48, (uint64_t)v19, (uint64_t)v22, (uint64_t)&__block_literal_global_265);
      }
      _Block_object_dispose(&v39, 8);
      _Block_object_dispose(&v44, 8);
    }
  }
}

__n128 __Block_byref_object_copy__258(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = result;
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, unsigned __int8 a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18)
{
  uint64_t v18 = *(void *)(a4 + ((unint64_t)a10 << 6) + 16);
  uint64_t v19 = *(void *)(a1 + 136);
  if (a17)
  {
    uint64_t v20 = *(void *)(*(void *)(a1 + 48) + 8);
    int v21 = *(_DWORD *)(v20 + 24);
    *(_DWORD *)(v20 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v21 + 1;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 4dyld4::halt("obsolete dyld API called", 0) = v21;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 44) = a8;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = a13;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56) = a16;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 64) = a14;
    if (a15) {
      BOOL v22 = *(unsigned char *)(a1 + 168) != 0;
    }
    else {
      BOOL v22 = 0;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 65) = v22;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v18 + a11 - v19, *(void *)(*(void *)(a1 + 40) + 8) + 40, a18);
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesRegular(dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)a3 || !*(_DWORD *)(*(void *)a3 + 20)) {
    return 0;
  }
  unsigned int v9 = dyld3::MachOFile::pointerSize(a1);
  v44[0] = 0;
  unsigned int v37 = dyld3::MachOFile::dependentDylibCount(a1, 0);
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  char v10 = 0;
  char v11 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  char v38 = 0;
  uint64_t v14 = 0;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(void *)a3 + 16));
  long long v36 = (unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(void *)a3 + 20));
  uint64_t v15 = v9;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v17 = LinkEditContent;
    if ((LinkEditContent >= (const unsigned __int8 **)v36) | v10 & 1) {
      break;
    }
    uint64_t v18 = (unsigned __int8 *)LinkEditContent + 1;
    unsigned int v19 = *(unsigned __int8 *)LinkEditContent;
    uint64_t LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    int v20 = v19 & 0xF;
    char v10 = 1;
    switch(v19 >> 4)
    {
      case 0u:
        break;
      case 1u:
        char v10 = 0;
        char v12 = 1;
        uint64_t v13 = v19 & 0xF;
        break;
      case 2u:
        uint64_t v13 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v10 = 0;
        goto LABEL_13;
      case 3u:
        char v10 = 0;
        if ((v19 & 0xF) != 0) {
          uint64_t v13 = v19 | 0xFFFFFFF0;
        }
        else {
          uint64_t v13 = 0;
        }
LABEL_13:
        char v12 = 1;
        break;
      case 4u:
        if (*v18)
        {
          int v21 = (const unsigned __int8 **)((char *)v17 + 2);
          do
          {
            uint64_t LinkEditContent = v21;
            int v22 = *(unsigned __int8 *)v21;
            int v21 = (const unsigned __int8 **)((char *)v21 + 1);
          }
          while (v22);
          uint64_t v17 = (const unsigned __int8 **)((char *)v21 - 2);
        }
        char v10 = 0;
        LOBYTE(v39) = v19 & 1;
        uint64_t LinkEditContent = (const unsigned __int8 **)((char *)v17 + 2);
        char v11 = 1;
        char v38 = v18;
        break;
      case 5u:
        char v10 = 0;
        BYTE4(v4dyld4::halt("obsolete dyld API called", 0) = v19 & 0xF;
        break;
      case 6u:
        uint64_t v41 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v10 = 0;
        char v11 = 1;
        break;
      case 7u:
        uint64_t v14 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v10 = 0;
        BYTE4(v39) = v20;
        LOBYTE(v4dyld4::halt("obsolete dyld API called", 0) = 1;
        break;
      case 8u:
        char v10 = 0;
        v14 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        break;
      case 9u:
        LOBYTE(v34) = v11;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v31) = BYTE4(v39);
        LODWORD(v31) = v15;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND", a3, a4, v40 & 1, v12 & 1, v37, v13, v31, v14, v32, v38, v33, v41, v34, v44);
        char v11 = 0;
        char v10 = 0;
        v14 += v15;
        break;
      case 0xAu:
        LOBYTE(v34) = v11;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v31) = BYTE4(v39);
        LODWORD(v31) = v15;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", a3, a4, v40 & 1, v12 & 1, v37, v13, v31, v14, v32, v38, v33, v41, v34, v44);
        char v11 = 0;
        char v10 = 0;
        v14 += v15
             + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v23);
        break;
      case 0xBu:
        LOBYTE(v34) = v11;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v31) = BYTE4(v39);
        LODWORD(v31) = v15;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", a3, a4, v40 & 1, v12 & 1, v37, v13, v31, v14, v32, v38, v33, v41, v34, v44);
        char v11 = 0;
        char v10 = 0;
        v14 += (v15 + v15 * v20);
        break;
      case 0xCu:
        unint64_t v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        uint64_t v26 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v25);
        if (!v24) {
          goto LABEL_31;
        }
        long long v35 = a2;
        uint64_t v27 = v26 + v15;
        unsigned int v28 = 1;
        do
        {
          LOBYTE(v34) = v11;
          LOWORD(v33) = v39 & 1;
          LOBYTE(v32) = BYTE4(v40);
          BYTE4(v31) = BYTE4(v39);
          LODWORD(v31) = v15;
          (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", a3, a4, v40 & 1, v12 & 1, v37, v13, v31, v14, v32, v38, v33, v41, v34, v44);
          char v11 = 0;
          v14 += v27;
          if (v44[0]) {
            break;
          }
          unint64_t v29 = v28++;
        }
        while (v24 > v29);
        char v10 = 0;
        a2 = v35;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X", *v18);
LABEL_31:
        char v10 = 0;
        break;
    }
  }
  while (!v44[0]);
  return v44[0] != 0;
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesLazy(dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)a3 || !*(_DWORD *)(*(void *)a3 + 36)) {
    return 0;
  }
  unsigned int v9 = dyld3::MachOFile::pointerSize(a1);
  char v34 = 0;
  unsigned int v29 = dyld3::MachOFile::dependentDylibCount(a1, 0);
  char v10 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(void *)a3 + 32));
  uint64_t v15 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(void *)a3 + 36));
  uint64_t v28 = v9;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v17 = LinkEditContent;
    if (LinkEditContent >= v15) {
      break;
    }
    uint64_t v18 = (char *)LinkEditContent + 1;
    unsigned __int8 v19 = *(unsigned char *)LinkEditContent;
    uint64_t LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    char v20 = v19 & 0xF;
    switch(v19 >> 4)
    {
      case 0:
        break;
      case 1:
        char v11 = 1;
        uint64_t v12 = v19 & 0xF;
        break;
      case 2:
        uint64_t v12 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, v15, v16);
        goto LABEL_12;
      case 3:
        if ((v19 & 0xF) != 0) {
          uint64_t v12 = *(_DWORD *)&v19 | 0xFFFFFFF0;
        }
        else {
          uint64_t v12 = 0;
        }
LABEL_12:
        char v11 = 1;
        break;
      case 4:
        if (*v18)
        {
          int v21 = (const unsigned __int8 **)((char *)v17 + 2);
          do
          {
            uint64_t LinkEditContent = v21;
            int v22 = *(unsigned __int8 *)v21;
            int v21 = (const unsigned __int8 **)((char *)v21 + 1);
          }
          while (v22);
          uint64_t v17 = (const unsigned __int8 **)((char *)v21 - 2);
        }
        char v10 = v19 & 1;
        uint64_t LinkEditContent = (const unsigned __int8 **)((char *)v17 + 2);
        uint64_t v13 = v18;
        break;
      case 6:
        uint64_t v32 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, v15, v16);
        break;
      case 7:
        uint64_t v14 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, v15, v16);
        LOBYTE(v31) = v20;
        BYTE4(v31) = 1;
        break;
      case 9:
        LOBYTE(v27) = 1;
        BYTE1(v26) = 1;
        LOBYTE(v26) = v10 & 1;
        LOBYTE(v25) = 1;
        BYTE4(v++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v31;
        LODWORD(v++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v28;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, void, void, uint64_t, uint64_t, uint64_t, int, unsigned char *, int, uint64_t, int, char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND", a3, a4, BYTE4(v31) & 1, v11 & 1, v29, v12, v24, v14, v25, v13, v26, v32, v27, &v34);
        v14 += v28;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad lazy bind opcode 0x%02X", v19 & 0xF0);
        break;
    }
  }
  while (!v34);
  return v34 != 0;
}

uint64_t ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke_2(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14 = *(void *)(a1[5] + 8);
  if (*(void *)(v14 + 48) != a12 || *(void *)(v14 + 56) != a14)
  {
    uint64_t v15 = *(void *)(a1[6] + 8);
    int v16 = *(_DWORD *)(v15 + 24);
    *(_DWORD *)(v15 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16 + 1;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 4dyld4::halt("obsolete dyld API called", 0) = v16;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 44) = -3;
    *(void *)(*(void *)(a1[5] + 8) + 48) = a12;
    *(void *)(*(void *)(a1[5] + 8) + 56) = a14;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 64) = 0;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 65) = 0;
  }
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesWeak(dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(void *)a3 || !*(_DWORD *)(*(void *)a3 + 28)) {
    return 0;
  }
  unsigned int v10 = dyld3::MachOFile::pointerSize(a1);
  v44[0] = 0;
  unsigned int v37 = dyld3::MachOFile::dependentDylibCount(a1, 0);
  char v11 = 0;
  char v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(void *)a3 + 24));
  uint64_t v35 = a6;
  long long v36 = (unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(void *)a3 + 28));
  char v14 = 1;
  char v15 = 1;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v17 = LinkEditContent;
    if ((LinkEditContent >= (const unsigned __int8 **)v36) | v11 & 1) {
      break;
    }
    unsigned __int8 v19 = (char *)LinkEditContent + 1;
    unsigned int v18 = *(unsigned __int8 *)LinkEditContent;
    uint64_t LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    unsigned int v20 = v18 & 0xF;
    char v11 = 1;
    switch(v18 >> 4)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 3u:
        Diagnostics::error((vm_address_t *)a2, "unexpected dylib ordinal in weak_bind");
        goto LABEL_17;
      case 4u:
        if (*v19)
        {
          int v21 = (const unsigned __int8 **)((char *)v17 + 2);
          do
          {
            uint64_t LinkEditContent = v21;
            int v22 = *(unsigned __int8 *)v21;
            int v21 = (const unsigned __int8 **)((char *)v21 + 1);
          }
          while (v22);
          uint64_t v17 = (const unsigned __int8 **)((char *)v21 - 2);
        }
        char v38 = v18 & 1;
        uint64_t LinkEditContent = (const unsigned __int8 **)((char *)v17 + 2);
        if (v20 >= 8) {
          (*(void (**)(uint64_t, unsigned char *))(v35 + 16))(v35, v19);
        }
        char v11 = 0;
        char v14 = 1;
        uint64_t v12 = v19;
        break;
      case 5u:
        char v11 = 0;
        char v15 = v18 & 0xF;
        break;
      case 6u:
        uint64_t v40 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v11 = 0;
        char v14 = 1;
        break;
      case 7u:
        uint64_t v13 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v11 = 0;
        LOBYTE(v39) = v20;
        BYTE4(v39) = 1;
        break;
      case 8u:
        char v11 = 0;
        v13 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        break;
      case 9u:
        LOBYTE(v34) = v14;
        LOWORD(v33) = v38 & 1;
        LOBYTE(v32) = v15;
        BYTE4(v31) = v39;
        LODWORD(v31) = v10;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned char *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND", a3, a4, BYTE4(v39) & 1, 1, v37, 4294967293, v31, v13, v32, v12, v33, v40, v34, v44);
        char v14 = 0;
        char v11 = 0;
        v13 += v10;
        break;
      case 0xAu:
        LOBYTE(v34) = v14;
        LOWORD(v33) = v38 & 1;
        LOBYTE(v32) = v15;
        BYTE4(v31) = v39;
        LODWORD(v31) = v10;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned char *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB", a3, a4, BYTE4(v39) & 1, 1, v37, 4294967293, v31, v13, v32, v12, v33, v40, v34, v44);
        char v14 = 0;
        char v11 = 0;
        v13 += v10
             + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v23);
        break;
      case 0xBu:
        LOBYTE(v34) = v14;
        LOWORD(v33) = v38 & 1;
        LOBYTE(v32) = v15;
        BYTE4(v31) = v39;
        LODWORD(v31) = v10;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned char *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED", a3, a4, BYTE4(v39) & 1, 1, v37, 4294967293, v31, v13, v32, v12, v33, v40, v34, v44);
        char v14 = 0;
        char v11 = 0;
        v13 += v10 + v10 * v20;
        break;
      case 0xCu:
        unint64_t v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        uint64_t v26 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v25);
        if (!v24) {
          goto LABEL_17;
        }
        uint64_t v27 = v26 + v10;
        unsigned int v28 = 1;
        do
        {
          LOBYTE(v34) = v14;
          LOWORD(v33) = v38 & 1;
          LOBYTE(v32) = v15;
          BYTE4(v31) = v39;
          LODWORD(v31) = v10;
          (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned char *, int, uint64_t, int, unsigned char *))(a5 + 16))(a5, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB", a3, a4, BYTE4(v39) & 1, 1, v37, 4294967293, v31, v13, v32, v12, v33, v40, v34, v44);
          char v14 = 0;
          v13 += v27;
          if (v44[0]) {
            break;
          }
          unint64_t v29 = v28++;
        }
        while (v24 > v29);
        char v11 = 0;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X");
LABEL_17:
        char v11 = 0;
        break;
    }
  }
  while (!v44[0]);
  return v44[0] != 0;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke(uint64_t result, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) != *a3)
  {
    uint64_t v4 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
    *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a3;
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2(uint64_t result, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) != *a3)
  {
    uint64_t v4 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
    *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a3;
  }
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v8 = a1 + 32;
  uint64_t v7 = *(void *)(a1 + 32);
  v10[0] = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 8) + 24);
  v10[1] = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  char v13 = a5;
  char v14 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(v7 + 16))(v7, v10, a6, a4);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 32;
  uint64_t v3 = *(void *)(a1 + 32);
  int v7 = *(_DWORD *)(*(void *)(*(void *)(v4 + 8) + 8) + 24);
  int v8 = -3;
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  __int16 v11 = 0;
  char v6 = 0;
  uint64_t result = (*(uint64_t (**)(void))(v3 + 16))();
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

void dyld3::MachOAnalyzer::forEachBindLocation_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke;
  void v5[3] = &unk_1EFF66F90;
  v5[4] = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke_2;
  void v4[3] = &unk_1EFF66FB8;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(a1, a2, 0, (uint64_t)v5, (uint64_t)v4);
}

uint64_t ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t dyld3::MachOAnalyzer::forEachRebaseLocation_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v26);
  BOOL hasError = Diagnostics::hasError((Diagnostics *)a2);
  if (hasError) {
    return 0;
  }
  __chkstk_darwin(hasError, v7, v8, v9, v10, v11, v12, v13, v17);
  int v16 = &v18[-8 * v15 - 1];
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 0x40000000;
  v27[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
  v27[3] = &__block_descriptor_tmp_58_0;
  v27[4] = v16;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v27);
  if (Diagnostics::hasError((Diagnostics *)a2)) {
    return 0;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  _OWORD v18[2] = ___ZNK5dyld313MachOAnalyzer29forEachRebaseLocation_OpcodesER11DiagnosticsU13block_pointerFvyRbE_block_invoke;
  void v18[3] = &unk_1EFF66FE0;
  long long v22 = v26[3];
  long long v23 = v26[4];
  long long v24 = v26[5];
  long long v25 = v26[6];
  long long v19 = v26[0];
  long long v20 = v26[1];
  long long v21 = v26[2];
  v18[4] = a3;
  return dyld3::MachOAnalyzer::forEachRebase_Opcodes(a1, a2, (uint64_t)v26, (uint64_t)v16, (uint64_t)v18);
}

uint64_t dyld3::MachOAnalyzer::forEachRebase_Opcodes(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (dyld3::MachOFile::is64(a1)) {
    int v10 = 2;
  }
  else {
    int v10 = 1;
  }
  unsigned int v41 = v10;
  if (!*(void *)a3) {
    dyld3::MachOAnalyzer::forEachRebase_Opcodes();
  }
  uint64_t v46 = a4;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, a3 + 72, *(_DWORD *)(*(void *)a3 + 8));
  uint64_t v45 = a3;
  uint64_t v39 = *(unsigned int *)(*(void *)a3 + 12);
  int v40 = (int)LinkEditContent;
  uint64_t v12 = (const unsigned __int8 **)((char *)LinkEditContent + v39);
  long long v51 = LinkEditContent;
  unsigned int v13 = dyld3::MachOFile::pointerSize(a1);
  int v14 = 0;
  uint64_t v15 = 0;
  unsigned __int8 v16 = 0;
  uint64_t v17 = 0;
  unsigned __int8 v50 = 0;
  uint64_t v43 = a2;
  uint64_t v44 = a5;
  uint64_t v48 = v13;
  int v42 = v12;
  while (2)
  {
    if (Diagnostics::noError((Diagnostics *)a2))
    {
      long long v19 = v51;
      if (v51 < v12)
      {
        unsigned __int8 v20 = *(unsigned char *)v51;
        long long v51 = (const unsigned __int8 **)((char *)v51 + 1);
        uint64_t v21 = v17;
        uint64_t v17 = v20 & 0xF;
        switch(v20 >> 4)
        {
          case 0:
            unsigned int v37 = (char *)v19 + 1;
            if ((char *)v12 - v37 >= 16) {
              Diagnostics::error(a2, "rebase opcodes terminated early at offset %d of %d", v37 - v40, v39);
            }
            return 1;
          case 1:
            if (v17 == 1)
            {
              uint64_t v17 = v41;
            }
            else
            {
              if (v17 == 2) {
                unsigned int v22 = 4;
              }
              else {
                unsigned int v22 = 0;
              }
              if (v17 == 3) {
                uint64_t v17 = 3;
              }
              else {
                uint64_t v17 = v22;
              }
            }
            goto LABEL_46;
          case 2:
            uint64_t v15 = dyld3::MachOFile::read_uleb128(a2, &v51, v12, v18);
            int v14 = 1;
            unsigned __int8 v16 = v17;
            goto LABEL_45;
          case 3:
            v15 += dyld3::MachOFile::read_uleb128(a2, &v51, v12, v18);
            goto LABEL_45;
          case 4:
            v15 += (v48 * v17);
            goto LABEL_45;
          case 5:
            if ((v20 & 0xF) == 0) {
              goto LABEL_45;
            }
            unsigned int v23 = 1;
            do
            {
              (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, _DWORD, unsigned __int8 *))(v44 + 16))(v44, "REBASE_OPCODE_DO_REBASE_IMM_TIMES", v45, v46, v14 & 1, v48, v16, v15, v21, &v50);
              v15 += v48;
              if (v50) {
                BOOL v24 = 1;
              }
              else {
                BOOL v24 = v23 >= v17;
              }
              ++v23;
            }
            while (!v24);
            uint64_t v12 = v42;
            a2 = v43;
            uint64_t v17 = v21;
            if (v50) {
              return v50;
            }
            continue;
          case 6:
            uint64_t v25 = dyld3::MachOFile::read_uleb128(a2, &v51, v12, v18);
            if (!v25) {
              goto LABEL_45;
            }
            unint64_t v26 = v25;
            unsigned int v27 = 1;
            do
            {
              (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, _DWORD, unsigned __int8 *))(v44 + 16))(v44, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES", v45, v46, v14 & 1, v48, v16, v15, v21, &v50);
              v15 += v48;
              unint64_t v28 = v27++;
              if (v50) {
                BOOL v29 = 0;
              }
              else {
                BOOL v29 = v26 > v28;
              }
            }
            while (v29);
            uint64_t v12 = v42;
            a2 = v43;
            uint64_t v17 = v21;
            goto LABEL_46;
          case 7:
            uint64_t v17 = v21;
            (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, _DWORD, unsigned __int8 *))(v44 + 16))(v44, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB", v45, v46, v14 & 1, v48, v16, v15, v21, &v50);
            v15 += v48 + dyld3::MachOFile::read_uleb128(a2, &v51, v12, v30);
            goto LABEL_46;
          case 8:
            unint64_t v31 = dyld3::MachOFile::read_uleb128(a2, &v51, v12, v18);
            if (Diagnostics::hasError((Diagnostics *)a2)
              || (uint64_t v33 = dyld3::MachOFile::read_uleb128(a2, &v51, v12, v32), !v31))
            {
LABEL_45:
              uint64_t v17 = v21;
            }
            else
            {
              uint64_t v47 = v33 + v48;
              int v49 = v14;
              unsigned int v34 = 1;
              uint64_t v17 = v21;
              do
              {
                (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, _DWORD, unsigned __int8 *))(v44 + 16))(v44, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB", v45, v46, v49 & 1, v48, v16, v15, v21, &v50);
                unint64_t v35 = v34++;
                v15 += v47;
                if (v50) {
                  BOOL v36 = 0;
                }
                else {
                  BOOL v36 = v31 > v35;
                }
              }
              while (v36);
              uint64_t v12 = v42;
              a2 = v43;
              int v14 = v49;
            }
            goto LABEL_46;
          default:
            Diagnostics::error(a2, "unknown rebase opcode 0x%02X", v20 & 0xF0);
LABEL_46:
            if (v50) {
              return v50;
            }
            continue;
        }
      }
    }
    return v50;
  }
}

uint64_t ___ZNK5dyld313MachOAnalyzer29forEachRebaseLocation_OpcodesER11DiagnosticsU13block_pointerFvyRbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t metadata_visitor::Visitor::getValueFor@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (!(_BYTE)a3 || !*(unsigned char *)(result + 24)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  *a4 = *(void *)(result + 8) + a2 - *(void *)(result + 16);
  a4[1] = a2;
  a4[2] = a3;
  return result;
}

uint64_t metadata_visitor::Visitor::resolveBindOrRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, BOOL *x2_0@<X2>, void *a3@<X8>)
{
  *x2_0 = 0;
  return metadata_visitor::Visitor::resolveRebase(this, a2, a3);
}

uint64_t (****mach_o::Platform::Platform(uint64_t (****this)(mach_o::PlatformInfo_macOS *__hidden this, unsigned __int16, BOOL), int a2))(mach_o::PlatformInfo_macOS *__hidden this, unsigned __int16, BOOL)
{
  uint64_t v2 = 0;
  *this = 0;
  while (1)
  {
    uint64_t v3 = mach_o::PlatformInfo::knownPlatformInfos[v2];
    int v4 = *((_DWORD *)v3 + 2);
    if (!v4) {
      mach_o::Platform::Platform();
    }
    if (v4 == a2) {
      break;
    }
    if (++v2 == 31) {
      return this;
    }
  }
  *this = v3;
  return this;
}

BOOL mach_o::Platform::isExclaveKit(mach_o::Platform *this)
{
  return *(void *)this && *(unsigned char *)(*(void *)this + 50) != 0;
}

void mach_o::PlatformAndVersions::zip(uint64_t *a1@<X0>, uint64_t *a2@<X1>, mach_o::Error *a3@<X8>)
{
  if (!*a1)
  {
    *a1 = *a2;
LABEL_11:
    long long v8 = *(_OWORD *)(a2 + 1);
LABEL_12:
    *(_OWORD *)(a1 + 1) = v8;
LABEL_13:
    *(void *)a3 = 0;
    return;
  }
  if (*a2)
  {
    uint64_t v12 = 0;
  }
  else
  {
    mach_o::Error::Error((mach_o::Error *)&v12, "unknown platform");
    if (v12)
    {
      mach_o::Error::Error(a3, "can't zip with invalid platform");
      mach_o::Error::~Error(&v12);
      return;
    }
  }
  mach_o::Error::~Error(&v12);
  uint64_t v6 = *a1;
  uint64_t v7 = *a2;
  if (*a1 == *a2) {
    goto LABEL_11;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_macOS::singleton)
  {
    if ((uint64_t (***)(mach_o::PlatformInfo *__hidden, unsigned __int16, BOOL))v7 == &mach_o::PlatformInfo_macCatalyst::singleton)
    {
      *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
      goto LABEL_18;
    }
    goto LABEL_22;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v7 != &mach_o::PlatformInfo_macOS::singleton)
  {
    if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_zippered::singleton)
    {
      if ((uint64_t (***)(mach_o::PlatformInfo *__hidden, unsigned __int16, BOOL))v7 == &mach_o::PlatformInfo_macCatalyst::singleton)
      {
        *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
LABEL_18:
        a1[2] = a2[1];
        goto LABEL_13;
      }
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_macCatalyst::singleton)
  {
    long long v8 = *(_OWORD *)(a2 + 1);
    uint64_t v11 = a1[1];
    *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
LABEL_30:
    *((void *)&v8 + 1) = v11;
    goto LABEL_12;
  }
  if ((uint64_t (***)(mach_o::PlatformInfo_macOS *__hidden, unsigned __int16, BOOL))v6 == &mach_o::PlatformInfo_zippered::singleton)
  {
    long long v8 = *(_OWORD *)(a2 + 1);
    uint64_t v11 = a1[2];
    *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
    goto LABEL_30;
  }
LABEL_21:
  if (!v6)
  {
    uint64_t v9 = "unknown";
    if (v7) {
      goto LABEL_23;
    }
LABEL_25:
    int v10 = "unknown";
    goto LABEL_26;
  }
LABEL_22:
  uint64_t v9 = *(const char **)(v6 + 16);
  if (!v7) {
    goto LABEL_25;
  }
LABEL_23:
  int v10 = *(const char **)(v7 + 16);
LABEL_26:
  mach_o::Error::Error(a3, "incompatible platforms: %s - %s", v9, v10);
}

uint64_t mach_o::PlatformInfo_macOS::versionForYear(mach_o::PlatformInfo_macOS *this, unsigned int a2, int a3)
{
  if (a2 == 2020) {
    char v3 = a3;
  }
  else {
    char v3 = 1;
  }
  if (a2 <= 0x7E4 && (v3 & 1) != 0)
  {
    if (a3) {
      int v4 = 655364;
    }
    else {
      int v4 = 655360;
    }
    return ((((_WORD)a2 - (_WORD)a3) << 8) + 11264) & 0xFF00 | v4;
  }
  else
  {
    unsigned int v6 = a2 - *((unsigned __int16 *)this + 27);
    if (a3) {
      int v7 = (*(unsigned __int8 (**)(mach_o::PlatformInfo_macOS *, void))(*(void *)this + 16))(this, (unsigned __int16)--v6) << 8;
    }
    else {
      int v7 = 0;
    }
    return v7 | (v6 << 16);
  }
}

_WORD *mach_o::PlatformInfo_macOS::yearForVersion(_WORD *result, unsigned int a2, _WORD *a3, BOOL *a4)
{
  if (a2 >= 0xB0000) {
    return (_WORD *)mach_o::PlatformInfo::yearForMajorVersion(result, a2, a3, a4);
  }
  unsigned int v4 = (a2 + 16121856) >> 8;
  *a3 = v4 + 2004;
  *a4 = (a2 & 0xFC) != 0;
  if ((a2 & 0xFC) != 0) {
    *a3 = v4 + 2003;
  }
  return result;
}

uint64_t mach_o::PlatformInfo_macOS::minorVersionForSpring(mach_o::PlatformInfo_macOS *this, unsigned int a2)
{
  if (a2 < 0xE) {
    return 3;
  }
  else {
    return 4;
  }
}

uint64_t mach_o::PlatformInfo::versionForYear(mach_o::PlatformInfo *this, int a2, int a3)
{
  int v3 = a2 - *((unsigned __int16 *)this + 27);
  if (a3) {
    int v4 = (*(unsigned __int8 (**)(mach_o::PlatformInfo *, void))(*(void *)this + 16))(this, (unsigned __int16)--v3) << 8;
  }
  else {
    int v4 = 0;
  }
  return v4 | (v3 << 16);
}

uint64_t mach_o::PlatformInfo::yearForVersion(_WORD *a1, int a2, _WORD *a3, BOOL *a4)
{
  return mach_o::PlatformInfo::yearForMajorVersion(a1, a2, a3, a4);
}

uint64_t mach_o::PlatformInfo::minorVersionForSpring(mach_o::PlatformInfo *this)
{
  return 4;
}

uint64_t mach_o::PlatformInfo_bridgeOS::minorVersionForSpring(mach_o::PlatformInfo_bridgeOS *this, unsigned int a2)
{
  if (a2 < 9) {
    return 3;
  }
  else {
    return 4;
  }
}

uint64_t mach_o::PlatformInfo_firmware::versionForYear(mach_o::PlatformInfo_firmware *this)
{
  return 0x10000;
}

void mach_o::PlatformInfo_firmware::yearForVersion(uint64_t a1, uint64_t a2, _WORD *a3, unsigned char *a4)
{
  *a3 = 2020;
  *a4 = 0;
}

uint64_t mach_o::PlatformInfo_sepOS::versionForYear(mach_o::PlatformInfo_sepOS *this)
{
  return 0x10000;
}

void mach_o::PlatformInfo_sepOS::yearForVersion(uint64_t a1, uint64_t a2, _WORD *a3, unsigned char *a4)
{
  *a3 = 2020;
  *a4 = 0;
}

uint64_t mach_o::PlatformInfo_visionOS::minorVersionForSpring(mach_o::PlatformInfo_visionOS *this, int a2)
{
  if (a2 == 1) {
    return 1;
  }
  else {
    return 4;
  }
}

uint64_t mach_o::PlatformInfo::yearForMajorVersion(_WORD *a1, int a2, _WORD *a3, BOOL *a4)
{
  *a3 = a1[27] + HIWORD(a2);
  unsigned int v6 = BYTE1(a2);
  uint64_t result = (*(uint64_t (**)(_WORD *, void))(*(void *)a1 + 16))(a1, HIWORD(a2));
  *a4 = v6 >= result;
  if (v6 >= result) {
    ++*a3;
  }
  return result;
}

uint64_t amfi_load_trust_cache(char a1, uint64_t a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  v9[0] = 0xAAAAAAAAAAAAAAAALL;
  int v11 = -1431655766;
  int v14 = -1431655766;
  LOBYTE(v9[0]) = a1;
  v9[1] = a2;
  int v10 = a3;
  uint64_t v12 = a4;
  int v13 = (int)a5;
  uint64_t v15 = a6;
  int v17 = -1431655766;
  int v16 = (int)a7;
  return __sandbox_ms("AMFI", (void *)0x65, v9, a4, a5, a6, a7, a8);
}

uint32_t arc4random(void)
{
  os_unfair_lock_lock(&arc4_lock);
  int v0 = arc4_count;
  if (arc4_count > 0) {
    char v1 = rs_stired;
  }
  else {
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    arc4_stir();
    int v0 = arc4_count;
  }
  char v2 = rs;
  uint64_t v3 = (rs + 1);
  unsigned __int8 v4 = byte_1EC3F25A2[v3];
  char v5 = byte_1EC3F25A1 + v4;
  uint64_t v6 = (byte_1EC3F25A1 + v4);
  unsigned __int8 v7 = byte_1EC3F25A2[v6];
  byte_1EC3F25A2[v3] = v7;
  byte_1EC3F25A2[v6] = v4;
  int v8 = byte_1EC3F25A2[(v7 + v4)];
  uint64_t v9 = (v2 + 2);
  unsigned __int8 v10 = byte_1EC3F25A2[v9];
  unsigned __int8 v11 = v10 + v5;
  unsigned __int8 v12 = byte_1EC3F25A2[v11];
  byte_1EC3F25A2[v9] = v12;
  byte_1EC3F25A2[v11] = v10;
  int v13 = byte_1EC3F25A2[(v12 + v10)];
  uint64_t v14 = (v2 + 3);
  unsigned __int8 v15 = byte_1EC3F25A2[v14];
  unsigned __int8 v16 = v15 + v11;
  unsigned __int8 v17 = byte_1EC3F25A2[v16];
  byte_1EC3F25A2[v14] = v17;
  byte_1EC3F25A2[v16] = v15;
  int v18 = byte_1EC3F25A2[(v17 + v15)];
  rs = v2 + 4;
  uint64_t v19 = (v2 + 4);
  LOBYTE(v14) = byte_1EC3F25A2[v19];
  byte_1EC3F25A1 = v14 + v16;
  uint64_t v20 = (v14 + v16);
  unsigned __int8 v21 = byte_1EC3F25A2[v20];
  byte_1EC3F25A2[v19] = v21;
  byte_1EC3F25A2[v20] = v14;
  int v22 = byte_1EC3F25A2[(v21 + v14)];
  arc4_count = v0 - 4;
  os_unfair_lock_unlock(&arc4_lock);
  if ((v1 & 1) == 0)
  {
    arc4_fetch();
    rs_data_available = 1;
    __dmb(0xBu);
  }
  return (v8 << 24) | (v13 << 16) | (v18 << 8) | v22;
}

uint64_t arc4_fetch()
{
  uint64_t result = getentropy(&rdat, 0x80uLL);
  if (result)
  {
    int v1 = open("/dev/random", 0, 0);
    if (v1 == -1 || (int v2 = v1, v3 = read(v1, &rdat, 0x80uLL), v3 == -1)) {
LABEL_8:
    }
      abort();
    unsigned __int8 v4 = (char *)&rdat;
    size_t v5 = 128;
    while (1)
    {
      BOOL v6 = v5 > v3;
      v5 -= v3;
      if (!v6) {
        break;
      }
      v4 += v3;
      unint64_t v3 = read(v2, v4, v5);
      if (v3 == -1) {
        goto LABEL_8;
      }
    }
    return close(v2);
  }
  return result;
}

uint64_t arc4_stir()
{
  if (!rs_data_available) {
    uint64_t result = arc4_fetch();
  }
  int v1 = 0;
  rs_data_available = 0;
  __dmb(0xBu);
  unsigned __int8 v2 = rs - 1;
  int v3 = byte_1EC3F25A1;
  do
  {
    int v4 = byte_1EC3F25A2[++v2];
    v3 += v4 + rdat[v1 & 0x7F];
    byte_1EC3F25A2[v2] = byte_1EC3F25A2[v3];
    byte_1EC3F25A2[v3] = v4;
    ++v1;
  }
  while (v1 != 256);
  int v5 = 1024;
  unsigned __int8 v6 = v2;
  do
  {
    unsigned __int8 v7 = byte_1EC3F25A2[++v6];
    v2 += v7;
    byte_1EC3F25A2[v6] = byte_1EC3F25A2[v2];
    byte_1EC3F25A2[v2] = v7;
    --v5;
  }
  while (v5);
  rs = v6;
  byte_1EC3F25A1 = v2;
  arc4_count = 1600000;
  rs_stired = 1;
  return result;
}

unsigned char *extract_next_subsystem_root_path(void *a1, char *__s)
{
  size_t v4 = _platform_strlen(__s);
  int v5 = _platform_memchr(__s, 58, v4);
  if (v5) {
    size_t v4 = v5 - __s;
  }
  if (v4 > 0x3FF) {
    return 0;
  }
  unsigned __int8 v7 = v5;
  memmove(a1, __s, v4);
  *((unsigned char *)a1 + v4) = 0;
  if (v7) {
    return v7 + 1;
  }
  else {
    return 0;
  }
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  size_t v4 = _platform_strlen(__s1);
  size_t v5 = _platform_strlen(__s2);
  memmove(&__s1[v4], __s2, v5 + 1);
  return __s1;
}

uint64_t cryptex_graft_failure_exists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  uint64_t v10 = configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8 == 37 && *(unsigned char *)(v10 + 7034))
  {
    uint64_t v8 = 0;
    *(void *)(a1 + 12dyld4::halt("obsolete dyld API called", 0) = 0;
  }
  return v8;
}

uint64_t cryptex_spec_next(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 > 1) {
    return 0;
  }
  while (1)
  {
    uint64_t v3 = v1;
    size_t v4 = __specs[(*a1)++];
    uint64_t result = (*((uint64_t (**)(void))v4 + 16))();
    if (result) {
      break;
    }
    uint64_t v1 = 1;
    if (v3) {
      return 0;
    }
  }
  return result;
}

uint64_t _graft_payload_check()
{
  return 0;
}

uint64_t _graft_fire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v84[0] = 0;
  uint64_t v5 = cryptex_spec_next(v84);
  if (!v5)
  {
    LODWORD(trust_cache) = -1;
    goto LABEL_17;
  }
  uint64_t v13 = v5;
  do
  {
    bzero(v78, 0x488uLL);
    int v79 = -1;
    int v80 = -1;
    int v81 = -1;
    int v82 = -1;
    int v83 = -1;
    unint64_t v77 = 0;
    int v75 = -1;
    int v76 = -1;
    unint64_t v77 = cryptex_init(v78, v13, a3, a1);
    uint64_t v20 = cryptex_open((uint64_t)v77, &v75, v14, v15, v16, v17, v18, v19);
    if (v20)
    {
      uint64_t trust_cache = v20;
      pid_t v28 = getpid();
      dlog(-1, "libignition: %d: %12s: failed to open %s cryptex: %d\n", v29, v30, v31, v32, v33, v34, v28);
    }
    else
    {
      uint64_t v35 = cryptex_graft(v77, &v76, v21, v22, v23, v24, v25, v26);
      if (v35)
      {
        uint64_t trust_cache = v35;
        pid_t v43 = getpid();
        dlog(-1, "libignition: %d: %12s: failed to graft %s cryptex: %d\n", v44, v45, v46, v47, v48, v49, v43);
      }
      else
      {
        uint64_t trust_cache = cryptex_load_trust_cache(v77, v36, v37, v38, v39, v40, v41, v42);
        pid_t v50 = getpid();
        if (trust_cache)
        {
          dlog(-1, "libignition: %d: %12s: failed to load trust cache: cryptex = %s: %d\n", v51, v52, v53, v54, v55, v56, v50);
          if (trust_cache >= 0x6A) {
            goto LABEL_17;
          }
          pid_t v57 = getpid();
          dlog(-1, "libignition: %d: %12s: failed to load trust cache for %s cryptex: %d\n", v58, v59, v60, v61, v62, v63, v57);
        }
        else
        {
          dlog(-1, "libignition: %d: %12s: loaded trust cache: cryptex = %s\n", v51, v52, v53, v54, v55, v56, v50);
          boot_set_root(a3, *(void *)(v13 + 80), &v76, v64, v65, v66, v67, v68);
          boot_set_root(a3, *(void *)(v13 + 88), &v75, v69, v70, v71, v72, v73);
        }
      }
    }
    closefd_optional(&v75, (int)"canonical root");
    closefd_optional(&v76, (int)"graft point");
    cryptex_destroy(&v77);
    if (trust_cache)
    {
      if (trust_cache < 0x6A) {
        return trust_cache;
      }
LABEL_17:
      dyld_halt("error not set to valid posix code: %d", v6, v7, v8, v9, v10, v11, v12, trust_cache);
    }
    uint64_t v13 = cryptex_spec_next(v84);
  }
  while (v13);
  return 0;
}

uint64_t _hello_payload_check()
{
  return 0;
}

uint64_t _goodbye_payload_check()
{
  return 0;
}

char **_cryptex_spec_iterate_select_app(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v9 = configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = arguments(v9, v10, v11, v12, v13, v14, v15, v16);
  boot_get();
  if ((*(unsigned char *)(*(void *)(v9 + 6792) + 67) & 0x40) == 0)
  {
    pid_t v18 = getpid();
    dlog(-1, "libignition: %d: livefs boot; skipping app cryptex\n", v19, v20, v21, v22, v23, v24, v18);
    uint64_t v32 = *(void *)(v17 + 16);
    if ((unint64_t)(v32 - 1) >= 2)
    {
      if (v32) {
        dyld_halt("unreachable", v25, v26, v27, v28, v29, v30, v31, v34);
      }
      return &_cryptex_spec_app_livefs;
    }
  }
  return (char **)v8;
}

void *cryptex_init(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  result[1] = a3;
  result[2] = a4;
  *uint64_t result = a2;
  do
  {
    uint64_t v5 = &result[v4];
    v5[4] = 0;
    *((_DWORD *)v5 + 1dyld4::halt("obsolete dyld API called", 0) = -1;
    v4 += 2;
  }
  while (v4 != 8);
  return result;
}

uint64_t cryptex_open(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v213 = *(dyld4::JustInTimeLoader **)a1;
  int v214 = -1;
  uint64_t v10 = configuration(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v11 = *(dyld4::JustInTimeLoader **)a1;
  bzero(value, 0x400uLL);
  memset(v217, 0, sizeof(v217));
  unint64_t v12 = *((void *)v11 + 7);
  int v216 = -1;
  int v13 = openat(*(_DWORD *)(*(void *)(a1 + 8) + 16), *((const char **)v11 + 9), 0x200000);
  int v218 = v13;
  if (v13 < 0)
  {
    bzero(v215, 0x400uLL);
    realpathfd(*(_DWORD *)(*(void *)(a1 + 8) + 16), (uint64_t)v215, (int)"rootmnt");
    uint64_t v185 = boot_get();
    uint64_t v186 = (*v185)[1];
    unint64_t v187 = (unint64_t)(*v185)[2];
    int v188 = *__error();
    __error();
    ignition_halt(v186, v188, v187, "failed to open canonical cryptex location: root = %s, subpath = %s: %d", v189, v190, v191, v192, (int)v215);
  }
  ssize_t v14 = fgetxattr(v13, "com.apple.root.cryptex", value, 0x400uLL, 0, 0);
  uint64_t v15 = __error();
  if (v14 < 0)
  {
    if (!*v15) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v16, v17, v18, v19, v20, v21, v22, (int)"xattr_len");
    }
  }
  else
  {
    *uint64_t v15 = 0;
  }
  int v23 = *__error();
  if (v23 == 93) {
    goto LABEL_10;
  }
  if (v23)
  {
    fsid_t v198 = boot_get();
    uint64_t v199 = (*v198)[1];
    unint64_t v200 = (unint64_t)(*v198)[2];
    int v201 = *__error();
    uint64_t v202 = *((void *)v11 + 9);
    __error();
    ignition_halt(v199, v201, v200, "failed to read xattr: path = %s, attr = %s: %d", v203, v204, v205, v206, v202);
  }
  value[v14] = 0;
  if (!_platform_strlen(value))
  {
    pid_t v32 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: root xattr empty\n", v33, v34, v35, v36, v37, v38, v32);
LABEL_10:
    pid_t v39 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: no root xattr present\n", v40, v41, v42, v43, v44, v45, v39);
    unint64_t v31 = 0;
    goto LABEL_11;
  }
  v217[0] = value;
  ++v12;
  pid_t v24 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: found root xattr: %s\n", v25, v26, v27, v28, v29, v30, v24);
  unint64_t v31 = 1;
LABEL_11:
  closefd(&v218, (int)"canonical cryptex");
  if (v12 > 3)
  {
    int v193 = boot_get();
    ignition_halt((*v193)[1], 0, (unint64_t)(*v193)[2], "path count overflow: actual = %lu, expected <= %lu", v194, v195, v196, v197, v12);
  }
  uint64_t v212 = v10;
  unint64_t v46 = v12 - v31;
  if (v12 > v31)
  {
    uint64_t v47 = &v217[v31];
    uint64_t v48 = (uint64_t *)((char *)v11 + 32);
    do
    {
      uint64_t v49 = *v48++;
      *v47++ = v49;
      --v46;
    }
    while (v46);
  }
  uint64_t v50 = 0;
  while (1)
  {
    uint64_t v51 = (const char *)v217[v50];
    pid_t v52 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: opening preboot subdirectory: %s\n", v53, v54, v55, v56, v57, v58, v52);
    int v59 = openat(*(_DWORD *)(*(void *)(a1 + 8) + 24), v51, 537919488);
    int v216 = v59;
    uint64_t v60 = __error();
    if (v59 < 0)
    {
      if (!*v60) {
        dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v61, v62, v63, v64, v65, v66, v67, (int)"pbobjdir");
      }
    }
    else
    {
      int *v60 = 0;
    }
    int v68 = *__error();
    if (v68 == 2)
    {
      int v84 = __error();
      if (v51 == value) {
        dyld_halt("root object directory does not exist: %s", v77, v78, v79, v80, v81, v82, v83, (int)value);
      }
      uint64_t v69 = *v84;
      goto LABEL_24;
    }
    if (!v68) {
      break;
    }
    uint64_t v69 = *__error();
    pid_t v70 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to open preboot subdirectory: %s: %d\n", v71, v72, v73, v74, v75, v76, v70);
LABEL_24:
    if (v69 == 2 && ++v50 < v12) {
      continue;
    }
    if (v59 < 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if (v51 == value)
  {
    strlcpy((char *)(a1 + 128), value, 0x400uLL);
    *(void *)(a1 + 1152) = a1 + 128;
  }
  pid_t v145 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: opened preboot subdirectory: %s\n", v146, v147, v148, v149, v150, v151, v145);
  uint64_t v69 = 0;
  if ((v59 & 0x80000000) == 0) {
LABEL_27:
  }
    *(_DWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = xferfd(&v216);
LABEL_28:
  if (v69 >= 0x6A) {
    goto LABEL_34;
  }
  if (v69)
  {
    pid_t v85 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to open object directory: %d\n", v86, v87, v88, v89, v90, v91, v85);
    goto LABEL_31;
  }
  uint64_t v94 = openat(*(_DWORD *)(*(void *)(a1 + 8) + 16), *((const char **)v213 + 9), 0x100000);
  int v214 = v94;
  if ((v94 & 0x80000000) != 0)
  {
    uint64_t v69 = *__error();
    pid_t v156 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to open canonical root: %d\n", v157, v158, v159, v160, v161, v162, v156);
    if (!v69) {
      goto LABEL_63;
    }
    goto LABEL_31;
  }
  uint64_t v102 = 0;
  while (2)
  {
    uint64_t v103 = *((void *)v213 + v102 + 12);
    if (!v103)
    {
      pid_t v108 = getpid();
      uint64_t v94 = dlog(-1, "libignition: %d: %12s: %s: object spec not present: %lu\n", v109, v110, v111, v112, v113, v114, v108);
      goto LABEL_47;
    }
    uint64_t v104 = configuration(v94, v95, v96, v97, v98, v99, v100, v101);
    uint64_t v105 = *(const char **)(v103 + 16);
    int v106 = *(_DWORD *)(v103 + 12);
    LODWORD(v217[0]) = -1;
    bzero(value, 0x400uLL);
    uint64_t v107 = *(void *)(a1 + 1152);
    if (!v105) {
      uint64_t v105 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, char *))(v103 + 24))(v103, v104, value);
    }
    v215[0] = openat(*(_DWORD *)(a1 + 24), v105, v106);
    if ((v215[0] & 0x80000000) == 0)
    {
      LODWORD(v217[0]) = xferfd(v215);
      goto LABEL_46;
    }
    uint64_t v122 = *__error();
    if (v122 >= 0x6A) {
      goto LABEL_76;
    }
    if (v122 != 2)
    {
      if (v122)
      {
        pid_t v171 = getpid();
        dlog(-1, "libignition: %d: %12s: %s: failed to open object: mach_port_name_t name = %s, type = %s: %d\n", v172, v173, v174, v175, v176, v177, v171);
        goto LABEL_67;
      }
LABEL_46:
      object_setfd(v103, a1 + 32, v217);
      pid_t v123 = getpid();
      v94 = dlog(-1, "libignition: %d: %12s: %s: opened object: mach_port_name_t name = %s, type = %s, slot = %llu\n", v124, v125, v126, v127, v128, v129, v123);
LABEL_47:
      if (++v102 != 4) {
        continue;
      }
      uint64_t v152 = *(void *)(v212 + 6952);
      if (v152)
      {
        int v153 = *(_DWORD *)(v152 + 46);
        if ((v153 - 1) < 3)
        {
          unint64_t v154 = v213;
          uint64_t CatalystMacTwinPatches = dyld4::JustInTimeLoader::getCatalystMacTwinPatches(v213);
LABEL_62:
          *(void *)(a1 + 96) = CatalystMacTwinPatches;
          pid_t v163 = getpid();
          dlog(-1, "libignition: %d: %12s: %s: selected im4m spec: %s\n", v164, v165, v166, v167, v168, v169, v163);
          *(void *)(a1 + 104) = *((void *)v154 + 13);
          *(void *)(a1 + 112) = *((void *)v154 + 14);
          *(void *)(a1 + 12dyld4::halt("obsolete dyld API called", 0) = *((void *)v154 + 15);
          *a2 = xferfd(&v214);
          goto LABEL_63;
        }
        if (v153)
        {
          uint64_t v207 = boot_get();
          ignition_halt((*v207)[1], 0, (unint64_t)(*v207)[2], "bogus secure boot level: 0x%x", v208, v209, v210, v211, v153);
        }
      }
      unint64_t v154 = v213;
      uint64_t CatalystMacTwinPatches = *((void *)v213 + 12);
      goto LABEL_62;
    }
    break;
  }
  pid_t v130 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: object not present: mach_port_name_t name = %s, type = %s\n", v131, v132, v133, v134, v135, v136, v130);
  uint64_t v137 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v103 + 32))(v103, v107, 2);
  if (!v137)
  {
    pid_t v138 = getpid();
    v94 = dlog(-1, "libignition: %d: %12s: %s: object absence permitted: mach_port_name_t name = %s, type = %s, xattr path = %s\n", v139, v140, v141, v142, v143, v144, v138);
    goto LABEL_47;
  }
  uint64_t v122 = v137;
  if (v137 >= 0x6A) {
LABEL_76:
  }
    dyld_halt("error not set to valid posix code: %d", v115, v116, v117, v118, v119, v120, v121, v122);
LABEL_67:
  pid_t v178 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: failed to open object: %s: %d\n", v179, v180, v181, v182, v183, v184, v178);
  uint64_t v69 = v122;
  if (!v122)
  {
LABEL_63:
    closefd_optional(&v214, (int)"canonical root");
    return 0;
  }
LABEL_31:
  uint64_t v92 = 0;
  uint64_t v93 = a1 + 32;
  do
  {
    object_fd_close(v93 + v92);
    v92 += 16;
  }
  while (v92 != 64);
  closefd_optional(&v214, (int)"canonical root");
  if (v69 >= 0x6A) {
LABEL_34:
  }
    dyld_halt("error not set to valid posix code: %d", v77, v78, v79, v80, v81, v82, v83, v69);
  return v69;
}

uint64_t cryptex_graft(void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  arguments((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v144[0] = -1;
  bzero(v143, 0x400uLL);
  bzero(v142, 0x400uLL);
  bzero(v141, 0x400uLL);
  bzero(v140, 0x400uLL);
  long long v138 = 0u;
  memset(v139, 0, sizeof(v139));
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v125 = 0u;
  long long v124 = 0u;
  long long v123 = 0u;
  long long v122 = 0u;
  long long v121 = 0u;
  long long v120 = 0u;
  long long v119 = 0u;
  long long v118 = 0u;
  long long v117 = 0u;
  long long v116 = 0u;
  long long v115 = 0u;
  long long v114 = 0u;
  long long v113 = 0u;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  uint64_t v10 = *a1;
  int v11 = *(_DWORD *)(*a1 + 20);
  v107[0] = 1;
  v107[1] = v11;
  uint64_t v108 = -1;
  int v109 = -1;
  unint64_t v12 = *(const char **)(v10 + 64);
  int v106 = -1;
  uint64_t v13 = a1[13];
  if (v13)
  {
    ssize_t v14 = (void *)object_getfd(v13, (uint64_t)(a1 + 4));
    int v15 = object_getfd(a1[14], (uint64_t)(a1 + 4));
    int v16 = object_getfd(a1[12], (uint64_t)(a1 + 4));
    realpathfd((int)v14, (uint64_t)v143, (int)"dmg");
    realpathfd(v15, (uint64_t)v142, (int)"seal im4p");
    realpathfd(v16, (uint64_t)v140, (int)"chosen im4m");
    int v17 = openat(*(_DWORD *)(a1[1] + 20), v12, 537919488);
    v144[0] = v17;
    if (v17 < 0)
    {
      uint64_t v29 = *__error();
      pid_t v44 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: failed to open graft point: %s: %d\n", v45, v46, v47, v48, v49, v50, v44);
    }
    else
    {
      realpathfd(v17, (uint64_t)v141, (int)"uncovered graft point");
      int v109 = v15;
      LODWORD(v108) = v16;
      *(void *)&long long v110 = *(unsigned int *)(*a1 + 12);
      pid_t v18 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: grafting: method = syscall, dmg = %s, seal = %s, graft point = %s, im4m = %s\n", v19, v20, v21, v22, v23, v24, v18);
      if (graftdmg(v14, v141, (void *)*(unsigned int *)(*a1 + 8), v107, v25, v26, v27, v28))
      {
        uint64_t v29 = *__error();
        pid_t v30 = getpid();
        dlog(-1, "libignition: %d: %12s: %s: graftdmg: %d\n", v31, v32, v33, v34, v35, v36, v30);
      }
      else
      {
        uint64_t v29 = 0;
      }
    }
  }
  else
  {
    pid_t v37 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: cryptex has no associated disk image\n", v38, v39, v40, v41, v42, v43, v37);
    uint64_t v29 = 21;
  }
  uint64_t v51 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 136))(a1, v29);
  if (v51)
  {
    pid_t v52 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: graft failed [%s]: %d\n", v53, v54, v55, v56, v57, v58, v52);
  }
  else
  {
    if (v29 == 37)
    {
      pid_t v66 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: cryptex content already available: dmg = %s, graft point = %s, ignored error = %d\n", v67, v68, v69, v70, v71, v72, v66);
      int v106 = openat(*(_DWORD *)(a1[1] + 20), v12, 537919488);
      if (v106 < 0)
      {
        uint64_t v73 = boot_get();
        uint64_t v74 = (*v73)[1];
        unint64_t v75 = (unint64_t)(*v73)[2];
        int v76 = *__error();
        int v104 = *__error();
        ignition_halt(v74, v76, v75, "failed to open covered graft point: %d", v77, v78, v79, v80, v104);
      }
    }
    else if (v29)
    {
      pid_t v81 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: cryptex not grafted; ignoring failure: dmg = %s, ignored error = %d\n",
        v82,
        v83,
        v84,
        v85,
        v86,
        v87,
        v81);
      int v106 = open("/dev/null", 0);
      if (v106 < 0)
      {
        uint64_t v96 = boot_get();
        uint64_t v97 = (*v96)[1];
        unint64_t v98 = (unint64_t)(*v96)[2];
        int v99 = *__error();
        int v105 = *__error();
        ignition_halt(v97, v99, v98, "failed to open /dev/null for fallback: %d", v100, v101, v102, v103, v105);
      }
    }
    else
    {
      pid_t v59 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: grafted cryptex: dmg = %s, graft point = %s, ignored error = %d\n", v60, v61, v62, v63, v64, v65, v59);
      int v106 = xferfd(v144);
    }
    *a2 = xferfd(&v106);
  }
  closefd_optional(v144, (int)"uncovered graft point");
  closefd_optional(&v106, (int)"covered graft point");
  if (v51 >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v88, v89, v90, v91, v92, v93, v94, v51);
  }
  return v51;
}

uint64_t cryptex_load_trust_cache(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (unint64_t *)arguments((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  unint64_t v10 = *(void *)(a1[2] + 40) + 2;
  bzero(v104, 0x400uLL);
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  memset(v101, 0, sizeof(v101));
  uint64_t v99 = 0;
  uint64_t v100 = 0;
  memset(v98, 0, sizeof(v98));
  if (*v9 < v10)
  {
    pid_t v11 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: ignition level insufficient: operation = load trust cache, actual = %llu, required >= %llu\n", v12, v13, v14, v15, v16, v17, v11);
    return 0;
  }
  if (!a1[15])
  {
    pid_t v28 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: cryptex already available; skipping trust cache load\n",
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v28);
    return 0;
  }
  int v18 = object_getfd(a1[12], (uint64_t)(a1 + 4));
  int v19 = object_getfd(a1[15], (uint64_t)(a1 + 4));
  int v20 = v19;
  if (a1[144] && v19 < 0)
  {
    pid_t v21 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: trust cache not present in rooted cryptex\n", v22, v23, v24, v25, v26, v27, v21);
    return 0;
  }
  realpathfd(v19, (uint64_t)v104, (int)"trust cache");
  pid_t v37 = getpid();
  dlog(-1, "libignition: %d: %12s: %s: trust cache path = %s\n", v38, v39, v40, v41, v42, v43, v37);
  uint64_t v44 = buff_map_fd_anon(v101, &v103, v20);
  if (v44)
  {
    uint64_t v35 = v44;
    pid_t v45 = getpid();
    dlog(-1, "libignition: %d: %12s: %s: failed to read trust cache im4p: %d\n", v46, v47, v48, v49, v50, v51, v45);
  }
  else
  {
    uint64_t v59 = buff_map_fd_anon(v98, &v100, v18);
    if (v59)
    {
      uint64_t v35 = v59;
      pid_t v67 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: failed to read manifest: %d\n", v68, v69, v70, v71, v72, v73, v67);
    }
    else
    {
      int length_uint32 = buff_get_length_uint32((uint64_t)v103, v60, v61, v62, v63, v64, v65, v66);
      uint64_t v82 = (void *)buff_get_length_uint32((uint64_t)v100, v75, v76, v77, v78, v79, v80, v81);
      if (!amfi_load_trust_cache) {
        return 78;
      }
      if (!amfi_load_trust_cache(*(unsigned char *)(*a1 + 16), *v103, length_uint32, *v100, v82, 0, 0, v83))
      {
        pid_t v91 = getpid();
        dlog(-1, "libignition: %d: %12s: %s: loaded cryptex trust cache\n", v92, v93, v94, v95, v96, v97, v91);
        return 0;
      }
      uint64_t v35 = *__error();
      pid_t v84 = getpid();
      dlog(-1, "libignition: %d: %12s: %s: failed to load trust cache: %d\n", v85, v86, v87, v88, v89, v90, v84);
    }
  }
  if (v35 >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v52, v53, v54, v55, v56, v57, v58, v35);
  }
  return v35;
}

void *cryptex_destroy(void *result)
{
  uint64_t v1 = *result;
  if (*result)
  {
    unsigned __int8 v2 = result;
    closefd_optional((int *)(v1 + 24), (int)"object directory");
    uint64_t v3 = 0;
    uint64_t v4 = v1 + 32;
    do
    {
      uint64_t result = (void *)object_fd_close(v4 + v3);
      v3 += 16;
    }
    while (v3 != 64);
    *unsigned __int8 v2 = 0;
  }
  return result;
}

uint64_t _graft_select_payload_check()
{
  return 0;
}

uint64_t _graft_fetch_payload_check()
{
  return 0;
}

uint64_t _preboot_payload_check(uint64_t a1, uint64_t a2)
{
  return (a2 + *(void *)(a1 + 32)) & ~(*(uint64_t *)(a1 + 32) >> 63);
}

uint64_t _preboot_fire(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  configuration(a1, a2, a3, a4, a5, a6, a7, a8);
  memset(v121, 0, 255);
  bzero(v120, 0x400uLL);
  long long v119 = 0;
  int v117 = 0;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  LOWORD(v98) = 1;
  uint64_t v118 = 0x6300000063;
  memset(&v96, 0, sizeof(v96));
  int v94 = -1;
  int v95 = -1;
  int v93 = -1;
  uint64_t devnode_by_role = ignition_get_devnode_by_role(16, v121, v9, v10, v11, v12, v13, v14);
  pid_t v16 = getpid();
  if (!devnode_by_role)
  {
    dlog(-1, "libignition: %d: %12s: preboot device: %s\n", v17, v18, v19, v20, v21, v22, v16);
    uint64_t devnode_by_role = ignition_get_mount_point_by_role(16, v120, &v119);
    pid_t v23 = getpid();
    if (devnode_by_role)
    {
      dlog(-1, "libignition: %d: %12s: failed to get preboot mount point: %d\n", v24, v25, v26, v27, v28, v29, v23);
      goto LABEL_6;
    }
    dlog(-1, "libignition: %d: %12s: preboot mount point: %s\n", v24, v25, v26, v27, v28, v29, v23);
    int v38 = open(v119, 537919488);
    int v95 = v38;
    if (v38 < 0)
    {
      pid_t v46 = getpid();
      dlog(-1, "libignition: %d: %12s: failed to open preboot mount point: %d\n", v47, v48, v49, v50, v51, v52, v46);
    }
    else
    {
      if (fstat64(v38, &v96))
      {
        uint64_t devnode_by_role = *__error();
        pid_t v39 = getpid();
        dlog(-1, "libignition: %d: %12s: failed to stat preboot mount point: %d\n", v40, v41, v42, v43, v44, v45, v39);
        goto LABEL_6;
      }
      *(void *)&long long v97 = v121;
      uint64_t v118 = *(void *)&v96.st_uid;
      pid_t v53 = getpid();
      dlog(-1, "libignition: %d: %12s: mounting preboot: dev = %s, uid = %u, gid = %u\n", v54, v55, v56, v57, v58, v59, v53);
      uint64_t v60 = fmount_90140467("apfs", v95, 0x100000, v121);
      if (v60 == 16)
      {
        pid_t v69 = getpid();
        dlog(-1, "libignition: %d: %12s: preboot already mounted: device = %s, mount point = %s\n", v70, v71, v72, v73, v74, v75, v69);
        int v61 = xferfd(&v95);
        int v94 = v61;
      }
      else
      {
        uint64_t devnode_by_role = v60;
        if (v60)
        {
          pid_t v86 = getpid();
          dlog(-1, "libignition: %d: %12s: failed to mount preboot: %d\n", v87, v88, v89, v90, v91, v92, v86);
          goto LABEL_6;
        }
        int v61 = open(v119, 537919488);
        int v94 = v61;
        if (v61 < 0)
        {
          uint64_t devnode_by_role = *__error();
          pid_t v62 = getpid();
          dlog(-1, "libignition: %d: %12s: failed to open preboot mount: %d\n", v63, v64, v65, v66, v67, v68, v62);
          goto LABEL_6;
        }
      }
      int v93 = dupfd(v61, (int)"preboot mount");
      boot_set_root(a3, (uint64_t)&_boot_root_preboot, &v94, v76, v77, v78, v79, v80);
      boot_set_root(a3, (uint64_t)&_boot_root_preboot_groupdir, &v93, v81, v82, v83, v84, v85);
    }
    uint64_t devnode_by_role = 0;
    goto LABEL_6;
  }
  dlog(-1, "libignition: %d: %12s: failed to get preboot device: %d\n", v17, v18, v19, v20, v21, v22, v16);
LABEL_6:
  closefd_optional(&v95, (int)"mounted-over preboot");
  closefd_optional(&v94, (int)"preboot");
  if (devnode_by_role >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v30, v31, v32, v33, v34, v35, v36, devnode_by_role);
  }
  return devnode_by_role;
}

uint64_t _cryptex1_sniff_payload_check()
{
  return 0;
}

uint64_t _cryptex1_sniff_fire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(&v22, 0, sizeof(v22));
  int v3 = fstatat64(*(_DWORD *)(a3 + 24), "cryptex1", &v22, 0);
  uint64_t v4 = __error();
  if (v3 < 0)
  {
    if (!*v4) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v5, v6, v7, v8, v9, v10, v11, (int)"ret");
    }
  }
  else
  {
    *uint64_t v4 = 0;
  }
  uint64_t result = *__error();
  if (result)
  {
    if (result != 2)
    {
      uint64_t v13 = boot_get();
      uint64_t v14 = (*v13)[1];
      unint64_t v15 = (unint64_t)(*v13)[2];
      int v16 = *__error();
      uint64_t v17 = __error();
      ignition_halt(v14, v16, v15, "failed to stat cryptex1 canary: %d", v18, v19, v20, v21, *v17);
    }
    return 8;
  }
  return result;
}

char *object_derive_im4m_name(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v4 = *(void *)(a2 + 6800);
  vm_address_t v5 = _simple_salloc();
  uint64_t v6 = (vm_address_t *)v5;
  if (v4) {
    _simple_sprintf(v5, "apticket.%s.%llX.im4m");
  }
  else {
    _simple_sprintf(v5, "apticket.%s.im4m");
  }
  uint64_t v7 = (const char *)_simple_string((unsigned char **)v6);
  strlcpy(a3, v7, 0xFFuLL);
  _simple_sfree(v6);
  return a3;
}

uint64_t object_absence_policy_default(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t object_absence_policy_optional(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 2) {
    return 0;
  }
  else {
    return a3;
  }
}

uint64_t object_absence_policy_root_optional(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 2) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = a3;
  }
  if (a2) {
    return v3;
  }
  else {
    return a3;
  }
}

uint64_t object_setfd(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = a2 + 16 * *(void *)(a1 + 40);
  if (*(void *)v5) {
    closefd((int *)(v5 + 8), (int)"object");
  }
  *(void *)uint64_t v5 = a1;
  uint64_t result = xferfd(a3);
  *(_DWORD *)(v5 + 8) = result;
  return result;
}

uint64_t object_fd_close(uint64_t result)
{
  if (*(void *)result)
  {
    uint64_t v1 = (void *)result;
    uint64_t result = closefd((int *)(result + 8), (int)"object");
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t object_getfd(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 16 * *(void *)(a1 + 40) + 8);
}

void ignition_halt(void *a1, int a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v13 = boot_get();
  uint64_t v14 = configuration_unsafe();
  vm_address_t v15 = _simple_salloc();
  if (v15)
  {
    uint64_t v17 = (unsigned char **)v15;
    _simple_vsprintf(v15, a4, &a9);
    int v16 = (char *)_simple_string(v17);
  }
  else
  {
    int v16 = "panic: [failed to allocate panic message]";
  }
  if (*((unsigned char *)v14 + 7032))
  {
    int v18 = open("/dev/console", 1);
    if ((v18 & 0x80000000) == 0) {
      fsync(v18);
    }
    ignition_write_BRA_blob((const char ***)v13, v19, v16, a2);
  }
  abort_with_reason((void *)0x23, a1, v16, a3);
}

uint64_t dupfd2(int a1, int a2, int a3)
{
  uint64_t result = dup2(a1, a2);
  if (a1 < 0)
  {
    uint64_t v6 = boot_get();
    uint64_t v7 = (*v6)[1];
    unint64_t v8 = (unint64_t)(*v6)[2];
    int v9 = *__error();
    __error();
    ignition_halt(v7, v9, v8, "failed to dup %s: src fd = %d, dst fd = %d: %d", v10, v11, v12, v13, a3);
  }
  return result;
}

uint64_t sleep_ns(unint64_t a1)
{
  kern_return_t v5;
  int v7;
  char ***v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t vars8;

  uint64_t v2 = mach_absolute_time();
  if (_tbi)
  {
    unsigned int v3 = *(_DWORD *)__tbi;
    unsigned int v4 = *(_DWORD *)(__tbi + 4);
  }
  else
  {
    uint64_t v5 = mach_timebase_info((mach_timebase_info_t)&dword_1EC3F3570);
    if (v5)
    {
      uint64_t v7 = v5;
      unint64_t v8 = boot_get();
      ignition_halt((*v8)[1], v7, (unint64_t)(*v8)[2], "mach_timebase_info: 0x%x", v9, v10, v11, v12, v7);
    }
    unsigned int v3 = dword_1EC3F3570;
    __tbuint64_t i = (uint64_t)&dword_1EC3F3570;
    unsigned int v4 = dword_1EC3F3574;
    *(double *)&qword_1EC3F3580 = (double)dword_1EC3F3570 / (double)dword_1EC3F3574;
    qword_1EC3F3578 = 0xFFFFFFFFFFFFFFFFLL / dword_1EC3F3570;
    _tbuint64_t i = (uint64_t)&__tbi;
  }
  if (v3 != v4) {
    a1 = a1 / v3 * v4;
  }

  return mach_wait_until(a1 + v2);
}

int fmount_90140467(const char *a1, int a2, int a3, void *a4)
{
  uint64_t v5 = v4;
  if (!a4) {
    goto LABEL_4;
  }
  bzero(&v18, 0x878uLL);
  if (fstatfs64(a2, &v18))
  {
LABEL_5:
    int result = *__error();
    goto LABEL_6;
  }
  if (_platform_strcmp((const char *)a4, v18.f_mntfromname))
  {
LABEL_4:
    int result = fmount(a1, a2, a3, v5);
    if (!result) {
      return result;
    }
    goto LABEL_5;
  }
  int result = 16;
LABEL_6:
  if (result >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v10, v11, v12, v13, v14, v15, v16, result);
  }
  return result;
}

ssize_t ignition_write_BRA_blob(const char ***a1, uint64_t a2, const char *a3, uint64_t a4)
{
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  HIBYTE(v16) = -86;
  strlcpy((char *)v15 + 2, **a1, 0x18uLL);
  strlcpy((char *)&v15[1] + 10, *a1[1], 0x18uLL);
  *(void *)((char *)&v15[3] + 2) = a4;
  strlcpy((char *)&v15[3] + 10, "AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE", 0x25uLL);
  strlcpy((char *)&v15[5] + 15, a3, 0x40uLL);
  ssize_t result = sysctlbyname("security.mac.img4.ignition_failure_blob", 0, 0, v15, 0xA0uLL);
  if (result)
  {
    unint64_t v8 = __error();
    return _simple_dprintf(2, "failed to write BRA failure blob: %d\n", v9, v10, v11, v12, v13, v14, *v8);
  }
  return result;
}

uint64_t ignition_get_devnode_by_role(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v34 = -86;
  v32[0] = -22014;
  v32[1] = a1;
  memset(v33, 0, sizeof(v33));
  if (a1 != 256)
  {
    if (a1 != 16) {
      dyld_halt("unsupported role: 0x%x", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a1);
    }
    if (fsctl("/", 0xC1044A50uLL, v32, 0))
    {
      uint64_t v9 = *__error();
      pid_t v10 = getpid();
      dlog(-1, "libignition: %d: failed to lookup preboot: %d\n", v11, v12, v13, v14, v15, v16, v10);
      goto LABEL_7;
    }
LABEL_9:
    strlcpy(a2, v33, 0xFFuLL);
    return 0;
  }
  if (!fsctl("/", 0xC1044A50uLL, v32, 0)) {
    goto LABEL_9;
  }
  uint64_t v9 = *__error();
  pid_t v24 = getpid();
  dlog(-1, "libignition: %d: failed to lookup xART device: %d\n", v25, v26, v27, v28, v29, v30, v24);
LABEL_7:
  if (v9 >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v17, v18, v19, v20, v21, v22, v23, v9);
  }
  return v9;
}

uint64_t ignition_get_mount_point_by_role(int a1, char *a2, char **a3)
{
  bzero(v37, 0x938uLL);
  size_t v36 = 2360;
  int v6 = sysctlbyname("vfs.generic.apfs.edt_fstab", v37, &v36, 0, 0);
  uint64_t v7 = __error();
  if (v6 < 0)
  {
    if (!*v7) {
      dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v8, v9, v10, v11, v12, v13, v14, (int)"ret");
    }
  }
  else
  {
    int *v7 = 0;
  }
  int v15 = *__error();
  if (v15)
  {
    if (v15 == 12)
    {
      size_t v36 = 0;
      sysctlbyname("vfs.generic.apfs.edt_fstab", 0, &v36, 0, 0);
      uint64_t v26 = boot_get();
      ignition_halt((*v26)[1], 0, (unint64_t)(*v26)[2], "device tree fstab buffer not large enough: actual = %lu, expected >= %lu, required DEVICE_TREE_FSTAB_COUNT >= %lu", v27, v28, v29, v30, 2360);
    }
    uint64_t result = *__error();
    if (result >= 0x6A) {
      dyld_halt("error not set to valid posix code: %d", v17, v18, v19, v20, v21, v22, v23, result);
    }
  }
  else
  {
    size_t v24 = v36 / 0xEC;
    if (v36 % 0xEC)
    {
      uint64_t v31 = boot_get();
      ignition_halt((*v31)[1], 0, (unint64_t)(*v31)[2], "non-integral fstab buffer returned; possible mismatch between kernel and userspace structs: total = %lu, expecte"
        "d element vm_size_t size = %lu",
        v32,
        v33,
        v34,
        v35,
        v36);
    }
    if (v36 < 0xEC)
    {
      return 2;
    }
    else
    {
      for (uint64_t i = (const char *)&v38; *(_DWORD *)i != a1; i += 236)
      {
        if (!--v24) {
          return 2;
        }
      }
      strlcpy(a2, i - 200, 0x400uLL);
      uint64_t result = 0;
      *a3 = a2;
    }
  }
  return result;
}

uint64_t _open_as(int a1, int *a2)
{
  unint64_t v4 = 0;
  int v5 = *a2;
  *a2 = -1;
  do
  {
    int v6 = open("/dev/null", a1, 0);
    uint64_t v7 = __error();
    if (v6 < 0)
    {
      if (!*v7) {
        dyld_halt("errno unset, wrong return value being checked?: %s = %lld", v8, v9, v10, v11, v12, v13, v14, (int)"srcfd");
      }
    }
    else
    {
      int *v7 = 0;
    }
    uint64_t v15 = *__error();
    if (v15)
    {
      if (v15 != 5)
      {
        int v34 = v6;
        uint64_t v15 = *__error();
        if (v6 < 0) {
          goto LABEL_18;
        }
        goto LABEL_16;
      }
      uint64_t v15 = *__error();
      sleep_ns(0x2FAF080uLL);
      ++v4;
    }
  }
  while (v6 < 0 && v4 < 0xA);
  int v34 = v6;
  if (v4 == 10)
  {
    *(void *)uint64_t v33 = -1;
    if (pipe(v33))
    {
      size_t v24 = boot_get();
      uint64_t v25 = (*v24)[1];
      unint64_t v26 = (unint64_t)(*v24)[2];
      int v27 = *__error();
      uint64_t v28 = __error();
      ignition_halt(v25, v27, v26, "failed to create pipe for 88828241 workaround: %d", v29, v30, v31, v32, *v28);
    }
    int v6 = v33[0];
    int v34 = v33[0];
    closefd(&v33[1], (int)"pipe write end");
    uint64_t v15 = 0;
  }
  if ((v6 & 0x80000000) == 0)
  {
LABEL_16:
    *a2 = dupfd2(v6, v5, (int)"reserved src fd");
    if (v6 == v5) {
      int v34 = -1;
    }
  }
LABEL_18:
  closefd_optional(&v34, (int)"reserved fd src");
  if (v15 >= 0x6A) {
    dyld_halt("error not set to valid posix code: %d", v16, v17, v18, v19, v20, v21, v22, v15);
  }
  return v15;
}

char ***boot_get()
{
  return __boot;
}

uint64_t boot_set_dylib_root(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return boot_set_root(a1, (uint64_t)&_boot_root_canonical_os, a2, a4, a5, a6, a7, a8);
}

uint64_t *configuration_unsafe()
{
  return &__config;
}

uint64_t _cryptex_graft_failure_app_livefs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  unint64_t v16 = *(void *)(arguments(a1, a2, a3, a4, a5, a6, a7, a8) + 16);
  if (v16 < 2) {
    return 0;
  }
  if (v16 != 2) {
    dyld_halt("unreachable", v9, v10, v11, v12, v13, v14, v15, v18);
  }
  return v8;
}

size_t dyld_tolower_cstr(const char *a1, uint64_t a2, unint64_t a3)
{
  size_t result = _platform_strlen(a1);
  if (result + 1 < a3) {
    unint64_t v7 = result + 1;
  }
  else {
    unint64_t v7 = a3;
  }
  if (v7) {
    unint64_t v8 = v7 - 1;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= 2)
  {
    unint64_t v9 = 0;
    do
    {
      int v10 = a1[v9];
      if ((v10 - 65) <= 0x19) {
        LOBYTE(v1dyld4::halt("obsolete dyld API called", 0) = aAbcdefghijklmn[v10 - 65];
      }
      *(unsigned char *)(a2 + v9++) = v10;
    }
    while (v9 < v8);
  }
  if (v7) {
    *(unsigned char *)(a2 + v7 - 1) = 0;
  }
  return result;
}

unint64_t buff_get_length_uint32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result = *(void *)(a1 + 8);
  if (HIDWORD(result)) {
    dyld_halt("buffer length not expressible as unsigned 32-bit integer: %lu", a2, a3, a4, a5, a6, a7, a8, result);
  }
  return result;
}

uint64_t buff_map_fd_anon(void *a1, void *a2, int a3)
{
  v6.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v19.st_blkvm_size_t size = v6;
  *(timespec *)v19.st_qspare = v6;
  v19.st_birthtimespec = v6;
  *(timespec *)&v19.st_vm_size_t size = v6;
  v19.st_mtimespec = v6;
  v19.st_ctimespec = v6;
  *(timespec *)&v19.st_uid = v6;
  v19.st_atimespec = v6;
  *(timespec *)&v19.fsobj_id st_dev = v6;
  if (fstat64(a3, &v19)) {
    return *__error();
  }
  st_vm_size_t size = v19.st_size;
  if (v19.st_size < 0) {
    dyld_halt("value not representable as size_t", v7, v8, v9, v10, v11, v12, v13, v19.st_dev);
  }
  unint64_t v16 = mmap(0, v19.st_size, 3, 4098, -1, 0);
  if (v16 == (void *)-1) {
    return *__error();
  }
  uint64_t v17 = v16;
  while (1)
  {
    ssize_t v18 = pread(a3, v17, st_size, 0);
    if ((v18 & 0x8000000000000000) == 0) {
      break;
    }
    uint64_t result = *__error();
    if (result != 4) {
      goto LABEL_13;
    }
  }
  if (v18 == st_size) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 5;
  }
LABEL_13:
  *a1 = v17;
  a1[1] = st_size;
  a1[2] = 0;
  if (a2) {
    *a2 = a1;
  }
  return result;
}

uint64_t os_log_simple_type_from_asl(int a1)
{
  unsigned int v1 = a1 & ~(a1 >> 31);
  if (v1 >= 7) {
    unsigned int v1 = 7;
  }
  return os_log_simple_type_from_asl__level2ostype[v1];
}

uint64_t __os_log_simple_offset(uint64_t a1, char *a2, const void *a3, uint64_t a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  v24[0] = a6;
  v24[1] = a7;
  _OWORD v24[2] = a8;
  v24[3] = mach_continuous_time();
  pid_t v13 = getpid();
  *(void *)&long long v25 = v13;
  if (proc_pidinfo(v13, 17, 0, buffer, 56) == 56)
  {
    *((void *)&v25 + 1) = v32;
    *(void *)&long long v26 = v33;
    memmove((char *)&v28 + 8, buffer, 0x10uLL);
  }
  if (a1)
  {
    if (*(int *)(a1 + 24) >= 0) {
      uint64_t v14 = a1;
    }
    else {
      uint64_t v14 = a4;
    }
    *(void *)&long long v27 = a5 - v14;
    uint64_t v15 = a2;
  }
  else
  {
    uint64_t v15 = (char *)&v28 + 8;
  }
  memmove((char *)&v27 + 8, v15, 0x10uLL);
  memmove((char *)&v29 + 8, a3, 0x10uLL);
  return _os_log_simple_send((uint64_t)v24, v16, v17, v18, v19, v20, v21, v22);
}

uint64_t _os_log_simple_send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  int fd = _simple_asl_get_fd(a1, a2, a3, a4, a5, a6, a7, a8);
  if (fd < 0) {
    return 9;
  }
  if ((MEMORY[0xFFFFFC105] & 4) != 0) {
    return 0;
  }
  int v10 = fd;
  size_t v11 = _platform_strlen(*(const char **)(a1 + 16)) + 1;
  uint64_t v12 = *(const char **)(a1 + 8);
  if (v12) {
    size_t v13 = _platform_strlen(v12) + 1;
  }
  else {
    size_t v13 = 0;
  }
  size_t v15 = v13 + v11 + 104;
  BOOL v16 = __CFADD__(v13, v11 + 104);
  uint64_t result = 84;
  if (v11 < 0xFFFFFFFFFFFFFF98 && !v16)
  {
    if (v15 <= 0x800)
    {
      v18[0] = v11;
      v18[1] = v13;
      char v19 = *(unsigned char *)a1;
      long long v20 = *(_OWORD *)(a1 + 24);
      long long v21 = *(_OWORD *)(a1 + 40);
      long long v22 = *(_OWORD *)(a1 + 56);
      memmove(&v23, (const void *)(a1 + 72), 0x10uLL);
      memmove(&v24, (const void *)(a1 + 88), 0x10uLL);
      memmove(&v25, (const void *)(a1 + 104), 0x10uLL);
      _platform_strlcpy(v26, *(char **)(a1 + 16), v11);
      if (v13) {
        _platform_strlcpy(&v26[v11], *(char **)(a1 + 8), v13);
      }
      unint64_t v17 = sendto(v10, v18, v15, 0, 0, 0);
      if ((v17 & 0x8000000000000000) != 0)
      {
        return *__error();
      }
      else if (v17 >= v15)
      {
        return 0;
      }
      else
      {
        return 40;
      }
    }
    else
    {
      return 7;
    }
  }
  return result;
}

uint64_t _os_log_simple_shim(unsigned __int8 a1, uint64_t a2, uint64_t a3)
{
  return __os_log_simple_offset(0, UUID_NULL, UUID_NULL, 0, 0, a1, a2, a3);
}

uint64_t _simple_asl_connect()
{
  uint64_t v0 = socket(1, 2, 0);
  uint64_t v1 = v0;
  if (v0 != -1)
  {
    fcntl(v0, 2, 1);
    v5.sa_family = 1;
    size_t v2 = _platform_strlen("/var/run/syslog");
    if (v2 + 1 < 0x68) {
      size_t v3 = v2 + 1;
    }
    else {
      size_t v3 = 104;
    }
    memmove(v5.sa_data, "/var/run/syslog", v3);
    if (connect(v1, &v5, 0x6Au) == -1)
    {
      close(v1);
      return 0xFFFFFFFFLL;
    }
  }
  return v1;
}

uint64_t _simple_asl_get_fd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  if (qword_1EC3F2BC0 == -1) {
    atomic_ullong v8 = qword_1EC3F2BC8;
  }
  else {
    atomic_ullong v8 = _os_alloc_once(&qword_1EC3F2BC0, 32, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  }
  if (!*(unsigned char *)v8) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v8 + 24) != -1) {
    _os_once((atomic_ullong *)(v8 + 24), 0, (uint64_t (*)(uint64_t))_simple_asl_connect_once, a4, a5, a6, a7, a8);
  }
  return *(unsigned int *)(v8 + 16);
}

void _simple_asl_connect_once(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  if (qword_1EC3F2BC0 == -1) {
    atomic_ullong v8 = qword_1EC3F2BC8;
  }
  else {
    atomic_ullong v8 = _os_alloc_once(&qword_1EC3F2BC0, 32, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  }
  if (*(_DWORD *)(v8 + 16) == -1) {
    *(_DWORD *)(v8 + 16) = _simple_asl_connect();
  }
}

uint64_t _simple_asl_log(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  if (qword_1EC3F2BC0 != -1) {
    _os_alloc_once(&qword_1EC3F2BC0, 32, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  }
  unsigned __int8 v11 = os_log_simple_type_from_asl(a1);

  return _os_log_simple_shim(v11, a2, a3);
}

uint64_t _simple_asl_init_context(uint64_t result)
{
  *(void *)(result + 8) = "unknown";
  *(_DWORD *)(result + 16) = -1;
  return result;
}

ssize_t _simple_vdprintf(int a1, char *__s, int *a3)
{
  int v6 = a1;
  v5[0] = v4;
  v5[1] = v4;
  v5[2] = v5;
  uint64_t v7 = _flush_reset;
  __simple_bprintf((uint64_t)v5, 0, __s, a3);
  return _flush((ssize_t)v5);
}

ssize_t _flush_reset(void *a1)
{
  ssize_t result = _flush((ssize_t)a1);
  a1[1] = *a1;
  return result;
}

ssize_t _flush(ssize_t result)
{
  uint64_t v1 = *(char **)result;
  int64_t v2 = *(void *)(result + 8) - *(void *)result;
  if (v2 >= 1)
  {
    ssize_t v3 = result;
    while (1)
    {
      while (1)
      {
        ssize_t result = write(*(_DWORD *)(v3 + 24), v1, v2);
        if (result < 0) {
          break;
        }
        BOOL v4 = v2 <= result;
        v2 -= result;
        v1 += v2;
        if (v4) {
          return result;
        }
      }
      if (*__error() != 4)
      {
        ssize_t result = (ssize_t)__error();
        if (*(_DWORD *)result != 35) {
          break;
        }
      }
    }
  }
  return result;
}

ssize_t _simple_dprintf(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return _simple_vdprintf(a1, a2, &a9);
}

void *_enlarge(uint64_t a1)
{
  kern_return_t v6;
  vm_size_t v7;
  vm_address_t v8;
  vm_size_t v9;
  vm_address_t address;

  int64_t v2 = (vm_size_t *)(a1 + 16);
  vm_address_t address = *(void *)(a1 + 16) + 1;
  ssize_t result = (void *)vm_allocate(mach_task_self_, &address, vm_page_size, 0);
  if (result)
  {
    size_t v4 = *(void *)(a1 + 16) - *(void *)a1 + 1;
    vm_size_t v5 = (v4 + vm_page_size) & -(uint64_t)vm_page_size;
    int v6 = vm_allocate(mach_task_self_, &address, v5, 1);
    if (v6) {
      _enlarge_cold_1(v6);
    }
    uint64_t v7 = address - *(void *)a1;
    ssize_t result = memmove((void *)address, *(const void **)a1, v4);
    atomic_ullong v8 = *(void *)a1;
    if (((vm_page_size - 1) & *(void *)a1) != 0)
    {
      v4 &= -(uint64_t)vm_page_size;
      atomic_ullong v8 = (v8 + vm_page_size) & -(uint64_t)vm_page_size;
      *(void *)a1 = v8;
      uint64_t v9 = v5 + address - 1;
    }
    else
    {
      uint64_t v9 = *v2 + vm_page_size + v7;
    }
    *int64_t v2 = v9;
    if (v4) {
      ssize_t result = (void *)vm_deallocate(mach_task_self_, v8, v4);
    }
    *(void *)a1 = address;
    int64_t v2 = (vm_size_t *)(a1 + 8);
  }
  else
  {
    uint64_t v7 = vm_page_size;
  }
  *v2 += v7;
  return result;
}

uint64_t _simple_sprintf(uint64_t a1, char *__s, ...)
{
  va_start(va, __s);
  __simple_bprintf(a1, 0, __s, (int *)va);
  return 0;
}

std::ios_base *__cdecl dec(std::ios_base *__str)
{
  vm_size_t v5 = v1;
  int v7 = (v2 >> 63) + v3;
  unint64_t v8 = (unint64_t)v2 >> 63;
  char v39 = 0;
  if (v2)
  {
    uint64_t v9 = &v39;
    if (v2 >= 0) {
      unint64_t v10 = v2;
    }
    else {
      unint64_t v10 = -v2;
    }
    do
    {
      *--uint64_t v9 = (v10 % 0xA) | 0x30;
      BOOL v11 = v10 >= 0xA;
      v10 /= 0xAuLL;
    }
    while (v11);
    BOOL v12 = v4 != 0;
    if (v2 < 0 && v4)
    {
      if (v1 && (size_t v13 = (unsigned char *)v1(45)) != 0)
      {
        LODWORD(v8) = *v13;
        if (*v13)
        {
          uint64_t v14 = v13 + 1;
          do
          {
            size_t v15 = *(unsigned char **)&__str->__fmtflags_;
            if ((unint64_t)v15 >= __str->__precision_)
            {
              (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
              size_t v15 = *(unsigned char **)&__str->__fmtflags_;
            }
            *(void *)&__str->__fmtflags_ = v15 + 1;
            *size_t v15 = v8;
            int v16 = *v14++;
            LODWORD(v8) = v16;
          }
          while (v16);
        }
      }
      else
      {
        unint64_t v17 = *(unsigned char **)&__str->__fmtflags_;
        if ((unint64_t)v17 >= __str->__precision_)
        {
          (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
          unint64_t v17 = *(unsigned char **)&__str->__fmtflags_;
        }
        LODWORD(v8) = 0;
        *(void *)&__str->__fmtflags_ = v17 + 1;
        *unint64_t v17 = 45;
      }
      BOOL v12 = 1;
    }
  }
  else
  {
    uint64_t v9 = &v38;
    char v38 = 48;
    BOOL v12 = v4 != 0;
  }
  ssize_t result = (std::ios_base *)_platform_strlen(v9);
  uint64_t v19 = v7 - (void)result;
  if (v19 >= 1)
  {
    if (v12) {
      uint64_t v20 = 48;
    }
    else {
      uint64_t v20 = 32;
    }
    do
    {
      if (v5 && (ssize_t result = (std::ios_base *)v5(v20)) != 0)
      {
        char v21 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          long long v22 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            uint64_t v23 = *(unsigned char **)&__str->__fmtflags_;
            if ((unint64_t)v23 >= __str->__precision_)
            {
              ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              uint64_t v23 = *(unsigned char **)&__str->__fmtflags_;
            }
            *(void *)&__str->__fmtflags_ = v23 + 1;
            *uint64_t v23 = v21;
            int v24 = *v22++;
            char v21 = v24;
          }
          while (v24);
        }
      }
      else
      {
        uint64_t v25 = *(unsigned char **)&__str->__fmtflags_;
        if ((unint64_t)v25 >= __str->__precision_)
        {
          ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          uint64_t v25 = *(unsigned char **)&__str->__fmtflags_;
        }
        *(void *)&__str->__fmtflags_ = v25 + 1;
        unsigned char *v25 = v20;
      }
    }
    while (v19-- > 1);
  }
  if (v8)
  {
    if (v5 && (ssize_t result = (std::ios_base *)v5(45)) != 0)
    {
      char v27 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        long long v28 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          long long v29 = *(unsigned char **)&__str->__fmtflags_;
          if ((unint64_t)v29 >= __str->__precision_)
          {
            ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            long long v29 = *(unsigned char **)&__str->__fmtflags_;
          }
          *(void *)&__str->__fmtflags_ = v29 + 1;
          *long long v29 = v27;
          int v30 = *v28++;
          char v27 = v30;
        }
        while (v30);
      }
    }
    else
    {
      uint64_t v31 = *(unsigned char **)&__str->__fmtflags_;
      if ((unint64_t)v31 >= __str->__precision_)
      {
        ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        uint64_t v31 = *(unsigned char **)&__str->__fmtflags_;
      }
      *(void *)&__str->__fmtflags_ = v31 + 1;
      *uint64_t v31 = 45;
    }
  }
  while (1)
  {
    char v37 = *v9;
    if (!*v9) {
      break;
    }
    if (v5 && (ssize_t result = (std::ios_base *)v5(*(unsigned __int8 *)v9)) != 0)
    {
      char v32 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        int v33 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          int v34 = *(unsigned char **)&__str->__fmtflags_;
          if ((unint64_t)v34 >= __str->__precision_)
          {
            ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            int v34 = *(unsigned char **)&__str->__fmtflags_;
          }
          *(void *)&__str->__fmtflags_ = v34 + 1;
          *int v34 = v32;
          int v35 = *v33++;
          char v32 = v35;
        }
        while (v35);
      }
    }
    else
    {
      size_t v36 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v36 >= __str->__precision_)
      {
        ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        size_t v36 = *(char **)&__str->__fmtflags_;
      }
      *(void *)&__str->__fmtflags_ = v36 + 1;
      char *v36 = v37;
    }
    ++v9;
  }
  return result;
}

std::ios_base *__cdecl oct(std::ios_base *__str)
{
  int v5 = v4;
  int v6 = v1;
  char v27 = 0;
  if (v2)
  {
    unint64_t v8 = &v27;
    do
    {
      *--unint64_t v8 = v2 & 7 | 0x30;
      BOOL v9 = v2 >= 8;
      v2 >>= 3;
    }
    while (v9);
  }
  else
  {
    unint64_t v8 = &v26;
    char v26 = 48;
  }
  uint64_t v10 = v3;
  ssize_t result = (std::ios_base *)_platform_strlen(v8);
  uint64_t v12 = v10 - (void)result;
  if (v12 >= 1)
  {
    if (v5) {
      uint64_t v13 = 48;
    }
    else {
      uint64_t v13 = 32;
    }
    do
    {
      if (v6 && (ssize_t result = (std::ios_base *)v6(v13)) != 0)
      {
        char v14 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          size_t v15 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            int v16 = *(unsigned char **)&__str->__fmtflags_;
            if ((unint64_t)v16 >= __str->__precision_)
            {
              ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              int v16 = *(unsigned char **)&__str->__fmtflags_;
            }
            *(void *)&__str->__fmtflags_ = v16 + 1;
            *int v16 = v14;
            int v17 = *v15++;
            char v14 = v17;
          }
          while (v17);
        }
      }
      else
      {
        uint64_t v18 = *(unsigned char **)&__str->__fmtflags_;
        if ((unint64_t)v18 >= __str->__precision_)
        {
          ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          uint64_t v18 = *(unsigned char **)&__str->__fmtflags_;
        }
        *(void *)&__str->__fmtflags_ = v18 + 1;
        unsigned char *v18 = v13;
      }
    }
    while (v12-- > 1);
  }
  while (1)
  {
    char v25 = *v8;
    if (!*v8) {
      break;
    }
    if (v6 && (ssize_t result = (std::ios_base *)v6(*(unsigned __int8 *)v8)) != 0)
    {
      char v20 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        char v21 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          long long v22 = *(unsigned char **)&__str->__fmtflags_;
          if ((unint64_t)v22 >= __str->__precision_)
          {
            ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            long long v22 = *(unsigned char **)&__str->__fmtflags_;
          }
          *(void *)&__str->__fmtflags_ = v22 + 1;
          unsigned char *v22 = v20;
          int v23 = *v21++;
          char v20 = v23;
        }
        while (v23);
      }
    }
    else
    {
      int v24 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v24 >= __str->__precision_)
      {
        ssize_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        int v24 = *(char **)&__str->__fmtflags_;
      }
      *(void *)&__str->__fmtflags_ = v24 + 1;
      *int v24 = v25;
    }
    ++v8;
  }
  return result;
}

unsigned char *udec(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t a3, int a4, int a5)
{
  char v27 = 0;
  if (a3)
  {
    unint64_t v8 = &v27;
    do
    {
      *--unint64_t v8 = (a3 % 0xA) | 0x30;
      BOOL v9 = a3 >= 0xA;
      a3 /= 0xAuLL;
    }
    while (v9);
  }
  else
  {
    unint64_t v8 = &v26;
    char v26 = 48;
  }
  uint64_t v10 = a4;
  ssize_t result = (unsigned char *)_platform_strlen(v8);
  uint64_t v12 = v10 - (void)result;
  if (v12 >= 1)
  {
    if (a5) {
      uint64_t v13 = 48;
    }
    else {
      uint64_t v13 = 32;
    }
    do
    {
      if (a2 && (ssize_t result = (unsigned char *)a2(v13)) != 0)
      {
        char v14 = *result;
        if (*result)
        {
          size_t v15 = result + 1;
          do
          {
            int v16 = *(unsigned char **)(a1 + 8);
            if ((unint64_t)v16 >= *(void *)(a1 + 16))
            {
              ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              int v16 = *(unsigned char **)(a1 + 8);
            }
            *(void *)(a1 + 8) = v16 + 1;
            *int v16 = v14;
            int v17 = *v15++;
            char v14 = v17;
          }
          while (v17);
        }
      }
      else
      {
        uint64_t v18 = *(unsigned char **)(a1 + 8);
        if ((unint64_t)v18 >= *(void *)(a1 + 16))
        {
          ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          uint64_t v18 = *(unsigned char **)(a1 + 8);
        }
        *(void *)(a1 + 8) = v18 + 1;
        unsigned char *v18 = v13;
      }
    }
    while (v12-- > 1);
  }
  while (1)
  {
    char v25 = *v8;
    if (!*v8) {
      break;
    }
    if (a2 && (ssize_t result = (unsigned char *)a2(*(unsigned __int8 *)v8)) != 0)
    {
      char v20 = *result;
      if (*result)
      {
        char v21 = result + 1;
        do
        {
          long long v22 = *(unsigned char **)(a1 + 8);
          if ((unint64_t)v22 >= *(void *)(a1 + 16))
          {
            ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
            long long v22 = *(unsigned char **)(a1 + 8);
          }
          *(void *)(a1 + 8) = v22 + 1;
          unsigned char *v22 = v20;
          int v23 = *v21++;
          char v20 = v23;
        }
        while (v23);
      }
    }
    else
    {
      int v24 = *(char **)(a1 + 8);
      if ((unint64_t)v24 >= *(void *)(a1 + 16))
      {
        ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
        int v24 = *(char **)(a1 + 8);
      }
      *(void *)(a1 + 8) = v24 + 1;
      *int v24 = v25;
    }
    ++v8;
  }
  return result;
}

unsigned char *ydec(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t a3, int a4, int a5)
{
  if (a3 < 0xA00000)
  {
    if (a3 >> 11 < 5)
    {
      ssize_t result = udec(a1, a2, a3, a4, a5);
      if (a2 && (ssize_t result = (unsigned char *)a2(98)) != 0)
      {
        char v24 = *result;
        if (*result)
        {
          char v25 = result + 1;
          do
          {
            char v26 = *(unsigned char **)(a1 + 8);
            if ((unint64_t)v26 >= *(void *)(a1 + 16))
            {
              ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              char v26 = *(unsigned char **)(a1 + 8);
            }
            *(void *)(a1 + 8) = v26 + 1;
            *char v26 = v24;
            int v27 = *v25++;
            char v24 = v27;
          }
          while (v27);
        }
      }
      else
      {
        long long v28 = *(unsigned char **)(a1 + 8);
        if ((unint64_t)v28 >= *(void *)(a1 + 16))
        {
          ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          long long v28 = *(unsigned char **)(a1 + 8);
        }
        *(void *)(a1 + 8) = v28 + 1;
        *long long v28 = 98;
      }
    }
    else
    {
      ssize_t result = udec(a1, a2, (a3 + 512) >> 10, a4, a5);
      int v16 = "KB";
      unsigned __int8 v17 = 75;
      do
      {
        if (a2 && (ssize_t result = (unsigned char *)a2(v17)) != 0)
        {
          char v18 = *result;
          if (*result)
          {
            uint64_t v19 = result + 1;
            do
            {
              char v20 = *(unsigned char **)(a1 + 8);
              if ((unint64_t)v20 >= *(void *)(a1 + 16))
              {
                ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
                char v20 = *(unsigned char **)(a1 + 8);
              }
              *(void *)(a1 + 8) = v20 + 1;
              unsigned char *v20 = v18;
              int v21 = *v19++;
              char v18 = v21;
            }
            while (v21);
          }
        }
        else
        {
          long long v22 = *(unsigned __int8 **)(a1 + 8);
          if ((unint64_t)v22 >= *(void *)(a1 + 16))
          {
            ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
            long long v22 = *(unsigned __int8 **)(a1 + 8);
          }
          *(void *)(a1 + 8) = v22 + 1;
          unsigned __int8 *v22 = v17;
        }
        unsigned __int8 v23 = *++v16;
        unsigned __int8 v17 = v23;
      }
      while (v16 != "");
    }
  }
  else
  {
    ssize_t result = udec(a1, a2, (a3 + 0x80000) >> 20, a4, a5);
    unint64_t v8 = "MB";
    unsigned __int8 v9 = 77;
    do
    {
      if (a2 && (ssize_t result = (unsigned char *)a2(v9)) != 0)
      {
        char v10 = *result;
        if (*result)
        {
          BOOL v11 = result + 1;
          do
          {
            uint64_t v12 = *(unsigned char **)(a1 + 8);
            if ((unint64_t)v12 >= *(void *)(a1 + 16))
            {
              ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              uint64_t v12 = *(unsigned char **)(a1 + 8);
            }
            *(void *)(a1 + 8) = v12 + 1;
            *uint64_t v12 = v10;
            int v13 = *v11++;
            char v10 = v13;
          }
          while (v13);
        }
      }
      else
      {
        char v14 = *(unsigned __int8 **)(a1 + 8);
        if ((unint64_t)v14 >= *(void *)(a1 + 16))
        {
          ssize_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          char v14 = *(unsigned __int8 **)(a1 + 8);
        }
        *(void *)(a1 + 8) = v14 + 1;
        unsigned __int8 *v14 = v9;
      }
      unsigned __int8 v15 = *++v8;
      unsigned __int8 v9 = v15;
    }
    while (v8 != "");
  }
  return result;
}

uint64_t _os_unfair_lock_lock_slow(atomic_uint *a1, int a2, void *a3, unsigned int a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  if ((a2 & 0xFCFAFFFF) != 0)
  {
    qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Invalid options";
    qword_1EC3F2780 = a2 & 0xFEFFFFFF;
    __break(1u);
LABEL_30:
    _os_unfair_lock_recursive_abort(v8);
  }
  unsigned int v8 = a4;
  int v12 = 0;
  do
  {
    while (1)
    {
      while (1)
      {
        do
        {
          unsigned int v13 = *a1;
          if (!*a1)
          {
            atomic_compare_exchange_strong_explicit(a1, &v13, v8 & ~v12, memory_order_acquire, memory_order_acquire);
            if (!v13) {
              return 1;
            }
          }
          int v14 = v13 | 1;
          BOOL v15 = (a2 & 0x1000000) != 0 && v14 == -1;
          int v16 = !v15;
          if (v14 == v8 && v16 != 0) {
            goto LABEL_30;
          }
          if (v13 == (v13 & 0xFFFFFFFE)) {
            break;
          }
          unsigned int v18 = v13;
          atomic_compare_exchange_strong_explicit(a1, &v18, v13 & 0xFFFFFFFE, memory_order_relaxed, memory_order_relaxed);
          BOOL v15 = v18 == v13;
          v13 &= ~1u;
        }
        while (!v15);
        uint64_t result = __ulock_wait2((void *)(a2 | 0x1000002u), a1, (void *)v13, a3, 0, a6, a7, a8);
        if ((result & 0x80000000) != 0) {
          break;
        }
        if (result) {
          int v12 = 1;
        }
      }
      uint64_t v20 = -(int)result;
      if ((int)v20 > 13) {
        break;
      }
      if (v20 != 4) {
        goto LABEL_34;
      }
    }
  }
  while (v20 == 14);
  uint64_t result = 0;
  if (v20 != 60)
  {
    if (v20 == 105) {
      _os_unfair_lock_corruption_abort(v13);
    }
LABEL_34:
    qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wait2 failure";
    qword_1EC3F2780 = v20;
    __break(1u);
  }
  return result;
}

atomic_uint *os_unfair_lock_lock_with_options(atomic_uint *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  int v8 = 0;
  unsigned int v9 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  atomic_compare_exchange_strong_explicit(result, (unsigned int *)&v8, v9, memory_order_acquire, memory_order_acquire);
  if (v8) {
    return (atomic_uint *)_os_unfair_lock_lock_slow(result, a2, 0, v9, a5, a6, a7, a8);
  }
  return result;
}

uint64_t _os_unfair_lock_unlock_slow(void *a1, int a2, unsigned int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = a3 | 1;
  if (result != a2) {
    _os_unfair_lock_unowned_abort(result);
  }
  if (a3)
  {
    uint64_t v10 = a3;
    qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: unlock_slow with no waiters";
    qword_1EC3F2780 = a3;
    __break(1u);
LABEL_9:
    qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wake failure";
    qword_1EC3F2780 = v10;
    __break(1u);
  }
  else
  {
    while (1)
    {
      uint64_t result = __ulock_wake((void *)0x1000002, a1, 0, a4, a5, a6, a7, a8);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if (result != -4)
      {
        uint64_t v10 = -(int)result;
        if (v10 != 2) {
          goto LABEL_9;
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t _os_once_gate_broadcast(void *a1, unsigned int a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = a2 | 1;
  if (result != a3) {
    _os_once_gate_unowned_abort(result);
  }
  if (a2)
  {
    uint64_t v10 = a2;
    qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: unlock_slow with no waiters";
    qword_1EC3F2780 = a2;
    __break(1u);
LABEL_9:
    qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wake failure";
    qword_1EC3F2780 = v10;
    __break(1u);
  }
  else
  {
    while (1)
    {
      uint64_t result = __ulock_wake((void *)0x1000102, a1, 0, a4, a5, a6, a7, a8);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if (result != -4)
      {
        uint64_t v10 = -(int)result;
        if (v10 != 2) {
          goto LABEL_9;
        }
        return result;
      }
    }
  }
  return result;
}

atomic_ullong *_os_once(atomic_ullong *result, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t explicit = atomic_load_explicit(result, memory_order_acquire);
  if ((explicit & 3) == 1)
  {
    if (4 * MEMORY[0xFFFFFC180] - explicit - 15 <= 0xFFFFFFFFFFFFFFEFLL) {
      *uint64_t result = -1;
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    atomic_compare_exchange_strong_explicit(result, (unint64_t *)&v9, v10, memory_order_acquire, memory_order_acquire);
    if (v9) {
      return (atomic_ullong *)_os_once_gate_wait((uint64_t)result, a2, a3, v10, a5, a6, a7, a8);
    }
    else {
      return (atomic_ullong *)_os_once_callout(result, a2, a3, v10);
    }
  }
  return result;
}

uint64_t _os_once_callout(atomic_ullong *a1, uint64_t a2, uint64_t (*a3)(uint64_t), int a4)
{
  uint64_t result = a3(a2);
  unsigned int v12 = atomic_exchange_explicit(a1, (4 * MEMORY[0xFFFFFC180]) | 1, memory_order_release);
  if (v12 != a4)
  {
    return _os_once_gate_broadcast(a1, v12, a4, v7, v8, v9, v10, v11);
  }
  return result;
}

uint64_t _os_once_gate_wait(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t), unsigned int a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v8 = *(void *)result;
  if (*(void *)result != -1)
  {
    unsigned int v12 = (uint64_t *)result;
    unint64_t v13 = a4;
    while ((v8 & 3) != 1)
    {
      if (v8)
      {
        unsigned int v14 = v8;
        if ((v8 & 0xFFFFFFFFFFFFFFFELL) == v8
          || (uint64_t v15 = v8,
              atomic_compare_exchange_strong_explicit(v12, (unint64_t *)&v15, v8 & 0xFFFFFFFFFFFFFFFELL, memory_order_relaxed, memory_order_relaxed), unsigned int v14 = v8 & 0xFFFFFFFE, v15 == v8))
        {
          if ((v8 | 1) == a4) {
            _os_once_gate_recursive_abort(a4);
          }
          uint64_t result = __ulock_wait((void *)0x1000002, v12, (void *)v14, 0, a5, a6, a7, a8);
          if ((result & 0x80000000) != 0 && result != -4 && -(int)result != 14)
          {
            if (-(int)result == 105) {
              _os_once_gate_corruption_abort(v8);
            }
            qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wait failure";
            qword_1EC3F2780 = -(int)result;
            __break(1u);
            return result;
          }
          uint64_t v8 = *v12;
        }
        else
        {
          uint64_t v8 = v15;
        }
      }
      else
      {
        uint64_t v16 = 0;
        atomic_compare_exchange_strong_explicit(v12, (unint64_t *)&v16, v13, memory_order_relaxed, memory_order_relaxed);
        if (!v16)
        {
          __dmb(9u);
          return _os_once_callout(v12, a2, a3, a4);
        }
        uint64_t v8 = v16;
      }
      if (v8 == -1) {
        return result;
      }
    }
    __dmb(9u);
    if ((unint64_t)(4 * MEMORY[0xFFFFFC180] - v8 - 15) <= 0xFFFFFFFFFFFFFFEFLL) {
      *unsigned int v12 = -1;
    }
  }
  return result;
}

atomic_ullong _os_alloc_once(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  v10[0] = a1;
  v10[1] = a2;
  _DWORD v10[2] = a3;
  _os_once(a1, (uint64_t)v10, _os_alloc, a4, a5, a6, a7, a8);
  return a1[1];
}

uint64_t _os_alloc(uint64_t a1)
{
  unint64_t v1 = (*(_DWORD *)(a1 + 8) + 15) & 0xFFFFFFF0;
  if (v1 - 1 >= 2 * vm_page_size - 16) {
    _os_alloc_cold_1((*(_DWORD *)(a1 + 8) + 15) & 0xFFFFFFF0);
  }
  int v3 = (atomic_ullong *)_os_alloc_heap[0];
  if (_os_alloc_heap[0]
    && (add_unint64_t explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)_os_alloc_heap[0], v1, memory_order_relaxed),
        add_explicit + v1 <= 2 * vm_page_size - 16))
  {
    uint64_t result = (uint64_t)v3 + add_explicit + 16;
  }
  else
  {
    uint64_t result = _os_alloc_slow(v3, v1);
  }
  *(void *)(*(void *)a1 + 8) = result;
  int v6 = *(uint64_t (**)(void))(a1 + 16);
  if (v6)
  {
    return v6();
  }
  return result;
}

uint64_t _os_alloc_slow(atomic_ullong *a1, unint64_t a2)
{
  mach_vm_address_t v4 = vm_page_size;
  while (1)
  {
    mach_vm_address_t address = v4;
    uint64_t result = mach_vm_map(mach_task_self_, &address, 2 * v4, 0, 1224736769, 0, 0, 0, 3, 7, 1u);
    if (result) {
      break;
    }
    mach_vm_address_t v6 = address;
    int v7 = a1;
    atomic_compare_exchange_strong_explicit(_os_alloc_heap, (unint64_t *)&v7, address, memory_order_relaxed, memory_order_relaxed);
    if (v7 == a1)
    {
      *(void *)(v6 + 8) = a1;
      a1 = (atomic_ullong *)v6;
LABEL_6:
      add_unint64_t explicit = atomic_fetch_add_explicit(a1, a2, memory_order_relaxed);
      mach_vm_address_t v4 = vm_page_size;
      if (add_explicit + a2 <= 2 * vm_page_size - 16) {
        return (uint64_t)a1 + add_explicit + 16;
      }
    }
    else
    {
      mach_vm_deallocate(mach_task_self_, v6, 2 * vm_page_size);
      a1 = (atomic_ullong *)_os_alloc_heap[0];
      if (_os_alloc_heap[0]) {
        goto LABEL_6;
      }
      mach_vm_address_t v4 = vm_page_size;
    }
  }
  qword_1EC3F2750 = (uint64_t)"BUG IN LIBPLATFORM: Failed to allocate in os_alloc_once";
  qword_1EC3F2780 = (int)result;
  __break(1u);
  return result;
}

uint64_t _os_semaphore_dispose(semaphore_t semaphore)
{
  uint64_t result = semaphore_destroy(mach_task_self_, semaphore);
  if (result) {
    _os_semaphore_dispose_cold_1(result);
  }
  return result;
}

void *__cdecl _platform_memchr(void *__s, int __c, size_t __n)
{
  if (!__n) {
    return 0;
  }
  if ((__n & 0x8000000000000000) != 0)
  {
    int8x16_t v13 = vdupq_n_s8(__c);
    uint64_t v14 = __s & 0xF;
    unint64_t v15 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
    int8x16_t v16 = *(int8x16_t *)&algn_1A8E687B0[-v14];
    for (uint8x16_t i = (uint8x16_t)vorrq_s8(vsubq_s8(*(int8x16_t *)v15, v13), v16); ; uint8x16_t i = (uint8x16_t)vsubq_s8(v18, v13))
    {
      v16.i8[0] = vminvq_u8(i);
      if (!v16.i32[0]) {
        break;
      }
      int8x16_t v18 = *(int8x16_t *)(v15 + 16);
      v15 += 16;
    }
    uint8x16_t v19 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, (uint8x16_t)veorq_s8(v13, v13)), (int8x16_t)xmmword_1A8E687A0);
    v19.i8[0] = vminvq_u8(v19);
    return (void *)(v15 + v19.u32[0]);
  }
  else
  {
    int8x16_t v3 = vdupq_n_s8(__c);
    uint64_t v4 = __s & 0xF;
    unint64_t v5 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0;
    int8x16_t v6 = *(int8x16_t *)&algn_1A8E687B0[-v4];
    uint8x16_t v7 = (uint8x16_t)vorrq_s8(vsubq_s8(*(int8x16_t *)v5, v3), v6);
    unint64_t v8 = __n + v4;
    while (1)
    {
      v6.i8[0] = vminvq_u8(v7);
      if (!v6.i32[0]) {
        break;
      }
      BOOL v10 = v8 > 0x10;
      v8 -= 16;
      if (!v10) {
        return 0;
      }
      int8x16_t v9 = *(int8x16_t *)(v5 + 16);
      v5 += 16;
      uint8x16_t v7 = (uint8x16_t)vsubq_s8(v9, v3);
    }
    uint8x16_t v12 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v7, (uint8x16_t)veorq_s8(v3, v3)), (int8x16_t)xmmword_1A8E687A0);
    v12.i8[0] = vminvq_u8(v12);
    uint64_t result = (void *)(v5 + v12.u32[0]);
    if (v12.u32[0] >= v8) {
      return 0;
    }
  }
  return result;
}

unint64_t timingsafe_enable_if_supported()
{
  uint64_t v0 = MEMORY[0xFFFFFC010];
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000) != 0)
  {
    unint64_t v1 = (_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) >> 24) & 1;
    __asm { MSR             DIT, #1 }
    if ((v0 & 0x200000000000) != 0) {
      goto LABEL_3;
    }
LABEL_5:
    __dsb(0xFu);
    __isb(0xFu);
    return v1;
  }
  unint64_t v1 = 0;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000) == 0) {
    goto LABEL_5;
  }
LABEL_3:
  sb();
  return v1;
}

uint64_t timingsafe_restore_if_supported(uint64_t result)
{
  if ((result & 1) == 0 && (MEMORY[0xFFFFFC010] & 0x200000000000000) != 0) {
    __asm { MSR             DIT, #0 }
  }
  return result;
}

void sb()
{
  __asm { SB }
}

void _pthread_exit(unint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  __disable_threadsignal((void *)1, a2, a3, a4, a5, a6, a7, a8);
  _pthread_setcancelstate_exit(a1);
  for (uint64_t i = *(void *)(a1 + 8); i; *(void *)(a1 + 8) = i)
  {
    (*(void (**)(void))i)(*(void *)(i + 8));
    uint64_t i = *(void *)(i + 16);
  }
  ignition_test_BRA(a1);
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v18 = *(void *)(StatusReg + 72);
  *(void *)(StatusReg + 72) = 0;
  if (v18) {
    goto LABEL_5;
  }
  while (1)
  {
    LODWORD(v18) = _pthread_terminate_invoke(a1, (uint64_t)a2, v11, v12, v13, v14, v15, v16);
LABEL_5:
    _os_semaphore_dispose(v18);
  }
}

uint64_t _pthread_joiner_wake(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8 = (void *)(a1 + 52);
  do
    uint64_t result = __ulock_wake((void *)0x1000002, v8, 0, a4, a5, a6, a7, a8);
  while (result == -4);
  if (result != -2)
  {
    if (result) {
      _pthread_joiner_wake_cold_1(result);
    }
  }
  return result;
}

void pthread_exit(void *a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  if ((*(_WORD *)(StatusReg - 146) & 0x400) != 0)
  {
    qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPTHREAD: pthread_exit() called from a thread not created by pthread_create()";
    __break(1u);
  }
  else if ((_pthread_ptr_munge_token ^ *(void *)(StatusReg - 224)) == StatusReg - 224)
  {
    _pthread_exit(StatusReg - 224, a1, v1, v2, v3, v4, v5, v6);
  }
  abort_with_reason((void *)0x12, (void *)4, "pthread_t was corrupted", 0);
}

uint64_t _pthread_terminate_invoke(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  if ((((unint64_t)&vars0 ^ a1) & -(uint64_t)vm_page_size) == 0) {
    bzero(&v19, 0x3000uLL);
  }
  unint64_t v10 = _pthread_terminate(a1, a2, a3, a4, a5, a6, a7, a8);
  return _pthread_terminate(v10, v11, v12, v13, v14, v15, v16, v17);
}

uint64_t _pthread_terminate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  if (_pthread_introspection_hook) {
    _pthread_introspection_hook_callout_thread_terminate(a1);
  }
  unint64_t v10 = *(void *)(a1 + 192);
  uint64_t v11 = *(char **)(a1 + 200);
  if (v10 < a1 && (unint64_t)&v11[v10] > a1)
  {
    uint64_t v14 = (char *)((a1 - v10) & -(uint64_t)vm_page_size);
    *(void *)(a1 + 192) = &v14[v10];
    *(void *)(a1 + 20dyld4::halt("obsolete dyld API called", 0) = v11 - v14;
  }
  else if ((_UNKNOWN *)a1 == &_main_thread)
  {
    uint64_t v13 = qword_1EB1D1A30 - unk_1EB1D1A38;
    if (qword_1EB1D1A30 == unk_1EB1D1A38) {
      uint64_t v13 = 0x80000;
    }
    unint64_t v10 = qword_1EB1D1A30 - v13;
    uint64_t v14 = (char *)(((unint64_t)_pthread_current_stack_address() & -(uint64_t)vm_page_size) - v10);
  }
  else
  {
    uint64_t v14 = 0;
  }
  unint64_t v15 = (void *)*(unsigned int *)(a1 + 248);
  mach_port_name_t v16 = *(_DWORD *)(a1 + 288);
  if (v16)
  {
    *(_DWORD *)(a1 + 288) = 0;
    thread_destruct_special_reply_port(v16, 0);
  }
  mach_port_t v17 = *(_DWORD *)(a1 + 240);
  if (v17) {
    mig_dealloc_reply_port(v17);
  }
  os_unfair_lock_lock_with_options((atomic_uint *)&_pthread_list_lock, 327680, a3, a4, a5, a6, a7, a8);
  *(_DWORD *)(a1 + 52) = -1;
  *(void *)(a1 + 4dyld4::halt("obsolete dyld API called", 0) = a2;
  int v18 = _pthread_count--;
  uint64_t v19 = *(void *)(a1 + 32);
  if (v19) {
    uint64_t v20 = (void *)_pthread_joiner_prepost_wake(a1);
  }
  else {
    uint64_t v20 = 0;
  }
  char v21 = *(unsigned char *)(a1 + 49);
  char v22 = v21 & 1;
  if (v21)
  {
    *(unsigned char *)(a1 + 49) = v21 | 2;
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    char v24 = *(void **)(a1 + 24);
    if (v23)
    {
      *(void *)(v23 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v24;
      char v24 = *(void **)(a1 + 24);
    }
    else
    {
      qword_1EC3F2738 = *(void *)(a1 + 24);
    }
    *char v24 = v23;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_pthread_list_lock);
  if (v19)
  {
    _pthread_joiner_wake(a1, v25, v26, v27, v28, v29, v30, v31);
    os_unfair_lock_lock_with_options((atomic_uint *)&_pthread_list_lock, 327680, v32, v33, v34, v35, v36, v37);
    if (*(void *)(a1 + 32))
    {
      *(unsigned char *)(a1 + 49) |= 2u;
      char v22 = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_pthread_list_lock);
  }
  if ((_UNKNOWN *)a1 != &_main_thread && (v22 & 1) == 0)
  {
    if (_pthread_introspection_hook) {
      _pthread_introspection_hook_callout_thread_destroy(a1);
    }
    uint64_t v14 = v11;
  }
  if (v18 <= 1) {
    _exit(0);
  }
  if (v14) {
    char v38 = (void *)v10;
  }
  else {
    char v38 = 0;
  }
  uint64_t result = __bsdthread_terminate(v38, v14, v15, v20, v28, v29, v30, v31);
  qword_1EC3F2750 = (uint64_t)"BUG IN LIBPTHREAD: thread didn't terminate";
  qword_1EC3F2780 = a1;
  __break(1u);
  return result;
}

char *_pthread_current_stack_address()
{
  return &v1;
}

uint64_t _pthread_introspection_hook_callout_thread_terminate(uint64_t a1)
{
  if ((_UNKNOWN *)a1 == &_main_thread)
  {
    uint64_t v2 = qword_1EB1D1A30 - unk_1EB1D1A38 + qword_1EB1D1A50;
    uint64_t v1 = unk_1EB1D1A38 - qword_1EB1D1A50;
  }
  else
  {
    uint64_t v1 = *(void *)(a1 + 192);
    uint64_t v2 = *(void *)(a1 + 200) - (~vm_page_mask & (vm_page_mask + 4320));
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  __int16 v4 = *(_WORD *)(StatusReg - 174);
  *(_WORD *)(StatusReg - 174) = 3;
  uint64_t result = _pthread_introspection_hook(3, a1, v1, v2);
  *(_WORD *)(StatusReg - 174) = v4;
  return result;
}

uint64_t _pthread_introspection_hook_callout_thread_destroy(uint64_t a1)
{
  vm_size_t v1 = ~vm_page_mask & (vm_page_mask + 4320);
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  __int16 v3 = *(_WORD *)(StatusReg - 174);
  *(_WORD *)(StatusReg - 174) = 4;
  uint64_t result = _pthread_introspection_hook(4, a1, a1, v1);
  *(_WORD *)(StatusReg - 174) = v3;
  return result;
}

void _pthread_joiner_wake_cold_1(int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN LIBPTHREAD: pthread_join() wake failure";
  qword_1EC3F2780 = -a1;
  __break(1u);
}

uint64_t _pthread_setcancelstate_exit(uint64_t result)
{
  unsigned __int16 v1 = *(_WORD *)(result + 166);
  int v2 = v1;
  do
  {
    atomic_compare_exchange_strong_explicit((atomic_ushort *volatile)(result + 166), (unsigned __int16 *)&v2, v1 & 0xFFDC | 0x22, memory_order_relaxed, memory_order_relaxed);
    BOOL v3 = v2 == v1;
    unsigned __int16 v1 = v2;
  }
  while (!v3);
  return result;
}

uint64_t _pthread_joiner_prepost_wake(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(unsigned char *)(a1 + 49);
  if (v3)
  {
    uint64_t result = *(unsigned int *)(v2 + 20);
    *(unsigned char *)(a1 + 49) = v3 & 0xFE;
  }
  else
  {
    uint64_t result = 0;
    *(unsigned char *)(v2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *(void *)(a1 + 32) = 0;
  }
  if (*(void *)(v2 + 8))
  {
    int v5 = atomic_load((unsigned __int16 *)(a1 + 166));
    if ((~v5 & 0x11) != 0) {
      uint64_t v6 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v6 = 1;
    }
    **(void **)(v2 + 8) = v6;
  }
  return result;
}

void OUTLINED_FUNCTION_0_0(uint64_t a1, uint64_t a2, void *a3)
{
  abort_with_reason((void *)0x12, (void *)4, a3, 0);
}

void _pthread_exit_if_canceled_cold_1(uint64_t a1, uint64_t a2)
{
}

BOOL mutex_seq_atomic_cmpxchgv_relaxed(atomic_ullong *a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v4, *a3, memory_order_relaxed, memory_order_relaxed);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

BOOL mutex_seq_atomic_cmpxchgv_acquire(atomic_ullong *a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v4, *a3, memory_order_acquire, memory_order_acquire);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

BOOL mutex_seq_atomic_cmpxchgv_release(atomic_ullong *a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v4, *a3, memory_order_release, memory_order_relaxed);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

vm_address_t *sandbox_warn(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  unint64_t v10 = (vm_address_t *)_simple_salloc();
  _simple_vsprintf((uint64_t)v10, a1, &a9);
  uint64_t v11 = _simple_string((unsigned char **)v10);
  _simple_asl_log(2, (uint64_t)"com.apple.libsystem.sandbox", v11, v12, v13, v14, v15, v16);
  int v17 = _simple_string((unsigned char **)v10);
  _simple_dprintf(2, "%s\n", v18, v19, v20, v21, v22, v23, v17);
  return _simple_sfree(v10);
}

uint64_t __abort_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_abort_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_create(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_create, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_ctl(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_ctl, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_register(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_register, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_terminate(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_terminate, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __chmod(const char *a1, mode_t a2)
{
  int result = mac_syscall(SYS_chmod, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  LODWORD(v9) = mac_syscall(SYS_connect, a1, a2, a3);
  if (v3) {
    LODWORD(v9) = cerror(v9, (void *)a2, *(void **)&a3, v4, v5, v6, v7, v8);
  }
  return v9;
}

uint64_t __disable_threadsignal(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___disable_threadsignal, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __execve(const char *a1, char *const *a2, char *const *a3)
{
  int result = mac_syscall(SYS_execve, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

void _exit(int a1)
{
  mac_syscall(SYS_exit, a1);
  if (v1) {
    cerror_nocancel(v2);
  }
}

int __fchmod(int a1, mode_t a2)
{
  int result = mac_syscall(SYS_fchmod, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __getdirentries64(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_getdirentries64, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __gettimeofday_with_mach(timeval *a1, void *a2)
{
  int result = mac_syscall(SYS_gettimeofday, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int __gettimeofday(timeval *a1, void *a2)
{
  int result = mac_syscall(SYS_gettimeofday, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int __ioctl(int a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_ioctl, a1, (unint64_t)a2, a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __kqueue_workloop_ctl(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_kqueue_workloop_ctl, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  off_t result = mac_syscall(SYS_lseek, a1, a2, a3);
  if (v3) {
    return cerror(result, (void *)a2, *(void **)&a3, v4, v5, v6, v7, v8);
  }
  return result;
}

int __open_dprotected_np(const char *a1, int a2, int a3, int a4)
{
  int result = mac_syscall(SYS_open_dprotected_np, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int __openat_dprotected_np(int a1, const char *a2, int a3, int a4, int a5)
{
  int result = mac_syscall(SYS_openat_dprotected_np, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

int pipe(int a1[2])
{
  int v4 = mac_syscall(SYS_pipe, a1);
  if (v1) {
    return cerror_nocancel(v4);
  }
  *a1 = v4;
  a1[1] = v2;
  return 0;
}

int __posix_spawn(pid_t *a1, char *a2, posix_spawn_file_actions_t *a3, posix_spawnattr_t *a4, char **a5, char **a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_posix_spawn, a1, a2, a3, a4, a5, a6);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __proc_info_extended_id(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_proc_info_extended_id, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __process_policy(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_process_policy, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvbroad(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvbroad, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvclrprepost(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvclrprepost, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvsignal(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvsignal, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvwait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvwait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_mutexdrop(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_mutexdrop, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_mutexwait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_mutexwait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __pthread_canceled(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___pthread_canceled, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __pthread_kill(_opaque_pthread_t *a1, int a2)
{
  int result = mac_syscall(SYS___pthread_kill, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __pthread_markcancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___pthread_markcancel, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  int result = mac_syscall(SYS___pthread_sigmask, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

void __rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  mac_syscall(SYS_rename, __from, __to, __ec);
  if (v3) {
    cerror(v9, (void *)__to, __ec, v4, v5, v6, v7, v8);
  }
}

uint64_t __semwait_signal_nocancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___semwait_signal_nocancel, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  ssize_t result = mac_syscall(SYS_sendto, a1, a2, a3, a4, a5, a6);
  if (v6) {
    return cerror(result, (void *)a2, (void *)a3, *(void **)&a4, (void *)a5, *(void **)&a6, v7, v8);
  }
  return result;
}

uint64_t __shared_region_map_and_slide_2_np(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_shared_region_map_and_slide_2_np, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __sigwait(const sigset_t *a1, int *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS___sigwait, a1, a2);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

int syscall(int a1, ...)
{
  va_start(va, a1);
  int v4 = va_arg(va, void *);
  char v5 = va_arg(va, void *);
  char v6 = va_arg(va, void *);
  uint8x16_t v7 = va_arg(va, void *);
  char v8 = va_arg(va, void *);
  uint64_t v9 = va_arg(va, void *);
  unint64_t v10 = va_arg(va, void *);
  LODWORD(v2) = mac_syscall(SYS_syscall, a1, v4, v5, v6, v7, v8, v9, v10);
  if (v1) {
    LODWORD(v2) = cerror(v2, v4, v5, v6, v7, v8, v9, v10);
  }
  return v2;
}

uint64_t __terminate_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_terminate_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __ulock_wait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_ulock_wait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __ulock_wait2(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_ulock_wait2, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __ulock_wake(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_ulock_wake, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __unlink(const char *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_unlink, a1);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __workq_kernreturn(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_workq_kernreturn, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __workq_open(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_workq_open, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int dup2(int a1, int a2)
{
  int result = mac_syscall(SYS_dup2, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int fgetattrlist(int a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  int result = mac_syscall(SYS_fgetattrlist, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  ssize_t result = mac_syscall(SYS_fgetxattr, fd, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

int fmount(const char *a1, int a2, int a3, void *a4)
{
  int result = mac_syscall(SYS_fmount, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  int result = mac_syscall(SYS_fsctl, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  int result = mac_syscall(SYS_fsetxattr, fd, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

int fstatfs64(int a1, statfs *a2)
{
  int64_t v9 = mac_syscall(SYS_fstatfs64, *(void **)&a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int fsync(int a1)
{
  LODWORD(v9) = mac_syscall(SYS_fsync, a1);
  if (v1) {
    LODWORD(v9) = cerror(v9, v2, v3, v4, v5, v6, v7, v8);
  }
  return v9;
}

int ftruncate(int a1, off_t a2)
{
  int result = mac_syscall(SYS_ftruncate, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int getattrlistbulk(int a1, void *a2, void *a3, size_t a4, uint64_t a5)
{
  int result = mac_syscall(SYS_getattrlistbulk, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

int getentropy(void *buffer, size_t size)
{
  int result = mac_syscall(SYS_getentropy, buffer, size);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

gid_t getgid(void)
{
  gid_t result = mac_syscall(SYS_getgid);
  if (v0) {
    return cerror_nocancel(result);
  }
  return result;
}

uid_t getuid(void)
{
  uid_t result = mac_syscall(SYS_getuid);
  if (v0) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t graftdmg(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_graftdmg, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int lstat64(const char *a1, stat *a2)
{
  int64_t v9 = mac_syscall(SYS_lstat64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int mkdir(const char *a1, mode_t a2)
{
  int result = mac_syscall(SYS_mkdir, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int mount(const char *a1, const char *a2, int a3, void *a4)
{
  int result = mac_syscall(SYS_mount, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t mremap_encrypted(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_mremap_encrypted, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t openbyid_np(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_openbyid_np, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t os_fault_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_os_fault_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  ssize_t result = mac_syscall(SYS_pread, __fd, __buf, __nbyte, a4);
  if (v4) {
    return cerror(result, __buf, (void *)__nbyte, (void *)a4, v5, v6, v7, v8);
  }
  return result;
}

uint64_t proc_rlimit_control(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_proc_rlimit_control, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  ssize_t result = mac_syscall(SYS_pwrite, __fd, __buf, __nbyte, a4);
  if (v4) {
    return cerror(result, (void *)__buf, (void *)__nbyte, (void *)a4, v5, v6, v7, v8);
  }
  return result;
}

ssize_t read(int a1, void *a2, size_t a3)
{
  ssize_t result = mac_syscall(SYS_read, a1, a2, a3);
  if (v3) {
    return cerror(result, a2, (void *)a3, v4, v5, v6, v7, v8);
  }
  return result;
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  ssize_t result = mac_syscall(SYS_readlink, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  int result = mac_syscall(SYS_setxattr, path, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

int sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  int result = mac_syscall(SYS_sigprocmask, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int socket(int a1, int a2, int a3)
{
  mac_syscall(SYS_socket);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int statfs64(const char *a1, statfs *a2)
{
  int64_t v9 = mac_syscall(SYS_statfs64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  ssize_t result = mac_syscall(SYS_write, __fd, __buf, __nbyte);
  if (v3) {
    return cerror(result, (void *)__buf, (void *)__nbyte, v4, v5, v6, v7, v8);
  }
  return result;
}

uint64_t ccdigest_final_64be(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6)) {
    *(_DWORD *)(v8 + v6) = 0;
  }
  size_t v9 = (v7 + v6 + 19) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v10 = (uint64_t *)((char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v10, v9);
  memmove(v10, a2, v7 + v6 + 12);
  uint64_t v11 = (char *)v10 + v7;
  uint64_t v12 = (uint64_t)v10 + v7 + 8;
  uint64_t v13 = (char *)(v12 + v6);
  uint64_t v14 = *(unsigned int *)(v12 + v6);
  *v10 += (8 * v14);
  *(_DWORD *)(v12 + v6) = v14 + 1;
  *(unsigned char *)(v12 + v14) = 0x80;
  unint64_t v15 = *(unsigned int *)(v12 + v6);
  if (v15 < 0x39)
  {
    if (v15 == 56) {
      goto LABEL_9;
    }
  }
  else
  {
    if (v15 <= 0x3F)
    {
      do
      {
        *(_DWORD *)uint64_t v13 = v15 + 1;
        *(unsigned char *)(v12 + v15) = 0;
        unint64_t v15 = *(unsigned int *)v13;
      }
      while (v15 < 0x40);
    }
    (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1);
    unint64_t v15 = 0;
    uint64_t v11 = (char *)v10 + *(void *)(a1 + 8);
    uint64_t v12 = (uint64_t)(v11 + 8);
    uint64_t v13 = &v11[*(void *)(a1 + 16) + 8];
    *(_DWORD *)uint64_t v13 = 0;
  }
  do
  {
    *(_DWORD *)uint64_t v13 = v15 + 1;
    *(unsigned char *)(v12 + v15) = 0;
    unint64_t v15 = *(unsigned int *)v13;
  }
  while (v15 < 0x38);
LABEL_9:
  *((void *)v11 + 8) = bswap64(*v10);
  (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1);
  if (*(void *)a1 >= 4uLL)
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0;
    unsigned int v18 = 1;
    do
    {
      *(_DWORD *)(a3 + v16) = bswap32(*((_DWORD *)v10 + v17 + 2));
      unint64_t v17 = v18++;
      v16 += 4;
    }
    while (v17 < *(void *)a1 >> 2);
  }
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v10);
}

uint64_t ccdigest_init(uint64_t a1, void *a2)
{
  unsigned int v5 = timingsafe_enable_if_supported();
  memmove(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  *a2 = 0;
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + 8) = 0;
  return cc_disable_dit_with_sb(&v5);
}

unint64_t *ccdigest_update_internal(unint64_t *result, void *a2, size_t a3, char *__src)
{
  size_t v5 = a3;
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (uint64_t)a2 + result[1] + 8;
  if (v8 <= *(unsigned int *)(v9 + v8)) {
    *(_DWORD *)(v9 + v8) = 0;
  }
  if (a3)
  {
    unint64_t v10 = a2 + 1;
    do
    {
      size_t v11 = v7[2];
      uint64_t v12 = (char *)v10 + v7[1];
      uint64_t v13 = *(unsigned int *)&v12[v11];
      if (v5 > v11 && v13 == 0)
      {
        if (v11 == 128)
        {
          size_t v22 = v5 >> 7;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFF80;
        }
        else if (v11 == 64)
        {
          size_t v22 = v5 >> 6;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          size_t v22 = v5 / v11;
          size_t v16 = v5 / v11 * v11;
        }
        ssize_t result = (unint64_t *)((uint64_t (*)(void *, size_t, char *))v7[6])(a2 + 1, v22, __src);
        *a2 += 8 * v16;
      }
      else
      {
        size_t v15 = v11 - v13;
        if (v15 >= v5) {
          size_t v16 = v5;
        }
        else {
          size_t v16 = v15;
        }
        ssize_t result = (unint64_t *)memmove(&v12[v13], __src, v16);
        unint64_t v17 = v7[2];
        unsigned int v18 = (char *)v10 + v7[1];
        uint64_t v19 = (*(_DWORD *)&v18[v17] + v16);
        *(_DWORD *)&v18[v17] = v19;
        if (v17 == v19)
        {
          ssize_t result = (unint64_t *)((uint64_t (*)(void *, uint64_t))v7[6])(a2 + 1, 1);
          unint64_t v20 = v7[2];
          uint64_t v21 = (char *)v10 + v7[1];
          *a2 += (8 * *(_DWORD *)&v21[v20]);
          *(_DWORD *)&v21[v20] = 0;
        }
      }
      __src += v16;
      v5 -= v16;
    }
    while (v5);
  }
  return result;
}

uint64_t ccdigest_update(unint64_t *a1, void *a2, size_t a3, char *a4)
{
  unsigned int v9 = timingsafe_enable_if_supported();
  ccdigest_update_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb(&v9);
}

int32x4_t *AccelerateCrypto_SHA256_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v4 = *a3;
    int8x16_t v5 = a3[1];
    int8x16_t v6 = a3[2];
    int8x16_t v7 = a3[3];
    char v3 = a3 + 4;
    _Q1 = (int32x4_t)vrev32q_s8(v5);
    int32x4_t v9 = *result;
    _Q2 = (int32x4_t)vrev32q_s8(v6);
    _Q17 = result[1];
    _Q3 = (int32x4_t)vrev32q_s8(v7);
    _Q18 = *result;
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v4), (int32x4_t)K256);
    _Q5 = vaddq_s32(_Q1, (int32x4_t)xmmword_1A8E6A170);
    _Q19 = _Q17;
    _Q6 = vaddq_s32(_Q2, (int32x4_t)xmmword_1A8E6A180);
    _Q7 = vaddq_s32(_Q3, (int32x4_t)xmmword_1A8E6A190);
    uint64_t v19 = &xmmword_1A8E6A1A0;
    int v20 = 3;
    do
    {
      _Q20 = _Q18;
      int32x4_t v22 = (int32x4_t)*v19;
      __asm { SHA256SU0       V0.4S, V1.4S }
      int32x4_t v28 = (int32x4_t)v19[1];
      __asm { SHA256H         Q18, Q19, V4.4S }
      int32x4_t v30 = (int32x4_t)v19[2];
      __asm { SHA256SU1       V0.4S, V2.4S, V3.4S }
      int32x4_t v32 = (int32x4_t)v19[3];
      __asm { SHA256H2        Q19, Q20, V4.4S }
      v19 += 4;
      _Q4 = vaddq_s32(_Q0, v22);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V1.4S, V2.4S
        SHA256H         Q18, Q19, V5.4S
        SHA256SU1       V1.4S, V3.4S, V0.4S
        SHA256H2        Q19, Q20, V5.4S
      }
      _Q5 = vaddq_s32(_Q1, v28);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V2.4S, V3.4S
        SHA256H         Q18, Q19, V6.4S
        SHA256SU1       V2.4S, V0.4S, V1.4S
        SHA256H2        Q19, Q20, V6.4S
      }
      _Q6 = vaddq_s32(_Q2, v30);
      --v20;
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V3.4S, V0.4S
        SHA256H         Q18, Q19, V7.4S
        SHA256SU1       V3.4S, V1.4S, V2.4S
        SHA256H2        Q19, Q20, V7.4S
      }
      _Q7 = vaddq_s32(_Q3, v32);
    }
    while (!(_NF ^ _VF | _ZF));
    BOOL v44 = a2 <= 1;
    uint64_t v45 = a2 - 1;
    if (!v44)
    {
      pid_t v46 = (int32x4_t *)(v19 - 16);
      do
      {
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V4.4S }
        int8x16_t v49 = v3[1];
        int8x16_t v50 = v3[2];
        __asm { SHA256H2        Q19, Q20, V4.4S }
        int8x16_t v52 = v3[3];
        _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(*v3), *v46);
        _Q20 = _Q18;
        v3 += 4;
        __asm { SHA256H         Q18, Q19, V5.4S }
        _Q1 = (int32x4_t)vrev32q_s8(v49);
        __asm { SHA256H2        Q19, Q20, V5.4S }
        _Q5 = vaddq_s32(_Q1, v46[1]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V6.4S }
        _Q2 = (int32x4_t)vrev32q_s8(v50);
        __asm { SHA256H2        Q19, Q20, V6.4S }
        _Q6 = vaddq_s32(_Q2, v46[2]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V7.4S }
        _Q3 = (int32x4_t)vrev32q_s8(v52);
        __asm { SHA256H2        Q19, Q20, V7.4S }
        _Q7 = vaddq_s32(_Q3, v46[3]);
        int32x4_t v9 = vaddq_s32(v9, _Q18);
        _Q17 = vaddq_s32(_Q17, _Q19);
        _Q20 = v9;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }
        _Q4 = vaddq_s32(_Q0, v46[4]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }
        _Q5 = vaddq_s32(_Q1, v46[5]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }
        _Q6 = vaddq_s32(_Q2, v46[6]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }
        _Q7 = vaddq_s32(_Q3, v46[7]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }
        _Q4 = vaddq_s32(_Q0, v46[8]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }
        _Q5 = vaddq_s32(_Q1, v46[9]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }
        _Q6 = vaddq_s32(_Q2, v46[10]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }
        _Q7 = vaddq_s32(_Q3, v46[11]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }
        _Q4 = vaddq_s32(_Q0, v46[12]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }
        _Q5 = vaddq_s32(_Q1, v46[13]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }
        _Q6 = vaddq_s32(_Q2, v46[14]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }
        _Q7 = vaddq_s32(_Q3, v46[15]);
        BOOL v44 = v45-- <= 1;
      }
      while (!v44);
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V4.4S
      SHA256H2        Q19, Q20, V4.4S
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V5.4S
      SHA256H2        Q19, Q20, V5.4S
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V6.4S
      SHA256H2        Q19, Q20, V6.4S
    }
    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V7.4S
      SHA256H2        Q19, Q20, V7.4S
    }
    *ssize_t result = vaddq_s32(v9, _Q18);
    result[1] = vaddq_s32(_Q17, _Q19);
  }
  return result;
}

uint64_t *AccelerateCrypto_SHA512_compress(uint64_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v4 = *a3;
    char v3 = a3 + 8;
    int64x2_t v5 = (int64x2_t)vrev64q_s8(v4);
    int64x2_t v6 = (int64x2_t)vrev64q_s8(v3[-7]);
    int64x2_t v7 = (int64x2_t)vrev64q_s8(v3[-6]);
    int64x2_t v8 = (int64x2_t)vrev64q_s8(v3[-5]);
    int64x2_t v9 = (int64x2_t)vrev64q_s8(v3[-4]);
    int64x2_t v10 = (int64x2_t)vrev64q_s8(v3[-3]);
    int64x2_t v11 = (int64x2_t)vrev64q_s8(v3[-2]);
    int64x2_t v12 = (int64x2_t)vrev64q_s8(v3[-1]);
    i8 = &xmmword_1A8E71670;
    int64x2_t v240 = vaddq_s64((int64x2_t)sha512_K, v5);
    int64x2_t v241 = vaddq_s64(unk_1A8E71600, v6);
    int64x2_t v242 = vaddq_s64(unk_1A8E71610, v7);
    int64x2_t v243 = vaddq_s64(unk_1A8E71620, v8);
    int64x2_t v244 = vaddq_s64((int64x2_t)xmmword_1A8E71630, v9);
    int64x2_t v245 = vaddq_s64(unk_1A8E71640, v10);
    int64x2_t v246 = vaddq_s64(unk_1A8E71650, v11);
    int64x2_t v247 = vaddq_s64(unk_1A8E71660, v12);
    while (1)
    {
      uint64_t v14 = *result;
      uint64_t v15 = result[1];
      uint64_t v16 = result[2];
      uint64_t v17 = result[3];
      uint64_t v18 = result[4];
      uint64_t v19 = result[5];
      uint64_t v20 = result[6];
      uint64_t v21 = result[7];
      int v22 = 4;
      do
      {
        int64x2_t v23 = (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
        int8x16_t v24 = (int8x16_t)vshrq_n_u64((uint64x2_t)v12, 0x13uLL);
        int64x2_t v25 = vshlq_n_s64(v12, 3uLL);
        uint64_t v26 = v21
            + v240.i64[0]
            + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41))
            + ((v19 ^ v20) & v18 ^ v20);
        int8x16_t v27 = (int8x16_t)vshrq_n_u64((uint64x2_t)v23, 1uLL);
        int64x2_t v28 = vshlq_n_s64(v23, 0x38uLL);
        uint64_t v29 = v17 + v26;
        uint64_t v30 = v26 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
        int8x16_t v31 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v12, 6uLL), v24), (int8x16_t)v25), (int8x16_t)vshrq_n_u64((uint64x2_t)v24, 0x2AuLL));
        int64x2_t v32 = (int64x2_t)*i8;
        uint64_t v33 = (int64x2_t *)(i8 + 1);
        int64x2_t v5 = vaddq_s64(vaddq_s64(vaddq_s64(v5, (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL)), (int64x2_t)veorq_s8(v31, (int8x16_t)vshlq_n_s64(v25, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v23, 7uLL), v27), (int8x16_t)v28), (int8x16_t)vshrq_n_u64((uint64x2_t)v27, 7uLL)), (int8x16_t)vshlq_n_s64(v28, 7uLL)));
        uint64_t v34 = v20
            + v240.i64[1]
            + (__ROR8__(v29, 14) ^ __ROR8__(v29, 18) ^ __ROR8__(v29, 41))
            + ((v18 ^ v19) & v29 ^ v19);
        uint64_t v35 = v16 + v34;
        uint64_t v36 = v34 + (__ROR8__(v30, 28) ^ __ROR8__(v30, 34) ^ __ROR8__(v30, 39)) + ((v14 ^ v15) & v30 ^ v14 & v15);
        int64x2_t v240 = vaddq_s64(v32, v5);
        int64x2_t v37 = (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL);
        int8x16_t v38 = (int8x16_t)vshrq_n_u64((uint64x2_t)v5, 0x13uLL);
        int64x2_t v39 = vshlq_n_s64(v5, 3uLL);
        uint64_t v40 = v19
            + v241.i64[0]
            + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41))
            + ((v29 ^ v18) & v35 ^ v18);
        int8x16_t v41 = (int8x16_t)vshrq_n_u64((uint64x2_t)v37, 1uLL);
        int64x2_t v42 = vshlq_n_s64(v37, 0x38uLL);
        uint64_t v43 = v15 + v40;
        uint64_t v44 = v40 + (__ROR8__(v36, 28) ^ __ROR8__(v36, 34) ^ __ROR8__(v36, 39)) + ((v30 ^ v14) & v36 ^ v30 & v14);
        int8x16_t v45 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v5, 6uLL), v38), (int8x16_t)v39), (int8x16_t)vshrq_n_u64((uint64x2_t)v38, 0x2AuLL));
        int64x2_t v46 = *v33++;
        int64x2_t v6 = vaddq_s64(vaddq_s64(vaddq_s64(v6, (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL)), (int64x2_t)veorq_s8(v45, (int8x16_t)vshlq_n_s64(v39, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v37, 7uLL), v41), (int8x16_t)v42), (int8x16_t)vshrq_n_u64((uint64x2_t)v41, 7uLL)), (int8x16_t)vshlq_n_s64(v42, 7uLL)));
        uint64_t v47 = v18
            + v241.i64[1]
            + (__ROR8__(v43, 14) ^ __ROR8__(v43, 18) ^ __ROR8__(v43, 41))
            + ((v35 ^ v29) & v43 ^ v29);
        uint64_t v48 = v14 + v47;
        uint64_t v49 = v47 + (__ROR8__(v44, 28) ^ __ROR8__(v44, 34) ^ __ROR8__(v44, 39)) + ((v36 ^ v30) & v44 ^ v36 & v30);
        int64x2_t v241 = vaddq_s64(v46, v6);
        int64x2_t v50 = (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL);
        int8x16_t v51 = (int8x16_t)vshrq_n_u64((uint64x2_t)v6, 0x13uLL);
        int64x2_t v52 = vshlq_n_s64(v6, 3uLL);
        uint64_t v53 = v29
            + v242.i64[0]
            + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41))
            + ((v43 ^ v35) & v48 ^ v35);
        int8x16_t v54 = (int8x16_t)vshrq_n_u64((uint64x2_t)v50, 1uLL);
        int64x2_t v55 = vshlq_n_s64(v50, 0x38uLL);
        uint64_t v56 = v30 + v53;
        uint64_t v57 = v53 + (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + ((v44 ^ v36) & v49 ^ v44 & v36);
        int8x16_t v58 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v6, 6uLL), v51), (int8x16_t)v52), (int8x16_t)vshrq_n_u64((uint64x2_t)v51, 0x2AuLL));
        int64x2_t v59 = *v33++;
        int64x2_t v7 = vaddq_s64(vaddq_s64(vaddq_s64(v7, (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL)), (int64x2_t)veorq_s8(v58, (int8x16_t)vshlq_n_s64(v52, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v50, 7uLL), v54), (int8x16_t)v55), (int8x16_t)vshrq_n_u64((uint64x2_t)v54, 7uLL)), (int8x16_t)vshlq_n_s64(v55, 7uLL)));
        uint64_t v60 = v35
            + v242.i64[1]
            + (__ROR8__(v56, 14) ^ __ROR8__(v56, 18) ^ __ROR8__(v56, 41))
            + ((v48 ^ v43) & v56 ^ v43);
        uint64_t v61 = v36 + v60;
        uint64_t v62 = v60 + (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + ((v49 ^ v44) & v57 ^ v49 & v44);
        int64x2_t v242 = vaddq_s64(v59, v7);
        int64x2_t v63 = (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL);
        int8x16_t v64 = (int8x16_t)vshrq_n_u64((uint64x2_t)v7, 0x13uLL);
        int64x2_t v65 = vshlq_n_s64(v7, 3uLL);
        uint64_t v66 = v43
            + v243.i64[0]
            + (__ROR8__(v61, 14) ^ __ROR8__(v61, 18) ^ __ROR8__(v61, 41))
            + ((v56 ^ v48) & v61 ^ v48);
        int8x16_t v67 = (int8x16_t)vshrq_n_u64((uint64x2_t)v63, 1uLL);
        int64x2_t v68 = vshlq_n_s64(v63, 0x38uLL);
        uint64_t v69 = v44 + v66;
        uint64_t v70 = v66 + (__ROR8__(v62, 28) ^ __ROR8__(v62, 34) ^ __ROR8__(v62, 39)) + ((v57 ^ v49) & v62 ^ v57 & v49);
        int8x16_t v71 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v7, 6uLL), v64), (int8x16_t)v65), (int8x16_t)vshrq_n_u64((uint64x2_t)v64, 0x2AuLL));
        int64x2_t v72 = *v33++;
        int64x2_t v8 = vaddq_s64(vaddq_s64(vaddq_s64(v8, (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL)), (int64x2_t)veorq_s8(v71, (int8x16_t)vshlq_n_s64(v65, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v63, 7uLL), v67), (int8x16_t)v68), (int8x16_t)vshrq_n_u64((uint64x2_t)v67, 7uLL)), (int8x16_t)vshlq_n_s64(v68, 7uLL)));
        uint64_t v73 = v48
            + v243.i64[1]
            + (__ROR8__(v69, 14) ^ __ROR8__(v69, 18) ^ __ROR8__(v69, 41))
            + ((v61 ^ v56) & v69 ^ v56);
        uint64_t v74 = v49 + v73;
        uint64_t v75 = v73 + (__ROR8__(v70, 28) ^ __ROR8__(v70, 34) ^ __ROR8__(v70, 39)) + ((v62 ^ v57) & v70 ^ v62 & v57);
        int64x2_t v243 = vaddq_s64(v72, v8);
        int64x2_t v76 = (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL);
        int8x16_t v77 = (int8x16_t)vshrq_n_u64((uint64x2_t)v8, 0x13uLL);
        int64x2_t v78 = vshlq_n_s64(v8, 3uLL);
        uint64_t v79 = v56
            + v244.i64[0]
            + (__ROR8__(v74, 14) ^ __ROR8__(v74, 18) ^ __ROR8__(v74, 41))
            + ((v69 ^ v61) & v74 ^ v61);
        int8x16_t v80 = (int8x16_t)vshrq_n_u64((uint64x2_t)v76, 1uLL);
        int64x2_t v81 = vshlq_n_s64(v76, 0x38uLL);
        uint64_t v82 = v57 + v79;
        uint64_t v83 = v79 + (__ROR8__(v75, 28) ^ __ROR8__(v75, 34) ^ __ROR8__(v75, 39)) + ((v70 ^ v62) & v75 ^ v70 & v62);
        int8x16_t v84 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v8, 6uLL), v77), (int8x16_t)v78), (int8x16_t)vshrq_n_u64((uint64x2_t)v77, 0x2AuLL));
        int64x2_t v85 = *v33++;
        int64x2_t v9 = vaddq_s64(vaddq_s64(vaddq_s64(v9, (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL)), (int64x2_t)veorq_s8(v84, (int8x16_t)vshlq_n_s64(v78, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v76, 7uLL), v80), (int8x16_t)v81), (int8x16_t)vshrq_n_u64((uint64x2_t)v80, 7uLL)), (int8x16_t)vshlq_n_s64(v81, 7uLL)));
        uint64_t v86 = v61
            + v244.i64[1]
            + (__ROR8__(v82, 14) ^ __ROR8__(v82, 18) ^ __ROR8__(v82, 41))
            + ((v74 ^ v69) & v82 ^ v69);
        uint64_t v87 = v62 + v86;
        uint64_t v88 = v86 + (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39)) + ((v75 ^ v70) & v83 ^ v75 & v70);
        int64x2_t v244 = vaddq_s64(v85, v9);
        int64x2_t v89 = (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL);
        int8x16_t v90 = (int8x16_t)vshrq_n_u64((uint64x2_t)v9, 0x13uLL);
        int64x2_t v91 = vshlq_n_s64(v9, 3uLL);
        uint64_t v92 = v69
            + v245.i64[0]
            + (__ROR8__(v87, 14) ^ __ROR8__(v87, 18) ^ __ROR8__(v87, 41))
            + ((v82 ^ v74) & v87 ^ v74);
        int8x16_t v93 = (int8x16_t)vshrq_n_u64((uint64x2_t)v89, 1uLL);
        int64x2_t v94 = vshlq_n_s64(v89, 0x38uLL);
        uint64_t v95 = v70 + v92;
        uint64_t v96 = v92 + (__ROR8__(v88, 28) ^ __ROR8__(v88, 34) ^ __ROR8__(v88, 39)) + ((v83 ^ v75) & v88 ^ v83 & v75);
        int8x16_t v97 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v9, 6uLL), v90), (int8x16_t)v91), (int8x16_t)vshrq_n_u64((uint64x2_t)v90, 0x2AuLL));
        int64x2_t v98 = *v33++;
        int64x2_t v10 = vaddq_s64(vaddq_s64(vaddq_s64(v10, (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL)), (int64x2_t)veorq_s8(v97, (int8x16_t)vshlq_n_s64(v91, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v89, 7uLL), v93), (int8x16_t)v94), (int8x16_t)vshrq_n_u64((uint64x2_t)v93, 7uLL)), (int8x16_t)vshlq_n_s64(v94, 7uLL)));
        uint64_t v99 = v74
            + v245.i64[1]
            + (__ROR8__(v95, 14) ^ __ROR8__(v95, 18) ^ __ROR8__(v95, 41))
            + ((v87 ^ v82) & v95 ^ v82);
        uint64_t v100 = v75 + v99;
        uint64_t v101 = v99 + (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + ((v88 ^ v83) & v96 ^ v88 & v83);
        int64x2_t v245 = vaddq_s64(v98, v10);
        int64x2_t v102 = (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL);
        int8x16_t v103 = (int8x16_t)vshrq_n_u64((uint64x2_t)v10, 0x13uLL);
        int64x2_t v104 = vshlq_n_s64(v10, 3uLL);
        uint64_t v105 = v82
             + v246.i64[0]
             + (__ROR8__(v100, 14) ^ __ROR8__(v100, 18) ^ __ROR8__(v100, 41))
             + ((v95 ^ v87) & v100 ^ v87);
        int8x16_t v106 = (int8x16_t)vshrq_n_u64((uint64x2_t)v102, 1uLL);
        int64x2_t v107 = vshlq_n_s64(v102, 0x38uLL);
        uint64_t v21 = v83 + v105;
        uint64_t v17 = v105 + (__ROR8__(v101, 28) ^ __ROR8__(v101, 34) ^ __ROR8__(v101, 39)) + ((v96 ^ v88) & v101 ^ v96 & v88);
        int8x16_t v108 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v10, 6uLL), v103), (int8x16_t)v104), (int8x16_t)vshrq_n_u64((uint64x2_t)v103, 0x2AuLL));
        int64x2_t v109 = *v33++;
        int64x2_t v11 = vaddq_s64(vaddq_s64(vaddq_s64(v11, (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL)), (int64x2_t)veorq_s8(v108, (int8x16_t)vshlq_n_s64(v104, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v102, 7uLL), v106), (int8x16_t)v107), (int8x16_t)vshrq_n_u64((uint64x2_t)v106, 7uLL)), (int8x16_t)vshlq_n_s64(v107, 7uLL)));
        uint64_t v110 = v87
             + v246.i64[1]
             + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41))
             + ((v100 ^ v95) & v21 ^ v95);
        uint64_t v20 = v88 + v110;
        uint64_t v16 = v110 + (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + ((v101 ^ v96) & v17 ^ v101 & v96);
        int64x2_t v246 = vaddq_s64(v109, v11);
        int64x2_t v111 = (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL);
        int8x16_t v112 = (int8x16_t)vshrq_n_u64((uint64x2_t)v11, 0x13uLL);
        int64x2_t v113 = vshlq_n_s64(v11, 3uLL);
        uint64_t v114 = v95
             + v247.i64[0]
             + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41))
             + ((v21 ^ v100) & v20 ^ v100);
        int8x16_t v115 = (int8x16_t)vshrq_n_u64((uint64x2_t)v111, 1uLL);
        int64x2_t v116 = vshlq_n_s64(v111, 0x38uLL);
        uint64_t v19 = v96 + v114;
        uint64_t v15 = v114 + (__ROR8__(v16, 28) ^ __ROR8__(v16, 34) ^ __ROR8__(v16, 39)) + ((v17 ^ v101) & v16 ^ v17 & v101);
        int8x16_t v117 = veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v11, 6uLL), v112), (int8x16_t)v113), (int8x16_t)vshrq_n_u64((uint64x2_t)v112, 0x2AuLL));
        int64x2_t v118 = *v33;
        i8 = (long long *)v33[1].i8;
        int64x2_t v12 = vaddq_s64(vaddq_s64(vaddq_s64(v12, (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL)), (int64x2_t)veorq_s8(v117, (int8x16_t)vshlq_n_s64(v113, 0x2AuLL))), (int64x2_t)veorq_s8(veorq_s8(veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v111, 7uLL), v115), (int8x16_t)v116), (int8x16_t)vshrq_n_u64((uint64x2_t)v115, 7uLL)), (int8x16_t)vshlq_n_s64(v116, 7uLL)));
        uint64_t v119 = v100
             + v247.i64[1]
             + (__ROR8__(v19, 14) ^ __ROR8__(v19, 18) ^ __ROR8__(v19, 41))
             + ((v20 ^ v21) & v19 ^ v21);
        uint64_t v18 = v101 + v119;
        uint64_t v14 = v119 + (__ROR8__(v15, 28) ^ __ROR8__(v15, 34) ^ __ROR8__(v15, 39)) + ((v16 ^ v17) & v15 ^ v16 & v17);
        int64x2_t v247 = vaddq_s64(v118, v12);
        BOOL v120 = __OFSUB__(v22--, 1);
      }
      while (!((v22 < 0) ^ v120 | (v22 == 0)));
      long long v121 = i8 - 40;
      if (!--a2) {
        break;
      }
      int8x16_t v123 = *v3;
      long long v122 = v3 + 1;
      uint64_t v124 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
      int64x2_t v126 = (int64x2_t)*v121;
      long long v125 = (int64x2_t *)(v121 + 1);
      uint64_t v127 = v17 + v124;
      uint64_t v128 = v124 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
      int64x2_t v5 = (int64x2_t)vrev64q_s8(v123);
      uint64_t v129 = v20
           + v240.i64[1]
           + (__ROR8__(v127, 14) ^ __ROR8__(v127, 18) ^ __ROR8__(v127, 41))
           + ((v18 ^ v19) & v127 ^ v19);
      uint64_t v130 = v16 + v129;
      int64x2_t v240 = vaddq_s64(v126, v5);
      uint64_t v131 = v129 + (__ROR8__(v128, 28) ^ __ROR8__(v128, 34) ^ __ROR8__(v128, 39)) + ((v14 ^ v15) & v128 ^ v14 & v15);
      int8x16_t v132 = *v122++;
      uint64_t v133 = v19
           + v241.i64[0]
           + (__ROR8__(v130, 14) ^ __ROR8__(v130, 18) ^ __ROR8__(v130, 41))
           + ((v127 ^ v18) & v130 ^ v18);
      int64x2_t v134 = *v125++;
      uint64_t v135 = v15 + v133;
      uint64_t v136 = v133 + (__ROR8__(v131, 28) ^ __ROR8__(v131, 34) ^ __ROR8__(v131, 39)) + ((v128 ^ v14) & v131 ^ v128 & v14);
      int64x2_t v6 = (int64x2_t)vrev64q_s8(v132);
      uint64_t v137 = v18
           + v241.i64[1]
           + (__ROR8__(v135, 14) ^ __ROR8__(v135, 18) ^ __ROR8__(v135, 41))
           + ((v130 ^ v127) & v135 ^ v127);
      uint64_t v138 = v14 + v137;
      int64x2_t v241 = vaddq_s64(v134, v6);
      uint64_t v139 = v137
           + (__ROR8__(v136, 28) ^ __ROR8__(v136, 34) ^ __ROR8__(v136, 39))
           + ((v131 ^ v128) & v136 ^ v131 & v128);
      int8x16_t v140 = *v122++;
      uint64_t v141 = v127
           + v242.i64[0]
           + (__ROR8__(v138, 14) ^ __ROR8__(v138, 18) ^ __ROR8__(v138, 41))
           + ((v135 ^ v130) & v138 ^ v130);
      int64x2_t v142 = *v125++;
      uint64_t v143 = v128 + v141;
      uint64_t v144 = v141
           + (__ROR8__(v139, 28) ^ __ROR8__(v139, 34) ^ __ROR8__(v139, 39))
           + ((v136 ^ v131) & v139 ^ v136 & v131);
      int64x2_t v7 = (int64x2_t)vrev64q_s8(v140);
      uint64_t v145 = v130
           + v242.i64[1]
           + (__ROR8__(v143, 14) ^ __ROR8__(v143, 18) ^ __ROR8__(v143, 41))
           + ((v138 ^ v135) & v143 ^ v135);
      uint64_t v146 = v131 + v145;
      int64x2_t v242 = vaddq_s64(v142, v7);
      uint64_t v147 = v145
           + (__ROR8__(v144, 28) ^ __ROR8__(v144, 34) ^ __ROR8__(v144, 39))
           + ((v139 ^ v136) & v144 ^ v139 & v136);
      int8x16_t v148 = *v122++;
      uint64_t v149 = v135
           + v243.i64[0]
           + (__ROR8__(v146, 14) ^ __ROR8__(v146, 18) ^ __ROR8__(v146, 41))
           + ((v143 ^ v138) & v146 ^ v138);
      int64x2_t v150 = *v125++;
      uint64_t v151 = v136 + v149;
      uint64_t v152 = v149
           + (__ROR8__(v147, 28) ^ __ROR8__(v147, 34) ^ __ROR8__(v147, 39))
           + ((v144 ^ v139) & v147 ^ v144 & v139);
      int64x2_t v8 = (int64x2_t)vrev64q_s8(v148);
      uint64_t v153 = v138
           + v243.i64[1]
           + (__ROR8__(v151, 14) ^ __ROR8__(v151, 18) ^ __ROR8__(v151, 41))
           + ((v146 ^ v143) & v151 ^ v143);
      uint64_t v154 = v139 + v153;
      int64x2_t v243 = vaddq_s64(v150, v8);
      uint64_t v155 = v153
           + (__ROR8__(v152, 28) ^ __ROR8__(v152, 34) ^ __ROR8__(v152, 39))
           + ((v147 ^ v144) & v152 ^ v147 & v144);
      int8x16_t v156 = *v122++;
      uint64_t v157 = v143
           + v244.i64[0]
           + (__ROR8__(v154, 14) ^ __ROR8__(v154, 18) ^ __ROR8__(v154, 41))
           + ((v151 ^ v146) & v154 ^ v146);
      int64x2_t v158 = *v125++;
      uint64_t v159 = v144 + v157;
      uint64_t v160 = v157
           + (__ROR8__(v155, 28) ^ __ROR8__(v155, 34) ^ __ROR8__(v155, 39))
           + ((v152 ^ v147) & v155 ^ v152 & v147);
      int64x2_t v9 = (int64x2_t)vrev64q_s8(v156);
      uint64_t v161 = v146
           + v244.i64[1]
           + (__ROR8__(v159, 14) ^ __ROR8__(v159, 18) ^ __ROR8__(v159, 41))
           + ((v154 ^ v151) & v159 ^ v151);
      uint64_t v162 = v147 + v161;
      int64x2_t v244 = vaddq_s64(v158, v9);
      uint64_t v163 = v161
           + (__ROR8__(v160, 28) ^ __ROR8__(v160, 34) ^ __ROR8__(v160, 39))
           + ((v155 ^ v152) & v160 ^ v155 & v152);
      int8x16_t v164 = *v122++;
      uint64_t v165 = v151
           + v245.i64[0]
           + (__ROR8__(v162, 14) ^ __ROR8__(v162, 18) ^ __ROR8__(v162, 41))
           + ((v159 ^ v154) & v162 ^ v154);
      int64x2_t v166 = *v125++;
      uint64_t v167 = v152 + v165;
      uint64_t v168 = v165
           + (__ROR8__(v163, 28) ^ __ROR8__(v163, 34) ^ __ROR8__(v163, 39))
           + ((v160 ^ v155) & v163 ^ v160 & v155);
      int64x2_t v10 = (int64x2_t)vrev64q_s8(v164);
      uint64_t v169 = v154
           + v245.i64[1]
           + (__ROR8__(v167, 14) ^ __ROR8__(v167, 18) ^ __ROR8__(v167, 41))
           + ((v162 ^ v159) & v167 ^ v159);
      uint64_t v170 = v155 + v169;
      int64x2_t v245 = vaddq_s64(v166, v10);
      uint64_t v171 = v169
           + (__ROR8__(v168, 28) ^ __ROR8__(v168, 34) ^ __ROR8__(v168, 39))
           + ((v163 ^ v160) & v168 ^ v163 & v160);
      int8x16_t v172 = *v122++;
      uint64_t v173 = v159
           + v246.i64[0]
           + (__ROR8__(v170, 14) ^ __ROR8__(v170, 18) ^ __ROR8__(v170, 41))
           + ((v167 ^ v162) & v170 ^ v162);
      int64x2_t v174 = *v125++;
      uint64_t v175 = v160 + v173;
      uint64_t v176 = v173
           + (__ROR8__(v171, 28) ^ __ROR8__(v171, 34) ^ __ROR8__(v171, 39))
           + ((v168 ^ v163) & v171 ^ v168 & v163);
      int64x2_t v11 = (int64x2_t)vrev64q_s8(v172);
      uint64_t v177 = v162
           + v246.i64[1]
           + (__ROR8__(v175, 14) ^ __ROR8__(v175, 18) ^ __ROR8__(v175, 41))
           + ((v170 ^ v167) & v175 ^ v167);
      uint64_t v178 = v163 + v177;
      int64x2_t v246 = vaddq_s64(v174, v11);
      uint64_t v179 = v177
           + (__ROR8__(v176, 28) ^ __ROR8__(v176, 34) ^ __ROR8__(v176, 39))
           + ((v171 ^ v168) & v176 ^ v171 & v168);
      int8x16_t v180 = *v122;
      char v3 = v122 + 1;
      uint64_t v181 = v167
           + v247.i64[0]
           + (__ROR8__(v178, 14) ^ __ROR8__(v178, 18) ^ __ROR8__(v178, 41))
           + ((v175 ^ v170) & v178 ^ v170);
      int64x2_t v182 = *v125;
      i8 = (long long *)v125[1].i8;
      uint64_t v183 = v168 + v181;
      uint64_t v184 = v181
           + (__ROR8__(v179, 28) ^ __ROR8__(v179, 34) ^ __ROR8__(v179, 39))
           + ((v176 ^ v171) & v179 ^ v176 & v171);
      int64x2_t v12 = (int64x2_t)vrev64q_s8(v180);
      uint64_t v185 = v170
           + v247.i64[1]
           + (__ROR8__(v183, 14) ^ __ROR8__(v183, 18) ^ __ROR8__(v183, 41))
           + ((v178 ^ v175) & v183 ^ v175);
      int64x2_t v247 = vaddq_s64(v182, v12);
      uint64_t v186 = result[1] + v184;
      *result += v185
               + (__ROR8__(v184, 28) ^ __ROR8__(v184, 34) ^ __ROR8__(v184, 39))
               + ((v179 ^ v176) & v184 ^ v179 & v176);
      result[1] = v186;
      uint64_t v187 = result[3] + v176;
      result[2] += v179;
      result[3] = v187;
      uint64_t v188 = result[5] + v183;
      result[4] += v171 + v185;
      result[5] = v188;
      uint64_t v189 = result[7] + v175;
      result[6] += v178;
      result[7] = v189;
    }
    uint64_t v190 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
    uint64_t v191 = v17 + v190;
    uint64_t v192 = v190 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
    uint64_t v193 = v20
         + v240.i64[1]
         + (__ROR8__(v191, 14) ^ __ROR8__(v191, 18) ^ __ROR8__(v191, 41))
         + ((v18 ^ v19) & v191 ^ v19);
    uint64_t v194 = v16 + v193;
    uint64_t v195 = v193 + (__ROR8__(v192, 28) ^ __ROR8__(v192, 34) ^ __ROR8__(v192, 39)) + ((v14 ^ v15) & v192 ^ v14 & v15);
    uint64_t v196 = v19
         + v241.i64[0]
         + (__ROR8__(v194, 14) ^ __ROR8__(v194, 18) ^ __ROR8__(v194, 41))
         + ((v191 ^ v18) & v194 ^ v18);
    uint64_t v197 = v15 + v196;
    uint64_t v198 = v196 + (__ROR8__(v195, 28) ^ __ROR8__(v195, 34) ^ __ROR8__(v195, 39)) + ((v192 ^ v14) & v195 ^ v192 & v14);
    uint64_t v199 = v18
         + v241.i64[1]
         + (__ROR8__(v197, 14) ^ __ROR8__(v197, 18) ^ __ROR8__(v197, 41))
         + ((v194 ^ v191) & v197 ^ v191);
    uint64_t v200 = v14 + v199;
    uint64_t v201 = v199 + (__ROR8__(v198, 28) ^ __ROR8__(v198, 34) ^ __ROR8__(v198, 39)) + ((v195 ^ v192) & v198 ^ v195 & v192);
    uint64_t v202 = v191
         + v242.i64[0]
         + (__ROR8__(v200, 14) ^ __ROR8__(v200, 18) ^ __ROR8__(v200, 41))
         + ((v197 ^ v194) & v200 ^ v194);
    uint64_t v203 = v192 + v202;
    uint64_t v204 = v202 + (__ROR8__(v201, 28) ^ __ROR8__(v201, 34) ^ __ROR8__(v201, 39)) + ((v198 ^ v195) & v201 ^ v198 & v195);
    uint64_t v205 = v194
         + v242.i64[1]
         + (__ROR8__(v203, 14) ^ __ROR8__(v203, 18) ^ __ROR8__(v203, 41))
         + ((v200 ^ v197) & v203 ^ v197);
    uint64_t v206 = v195 + v205;
    uint64_t v207 = v205 + (__ROR8__(v204, 28) ^ __ROR8__(v204, 34) ^ __ROR8__(v204, 39)) + ((v201 ^ v198) & v204 ^ v201 & v198);
    uint64_t v208 = v197
         + v243.i64[0]
         + (__ROR8__(v206, 14) ^ __ROR8__(v206, 18) ^ __ROR8__(v206, 41))
         + ((v203 ^ v200) & v206 ^ v200);
    uint64_t v209 = v198 + v208;
    uint64_t v210 = v208 + (__ROR8__(v207, 28) ^ __ROR8__(v207, 34) ^ __ROR8__(v207, 39)) + ((v204 ^ v201) & v207 ^ v204 & v201);
    uint64_t v211 = v200
         + v243.i64[1]
         + (__ROR8__(v209, 14) ^ __ROR8__(v209, 18) ^ __ROR8__(v209, 41))
         + ((v206 ^ v203) & v209 ^ v203);
    uint64_t v212 = v201 + v211;
    uint64_t v213 = v211 + (__ROR8__(v210, 28) ^ __ROR8__(v210, 34) ^ __ROR8__(v210, 39)) + ((v207 ^ v204) & v210 ^ v207 & v204);
    uint64_t v214 = v203
         + v244.i64[0]
         + (__ROR8__(v212, 14) ^ __ROR8__(v212, 18) ^ __ROR8__(v212, 41))
         + ((v209 ^ v206) & v212 ^ v206);
    uint64_t v215 = v204 + v214;
    uint64_t v216 = v214 + (__ROR8__(v213, 28) ^ __ROR8__(v213, 34) ^ __ROR8__(v213, 39)) + ((v210 ^ v207) & v213 ^ v210 & v207);
    uint64_t v217 = v206
         + v244.i64[1]
         + (__ROR8__(v215, 14) ^ __ROR8__(v215, 18) ^ __ROR8__(v215, 41))
         + ((v212 ^ v209) & v215 ^ v209);
    uint64_t v218 = v207 + v217;
    uint64_t v219 = v217 + (__ROR8__(v216, 28) ^ __ROR8__(v216, 34) ^ __ROR8__(v216, 39)) + ((v213 ^ v210) & v216 ^ v213 & v210);
    uint64_t v220 = v209
         + v245.i64[0]
         + (__ROR8__(v218, 14) ^ __ROR8__(v218, 18) ^ __ROR8__(v218, 41))
         + ((v215 ^ v212) & v218 ^ v212);
    uint64_t v221 = v210 + v220;
    uint64_t v222 = v220 + (__ROR8__(v219, 28) ^ __ROR8__(v219, 34) ^ __ROR8__(v219, 39)) + ((v216 ^ v213) & v219 ^ v216 & v213);
    uint64_t v223 = v212
         + v245.i64[1]
         + (__ROR8__(v221, 14) ^ __ROR8__(v221, 18) ^ __ROR8__(v221, 41))
         + ((v218 ^ v215) & v221 ^ v215);
    uint64_t v224 = v213 + v223;
    uint64_t v225 = v223 + (__ROR8__(v222, 28) ^ __ROR8__(v222, 34) ^ __ROR8__(v222, 39)) + ((v219 ^ v216) & v222 ^ v219 & v216);
    uint64_t v226 = v215
         + v246.i64[0]
         + (__ROR8__(v224, 14) ^ __ROR8__(v224, 18) ^ __ROR8__(v224, 41))
         + ((v221 ^ v218) & v224 ^ v218);
    uint64_t v227 = v216 + v226;
    uint64_t v228 = v226 + (__ROR8__(v225, 28) ^ __ROR8__(v225, 34) ^ __ROR8__(v225, 39)) + ((v222 ^ v219) & v225 ^ v222 & v219);
    uint64_t v229 = v218
         + v246.i64[1]
         + (__ROR8__(v227, 14) ^ __ROR8__(v227, 18) ^ __ROR8__(v227, 41))
         + ((v224 ^ v221) & v227 ^ v221);
    uint64_t v230 = v219 + v229;
    uint64_t v231 = v229 + (__ROR8__(v228, 28) ^ __ROR8__(v228, 34) ^ __ROR8__(v228, 39)) + ((v225 ^ v222) & v228 ^ v225 & v222);
    uint64_t v232 = v221
         + v247.i64[0]
         + (__ROR8__(v230, 14) ^ __ROR8__(v230, 18) ^ __ROR8__(v230, 41))
         + ((v227 ^ v224) & v230 ^ v224);
    uint64_t v233 = v222 + v232;
    uint64_t v234 = v232 + (__ROR8__(v231, 28) ^ __ROR8__(v231, 34) ^ __ROR8__(v231, 39)) + ((v228 ^ v225) & v231 ^ v228 & v225);
    uint64_t v235 = v224
         + v247.i64[1]
         + (__ROR8__(v233, 14) ^ __ROR8__(v233, 18) ^ __ROR8__(v233, 41))
         + ((v230 ^ v227) & v233 ^ v227);
    uint64_t v236 = result[1] + v234;
    *result += v235
             + (__ROR8__(v234, 28) ^ __ROR8__(v234, 34) ^ __ROR8__(v234, 39))
             + ((v231 ^ v228) & v234 ^ v231 & v228);
    result[1] = v236;
    uint64_t v237 = result[3] + v228;
    result[2] += v231;
    result[3] = v237;
    uint64_t v238 = result[5] + v233;
    result[4] += v225 + v235;
    result[5] = v238;
    uint64_t v239 = result[7] + v227;
    result[6] += v230;
    result[7] = v239;
  }
  return result;
}

void *ccsha1_di()
{
  return &ccsha1_vng_arm_di;
}

int64x2_t *AccelerateCrypto_SHA512_compress_hwassist(int64x2_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int64x2_t v3 = *result;
    int64x2_t v4 = result[1];
    int64x2_t v5 = result[2];
    int64x2_t v6 = result[3];
    do
    {
      _Q24 = v3;
      _Q25 = v4;
      _Q0 = vrev64q_s8(*a3);
      _Q1 = vrev64q_s8(a3[1]);
      _Q2 = vrev64q_s8(a3[2]);
      _Q3 = vrev64q_s8(a3[3]);
      _Q4 = vrev64q_s8(a3[4]);
      _Q5 = vrev64q_s8(a3[5]);
      _Q6 = vrev64q_s8(a3[6]);
      _Q7 = vrev64q_s8(a3[7]);
      a3 += 8;
      _Q29 = vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v4, (int8x16_t)v5, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v26 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v29 = (int8x16_t)vaddq_s64(v4, v26);
      _Q29 = vextq_s8(v29, (int8x16_t)v5, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v3, v29, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v35 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v38 = (int8x16_t)vaddq_s64(v3, v35);
      _Q29 = vextq_s8(v38, v29, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v38, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v44 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v47 = (int8x16_t)vaddq_s64(_Q27, v44);
      _Q29 = vextq_s8(v47, v38, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v47, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v53 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v56 = (int8x16_t)vaddq_s64(_Q26, v53);
      _Q29 = vextq_s8(v56, v47, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v56, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v62 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v65 = (int8x16_t)vaddq_s64(_Q25, v62);
      _Q29 = vextq_s8(v65, v56, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v65, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v71 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v74 = (int8x16_t)vaddq_s64(_Q24, v71);
      _Q29 = vextq_s8(v74, v65, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v74, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v80 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v83 = (int8x16_t)vaddq_s64(_Q27, v80);
      _Q29 = vextq_s8(v83, v74, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v83, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v89 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v92 = (int8x16_t)vaddq_s64(_Q26, v89);
      _Q29 = vextq_s8(v92, v83, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v92, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v98 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v101 = (int8x16_t)vaddq_s64(_Q25, v98);
      _Q29 = vextq_s8(v101, v92, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v101, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v107 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v110 = (int8x16_t)vaddq_s64(_Q24, v107);
      _Q29 = vextq_s8(v110, v101, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v110, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v116 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v119 = (int8x16_t)vaddq_s64(_Q27, v116);
      _Q29 = vextq_s8(v119, v110, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v119, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v125 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v128 = (int8x16_t)vaddq_s64(_Q26, v125);
      _Q29 = vextq_s8(v128, v119, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v128, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v134 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v137 = (int8x16_t)vaddq_s64(_Q25, v134);
      _Q29 = vextq_s8(v137, v128, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v137, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v143 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v146 = (int8x16_t)vaddq_s64(_Q24, v143);
      _Q29 = vextq_s8(v146, v137, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v146, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v152 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v155 = (int8x16_t)vaddq_s64(_Q27, v152);
      _Q29 = vextq_s8(v155, v146, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v155, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v161 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v164 = (int8x16_t)vaddq_s64(_Q26, v161);
      _Q29 = vextq_s8(v164, v155, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v164, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v170 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v173 = (int8x16_t)vaddq_s64(_Q25, v170);
      _Q29 = vextq_s8(v173, v164, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v173, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v179 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v182 = (int8x16_t)vaddq_s64(_Q24, v179);
      _Q29 = vextq_s8(v182, v173, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v182, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v188 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v191 = (int8x16_t)vaddq_s64(_Q27, v188);
      _Q29 = vextq_s8(v191, v182, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v191, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v197 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v200 = (int8x16_t)vaddq_s64(_Q26, v197);
      _Q29 = vextq_s8(v200, v191, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v200, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v206 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v209 = (int8x16_t)vaddq_s64(_Q25, v206);
      _Q29 = vextq_s8(v209, v200, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v209, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v215 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v218 = (int8x16_t)vaddq_s64(_Q24, v215);
      _Q29 = vextq_s8(v218, v209, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v218, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v224 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v227 = (int8x16_t)vaddq_s64(_Q27, v224);
      _Q29 = vextq_s8(v227, v218, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v227, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v233 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v236 = (int8x16_t)vaddq_s64(_Q26, v233);
      _Q29 = vextq_s8(v236, v227, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v236, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }
      int64x2_t v242 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }
      int8x16_t v245 = (int8x16_t)vaddq_s64(_Q25, v242);
      _Q29 = vextq_s8(v245, v236, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v245, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }
      int64x2_t v251 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }
      int8x16_t v254 = (int8x16_t)vaddq_s64(_Q24, v251);
      _Q29 = vextq_s8(v254, v245, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v254, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }
      int64x2_t v260 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }
      int8x16_t v263 = (int8x16_t)vaddq_s64(_Q27, v260);
      _Q29 = vextq_s8(v263, v254, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v263, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }
      int64x2_t v269 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }
      int8x16_t v272 = (int8x16_t)vaddq_s64(_Q26, v269);
      _Q29 = vextq_s8(v272, v263, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v272, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }
      int64x2_t v278 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }
      int8x16_t v281 = (int8x16_t)vaddq_s64(_Q25, v278);
      _Q29 = vextq_s8(v281, v272, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v281, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }
      int64x2_t v287 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }
      int8x16_t v290 = (int8x16_t)vaddq_s64(_Q24, v287);
      _Q29 = vextq_s8(v290, v281, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v290, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }
      int64x2_t v296 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }
      int8x16_t v299 = (int8x16_t)vaddq_s64(_Q27, v296);
      _Q29 = vextq_s8(v299, v290, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v299, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }
      int64x2_t v305 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }
      int8x16_t v308 = (int8x16_t)vaddq_s64(_Q26, v305);
      _Q29 = vextq_s8(v308, v299, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v308, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }
      int8x16_t v313 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v313, v308, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v313, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }
      int8x16_t v318 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v318, v313, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v318, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }
      int8x16_t v323 = (int8x16_t)vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8(v323, v318, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v323, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }
      int8x16_t v328 = (int8x16_t)vaddq_s64(_Q26, _Q30);
      _Q29 = vextq_s8(v328, v323, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v328, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }
      int8x16_t v333 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v333, v328, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v333, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }
      int8x16_t v338 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v338, v333, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v338, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }
      int64x2_t v343 = vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8((int8x16_t)v343, v338, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, (int8x16_t)v343, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }
      int64x2_t v3 = vaddq_s64(v3, _Q24);
      int64x2_t v4 = vaddq_s64(v4, _Q25);
      int64x2_t v5 = vaddq_s64(v5, vaddq_s64(_Q26, _Q30));
      int64x2_t v6 = vaddq_s64(v6, v343);
    }
    while (a2-- > 1);
    *ssize_t result = v3;
    result[1] = v4;
    result[2] = v5;
    result[3] = v6;
  }
  return result;
}

int32x4_t *AccelerateCrypto_SHA1_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v5 = *a3;
    int8x16_t v6 = a3[1];
    int8x16_t v7 = a3[2];
    int8x16_t v8 = a3[3];
    int64x2_t v4 = a3 + 4;
    int32x4_t v10 = *result;
    int64x2_t v9 = result + 1;
    int32x4_t v11 = v10;
    v10.i32[0] = v9->i32[0];
    int64x2_t v12 = v9 - 1;
    v3.i32[0] = v10.i32[0];
    _Q1 = (int32x4_t)vrev32q_s8(v6);
    _Q2 = (int32x4_t)vrev32q_s8(v7);
    _Q3 = (int32x4_t)vrev32q_s8(v8);
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v5), *(int32x4_t *)K_XMM_AR);
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
    _Q19 = v3;
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = v11.i32[0];
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, loc_1A8E6C2A0);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }
    _Q4 = vaddq_s32(_Q0, loc_1A8E6C2A0);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }
    _Q5 = vaddq_s32(_Q1, loc_1A8E6C2A0);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }
    _Q6 = vaddq_s32(_Q2, loc_1A8E6C2A0);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }
    _Q7 = vaddq_s32(_Q3, loc_1A8E6C2A0);
    BOOL v105 = a2 <= 1;
    for (uint64_t i = a2 - 1; !v105; --i)
    {
      int8x16_t v107 = *v4;
      int8x16_t v108 = v4[1];
      int8x16_t v109 = v4[2];
      int8x16_t v110 = v4[3];
      v4 += 4;
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
      }
      _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v107), *(int32x4_t *)K_XMM_AR);
      _Q1 = (int32x4_t)vrev32q_s8(v108);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
      _Q2 = (int32x4_t)vrev32q_s8(v109);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
      _Q3 = (int32x4_t)vrev32q_s8(v110);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
      }
      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
      _Q19 = vaddq_s32(v3, _Q19);
      int32x4_t v11 = vaddq_s32(v11, _Q18);
      int32x4_t v3 = _Q19;
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = v11.i32[0];
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, loc_1A8E6C2A0);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }
      _Q4 = vaddq_s32(_Q0, loc_1A8E6C2A0);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }
      _Q5 = vaddq_s32(_Q1, loc_1A8E6C2A0);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }
      _Q6 = vaddq_s32(_Q2, loc_1A8E6C2A0);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }
      _Q7 = vaddq_s32(_Q3, loc_1A8E6C2A0);
      BOOL v105 = i <= 1;
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
    }
    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
    }
    *int64x2_t v12 = vaddq_s32(v11, _Q18);
    ssize_t result = v12 + 1;
    result->i32[0] = vaddq_s32(v3, _Q19).u32[0];
  }
  return result;
}

uint64_t ccsha512_final(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  if (v6 <= *(unsigned int *)(v8 + v6)) {
    *(_DWORD *)(v8 + v6) = 0;
  }
  unint64_t v9 = v7 + 8 + v6;
  size_t v10 = (v9 + 11) & 0xFFFFFFFFFFFFFFF8;
  int32x4_t v11 = (uint64_t *)((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v11, v10);
  memmove(v11, a2, v9 + 4);
  int64x2_t v12 = (char *)v11 + v7 + 8;
  uint64_t v13 = *(unsigned int *)&v12[v6];
  *v11 += (8 * v13);
  *(_DWORD *)&v12[v6] = v13 + 1;
  v12[v13] = 0x80;
  unint64_t v14 = *(unsigned int *)&v12[v6];
  if (v6 - 16 < v14)
  {
    while (v6 > v14)
    {
      *(_DWORD *)&v12[v6] = v14 + 1;
      v12[v14] = 0;
      unint64_t v14 = *(unsigned int *)&v12[v6];
    }
    (*(void (**)(void *, uint64_t))(a1 + 48))(v11 + 1, 1);
    LODWORD(v14) = 0;
    uint64_t v7 = *(void *)(a1 + 8);
    unint64_t v6 = *(void *)(a1 + 16);
    *(_DWORD *)((char *)v11 + v7 + v6 + 8) = 0;
  }
  uint64_t v15 = (uint64_t)v11 + v7 + 8;
  uint64_t v16 = (_DWORD *)(v15 + v6);
  if (v6 - 8 > v14)
  {
    unint64_t v17 = v14;
    do
    {
      *uint64_t v16 = v14 + 1;
      *(unsigned char *)(v15 + v17) = 0;
      unint64_t v17 = *v16;
      LODWORD(v14) = *v16;
    }
    while (v6 - 8 > v17);
  }
  *((void *)v16 - 1) = bswap64(*v11);
  (*(void (**)(void *, uint64_t))(a1 + 48))(v11 + 1, 1);
  if (*(void *)a1 >= 8uLL)
  {
    unsigned int v18 = 0;
    unint64_t v19 = 0;
    unsigned int v20 = 1;
    do
    {
      *(void *)(a3 + v18) = bswap64(v11[v19 + 1]);
      unint64_t v19 = v20++;
      v18 += 8;
    }
    while (v19 < *(void *)a1 >> 3);
  }
  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12, v11);
}

uint64_t cc_clear(rsize_t __n, void *__s)
{
  return memset_s(__s, __n, 0, __n);
}

void *ccsha256_di()
{
  return &ccsha256_vng_arm_di;
}

void *ccsha384_di()
{
  if (MEMORY[0xFFFFFC010] < 0) {
    return &ccsha384_vng_arm_hw_di;
  }
  else {
    return &ccsha384_vng_arm_di;
  }
}

uint64_t cc_disable_dit_with_sb(unsigned int *a1)
{
  return timingsafe_restore_if_supported(*a1);
}

int64_t rosetta_dyld_get_runtime_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v9 = a1;
  return _crossarch_trap(0, 0, (void *)1, &v9, a5, a6, a7, a8);
}

int64_t rosetta_dyld_get_aot_size(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  v9[1] = a2;
  v9[0] = a1;
  void v9[2] = a3;
  void v9[3] = a4;
  void v9[4] = a5;
  return _crossarch_trap(0, 0, (void *)2, v9, a5, a6, a7, a8);
}

int64_t rosetta_dyld_map_aot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  v9[0] = a1;
  v9[1] = a2;
  void v9[2] = a3;
  void v9[3] = a4;
  void v9[4] = a5;
  void v9[5] = a6;
  return _crossarch_trap(0, 0, (void *)3, v9, a5, a6, a7, a8);
}

uint64_t mach_continuous_time(void)
{
  if (MEMORY[0xFFFFFC091])
  {
    if (MEMORY[0xFFFFFC090] == 3)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }
    else if (MEMORY[0xFFFFFC090] == 2)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
    }
    else
    {
      __isb(0xFu);
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }
    uint64_t v1 = MEMORY[0xFFFFFC0A8];
  }
  else
  {
    do
    {
      uint64_t v4 = MEMORY[0xFFFFFC098];
      uint64_t v3 = mach_absolute_time();
    }
    while (v4 != MEMORY[0xFFFFFC098]);
    unint64_t StatusReg = v3;
    uint64_t v1 = v4;
  }
  return v1 + StatusReg;
}

mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
{
  if (rcv_msg != 0 && (option & 2) != 0) {
    uint64_t v9 = option | 0x100000000;
  }
  else {
    uint64_t v9 = option;
  }
  if ((v9 & 0x100000000) != 0)
  {
    v27[0] = msg;
    v27[1] = rcv_msg;
    mach_msg_size_t v28 = send_size;
    mach_msg_size_t v29 = rcv_size;
    uint64_t v30 = &v26;
    uint64_t v31 = 0;
    uint64_t v32 = 0x8000000000;
  }
  if (v9) {
    uint64_t v10 = notify;
  }
  else {
    uint64_t v10 = 0;
  }
  if ((v9 & 0x4003) == 0x4002) {
    msg->msgh_remote_port = notify;
  }
  unint64_t v11 = v9 | 0x400000000;
  int64x2_t v12 = (void *)timeout;
  uint64_t msgh_bits = msg->msgh_bits;
  unint64_t v14 = *(void **)&msg->msgh_remote_port;
  uint64_t msgh_voucher_port = msg->msgh_voucher_port;
  uint64_t msgh_id = msg->msgh_id;
  BOOL v18 = (v9 & 1) == 0 || (int)msgh_bits >= 0;
  if ((v9 & 0x100000000) != 0)
  {
    if (v18) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = msg[1].msgh_bits;
    }
    uint64_t v21 = (void *)(msgh_bits | 0x200000000);
    uint64_t v22 = (void *)(msgh_voucher_port | (msgh_id << 32));
    int64x2_t v23 = (void *)(v20 | (*(void *)&rcv_name << 32));
    int8x16_t v24 = (void *)((v10 << 32) | 2);
    msg = (mach_msg_header_t *)v27;
  }
  else
  {
    if (v18) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = msg[1].msgh_bits;
    }
    uint64_t v21 = (void *)(msgh_bits | (*(void *)&send_size << 32));
    uint64_t v22 = (void *)(msgh_voucher_port | (msgh_id << 32));
    int64x2_t v23 = (void *)(v19 | (*(void *)&rcv_name << 32));
    int8x16_t v24 = (void *)(rcv_size | (unint64_t)(v10 << 32));
  }
  return mach_msg2_internal(msg, v11, v21, v14, v22, v23, v24, v12);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  mach_msg_bits_t msgh_bits = a1->msgh_bits;
  mach_msg_destroy_port(a1->msgh_remote_port, a1->msgh_bits & 0x1F);
  mach_msg_destroy_port(a1->msgh_voucher_port, HIWORD(msgh_bits) & 0x1F);
  if ((msgh_bits & 0x80000000) != 0)
  {
    mach_msg_bits_t v3 = a1[1].msgh_bits;
    if (v3)
    {
      int v4 = 0;
      p_msgh_vm_size_t size = &a1[1].msgh_size;
      do
      {
        mach_msg_size_t v6 = p_msgh_size[2];
        switch(HIBYTE(v6))
        {
          case 0u:
            mach_msg_size_t v7 = *p_msgh_size;
            p_msgh_size += 3;
            mach_msg_destroy_port(v7, BYTE2(v6));
            break;
          case 1u:
            if (p_msgh_size[2])
            {
              mach_vm_size_t v8 = p_msgh_size[3];
              if (v8) {
                goto LABEL_17;
              }
            }
            goto LABEL_31;
          case 2u:
            if (p_msgh_size[3])
            {
              uint64_t v9 = 0;
              mach_vm_address_t v10 = *(void *)p_msgh_size;
              do
              {
                mach_msg_destroy_port(*(unsigned int *)(v10 + 4 * v9), *((unsigned __int8 *)p_msgh_size + 10));
                unint64_t v11 = p_msgh_size[3];
                ++v9;
              }
              while (v11 > v9);
              if (p_msgh_size[3] && *((unsigned char *)p_msgh_size + 8) != 0)
              {
                mach_vm_size_t v8 = 4 * v11;
LABEL_17:
                mach_vm_deallocate(mach_task_self_, *(void *)p_msgh_size, v8);
              }
            }
            goto LABEL_31;
          case 3u:
            goto LABEL_31;
          case 4u:
            if ((v6 & 2) == 0)
            {
              mach_port_t v13 = mach_task_self_;
              mach_port_name_t v14 = p_msgh_size[3];
              mach_vm_address_t v15 = *(void *)p_msgh_size;
              if (_kernelrpc_mach_port_unguard_trap(mach_task_self_, v14, *(void *)p_msgh_size) == 268435459)
              {
                uint64_t v19 = 0x100000000;
                mach_port_name_t v20 = v14;
                mach_vm_address_t v21 = v15;
                uint64_t reply_port = mig_get_reply_port();
                *(void *)&v18.mach_msg_bits_t msgh_bits = 0x2C00001513;
                *(void *)&v18.msgh_remote_port = __PAIR64__(reply_port, v13);
                *(void *)&v18.uint64_t msgh_voucher_port = 0xCA200000000;
                int v17 = mach_msg2_internal(&v18, 0x200000003uLL, (void *)0x2C00001513, (void *)__PAIR64__(reply_port, v13), (void *)0xCA200000000, (void *)(reply_port << 32), (void *)0x2C, 0);
                if ((v17 - 268435458) > 0xE || ((1 << (v17 - 2)) & 0x4003) == 0)
                {
                  if (v17)
                  {
                    mig_dealloc_reply_port(v18.msgh_local_port);
                  }
                  else if (v18.msgh_id != 3334 {
                         || (v18.msgh_bits & 0x80000000) != 0
                  }
                         || *(void *)&v18.msgh_size != 36
                         || v20)
                  {
                    mach_msg_destroy(&v18);
                  }
                }
              }
              mach_msg_size_t v6 = p_msgh_size[2];
            }
            mach_msg_destroy_port(p_msgh_size[3], BYTE2(v6));
LABEL_31:
            p_msgh_size += 4;
            break;
          default:
            break;
        }
        ++v4;
      }
      while (v4 != v3);
    }
  }
}

uint64_t mach_msg_destroy_port(uint64_t name, int a2)
{
  if ((name - 1) <= 0xFFFFFFFD)
  {
    mach_port_name_t v2 = name;
    switch(a2)
    {
      case 16:
        mach_port_t v4 = mach_task_self_;
        mach_port_name_t name = mach_port_mod_refs(v4, v2, 1u, -1);
        break;
      case 17:
      case 18:
        mach_port_t v3 = mach_task_self_;
        goto LABEL_33;
      case 20:
        mach_port_t v5 = mach_task_self_;
        if (_kernelrpc_mach_port_insert_right_trap(mach_task_self_, name, name, 0x14u) == 268435459)
        {
          LODWORD(v12) = 1;
          HIDWORD(v12) = v2;
          uint64_t v13 = 0x14000000000000;
          uint64_t v14 = 0x100000000;
          mach_port_name_t v15 = v2;
          uint64_t reply_port = mig_get_reply_port();
          *(void *)&v11.mach_msg_bits_t msgh_bits = 0x3480001513;
          *(void *)&v11.msgh_remote_port = __PAIR64__(reply_port, v5);
          *(void *)&v11.uint64_t msgh_voucher_port = 0xC8E00000000;
          int v7 = mach_msg2_internal(&v11, 0x200000003uLL, (void *)0x3480001513, (void *)__PAIR64__(reply_port, v5), (void *)0xC8E00000000, (void *)((reply_port << 32) | 1), (void *)0x2C, 0);
          if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
          {
            if (v7)
            {
              mig_dealloc_reply_port(v11.msgh_local_port);
            }
            else if (v11.msgh_id != 3314 {
                   || (v11.msgh_bits & 0x80000000) != 0
            }
                   || v11.msgh_size != 36
                   || v11.msgh_remote_port
                   || v13)
            {
              mach_msg_destroy(&v11);
            }
          }
        }
        mach_port_t v3 = mach_task_self_;
LABEL_33:
        mach_port_name_t name = mach_port_deallocate(v3, v2);
        break;
      case 21:
        mach_port_t v8 = mach_task_self_;
        uint64_t v14 = 0;
        uint64_t v12 = 0x100000000;
        uint64_t v13 = name | 0x1500000000;
        uint64_t v9 = mig_get_reply_port();
        *(void *)&v11.mach_msg_bits_t msgh_bits = 0x2800001513;
        *(void *)&v11.msgh_remote_port = __PAIR64__(v9, v8);
        *(void *)&v11.uint64_t msgh_voucher_port = 0xC8F00000000;
        int v10 = mach_msg2_internal(&v11, 0x200000003uLL, (void *)0x2800001513, (void *)__PAIR64__(v9, v8), (void *)0xC8F00000000, (void *)(v9 << 32), (void *)0x30, 0);
        if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
        {
          if (v10)
          {
            mig_dealloc_reply_port(v11.msgh_local_port);
          }
          else if (v11.msgh_id == 3315 {
                 && (v11.msgh_bits & 0x80000000) != 0
          }
                 && v12 == 1
                 && v11.msgh_size == 40
                 && !v11.msgh_remote_port
                 && !HIBYTE(HIDWORD(v13)))
          {
            mach_port_name_t v2 = HIDWORD(v12);
          }
          else
          {
            mach_msg_destroy(&v11);
          }
        }
        mach_port_name_t name = mach_port_deallocate(mach_task_self_, v2);
        break;
      default:
        return name;
    }
  }
  return name;
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  mach_port_name_t v2 = *(_DWORD *)(StatusReg + 16);
  if (v2 && _task_reply_port != v2)
  {
    *(void *)(StatusReg + 16) = _task_reply_port;
    mach_port_mod_refs(mach_task_self_, v2, 1u, -1);
    if (v2 != reply_port) {
      mach_port_deallocate(mach_task_self_, reply_port);
    }
    *(void *)(StatusReg + 16) = 0;
  }
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  int result = __proc_info((void *)2, *(void **)&pid, *(void **)&flavor, (void *)arg, buffer, *(void **)&buffersize, v5, v6);
  if (result == -1) {
    return 0;
  }
  return result;
}

int chmod(const char *a1, mode_t a2)
{
  int result = __chmod(a1, a2);
  if (result < 0)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    mach_msg_size_t v6 = *(int **)(StatusReg + 8);
    if (!v6) {
      mach_msg_size_t v6 = &errno;
    }
    int v7 = a2 & 0xC00;
    if (*v6 == 1 && v7 != 0)
    {
      if ((a2 & 0x400) == 0) {
        goto LABEL_24;
      }
      int result = __chmod(a1, a2 ^ 0x400);
      if (result < 0)
      {
        uint64_t v9 = *(int **)(StatusReg + 8);
        if (!v9) {
          uint64_t v9 = &errno;
        }
        if (*v9 == 1)
        {
LABEL_24:
          if ((a2 & 0x800) == 0) {
            goto LABEL_12;
          }
          int result = __chmod(a1, a2 ^ 0x800);
          if (result < 0)
          {
            int v10 = *(int **)(StatusReg + 8);
            if (!v10) {
              int v10 = &errno;
            }
            if (*v10 == 1)
            {
LABEL_12:
              if (v7 == 3072)
              {
                return __chmod(a1, a2 ^ 0xC00);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

int fchmod(int a1, mode_t a2)
{
  int result = __fchmod(a1, a2);
  if (result < 0)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    mach_msg_size_t v6 = *(int **)(StatusReg + 8);
    if (!v6) {
      mach_msg_size_t v6 = &errno;
    }
    int v7 = a2 & 0xC00;
    if (*v6 == 1 && v7 != 0)
    {
      if ((a2 & 0x400) == 0) {
        goto LABEL_24;
      }
      int result = __fchmod(a1, a2 ^ 0x400);
      if (result < 0)
      {
        uint64_t v9 = *(int **)(StatusReg + 8);
        if (!v9) {
          uint64_t v9 = &errno;
        }
        if (*v9 == 1)
        {
LABEL_24:
          if ((a2 & 0x800) == 0) {
            goto LABEL_12;
          }
          int result = __fchmod(a1, a2 ^ 0x800);
          if (result < 0)
          {
            int v10 = *(int **)(StatusReg + 8);
            if (!v10) {
              int v10 = &errno;
            }
            if (*v10 == 1)
            {
LABEL_12:
              if (v7 == 3072)
              {
                return __fchmod(a1, a2 ^ 0xC00);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

int ioctl(int a1, unint64_t a2, ...)
{
  va_start(va, a2);
  mach_port_t v8 = va_arg(va, void *);
  return __ioctl(a1, (void *)a2, v8, v2, v3, v4, v5, v6);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  kern_return_t result;

  uint32_t numer = mach_timebase_info_cached_info.numer;
  uint32_t denom = mach_timebase_info_cached_info.denom;
  if (mach_timebase_info_cached_info.numer) {
    BOOL v4 = mach_timebase_info_cached_info.denom == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    int result = mach_timebase_info_trap(&mach_timebase_info_cached_info);
    if (result) {
      return result;
    }
    uint32_t numer = mach_timebase_info_cached_info.numer;
    uint32_t denom = mach_timebase_info_cached_info.denom;
  }
  int result = 0;
  info->uint32_t numer = numer;
  info->uint32_t denom = denom;
  return result;
}

int unlink(const char *a1)
{
  int result = __unlink(a1, v1, v2, v3, v4, v5, v6, v7);
  if (!result) {
    atomic_fetch_add(__remove_counter, 1u);
  }
  return result;
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  __rename(__from, __to, __ec);
  if (!v3) {
    atomic_fetch_add(__remove_counter, 1u);
  }
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  if ((a4 & 4) == 0) {
    return __open_dprotected_np(a1, a2, a3, a4);
  }
  BOOL v4 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (!v4) {
    BOOL v4 = &errno;
  }
  *BOOL v4 = 22;
  return -1;
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  kern_return_t v4;
  uint64_t reply_port;
  kern_return_t v6;
  mach_msg_header_t v9;
  uint64_t v10;
  mach_port_name_t v11;
  uint64_t v12;

  BOOL v4 = _kernelrpc_mach_port_deallocate_trap(task, name);
  if (v4 == 268435459)
  {
    uint64_t v12 = 0;
    int v10 = 0x100000000;
    mach_msg_header_t v11 = name;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v9.mach_msg_bits_t msgh_bits = 0x2400001513;
    *(void *)&v9.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v9.uint64_t msgh_voucher_port = 0xC8600000000;
    mach_msg_size_t v6 = mach_msg2_internal(&v9, 0x200000003uLL, (void *)0x2400001513, (void *)__PAIR64__(reply_port, task), (void *)0xC8600000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    BOOL v4 = v6;
    if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
    {
      if (v6)
      {
        mig_dealloc_reply_port(v9.msgh_local_port);
        return v4;
      }
      if (v9.msgh_id == 71)
      {
        BOOL v4 = -308;
      }
      else if (v9.msgh_id == 3306)
      {
        BOOL v4 = -300;
        if ((v9.msgh_bits & 0x80000000) == 0 && *(void *)&v9.msgh_size == 36)
        {
          BOOL v4 = v11;
          if (!v11) {
            return v4;
          }
        }
      }
      else
      {
        BOOL v4 = -301;
      }
      mach_msg_destroy(&v9);
    }
  }
  return v4;
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  mach_msg_header_t v13;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_delta_t v16;
  mach_port_context_t v17;

  mach_port_t v8 = _kernelrpc_mach_port_destruct_trap(task, name, srdelta, guard);
  if (v8 == 268435459)
  {
    uint64_t v14 = 0x100000000;
    mach_port_name_t v15 = name;
    uint64_t v16 = srdelta;
    int v17 = guard;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v13.mach_msg_bits_t msgh_bits = 0x3000001513;
    *(void *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v13.uint64_t msgh_voucher_port = 0xCA000000000;
    int v10 = mach_msg2_internal(&v13, 0x200000003uLL, (void *)0x3000001513, (void *)__PAIR64__(reply_port, task), (void *)0xCA000000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    mach_port_t v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (v10)
      {
        mig_dealloc_reply_port(v13.msgh_local_port);
        return v8;
      }
      if (v13.msgh_id == 71)
      {
        mach_port_t v8 = -308;
      }
      else if (v13.msgh_id == 3332)
      {
        mach_port_t v8 = -300;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(void *)&v13.msgh_size == 36)
        {
          mach_port_t v8 = v15;
          if (!v15) {
            return v8;
          }
        }
      }
      else
      {
        mach_port_t v8 = -301;
      }
      mach_msg_destroy(&v13);
    }
  }
  return v8;
}

uint64_t thread_destruct_special_reply_port(mach_port_name_t name, int a2)
{
  switch(a2)
  {
    case 2:
      return mach_port_deallocate(mach_task_self_, name);
    case 1:
      mach_port_t v3 = mach_task_self_;
      mach_port_name_t v4 = name;
      mach_port_delta_t v5 = 0;
      return mach_port_destruct(v3, v4, v5, 0);
    case 0:
      mach_port_t v3 = mach_task_self_;
      mach_port_name_t v4 = name;
      mach_port_delta_t v5 = -1;
      return mach_port_destruct(v3, v4, v5, 0);
  }
  return 4;
}

kern_return_t vm_protect(vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  kern_return_t v10;
  uint64_t reply_port;
  kern_return_t v12;
  mach_msg_header_t v15;
  uint64_t v16;
  vm_address_t v17;
  vm_size_t v18;
  BOOLean_t v19;
  vm_prot_t v20;

  int v10 = _kernelrpc_mach_vm_protect_trap(target_task, address, size, set_maximum, new_protection);
  if (v10 == 268435459)
  {
    uint64_t v16 = 0x100000000;
    int v17 = address;
    mach_msg_header_t v18 = size;
    uint64_t v19 = set_maximum;
    mach_port_name_t v20 = new_protection;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v15.mach_msg_bits_t msgh_bits = 0x3800001513;
    *(void *)&v15.msgh_remote_port = __PAIR64__(reply_port, target_task);
    *(void *)&v15.uint64_t msgh_voucher_port = 0x12C200000000;
    uint64_t v12 = mach_msg2_internal(&v15, 0x200000003uLL, (void *)0x3800001513, (void *)__PAIR64__(reply_port, target_task), (void *)0x12C200000000, (void *)(reply_port << 32), (void *)0x2C, 0);
    int v10 = v12;
    if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
    {
      if (v12)
      {
        mig_dealloc_reply_port(v15.msgh_local_port);
        return v10;
      }
      if (v15.msgh_id == 71)
      {
        int v10 = -308;
      }
      else if (v15.msgh_id == 4902)
      {
        int v10 = -300;
        if ((v15.msgh_bits & 0x80000000) == 0 && v15.msgh_size == 36 && !v15.msgh_remote_port)
        {
          int v10 = v17;
          if (!v17) {
            return v10;
          }
        }
      }
      else
      {
        int v10 = -301;
      }
      mach_msg_destroy(&v15);
    }
  }
  return v10;
}

kern_return_t semaphore_destroy(task_t task, semaphore_t semaphore)
{
  kern_return_t v4;
  kern_return_t v5;
  mach_msg_header_t v8;
  int v9;
  semaphore_t v10;
  uint64_t v11;
  int v12;

  mach_msg_header_t v11 = 0x11000000000000;
  uint64_t v9 = 1;
  int v10 = semaphore;
  uint64_t v12 = 0;
  uint64_t reply_port = mig_get_reply_port();
  *(void *)&v8.mach_msg_bits_t msgh_bits = 0x2880001513;
  *(void *)&v8.msgh_remote_port = __PAIR64__(reply_port, task);
  *(void *)&v8.uint64_t msgh_voucher_port = 0xD5B00000000;
  mach_port_name_t v4 = mach_msg2_internal(&v8, 0x200000003uLL, (void *)0x2880001513, (void *)__PAIR64__(reply_port, task), (void *)0xD5B00000000, (void *)((reply_port << 32) | 1), (void *)0x2C, 0);
  mach_port_delta_t v5 = v4;
  if ((v4 - 268435458) > 0xE || ((1 << (v4 - 2)) & 0x4003) == 0)
  {
    if (v4)
    {
      mig_dealloc_reply_port(v8.msgh_local_port);
      return v5;
    }
    if (v8.msgh_id == 71)
    {
      mach_port_delta_t v5 = -308;
    }
    else if (v8.msgh_id == 3519)
    {
      mach_port_delta_t v5 = -300;
      if ((v8.msgh_bits & 0x80000000) == 0 && *(void *)&v8.msgh_size == 36)
      {
        mach_port_delta_t v5 = v11;
        if (!v11) {
          return v5;
        }
      }
    }
    else
    {
      mach_port_delta_t v5 = -301;
    }
    mach_msg_destroy(&v8);
  }
  return v5;
}

void ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1()
{
}

void dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace()
{
}

void dyld4::PseudoDylib::create()
{
}

{
  __assert_rtn("create", "DyldRuntimeState.cpp", 157, "callbacks && \"callbacks cannot be null\"");
}

{
  __assert_rtn("create", "DyldRuntimeState.cpp", 159, "identifier > addr && (identifier - size) < addr && \"identifier is not embedded within image?\"");
}

void dyld4::PseudoDylib::lookupSymbols()
{
  __assert_rtn("lookupSymbols", "DyldRuntimeState.cpp", 195, "names.size() == flags.size() && \"array sizes should match\"");
}

{
  __assert_rtn("lookupSymbols", "DyldRuntimeState.cpp", 194, "names.size() == addrs.size() && \"array sizes should match\"");
}

void dyld4::PseudoDylib::findUnwindSections()
{
}

{
  __assert_rtn("findUnwindSections", "DyldRuntimeState.cpp", 212, "info && \"info cannot be null\"");
}

void dyld4::RuntimeState::appLoadAddress()
{
  __assert_rtn("appLoadAddress", "DyldRuntimeState.cpp", 424, "_processPrebuiltLoaderSet != nullptr");
}

{
  __assert_rtn("appLoadAddress", "DyldRuntimeState.cpp", 425, "index < _processPrebuiltLoaderSet->loaderCount()");
}

void dyld4::RuntimeState::setAppLoadAddress()
{
  __assert_rtn("setAppLoadAddress", "DyldRuntimeState.cpp", 431, "_processPrebuiltLoaderSet != nullptr");
}

{
  __assert_rtn("setAppLoadAddress", "DyldRuntimeState.cpp", 432, "index < _processPrebuiltLoaderSet->loaderCount()");
}

void dyld4::RuntimeState::cachedDylibLoadAddress()
{
}

void dyld4::RuntimeState::setDyldLoader()
{
  __assert_rtn("setDyldLoader", "DyldRuntimeState.cpp", 674, "result.kind == Loader::ResolvedSymbol::Kind::bindToImage");
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1()
{
}

void dyld4::RuntimeState::findPrebuiltLoader()
{
}

void ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke_cold_1()
{
}

void ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166_cold_1()
{
}

void dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap()
{
  __assert_rtn("setInitialStorage", "Array.h", 54, "_usedCount == 0");
}

void dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert()
{
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>()
{
}

void dyld4::Loader::path()
{
  __assert_rtn("path", "Loader.cpp", 137, "this->magic == kMagic");
}

void dyld4::Loader::mf()
{
  __assert_rtn("mf", "Loader.cpp", 169, "this->magic == kMagic");
}

void dyld4::Loader::loadAddress()
{
  __assert_rtn("loadAddress", "Loader.cpp", 186, "this->magic == kMagic");
}

void dyld4::Loader::contains()
{
  __assert_rtn("contains", "Loader.cpp", 204, "this->magic == kMagic");
}

void dyld4::Loader::matchesPath()
{
  __assert_rtn("matchesPath", "Loader.cpp", 221, "this->magic == kMagic");
}

void dyld4::Loader::fileID()
{
  __assert_rtn("fileID", "Loader.cpp", 238, "this->magic == kMagic");
}

void dyld4::Loader::dependentCount()
{
  __assert_rtn("dependentCount", "Loader.cpp", 250, "this->magic == kMagic");
}

void dyld4::Loader::dependent()
{
  __assert_rtn("dependent", "Loader.cpp", 266, "this->magic == kMagic");
}

void dyld4::Loader::loadDependents()
{
  __assert_rtn("loadDependents", "Loader.cpp", 282, "this->magic == kMagic");
}

void dyld4::Loader::getExportsTrie()
{
  __assert_rtn("getExportsTrie", "Loader.cpp", 298, "this->magic == kMagic");
}

void dyld4::Loader::hiddenFromFlat()
{
  __assert_rtn("hiddenFromFlat", "Loader.cpp", 314, "this->magic == kMagic");
}

void dyld4::Loader::representsCachedDylibIndex()
{
  __assert_rtn("representsCachedDylibIndex", "Loader.cpp", 331, "this->magic == kMagic");
}

void dyld4::Loader::overridesDylibInCache()
{
  __assert_rtn("overridesDylibInCache", "Loader.cpp", 342, "this->magic == kMagic");
}

void dyld4::Loader::applyFixups()
{
  __assert_rtn("applyFixups", "Loader.cpp", 357, "this->magic == kMagic");
}

void dyld4::Loader::withLayout()
{
  __assert_rtn("withLayout", "Loader.cpp", 374, "this->magic == kMagic");
}

void dyld4::Loader::dyldDoesObjCFixups()
{
  __assert_rtn("dyldDoesObjCFixups", "Loader.cpp", 390, "this->magic == kMagic");
}

void dyld4::Loader::getSectionLocations()
{
  __assert_rtn("getSectionLocations", "Loader.cpp", 406, "this->magic == kMagic");
}

void dyld4::Loader::unmap()
{
  __assert_rtn("unmap", "Loader.cpp", 418, "this->magic == kMagic");
}

void dyld4::Loader::hasBeenFixedUp()
{
  __assert_rtn("hasBeenFixedUp", "Loader.cpp", 431, "this->magic == kMagic");
}

void dyld4::Loader::beginInitializers()
{
  __assert_rtn("beginInitializers", "Loader.cpp", 448, "this->magic == kMagic");
}

void dyld4::Loader::runInitializers()
{
  __assert_rtn("runInitializers", "Loader.cpp", 465, "this->magic == kMagic");
}

void dyld4::Loader::isDelayInit()
{
  __assert_rtn("isDelayInit", "Loader.cpp", 482, "this->magic == kMagic");
}

void dyld4::Loader::setDelayInit()
{
  __assert_rtn("setDelayInit", "Loader.cpp", 498, "this->magic == kMagic");
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2_cold_1()
{
  __assert_rtn("forEachBindTarget_block_invoke_2", "Loader.cpp", 2369, "targetIndex == info.targetIndex");
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3_cold_1()
{
  __assert_rtn("forEachBindTarget_block_invoke_3", "Loader.cpp", 2378, "overrideBindTargetIndex == info.targetIndex");
}

void dyld4::Loader::applyCachePatchesToOverride()
{
  __assert_rtn("applyCachePatchesToOverride", "Loader.cpp", 3280, "cachePatch->overrideOffsetOfImpl == DylibPatch::endOfPatchTable");
}

{
  __assert_rtn("applyCachePatchesToOverride", "Loader.cpp", 3196, "(patchVersion == 2) || (patchVersion == 3) || (patchVersion == 4)");
}

void dyld4::Loader::applyCachePatches()
{
  __assert_rtn("applyCachePatches", "Loader.cpp", 3398, "cachePatch->overrideOffsetOfImpl == DylibPatch::endOfPatchTable");
}

void dyld4::dyld_map_with_linking_np()
{
  __assert_rtn("fixupPage", "Loader.cpp", 1920, "segInfo != nullptr");
}

void dyld4::signPointer()
{
}

void dyld4::JustInTimeLoader::makePatchTable()
{
}

void dyld4::JustInTimeLoader::dependentAttrs()
{
}

{
  __assert_rtn("dependentAttrs", "JustInTimeLoader.cpp", 579, "depIndex < this->depCount");
}

void dyld4::JustInTimeLoader::dependent()
{
}

void dyld4::JustInTimeLoader::unmap()
{
}

void dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef()
{
  __assert_rtn("BindTargetRef", "PrebuiltLoader.cpp", 99, "(offset() == targetSymbol.targetRuntimeOffset) && \"large offset not support\"");
}

{
  __assert_rtn("BindTargetRef", "PrebuiltLoader.cpp", 189, "unpackAbsoluteValue() == absoluteValue && \"unencodeable absolute symbol value\"");
}

{
  __assert_rtn("BindTargetRef", "PrebuiltLoader.cpp", 202, "(offset() == bindTarget.runtimeOffset) && \"large offset not support\"");
}

void dyld4::PrebuiltLoader::setLoadAddress()
{
}

void dyld4::PrebuiltLoader::dependent()
{
}

void dyld4::PrebuiltLoader::recursiveMarkBeingValidated()
{
}

void dyld4::PrebuiltLoader::beginInitializers()
{
  __assert_rtn("beginInitializers", "PrebuiltLoader.cpp", 843, "ldrState == State::fixedUp");
}

void dyld4::PrebuiltLoader::serialize()
{
}

{
  __assert_rtn("serialize", "PrebuiltLoader.cpp", 1306, "p->bindTargetRefsOffset == off && \"uint16_t bindTargetRefsOffset overflow\"");
}

{
  __assert_rtn("serialize", "PrebuiltLoader.cpp", 1247, "p->fileValidationOffset == off && \"uint16_t fileValidationOffset overflow\"");
}

void dyld4::BumpAllocator::zeroFill()
{
  __assert_rtn("zeroFill", "PrebuiltLoader.cpp", 2411, "newAllocationAddr != 0");
}

{
  __assert_rtn("zeroFill", "PrebuiltLoader.cpp", 2421, "(uint8_t*)_usageEnd + reqSize <= (uint8_t*)_vmAllocationStart + _vmAllocationSize");
}

void ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_cold_2()
{
  __assert_rtn("serialize_block_invoke", "PrebuiltLoader.cpp", 1257, "p->regionsOffset == off && \"uint16_t regionsOffset overflow\"");
}

void ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51_cold_1()
{
  __assert_rtn("serialize_block_invoke", "PrebuiltLoader.cpp", 1317, "p->bindTargetRefsCount != 0 && \"bindTargetRefsCount overflow\"");
}

void dyld4::SyscallDelegate::getFileAttribute()
{
  __assert_rtn("resize", "Array.h", 77, "count <= _allocCount");
}

void dyld4::FileManager::uuidForFileSystem()
{
  __assert_rtn("operator()", "FileManager.cpp", 161, "i != _fsUUIDMap->end()");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++()
{
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert()
{
  __assert_rtn("insert", "BTree.h", 140, "size() != capacity()");
}

{
  __assert_rtn("insert", "BTree.h", 141, "index != capacity()");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion()
{
  __assert_rtn("prepareForInsertion", "BTree.h", 573, "_depth == _btree->_depth && \"prepareForInsertion only works on iterators leaf nodes\"");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild()
{
}

{
  __assert_rtn("splitChild", "BTree.h", 194, "!newChild->full() && !child->full() && \"After split the child nodes should be full\"");
}

{
  __assert_rtn("splitChild", "BTree.h", 160, "children()[index]->full() && \"The child being split must be full\"");
}

{
  __assert_rtn("splitChild", "BTree.h", 159, "size() < capacity() && \"There must be room in this node for an additional child\"");
}

void lsl::Lock::unlock()
{
  __assert_rtn("unlock", "Allocator.cpp", 110, "_runtimeState != nullptr");
}

void lsl::MemoryManager::vm_allocate_bytes(char *a1, uint64_t a2, uint64_t *a3, __int32 a4)
{
  strcpy(a1, "Could not vm_allocate 0x");
  size_t appended = lsl::appendHexToString<unsigned long long>(a1, a2);
  OUTLINED_FUNCTION_0(appended, "\n\tRequested size: 0x");
  size_t v8 = lsl::appendHexToString<unsigned long long>(a1, a3[7]);
  OUTLINED_FUNCTION_0(v8, "\n\tRequested allgnment: 0x");
  size_t v9 = lsl::appendHexToString<unsigned long long>(a1, a3[6]);
  OUTLINED_FUNCTION_0(v9, "\n\tRequested target size: 0x");
  size_t v10 = lsl::appendHexToString<unsigned long long>(a1, a3[9]);
  OUTLINED_FUNCTION_0(v10, "\n\tRequested target allgnment: 0x");
  size_t v11 = lsl::appendHexToString<unsigned long long>(a1, a3[8]);
  OUTLINED_FUNCTION_0(v11, "\n\tkern return: 0x");
  lsl::appendHexToString<int>(a1, a4, v12);
  qword_1EC3F2768 = (uint64_t)a1;
  __assert_rtn("vm_allocate_bytes", "Allocator.cpp", 342, "0 && \"vm_allocate failed\"");
}

void lsl::AllocatorLayout::init()
{
  __assert_rtn("consumeSpace", "Allocator.cpp", 426, "consumedSpace <= size");
}

void lsl::Allocator::stackAllocatorInternal()
{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 471, "buffer != nullptr");
}

{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 472, "size != 0");
}

{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 475, "0");
}

void lsl::Allocator::aligned_alloc()
{
}

{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 499, "std::popcount(alignment) == 1");
}

void lsl::Allocator::Pool::aligned_alloc_best_fit()
{
  __assert_rtn("aligned_alloc_best_fit", "Allocator.cpp", 754, "(uint64_t)result != (uint64_t)this");
}

{
  __assert_rtn("markAllocated", "Allocator.cpp", 1025, "!allocated()");
}

void lsl::Allocator::Pool::aligned_alloc()
{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 705, "(uint64_t)result != (uint64_t)this");
}

{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 674, "_lastFreeMetadata->pool() == this");
}

void lsl::Allocator::AllocationMetadata::deallocate()
{
}

void lsl::Allocator::Pool::Pool()
{
}

void lsl::Allocator::AllocationMetadata::reserve()
{
}

void lsl::Allocator::AllocationMetadata::AllocationMetadata()
{
}

void lsl::Allocator::AllocationMetadata::setPoolHint()
{
}

void dyld4::handleFromLoader()
{
  __assert_rtn("handleFromLoader", "DyldAPIs.cpp", 112, "(((uintptr_t)ldr) & 1) == 0");
}

void objc::objc_headeropt_rw_t<unsigned long>::isLoaded()
{
}

void dyld4::objc_headeropt_rw_t::isLoaded()
{
}

void dyld4::EqualTypeConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 209, "state != nullptr");
}

void dyld4::EqualMetadataConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 216, "state != nullptr");
}

void dyld4::EqualForeignConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 223, "state != nullptr");
}

void dyld4::APIs::_dyld_pseudodylib_register()
{
  __assert_rtn("_dyld_pseudodylib_register", "DyldAPIs.cpp", 3213, "result == nullptr && \"Existing pseudo-dylib, but result set anyway?\"");
}

void ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke_cold_1()
{
}

void mach_o::Header::loadCommandToDylibKind()
{
}

void dyld4::generateClassOrProtocolHashTable()
{
  __assert_rtn("generateClassOrProtocolHashTable", "PrebuiltObjC.cpp", 773, "protocolIndexIt != image.protocolIndexMap.end()");
}

void dyld4::PrebuiltObjC::generatePerImageFixups()
{
}

void dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique()
{
}

void dyld4::PrebuiltObjC::make()
{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 884, "headerInfoRO != nullptr");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 885, "headerInfoRW != nullptr");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 895, "hinfoRW->entsize == sizeof(header_info_rw<PointerType>)");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 906, "hinfoRW->entsize == sizeof(header_info_rw<PointerType>)");
}

void dyld4::PrebuiltObjC::serializeFixups()
{
}

{
  __assert_rtn("serializeFixups", "PrebuiltObjC.cpp", 1340, "fixups.protocolISAFixups.count() == fixups.binaryInfo.protocolListCount");
}

void objc::objc_headeropt_ro_t<unsigned long long>::get()
{
}

void objc::objc_headeropt_ro_t<unsigned long long>::index()
{
  __assert_rtn("index", "OptimizerObjC.h", 792, "hi >= begin && hi < end");
}

void abort_report_np(char *__format, ...)
{
  va_start(va, __format);
  vsnprintf(__str, 0x400uLL, __format, va);
  dyld4::halt(__str, 0);
}

void abort(void)
{
}

void dyld4::Atlas::Mapper::~Mapper()
{
  __assert_rtn("~Mapper", "ProcessAtlas.cpp", 493, "_flatMapping == nullptr");
}

void dyld4::Atlas::Mapper::map()
{
  __assert_rtn("map", "ProcessAtlas.cpp", 521, "((uint64_t)addr + size) <= mapping.address + mapping.size");
}

void dyld4::Atlas::SharedCache::SharedCache()
{
}

void dyld4::Atlas::ProcessSnapshot::addSharedCacheImage()
{
  __assert_rtn("addSharedCacheImage", "ProcessAtlas.cpp", 1750, "i != images.end()");
}

void dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo()
{
  __assert_rtn("emitMappedFileInfo", "ProcessAtlas.cpp", 1899, "i != _volumeUUIDs.end()");
}

{
  __assert_rtn("emitMappedFileInfo", "ProcessAtlas.cpp", 1900, "*i == file.volume()");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase()
{
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase()
{
}

{
  __assert_rtn("erase", "BTree.h", 150, "leaf()");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure()
{
  __assert_rtn("rebalanceFromErasure", "BTree.h", 651, "_indexes[0] == 0");
}

{
  __assert_rtn("rebalanceFromErasure", "BTree.h", 610, "_depth == _btree->_depth && \"rebalanceFromErasure only works on iterators to leaf nodes\"");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge()
{
}

{
  __assert_rtn("merge", "BTree.h", 247, "index < size() && \"A node must have a successor node to merge with\"");
}

void DyldSharedCache::forEachPatchableUseOfExportInImage()
{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1403, "userDylib != nullptr");
}

{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1404, "userDylibImageIndex != ~0U");
}

{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1405, "!dataRanges.empty()");
}

void objc_visitor::MethodList::numMethods()
{
  __assert_rtn("numMethods", "ObjCVisitor.cpp", 904, "methodList != nullptr");
}

void objc_visitor::MethodList::usesRelativeOffsets()
{
  __assert_rtn("usesRelativeOffsets", "ObjCVisitor.cpp", 945, "methodList != nullptr");
}

void objc_visitor::Method::getNameField()
{
}

{
  __assert_rtn("getNameField", "ObjCVisitor.cpp", 1099, "0");
}

void objc_visitor::Method::getName()
{
}

void objc_visitor::Method::getNameVMAddr()
{
}

void objc_visitor::Method::getNameSelRefVMAddr()
{
}

{
  __assert_rtn("getNameSelRefVMAddr", "ObjCVisitor.cpp", 1316, "0");
}

void objc_visitor::ProtocolList::numProtocols()
{
  __assert_rtn("numProtocols", "ObjCVisitor.cpp", 1541, "protocolList != nullptr");
}

void objc_visitor::ProtocolList::getProtocolField()
{
}

{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1557, "protocolList != nullptr");
}

{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1553, "i < this->numProtocols(objcVisitor)");
}

void objc_visitor::Visitor::forEachClass()
{
  __assert_rtn("forEachClass", "ObjCVisitor.cpp", 1797, "(classListSection.sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachCategory()
{
  __assert_rtn("forEachCategory", "ObjCVisitor.cpp", 1879, "(categoryListSection->sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachProtocol()
{
  __assert_rtn("forEachProtocol", "ObjCVisitor.cpp", 1905, "(protocolListSection->sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachSelectorReference()
{
  __assert_rtn("forEachSelectorReference", "ObjCVisitor.cpp", 1930, "(selRefsSection->sectSize % pointerSize) == 0");
}

void metadata_visitor::SwiftVisitor::getSwiftConformances()
{
  __assert_rtn("getSwiftConformances", "SwiftVisitor.cpp", 64, "(protoListSection->sectSize % 4) == 0");
}

void metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName()
{
  __assert_rtn("getClassName", "SwiftVisitor.cpp", 408, "this->kind == SwiftProtocolConformanceFlags::TypeReferenceKind::directObjCClassName");
}

void dyld3::MachOFile::entryAddrFromThreadCmd()
{
  __assert_rtn("entryAddrFromThreadCmd", "MachOFile.cpp", 1543, "cmd->cmd == LC_UNIXTHREAD");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget()
{
  __assert_rtn("unpackTarget", "MachOLayout.cpp", 1970, "this->authBind.auth == 0");
}

{
  __assert_rtn("unpackTarget", "MachOLayout.cpp", 1969, "this->authBind.bind == 0");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend()
{
  __assert_rtn("signExtendedAddend", "MachOLayout.cpp", 1976, "this->authBind.bind == 1");
}

{
  __assert_rtn("signExtendedAddend", "MachOLayout.cpp", 1977, "this->authBind.auth == 0");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::keyName()
{
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::signPointer()
{
}

{
  __assert_rtn("signPointer", "MachOLayout.cpp", 2028, "this->authBind.auth == 1");
}

void mach_o::ChainedFixupPointerOnDisk::Cache64e::high8()
{
  __assert_rtn("high8", "MachOLayout.cpp", 2059, "this->regular.auth == 0");
}

void mach_o::ChainedFixupPointerOnDisk::Cache64e::signPointer()
{
}

{
  __assert_rtn("signPointer", "MachOLayout.cpp", 2098, "this->auth.auth == 1");
}

void mach_o::ChainedFixupPointerOnDisk::isRebase()
{
}

void mach_o::ChainedFixupPointerOnDisk::isBind()
{
}

void mach_o::ChainedFixupPointerOnDisk::strideSize()
{
}

void dyld3::MachOAnalyzer::chainedPointerFormat()
{
  __assert_rtn("chainedPointerFormat", "MachOAnalyzer.cpp", 3257, "this->cputype == CPU_TYPE_ARM64 && (this->maskedCpuSubtype() == CPU_SUBTYPE_ARM64E) && \"chainedPointerFormat() called on non-chained binary\"");
}

void ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke_cold_1()
{
}

void ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke_cold_2()
{
}

void ___ZNK5dyld313MachOAnalyzer15withChainStartsER11DiagnosticsyU13block_pointerFvPK28dyld_chained_starts_in_imageE_block_invoke_cold_3()
{
}

void dyld3::MachOAnalyzer::forEachRebase_Opcodes()
{
  __assert_rtn("forEachRebase_Opcodes", "MachOAnalyzer.cpp", 5226, "leInfo.dyldInfo != nullptr");
}

void mach_o::Platform::Platform()
{
  __assert_rtn("Platform", "Platform.cpp", 745, "p->value != 0 && \"PlatformInfo value uninitialized, this might be a problem with C++ static initializers order\"");
}

void _enlarge_cold_1(int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Failed to allocate memory for buffer";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_unfair_lock_recursive_abort(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_unfair_lock";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_unfair_lock_unowned_abort(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Unlock of an os_unfair_lock not owned by current thread";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_unfair_lock_corruption_abort(unsigned int a1)
{
  if (a1 - 512 <= 0x3FE00)
  {
    qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_unfair_lock is corrupt, or owner thread exited without unlocking";
    qword_1EC3F2780 = a1;
    __break(1u);
  }
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_unfair_lock is corrupt";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_once_gate_recursive_abort(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_once_t";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_once_gate_unowned_abort(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Unlock of an os_once_t not owned by current thread";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_once_gate_corruption_abort(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_once_t is corrupt";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void os_unfair_lock_assert_owner_cold_1(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Assertion failed: Lock unexpectedly not owned by current thread";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void os_unfair_lock_assert_not_owner_cold_1(unsigned int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Assertion failed: Lock unexpectedly owned by current thread";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_alloc_cold_1(uint64_t a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Requested allocation size is invalid";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void _os_semaphore_dispose_cold_1(int a1)
{
  qword_1EC3F2750 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Destroying semaphore failed";
  qword_1EC3F2780 = a1;
  __break(1u);
}

void abort_with_reason(void *a1, void *a2, void *a3, unint64_t a4)
{
}

void abort_with_payload_wrapper_internal(void *a1, void *a2, void *a3, void *a4, void *a5, unint64_t a6)
{
  sigset_t v15 = 32;
  sigprocmask(2, &v15, 0);
  __abort_with_payload(a1, a2, a3, a4, a5, (void *)a6, v12, v13);
  uint64_t v14 = getpid();
  terminate_with_payload(v14, a1, a2, a3, a4, a5, a6 | 0x200);
  __break(1u);
}

void abort_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, unint64_t a6)
{
}