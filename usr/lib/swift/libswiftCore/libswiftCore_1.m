__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(unint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int8x8_t v6;
  uint8x8_t v7;
  BOOL v8;
  __objc2_class **result;
  unint64_t v10;
  unint64_t v11;
  __objc2_class **v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int64_t v24;
  uint64_t v25;
  __objc2_class **v26;
  unint64_t *v27;
  __objc2_class **v28;
  int64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  const void *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  __objc2_class *v41;

  if (a2 < 0) {
    goto LABEL_71;
  }
  v4 = 0;
  v5 = 0;
  while (a2 != v5)
  {
    v6 = (int8x8_t)a1[v5++];
    v7 = (uint8x8_t)vcnt_s8(v6);
    v7.i16[0] = vaddlv_u8(v7);
    v8 = __OFADD__(v4, v7.u32[0]);
    v4 += v7.u32[0];
    if (v8)
    {
      __break(1u);
      break;
    }
  }
  if (v4)
  {
    result = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v4, 0);
    if (a2)
    {
      if (v4 < 0) {
        goto LABEL_71;
      }
      v10 = *a1;
    }
    else
    {
      if (v4 < 0) {
        goto LABEL_71;
      }
      v10 = 0;
    }
    v13 = 0;
    v14 = 0;
    v12 = result + 4;
    v11 = ((unint64_t)result[3] >> 1) - v4;
    while (1)
    {
      if (v14 == v4) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
      }
      if (v10)
      {
        v15 = __clz(__rbit64(v10));
        v10 &= v10 - 1;
        v16 = v15 | (v13 << 6);
      }
      else
      {
        v8 = __OFADD__(v13++, 1);
        if (v8) {
          goto LABEL_73;
        }
        if (v13 >= a2) {
          goto LABEL_75;
        }
        v17 = a1[v13];
        if (!v17)
        {
          v18 = v13 + 1;
          if (v13 + 1 >= a2) {
            goto LABEL_75;
          }
          v17 = a1[v18];
          if (!v17)
          {
            while (1)
            {
              v13 = v18 + 1;
              if (__OFADD__(v18, 1)) {
                break;
              }
              if (v13 >= a2) {
                goto LABEL_75;
              }
              v17 = a1[v13];
              ++v18;
              if (v17) {
                goto LABEL_29;
              }
            }
            __break(1u);
LABEL_73:
            __break(1u);
            goto LABEL_74;
          }
          ++v13;
        }
LABEL_29:
        v10 = (v17 - 1) & v17;
        v16 = __clz(__rbit64(v17)) + (v13 << 6);
      }
      ++v14;
      *v12++ = (__objc2_class *)v16;
      if (v14 == v4) {
        goto LABEL_34;
      }
    }
  }
  result = &_swiftEmptyArrayStorage;
  v11 = (unint64_t)qword_1EC07DB68 >> 1;
  v12 = &_swiftEmptySetSingleton;
  if (!a2)
  {
    v10 = 0;
    v13 = 0;
LABEL_34:
    if (!v10) {
      goto LABEL_39;
    }
    goto LABEL_35;
  }
  v13 = 0;
  v10 = *a1;
  if (!*a1) {
    goto LABEL_39;
  }
LABEL_35:
  v19 = __clz(__rbit64(v10));
  v10 &= v10 - 1;
  v20 = v19 | (v13 << 6);
  if (v11)
  {
LABEL_36:
    v8 = __OFSUB__(v11--, 1);
    if (!v8) {
      goto LABEL_61;
    }
LABEL_67:
    __break(1u);
    goto LABEL_68;
  }
  while (1)
  {
    v23 = (unint64_t)result[3];
    if ((uint64_t)((v23 >> 1) + 0x4000000000000000) < 0) {
      goto LABEL_70;
    }
    v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
    if (v24 <= 1) {
      v25 = 1;
    }
    else {
      v25 = v24;
    }
    v26 = result;
    v27 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
    v28 = (__objc2_class **)swift_allocObject(v27, 8 * v25 + 32, 7uLL);
    v29 = _swift_stdlib_malloc_size(v28);
    v31 = v29 - 32;
    v30 = v29 < 32;
    v32 = v29 - 25;
    v33 = (uint64_t)v26;
    if (v30) {
      v31 = v32;
    }
    v34 = v31 >> 3;
    v28[2] = (__objc2_class *)v25;
    v28[3] = (__objc2_class *)(2 * (v31 >> 3));
    v35 = (unint64_t)(v28 + 4);
    v36 = (unint64_t)v26[3] >> 1;
    if (v26[2])
    {
      v37 = v26 + 4;
      if (v28 != v26 || v35 >= (unint64_t)v37 + 8 * v36)
      {
        memmove(v28 + 4, v37, 8 * v36);
        v33 = (uint64_t)v26;
      }
      *(void *)(v33 + 16) = 0;
    }
    v12 = (__objc2_class **)(v35 + 8 * v36);
    v38 = (v34 & 0x7FFFFFFFFFFFFFFFLL) - v36;
    swift_release(v33);
    result = v28;
    v8 = __OFSUB__(v38, 1);
    v11 = v38 - 1;
    if (v8) {
      goto LABEL_67;
    }
LABEL_61:
    *v12++ = (__objc2_class *)v20;
    if (v10) {
      goto LABEL_35;
    }
LABEL_39:
    v8 = __OFADD__(v13++, 1);
    if (v8) {
      goto LABEL_69;
    }
    if (v13 >= a2) {
      break;
    }
    v21 = a1[v13];
    if (!v21)
    {
      v22 = v13 + 1;
      if (v13 + 1 >= a2) {
        break;
      }
      v21 = a1[v22];
      if (!v21)
      {
        while (1)
        {
          v13 = v22 + 1;
          if (__OFADD__(v22, 1)) {
            break;
          }
          if (v13 >= a2) {
            goto LABEL_63;
          }
          v21 = a1[v13];
          ++v22;
          if (v21) {
            goto LABEL_48;
          }
        }
LABEL_68:
        __break(1u);
LABEL_69:
        __break(1u);
LABEL_70:
        __break(1u);
LABEL_71:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      }
      ++v13;
    }
LABEL_48:
    v10 = (v21 - 1) & v21;
    v20 = __clz(__rbit64(v21)) + (v13 << 6);
    if (v11) {
      goto LABEL_36;
    }
  }
LABEL_63:
  v39 = (unint64_t)result[3];
  if (v39 >= 2)
  {
    v40 = v39 >> 1;
    v8 = __OFSUB__(v40, v11);
    v41 = (__objc2_class *)(v40 - v11);
    if (v8)
    {
LABEL_74:
      __break(1u);
LABEL_75:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x429uLL, 0);
    }
    result[2] = v41;
  }
  return result;
}

__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(unint64_t a1)
{
  if (a1)
  {
    unint64_t v1 = a1;
    uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
    v2.i16[0] = vaddlv_u8(v2);
    uint64_t v3 = v2.u32[0];
    v4 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v2.u32[0], 0);
    v5 = v4 + 4;
    unint64_t v6 = (unint64_t)v4[3];
    unint64_t v7 = (v6 >> 1) - v3;
    unint64_t v8 = (v6 >> 1) | 0x8000000000000000;
    do
    {
      if (!v1) {
        goto LABEL_35;
      }
      if (!v8)
      {
        __break(1u);
        goto LABEL_32;
      }
      unint64_t v9 = (v1 - 1) & v1;
      *v5++ = __clz(__rbit64(v1));
      --v8;
      unint64_t v1 = v9;
      --v3;
    }
    while (v3);
    if (v9)
    {
      while (1)
      {
        if (!v7)
        {
          unint64_t v10 = (unint64_t)v4[3];
          if ((uint64_t)((v10 >> 1) + 0x4000000000000000) < 0) {
            goto LABEL_33;
          }
          int64_t v11 = v10 & 0xFFFFFFFFFFFFFFFELL;
          if (v11 <= 1) {
            uint64_t v12 = 1;
          }
          else {
            uint64_t v12 = v11;
          }
          v13 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
          v14 = (__objc2_class **)swift_allocObject(v13, 8 * v12 + 32, 7uLL);
          int64_t v15 = _swift_stdlib_malloc_size(v14);
          uint64_t v16 = v15 - 32;
          if (v15 < 32) {
            uint64_t v16 = v15 - 25;
          }
          uint64_t v17 = v16 >> 3;
          v14[2] = (__objc2_class *)v12;
          v14[3] = (__objc2_class *)(2 * (v16 >> 3));
          unint64_t v18 = (unint64_t)(v14 + 4);
          unint64_t v19 = (unint64_t)v4[3] >> 1;
          if (v4[2])
          {
            if (v14 != v4 || v18 >= (unint64_t)&v4[v19 + 4]) {
              memmove(v14 + 4, v4 + 4, 8 * v19);
            }
            v4[2] = 0;
          }
          v5 = (void *)(v18 + 8 * v19);
          unint64_t v7 = (v17 & 0x7FFFFFFFFFFFFFFFLL) - v19;
          swift_release((uint64_t)v4);
          v4 = v14;
        }
        BOOL v21 = __OFSUB__(v7--, 1);
        if (v21) {
          break;
        }
        *v5++ = __clz(__rbit64(v9));
        v9 &= v9 - 1;
        if (!v9) {
          goto LABEL_27;
        }
      }
LABEL_32:
      __break(1u);
LABEL_33:
      __break(1u);
LABEL_34:
      __break(1u);
LABEL_35:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x429uLL, 0);
    }
  }
  else
  {
    v4 = &_swiftEmptyArrayStorage;
    unint64_t v7 = (unint64_t)qword_1EC07DB68 >> 1;
  }
LABEL_27:
  unint64_t v22 = (unint64_t)v4[3];
  if (v22 >= 2)
  {
    unint64_t v23 = v22 >> 1;
    BOOL v21 = __OFSUB__(v23, v7);
    v24 = (__objc2_class *)(v23 - v7);
    if (v21) {
      goto LABEL_34;
    }
    v4[2] = v24;
  }
  return v4;
}

void *specialized _copySequenceToContiguousArray<A>(_:)(void *result, uint64_t a2)
{
  uint8x8_t v2 = result;
  unint64_t v3 = 0;
  int64_t v4 = 0;
  if (a2 + 1 < 64) {
    uint64_t v5 = ~(-1 << (a2 + 1));
  }
  else {
    uint64_t v5 = -1;
  }
  unint64_t v6 = *result & v5;
  unint64_t v7 = &_swiftEmptyArrayStorage;
  unint64_t v8 = &_swiftEmptySetSingleton;
  int64_t v9 = (unint64_t)(a2 + 64) >> 6;
  int64_t v30 = v9;
  if (!v6) {
    goto LABEL_9;
  }
LABEL_5:
  unint64_t v10 = __clz(__rbit64(v6));
  v6 &= v6 - 1;
  unint64_t v11 = v10 | (v4 << 6);
  if (v3)
  {
LABEL_6:
    BOOL v12 = __OFSUB__(v3--, 1);
    if (!v12) {
      goto LABEL_31;
    }
LABEL_37:
    __break(1u);
LABEL_38:
    __break(1u);
LABEL_39:
    __break(1u);
  }
  else
  {
    while (1)
    {
      unint64_t v15 = (unint64_t)v7[3];
      if ((uint64_t)((v15 >> 1) + 0x4000000000000000) < 0) {
        break;
      }
      int64_t v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
      if (v16 <= 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = v16;
      }
      unint64_t v18 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_HashTable.Bucket>();
      unint64_t v19 = (__objc2_class **)swift_allocObject(v18, 8 * v17 + 32, 7uLL);
      int64_t v20 = _swift_stdlib_malloc_size(v19);
      uint64_t v21 = v20 - 32;
      if (v20 < 32) {
        uint64_t v21 = v20 - 25;
      }
      uint64_t v22 = v21 >> 3;
      v19[2] = (__objc2_class *)v17;
      v19[3] = (__objc2_class *)(2 * (v21 >> 3));
      unint64_t v23 = (unint64_t)(v19 + 4);
      unint64_t v24 = (unint64_t)v7[3] >> 1;
      if (v7[2])
      {
        v25 = v7 + 4;
        if (v19 != v7 || v23 >= (unint64_t)v25 + 8 * v24) {
          memmove(v19 + 4, v25, 8 * v24);
        }
        v7[2] = 0;
      }
      unint64_t v8 = (__objc2_class **)(v23 + 8 * v24);
      unint64_t v26 = (v22 & 0x7FFFFFFFFFFFFFFFLL) - v24;
      result = (void *)swift_release((uint64_t)v7);
      unint64_t v7 = v19;
      int64_t v9 = v30;
      BOOL v12 = __OFSUB__(v26, 1);
      unint64_t v3 = v26 - 1;
      if (v12) {
        goto LABEL_37;
      }
LABEL_31:
      *v8++ = (__objc2_class *)v11;
      if (v6) {
        goto LABEL_5;
      }
LABEL_9:
      BOOL v12 = __OFADD__(v4++, 1);
      if (v12) {
        goto LABEL_39;
      }
      if (v4 >= v9)
      {
LABEL_33:
        unint64_t v27 = (unint64_t)v7[3];
        if (v27 >= 2)
        {
          unint64_t v28 = v27 >> 1;
          BOOL v12 = __OFSUB__(v28, v3);
          v29 = (__objc2_class *)(v28 - v3);
          if (v12) {
            goto LABEL_41;
          }
          v7[2] = v29;
        }
        return v7;
      }
      unint64_t v13 = v2[v4];
      if (!v13)
      {
        int64_t v14 = v4 + 1;
        if (v4 + 1 >= v9) {
          goto LABEL_33;
        }
        unint64_t v13 = v2[v14];
        if (!v13)
        {
          while (1)
          {
            int64_t v4 = v14 + 1;
            if (__OFADD__(v14, 1)) {
              goto LABEL_38;
            }
            if (v4 >= v9) {
              goto LABEL_33;
            }
            unint64_t v13 = v2[v4];
            ++v14;
            if (v13) {
              goto LABEL_18;
            }
          }
        }
        ++v4;
      }
LABEL_18:
      unint64_t v6 = (v13 - 1) & v13;
      unint64_t v11 = __clz(__rbit64(v13)) + (v4 << 6);
      if (v3) {
        goto LABEL_6;
      }
    }
  }
  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(char *a1, char *a2)
{
  if (a1)
  {
    uint8x8_t v2 = a1;
    size_t v5 = 0;
    unint64_t v6 = &_swiftEmptyArrayStorage;
    unint64_t v3 = &_swiftEmptySetSingleton;
    if (a2) {
      goto LABEL_6;
    }
  }
  else
  {
    size_t v5 = 0;
    unint64_t v6 = &_swiftEmptyArrayStorage;
    if (!a2) {
      goto LABEL_7;
    }
    unint64_t v3 = &_swiftEmptySetSingleton;
    uint8x8_t v2 = 0;
  }
  while (1)
  {
    do
    {
      if (!v2 || !a2) {
        goto LABEL_35;
      }
      if (v2 >= a2) {
        goto LABEL_33;
      }
      char v13 = *v2++;
      char v12 = v13;
      if (v5)
      {
        int64_t v14 = v6;
        BOOL v9 = __OFSUB__(v5--, 1);
        if (v9) {
          goto LABEL_32;
        }
      }
      else
      {
        unint64_t v15 = (unint64_t)v6[3];
        if ((uint64_t)((v15 >> 1) + 0x4000000000000000) < 0)
        {
          __break(1u);
LABEL_35:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
        }
        int64_t v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
        if (v16 <= 1) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = v16;
        }
        unint64_t v18 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
        int64_t v14 = (__objc2_class **)swift_allocObject(v18, v17 + 32, 7uLL);
        size_t v19 = 2 * _swift_stdlib_malloc_size(v14) - 64;
        v14[2] = (__objc2_class *)v17;
        v14[3] = (__objc2_class *)v19;
        int64_t v20 = (char *)(v14 + 4);
        size_t v21 = (unint64_t)v6[3] >> 1;
        unint64_t v3 = (__objc2_class **)((char *)v14 + v21 + 32);
        size_t v22 = (v19 >> 1) - v21;
        if (v6[2])
        {
          if (v14 != v6 || v20 >= (char *)v6 + v21 + 32) {
            memmove(v20, v6 + 4, v21);
          }
          v6[2] = 0;
        }
        swift_release((uint64_t)v6);
        BOOL v9 = __OFSUB__(v22, 1);
        size_t v5 = v22 - 1;
        if (v9)
        {
LABEL_32:
          __break(1u);
LABEL_33:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
        }
      }
      *(unsigned char *)unint64_t v3 = v12;
      unint64_t v3 = (__objc2_class **)((char *)v3 + 1);
      unint64_t v6 = v14;
LABEL_6:
      ;
    }
    while (a2 != v2);
LABEL_7:
    unint64_t v7 = (unint64_t)v6[3];
    if (v7 < 2) {
      return v6;
    }
    unint64_t v8 = v7 >> 1;
    BOOL v9 = __OFSUB__(v8, v5);
    unint64_t v10 = (__objc2_class *)(v8 - v5);
    if (!v9) {
      break;
    }
    __break(1u);
  }
  v6[2] = v10;
  return v6;
}

__objc2_class **_copySequenceToContiguousArray<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v7 = *(AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  v73 = (char *)&v68 - v8;
  unint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v69 = (uint64_t)*(v11 - 1);
  v70 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  v78 = (char *)&v68 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  int64_t v16 = (char *)&v68 - v15;
  uint64_t v17 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v14);
  size_t v19 = (char *)&v68 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v77 = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v68 = *((void *)v77 - 1);
  MEMORY[0x1F4188790](v77);
  uint64_t AssociatedConformanceWitness = a3;
  v83 = (char *)&v68 - v20;
  uint64_t v21 = a1;
  uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a2, a3);
  uint64_t v79 = v7;
  if (v22 <= 0)
  {
    uint64_t v31 = *(unsigned __int8 *)(v7 + 80);
    uint64_t v71 = ~v31;
    uint64_t v72 = v31;
    uint64_t v74 = (v31 + 32) & ~v31;
    unint64_t v26 = &_swiftEmptyArrayStorage;
  }
  else
  {
    unint64_t v23 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    uint64_t v24 = *(void *)(v7 + 72);
    uint64_t v25 = *(unsigned __int8 *)(v7 + 80);
    unint64_t v26 = (__objc2_class **)swift_allocObject((unint64_t *)v23, ((v25 + *((unsigned int *)v23 + 12)) & ~v25) + v24 * v22, v25 | *((unsigned __int16 *)v23 + 26));
    size_t v27 = _swift_stdlib_malloc_size(v26);
    if (!v24) {
      goto LABEL_47;
    }
    uint64_t v71 = ~v25;
    uint64_t v72 = v25;
    uint64_t v74 = (v25 + 32) & ~v25;
    if (v27 - v74 == 0x8000000000000000 && v24 == -1) {
LABEL_49:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    uint64_t v29 = (uint64_t)(v27 - v74) / v24;
    swift_retain((atomic_ullong *)v26);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    v26[2] = (__objc2_class *)v22;
    v26[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v29));
    swift_release((uint64_t)v26);
  }
  unint64_t v32 = (unint64_t)v26[3];
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v19, v21, a2);
  uint64_t v33 = AssociatedConformanceWitness;
  (*(void (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 32))(a2, AssociatedConformanceWitness);
  if (v22 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v34 = (char *)v26 + v74;
  unint64_t v35 = v32 >> 1;
  uint64_t v36 = a2;
  v37 = v77;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v33, v36, (uint64_t)v77, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v80 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v81 = AssociatedConformanceWitness + 16;
  if (v22)
  {
    v38 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v79 + 48);
    v35 -= v22;
    while (1)
    {
      v80(v37, AssociatedConformanceWitness);
      if ((*v38)(v16, 1, AssociatedTypeWitness) == 1) {
        break;
      }
      uint64_t v39 = v79;
      (*(void (**)(char *, char *, uint64_t *))(v79 + 32))(v34, v16, AssociatedTypeWitness);
      v34 += *(void *)(v39 + 72);
      if (!--v22) {
        goto LABEL_14;
      }
    }
LABEL_52:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x429uLL, 0);
  }
LABEL_14:
  v40 = v78;
  v80(v37, AssociatedConformanceWitness);
  v41 = v40;
  uint64_t v42 = v79;
  v75 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v79 + 48);
  uint64_t v76 = v79 + 48;
  if (v75(v40, 1, AssociatedTypeWitness) != 1)
  {
    v44 = *(void (**)(char *, char *, uint64_t *))(v42 + 32);
    v45 = v73;
    while (1)
    {
      v44(v45, v41, AssociatedTypeWitness);
      if (v35)
      {
        v43 = v26;
        BOOL v46 = __OFSUB__(v35--, 1);
        if (v46) {
          goto LABEL_46;
        }
      }
      else
      {
        unint64_t v47 = (unint64_t)v26[3];
        if ((uint64_t)((v47 >> 1) + 0x4000000000000000) < 0)
        {
          __break(1u);
          goto LABEL_49;
        }
        int64_t v48 = v47 & 0xFFFFFFFFFFFFFFFELL;
        if (v48 <= 1) {
          uint64_t v49 = 1;
        }
        else {
          uint64_t v49 = v48;
        }
        v50 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v51 = *(void *)(v42 + 72);
        v43 = (__objc2_class **)swift_allocObject((unint64_t *)v50, ((v72 + *((unsigned int *)v50 + 12)) & v71) + v51 * v49, v72 | *((unsigned __int16 *)v50 + 26));
        size_t v52 = _swift_stdlib_malloc_size(v43);
        if (!v51) {
          goto LABEL_47;
        }
        uint64_t v53 = v74;
        if (v52 - v74 == 0x8000000000000000 && v51 == -1) {
          goto LABEL_49;
        }
        uint64_t v55 = (uint64_t)(v52 - v74) / v51;
        swift_retain((atomic_ullong *)v43);
        BOOL v56 = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        v43[2] = (__objc2_class *)v49;
        v43[3] = (__objc2_class *)(v56 | (unint64_t)(2 * v55));
        swift_release((uint64_t)v43);
        v57 = (char *)v43 + v53;
        uint64_t v58 = (unint64_t)v26[3] >> 1;
        uint64_t v59 = v58 * v51;
        v60 = v43[3];
        if (v26[2])
        {
          v61 = (char *)v26 + v53;
          if (v43 < v26 || v57 >= (char *)v26 + v53 + v59)
          {
            swift_arrayInitWithTakeFrontToBack((char *)v43 + v53, v61, v58, (unint64_t *)AssociatedTypeWitness);
          }
          else if (v43 != v26)
          {
            swift_arrayInitWithTakeBackToFront((char *)v43 + v53, v61, v58, (uint64_t)AssociatedTypeWitness);
          }
          v26[2] = 0;
        }
        v34 = &v57[v59];
        uint64_t v63 = ((unint64_t)v60 >> 1) - v58;
        swift_release((uint64_t)v26);
        uint64_t v42 = v79;
        v45 = v73;
        BOOL v46 = __OFSUB__(v63, 1);
        unint64_t v35 = v63 - 1;
        if (v46)
        {
LABEL_46:
          __break(1u);
LABEL_47:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
        }
      }
      v44(v34, v45, AssociatedTypeWitness);
      v34 += *(void *)(v42 + 72);
      v80(v77, AssociatedConformanceWitness);
      v41 = v78;
      unint64_t v26 = v43;
      if (v75(v78, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_42;
      }
    }
  }
  v43 = v26;
LABEL_42:
  (*(void (**)(char *, const char *))(v68 + 8))(v83, v77);
  (*(void (**)(char *, Class *))(v69 + 8))(v41, v70);
  unint64_t v64 = (unint64_t)v43[3];
  if (v64 >= 2)
  {
    unint64_t v65 = v64 >> 1;
    BOOL v46 = __OFSUB__(v65, v35);
    v66 = (__objc2_class *)(v65 - v35);
    if (v46)
    {
      __break(1u);
      goto LABEL_52;
    }
    v43[2] = v66;
  }
  return v43;
}

__objc2_class **_UnsafePartiallyInitializedContiguousArrayBuffer.init(initialCapacity:)(uint64_t a1, uint64_t *a2)
{
  if (a1 <= 0) {
    return &_swiftEmptyArrayStorage;
  }
  int64_t v4 = getContiguousArrayStorageType<A>(for:)((uint64_t)a2, a2);
  uint64_t v5 = *(void *)(*(a2 - 1) + 72);
  uint64_t v6 = *(unsigned __int8 *)(*(a2 - 1) + 80);
  uint64_t v7 = swift_allocObject((unint64_t *)v4, ((v6 + *((unsigned int *)v4 + 12)) & ~v6) + v5 * a1, v6 | *((unsigned __int16 *)v4 + 26));
  size_t v8 = _swift_stdlib_malloc_size(v7);
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  int64_t v9 = v8 - ((v6 + 32) & ~v6);
  if (v9 == 0x8000000000000000 && v5 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  }
  uint64_t v11 = v9 / v5;
  swift_retain(v7);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  v7[2] = a1;
  v7[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v11);
  swift_release((uint64_t)v7);
  return (__objc2_class **)v7;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.addWithExistingCapacity(_:)(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(v2 + 16);
  BOOL v4 = __OFSUB__(v3, 1);
  uint64_t v5 = v3 - 1;
  if (v4)
  {
    __break(1u);
  }
  else
  {
    *(void *)(v2 + 16) = v5;
    uint64_t v6 = *(void *)(v2 + 8);
    uint64_t v7 = *(void *)(*(void *)(a2 + 16) - 8) + 16;
    result = (*(uint64_t (**)(uint64_t, uint64_t))v7)(v6, result);
    *(void *)(v2 + 8) = v6 + *(void *)(v7 + 56);
  }
  return result;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.add(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = v2[2];
  if (!v5)
  {
    uint64_t v6 = *v2;
    unint64_t v7 = *(void *)(*v2 + 24);
    if ((uint64_t)((v7 >> 1) + 0x4000000000000000) < 0)
    {
LABEL_17:
      __break(1u);
      goto LABEL_18;
    }
    int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    uint64_t v10 = *(uint64_t **)(a2 + 16);
    uint64_t v11 = getContiguousArrayStorageType<A>(for:)((uint64_t)v10, v10);
    uint64_t v12 = *(void *)(*(v10 - 1) + 72);
    uint64_t v13 = *(unsigned __int8 *)(*(v10 - 1) + 80);
    uint64_t v14 = swift_allocObject((unint64_t *)v11, ((v13 + *((unsigned int *)v11 + 12)) & ~v13) + v12 * v9, v13 | *((unsigned __int16 *)v11 + 26));
    size_t v15 = _swift_stdlib_malloc_size(v14);
    if (!v12) {
LABEL_18:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    uint64_t v16 = (v13 + 32) & ~v13;
    if (v15 - v16 == 0x8000000000000000 && v12 == -1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    }
    uint64_t v18 = (uint64_t)(v15 - v16) / v12;
    swift_retain(v14);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
    v14[2] = v9;
    v14[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v18);
    swift_release((uint64_t)v14);
    uint64_t v20 = *(void *)(v6 + 24) >> 1;
    uint64_t v5 = (v14[3] >> 1) - v20;
    v2[1] = (uint64_t)v14 + v16 + v20 * v12;
    v2[2] = v5;
    if (*(void *)(v6 + 16))
    {
      UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v6 + v16), v20, (char *)v14 + v16, (unint64_t *)v10);
      *(void *)(v6 + 16) = 0;
    }
    swift_release(v6);
    *uint64_t v2 = (uint64_t)v14;
  }
  if (__OFSUB__(v5, 1))
  {
    __break(1u);
    goto LABEL_17;
  }
  v2[2] = v5 - 1;
  uint64_t v21 = v2[1];
  uint64_t v22 = *(void *)(*(void *)(a2 + 16) - 8) + 16;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))v22)(v21, a1);
  v2[1] = v21 + *(void *)(v22 + 56);
  return result;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.finish()()
{
  uint64_t result = *v0;
  unint64_t v2 = *(void *)(*v0 + 24);
  if (v2 < 2) {
    goto LABEL_4;
  }
  unint64_t v3 = v2 >> 1;
  uint64_t v4 = v0[2];
  BOOL v5 = __OFSUB__(v3, v4);
  uint64_t v6 = v3 - v4;
  if (!v5)
  {
    *(void *)(result + 16) = v6;
LABEL_4:
    void *v0 = &_swiftEmptyArrayStorage;
    v0[2] = 0;
    return result;
  }
  __break(1u);
  return result;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.result.setter(uint64_t a1)
{
  uint64_t result = swift_release(*v1);
  *unint64_t v1 = a1;
  return result;
}

uint64_t (*_UnsafePartiallyInitializedContiguousArrayBuffer.result.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.p.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.p.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*_UnsafePartiallyInitializedContiguousArrayBuffer.p.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*_UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.finishWithOriginalCount()()
{
  uint64_t result = *v0;
  uint64_t *v0 = (uint64_t)&_swiftEmptyArrayStorage;
  v0[2] = 0;
  return result;
}

uint64_t String.init(cString:)(uint8x16_t *a1)
{
  size_t v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  int64_t v3 = v2;
  int64_t v4 = validateUTF8(_:)(a1->i64, v2);
  if (v6)
  {
    return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  }
  else
  {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  }
}

{
  size_t v2;
  int64_t v3;
  int64_t v4;
  int64_t v5;
  char v6;
  uint64_t vars8;

  size_t v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  int64_t v3 = v2;
  int64_t v4 = validateUTF8(_:)(a1->i64, v2);
  if (v6)
  {
    return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  }
  else
  {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  }
}

uint64_t static String._fromUTF8Repairing(_:)(uint8x16_t *a1, uint64_t a2)
{
  int64_t v4 = validateUTF8(_:)(a1->i64, a2);
  if (v6) {
    return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, a2, v4, v5);
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v4 & 1);
  }
}

uint64_t *_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n(uint64_t *result, uint64_t a2)
{
  if (result)
  {
    if (a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    int64_t v3 = (uint8x16_t *)result;
    int64_t v4 = validateUTF8(_:)(result, a2);
    if (v6) {
      return (uint64_t *)repairUTF8(_:firstKnownBrokenRange:)(v3->i8, a2, v4, v5);
    }
    else {
      return (uint64_t *)specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, a2, v4 & 1);
    }
  }
  return result;
}

uint64_t _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys4Int8VsAD_pqd_1_Isgyrzr_SRys5UInt8VGqd_1_sAD_pAIRszAGRsd__sAD_pRsd_0_Ri_d_1_r_1_lIetMgyrzo_Tpq5Sb_Tgq507_sSRys4f5VGxs5E35_pIgyrzo_ACxsAD_pIegyrzr_lTRSb_TGq5SRyAGGSbsAD_pIgyrzo_Tf1cn_n(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr))
{
  if (a1)
  {
    if (a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    a3(&var2);
    if (!v3) {
      char v4 = var2;
    }
  }
  else
  {
    ((void (*)(uint64_t *__return_ptr, void, void))a3)((uint64_t *)((char *)&var2 + 1), 0, 0);
    if (!v3) {
      char v4 = BYTE1(var2);
    }
  }
  return v4 & 1;
}

uint64_t _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys4Int8VsAD_pqd_1_Isgyrzr_SRys5UInt8VGqd_1_sAD_pAIRszAGRsd__sAD_pRsd_0_Ri_d_1_r_1_lIetMgyrzo_Tpq5(uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    return a1(0, 0, &v5);
  }
  if (a4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return a1(a3, a4, &v5);
}

uint64_t _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5(uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return a1(0, 0, &v13);
  }
  uint64_t v6 = *(void *)(a6 - 8);
  if ((*(unsigned char *)(v6 + 80) & a3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "baseAddress must be a properly aligned pointer for types Element and T", 70, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x7E7uLL, 0);
  }
  uint64_t v7 = *(void *)(v6 + 72);
  uint64_t v8 = *(void *)(*(void *)(a5 - 8) + 72);
  if (v7 != v8)
  {
    uint64_t v9 = a4 * v8;
    if ((unsigned __int128)(a4 * (__int128)v8) >> 64 == (a4 * v8) >> 63)
    {
      if (v7)
      {
        if (v9 == 0x8000000000000000 && v7 == -1) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
        }
        if (v8 >= v7)
        {
          if (v8 != 0x8000000000000000 || v7 != -1)
          {
            uint64_t v11 = v8 % v7;
            goto LABEL_19;
          }
        }
        else
        {
          if (!v8) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x390EuLL, 0);
          }
          if (v7 != 0x8000000000000000 || v8 != -1)
          {
            uint64_t v11 = v7 % v8;
LABEL_19:
            if (v11) {
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Buffer must contain a whole number of Element instances", 55, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x7F1uLL, 0);
            }
            a4 = v9 / v7;
            goto LABEL_21;
          }
        }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3913uLL, 0);
      }
    }
    else
    {
      __break(1u);
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
LABEL_21:
  if (a4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return a1(a3, a4, &v13);
}

BOOL static Int8.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t specialized String.withCString<A>(_:)(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t (*a4)(__objc2_class **, uint64_t), uint64_t (*a5)(void))
{
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    LOBYTE(v8) = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, a3, a4);
  }
  else if ((a2 & 0x2000000000000000) != 0)
  {
    v10[0] = a1;
    v10[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if a1 <= 0x20u && ((0x100003E01uLL >> a1))
    {
      LOBYTE(v8) = 0;
    }
    else
    {
      uint64_t v8 = ((uint64_t (*)(void *, uint64_t))a5)(v10, a3);
      if (v8) {
        LOBYTE(v8) = *(unsigned char *)v8 == 0;
      }
    }
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0) {
      uint64_t v6 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v6 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
    }
    unint64_t v7 = *v6;
    if (v7 <= 0x20 && ((0x100003E01uLL >> v7) & 1) != 0)
    {
      LOBYTE(v8) = 0;
    }
    else
    {
      uint64_t v8 = a5();
      if (v8) {
        LOBYTE(v8) = *(unsigned char *)v8 == 0;
      }
    }
  }
  return v8 & 1;
}

uint64_t String.withCString<A>(_:)(void (*a1)(__objc2_class **), uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  if ((a4 & 0x1000000000000000) != 0 || !(a4 & 0x2000000000000000 | a3 & 0x1000000000000000)) {
    return _StringGuts._slowWithCString<A>(_:)(a1, a2, a3, a4);
  }
  id v6 = (id)MEMORY[0x1F4188790](a1);
  v16[2] = v10;
  v16[3] = v9;
  v16[4] = v11;
  if ((v8 & 0x2000000000000000) != 0)
  {
    v17[0] = v7;
    v17[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    return v9(v17);
  }
  else
  {
    if ((v7 & 0x1000000000000000) == 0) {
      id v6 = _StringObject.sharedUTF8.getter(v7, v8);
    }
    MEMORY[0x1F4188790](v6);
    v15[2] = a5;
    v15[3] = partial apply for closure #1 in _StringGuts.withCString<A>(_:);
    v15[4] = v16;
    return _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys4Int8VsAD_pqd_1_Isgyrzr_SRys5UInt8VGqd_1_sAD_pAIRszAGRsd__sAD_pRsd_0_Ri_d_1_r_1_lIetMgyrzo_Tpq5(partial apply for thunk for @callee_guaranteed (@unowned UnsafeBufferPointer<Int8>) -> (@out A, @error @owned Error), (uint64_t)v15, v13, v12);
  }
}

BOOL static UInt8.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t static String._tryFromUTF8(_:)(uint8x16_t *a1, uint64_t a2)
{
  char v4 = validateUTF8(_:)(a1->i64, a2);
  if (v5) {
    return 0;
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v4 & 1);
  }
}

unint64_t static String.decodeCString<A>(_:as:repairingInvalidCodeUnits:)(uint8x16_t *a1, ValueMetadata *a2, int a3, ValueMetadata *a4, int **a5)
{
  int v81 = a3;
  v80 = a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a5, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v9 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)a5, (uint64_t)a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)+ 8);
  uint64_t v79 = *(int ***)(*(void *)(v9 + 24) + 16);
  uint64_t v10 = swift_getAssociatedTypeWitness(0, v79, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v10);
  uint64_t v12 = &v63[-v11];
  uint64_t v13 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v16 = &v63[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  size_t v19 = &v63[-v18];
  MEMORY[0x1F4188790](v17);
  uint64_t v22 = &v63[-v21];
  if (a4 == &type metadata for Unicode.UTF8)
  {
    if (!a1) {
      return 0;
    }
    size_t v28 = _swift_stdlib_strlen(a1->i8);
    if ((v28 & 0x8000000000000000) != 0) {
      goto LABEL_33;
    }
    uint64_t v25 = v28;
    goto LABEL_18;
  }
  if (a4 != &type metadata for Unicode.UTF16)
  {
    if (!a1) {
      return 0;
    }
    if (v80 == &type metadata for Unicode.UTF8)
    {
      uint64_t v23 = v20;
      int64_t v24 = _swift_stdlib_strlen(a1->i8);
      if (v24 < 0) {
        goto LABEL_33;
      }
      uint64_t v25 = v24;
      uint64_t v26 = *(void *)(v23 + 72);
      if (v26 != 1)
      {
        if ((unsigned __int128)(v24 * (__int128)v26) >> 64 != (v24 * v26) >> 63)
        {
          __break(1u);
          return 0;
        }
        if (v26 < 1 && v26 != -1)
        {
          if (!v26) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x390EuLL, 0);
          }
          LODWORD(v65) = 0;
          uint64_t v64 = 2033;
          v63[0] = 2;
          v38 = "Buffer must contain a whole number of Element instances";
          uint64_t v39 = 55;
LABEL_34:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v38, v39, 2, "Swift/UnsafeBufferPointer.swift", 31, v60, v61, v62);
        }
        uint64_t v25 = v24 * v26;
        if (v24 * v26 < 0)
        {
LABEL_33:
          int v62 = 0;
          unint64_t v61 = 1343;
          char v60 = 2;
          v38 = "UnsafeBufferPointer with negative count";
          uint64_t v39 = 39;
          goto LABEL_34;
        }
      }
LABEL_18:
      int64_t v29 = validateUTF8(_:)(a1->i64, v25);
      if (v81)
      {
        if (v31) {
          return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v25, v29, v30);
        }
        return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v25, v29 & 1);
      }
      if ((v31 & 1) == 0) {
        return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v25, v29 & 1);
      }
      return 0;
    }
    uint64_t v78 = v9;
    v75 = *(uint64_t (**)(uint64_t *, uint64_t))(v9 + 64);
    uint64_t v76 = v9 + 64;
    uint64_t v70 = v20;
    v40 = *(void (**)(unsigned char *))(v20 + 16);
    uint64_t v71 = v9 + 128;
    uint64_t v72 = v40;
    uint64_t v68 = v9 + 96;
    uint64_t v73 = v20 + 16;
    uint64_t v74 = (void (**)(unsigned char *, uint64_t *))(v20 + 8);
    unint64_t v65 = v79 + 3;
    uint64_t v66 = v9 + 120;
    uint64_t v64 = v20 + 32;
    for (i = a1; ; i = (uint8x16_t *)((char *)v77 + *(void *)(v70 + 72)))
    {
      v77 = i;
      v72(v22);
      if (v75(v13, v78)) {
        break;
      }
      LODWORD(v69) = v75(v13, v78);
      uint64_t v43 = (*(uint64_t (**)(uint64_t *))(v78 + 128))(v13);
      if ((v69 & 1) == 0)
      {
        if (v43 < 64)
        {
LABEL_36:
          uint64_t v42 = (*(uint64_t (**)(uint64_t *))(v78 + 120))(v13);
          (*v74)(v22, v13);
          if (!v42) {
            goto LABEL_52;
          }
          continue;
        }
        v82[0] = 0;
        uint64_t v69 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v78 + 96);
        unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
        v69(v82, &type metadata for Int, v48, v13, v78);
        int v67 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t *))(*(void *)(*(void *)(v78 + 16) + 8) + 8))(v22, v19, v13);
        uint64_t v69 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))*v74;
        ((void (*)(unsigned char *, uint64_t *))v69)(v22, v13);
        unint64_t v47 = v19;
        goto LABEL_46;
      }
      if (v43 > 64) {
        goto LABEL_43;
      }
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v79, (uint64_t)v13, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0B8, 256, v10, AssociatedConformanceWitness);
      ((void (*)(unsigned char *, uint64_t *))v79[3])(v12, v13);
      char v50 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t *))(*(void *)(*(void *)(v78 + 32) + 8) + 32))(v22, v19, v13);
      uint64_t v69 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))*v74;
      ((void (*)(unsigned char *, uint64_t *))v69)(v19, v13);
      (*(void (**)(unsigned char *, unsigned char *, uint64_t *))v64)(v16, v22, v13);
      if (v50)
      {
        uint64_t v51 = (*(uint64_t (**)(uint64_t *))(v78 + 120))(v13);
        ((void (*)(unsigned char *, uint64_t *))v69)(v16, v13);
        if (!v51)
        {
LABEL_52:
          uint64_t v52 = *(void *)(v70 + 72);
          if (!v52) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
          }
          if ((char *)v77 - (char *)a1 == 0x8000000000000000 && v52 == -1) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
          }
          v82[0] = UnsafeBufferPointer.init(start:count:)((uint64_t)a1, ((char *)v77 - (char *)a1) / v52);
          v82[1] = v53;
          BOOL v56 = (unint64_t *)type metadata accessor for UnsafeBufferPointer(0, (uint64_t)v13, v54, v55);
          uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, v56, v57);
          unint64_t result = static String._fromCodeUnits<A, B>(_:encoding:repair:)((uint64_t)v82, (uint64_t)v80, v81 & 1, (Class *)v56, a4, WitnessTable, a5);
          if (v59) {
            return result;
          }
          return 0;
        }
      }
      else
      {
        ((void (*)(unsigned char *, uint64_t *))v69)(v16, v13);
      }
LABEL_37:
      ;
    }
    uint64_t v43 = (*(uint64_t (**)(uint64_t *))(v78 + 128))(v13);
    if (v43 < 64) {
      goto LABEL_36;
    }
LABEL_43:
    v82[0] = 0;
    uint64_t v69 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v78 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
    v69(v82, &type metadata for Int, v46, v13, v78);
    int v67 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t *))(*(void *)(*(void *)(v78 + 16) + 8) + 8))(v22, v19, v13);
    uint64_t v69 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))*v74;
    ((void (*)(unsigned char *, uint64_t *))v69)(v19, v13);
    unint64_t v47 = v22;
LABEL_46:
    ((void (*)(unsigned char *, uint64_t *))v69)(v47, v13);
    if (v67) {
      goto LABEL_52;
    }
    goto LABEL_37;
  }
  if (!a1) {
    return 0;
  }
  uint64_t v33 = a1;
  if (a1->i16[0])
  {
    v34 = &a1->u16[1];
    uint64_t v33 = a1;
    do
    {
      int v35 = *v34++;
      uint64_t v33 = (uint8x16_t *)((char *)v33 + 2);
    }
    while (v35);
  }
  uint64_t v36 = (char *)v33 - (char *)a1;
  if (v36 <= -2) {
    goto LABEL_33;
  }
  unint64_t result = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, v36 / 2, v80, v81 & 1);
  if (!v37) {
    return 0;
  }
  return result;
}

BOOL static BinaryInteger.!= infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v87 = a1;
  uint64_t v88 = a2;
  v82 = *(int ***)(*(void *)(a6 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v82, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v78 = (char *)&v73 - v10;
  v77 = *(int ***)(*(void *)(a5 + 24) + 16);
  uint64_t v76 = swift_getAssociatedTypeWitness(0, v77, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](v76);
  v75 = (char *)&v73 - v12;
  uint64_t v86 = *(void *)(a4 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  v80 = (char *)&v73 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  int v81 = (char *)&v73 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v84 = (char *)&v73 - v18;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v73 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  int64_t v24 = (char *)&v73 - v23;
  MEMORY[0x1F4188790](v22);
  v83 = (char *)&v73 - v25;
  uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  int v27 = v26(a3, a5);
  if (((v27 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6)) & 1) == 0)
  {
    uint64_t v39 = v87;
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
    uint64_t v41 = v88;
    BOOL v42 = v40 < (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
    uint64_t v32 = v41;
    uint64_t v43 = v39;
    if (!v42)
    {
      unint64_t v46 = v84;
      (*(void (**)(char *, uint64_t, uint64_t))(v86 + 16))(v84, v32, a4);
      unint64_t v47 = v83;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v46, a4, a6, a3, a5);
      char v36 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 16) + 8) + 8))(v43, v47, a3);
      uint64_t v37 = *(void (**)(char *, uint64_t))(v85 + 8);
      v38 = v47;
      goto LABEL_11;
    }
    uint64_t v44 = v83;
    (*(void (**)(char *, uint64_t, uint64_t))(v85 + 16))(v83, v39, a3);
    goto LABEL_10;
  }
  uint64_t v73 = v24;
  uint64_t v74 = v21;
  size_t v28 = v82;
  char v29 = v26(a3, a5);
  uint64_t v30 = v87;
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
  uint64_t v32 = v88;
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
  if ((v29 & 1) == 0)
  {
    if (v31 >= v33)
    {
      unint64_t v61 = AssociatedTypeWitness;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v28, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v63 = v78;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0B8, 256, v61, AssociatedConformanceWitness);
      uint64_t v64 = v84;
      ((void (*)(char *, uint64_t, int **))v28[3])(v63, a4, v28);
      LODWORD(v82) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 32))(v32, v64, a4);
      uint64_t v65 = v30;
      uint64_t v66 = v86;
      int v67 = *(void (**)(char *, uint64_t))(v86 + 8);
      v67(v64, a4);
      uint64_t v68 = v85;
      uint64_t v69 = v74;
      (*(void (**)(char *, uint64_t, uint64_t))(v85 + 16))(v74, v65, a3);
      uint64_t v70 = v80;
      (*(void (**)(char *, uint64_t, uint64_t))(v66 + 16))(v80, v88, a4);
      if (v82)
      {
        uint64_t v71 = v83;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v70, a4, a6, a3, a5);
        char v36 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 16) + 8) + 8))(v69, v71, a3);
        uint64_t v72 = *(void (**)(char *, uint64_t))(v68 + 8);
        v72(v71, a3);
        v72(v69, a3);
      }
      else
      {
        v67(v70, a4);
        (*(void (**)(char *, uint64_t))(v68 + 8))(v69, a3);
        char v36 = 0;
      }
      return (v36 & 1) == 0;
    }
    uint64_t v44 = v83;
    (*(void (**)(char *, uint64_t, uint64_t))(v85 + 16))(v83, v30, a3);
LABEL_10:
    uint64_t v45 = v84;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v44, a3, a5, a4, a6);
    char v36 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 16) + 8) + 8))(v45, v32, a4);
    (*(void (**)(char *, uint64_t))(v86 + 8))(v45, a4);
    return (v36 & 1) == 0;
  }
  if (v33 < v31)
  {
    v34 = v84;
    (*(void (**)(char *, uint64_t, uint64_t))(v86 + 16))(v84, v32, a4);
    int v35 = v83;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v34, a4, a6, a3, a5);
    char v36 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 16) + 8) + 8))(v30, v35, a3);
    uint64_t v37 = *(void (**)(char *, uint64_t))(v85 + 8);
    v38 = v35;
LABEL_11:
    v37(v38, a3);
    return (v36 & 1) == 0;
  }
  uint64_t v49 = v76;
  char v50 = v77;
  uint64_t v51 = swift_getAssociatedConformanceWitness((uint64_t)v77, a3, (uint64_t)v76, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v52 = v75;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v51 + 8))(&unk_18162B0B8, 256, v49, v51);
  uint64_t v53 = v83;
  ((void (*)(char *, uint64_t, int **))v50[3])(v52, a3, v50);
  LOBYTE(v49) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8) + 32))(v30, v53, a3);
  uint64_t v54 = v85;
  uint64_t v55 = *(void (**)(char *, uint64_t))(v85 + 8);
  v55(v53, a3);
  BOOL v56 = v73;
  (*(void (**)(void))(v54 + 16))();
  uint64_t v57 = v86;
  uint64_t v58 = v81;
  (*(void (**)(char *, uint64_t, uint64_t))(v86 + 16))(v81, v88, a4);
  if (v49)
  {
    uint64_t v59 = v84;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v56, a3, a5, a4, a6);
    char v36 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 16) + 8) + 8))(v59, v58, a4);
    char v60 = *(void (**)(char *, uint64_t))(v57 + 8);
    v60(v59, a4);
    v60(v58, a4);
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v57 + 8))(v58, a4);
    v55(v56, a3);
    char v36 = 0;
  }
  return (v36 & 1) == 0;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(uint8x16_t *a1, uint64_t a2, char a3)
{
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for UnsafeBufferPointer<UInt8>
    && &full type metadata for Unicode.UTF16 == &full type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, a3 & 1);
  }
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for [UInt8]
    && &full type metadata for Unicode.UTF16 == &full type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)((unint64_t)a1, a3 & 1);
  }
  return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)((unsigned __int16 *)a1, a2, a3 & 1);
}

{
  __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t result;
  uint64_t v10;

  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (a2)
  {
    if (!a1) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
    }
    goto LABEL_6;
  }
  if (a1)
  {
LABEL_6:
    id v6 = &a1->i8[a2];
    goto LABEL_7;
  }
  id v6 = 0;
LABEL_7:
  uint64_t v7 = v6 - (__int8 *)a1;
  if (a1) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!_allASCII(_:)(a1->i64, v8)) {
    return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1->i8, a2, a3 & 1);
  }
  unint64_t result = specialized static String._uncheckedFromASCII(_:)(a1, v8);
  if (!v10) {
    return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1->i8, a2, a3 & 1);
  }
  return result;
}

unint64_t static String._fromCodeUnits<A, B>(_:encoding:repair:)(uint64_t a1, uint64_t a2, char a3, Class *a4, ValueMetadata *a5, uint64_t a6, int **a7)
{
  uint64_t v13 = (uint64_t)*(a4 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](a1);
  uint64_t v16 = (char *)&v45 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v19 = (unint64_t *)((char *)&v45 - v18);
  if (v20 == &unk_1ECA01D20 && a5 == &type metadata for Unicode.ASCII) {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(*(uint8x16_t **)a1, *(void *)(a1 + 8), a3 & 1);
  }
  if (a4 == (Class *)&unk_1ECA01C90 && a5 == &type metadata for Unicode.ASCII) {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(*(void *)a1, a3 & 1);
  }
  if (v17 != &type metadata for Unicode.ASCII)
  {
    int v40 = a3 & 1;
    uint64_t v41 = a1;
    uint64_t v42 = (uint64_t)a4;
    uint64_t v43 = (uint64_t)a5;
    uint64_t v38 = a6;
    uint64_t v39 = a7;
    return static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(v41, v40, v42, v43, v38, v39);
  }
  uint64_t v45 = *(void (**)(char *, uint64_t, Class *))(v13 + 16);
  v45((char *)&v45 - v18, a1, a4);
  uint64_t v22 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasContiguousBytes);
  char v23 = swift_dynamicCast((char *)v48, v19, a4, v22, 6uLL);
  unint64_t v47 = a7;
  if ((v23 & 1) == 0)
  {
    uint64_t v49 = 0;
    memset(v48, 0, sizeof(v48));
    uint64_t HasContiguous = outlined destroy of _HasContiguousBytes?((uint64_t)v48, &demangling cache variable for type metadata for _HasContiguousBytes?);
    goto LABEL_14;
  }
  uint64_t v24 = a6;
  outlined init with take of MirrorPath(v48, (uint64_t)&v50);
  uint64_t v25 = v52;
  uint64_t v26 = v53;
  __swift_project_boxed_opaque_existential_0Tm(&v50, v52);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v26 + 16))(v25, v26) & 1) == 0)
  {
    uint64_t HasContiguous = __swift_destroy_boxed_opaque_existential_1Tm(&v50);
    a7 = v47;
    a6 = v24;
LABEL_14:
    MEMORY[0x1F4188790](HasContiguous);
    *(&v45 - 4) = (void (*)(char *, uint64_t, Class *))a4;
    *(&v45 - 3) = (void (*)(char *, uint64_t, Class *))a5;
    *(&v45 - 2) = (void (*)(char *, uint64_t, Class *))a6;
    *(&v45 - 1) = (void (*)(char *, uint64_t, Class *))a7;
    unint64_t v46 = (void (*)(char *, uint64_t, Class *))a6;
    uint64_t v31 = *(void *)(a6 + 8);
    (*(void (**)(uint64_t *__return_ptr, unint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, unint64_t *@<X8>)))(v31 + 72))(&v50, partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:));
    if (v51 == 1)
    {
      v45(v16, a1, a4);
      int64_t v32 = (*(uint64_t (**)(Class *, uint64_t))(v31 + 56))(a4, v31);
      MEMORY[0x1F4188790](v32);
      *(&v45 - 4) = (void (*)(char *, uint64_t, Class *))a4;
      *(&v45 - 3) = (void (*)(char *, uint64_t, Class *))a5;
      uint64_t v34 = (uint64_t)v46;
      uint64_t v33 = v47;
      *(&v45 - 2) = v46;
      *(&v45 - 1) = (void (*)(char *, uint64_t, Class *))v33;
      AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, (int **)v31, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
      uint64_t v29 = (uint64_t)_ss12_ArrayBufferV010withUnsafeB7Pointeryqd__qd__SRyxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxSSSgIsgyrzo_AByxGAFsAE_pAFRsd__r__lIetMggozo_Tp5((void *(*)(uint64_t *__return_ptr, unint64_t, unint64_t))partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:), (uint64_t)(&v45 - 6), v32, AssociatedTypeWitness);
      uint64_t v37 = v36;
      swift_release(v32);
      if (v37) {
        return v29;
      }
      int v40 = a3 & 1;
      uint64_t v41 = a1;
      uint64_t v42 = (uint64_t)a4;
      uint64_t v43 = (uint64_t)a5;
      uint64_t v38 = v34;
      uint64_t v39 = v47;
    }
    else
    {
      uint64_t v38 = (uint64_t)v46;
      uint64_t v39 = v47;
      if (v51) {
        return v50;
      }
      int v40 = a3 & 1;
      uint64_t v41 = a1;
      uint64_t v42 = (uint64_t)a4;
      uint64_t v43 = (uint64_t)a5;
    }
    return static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(v41, v40, v42, v43, v38, v39);
  }
  uint64_t v27 = v52;
  uint64_t v28 = v53;
  __swift_project_boxed_opaque_existential_0Tm(&v50, v52);
  (*(void (**)(long long *__return_ptr, unint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, unint64_t *@<X8>), void, void *, uint64_t, uint64_t))(v28 + 8))(v48, closure #1 in static String._fromCodeUnits<A, B>(_:encoding:repair:), 0, &unk_1ECA01C60, v27, v28);
  if (*((void *)&v48[0] + 1)) {
    uint64_t v29 = *(void *)&v48[0];
  }
  else {
    uint64_t v29 = static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1, a3 & 1, (uint64_t)a4, (uint64_t)a5, v24, v47);
  }
  __swift_destroy_boxed_opaque_existential_1Tm(&v50);
  return v29;
}

void String.withCString<A, B>(encodedAs:_:)(ValueMetadata *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a1 == &type metadata for Unicode.UTF8)
  {
    MEMORY[0x1F4188790](a1);
    v12[2] = v5;
    v12[3] = v6;
    v12[4] = v8;
    v12[5] = v7;
    v12[6] = v9;
    String.withCString<A>(_:)((void (*)(__objc2_class **))partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:), (uint64_t)v12, v10, v11, v5);
  }
  else
  {
    String._slowWithCString<A, B>(encodedAs:_:)((uint64_t)a1, a2, a3, a4, a5);
  }
}

unint64_t String.init<A>(decodingCString:as:)(uint8x16_t *a1, ValueMetadata *a2, ValueMetadata *a3, int **a4)
{
  uint64_t v74 = a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, (uint64_t)a3, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v8 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)a4, (uint64_t)a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)+ 8);
  uint64_t v73 = *(int ***)(*(void *)(v8 + 24) + 16);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, v73, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v9);
  unint64_t v11 = (char *)&v58 - v10;
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v58 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v58 - v20;
  if (a3 == &type metadata for Unicode.UTF8)
  {
    size_t v27 = _swift_stdlib_strlen(a1->i8);
    if ((v27 & 0x8000000000000000) != 0) {
      goto LABEL_25;
    }
    uint64_t v24 = v27;
    goto LABEL_16;
  }
  if (a3 == &type metadata for Unicode.UTF16)
  {
    int64_t v32 = a1;
    if (a1->i16[0])
    {
      int64_t v32 = a1;
      do
      {
        int v33 = v32->u16[1];
        int64_t v32 = (uint8x16_t *)((char *)v32 + 2);
      }
      while (v33);
    }
    uint64_t v34 = (char *)v32 - (char *)a1;
    if (v34 > -2)
    {
      unint64_t result = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, v34 / 2, v74, 1);
      if (!v35) {
        goto LABEL_45;
      }
      return result;
    }
    goto LABEL_25;
  }
  if (v74 == &type metadata for Unicode.UTF8)
  {
    uint64_t v22 = v19;
    int64_t v23 = _swift_stdlib_strlen(a1->i8);
    if (v23 < 0) {
      goto LABEL_25;
    }
    uint64_t v24 = v23;
    uint64_t v25 = *(void *)(v22 + 72);
    if (v25 != 1)
    {
      if ((unsigned __int128)(v23 * (__int128)v25) >> 64 != (v23 * v25) >> 63)
      {
        __break(1u);
LABEL_47:
        if (!v25) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x390EuLL, 0);
        }
        LODWORD(v60) = 0;
        uint64_t v59 = 2033;
        LOBYTE(v58) = 2;
        uint64_t v36 = "Buffer must contain a whole number of Element instances";
        uint64_t v37 = 55;
LABEL_26:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v36, v37, 2, "Swift/UnsafeBufferPointer.swift", 31, v55, v56, v57);
      }
      if (v25 < 1 && v25 != -1) {
        goto LABEL_47;
      }
      uint64_t v24 = v23 * v25;
      if (v23 * v25 < 0)
      {
LABEL_25:
        int v57 = 0;
        unint64_t v56 = 1343;
        char v55 = 2;
        uint64_t v36 = "UnsafeBufferPointer with negative count";
        uint64_t v37 = 39;
        goto LABEL_26;
      }
    }
LABEL_16:
    int64_t v28 = validateUTF8(_:)(a1->i64, v24);
    if (v30) {
      return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v24, v28, v29);
    }
    else {
      return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v24, v28 & 1);
    }
  }
  uint64_t v72 = v8;
  uint64_t v69 = *(uint64_t (**)(uint64_t *, uint64_t))(v8 + 64);
  uint64_t v70 = v8 + 64;
  uint64_t v65 = v19;
  uint64_t v66 = *(void (**)(char *))(v19 + 16);
  uint64_t v67 = v19 + 16;
  uint64_t v64 = v8 + 128;
  uint64_t v62 = v8 + 96;
  uint64_t v68 = (void (**)(char *, uint64_t *))(v19 + 8);
  uint64_t v59 = (uint64_t)(v73 + 3);
  uint64_t v60 = v8 + 120;
  uint64_t v58 = (void (**)(char *, char *, uint64_t *))(v19 + 32);
  for (i = a1; ; i = (uint8x16_t *)((char *)v71 + *(void *)(v65 + 72)))
  {
    uint64_t v71 = i;
    v66(v21);
    if (v69(v12, v72)) {
      break;
    }
    LODWORD(v63) = v69(v12, v72);
    uint64_t v40 = (*(uint64_t (**)(uint64_t *))(v72 + 128))(v12);
    if ((v63 & 1) == 0) {
      goto LABEL_37;
    }
    if (v40 > 64) {
      goto LABEL_28;
    }
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v73, (uint64_t)v12, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v9, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t *))v73[3])(v11, v12);
    char v44 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v72 + 32) + 8) + 32))(v21, v18, v12);
    uint64_t v63 = *v68;
    v63(v18, v12);
    (*v58)(v15, v21, v12);
    if (v44)
    {
      uint64_t v45 = (*(uint64_t (**)(uint64_t *))(v72 + 120))(v12);
      v63(v15, v12);
      if (!v45) {
        goto LABEL_41;
      }
    }
    else
    {
      v63(v15, v12);
    }
LABEL_29:
    ;
  }
  uint64_t v40 = (*(uint64_t (**)(uint64_t *))(v72 + 128))(v12);
LABEL_37:
  if (v40 >= 64)
  {
LABEL_28:
    v75[0] = 0;
    uint64_t v63 = *(void (**)(char *, uint64_t *))(v72 + 96);
    unint64_t v39 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))v63)(v75, &type metadata for Int, v39, v12, v72);
    int v61 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v72 + 16) + 8) + 8))(v21, v18, v12);
    uint64_t v63 = *v68;
    v63(v18, v12);
    v63(v21, v12);
    if (v61) {
      goto LABEL_41;
    }
    goto LABEL_29;
  }
  uint64_t v46 = (*(uint64_t (**)(uint64_t *))(v72 + 120))(v12);
  (*v68)(v21, v12);
  if (v46) {
    goto LABEL_29;
  }
LABEL_41:
  uint64_t v47 = *(void *)(v65 + 72);
  if (!v47) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  if ((char *)v71 - (char *)a1 == 0x8000000000000000 && v47 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  }
  v75[0] = UnsafeBufferPointer.init(start:count:)((uint64_t)a1, ((char *)v71 - (char *)a1) / v47);
  v75[1] = v48;
  uint64_t v51 = (unint64_t *)type metadata accessor for UnsafeBufferPointer(0, (uint64_t)v12, v49, v50);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, v51, v52);
  unint64_t result = static String._fromCodeUnits<A, B>(_:encoding:repair:)((uint64_t)v75, (uint64_t)v74, 1, (Class *)v51, a3, WitnessTable, a4);
  if (!v54) {
LABEL_45:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CString.swift", 19, 2, 0x1E3uLL, 0);
  return result;
}

uint64_t OpaquePointer._rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*OpaquePointer._rawValue.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Int OpaquePointer.hashValue.getter(Swift::UInt a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance OpaquePointer()
{
  Hasher._combine(_:)(*v0);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance OpaquePointer()
{
  Hasher._combine(_:)(*v0);
  return Hasher._finalize()();
}

unint64_t specialized _Pointer.debugDescription.getter(Swift::UInt64 a1)
{
  Swift::String v1 = _uint64ToString(_:radix:uppercase:)(a1, 16, 0);
  uint64_t countAndFlagsBits = v1._countAndFlagsBits;
  unint64_t object = (unint64_t)v1._object;
  if (((uint64_t)v1._object & 0x1000000000000000) != 0)
  {
    Swift::Int v5 = String.UTF16View._foreignCount()();
  }
  else
  {
    unint64_t v4 = ((unint64_t)v1._object >> 56) & 0xF;
    if (((uint64_t)v1._object & 0x2000000000000000) == 0) {
      unint64_t v4 = v1._countAndFlagsBits;
    }
    Swift::Int v5 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v4 << 16) | 7));
  }
  Swift::Int v6 = 16 - v5;
  if (__OFSUB__(16, v5))
  {
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (v6 < 0) {
    goto LABEL_20;
  }
  if (v6)
  {
    Swift::Int v7 = v5 - 16;
    do
    {
      while ((object & 0x2000000000000000) != 0)
      {
        unint64_t v10 = specialized _SmallString.init(_:appending:)(0x30uLL, 0xE100000000000000, countAndFlagsBits, object);
        if (v12) {
          break;
        }
        unint64_t v13 = v10;
        unint64_t v14 = v11;
        swift_bridgeObjectRelease(object);
        unint64_t object = v14;
        uint64_t countAndFlagsBits = v13;
        BOOL v9 = __CFADD__(v7++, 1);
        if (v9) {
          goto LABEL_17;
        }
      }
      if ((object & 0x2000000000000000) != 0) {
        uint64_t v8 = HIBYTE(object) & 0xF;
      }
      else {
        uint64_t v8 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      _StringGuts.append(_:)(countAndFlagsBits, object, 0, v8);
      swift_bridgeObjectRelease(object);
      uint64_t countAndFlagsBits = 48;
      unint64_t object = 0xE100000000000000;
      BOOL v9 = __CFADD__(v7++, 1);
    }
    while (!v9);
  }
LABEL_17:
  unint64_t v15 = specialized static String.+ infix(_:_:)(0x7830uLL, 0xE200000000000000, countAndFlagsBits, object);
  swift_bridgeObjectRelease(0xE200000000000000);
  swift_bridgeObjectRelease(object);
  return v15;
}

Swift::String __swiftcall _rawPointerToString(_:)(Builtin::RawPointer a1)
{
  Swift::String v1 = _uint64ToString(_:radix:uppercase:)((Swift::UInt64)a1, 16, 0);
  uint64_t countAndFlagsBits = v1._countAndFlagsBits;
  unint64_t object = (unint64_t)v1._object;
  if (((uint64_t)v1._object & 0x1000000000000000) != 0)
  {
    Swift::Int v5 = String.UTF16View._foreignCount()();
  }
  else
  {
    unint64_t v4 = ((unint64_t)v1._object >> 56) & 0xF;
    if (((uint64_t)v1._object & 0x2000000000000000) == 0) {
      unint64_t v4 = v1._countAndFlagsBits;
    }
    Swift::Int v5 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v4 << 16) | 7));
  }
  Swift::Int v6 = 16 - v5;
  if (__OFSUB__(16, v5))
  {
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (v6 < 0) {
    goto LABEL_20;
  }
  if (v6)
  {
    Swift::Int v7 = v5 - 16;
    do
    {
      while ((object & 0x2000000000000000) != 0)
      {
        unint64_t v10 = specialized _SmallString.init(_:appending:)(0x30uLL, 0xE100000000000000, countAndFlagsBits, object);
        if (v12) {
          break;
        }
        unint64_t v13 = v10;
        unint64_t v14 = v11;
        swift_bridgeObjectRelease(object);
        unint64_t object = v14;
        uint64_t countAndFlagsBits = v13;
        BOOL v9 = __CFADD__(v7++, 1);
        if (v9) {
          goto LABEL_17;
        }
      }
      if ((object & 0x2000000000000000) != 0) {
        uint64_t v8 = HIBYTE(object) & 0xF;
      }
      else {
        uint64_t v8 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      _StringGuts.append(_:)(countAndFlagsBits, object, 0, v8);
      swift_bridgeObjectRelease(object);
      uint64_t countAndFlagsBits = 48;
      unint64_t object = 0xE100000000000000;
      BOOL v9 = __CFADD__(v7++, 1);
    }
    while (!v9);
  }
LABEL_17:
  unint64_t v15 = specialized static String.+ infix(_:_:)(0x7830uLL, 0xE200000000000000, countAndFlagsBits, object);
  uint64_t v17 = v16;
  swift_bridgeObjectRelease(0xE200000000000000);
  swift_bridgeObjectRelease(object);
  uint64_t v18 = v15;
  uint64_t v19 = v17;
  result._unint64_t object = v19;
  result._uint64_t countAndFlagsBits = v18;
  return result;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance OpaquePointer()
{
  return OpaquePointer.debugDescription.getter(*v0);
}

uint64_t Int.init<A>(bitPattern:)(const void *a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = *(void *)(*(void *)(a2 - 8) + 64);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v8 + 48))(v7, 1, a2) == 1)
  {
    unint64_t v11 = type metadata accessor for Optional(0, a2, v9, v10);
    (*((void (**)(const void *, Class *))*(v11 - 1) + 1))(a1, v11);
    return 0;
  }
  else
  {
    memcpy((char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v6);
    return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 48))(a2, a3);
  }
}

uint64_t CVaListPointer._value.setter(uint64_t result)
{
  *Swift::String v1 = result;
  return result;
}

uint64_t (*CVaListPointer._value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t CVaListPointer.debugDescription.getter(Swift::UInt64 a1)
{
  return specialized _Pointer.debugDescription.getter(a1);
}

uint64_t specialized static Optional<A>.== infix(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = (a2 | a4) == 0;
  if (!a2 || !a4) {
    return v4;
  }
  if (a1 == a3 && a2 == a4) {
    return 1;
  }
  if ((~a2 & 0x6000000000000000) == 0 && (a4 & 0x2000000000000000) != 0 && (a4 & 0x4000000000000000) != 0) {
    return 0;
  }
  return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, 0);
}

uint64_t specialized static Optional<A>.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  outlined init with copy of AnyHashable?(a1, (uint64_t)v23);
  outlined init with copy of AnyHashable?(a2, (uint64_t)&v24);
  if (!v23[3])
  {
    if (!*((void *)&v25 + 1))
    {
      outlined destroy of AnyHashable?(v23);
      return 1;
    }
LABEL_7:
    outlined destroy of _HasContiguousBytes?((uint64_t)v23, &demangling cache variable for type metadata for (AnyHashable?, AnyHashable?));
    return 0;
  }
  outlined init with copy of AnyHashable?((uint64_t)v23, (uint64_t)&v20);
  if (!*((void *)&v25 + 1))
  {
    outlined destroy of AnyHashable((uint64_t *)&v20);
    goto LABEL_7;
  }
  v18[0] = v20;
  v18[1] = v21;
  uint64_t v3 = v22;
  uint64_t v19 = v22;
  long long v15 = v24;
  long long v16 = v25;
  uint64_t v17 = v26;
  uint64_t v4 = *((void *)&v21 + 1);
  __swift_project_boxed_opaque_existential_0Tm(v18, *((uint64_t *)&v21 + 1));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 8))(v12, v4, v3);
  uint64_t v5 = v13;
  uint64_t v6 = v14;
  __swift_project_boxed_opaque_existential_0Tm(v12, v13);
  uint64_t v7 = *((void *)&v16 + 1);
  uint64_t v8 = v17;
  __swift_project_boxed_opaque_existential_0Tm(&v15, *((uint64_t *)&v16 + 1));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v11, v7, v8);
  LOBYTE(v5) = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v6 + 16))(v11, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t v9 = v5 & 1;
  __swift_destroy_boxed_opaque_existential_1Tm(v12);
  outlined destroy of AnyHashable((uint64_t *)&v15);
  outlined destroy of AnyHashable((uint64_t *)v18);
  outlined destroy of AnyHashable?(v23);
  return v9;
}

uint64_t static Optional<A>.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = a4;
  uint64_t v34 = a2;
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v31 = (char *)&v30 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  char v30 = (char *)&v30 - v9;
  char v12 = type metadata accessor for Optional(0, v10, v10, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v35 = (char *)&v30 - v14;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v12, (uint64_t)v12, 0, 0);
  uint64_t v16 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v19 = (char *)&v30 - v18;
  long long v20 = (char *)&v30 + *(int *)(v17 + 48) - v18;
  uint64_t v33 = v13;
  long long v21 = *(void (**)(char *, uint64_t, Class *))(v13 + 16);
  v21((char *)&v30 - v18, a1, v12);
  v21(v20, v34, v12);
  uint64_t v34 = v6;
  uint64_t v22 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48);
  if (v22(v19, 1, a3) == 1)
  {
    char v23 = 1;
    if (v22(v20, 1, a3) == 1) {
      goto LABEL_8;
    }
  }
  else
  {
    v21(v35, (uint64_t)v19, v12);
    if (v22(v20, 1, a3) != 1)
    {
      uint64_t v24 = v34;
      long long v25 = *(void (**)(char *, char *, uint64_t))(v34 + 32);
      uint64_t v26 = v30;
      v25(v30, v35, a3);
      size_t v27 = v31;
      v25(v31, v20, a3);
      char v23 = (*(uint64_t (**)(char *, char *, uint64_t))(v32 + 8))(v26, v27, a3);
      int64_t v28 = *(void (**)(char *, uint64_t))(v24 + 8);
      v28(v27, a3);
      v28(v26, a3);
LABEL_8:
      uint64_t v16 = v33;
      goto LABEL_9;
    }
    (*(void (**)(char *, uint64_t))(v34 + 8))(v35, a3);
  }
  char v23 = 0;
  char v12 = (Class *)TupleTypeMetadata2;
LABEL_9:
  (*(void (**)(char *, Class *))(v16 + 8))(v19, v12);
  return v23 & 1;
}

void *ObjectIdentifier.init(_:)(void *a1)
{
  return a1;
}

uint64_t String.init<A>(_:radix:uppercase:)(uint64_t a1, Swift::Int radix, Swift::Bool uppercase, uint64_t a4)
{
  uint64_t countAndFlagsBits = BinaryInteger._description(radix:uppercase:)(radix, uppercase)._countAndFlagsBits;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8))(a1, a4);
  return countAndFlagsBits;
}

uint64_t static _DebuggerSupport.ivarCount(mirror:)(void *a1)
{
  void (*v3)(uint64_t *__return_ptr, atomic_ullong *);
  atomic_ullong *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t result;
  void v15[2];
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;

  Swift::String v1 = (atomic_ullong *)a1[1];
  uint64_t v3 = (void (*)(uint64_t *__return_ptr, atomic_ullong *))a1[3];
  size_t v2 = (atomic_ullong *)a1[4];
  swift_retain(v1);
  uint64_t v4 = swift_retain(v2);
  v3(&v20, v4);
  swift_release((uint64_t)v2);
  uint64_t v5 = swift_release((uint64_t)v1);
  uint64_t v6 = v20;
  if (v20)
  {
    uint64_t v8 = v23;
    uint64_t v7 = v24;
    uint64_t v10 = v21;
    uint64_t v9 = v22;
    v15[0] = v20;
    v15[1] = v21;
    uint64_t v16 = v22;
    uint64_t v17 = v23;
    uint64_t v18 = v24;
    uint64_t v19 = v25 & 1;
    uint64_t v11 = static _DebuggerSupport.ivarCount(mirror:)(v15);
    uint64_t v5 = outlined consume of Mirror?(v6, v10, v9, v8, v7);
  }
  else
  {
    uint64_t v11 = 0;
  }
  char v12 = (*(uint64_t (**)(uint64_t))(*v1 + 320))(v5);
  uint64_t v13 = __OFADD__(v11, v12);
  Swift::String result = v11 + v12;
  if (v13) {
    __break(1u);
  }
  return result;
}

uint64_t Mirror.superclassMirror.getter()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

void specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, int a7, unsigned __int8 a8, uint64_t *a9, uint64_t *a10, unint64_t *a11)
{
  void (*v19)(long long *__return_ptr, uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  void *v27;
  unint64_t v28;
  uint64_t v29;
  BOOL v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  uint64_t v39;
  void *v40;
  int v41;
  unint64_t v42;
  void *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  char v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char v64;
  unint64_t v65;
  Class *v66;
  Swift::String v67;
  uint64_t countAndFlagsBits;
  unint64_t object;
  const char *v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  const char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const char *v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  char v115;
  unint64_t v116;
  unint64_t v117;
  Swift::String v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  char v123;
  unint64_t v124;
  unint64_t v125;
  void *v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  char v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t *v140;
  uint64_t v141;
  uint8x16_t *v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  char v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  unint64_t v154;
  char v155;
  unint64_t v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t *v160;
  swift::SwiftError **v161;
  Class *DynamicType;
  uint64_t *TypeName;
  uint64_t v164;
  uint8x16_t *v165;
  int64_t v166;
  int64_t v167;
  int64_t v168;
  char v169;
  unint64_t v170;
  unint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint8x16_t *v174;
  int64_t v175;
  int64_t v176;
  int64_t v177;
  char v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  char v187;
  unint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t *v197;
  uint64_t v198;
  uint8x16_t *v199;
  int64_t v200;
  int64_t v201;
  int64_t v202;
  char v203;
  unint64_t v204;
  unint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  char v211;
  unint64_t v212;
  unint64_t v213;
  uint64_t v214;
  unint64_t v215;
  void *v216;
  BOOL v217;
  char v218;
  void *v219;
  void *v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t *v223;
  swift::SwiftError **v224;
  uint64_t *v225;
  uint64_t *v226;
  uint64_t *v227;
  uint64_t v228;
  atomic_ullong *v229;
  void *v230;
  void (*v231)(long long *__return_ptr, uint64_t);
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  long long v237;
  uint64_t v238;
  BOOL v239;
  uint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unint64_t v246;
  unint64_t v247;
  char v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  unint64_t v253;
  uint64_t v254;
  uint64_t v255;
  unint64_t v256;
  unint64_t v257;
  char v258;
  unint64_t v259;
  unint64_t v260;
  uint64_t v261;
  unint64_t v262;
  uint64_t v263;
  char v264;
  unint64_t *v265;
  const char *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  char v271;
  uint64_t v272;
  uint64_t v273;
  char v274;
  uint64_t v275;
  void *v276;
  void *v277;
  unint64_t v278;
  uint64_t v279;
  uint64_t v280;
  void *v281;
  unint64_t v282;
  unint64_t v283;
  uint64_t v284;
  uint64_t v285;
  unint64_t v286;
  unint64_t v287;
  char v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  unint64_t v297;
  unint64_t v298;
  char v299;
  unint64_t v300;
  unint64_t v301;
  void *v302;
  void *v303;
  uint64_t v304;
  Swift::String v305;
  unint64_t *v306;
  unint64_t v307;
  unint64_t v308;
  char v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unint64_t v313;
  char v314;
  unint64_t v315;
  unint64_t v316;
  uint64_t v317;
  unint64_t v318;
  uint64_t v319;
  char v320;
  unint64_t v321;
  uint64_t v322;
  uint64_t *v323;
  swift::SwiftError **v324;
  uint64_t *v325;
  uint64_t *v326;
  atomic_ullong *v327;
  unint64_t v328;
  unint64_t v329;
  unint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  unint64_t v334;
  unint64_t v335;
  char v336;
  unint64_t v337;
  unint64_t v338;
  uint64_t v339;
  unint64_t v340;
  unint64_t v341;
  char v342;
  uint64_t v344;
  BOOL v345;
  BOOL v346;
  void (*v347)(long long *__return_ptr);
  uint64_t v350;
  uint64_t v351;
  unint64_t v352;
  uint64_t v353;
  unint64_t *v354;
  uint64_t v356;
  _OWORD v357[3];
  unint64_t v358[4];
  _OWORD v359[2];
  unsigned char v360[32];
  uint64_t v361[4];
  long long v362;
  long long v363;
  uint64_t v364;
  char v365;
  long long v366;
  long long v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  unint64_t v371;
  char v372;
  uint64_t v373;
  uint64_t v374;
  char v375;
  long long v376;
  char v377;
  uint64_t v378;
  uint64_t v379;
  char v380;

  uint64_t v11 = a10;
  uint64_t v12 = *a10 - 1;
  if (*a10 < 1) {
    return;
  }
  unint64_t v15 = a5;
  uint64_t v18 = a2;
  if ((a7 & 1) == 0
    && !a8
    && (specialized static AnyIndex.== infix(_:_:)(*(void *)(*(void *)(a2 + 8) + 16), *(void *)(*(void *)(a2 + 8) + 24), *(void *)(*(void *)(a2 + 8) + 32), *(void *)(*(void *)(a2 + 8) + 40)) & 1) != 0&& *(unsigned char *)(v18 + 16) != 1)
  {
    uint64_t v19 = *(void (**)(long long *__return_ptr, uint64_t))(v18 + 24);
    long long v20 = outlined retain of Mirror(v18);
    v19(&v366, v20);
    outlined release of Mirror(v18);
    long long v21 = v366;
    if ((void)v366)
    {
      uint64_t v22 = *((void *)&v367 + 1);
      v353 = v368;
      uint64_t v24 = *((void *)&v366 + 1);
      char v23 = v367;
      LOBYTE(v369) = v369 & 1;
      v351 = static _DebuggerSupport.ivarCount(mirror:)(&v366);
      long long v25 = v23;
      uint64_t v18 = a2;
      uint64_t v11 = a10;
      outlined consume of Mirror?(v21, v24, v25, v22, v353);
      unint64_t v15 = a5;
      if (v351 <= 0) {
        return;
      }
    }
    else
    {
      unint64_t v15 = a5;
    }
  }
  uint64_t v26 = a11;
  *uint64_t v11 = v12;
  v354 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  size_t v27 = swift_allocObject(v354, 0x40uLL, 7uLL);
  *((_OWORD *)v27 + 1) = xmmword_18162AC80;
  int64_t v28 = specialized String.init(repeating:count:)(0x20uLL, 0xE100000000000000, v15);
  v27[7] = &type metadata for String;
  v27[4] = v28;
  v27[5] = v29;
  specialized _print<A>(_:separator:terminator:to:)((uint64_t)v27, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, a11);
  swift_bridgeObjectRelease(0xE000000000000000);
  swift_bridgeObjectRelease(0xE100000000000000);
  swift_setDeallocating((uint64_t)v27);
  swift_arrayDestroy((uint64_t)(v27 + 4), 1, (unint64_t *)qword_1ECA06310);
  swift_deallocClassInstance((uint64_t)v27);
  char v30 = *(unsigned __int8 *)(v18 + 16) == 1;
  outlined init with copy of Any?(a1, (uint64_t)&v366);
  if (*((void *)&v367 + 1))
  {
    outlined init with take of Any(&v366, &v362);
    outlined init with take of Any(&v362, &v376);
    uint64_t v31 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
    if ((swift_dynamicCast((char *)&v366, (unint64_t *)&v376, qword_1ECA06310, v31, 6uLL) & 1) == 0) {
      goto LABEL_15;
    }
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v366);
  }
  else
  {
    outlined destroy of Any?((uint64_t)&v366);
  }
  char v30 = 0;
LABEL_15:
  uint64_t v32 = *(void *)(v18 + 8);
  uint64_t v33 = (*(uint64_t (**)(void))(*(void *)v32 + 320))();
  uint64_t v34 = 549033698;
  if (a6 > 0) {
    uint64_t v34 = 549426914;
  }
  v344 = v33;
  v346 = v30;
  if (v33) {
    uint64_t v35 = v30;
  }
  else {
    uint64_t v35 = 1;
  }
  if (!v33) {
    uint64_t v34 = 8237;
  }
  uint64_t v36 = 0xA400000000000000;
  if (!v33) {
    uint64_t v36 = 0xE200000000000000;
  }
  uint64_t v37 = (a7 & v35) == 0;
  if ((a7 & v35) != 0) {
    uint64_t v38 = 0xE000000000000000;
  }
  else {
    uint64_t v38 = v36;
  }
  if (v37) {
    unint64_t v39 = v34;
  }
  else {
    unint64_t v39 = 0;
  }
  uint64_t v40 = swift_allocObject(v354, 0x40uLL, 7uLL);
  *((_OWORD *)v40 + 1) = xmmword_18162AC80;
  v40[7] = &type metadata for String;
  v40[4] = v39;
  v40[5] = v38;
  specialized _print<A>(_:separator:terminator:to:)((uint64_t)v40, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, a11);
  swift_bridgeObjectRelease(0xE000000000000000);
  swift_bridgeObjectRelease(0xE100000000000000);
  swift_setDeallocating((uint64_t)v40);
  swift_arrayDestroy((uint64_t)(v40 + 4), 1, (unint64_t *)qword_1ECA06310);
  swift_deallocClassInstance((uint64_t)v40);
  uint64_t v41 = *(unsigned __int8 *)(v18 + 16);
  if ((v41 - 5) < 3)
  {
    uint64_t v42 = 0x10201u >> (8 * (v41 - 5));
LABEL_34:
    v352 = v42;
    goto LABEL_36;
  }
  if (a8 < 5u)
  {
    uint64_t v42 = 0x500040300uLL >> (8 * a8);
    goto LABEL_34;
  }
  v352 = 0;
LABEL_36:
  if (a4)
  {
    uint64_t v43 = swift_allocObject(v354, 0x40uLL, 7uLL);
    *((_OWORD *)v43 + 1) = xmmword_18162AC80;
    char v44 = specialized static String._createEmpty(withInitialCapacity:)(5);
    uint64_t v46 = v45;
    *(void *)&v366 = v44;
    *((void *)&v366 + 1) = v45;
    uint64_t v47 = HIBYTE(v45) & 0xF;
    if ((v45 & 0x2000000000000000) == 0) {
      uint64_t v47 = v44 & 0xFFFFFFFFFFFFLL;
    }
    if (v47 || (v44 & ~v45 & 0x2000000000000000) != 0)
    {
      if ((v45 & 0x2000000000000000) == 0
        || (uint64_t v48 = specialized _SmallString.init(_:appending:)(v44, v45, 0, 0xE000000000000000), (v50 & 1) != 0))
      {
        _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
        swift_bridgeObjectRelease(0xE000000000000000);
        uint64_t v52 = *((void *)&v366 + 1);
        uint64_t v51 = v366;
LABEL_47:
        uint64_t v53 = HIBYTE(v52) & 0xF;
        if ((v52 & 0x2000000000000000) == 0) {
          uint64_t v53 = v51 & 0xFFFFFFFFFFFFLL;
        }
        if (v53 || (v51 & ~v52 & 0x2000000000000000) != 0)
        {
          if ((v52 & 0x2000000000000000) != 0
            && (a4 & 0x2000000000000000) != 0
            && (uint64_t v54 = specialized _SmallString.init(_:appending:)(v51, v52, a3, a4), (v56 & 1) == 0))
          {
            int v57 = v54;
            uint64_t v58 = v55;
            swift_bridgeObjectRelease(v52);
            *(void *)&v366 = v57;
            *((void *)&v366 + 1) = v58;
            a4 = v58;
            a3 = v57;
          }
          else
          {
            if ((a4 & 0x2000000000000000) != 0) {
              uint64_t v59 = HIBYTE(a4) & 0xF;
            }
            else {
              uint64_t v59 = a3 & 0xFFFFFFFFFFFFLL;
            }
            _StringGuts.append(_:)(a3, a4, 0, v59);
            a4 = *((void *)&v366 + 1);
            a3 = v366;
          }
          uint64_t v18 = a2;
        }
        else
        {
          swift_bridgeObjectRetain(a4);
          swift_bridgeObjectRelease(v52);
          *(void *)&v366 = a3;
          *((void *)&v366 + 1) = a4;
        }
        uint64_t v60 = 2112032;
        int v61 = HIBYTE(a4) & 0xF;
        if ((a4 & 0x2000000000000000) == 0) {
          int v61 = a3 & 0xFFFFFFFFFFFFLL;
        }
        if (v61 || (a3 & ~a4 & 0x2000000000000000) != 0)
        {
          if ((a4 & 0x2000000000000000) == 0
            || (uint64_t v62 = specialized _SmallString.init(_:appending:)(a3, a4, 0x203A20uLL, 0xE300000000000000),
                (v64 & 1) != 0))
          {
            _StringGuts.append(_:)(2112032, 0xE300000000000000, 0, 3);
            swift_bridgeObjectRelease(0xE300000000000000);
            uint64_t v65 = *((void *)&v366 + 1);
            uint64_t v60 = v366;
          }
          else
          {
            uint64_t v60 = v62;
            uint64_t v65 = v63;
            swift_bridgeObjectRelease(a4);
            swift_bridgeObjectRelease(0xE300000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(a4);
          uint64_t v65 = 0xE300000000000000;
        }
        v43[7] = &type metadata for String;
        v43[4] = v60;
        v43[5] = v65;
        specialized _print<A>(_:separator:terminator:to:)((uint64_t)v43, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, a11);
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(0xE100000000000000);
        swift_setDeallocating((uint64_t)v43);
        swift_arrayDestroy((uint64_t)(v43 + 4), 1, (unint64_t *)qword_1ECA06310);
        swift_deallocClassInstance((uint64_t)v43);
        uint64_t v41 = *(unsigned __int8 *)(v18 + 16);
        goto LABEL_69;
      }
      uint64_t v51 = v48;
      uint64_t v52 = v49;
      swift_bridgeObjectRelease(v46);
      swift_bridgeObjectRelease(0xE000000000000000);
      *(void *)&v366 = v51;
    }
    else
    {
      swift_bridgeObjectRelease(v45);
      uint64_t v51 = 0;
      uint64_t v52 = 0xE000000000000000;
      *(void *)&v366 = 0;
    }
    *((void *)&v366 + 1) = v52;
    goto LABEL_47;
  }
LABEL_69:
  uint64_t v66 = *(Class **)v18;
  switch(v41)
  {
    case 1:
      outlined init with copy of Any?(a1, (uint64_t)&v376);
      if (v378)
      {
        uint64_t v78 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
        if (swift_dynamicCast((char *)&v366, (unint64_t *)&v376, qword_1ECA06310, v78, 0)
          || (v104 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible),
              swift_dynamicCast((char *)&v366, (unint64_t *)&v376, qword_1ECA06310, v104, 0)))
        {
          outlined init with take of MirrorPath(&v366, (uint64_t)&v362);
          v105 = *((void *)&v363 + 1);
          v106 = v364;
          __swift_project_boxed_opaque_existential_0Tm(&v362, *((uint64_t *)&v363 + 1));
          uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 8))(v105, v106);
          unint64_t object = v107;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v362);
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v376);
          goto LABEL_265;
        }
        outlined init with take of Any(&v376, &v366);
        v131 = specialized static String._createEmpty(withInitialCapacity:)(10);
        v133 = v132;
        *(void *)&v362 = v131;
        *((void *)&v362 + 1) = v132;
        v134 = HIBYTE(v132) & 0xF;
        if ((v132 & 0x2000000000000000) == 0) {
          v134 = v131 & 0xFFFFFFFFFFFFLL;
        }
        if (v134 || (v131 & ~v132 & 0x2000000000000000) != 0)
        {
          if ((v132 & 0x2000000000000000) == 0
            || (v135 = specialized _SmallString.init(_:appending:)(v131, v132, 0x3CuLL, 0xE100000000000000),
                (v137 & 1) != 0))
          {
            _StringGuts.append(_:)(60, 0xE100000000000000, 0, 1);
            swift_bridgeObjectRelease(0xE100000000000000);
          }
          else
          {
            v138 = v135;
            v139 = v136;
            swift_bridgeObjectRelease(0xE100000000000000);
            swift_bridgeObjectRelease(v133);
            *(void *)&v362 = v138;
            *((void *)&v362 + 1) = v139;
          }
        }
        else
        {
          swift_bridgeObjectRelease(v132);
          *(void *)&v362 = 60;
          *((void *)&v362 + 1) = 0xE100000000000000;
        }
        v160 = (uint64_t *)*((void *)&v367 + 1);
        v161 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v366, *((uint64_t *)&v367 + 1));
        DynamicType = (Class *)swift_getDynamicType(v161, v160, 1);
        TypeName = (uint64_t *)swift_getTypeName(DynamicType, 0);
        if (v164 < 0) {
          goto LABEL_425;
        }
        v165 = (uint8x16_t *)TypeName;
        v166 = v164;
        v167 = validateUTF8(_:)(TypeName, v164);
        if (v169) {
          v170 = repairUTF8(_:firstKnownBrokenRange:)(v165->i8, v166, v167, v168);
        }
        else {
          v170 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v165, v166, v167 & 1);
        }
        v192 = v170;
        v193 = v171;
        v194 = *((void *)&v362 + 1);
        v195 = HIBYTE(*((void *)&v362 + 1)) & 0xFLL;
        if ((*((void *)&v362 + 1) & 0x2000000000000000) == 0) {
          v195 = v362 & 0xFFFFFFFFFFFFLL;
        }
        if (!v195 && ((unint64_t)v362 & ~*((void *)&v362 + 1) & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v362 + 1));
          *(void *)&v362 = v192;
          *((void *)&v362 + 1) = v193;
LABEL_382:
          v317 = HIBYTE(v193) & 0xF;
          if ((v193 & 0x2000000000000000) == 0) {
            v317 = v192 & 0xFFFFFFFFFFFFLL;
          }
          if (v317 || (v192 & ~v193 & 0x2000000000000000) != 0)
          {
            if ((v193 & 0x2000000000000000) == 0
              || (v318 = specialized _SmallString.init(_:appending:)(v192, v193, 0x7830203AuLL, 0xE400000000000000),
                  (v320 & 1) != 0))
            {
              _StringGuts.append(_:)(2016419898, 0xE400000000000000, 0, 4);
              swift_bridgeObjectRelease(0xE400000000000000);
            }
            else
            {
              v321 = v318;
              v322 = v319;
              swift_bridgeObjectRelease(v193);
              swift_bridgeObjectRelease(0xE400000000000000);
              *(void *)&v362 = v321;
              *((void *)&v362 + 1) = v322;
            }
          }
          else
          {
            swift_bridgeObjectRelease(v193);
            *(void *)&v362 = 2016419898;
            *((void *)&v362 + 1) = 0xE400000000000000;
          }
          v323 = (uint64_t *)*((void *)&v367 + 1);
          v324 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v366, *((uint64_t *)&v367 + 1));
          v325 = (uint64_t *)swift_getDynamicType(v324, v323, 1);
          if (swift_isClassType(v325)) {
            v326 = v325;
          }
          else {
            v326 = 0;
          }
          if (v326)
          {
            v327 = _unsafeDowncastToAnyObject(fromAny:)(&v366);
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v366);
            swift_unknownObjectRelease(v327);
          }
          else
          {
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v366);
            v327 = 0;
          }
          v329 = _int64ToString(_:radix:uppercase:)((uint64_t)v327, 16, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
          v330 = v328;
          v331 = *((void *)&v362 + 1);
          v332 = HIBYTE(*((void *)&v362 + 1)) & 0xFLL;
          if ((*((void *)&v362 + 1) & 0x2000000000000000) == 0) {
            v332 = v362 & 0xFFFFFFFFFFFFLL;
          }
          if (!v332 && ((unint64_t)v362 & ~*((void *)&v362 + 1) & 0x2000000000000000) == 0)
          {
            swift_bridgeObjectRelease(*((uint64_t *)&v362 + 1));
            *(void *)&v362 = v329;
            *((void *)&v362 + 1) = v330;
            goto LABEL_409;
          }
          if ((*((void *)&v362 + 1) & 0x2000000000000000) != 0)
          {
            if ((v328 & 0x2000000000000000) != 0)
            {
              v334 = specialized _SmallString.init(_:appending:)(v362, *((unint64_t *)&v362 + 1), v329, v328);
              if ((v336 & 1) == 0)
              {
                v337 = v334;
                v338 = v335;
                swift_bridgeObjectRelease(v330);
                swift_bridgeObjectRelease(v331);
                *(void *)&v362 = v337;
                *((void *)&v362 + 1) = v338;
                v330 = v338;
                v329 = v337;
LABEL_409:
                v339 = HIBYTE(v330) & 0xF;
                if ((v330 & 0x2000000000000000) == 0) {
                  v339 = v329 & 0xFFFFFFFFFFFFLL;
                }
                if (v339 || (v329 & ~v330 & 0x2000000000000000) != 0)
                {
                  if ((v330 & 0x2000000000000000) == 0
                    || (v340 = specialized _SmallString.init(_:appending:)(v329, v330, 0x3EuLL, 0xE100000000000000),
                        (v342 & 1) != 0))
                  {
                    _StringGuts.append(_:)(62, 0xE100000000000000, 0, 1);
                    swift_bridgeObjectRelease(0xE100000000000000);
                    unint64_t object = *((void *)&v362 + 1);
                    uint64_t countAndFlagsBits = v362;
                  }
                  else
                  {
                    uint64_t countAndFlagsBits = v340;
                    unint64_t object = v341;
                    swift_bridgeObjectRelease(v330);
                    swift_bridgeObjectRelease(0xE100000000000000);
                  }
                }
                else
                {
                  swift_bridgeObjectRelease(v330);
                  unint64_t object = 0xE100000000000000;
                  uint64_t countAndFlagsBits = 62;
                }
                goto LABEL_265;
              }
              goto LABEL_407;
            }
          }
          else if ((v328 & 0x2000000000000000) != 0)
          {
LABEL_407:
            v333 = HIBYTE(v330) & 0xF;
            goto LABEL_408;
          }
          v333 = v329 & 0xFFFFFFFFFFFFLL;
LABEL_408:
          _StringGuts.append(_:)(v329, v330, 0, v333);
          swift_bridgeObjectRelease(v330);
          v330 = *((void *)&v362 + 1);
          v329 = v362;
          goto LABEL_409;
        }
        if ((*((void *)&v362 + 1) & 0x2000000000000000) != 0)
        {
          if ((v171 & 0x2000000000000000) != 0)
          {
            v312 = specialized _SmallString.init(_:appending:)(v362, *((unint64_t *)&v362 + 1), v170, v171);
            if ((v314 & 1) == 0)
            {
              v315 = v312;
              v316 = v313;
              swift_bridgeObjectRelease(v194);
              swift_bridgeObjectRelease(v193);
              *(void *)&v362 = v315;
              *((void *)&v362 + 1) = v316;
              v193 = v316;
              v192 = v315;
              goto LABEL_382;
            }
            goto LABEL_380;
          }
        }
        else if ((v171 & 0x2000000000000000) != 0)
        {
LABEL_380:
          v196 = HIBYTE(v193) & 0xF;
          goto LABEL_381;
        }
        v196 = v170 & 0xFFFFFFFFFFFFLL;
LABEL_381:
        _StringGuts.append(_:)(v192, v193, 0, v196);
        swift_bridgeObjectRelease(v193);
        v193 = *((void *)&v362 + 1);
        v192 = v362;
        goto LABEL_382;
      }
      v98 = specialized static String._createEmpty(withInitialCapacity:)(2);
      v100 = v98;
      v101 = v99;
      *(void *)&v366 = v98;
      *((void *)&v366 + 1) = v99;
      v102 = HIBYTE(v99) & 0xF;
      v103 = v98 & 0xFFFFFFFFFFFFLL;
      if ((v99 & 0x2000000000000000) != 0) {
        v103 = HIBYTE(v99) & 0xF;
      }
      if (v103 || (v98 & ~v99 & 0x2000000000000000) != 0)
      {
        if ((v99 & 0x2000000000000000) == 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          swift_bridgeObjectRelease(0xE000000000000000);
          goto LABEL_238;
        }
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(v101);
        v129 = 0xA000000000000000;
        if (!(v101 & 0x80808080808080 | v100 & 0x8080808080808080)) {
          v129 = 0xE000000000000000;
        }
        v130 = v129 & 0xFF00000000000000 | (v102 << 56) | v101 & 0xFFFFFFFFFFFFFFLL;
        *(void *)&v366 = v100;
      }
      else
      {
        swift_bridgeObjectRelease(v99);
        v130 = 0xE000000000000000;
        *(void *)&v366 = 0;
      }
      *((void *)&v366 + 1) = v130;
LABEL_238:
      v197 = (uint64_t *)swift_getTypeName(v66, 0);
      if (v198 < 0) {
        goto LABEL_425;
      }
      v199 = (uint8x16_t *)v197;
      v200 = v198;
      v201 = validateUTF8(_:)(v197, v198);
      if (v203) {
        v204 = repairUTF8(_:firstKnownBrokenRange:)(v199->i8, v200, v201, v202);
      }
      else {
        v204 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v199, v200, v201 & 1);
      }
      uint64_t countAndFlagsBits = v204;
      v149 = v205;
      v206 = *((void *)&v366 + 1);
      v207 = HIBYTE(*((void *)&v366 + 1)) & 0xFLL;
      if ((*((void *)&v366 + 1) & 0x2000000000000000) == 0) {
        v207 = v366 & 0xFFFFFFFFFFFFLL;
      }
      if (v207 || ((unint64_t)v366 & ~*((void *)&v366 + 1) & 0x2000000000000000) != 0)
      {
        if ((*((void *)&v366 + 1) & 0x2000000000000000) != 0)
        {
          if ((v205 & 0x2000000000000000) != 0)
          {
            v209 = specialized _SmallString.init(_:appending:)(v366, *((unint64_t *)&v366 + 1), v204, v205);
            if ((v211 & 1) == 0)
            {
              v212 = v209;
              v213 = v210;
              swift_bridgeObjectRelease(v149);
              swift_bridgeObjectRelease(v206);
              *(void *)&v366 = v212;
              *((void *)&v366 + 1) = v213;
              v149 = v213;
              uint64_t countAndFlagsBits = v212;
              goto LABEL_255;
            }
            goto LABEL_253;
          }
        }
        else if ((v205 & 0x2000000000000000) != 0)
        {
LABEL_253:
          v208 = HIBYTE(v149) & 0xF;
          goto LABEL_254;
        }
        v208 = v204 & 0xFFFFFFFFFFFFLL;
LABEL_254:
        _StringGuts.append(_:)(countAndFlagsBits, v149, 0, v208);
        swift_bridgeObjectRelease(v149);
        v149 = *((void *)&v366 + 1);
        uint64_t countAndFlagsBits = v366;
        goto LABEL_255;
      }
      swift_bridgeObjectRelease(*((uint64_t *)&v366 + 1));
      *(void *)&v366 = countAndFlagsBits;
      *((void *)&v366 + 1) = v149;
LABEL_255:
      v158 = HIBYTE(v149) & 0xF;
      v214 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      if ((v149 & 0x2000000000000000) != 0) {
        v214 = HIBYTE(v149) & 0xF;
      }
      if (!v214 && (countAndFlagsBits & ~v149 & 0x2000000000000000) == 0) {
        goto LABEL_263;
      }
      if ((v149 & 0x2000000000000000) == 0) {
        goto LABEL_190;
      }
LABEL_260:
      swift_bridgeObjectRelease(v149);
      swift_bridgeObjectRelease(0xE000000000000000);
      v215 = 0xA000000000000000;
      if (!(v149 & 0x80808080808080 | countAndFlagsBits & 0x8080808080808080)) {
        v215 = 0xE000000000000000;
      }
      unint64_t object = v215 & 0xFF00000000000000 | (v158 << 56) | v149 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_264;
    case 3:
    case 5:
    case 6:
    case 7:
      if (v344 == 1)
      {
        uint64_t v67 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("1 element", 9uLL, 1);
        uint64_t countAndFlagsBits = v67._countAndFlagsBits;
        unint64_t object = (unint64_t)v67._object;
        goto LABEL_265;
      }
      uint64_t v71 = specialized static String._createEmpty(withInitialCapacity:)(11);
      uint64_t v73 = v71;
      uint64_t v74 = v72;
      *(void *)&v366 = v71;
      *((void *)&v366 + 1) = v72;
      v75 = HIBYTE(v72) & 0xF;
      uint64_t v76 = v71 & 0xFFFFFFFFFFFFLL;
      if ((v72 & 0x2000000000000000) != 0) {
        uint64_t v76 = HIBYTE(v72) & 0xF;
      }
      if (v76 || (v71 & ~v72 & 0x2000000000000000) != 0)
      {
        if ((v72 & 0x2000000000000000) == 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          swift_bridgeObjectRelease(0xE000000000000000);
          v77 = *((void *)&v366 + 1);
          uint64_t v73 = v366;
          goto LABEL_123;
        }
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(v74);
        v89 = 0xA000000000000000;
        if (!(v74 & 0x80808080808080 | v73 & 0x8080808080808080)) {
          v89 = 0xE000000000000000;
        }
        v77 = v89 & 0xFF00000000000000 | (v75 << 56) | v74 & 0xFFFFFFFFFFFFFFLL;
        *(void *)&v366 = v73;
      }
      else
      {
        swift_bridgeObjectRelease(v72);
        uint64_t v73 = 0;
        v77 = 0xE000000000000000;
        *(void *)&v366 = 0;
      }
      *((void *)&v366 + 1) = v77;
LABEL_123:
      v109 = _int64ToString(_:radix:uppercase:)(v344, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
      v110 = v108;
      v111 = HIBYTE(v77) & 0xF;
      if ((v77 & 0x2000000000000000) == 0) {
        v111 = v73 & 0xFFFFFFFFFFFFLL;
      }
      if (v111 || (v73 & ~v77 & 0x2000000000000000) != 0)
      {
        if ((v77 & 0x2000000000000000) != 0)
        {
          if ((v108 & 0x2000000000000000) != 0)
          {
            v113 = specialized _SmallString.init(_:appending:)(v73, v77, v109, v108);
            if ((v115 & 1) == 0)
            {
              v116 = v113;
              v117 = v114;
              swift_bridgeObjectRelease(v110);
              swift_bridgeObjectRelease(v77);
              *(void *)&v366 = v116;
              *((void *)&v366 + 1) = v117;
              v110 = v117;
              v109 = v116;
              goto LABEL_136;
            }
            goto LABEL_134;
          }
        }
        else if ((v108 & 0x2000000000000000) != 0)
        {
LABEL_134:
          v112 = HIBYTE(v110) & 0xF;
          goto LABEL_135;
        }
        v112 = v109 & 0xFFFFFFFFFFFFLL;
LABEL_135:
        _StringGuts.append(_:)(v109, v110, 0, v112);
        swift_bridgeObjectRelease(v110);
        v110 = *((void *)&v366 + 1);
        v109 = v366;
        goto LABEL_136;
      }
      swift_bridgeObjectRelease(v77);
      *(void *)&v366 = v109;
      *((void *)&v366 + 1) = v110;
LABEL_136:
      v118 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements", 9uLL, 1);
      uint64_t countAndFlagsBits = v118._countAndFlagsBits;
      unint64_t object = (unint64_t)v118._object;
      v119 = HIBYTE(v110) & 0xF;
      if ((v110 & 0x2000000000000000) == 0) {
        v119 = v109 & 0xFFFFFFFFFFFFLL;
      }
      if (!v119 && (v109 & ~v110 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v110);
        goto LABEL_265;
      }
      if ((v110 & 0x2000000000000000) != 0)
      {
        if (((uint64_t)v118._object & 0x2000000000000000) != 0)
        {
          v121 = specialized _SmallString.init(_:appending:)(v109, v110, v118._countAndFlagsBits, (unint64_t)v118._object);
          if ((v123 & 1) == 0)
          {
            v124 = v121;
            v125 = v122;
            swift_bridgeObjectRelease((uint64_t)v118._object);
            swift_bridgeObjectRelease(v110);
            uint64_t countAndFlagsBits = v124;
            unint64_t object = v125;
            goto LABEL_265;
          }
LABEL_147:
          v120 = ((unint64_t)v118._object >> 56) & 0xF;
LABEL_148:
          _StringGuts.append(_:)(v118._countAndFlagsBits, (unint64_t)v118._object, 0, v120);
          v126 = v118._object;
LABEL_149:
          swift_bridgeObjectRelease((uint64_t)v126);
          unint64_t object = *((void *)&v366 + 1);
          uint64_t countAndFlagsBits = v366;
          goto LABEL_265;
        }
      }
      else if (((uint64_t)v118._object & 0x2000000000000000) != 0)
      {
        goto LABEL_147;
      }
      v120 = v118._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_148;
    case 4:
      if (v344 < 1)
      {
        outlined init with copy of Any?(a1, (uint64_t)&v366);
        if (!*((void *)&v367 + 1)) {
          goto LABEL_267;
        }
        outlined init with take of Any(&v366, &v362);
        *(void *)&v376 = 0;
        *((void *)&v376 + 1) = 0xE000000000000000;
        _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v362, (uint64_t)&v376, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v362);
        unint64_t object = *((void *)&v376 + 1);
        uint64_t countAndFlagsBits = v376;
        goto LABEL_265;
      }
      uint64_t v79 = specialized static String._createEmpty(withInitialCapacity:)(2);
      int v81 = v79;
      v82 = v80;
      *(void *)&v366 = v79;
      *((void *)&v366 + 1) = v80;
      v83 = HIBYTE(v80) & 0xF;
      v84 = v79 & 0xFFFFFFFFFFFFLL;
      if ((v80 & 0x2000000000000000) != 0) {
        v84 = HIBYTE(v80) & 0xF;
      }
      if (v84 || (v79 & ~v80 & 0x2000000000000000) != 0)
      {
        if ((v80 & 0x2000000000000000) == 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          swift_bridgeObjectRelease(0xE000000000000000);
          goto LABEL_198;
        }
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(v82);
        v127 = 0xA000000000000000;
        if (!(v82 & 0x80808080808080 | v81 & 0x8080808080808080)) {
          v127 = 0xE000000000000000;
        }
        v128 = v127 & 0xFF00000000000000 | (v83 << 56) | v82 & 0xFFFFFFFFFFFFFFLL;
        *(void *)&v366 = v81;
      }
      else
      {
        swift_bridgeObjectRelease(v80);
        v128 = 0xE000000000000000;
        *(void *)&v366 = 0;
      }
      *((void *)&v366 + 1) = v128;
LABEL_198:
      v172 = (uint64_t *)swift_getTypeName(v66, 0);
      if (v173 < 0) {
        goto LABEL_425;
      }
      v174 = (uint8x16_t *)v172;
      v175 = v173;
      v176 = validateUTF8(_:)(v172, v173);
      if (v178) {
        v179 = repairUTF8(_:firstKnownBrokenRange:)(v174->i8, v175, v176, v177);
      }
      else {
        v179 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v174, v175, v176 & 1);
      }
      uint64_t countAndFlagsBits = v179;
      v181 = v180;
      v182 = *((void *)&v366 + 1);
      v183 = HIBYTE(*((void *)&v366 + 1)) & 0xFLL;
      if ((*((void *)&v366 + 1) & 0x2000000000000000) == 0) {
        v183 = v366 & 0xFFFFFFFFFFFFLL;
      }
      if (v183 || ((unint64_t)v366 & ~*((void *)&v366 + 1) & 0x2000000000000000) != 0)
      {
        if ((*((void *)&v366 + 1) & 0x2000000000000000) != 0)
        {
          if ((v180 & 0x2000000000000000) != 0)
          {
            v185 = specialized _SmallString.init(_:appending:)(v366, *((unint64_t *)&v366 + 1), v179, v180);
            if ((v187 & 1) == 0)
            {
              v188 = v185;
              v189 = v186;
              swift_bridgeObjectRelease(v181);
              swift_bridgeObjectRelease(v182);
              *(void *)&v366 = v188;
              *((void *)&v366 + 1) = v189;
              v181 = v189;
              uint64_t countAndFlagsBits = v188;
              goto LABEL_215;
            }
            goto LABEL_213;
          }
        }
        else if ((v180 & 0x2000000000000000) != 0)
        {
LABEL_213:
          v184 = HIBYTE(v181) & 0xF;
          goto LABEL_214;
        }
        v184 = v179 & 0xFFFFFFFFFFFFLL;
LABEL_214:
        _StringGuts.append(_:)(countAndFlagsBits, v181, 0, v184);
        swift_bridgeObjectRelease(v181);
        v181 = *((void *)&v366 + 1);
        uint64_t countAndFlagsBits = v366;
        goto LABEL_215;
      }
      swift_bridgeObjectRelease(*((uint64_t *)&v366 + 1));
      *(void *)&v366 = countAndFlagsBits;
      *((void *)&v366 + 1) = v181;
LABEL_215:
      v190 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      if ((v181 & 0x2000000000000000) != 0) {
        v190 = HIBYTE(v181) & 0xF;
      }
      if (v190 || (countAndFlagsBits & ~v181 & 0x2000000000000000) != 0)
      {
        if ((v181 & 0x2000000000000000) == 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          v126 = (void *)0xE000000000000000;
          goto LABEL_149;
        }
        swift_bridgeObjectRelease(v181);
        swift_bridgeObjectRelease(0xE000000000000000);
        v191 = 0xA000000000000000;
        if (!(v181 & 0x80808080808080 | countAndFlagsBits & 0x8080808080808080)) {
          v191 = 0xE000000000000000;
        }
        unint64_t object = v191 & 0xFF00000000000000 | ((HIBYTE(v181) & 0xF) << 56) | v181 & 0xFFFFFFFFFFFFFFLL;
      }
      else
      {
        swift_bridgeObjectRelease(v181);
        uint64_t countAndFlagsBits = 0;
        unint64_t object = 0xE000000000000000;
      }
      goto LABEL_265;
    default:
      outlined init with copy of Any?(a1, (uint64_t)&v376);
      if (!v378) {
        goto LABEL_99;
      }
      outlined init with copy of Any?((uint64_t)&v376, (uint64_t)&v370);
      uint64_t v70 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
      if (swift_dynamicCast((char *)&v366, (unint64_t *)&v370, qword_1ECA06310, v70, 0)
        || (uint64_t v85 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible),
            swift_dynamicCast((char *)&v366, (unint64_t *)&v370, qword_1ECA06310, v85, 0)))
      {
        outlined init with take of MirrorPath(&v366, (uint64_t)&v362);
        uint64_t v86 = *((void *)&v363 + 1);
        uint64_t v87 = v364;
        __swift_project_boxed_opaque_existential_0Tm(&v362, *((uint64_t *)&v363 + 1));
        uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v87 + 8))(v86, v87);
        unint64_t object = v88;
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v362);
        __swift_destroy_boxed_opaque_existential_1Tm(&v370);
        goto LABEL_264;
      }
      __swift_destroy_boxed_opaque_existential_1Tm(&v370);
LABEL_99:
      if (v344 < 1)
      {
        outlined init with copy of Any?(a1, (uint64_t)&v366);
        if (*((void *)&v367 + 1))
        {
          outlined init with take of Any(&v366, &v362);
          v370 = 0;
          v371 = 0xE000000000000000;
          _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v362, (uint64_t)&v370, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v362);
          uint64_t countAndFlagsBits = v370;
          unint64_t object = v371;
        }
        else
        {
          uint64_t countAndFlagsBits = 0;
          unint64_t object = 0;
        }
        goto LABEL_264;
      }
      v90 = specialized static String._createEmpty(withInitialCapacity:)(2);
      v92 = v90;
      v93 = v91;
      *(void *)&v366 = v90;
      *((void *)&v366 + 1) = v91;
      v94 = HIBYTE(v91) & 0xF;
      v95 = v90 & 0xFFFFFFFFFFFFLL;
      if ((v91 & 0x2000000000000000) != 0) {
        v95 = HIBYTE(v91) & 0xF;
      }
      if (v95 || (v90 & ~v91 & 0x2000000000000000) != 0)
      {
        if ((v91 & 0x2000000000000000) == 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          swift_bridgeObjectRelease(0xE000000000000000);
          goto LABEL_168;
        }
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(v93);
        v96 = 0xA000000000000000;
        if (!(v93 & 0x80808080808080 | v92 & 0x8080808080808080)) {
          v96 = 0xE000000000000000;
        }
        v97 = v96 & 0xFF00000000000000 | (v94 << 56) | v93 & 0xFFFFFFFFFFFFFFLL;
        *(void *)&v366 = v92;
      }
      else
      {
        swift_bridgeObjectRelease(v91);
        v97 = 0xE000000000000000;
        *(void *)&v366 = 0;
      }
      *((void *)&v366 + 1) = v97;
LABEL_168:
      v140 = (uint64_t *)swift_getTypeName(v66, 0);
      if (v141 < 0) {
        goto LABEL_425;
      }
      v142 = (uint8x16_t *)v140;
      v143 = v141;
      v144 = validateUTF8(_:)(v140, v141);
      if (v146) {
        v147 = repairUTF8(_:firstKnownBrokenRange:)(v142->i8, v143, v144, v145);
      }
      else {
        v147 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v142, v143, v144 & 1);
      }
      uint64_t countAndFlagsBits = v147;
      v149 = v148;
      v150 = *((void *)&v366 + 1);
      v151 = HIBYTE(*((void *)&v366 + 1)) & 0xFLL;
      if ((*((void *)&v366 + 1) & 0x2000000000000000) == 0) {
        v151 = v366 & 0xFFFFFFFFFFFFLL;
      }
      if (v151 || ((unint64_t)v366 & ~*((void *)&v366 + 1) & 0x2000000000000000) != 0)
      {
        if ((*((void *)&v366 + 1) & 0x2000000000000000) != 0)
        {
          if ((v148 & 0x2000000000000000) != 0)
          {
            v153 = specialized _SmallString.init(_:appending:)(v366, *((unint64_t *)&v366 + 1), v147, v148);
            if ((v155 & 1) == 0)
            {
              v156 = v153;
              v157 = v154;
              swift_bridgeObjectRelease(v149);
              swift_bridgeObjectRelease(v150);
              *(void *)&v366 = v156;
              *((void *)&v366 + 1) = v157;
              v149 = v157;
              uint64_t countAndFlagsBits = v156;
              goto LABEL_185;
            }
            goto LABEL_183;
          }
        }
        else if ((v148 & 0x2000000000000000) != 0)
        {
LABEL_183:
          v152 = HIBYTE(v149) & 0xF;
          goto LABEL_184;
        }
        v152 = v147 & 0xFFFFFFFFFFFFLL;
LABEL_184:
        _StringGuts.append(_:)(countAndFlagsBits, v149, 0, v152);
        swift_bridgeObjectRelease(v149);
        v149 = *((void *)&v366 + 1);
        uint64_t countAndFlagsBits = v366;
        goto LABEL_185;
      }
      swift_bridgeObjectRelease(*((uint64_t *)&v366 + 1));
      *(void *)&v366 = countAndFlagsBits;
      *((void *)&v366 + 1) = v149;
LABEL_185:
      v158 = HIBYTE(v149) & 0xF;
      v159 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      if ((v149 & 0x2000000000000000) != 0) {
        v159 = HIBYTE(v149) & 0xF;
      }
      if (v159 || (countAndFlagsBits & ~v149 & 0x2000000000000000) != 0)
      {
        if ((v149 & 0x2000000000000000) != 0) {
          goto LABEL_260;
        }
LABEL_190:
        _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
        swift_bridgeObjectRelease(0xE000000000000000);
        unint64_t object = *((void *)&v366 + 1);
        uint64_t countAndFlagsBits = v366;
      }
      else
      {
LABEL_263:
        swift_bridgeObjectRelease(v149);
        uint64_t countAndFlagsBits = 0;
        unint64_t object = 0xE000000000000000;
      }
LABEL_264:
      outlined destroy of Any?((uint64_t)&v376);
LABEL_265:
      if (object)
      {
        v216 = swift_allocObject(v354, 0x40uLL, 7uLL);
        *((_OWORD *)v216 + 1) = xmmword_18162AC80;
        v216[7] = &type metadata for String;
        v216[4] = countAndFlagsBits;
        v216[5] = object;
        specialized _print<A>(_:separator:terminator:to:)((uint64_t)v216, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, a11);
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(0xE100000000000000);
        swift_setDeallocating((uint64_t)v216);
        swift_arrayDestroy((uint64_t)(v216 + 4), 1, (unint64_t *)qword_1ECA06310);
        swift_deallocClassInstance((uint64_t)v216);
      }
LABEL_267:
      v217 = a6 < 1;
      v356 = a6 - 1;
      v218 = v346;
      if (v217) {
        v218 = 1;
      }
      if (v218)
      {
        v219 = swift_allocObject(v354, 0x40uLL, 7uLL);
        v220 = v219;
        *((_OWORD *)v219 + 1) = xmmword_18162AC80;
        v219[7] = &type metadata for String;
        v219[4] = 0;
        v221 = (uint64_t)(v219 + 4);
        v222 = 0xE000000000000000;
LABEL_272:
        v219[5] = v222;
        goto LABEL_273;
      }
      outlined init with copy of Any?(a1, (uint64_t)&v366);
      if (*((void *)&v367 + 1))
      {
        outlined init with take of Any(&v366, &v362);
        v223 = (uint64_t *)*((void *)&v363 + 1);
        v224 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v362, *((uint64_t *)&v363 + 1));
        v225 = (uint64_t *)swift_getDynamicType(v224, v223, 1);
        if (swift_isClassType(v225)) {
          v226 = v225;
        }
        else {
          v226 = 0;
        }
        v227 = a10;
        v228 = a2;
        if (v226)
        {
          v229 = _unsafeDowncastToAnyObject(fromAny:)(&v362);
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v362);
          swift_unknownObjectRelease(v229);
          if (specialized Set.contains(_:)((uint64_t)v229, *a9))
          {
            v219 = swift_allocObject(v354, 0x40uLL, 7uLL);
            v220 = v219;
            *((_OWORD *)v219 + 1) = xmmword_18162AC80;
            v219[7] = &type metadata for String;
            v219[4] = 0x7D202E2E2E207B20;
            v221 = (uint64_t)(v219 + 4);
            v222 = 0xE800000000000000;
            goto LABEL_272;
          }
          specialized Set._Variant.insert(_:)((uint64_t *)&v366, (uint64_t)v229);
        }
        else
        {
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v362);
        }
      }
      else
      {
        v227 = a10;
        v228 = a2;
      }
      v230 = swift_allocObject(v354, 0x40uLL, 7uLL);
      *((_OWORD *)v230 + 1) = xmmword_18162AC80;
      v230[7] = &type metadata for String;
      v230[4] = 0;
      v230[5] = 0xE000000000000000;
      specialized _print<A>(_:separator:terminator:to:)((uint64_t)v230, 0x20uLL, 0xE100000000000000, 10, (void *)0xE100000000000000, a11);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      swift_setDeallocating((uint64_t)v230);
      swift_arrayDestroy((uint64_t)(v230 + 4), 1, (unint64_t *)qword_1ECA06310);
      swift_deallocClassInstance((uint64_t)v230);
      v231 = *(void (**)(long long *__return_ptr, uint64_t))(v228 + 24);
      v232 = outlined retain of Mirror(v228);
      v231(&v366, v232);
      v233 = outlined release of Mirror(v228);
      v234 = v366;
      if ((void)v366)
      {
        v235 = *((void *)&v366 + 1);
        v237 = v367;
        v236 = v368;
        v376 = v366;
        v377 = v367;
        v378 = *((void *)&v367 + 1);
        v379 = v368;
        v380 = v369 & 1;
        v366 = 0u;
        v367 = 0u;
        if (__OFADD__(a5, 2)) {
          goto LABEL_424;
        }
        specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)(&v366, &v376, 0x7265707573, 0xE500000000000000, a5 + 2, v356, 0, 0, a9, v227, a11);
        outlined consume of Mirror?(v234, v235, v237, *((uint64_t *)&v237 + 1), v236);
        swift_bridgeObjectRelease(0xE500000000000000);
        v233 = outlined destroy of Any?((uint64_t)&v366);
      }
      v350 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 96))(v233);
      v347 = *(void (**)(long long *__return_ptr))(*(void *)v350 + 96);
      v347(&v362);
      outlined init with take of (key: AnyHashable, value: AnyHashable)?((uint64_t)&v362, (uint64_t)&v366, &demangling cache variable for type metadata for (label: String?, value: Any)?);
      if (!v369)
      {
LABEL_334:
        swift_release(v350);
        return;
      }
      v238 = 0;
      v239 = __OFADD__(a5, 2);
      v345 = v239;
      while (1)
      {
        v240 = *((void *)&v366 + 1);
        v241 = v366;
        outlined init with take of Any(&v367, v361);
        if (v240) {
          goto LABEL_324;
        }
        v242 = specialized static String._createEmpty(withInitialCapacity:)(2);
        v244 = v243;
        *(void *)&v362 = v242;
        *((void *)&v362 + 1) = v243;
        v245 = HIBYTE(v243) & 0xF;
        if ((v243 & 0x2000000000000000) == 0) {
          v245 = v242 & 0xFFFFFFFFFFFFLL;
        }
        if (v245 || (v242 & ~v243 & 0x2000000000000000) != 0)
        {
          if ((v243 & 0x2000000000000000) == 0
            || (v246 = specialized _SmallString.init(_:appending:)(v242, v243, 0, 0xE000000000000000),
                (v248 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            v250 = *((void *)&v362 + 1);
            v249 = v362;
            goto LABEL_303;
          }
          v249 = v246;
          v250 = v247;
          swift_bridgeObjectRelease(v244);
          swift_bridgeObjectRelease(0xE000000000000000);
          *(void *)&v362 = v249;
        }
        else
        {
          swift_bridgeObjectRelease(v243);
          v249 = 0;
          v250 = 0xE000000000000000;
          *(void *)&v362 = 0;
        }
        *((void *)&v362 + 1) = v250;
LABEL_303:
        v252 = _int64ToString(_:radix:uppercase:)(v238, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        v253 = v251;
        v254 = HIBYTE(v250) & 0xF;
        if ((v250 & 0x2000000000000000) == 0) {
          v254 = v249 & 0xFFFFFFFFFFFFLL;
        }
        if (!v254 && (v249 & ~v250 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v250);
          *(void *)&v362 = v252;
          *((void *)&v362 + 1) = v253;
          goto LABEL_316;
        }
        if ((v250 & 0x2000000000000000) == 0)
        {
          if ((v251 & 0x2000000000000000) != 0) {
LABEL_314:
          }
            v255 = HIBYTE(v253) & 0xF;
          else {
LABEL_311:
          }
            v255 = v252 & 0xFFFFFFFFFFFFLL;
          _StringGuts.append(_:)(v252, v253, 0, v255);
          swift_bridgeObjectRelease(v253);
          v253 = *((void *)&v362 + 1);
          v252 = v362;
          goto LABEL_316;
        }
        if ((v251 & 0x2000000000000000) == 0) {
          goto LABEL_311;
        }
        v256 = specialized _SmallString.init(_:appending:)(v249, v250, v252, v251);
        if (v258) {
          goto LABEL_314;
        }
        v259 = v256;
        v260 = v257;
        swift_bridgeObjectRelease(v250);
        swift_bridgeObjectRelease(v253);
        *(void *)&v362 = v259;
        *((void *)&v362 + 1) = v260;
        v253 = v260;
        v252 = v259;
LABEL_316:
        v261 = HIBYTE(v253) & 0xF;
        if ((v253 & 0x2000000000000000) == 0) {
          v261 = v252 & 0xFFFFFFFFFFFFLL;
        }
        if (v261 || (v252 & ~v253 & 0x2000000000000000) != 0)
        {
          if ((v253 & 0x2000000000000000) == 0
            || (v262 = specialized _SmallString.init(_:appending:)(v252, v253, 0, 0xE000000000000000),
                (v264 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            v240 = *((void *)&v362 + 1);
            v241 = v362;
          }
          else
          {
            v241 = v262;
            v240 = v263;
            swift_bridgeObjectRelease(v253);
            swift_bridgeObjectRelease(0xE000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v253);
          v241 = 0;
          v240 = 0xE000000000000000;
        }
LABEL_324:
        if (*v227 < 1) {
          break;
        }
        v265 = v26;
        outlined init with copy of Any((uint64_t)v361, (uint64_t)v360);
        outlined init with take of Any(v361, v359);
        outlined init with copy of Any((uint64_t)v359, (uint64_t)v358);
        v266 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
        if (swift_dynamicCast((char *)&v362, v358, qword_1ECA06310, v266, 6uLL))
        {
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v359);
          outlined init with take of MirrorPath(&v362, (uint64_t)v357);
          v268 = *(void *)&v357[2];
          v267 = *((void *)&v357[1] + 1);
          __swift_project_boxed_opaque_existential_0Tm(v357, *((uint64_t *)&v357[1] + 1));
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v268 + 8))(&v362, v267, v268);
          v269 = *((void *)&v362 + 1);
          v270 = v362;
          v271 = v363;
          v273 = *((void *)&v363 + 1);
          v272 = v364;
          v274 = v365;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v357);
        }
        else
        {
          v364 = 0;
          v362 = 0u;
          v363 = 0u;
          outlined destroy of _HasContiguousBytes?((uint64_t)&v362, &demangling cache variable for type metadata for CustomReflectable?);
          memset(v357, 0, 41);
          Mirror.init(internalReflecting:subjectType:customAncestor:)((swift::SwiftError **)v359, 0, (uint64_t)v357, (uint64_t)&v362);
          v269 = *((void *)&v362 + 1);
          v270 = v362;
          v271 = v363;
          v273 = *((void *)&v363 + 1);
          v272 = v364;
          v274 = v365;
        }
        v370 = v270;
        v371 = v269;
        v372 = v271;
        v373 = v273;
        v374 = v272;
        v375 = v274;
        if (v345)
        {
          __break(1u);
LABEL_423:
          __break(1u);
LABEL_424:
          __break(1u);
LABEL_425:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
        }
        uint64_t v26 = v265;
        v227 = a10;
        specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)(v360, &v370, v241, v240, a5 + 2, v356, 0, v352, a9, a10, v265);
        swift_release(v272);
        swift_release(v269);
        swift_bridgeObjectRelease(v240);
        v275 = outlined destroy of Any?((uint64_t)v360);
        if (__OFADD__(v238, 1)) {
          goto LABEL_423;
        }
        ((void (*)(long long *__return_ptr, uint64_t))v347)(&v362, v275);
        outlined init with take of (key: AnyHashable, value: AnyHashable)?((uint64_t)&v362, (uint64_t)&v366, &demangling cache variable for type metadata for (label: String?, value: Any)?);
        ++v238;
        if (!v369) {
          goto LABEL_334;
        }
      }
      __swift_destroy_boxed_opaque_existential_1Tm(v361);
      swift_release(v350);
      swift_bridgeObjectRelease(v240);
      v276 = swift_allocObject(v354, 0x40uLL, 7uLL);
      *((_OWORD *)v276 + 1) = xmmword_18162AC80;
      if (__OFADD__(a5, 4))
      {
        __break(1u);
        goto LABEL_427;
      }
      v277 = v276;
      v278 = specialized String.init(repeating:count:)(0x20uLL, 0xE100000000000000, a5 + 4);
      v277[7] = &type metadata for String;
      v277[4] = v278;
      v277[5] = v279;
      specialized _print<A>(_:separator:terminator:to:)((uint64_t)v277, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, v26);
      swift_bridgeObjectRelease(0xE000000000000000);
      swift_bridgeObjectRelease(0xE100000000000000);
      swift_setDeallocating((uint64_t)v277);
      swift_arrayDestroy((uint64_t)(v277 + 4), 1, (unint64_t *)qword_1ECA06310);
      swift_deallocClassInstance((uint64_t)v277);
      v280 = v344 - v238;
      if (__OFSUB__(v344, v238))
      {
LABEL_427:
        __break(1u);
        JUMPOUT(0x18122A778);
      }
      v281 = swift_allocObject(v354, 0x40uLL, 7uLL);
      *((_OWORD *)v281 + 1) = xmmword_18162AC80;
      v282 = specialized static String._createEmpty(withInitialCapacity:)(3);
      v284 = v283;
      *(void *)&v362 = v282;
      *((void *)&v362 + 1) = v283;
      v285 = HIBYTE(v283) & 0xF;
      if ((v283 & 0x2000000000000000) == 0) {
        v285 = v282 & 0xFFFFFFFFFFFFLL;
      }
      if (v285 || (v282 & ~v283 & 0x2000000000000000) != 0)
      {
        if ((v283 & 0x2000000000000000) != 0)
        {
          v286 = specialized _SmallString.init(_:appending:)(v282, v283, 0x28uLL, 0xE100000000000000);
          if ((v288 & 1) == 0)
          {
            v289 = v286;
            v290 = v287;
            swift_bridgeObjectRelease(v284);
            swift_bridgeObjectRelease(0xE100000000000000);
            goto LABEL_347;
          }
        }
        _StringGuts.append(_:)(40, 0xE100000000000000, 0, 1);
        swift_bridgeObjectRelease(0xE100000000000000);
        v290 = *((void *)&v362 + 1);
        v289 = v362;
      }
      else
      {
        swift_bridgeObjectRelease(v283);
        v289 = 40;
        v290 = 0xE100000000000000;
LABEL_347:
        *(void *)&v362 = v289;
        *((void *)&v362 + 1) = v290;
      }
      v292 = _int64ToString(_:radix:uppercase:)(v280, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
      v293 = v291;
      v294 = HIBYTE(v290) & 0xF;
      if ((v290 & 0x2000000000000000) == 0) {
        v294 = v289 & 0xFFFFFFFFFFFFLL;
      }
      if (v294 || (v289 & ~v290 & 0x2000000000000000) != 0)
      {
        if ((v290 & 0x2000000000000000) != 0)
        {
          if ((v291 & 0x2000000000000000) == 0) {
            goto LABEL_356;
          }
          v306 = v26;
          v307 = specialized _SmallString.init(_:appending:)(v289, v290, v292, v291);
          if (v309)
          {
            v295 = HIBYTE(v293) & 0xF;
            goto LABEL_357;
          }
          v310 = v307;
          v311 = v308;
          swift_bridgeObjectRelease(v290);
          swift_bridgeObjectRelease(v293);
          *(void *)&v362 = v310;
          *((void *)&v362 + 1) = v311;
          v293 = v311;
          v292 = v310;
          uint64_t v26 = v306;
        }
        else
        {
          if ((v291 & 0x2000000000000000) != 0)
          {
            v295 = HIBYTE(v291) & 0xF;
            goto LABEL_357;
          }
LABEL_356:
          v295 = v292 & 0xFFFFFFFFFFFFLL;
LABEL_357:
          _StringGuts.append(_:)(v292, v293, 0, v295);
          swift_bridgeObjectRelease(v293);
          v293 = *((void *)&v362 + 1);
          v292 = v362;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v290);
        *(void *)&v362 = v292;
        *((void *)&v362 + 1) = v293;
      }
      v296 = HIBYTE(v293) & 0xF;
      if ((v293 & 0x2000000000000000) == 0) {
        v296 = v292 & 0xFFFFFFFFFFFFLL;
      }
      if (v296 || (v292 & ~v293 & 0x2000000000000000) != 0)
      {
        if ((v293 & 0x2000000000000000) == 0
          || (v297 = specialized _SmallString.init(_:appending:)(v292, v293, 0, 0xE000000000000000), (v299 & 1) != 0))
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          swift_bridgeObjectRelease(0xE000000000000000);
          v301 = *((void *)&v362 + 1);
          v300 = v362;
        }
        else
        {
          v300 = v297;
          v301 = v298;
          swift_bridgeObjectRelease(v293);
          swift_bridgeObjectRelease(0xE000000000000000);
        }
      }
      else
      {
        swift_bridgeObjectRelease(v293);
        v300 = 0;
        v301 = 0xE000000000000000;
      }
      v281[7] = &type metadata for String;
      v281[4] = v300;
      v281[5] = v301;
      specialized _print<A>(_:separator:terminator:to:)((uint64_t)v281, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, v26);
      swift_bridgeObjectRelease(0xE000000000000000);
      swift_bridgeObjectRelease(0xE100000000000000);
      swift_setDeallocating((uint64_t)v281);
      swift_arrayDestroy((uint64_t)(v281 + 4), 1, (unint64_t *)qword_1ECA06310);
      swift_deallocClassInstance((uint64_t)v281);
      if (v238 >= 1)
      {
        v302 = swift_allocObject(v354, 0x40uLL, 7uLL);
        *((_OWORD *)v302 + 1) = xmmword_18162AC80;
        v302[7] = &type metadata for String;
        v302[4] = 0x65726F6D20;
        v302[5] = 0xE500000000000000;
        specialized _print<A>(_:separator:terminator:to:)((uint64_t)v302, 0x20uLL, 0xE100000000000000, 0, (void *)0xE000000000000000, v26);
        swift_bridgeObjectRelease(0xE000000000000000);
        swift_bridgeObjectRelease(0xE100000000000000);
        swift_setDeallocating((uint64_t)v302);
        swift_arrayDestroy((uint64_t)(v302 + 4), 1, (unint64_t *)qword_1ECA06310);
        swift_deallocClassInstance((uint64_t)v302);
      }
      v220 = swift_allocObject(v354, 0x40uLL, 7uLL);
      *((_OWORD *)v220 + 1) = xmmword_18162AC80;
      v221 = (uint64_t)(v220 + 4);
      if (v280 == 1)
      {
        v303 = (void *)0xE700000000000000;
        v304 = 0x29646C69686320;
      }
      else
      {
        v305 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" children)", 0xAuLL, 1);
        v303 = v305._object;
        v304 = v305._countAndFlagsBits;
      }
      v220[7] = &type metadata for String;
      v220[4] = v304;
      v220[5] = v303;
      v219 = v220;
LABEL_273:
      specialized _print<A>(_:separator:terminator:to:)((uint64_t)v219, 0x20uLL, 0xE100000000000000, 10, (void *)0xE100000000000000, v26);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      swift_setDeallocating((uint64_t)v220);
      swift_arrayDestroy(v221, 1, (unint64_t *)qword_1ECA06310);
      swift_deallocClassInstance((uint64_t)v220);
      return;
  }
}

uint64_t print<A>(_:separator:terminator:to:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _print<A>(_:separator:terminator:to:)(a1, a2, a3, a4, a5, a6, a7, a8, (void (*)(uint64_t *, uint64_t))_print_unlocked<A, B>(_:_:));
}

BOOL specialized Set.contains(_:)(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 16)) {
    return 0;
  }
  uint64_t v4 = specialized static Hasher._hash(seed:_:)(*(void *)(a2 + 40), a1);
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = v4 & ~v5;
  if (((*(void *)(a2 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) == 0) {
    return 0;
  }
  uint64_t v7 = ~v5;
  do
  {
    uint64_t v8 = *(void *)(*(void *)(a2 + 48) + 8 * v6);
    BOOL result = v8 == a1;
    if (v8 == a1) {
      break;
    }
    unint64_t v6 = (v6 + 1) & v7;
  }
  while (((*(void *)(a2 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
  return result;
}

uint64_t specialized Set.contains(_:)(unint64_t a1, unint64_t a2, uint64_t a3)
{
  if (!*(void *)(a3 + 16)) {
    return 0;
  }
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ *(void *)(a3 + 40);
  v19[0] = 0;
  v19[1] = v6 ^ 0x736F6D6570736575;
  v19[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v19[3] = v6 ^ 0x6C7967656E657261;
  v19[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v20 = 0u;
  long long v21 = 0u;
  String.hash(into:)(v19, a1, a2);
  Swift::Int v7 = Hasher._finalize()();
  uint64_t v8 = -1 << *(unsigned char *)(a3 + 32);
  unint64_t v9 = v7 & ~v8;
  uint64_t v10 = a3 + 56;
  if (((*(void *)(a3 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0) {
    return 0;
  }
  uint64_t v11 = ~v8;
  uint64_t v12 = *(void *)(a3 + 48);
  while (1)
  {
    uint64_t v13 = (uint64_t *)(v12 + 16 * v9);
    unint64_t v14 = v13[1];
    if (*v13 == a1 && v14 == a2) {
      break;
    }
    BOOL v16 = (~v14 & 0x6000000000000000) != 0 || (a2 & 0x2000000000000000) == 0;
    BOOL v17 = v16 || (a2 & 0x4000000000000000) == 0;
    if (v17 && (_stringCompareInternal(_:_:expecting:)(*v13, v14, a1, a2, 0) & 1) != 0) {
      break;
    }
    unint64_t v9 = (v9 + 1) & v11;
    if (((*(void *)(v10 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0) {
      return 0;
    }
  }
  return 1;
}

uint64_t specialized Set.contains(_:)(void *a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    uint64_t v2 = a2;
    uint64_t v4 = *(void *)(a2 + 40);
    uint64_t v5 = a1[3];
    uint64_t v6 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v5);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 8))(v27, v5, v6);
    uint64_t v7 = v28;
    uint64_t v8 = v29;
    __swift_project_boxed_opaque_existential_0Tm(v27, v28);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 40))(v4, v7, v8);
    __swift_destroy_boxed_opaque_existential_1Tm(v27);
    uint64_t v10 = -1 << *(unsigned char *)(v2 + 32);
    unint64_t v11 = v9 & ~v10;
    uint64_t v12 = v2 + 56;
    if ((*(void *)(v2 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11))
    {
      uint64_t v22 = ~v10;
      do
      {
        uint64_t v13 = v2;
        outlined init with copy of AnyHashable(*(void *)(v2 + 48) + 40 * v11, (uint64_t)v27);
        uint64_t v14 = v28;
        uint64_t v15 = v29;
        __swift_project_boxed_opaque_existential_0Tm(v27, v28);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v15 + 8))(v24, v14, v15);
        uint64_t v16 = v25;
        uint64_t v17 = v26;
        __swift_project_boxed_opaque_existential_0Tm(v24, v25);
        uint64_t v18 = a1[3];
        uint64_t v19 = a1[4];
        __swift_project_boxed_opaque_existential_0Tm(a1, v18);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v19 + 8))(v23, v18, v19);
        char v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v17 + 16))(v23, v16, v17);
        __swift_destroy_boxed_opaque_existential_1Tm(v23);
        if (v20 == 2)
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v24);
          outlined destroy of AnyHashable(v27);
        }
        else
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v24);
          outlined destroy of AnyHashable(v27);
          if (v20) {
            return 1;
          }
        }
        unint64_t v11 = (v11 + 1) & v22;
        uint64_t v2 = v13;
      }
      while (((*(void *)(v12 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11) & 1) != 0);
    }
  }
  return 0;
}

uint64_t Set.contains(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(a3 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v25 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v11 & 0xC000000000000001) != 0)
  {
    if (a2 < 0) {
      uint64_t v12 = (void *)a2;
    }
    else {
      uint64_t v12 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
    }
    uint64_t v13 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    id v14 = [v12 sel_member_:v13];
    swift_unknownObjectRelease(v13);
    if (v14)
    {
      swift_unknownObjectRelease(v14);
      char v15 = 1;
      return v15 & 1;
    }
LABEL_13:
    char v15 = 0;
    return v15 & 1;
  }
  if (!*(void *)(a2 + 16)) {
    goto LABEL_13;
  }
  uint64_t v16 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  uint64_t v17 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v18 = v16 & ~v17;
  uint64_t v30 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v18 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v18) & 1) == 0) {
    goto LABEL_13;
  }
  uint64_t v26 = ~v17;
  uint64_t v28 = *(void *)(a4 + 8);
  uint64_t v29 = a1;
  size_t v27 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v28 + 8);
  long long v21 = *(void (**)(char *, unint64_t, uint64_t *))(v8 + 16);
  uint64_t v20 = v8 + 16;
  uint64_t v19 = v21;
  uint64_t v22 = *(void *)(v20 + 56);
  char v23 = (void (**)(char *, uint64_t *))(v20 - 8);
  do
  {
    v19(v10, *(void *)(a2 + 48) + v22 * v18, a3);
    char v15 = v27(v10, v29, a3, v28);
    (*v23)(v10, a3);
    if (v15) {
      break;
    }
    unint64_t v18 = (v18 + 1) & v26;
  }
  while (((*(void *)(v30 + ((v18 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v18) & 1) != 0);
  return v15 & 1;
}

uint64_t AnyIterator.next()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 96))();
}

uint64_t Mirror.init(reflecting:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v17);
  uint64_t v4 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
  if (swift_dynamicCast(v15, v17, qword_1ECA06310, v4, 6uLL))
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    outlined init with take of MirrorPath((long long *)v15, (uint64_t)v14);
    uint64_t v6 = *(void *)&v14[2];
    uint64_t v5 = *((void *)&v14[1] + 1);
    __swift_project_boxed_opaque_existential_0Tm(v14, *((uint64_t *)&v14[1] + 1));
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(v6 + 8))(v15, v5, v6);
    char v7 = v15[16];
    long long v12 = *(_OWORD *)&v15[24];
    long long v13 = *(_OWORD *)v15;
    char v8 = v16;
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v14);
    long long v11 = v12;
    long long v10 = v13;
  }
  else
  {
    memset(v15, 0, sizeof(v15));
    outlined destroy of _HasContiguousBytes?((uint64_t)v15, &demangling cache variable for type metadata for CustomReflectable?);
    memset(v14, 0, 41);
    uint64_t result = Mirror.init(internalReflecting:subjectType:customAncestor:)((swift::SwiftError **)a1, 0, (uint64_t)v14, (uint64_t)v15);
    long long v10 = *(_OWORD *)v15;
    char v7 = v15[16];
    long long v11 = *(_OWORD *)&v15[24];
    char v8 = v16;
  }
  *(_OWORD *)a2 = v10;
  *(unsigned char *)(a2 + 16) = v7;
  *(_OWORD *)(a2 + 24) = v11;
  *(unsigned char *)(a2 + 40) = v8;
  return result;
}

uint64_t (*Dictionary._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Dictionary.init(_cocoa:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000 | a1;
}

uint64_t Dictionary._Variant.init(cocoa:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000 | a1;
}

uint64_t Dictionary.init(_immutableCocoaDictionary:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000 | a1;
}

__objc2_class **_NativeDictionary.init()()
{
  return &_swiftEmptyDictionarySingleton;
}

__objc2_class **Dictionary.init(minimumCapacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptyDictionarySingleton;
  }
  type metadata accessor for _DictionaryStorage(0, a2, a3, a4);
  return (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a1);
}

__objc2_class **_NativeDictionary.init(capacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptyDictionarySingleton;
  }
  type metadata accessor for _DictionaryStorage(0, a2, a3, a4);
  return (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a1);
}

__objc2_class **Dictionary.init<A>(uniqueKeysWithValues:)(uint64_t a1, uint64_t a2, uint64_t a3, Class *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (uint64_t)*(a4 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](a1);
  uint64_t v36 = (char *)&v33 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  char v16 = (unint64_t *)((char *)&v33 - v15);
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v17((char *)&v33 - v15, a1, v18);
  uint64_t v37 = a3;
  uint64_t v38 = (uint64_t *)a5;
  uint64_t v19 = type metadata accessor for Dictionary(0, a2, a3, a5);
  if (swift_dynamicCast((char *)&v39, v16, a4, (const char *)v19, 6uLL))
  {
    (*(void (**)(uint64_t, Class *))(v12 + 8))(a1, a4);
  }
  else
  {
    uint64_t v20 = *(uint64_t (**)(Class *, uint64_t))(a6 + 40);
    uint64_t v34 = a1;
    uint64_t v35 = a6;
    uint64_t v21 = v20(a4, a6);
    if (v21)
    {
      uint64_t v22 = v21;
      uint64_t v24 = v37;
      uint64_t v23 = (uint64_t)v38;
      type metadata accessor for _DictionaryStorage(0, a2, v37, (uint64_t)v38);
      uint64_t v25 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(v22);
    }
    else
    {
      uint64_t v25 = &_swiftEmptyDictionarySingleton;
      uint64_t v24 = v37;
      uint64_t v23 = (uint64_t)v38;
    }
    unint64_t v39 = v25;
    uint64_t v26 = (uint64_t)v36;
    uint64_t v27 = v34;
    uint64_t v28 = ((uint64_t (*)(char *, uint64_t, Class *))v17)(v36, v34, a4);
    uint64_t v38 = &v33;
    MEMORY[0x1F4188790](v28);
    *(&v33 - 6) = a2;
    *(&v33 - 5) = v24;
    *(&v33 - 4) = (uint64_t)a4;
    *(&v33 - 3) = v23;
    uint64_t v29 = v35;
    *(&v33 - 2) = v35;
    uint64_t v30 = type metadata accessor for _NativeDictionary(0, a2, v24, v23);
    specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)(v26, 1, (void (*)(char *, char *))partial apply for closure #1 in Dictionary.init<A>(uniqueKeysWithValues:), (uint64_t)(&v33 - 8), (uint64_t)v30, (uint64_t)a4, v29);
    uint64_t v31 = *(void (**)(uint64_t, Class *))(v12 + 8);
    v31(v26, a4);
    v31(v27, a4);
  }
  return v39;
}

uint64_t _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)(uint64_t a1, char a2, void (*a3)(char *, char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a6 - 8) + 8))(a1, a6);
}

void swift_unexpectedError(void *a1, const char *a2, uint64_t a3, char a4, unint64_t a5)
{
  unint64_t v10 = 0xD000000000000030;
  unint64_t v11 = specialized static String._createEmpty(withInitialCapacity:)(50);
  uint64_t v13 = v12;
  unint64_t v37 = v11;
  unint64_t v38 = v12;
  uint64_t v14 = HIBYTE(v12) & 0xF;
  if ((v12 & 0x2000000000000000) == 0) {
    uint64_t v14 = v11 & 0xFFFFFFFFFFFFLL;
  }
  if (v14 || (v11 & ~v12 & 0x2000000000000000) != 0)
  {
    if ((v12 & 0x2000000000000000) == 0
      || ((unint64_t)"Swift/CString.swift" & 0x2000000000000000) == 0
      || (unint64_t v16 = specialized _SmallString.init(_:appending:)(v11, v12, 0xD000000000000030, 0x80000001816DDDB0),
          (v18 & 1) != 0))
    {
      if (((unint64_t)"Swift/CString.swift" & 0x2000000000000000) != 0) {
        unint64_t v19 = (0x80000001816DDDB0 >> 56) & 0xF;
      }
      else {
        unint64_t v19 = 48;
      }
      _StringGuts.append(_:)(0xD000000000000030, 0x80000001816DDDB0, 0, v19);
      unint64_t v10 = v37;
      unint64_t v15 = v38;
LABEL_15:
      unint64_t v34 = 0;
      unint64_t v35 = 0xE000000000000000;
      uint64_t v36 = a1;
      uint64_t v20 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
      _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v36, (uint64_t)&v34, v20, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
      swift_errorRelease(a1);
      uint64_t v21 = v34;
      unint64_t v22 = v35;
      uint64_t v23 = HIBYTE(v15) & 0xF;
      if ((v15 & 0x2000000000000000) == 0) {
        uint64_t v23 = v10 & 0xFFFFFFFFFFFFLL;
      }
      if (!v23 && (v10 & ~v15 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v15);
        unint64_t v37 = v21;
        unint64_t v38 = v22;
        goto LABEL_29;
      }
      if ((v15 & 0x2000000000000000) != 0)
      {
        if ((v35 & 0x2000000000000000) != 0)
        {
          unint64_t v25 = specialized _SmallString.init(_:appending:)(v10, v15, v34, v35);
          if ((v27 & 1) == 0)
          {
            unint64_t v28 = v25;
            unint64_t v29 = v26;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(v22);
            unint64_t v37 = v28;
            unint64_t v38 = v29;
            unint64_t v22 = v29;
            uint64_t v21 = v28;
            goto LABEL_29;
          }
          goto LABEL_27;
        }
      }
      else if ((v35 & 0x2000000000000000) != 0)
      {
LABEL_27:
        uint64_t v24 = HIBYTE(v22) & 0xF;
        goto LABEL_28;
      }
      uint64_t v24 = v34 & 0xFFFFFFFFFFFFLL;
LABEL_28:
      _StringGuts.append(_:)(v21, v22, 0, v24);
      swift_bridgeObjectRelease(v22);
      uint64_t v21 = v37;
      unint64_t v22 = v38;
LABEL_29:
      uint64_t v30 = v21 & 0xFFFFFFFFFFFFLL;
      if ((v22 & 0x2000000000000000) != 0) {
        uint64_t v30 = HIBYTE(v22) & 0xF;
      }
      if (v30 || (v21 & ~v22 & 0x2000000000000000) != 0)
      {
        if ((v22 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v22);
          unint64_t v32 = 0xA000000000000000;
          if (!(v22 & 0x80808080808080 | v21 & 0x8080808080808080)) {
            unint64_t v32 = 0xE000000000000000;
          }
          unint64_t v31 = v32 & 0xFF00000000000000 | ((HIBYTE(v22) & 0xF) << 56) | v22 & 0xFFFFFFFFFFFFFFLL;
        }
        else
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          uint64_t v21 = v37;
          unint64_t v31 = v38;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v22);
        uint64_t v21 = 0;
        unint64_t v31 = 0xE000000000000000;
      }
      if (a4) {
        char v33 = 2;
      }
      else {
        char v33 = 0;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v21, v31, a2, a3, v33, a5, 0);
    }
    unint64_t v10 = v16;
    unint64_t v15 = v17;
    swift_bridgeObjectRelease(v13);
  }
  else
  {
    swift_bridgeObjectRelease(v12);
    unint64_t v15 = 0x80000001816DDDB0;
  }
  unint64_t v37 = v10;
  unint64_t v38 = v15;
  goto LABEL_15;
}

uint64_t Dictionary.init<A>(_:uniquingKeysWith:)(uint64_t a1, void (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = a3;
  char v27 = a2;
  uint64_t v14 = *(void *)(a6 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v16 = (char *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 40))(v18, v17);
  if (v19)
  {
    uint64_t v20 = v19;
    type metadata accessor for _DictionaryStorage(0, a4, a5, a7);
    uint64_t v21 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(v20);
  }
  else
  {
    uint64_t v21 = &_swiftEmptyDictionarySingleton;
  }
  uint64_t v30 = v21;
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 32))(v16, a1, a6);
  unint64_t v22 = type metadata accessor for _NativeDictionary(0, a4, a5, a7);
  uint64_t v23 = v29;
  specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)((uint64_t)v16, 1, v27, v28, (uint64_t)v22, a6, a8);
  (*(void (**)(char *, uint64_t))(v14 + 8))(v16, a6);
  uint64_t v24 = (uint64_t)v30;
  if (v23) {
    swift_release((uint64_t)v30);
  }
  return v24;
}

__objc2_class **Dictionary.init<A>(grouping:by:)(uint64_t a1, void (*a2)(char *), uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v88 = a4;
  uint64_t v83 = a6;
  uint64_t v79 = a2;
  uint64_t v80 = a3;
  uint64_t v69 = *(void *)(a4 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v68 = (char *)&v64 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  unint64_t v12 = (char *)&v64 - v11;
  AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, v13, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v70 = *(AssociatedTypeWitness - 1);
  uint64_t v15 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v67 = (char *)&v64 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v86 = (char *)&v64 - v17;
  uint64_t v20 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v18, v19);
  MEMORY[0x1F4188790](v20 - 1);
  unint64_t v22 = (char *)&v64 - v21;
  uint64_t v23 = swift_getAssociatedTypeWitness(0, (int **)a7, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v64 = *((void *)v23 - 1);
  MEMORY[0x1F4188790](v23);
  unint64_t v25 = (char *)&v64 - v24;
  v89 = &_swiftEmptyDictionarySingleton;
  (*(void (**)(uint64_t, uint64_t))(a7 + 32))(a5, a7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a5, (uint64_t)v23, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  char v27 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  int v81 = v25;
  v82 = v23;
  uint64_t v77 = AssociatedConformanceWitness + 16;
  uint64_t v78 = AssociatedConformanceWitness;
  uint64_t v76 = v27;
  ((void (*)(const char *))v27)(v23);
  uint64_t v28 = v70;
  uint64_t v74 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v70 + 48);
  uint64_t v75 = v70 + 48;
  if (v74(v22, 1, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, const char *))(v64 + 8))(v81, v82);
    return v89;
  }
  else
  {
    v84 = *(void (**)(char *, char *, uint64_t *))(v28 + 32);
    uint64_t v85 = v28 + 32;
    uint64_t v66 = v69 + 32;
    uint64_t v65 = (void (**)(char *, unint64_t))(v69 + 8);
    uint64_t v30 = (atomic_ullong *)&_swiftEmptyDictionarySingleton;
    uint64_t v72 = AssociatedTypeWitness;
    uint64_t v73 = v12;
    uint64_t v71 = v22;
    uint64_t v31 = v69;
    while (1)
    {
      uint64_t v36 = v86;
      v84(v86, v22, AssociatedTypeWitness);
      uint64_t v37 = v87;
      v79(v36);
      uint64_t v87 = v37;
      if (v37) {
        break;
      }
      unint64_t v38 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v12, v88, v83);
      atomic_ullong v42 = v30[2];
      BOOL v43 = (v39 & 1) == 0;
      Swift::Int v44 = v42 + v43;
      if (__OFADD__(v42, v43))
      {
        __break(1u);
LABEL_16:
        __break(1u);
LABEL_17:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v88);
      }
      unint64_t v45 = v38;
      char v46 = v39;
      if (v30[3] < v44)
      {
        uint64_t v47 = type metadata accessor for Array(255, (uint64_t)AssociatedTypeWitness, v40, v41);
        uint64_t v48 = (uint64_t)v12;
        uint64_t v49 = v88;
        uint64_t v50 = v83;
        type metadata accessor for _NativeDictionary(0, v88, (uint64_t)v47, v83);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v44, 1);
        uint64_t v30 = (atomic_ullong *)v89;
        unint64_t v51 = __RawDictionaryStorage.find<A>(_:)(v48, v49, v50);
        if ((v46 & 1) != (v52 & 1)) {
          goto LABEL_17;
        }
        unint64_t v45 = v51;
        AssociatedTypeWitness = v72;
        unint64_t v12 = v73;
        unint64_t v22 = v71;
      }
      if (v46)
      {
        (*v65)(v12, v88);
        uint64_t v30 = (atomic_ullong *)v89;
        uint64_t v32 = (uint64_t)v67;
        v84(v67, v86, AssociatedTypeWitness);
        unint64_t v35 = type metadata accessor for Array(0, (uint64_t)AssociatedTypeWitness, v33, v34);
        Array.append(_:)(v32, (uint64_t)v35);
      }
      else
      {
        uint64_t v53 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
        uint64_t v54 = v68;
        char v55 = v12;
        unint64_t v56 = v88;
        v53(v68, v55, v88);
        int v57 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v58 = swift_allocObject((unint64_t *)v57, ((*(unsigned __int8 *)(v70 + 80) + (unint64_t)*((unsigned int *)v57 + 12)) & ~(unint64_t)*(unsigned __int8 *)(v70 + 80))+ *(void *)(v70 + 72), *(unsigned __int8 *)(v70 + 80) | (unint64_t)*((unsigned __int16 *)v57 + 26));
        swift_retain(v30);
        uint64_t v59 = static Array._adoptStorage(_:count:)(v58, 1);
        v84(v60, v86, AssociatedTypeWitness);
        v30[(v45 >> 6) + 8] |= 1 << v45;
        v53((char *)(v30[6] + *(void *)(v31 + 72) * v45), v54, v56);
        *(void *)(v30[7] + 8 * v45) = v59;
        atomic_ullong v61 = v30[2];
        BOOL v62 = __OFADD__(v61, 1);
        atomic_ullong v63 = v61 + 1;
        if (v62) {
          goto LABEL_16;
        }
        v30[2] = v63;
        swift_release((uint64_t)v30);
        AssociatedTypeWitness = v72;
        unint64_t v12 = v73;
        unint64_t v22 = v71;
      }
      v76(v82, v78);
      if (v74(v22, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }
    (*(void (**)(char *, uint64_t *))(v70 + 8))(v86, AssociatedTypeWitness);
    (*(void (**)(char *, const char *))(v64 + 8))(v81, v82);
    return (__objc2_class **)swift_release((uint64_t)v89);
  }
}

__objc2_class **_NativeDictionary.init<A>(grouping:by:)(uint64_t a1, void (*a2)(char *), uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v88 = a4;
  uint64_t v83 = a6;
  uint64_t v79 = a2;
  uint64_t v80 = a3;
  uint64_t v69 = *(void *)(a4 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v68 = (char *)&v64 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  unint64_t v12 = (char *)&v64 - v11;
  AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, v13, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v70 = *(AssociatedTypeWitness - 1);
  uint64_t v15 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v67 = (char *)&v64 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v86 = (char *)&v64 - v17;
  uint64_t v20 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v18, v19);
  MEMORY[0x1F4188790](v20 - 1);
  unint64_t v22 = (char *)&v64 - v21;
  uint64_t v23 = swift_getAssociatedTypeWitness(0, (int **)a7, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v64 = *((void *)v23 - 1);
  MEMORY[0x1F4188790](v23);
  unint64_t v25 = (char *)&v64 - v24;
  v89 = &_swiftEmptyDictionarySingleton;
  (*(void (**)(uint64_t, uint64_t))(a7 + 32))(a5, a7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a5, (uint64_t)v23, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  char v27 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  int v81 = v25;
  v82 = v23;
  uint64_t v77 = AssociatedConformanceWitness + 16;
  uint64_t v78 = AssociatedConformanceWitness;
  uint64_t v76 = v27;
  ((void (*)(const char *))v27)(v23);
  uint64_t v28 = v70;
  uint64_t v74 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v70 + 48);
  uint64_t v75 = v70 + 48;
  if (v74(v22, 1, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, const char *))(v64 + 8))(v81, v82);
    return v89;
  }
  else
  {
    v84 = *(void (**)(char *, char *, uint64_t *))(v28 + 32);
    uint64_t v85 = v28 + 32;
    uint64_t v66 = v69 + 32;
    uint64_t v65 = (void (**)(char *, unint64_t))(v69 + 8);
    uint64_t v30 = (atomic_ullong *)&_swiftEmptyDictionarySingleton;
    uint64_t v72 = AssociatedTypeWitness;
    uint64_t v73 = v12;
    uint64_t v71 = v22;
    uint64_t v31 = v69;
    while (1)
    {
      uint64_t v36 = v86;
      v84(v86, v22, AssociatedTypeWitness);
      uint64_t v37 = v87;
      v79(v36);
      uint64_t v87 = v37;
      if (v37) {
        break;
      }
      unint64_t v38 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v12, v88, v83);
      atomic_ullong v42 = v30[2];
      BOOL v43 = (v39 & 1) == 0;
      Swift::Int v44 = v42 + v43;
      if (__OFADD__(v42, v43))
      {
        __break(1u);
LABEL_16:
        __break(1u);
LABEL_17:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v88);
      }
      unint64_t v45 = v38;
      char v46 = v39;
      if (v30[3] < v44)
      {
        uint64_t v47 = type metadata accessor for Array(255, (uint64_t)AssociatedTypeWitness, v40, v41);
        uint64_t v48 = (uint64_t)v12;
        uint64_t v49 = v88;
        uint64_t v50 = v83;
        type metadata accessor for _NativeDictionary(0, v88, (uint64_t)v47, v83);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v44, 1);
        uint64_t v30 = (atomic_ullong *)v89;
        unint64_t v51 = __RawDictionaryStorage.find<A>(_:)(v48, v49, v50);
        if ((v46 & 1) != (v52 & 1)) {
          goto LABEL_17;
        }
        unint64_t v45 = v51;
        AssociatedTypeWitness = v72;
        unint64_t v12 = v73;
        unint64_t v22 = v71;
      }
      if (v46)
      {
        (*v65)(v12, v88);
        uint64_t v30 = (atomic_ullong *)v89;
        uint64_t v32 = (uint64_t)v67;
        v84(v67, v86, AssociatedTypeWitness);
        unint64_t v35 = type metadata accessor for Array(0, (uint64_t)AssociatedTypeWitness, v33, v34);
        Array.append(_:)(v32, (uint64_t)v35);
      }
      else
      {
        uint64_t v53 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
        uint64_t v54 = v68;
        char v55 = v12;
        unint64_t v56 = v88;
        v53(v68, v55, v88);
        int v57 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v58 = swift_allocObject((unint64_t *)v57, ((*(unsigned __int8 *)(v70 + 80) + (unint64_t)*((unsigned int *)v57 + 12)) & ~(unint64_t)*(unsigned __int8 *)(v70 + 80))+ *(void *)(v70 + 72), *(unsigned __int8 *)(v70 + 80) | (unint64_t)*((unsigned __int16 *)v57 + 26));
        swift_retain(v30);
        uint64_t v59 = static Array._adoptStorage(_:count:)(v58, 1);
        v84(v60, v86, AssociatedTypeWitness);
        v30[(v45 >> 6) + 8] |= 1 << v45;
        v53((char *)(v30[6] + *(void *)(v31 + 72) * v45), v54, v56);
        *(void *)(v30[7] + 8 * v45) = v59;
        atomic_ullong v61 = v30[2];
        BOOL v62 = __OFADD__(v61, 1);
        atomic_ullong v63 = v61 + 1;
        if (v62) {
          goto LABEL_16;
        }
        v30[2] = v63;
        swift_release((uint64_t)v30);
        AssociatedTypeWitness = v72;
        unint64_t v12 = v73;
        unint64_t v22 = v71;
      }
      v76(v82, v78);
      if (v74(v22, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }
    (*(void (**)(char *, uint64_t *))(v70 + 8))(v86, AssociatedTypeWitness);
    (*(void (**)(char *, const char *))(v64 + 8))(v81, v82);
    return (__objc2_class **)swift_release((uint64_t)v89);
  }
}

int64_t Dictionary._Variant.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v4 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0;
    uint64_t result = v5 | 0x8000000000000000;
  }
  else
  {
    uint64_t v9 = -1;
    uint64_t v10 = -1 << *(unsigned char *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1 << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }
  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0;
  a2[4] = v8;
  return result;
}

__objc2_class **Dictionary.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = (char *)a5;
  uint64_t v8 = (char *)a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a4, a5, "key value ", 0);
  uint64_t v103 = *(TupleTypeMetadata2 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  v121 = (char *)&v91 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v122 = (char *)&v91 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v123 = (char *)&v91 - v18;
  MEMORY[0x1F4188790](v17);
  v136 = (char *)&v91 - v19;
  v100 = type metadata accessor for Optional(0, (uint64_t)v7, v20, v21);
  v135 = (void (**)(char *, char *, char *))*(v100 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v100);
  uint64_t v24 = (char *)&v91 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v22);
  v124 = (char *)&v91 - v25;
  v99 = type metadata accessor for Optional(0, (uint64_t)v8, v26, v27);
  uint64_t v28 = (uint64_t)*(v99 - 1);
  uint64_t v29 = MEMORY[0x1F4188790](v99);
  v98 = (char *)&v91 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v29);
  v101 = (char *)&v91 - v31;
  uint64_t v109 = *((void *)v7 - 1);
  v125 = TupleTypeMetadata2;
  uint64_t v34 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v32, v33);
  MEMORY[0x1F4188790](v34 - 1);
  uint64_t v36 = (char *)&v91 - v35;
  if ((a3 & 0xC000000000000001) != 0)
  {
    uint64_t v108 = a6;
    v137 = v36;
    uint64_t v120 = a2;
    v140 = &_swiftEmptyDictionarySingleton;
    if (a3 < 0) {
      uint64_t v37 = a3;
    }
    else {
      uint64_t v37 = a3 & 0xFFFFFFFFFFFFFF8;
    }
    unint64_t v38 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v39 = (unint64_t)swift_allocObject(v38, 0xE8uLL, 7uLL);
    *(_OWORD *)(v39 + 16) = 0u;
    *(_OWORD *)(v39 + 32) = 0u;
    *(_OWORD *)(v39 + 48) = 0u;
    *(_OWORD *)(v39 + 64) = 0u;
    *(_OWORD *)(v39 + 80) = 0u;
    *(_OWORD *)(v39 + 96) = 0u;
    *(_OWORD *)(v39 + 112) = 0u;
    *(_OWORD *)(v39 + 128) = 0u;
    *(_OWORD *)(v39 + 144) = 0u;
    *(_OWORD *)(v39 + 160) = 0u;
    *(_OWORD *)(v39 + 176) = 0u;
    *(_OWORD *)(v39 + 192) = 0u;
    *(void *)(v39 + 216) = 0;
    *(void *)(v39 + 224) = 0;
    *(void *)(v39 + 208) = v37;
    unint64_t v102 = v39 | 0x8000000000000000;
    uint64_t v40 = v39 & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v41 = *(void *)((v39 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8);
    if ((v41 & 0x8000000000000000) == 0)
    {
      uint64_t v106 = v40 + 16;
      uint64_t v105 = v40 + 80;
      v119 = v8 - 8;
      v97 = (void (**)(char *, char *, Class *))(v28 + 16);
      v96 = (void (**)(char *, Class *))(v28 + 8);
      v95 = (void (**)(void *, uint64_t, uint64_t, char *))(v109 + 56);
      v94 = (void (**)(char *, void *, Class *))(v135 + 2);
      v93 = (unsigned int (**)(char *, uint64_t, char *))(v109 + 48);
      v92 = (void (**)(void *, Class *))(v135 + 1);
      v135 = (void (**)(char *, char *, char *))(v109 + 32);
      v117 = (void (**)(char *, void, uint64_t, uint64_t *))(v103 + 56);
      v129 = (void (**)(char *, char *))(v109 + 8);
      v130 = (void (**)(char *, char *, char *))(v109 + 16);
      v107 = (void (**)(char *, uint64_t *))(v103 + 8);
      uint64_t v104 = v108 + 32;
      v116 = qword_1ECA06328;
      atomic_ullong v42 = v125;
      v115 = v24;
      BOOL v43 = v124;
      uint64_t v128 = v39 & 0x7FFFFFFFFFFFFFFFLL;
      v118 = (uint64_t (*)(char *, char *))a1;
      v133 = v7;
      v134 = v8;
      while (1)
      {
        Swift::Int v44 = *(void **)(v40 + 208);
        if (v41 == *(void *)(v40 + 224))
        {
          id v45 = [*(id *)(v40 + 208) countByEnumeratingWithState:v106 objects:v105 count:16];
          uint64_t v40 = v128;
          *(void *)(v128 + 224) = v45;
          if (!v45)
          {
            *(void *)(v40 + 216) = -1;
            goto LABEL_34;
          }
          uint64_t v41 = 0;
          *(void *)(v40 + 216) = 0;
        }
        uint64_t v46 = *(void *)(v40 + 24);
        if (!v46)
        {
          unint64_t v90 = 773;
          goto LABEL_40;
        }
        if ((unint64_t)(v41 - 0x1000000000000000) >> 61 != 7)
        {
          __break(1u);
LABEL_37:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
        }
        uint64_t v47 = (void **)(v46 + 8 * v41);
        if ((v47 & 7) != 0) {
          goto LABEL_37;
        }
        uint64_t v48 = *v47;
        *(void *)(v40 + 216) = v41 + 1;
        swift_unknownObjectRetain(v48);
        uint64_t v49 = (swift)[v44 objectForKey:v48];
        if (!v49)
        {
          unint64_t v90 = 784;
LABEL_40:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v90, 0);
        }
        uint64_t v50 = v49;
        if (_swift_isClassOrObjCExistentialType((uint64_t)v8, (uint64_t *)v8))
        {
          v139 = (swift *)v48;
          unint64_t v51 = v137;
          swift_dynamicCast(v137, (unint64_t *)&v139, v116, v8, 7uLL);
        }
        else
        {
          v132 = (void (**)(char *, uint64_t, uint64_t, char *))*((void *)v8 - 1);
          uint64_t v83 = v101;
          v132[7](v101, 1, 1, v8);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v48, (uint64_t)v8, v83);
          swift_unknownObjectRelease(v48);
          v84 = v98;
          uint64_t v85 = v99;
          (*v97)(v98, v101, v99);
          if (((unsigned int (*)(char *, uint64_t, char *))v132[6])(v84, 1, v8) == 1) {
            goto LABEL_42;
          }
          (*v96)(v101, v85);
          unint64_t v51 = v137;
          ((void (*)(char *, char *, char *))v132[4])(v137, v84, v8);
        }
        char v52 = &v51[*((int *)v42 + 12)];
        if (_swift_isClassOrObjCExistentialType((uint64_t)v7, (uint64_t *)v7))
        {
          v139 = v50;
          swift_dynamicCast(v52, (unint64_t *)&v139, qword_1ECA06328, v7, 7uLL);
        }
        else
        {
          (*v95)(v43, 1, 1, v7);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v50, (uint64_t)v7, v43);
          swift_unknownObjectRelease(v50);
          uint64_t v86 = v100;
          (*v94)(v24, v43, v100);
          if ((*v93)(v24, 1, v7) == 1) {
LABEL_42:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
          (*v92)(v43, v86);
          (*v135)(v52, v24, v7);
        }
        uint64_t v53 = v7;
        uint64_t v54 = v137;
        (*v117)(v137, 0, 1, v42);
        uint64_t v55 = *((int *)v42 + 12);
        unint64_t v56 = v136;
        int v57 = &v136[v55];
        uint64_t v58 = &v54[v55];
        uint64_t v59 = *((void *)v8 - 1);
        v131 = *(void (**)(void))(v59 + 32);
        ((void (*)(char *, char *, char *))v131)(v136, v54, v8);
        v132 = (void (**)(char *, uint64_t, uint64_t, char *))*v135;
        ((void (*)(char *, char *, char *))v132)(v57, v58, v53);
        uint64_t v60 = &v123[*((int *)v42 + 12)];
        atomic_ullong v61 = v8;
        BOOL v62 = v123;
        atomic_ullong v63 = *(void (**)(void))(v59 + 16);
        ((void (*)(char *, char *, char *))v63)(v123, v56, v61);
        uint64_t v64 = *v130;
        v127 = v57;
        v64(v60, v57, v53);
        uint64_t v65 = v138;
        char v66 = v118(v62, v60);
        uint64_t v138 = v65;
        if (v65)
        {
          (*v107)(v136, v125);
          outlined consume of [A : B].Iterator._Variant<A, B>(v102);
          swift_release((uint64_t)v140);
          (*v129)(v60, v133);
          (*(void (**)(char *, char *))(v59 + 8))(v62, v134);
          return (__objc2_class **)v60;
        }
        char v67 = v66;
        uint64_t v68 = *v129;
        (*v129)(v60, v133);
        v126 = *(void (**)(char *, char *))(v59 + 8);
        v126(v62, v134);
        if (v67)
        {
          uint64_t v114 = v59 + 8;
          v112 = v68;
          uint64_t v113 = v59;
          uint64_t v69 = v125;
          uint64_t v70 = &v122[*((int *)v125 + 12)];
          unint64_t v71 = (unint64_t)v134;
          v63();
          atomic_ullong v42 = v69;
          v111 = v70;
          uint64_t v72 = v127;
          uint64_t v7 = v133;
          v64(v70, v127, v133);
          uint64_t v73 = &v121[*((int *)v42 + 12)];
          v131();
          v110 = v73;
          ((void (*)(char *, char *, char *))v132)(v73, v72, v7);
          uint64_t v74 = v140;
          uint64_t v75 = v140[2];
          uint64_t v76 = v108;
          if (v140[3] <= v75)
          {
            Swift::Int v77 = (Swift::Int)&v75->isa + 1;
            type metadata accessor for _NativeDictionary(0, v71, (uint64_t)v7, v108);
            _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v77, 1);
            uint64_t v74 = v140;
          }
          uint64_t v78 = (uint64_t)v122;
          uint64_t v79 = (*(uint64_t (**)(__objc2_class *, unint64_t, uint64_t))(v76 + 32))(v74[5], v71, v76);
          unint64_t v80 = __RawDictionaryStorage.find<A>(_:hashValue:)(v78, v79, v71);
          if (v81) {
            KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v71);
          }
          unint64_t v82 = v80;
          v74[(v80 >> 6) + 8] = (__objc2_class *)((unint64_t)v74[(v80 >> 6) + 8] | (1 << v80));
          ((void (*)(char *, uint64_t, unint64_t))v131)((char *)v74[6] + *(void *)(v113 + 72) * v80, v78, v71);
          ((void (*)(char *, char *, char *))v132)((char *)v74[7] + *(void *)(v109 + 72) * v82, v110, v7);
          v74[2] = (__objc2_class *)((char *)v74[2] + 1);
          v126(v121, (char *)v71);
          v112(v111, v7);
          uint64_t v8 = (char *)v71;
        }
        else
        {
          atomic_ullong v42 = v125;
          (*v107)(v136, v125);
          uint64_t v7 = v133;
          uint64_t v8 = v134;
        }
        uint64_t v40 = v128;
        uint64_t v41 = *(void *)(v128 + 216);
        uint64_t v24 = v115;
        BOOL v43 = v124;
        if (v41 < 0) {
          goto LABEL_34;
        }
      }
    }
    atomic_ullong v42 = v125;
LABEL_34:
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v103 + 56))(v137, 1, 1, v42);
    outlined consume of [A : B].Iterator._Variant<A, B>(v102);
    return v140;
  }
  uint64_t v87 = v138;
  _NativeDictionary.filter(_:)(a1, a2, a3, (uint64_t)v8, (uint64_t)v7, a6);
  uint64_t v60 = v88;
  swift_bridgeObjectRelease(a3);
  uint64_t v138 = v87;
  return (__objc2_class **)v60;
}

uint64_t _NativeDictionary.insertNew(key:value:)(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = *(void **)v3;
  unint64_t v8 = *(void *)(*(void *)v3 + 16);
  if (*(void *)(*(void *)v3 + 24) <= v8)
  {
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v8 + 1, 1);
    uint64_t v7 = *(void **)v3;
  }
  unint64_t v9 = a3[2];
  uint64_t v10 = a3[3];
  uint64_t v11 = a3[4];

  return _NativeDictionary._unsafeInsertNew(key:value:)(a1, a2, v7, v9, v10, v11);
}

BOOL Dictionary._Variant.isNative.getter(uint64_t a1)
{
  return (a1 & 0xC000000000000001) == 0;
}

__objc2_class **_ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, __objc2_class **a5)
{
  uint64_t v10 = (uint64_t (*)(char *, uint64_t *))isStackAllocationSafe;
  v18[1] = *MEMORY[0x1E4F143B8];
  char v11 = *(unsigned char *)(a3 + 32);
  unint64_t v12 = (unint64_t)((1 << v11) + 63) >> 6;
  size_t v13 = 8 * v12;
  if ((v11 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1F4188790](isStackAllocationSafe);
    uint64_t v14 = (int64x2_t *)((char *)v18 - ((v13 + 15) & 0x3FFFFFFFFFFFFFF0));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v12, v14);
    uint64_t v15 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5((unint64_t *)v14, v12, a3, v10, a2, a4, (uint64_t)a5);
    if (v5) {
      swift_willThrow();
    }
    else {
      return v15;
    }
  }
  else
  {
    uint64_t v16 = (int64x2_t *)swift_slowAlloc(v13, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v12, v16);
    a5 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5((unint64_t *)v16, v12, a3, v10, a2, a4, (uint64_t)a5);
    swift_slowDealloc(v16);
  }
  return a5;
}

void _NativeDictionary.filter(_:)(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v9 = (uint64_t (*)(char *, char *))isStackAllocationSafe;
  v17[1] = *(__objc2_class ***)MEMORY[0x1E4F143B8];
  char v10 = *(unsigned char *)(a3 + 32);
  unint64_t v11 = (unint64_t)((1 << v10) + 63) >> 6;
  size_t v12 = 8 * v11;
  if ((v10 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    uint64_t v15 = (uint64_t)&v15;
    MEMORY[0x1F4188790](isStackAllocationSafe);
    size_t v13 = (int64x2_t *)((char *)&v15 - ((v12 + 15) & 0x3FFFFFFFFFFFFFF0));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v11, v13);
    closure #1 in _NativeDictionary.filter(_:)((unint64_t *)v13, v11, v9, a5, a6, &v16);
    if (v6) {
      swift_willThrow();
    }
  }
  else
  {
    uint64_t v14 = (int64x2_t *)swift_slowAlloc(v12, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v11, v14);
    closure #1 in _NativeDictionary.filter(_:)((unint64_t *)v14, v11, v9, a5, a6, v17);
    swift_slowDealloc(v14);
  }
}

unint64_t *Dictionary._Variant.startIndex.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return (unint64_t *)_NativeDictionary.startIndex.getter(a1);
  }
  if (a1 < 0) {
    uint64_t v2 = (void *)a1;
  }
  else {
    uint64_t v2 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v3 = (unint64_t)[swift_unknownObjectRetain(v2) count];
  uint64_t result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v3 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v3, 24))
    {
      uint64_t v5 = swift_bufferAllocate(result, 8 * v3 + 24, 7uLL);
      v5[2] = v3;
      [v2 sel_getObjects_andKeys_count_:0, v5 + 3, v3];
      swift_bridgeObjectRelease(a1);
      uint64_t v6 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v7 = swift_allocObject(v6, 0x20uLL, 7uLL);
      v7[2] = v2;
      v7[3] = v5;
      swift_bridgeObjectRetain(a1);
      return v7;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

unint64_t *Dictionary._Variant.endIndex.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return (unint64_t *)(1 << *(unsigned char *)(a1 + 32));
  }
  if (a1 < 0) {
    uint64_t v2 = (void *)a1;
  }
  else {
    uint64_t v2 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v3 = (unint64_t)[swift_unknownObjectRetain(v2) count];
  uint64_t result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v3 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v3, 24))
    {
      uint64_t v5 = swift_bufferAllocate(result, 8 * v3 + 24, 7uLL);
      v5[2] = v3;
      [v2 setObject:0 forKey:(v5 + 3)];
      swift_bridgeObjectRelease(a1);
      uint64_t v6 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v7 = swift_allocObject(v6, 0x20uLL, 7uLL);
      v7[2] = v2;
      v7[3] = v5;
      swift_bridgeObjectRetain(a1);
      return v7;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

Swift::Int Dictionary._Variant.index(after:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = a1;
  uint64_t v9 = a3 & 1;
  if ((a4 & 0xC000000000000001) == 0) {
    return _NativeDictionary.index(after:)(a1, a2, v9, a4, a5, a6, a7);
  }
  if (a4 < 0) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a4 & 0xFFFFFFFFFFFFFF8;
  }
  if (!v9) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  if (a1 >= 0) {
    uint64_t v11 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v11 = a1;
  }
  outlined copy of [A : B].Index._Variant<A, B>(a1, a2, 1);
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v11, v12)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(void *)(v11 + 16) != v10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E7uLL, 0);
  }
  if (*(void *)(*(void *)(v11 + 24) + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  return v8;
}

void Dictionary._Variant.formIndex(after:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 16);
  if ((a2 & 0xC000000000000001) == 0)
  {
    Swift::Int v18 = _NativeDictionary.index(after:)(*(void *)a1, v9, v10, a2, a3, a6, a5);
    uint64_t v16 = v19;
    char v17 = v20 & 1;
    outlined consume of [A : B].Index._Variant<A, B>(v8, v9, v10);
    *(void *)a1 = v18;
    goto LABEL_20;
  }
  if ((v10 & 1) == 0)
  {
    unint64_t v21 = 1850;
    goto LABEL_26;
  }
  if (v8 >= 0) {
    uint64_t v11 = v8 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v11 = *(void *)a1;
  }
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v8);
  if (!swift_dynamicCastClass(v11, v12)) {
LABEL_23:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  outlined consume of [A : B].Index._Variant<A, B>(v8, v9, 1);
  if (v11) {
    swift_isUniquelyReferenced_nonNull_native(v11);
  }
  if (*(unsigned char *)(a1 + 16) != 1)
  {
    unint64_t v21 = 1858;
LABEL_26:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, v21, 0);
  }
  uint64_t v13 = *(void *)(a1 + 8);
  if (*(uint64_t *)a1 >= 0) {
    uint64_t v14 = *(void *)a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v14 = *(void *)a1;
  }
  if (!swift_dynamicCastClass(v14, v12)) {
    goto LABEL_23;
  }
  uint64_t v15 = a2 & 0xFFFFFFFFFFFFFF8;
  if (a2 < 0) {
    uint64_t v15 = a2;
  }
  if (*(void *)(v14 + 16) != v15) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E7uLL, 0);
  }
  if (v13 >= *(void *)(*(void *)(v14 + 24) + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  uint64_t v16 = v13 + 1;
  char v17 = 1;
LABEL_20:
  *(void *)(a1 + 8) = v16;
  *(unsigned char *)(a1 + 16) = v17;
}

void *Dictionary._Variant.index(forKey:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v18 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if (v19) {
        return (void *)v18;
      }
    }
    return 0;
  }
  uint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  }
  id v8 = [v7 objectForKey:v6];
  if (!v8)
  {
    swift_unknownObjectRelease(v6);
    return 0;
  }
  swift_unknownObjectRelease(v8);
  unint64_t v9 = (unint64_t)[swift_unknownObjectRetain(v7) count];
  uint64_t v10 = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v9 - 0x1000000000000000) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_19;
  }
  if (__OFADD__(8 * v9, 24))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v11 = swift_bufferAllocate(v10, 8 * v9 + 24, 7uLL);
  v11[2] = v9;
  [v7 setObjects:v11 + 3 count:v9];
  swift_bridgeObjectRelease(a2);
  if ((v11[2] & 0x8000000000000000) != 0) {
    goto LABEL_20;
  }
  swift_unknownObjectRetain(v11);
  uint64_t v12 = 0;
  do
  {
    uint64_t v13 = v12 + 1;
    uint64_t v14 = (void *)v11[v12 + 3];
    swift_unknownObjectRetain(v14);
    char isEqual = swift_stdlib_NSObject_isEqual(v6, v14);
    swift_unknownObjectRelease(v14);
    uint64_t v12 = v13;
  }
  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v11);
  uint64_t v16 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
  char v17 = swift_allocObject(v16, 0x20uLL, 7uLL);
  void v17[2] = v7;
  v17[3] = v11;
  swift_unknownObjectRetain(v7);
  swift_unknownObjectRelease(v6);
  return v17;
}

void Dictionary.subscript.getter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, char *a8, uint64_t a9)
{
  uint64_t v15 = *((void *)a7 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](a1);
  char v19 = (char *)&v36 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v20 & 0xC000000000000001) == 0)
  {
    if (v17)
    {
      uint64_t v36 = v16;
      uint64_t v37 = a2;
      if (a3 >= 0) {
        uint64_t v30 = a3 & 0xFFFFFFFFFFFFFF8;
      }
      else {
        uint64_t v30 = a3;
      }
      uint64_t v31 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(a3);
      if (!swift_dynamicCastClass(v30, v31)) {
        goto LABEL_34;
      }
      if (*(_DWORD *)(a6 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v30 + 16))) {
        goto LABEL_37;
      }
      if (!swift_dynamicCastClass(v30, v31)) {
        goto LABEL_34;
      }
      uint64_t v32 = *(void *)(v30 + 24);
      if (*(void *)(v32 + 16) <= a4) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
      }
      uint64_t v33 = *(void **)(v32 + 8 * a4 + 24);
      swift_unknownObjectRetain(v33);
      outlined consume of [A : B].Index._Variant<A, B>(a3, a4, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v33, a7, v34, v19);
      swift_unknownObjectRelease(v33);
      a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v19, (uint64_t)a7, a9);
      LOBYTE(v33) = v35;
      (*(void (**)(char *, char *))(v15 + 8))(v19, a7);
      if ((v33 & 1) == 0)
      {
LABEL_37:
        unint64_t v29 = 303;
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v29, 0);
      }
      uint64_t v16 = v36;
      a2 = v37;
    }
    else if (a3 < 0 {
           || 1 << *(unsigned char *)(a6 + 32) <= a3
    }
           || ((*(void *)(a6 + 8 * ((unint64_t)a3 >> 6) + 64) >> a3) & 1) == 0
           || *(_DWORD *)(a6 + 36) != a4)
    {
      unint64_t v29 = 281;
      goto LABEL_21;
    }
    (*(void (**)(uint64_t, uint64_t, char *))(v15 + 16))(v16, *(void *)(a6 + 48) + *(void *)(v15 + 72) * a3, a7);
    (*(void (**)(char *, uint64_t, char *))(*((void *)a8 - 1) + 16))(a2, *(void *)(a6 + 56) + *(void *)(*((void *)a8 - 1) + 72) * a3, a8);
    return;
  }
  if (a6 >= 0) {
    a6 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v17 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  unint64_t v21 = (char *)v16;
  if (a3 >= 0) {
    uint64_t v22 = a3 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v22 = a3;
  }
  uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v22, v23)) {
    goto LABEL_34;
  }
  if (*(void *)(v22 + 16) != a6) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x21CuLL, 0);
  }
  uint64_t v24 = *(void **)(*(void *)(v22 + 24) + 8 * a4 + 24);
  swift_unknownObjectRetain(v24);
  if (!swift_dynamicCastClass(v22, v23)) {
LABEL_34:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  id v25 = [a6 objectForKey:v24];
  if (!v25) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x21EuLL, 0);
  }
  uint64_t v27 = v25;
  _forceBridgeFromObjectiveC<A>(_:_:)(v24, a7, v26, v21);
  swift_unknownObjectRelease(v24);
  _forceBridgeFromObjectiveC<A>(_:_:)(v27, a8, v28, a2);

  swift_unknownObjectRelease(v27);
}

void Dictionary._Variant.lookup(_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, char *a8, uint64_t a9)
{
  uint64_t v15 = *((void *)a7 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](a1);
  char v19 = (char *)&v36 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v20 & 0xC000000000000001) == 0)
  {
    if (v17)
    {
      uint64_t v36 = v16;
      uint64_t v37 = a2;
      if (a3 >= 0) {
        uint64_t v30 = a3 & 0xFFFFFFFFFFFFFF8;
      }
      else {
        uint64_t v30 = a3;
      }
      uint64_t v31 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(a3);
      if (!swift_dynamicCastClass(v30, v31)) {
        goto LABEL_34;
      }
      if (*(_DWORD *)(a6 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v30 + 16))) {
        goto LABEL_37;
      }
      if (!swift_dynamicCastClass(v30, v31)) {
        goto LABEL_34;
      }
      uint64_t v32 = *(void *)(v30 + 24);
      if (*(void *)(v32 + 16) <= a4) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
      }
      uint64_t v33 = *(void **)(v32 + 8 * a4 + 24);
      swift_unknownObjectRetain(v33);
      outlined consume of [A : B].Index._Variant<A, B>(a3, a4, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v33, a7, v34, v19);
      swift_unknownObjectRelease(v33);
      a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v19, (uint64_t)a7, a9);
      LOBYTE(v33) = v35;
      (*(void (**)(char *, char *))(v15 + 8))(v19, a7);
      if ((v33 & 1) == 0)
      {
LABEL_37:
        unint64_t v29 = 303;
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v29, 0);
      }
      uint64_t v16 = v36;
      a2 = v37;
    }
    else if (a3 < 0 {
           || 1 << *(unsigned char *)(a6 + 32) <= a3
    }
           || ((*(void *)(a6 + 8 * ((unint64_t)a3 >> 6) + 64) >> a3) & 1) == 0
           || *(_DWORD *)(a6 + 36) != a4)
    {
      unint64_t v29 = 281;
      goto LABEL_21;
    }
    (*(void (**)(uint64_t, uint64_t, char *))(v15 + 16))(v16, *(void *)(a6 + 48) + *(void *)(v15 + 72) * a3, a7);
    (*(void (**)(char *, uint64_t, char *))(*((void *)a8 - 1) + 16))(a2, *(void *)(a6 + 56) + *(void *)(*((void *)a8 - 1) + 72) * a3, a8);
    return;
  }
  if (a6 >= 0) {
    a6 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v17 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  unint64_t v21 = (char *)v16;
  if (a3 >= 0) {
    uint64_t v22 = a3 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v22 = a3;
  }
  uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v22, v23)) {
    goto LABEL_34;
  }
  if (*(void *)(v22 + 16) != a6) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x21CuLL, 0);
  }
  uint64_t v24 = *(void **)(*(void *)(v22 + 24) + 8 * a4 + 24);
  swift_unknownObjectRetain(v24);
  if (!swift_dynamicCastClass(v22, v23)) {
LABEL_34:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  id v25 = [a6 objectForKey:v24];
  if (!v25) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x21EuLL, 0);
  }
  uint64_t v27 = v25;
  _forceBridgeFromObjectiveC<A>(_:_:)(v24, a7, v26, v21);
  swift_unknownObjectRelease(v24);
  _forceBridgeFromObjectiveC<A>(_:_:)(v27, a8, v28, a2);

  swift_unknownObjectRelease(v27);
}

id Dictionary._Variant.count.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return *(id *)(a1 + 16);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return [a1 count];
}

uint64_t (*Dictionary.subscript.read(uint64_t **a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, char *a6, char *a7, uint64_t a8))()
{
  uint64_t v15 = a4 & 1;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)a6, (uint64_t)a7, "key value ", 0);
  *a1 = TupleTypeMetadata2;
  uint64_t v17 = *(TupleTypeMetadata2 - 1);
  a1[1] = (uint64_t *)v17;
  uint64_t v18 = (char *)malloc(*(void *)(v17 + 64));
  a1[2] = (uint64_t *)v18;
  Dictionary.subscript.getter((uint64_t)v18, &v18[*((int *)TupleTypeMetadata2 + 12)], a2, a3, v15, a5, a6, a7, a8);
  return _ArrayBuffer.subscript.read;
}

uint64_t Dictionary._Variant.lookup(_:)@<X0>(id *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, char *a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  if ((a2 & 0xC000000000000001) != 0)
  {
    unint64_t v9 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    if (a2 < 0) {
      uint64_t v10 = (void *)a2;
    }
    else {
      uint64_t v10 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
    }
    id v11 = [v10 objectForKey:v9];
    swift_unknownObjectRelease(v9);
    if (v11)
    {
      _forceBridgeFromObjectiveC<A>(_:_:)(v11, a4, v12, a6);
      swift_unknownObjectRelease(v11);
      uint64_t v13 = 0;
      uint64_t v14 = *((void *)a4 - 1);
      goto LABEL_11;
    }
  }
  else if (*(void *)(a2 + 16))
  {
    unint64_t v15 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
    if (v16)
    {
      uint64_t v19 = *((void *)a4 - 1);
      (*(void (**)(char *, unint64_t, char *))(v19 + 16))(a6, *(void *)(a2 + 56) + *(void *)(v19 + 72) * v15, a4);
      uint64_t v14 = v19;
      uint64_t v13 = 0;
      goto LABEL_11;
    }
  }
  uint64_t v14 = *((void *)a4 - 1);
  uint64_t v13 = 1;
LABEL_11:
  uint64_t v17 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56);

  return v17(a6, v13, 1, a4);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
  uint64_t v11 = *v4;
  *uint64_t v4 = 0x8000000000000000;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, a4, isUniquelyReferenced_nonNull_native);
  uint64_t v10 = *v4;
  *uint64_t v4 = v11;

  swift_bridgeObjectRelease(v10);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(uint64_t a1, unint64_t a2, unint64_t a3)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v9 = *v3;
  *unint64_t v3 = 0x8000000000000000;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, isUniquelyReferenced_nonNull_native);
  uint64_t v8 = *v3;
  *unint64_t v3 = v9;

  swift_bridgeObjectRelease(v8);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(_OWORD *a1, unint64_t a2, unint64_t a3)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v9 = *v3;
  *unint64_t v3 = 0x8000000000000000;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, isUniquelyReferenced_nonNull_native);
  uint64_t v8 = *v3;
  *unint64_t v3 = v9;

  swift_bridgeObjectRelease(v8);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(uint64_t a1, uint64_t a2, void *a3)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v9 = *v3;
  *unint64_t v3 = 0x8000000000000000;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, isUniquelyReferenced_nonNull_native);
  uint64_t v8 = *v3;
  *unint64_t v3 = v9;

  swift_bridgeObjectRelease(v8);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(_OWORD *a1, void *a2)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
  uint64_t v7 = *v2;
  *uint64_t v2 = 0x8000000000000000;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, isUniquelyReferenced_nonNull_native);
  uint64_t v6 = *v2;
  *uint64_t v2 = v7;

  swift_bridgeObjectRelease(v6);
}

void Dictionary._Variant.setValue(_:forKey:)(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (char *)a3[2];
  uint64_t v10 = (uint64_t *)a3[3];
  if ((v8 & 0xC000000000000001) != 0)
  {
    if (v8 < 0) {
      uint64_t v11 = (void *)v8;
    }
    else {
      uint64_t v11 = (void *)(v8 & 0xFFFFFFFFFFFFFF8);
    }
    id v12 = [v11 count];
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      return;
    }
    uint64_t v13 = a3[4];
    uint64_t v8 = (uint64_t)_NativeDictionary.init(_:capacity:)(v11, (uint64_t)v12 + 1, v9, v10, v13);
    *uint64_t v4 = v8;
  }
  else
  {
    uint64_t v13 = a3[4];
  }
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8);
  uint64_t v17 = *v4;
  *uint64_t v4 = 0x8000000000000000;
  unint64_t v15 = type metadata accessor for _NativeDictionary(0, (uint64_t)v9, (uint64_t)v10, v13);
  _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, isUniquelyReferenced_nonNull_native, (uint64_t)v15);
  uint64_t v16 = *v4;
  *uint64_t v4 = v17;

  swift_bridgeObjectRelease(v16);
}

uint64_t Dictionary.removeValue(forKey:)@<X0>(id *a1@<X0>, uint64_t *a2@<X1>, char *a3@<X8>)
{
  uint64_t v5 = type metadata accessor for Dictionary._Variant(0, a2[2], a2[3], a2[4]);

  return Dictionary._Variant.removeValue(forKey:)(a1, (uint64_t)v5, a3);
}

void (*Dictionary.subscript.modify(void *a1, uint64_t a2, void *a3))(void *a1)
{
  uint64_t v5 = malloc(0x40uLL);
  *a1 = v5;
  uint64_t v6 = a3[2];
  v5[4] = v6;
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = v7;
  v5[5] = v7;
  uint64_t v9 = malloc(*(void *)(v7 + 64));
  v5[6] = v9;
  (*(void (**)(void))(v8 + 16))();
  uint64_t v10 = type metadata accessor for Dictionary._Variant(0, v6, a3[3], a3[4]);
  v5[7] = Dictionary._Variant.subscript.modify(v5, (uint64_t)v9, v10);
  return Dictionary.subscript.modify;
}

void Dictionary.subscript.modify(void *a1)
{
  Swift::String v1 = (void *)*a1;
  uint64_t v2 = *(void **)(*a1 + 48);
  uint64_t v3 = *(void *)(*a1 + 32);
  uint64_t v4 = *(void *)(*a1 + 40);
  (*(void (**)(void, void))(*a1 + 56))(*a1, 0);
  (*(void (**)(void *, uint64_t))(v4 + 8))(v2, v3);
  free(v2);

  free(v1);
}

void (*Dictionary._Variant.subscript.modify(void *a1, uint64_t a2, void *a3))(uint64_t *a1)
{
  uint64_t v7 = malloc(0xA0uLL);
  *a1 = v7;
  uint64_t v8 = (char *)a3[2];
  v7[13] = v8;
  uint64_t v9 = *((void *)v8 - 1);
  uint64_t v10 = v9;
  v7[14] = v9;
  size_t v11 = *(void *)(v9 + 64);
  id v12 = malloc(v11);
  v7[15] = v12;
  uint64_t v13 = malloc(v11);
  v7[16] = v13;
  uint64_t v14 = *v3;
  unint64_t v15 = (uint64_t *)a3[3];
  if ((*v3 & 0xC000000000000001) == 0)
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v14);
    (*(void (**)(void *, uint64_t, char *))(v10 + 16))(v13, a2, v8);
    v7[17] = Dictionary._Variant.asNative.modify(v7 + 4);
    uint64_t v23 = type metadata accessor for _NativeDictionary(0, (uint64_t)v8, (uint64_t)v15, a3[4]);
    v7[18] = _NativeDictionary.subscript.modify(v7 + 8, (uint64_t)v13, isUniquelyReferenced_nonNull_native, v23);
    return Dictionary._Variant.subscript.modify;
  }
  if (v14 < 0) {
    uint64_t v16 = (void *)*v3;
  }
  else {
    uint64_t v16 = (void *)(v14 & 0xFFFFFFFFFFFFFF8);
  }
  uint64_t result = (void (*)(uint64_t *))[v16 sel_count];
  if (!__OFADD__(result, 1))
  {
    uint64_t v18 = a3[4];
    uint64_t v19 = _NativeDictionary.init(_:capacity:)(v16, (uint64_t)result + 1, v8, v15, v18);
    v7[12] = v19;
    *uint64_t v3 = (uint64_t)v19;
    (*(void (**)(void *, uint64_t, char *))(v10 + 16))(v12, a2, v8);
    swift_retain((atomic_ullong *)v19);
    uint64_t v20 = type metadata accessor for _NativeDictionary(0, (uint64_t)v8, (uint64_t)v15, v18);
    v7[19] = _NativeDictionary.subscript.modify(v7, (uint64_t)v12, 1, v20);
    return Dictionary._Variant.subscript.modify;
  }
  __break(1u);
  return result;
}

void Dictionary._Variant.subscript.modify(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *a1 + 32;
  uint64_t v3 = *(void (**)(uint64_t, void))(*a1 + 136);
  uint64_t v4 = *(void *)(*a1 + 128);
  uint64_t v5 = *(void *)(*a1 + 104);
  uint64_t v6 = *(void *)(*a1 + 112);
  (*(void (**)(void))(*a1 + 144))();
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v4, v5);
  v3(v2, 0);
  uint64_t v7 = *(void **)(v1 + 120);
  free(*(void **)(v1 + 128));
  free(v7);

  free((void *)v1);
}

void Dictionary._Variant.subscript.modify(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = *(void *)(*a1 + 112);
  uint64_t v2 = *(void *)(*a1 + 120);
  uint64_t v4 = *(void *)(*a1 + 104);
  (*(void (**)(void, void))(*a1 + 152))(*a1, 0);
  (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v2, v4);
  swift_release(*(void *)(v1 + 96));
  uint64_t v5 = *(void **)(v1 + 120);
  free(*(void **)(v1 + 128));
  free(v5);

  free((void *)v1);
}

unint64_t _NativeDictionary.find(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return __RawDictionaryStorage.find<A>(_:)(a1, a3, a5);
}

_OWORD *specialized _NativeDictionary._insert(at:key:value:)(unint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, void *a5)
{
  a5[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v6 = (void *)(a5[6] + 16 * a1);
  *uint64_t v6 = a2;
  v6[1] = a3;
  uint64_t result = outlined init with take of Any(a4, (_OWORD *)(a5[7] + 32 * a1));
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

{
  void *v6;
  _OWORD *result;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;

  a5[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v6 = (void *)(a5[6] + 16 * a1);
  *uint64_t v6 = a2;
  v6[1] = a3;
  uint64_t result = outlined init with take of Any(a4, (_OWORD *)(a5[7] + 32 * a1));
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

_OWORD *specialized _NativeDictionary._insert(at:key:value:)(unint64_t a1, uint64_t a2, _OWORD *a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v5 = a4[6] + 40 * a1;
  long long v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v6;
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  uint64_t result = outlined init with take of Any(a3, (_OWORD *)(a4[7] + 32 * a1));
  uint64_t v8 = a4[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a4[2] = v10;
  }
  return result;
}

{
  uint64_t v5;
  long long v6;
  _OWORD *result;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;

  a4[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v5 = a4[6] + 40 * a1;
  long long v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v6;
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  uint64_t result = outlined init with take of Any(a3, (_OWORD *)(a4[7] + 32 * a1));
  uint64_t v8 = a4[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a4[2] = v10;
  }
  return result;
}

unint64_t specialized _NativeDictionary._insert(at:key:value:)(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  a6[(result >> 6) + 8] |= 1 << result;
  long long v6 = (void *)(a6[6] + 16 * result);
  *long long v6 = a2;
  v6[1] = a3;
  uint64_t v7 = (void *)(a6[7] + 16 * result);
  *uint64_t v7 = a4;
  v7[1] = a5;
  uint64_t v8 = a6[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a6[2] = v10;
  }
  return result;
}

unint64_t specialized _NativeDictionary._insert(at:key:value:)(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  a5[(result >> 6) + 8] |= 1 << result;
  uint64_t v5 = (void *)(a5[6] + 16 * result);
  void *v5 = a2;
  v5[1] = a3;
  uint64_t v6 = a5[7] + 40 * result;
  long long v7 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)uint64_t v6 = *(_OWORD *)a4;
  *(_OWORD *)(v6 + 16) = v7;
  *(void *)(v6 + 32) = *(void *)(a4 + 32);
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

{
  uint64_t v5;
  long long v6;
  void *v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;

  a5[(result >> 6) + 8] |= 1 << result;
  uint64_t v5 = a5[6] + 40 * result;
  uint64_t v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v6;
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  long long v7 = (void *)(a5[7] + 16 * result);
  *long long v7 = a3;
  v7[1] = a4;
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

uint64_t _NativeDictionary._insert(at:key:value:)(unint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  (*(void (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32))(a4[6] + *(void *)(*(void *)(a5 - 8) + 72) * a1, a2, a5);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a6 - 8) + 32))(a4[7] + *(void *)(*(void *)(a6 - 8) + 72) * a1, a3, a6);
  uint64_t v11 = a4[2];
  BOOL v12 = __OFADD__(v11, 1);
  uint64_t v13 = v11 + 1;
  if (v12) {
    __break(1u);
  }
  else {
    a4[2] = v13;
  }
  return result;
}

uint64_t Dictionary.subscript.getter@<X0>(id *a1@<X0>, void (*a2)(void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, char *a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a3;
  uint64_t v32 = a2;
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)a6, a3, a4);
  uint64_t v15 = (uint64_t)*(v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v31 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v31 - v19;
  if ((a4 & 0xC000000000000001) != 0)
  {
    unint64_t v21 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a5);
    if (a4 < 0) {
      uint64_t v22 = (void *)a4;
    }
    else {
      uint64_t v22 = (void *)(a4 & 0xFFFFFFFFFFFFFF8);
    }
    id v23 = [v22 objectForKey:v21, v31, v32];
    swift_unknownObjectRelease(v21);
    if (v23)
    {
      _forceBridgeFromObjectiveC<A>(_:_:)(v23, a6, v24, v20);
      swift_unknownObjectRelease(v23);
      uint64_t v25 = *((void *)a6 - 1);
      uint64_t v26 = v25;
LABEL_10:
      (*(void (**)(char *, void, uint64_t, char *))(v26 + 56))(v20, 0, 1, a6);
      goto LABEL_12;
    }
  }
  else if (*(void *)(a4 + 16))
  {
    unint64_t v27 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a5, a7);
    if (v28)
    {
      uint64_t v29 = *(void *)(a4 + 56);
      uint64_t v25 = *((void *)a6 - 1);
      (*(void (**)(char *, unint64_t, char *))(v25 + 16))(v20, v29 + *(void *)(v25 + 72) * v27, a6);
      uint64_t v26 = v25;
      goto LABEL_10;
    }
  }
  uint64_t v25 = *((void *)a6 - 1);
  (*(void (**)(char *, uint64_t, uint64_t, char *))(v25 + 56))(v20, 1, 1, a6);
LABEL_12:
  (*(void (**)(char *, char *, Class *))(v15 + 32))(v18, v20, v14);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v25 + 48))(v18, 1, a6) != 1) {
    return (*(uint64_t (**)(uint64_t, char *, char *))(v25 + 32))(a8, v18, a6);
  }
  v32();
  return (*(uint64_t (**)(char *, Class *))(v15 + 8))(v18, v14);
}

void (*Dictionary.subscript.modify(void *a1, unint64_t a2, void (*a3)(unint64_t), uint64_t a4, uint64_t a5))(void **a1)
{
  uint64_t v6 = v5;
  long long v7 = (__objc2_class **)a5;
  uint64_t v11 = *(char **)(a5 + 16);
  uint64_t v40 = *((void *)v11 - 1);
  unint64_t v39 = malloc(*(void *)(v40 + 64));
  *a1 = v39;
  BOOL v12 = (uint64_t *)v7[3];
  uint64_t v13 = *(v12 - 1);
  unint64_t v38 = malloc(*(void *)(v13 + 64));
  a1[1] = v38;
  uint64_t v14 = *v5;
  uint64_t v42 = a2;
  uint64_t v41 = a3;
  if ((*v5 & 0xC000000000000001) == 0)
  {
    Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v14);
    uint64_t v27 = *v5;
    uint64_t v43 = *v6;
    *uint64_t v6 = 0x8000000000000000;
    long long v7 = (__objc2_class **)v7[4];
    unint64_t v28 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v11, (uint64_t)v7);
    uint64_t v30 = *(void *)(v27 + 16);
    BOOL v31 = (v29 & 1) == 0;
    Swift::Int v32 = v30 + v31;
    if (!__OFADD__(v30, v31))
    {
      a2 = v28;
      LOBYTE(v13) = v29;
      if (*(void *)(v27 + 24) < v32)
      {
        type metadata accessor for _NativeDictionary(0, (uint64_t)v11, (uint64_t)v12, (uint64_t)v7);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v32, isUniquelyReferenced_nonNull_native);
        uint64_t v27 = v43;
        unint64_t v33 = __RawDictionaryStorage.find<A>(_:)(v42, (uint64_t)v11, (uint64_t)v7);
        if ((v13 & 1) != (v34 & 1)) {
          goto LABEL_24;
        }
        a2 = v33;
LABEL_17:
        uint64_t v35 = *v6;
        *uint64_t v6 = v27;
        swift_bridgeObjectRelease(v35);
        long long v7 = (__objc2_class **)*v6;
        if (v13) {
          goto LABEL_11;
        }
LABEL_18:
        unint64_t v36 = swift_bridgeObjectRetain((unint64_t)v7);
        v41(v36);
        (*(void (**)(void *, uint64_t, char *))(v40 + 16))(v39, v42, v11);
        _NativeDictionary._insert(at:key:value:)(a2, (uint64_t)v39, (uint64_t)v38, v7, (uint64_t)v11, (uint64_t)v12);
        goto LABEL_19;
      }
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_17;
      }
LABEL_23:
      type metadata accessor for _NativeDictionary(0, (uint64_t)v11, (uint64_t)v12, (uint64_t)v7);
      _NativeDictionary.copy()();
      uint64_t v27 = v43;
      goto LABEL_17;
    }
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  if (v14 < 0) {
    uint64_t v15 = (void *)*v5;
  }
  else {
    uint64_t v15 = (void *)(v14 & 0xFFFFFFFFFFFFFF8);
  }
  id v16 = [v15 count:v38];
  if (__OFADD__(v16, 1))
  {
    __break(1u);
    goto LABEL_21;
  }
  uint64_t v17 = (uint64_t)v7[4];
  long long v7 = _NativeDictionary.init(_:capacity:)(v15, (uint64_t)v16 + 1, v11, v12, v17);
  uint64_t v43 = (uint64_t)v7;
  unint64_t v18 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v11, v17);
  uint64_t v20 = v7[2];
  BOOL v21 = (v19 & 1) == 0;
  Swift::Int v22 = (Swift::Int)v20 + v21;
  if (__OFADD__(v20, v21))
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  a2 = v18;
  char v23 = v19;
  if ((uint64_t)v7[3] >= v22) {
    goto LABEL_10;
  }
  type metadata accessor for _NativeDictionary(0, (uint64_t)v11, (uint64_t)v12, v17);
  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v22, 1);
  unint64_t v24 = __RawDictionaryStorage.find<A>(_:)(v42, (uint64_t)v11, v17);
  if ((v23 & 1) != (v25 & 1)) {
LABEL_24:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v11);
  a2 = v24;
LABEL_10:
  *uint64_t v6 = (uint64_t)v7;
  if ((v23 & 1) == 0) {
    goto LABEL_18;
  }
LABEL_11:
  swift_bridgeObjectRetain((unint64_t)v7);
LABEL_19:
  swift_bridgeObjectRelease((uint64_t)v7);
  return Dictionary.subscript.modify;
}

void Dictionary.subscript.modify(void **a1)
{
  uint64_t v1 = *a1;
  free(a1[1]);

  free(v1);
}

unint64_t Dictionary._Variant.mutatingFind(_:)(uint64_t a1, void *a2)
{
  uint64_t v5 = v2;
  uint64_t v8 = *v2;
  BOOL v9 = (char *)a2[2];
  uint64_t v10 = (uint64_t *)a2[3];
  if ((*v2 & 0xC000000000000001) == 0)
  {
    Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8);
    uint64_t v23 = *v2;
    uint64_t v34 = *v5;
    uint64_t *v5 = 0x8000000000000000;
    uint64_t v4 = a2[4];
    unint64_t v24 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
    uint64_t v26 = *(void *)(v23 + 16);
    BOOL v27 = (v25 & 1) == 0;
    Swift::Int v28 = v26 + v27;
    if (!__OFADD__(v26, v27))
    {
      char v29 = v25;
      if (*(void *)(v23 + 24) >= v28)
      {
        unint64_t v3 = v24;
        if (!isUniquelyReferenced_nonNull_native)
        {
LABEL_21:
          type metadata accessor for _NativeDictionary(0, (uint64_t)v9, (uint64_t)v10, v4);
          _NativeDictionary.copy()();
          uint64_t v23 = v34;
        }
      }
      else
      {
        type metadata accessor for _NativeDictionary(0, (uint64_t)v9, (uint64_t)v10, v4);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v28, isUniquelyReferenced_nonNull_native);
        uint64_t v23 = v34;
        unint64_t v30 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
        if ((v29 & 1) != (v31 & 1)) {
          goto LABEL_22;
        }
        unint64_t v3 = v30;
      }
      uint64_t v32 = *v5;
      uint64_t *v5 = v23;
      swift_bridgeObjectRelease(v32);
      return v3;
    }
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }
  if (v8 < 0) {
    uint64_t v11 = (void *)*v2;
  }
  else {
    uint64_t v11 = (void *)(v8 & 0xFFFFFFFFFFFFFF8);
  }
  id v12 = [v11 count];
  if (__OFADD__(v12, 1))
  {
    __break(1u);
    goto LABEL_19;
  }
  uint64_t v4 = a2[4];
  uint64_t v13 = _NativeDictionary.init(_:capacity:)(v11, (uint64_t)v12 + 1, v9, v10, v4);
  uint64_t v34 = (uint64_t)v13;
  unint64_t v14 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
  id v16 = v13[2];
  BOOL v17 = (v15 & 1) == 0;
  Swift::Int v18 = (Swift::Int)v16 + v17;
  if (__OFADD__(v16, v17))
  {
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }
  unint64_t v3 = v14;
  char v19 = v15;
  if ((uint64_t)v13[3] < v18)
  {
    type metadata accessor for _NativeDictionary(0, (uint64_t)v9, (uint64_t)v10, v4);
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v18, 1);
    unint64_t v20 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
    if ((v19 & 1) == (v21 & 1))
    {
      unint64_t v3 = v20;
      goto LABEL_10;
    }
LABEL_22:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v9);
  }
LABEL_10:
  uint64_t *v5 = (uint64_t)v13;
  return v3;
}

uint64_t _NativeDictionary._values.getter(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t Dictionary.subscript.setter(Swift::Int a1, uint64_t a2, Swift::Int a3, unint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  uint64_t v7 = a5;
  id v12 = *(uint64_t **)(a5 + 24);
  uint64_t v13 = *(v12 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v46 = (char *)&v46 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v47 = v15;
  uint64_t v16 = *v5;
  Swift::Int v18 = *(char **)(v17 + 16);
  BOOL v19 = (*v5 & 0xC000000000000001) == 0;
  Swift::Int v49 = a1;
  uint64_t v50 = v20;
  uint64_t v48 = v21;
  if (v19)
  {
    Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v16);
    uint64_t v34 = *v5;
    unint64_t v51 = (__objc2_class **)*v6;
    *uint64_t v6 = 0x8000000000000000;
    uint64_t v7 = *(void *)(v7 + 32);
    unint64_t v35 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v18, v7);
    uint64_t v37 = *(void *)(v34 + 16);
    BOOL v38 = (v36 & 1) == 0;
    a3 = v37 + v38;
    if (!__OFADD__(v37, v38))
    {
      a4 = v35;
      LOBYTE(a2) = v36;
      if (*(void *)(v34 + 24) < a3)
      {
        type metadata accessor for _NativeDictionary(0, (uint64_t)v18, (uint64_t)v12, v7);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(a3, isUniquelyReferenced_nonNull_native);
        uint64_t v34 = (uint64_t)v51;
        unint64_t v39 = __RawDictionaryStorage.find<A>(_:)(v50, (uint64_t)v18, v7);
        if ((a2 & 1) != (v40 & 1)) {
          goto LABEL_24;
        }
        a4 = v39;
        a3 = v49;
LABEL_17:
        uint64_t v41 = *v6;
        *uint64_t v6 = v34;
        swift_bridgeObjectRelease(v41);
        unint64_t v24 = (__objc2_class **)*v6;
        if (a2) {
          goto LABEL_11;
        }
LABEL_18:
        unint64_t v42 = swift_bridgeObjectRetain((unint64_t)v24);
        uint64_t v43 = (uint64_t)v46;
        v48(v42);
        _NativeDictionary._insert(at:key:value:)(a4, v50, v43, v24, (uint64_t)v18, (uint64_t)v12);
        goto LABEL_19;
      }
      a3 = v49;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_17;
      }
LABEL_23:
      type metadata accessor for _NativeDictionary(0, (uint64_t)v18, (uint64_t)v12, v7);
      _NativeDictionary.copy()();
      uint64_t v34 = (uint64_t)v51;
      goto LABEL_17;
    }
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  if (v16 < 0) {
    Swift::Int v22 = (void *)v16;
  }
  else {
    Swift::Int v22 = (void *)(v16 & 0xFFFFFFFFFFFFFF8);
  }
  id v23 = [v22 sel_count:v46, v47, v48];
  if (__OFADD__(v23, 1))
  {
    __break(1u);
    goto LABEL_21;
  }
  uint64_t v7 = *(void *)(v7 + 32);
  unint64_t v24 = _NativeDictionary.init(_:capacity:)(v22, (uint64_t)v23 + 1, v18, v12, v7);
  unint64_t v51 = v24;
  unint64_t v25 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v18, v7);
  BOOL v27 = v24[2];
  BOOL v28 = (v26 & 1) == 0;
  a3 = (Swift::Int)v27 + v28;
  if (__OFADD__(v27, v28))
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  a4 = v25;
  char v29 = v26;
  if ((uint64_t)v24[3] >= a3) {
    goto LABEL_10;
  }
  type metadata accessor for _NativeDictionary(0, (uint64_t)v18, (uint64_t)v12, v7);
  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(a3, 1);
  unint64_t v24 = v51;
  unint64_t v30 = __RawDictionaryStorage.find<A>(_:)(v50, (uint64_t)v18, v7);
  if ((v29 & 1) != (v31 & 1)) {
LABEL_24:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v18);
  a4 = v30;
LABEL_10:
  *uint64_t v6 = (uint64_t)v24;
  a3 = v49;
  if ((v29 & 1) == 0) {
    goto LABEL_18;
  }
LABEL_11:
  uint64_t v32 = *(void (**)(uint64_t, char *))(*((void *)v18 - 1) + 8);
  swift_bridgeObjectRetain((unint64_t)v24);
  v32(v50, v18);
LABEL_19:
  Swift::Int v44 = v24[7];
  swift_bridgeObjectRelease((uint64_t)v24);
  return (*(uint64_t (**)(unint64_t, Swift::Int, uint64_t *))(v13 + 40))((unint64_t)v44 + *(void *)(v13 + 72) * a4, a3, v12);
}

__objc2_class **Dictionary.mapValues<A>(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, char *a5, uint64_t a6, uint64_t a7)
{
  if ((a3 & 0xC000000000000001) == 0) {
    return (__objc2_class **)_NativeDictionary.mapValues<A>(_:)(a1, a2, a3, (uint64_t)a4, (uint64_t)a5, a6);
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return __CocoaDictionary.mapValues<A, B, C>(_:)(a1, a2, (Class *)a3, a4, a5, a6, a7);
}

__objc2_class **Dictionary._Variant.mapValues<A>(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, char *a5, uint64_t a6, uint64_t a7)
{
  if ((a3 & 0xC000000000000001) == 0) {
    return (__objc2_class **)_NativeDictionary.mapValues<A>(_:)(a1, a2, a3, (uint64_t)a4, (uint64_t)a5, a6);
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return __CocoaDictionary.mapValues<A, B, C>(_:)(a1, a2, (Class *)a3, a4, a5, a6, a7);
}

__objc2_class **Dictionary.compactMapValues<A>(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v136 = a7;
  v154 = (char *)a4;
  v142 = a1;
  uint64_t v143 = a2;
  v127 = type metadata accessor for Optional(0, a6, a3, a4);
  uint64_t v155 = (uint64_t)*(v127 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v127);
  v149 = (char *)&v101 - v12;
  uint64_t v152 = a6;
  unint64_t v151 = *(void *)(a6 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  v139 = (char *)&v101 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  v126 = (char *)&v101 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a4, (uint64_t)a5, "key value ", 0);
  int64_t v150 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v138 = (uint64_t)&v101 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v20 = (char *)&v101 - v19;
  v112 = type metadata accessor for Optional(0, (uint64_t)a5, v21, v22);
  v147 = (void (**)(void, void, void))*(v112 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v112);
  v115 = (char *)&v101 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  uint64_t v114 = (char *)&v101 - v25;
  uint64_t v113 = type metadata accessor for Optional(0, a4, v26, v27);
  uint64_t v28 = (uint64_t)*(v113 - 1);
  uint64_t v29 = MEMORY[0x1F4188790](v113);
  v111 = (char *)&v101 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v110 = (char *)&v101 - v32;
  v153 = a5;
  uint64_t v135 = *(a5 - 1);
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v133 = (char *)&v101 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v134 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v33);
  v132 = (char *)&v101 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v36 = TupleTypeMetadata2;
  unint64_t v39 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v37, v38);
  MEMORY[0x1F4188790](v39 - 1);
  uint64_t v41 = (char *)&v101 - v40;
  v158 = &_swiftEmptyDictionarySingleton;
  if ((a3 & 0xC000000000000001) != 0)
  {
    if (a3 < 0) {
      uint64_t v42 = a3;
    }
    else {
      uint64_t v42 = a3 & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v43 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v44 = (unint64_t)swift_allocObject(v43, 0xE8uLL, 7uLL);
    uint64_t v120 = 0;
    uint64_t v45 = 0;
    unint64_t v46 = 0;
    *(void *)(v44 + 208) = v42;
    *(void *)(v44 + 216) = 0;
    *(_OWORD *)(v44 + 16) = 0u;
    *(_OWORD *)(v44 + 32) = 0u;
    *(_OWORD *)(v44 + 48) = 0u;
    *(_OWORD *)(v44 + 64) = 0u;
    *(_OWORD *)(v44 + 80) = 0u;
    *(_OWORD *)(v44 + 96) = 0u;
    *(_OWORD *)(v44 + 112) = 0u;
    *(_OWORD *)(v44 + 128) = 0u;
    *(_OWORD *)(v44 + 144) = 0u;
    *(_OWORD *)(v44 + 160) = 0u;
    *(_OWORD *)(v44 + 176) = 0u;
    *(_OWORD *)(v44 + 192) = 0u;
    *(void *)(v44 + 224) = 0;
    unint64_t v47 = v44 | 0x8000000000000000;
  }
  else
  {
    uint64_t v48 = -1 << *(unsigned char *)(a3 + 32);
    uint64_t v45 = ~v48;
    uint64_t v49 = *(void *)(a3 + 64);
    uint64_t v120 = a3 + 64;
    uint64_t v50 = -v48;
    if (v50 < 64) {
      uint64_t v51 = ~(-1 << v50);
    }
    else {
      uint64_t v51 = -1;
    }
    unint64_t v46 = v51 & v49;
    unint64_t v47 = a3;
  }
  uint64_t v118 = (v47 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v129 = v47 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v117 = (v47 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v109 = (void (**)(char *, uint64_t, uint64_t, char *))(v134 + 56);
  uint64_t v108 = (void (**)(char *, void *, Class *))(v28 + 16);
  v107 = (unsigned int (**)(char *, uint64_t, char *))(v134 + 48);
  uint64_t v106 = (void (**)(void *, Class *))(v28 + 8);
  v148 = (void (**)(void))(v134 + 32);
  uint64_t v105 = (void (**)(char *, uint64_t, uint64_t, const char *))(v135 + 56);
  uint64_t v104 = (void (**)(char *, void *, Class *))(v147 + 2);
  uint64_t v103 = (unsigned int (**)(char *, uint64_t, const char *))(v135 + 48);
  unint64_t v102 = (void (**)(char *, Class *))(v147 + 1);
  v147 = (void (**)(void, void, void))(v135 + 32);
  v144 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v150 + 56);
  uint64_t v116 = v45;
  int64_t v119 = (unint64_t)(v45 + 64) >> 6;
  uint64_t v131 = v134 + 16;
  uint64_t v130 = v135 + 16;
  v140 = (void (**)(char *, char *, uint64_t *))(v150 + 32);
  v137 = (unsigned int (**)(char *, uint64_t, uint64_t))(v151 + 48);
  v124 = (void (**)(char *, char *, uint64_t))(v151 + 32);
  v123 = (void (**)(uint64_t, uint64_t *))(v135 + 8);
  uint64_t v128 = (void (**)(char *, uint64_t *))(v150 + 8);
  v122 = (void (**)(char *, Class *))(v155 + 8);
  swift_bridgeObjectRetain(a3);
  int64_t v52 = 0;
  v121 = qword_1ECA06328;
  uint64_t v53 = v149;
  v146 = v41;
  unint64_t v141 = v47;
  v125 = v36;
  v145 = v20;
  unint64_t v151 = v46;
  if ((v47 & 0x8000000000000000) == 0) {
    goto LABEL_28;
  }
LABEL_11:
  uint64_t v54 = v129;
  uint64_t v55 = *(void *)(v129 + 216);
  unint64_t v56 = v154;
  if (v55 < 0) {
    goto LABEL_55;
  }
  int v57 = *(void **)(v129 + 208);
  if (v55 != *(void *)(v129 + 224)) {
    goto LABEL_15;
  }
  id v58 = [*(id *)(v129 + 208) countByEnumeratingWithState:v118 objects:v117 count:16];
  uint64_t v54 = v129;
  *(void *)(v129 + 224) = v58;
  if (!v58)
  {
    *(void *)(v54 + 216) = -1;
LABEL_55:
    (*v144)(v41, 1, 1, v36);
    outlined consume of [A : B].Iterator._Variant<A, B>(v47);
    return v158;
  }
  uint64_t v55 = 0;
  *(void *)(v54 + 216) = 0;
LABEL_15:
  uint64_t v59 = *(void *)(v54 + 24);
  if (!v59) {
    goto LABEL_61;
  }
  if ((unint64_t)(v55 - 0x1000000000000000) >> 61 != 7)
  {
    __break(1u);
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
  }
  uint64_t v60 = (void **)(v59 + 8 * v55);
  if ((v60 & 7) != 0) {
    goto LABEL_58;
  }
  atomic_ullong v61 = *v60;
  *(void *)(v54 + 216) = v55 + 1;
  swift_unknownObjectRetain(v61);
  BOOL v62 = [v57 objectForKey:v61];
  if (!v62)
  {
    unint64_t v100 = 784;
    goto LABEL_63;
  }
  atomic_ullong v63 = v62;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v56, (uint64_t *)v56))
  {
    v157 = (swift *)v61;
    swift_dynamicCast(v41, (unint64_t *)&v157, v121, v56, 7uLL);
  }
  else
  {
    char v67 = v110;
    (*v109)(v110, 1, 1, v56);
    _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v61, (uint64_t)v56, v67);
    swift_unknownObjectRelease(v61);
    uint64_t v68 = v111;
    (*v108)(v111, v67, v113);
    if ((*v107)(v68, 1, v56) == 1) {
      goto LABEL_64;
    }
    (*v106)(v67, v113);
    ((void (*)(char *, char *, char *))*v148)(v41, v68, v56);
  }
  uint64_t v64 = &v41[*((int *)v36 + 12)];
  uint64_t v65 = (const char *)v153;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v153, v153))
  {
    v157 = v63;
    swift_dynamicCast(v64, (unint64_t *)&v157, qword_1ECA06328, v65, 7uLL);
    goto LABEL_23;
  }
  uint64_t v69 = v114;
  (*v105)(v114, 1, 1, v65);
  _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v63, (uint64_t)v65, v69);
  swift_unknownObjectRelease(v63);
  uint64_t v70 = v112;
  (*v104)(v115, v69, v112);
  if ((*v103)(v115, 1, v65) == 1) {
LABEL_64:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
  (*v102)(v114, v70);
  (*v147)(v64, v115, v65);
LABEL_23:
  (*v144)(v41, 0, 1, v36);
  int64_t v66 = v52;
  uint64_t v155 = v151;
  while (1)
  {
    (*v140)(v20, v41, v36);
    uint64_t v87 = &v20[*((int *)v36 + 12)];
    uint64_t v88 = v156;
    v142(v87);
    uint64_t v156 = v88;
    if (v88) {
      break;
    }
    uint64_t v89 = v152;
    if ((*v137)(v53, 1, v152) == 1)
    {
      (*v128)(v20, v36);
      (*v122)(v53, v127);
      int64_t v52 = v66;
      unint64_t v46 = v155;
    }
    else
    {
      unint64_t v90 = *v124;
      uint64_t v91 = v126;
      (*v124)(v126, v53, v89);
      uint64_t v92 = v138 + *((int *)v36 + 12);
      unint64_t v93 = (unint64_t)v154;
      (*v148)();
      v94 = v153;
      (*v147)(v92, v87, v153);
      v90(v139, v91, v89);
      v95 = v158;
      v96 = v158[2];
      if (v158[3] <= v96)
      {
        Swift::Int v97 = (Swift::Int)&v96->isa + 1;
        type metadata accessor for _NativeDictionary(0, v93, v152, v136);
        Swift::Int v98 = v97;
        uint64_t v89 = v152;
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v98, 1);
        v95 = v158;
      }
      _NativeDictionary._unsafeInsertNew(key:value:)(v138, (uint64_t)v139, v95, v93, v89, v136);
      (*v123)(v92, v94);
      int64_t v52 = v66;
      unint64_t v46 = v155;
      uint64_t v53 = v149;
      uint64_t v20 = v145;
      uint64_t v41 = v146;
      char v36 = v125;
    }
    unint64_t v47 = v141;
    unint64_t v151 = v46;
    if ((v141 & 0x8000000000000000) != 0) {
      goto LABEL_11;
    }
LABEL_28:
    int64_t v150 = v52;
    if (v46)
    {
      unint64_t v71 = v36;
      uint64_t v155 = (v46 - 1) & v46;
      unint64_t v72 = __clz(__rbit64(v46)) | (v52 << 6);
      int64_t v66 = v52;
    }
    else
    {
      int64_t v66 = v52 + 1;
      if (__OFADD__(v52, 1))
      {
        __break(1u);
        goto LABEL_60;
      }
      if (v66 >= v119) {
        goto LABEL_55;
      }
      unint64_t v73 = *(void *)(v120 + 8 * v66);
      if (!v73)
      {
        int64_t v74 = v52 + 2;
        if (v52 + 2 >= v119) {
          goto LABEL_55;
        }
        unint64_t v73 = *(void *)(v120 + 8 * v74);
        if (!v73)
        {
          int64_t v74 = v52 + 3;
          if (v52 + 3 >= v119) {
            goto LABEL_55;
          }
          unint64_t v73 = *(void *)(v120 + 8 * v74);
          if (!v73)
          {
            while (1)
            {
              int64_t v66 = v74 + 1;
              if (__OFADD__(v74, 1)) {
                break;
              }
              if (v66 >= v119) {
                goto LABEL_55;
              }
              unint64_t v73 = *(void *)(v120 + 8 * v66);
              ++v74;
              if (v73) {
                goto LABEL_38;
              }
            }
LABEL_60:
            __break(1u);
LABEL_61:
            unint64_t v100 = 773;
LABEL_63:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v100, 0);
          }
        }
        int64_t v66 = v74;
      }
LABEL_38:
      unint64_t v71 = v36;
      uint64_t v155 = (v73 - 1) & v73;
      unint64_t v72 = __clz(__rbit64(v73)) + (v66 << 6);
    }
    uint64_t v75 = v134;
    uint64_t v76 = v132;
    Swift::Int v77 = v154;
    (*(void (**)(char *, unint64_t, char *))(v134 + 16))(v132, *(void *)(v47 + 48) + *(void *)(v134 + 72) * v72, v154);
    uint64_t v78 = *(void *)(v47 + 56);
    uint64_t v79 = v135;
    unint64_t v80 = v133;
    char v81 = v153;
    (*(void (**)(char *, unint64_t, uint64_t *))(v135 + 16))(v133, v78 + *(void *)(v135 + 72) * v72, v153);
    unint64_t v82 = v71;
    uint64_t v83 = *((int *)v71 + 12);
    uint64_t v41 = v146;
    v84 = &v146[v83];
    uint64_t v85 = v76;
    uint64_t v86 = v82;
    (*(void (**)(char *, char *, char *))(v75 + 32))(v146, v85, v77);
    (*(void (**)(char *, char *, uint64_t *))(v79 + 32))(v84, v80, v81);
    char v36 = v86;
    (*v144)(v41, 0, 1, v86);
    uint64_t v53 = v149;
    uint64_t v20 = v145;
  }
  (*v128)(v20, v36);
  swift_release((uint64_t)v158);
  return (__objc2_class **)outlined consume of [A : B].Iterator._Variant<A, B>(v141);
}

uint64_t Sequence.reduce<A>(into:_:)@<X0>(uint64_t a1@<X0>, void (*a2)(uint64_t, char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int **a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v43 = a6;
  uint64_t v36 = a5;
  uint64_t v41 = a2;
  uint64_t v42 = a3;
  uint64_t v45 = a1;
  uint64_t v33 = a7;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v34 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v33 - v11;
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t v16 = MEMORY[0x1F4188790](v15 - 1);
  uint64_t v18 = (char *)&v33 - v17;
  uint64_t v19 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v33 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = swift_getAssociatedTypeWitness(0, a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v35 = *((void *)v22 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v24 = (int **)((char *)&v33 - v23);
  (*(void (**)(char *, const char *, uint64_t))(v19 + 16))(v21, v44, a4);
  uint64_t v25 = (uint64_t)v43;
  ((void (*)(uint64_t, int **))v43[4])(a4, v43);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v25, a4, (uint64_t)v22, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v27 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v43 = v24;
  unint64_t v44 = v22;
  uint64_t v40 = v27;
  v27(v22, AssociatedConformanceWitness);
  uint64_t v28 = v34;
  uint64_t v29 = *(unsigned int (**)(char *, uint64_t, const char *))(v34 + 48);
  if (v29(v18, 1, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(int **, const char *))(v35 + 8))(v43, v44);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v36 - 8) + 32))(v33, v45);
  }
  else
  {
    uint64_t v37 = v29;
    uint64_t v38 = AssociatedConformanceWitness + 16;
    uint64_t v39 = AssociatedConformanceWitness;
    uint64_t v30 = *(void (**)(char *, char *, const char *))(v28 + 32);
    uint64_t v31 = (void (**)(char *, const char *))(v28 + 8);
    while (1)
    {
      v30(v12, v18, AssociatedTypeWitness);
      v41(v45, v12);
      if (v7) {
        break;
      }
      (*v31)(v12, AssociatedTypeWitness);
      v40(v44, v39);
      if (v37(v18, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }
    (*v31)(v12, AssociatedTypeWitness);
    (*(void (**)(int **, const char *))(v35 + 8))(v43, v44);
    return (*(uint64_t (**)(uint64_t))(*(void *)(v36 - 8) + 8))(v45);
  }
}

void Dictionary.updateValue(_:forKey:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = type metadata accessor for Dictionary._Variant(0, a3[2], a3[3], a3[4]);

  Dictionary._Variant.updateValue(_:forKey:)(a1, a2, v7, a4);
}

void Dictionary._Variant.updateValue(_:forKey:)(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  uint64_t v11 = (char *)a3[2];
  uint64_t v12 = (uint64_t *)a3[3];
  if ((v10 & 0xC000000000000001) != 0)
  {
    if (v10 < 0) {
      uint64_t v13 = (void *)v10;
    }
    else {
      uint64_t v13 = (void *)(v10 & 0xFFFFFFFFFFFFFF8);
    }
    id v14 = [v13 count];
    if (__OFADD__(v14, 1))
    {
      __break(1u);
    }
    else
    {
      uint64_t v15 = a3[4];
      uint64_t v20 = _NativeDictionary.init(_:capacity:)(v13, (uint64_t)v14 + 1, v11, v12, v15);
      uint64_t v16 = type metadata accessor for _NativeDictionary(0, (uint64_t)v11, (uint64_t)v12, v15);
      _NativeDictionary.updateValue(_:forKey:isUnique:)(a1, a2, 1, (uint64_t)v16, a4);
      uint64_t *v5 = (uint64_t)v20;
    }
  }
  else
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v10);
    uint64_t v21 = *v5;
    uint64_t *v5 = 0x8000000000000000;
    uint64_t v18 = type metadata accessor for _NativeDictionary(0, (uint64_t)v11, (uint64_t)v12, a3[4]);
    _NativeDictionary.updateValue(_:forKey:isUnique:)(a1, a2, isUniquelyReferenced_nonNull_native, (uint64_t)v18, a4);
    uint64_t v19 = *v5;
    uint64_t *v5 = v21;
    swift_bridgeObjectRelease(v19);
  }
}

void Dictionary.merge<A>(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  BOOL v9 = type metadata accessor for Dictionary._Variant(0, a4[2], a4[3], a4[4]);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)(a1, a2, a3, (uint64_t)v9, a5);
}

void Dictionary._Variant.merge<A>(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = v5;
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  id v14 = (char *)&v33 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = *v7;
  uint64_t v19 = *(char **)(v18 + 16);
  uint64_t v20 = *(uint64_t **)(v18 + 24);
  BOOL v21 = (*v7 & 0xC000000000000001) == 0;
  uint64_t v35 = v22;
  uint64_t v36 = v23;
  uint64_t v33 = v6;
  uint64_t v34 = v24;
  if (v21)
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v17);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))(v16, a1, a5);
    uint64_t v37 = (__objc2_class **)*v7;
    *uint64_t v7 = 0x8000000000000000;
    uint64_t v31 = type metadata accessor for _NativeDictionary(0, (uint64_t)v19, (uint64_t)v20, *(void *)(a4 + 32));
    specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)((uint64_t)v16, isUniquelyReferenced_nonNull_native, v34, v35, (uint64_t)v31, a5, v36);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v16, a5);
    uint64_t v32 = *v7;
    *uint64_t v7 = (uint64_t)v37;
    swift_bridgeObjectRelease(v32);
  }
  else
  {
    if (v17 < 0) {
      uint64_t v25 = (void *)v17;
    }
    else {
      uint64_t v25 = (void *)(v17 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(v17);
    id v26 = [v25 count];
    uint64_t v27 = *(void *)(a4 + 32);
    uint64_t v37 = _NativeDictionary.init(_:capacity:)(v25, (uint64_t)v26, v19, v20, v27);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))(v14, a1, a5);
    uint64_t v28 = type metadata accessor for _NativeDictionary(0, (uint64_t)v19, (uint64_t)v20, v27);
    uint64_t v29 = v33;
    specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)((uint64_t)v14, 1, v34, v35, (uint64_t)v28, a5, v36);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, a5);
    if (v29)
    {
      swift_release((uint64_t)v37);
    }
    else
    {
      swift_bridgeObjectRelease(*v7);
      *uint64_t v7 = (uint64_t)v37;
    }
  }
}

void Dictionary.merge(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v8 = swift_allocObject(qword_1EC9F2988, 0x28uLL, 7uLL);
  uint64_t v9 = a4[2];
  uint64_t v10 = a4[3];
  v8[2] = v9;
  v8[3] = v10;
  uint64_t v11 = a4[4];
  v8[4] = v11;
  uint64_t v12 = swift_allocObject(qword_1EC9F29B0, 0x38uLL, 7uLL);
  v12[2] = v9;
  uint64_t v12[3] = v10;
  v12[4] = v11;
  v12[5] = partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:);
  v12[6] = v8;
  v19[0] = a1;
  v19[1] = partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B);
  v19[2] = v12;
  uint64_t v13 = type metadata accessor for Dictionary._Variant(0, v9, v10, v11);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, v9, v10, 0, 0);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A : B], a4, v15);
  uint64_t v17 = (unint64_t *)type metadata accessor for LazyMapSequence(0, (uint64_t)a4, (uint64_t)TupleTypeMetadata2, WitnessTable);
  swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>, v17, v18);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)((uint64_t)v19, a2, a3, (uint64_t)v13, (uint64_t)v17);
}

uint64_t thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(uint64_t, uint64_t, uint64_t, uint64_t)@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v10 = a1 + *((int *)swift_getTupleTypeMetadata2(0, a3, a4, "key value ", 0) + 12);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a3, a4, 0, 0);
  return a2(a5, a5 + *((int *)TupleTypeMetadata2 + 12), a1, v10);
}

atomic_ullong *LazySequenceProtocol.map<A>(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  id v14 = (void *)(a6
                 + *((int *)type metadata accessor for LazyMapSequence(0, (uint64_t)AssociatedTypeWitness, a4, AssociatedConformanceWitness)+ 11));
  *id v14 = a1;
  v14[1] = a2;

  return swift_retain(a2);
}

uint64_t Dictionary.merging<A>(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = type metadata accessor for Dictionary._Variant(0, a5, a6, a8);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)(a1, a2, a3, (uint64_t)v13, a7);
  if (v8) {
    swift_bridgeObjectRelease(a4);
  }
  return a4;
}

void Dictionary.merging(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v24 = a4;
  id v14 = swift_allocObject(qword_1EC9F29D8, 0x28uLL, 7uLL);
  v14[2] = a5;
  _OWORD v14[3] = a6;
  v14[4] = a7;
  uint64_t v15 = swift_allocObject(qword_1EC9F2A00, 0x38uLL, 7uLL);
  v15[2] = a5;
  v15[3] = a6;
  v15[4] = a7;
  v15[5] = partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:);
  void v15[6] = v14;
  v23[0] = a1;
  v23[1] = partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B);
  v23[2] = v15;
  uint64_t v16 = type metadata accessor for Dictionary._Variant(0, a5, a6, a7);
  uint64_t v17 = (unint64_t *)type metadata accessor for Dictionary(255, a5, a6, a7);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, a5, a6, 0, 0);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A : B], v17, v19);
  BOOL v21 = (unint64_t *)type metadata accessor for LazyMapSequence(0, (uint64_t)v17, (uint64_t)TupleTypeMetadata2, WitnessTable);
  swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>, v21, v22);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)((uint64_t)v23, a2, a3, (uint64_t)v16, (uint64_t)v21);
  if (v7) {
    swift_bridgeObjectRelease(v24);
  }
}

void Dictionary.remove(at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t *a6)
{
  char v10 = a5 & 1;
  uint64_t v11 = type metadata accessor for Dictionary._Variant(0, a6[2], a6[3], a6[4]);

  Dictionary._Variant.remove(at:)(a1, a2, a3, a4, v10, (uint64_t)v11);
}

void Dictionary._Variant.remove(at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v7 = (unint64_t *)v6;
  uint64_t v38 = a1;
  uint64_t v39 = a2;
  uint64_t v12 = *(char **)(a6 + 16);
  uint64_t v13 = *((void *)v12 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v37 = (char *)&v35 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *v6;
  uint64_t v17 = *(uint64_t **)(v16 + 24);
  if ((*v6 & 0xC000000000000001) != 0)
  {
    if (v15 < 0) {
      uint64_t v18 = (void *)*v6;
    }
    else {
      uint64_t v18 = (void *)(v15 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(v15);
    uint64_t v19 = _NativeDictionary.init(_:capacity:)(v18, (uint64_t)[v18 count], v12, v17, *(void *)(a6 + 32));
    uint64_t v20 = a4;
    unint64_t v21 = *v7;
    *uint64_t v7 = (unint64_t)v19;
    swift_retain((atomic_ullong *)v19);
    uint64_t v22 = v21;
    a4 = v20;
    swift_bridgeObjectRelease(v22);
    if ((a5 & 1) == 0) {
      goto LABEL_6;
    }
LABEL_15:
    uint64_t v36 = a4;
    if (a3 >= 0) {
      uint64_t v25 = a3 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v25 = a3;
    }
    uint64_t v26 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a3);
    if (swift_dynamicCastClass(v25, v26))
    {
      if (*((_DWORD *)v19 + 9) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v25 + 16))) {
        goto LABEL_26;
      }
      if (swift_dynamicCastClass(v25, v26))
      {
        uint64_t v27 = *(void *)(v25 + 24);
        uint64_t v28 = v36;
        if (*(void *)(v27 + 16) <= v36) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        uint64_t v29 = *(void **)(v27 + 8 * v36 + 24);
        swift_unknownObjectRetain(v29);
        outlined consume of [A : B].Index._Variant<A, B>(a3, v28, 1);
        uint64_t v30 = v37;
        _forceBridgeFromObjectiveC<A>(_:_:)(v29, v12, v31, v37);
        swift_unknownObjectRelease(v29);
        a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v30, (uint64_t)v12, *(void *)(a6 + 32));
        LOBYTE(v29) = v32;
        (*(void (**)(char *, char *))(v13 + 8))(v30, v12);
        if (v29) {
          goto LABEL_23;
        }
LABEL_26:
        unint64_t v23 = 303;
LABEL_11:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v23, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (!swift_isUniquelyReferenced_nonNull_native(v15))
  {
    uint64_t v40 = *v6;
    *uint64_t v6 = 0x8000000000000000;
    type metadata accessor for _NativeDictionary(0, (uint64_t)v12, (uint64_t)v17, *(void *)(a6 + 32));
    _NativeDictionary.copy()();
    uint64_t v24 = *v6;
    *uint64_t v6 = v40;
    swift_bridgeObjectRelease(v24);
  }
  uint64_t v19 = (__objc2_class **)*v6;
  swift_bridgeObjectRetain(*v7);
  if (a5) {
    goto LABEL_15;
  }
LABEL_6:
  if (a3 < 0
    || 1 << *((unsigned char *)v19 + 32) <= a3
    || (((unint64_t)v19[((unint64_t)a3 >> 6) + 8] >> a3) & 1) == 0
    || *((_DWORD *)v19 + 9) != a4)
  {
    unint64_t v23 = 281;
    goto LABEL_11;
  }
LABEL_23:
  swift_release((uint64_t)v19);
  unint64_t v33 = *v7;
  *uint64_t v7 = 0x8000000000000000;
  (*(void (**)(uint64_t, uint64_t, char *))(v13 + 32))(v38, *(void *)(v33 + 48) + *(void *)(v13 + 72) * a3, v12);
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(v17 - 1) + 32))(v39, *(void *)(v33 + 56) + *(void *)(*(v17 - 1) + 72) * a3, v17);
  _NativeDictionary._delete(at:)((Swift::_HashTable::Bucket)a3);
  uint64_t v34 = *v7;
  *uint64_t v7 = v33;
  swift_bridgeObjectRelease(v34);
}

uint64_t specialized Dictionary._Variant.removeValue(forKey:)(unint64_t a1, unint64_t a2)
{
  unint64_t v3 = v2;
  uint64_t v6 = *v3;
  swift_bridgeObjectRetain(*v3);
  Swift::Int v7 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
  LOBYTE(a2) = v8;
  swift_bridgeObjectRelease(v6);
  if ((a2 & 1) == 0) {
    return 0;
  }
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v10 = *v3;
  unint64_t v15 = *v3;
  *unint64_t v3 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized _NativeDictionary.copy()();
    uint64_t v10 = v15;
  }
  swift_bridgeObjectRelease(*(void *)(*(void *)(v10 + 48) + 16 * v7 + 8));
  uint64_t v11 = *(void *)(*(void *)(v10 + 56) + 16 * v7);
  v12.offset = v7;
  specialized _NativeDictionary._delete(at:)(v12, v10);
  uint64_t v13 = *v3;
  *unint64_t v3 = v10;
  swift_bridgeObjectRelease(v13);
  return v11;
}

double specialized Dictionary._Variant.removeValue(forKey:)@<D0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v4;
  swift_bridgeObjectRetain(*v4);
  Swift::Int v9 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
  LOBYTE(a2) = v10;
  swift_bridgeObjectRelease(v8);
  if (a2)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
    uint64_t v12 = *v4;
    unint64_t v17 = *v4;
    *uint64_t v4 = 0x8000000000000000;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeDictionary.copy()();
      uint64_t v12 = v17;
    }
    swift_bridgeObjectRelease(*(void *)(*(void *)(v12 + 48) + 16 * v9 + 8));
    uint64_t v13 = *(void *)(v12 + 56) + 40 * v9;
    long long v18 = *(_OWORD *)v13;
    long long v19 = *(_OWORD *)(v13 + 16);
    uint64_t v20 = *(void *)(v13 + 32);
    v14.offset = v9;
    specialized _NativeDictionary._delete(at:)(v14, v12);
    uint64_t v15 = *v4;
    *uint64_t v4 = v12;
    swift_bridgeObjectRelease(v15);
    double result = *(double *)&v18;
    *(_OWORD *)a3 = v18;
    *(_OWORD *)(a3 + 16) = v19;
    *(void *)(a3 + 32) = v20;
  }
  else
  {
    *(void *)(a3 + 32) = 0;
    double result = 0.0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return result;
}

double specialized Dictionary._Variant.removeValue(forKey:)@<D0>(unint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v4;
  swift_bridgeObjectRetain(*v4);
  Swift::Int v9 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
  LOBYTE(a2) = v10;
  swift_bridgeObjectRelease(v8);
  if (a2)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
    uint64_t v12 = *v4;
    unint64_t v16 = *v4;
    *uint64_t v4 = 0x8000000000000000;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeDictionary.copy()();
      uint64_t v12 = v16;
    }
    swift_bridgeObjectRelease(*(void *)(*(void *)(v12 + 48) + 16 * v9 + 8));
    outlined init with take of Any((_OWORD *)(*(void *)(v12 + 56) + 32 * v9), v17);
    v13.offset = v9;
    specialized _NativeDictionary._delete(at:)(v13, v12);
    uint64_t v14 = *v4;
    *uint64_t v4 = v12;
    swift_bridgeObjectRelease(v14);
    outlined init with take of Any(v17, a3);
  }
  else
  {
    double result = 0.0;
    *a3 = 0u;
    a3[1] = 0u;
  }
  return result;
}

double specialized Dictionary._Variant.removeValue(forKey:)@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  unint64_t v3 = v2;
  uint64_t v6 = *v3;
  swift_bridgeObjectRetain(*v3);
  Swift::Int v7 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
  LOBYTE(a1) = v8;
  swift_bridgeObjectRelease(v6);
  if (a1)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v10 = *v3;
    unint64_t v14 = *v3;
    *unint64_t v3 = 0x8000000000000000;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeDictionary.copy()();
      uint64_t v10 = v14;
    }
    outlined destroy of AnyHashable((uint64_t *)(*(void *)(v10 + 48) + 40 * v7));
    outlined init with take of Any((_OWORD *)(*(void *)(v10 + 56) + 32 * v7), v15);
    v11.offset = v7;
    specialized _NativeDictionary._delete(at:)(v11, v10);
    uint64_t v12 = *v3;
    *unint64_t v3 = v10;
    swift_bridgeObjectRelease(v12);
    outlined init with take of Any(v15, a2);
  }
  else
  {
    double result = 0.0;
    *a2 = 0u;
    a2[1] = 0u;
  }
  return result;
}

uint64_t specialized Dictionary._Variant.removeValue(forKey:)(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v2;
  swift_bridgeObjectRetain(*v2);
  Swift::Int v5 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
  LOBYTE(a1) = v6;
  swift_bridgeObjectRelease(v4);
  if ((a1 & 1) == 0) {
    return 0;
  }
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
  uint64_t v8 = *v2;
  unint64_t v13 = *v2;
  *uint64_t v2 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized _NativeDictionary.copy()();
    uint64_t v8 = v13;
  }
  outlined destroy of AnyHashable((uint64_t *)(*(void *)(v8 + 48) + 40 * v5));
  uint64_t v9 = *(void *)(*(void *)(v8 + 56) + 16 * v5);
  v10.offset = v5;
  specialized _NativeDictionary._delete(at:)(v10, v8);
  uint64_t v11 = *v2;
  *uint64_t v2 = v8;
  swift_bridgeObjectRelease(v11);
  return v9;
}

uint64_t Dictionary._Variant.removeValue(forKey:)@<X0>(id *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(uint64_t **)(a2 + 24);
  uint64_t v43 = *(v8 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v41 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  unint64_t v13 = (char *)&v41 - v12;
  uint64_t v14 = *v4;
  unint64_t v16 = *(uint64_t **)(v15 + 16);
  if ((*v4 & 0xC000000000000001) != 0)
  {
    uint64_t v42 = a3;
    unint64_t v17 = _bridgeAnythingToObjectiveC<A>(_:)(a1, v16);
    uint64_t v18 = *v4;
    if ((*v4 & 0x8000000000000000) != 0) {
      long long v19 = (void *)*v4;
    }
    else {
      long long v19 = (void *)(*v4 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(*v4);
    id v20 = [v19 objectForKey:v17];
    swift_unknownObjectRelease(v17);
    if (v20)
    {
      swift_unknownObjectRelease(v20);
      id v21 = [v19 count];
      uint64_t v22 = *(void *)(a2 + 32);
      unint64_t v23 = (atomic_ullong *)_NativeDictionary.init(_:capacity:)(v19, (uint64_t)v21, (char *)v16, v8, v22);
      swift_retain(v23);
      unint64_t v24 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)v16, v22);
      char v26 = v25;
      swift_release((uint64_t)v23);
      if ((v26 & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Bridging did not preserve equality", 34, 2, "Swift/DictionaryVariant.swift", 29, 2, 0x195uLL, 0);
      }
      (*(void (**)(unint64_t, uint64_t *))(*(v16 - 1) + 8))(v23[6] + *(void *)(*(v16 - 1) + 72) * v24, v16);
      uint64_t v27 = *(void (**)(char *, unint64_t, uint64_t *))(v43 + 32);
      v27(v11, v23[7] + *(void *)(v43 + 72) * v24, v8);
      _NativeDictionary._delete(at:)((Swift::_HashTable::Bucket)v24);
      uint64_t v28 = *v4;
      *uint64_t v4 = (unint64_t)v23;
      swift_bridgeObjectRelease(v28);
      uint64_t v29 = v42;
      v27(v42, (unint64_t)v11, v8);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t *))(v43 + 56))(v29, 0, 1, v8);
    }
    swift_bridgeObjectRelease(v18);
    uint64_t v39 = v42;
    uint64_t v40 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t *))(v43 + 56);
    goto LABEL_14;
  }
  uint64_t v31 = *(void *)(a2 + 32);
  swift_bridgeObjectRetain(*v4);
  unint64_t v32 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)v16, v31);
  char v34 = v33;
  swift_bridgeObjectRelease(v14);
  if ((v34 & 1) == 0)
  {
    uint64_t v40 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t *))(v43 + 56);
    uint64_t v39 = a3;
LABEL_14:
    return v40(v39, 1, 1, v8);
  }
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
  unint64_t v36 = *v4;
  unint64_t v44 = *v4;
  *uint64_t v4 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    type metadata accessor for _NativeDictionary(0, (uint64_t)v16, (uint64_t)v8, v31);
    _NativeDictionary.copy()();
    unint64_t v36 = v44;
  }
  (*(void (**)(unint64_t, uint64_t *))(*(v16 - 1) + 8))(*(void *)(v36 + 48) + *(void *)(*(v16 - 1) + 72) * v32, v16);
  uint64_t v37 = *(void (**)(char *, unint64_t, uint64_t *))(v43 + 32);
  v37(v13, *(void *)(v36 + 56) + *(void *)(v43 + 72) * v32, v8);
  _NativeDictionary._delete(at:)((Swift::_HashTable::Bucket)v32);
  uint64_t v38 = *v4;
  *uint64_t v4 = v36;
  swift_bridgeObjectRelease(v38);
  v37(a3, (unint64_t)v13, v8);
  return (*(uint64_t (**)(char *, void, uint64_t, uint64_t *))(v43 + 56))(a3, 0, 1, v8);
}

Swift::Void __swiftcall Dictionary.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  type metadata accessor for Dictionary._Variant(0, v1[2], v1[3], v1[4]);

  Dictionary._Variant.removeAll(keepingCapacity:)(keepingCapacity);
}

Swift::Void __swiftcall Dictionary._Variant.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  unint64_t v3 = v2;
  uint64_t v5 = *v2;
  if (!keepingCapacity)
  {
    swift_bridgeObjectRelease(v5);
    *uint64_t v2 = (uint64_t)&_swiftEmptyDictionarySingleton;
    return;
  }
  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v1 + 16);
  if ((v5 & 0xC000000000000001) == 0)
  {
    if (*(uint64_t *)(v5 + 16) <= 0) {
      return;
    }
    goto LABEL_9;
  }
  if (v5 >= 0) {
    v5 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((uint64_t)objc_msgSend((id)v5, sel_count) > 0)
  {
LABEL_9:
    uint64_t v8 = *v3;
    uint64_t v9 = *(void *)(v6 + 24);
    if ((*v3 & 0xC000000000000001) != 0)
    {
      if (v8 < 0) {
        uint64_t v10 = (void *)*v3;
      }
      else {
        uint64_t v10 = (void *)(v8 & 0xFFFFFFFFFFFFFF8);
      }
      id v11 = [v10 count];
      swift_bridgeObjectRelease(v8);
      if (v11)
      {
        type metadata accessor for _DictionaryStorage(0, v7, v9, *(void *)(v6 + 32));
        uint64_t v12 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v11);
      }
      else
      {
        uint64_t v12 = &_swiftEmptyDictionarySingleton;
      }
      *unint64_t v3 = (uint64_t)v12;
    }
    else
    {
      Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
      uint64_t v15 = *v3;
      *unint64_t v3 = 0x8000000000000000;
      type metadata accessor for _NativeDictionary(0, v7, v9, *(void *)(v6 + 32));
      _NativeDictionary.removeAll(isUnique:)(isUniquelyReferenced_nonNull_native);
      uint64_t v14 = *v3;
      *unint64_t v3 = v15;
      swift_bridgeObjectRelease(v14);
    }
  }
}

unint64_t Dictionary.values.getter()
{
  unint64_t v0 = EnumeratedSequence._base.modify();

  return swift_bridgeObjectRetain(v0);
}

uint64_t (*Dictionary.values.modify(void *a1))(uint64_t result)
{
  *a1 = *v1;
  a1[1] = v1;
  *uint64_t v1 = 0x8000000000000000;
  return _ArrayBody.count.modify;
}

unint64_t Dictionary._Variant.init(dummy:)()
{
  return 0x8000000000000000;
}

uint64_t swap<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *(void (**)(char *, uint64_t))(v6 + 32);
  v9(v8, a1);
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(a1, a2, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v9)(a2, v8, a3);
}

void Dictionary.values.setter(uint64_t a1)
{
  swift_bridgeObjectRelease(*v1);
  *uint64_t v1 = a1;
}

void Dictionary.Keys._variant.setter(uint64_t a1)
{
  swift_bridgeObjectRelease(*v1);
  *uint64_t v1 = a1;
}

uint64_t (*Dictionary.Keys._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t *Dictionary.Keys.startIndex.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return (unint64_t *)_NativeDictionary.startIndex.getter(a1);
  }
  if (a1 < 0) {
    uint64_t v2 = (void *)a1;
  }
  else {
    uint64_t v2 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v3 = (unint64_t)[swift_unknownObjectRetain(v2) count];
  double result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v3 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v3, 24))
    {
      uint64_t v5 = swift_bufferAllocate(result, 8 * v3 + 24, 7uLL);
      v5[2] = v3;
      [v2 sel_getObjects_andKeys_count_:0, v5 + 3, v3];
      swift_bridgeObjectRelease(a1);
      uint64_t v6 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v7 = swift_allocObject(v6, 0x20uLL, 7uLL);
      v7[2] = v2;
      v7[3] = v5;
      swift_bridgeObjectRetain(a1);
      return v7;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

unint64_t *Dictionary.Keys.endIndex.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return (unint64_t *)(1 << *(unsigned char *)(a1 + 32));
  }
  if (a1 < 0) {
    uint64_t v2 = (void *)a1;
  }
  else {
    uint64_t v2 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v3 = (unint64_t)[swift_unknownObjectRetain(v2) count];
  double result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v3 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v3, 24))
    {
      uint64_t v5 = swift_bufferAllocate(result, 8 * v3 + 24, 7uLL);
      v5[2] = v3;
      [v2 sel_getObjects_andKeys_count_:0, v5 + 3, v3];
      swift_bridgeObjectRelease(a1);
      uint64_t v6 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v7 = swift_allocObject(v6, 0x20uLL, 7uLL);
      v7[2] = v2;
      v7[3] = v5;
      swift_bridgeObjectRetain(a1);
      return v7;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

Swift::Int Dictionary.Keys.index(after:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = a1;
  uint64_t v9 = a3 & 1;
  if ((a4 & 0xC000000000000001) == 0) {
    return _NativeDictionary.index(after:)(a1, a2, v9, a4, a5, a6, a7);
  }
  if (a4 < 0) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a4 & 0xFFFFFFFFFFFFFF8;
  }
  if (!v9) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  if (a1 >= 0) {
    uint64_t v11 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v11 = a1;
  }
  outlined copy of [A : B].Index._Variant<A, B>(a1, a2, 1);
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v11, v12)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(void *)(v11 + 16) != v10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E7uLL, 0);
  }
  if (*(void *)(*(void *)(v11 + 24) + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  return v8;
}

void Dictionary.Keys.subscript.getter(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X6>, char *a6@<X8>)
{
  uint64_t v10 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v16 & 0xC000000000000001) == 0)
  {
    if ((v13 & 1) == 0)
    {
      if (v10 < 0
        || 1 << *(unsigned char *)(a3 + 32) <= v10
        || ((*(void *)(a3 + 8 * ((unint64_t)v10 >> 6) + 64) >> v10) & 1) == 0
        || *(_DWORD *)(a3 + 36) != a2)
      {
        unint64_t v21 = 281;
        goto LABEL_15;
      }
LABEL_24:
      (*(void (**)(char *, uint64_t, char *))(v12 + 16))(a6, *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10, a4);
      return;
    }
    if (v10 >= 0) {
      uint64_t v22 = v10 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v22 = v10;
    }
    uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v10);
    if (swift_dynamicCastClass(v22, v23))
    {
      if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v22 + 16))) {
        goto LABEL_28;
      }
      if (swift_dynamicCastClass(v22, v23))
      {
        uint64_t v24 = *(void *)(v22 + 24);
        if (*(void *)(v24 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        char v25 = *(void **)(v24 + 8 * a2 + 24);
        swift_unknownObjectRetain(v25);
        outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v25, a4, v26, v15);
        swift_unknownObjectRelease(v25);
        uint64_t v10 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, (uint64_t)a4, a5);
        char v28 = v27;
        (*(void (**)(char *, char *))(v12 + 8))(v15, a4);
        if (v28) {
          goto LABEL_24;
        }
LABEL_28:
        unint64_t v21 = 303;
LABEL_15:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v21, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if ((v13 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  if (a3 < 0) {
    uint64_t v17 = a3;
  }
  else {
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v18 = (void *)specialized __CocoaDictionary.key(at:)(v10, a2, v17);
  id v19 = swift_unknownObjectRetain(v18);
  _forceBridgeFromObjectiveC<A>(_:_:)(v19, a4, v20, a6);

  swift_unknownObjectRelease(v18);
}

void Dictionary._Variant.key(at:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X6>, char *a6@<X8>)
{
  uint64_t v10 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v16 & 0xC000000000000001) == 0)
  {
    if ((v13 & 1) == 0)
    {
      if (v10 < 0
        || 1 << *(unsigned char *)(a3 + 32) <= v10
        || ((*(void *)(a3 + 8 * ((unint64_t)v10 >> 6) + 64) >> v10) & 1) == 0
        || *(_DWORD *)(a3 + 36) != a2)
      {
        unint64_t v21 = 281;
        goto LABEL_15;
      }
LABEL_24:
      (*(void (**)(char *, uint64_t, char *))(v12 + 16))(a6, *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10, a4);
      return;
    }
    if (v10 >= 0) {
      uint64_t v22 = v10 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v22 = v10;
    }
    uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v10);
    if (swift_dynamicCastClass(v22, v23))
    {
      if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v22 + 16))) {
        goto LABEL_28;
      }
      if (swift_dynamicCastClass(v22, v23))
      {
        uint64_t v24 = *(void *)(v22 + 24);
        if (*(void *)(v24 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        char v25 = *(void **)(v24 + 8 * a2 + 24);
        swift_unknownObjectRetain(v25);
        outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v25, a4, v26, v15);
        swift_unknownObjectRelease(v25);
        uint64_t v10 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, (uint64_t)a4, a5);
        char v28 = v27;
        (*(void (**)(char *, char *))(v12 + 8))(v15, a4);
        if (v28) {
          goto LABEL_24;
        }
LABEL_28:
        unint64_t v21 = 303;
LABEL_15:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v21, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if ((v13 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  if (a3 < 0) {
    uint64_t v17 = a3;
  }
  else {
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v18 = (void *)specialized __CocoaDictionary.key(at:)(v10, a2, v17);
  id v19 = swift_unknownObjectRetain(v18);
  _forceBridgeFromObjectiveC<A>(_:_:)(v19, a4, v20, a6);

  swift_unknownObjectRelease(v18);
}

id Dictionary.Keys.count.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return *(id *)(a1 + 16);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return [a1 count];
}

uint64_t Dictionary.Keys._customContainsEquatableElement(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      return v9 & 1;
    }
LABEL_9:
    char v9 = 0;
    return v9 & 1;
  }
  uint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  }
  id v8 = [v7 objectForKey:v6];
  swift_unknownObjectRelease(v6);
  if (!v8) {
    goto LABEL_9;
  }
  swift_unknownObjectRelease(v8);
  char v9 = 1;
  return v9 & 1;
}

uint64_t Dictionary._Variant.contains(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      return v9 & 1;
    }
LABEL_9:
    char v9 = 0;
    return v9 & 1;
  }
  uint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  }
  id v8 = [v7 objectForKey:v6];
  swift_unknownObjectRelease(v6);
  if (!v8) {
    goto LABEL_9;
  }
  swift_unknownObjectRelease(v8);
  char v9 = 1;
  return v9 & 1;
}

void *Dictionary.index(forKey:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v18 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if (v19) {
        return (void *)v18;
      }
    }
    return 0;
  }
  uint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  }
  id v8 = [v7 objectForKey:v6];
  if (!v8)
  {
    swift_unknownObjectRelease(v6);
    return 0;
  }
  swift_unknownObjectRelease(v8);
  unint64_t v9 = (unint64_t)[swift_unknownObjectRetain(v7) count];
  uint64_t v10 = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v9 - 0x1000000000000000) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_19;
  }
  if (__OFADD__(8 * v9, 24))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v11 = swift_bufferAllocate(v10, 8 * v9 + 24, 7uLL);
  v11[2] = v9;
  [v7 objectsAndKeys:0, v11 + 3, v9, nil];
  swift_bridgeObjectRelease(a2);
  if ((v11[2] & 0x8000000000000000) != 0) {
    goto LABEL_20;
  }
  swift_unknownObjectRetain(v11);
  uint64_t v12 = 0;
  do
  {
    uint64_t v13 = v12 + 1;
    uint64_t v14 = (void *)v11[v12 + 3];
    swift_unknownObjectRetain(v14);
    char isEqual = swift_stdlib_NSObject_isEqual(v6, v14);
    swift_unknownObjectRelease(v14);
    uint64_t v12 = v13;
  }
  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v11);
  uint64_t v16 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v17 = swift_allocObject(v16, 0x20uLL, 7uLL);
  _OWORD v17[2] = v7;
  v17[3] = v11;
  swift_unknownObjectRetain(v7);
  swift_unknownObjectRelease(v6);
  return v17;
}

uint64_t Optional.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = *(void *)(a2 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a3, a1, a2);
  uint64_t v5 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v7 + 56);

  return v5(a3, 0, 1, a2);
}

void *Dictionary.Keys._customLastIndexOfEquatableElement(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v18 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if (v19) {
        return (void *)v18;
      }
    }
    return 0;
  }
  uint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  }
  id v8 = [v7 objectForKey:v6];
  if (!v8)
  {
    swift_unknownObjectRelease(v6);
    return 0;
  }
  swift_unknownObjectRelease(v8);
  unint64_t v9 = (unint64_t)[swift_unknownObjectRetain(v7) count];
  uint64_t v10 = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v9 - 0x1000000000000000) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_19;
  }
  if (__OFADD__(8 * v9, 24))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v11 = swift_bufferAllocate(v10, 8 * v9 + 24, 7uLL);
  v11[2] = v9;
  [v7 setObjects:v11 + 3 count:v9];
  swift_bridgeObjectRelease(a2);
  if ((v11[2] & 0x8000000000000000) != 0) {
    goto LABEL_20;
  }
  swift_unknownObjectRetain(v11);
  uint64_t v12 = 0;
  do
  {
    uint64_t v13 = v12 + 1;
    uint64_t v14 = (void *)v11[v12 + 3];
    swift_unknownObjectRetain(v14);
    char isEqual = swift_stdlib_NSObject_isEqual(v6, v14);
    swift_unknownObjectRelease(v14);
    uint64_t v12 = v13;
  }
  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v11);
  uint64_t v16 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v17 = swift_allocObject(v16, 0x20uLL, 7uLL);
  _OWORD v17[2] = v7;
  v17[3] = v11;
  swift_unknownObjectRetain(v7);
  swift_unknownObjectRelease(v6);
  return v17;
}

uint64_t static Dictionary.Keys.== infix(_:_:)(int64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v89 = a5;
  uint64_t v91 = *(a3 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (id *)((char *)&v71 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v90 = v9;
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (id *)((char *)&v71 - v11);
  uint64_t v15 = type metadata accessor for Optional(0, v13, v13, v14);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v18 = MEMORY[0x1F4188790](v17);
  uint64_t v19 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v71 - v22;
  unint64_t v96 = a2 & 0xC000000000000001;
  unint64_t v24 = a1 & 0xC000000000000001;
  if ((a1 & 0xC000000000000001) == 0 && !v96 && a1 == a2) {
    return 1;
  }
  if (!v24)
  {
    uint64_t v78 = v21;
    uint64_t v76 = v20;
    uint64_t v77 = v19;
    id v29 = *(id *)(a1 + 16);
    if (v96) {
      goto LABEL_22;
    }
LABEL_15:
    if (v29 == *(id *)(a2 + 16)) {
      goto LABEL_26;
    }
    return 0;
  }
  if (v96)
  {
    uint64_t v26 = a1 & 0xFFFFFFFFFFFFFF8;
    if (a1 < 0) {
      uint64_t v27 = a1;
    }
    else {
      uint64_t v27 = a1 & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v28 = a2 & 0xFFFFFFFFFFFFFF8;
    if (a2 < 0) {
      uint64_t v28 = a2;
    }
    if (v27 == v28) {
      return 1;
    }
  }
  else
  {
    uint64_t v26 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v78 = v21;
  uint64_t v76 = v20;
  uint64_t v77 = v19;
  if (a1 < 0) {
    uint64_t v30 = (void *)a1;
  }
  else {
    uint64_t v30 = (void *)v26;
  }
  id v29 = [v30 count];
  if (!v96) {
    goto LABEL_15;
  }
LABEL_22:
  if (a2 < 0) {
    uint64_t v31 = (void *)a2;
  }
  else {
    uint64_t v31 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  }
  if (v29 != objc_msgSend(v31, sel_count)) {
    return 0;
  }
LABEL_26:
  int64_t v74 = v10;
  if (v24)
  {
    if (a1 < 0) {
      uint64_t v32 = a1;
    }
    else {
      uint64_t v32 = a1 & 0xFFFFFFFFFFFFFF8;
    }
    char v33 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v34 = (unint64_t)swift_allocObject(v33, 0xE8uLL, 7uLL);
    int64_t v84 = 0;
    uint64_t v35 = 0;
    unint64_t v36 = 0;
    *(void *)(v34 + 208) = v32;
    *(void *)(v34 + 216) = 0;
    *(_OWORD *)(v34 + 16) = 0u;
    *(_OWORD *)(v34 + 32) = 0u;
    *(_OWORD *)(v34 + 48) = 0u;
    *(_OWORD *)(v34 + 64) = 0u;
    *(_OWORD *)(v34 + 80) = 0u;
    *(_OWORD *)(v34 + 96) = 0u;
    *(_OWORD *)(v34 + 112) = 0u;
    *(_OWORD *)(v34 + 128) = 0u;
    *(_OWORD *)(v34 + 144) = 0u;
    *(_OWORD *)(v34 + 160) = 0u;
    *(_OWORD *)(v34 + 176) = 0u;
    *(_OWORD *)(v34 + 192) = 0u;
    *(void *)(v34 + 224) = 0;
    unint64_t v37 = v34 | 0x8000000000000000;
  }
  else
  {
    uint64_t v38 = -1 << *(unsigned char *)(a1 + 32);
    uint64_t v35 = ~v38;
    uint64_t v39 = *(void *)(a1 + 64);
    int64_t v84 = a1 + 64;
    uint64_t v40 = -v38;
    if (v40 < 64) {
      uint64_t v41 = ~(-1 << v40);
    }
    else {
      uint64_t v41 = -1;
    }
    unint64_t v36 = v41 & v39;
    unint64_t v37 = a1;
  }
  unint64_t v95 = v37;
  uint64_t v82 = v37 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v79 = (v37 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v80 = (v37 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  v94 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v91 + 56);
  unint64_t v73 = (void (**)(uint64_t, void *, uint64_t))(v16 + 16);
  unint64_t v72 = (unsigned int (**)(uint64_t, uint64_t, uint64_t *))(v91 + 48);
  unint64_t v71 = (void (**)(void *, uint64_t))(v16 + 8);
  unint64_t v93 = (void (**)(id *, char *, uint64_t *))(v91 + 32);
  uint64_t v75 = v35;
  int64_t v83 = (unint64_t)(v35 + 64) >> 6;
  uint64_t v92 = (void (**)(id *, uint64_t *))(v91 + 8);
  uint64_t v42 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
  if (a2 < 0) {
    uint64_t v42 = (void *)a2;
  }
  id v87 = v42;
  uint64_t v88 = v91 + 16;
  swift_bridgeObjectRetain(a1);
  int64_t v43 = 0;
  char v81 = qword_1ECA06328;
  uint64_t v85 = v23;
  uint64_t v86 = v12;
  while (1)
  {
    unint64_t v44 = v36;
    int64_t v45 = v43;
    uint64_t v46 = v95;
    if ((v95 & 0x8000000000000000) != 0) {
      break;
    }
    if (v36)
    {
      unint64_t v47 = __clz(__rbit64(v36));
      v36 &= v36 - 1;
      unint64_t v48 = v47 | (v43 << 6);
    }
    else
    {
      int64_t v57 = v43 + 1;
      if (__OFADD__(v43, 1))
      {
        __break(1u);
LABEL_89:
        __break(1u);
LABEL_90:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x305uLL, 0);
      }
      if (v57 >= v83) {
        goto LABEL_79;
      }
      unint64_t v58 = *(void *)(v84 + 8 * v57);
      ++v43;
      if (!v58)
      {
        int64_t v43 = v45 + 2;
        if (v45 + 2 >= v83) {
          goto LABEL_79;
        }
        unint64_t v58 = *(void *)(v84 + 8 * v43);
        if (!v58)
        {
          int64_t v43 = v45 + 3;
          if (v45 + 3 >= v83) {
            goto LABEL_79;
          }
          unint64_t v58 = *(void *)(v84 + 8 * v43);
          if (!v58)
          {
            int64_t v59 = v45 + 4;
            if (v45 + 4 >= v83)
            {
LABEL_79:
              uint64_t v25 = 1;
              (*v94)(v23, 1, 1, a3);
              outlined consume of [A : B].Iterator._Variant<A, B>(v46);
              return v25;
            }
            unint64_t v58 = *(void *)(v84 + 8 * v59);
            if (!v58)
            {
              while (1)
              {
                int64_t v43 = v59 + 1;
                if (__OFADD__(v59, 1)) {
                  goto LABEL_89;
                }
                if (v43 >= v83) {
                  goto LABEL_79;
                }
                unint64_t v58 = *(void *)(v84 + 8 * v43);
                ++v59;
                if (v58) {
                  goto LABEL_64;
                }
              }
            }
            int64_t v43 = v45 + 4;
          }
        }
      }
LABEL_64:
      unint64_t v36 = (v58 - 1) & v58;
      unint64_t v48 = __clz(__rbit64(v58)) + (v43 << 6);
    }
    uint64_t v60 = v91;
    (*(void (**)(char *, unint64_t, uint64_t *))(v91 + 16))(v23, *(void *)(v95 + 48) + *(void *)(v91 + 72) * v48, a3);
    (*(void (**)(char *, void, uint64_t, uint64_t *))(v60 + 56))(v23, 0, 1, a3);
LABEL_66:
    atomic_ullong v61 = *v93;
    (*v93)(v12, v23, a3);
    if (v96)
    {
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
      {
        if (v90 != 8) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        BOOL v62 = *v12;
        atomic_ullong v63 = *v92;
        swift_unknownObjectRetain(*v12);
        v63(v12, a3);
      }
      else
      {
        char v67 = v74;
        v61(v74, (char *)v12, a3);
        BOOL v62 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v67, a3);
      }
      id v64 = [v87 objectForKey:v62];
      swift_unknownObjectRelease(v62);
      if (!v64)
      {
LABEL_78:
        outlined consume of [A : B].Iterator._Variant<A, B>(v95);
        return 0;
      }
      swift_unknownObjectRelease(v64);
      uint64_t v23 = v85;
      uint64_t v12 = v86;
    }
    else
    {
      if (!*(void *)(a2 + 16))
      {
        outlined consume of [A : B].Iterator._Variant<A, B>(v95);
        (*v92)(v12, a3);
        return 0;
      }
      __RawDictionaryStorage.find<A>(_:)((uint64_t)v12, (uint64_t)a3, v89);
      char v66 = v65;
      (*v92)(v12, a3);
      if ((v66 & 1) == 0) {
        goto LABEL_78;
      }
    }
  }
  uint64_t v49 = (void *)v82;
  uint64_t v50 = *(void *)(v82 + 216);
  uint64_t v51 = v94;
  if (v50 < 0) {
    goto LABEL_84;
  }
  if (v50 != *(void *)(v82 + 224))
  {
LABEL_45:
    uint64_t v53 = v49[3];
    if (!v53) {
      goto LABEL_90;
    }
    if ((unint64_t)(v50 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_87:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
    }
    uint64_t v54 = (void **)(v53 + 8 * v50);
    if ((v54 & 7) != 0) {
      goto LABEL_87;
    }
    uint64_t v55 = *v54;
    v49[27] = v50 + 1;
    swift_unknownObjectRetain(v55);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
    {
      Swift::Int v97 = v55;
      swift_dynamicCast(v23, (unint64_t *)&v97, v81, (const char *)a3, 7uLL);
      unint64_t v56 = *v51;
    }
    else
    {
      unint64_t v56 = *v51;
      (*v51)((char *)v78, 1, 1, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v55, (uint64_t)a3, (char *)v78);
      swift_unknownObjectRelease(v55);
      uint64_t v68 = v76;
      uint64_t v69 = v77;
      (*v73)((uint64_t)v76, (char *)v78, v77);
      if ((*v72)((uint64_t)v68, 1, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
      }
      (*v71)((char *)v78, v69);
      (*v93)((id *)v23, v68, a3);
    }
    v56(v23, 0, 1, a3);
    int64_t v43 = v45;
    unint64_t v36 = v44;
    goto LABEL_66;
  }
  id v52 = [*(id *)(v82 + 208) countByEnumeratingWithState:v80 objects:v79 count:16];
  v49[28] = v52;
  if (v52)
  {
    uint64_t v50 = 0;
    v49[27] = 0;
    goto LABEL_45;
  }
  v49[27] = -1;
LABEL_84:
  uint64_t v25 = 1;
  (*v51)(v23, 1, 1, a3);
  outlined consume of [A : B].Iterator._Variant<A, B>(v46);
  return v25;
}

BOOL === infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == a2;
  if (!a2) {
    BOOL v2 = a1 == 0;
  }
  if (a1) {
    return v2;
  }
  else {
    return a2 == 0;
  }
}

id Dictionary._Variant.asCocoa.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized _ArrayBuffer._nonNative.getter(a1);

  return swift_unknownObjectRetain(v1);
}

int64_t Dictionary.Keys.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v4 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0;
    double result = v5 | 0x8000000000000000;
  }
  else
  {
    uint64_t v9 = -1;
    uint64_t v10 = -1 << *(unsigned char *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1 << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }
  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0;
  a2[4] = v8;
  return result;
}

uint64_t Dictionary.Keys.Iterator.next()@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  uint64_t v4 = *v2;
  if (*v2 < 0)
  {
    uint64_t v14 = *(char **)(result + 16);
    id v15 = __CocoaDictionary.Iterator.nextKey()();
    if (v15)
    {
      uint64_t v17 = v15;
      _forceBridgeFromObjectiveC<A>(_:_:)(v15, v14, v16, a2);
      swift_unknownObjectRelease(v17);
      uint64_t v18 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v14 - 1) + 56);
      uint64_t v19 = a2;
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v18 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v14 - 1) + 56);
      uint64_t v19 = a2;
      uint64_t v20 = 1;
    }
    return v18(v19, v20, 1, v14);
  }
  else
  {
    uint64_t v5 = v2[1];
    uint64_t v6 = v2[2];
    int64_t v8 = v2[3];
    unint64_t v7 = v2[4];
    if (v7)
    {
      uint64_t v9 = (v7 - 1) & v7;
      unint64_t v10 = __clz(__rbit64(v7)) | (v8 << 6);
LABEL_4:
      uint64_t v11 = *(void *)(result + 16);
      uint64_t v12 = *(void *)(v11 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v12 + 16))(a2, *(void *)(v4 + 48) + *(void *)(v12 + 72) * v10, v11);
      double result = (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v12 + 56))(a2, 0, 1, v11);
      int64_t v13 = v8;
LABEL_25:
      *BOOL v2 = v4;
      v2[1] = v5;
      v2[2] = v6;
      v2[3] = v13;
      v2[4] = v9;
      return result;
    }
    int64_t v21 = v8 + 1;
    if (!__OFADD__(v8, 1))
    {
      int64_t v22 = (unint64_t)(v6 + 64) >> 6;
      int64_t v13 = v2[3];
      if (v21 < v22)
      {
        unint64_t v23 = *(void *)(v5 + 8 * v21);
        if (v23)
        {
LABEL_10:
          uint64_t v9 = (v23 - 1) & v23;
          unint64_t v10 = __clz(__rbit64(v23)) + (v21 << 6);
          int64_t v8 = v21;
          goto LABEL_4;
        }
        int64_t v13 = v8 + 1;
        if (v8 + 2 < v22)
        {
          unint64_t v23 = *(void *)(v5 + 8 * (v8 + 2));
          if (v23)
          {
            int64_t v21 = v8 + 2;
            goto LABEL_10;
          }
          int64_t v21 = v8 + 3;
          int64_t v13 = v8 + 2;
          if (v8 + 3 < v22)
          {
            unint64_t v23 = *(void *)(v5 + 8 * v21);
            if (v23) {
              goto LABEL_10;
            }
            int64_t v13 = v22 - 1;
            int64_t v24 = v8 + 4;
            while (v22 != v24)
            {
              unint64_t v23 = *(void *)(v5 + 8 * v24++);
              if (v23)
              {
                int64_t v21 = v24 - 1;
                goto LABEL_10;
              }
            }
          }
        }
      }
      double result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(result + 16) - 8) + 56))(a2, 1, 1);
      uint64_t v9 = 0;
      goto LABEL_25;
    }
    __break(1u);
  }
  return result;
}

BOOL Sequence<>.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(a3 + 48))();
  if (v8 == 2)
  {
    MEMORY[0x1F4188790](v8);
    v11[2] = a2;
    v11[3] = a3;
    v11[4] = a4;
    uint64_t v11[5] = a1;
    return Sequence.contains(where:)((uint64_t (*)(char *))partial apply for closure #1 in Sequence<>.contains(_:), (uint64_t)v11, a2, (int **)a3);
  }
  else
  {
    return v8 & 1;
  }
}

uint64_t (*Dictionary.Keys.subscript.read(char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8))()
{
  uint64_t v14 = *((void *)a6 - 1);
  *a1 = a6;
  a1[1] = (char *)v14;
  id v15 = (char *)malloc(*(void *)(v14 + 64));
  a1[2] = v15;
  Dictionary.Keys.subscript.getter(a2, a3, a5, a6, a8, v15);
  return _ArrayBuffer.subscript.read;
}

uint64_t (*Dictionary.Values._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t *Dictionary.startIndex.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0)
  {
    unint64_t v8 = *(void *)(a1 + 64);
    if (v8)
    {
      uint64_t v9 = 0;
      return (unint64_t *)(__clz(__rbit64(v8)) + v9);
    }
    else
    {
      uint64_t v9 = 0;
      unint64_t v7 = (void *)(1 << *(unsigned char *)(a1 + 32));
      unint64_t v10 = (((unint64_t)v7 + 63) >> 6) - 1;
      uint64_t v11 = (unint64_t *)(a1 + 72);
      while (v10)
      {
        unint64_t v12 = *v11++;
        unint64_t v8 = v12;
        --v10;
        v9 += 64;
        if (v12) {
          return (unint64_t *)(__clz(__rbit64(v8)) + v9);
        }
      }
    }
    return v7;
  }
  if (a1 < 0) {
    BOOL v2 = (void *)a1;
  }
  else {
    BOOL v2 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v3 = (unint64_t)[swift_unknownObjectRetain(v2) count];
  double result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v3 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v3, 24))
    {
      uint64_t v5 = swift_bufferAllocate(result, 8 * v3 + 24, 7uLL);
      v5[2] = v3;
      [v2 setObjects:v5 + 3 count:v3];
      swift_bridgeObjectRelease(a1);
      uint64_t v6 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      unint64_t v7 = swift_allocObject(v6, 0x20uLL, 7uLL);
      v7[2] = v2;
      v7[3] = v5;
      swift_bridgeObjectRetain(a1);
      return v7;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

void Dictionary.formIndex(after:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 16);
  if ((a2 & 0xC000000000000001) == 0)
  {
    Swift::Int v18 = _NativeDictionary.index(after:)(*(void *)a1, v9, v10, a2, a3, a6, a5);
    uint64_t v16 = v19;
    char v17 = v20 & 1;
    outlined consume of [A : B].Index._Variant<A, B>(v8, v9, v10);
    *(void *)a1 = v18;
    goto LABEL_20;
  }
  if ((v10 & 1) == 0)
  {
    unint64_t v21 = 1850;
    goto LABEL_26;
  }
  if (v8 >= 0) {
    uint64_t v11 = v8 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v11 = *(void *)a1;
  }
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v8);
  if (!swift_dynamicCastClass(v11, v12)) {
LABEL_23:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  outlined consume of [A : B].Index._Variant<A, B>(v8, v9, 1);
  if (v11) {
    swift_isUniquelyReferenced_nonNull_native(v11);
  }
  if (*(unsigned char *)(a1 + 16) != 1)
  {
    unint64_t v21 = 1858;
LABEL_26:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, v21, 0);
  }
  uint64_t v13 = *(void *)(a1 + 8);
  if (*(uint64_t *)a1 >= 0) {
    uint64_t v14 = *(void *)a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v14 = *(void *)a1;
  }
  if (!swift_dynamicCastClass(v14, v12)) {
    goto LABEL_23;
  }
  uint64_t v15 = a2 & 0xFFFFFFFFFFFFFF8;
  if (a2 < 0) {
    uint64_t v15 = a2;
  }
  if (*(void *)(v14 + 16) != v15) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E7uLL, 0);
  }
  if (v13 >= *(void *)(*(void *)(v14 + 24) + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  uint64_t v16 = v13 + 1;
  char v17 = 1;
LABEL_20:
  *(void *)(a1 + 8) = v16;
  *(unsigned char *)(a1 + 16) = v17;
}

void Dictionary.Values.subscript.getter(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, char *a5@<X5>, uint64_t a6@<X6>, char *a7@<X8>)
{
  uint64_t v12 = a1;
  uint64_t v14 = *((void *)a4 - 1);
  MEMORY[0x1F4188790](a1);
  char v17 = (char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v18 & 0xC000000000000001) == 0)
  {
    if (v15)
    {
      char v33 = a7;
      if (v12 >= 0) {
        uint64_t v25 = v12 & 0xFFFFFFFFFFFFFF8;
      }
      else {
        uint64_t v25 = v12;
      }
      uint64_t v26 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(v12);
      if (!swift_dynamicCastClass(v25, v26)) {
        goto LABEL_34;
      }
      if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v25 + 16))) {
        goto LABEL_37;
      }
      if (!swift_dynamicCastClass(v25, v26)) {
        goto LABEL_34;
      }
      uint64_t v27 = *(void *)(v25 + 24);
      if (*(void *)(v27 + 16) <= a2) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
      }
      uint64_t v28 = *(void **)(v27 + 8 * a2 + 24);
      swift_unknownObjectRetain(v28);
      outlined consume of [A : B].Index._Variant<A, B>(v12, a2, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v28, a4, v29, v17);
      swift_unknownObjectRelease(v28);
      uint64_t v12 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)a4, a6);
      char v31 = v30;
      (*(void (**)(char *, char *))(v14 + 8))(v17, a4);
      if ((v31 & 1) == 0)
      {
LABEL_37:
        unint64_t v24 = 303;
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v24, 0);
      }
      a7 = v33;
    }
    else if (v12 < 0 {
           || 1 << *(unsigned char *)(a3 + 32) <= v12
    }
           || ((*(void *)(a3 + 8 * ((unint64_t)v12 >> 6) + 64) >> v12) & 1) == 0
           || *(_DWORD *)(a3 + 36) != a2)
    {
      unint64_t v24 = 281;
      goto LABEL_21;
    }
    (*(void (**)(char *, uint64_t, char *))(*((void *)a5 - 1) + 16))(a7, *(void *)(a3 + 56) + *(void *)(*((void *)a5 - 1) + 72) * v12, a5);
    return;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v15 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  if (v12 >= 0) {
    uint64_t v19 = v12 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v19 = v12;
  }
  uint64_t v20 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v19, v20)) {
    goto LABEL_34;
  }
  if (*(void *)(v19 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x22CuLL, 0);
  }
  unint64_t v21 = *(void **)(*(void *)(v19 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v21);
  if (!swift_dynamicCastClass(v19, v20)) {
LABEL_34:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  id v22 = [a3 objectForKey:v21];
  swift_unknownObjectRelease(v21);
  if (!v22) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x22EuLL, 0);
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v22, a5, v23, a7);

  swift_unknownObjectRelease(v22);
}

void (*Dictionary.Values.subscript.modify(char **a1, uint64_t a2, uint64_t a3, char a4, void *a5))(void **a1)
{
  uint64_t v6 = (unint64_t *)v5;
  uint64_t v12 = (char *)a5[2];
  uint64_t v28 = *((void *)v12 - 1);
  uint64_t v13 = (char *)malloc(*(void *)(v28 + 64));
  *a1 = v13;
  uint64_t v14 = *v5;
  char v15 = (uint64_t *)a5[3];
  if ((*v5 & 0xC000000000000001) == 0)
  {
    if (!swift_isUniquelyReferenced_nonNull_native(v14))
    {
      uint64_t v29 = *v5;
      uint64_t *v5 = 0x8000000000000000;
      type metadata accessor for _NativeDictionary(0, (uint64_t)v12, (uint64_t)v15, a5[4]);
      _NativeDictionary.copy()();
      uint64_t v20 = *v5;
      uint64_t *v5 = v29;
      swift_bridgeObjectRelease(v20);
    }
    char v17 = (__objc2_class **)*v5;
    swift_bridgeObjectRetain(*v6);
    if ((a4 & 1) == 0) {
      goto LABEL_6;
    }
LABEL_15:
    if (a2 >= 0) {
      uint64_t v21 = a2 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v21 = a2;
    }
    uint64_t v22 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a2);
    if (swift_dynamicCastClass(v21, v22))
    {
      if (*((_DWORD *)v17 + 9) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v21 + 16)))
      {
        swift_retain((atomic_ullong *)v17);
        goto LABEL_28;
      }
      if (swift_dynamicCastClass(v21, v22))
      {
        uint64_t v23 = *(void *)(v21 + 24);
        if (*(void *)(v23 + 16) <= a3) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        unint64_t v24 = *(void **)(v23 + 8 * a3 + 24);
        swift_retain((atomic_ullong *)v17);
        swift_unknownObjectRetain(v24);
        outlined consume of [A : B].Index._Variant<A, B>(a2, a3, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v24, v12, v25, v13);
        swift_unknownObjectRelease(v24);
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, (uint64_t)v12, a5[4]);
        LOBYTE(v24) = v26;
        swift_release((uint64_t)v17);
        (*(void (**)(char *, char *))(v28 + 8))(v13, v12);
        if (v24) {
          goto LABEL_23;
        }
LABEL_28:
        unint64_t v19 = 303;
LABEL_11:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v19, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (v14 < 0) {
    uint64_t v16 = (void *)*v5;
  }
  else {
    uint64_t v16 = (void *)(v14 & 0xFFFFFFFFFFFFFF8);
  }
  swift_bridgeObjectRetain(v14);
  char v17 = _NativeDictionary.init(_:capacity:)(v16, (uint64_t)objc_msgSend(v16, sel_count), v12, v15, a5[4]);
  uint64_t v18 = *v6;
  *uint64_t v6 = (unint64_t)v17;
  swift_retain((atomic_ullong *)v17);
  swift_bridgeObjectRelease(v18);
  if (a4) {
    goto LABEL_15;
  }
LABEL_6:
  if (a2 < 0 || 1 << *((unsigned char *)v17 + 32) <= a2)
  {
    swift_retain((atomic_ullong *)v17);
LABEL_10:
    unint64_t v19 = 281;
    goto LABEL_11;
  }
  if ((((unint64_t)v17[((unint64_t)a2 >> 6) + 8] >> a2) & 1) == 0 || *((_DWORD *)v17 + 9) != a3) {
    goto LABEL_10;
  }
LABEL_23:
  swift_release((uint64_t)v17);
  return Dictionary.Values.subscript.modify;
}

void Dictionary.Values.subscript.modify(void **a1)
{
}

void Dictionary._Variant.value(at:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, char *a5@<X5>, uint64_t a6@<X6>, char *a7@<X8>)
{
  uint64_t v12 = a1;
  uint64_t v14 = *((void *)a4 - 1);
  MEMORY[0x1F4188790](a1);
  char v17 = (char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v18 & 0xC000000000000001) == 0)
  {
    if (v15)
    {
      char v33 = a7;
      if (v12 >= 0) {
        uint64_t v25 = v12 & 0xFFFFFFFFFFFFFF8;
      }
      else {
        uint64_t v25 = v12;
      }
      uint64_t v26 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(v12);
      if (!swift_dynamicCastClass(v25, v26)) {
        goto LABEL_34;
      }
      if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v25 + 16))) {
        goto LABEL_37;
      }
      if (!swift_dynamicCastClass(v25, v26)) {
        goto LABEL_34;
      }
      uint64_t v27 = *(void *)(v25 + 24);
      if (*(void *)(v27 + 16) <= a2) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
      }
      uint64_t v28 = *(void **)(v27 + 8 * a2 + 24);
      swift_unknownObjectRetain(v28);
      outlined consume of [A : B].Index._Variant<A, B>(v12, a2, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v28, a4, v29, v17);
      swift_unknownObjectRelease(v28);
      uint64_t v12 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)a4, a6);
      char v31 = v30;
      (*(void (**)(char *, char *))(v14 + 8))(v17, a4);
      if ((v31 & 1) == 0)
      {
LABEL_37:
        unint64_t v24 = 303;
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v24, 0);
      }
      a7 = v33;
    }
    else if (v12 < 0 {
           || 1 << *(unsigned char *)(a3 + 32) <= v12
    }
           || ((*(void *)(a3 + 8 * ((unint64_t)v12 >> 6) + 64) >> v12) & 1) == 0
           || *(_DWORD *)(a3 + 36) != a2)
    {
      unint64_t v24 = 281;
      goto LABEL_21;
    }
    (*(void (**)(char *, uint64_t, char *))(*((void *)a5 - 1) + 16))(a7, *(void *)(a3 + 56) + *(void *)(*((void *)a5 - 1) + 72) * v12, a5);
    return;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v15 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  if (v12 >= 0) {
    uint64_t v19 = v12 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v19 = v12;
  }
  uint64_t v20 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v19, v20)) {
    goto LABEL_34;
  }
  if (*(void *)(v19 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x22CuLL, 0);
  }
  uint64_t v21 = *(void **)(*(void *)(v19 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v21);
  if (!swift_dynamicCastClass(v19, v20)) {
LABEL_34:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  id v22 = [a3 objectForKey:v21];
  swift_unknownObjectRelease(v21);
  if (!v22) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x22EuLL, 0);
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v22, a5, v23, a7);

  swift_unknownObjectRelease(v22);
}

__objc2_class **Dictionary._Variant.ensureUniqueNative()(void *a1)
{
  BOOL v2 = (unint64_t *)v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (char *)a1[2];
  uint64_t v6 = (uint64_t *)a1[3];
  if ((v4 & 0xC000000000000001) != 0)
  {
    if (v4 < 0) {
      unint64_t v7 = (void *)v4;
    }
    else {
      unint64_t v7 = (void *)(v4 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(v4);
    uint64_t v8 = _NativeDictionary.init(_:capacity:)(v7, (uint64_t)objc_msgSend(v7, sel_count), v5, v6, a1[4]);
    uint64_t v9 = *v2;
    *BOOL v2 = (unint64_t)v8;
    swift_retain((atomic_ullong *)v8);
    swift_bridgeObjectRelease(v9);
  }
  else
  {
    if (!swift_isUniquelyReferenced_nonNull_native(v4))
    {
      unint64_t v12 = *v2;
      *BOOL v2 = 0x8000000000000000;
      type metadata accessor for _NativeDictionary(0, (uint64_t)v5, (uint64_t)v6, a1[4]);
      _NativeDictionary.copy()();
      uint64_t v10 = *v2;
      *BOOL v2 = v12;
      swift_bridgeObjectRelease(v10);
    }
    uint64_t v8 = (__objc2_class **)*v2;
    swift_bridgeObjectRetain(*v2);
  }
  return v8;
}

uint64_t _NativeDictionary.validatedBucket(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a1;
  uint64_t v12 = *((void *)a5 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v25 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v15)
  {
    if (v11 >= 0) {
      uint64_t v17 = v11 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v17 = v11;
    }
    uint64_t v18 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v11);
    if (swift_dynamicCastClass(v17, v18))
    {
      if (*(_DWORD *)(a4 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v17 + 16))) {
        goto LABEL_19;
      }
      if (swift_dynamicCastClass(v17, v18))
      {
        uint64_t v19 = *(void *)(v17 + 24);
        if (*(void *)(v19 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        uint64_t v20 = *(void **)(v19 + 8 * a2 + 24);
        swift_unknownObjectRetain(v20);
        outlined consume of [A : B].Index._Variant<A, B>(v11, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v20, a5, v21, v14);
        swift_unknownObjectRelease(v20);
        uint64_t v11 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)a5, a7);
        char v23 = v22;
        (*(void (**)(char *, char *))(v12 + 8))(v14, a5);
        if (v23) {
          return v11;
        }
LABEL_19:
        unint64_t v16 = 303;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v16, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (v11 < 0
    || 1 << *(unsigned char *)(a4 + 32) <= v11
    || ((*(void *)(a4 + 8 * ((unint64_t)v11 >> 6) + 64) >> v11) & 1) == 0
    || *(_DWORD *)(a4 + 36) != a2)
  {
    unint64_t v16 = 281;
    goto LABEL_7;
  }
  return v11;
}

void Dictionary.Values.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v6 = (unint64_t *)v5;
  uint64_t v11 = *(char **)(a5 + 16);
  uint64_t v33 = *((void *)v11 - 1);
  uint64_t v34 = a1;
  MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v32 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = *v5;
  unint64_t v16 = *(uint64_t **)(v15 + 24);
  if ((*v5 & 0xC000000000000001) != 0)
  {
    if (v14 < 0) {
      uint64_t v17 = (void *)*v5;
    }
    else {
      uint64_t v17 = (void *)(v14 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(v14);
    uint64_t v18 = _NativeDictionary.init(_:capacity:)(v17, (uint64_t)[v17 count], v11, v16, *(void *)(a5 + 32));
    int v19 = a4;
    unint64_t v20 = *v6;
    *uint64_t v6 = (unint64_t)v18;
    swift_retain((atomic_ullong *)v18);
    uint64_t v21 = v20;
    a4 = v19;
    swift_bridgeObjectRelease(v21);
    if (v19) {
      goto LABEL_6;
    }
  }
  else
  {
    if (!swift_isUniquelyReferenced_nonNull_native(v14))
    {
      uint64_t v35 = *v5;
      uint64_t *v5 = 0x8000000000000000;
      type metadata accessor for _NativeDictionary(0, (uint64_t)v11, (uint64_t)v16, *(void *)(a5 + 32));
      _NativeDictionary.copy()();
      uint64_t v29 = *v5;
      uint64_t *v5 = v35;
      swift_bridgeObjectRelease(v29);
    }
    uint64_t v18 = (__objc2_class **)*v5;
    swift_bridgeObjectRetain(*v6);
    if (a4)
    {
LABEL_6:
      HIDWORD(v32) = a4;
      if (a2 >= 0) {
        uint64_t v22 = a2 & 0xFFFFFFFFFFFFFF8;
      }
      else {
        uint64_t v22 = a2;
      }
      uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(a2);
      if (swift_dynamicCastClass(v22, v23))
      {
        if (*((_DWORD *)v18 + 9) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v22 + 16)))
        {
          swift_retain((atomic_ullong *)v18);
LABEL_29:
          unint64_t v31 = 303;
LABEL_27:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v31, 0);
        }
        if (swift_dynamicCastClass(v22, v23))
        {
          uint64_t v24 = *(void *)(v22 + 24);
          if (*(void *)(v24 + 16) <= a3) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
          }
          uint64_t v25 = *(void **)(v24 + 8 * a3 + 24);
          swift_retain((atomic_ullong *)v18);
          swift_unknownObjectRetain(v25);
          outlined consume of [A : B].Index._Variant<A, B>(a2, a3, 1);
          _forceBridgeFromObjectiveC<A>(_:_:)(v25, v11, v26, v13);
          swift_unknownObjectRelease(v25);
          unint64_t v27 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, (uint64_t)v11, *(void *)(a5 + 32));
          LOBYTE(v25) = v28;
          swift_release((uint64_t)v18);
          (*(void (**)(char *, char *))(v33 + 8))(v13, v11);
          if (v25)
          {
            LOBYTE(a4) = BYTE4(v32);
            goto LABEL_22;
          }
          goto LABEL_29;
        }
      }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
    }
  }
  if (a2 < 0 || 1 << *((unsigned char *)v18 + 32) <= a2)
  {
    swift_retain((atomic_ullong *)v18);
LABEL_26:
    unint64_t v31 = 281;
    goto LABEL_27;
  }
  if ((((unint64_t)v18[((unint64_t)a2 >> 6) + 8] >> a2) & 1) == 0) {
    goto LABEL_26;
  }
  unint64_t v27 = a2;
  if (*((_DWORD *)v18 + 9) != a3) {
    goto LABEL_26;
  }
LABEL_22:
  char v30 = v18[7];
  swift_release((uint64_t)v18);
  (*(void (**)(unint64_t, uint64_t, uint64_t *))(*(v16 - 1) + 40))((unint64_t)v30 + *(void *)(*(v16 - 1) + 72) * v27, v34, v16);
  outlined consume of [A : B].Index._Variant<A, B>(a2, a3, a4 & 1);
}

BOOL Dictionary.isEmpty.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) != 0)
  {
    if (a1 >= 0) {
      a1 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    id v1 = [a1 count];
  }
  else
  {
    id v1 = *(id *)(a1 + 16);
  }
  return v1 == 0;
}

void Dictionary.Values.swapAt(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v13 = a1;
  uint64_t v14 = *(uint64_t **)(a7 + 24);
  uint64_t v15 = *(v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](a1);
  unint64_t v71 = *(char **)(v17 + 16);
  uint64_t v72 = v17;
  uint64_t v70 = *((void *)v71 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v65 - v20;
  uint64_t v69 = v22;
  char v67 = v23;
  int v73 = v19;
  if ((v24 & 1) == 0)
  {
    if ((v19 & 1) == 0)
    {
      if (a2 != a5) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xD5uLL, 0);
      }
      if (v13 == a4) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
LABEL_54:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/Dictionary.swift", 22, 2, 0x75CuLL, 0);
  }
  if ((v19 & 1) == 0)
  {
    outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1);
    outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1);
    swift_bridgeObjectRetain(v13);
    goto LABEL_54;
  }
  BOOL v25 = specialized static __CocoaDictionary.Index.== infix(_:_:)(v13, a2, a4, a5);
  outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1);
  outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1);
  swift_bridgeObjectRetain(v13);
  if (v25)
  {
LABEL_4:
    outlined consume of [A : B].Index._Variant<A, B>(v13, a2, a3 & 1);
    outlined consume of [A : B].Index._Variant<A, B>(v13, a2, a3 & 1);
    outlined consume of [A : B].Index._Variant<A, B>(v13, a2, a3 & 1);
    return;
  }
LABEL_10:
  uint64_t v66 = v15;
  uint64_t v68 = v14;
  int64_t v26 = *v8;
  if ((*v8 & 0xC000000000000001) != 0)
  {
    if (v26 < 0) {
      unint64_t v27 = (void *)*v8;
    }
    else {
      unint64_t v27 = (void *)(v26 & 0xFFFFFFFFFFFFFF8);
    }
    char v28 = v73 & 1;
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v73 & 1);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v28);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v28);
    swift_bridgeObjectRetain(v26);
    id v29 = [v27 count];
    char v30 = _NativeDictionary.init(_:capacity:)(v27, (uint64_t)v29, v71, v68, *(void *)(v72 + 32));
    uint64_t v31 = *v8;
    *uint64_t v8 = (uint64_t)v30;
    swift_bridgeObjectRelease(v31);
  }
  else
  {
    char v32 = v73 & 1;
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v73 & 1);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v32);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v32);
  }
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v8);
  char v34 = isUniquelyReferenced_nonNull_native;
  uint64_t v35 = *v8;
  if ((a3 & 1) == 0)
  {
    if (v13 < 0
      || 1 << *(unsigned char *)(v35 + 32) <= v13
      || ((*(void *)(v35 + 8 * ((unint64_t)v13 >> 6) + 64) >> v13) & 1) == 0
      || *(_DWORD *)(v35 + 36) != a2)
    {
      goto LABEL_47;
    }
    swift_bridgeObjectRetain_n(*v8, 2);
    if ((v73 & 1) == 0) {
      goto LABEL_26;
    }
    goto LABEL_36;
  }
  HIDWORD(v65) = isUniquelyReferenced_nonNull_native;
  swift_bridgeObjectRetain_n(v35, 2);
  outlined consume of [A : B].Index._Variant<A, B>(v13, a2, 1);
  outlined consume of [A : B].Index._Variant<A, B>(v13, a2, 1);
  if (v13 >= 0) {
    uint64_t v36 = v13 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v36 = v13;
  }
  uint64_t v37 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v36, v37)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(_DWORD *)(v35 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v36 + 16))) {
    goto LABEL_51;
  }
  if (!swift_dynamicCastClass(v36, v37)) {
    goto LABEL_52;
  }
  uint64_t v38 = *(void *)(v36 + 24);
  if (*(void *)(v38 + 16) <= a2) {
    goto LABEL_50;
  }
  uint64_t v39 = *(void **)(v38 + 8 * a2 + 24);
  swift_unknownObjectRetain(v39);
  outlined consume of [A : B].Index._Variant<A, B>(v13, a2, 1);
  uint64_t v40 = v71;
  _forceBridgeFromObjectiveC<A>(_:_:)(v39, v71, v41, v21);
  swift_unknownObjectRelease(v39);
  uint64_t v13 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v21, (uint64_t)v40, *(void *)(v72 + 32));
  char v43 = v42;
  (*(void (**)(char *, char *))(v70 + 8))(v21, v40);
  if ((v43 & 1) == 0) {
    goto LABEL_51;
  }
  char v34 = BYTE4(v65);
  if (v73)
  {
LABEL_36:
    outlined consume of [A : B].Index._Variant<A, B>(a4, a5, 1);
    outlined consume of [A : B].Index._Variant<A, B>(a4, a5, 1);
    if (a4 >= 0) {
      uint64_t v46 = a4 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v46 = a4;
    }
    uint64_t v47 = type metadata accessor for __CocoaDictionary.Index.Storage();
    if (swift_dynamicCastClass(v46, v47))
    {
      int v48 = specialized static Hasher._hash(seed:_:)(0, *(void *)(v46 + 16));
      int v49 = *(_DWORD *)(v35 + 36);
      swift_bridgeObjectRelease(v35);
      if (v49 != v48) {
        goto LABEL_51;
      }
      if (swift_dynamicCastClass(v46, v47))
      {
        uint64_t v50 = *(void *)(v46 + 24);
        if (*(void *)(v50 + 16) > a5)
        {
          uint64_t v51 = *(void **)(v50 + 8 * a5 + 24);
          swift_unknownObjectRetain(v51);
          outlined consume of [A : B].Index._Variant<A, B>(a4, a5, 1);
          id v52 = v67;
          uint64_t v53 = v71;
          _forceBridgeFromObjectiveC<A>(_:_:)(v51, v71, v54, v67);
          swift_unknownObjectRelease(v51);
          a4 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v52, (uint64_t)v53, *(void *)(v72 + 32));
          LOBYTE(v51) = v55;
          swift_bridgeObjectRelease(v35);
          (*(void (**)(char *, char *))(v70 + 8))(v52, v53);
          if (v51) {
            goto LABEL_44;
          }
LABEL_51:
          unint64_t v64 = 303;
LABEL_48:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v64, 0);
        }
LABEL_50:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
      }
    }
LABEL_52:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
LABEL_26:
  if (a4 < 0
    || 1 << *(unsigned char *)(v35 + 32) <= a4
    || (unint64_t v44 = *(void *)(v35 + 8 * ((unint64_t)a4 >> 6) + 64),
        swift_bridgeObjectRelease(v35),
        ((v44 >> a4) & 1) == 0)
    || (int v45 = *(_DWORD *)(v35 + 36), swift_bridgeObjectRelease(v35), v45 != a5))
  {
LABEL_47:
    unint64_t v64 = 281;
    goto LABEL_48;
  }
LABEL_44:
  uint64_t v56 = *v8;
  uint64_t v74 = *v8;
  *uint64_t v8 = 0x8000000000000000;
  int64_t v57 = (unint64_t *)v68;
  if ((v34 & 1) == 0)
  {
    type metadata accessor for _NativeDictionary(0, (uint64_t)v71, (uint64_t)v68, *(void *)(v72 + 32));
    _NativeDictionary.copy()();
    uint64_t v56 = v74;
  }
  unint64_t v58 = *(void (**)(uint64_t, uint64_t, unint64_t *))(v66 + 32);
  uint64_t v59 = *(void *)(v66 + 72);
  uint64_t v60 = v59 * v13;
  uint64_t v61 = v69;
  v58(v69, *(void *)(v56 + 56) + v60, v57);
  uint64_t v62 = v59 * a4;
  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(*(void *)(v56 + 56) + v62), 1, (char *)(*(void *)(v56 + 56) + v60), v57);
  v58(*(void *)(v56 + 56) + v62, v61, v57);
  uint64_t v63 = *v8;
  *uint64_t v8 = v56;
  swift_bridgeObjectRelease(v63);
}

__objc2_class **_NativeDictionary.init(_:)(void *a1, char *a2, uint64_t *a3, uint64_t a4)
{
  id v8 = [a1 count];

  return _NativeDictionary.init(_:capacity:)(a1, (uint64_t)v8, a2, a3, a4);
}

BOOL specialized Dictionary._Variant.isUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull_native(*v0);
}

Swift::Bool __swiftcall Dictionary._Variant.isUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull_native(*v0);
}

uint64_t (*Dictionary._Variant.asNative.modify(void *a1))()
{
  *a1 = *v1;
  a1[1] = v1;
  *id v1 = 0x8000000000000000;
  return _SmallString.leadingRawBits.modify;
}

Swift::Void __swiftcall _NativeDictionary.swapValuesAt(_:_:isUnique:)(Swift::_HashTable::Bucket _, Swift::_HashTable::Bucket a2, Swift::Bool isUnique)
{
  unint64_t v7 = *(unint64_t **)(v3 + 24);
  uint64_t v8 = *(v7 - 1);
  MEMORY[0x1F4188790](_.offset);
  uint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v11 & 1) == 0) {
    _NativeDictionary.copy()();
  }
  uint64_t v12 = *v4;
  uint64_t v13 = *(void (**)(char *, Swift::Int, unint64_t *))(v8 + 32);
  uint64_t v14 = *(void *)(v8 + 72);
  Swift::Int v15 = v14 * _.offset;
  v13(v10, *(void *)(v12 + 56) + v15, v7);
  Swift::Int v16 = v14 * a2.offset;
  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(*(void *)(v12 + 56) + v16), 1, (char *)(*(void *)(v12 + 56) + v15), v7);
  v13((char *)(*(void *)(v12 + 56) + v16), (Swift::Int)v10, v7);
}

uint64_t (*MutableCollection<>.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v9 = malloc(0x58uLL);
  *a1 = v9;
  v9[1] = a4;
  v9[2] = v4;
  *uint64_t v9 = a3;
  uint64_t v10 = *(int ***)(a4 + 8);
  uint64_t v12 = type metadata accessor for Slice(0, a3, (uint64_t)v10, v11);
  v9[3] = v12;
  uint64_t v13 = (uint64_t)*(v12 - 1);
  v9[4] = v13;
  size_t v14 = *(void *)(v13 + 64);
  v9[5] = malloc(v14);
  Swift::Int v15 = (char *)malloc(v14);
  v9[6] = v15;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  int v19 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  v9[7] = v19;
  uint64_t v20 = (uint64_t)*(v19 - 1);
  uint64_t v21 = v20;
  v9[8] = v20;
  size_t v22 = *(void *)(v20 + 64);
  v9[9] = malloc(v22);
  v9[10] = malloc(v22);
  (*(void (**)(void))(v21 + 16))();
  MutableCollection<>.subscript.getter(a2, a3, a4, v15);
  return MutableCollection<>.subscript.modify;
}

uint64_t (*Dictionary.Values.subscript.read(char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, char *a7, uint64_t a8))()
{
  uint64_t v15 = *((void *)a7 - 1);
  *a1 = a7;
  a1[1] = (char *)v15;
  Swift::Int v16 = (char *)malloc(*(void *)(v15 + 64));
  a1[2] = v16;
  Dictionary.Values.subscript.getter(a2, a3, a5, a6, a7, a8, v16);
  return _ArrayBuffer.subscript.read;
}

uint64_t MutableCollection<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v67 = a1;
  unint64_t v58 = a4;
  uint64_t v6 = *(void *)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v61 = (char *)&v52 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v56 = (char *)&v52 - v11;
  uint64_t v12 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v52 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v52 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v52 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v52 - v22;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v62 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v60 = (uint64_t)*(v62 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v62);
  uint64_t v59 = (char *)&v52 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  int64_t v57 = (char *)&v52 - v28;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a2, v6);
  id v29 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  uint64_t v64 = a2;
  uint64_t v65 = v4;
  uint64_t v63 = v6;
  v29(a2, v6);
  char v30 = (void (*)(char *, char *, const char *))v12[2];
  v30(v18, v23, AssociatedTypeWitness);
  char v55 = v21;
  v30(v15, v21, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v18, v15, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v31 = (void (*)(char *, const char *))v12[1];
  }
  uint64_t v54 = v31;
  v31(v15, AssociatedTypeWitness);
  v31(v18, AssociatedTypeWitness);
  char v32 = TupleTypeMetadata2;
  uint64_t v33 = v56;
  char v34 = &v56[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v35 = (void (*)(char *, char *, const char *))v12[4];
  v35(v56, v23, AssociatedTypeWitness);
  uint64_t v53 = v34;
  v35(v34, v55, AssociatedTypeWitness);
  uint64_t v36 = v61;
  uint64_t v37 = &v61[*((int *)v32 + 12)];
  v30(v61, v33, AssociatedTypeWitness);
  v30(v37, v34, AssociatedTypeWitness);
  uint64_t v38 = v59;
  v35(v59, v36, AssociatedTypeWitness);
  uint64_t v39 = v37;
  uint64_t v40 = v54;
  v54(v39, AssociatedTypeWitness);
  uint64_t v41 = &v36[*((int *)TupleTypeMetadata2 + 12)];
  v35(v36, v33, AssociatedTypeWitness);
  v35(v41, v53, AssociatedTypeWitness);
  char v42 = v62;
  v35(&v38[*((int *)v62 + 9)], v41, AssociatedTypeWitness);
  v40(v36, AssociatedTypeWitness);
  uint64_t v43 = v60;
  unint64_t v44 = v57;
  (*(void (**)(char *, char *, Class *))(v60 + 32))(v57, v38, v42);
  uint64_t v45 = v63;
  uint64_t v46 = v64;
  uint64_t v47 = v65;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v63 + 176))(v67, v44, v64, v63);
  (*(void (**)(char *, Class *))(v43 + 8))(v44, v42);
  int v49 = type metadata accessor for Slice(0, v46, v45, v48);
  uint64_t v50 = v58;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v46 - 8) + 16))(&v58[*((int *)v49 + 10)], v47, v46);
  (*(void (**)(char *, uint64_t, Class *))(v43 + 16))(v38, v67, v42);
  v35(v50, v38, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, const char *))v35)(&v50[*((int *)v49 + 9)], &v38[*((int *)v42 + 9)], AssociatedTypeWitness);
}

int64_t Dictionary.Values.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v4 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0;
    double result = v5 | 0x8000000000000000;
  }
  else
  {
    uint64_t v9 = -1;
    uint64_t v10 = -1 << *(unsigned char *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1 << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }
  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0;
  a2[4] = v8;
  return result;
}

uint64_t Dictionary.Keys.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (unint64_t *)type metadata accessor for Dictionary.Keys(0, a2, a3, a4);
  swift_getWitnessTable(protocol conformance descriptor for [A : B].Keys, v4, v5);
  return Collection._makeCollectionDescription(withTypeName:)((Swift::String_optional)0)._countAndFlagsBits;
}

uint64_t Dictionary.Keys.debugDescription.getter(int64_t a1, uint64_t a2)
{
  int64_t v2 = a1;
  unint64_t v3 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  v205 = (char *)&v194 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v197 = v5;
  uint64_t v8 = type metadata accessor for Optional(0, v5, v6, v7);
  MEMORY[0x1F4188790](v8 - 1);
  uint64_t v10 = (char *)&v194 - v9;
  long long v11 = (__int128)String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Dictionary.Keys", 0xFuLL, 1);
  uint64_t v12 = (int64_t *)v11;
  uint64_t v13 = *((void *)&v11 + 1);
  unint64_t v212 = 0;
  unint64_t v213 = 0xE000000000000000;
  uint64_t v14 = specialized static String._createEmpty(withInitialCapacity:)(4);
  uint64_t v16 = v14;
  unint64_t v17 = v15;
  *(void *)&long long v211 = v14;
  *((void *)&v211 + 1) = v15;
  uint64_t v18 = HIBYTE(v15) & 0xF;
  int64_t v19 = v14 & 0xFFFFFFFFFFFFLL;
  if ((v15 & 0x2000000000000000) != 0) {
    uint64_t v20 = HIBYTE(v15) & 0xF;
  }
  else {
    uint64_t v20 = v14 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v198 = v3;
  if (!v20 && (v14 & ~v15 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v15);
    uint64_t v16 = 0;
    unint64_t v39 = 0xE000000000000000;
    *(void *)&long long v211 = 0;
LABEL_21:
    *((void *)&v211 + 1) = v39;
    goto LABEL_25;
  }
  if ((v15 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v15);
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v40 = 0xA000000000000000;
    if (!(v17 & 0x80808080808080 | v16 & 0x8080808080808080)) {
      unint64_t v40 = 0xE000000000000000;
    }
    unint64_t v39 = v40 & 0xFF00000000000000 | (v18 << 56) | v17 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&long long v211 = v16;
    goto LABEL_21;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6);
  if ((v17 & 0x1000000000000000) != 0)
  {
    int64_t v19 = String.UTF8View._foreignCount()();
    if ((v16 & ~v17 & 0x2000000000000000) == 0) {
      goto LABEL_23;
    }
  }
  else if ((v16 & ~v17 & 0x2000000000000000) == 0)
  {
    goto LABEL_23;
  }
  if (swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
    if (v22) {
      goto LABEL_218;
    }
    if (v19 <= 15 && (v21 & 0x8000000000000000) != 0) {
      goto LABEL_13;
    }
LABEL_24:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v19, 0);
    swift_bridgeObjectRelease_n(0xE000000000000000, 6);
    uint64_t v208 = 0;
    uint64_t v209 = 0;
    uint64_t v41 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v208, 0);
    _StringGuts.appendInPlace(_:isASCII:)(v41, v42, 1);
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v39 = *((void *)&v211 + 1);
    uint64_t v16 = v211;
    goto LABEL_25;
  }
LABEL_23:
  if (v19 > 15) {
    goto LABEL_24;
  }
LABEL_13:
  swift_bridgeObjectRelease_n(0xE000000000000000, 5);
  swift_bridgeObjectRetain(v17);
  unint64_t v23 = _StringGuts._convertedToSmall()(v16, v17);
  unint64_t v25 = v24;
  swift_bridgeObjectRelease(v17);
  v26._rawBits = 1;
  v27._rawBits = 1;
  v28._rawBits = _StringGuts.validateScalarRange(_:)(v26, v27, 0, 0xE000000000000000);
  if (v28._rawBits < 0x10000) {
    v28._rawBits |= 3;
  }
  unint64_t v30 = specialized String.init(_:)(v28, v29, 0, 0xE000000000000000);
  unint64_t v32 = v31;
  swift_bridgeObjectRelease(0xE000000000000000);
  unint64_t v33 = _StringGuts._convertedToSmall()(v30, v32);
  unint64_t v35 = v34;
  swift_bridgeObjectRelease(v32);
  unint64_t v36 = specialized _SmallString.init(_:appending:)(v23, v25, v33, v35);
  if (v38) {
    goto LABEL_217;
  }
  uint64_t v16 = v36;
  unint64_t v39 = v37;
  swift_bridgeObjectRelease(v17);
  swift_bridgeObjectRelease(0xE000000000000000);
  *(void *)&long long v211 = v16;
  *((void *)&v211 + 1) = v39;
  unint64_t v3 = v198;
LABEL_25:
  uint64_t v43 = HIBYTE(v39) & 0xF;
  if ((v39 & 0x2000000000000000) != 0) {
    uint64_t v44 = HIBYTE(v39) & 0xF;
  }
  else {
    uint64_t v44 = v16 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v195 = *((void *)&v11 + 1);
  v202 = v10;
  if (!v44 && (v16 & ~v39 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(*((unint64_t *)&v11 + 1));
    swift_bridgeObjectRelease(v39);
    long long v211 = v11;
    goto LABEL_76;
  }
  uint64_t v207 = v2;
  int64_t v2 = *((void *)&v11 + 1) & 0x2000000000000000;
  unint64_t v3 = HIBYTE(*((void *)&v11 + 1)) & 0xFLL;
  if ((v39 & 0x2000000000000000) != 0 && v2)
  {
    unint64_t v45 = v43 + v3;
    if (v43 + v3 <= 0xF)
    {
      if (v3)
      {
        char v75 = 0;
        unint64_t v76 = 0;
        unint64_t v77 = v39;
        do
        {
          unint64_t v78 = v43 + v76;
          unint64_t v79 = v76 + 1;
          if (v76 >= 8) {
            unint64_t v80 = *((void *)&v11 + 1);
          }
          else {
            unint64_t v80 = v11;
          }
          unint64_t v81 = v80 >> (v75 & 0x38);
          char v82 = (8 * v43 + v75) & 0x38;
          uint64_t v83 = (-255 << v82) - 1;
          unint64_t v84 = (unint64_t)v81 << v82;
          unint64_t v85 = v84 | v83 & v77;
          unint64_t v86 = v84 | v83 & v16;
          if (v78 < 8) {
            uint64_t v16 = v86;
          }
          else {
            unint64_t v77 = v85;
          }
          v75 += 8;
          unint64_t v76 = v79;
        }
        while (v3 != v79);
      }
      else
      {
        unint64_t v77 = v39;
      }
      swift_bridgeObjectRelease(v39);
      unint64_t v92 = 0xA000000000000000;
      if (!(v16 & 0x8080808080808080 | v77 & 0x80808080808080)) {
        unint64_t v92 = 0xE000000000000000;
      }
      *(void *)&long long v211 = v16;
      *((void *)&v211 + 1) = v92 & 0xFF00000000000000 | (v45 << 56) | v77 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_75;
    }
    int64_t v2 = 1;
  }
  uint64_t v46 = v11 & 0xFFFFFFFFFFFFLL;
  if (v2) {
    uint64_t v47 = HIBYTE(*((void *)&v11 + 1)) & 0xFLL;
  }
  else {
    uint64_t v47 = v11 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v11 + 1), 2);
  *(void *)&long long v206 = v11;
  if ((*((void *)&v11 + 1) & 0x1000000000000000) != 0) {
    goto LABEL_206;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v11 + 1), 4);
  Swift::Int v48 = v47;
  if ((v39 & 0x1000000000000000) == 0) {
    goto LABEL_39;
  }
  while (2)
  {
    Swift::Int v190 = String.UTF8View._foreignCount()();
    uint64_t v44 = v190 + v48;
    if (__OFADD__(v190, v48)) {
      goto LABEL_211;
    }
LABEL_40:
    if ((v16 & ~v39 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v39 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v50 = *((void *)&v211 + 1);
      int64_t v51 = _StringGuts.nativeUnusedCapacity.getter(v211, *((uint64_t *)&v211 + 1));
      if (v52) {
        goto LABEL_218;
      }
      if (v44 <= 15 && ((v50 & 0x2000000000000000) != 0 || v51 < v48))
      {
LABEL_52:
        swift_bridgeObjectRelease_n(v13, 5);
        unint64_t v55 = v211;
        swift_bridgeObjectRetain(v50);
        unint64_t v56 = _StringGuts._convertedToSmall()(v55, v50);
        unint64_t v58 = v57;
        swift_bridgeObjectRelease(v50);
        v59._rawBits = (v47 << 16) | 1;
        v60._rawBits = 1;
        unint64_t v61 = v206;
        v62._rawBits = _StringGuts.validateScalarRange(_:)(v60, v59, v206, v13);
        if (v62._rawBits < 0x10000) {
          v62._rawBits |= 3;
        }
        unint64_t v64 = specialized String.init(_:)(v62, v63, v61, v13);
        unint64_t v66 = v65;
        swift_bridgeObjectRelease(v13);
        unint64_t v67 = _StringGuts._convertedToSmall()(v64, v66);
        unint64_t v69 = v68;
        swift_bridgeObjectRelease(v66);
        unint64_t v70 = specialized _SmallString.init(_:appending:)(v56, v58, v67, v69);
        int64_t v2 = v207;
        if ((v72 & 1) == 0)
        {
          unint64_t v73 = v70;
          uint64_t v74 = v71;
          swift_bridgeObjectRelease(v50);
          *(void *)&long long v211 = v73;
          *((void *)&v211 + 1) = v74;
          unint64_t v3 = v198;
          goto LABEL_76;
        }
LABEL_217:
        unint64_t v193 = 266;
        goto LABEL_219;
      }
    }
    else if (v44 <= 15)
    {
      unint64_t v50 = *((void *)&v211 + 1);
      goto LABEL_52;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v44, v48);
    swift_bridgeObjectRelease_n(v13, 4);
    if ((v13 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v13);
      _StringGuts._foreignAppendInPlace(_:)(v206, v13, 0, v47);
      swift_bridgeObjectRelease(v13);
      goto LABEL_75;
    }
    uint64_t v44 = v46;
    uint64_t v46 = v206;
    if (v2)
    {
      swift_bridgeObjectRelease_n(v13, 2);
      uint64_t v208 = v46;
      uint64_t v209 = v13 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v53 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v3, (uint64_t)&v208, v3);
      _StringGuts.appendInPlace(_:isASCII:)(v53, v54, (v13 & 0x4000000000000000) != 0);
LABEL_75:
      unint64_t v3 = v198;
      int64_t v2 = v207;
      goto LABEL_76;
    }
    if ((v206 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v13);
      id v87 = (id)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v88 = v44;
      uint64_t v89 = v44;
      unint64_t v3 = v198;
      int64_t v2 = v207;
    }
    else
    {
LABEL_215:
      id v87 = _StringObject.sharedUTF8.getter(v46, v13);
      uint64_t v89 = v192;
      swift_bridgeObjectRelease(v13);
      if (v89 < v44) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
      }
      uint64_t v13 = v195;
      unint64_t v3 = v198;
      uint64_t v10 = v202;
      int64_t v2 = v207;
      uint64_t v88 = v44;
    }
    uint64_t v90 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v88, (uint64_t)v87, v89);
    _StringGuts.appendInPlace(_:isASCII:)(v90, v91, v46 < 0);
    swift_bridgeObjectRelease(v13);
LABEL_76:
    uint64_t v93 = *((void *)&v211 + 1);
    uint64_t v94 = HIBYTE(*((void *)&v211 + 1)) & 0xFLL;
    if ((*((void *)&v211 + 1) & 0x2000000000000000) == 0) {
      uint64_t v94 = v211 & 0xFFFFFFFFFFFFLL;
    }
    if (v94 || ((unint64_t)v211 & ~*((void *)&v211 + 1) & 0x2000000000000000) != 0)
    {
      if ((*((void *)&v211 + 1) & 0x2000000000000000) == 0
        || (unint64_t v95 = specialized _SmallString.init(_:appending:)(v211, *((unint64_t *)&v211 + 1), 0x5B28uLL, 0xE200000000000000), (v97 & 1) != 0))
      {
        swift_bridgeObjectRetain(0xE200000000000000);
        _StringGuts.append(_:)(23336, 0xE200000000000000, 0, 2);
        swift_bridgeObjectRelease_n(0xE200000000000000, 2);
        unint64_t v99 = *((void *)&v211 + 1);
        unint64_t v98 = v211;
      }
      else
      {
        unint64_t v98 = v95;
        unint64_t v99 = v96;
        swift_bridgeObjectRelease(v93);
        swift_bridgeObjectRelease(0xE200000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
      unint64_t v99 = 0xE200000000000000;
      unint64_t v98 = 23336;
    }
    uint64_t v100 = v213;
    unint64_t v101 = HIBYTE(v213) & 0xF;
    if ((v213 & 0x2000000000000000) == 0) {
      unint64_t v101 = v212 & 0xFFFFFFFFFFFFLL;
    }
    if (!v101 && (v212 & ~v213 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v213);
      unint64_t v212 = v98;
      unint64_t v213 = v99;
      goto LABEL_97;
    }
    if ((v213 & 0x2000000000000000) == 0)
    {
      if ((v99 & 0x2000000000000000) != 0) {
        goto LABEL_95;
      }
LABEL_92:
      uint64_t v102 = v98 & 0xFFFFFFFFFFFFLL;
LABEL_96:
      swift_bridgeObjectRetain(v99);
      _StringGuts.append(_:)(v98, v99, 0, v102);
      swift_bridgeObjectRelease_n(v99, 2);
      goto LABEL_97;
    }
    if ((v99 & 0x2000000000000000) == 0) {
      goto LABEL_92;
    }
    unint64_t v103 = specialized _SmallString.init(_:appending:)(v212, v213, v98, v99);
    if (v105)
    {
LABEL_95:
      uint64_t v102 = HIBYTE(v99) & 0xF;
      goto LABEL_96;
    }
    unint64_t v106 = v103;
    unint64_t v107 = v104;
    swift_bridgeObjectRelease(v100);
    swift_bridgeObjectRelease(v99);
    unint64_t v212 = v106;
    unint64_t v213 = v107;
LABEL_97:
    uint64_t v47 = v197;
    unint64_t v39 = (unint64_t)v205;
    if ((v2 & 0xC000000000000001) != 0)
    {
      if (v2 < 0) {
        uint64_t v108 = v2;
      }
      else {
        uint64_t v108 = v2 & 0xFFFFFFFFFFFFFF8;
      }
      uint64_t v109 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v110 = (unint64_t)swift_allocObject(v109, 0xE8uLL, 7uLL);
      uint64_t v200 = 0;
      uint64_t v111 = 0;
      uint64_t v44 = 0;
      *(void *)(v110 + 208) = v108;
      *(void *)(v110 + 216) = 0;
      *(_OWORD *)(v110 + 16) = 0u;
      *(_OWORD *)(v110 + 32) = 0u;
      *(_OWORD *)(v110 + 48) = 0u;
      *(_OWORD *)(v110 + 64) = 0u;
      *(_OWORD *)(v110 + 80) = 0u;
      *(_OWORD *)(v110 + 96) = 0u;
      *(_OWORD *)(v110 + 112) = 0u;
      *(_OWORD *)(v110 + 128) = 0u;
      *(_OWORD *)(v110 + 144) = 0u;
      *(_OWORD *)(v110 + 160) = 0u;
      *(_OWORD *)(v110 + 176) = 0u;
      *(_OWORD *)(v110 + 192) = 0u;
      *(void *)(v110 + 224) = 0;
      unint64_t v112 = v110 | 0x8000000000000000;
    }
    else
    {
      uint64_t v113 = -1 << *(unsigned char *)(v2 + 32);
      uint64_t v111 = ~v113;
      uint64_t v114 = *(void *)(v2 + 64);
      uint64_t v200 = v2 + 64;
      uint64_t v115 = -v113;
      if (v115 < 64) {
        uint64_t v116 = ~(-1 << v115);
      }
      else {
        uint64_t v116 = -1;
      }
      uint64_t v44 = v116 & v114;
      unint64_t v112 = v2;
    }
    uint64_t v207 = v112;
    uint64_t v201 = v112 & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v13 = v3 + 56;
    uint64_t v194 = v111;
    int64_t v199 = (unint64_t)(v111 + 64) >> 6;
    unint64_t v203 = v3 + 16;
    uint64_t v12 = (int64_t *)(v3 + 32);
    swift_bridgeObjectRetain(v2);
    uint64_t v204 = 0;
    uint64_t v46 = 1;
    long long v206 = xmmword_18162AC80;
    long long v196 = xmmword_18162AC90;
    while (v207 < 0)
    {
      id v124 = __CocoaDictionary.Iterator.nextKey()();
      if (!v124) {
        goto LABEL_167;
      }
      v126 = v124;
      _forceBridgeFromObjectiveC<A>(_:_:)(v124, (char *)v47, v125, v10);
      swift_unknownObjectRelease(v126);
      unint64_t v39 = (unint64_t)v205;
LABEL_126:
      (*(void (**)(char *, void, uint64_t, uint64_t))v13)(v10, 0, 1, v47);
      int64_t v2 = *v12;
      ((void (*)(unint64_t, char *, uint64_t))*v12)(v39, v10, v47);
      if ((v46 & 1) == 0)
      {
        uint64_t v16 = v212;
        unint64_t v39 = v213;
        unint64_t v130 = HIBYTE(v213) & 0xF;
        if ((v213 & 0x2000000000000000) != 0) {
          unint64_t v131 = HIBYTE(v213) & 0xF;
        }
        else {
          unint64_t v131 = v212 & 0xFFFFFFFFFFFFLL;
        }
        if (!v131 && (v212 & ~v213 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v213);
          unint64_t v212 = 8236;
          unint64_t v160 = 0xE200000000000000;
LABEL_164:
          unint64_t v213 = v160;
LABEL_165:
          uint64_t v10 = v202;
          goto LABEL_108;
        }
        if ((v213 & 0x2000000000000000) != 0 && v130 <= 0xD)
        {
          unint64_t v132 = 8 * (HIBYTE(v213) & 7);
          uint64_t v133 = (-255 << v132) - 1;
          uint64_t v134 = 44 << v132;
          char v135 = v130 + 1;
          if (v130 >= 8)
          {
            uint64_t v136 = v134 | v133 & v213;
          }
          else
          {
            uint64_t v16 = v134 | v133 & v212;
            if (v130 != 7)
            {
              uint64_t v16 = (32 << (8 * (v135 & 7u))) | ((-255 << (8 * (v135 & 7u))) - 1) & v16;
              uint64_t v159 = v213;
              goto LABEL_161;
            }
            char v135 = 8;
            uint64_t v136 = v213;
          }
          uint64_t v159 = (32 << (8 * (v135 & 7u))) | ((-255 << (8 * (v135 & 7u))) - 1) & v136;
LABEL_161:
          swift_bridgeObjectRelease(v213);
          swift_bridgeObjectRelease(0xE200000000000000);
          unint64_t v161 = 0xE000000000000000;
          if (v16 & 0x8080808080808080 | v159 & 0x80808080808080) {
            unint64_t v161 = 0xA000000000000000;
          }
          unint64_t v160 = (v161 & 0xFF00000000000000 | (v130 << 56) | v159 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
          unint64_t v212 = v16;
          goto LABEL_164;
        }
        swift_bridgeObjectRetain_n(0xE200000000000000, 6);
        if ((v39 & 0x1000000000000000) != 0) {
          unint64_t v131 = String.UTF8View._foreignCount()();
        }
        BOOL v49 = __OFADD__(v131, 2);
        uint64_t v46 = v131 + 2;
        uint64_t v10 = v202;
        if (v49) {
          goto LABEL_205;
        }
        if ((v16 & ~v39 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v39 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v137 = _StringGuts.nativeUnusedCapacity.getter(v16, v39);
          if (v138) {
            goto LABEL_218;
          }
          BOOL v140 = (v39 & 0x2000000000000000) == 0 && v137 > 1;
          if (v46 > 15 || v140) {
            goto LABEL_107;
          }
        }
        else if (v46 > 15)
        {
LABEL_107:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v46, 2);
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v211 = v196;
          uint64_t v117 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v211, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v117, v118, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
LABEL_108:
          unint64_t v39 = (unint64_t)v205;
          goto LABEL_109;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        swift_bridgeObjectRetain(v39);
        unint64_t v141 = _StringGuts._convertedToSmall()(v16, v39);
        unint64_t v143 = v142;
        swift_bridgeObjectRelease(v39);
        v144._rawBits = 1;
        v145._rawBits = 131073;
        v146._rawBits = _StringGuts.validateScalarRange(_:)(v144, v145, 0x202CuLL, 0xE200000000000000);
        if (v146._rawBits < 0x10000) {
          v146._rawBits |= 3;
        }
        unint64_t v148 = specialized String.init(_:)(v146, v147, 0x202CuLL, 0xE200000000000000);
        unint64_t v150 = v149;
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v151 = _StringGuts._convertedToSmall()(v148, v150);
        unint64_t v153 = v152;
        swift_bridgeObjectRelease(v150);
        unint64_t v154 = specialized _SmallString.init(_:appending:)(v141, v143, v151, v153);
        if (v156) {
          goto LABEL_217;
        }
        unint64_t v157 = v154;
        unint64_t v158 = v155;
        swift_bridgeObjectRelease(v39);
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v212 = v157;
        unint64_t v213 = v158;
        uint64_t v47 = v197;
        unint64_t v3 = v198;
        goto LABEL_165;
      }
LABEL_109:
      uint64_t v119 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
      inited = swift_initStackObject(v119, v210);
      *((_OWORD *)inited + 1) = v206;
      inited[7] = v47;
      boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
      ((void (*)(void *, unint64_t, uint64_t))v2)(boxed_opaque_existential_0Tm, v39, v47);
      specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, (uint64_t *)&v212);
      swift_bridgeObjectRelease((uint64_t)inited);
      swift_bridgeObjectRelease(0xE000000000000000);
      swift_bridgeObjectRelease(0xE100000000000000);
      uint64_t v46 = 0;
    }
    if (v44)
    {
      unint64_t v122 = __clz(__rbit64(v44));
      v44 &= v44 - 1;
      unint64_t v123 = v122 | (v204 << 6);
LABEL_125:
      (*(void (**)(char *, unint64_t, uint64_t))(v3 + 16))(v10, *(void *)(v207 + 48) + *(void *)(v3 + 72) * v123, v47);
      goto LABEL_126;
    }
    int64_t v127 = v204 + 1;
    uint64_t v16 = v200;
    if (__OFADD__(v204, 1)) {
      goto LABEL_204;
    }
    if (v127 < v199)
    {
      unint64_t v128 = *(void *)(v200 + 8 * v127);
      if (!v128)
      {
        uint64_t v129 = v204 + 2;
        if (v204 + 2 >= v199) {
          break;
        }
        unint64_t v128 = *(void *)(v200 + 8 * v129);
        if (!v128)
        {
          while (1)
          {
            int64_t v127 = v129 + 1;
            if (__OFADD__(v129, 1)) {
              break;
            }
            if (v127 >= v199) {
              goto LABEL_166;
            }
            unint64_t v128 = *(void *)(v200 + 8 * v127);
            ++v129;
            if (v128) {
              goto LABEL_124;
            }
          }
          __break(1u);
LABEL_204:
          __break(1u);
LABEL_205:
          __break(1u);
LABEL_206:
          uint64_t v204 = v46;
          swift_bridgeObjectRetain_n(v13, 5);
          v186._rawBits = 1;
          v187._rawBits = (v47 << 16) | 1;
          uint64_t v46 = v204;
          v188._rawBits = _StringGuts.validateScalarRange(_:)(v186, v187, (unint64_t)v12, v13);
          if (v188._rawBits < 0x10000) {
            v188._rawBits |= 3;
          }
          Swift::Int v48 = specialized Collection.count.getter(v188, v189, (unint64_t)v12, v13);
          swift_bridgeObjectRelease(v13);
          if ((v39 & 0x1000000000000000) != 0) {
            continue;
          }
LABEL_39:
          BOOL v49 = __OFADD__(v44, v48);
          v44 += v48;
          if (!v49) {
            goto LABEL_40;
          }
LABEL_211:
          __break(1u);
LABEL_212:
          Swift::Int v191 = String.UTF8View._foreignCount()();
          int64_t v163 = v191 + 2;
          if (!__OFADD__(v191, 2)) {
            goto LABEL_179;
          }
LABEL_214:
          __break(1u);
          goto LABEL_215;
        }
        int64_t v127 = v204 + 2;
      }
LABEL_124:
      uint64_t v44 = (v128 - 1) & v128;
      unint64_t v123 = __clz(__rbit64(v128)) + (v127 << 6);
      uint64_t v204 = v127;
      goto LABEL_125;
    }
    break;
  }
LABEL_166:
  uint64_t v44 = 0;
LABEL_167:
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))v13)(v10, 1, 1, v47);
  outlined consume of [A : B].Iterator._Variant<A, B>(v207);
  unint64_t v39 = v212;
  uint64_t v16 = v213;
  uint64_t v46 = HIBYTE(v213) & 0xF;
  if ((v213 & 0x2000000000000000) != 0) {
    unint64_t v162 = HIBYTE(v213) & 0xF;
  }
  else {
    unint64_t v162 = v212 & 0xFFFFFFFFFFFFLL;
  }
  if (!v162 && (v212 & ~v213 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v213);
    swift_bridgeObjectRelease(v195);
    return 10589;
  }
  uint64_t v13 = v195;
  if ((v213 & 0x2000000000000000) == 0 || (unint64_t)v46 > 0xD)
  {
    swift_bridgeObjectRetain_n(0xE200000000000000, 6);
    if ((v16 & 0x1000000000000000) != 0) {
      goto LABEL_212;
    }
    BOOL v49 = __OFADD__(v162, 2);
    int64_t v163 = v162 + 2;
    if (v49) {
      goto LABEL_214;
    }
LABEL_179:
    if ((v39 & ~v16 & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v163 <= 15) {
        goto LABEL_190;
      }
      goto LABEL_195;
    }
    int64_t v164 = _StringGuts.nativeUnusedCapacity.getter(v39, v16);
    if ((v165 & 1) == 0)
    {
      BOOL v167 = (v16 & 0x2000000000000000) == 0 && v164 > 1;
      if (v163 <= 15 && !v167)
      {
LABEL_190:
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        swift_bridgeObjectRetain(v16);
        unint64_t v168 = _StringGuts._convertedToSmall()(v39, v16);
        unint64_t v170 = v169;
        swift_bridgeObjectRelease(v16);
        v171._rawBits = 1;
        v172._rawBits = 131073;
        v173._rawBits = _StringGuts.validateScalarRange(_:)(v171, v172, 0x295DuLL, 0xE200000000000000);
        if (v173._rawBits < 0x10000) {
          v173._rawBits |= 3;
        }
        unint64_t v175 = specialized String.init(_:)(v173, v174, 0x295DuLL, 0xE200000000000000);
        unint64_t v177 = v176;
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v178 = _StringGuts._convertedToSmall()(v175, v177);
        unint64_t v180 = v179;
        swift_bridgeObjectRelease(v177);
        unint64_t v181 = specialized _SmallString.init(_:appending:)(v168, v170, v178, v180);
        if ((v182 & 1) == 0)
        {
          unint64_t v39 = v181;
          swift_bridgeObjectRelease(v16);
          swift_bridgeObjectRelease(v195);
          swift_bridgeObjectRelease(0xE200000000000000);
          return v39;
        }
        goto LABEL_217;
      }
LABEL_195:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v163, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 6);
      long long v211 = xmmword_18162AD20;
      v183 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v211, 2);
      _StringGuts.appendInPlace(_:isASCII:)(v183, v184, 1);
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(0xE200000000000000);
      return v212;
    }
LABEL_218:
    unint64_t v193 = 258;
LABEL_219:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v193, 0);
  }
  if ((unint64_t)v46 < 8)
  {
    unint64_t v39 = (93 << (8 * (HIBYTE(v213) & 7u))) | ((-255 << (8 * (HIBYTE(v213) & 7u))) - 1) & v212;
    if (v46 != 7) {
      unint64_t v39 = (41 << (8 * ((v46 + 1) & 7))) | ((-255 << (8 * ((v46 + 1) & 7))) - 1) & v39;
    }
  }
  swift_bridgeObjectRelease(v213);
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRelease(0xE200000000000000);
  return v39;
}

uint64_t Dictionary.Values.description.getter(int64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)v102 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = type metadata accessor for Optional(0, v8, v8, v9);
  MEMORY[0x1F4188790](v10 - 1);
  uint64_t v114 = (char *)v102 - v11;
  swift_bridgeObjectRelease(0xE000000000000000);
  uint64_t v117 = 91;
  unint64_t v118 = 0xE100000000000000;
  if ((a1 & 0xC000000000000001) != 0)
  {
    if (a1 < 0) {
      uint64_t v12 = a1;
    }
    else {
      uint64_t v12 = a1 & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v13 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v14 = (unint64_t)swift_allocObject(v13, 0xE8uLL, 7uLL);
    uint64_t v107 = 0;
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    *(void *)(v14 + 208) = v12;
    *(void *)(v14 + 216) = 0;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_OWORD *)(v14 + 80) = 0u;
    *(_OWORD *)(v14 + 96) = 0u;
    *(_OWORD *)(v14 + 112) = 0u;
    *(_OWORD *)(v14 + 128) = 0u;
    *(_OWORD *)(v14 + 144) = 0u;
    *(_OWORD *)(v14 + 160) = 0u;
    *(_OWORD *)(v14 + 176) = 0u;
    *(_OWORD *)(v14 + 192) = 0u;
    *(void *)(v14 + 224) = 0;
    uint64_t v17 = v14 | 0x8000000000000000;
  }
  else
  {
    uint64_t v18 = -1 << *(unsigned char *)(a1 + 32);
    uint64_t v15 = ~v18;
    uint64_t v19 = *(void *)(a1 + 64);
    uint64_t v107 = a1 + 64;
    uint64_t v20 = -v18;
    if (v20 < 64) {
      uint64_t v21 = ~(-1 << v20);
    }
    else {
      uint64_t v21 = -1;
    }
    unint64_t v16 = v21 & v19;
    uint64_t v17 = a1;
  }
  uint64_t v108 = v17 & 0x7FFFFFFFFFFFFFFFLL;
  int64_t v22 = v5 + 56;
  v102[1] = v15;
  int64_t v106 = (unint64_t)(v15 + 64) >> 6;
  uint64_t v111 = v5 + 16;
  unint64_t v23 = v5 + 32;
  swift_bridgeObjectRetain(a1);
  int64_t v112 = 0;
  uint64_t v24 = 1;
  long long v113 = xmmword_18162AC80;
  long long v105 = xmmword_18162AC90;
  uint64_t v104 = v5;
  unint64_t v103 = v7;
  int64_t v109 = v5 + 56;
  uint64_t v110 = v17;
  while (v17 < 0)
  {
    id v32 = __CocoaDictionary.Iterator.next()();
    if (!v32) {
      goto LABEL_71;
    }
    unint64_t v34 = v33;
    swift_unknownObjectRelease(v32);
    unint64_t v35 = v114;
    _forceBridgeFromObjectiveC<A>(_:_:)(v34, (char *)v3, v36, v114);
    swift_unknownObjectRelease(v34);
LABEL_30:
    (*(void (**)(char *, void, uint64_t, uint64_t))v22)(v35, 0, 1, v3);
    uint64_t v41 = v35;
    size_t v42 = *(void (**)(void *, char *, uint64_t))v23;
    (*(void (**)(char *, char *, uint64_t))v23)(v7, v41, v3);
    if ((v24 & 1) == 0)
    {
      uint64_t v17 = v117;
      uint64_t v43 = v118;
      unint64_t v44 = HIBYTE(v118) & 0xF;
      if ((v118 & 0x2000000000000000) != 0) {
        unint64_t v45 = HIBYTE(v118) & 0xF;
      }
      else {
        unint64_t v45 = v117 & 0xFFFFFFFFFFFFLL;
      }
      if (!v45 && (v117 & ~v118 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v118);
        uint64_t v117 = 8236;
        unint64_t v75 = 0xE200000000000000;
LABEL_67:
        unint64_t v118 = v75;
        goto LABEL_12;
      }
      if ((v118 & 0x2000000000000000) != 0 && v44 <= 0xD)
      {
        unint64_t v46 = 8 * (HIBYTE(v118) & 7);
        uint64_t v47 = (-255 << v46) - 1;
        uint64_t v48 = 44 << v46;
        char v49 = v44 + 1;
        if (v44 >= 8)
        {
          uint64_t v50 = v48 | v47 & v118;
        }
        else
        {
          uint64_t v17 = v48 | v47 & v117;
          if (v44 != 7)
          {
            uint64_t v17 = (32 << (8 * (v49 & 7u))) | ((-255 << (8 * (v49 & 7u))) - 1) & v17;
            uint64_t v74 = v118;
            goto LABEL_64;
          }
          char v49 = 8;
          uint64_t v50 = v118;
        }
        uint64_t v74 = (32 << (8 * (v49 & 7u))) | ((-255 << (8 * (v49 & 7u))) - 1) & v50;
LABEL_64:
        swift_bridgeObjectRelease(v118);
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v76 = 0xE000000000000000;
        if (v17 & 0x8080808080808080 | v74 & 0x80808080808080) {
          unint64_t v76 = 0xA000000000000000;
        }
        unint64_t v75 = (v76 & 0xFF00000000000000 | (v44 << 56) | v74 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
        uint64_t v117 = v17;
        goto LABEL_67;
      }
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v43 & 0x1000000000000000) == 0)
      {
        BOOL v51 = __OFADD__(v45, 2);
        int64_t v22 = v45 + 2;
        if (v51) {
          goto LABEL_70;
        }
LABEL_43:
        if ((v17 & ~v43 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v43 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v52 = _StringGuts.nativeUnusedCapacity.getter(v17, v43);
          if (v53) {
            goto LABEL_116;
          }
          BOOL v55 = (v43 & 0x2000000000000000) == 0 && v52 > 1;
          if (v22 > 15 || v55) {
            goto LABEL_11;
          }
        }
        else if (v22 > 15)
        {
LABEL_11:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v22, 2);
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v115 = v105;
          unint64_t v25 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v115, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v25, v26, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
LABEL_12:
          int64_t v22 = v109;
          uint64_t v17 = v110;
          goto LABEL_13;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        swift_bridgeObjectRetain(v43);
        unint64_t v56 = _StringGuts._convertedToSmall()(v17, v43);
        unint64_t v58 = v57;
        swift_bridgeObjectRelease(v43);
        v59._rawBits = 131073;
        v60._rawBits = 1;
        v61._rawBits = _StringGuts.validateScalarRange(_:)(v60, v59, 0x202CuLL, 0xE200000000000000);
        if (v61._rawBits < 0x10000) {
          v61._rawBits |= 3;
        }
        unint64_t v63 = specialized String.init(_:)(v61, v62, 0x202CuLL, 0xE200000000000000);
        unint64_t v65 = v64;
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v66 = _StringGuts._convertedToSmall()(v63, v65);
        unint64_t v68 = v67;
        swift_bridgeObjectRelease(v65);
        unint64_t v69 = specialized _SmallString.init(_:appending:)(v56, v58, v66, v68);
        if (v71) {
          goto LABEL_115;
        }
        uint64_t v72 = v69;
        unint64_t v73 = v70;
        swift_bridgeObjectRelease(v43);
        swift_bridgeObjectRelease(0xE200000000000000);
        uint64_t v117 = v72;
        unint64_t v118 = v73;
        uint64_t v5 = v104;
        uint64_t v7 = v103;
        goto LABEL_12;
      }
      Swift::Int v77 = String.UTF8View._foreignCount()();
      int64_t v22 = v77 + 2;
      if (!__OFADD__(v77, 2)) {
        goto LABEL_43;
      }
LABEL_70:
      __break(1u);
LABEL_71:
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))v22)(v114, 1, 1, v3);
      outlined consume of [A : B].Iterator._Variant<A, B>(v17);
      uint64_t v38 = v117;
      uint64_t v3 = v118;
      unint64_t v23 = HIBYTE(v118) & 0xF;
      uint64_t v24 = v117 & 0xFFFFFFFFFFFFLL;
      if ((v118 & 0x2000000000000000) != 0) {
        unint64_t v78 = HIBYTE(v118) & 0xF;
      }
      else {
        unint64_t v78 = v117 & 0xFFFFFFFFFFFFLL;
      }
      if (!v78 && (v117 & ~v118 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v118);
        return 93;
      }
      if ((v118 & 0x2000000000000000) != 0 && v23 != 15)
      {
        if (v23 < 8) {
          uint64_t v38 = (93 << (8 * (HIBYTE(v118) & 7u))) | ((-255 << (8 * (HIBYTE(v118) & 7u))) - 1) & v117;
        }
        swift_bridgeObjectRelease(v118);
        swift_bridgeObjectRelease(0xE100000000000000);
        return v38;
      }
      swift_bridgeObjectRetain_n(0xE100000000000000, 6);
      if ((v3 & 0x1000000000000000) != 0) {
        goto LABEL_104;
      }
      BOOL v51 = __OFADD__(v78, 1);
      uint64_t v79 = v78 + 1;
      if (!v51) {
        goto LABEL_83;
      }
LABEL_106:
      __break(1u);
      goto LABEL_107;
    }
LABEL_13:
    uint64_t v27 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v27, v116);
    *((_OWORD *)inited + 1) = v113;
    inited[7] = v3;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v42(boxed_opaque_existential_0Tm, v7, v3);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v117);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    uint64_t v24 = 0;
  }
  if (v16)
  {
    unint64_t v30 = __clz(__rbit64(v16));
    v16 &= v16 - 1;
    unint64_t v31 = v30 | (v112 << 6);
LABEL_29:
    unint64_t v35 = v114;
    (*(void (**)(char *, unint64_t, uint64_t))(v5 + 16))(v114, *(void *)(v17 + 56) + *(void *)(v5 + 72) * v31, v3);
    goto LABEL_30;
  }
  int64_t v37 = v112 + 1;
  uint64_t v38 = v107;
  if (__OFADD__(v112, 1)) {
    goto LABEL_103;
  }
  if (v37 >= v106) {
    goto LABEL_71;
  }
  unint64_t v39 = *(void *)(v107 + 8 * v37);
  if (v39)
  {
LABEL_28:
    unint64_t v16 = (v39 - 1) & v39;
    unint64_t v31 = __clz(__rbit64(v39)) + (v37 << 6);
    int64_t v112 = v37;
    goto LABEL_29;
  }
  int64_t v40 = v112 + 2;
  if (v112 + 2 >= v106) {
    goto LABEL_71;
  }
  unint64_t v39 = *(void *)(v107 + 8 * v40);
  if (v39)
  {
    int64_t v37 = v112 + 2;
    goto LABEL_28;
  }
  while (1)
  {
    int64_t v37 = v40 + 1;
    if (__OFADD__(v40, 1)) {
      break;
    }
    if (v37 >= v106) {
      goto LABEL_71;
    }
    unint64_t v39 = *(void *)(v107 + 8 * v37);
    ++v40;
    if (v39) {
      goto LABEL_28;
    }
  }
  __break(1u);
LABEL_103:
  __break(1u);
LABEL_104:
  Swift::Int v92 = String.UTF8View._foreignCount()();
  uint64_t v79 = v92 + 1;
  if (__OFADD__(v92, 1)) {
    goto LABEL_106;
  }
LABEL_83:
  if ((v38 & ~v3 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v3 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v80 = _StringGuts.nativeUnusedCapacity.getter(v38, v3);
    if (v81)
    {
LABEL_116:
      unint64_t v97 = 258;
    }
    else
    {
      if (v79 > 15) {
        goto LABEL_89;
      }
      if ((v3 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        goto LABEL_92;
      }
      if (v80 > 0) {
        goto LABEL_89;
      }
LABEL_91:
      swift_bridgeObjectRelease_n(0xE100000000000000, 5);
      if ((v3 & 0x2000000000000000) != 0)
      {
LABEL_92:
        uint64_t v24 = v3;
      }
      else if ((v3 & 0x1000000000000000) != 0)
      {
        uint64_t v38 = _StringGuts._foreignConvertedToSmall()(v38, v3);
        uint64_t v24 = v100;
      }
      else
      {
        if ((v38 & 0x1000000000000000) != 0)
        {
          unint64_t v96 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          unint64_t v96 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v38, v3);
          uint64_t v24 = v101;
        }
        swift_bridgeObjectRetain(v3);
        closure #1 in _StringGuts._convertedToSmall()(v96, v24, &v115);
        swift_bridgeObjectRelease(v3);
        uint64_t v24 = *((void *)&v115 + 1);
        uint64_t v38 = v115;
      }
      v84._rawBits = 1;
      v85._rawBits = 65537;
      v86._rawBits = _StringGuts.validateScalarRange(_:)(v84, v85, 0x5DuLL, 0xE100000000000000);
      if (v86._rawBits < 0x10000) {
        v86._rawBits |= 3;
      }
      unint64_t v23 = specialized String.init(_:)(v86, v87, 0x5DuLL, 0xE100000000000000);
      uint64_t v79 = v88;
      swift_bridgeObjectRelease(0xE100000000000000);
      if ((v79 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v79);
        goto LABEL_97;
      }
LABEL_107:
      uint64_t v93 = v38;
      if ((v79 & 0x1000000000000000) != 0)
      {
        unint64_t v23 = _StringGuts._foreignConvertedToSmall()(v23, v79);
        uint64_t v99 = v98;
        swift_bridgeObjectRelease(v79);
        uint64_t v79 = v99;
        uint64_t v38 = v93;
      }
      else
      {
        if ((v23 & 0x1000000000000000) != 0)
        {
          uint64_t v94 = (unsigned __int8 *)((v79 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v95 = v23 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v94 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v23, v79);
        }
        closure #1 in _StringGuts._convertedToSmall()(v94, v95, &v115);
        swift_bridgeObjectRelease(v79);
        uint64_t v79 = *((void *)&v115 + 1);
        unint64_t v23 = v115;
      }
LABEL_97:
      unint64_t v89 = specialized _SmallString.init(_:appending:)(v38, v24, v23, v79);
      if ((v90 & 1) == 0)
      {
        uint64_t v38 = v89;
        swift_bridgeObjectRelease(v3);
        swift_bridgeObjectRelease(0xE100000000000000);
        return v38;
      }
LABEL_115:
      unint64_t v97 = 266;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v97, 0);
  }
  if (v79 <= 15) {
    goto LABEL_91;
  }
LABEL_89:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v79, 1);
  swift_bridgeObjectRelease_n(0xE100000000000000, 6);
  long long v115 = xmmword_18162ACA0;
  char v82 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v115, 1);
  _StringGuts.appendInPlace(_:isASCII:)(v82, v83, 1);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v117;
}

uint64_t Dictionary.Values.debugDescription.getter(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1;
  unint64_t v197 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  v202 = (char *)v195 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v198 = (char *)v5;
  uint64_t v8 = type metadata accessor for Optional(0, v6, v5, v7);
  MEMORY[0x1F4188790](v8 - 1);
  unint64_t v203 = (char *)v195 - v9;
  unint64_t v212 = 0;
  unint64_t v213 = 0xE000000000000000;
  uint64_t v10 = specialized static String._createEmpty(withInitialCapacity:)(4);
  uint64_t inited = v10;
  unint64_t v13 = v11;
  *(void *)&long long v211 = v10;
  *((void *)&v211 + 1) = v11;
  unint64_t v14 = HIBYTE(v11) & 0xF;
  int64_t v15 = v10 & 0xFFFFFFFFFFFFLL;
  if ((v11 & 0x2000000000000000) != 0) {
    uint64_t v16 = HIBYTE(v11) & 0xF;
  }
  else {
    uint64_t v16 = v10 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v10 & ~v11 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v11);
    uint64_t inited = 0;
    unint64_t v35 = 0xE000000000000000;
    *(void *)&long long v211 = 0;
LABEL_21:
    *((void *)&v211 + 1) = v35;
    goto LABEL_25;
  }
  if ((v11 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v36 = 0xA000000000000000;
    if (!(v13 & 0x80808080808080 | inited & 0x8080808080808080)) {
      unint64_t v36 = 0xE000000000000000;
    }
    unint64_t v35 = v36 & 0xFF00000000000000 | (v14 << 56) | v13 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&long long v211 = inited;
    goto LABEL_21;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6);
  if ((v13 & 0x1000000000000000) != 0)
  {
    int64_t v15 = String.UTF8View._foreignCount()();
    if ((inited & ~v13 & 0x2000000000000000) == 0) {
      goto LABEL_23;
    }
  }
  else if ((inited & ~v13 & 0x2000000000000000) == 0)
  {
    goto LABEL_23;
  }
  if (swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v17 = _StringGuts.nativeUnusedCapacity.getter(inited, v13);
    if (v18) {
      goto LABEL_211;
    }
    if (v15 <= 15 && (v17 & 0x8000000000000000) != 0) {
      goto LABEL_13;
    }
    goto LABEL_24;
  }
LABEL_23:
  if (v15 <= 15)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE000000000000000, 5);
    swift_bridgeObjectRetain(v13);
    unint64_t v19 = _StringGuts._convertedToSmall()(inited, v13);
    unint64_t v21 = v20;
    swift_bridgeObjectRelease(v13);
    v22._rawBits = 1;
    v23._rawBits = 1;
    v24._rawBits = _StringGuts.validateScalarRange(_:)(v22, v23, 0, 0xE000000000000000);
    if (v24._rawBits < 0x10000) {
      v24._rawBits |= 3;
    }
    unint64_t v26 = specialized String.init(_:)(v24, v25, 0, 0xE000000000000000);
    unint64_t v28 = v27;
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v29 = _StringGuts._convertedToSmall()(v26, v28);
    unint64_t v31 = v30;
    swift_bridgeObjectRelease(v28);
    unint64_t v32 = specialized _SmallString.init(_:appending:)(v19, v21, v29, v31);
    if (v34) {
      goto LABEL_210;
    }
    uint64_t inited = v32;
    unint64_t v35 = v33;
    swift_bridgeObjectRelease(v13);
    swift_bridgeObjectRelease(0xE000000000000000);
    *(void *)&long long v211 = inited;
    goto LABEL_21;
  }
LABEL_24:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v15, 0);
  swift_bridgeObjectRelease_n(0xE000000000000000, 6);
  unint64_t v208 = 0;
  uint64_t v209 = 0;
  int64_t v37 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v208, 0);
  _StringGuts.appendInPlace(_:isASCII:)(v37, v38, 1);
  swift_bridgeObjectRelease(0xE000000000000000);
  unint64_t v35 = *((void *)&v211 + 1);
  uint64_t inited = v211;
LABEL_25:
  uint64_t v39 = HIBYTE(v35) & 0xF;
  if ((v35 & 0x2000000000000000) != 0) {
    int64_t v40 = (void (**)(unint64_t, unint64_t, char *))(HIBYTE(v35) & 0xF);
  }
  else {
    int64_t v40 = (void (**)(unint64_t, unint64_t, char *))(inited & 0xFFFFFFFFFFFFLL);
  }
  uint64_t v41 = "Dictionary.Values";
  if (!v40 && (inited & ~v35 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(0x80000001816DDF60 | 0x8000000000000000);
    swift_bridgeObjectRelease(v35);
    *(void *)&long long v211 = 0xD000000000000011;
    *((void *)&v211 + 1) = 0x80000001816DDF60 | 0x8000000000000000;
    goto LABEL_73;
  }
  if ((v35 & 0x2000000000000000) != 0 && (0x80000001816DDF60 & 0x2000000000000000) != 0)
  {
    unint64_t v14 = v39 + ((0x80000001816DDF60 >> 56) & 0xF);
    if (v14 <= 0xF)
    {
      unint64_t v71 = (0x80000001816DDF60 >> 56) & 0xF;
      if (v71)
      {
        char v73 = 0;
        uint64_t v74 = 0;
        unint64_t v72 = v35;
        do
        {
          uint64_t v75 = v39 + v74;
          uint64_t v76 = v74 + 1;
          unint64_t v77 = 0x80000001816DDF60 | 0x8000000000000000;
          if (v74 < 8) {
            unint64_t v77 = 0xD000000000000011;
          }
          unint64_t v78 = v77 >> (v73 & 0x38);
          char v79 = (8 * v39 + v73) & 0x38;
          uint64_t v80 = (-255 << v79) - 1;
          unint64_t v81 = (unint64_t)v78 << v79;
          unint64_t v82 = v81 | v80 & v72;
          unint64_t v83 = v81 | v80 & inited;
          if (v75 < 8) {
            uint64_t inited = v83;
          }
          else {
            unint64_t v72 = v82;
          }
          v73 += 8;
          uint64_t v74 = v76;
        }
        while (v71 != v76);
      }
      else
      {
        unint64_t v72 = v35;
      }
      swift_bridgeObjectRelease(v35);
      unint64_t v84 = 0xA000000000000000;
      if (!(inited & 0x8080808080808080 | v72 & 0x80808080808080)) {
        unint64_t v84 = 0xE000000000000000;
      }
      *(void *)&long long v211 = inited;
      *((void *)&v211 + 1) = v84 & 0xFF00000000000000 | (v14 << 56) | v72 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_73;
    }
  }
  size_t v42 = (char *)(0x80000001816DDF60 | 0x8000000000000000);
  if ((0x80000001816DDF60 & 0x2000000000000000) != 0) {
    unint64_t v43 = (0x80000001816DDF60 >> 56) & 0xF;
  }
  else {
    unint64_t v43 = 17;
  }
  swift_bridgeObjectRetain_n(0x80000001816DDF60 | 0x8000000000000000, 2);
  if ((0x80000001816DDF60 & 0x1000000000000000) != 0) {
    goto LABEL_202;
  }
  swift_bridgeObjectRetain_n(0x80000001816DDF60 | 0x8000000000000000, 4);
  Swift::Int v44 = v43;
  if ((v35 & 0x1000000000000000) == 0) {
    goto LABEL_38;
  }
LABEL_205:
  Swift::Int v193 = String.UTF8View._foreignCount()();
  int64_t v45 = v193 + v44;
  if (__OFADD__(v193, v44)) {
    goto LABEL_207;
  }
LABEL_39:
  if ((inited & ~v35 & 0x2000000000000000) != 0
    && swift_isUniquelyReferenced_nonNull_native(v35 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v46 = _StringGuts.nativeUnusedCapacity.getter(inited, v35);
    if (v47) {
      goto LABEL_211;
    }
    uint64_t v48 = (v35 >> 61) & 1;
    if (v46 < v44) {
      LODWORD(v48) = 1;
    }
    if (v45 <= 15 && v48) {
      goto LABEL_46;
    }
LABEL_51:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v45, v44);
    unint64_t v67 = (unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000;
    swift_bridgeObjectRelease_n(v67, 4);
    if (((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
      _StringGuts._foreignAppendInPlace(_:)(0xD000000000000011, (unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000, 0, v43);
    }
    else
    {
      char v68 = ((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) & 0x2000000000000000) == 0
         || (v67 & 0x4000000000000000) != 0;
      swift_bridgeObjectRelease((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
      if (((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
        unint64_t v208 = 0xD000000000000011;
        uint64_t v209 = (unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) & 0xFFFFFFFFFFFFFFLL;
        Swift::String::Index v85 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v43, (uint64_t)&v208, ((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v85, v86, v68);
        goto LABEL_73;
      }
      unint64_t v67 = (unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000;
      unint64_t v69 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v43, ((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) & 0xFFFFFFFFFFFFFFFLL) + 32, 17);
      _StringGuts.appendInPlace(_:isASCII:)(v69, v70, v68);
    }
    swift_bridgeObjectRelease(v67);
    goto LABEL_73;
  }
  if (v45 > 15) {
    goto LABEL_51;
  }
LABEL_46:
  swift_bridgeObjectRelease_n((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000, 5);
  swift_bridgeObjectRetain(v35);
  unint64_t v49 = _StringGuts._convertedToSmall()(inited, v35);
  unint64_t v51 = v50;
  swift_bridgeObjectRelease(v35);
  v52._rawBits = (v43 << 16) | 1;
  v53._rawBits = 1;
  v54._rawBits = _StringGuts.validateScalarRange(_:)(v53, v52, 0xD000000000000011, (unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
  if (v54._rawBits < 0x10000) {
    v54._rawBits |= 3;
  }
  unint64_t v56 = specialized String.init(_:)(v54, v55, 0xD000000000000011, (unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
  unint64_t v58 = v57;
  swift_bridgeObjectRelease((unint64_t)(v41 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
  unint64_t v59 = _StringGuts._convertedToSmall()(v56, v58);
  unint64_t v61 = v60;
  swift_bridgeObjectRelease(v58);
  unint64_t v62 = specialized _SmallString.init(_:appending:)(v49, v51, v59, v61);
  if (v64) {
    goto LABEL_210;
  }
  unint64_t v65 = v62;
  uint64_t v66 = v63;
  swift_bridgeObjectRelease(v35);
  *(void *)&long long v211 = v65;
  *((void *)&v211 + 1) = v66;
LABEL_73:
  uint64_t v87 = *((void *)&v211 + 1);
  uint64_t v88 = HIBYTE(*((void *)&v211 + 1)) & 0xFLL;
  if ((*((void *)&v211 + 1) & 0x2000000000000000) == 0) {
    uint64_t v88 = v211 & 0xFFFFFFFFFFFFLL;
  }
  if (v88 || ((unint64_t)v211 & ~*((void *)&v211 + 1) & 0x2000000000000000) != 0)
  {
    if ((*((void *)&v211 + 1) & 0x2000000000000000) == 0
      || (unint64_t v89 = specialized _SmallString.init(_:appending:)(v211, *((unint64_t *)&v211 + 1), 0x5B28uLL, 0xE200000000000000), (v91 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(23336, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
      unint64_t v93 = *((void *)&v211 + 1);
      unint64_t v92 = v211;
    }
    else
    {
      unint64_t v92 = v89;
      unint64_t v93 = v90;
      swift_bridgeObjectRelease(v87);
      swift_bridgeObjectRelease(0xE200000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
    unint64_t v93 = 0xE200000000000000;
    unint64_t v92 = 23336;
  }
  uint64_t v94 = v213;
  unint64_t v95 = HIBYTE(v213) & 0xF;
  if ((v213 & 0x2000000000000000) == 0) {
    unint64_t v95 = v212 & 0xFFFFFFFFFFFFLL;
  }
  if (!v95 && (v212 & ~v213 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v213);
    unint64_t v212 = v92;
    unint64_t v213 = v93;
    goto LABEL_94;
  }
  if ((v213 & 0x2000000000000000) == 0)
  {
    if ((v93 & 0x2000000000000000) != 0) {
      goto LABEL_92;
    }
LABEL_89:
    uint64_t v96 = v92 & 0xFFFFFFFFFFFFLL;
LABEL_93:
    swift_bridgeObjectRetain(v93);
    _StringGuts.append(_:)(v92, v93, 0, v96);
    swift_bridgeObjectRelease_n(v93, 2);
    goto LABEL_94;
  }
  if ((v93 & 0x2000000000000000) == 0) {
    goto LABEL_89;
  }
  unint64_t v97 = specialized _SmallString.init(_:appending:)(v212, v213, v92, v93);
  if (v99)
  {
LABEL_92:
    uint64_t v96 = HIBYTE(v93) & 0xF;
    goto LABEL_93;
  }
  unint64_t v100 = v97;
  unint64_t v101 = v98;
  swift_bridgeObjectRelease(v94);
  swift_bridgeObjectRelease(v93);
  unint64_t v212 = v100;
  unint64_t v213 = v101;
LABEL_94:
  uint64_t inited = v3;
  BOOL v102 = (v3 & 0xC000000000000001) == 0;
  size_t v42 = v198;
  unint64_t v43 = v197;
  unint64_t v3 = (unint64_t)v203;
  unint64_t v35 = (unint64_t)v202;
  if (v102)
  {
    uint64_t v109 = -1 << *(unsigned char *)(inited + 32);
    uint64_t v106 = ~v109;
    uint64_t v110 = *(void *)(inited + 64);
    unint64_t v200 = inited + 64;
    uint64_t v111 = -v109;
    if (v111 < 64) {
      uint64_t v112 = ~(-1 << v111);
    }
    else {
      uint64_t v112 = -1;
    }
    unint64_t v107 = v112 & v110;
    unint64_t v108 = inited;
  }
  else
  {
    if (inited < 0) {
      uint64_t v103 = inited;
    }
    else {
      uint64_t v103 = inited & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v104 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v105 = (unint64_t)swift_allocObject(v104, 0xE8uLL, 7uLL);
    unint64_t v200 = 0;
    uint64_t v106 = 0;
    unint64_t v107 = 0;
    *(void *)(v105 + 208) = v103;
    *(void *)(v105 + 216) = 0;
    *(_OWORD *)(v105 + 16) = 0u;
    *(_OWORD *)(v105 + 32) = 0u;
    *(_OWORD *)(v105 + 48) = 0u;
    *(_OWORD *)(v105 + 64) = 0u;
    *(_OWORD *)(v105 + 80) = 0u;
    *(_OWORD *)(v105 + 96) = 0u;
    *(_OWORD *)(v105 + 112) = 0u;
    *(_OWORD *)(v105 + 128) = 0u;
    *(_OWORD *)(v105 + 144) = 0u;
    *(_OWORD *)(v105 + 160) = 0u;
    *(_OWORD *)(v105 + 176) = 0u;
    *(_OWORD *)(v105 + 192) = 0u;
    *(void *)(v105 + 224) = 0;
    unint64_t v108 = v105 | 0x8000000000000000;
  }
  unint64_t v207 = v108;
  uint64_t v201 = v108 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v41 = (const char *)(v43 + 56);
  v195[1] = v106;
  int64_t v199 = (unint64_t)(v106 + 64) >> 6;
  unint64_t v204 = v43 + 16;
  int64_t v40 = (void (**)(unint64_t, unint64_t, char *))(v43 + 32);
  swift_bridgeObjectRetain(inited);
  int64_t v205 = 0;
  char v113 = 1;
  long long v206 = xmmword_18162AC80;
  long long v196 = xmmword_18162AC90;
  while (1)
  {
    if ((v207 & 0x8000000000000000) != 0)
    {
      id v120 = __CocoaDictionary.Iterator.next()();
      if (!v120) {
        goto LABEL_164;
      }
      unint64_t v122 = v121;
      swift_unknownObjectRelease(v120);
      _forceBridgeFromObjectiveC<A>(_:_:)(v122, v42, v123, (char *)v3);
      swift_unknownObjectRelease(v122);
    }
    else
    {
      if (v107)
      {
        unint64_t v118 = __clz(__rbit64(v107));
        v107 &= v107 - 1;
        unint64_t v119 = v118 | (v205 << 6);
      }
      else
      {
        int64_t v124 = v205 + 1;
        unint64_t v14 = v200;
        if (__OFADD__(v205, 1)) {
          goto LABEL_201;
        }
        if (v124 >= v199) {
          goto LABEL_164;
        }
        unint64_t v125 = *(void *)(v200 + 8 * v124);
        if (!v125)
        {
          int64_t v126 = v205 + 2;
          if (v205 + 2 >= v199) {
            goto LABEL_164;
          }
          unint64_t v125 = *(void *)(v200 + 8 * v126);
          if (!v125)
          {
            while (1)
            {
              int64_t v124 = v126 + 1;
              if (__OFADD__(v126, 1)) {
                break;
              }
              if (v124 >= v199) {
                goto LABEL_164;
              }
              unint64_t v125 = *(void *)(v200 + 8 * v124);
              ++v126;
              if (v125) {
                goto LABEL_121;
              }
            }
            __break(1u);
LABEL_201:
            __break(1u);
LABEL_202:
            swift_bridgeObjectRetain_n((uint64_t)v42, 5);
            v189._rawBits = 1;
            v190._rawBits = (v43 << 16) | 1;
            v191._rawBits = _StringGuts.validateScalarRange(_:)(v189, v190, 0xD000000000000011, (unint64_t)v42);
            if (v191._rawBits < 0x10000) {
              v191._rawBits |= 3;
            }
            Swift::Int v44 = specialized Collection.count.getter(v191, v192, 0xD000000000000011, (unint64_t)v42);
            swift_bridgeObjectRelease((uint64_t)v42);
            if ((v35 & 0x1000000000000000) != 0) {
              goto LABEL_205;
            }
LABEL_38:
            int64_t v45 = (int64_t)v40 + v44;
            if (!__OFADD__(v40, v44)) {
              goto LABEL_39;
            }
LABEL_207:
            __break(1u);
LABEL_208:
            unint64_t v165 = String.UTF8View._foreignCount()();
LABEL_175:
            BOOL v136 = __OFADD__(v165, 2);
            int64_t v166 = v165 + 2;
            if (v136)
            {
              __break(1u);
              goto LABEL_210;
            }
            if ((v14 & ~inited & 0x2000000000000000) == 0
              || !swift_isUniquelyReferenced_nonNull_native(inited & 0xFFFFFFFFFFFFFFFLL))
            {
              if (v166 <= 15) {
                goto LABEL_187;
              }
              goto LABEL_192;
            }
            int64_t v167 = _StringGuts.nativeUnusedCapacity.getter(v14, inited);
            if ((v168 & 1) == 0)
            {
              BOOL v170 = (inited & 0x2000000000000000) == 0 && v167 > 1;
              if (v166 <= 15 && !v170)
              {
LABEL_187:
                swift_bridgeObjectRelease_n(0xE200000000000000, 5);
                swift_bridgeObjectRetain(inited);
                unint64_t v171 = _StringGuts._convertedToSmall()(v14, inited);
                unint64_t v173 = v172;
                swift_bridgeObjectRelease(inited);
                v174._rawBits = 1;
                v175._rawBits = 131073;
                v176._rawBits = _StringGuts.validateScalarRange(_:)(v174, v175, 0x295DuLL, 0xE200000000000000);
                if (v176._rawBits < 0x10000) {
                  v176._rawBits |= 3;
                }
                unint64_t v178 = specialized String.init(_:)(v176, v177, 0x295DuLL, 0xE200000000000000);
                unint64_t v180 = v179;
                swift_bridgeObjectRelease(0xE200000000000000);
                unint64_t v181 = _StringGuts._convertedToSmall()(v178, v180);
                unint64_t v183 = v182;
                swift_bridgeObjectRelease(v180);
                unint64_t v184 = specialized _SmallString.init(_:appending:)(v171, v173, v181, v183);
                if ((v185 & 1) == 0)
                {
                  unint64_t v14 = v184;
                  swift_bridgeObjectRelease(inited);
                  swift_bridgeObjectRelease(0x80000001816DDF60 | 0x8000000000000000);
                  swift_bridgeObjectRelease(0xE200000000000000);
                  return v14;
                }
LABEL_210:
                unint64_t v194 = 266;
LABEL_212:
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v194, 0);
              }
LABEL_192:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v166, 2);
              swift_bridgeObjectRelease_n(0xE200000000000000, 6);
              long long v211 = xmmword_18162AD20;
              Swift::String::Index v186 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v211, 2);
              _StringGuts.appendInPlace(_:isASCII:)(v186, v187, 1);
              swift_bridgeObjectRelease(0x80000001816DDF60 | 0x8000000000000000);
              swift_bridgeObjectRelease(0xE200000000000000);
              return v212;
            }
LABEL_211:
            unint64_t v194 = 258;
            goto LABEL_212;
          }
          int64_t v124 = v205 + 2;
        }
LABEL_121:
        unint64_t v107 = (v125 - 1) & v125;
        unint64_t v119 = __clz(__rbit64(v125)) + (v124 << 6);
        int64_t v205 = v124;
      }
      (*(void (**)(unint64_t, unint64_t, char *))(v43 + 16))(v3, *(void *)(v207 + 56) + *(void *)(v43 + 72) * v119, v42);
    }
    (*(void (**)(unint64_t, void, uint64_t, char *))v41)(v3, 0, 1, v42);
    int64_t v127 = *v40;
    (*v40)(v35, v3, v42);
    if ((v113 & 1) == 0) {
      break;
    }
LABEL_106:
    uint64_t v116 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    uint64_t inited = (uint64_t)swift_initStackObject(v116, v210);
    *(_OWORD *)(inited + 16) = v206;
    *(void *)(inited + 56) = v42;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm((void *)(inited + 32));
    v127((unint64_t)boxed_opaque_existential_0Tm, v35, v42);
    specialized _debugPrint<A>(_:separator:terminator:to:)(inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, (uint64_t *)&v212);
    swift_bridgeObjectRelease(inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    char v113 = 0;
  }
  uint64_t v129 = v212;
  unint64_t v128 = v213;
  unint64_t v3 = HIBYTE(v213) & 0xF;
  if ((v213 & 0x2000000000000000) != 0) {
    unint64_t v130 = HIBYTE(v213) & 0xF;
  }
  else {
    unint64_t v130 = v212 & 0xFFFFFFFFFFFFLL;
  }
  if (!v130 && (v212 & ~v213 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v213);
    unint64_t v212 = 8236;
    unint64_t v161 = 0xE200000000000000;
LABEL_160:
    unint64_t v213 = v161;
    goto LABEL_105;
  }
  if ((v213 & 0x2000000000000000) != 0 && v3 <= 0xD)
  {
    unint64_t v131 = 8 * (HIBYTE(v213) & 7);
    uint64_t v132 = (-255 << v131) - 1;
    uint64_t v133 = 44 << v131;
    char v134 = v3 + 1;
    if (v3 >= 8)
    {
      uint64_t v135 = v133 | v132 & v213;
    }
    else
    {
      uint64_t v129 = v133 | v132 & v212;
      if (v3 != 7)
      {
        uint64_t v129 = (32 << (8 * (v134 & 7u))) | ((-255 << (8 * (v134 & 7u))) - 1) & v129;
        uint64_t v160 = v213;
        goto LABEL_157;
      }
      char v134 = 8;
      uint64_t v135 = v213;
    }
    uint64_t v160 = (32 << (8 * (v134 & 7u))) | ((-255 << (8 * (v134 & 7u))) - 1) & v135;
LABEL_157:
    swift_bridgeObjectRelease(v213);
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v162 = 0xE000000000000000;
    if (v129 & 0x8080808080808080 | v160 & 0x80808080808080) {
      unint64_t v162 = 0xA000000000000000;
    }
    unint64_t v161 = (v162 & 0xFF00000000000000 | (v3 << 56) | v160 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
    unint64_t v212 = v129;
    goto LABEL_160;
  }
  swift_bridgeObjectRetain_n(0xE200000000000000, 6);
  if ((v128 & 0x1000000000000000) == 0)
  {
    BOOL v136 = __OFADD__(v130, 2);
    int64_t v137 = v130 + 2;
    if (v136) {
      goto LABEL_163;
    }
LABEL_136:
    if ((v129 & ~v128 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v128 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v138 = _StringGuts.nativeUnusedCapacity.getter(v129, v128);
      if (v139) {
        goto LABEL_211;
      }
      BOOL v141 = (v128 & 0x2000000000000000) == 0 && v138 > 1;
      if (v137 > 15 || v141) {
        goto LABEL_104;
      }
    }
    else if (v137 > 15)
    {
LABEL_104:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v137, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 6);
      long long v211 = v196;
      uint64_t v114 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v211, 2);
      _StringGuts.appendInPlace(_:isASCII:)(v114, v115, 1);
      swift_bridgeObjectRelease(0xE200000000000000);
LABEL_105:
      unint64_t v3 = (unint64_t)v203;
      unint64_t v35 = (unint64_t)v202;
      goto LABEL_106;
    }
    swift_bridgeObjectRelease_n(0xE200000000000000, 5);
    swift_bridgeObjectRetain(v128);
    unint64_t v142 = _StringGuts._convertedToSmall()(v129, v128);
    unint64_t v144 = v143;
    swift_bridgeObjectRelease(v128);
    v145._rawBits = 1;
    v146._rawBits = 131073;
    v147._rawBits = _StringGuts.validateScalarRange(_:)(v145, v146, 0x202CuLL, 0xE200000000000000);
    if (v147._rawBits < 0x10000) {
      v147._rawBits |= 3;
    }
    unint64_t v149 = specialized String.init(_:)(v147, v148, 0x202CuLL, 0xE200000000000000);
    unint64_t v151 = v150;
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v152 = _StringGuts._convertedToSmall()(v149, v151);
    unint64_t v154 = v153;
    swift_bridgeObjectRelease(v151);
    unint64_t v155 = specialized _SmallString.init(_:appending:)(v142, v144, v152, v154);
    if (v157) {
      goto LABEL_210;
    }
    unint64_t v158 = v155;
    unint64_t v159 = v156;
    swift_bridgeObjectRelease(v128);
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v212 = v158;
    unint64_t v213 = v159;
    size_t v42 = v198;
    unint64_t v43 = v197;
    goto LABEL_105;
  }
  Swift::Int v163 = String.UTF8View._foreignCount()();
  int64_t v137 = v163 + 2;
  if (!__OFADD__(v163, 2)) {
    goto LABEL_136;
  }
LABEL_163:
  __break(1u);
LABEL_164:
  (*(void (**)(unint64_t, uint64_t, uint64_t, char *))v41)(v3, 1, 1, v42);
  outlined consume of [A : B].Iterator._Variant<A, B>(v207);
  unint64_t v14 = v212;
  uint64_t inited = v213;
  unint64_t v164 = HIBYTE(v213) & 0xF;
  if ((v213 & 0x2000000000000000) != 0) {
    unint64_t v165 = HIBYTE(v213) & 0xF;
  }
  else {
    unint64_t v165 = v212 & 0xFFFFFFFFFFFFLL;
  }
  if (v165 || (v212 & ~v213 & 0x2000000000000000) != 0)
  {
    if ((v213 & 0x2000000000000000) == 0 || v164 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((inited & 0x1000000000000000) != 0) {
        goto LABEL_208;
      }
      goto LABEL_175;
    }
    if (v164 < 8)
    {
      unint64_t v14 = (93 << (8 * (HIBYTE(v213) & 7u))) | ((-255 << (8 * (HIBYTE(v213) & 7u))) - 1) & v212;
      if (v164 != 7) {
        unint64_t v14 = (41 << (8 * ((v164 + 1) & 7))) | ((-255 << (8 * ((v164 + 1) & 7))) - 1) & v14;
      }
    }
    swift_bridgeObjectRelease(v213);
    swift_bridgeObjectRelease(0x80000001816DDF60 | 0x8000000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v213);
    swift_bridgeObjectRelease(0x80000001816DDF60 | 0x8000000000000000);
    return 10589;
  }
  return v14;
}

uint64_t (*Dictionary.Keys.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

id __CocoaDictionary.Iterator.nextKey()()
{
  uint64_t v1 = *(void *)(v0 + 216);
  if (v1 < 0) {
    return 0;
  }
  if (v1 != *(void *)(v0 + 224)) {
    goto LABEL_5;
  }
  id result = [*(id *)(v0 + 208) countByEnumeratingWithState:v0 + 16 objects:v0 + 80 count:16];
  *(void *)(v0 + 224) = result;
  if (result)
  {
    uint64_t v1 = 0;
    *(void *)(v0 + 216) = 0;
LABEL_5:
    uint64_t v3 = *(void *)(v0 + 24);
    if (!v3) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x305uLL, 0);
    }
    if ((unint64_t)(v1 - 0x1000000000000000) >> 61 == 7)
    {
      uint64_t v4 = (void **)(v3 + 8 * v1);
      if ((v4 & 7) == 0)
      {
        uint64_t v5 = *v4;
        *(void *)(v0 + 216) = v1 + 1;
        return swift_unknownObjectRetain(v5);
      }
    }
    else
    {
      __break(1u);
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
  }
  *(void *)(v0 + 216) = -1;
  return result;
}

uint64_t _NativeDictionary.Iterator.nextKey()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (!v4)
  {
    uint64_t v12 = v2[3];
    int64_t v13 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      return result;
    }
    int64_t v14 = (unint64_t)(v2[2] + 64) >> 6;
    if (v13 < v14)
    {
      v2[3] = v13;
      uint64_t v15 = v2[1];
      unint64_t v16 = *(void *)(v15 + 8 * v13);
      v2[4] = v16;
      if (v16)
      {
LABEL_7:
        v2[4] = (v16 - 1) & v16;
        unint64_t v5 = __clz(__rbit64(v16)) + (v13 << 6);
        goto LABEL_3;
      }
      int64_t v13 = v12 + 2;
      if (v12 + 2 < v14)
      {
        v2[3] = v13;
        unint64_t v16 = *(void *)(v15 + 8 * v13);
        v2[4] = v16;
        if (v16) {
          goto LABEL_7;
        }
        uint64_t v17 = v12 + 3;
        while (v14 != v17)
        {
          v2[3] = v17;
          unint64_t v16 = *(void *)(v15 + 8 * v17);
          v2[4] = v16;
          ++v17;
          if (v16)
          {
            int64_t v13 = v17 - 1;
            goto LABEL_7;
          }
        }
      }
    }
    uint64_t v11 = *(void *)(result + 16);
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56);
    uint64_t v9 = a2;
    uint64_t v10 = 1;
    goto LABEL_15;
  }
  v2[4] = (v4 - 1) & v4;
  unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
  uint64_t v6 = *(void *)(*v2 + 48);
  uint64_t v7 = *(void *)(result + 16);
  uint64_t v18 = *(void *)(v7 - 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v18 + 16))(a2, v6 + *(void *)(v18 + 72) * v5, v7);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 56);
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = v7;
LABEL_15:

  return v8(v9, v10, 1, v11);
}

double Dictionary.Iterator._asNative.setter(__n128 *a1, uint64_t a2)
{
  *(void *)&double result = Dictionary.Iterator._asNative.setter(a1, a2, (void (*)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t))outlined consume of [A : B].Iterator._Variant<A, B>).n128_u64[0];
  return result;
}

atomic_ullong *Dictionary.Keys.Iterator._base.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  uint64_t v5 = v1[2];
  uint64_t v6 = v1[3];
  uint64_t v7 = v1[4];
  double result = outlined copy of [A : B].Iterator._Variant<A, B>(v3);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  return result;
}

__n128 Dictionary.Keys.Iterator._base.setter(__n128 *a1)
{
  __n128 v4 = a1[1];
  __n128 v5 = *a1;
  unint64_t v2 = a1[2].n128_u64[0];
  outlined consume of [A : B].Iterator._Variant<A, B>(v1->n128_u64[0]);
  __n128 result = v4;
  *uint64_t v1 = v5;
  v1[1] = v4;
  v1[2].n128_u64[0] = v2;
  return result;
}

uint64_t (*Dictionary.Values.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

__n128 Dictionary.Keys.Iterator.init(_:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v2;
  return result;
}

uint64_t Dictionary.Values.Iterator.next()@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  uint64_t v4 = *v2;
  if (*v2 < 0)
  {
    int64_t v14 = *(char **)(result + 24);
    id v15 = __CocoaDictionary.Iterator.next()();
    if (v15)
    {
      uint64_t v17 = v16;
      swift_unknownObjectRelease(v15);
      _forceBridgeFromObjectiveC<A>(_:_:)(v17, v14, v18, a2);
      swift_unknownObjectRelease(v17);
      unint64_t v19 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v14 - 1) + 56);
      unint64_t v20 = a2;
      uint64_t v21 = 0;
    }
    else
    {
      unint64_t v19 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v14 - 1) + 56);
      unint64_t v20 = a2;
      uint64_t v21 = 1;
    }
    return v19(v20, v21, 1, v14);
  }
  else
  {
    uint64_t v5 = v2[1];
    uint64_t v6 = v2[2];
    int64_t v8 = v2[3];
    unint64_t v7 = v2[4];
    if (v7)
    {
      uint64_t v9 = (v7 - 1) & v7;
      unint64_t v10 = __clz(__rbit64(v7)) | (v8 << 6);
LABEL_4:
      uint64_t v11 = *(void *)(result + 24);
      uint64_t v12 = *(void *)(v11 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v12 + 16))(a2, *(void *)(v4 + 56) + *(void *)(v12 + 72) * v10, v11);
      __n128 result = (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v12 + 56))(a2, 0, 1, v11);
      int64_t v13 = v8;
LABEL_22:
      *uint64_t v2 = v4;
      v2[1] = v5;
      v2[2] = v6;
      v2[3] = v13;
      v2[4] = v9;
      return result;
    }
    int64_t v22 = v8 + 1;
    if (!__OFADD__(v8, 1))
    {
      int64_t v23 = (unint64_t)(v6 + 64) >> 6;
      int64_t v13 = v2[3];
      if (v22 < v23)
      {
        unint64_t v24 = *(void *)(v5 + 8 * v22);
        if (v24)
        {
LABEL_10:
          uint64_t v9 = (v24 - 1) & v24;
          unint64_t v10 = __clz(__rbit64(v24)) + (v22 << 6);
          int64_t v8 = v22;
          goto LABEL_4;
        }
        int64_t v13 = v8 + 1;
        if (v8 + 2 < v23)
        {
          unint64_t v24 = *(void *)(v5 + 8 * (v8 + 2));
          int64_t v22 = v8 + 2;
          if (v24) {
            goto LABEL_10;
          }
          int64_t v13 = v23 - 1;
          int64_t v25 = v8 + 3;
          while (v23 != v25)
          {
            unint64_t v24 = *(void *)(v5 + 8 * v25++);
            if (v24)
            {
              int64_t v22 = v25 - 1;
              goto LABEL_10;
            }
          }
        }
      }
      __n128 result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(result + 24) - 8) + 56))(a2, 1, 1);
      uint64_t v9 = 0;
      goto LABEL_22;
    }
    __break(1u);
  }
  return result;
}

id __CocoaDictionary.Iterator.next()()
{
  id v1 = __CocoaDictionary.Iterator.nextKey()();
  if (v1 && !objc_msgSend(*(id *)(v0 + 208), sel_objectForKey_, v1)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x310uLL, 0);
  }
  return v1;
}

uint64_t _NativeDictionary.Iterator.nextValue()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (!v4)
  {
    uint64_t v12 = v2[3];
    int64_t v13 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      return result;
    }
    int64_t v14 = (unint64_t)(v2[2] + 64) >> 6;
    if (v13 < v14)
    {
      v2[3] = v13;
      uint64_t v15 = v2[1];
      unint64_t v16 = *(void *)(v15 + 8 * v13);
      v2[4] = v16;
      if (v16)
      {
LABEL_11:
        v2[4] = (v16 - 1) & v16;
        unint64_t v5 = __clz(__rbit64(v16)) + (v13 << 6);
        goto LABEL_3;
      }
      uint64_t v17 = v12 + 2;
      while (v14 != v17)
      {
        v2[3] = v17;
        unint64_t v16 = *(void *)(v15 + 8 * v17);
        v2[4] = v16;
        ++v17;
        if (v16)
        {
          int64_t v13 = v17 - 1;
          goto LABEL_11;
        }
      }
    }
    uint64_t v11 = *(void *)(result + 24);
    int64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56);
    uint64_t v9 = a2;
    uint64_t v10 = 1;
    goto LABEL_13;
  }
  v2[4] = (v4 - 1) & v4;
  unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
  uint64_t v6 = *(void *)(*v2 + 56);
  uint64_t v7 = *(void *)(result + 24);
  uint64_t v18 = *(void *)(v7 - 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v18 + 16))(a2, v6 + *(void *)(v18 + 72) * v5, v7);
  int64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 56);
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = v7;
LABEL_13:

  return v8(v9, v10, 1, v11);
}

uint64_t specialized static Dictionary<>.== infix(_:_:)(unint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0;
  }
  unint64_t v27 = a1 + 64;
  uint64_t v4 = 1 << *(unsigned char *)(a1 + 32);
  uint64_t v5 = -1;
  if (v4 < 64) {
    uint64_t v5 = ~(-1 << v4);
  }
  unint64_t v6 = v5 & *(void *)(a1 + 64);
  int64_t v28 = (unint64_t)(v4 + 63) >> 6;
  uint64_t result = swift_bridgeObjectRetain(a1);
  int64_t v29 = 0;
  if (!v6) {
    goto LABEL_8;
  }
LABEL_6:
  unint64_t v8 = __clz(__rbit64(v6));
  v6 &= v6 - 1;
  unint64_t v9 = v8 | (v29 << 6);
LABEL_7:
  uint64_t v10 = 40 * v9;
  outlined init with copy of AnyHashable(*(void *)(v3 + 48) + 40 * v9, (uint64_t)&v40);
  outlined init with copy of AnyHashable(*(void *)(v3 + 56) + v10, (uint64_t)&v42[1]);
  while (1)
  {
    outlined init with take of (key: AnyHashable, value: AnyHashable)?((uint64_t)&v40, (uint64_t)&v43, &demangling cache variable for type metadata for (key: AnyHashable, value: AnyHashable)?);
    if (!*((void *)&v44 + 1))
    {
      swift_bridgeObjectRelease(v3);
      return 1;
    }
    long long v40 = v43;
    long long v41 = v44;
    v42[0] = v45;
    long long v37 = v46;
    long long v38 = v47;
    uint64_t v39 = v48;
    unint64_t v15 = specialized __RawDictionaryStorage.find<A>(_:)(&v40);
    char v17 = v16;
    outlined destroy of AnyHashable((uint64_t *)&v40);
    if ((v17 & 1) == 0)
    {
      swift_bridgeObjectRelease(v3);
      outlined destroy of AnyHashable((uint64_t *)&v37);
      return 0;
    }
    uint64_t v18 = v3;
    uint64_t v19 = v2;
    outlined init with copy of AnyHashable(*(void *)(v2 + 56) + 40 * v15, (uint64_t)v34);
    uint64_t v20 = v35;
    uint64_t v21 = v36;
    __swift_project_boxed_opaque_existential_0Tm(v34, v35);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v21 + 8))(v31, v20, v21);
    uint64_t v22 = v32;
    uint64_t v23 = v33;
    __swift_project_boxed_opaque_existential_0Tm(v31, v32);
    uint64_t v24 = *((void *)&v38 + 1);
    uint64_t v25 = v39;
    __swift_project_boxed_opaque_existential_0Tm(&v37, *((uint64_t *)&v38 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v25 + 8))(v30, v24, v25);
    char v26 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v23 + 16))(v30, v22, v23);
    __swift_destroy_boxed_opaque_existential_1Tm(v30);
    if (v26 == 2)
    {
      __swift_destroy_boxed_opaque_existential_1Tm(v31);
      outlined destroy of AnyHashable(v34);
      outlined destroy of AnyHashable((uint64_t *)&v37);
      uint64_t v3 = v18;
LABEL_34:
      swift_bridgeObjectRelease(v3);
      return 0;
    }
    __swift_destroy_boxed_opaque_existential_1Tm(v31);
    outlined destroy of AnyHashable(v34);
    uint64_t result = (uint64_t)outlined destroy of AnyHashable((uint64_t *)&v37);
    uint64_t v3 = v18;
    if ((v26 & 1) == 0) {
      goto LABEL_34;
    }
    uint64_t v2 = v19;
    if (v6) {
      goto LABEL_6;
    }
LABEL_8:
    int64_t v11 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      __break(1u);
      goto LABEL_37;
    }
    if (v11 < v28)
    {
      unint64_t v12 = *(void *)(v27 + 8 * v11);
      if (v12) {
        goto LABEL_11;
      }
      int64_t v13 = v29 + 2;
      ++v29;
      if (v11 + 1 < v28)
      {
        unint64_t v12 = *(void *)(v27 + 8 * v13);
        if (v12)
        {
          ++v11;
LABEL_11:
          unint64_t v6 = (v12 - 1) & v12;
          unint64_t v9 = __clz(__rbit64(v12)) + (v11 << 6);
          int64_t v29 = v11;
          goto LABEL_7;
        }
        int64_t v14 = v11 + 2;
        int64_t v29 = v11 + 1;
        if (v11 + 2 < v28) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v6 = 0;
    long long v41 = 0u;
    memset(v42, 0, sizeof(v42));
    long long v40 = 0u;
  }
  unint64_t v12 = *(void *)(v27 + 8 * v14);
  if (v12)
  {
    v11 += 2;
    goto LABEL_11;
  }
  while (1)
  {
    int64_t v11 = v14 + 1;
    if (__OFADD__(v14, 1)) {
      break;
    }
    if (v11 >= v28)
    {
      int64_t v29 = v28 - 1;
      goto LABEL_23;
    }
    unint64_t v12 = *(void *)(v27 + 8 * v11);
    ++v14;
    if (v12) {
      goto LABEL_11;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

unint64_t specialized static Dictionary<>.== infix(_:_:)(unint64_t result, uint64_t a2)
{
  if (result == a2) {
    return 1;
  }
  unint64_t v3 = result;
  if (*(void *)(result + 16) != *(void *)(a2 + 16)) {
    return 0;
  }
  int64_t v4 = 0;
  unint64_t v5 = result + 64;
  uint64_t v6 = 1 << *(unsigned char *)(result + 32);
  uint64_t v7 = -1;
  if (v6 < 64) {
    uint64_t v7 = ~(-1 << v6);
  }
  unint64_t v8 = v7 & *(void *)(result + 64);
  int64_t v9 = (unint64_t)(v6 + 63) >> 6;
  while (1)
  {
    if (v8)
    {
      unint64_t v10 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v11 = v10 | (v4 << 6);
      goto LABEL_22;
    }
    int64_t v12 = v4 + 1;
    if (__OFADD__(v4, 1))
    {
      __break(1u);
      goto LABEL_27;
    }
    if (v12 >= v9) {
      return 1;
    }
    unint64_t v13 = *(void *)(v5 + 8 * v12);
    ++v4;
    if (!v13)
    {
      int64_t v4 = v12 + 1;
      if (v12 + 1 >= v9) {
        return 1;
      }
      unint64_t v13 = *(void *)(v5 + 8 * v4);
      if (!v13)
      {
        int64_t v4 = v12 + 2;
        if (v12 + 2 >= v9) {
          return 1;
        }
        unint64_t v13 = *(void *)(v5 + 8 * v4);
        if (!v13) {
          break;
        }
      }
    }
LABEL_21:
    unint64_t v8 = (v13 - 1) & v13;
    unint64_t v11 = __clz(__rbit64(v13)) + (v4 << 6);
LABEL_22:
    uint64_t v15 = 8 * v11;
    uint64_t v16 = *(void *)(*(void *)(v3 + 56) + v15);
    uint64_t result = specialized __RawDictionaryStorage.find<A>(_:)(*(void *)(*(void *)(v3 + 48) + v15));
    if ((v17 & 1) == 0 || *(void *)(*(void *)(a2 + 56) + 8 * result) != v16) {
      return 0;
    }
  }
  int64_t v14 = v12 + 3;
  if (v14 >= v9) {
    return 1;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v14);
  if (v13)
  {
    int64_t v4 = v14;
    goto LABEL_21;
  }
  while (1)
  {
    int64_t v4 = v14 + 1;
    if (__OFADD__(v14, 1)) {
      break;
    }
    if (v4 >= v9) {
      return 1;
    }
    unint64_t v13 = *(void *)(v5 + 8 * v4);
    ++v14;
    if (v13) {
      goto LABEL_21;
    }
  }
LABEL_27:
  __break(1u);
  return result;
}

uint64_t static Dictionary<>.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v88 = a5;
  uint64_t v89 = a6;
  uint64_t v10 = *((void *)a4 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  unint64_t v13 = (char *)&v65 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v65 - v15;
  uint64_t v18 = *(void *)(v17 - 8);
  MEMORY[0x1F4188790](v14);
  uint64_t v20 = (char *)&v65 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, v21, (uint64_t)a4, "key value ", 0);
  uint64_t v25 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v23, v24);
  uint64_t v26 = MEMORY[0x1F4188790](v25);
  uint64_t result = MEMORY[0x1F4188790](v26);
  unint64_t v32 = a2 & 0xC000000000000001;
  if ((a1 & 0xC000000000000001) != 0)
  {
    if (a1 < 0) {
      uint64_t v33 = (void *)a1;
    }
    else {
      uint64_t v33 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
    }
    if (v32)
    {
      if (a2 < 0) {
        char v34 = (void *)a2;
      }
      else {
        char v34 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
      }
      return swift_stdlib_NSObject_isEqual(v33, v34);
    }
    uint64_t v35 = a2;
    goto LABEL_18;
  }
  uint64_t v81 = v31;
  unint64_t v82 = v20;
  unint64_t v84 = TupleTypeMetadata2;
  if (v32)
  {
    if (a2 < 0) {
      uint64_t v33 = (void *)a2;
    }
    else {
      uint64_t v33 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
    }
    uint64_t v35 = a1;
LABEL_18:
    uint64_t v36 = v89;
    return _NativeDictionary<>.isEqual(to:)(v33, v35, a3, a4, v28, v36);
  }
  if (a1 == a2) {
    return 1;
  }
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0;
  }
  char v79 = (char *)&v65 - v30;
  uint64_t v76 = v16;
  unint64_t v71 = v13;
  int64_t v37 = 0;
  uint64_t v38 = *(void *)(a1 + 64);
  uint64_t v66 = a1 + 64;
  uint64_t v39 = 1 << *(unsigned char *)(a1 + 32);
  uint64_t v40 = -1;
  if (v39 < 64) {
    uint64_t v40 = ~(-1 << v39);
  }
  unint64_t v41 = v40 & v38;
  size_t v42 = v84;
  unint64_t v78 = v84 - 1;
  uint64_t v68 = v18 + 16;
  uint64_t v83 = v10 + 16;
  unint64_t v77 = (void (**)(char *, uint64_t, uint64_t))(v29 + 32);
  uint64_t v74 = (void (**)(char *, char *, char *))(v10 + 32);
  uint64_t v75 = (void (**)(uint64_t, char *, uint64_t *))(v18 + 32);
  uint64_t v69 = v18;
  uint64_t v70 = v89 + 8;
  uint64_t v87 = v10;
  unint64_t v72 = (void (**)(char *, char *))(v10 + 8);
  char v73 = (void (**)(uint64_t, uint64_t *))(v18 + 8);
  int64_t v67 = (unint64_t)(v39 + 63) >> 6;
  int64_t v65 = v67 - 1;
  uint64_t v80 = result;
  while (1)
  {
    if (v41)
    {
      uint64_t v85 = (v41 - 1) & v41;
      int64_t v86 = v37;
      unint64_t v43 = __clz(__rbit64(v41)) | (v37 << 6);
      uint64_t v44 = v87;
      uint64_t v45 = v69;
      uint64_t v47 = v81;
      uint64_t v46 = (uint64_t)v82;
      goto LABEL_28;
    }
    int64_t v49 = v37 + 1;
    uint64_t v44 = v87;
    uint64_t v47 = v81;
    uint64_t v46 = (uint64_t)v82;
    if (__OFADD__(v37, 1))
    {
      __break(1u);
      goto LABEL_58;
    }
    if (v49 < v67) {
      break;
    }
    int64_t v86 = v37;
LABEL_34:
    uint64_t v85 = 0;
LABEL_35:
    uint64_t v48 = 1;
LABEL_36:
    uint64_t v51 = *(v42 - 1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v51 + 56))(v47, v48, 1, v42);
    Swift::String::Index v52 = v79;
    (*v77)(v79, v47, v80);
    int v53 = (*(uint64_t (**)(char *, uint64_t, uint64_t *))(v51 + 48))(v52, 1, v42);
    BOOL v54 = v53 == 1;
    if (v53 == 1) {
      return v54;
    }
    Swift::String::Index v55 = &v52[*((int *)v42 + 12)];
    (*v75)(v46, v52, a3);
    unint64_t v56 = v76;
    (*v74)(v76, v55, a4);
    unint64_t v57 = __RawDictionaryStorage.find<A>(_:)(v46, (uint64_t)a3, v88);
    char v59 = v58;
    (*v73)(v46, a3);
    if ((v59 & 1) == 0)
    {
      (*v72)(v56, a4);
      return 0;
    }
    uint64_t v60 = v87;
    unint64_t v61 = v71;
    (*(void (**)(char *, unint64_t, char *))(v87 + 16))(v71, *(void *)(a2 + 56) + *(void *)(v87 + 72) * v57, a4);
    char v62 = (*(uint64_t (**)(char *, char *, char *))(v89 + 8))(v61, v56, a4);
    uint64_t v63 = *(void (**)(char *, char *))(v60 + 8);
    v63(v61, a4);
    uint64_t result = ((uint64_t (*)(char *, char *))v63)(v56, a4);
    size_t v42 = v84;
    unint64_t v41 = v85;
    int64_t v37 = v86;
    if ((v62 & 1) == 0) {
      return v54;
    }
  }
  unint64_t v50 = *(void *)(v66 + 8 * v49);
  uint64_t v45 = v69;
  if (v50) {
    goto LABEL_32;
  }
  if (v37 + 2 >= v67)
  {
    uint64_t v85 = 0;
    int64_t v86 = v37 + 1;
    goto LABEL_35;
  }
  unint64_t v50 = *(void *)(v66 + 8 * (v37 + 2));
  if (v50)
  {
    int64_t v49 = v37 + 2;
    goto LABEL_32;
  }
  uint64_t v64 = v37 + 3;
  if (v37 + 3 >= v67)
  {
    int64_t v86 = v37 + 2;
    goto LABEL_34;
  }
  unint64_t v50 = *(void *)(v66 + 8 * v64);
  if (v50)
  {
    int64_t v49 = v37 + 3;
LABEL_32:
    uint64_t v85 = (v50 - 1) & v50;
    int64_t v86 = v49;
    unint64_t v43 = __clz(__rbit64(v50)) + (v49 << 6);
LABEL_28:
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(v45 + 16))(v47, *(void *)(a1 + 48) + *(void *)(v45 + 72) * v43, a3);
    (*(void (**)(uint64_t, unint64_t, char *))(v44 + 16))(v47 + *((int *)v42 + 12), *(void *)(a1 + 56) + *(void *)(v44 + 72) * v43, a4);
    uint64_t v48 = 0;
    goto LABEL_36;
  }
  while (1)
  {
    int64_t v49 = v64 + 1;
    if (__OFADD__(v64, 1)) {
      break;
    }
    if (v49 >= v67)
    {
      uint64_t v85 = 0;
      uint64_t v48 = 1;
      int64_t v86 = v65;
      goto LABEL_36;
    }
    unint64_t v50 = *(void *)(v66 + 8 * v49);
    ++v64;
    if (v50) {
      goto LABEL_32;
    }
  }
LABEL_58:
  __break(1u);
  return result;
}

uint64_t _NativeDictionary<>.isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v75 = a6;
  uint64_t v72 = a5;
  uint64_t v8 = *(void *)(a4 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v70 = (char *)&v55 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v13 = (char *)&v55 - v12;
  uint64_t v69 = *(void *)(v14 - 8);
  MEMORY[0x1F4188790](v11);
  unint64_t v71 = (char *)&v55 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v79 = v16;
  uint64_t v18 = v17;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, v16, v17, "key value ", 0);
  uint64_t v74 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v20, v21);
  uint64_t v22 = MEMORY[0x1F4188790](v74);
  uint64_t v24 = (char *)&v55 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t result = MEMORY[0x1F4188790](v22);
  uint64_t v28 = (char *)&v55 - v27;
  if (a2 == a1) {
    return 1;
  }
  if (*(void *)(a2 + 16) != *(void *)(a1 + 16)) {
    return 0;
  }
  int64_t v73 = 0;
  uint64_t v58 = a2;
  uint64_t v29 = *(void *)(a2 + 64);
  uint64_t v56 = a2 + 64;
  uint64_t v30 = 1 << *(unsigned char *)(a2 + 32);
  uint64_t v31 = -1;
  if (v30 < 64) {
    uint64_t v31 = ~(-1 << v30);
  }
  unint64_t v32 = v31 & v29;
  uint64_t v68 = TupleTypeMetadata2 - 1;
  uint64_t v59 = v69 + 16;
  uint64_t v77 = v8 + 16;
  uint64_t v66 = (void (**)(char *, char *, uint64_t))(v69 + 32);
  int64_t v67 = (void (**)(char *, char *, Class *))(v26 + 32);
  uint64_t v64 = (void (**)(uint64_t, uint64_t))(v69 + 8);
  int64_t v65 = (void (**)(char *, char *, uint64_t))(v8 + 32);
  uint64_t v60 = v75 + 8;
  uint64_t v63 = (void (**)(char *, uint64_t))(v8 + 8);
  int64_t v57 = (unint64_t)(v30 + 63) >> 6;
  int64_t v55 = v57 - 1;
  uint64_t v33 = v18;
  unint64_t v61 = TupleTypeMetadata2;
  char v62 = v24;
  while (1)
  {
    if (v32)
    {
      uint64_t v78 = (v32 - 1) & v32;
      unint64_t v34 = __clz(__rbit64(v32)) | (v73 << 6);
      uint64_t v35 = v58;
      goto LABEL_8;
    }
    int64_t v52 = v73 + 1;
    if (__OFADD__(v73, 1))
    {
      __break(1u);
      goto LABEL_32;
    }
    if (v52 >= v57)
    {
      uint64_t v78 = 0;
      uint64_t v36 = 1;
      goto LABEL_9;
    }
    unint64_t v53 = *(void *)(v56 + 8 * v52);
    if (v53) {
      goto LABEL_16;
    }
    int64_t v54 = v73 + 2;
    if (v73 + 2 < v57) {
      break;
    }
    uint64_t v78 = 0;
    uint64_t v36 = 1;
    ++v73;
LABEL_9:
    uint64_t v37 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v37 + 56))(v24, v36, 1, TupleTypeMetadata2);
    (*v67)(v28, v24, v74);
    int v38 = (*(uint64_t (**)(char *, uint64_t, uint64_t *))(v37 + 48))(v28, 1, TupleTypeMetadata2);
    BOOL v76 = v38 == 1;
    if (v38 == 1) {
      return v76;
    }
    uint64_t v39 = v8;
    uint64_t v40 = &v28[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v41 = (uint64_t)v71;
    size_t v42 = v28;
    uint64_t v43 = v79;
    (*v66)(v71, v28, v79);
    (*v65)(v13, v40, v33);
    unint64_t v44 = __RawDictionaryStorage.find<A>(_:)(v41, v43, v72);
    char v46 = v45;
    (*v64)(v41, v43);
    if ((v46 & 1) == 0)
    {
      (*v63)(v13, v33);
      return 0;
    }
    uint64_t v8 = v39;
    unint64_t v47 = *(void *)(a1 + 56) + *(void *)(v39 + 72) * v44;
    uint64_t v48 = *(void (**)(char *, unint64_t, uint64_t))(v39 + 16);
    int64_t v49 = v70;
    v48(v70, v47, v33);
    char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(v75 + 8))(v49, v13, v33);
    uint64_t v51 = *(void (**)(char *, uint64_t))(v8 + 8);
    v51(v49, v33);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v51)(v13, v33);
    TupleTypeMetadata2 = v61;
    uint64_t v24 = v62;
    uint64_t v28 = v42;
    unint64_t v32 = v78;
    if ((v50 & 1) == 0) {
      return v76;
    }
  }
  unint64_t v53 = *(void *)(v56 + 8 * v54);
  if (v53)
  {
    int64_t v52 = v73 + 2;
LABEL_16:
    uint64_t v35 = v58;
    uint64_t v78 = (v53 - 1) & v53;
    unint64_t v34 = __clz(__rbit64(v53)) + (v52 << 6);
    int64_t v73 = v52;
LABEL_8:
    (*(void (**)(char *, unint64_t, uint64_t))(v69 + 16))(v24, *(void *)(v35 + 48) + *(void *)(v69 + 72) * v34, v79);
    (*(void (**)(char *, unint64_t, uint64_t))(v8 + 16))(&v24[*((int *)TupleTypeMetadata2 + 12)], *(void *)(v35 + 56) + *(void *)(v8 + 72) * v34, v33);
    uint64_t v36 = 0;
    goto LABEL_9;
  }
  while (1)
  {
    int64_t v52 = v54 + 1;
    if (__OFADD__(v54, 1)) {
      break;
    }
    if (v52 >= v57)
    {
      uint64_t v78 = 0;
      uint64_t v36 = 1;
      int64_t v73 = v55;
      goto LABEL_9;
    }
    unint64_t v53 = *(void *)(v56 + 8 * v52);
    ++v54;
    if (v53) {
      goto LABEL_16;
    }
  }
LABEL_32:
  __break(1u);
  return result;
}

uint64_t _NativeDictionary<>.isEqual(to:)(void *a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v77 = a6;
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)a4, (uint64_t)a3, (uint64_t)a4);
  uint64_t v71 = (uint64_t)*(v10 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  unint64_t v13 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  char v62 = (char *)&v53 - v15;
  uint64_t v16 = *((void *)a4 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v74 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v78 = (char *)&v53 - v20;
  uint64_t v21 = *(a3 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v63 = (id *)((char *)&v53 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v75 = v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (id *)((char *)&v53 - v24);
  id v26 = *(id *)(a2 + 16);
  id v76 = a1;
  if (v26 == objc_msgSend(a1, sel_count))
  {
    uint64_t v59 = v13;
    uint64_t v60 = v10;
    int64_t v27 = 0;
    uint64_t v72 = a2;
    uint64_t v73 = v21;
    uint64_t v30 = *(void *)(a2 + 64);
    uint64_t v29 = a2 + 64;
    uint64_t v28 = v30;
    uint64_t v31 = 1 << *(unsigned char *)(v29 - 32);
    uint64_t v32 = -1;
    if (v31 < 64) {
      uint64_t v32 = ~(-1 << v31);
    }
    unint64_t v33 = v32 & v28;
    uint64_t v64 = v29;
    int64_t v65 = (unint64_t)(v31 + 63) >> 6;
    uint64_t v69 = v16 + 16;
    uint64_t v70 = v21 + 16;
    unint64_t v61 = (void (**)(char *, id *, uint64_t *))(v21 + 32);
    uint64_t v68 = (void (**)(id *, uint64_t *))(v21 + 8);
    uint64_t v58 = (void (**)(char *, uint64_t, uint64_t, char *))(v16 + 56);
    int64_t v57 = (void (**)(char *, void *, Class *))(v71 + 16);
    uint64_t v56 = (unsigned int (**)(char *, uint64_t, char *))(v16 + 48);
    int64_t v55 = (void (**)(void *, Class *))(v71 + 8);
    int64_t v54 = (void (**)(char *, char *, char *))(v16 + 32);
    uint64_t v67 = v77 + 8;
    uint64_t v71 = v16;
    unint64_t v34 = (void (**)(char *, char *))(v16 + 8);
    uint64_t v66 = qword_1ECA06328;
    while (1)
    {
      if (v33)
      {
        unint64_t v35 = __clz(__rbit64(v33));
        v33 &= v33 - 1;
        unint64_t v36 = v35 | (v27 << 6);
        uint64_t v37 = v73;
      }
      else
      {
        int64_t v38 = v27 + 1;
        if (__OFADD__(v27, 1))
        {
          __break(1u);
LABEL_32:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
        }
        if (v38 >= v65) {
          return 1;
        }
        unint64_t v39 = *(void *)(v64 + 8 * v38);
        ++v27;
        uint64_t v37 = v73;
        if (!v39)
        {
          while (1)
          {
            int64_t v27 = v38 + 1;
            if (__OFADD__(v38, 1)) {
              break;
            }
            if (v27 >= v65) {
              return 1;
            }
            unint64_t v39 = *(void *)(v64 + 8 * v27);
            ++v38;
            if (v39) {
              goto LABEL_13;
            }
          }
          __break(1u);
LABEL_30:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
LABEL_13:
        unint64_t v33 = (v39 - 1) & v39;
        unint64_t v36 = __clz(__rbit64(v39)) + (v27 << 6);
      }
      uint64_t v40 = v72;
      (*(void (**)(id *, unint64_t, uint64_t *))(v37 + 16))(v25, *(void *)(v72 + 48) + *(void *)(v37 + 72) * v36, a3);
      (*(void (**)(char *, unint64_t, char *))(v71 + 16))(v78, *(void *)(v40 + 56) + *(void *)(v71 + 72) * v36, a4);
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
      {
        if (v75 != 8) {
          goto LABEL_30;
        }
        uint64_t v41 = *v25;
        size_t v42 = *v68;
        swift_unknownObjectRetain(*v25);
        v42(v25, a3);
      }
      else
      {
        uint64_t v48 = v63;
        (*v61)((char *)v63, v25, a3);
        uint64_t v41 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v48, a3);
      }
      uint64_t v43 = (swift *)[v76 objectForKey:v41];
      swift_unknownObjectRelease(v41);
      if (!v43) {
        break;
      }
      if (_swift_isClassOrObjCExistentialType((uint64_t)a4, (uint64_t *)a4))
      {
        uint64_t v79 = v43;
        unint64_t v44 = v74;
        swift_dynamicCast(v74, (unint64_t *)&v79, v66, a4, 7uLL);
      }
      else
      {
        int64_t v49 = v62;
        (*v58)(v62, 1, 1, a4);
        _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v43, (uint64_t)a4, v49);
        swift_unknownObjectRelease(v43);
        uint64_t v51 = v59;
        char v50 = v60;
        (*v57)(v59, v49, v60);
        if ((*v56)(v51, 1, a4) == 1) {
          goto LABEL_32;
        }
        (*v55)(v49, v50);
        unint64_t v44 = v74;
        (*v54)(v74, v51, a4);
      }
      char v45 = v78;
      char v46 = (*(uint64_t (**)(char *, char *, char *))(v77 + 8))(v78, v44, a4);
      unint64_t v47 = *v34;
      (*v34)(v45, a4);
      v47(v44, a4);
      if ((v46 & 1) == 0) {
        return 0;
      }
    }
    (*v34)(v78, a4);
  }
  return 0;
}

void specialized Dictionary<>.hash(into:)(long long *a1, unint64_t a2)
{
  unint64_t v27 = a2 + 64;
  uint64_t v4 = 1 << *(unsigned char *)(a2 + 32);
  uint64_t v5 = -1;
  if (v4 < 64) {
    uint64_t v5 = ~(-1 << v4);
  }
  unint64_t v6 = v5 & *(void *)(a2 + 64);
  int64_t v28 = (unint64_t)(v4 + 63) >> 6;
  swift_bridgeObjectRetain(a2);
  Swift::UInt v7 = 0;
  int64_t v8 = 0;
  if (!v6) {
    goto LABEL_6;
  }
LABEL_4:
  unint64_t v9 = __clz(__rbit64(v6));
  v6 &= v6 - 1;
  unint64_t v10 = v9 | (v8 << 6);
LABEL_5:
  uint64_t v11 = 40 * v10;
  outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v10, (uint64_t)&v37);
  outlined init with copy of AnyHashable(*(void *)(a2 + 56) + v11, (uint64_t)&v39 + 8);
  while (1)
  {
    outlined init with take of (key: AnyHashable, value: AnyHashable)?((uint64_t)&v37, (uint64_t)&v42, &demangling cache variable for type metadata for (key: AnyHashable, value: AnyHashable)?);
    if (!*((void *)&v43 + 1))
    {
      swift_release(a2);
      Hasher._combine(_:)(v7);
      return;
    }
    v35[0] = v42;
    v35[1] = v43;
    uint64_t v36 = v44;
    long long v32 = v45;
    long long v33 = v46;
    uint64_t v34 = v47;
    uint64_t v16 = *((void *)a1 + 8);
    long long v17 = a1[1];
    long long v37 = *a1;
    long long v38 = v17;
    long long v18 = a1[3];
    long long v39 = a1[2];
    long long v40 = v18;
    *(void *)&long long v41 = v16;
    uint64_t v19 = *((void *)&v43 + 1);
    uint64_t v20 = v44;
    __swift_project_boxed_opaque_existential_0Tm(v35, *((uint64_t *)&v43 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v29, v19, v20);
    uint64_t v21 = v30;
    uint64_t v22 = v31;
    __swift_project_boxed_opaque_existential_0Tm(v29, v30);
    (*(void (**)(long long *, uint64_t, uint64_t))(v22 + 32))(&v37, v21, v22);
    __swift_destroy_boxed_opaque_existential_1Tm(v29);
    outlined destroy of AnyHashable((uint64_t *)v35);
    uint64_t v23 = *((void *)&v33 + 1);
    uint64_t v24 = v34;
    __swift_project_boxed_opaque_existential_0Tm(&v32, *((uint64_t *)&v33 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v24 + 8))(v29, v23, v24);
    uint64_t v25 = v30;
    uint64_t v26 = v31;
    __swift_project_boxed_opaque_existential_0Tm(v29, v30);
    (*(void (**)(long long *, uint64_t, uint64_t))(v26 + 32))(&v37, v25, v26);
    __swift_destroy_boxed_opaque_existential_1Tm(v29);
    outlined destroy of AnyHashable((uint64_t *)&v32);
    v7 ^= Hasher._finalize()();
    if (v6) {
      goto LABEL_4;
    }
LABEL_6:
    int64_t v12 = v8 + 1;
    if (__OFADD__(v8, 1))
    {
      __break(1u);
      goto LABEL_27;
    }
    if (v12 < v28)
    {
      unint64_t v13 = *(void *)(v27 + 8 * v12);
      if (v13) {
        goto LABEL_9;
      }
      int64_t v14 = v8 + 2;
      ++v8;
      if (v12 + 1 < v28)
      {
        unint64_t v13 = *(void *)(v27 + 8 * v14);
        if (v13)
        {
          ++v12;
LABEL_9:
          unint64_t v6 = (v13 - 1) & v13;
          unint64_t v10 = __clz(__rbit64(v13)) + (v12 << 6);
          int64_t v8 = v12;
          goto LABEL_5;
        }
        int64_t v15 = v12 + 2;
        int64_t v8 = v12 + 1;
        if (v12 + 2 < v28) {
          break;
        }
      }
    }
LABEL_21:
    unint64_t v6 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
  }
  unint64_t v13 = *(void *)(v27 + 8 * v15);
  if (v13)
  {
    v12 += 2;
    goto LABEL_9;
  }
  while (1)
  {
    int64_t v12 = v15 + 1;
    if (__OFADD__(v15, 1)) {
      break;
    }
    if (v12 >= v28)
    {
      int64_t v8 = v28 - 1;
      goto LABEL_21;
    }
    unint64_t v13 = *(void *)(v27 + 8 * v12);
    ++v15;
    if (v13) {
      goto LABEL_9;
    }
  }
LABEL_27:
  __break(1u);
}

void Dictionary<>.hash(into:)(uint64_t a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v120 = a5;
  uint64_t v121 = a6;
  unint64_t v6 = (uint64_t *)a4;
  Swift::UInt v7 = (uint64_t *)a3;
  unint64_t v10 = type metadata accessor for Optional(0, a4, a3, a4);
  Swift::UInt v131 = (Swift::UInt)*(v10 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  unint64_t v13 = (char *)&v84 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  int64_t v15 = (char *)&v84 - v14;
  unint64_t v93 = type metadata accessor for Optional(0, (uint64_t)v7, v16, v17);
  uint64_t v18 = (uint64_t)*(v93 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v93);
  uint64_t v111 = (char *)&v84 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  unint64_t v119 = (char *)&v84 - v22;
  uint64_t v110 = *(v6 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  int64_t v127 = (char *)&v84 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v109 = *(v7 - 1);
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v84 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, (uint64_t)v7, (uint64_t)v6, "key value ", 0);
  unint64_t v118 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v28, v29);
  uint64_t v30 = MEMORY[0x1F4188790](v118);
  int64_t v124 = (char *)&v84 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v30);
  uint64_t v123 = (char *)&v84 - v33;
  uint64_t v96 = v10;
  unint64_t v95 = v13;
  uint64_t v94 = v15;
  if ((a2 & 0xC000000000000001) != 0)
  {
    if (a2 < 0) {
      uint64_t v34 = a2;
    }
    else {
      uint64_t v34 = a2 & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v35 = v32;
    uint64_t v36 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v37 = (unint64_t)swift_allocObject(v36, 0xE8uLL, 7uLL);
    uint64_t v32 = v35;
    int64_t v100 = 0;
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    *(void *)(v37 + 208) = v34;
    *(void *)(v37 + 216) = 0;
    *(_OWORD *)(v37 + 16) = 0u;
    *(_OWORD *)(v37 + 32) = 0u;
    *(_OWORD *)(v37 + 48) = 0u;
    *(_OWORD *)(v37 + 64) = 0u;
    *(_OWORD *)(v37 + 80) = 0u;
    *(_OWORD *)(v37 + 96) = 0u;
    *(_OWORD *)(v37 + 112) = 0u;
    *(_OWORD *)(v37 + 128) = 0u;
    *(_OWORD *)(v37 + 144) = 0u;
    *(_OWORD *)(v37 + 160) = 0u;
    *(_OWORD *)(v37 + 176) = 0u;
    *(_OWORD *)(v37 + 192) = 0u;
    *(void *)(v37 + 224) = 0;
    unint64_t v40 = v37 | 0x8000000000000000;
  }
  else
  {
    uint64_t v41 = -1 << *(unsigned char *)(a2 + 32);
    uint64_t v38 = ~v41;
    uint64_t v42 = *(void *)(a2 + 64);
    int64_t v100 = a2 + 64;
    uint64_t v43 = -v41;
    if (v43 < 64) {
      uint64_t v44 = ~(-1 << v43);
    }
    else {
      uint64_t v44 = -1;
    }
    unint64_t v39 = v44 & v42;
    unint64_t v40 = a2;
  }
  uint64_t v101 = v40 & 0x7FFFFFFFFFFFFFFFLL;
  unint64_t v92 = (void (**)(void *, uint64_t, uint64_t, uint64_t *))(v109 + 56);
  char v91 = (void (**)(char *, void *, Class *))(v18 + 16);
  unint64_t v90 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v109 + 48);
  uint64_t v89 = (void (**)(void *, Class *))(v18 + 8);
  uint64_t v129 = (void (**)(char *, char *, uint64_t *))(v109 + 32);
  uint64_t v88 = (void (**)(void *, uint64_t, uint64_t, uint64_t *))(v110 + 56);
  uint64_t v87 = (void (**)(char *, void *, Class *))(v131 + 16);
  int64_t v86 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v110 + 48);
  uint64_t v85 = (void (**)(void *, Class *))(v131 + 8);
  unint64_t v128 = (void (**)(char *, char *, uint64_t *))(v110 + 32);
  uint64_t v116 = TupleTypeMetadata2 - 1;
  uint64_t v98 = v38;
  uint64_t v104 = v109 + 16;
  uint64_t v103 = v110 + 16;
  uint64_t v117 = (void (**)(char *, char *, Class *))(v32 + 32);
  uint64_t v115 = v120 + 24;
  uint64_t v114 = (void (**)(char *, uint64_t *))(v109 + 8);
  uint64_t v113 = v121 + 24;
  uint64_t v112 = (void (**)(char *, uint64_t *))(v110 + 8);
  int64_t v102 = (unint64_t)(v38 + 64) >> 6;
  int64_t v97 = v102 - 1;
  swift_bridgeObjectRetain(a2);
  Swift::UInt v45 = 0;
  int64_t v46 = 0;
  char v99 = qword_1ECA06328;
  uint64_t v47 = v111;
  uint64_t v48 = v119;
  unint64_t v108 = v6;
  unint64_t v107 = v7;
  uint64_t v106 = a1;
  unint64_t v105 = TupleTypeMetadata2;
  for (i = v40; ; unint64_t v40 = i)
  {
    int64_t v125 = v46;
    unint64_t v126 = v39;
    Swift::UInt v131 = v45;
    if ((v40 & 0x8000000000000000) != 0)
    {
      uint64_t v63 = (swift *)__CocoaDictionary.Iterator.next()();
      if (!v63)
      {
        uint64_t v61 = *(TupleTypeMetadata2 - 1);
        uint64_t v58 = v124;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v61 + 56))(v124, 1, 1, TupleTypeMetadata2);
        int64_t v62 = v125;
        uint64_t v130 = v126;
        goto LABEL_26;
      }
      int64_t v65 = v63;
      uint64_t v66 = v64;
      BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v7, v7);
      uint64_t v58 = v124;
      if (isClassOrObjCExistentialType)
      {
        *(void *)&v132[0] = v65;
        swift_dynamicCast(v124, (unint64_t *)v132, v99, (const char *)v7, 7uLL);
      }
      else
      {
        (*v92)(v48, 1, 1, v7);
        _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v65, (uint64_t)v7, v48);
        swift_unknownObjectRelease(v65);
        uint64_t v79 = v93;
        (*v91)(v47, v48, v93);
        if ((*v90)(v47, 1, v7) == 1) {
          goto LABEL_45;
        }
        (*v89)(v48, v79);
        (*v129)(v58, v47, v7);
      }
      uint64_t v68 = &v58[*((int *)TupleTypeMetadata2 + 12)];
      BOOL v69 = _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
      uint64_t v70 = v123;
      if (v69)
      {
        *(void *)&v132[0] = v66;
        swift_dynamicCast(v68, (unint64_t *)v132, qword_1ECA06328, (const char *)v6, 7uLL);
      }
      else
      {
        uint64_t v80 = v66;
        uint64_t v81 = v94;
        (*v88)(v94, 1, 1, v6);
        _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v80, (uint64_t)v6, v81);
        swift_unknownObjectRelease(v80);
        unint64_t v82 = v95;
        uint64_t v83 = v96;
        (*v87)(v95, v81, v96);
        if ((*v86)(v82, 1, v6) == 1) {
          goto LABEL_45;
        }
        (*v85)(v81, v83);
        (*v128)(v68, v82, v6);
        uint64_t v47 = v111;
        uint64_t v70 = v123;
      }
      uint64_t v61 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, void, uint64_t, uint64_t *))(v61 + 56))(v58, 0, 1, TupleTypeMetadata2);
      int64_t v62 = v125;
      uint64_t v130 = v126;
    }
    else
    {
      if (v39)
      {
        uint64_t v130 = (v39 - 1) & v39;
        unint64_t v49 = __clz(__rbit64(v39)) | (v46 << 6);
        int64_t v50 = v46;
        goto LABEL_14;
      }
      int64_t v50 = v46 + 1;
      uint64_t v58 = v124;
      if (__OFADD__(v46, 1))
      {
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
      }
      int64_t v62 = v46;
      uint64_t v70 = v123;
      if (v50 < v102)
      {
        unint64_t v71 = *(void *)(v100 + 8 * v50);
        if (v71) {
          goto LABEL_24;
        }
        int64_t v78 = v46 + 2;
        int64_t v62 = v46 + 1;
        if (v46 + 2 < v102)
        {
          unint64_t v71 = *(void *)(v100 + 8 * v78);
          if (v71)
          {
            int64_t v50 = v46 + 2;
LABEL_24:
            uint64_t v130 = (v71 - 1) & v71;
            unint64_t v49 = __clz(__rbit64(v71)) + (v50 << 6);
            unint64_t v40 = i;
LABEL_14:
            uint64_t v51 = v109;
            int64_t v52 = v26;
            uint64_t v53 = v26;
            int64_t v54 = v107;
            (*(void (**)(char *, unint64_t, uint64_t *))(v109 + 16))(v52, *(void *)(v40 + 48) + *(void *)(v109 + 72) * v49, v107);
            uint64_t v55 = *(void *)(v40 + 56);
            uint64_t v56 = v110;
            int64_t v57 = v127;
            unint64_t v6 = v108;
            (*(void (**)(char *, unint64_t, uint64_t *))(v110 + 16))(v127, v55 + *(void *)(v110 + 72) * v49, v108);
            TupleTypeMetadata2 = v105;
            uint64_t v58 = v124;
            uint64_t v59 = &v124[*((int *)v105 + 12)];
            uint64_t v60 = *(void (**)(char *, char *, uint64_t *))(v51 + 32);
            Swift::UInt v7 = v54;
            uint64_t v26 = v53;
            v60(v124, v53, v7);
            (*(void (**)(char *, char *, uint64_t *))(v56 + 32))(v59, v57, v6);
            uint64_t v61 = *(TupleTypeMetadata2 - 1);
            (*(void (**)(char *, void, uint64_t, uint64_t *))(v61 + 56))(v58, 0, 1, TupleTypeMetadata2);
            int64_t v62 = v50;
            uint64_t v47 = v111;
            a1 = v106;
LABEL_26:
            uint64_t v70 = v123;
            goto LABEL_27;
          }
          while (1)
          {
            int64_t v50 = v78 + 1;
            if (__OFADD__(v78, 1)) {
              goto LABEL_44;
            }
            if (v50 >= v102) {
              break;
            }
            unint64_t v71 = *(void *)(v100 + 8 * v50);
            ++v78;
            if (v71) {
              goto LABEL_24;
            }
          }
          int64_t v62 = v97;
        }
      }
      uint64_t v61 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v61 + 56))(v124, 1, 1, TupleTypeMetadata2);
      uint64_t v130 = 0;
      uint64_t v47 = v111;
    }
LABEL_27:
    (*v117)(v70, v58, v118);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v61 + 48))(v70, 1, TupleTypeMetadata2) == 1) {
      break;
    }
    uint64_t v72 = &v70[*((int *)TupleTypeMetadata2 + 12)];
    (*v129)(v26, v70, v7);
    uint64_t v73 = v127;
    (*v128)(v127, v72, v6);
    uint64_t v74 = *(void *)(a1 + 64);
    long long v75 = *(_OWORD *)(a1 + 16);
    v132[0] = *(_OWORD *)a1;
    v132[1] = v75;
    long long v76 = *(_OWORD *)(a1 + 48);
    v132[2] = *(_OWORD *)(a1 + 32);
    v132[3] = v76;
    uint64_t v133 = v74;
    (*(void (**)(_OWORD *, uint64_t *))(v120 + 24))(v132, v7);
    (*v114)(v26, v7);
    (*(void (**)(_OWORD *, uint64_t *))(v121 + 24))(v132, v6);
    (*v112)(v73, v6);
    Swift::Int v77 = Hasher._finalize()();
    unint64_t v39 = v130;
    Swift::UInt v45 = v77 ^ v131;
    int64_t v46 = v62;
    uint64_t v48 = v119;
  }
  outlined consume of [A : B].Iterator._Variant<A, B>(i);
  Hasher._combine(_:)(v131);
}

void *static Int.^= infix(_:_:)(void *result, uint64_t a2)
{
  *result ^= a2;
  return result;
}

Swift::Int Dictionary<>.hashValue.getter(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  Dictionary<>.hash(into:)((uint64_t)v6, a1, a2, a3, a4, a5);
  return Hasher._finalize()();
}

Class *Dictionary<>._toCustomAnyHashable()@<X0>(int64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int64_t *a6@<X8>)
{
  uint64_t v12 = specialized _dictionaryUpCast<A, B, C, D>(_:)(a1, a2, a3);
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a4;
  _OWORD v14[3] = a5;
  uint64_t result = type metadata accessor for _DictionaryAnyHashableBox(0, (uint64_t)v14);
  a6[3] = (int64_t)result;
  a6[4] = (int64_t)&protocol witness table for _DictionaryAnyHashableBox<A, B>;
  *a6 = a1;
  a6[1] = (int64_t)v12;
  return result;
}

void specialized _dictionaryUpCast<A, B, C, D>(_:)(unint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    uint64_t v2 = (atomic_ullong *)specialized static _DictionaryStorage.allocate(capacity:)(v1);
  }
  else {
    uint64_t v2 = (atomic_ullong *)&_swiftEmptyDictionarySingleton;
  }
  unint64_t v27 = a1 + 64;
  uint64_t v3 = -1;
  uint64_t v4 = -1 << *(unsigned char *)(a1 + 32);
  if (-v4 < 64) {
    uint64_t v3 = ~(-1 << -(char)v4);
  }
  unint64_t v5 = v3 & *(void *)(a1 + 64);
  int64_t v24 = (unint64_t)(63 - v4) >> 6;
  swift_retain(v2);
  swift_bridgeObjectRetain(a1);
  int64_t v6 = 0;
  uint64_t v25 = v2;
  if (!v5) {
    goto LABEL_8;
  }
LABEL_7:
  uint64_t v28 = (v5 - 1) & v5;
  int64_t v29 = v6;
  for (unint64_t i = __clz(__rbit64(v5)) | (v6 << 6); ; unint64_t i = __clz(__rbit64(v9)) + (v10 << 6))
  {
    uint64_t v12 = 40 * i;
    outlined init with copy of AnyHashable(*(void *)(a1 + 48) + 40 * i, (uint64_t)&v35);
    outlined init with copy of AnyHashable(*(void *)(a1 + 56) + v12, (uint64_t)&v30);
    long long v13 = v35;
    uint64_t v14 = v36;
    uint64_t v15 = v37;
    uint64_t v16 = v38;
    uint64_t v17 = v30;
    uint64_t v18 = v31;
    uint64_t v20 = v32;
    uint64_t v19 = v33;
    uint64_t v21 = v34;
    uint64_t v22 = swift_retain((atomic_ullong *)a1);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v22);
    uint64_t v2 = v25;
    if (!v15) {
      goto LABEL_24;
    }
    long long v35 = v13;
    uint64_t v36 = v14;
    uint64_t v37 = v15;
    uint64_t v38 = v16;
    uint64_t v30 = v17;
    uint64_t v31 = v18;
    uint64_t v32 = v20;
    uint64_t v33 = v19;
    uint64_t v34 = v21;
    specialized _NativeDictionary._unsafeInsertNew(key:value:)(&v35, (uint64_t)&v30, v25);
    unint64_t v5 = v28;
    int64_t v6 = v29;
    if (v28) {
      goto LABEL_7;
    }
LABEL_8:
    int64_t v8 = v6 + 1;
    if (__OFADD__(v6, 1))
    {
      __break(1u);
      goto LABEL_26;
    }
    if (v8 >= v24) {
      goto LABEL_23;
    }
    unint64_t v9 = *(void *)(v27 + 8 * v8);
    int64_t v10 = v6 + 1;
    if (!v9)
    {
      int64_t v10 = v6 + 2;
      if (v6 + 2 >= v24) {
        goto LABEL_23;
      }
      unint64_t v9 = *(void *)(v27 + 8 * v10);
      if (!v9) {
        break;
      }
    }
LABEL_19:
    uint64_t v28 = (v9 - 1) & v9;
    int64_t v29 = v10;
  }
  uint64_t v11 = v6 + 3;
  if (v6 + 3 >= v24)
  {
LABEL_23:
    uint64_t v23 = swift_retain((atomic_ullong *)a1);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v23);
LABEL_24:
    swift_release(a1);
    swift_release((uint64_t)v2);
    return;
  }
  unint64_t v9 = *(void *)(v27 + 8 * v11);
  if (v9)
  {
    int64_t v10 = v6 + 3;
    goto LABEL_19;
  }
  while (1)
  {
    int64_t v10 = v11 + 1;
    if (__OFADD__(v11, 1)) {
      break;
    }
    if (v10 >= v24) {
      goto LABEL_23;
    }
    unint64_t v9 = *(void *)(v27 + 8 * v10);
    ++v11;
    if (v9) {
      goto LABEL_19;
    }
  }
LABEL_26:
  __break(1u);
}

atomic_ullong *specialized _dictionaryUpCast<A, B, C, D>(_:)(int64_t a1, char *a2, uint64_t a3)
{
  uint64_t v3 = (char *)a3;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)a2, a3, "key value ", 0);
  int64_t v125 = (char *)*(TupleTypeMetadata2 - 1);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  Swift::UInt v131 = (char *)&v94 - v7;
  uint64_t v106 = type metadata accessor for Optional(0, (uint64_t)v3, v8, v9);
  unint64_t v128 = (void (**)(char *, void, uint64_t, uint64_t *))*(v106 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v106);
  uint64_t v12 = (char *)&v94 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v94 - v13;
  uint64_t v103 = type metadata accessor for Optional(0, (uint64_t)a2, v15, v16);
  uint64_t v17 = (uint64_t)*(v103 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v103);
  int64_t v102 = (char *)&v94 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v114 = (char *)&v94 - v21;
  uint64_t v119 = *((void *)v3 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  int64_t v24 = (unint64_t *)((char *)&v94 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v118 = *((void *)a2 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v94 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v29 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v27, v28);
  MEMORY[0x1F4188790](v29 - 1);
  uint64_t v130 = (char *)&v94 - v30;
  if ((a1 & 0xC000000000000001) != 0)
  {
    if (a1 < 0) {
      uint64_t v31 = (void *)a1;
    }
    else {
      uint64_t v31 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
    }
    id v32 = [v31 count];
    if (v32) {
      goto LABEL_6;
    }
LABEL_8:
    uint64_t v129 = (atomic_ullong *)&_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  id v32 = *(id *)(a1 + 16);
  if (!v32) {
    goto LABEL_8;
  }
LABEL_6:
  uint64_t v129 = (atomic_ullong *)specialized static _DictionaryStorage.allocate(capacity:)((uint64_t)v32);
LABEL_9:
  unint64_t v105 = v12;
  uint64_t v104 = v14;
  if ((a1 & 0xC000000000000001) != 0)
  {
    if (a1 < 0) {
      uint64_t v33 = a1;
    }
    else {
      uint64_t v33 = a1 & 0xFFFFFFFFFFFFFF8;
    }
    uint64_t v34 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v35 = (unint64_t)swift_allocObject(v34, 0xE8uLL, 7uLL);
    int64_t v111 = 0;
    uint64_t v36 = 0;
    *(void *)(v35 + 208) = v33;
    *(void *)(v35 + 216) = 0;
    unint64_t v37 = 0;
    *(_OWORD *)(v35 + 16) = 0u;
    *(_OWORD *)(v35 + 32) = 0u;
    *(_OWORD *)(v35 + 48) = 0u;
    *(_OWORD *)(v35 + 64) = 0u;
    *(_OWORD *)(v35 + 80) = 0u;
    *(_OWORD *)(v35 + 96) = 0u;
    *(_OWORD *)(v35 + 112) = 0u;
    *(_OWORD *)(v35 + 128) = 0u;
    *(_OWORD *)(v35 + 144) = 0u;
    *(_OWORD *)(v35 + 160) = 0u;
    *(_OWORD *)(v35 + 176) = 0u;
    *(_OWORD *)(v35 + 192) = 0u;
    *(void *)(v35 + 224) = 0;
    unint64_t v38 = a1;
    a1 = v35 | 0x8000000000000000;
  }
  else
  {
    uint64_t v39 = -1 << *(unsigned char *)(a1 + 32);
    uint64_t v36 = ~v39;
    uint64_t v40 = *(void *)(a1 + 64);
    int64_t v111 = a1 + 64;
    uint64_t v41 = -v39;
    if (v41 < 64) {
      uint64_t v42 = ~(-1 << v41);
    }
    else {
      uint64_t v42 = -1;
    }
    unint64_t v37 = v42 & v40;
    unint64_t v38 = a1;
  }
  uint64_t v109 = (a1 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v115 = a1 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v108 = (a1 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v101 = (void (**)(void *, uint64_t, uint64_t, char *))(v118 + 56);
  int64_t v100 = (void (**)(char *, void *, Class *))(v17 + 16);
  char v99 = (unsigned int (**)(char *, uint64_t, char *))(v118 + 48);
  uint64_t v98 = (void (**)(void *, Class *))(v17 + 8);
  unint64_t v126 = (void (**)(char *, char *, char *))(v118 + 32);
  int64_t v97 = (void (**)(void *, uint64_t, uint64_t, char *))(v119 + 56);
  uint64_t v96 = (void (**)(char *, void *, Class *))(v128 + 2);
  unint64_t v95 = (unsigned int (**)(char *, uint64_t, char *))(v119 + 48);
  uint64_t v94 = (void (**)(void *, Class *))(v128 + 1);
  int64_t v127 = (void (**)(char *, char *, char *))(v119 + 32);
  unint64_t v128 = (void (**)(char *, void, uint64_t, uint64_t *))(v125 + 56);
  uint64_t v107 = v36;
  int64_t v110 = (unint64_t)(v36 + 64) >> 6;
  uint64_t v117 = v118 + 16;
  uint64_t v116 = v119 + 16;
  uint64_t v123 = (void (**)(char *, char *, uint64_t *))(v125 + 32);
  unint64_t v122 = &v137;
  uint64_t v121 = &v140;
  swift_retain(v129);
  swift_bridgeObjectRetain(v38);
  int64_t v120 = 0;
  uint64_t v112 = qword_1ECA06328;
  int64_t v125 = v26;
  int64_t v124 = a1;
  uint64_t v43 = v131;
  uint64_t v44 = v24;
  uint64_t v113 = v24;
  while (1)
  {
    if ((a1 & 0x8000000000000000) == 0)
    {
      if (v37)
      {
        Swift::UInt v45 = v43;
        Swift::UInt v131 = (char *)((v37 - 1) & v37);
        unint64_t v46 = __clz(__rbit64(v37)) | (v120 << 6);
      }
      else
      {
        int64_t v69 = v120 + 1;
        uint64_t v70 = v130;
        if (__OFADD__(v120, 1))
        {
          __break(1u);
LABEL_59:
          unint64_t v93 = 773;
LABEL_61:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v93, 0);
        }
        if (v69 >= v110) {
          goto LABEL_54;
        }
        unint64_t v71 = *(void *)(v111 + 8 * v69);
        if (!v71)
        {
          int64_t v72 = v120 + 2;
          if (v120 + 2 >= v110) {
            goto LABEL_54;
          }
          unint64_t v71 = *(void *)(v111 + 8 * v72);
          if (!v71)
          {
            while (1)
            {
              int64_t v69 = v72 + 1;
              if (__OFADD__(v72, 1)) {
                break;
              }
              if (v69 >= v110) {
                goto LABEL_54;
              }
              unint64_t v71 = *(void *)(v111 + 8 * v69);
              ++v72;
              if (v71) {
                goto LABEL_33;
              }
            }
            __break(1u);
LABEL_56:
            __break(1u);
LABEL_57:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
          }
          int64_t v69 = v120 + 2;
        }
LABEL_33:
        Swift::UInt v45 = v43;
        Swift::UInt v131 = (char *)((v71 - 1) & v71);
        unint64_t v46 = __clz(__rbit64(v71)) + (v69 << 6);
        int64_t v120 = v69;
      }
      uint64_t v47 = v118;
      uint64_t v48 = (unint64_t *)v125;
      (*(void (**)(char *, unint64_t, char *))(v118 + 16))(v125, *(void *)(a1 + 48) + *(void *)(v118 + 72) * v46, a2);
      uint64_t v49 = v119;
      (*(void (**)(unint64_t *, unint64_t, char *))(v119 + 16))(v44, *(void *)(a1 + 56) + *(void *)(v119 + 72) * v46, v3);
      int64_t v50 = v130;
      uint64_t v51 = v3;
      int64_t v52 = &v130[*((int *)TupleTypeMetadata2 + 12)];
      uint64_t v53 = *(void (**)(char *, unint64_t *, char *))(v47 + 32);
      int64_t v54 = v48;
      uint64_t v55 = v48;
      uint64_t v56 = (void (**)(unint64_t *, char *, char *))v126;
      v53(v130, v55, a2);
      int64_t v57 = v52;
      uint64_t v3 = v51;
      uint64_t v58 = v51;
      uint64_t v59 = v127;
      (*(void (**)(char *, unint64_t *, char *))(v49 + 32))(v57, v44, v58);
      (*v128)(v50, 0, 1, TupleTypeMetadata2);
      uint64_t v43 = v45;
      goto LABEL_21;
    }
    uint64_t v73 = v115;
    uint64_t v74 = *(void *)(v115 + 216);
    if (v74 < 0)
    {
      uint64_t v70 = v130;
      goto LABEL_54;
    }
    Swift::UInt v131 = (char *)v37;
    long long v75 = *(void **)(v115 + 208);
    if (v74 == *(void *)(v115 + 224)) {
      break;
    }
LABEL_38:
    uint64_t v77 = *(void *)(v73 + 24);
    if (!v77) {
      goto LABEL_59;
    }
    uint64_t v59 = v127;
    if ((unint64_t)(v74 - 0x1000000000000000) >> 61 != 7) {
      goto LABEL_56;
    }
    int64_t v78 = (void **)(v77 + 8 * v74);
    if ((v78 & 7) != 0) {
      goto LABEL_57;
    }
    uint64_t v79 = v114;
    uint64_t v80 = TupleTypeMetadata2;
    uint64_t v81 = *v78;
    *(void *)(v73 + 216) = v74 + 1;
    swift_unknownObjectRetain(v81);
    unint64_t v82 = (swift *)[v75 objectForKey:v81];
    if (!v82)
    {
      unint64_t v93 = 784;
      goto LABEL_61;
    }
    uint64_t v83 = v82;
    if (_swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2))
    {
      *(void *)&v138[0] = v81;
      uint64_t v84 = v130;
      swift_dynamicCast(v130, (unint64_t *)v138, v112, a2, 7uLL);
    }
    else
    {
      (*v101)(v79, 1, 1, a2);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v81, (uint64_t)a2, v79);
      swift_unknownObjectRelease(v81);
      int64_t v86 = v102;
      uint64_t v87 = v103;
      (*v100)(v102, v79, v103);
      if ((*v99)(v86, 1, a2) == 1) {
        goto LABEL_62;
      }
      (*v98)(v79, v87);
      uint64_t v84 = v130;
      (*v126)(v130, v86, a2);
    }
    uint64_t v85 = &v84[*((int *)v80 + 12)];
    if (_swift_isClassOrObjCExistentialType((uint64_t)v3, (uint64_t *)v3))
    {
      *(void *)&v138[0] = v83;
      swift_dynamicCast(v85, (unint64_t *)v138, qword_1ECA06328, v3, 7uLL);
    }
    else
    {
      uint64_t v88 = v104;
      (*v97)(v104, 1, 1, v3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v83, (uint64_t)v3, v88);
      swift_unknownObjectRelease(v83);
      uint64_t v89 = v105;
      unint64_t v90 = v106;
      (*v96)(v105, v88, v106);
      if ((*v95)(v89, 1, v3) == 1) {
LABEL_62:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
      (*v94)(v88, v90);
      (*v59)(v85, v89, v3);
    }
    int64_t v50 = v130;
    TupleTypeMetadata2 = v80;
    (*v128)(v130, 0, 1, v80);
    uint64_t v44 = v113;
    int64_t v54 = (unint64_t *)v125;
    uint64_t v56 = (void (**)(unint64_t *, char *, char *))v126;
LABEL_21:
    (*v123)(v43, v50, TupleTypeMetadata2);
    uint64_t v60 = &v43[*((int *)TupleTypeMetadata2 + 12)];
    (*v56)(v54, v43, a2);
    swift_dynamicCast((char *)&v134, v54, (Class *)a2, (const char *)&type metadata for AnyHashable, 7uLL);
    (*v59)((char *)v44, v60, v3);
    uint64_t v61 = v122;
    swift_dynamicCast(v122, v44, (Class *)v3, (const char *)&type metadata for AnyHashable, 7uLL);
    uint64_t v62 = v136;
    uint64_t v139 = v136;
    long long v64 = v134;
    long long v63 = v135;
    v138[0] = v134;
    v138[1] = v135;
    long long v65 = *((_OWORD *)v61 + 1);
    uint64_t v66 = v121;
    *(_OWORD *)uint64_t v121 = *(_OWORD *)v61;
    *((_OWORD *)v66 + 1) = v65;
    uint64_t v67 = *((void *)v61 + 4);
    *((void *)v66 + 4) = v67;
    long long v134 = v64;
    long long v135 = v63;
    uint64_t v136 = v62;
    long long v68 = *((_OWORD *)v66 + 1);
    v132[0] = *(_OWORD *)v66;
    v132[1] = v68;
    uint64_t v133 = v67;
    specialized _NativeDictionary._unsafeInsertNew(key:value:)(&v134, (uint64_t)v132, v129);
    a1 = v124;
    unint64_t v37 = (unint64_t)v131;
  }
  id v76 = [*(id *)(v115 + 208) countByEnumeratingWithState:v109 objects:v108 count:16];
  uint64_t v73 = v115;
  *(void *)(v115 + 224) = v76;
  if (v76)
  {
    uint64_t v74 = 0;
    *(void *)(v73 + 216) = 0;
    goto LABEL_38;
  }
  *(void *)(v73 + 216) = -1;
  uint64_t v70 = v130;
LABEL_54:
  (*v128)(v70, 1, 1, TupleTypeMetadata2);
  char v91 = v129;
  swift_release((uint64_t)v129);
  outlined consume of [A : B].Iterator._Variant<A, B>(a1);
  return v91;
}

unint64_t specialized _dictionaryUpCast<A, B, C, D>(_:)(unint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    uint64_t v2 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v1);
  }
  else {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
  }
  unint64_t v36 = a1 + 64;
  uint64_t v3 = -1;
  uint64_t v4 = -1 << *(unsigned char *)(a1 + 32);
  uint64_t v34 = v2;
  if (-v4 < 64) {
    uint64_t v3 = ~(-1 << -(char)v4);
  }
  unint64_t v5 = v3 & *(void *)(a1 + 64);
  id v32 = v2 + 8;
  int64_t v33 = (unint64_t)(63 - v4) >> 6;
  unint64_t result = swift_bridgeObjectRetain(a1);
  for (int64_t i = 0; ; int64_t i = v38)
  {
    if (v5)
    {
      uint64_t v37 = (v5 - 1) & v5;
      int64_t v38 = i;
      unint64_t v11 = __clz(__rbit64(v5)) | (i << 6);
    }
    else
    {
      int64_t v12 = i + 1;
      if (__OFADD__(i, 1)) {
        goto LABEL_34;
      }
      if (v12 >= v33)
      {
LABEL_30:
        uint64_t v31 = swift_retain((atomic_ullong *)a1);
        outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v31);
LABEL_31:
        swift_release(a1);
        return (unint64_t)v34;
      }
      unint64_t v13 = *(void *)(v36 + 8 * v12);
      int64_t v14 = i + 1;
      if (!v13)
      {
        int64_t v14 = i + 2;
        if (i + 2 >= v33) {
          goto LABEL_30;
        }
        unint64_t v13 = *(void *)(v36 + 8 * v14);
        if (!v13)
        {
          int64_t v14 = i + 3;
          if (i + 3 >= v33) {
            goto LABEL_30;
          }
          unint64_t v13 = *(void *)(v36 + 8 * v14);
          if (!v13)
          {
            uint64_t v15 = i + 4;
            if (i + 4 >= v33) {
              goto LABEL_30;
            }
            unint64_t v13 = *(void *)(v36 + 8 * v15);
            if (!v13)
            {
              while (1)
              {
                int64_t v14 = v15 + 1;
                if (__OFADD__(v15, 1)) {
                  goto LABEL_35;
                }
                if (v14 >= v33) {
                  goto LABEL_30;
                }
                unint64_t v13 = *(void *)(v36 + 8 * v14);
                ++v15;
                if (v13) {
                  goto LABEL_24;
                }
              }
            }
            int64_t v14 = i + 4;
          }
        }
      }
LABEL_24:
      uint64_t v37 = (v13 - 1) & v13;
      int64_t v38 = v14;
      unint64_t v11 = __clz(__rbit64(v13)) + (v14 << 6);
    }
    uint64_t v16 = (unint64_t *)(*(void *)(a1 + 48) + 16 * v11);
    unint64_t v17 = *v16;
    unint64_t v18 = v16[1];
    outlined init with copy of AnyHashable(*(void *)(a1 + 56) + 40 * v11, (uint64_t)&v44);
    long long v19 = v44;
    long long v20 = v45;
    uint64_t v21 = v46;
    swift_retain((atomic_ullong *)a1);
    swift_bridgeObjectRetain(v18);
    outlined consume of [A : B].Iterator._Variant<A, B>(a1);
    if (!v18) {
      goto LABEL_31;
    }
    unint64_t v41 = v17;
    unint64_t v42 = v18;
    v39[0] = v19;
    v39[1] = v20;
    uint64_t v40 = v21;
    swift_dynamicCast((char *)v43, (unint64_t *)v39, (Class *)&type metadata for AnyHashable, (const char *)qword_1ECA06310, 7uLL);
    unint64_t v22 = v41;
    unint64_t v23 = v42;
    outlined init with take of Any(v43, &v45);
    outlined init with take of Any(&v45, v47);
    outlined init with take of Any(v47, &v44);
    unint64_t v24 = specialized __RawDictionaryStorage.find<A>(_:)(v22, v23);
    unint64_t v25 = v24;
    if (v26)
    {
      uint64_t v8 = (unint64_t *)((char *)v34[6] + 16 * v24);
      uint64_t v9 = v8[1];
      *uint64_t v8 = v22;
      v8[1] = v23;
      swift_bridgeObjectRelease(v9);
      uint64_t v10 = (uint64_t *)((char *)v34[7] + 32 * v25);
      __swift_destroy_boxed_opaque_existential_1Tm(v10);
      unint64_t result = (unint64_t)outlined init with take of Any(&v44, v10);
      goto LABEL_8;
    }
    if (v34[2] >= v34[3]) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/NativeDictionary.swift", 28, 2, 0x1FFuLL, 0);
    }
    *(__objc2_class **)((char *)v32 + ((v24 >> 3) & 0x1FFFFFFFFFFFFFF8)) = (__objc2_class *)(*(unint64_t *)((char *)v32 + ((v24 >> 3) & 0x1FFFFFFFFFFFFFF8)) | (1 << v24));
    uint64_t v27 = (unint64_t *)((char *)v34[6] + 16 * v24);
    *uint64_t v27 = v22;
    v27[1] = v23;
    unint64_t result = (unint64_t)outlined init with take of Any(&v44, (_OWORD *)v34[7] + 2 * v24);
    uint64_t v28 = v34[2];
    BOOL v29 = __OFADD__(v28, 1);
    uint64_t v30 = (__objc2_class *)((char *)&v28->isa + 1);
    if (v29) {
      break;
    }
    v34[2] = v30;
LABEL_8:
    unint64_t v5 = v37;
  }
  __break(1u);
LABEL_34:
  __break(1u);
LABEL_35:
  __break(1u);
  return result;
}

{
  uint64_t v1;
  atomic_ullong *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t result;
  int64_t v7;
  unint64_t i;
  int64_t v9;
  unint64_t v10;
  int64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  long long v16;
  long long v17;
  uint64_t v18;
  atomic_ullong *v19;
  int64_t v20;
  atomic_ullong *v21;
  unint64_t v23;
  uint64_t v24;
  int64_t v25;
  _OWORD v26[2];
  uint64_t v27;
  unint64_t v28[2];
  long long v29;
  long long v30;
  uint64_t v31;
  _OWORD v32[2];
  long long v33;
  long long v34;
  uint64_t v35;
  _OWORD v36[3];

  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    uint64_t v2 = (atomic_ullong *)specialized static _DictionaryStorage.allocate(capacity:)(v1);
  }
  else {
    uint64_t v2 = (atomic_ullong *)&_swiftEmptyDictionarySingleton;
  }
  unint64_t v23 = a1 + 64;
  uint64_t v3 = -1;
  uint64_t v4 = -1 << *(unsigned char *)(a1 + 32);
  if (-v4 < 64) {
    uint64_t v3 = ~(-1 << -(char)v4);
  }
  unint64_t v5 = v3 & *(void *)(a1 + 64);
  long long v20 = (unint64_t)(63 - v4) >> 6;
  swift_retain(v2);
  unint64_t result = swift_bridgeObjectRetain(a1);
  uint64_t v7 = 0;
  uint64_t v21 = v2;
  if (!v5) {
    goto LABEL_8;
  }
LABEL_7:
  unint64_t v24 = (v5 - 1) & v5;
  unint64_t v25 = v7;
  for (int64_t i = __clz(__rbit64(v5)) | (v7 << 6); ; int64_t i = __clz(__rbit64(v10)) + (v11 << 6))
  {
    unint64_t v13 = (unint64_t *)(*(void *)(a1 + 48) + 16 * i);
    uint64_t v15 = *v13;
    int64_t v14 = v13[1];
    outlined init with copy of AnyHashable(*(void *)(a1 + 56) + 40 * i, (uint64_t)&v33);
    uint64_t v16 = v33;
    unint64_t v17 = v34;
    unint64_t v18 = v35;
    swift_retain((atomic_ullong *)a1);
    swift_bridgeObjectRetain(v14);
    outlined consume of [A : B].Iterator._Variant<A, B>(a1);
    uint64_t v2 = v21;
    if (!v14) {
      goto LABEL_26;
    }
    v28[0] = v15;
    v28[1] = v14;
    swift_dynamicCast((char *)&v29, v28, (Class *)&type metadata for String, (const char *)&type metadata for AnyHashable, 7uLL);
    v26[0] = v16;
    v26[1] = v17;
    uint64_t v27 = v18;
    swift_dynamicCast((char *)v32, (unint64_t *)v26, (Class *)&type metadata for AnyHashable, (const char *)qword_1ECA06310, 7uLL);
    int64_t v33 = v29;
    uint64_t v34 = v30;
    unint64_t v35 = v31;
    outlined init with take of Any(v32, v36);
    BOOL v29 = v33;
    uint64_t v30 = v34;
    uint64_t v31 = v35;
    outlined init with take of Any(v36, v26);
    outlined init with take of Any(v26, &v33);
    unint64_t result = (unint64_t)specialized _NativeDictionary._unsafeInsertNew(key:value:)(&v29, &v33, v21);
    unint64_t v5 = v24;
    uint64_t v7 = v25;
    if (v24) {
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v9 = v7 + 1;
    if (__OFADD__(v7, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v9 >= v20) {
      goto LABEL_25;
    }
    uint64_t v10 = *(void *)(v23 + 8 * v9);
    unint64_t v11 = v7 + 1;
    if (!v10)
    {
      unint64_t v11 = v7 + 2;
      if (v7 + 2 >= v20) {
        goto LABEL_25;
      }
      uint64_t v10 = *(void *)(v23 + 8 * v11);
      if (!v10)
      {
        unint64_t v11 = v7 + 3;
        if (v7 + 3 >= v20) {
          goto LABEL_25;
        }
        uint64_t v10 = *(void *)(v23 + 8 * v11);
        if (!v10) {
          break;
        }
      }
    }
LABEL_21:
    unint64_t v24 = (v10 - 1) & v10;
    unint64_t v25 = v11;
  }
  int64_t v12 = v7 + 4;
  if (v7 + 4 >= v20)
  {
LABEL_25:
    long long v19 = swift_retain((atomic_ullong *)a1);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v19);
LABEL_26:
    swift_release(a1);
    swift_release((uint64_t)v2);
    return (unint64_t)v2;
  }
  uint64_t v10 = *(void *)(v23 + 8 * v12);
  if (v10)
  {
    unint64_t v11 = v7 + 4;
    goto LABEL_21;
  }
  while (1)
  {
    unint64_t v11 = v12 + 1;
    if (__OFADD__(v12, 1)) {
      break;
    }
    if (v11 >= v20) {
      goto LABEL_25;
    }
    uint64_t v10 = *(void *)(v23 + 8 * v11);
    ++v12;
    if (v10) {
      goto LABEL_21;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

__objc2_class **_dictionaryUpCast<A, B, C, D>(_:)(uint64_t a1, uint64_t *a2, char *a3, ValueMetadata *a4, const char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v262 = a7;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)a4, (uint64_t)a5, "key value ", 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  v257 = (char *)&v211 - v12;
  v256 = swift_getTupleTypeMetadata2(0, (uint64_t)a4, (uint64_t)a5, 0, 0);
  uint64_t v13 = MEMORY[0x1F4188790](v256);
  v255 = (char *)&v211 - v14;
  v265 = a5;
  uint64_t v241 = *((void *)a5 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v249 = (unint64_t)&v211 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v248 = (Class *)((char *)&v211 - v18);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v244 = (void (**)(void))((char *)&v211 - v20);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v243 = (Class *)((char *)&v211 - v22);
  Description = (char *)a4[-1].Description;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v247 = (void (**)(unint64_t *, char *, Class *))((char *)&v211 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v246 = (Class *)((char *)&v211 - v26);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v239 = (uint64_t)&v211 - v28;
  MEMORY[0x1F4188790](v27);
  v238 = (char *)&v211 - v29;
  uint64_t v30 = swift_getTupleTypeMetadata2(0, (uint64_t)a2, (uint64_t)a3, "key value ", 0);
  v234 = (Class *)*(v30 - 1);
  uint64_t v31 = MEMORY[0x1F4188790](v30);
  v245 = (char *)&v211 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v31);
  v237 = (char *)&v211 - v33;
  v225 = type metadata accessor for Optional(0, (uint64_t)a3, v34, v35);
  v254 = (void (**)(char *, char *, const char *))*(v225 - 1);
  uint64_t v36 = MEMORY[0x1F4188790](v225);
  v228 = (char *)&v211 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v40 = (char *)&v211 - v39;
  uint64_t v41 = MEMORY[0x1F4188790](v38);
  v223 = (void (**)(char *, uint64_t, uint64_t, const char *))((char *)&v211 - v42);
  MEMORY[0x1F4188790](v41);
  long long v44 = (char *)&v211 - v43;
  v226 = type metadata accessor for Optional(0, (uint64_t)a2, v45, v46);
  int64_t v232 = (int64_t)*(v226 - 1);
  uint64_t v47 = MEMORY[0x1F4188790](v226);
  v227 = (char *)&v211 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  v224 = (char *)&v211 - v50;
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  v222 = (char *)&v211 - v52;
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  v221 = (char *)&v211 - v54;
  uint64_t v252 = *((void *)a3 - 1);
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  v261 = (unint64_t *)((char *)&v211 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0));
  v268 = a2;
  uint64_t v251 = *(a2 - 1);
  MEMORY[0x1F4188790](v55);
  uint64_t v58 = (unint64_t *)((char *)&v211 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0));
  v264 = v30;
  uint64_t v61 = type metadata accessor for Optional(0, (uint64_t)v30, v59, v60);
  uint64_t v62 = MEMORY[0x1F4188790](v61 - 1);
  long long v64 = (char *)&v211 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v62);
  v250 = (Class *)((char *)&v211 - v65);
  unint64_t v66 = a1 & 0xC000000000000001;
  if ((a1 & 0xC000000000000001) != 0)
  {
    int64_t v67 = a1;
    if (a1 < 0) {
      long long v68 = (void *)a1;
    }
    else {
      long long v68 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
    }
    id v69 = [v68 count];
  }
  else
  {
    int64_t v67 = a1;
    id v69 = *(id *)(a1 + 16);
  }
  v263 = v64;
  if (v69)
  {
    type metadata accessor for _DictionaryStorage(0, (uint64_t)a4, (uint64_t)v265, v262);
    uint64_t v70 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v69);
  }
  else
  {
    uint64_t v70 = &_swiftEmptyDictionarySingleton;
  }
  v259 = v58;
  v260 = v70;
  v266 = a3;
  if (a4 == &type metadata for String)
  {
    v220 = v44;
    if (v66)
    {
      if (v67 < 0) {
        uint64_t v75 = v67;
      }
      else {
        uint64_t v75 = v67 & 0xFFFFFFFFFFFFFF8;
      }
      id v76 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v77 = (unint64_t)swift_allocObject(v76, 0xE8uLL, 7uLL);
      uint64_t v230 = 0;
      uint64_t v78 = 0;
      unint64_t v253 = 0;
      *(void *)(v77 + 208) = v75;
      *(void *)(v77 + 216) = 0;
      *(_OWORD *)(v77 + 16) = 0u;
      *(_OWORD *)(v77 + 32) = 0u;
      *(_OWORD *)(v77 + 48) = 0u;
      *(_OWORD *)(v77 + 64) = 0u;
      *(_OWORD *)(v77 + 80) = 0u;
      *(_OWORD *)(v77 + 96) = 0u;
      *(_OWORD *)(v77 + 112) = 0u;
      *(_OWORD *)(v77 + 128) = 0u;
      *(_OWORD *)(v77 + 144) = 0u;
      *(_OWORD *)(v77 + 160) = 0u;
      *(_OWORD *)(v77 + 176) = 0u;
      *(_OWORD *)(v77 + 192) = 0u;
      *(void *)(v77 + 224) = 0;
      unint64_t v79 = v77 | 0x8000000000000000;
    }
    else
    {
      uint64_t v145 = -1 << *(unsigned char *)(v67 + 32);
      uint64_t v78 = ~v145;
      uint64_t v146 = *(void *)(v67 + 64);
      uint64_t v230 = v67 + 64;
      uint64_t v147 = -v145;
      if (v147 < 64) {
        uint64_t v148 = ~(-1 << v147);
      }
      else {
        uint64_t v148 = -1;
      }
      unint64_t v253 = v148 & v146;
      unint64_t v79 = v67;
    }
    unint64_t v149 = (char *)v250;
    unint64_t v249 = v79;
    uint64_t v150 = v79 & 0x7FFFFFFFFFFFFFFFLL;
    v228 = (char *)(v150 + 16);
    v235 = (char *)v150;
    v227 = (char *)(v150 + 80);
    v219 = (void (**)(char *, uint64_t, uint64_t, const char *))(v251 + 56);
    v218 = (void (**)(char *, char *, Class *))(v232 + 16);
    v217 = (unsigned int (**)(char *, uint64_t, const char *))(v251 + 48);
    v216 = (void (**)(char *, Class *))(v232 + 8);
    v247 = (void (**)(unint64_t *, char *, Class *))(v251 + 32);
    v215 = (void (**)(void *, uint64_t, uint64_t, char *))(v252 + 56);
    v214 = (void (**)(void (**)(char *, uint64_t, uint64_t, const char *), void *, Class *))(v254 + 2);
    unint64_t v213 = (unsigned int (**)(void (**)(char *, uint64_t, uint64_t, const char *), uint64_t, char *))(v252 + 48);
    unint64_t v212 = (void (**)(void *, Class *))(v254 + 1);
    unint64_t v151 = (void (**)(char *, void (**)(char *, uint64_t, uint64_t, const char *), char *))(v252 + 32);
    v248 = v234 + 7;
    v224 = (char *)v78;
    int64_t v229 = (unint64_t)(v78 + 64) >> 6;
    v240 = (ValueMetadata *)(v251 + 16);
    uint64_t v236 = v252 + 16;
    v246 = v234 + 4;
    v263 = Description + 32;
    v254 = (void (**)(char *, char *, const char *))(v241 + 32);
    int64_t v232 = (int64_t)(v70 + 8);
    v234 = (Class *)(Description + 40);
    int64_t v233 = v241 + 40;
    swift_bridgeObjectRetain(v67);
    v245 = 0;
    v231 = qword_1ECA06328;
    unint64_t v152 = v264;
    unint64_t v267 = (unint64_t)v151;
    while (1)
    {
      unint64_t v153 = (char *)v249;
      if ((v249 & 0x8000000000000000) != 0)
      {
        unint64_t v156 = v235;
        uint64_t v157 = *((void *)v235 + 27);
        if (v157 < 0) {
          goto LABEL_111;
        }
        unint64_t v158 = (void *)*((void *)v235 + 26);
        if (v157 == *((void *)v235 + 28))
        {
          id v159 = [*((id *)v235 + 26) countByEnumeratingWithState:v228 objects:v227 count:16];
          unint64_t v156 = v235;
          *((void *)v235 + 28) = v159;
          if (!v159)
          {
            *((void *)v156 + 27) = -1;
            goto LABEL_111;
          }
          uint64_t v157 = 0;
          *((void *)v156 + 27) = 0;
        }
        uint64_t v160 = *((void *)v156 + 3);
        if (!v160) {
          goto LABEL_122;
        }
        if ((unint64_t)(v157 - 0x1000000000000000) >> 61 != 7) {
          goto LABEL_118;
        }
        unint64_t v161 = (void **)(v160 + 8 * v157);
        if ((v161 & 7) != 0) {
LABEL_113:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
        unint64_t v162 = *v161;
        *((void *)v156 + 27) = v157 + 1;
        swift_unknownObjectRetain(v162);
        Swift::Int v163 = (swift *)[v158 objectForKey:v162];
        if (!v163)
        {
LABEL_123:
          unint64_t v210 = 784;
          goto LABEL_124;
        }
        unint64_t v164 = v163;
        unint64_t v165 = (const char *)v268;
        if (_swift_isClassOrObjCExistentialType((uint64_t)v268, v268))
        {
          v269 = (swift *)v162;
          swift_dynamicCast(v149, (unint64_t *)&v269, v231, v165, 7uLL);
        }
        else
        {
          unint64_t v200 = v221;
          (*v219)(v221, 1, 1, v165);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v162, (uint64_t)v165, (char *)v200);
          uint64_t v201 = v162;
          v202 = (char *)v200;
          swift_unknownObjectRelease(v201);
          unint64_t v203 = v222;
          unint64_t v204 = v226;
          (*v218)(v222, v202, v226);
          if ((*v217)(v203, 1, v165) == 1) {
            goto LABEL_125;
          }
          (*v216)(v202, v204);
          (*v247)((unint64_t *)v149, v203, (Class *)v165);
        }
        int64_t v166 = &v149[*((int *)v152 + 12)];
        if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
        {
          v269 = v164;
          int64_t v167 = (Class *)a3;
          swift_dynamicCast(v166, (unint64_t *)&v269, qword_1ECA06328, a3, 7uLL);
        }
        else
        {
          int64_t v205 = v220;
          (*v215)(v220, 1, 1, a3);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v164, (uint64_t)a3, v205);
          swift_unknownObjectRelease(v164);
          long long v206 = v223;
          unint64_t v207 = v225;
          (*v214)(v223, v205, v225);
          if ((*v213)(v206, 1, a3) == 1) {
LABEL_125:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
          (*v212)(v205, v207);
          int64_t v167 = (Class *)a3;
          (*v151)(v166, v206, a3);
        }
        ((void (*)(char *, void, uint64_t, uint64_t *))*v248)(v149, 0, 1, v152);
        char v168 = (Class *)v268;
        unint64_t v169 = v261;
        BOOL v170 = v259;
        unint64_t v171 = v149;
        unint64_t v172 = v247;
      }
      else
      {
        if (v253)
        {
          unint64_t v154 = __clz(__rbit64(v253));
          v253 &= v253 - 1;
          unint64_t v155 = v154 | ((void)v245 << 6);
        }
        else
        {
          int64_t v173 = (int64_t)(v245 + 1);
          if (__OFADD__(v245, 1)) {
            goto LABEL_120;
          }
          if (v173 >= v229) {
            goto LABEL_111;
          }
          unint64_t v174 = *(void *)(v230 + 8 * v173);
          Swift::String::Index v175 = v245 + 1;
          if (!v174)
          {
            Swift::String::Index v175 = v245 + 2;
            if ((uint64_t)(v245 + 2) >= v229) {
              goto LABEL_111;
            }
            unint64_t v174 = *(void *)(v230 + 8 * (void)v175);
            if (!v174)
            {
              Swift::String::Index v176 = v245 + 3;
              if ((uint64_t)(v245 + 3) >= v229) {
                goto LABEL_111;
              }
              unint64_t v174 = *(void *)(v230 + 8 * (void)v176);
              if (!v174)
              {
                while (1)
                {
                  Swift::String::Index v175 = v176 + 1;
                  if (__OFADD__(v176, 1)) {
                    goto LABEL_121;
                  }
                  if ((uint64_t)v175 >= v229) {
                    break;
                  }
                  unint64_t v174 = *(void *)(v230 + 8 * (void)v175);
                  ++v176;
                  if (v174) {
                    goto LABEL_96;
                  }
                }
LABEL_111:
                ((void (*)(char *, uint64_t, uint64_t, uint64_t *))*v248)(v149, 1, 1, v152);
                uint64_t v208 = (uint64_t)v153;
                goto LABEL_112;
              }
              Swift::String::Index v175 = v245 + 3;
            }
          }
LABEL_96:
          unint64_t v253 = (v174 - 1) & v174;
          unint64_t v155 = __clz(__rbit64(v174)) + ((void)v175 << 6);
          v245 = v175;
        }
        uint64_t v177 = v251;
        BOOL v170 = v259;
        char v168 = (Class *)v268;
        (*(void (**)(unint64_t *, unint64_t, uint64_t *))(v251 + 16))(v259, *(void *)(v249 + 48) + *(void *)(v251 + 72) * v155, v268);
        uint64_t v178 = v252;
        unint64_t v179 = *((void *)v153 + 7) + *(void *)(v252 + 72) * v155;
        unint64_t v169 = v261;
        int64_t v167 = (Class *)v266;
        (*(void (**)(unint64_t *, unint64_t, char *))(v252 + 16))(v261, v179, v266);
        unint64_t v180 = &v149[*((int *)v152 + 12)];
        unint64_t v172 = v247;
        (*(void (**)(char *, unint64_t *, Class *))(v177 + 32))(v149, v170, v168);
        (*(void (**)(char *, unint64_t *, Class *))(v178 + 32))(v180, v169, v167);
        ((void (*)(char *, void, uint64_t, uint64_t *))*v248)(v149, 0, 1, v152);
        unint64_t v171 = v149;
      }
      unint64_t v181 = v237;
      ((void (*)(char *, char *, uint64_t *))*v246)(v237, v171, v152);
      unint64_t v182 = &v181[*((int *)v152 + 12)];
      unint64_t v183 = v257;
      unint64_t v184 = &v257[*((int *)TupleTypeMetadata2 + 12)];
      (*v172)(v170, v181, v168);
      swift_dynamicCast(v183, v170, v168, (const char *)&type metadata for String, 7uLL);
      (*(void (**)(unint64_t *, char *, Class *))v267)(v169, v182, v167);
      char v185 = v265;
      swift_dynamicCast(v184, v169, v167, v265, 7uLL);
      Swift::String::Index v186 = v255;
      size_t v187 = &v255[*((int *)v256 + 12)];
      Swift::String::Index v188 = *(void (**)(char *, char *, ValueMetadata *))v263;
      (*(void (**)(char *, char *, ValueMetadata *))v263)(v255, v183, &type metadata for String);
      Swift::String::Index v189 = *v254;
      (*v254)(v187, v184, v185);
      Swift::String::Index v190 = v238;
      v188(v238, v186, &type metadata for String);
      Swift::String::Index v191 = v243;
      v189((char *)v243, v187, v185);
      uint64_t v192 = v239;
      v188((char *)v239, v190, &type metadata for String);
      Swift::Int v193 = v244;
      v189((char *)v244, (char *)v191, v185);
      uint64_t v70 = v260;
      unint64_t v194 = __RawDictionaryStorage.find<A>(_:)(v192, (uint64_t)&type metadata for String, v262);
      unint64_t v195 = v194;
      unint64_t v151 = (void (**)(char *, void (**)(char *, uint64_t, uint64_t, const char *), char *))v267;
      if (v196)
      {
        (*((void (**)(char *, uint64_t, ValueMetadata *))Description + 5))((char *)v70[6] + *((void *)Description + 9) * v194, v192, &type metadata for String);
        (*(void (**)(char *, void (**)(void), const char *))(v241 + 40))((char *)v70[7] + *(void *)(v241 + 72) * v195, v193, v185);
      }
      else
      {
        if (v70[2] >= v70[3]) {
          goto LABEL_115;
        }
        *(void *)(v232 + ((v194 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v194;
        v188((char *)v70[6] + *((void *)Description + 9) * v194, (char *)v192, &type metadata for String);
        v189((char *)v70[7] + *(void *)(v241 + 72) * v195, (char *)v193, v185);
        unint64_t v197 = v70[2];
        BOOL v198 = __OFADD__(v197, 1);
        int64_t v199 = (__objc2_class *)((char *)&v197->isa + 1);
        if (v198)
        {
          __break(1u);
LABEL_117:
          __break(1u);
LABEL_118:
          __break(1u);
          goto LABEL_119;
        }
        v70[2] = v199;
      }
      unint64_t v152 = v264;
      a3 = v266;
      unint64_t v149 = (char *)v250;
    }
  }
  v240 = a4;
  v235 = v40;
  if (v66)
  {
    if (v67 < 0) {
      uint64_t v71 = v67;
    }
    else {
      uint64_t v71 = v67 & 0xFFFFFFFFFFFFFF8;
    }
    int64_t v72 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v73 = (unint64_t)swift_allocObject(v72, 0xE8uLL, 7uLL);
    int64_t v233 = 0;
    int64_t v74 = 0;
    unint64_t v253 = 0;
    *(void *)(v73 + 208) = v71;
    *(void *)(v73 + 216) = 0;
    *(_OWORD *)(v73 + 16) = 0u;
    *(_OWORD *)(v73 + 32) = 0u;
    *(_OWORD *)(v73 + 48) = 0u;
    *(_OWORD *)(v73 + 64) = 0u;
    *(_OWORD *)(v73 + 80) = 0u;
    *(_OWORD *)(v73 + 96) = 0u;
    *(_OWORD *)(v73 + 112) = 0u;
    *(_OWORD *)(v73 + 128) = 0u;
    *(_OWORD *)(v73 + 144) = 0u;
    *(_OWORD *)(v73 + 160) = 0u;
    *(_OWORD *)(v73 + 176) = 0u;
    *(_OWORD *)(v73 + 192) = 0u;
    *(void *)(v73 + 224) = 0;
    unint64_t v267 = v73 | 0x8000000000000000;
  }
  else
  {
    uint64_t v80 = -1 << *(unsigned char *)(v67 + 32);
    int64_t v74 = ~v80;
    uint64_t v81 = *(void *)(v67 + 64);
    int64_t v233 = v67 + 64;
    uint64_t v82 = -v80;
    if (v82 < 64) {
      uint64_t v83 = ~(-1 << v82);
    }
    else {
      uint64_t v83 = -1;
    }
    unint64_t v253 = v83 & v81;
    unint64_t v267 = v67;
  }
  v231 = (Class *)((v267 & 0x7FFFFFFFFFFFFFFFLL) + 16);
  uint64_t v236 = v267 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v230 = (v267 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  v223 = (void (**)(char *, uint64_t, uint64_t, const char *))(v251 + 56);
  v222 = (char *)(v232 + 16);
  v221 = (char *)(v251 + 48);
  v220 = (void *)(v232 + 8);
  v244 = (void (**)(void))(v251 + 32);
  v219 = (void (**)(char *, uint64_t, uint64_t, const char *))(v252 + 56);
  v218 = (void (**)(char *, char *, Class *))(v254 + 2);
  v217 = (unsigned int (**)(char *, uint64_t, const char *))(v252 + 48);
  v216 = (void (**)(char *, Class *))(v254 + 1);
  v254 = (void (**)(char *, char *, const char *))(v252 + 32);
  v250 = v234 + 7;
  int64_t v229 = v74;
  int64_t v232 = (unint64_t)(v74 + 64) >> 6;
  v238 = (char *)(v251 + 16);
  v237 = (char *)(v252 + 16);
  v243 = v234 + 4;
  Description += 32;
  v241 += 32;
  swift_bridgeObjectRetain(v67);
  swift_retain((atomic_ullong *)v70);
  uint64_t v239 = 0;
  v234 = qword_1ECA06328;
  while ((v267 & 0x8000000000000000) == 0)
  {
    uint64_t v116 = (Class *)v266;
    uint64_t v117 = v268;
    uint64_t v118 = v264;
    uint64_t v119 = v261;
    if (v253)
    {
      unint64_t v84 = __clz(__rbit64(v253));
      v253 &= v253 - 1;
      unint64_t v85 = v84 | (v239 << 6);
    }
    else
    {
      int64_t v120 = v239 + 1;
      uint64_t v121 = v263;
      if (__OFADD__(v239, 1)) {
        goto LABEL_117;
      }
      if (v120 >= v232) {
        goto LABEL_109;
      }
      unint64_t v122 = *(void *)(v233 + 8 * v120);
      uint64_t v123 = v239 + 1;
      if (!v122)
      {
        uint64_t v123 = v239 + 2;
        if (v239 + 2 >= v232) {
          goto LABEL_109;
        }
        unint64_t v122 = *(void *)(v233 + 8 * v123);
        if (!v122)
        {
          int64_t v124 = (char *)(v239 + 3);
          if (v239 + 3 >= v232) {
            goto LABEL_109;
          }
          unint64_t v122 = *(void *)(v233 + 8 * (void)v124);
          if (!v122)
          {
            while (1)
            {
              uint64_t v123 = (uint64_t)(v124 + 1);
              if (__OFADD__(v124, 1)) {
                break;
              }
              if (v123 >= v232) {
                goto LABEL_109;
              }
              unint64_t v122 = *(void *)(v233 + 8 * v123);
              ++v124;
              if (v122) {
                goto LABEL_55;
              }
            }
LABEL_119:
            __break(1u);
LABEL_120:
            __break(1u);
LABEL_121:
            __break(1u);
LABEL_122:
            unint64_t v210 = 773;
LABEL_124:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v210, 0);
          }
          uint64_t v123 = v239 + 3;
        }
      }
LABEL_55:
      unint64_t v253 = (v122 - 1) & v122;
      unint64_t v85 = __clz(__rbit64(v122)) + (v123 << 6);
      uint64_t v239 = v123;
    }
    unint64_t v86 = v267;
    uint64_t v87 = v251;
    uint64_t v88 = v259;
    (*(void (**)(unint64_t *, unint64_t, uint64_t *))(v251 + 16))(v259, *(void *)(v267 + 48) + *(void *)(v251 + 72) * v85, v268);
    uint64_t v89 = v252;
    (*(void (**)(unint64_t *, unint64_t, Class *))(v252 + 16))(v119, *(void *)(v86 + 56) + *(void *)(v252 + 72) * v85, v116);
    unint64_t v90 = v263;
    char v91 = &v263[*((int *)v118 + 12)];
    unint64_t v92 = v117;
    unint64_t v93 = (void (**)(unint64_t *, char *, uint64_t *))v244;
    (*(void (**)(char *, unint64_t *, uint64_t *))(v87 + 32))(v263, v88, v92);
    uint64_t v94 = *(void (**)(char *, unint64_t *, Class *))(v89 + 32);
    unint64_t v95 = v119;
    uint64_t v96 = v119;
    int64_t v97 = (void (**)(unint64_t *, char *, Class *))v254;
    v94(v91, v95, v116);
    ((void (*)(char *, void, uint64_t, uint64_t *))*v250)(v90, 0, 1, v118);
LABEL_28:
    uint64_t v98 = (const char *)v240;
    char v99 = v245;
    ((void (*)(char *, char *, uint64_t *))*v243)(v245, v90, v118);
    int64_t v100 = &v99[*((int *)v118 + 12)];
    uint64_t v101 = v257;
    int64_t v102 = &v257[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v103 = v99;
    uint64_t v104 = (Class *)v268;
    (*v93)(v88, v103, v268);
    swift_dynamicCast(v101, v88, v104, v98, 7uLL);
    (*v97)(v96, v100, v116);
    unint64_t v105 = v265;
    swift_dynamicCast(v102, v96, v116, v265, 7uLL);
    uint64_t v106 = v255;
    uint64_t v107 = &v255[*((int *)v256 + 12)];
    uint64_t v108 = *(void (**)(char *, uint64_t, ValueMetadata *))Description;
    uint64_t v109 = v101;
    uint64_t v110 = (uint64_t)v105;
    (*(void (**)(char *, char *, const char *))Description)(v255, v109, v98);
    int64_t v111 = *(void (**)(char *, char *, uint64_t))v241;
    (*(void (**)(char *, char *, uint64_t))v241)(v107, v102, v110);
    uint64_t v112 = v246;
    v108((char *)v246, (uint64_t)v106, (ValueMetadata *)v98);
    uint64_t v113 = v248;
    v111((char *)v248, v107, v110);
    uint64_t v114 = (uint64_t)v247;
    v108((char *)v247, (uint64_t)v112, (ValueMetadata *)v98);
    uint64_t v115 = v249;
    v111((char *)v249, (char *)v113, v110);
    _NativeDictionary._unsafeInsertNew(key:value:)(v114, v115, v260, (unint64_t)v98, v110, v262);
  }
  uint64_t v125 = v236;
  uint64_t v126 = *(void *)(v236 + 216);
  int64_t v127 = v266;
  uint64_t v118 = v264;
  uint64_t v96 = v261;
  unint64_t v128 = v235;
  uint64_t v129 = (void (**)(char *, char *, char *))v254;
  if (v126 < 0)
  {
    uint64_t v121 = v263;
    goto LABEL_109;
  }
  uint64_t v130 = *(void **)(v236 + 208);
  uint64_t v121 = v263;
  Swift::UInt v131 = v259;
  if (v126 != *(void *)(v236 + 224))
  {
LABEL_43:
    uint64_t v133 = *(void *)(v125 + 24);
    if (!v133) {
      goto LABEL_122;
    }
    if ((unint64_t)(v126 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_115:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/NativeDictionary.swift", 28, 2, 0x1FFuLL, 0);
    }
    long long v134 = (void **)(v133 + 8 * v126);
    if ((v134 & 7) != 0) {
      goto LABEL_113;
    }
    long long v135 = *v134;
    *(void *)(v125 + 216) = v126 + 1;
    swift_unknownObjectRetain(v135);
    uint64_t v136 = (swift *)[v130 objectForKey:v135];
    if (!v136) {
      goto LABEL_123;
    }
    char v137 = v136;
    int64_t v138 = (const char *)v268;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v268, v268))
    {
      v269 = (swift *)v135;
      unint64_t v90 = v263;
      swift_dynamicCast(v263, (unint64_t *)&v269, v234, v138, 7uLL);
    }
    else
    {
      char v140 = v224;
      (*v223)(v224, 1, 1, v138);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v135, (uint64_t)v138, v140);
      swift_unknownObjectRelease(v135);
      BOOL v141 = v227;
      (*(void (**)(char *, char *, Class *))v222)(v227, v140, v226);
      if ((*(unsigned int (**)(char *, uint64_t, const char *))v221)(v141, 1, v138) == 1) {
        goto LABEL_125;
      }
      ((void (*)(char *, Class *))*v220)(v140, v226);
      unint64_t v90 = v263;
      (*v244)();
    }
    uint64_t v139 = &v90[*((int *)v118 + 12)];
    if (_swift_isClassOrObjCExistentialType((uint64_t)v127, (uint64_t *)v127))
    {
      uint64_t v88 = v131;
      v269 = v137;
      uint64_t v116 = (Class *)v127;
      swift_dynamicCast(v139, (unint64_t *)&v269, qword_1ECA06328, v127, 7uLL);
    }
    else
    {
      (*v219)(v128, 1, 1, v127);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v137, (uint64_t)v127, v128);
      swift_unknownObjectRelease(v137);
      unint64_t v142 = v228;
      unint64_t v143 = v225;
      (*v218)(v228, v128, v225);
      if ((*v217)(v142, 1, v127) == 1) {
        goto LABEL_125;
      }
      uint64_t v88 = v131;
      (*v216)(v128, v143);
      unint64_t v144 = v142;
      uint64_t v116 = (Class *)v127;
      (*v129)(v139, v144, v127);
      unint64_t v90 = v263;
    }
    ((void (*)(char *, void, uint64_t, uint64_t *))*v250)(v90, 0, 1, v118);
    unint64_t v93 = (void (**)(unint64_t *, char *, uint64_t *))v244;
    int64_t v97 = (void (**)(unint64_t *, char *, Class *))v254;
    goto LABEL_28;
  }
  id v132 = [*(id *)(v236 + 208) countByEnumeratingWithState:v231 objects:v230 count:16];
  uint64_t v125 = v236;
  *(void *)(v236 + 224) = v132;
  if (v132)
  {
    uint64_t v126 = 0;
    *(void *)(v125 + 216) = 0;
    goto LABEL_43;
  }
  *(void *)(v125 + 216) = -1;
LABEL_109:
  ((void (*)(char *, uint64_t, uint64_t, uint64_t *))*v250)(v121, 1, 1, v118);
  uint64_t v70 = v260;
  swift_release((uint64_t)v260);
  uint64_t v208 = v267;
LABEL_112:
  outlined consume of [A : B].Iterator._Variant<A, B>(v208);
  return v70;
}

unint64_t _DictionaryAnyHashableBox._base.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unint64_t *a5@<X8>)
{
  a5[3] = (unint64_t)type metadata accessor for Dictionary(0, a2, a3, a4);
  *a5 = a1;

  return swift_bridgeObjectRetain(a1);
}

void _DictionaryAnyHashableBox._canonicalBox.getter(unint64_t a1@<X1>, unint64_t *a2@<X8>)
{
  swift_bridgeObjectRetain(a1);
  specialized _dictionaryUpCast<A, B, C, D>(_:)(a1);
  a2[3] = (unint64_t)&unk_1ECA03250;
  a2[4] = (unint64_t)&protocol witness table for _DictionaryAnyHashableBox<A, B>;
  *a2 = a1;
  a2[1] = v4;
}

uint64_t _DictionaryAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  outlined init with copy of MirrorPath(a1, (uint64_t)v10);
  unint64_t v4 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  if (!swift_dynamicCast((char *)v9, v10, v4, byte_1ECA03250, 6uLL)) {
    return 2;
  }
  uint64_t v5 = v9[0];
  uint64_t v6 = v9[1];
  char v7 = specialized static Dictionary<>.== infix(_:_:)(a3, v9[0]);
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(v5);
  return v7 & 1;
}

Swift::Int _DictionaryAnyHashableBox._hashValue.getter(uint64_t a1, unint64_t a2)
{
  *(void *)&long long v3 = 0;
  *((void *)&v3 + 1) = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  uint64_t v4 = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  uint64_t v6 = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  specialized Dictionary<>.hash(into:)(&v3, a2);
  return Hasher._finalize()();
}

void _DictionaryAnyHashableBox._hash(into:)(long long *a1, uint64_t a2, unint64_t a3)
{
}

Swift::Int __swiftcall _DictionaryAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  *(void *)&long long v3 = 0;
  *((void *)&v3 + 1) = _swift_stdlib_Hashing_parameters ^ _seed ^ 0x736F6D6570736575;
  uint64_t v4 = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ _seed ^ 0x6C7967656E657261;
  uint64_t v6 = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  specialized Dictionary<>.hash(into:)(&v3, v1);
  return Hasher._finalize()();
}

uint64_t _DictionaryAnyHashableBox._unbox<A>()@<X0>(unint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, const char *a4@<X4>, uint64_t a5@<X5>, char *a6@<X8>)
{
  unint64_t v12 = a1;
  uint64_t v9 = type metadata accessor for Dictionary(0, a2, a3, a5);
  swift_bridgeObjectRetain(a1);
  int v10 = swift_dynamicCast(a6, &v12, v9, a4, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a4 - 1) + 56))(a6, v10 ^ 1u, 1, a4);
}

uint64_t _DictionaryAnyHashableBox._downCastConditional<A>(into:)(char *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t v25 = a1;
  unint64_t v12 = type metadata accessor for Optional(0, (uint64_t)a6, a3, a4);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v25 - v15;
  uint64_t v17 = *((void *)a6 - 1);
  MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v25 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v26 = a2;
  uint64_t v20 = type metadata accessor for Dictionary(0, a4, a5, a7);
  swift_bridgeObjectRetain(a2);
  uint64_t v21 = swift_dynamicCast(v16, &v26, v20, a6, 6uLL);
  uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v17 + 56);
  if (v21)
  {
    v22(v16, 0, 1, a6);
    uint64_t v23 = *(void (**)(char *, char *, const char *))(v17 + 32);
    v23(v19, v16, a6);
    v23(v25, v19, a6);
  }
  else
  {
    v22(v16, 1, 1, a6);
    (*(void (**)(char *, Class *))(v13 + 8))(v16, v12);
  }
  return v21;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _DictionaryAnyHashableBox<A, B>(unint64_t *a1@<X8>)
{
  _DictionaryAnyHashableBox._canonicalBox.getter(*(void *)(v1 + 8), a1);
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _DictionaryAnyHashableBox<A, B>(uint64_t a1, uint64_t a2)
{
  return _DictionaryAnyHashableBox._isEqual(to:)(a1, a2, *(void *)(v2 + 8));
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _DictionaryAnyHashableBox<A, B>(uint64_t a1)
{
  return _DictionaryAnyHashableBox._hashValue.getter(a1, *(void *)(v1 + 8));
}

void protocol witness for _AnyHashableBox._hash(into:) in conformance _DictionaryAnyHashableBox<A, B>(long long *a1, uint64_t a2)
{
  _DictionaryAnyHashableBox._hash(into:)(a1, a2, *(void *)(v2 + 8));
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _DictionaryAnyHashableBox<A, B>(Swift::Int _seed)
{
  return _DictionaryAnyHashableBox._rawHashValue(_seed:)(_seed);
}

unint64_t protocol witness for _AnyHashableBox._base.getter in conformance _DictionaryAnyHashableBox<A, B>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  return _DictionaryAnyHashableBox._base.getter(*v2, a1[2], a1[3], a1[4], a2);
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _DictionaryAnyHashableBox<A, B>@<X0>(const char *a1@<X0>, uint64_t *a2@<X2>, char *a3@<X8>)
{
  return _DictionaryAnyHashableBox._unbox<A>()(*v3, a2[2], a2[3], a1, a2[4], a3);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _DictionaryAnyHashableBox<A, B>(char *a1, const char *a2, uint64_t *a3)
{
  return _DictionaryAnyHashableBox._downCastConditional<A>(into:)(a1, *v3, (uint64_t)a3, a3[2], a3[3], a2, a3[4]);
}

uint64_t Dictionary.description.getter(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v217 = *(void *)(a3 - 8);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  uint64_t v230 = (char *)v208 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v216 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v5);
  v223 = (char *)v208 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v231 = v9;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, v10, (uint64_t)v9, "key value ", 0);
  v220 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v12, v13);
  uint64_t v14 = (uint64_t)*(v220 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v220);
  uint64_t v17 = (char *)v208 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)v208 - v18;
  v225 = a2;
  if ((v4 & 0xC000000000000001) == 0)
  {
    if (*(void *)(v4 + 16))
    {
      uint64_t v235 = 91;
      unint64_t v236 = 0xE100000000000000;
      uint64_t v26 = -1 << *(unsigned char *)(v4 + 32);
      uint64_t v23 = ~v26;
      uint64_t v27 = *(void *)(v4 + 64);
      uint64_t v211 = v4 + 64;
      uint64_t v28 = -v26;
      if (v28 < 64) {
        uint64_t v29 = ~(-1 << v28);
      }
      else {
        uint64_t v29 = -1;
      }
      uint64_t v24 = v29 & v27;
      unint64_t v25 = v4;
      goto LABEL_12;
    }
    return 6109787;
  }
  if (v4 < 0) {
    uint64_t v20 = (void *)v4;
  }
  else {
    uint64_t v20 = (void *)(v4 & 0xFFFFFFFFFFFFFF8);
  }
  if (!objc_msgSend(v20, sel_count)) {
    return 6109787;
  }
  uint64_t v235 = 91;
  unint64_t v236 = 0xE100000000000000;
  uint64_t v21 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
  unint64_t v22 = (unint64_t)swift_allocObject(v21, 0xE8uLL, 7uLL);
  uint64_t v211 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  *(void *)(v22 + 208) = v20;
  *(void *)(v22 + 216) = 0;
  *(_OWORD *)(v22 + 16) = 0u;
  *(_OWORD *)(v22 + 32) = 0u;
  *(_OWORD *)(v22 + 48) = 0u;
  *(_OWORD *)(v22 + 64) = 0u;
  *(_OWORD *)(v22 + 80) = 0u;
  *(_OWORD *)(v22 + 96) = 0u;
  *(_OWORD *)(v22 + 112) = 0u;
  *(_OWORD *)(v22 + 128) = 0u;
  *(_OWORD *)(v22 + 144) = 0u;
  *(_OWORD *)(v22 + 160) = 0u;
  *(_OWORD *)(v22 + 176) = 0u;
  *(_OWORD *)(v22 + 192) = 0u;
  *(void *)(v22 + 224) = 0;
  unint64_t v25 = v22 | 0x8000000000000000;
  a2 = v225;
LABEL_12:
  unint64_t v221 = v25;
  uint64_t v212 = v25 & 0x7FFFFFFFFFFFFFFFLL;
  v219 = TupleTypeMetadata2 - 1;
  v208[1] = v23;
  uint64_t v215 = v216 + 16;
  uint64_t v214 = v217 + 16;
  v218 = (void (**)(char *, char *, Class *))(v14 + 32);
  v224 = (void (**)(char *, char *, char *))(v216 + 32);
  int64_t v229 = (void (**)(char *, char *, char *))(v217 + 32);
  int64_t v213 = (unint64_t)(v23 + 64) >> 6;
  v208[0] = v213 - 1;
  swift_bridgeObjectRetain(v4);
  uint64_t v30 = 0;
  char v31 = 1;
  long long v228 = xmmword_18162AC80;
  long long v210 = xmmword_18162AD30;
  long long v209 = xmmword_18162AC90;
  v222 = v17;
  while (1)
  {
    unint64_t v35 = v24;
    uint64_t v36 = v30;
    if ((v221 & 0x8000000000000000) != 0)
    {
      id v40 = __CocoaDictionary.Iterator.next()();
      if (v40)
      {
        id v43 = v40;
        long long v44 = v41;
        uint64_t v45 = v225;
        _forceBridgeFromObjectiveC<A>(_:_:)(v40, v225, v42, v17);
        uint64_t v46 = v43;
        a2 = v45;
        swift_unknownObjectRelease(v46);
        _forceBridgeFromObjectiveC<A>(_:_:)(v44, v231, v47, &v17[*((int *)TupleTypeMetadata2 + 12)]);
        swift_unknownObjectRelease(v44);
        uint64_t v39 = 0;
        uint64_t v227 = v35;
      }
      else
      {
        uint64_t v39 = 1;
        uint64_t v227 = v24;
        a2 = v225;
      }
    }
    else
    {
      if (v24)
      {
        uint64_t v227 = (v24 - 1) & v24;
        unint64_t v37 = __clz(__rbit64(v24)) | (v30 << 6);
        goto LABEL_20;
      }
      ++v30;
      if (__OFADD__(v36, 1)) {
        goto LABEL_249;
      }
      if (v30 >= v213)
      {
        uint64_t v227 = 0;
        uint64_t v39 = 1;
        uint64_t v30 = v36;
      }
      else
      {
        unint64_t v48 = *(void *)(v211 + 8 * v30);
        if (v48) {
          goto LABEL_26;
        }
        uint64_t v139 = v36 + 2;
        if (v36 + 2 >= v213)
        {
          uint64_t v227 = 0;
          uint64_t v39 = 1;
        }
        else
        {
          unint64_t v48 = *(void *)(v211 + 8 * v139);
          if (v48)
          {
            ++v30;
LABEL_26:
            uint64_t v227 = (v48 - 1) & v48;
            unint64_t v37 = __clz(__rbit64(v48)) + (v30 << 6);
LABEL_20:
            uint64_t v38 = v221;
            (*(void (**)(char *, unint64_t, char *))(v216 + 16))(v17, *(void *)(v221 + 48) + *(void *)(v216 + 72) * v37, a2);
            (*(void (**)(char *, unint64_t, char *))(v217 + 16))(&v17[*((int *)TupleTypeMetadata2 + 12)], *(void *)(v38 + 56) + *(void *)(v217 + 72) * v37, v231);
            uint64_t v39 = 0;
            goto LABEL_29;
          }
          while (1)
          {
            uint64_t v30 = v139 + 1;
            if (__OFADD__(v139, 1)) {
              goto LABEL_251;
            }
            if (v30 >= v213) {
              break;
            }
            unint64_t v48 = *(void *)(v211 + 8 * v30);
            ++v139;
            if (v48) {
              goto LABEL_26;
            }
          }
          uint64_t v227 = 0;
          uint64_t v39 = 1;
          uint64_t v30 = v208[0];
        }
      }
    }
LABEL_29:
    uint64_t v49 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v49 + 56))(v17, v39, 1, TupleTypeMetadata2);
    (*v218)(v19, v17, v220);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v49 + 48))(v19, 1, TupleTypeMetadata2) == 1) {
      break;
    }
    uint64_t v50 = &v19[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v51 = *v224;
    uint64_t v24 = (uint64_t)v223;
    (*v224)(v223, v19, a2);
    v226 = *v229;
    v226(v230, v50, v231);
    if (v31) {
      goto LABEL_79;
    }
    unint64_t v35 = v235;
    uint64_t v4 = v236;
    unint64_t v52 = HIBYTE(v236) & 0xF;
    uint64_t v53 = v235 & 0xFFFFFFFFFFFFLL;
    if ((v236 & 0x2000000000000000) != 0) {
      unint64_t v54 = HIBYTE(v236) & 0xF;
    }
    else {
      unint64_t v54 = v235 & 0xFFFFFFFFFFFFLL;
    }
    if (!v54 && (v235 & ~v236 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v236);
      uint64_t v235 = 8236;
      unint64_t v236 = 0xE200000000000000;
      goto LABEL_73;
    }
    if ((v236 & 0x2000000000000000) == 0 || v52 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v4 & 0x1000000000000000) != 0)
      {
        Swift::Int v140 = String.UTF8View._foreignCount()();
        int64_t v61 = v140 + 2;
        if (__OFADD__(v140, 2)) {
          goto LABEL_250;
        }
      }
      else
      {
        BOOL v60 = __OFADD__(v54, 2);
        int64_t v61 = v54 + 2;
        if (v60) {
          goto LABEL_250;
        }
      }
      if ((v35 & ~v4 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v62 = _StringGuts.nativeUnusedCapacity.getter(v35, v4);
        if (v63) {
          goto LABEL_266;
        }
        if (v61 > 15)
        {
LABEL_69:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v61, 2);
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v234 = v209;
          uint64_t v87 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v234, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v87, v88, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
LABEL_73:
          a2 = v225;
          goto LABEL_79;
        }
        if ((v4 & 0x2000000000000000) == 0)
        {
          if (v62 > 1) {
            goto LABEL_69;
          }
          goto LABEL_49;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_50:
        unint64_t v64 = v4;
      }
      else
      {
        if (v61 > 15) {
          goto LABEL_69;
        }
LABEL_49:
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        if ((v4 & 0x2000000000000000) != 0) {
          goto LABEL_50;
        }
        if ((v4 & 0x1000000000000000) != 0)
        {
          unint64_t v35 = _StringGuts._foreignConvertedToSmall()(v35, v4);
          unint64_t v64 = v153;
        }
        else
        {
          if ((v35 & 0x1000000000000000) != 0)
          {
            uint64_t v146 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            uint64_t v146 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v35, v4);
            uint64_t v53 = v154;
          }
          swift_bridgeObjectRetain(v4);
          closure #1 in _StringGuts._convertedToSmall()(v146, v53, &v234);
          swift_bridgeObjectRelease(v4);
          unint64_t v64 = *((void *)&v234 + 1);
          unint64_t v35 = v234;
        }
      }
      v65._rawBits = 1;
      v66._rawBits = 131073;
      v67._rawBits = _StringGuts.validateScalarRange(_:)(v65, v66, 0x202CuLL, 0xE200000000000000);
      if (v67._rawBits < 0x10000) {
        v67._rawBits |= 3;
      }
      unint64_t v69 = specialized String.init(_:)(v67, v68, 0x202CuLL, 0xE200000000000000);
      unint64_t v71 = v70;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v71 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v71);
      }
      else if ((v71 & 0x1000000000000000) != 0)
      {
        unint64_t v69 = _StringGuts._foreignConvertedToSmall()(v69, v71);
        unint64_t v152 = v151;
        swift_bridgeObjectRelease(v71);
        unint64_t v71 = v152;
      }
      else
      {
        if ((v69 & 0x1000000000000000) != 0)
        {
          unint64_t v144 = (unsigned __int8 *)((v71 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v145 = v69 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v144 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v69, v71);
        }
        closure #1 in _StringGuts._convertedToSmall()(v144, v145, &v234);
        swift_bridgeObjectRelease(v71);
        unint64_t v71 = *((void *)&v234 + 1);
        unint64_t v69 = v234;
      }
      uint64_t v72 = HIBYTE(v64) & 0xF;
      uint64_t v73 = HIBYTE(v71) & 0xF;
      uint64_t v74 = v73 + v72;
      if ((unint64_t)(v73 + v72) > 0xF) {
        goto LABEL_265;
      }
      if (v73)
      {
        char v75 = 0;
        unint64_t v76 = 0;
        do
        {
          unint64_t v77 = v72 + v76;
          unint64_t v78 = v76 + 1;
          if (v76 >= 8) {
            unint64_t v79 = v71;
          }
          else {
            unint64_t v79 = v69;
          }
          unint64_t v80 = v79 >> (v75 & 0x38);
          char v81 = (8 * v72 + v75) & 0x38;
          uint64_t v82 = (-255 << v81) - 1;
          unint64_t v83 = (unint64_t)v80 << v81;
          unint64_t v84 = v83 | v82 & v64;
          unint64_t v85 = v83 | v82 & v35;
          if (v77 < 8) {
            unint64_t v35 = v85;
          }
          else {
            unint64_t v64 = v84;
          }
          v75 += 8;
          unint64_t v76 = v78;
        }
        while (v73 != v78);
      }
      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v86 = 0xE000000000000000;
      if (v35 & 0x8080808080808080 | v64 & 0x80808080808080) {
        unint64_t v86 = 0xA000000000000000;
      }
      uint64_t v235 = v35;
      unint64_t v236 = v86 & 0xFF00000000000000 | (v74 << 56) | v64 & 0xFFFFFFFFFFFFFFLL;
      a2 = v225;
      goto LABEL_78;
    }
    unint64_t v55 = 8 * (HIBYTE(v236) & 7);
    uint64_t v56 = (-255 << v55) - 1;
    uint64_t v57 = 44 << v55;
    char v58 = v52 + 1;
    if (v52 >= 8)
    {
      uint64_t v59 = v57 | v56 & v236;
      a2 = v225;
    }
    else
    {
      unint64_t v35 = v57 | v56 & v235;
      a2 = v225;
      if (v52 != 7)
      {
        unint64_t v35 = (32 << (8 * (v58 & 7u))) | ((-255 << (8 * (v58 & 7u))) - 1) & v35;
        uint64_t v89 = v236;
        goto LABEL_75;
      }
      char v58 = 8;
      uint64_t v59 = v236;
    }
    uint64_t v89 = (32 << (8 * (v58 & 7u))) | ((-255 << (8 * (v58 & 7u))) - 1) & v59;
LABEL_75:
    swift_bridgeObjectRelease(v236);
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v90 = 0xE000000000000000;
    if (v35 & 0x8080808080808080 | v89 & 0x80808080808080) {
      unint64_t v90 = 0xA000000000000000;
    }
    uint64_t v235 = v35;
    unint64_t v236 = (v90 & 0xFF00000000000000 | (v52 << 56) | v89 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
LABEL_78:
    uint64_t v24 = (uint64_t)v223;
LABEL_79:
    uint64_t v91 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    uint64_t inited = swift_initStackObject(v91, &v233);
    *((_OWORD *)inited + 1) = v228;
    inited[7] = a2;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v51(boxed_opaque_existential_0Tm, (char *)v24, a2);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v235);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    unint64_t v35 = v235;
    uint64_t v94 = v236;
    unint64_t v95 = HIBYTE(v236) & 0xF;
    uint64_t v4 = v235 & 0xFFFFFFFFFFFFLL;
    if ((v236 & 0x2000000000000000) != 0) {
      unint64_t v96 = HIBYTE(v236) & 0xF;
    }
    else {
      unint64_t v96 = v235 & 0xFFFFFFFFFFFFLL;
    }
    if (!v96 && (v235 & ~v236 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v236);
      uint64_t v235 = 8250;
      unint64_t v32 = 0xE200000000000000;
      goto LABEL_14;
    }
    if ((v236 & 0x2000000000000000) != 0 && v95 <= 0xD)
    {
      unint64_t v97 = 8 * (HIBYTE(v236) & 7);
      uint64_t v98 = (-255 << v97) - 1;
      uint64_t v99 = 58 << v97;
      char v100 = v95 + 1;
      if (v95 >= 8)
      {
        uint64_t v101 = v99 | v98 & v236;
        a2 = v225;
LABEL_129:
        uint64_t v131 = (32 << (8 * (v100 & 7u))) | ((-255 << (8 * (v100 & 7u))) - 1) & v101;
      }
      else
      {
        unint64_t v35 = v99 | v98 & v235;
        a2 = v225;
        if (v95 == 7)
        {
          char v100 = 8;
          uint64_t v101 = v236;
          goto LABEL_129;
        }
        unint64_t v35 = (32 << (8 * (v100 & 7u))) | ((-255 << (8 * (v100 & 7u))) - 1) & v35;
        uint64_t v131 = v236;
      }
      swift_bridgeObjectRelease(v236);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v138 = 0xE000000000000000;
      if (v35 & 0x8080808080808080 | v131 & 0x80808080808080) {
        unint64_t v138 = 0xA000000000000000;
      }
      uint64_t v235 = v35;
      unint64_t v236 = (v138 & 0xFF00000000000000 | (v95 << 56) | v131 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
LABEL_15:
      uint64_t v17 = v222;
      goto LABEL_16;
    }
    swift_bridgeObjectRetain_n(0xE200000000000000, 6);
    if ((v94 & 0x1000000000000000) != 0) {
      unint64_t v96 = String.UTF8View._foreignCount()();
    }
    BOOL v60 = __OFADD__(v96, 2);
    Swift::Int v102 = v96 + 2;
    uint64_t v17 = v222;
    if (v60)
    {
      __break(1u);
LABEL_249:
      __break(1u);
LABEL_250:
      __break(1u);
LABEL_251:
      __break(1u);
LABEL_252:
      __break(1u);
LABEL_253:
      Swift::Int v199 = String.UTF8View._foreignCount()();
      uint64_t v164 = v199 + 1;
      if (!__OFADD__(v199, 1)) {
        goto LABEL_199;
      }
LABEL_255:
      __break(1u);
LABEL_256:
      if ((v164 & 0x1000000000000000) != 0)
      {
        unint64_t v35 = _StringGuts._foreignConvertedToSmall()(v35, v164);
        uint64_t v205 = v204;
        swift_bridgeObjectRelease(v164);
        uint64_t v164 = v205;
      }
      else
      {
        if ((v35 & 0x1000000000000000) != 0)
        {
          unint64_t v200 = (unsigned __int8 *)((v164 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v201 = v35 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v200 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v35, v164);
        }
        closure #1 in _StringGuts._convertedToSmall()(v200, v201, &v234);
        swift_bridgeObjectRelease(v164);
        uint64_t v164 = *((void *)&v234 + 1);
        unint64_t v35 = v234;
      }
      goto LABEL_222;
    }
    uint64_t v24 = v35 & ~v94;
    if ((v24 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v94 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v103 = _StringGuts.nativeUnusedCapacity.getter(v35, v94);
      if (v104) {
        goto LABEL_266;
      }
      if (v102 <= 15)
      {
        if ((v94 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_99:
          unint64_t v105 = v94;
          goto LABEL_100;
        }
        if (v103 <= 1) {
          goto LABEL_98;
        }
      }
    }
    else if (v102 <= 15)
    {
LABEL_98:
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      if ((v94 & 0x2000000000000000) != 0) {
        goto LABEL_99;
      }
      if ((v94 & 0x1000000000000000) != 0)
      {
        unint64_t v35 = _StringGuts._foreignConvertedToSmall()(v35, v94);
        unint64_t v105 = v149;
      }
      else
      {
        if ((v35 & 0x1000000000000000) != 0)
        {
          unint64_t v143 = (unsigned __int8 *)((v94 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          unint64_t v143 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v35, v94);
          uint64_t v4 = v150;
        }
        swift_bridgeObjectRetain(v94);
        closure #1 in _StringGuts._convertedToSmall()(v143, v4, &v234);
        swift_bridgeObjectRelease(v94);
        unint64_t v105 = *((void *)&v234 + 1);
        unint64_t v35 = v234;
      }
LABEL_100:
      v106._rawBits = 1;
      v107._rawBits = 131073;
      v108._rawBits = _StringGuts.validateScalarRange(_:)(v106, v107, 0x203AuLL, 0xE200000000000000);
      if (v108._rawBits < 0x10000) {
        v108._rawBits |= 3;
      }
      unint64_t v110 = specialized String.init(_:)(v108, v109, 0x203AuLL, 0xE200000000000000);
      unint64_t v112 = v111;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v112 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v112);
      }
      else if ((v112 & 0x1000000000000000) != 0)
      {
        unint64_t v110 = _StringGuts._foreignConvertedToSmall()(v110, v112);
        unint64_t v148 = v147;
        swift_bridgeObjectRelease(v112);
        unint64_t v112 = v148;
      }
      else
      {
        if ((v110 & 0x1000000000000000) != 0)
        {
          BOOL v141 = (unsigned __int8 *)((v112 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v142 = v110 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          BOOL v141 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v110, v112);
        }
        closure #1 in _StringGuts._convertedToSmall()(v141, v142, &v234);
        swift_bridgeObjectRelease(v112);
        unint64_t v112 = *((void *)&v234 + 1);
        unint64_t v110 = v234;
      }
      uint64_t v113 = HIBYTE(v105) & 0xF;
      uint64_t v114 = HIBYTE(v112) & 0xF;
      uint64_t v115 = v114 + v113;
      if ((unint64_t)(v114 + v113) > 0xF) {
        goto LABEL_265;
      }
      if (v114)
      {
        char v116 = 0;
        unint64_t v117 = 0;
        do
        {
          unint64_t v118 = v113 + v117;
          unint64_t v119 = v117 + 1;
          if (v117 >= 8) {
            unint64_t v120 = v112;
          }
          else {
            unint64_t v120 = v110;
          }
          unint64_t v121 = v120 >> (v116 & 0x38);
          char v122 = (8 * v113 + v116) & 0x38;
          uint64_t v123 = (-255 << v122) - 1;
          unint64_t v124 = (unint64_t)v121 << v122;
          unint64_t v125 = v124 | v123 & v105;
          unint64_t v126 = v124 | v123 & v35;
          if (v118 < 8) {
            unint64_t v35 = v126;
          }
          else {
            unint64_t v105 = v125;
          }
          v116 += 8;
          unint64_t v117 = v119;
        }
        while (v114 != v119);
      }
      swift_bridgeObjectRelease(v94);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v127 = 0xE000000000000000;
      if (v35 & 0x8080808080808080 | v105 & 0x80808080808080) {
        unint64_t v127 = 0xA000000000000000;
      }
      unint64_t v32 = v127 & 0xFF00000000000000 | (v115 << 56) | v105 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v235 = v35;
LABEL_14:
      unint64_t v236 = v32;
      a2 = v225;
      goto LABEL_15;
    }
    int64_t v128 = _StringGuts.nativeUnusedCapacity.getter(v35, v94);
    uint64_t v4 = (v129 & 1) == 0 && v128 > 1;
    if ((v24 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v94 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v4) {
        goto LABEL_138;
      }
LABEL_131:
      uint64_t v132 = _StringGuts.nativeCapacity.getter(v35, v94);
      if (v133) {
        uint64_t v134 = 0;
      }
      else {
        uint64_t v134 = v132;
      }
      if (v134 + 0x4000000000000000 < 0) {
        goto LABEL_252;
      }
      uint64_t v135 = 2 * v134;
      if (v135 > v102) {
        Swift::Int v102 = v135;
      }
      goto LABEL_137;
    }
    if ((v4 & 1) == 0) {
      goto LABEL_131;
    }
LABEL_137:
    _StringGuts.grow(_:)(v102);
LABEL_138:
    swift_bridgeObjectRelease_n(0xE200000000000000, 6);
    long long v234 = v210;
    uint64_t v136 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v234, 2);
    _StringGuts.appendInPlace(_:isASCII:)(v136, v137, 1);
    swift_bridgeObjectRelease(0xE200000000000000);
    a2 = v225;
LABEL_16:
    uint64_t v4 = (uint64_t)swift_initStackObject(v91, &v232);
    *(_OWORD *)(v4 + 16) = v228;
    uint64_t v33 = v231;
    *(void *)(v4 + 56) = v231;
    uint64_t v34 = (char *)__swift_allocate_boxed_opaque_existential_0Tm((void *)(v4 + 32));
    v226(v34, v230, v33);
    specialized _debugPrint<A>(_:separator:terminator:to:)(v4, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v235);
    swift_bridgeObjectRelease(v4);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    char v31 = 0;
    uint64_t v24 = v227;
  }
  outlined consume of [A : B].Iterator._Variant<A, B>(v221);
  uint64_t v24 = v235;
  uint64_t v4 = v236;
  unint64_t v35 = HIBYTE(v236) & 0xF;
  uint64_t v30 = v235 & 0xFFFFFFFFFFFFLL;
  if ((v236 & 0x2000000000000000) != 0) {
    unint64_t v155 = HIBYTE(v236) & 0xF;
  }
  else {
    unint64_t v155 = v235 & 0xFFFFFFFFFFFFLL;
  }
  if (!v155 && (v235 & ~v236 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v236);
    unint64_t v236 = 0xE100000000000000;
    return 93;
  }
  if ((v236 & 0x2000000000000000) == 0 || v35 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v4 & 0x1000000000000000) != 0) {
      goto LABEL_253;
    }
    BOOL v60 = __OFADD__(v155, 1);
    uint64_t v164 = v155 + 1;
    if (v60) {
      goto LABEL_255;
    }
LABEL_199:
    uint64_t v165 = v24 & ~v4;
    if ((v165 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v166 = _StringGuts.nativeUnusedCapacity.getter(v24, v4);
      if (v167)
      {
LABEL_266:
        unint64_t v203 = 258;
LABEL_267:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v203, 0);
      }
      if (v164 > 15) {
        goto LABEL_205;
      }
      if ((v4 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        goto LABEL_217;
      }
      if (v166 > 0)
      {
LABEL_205:
        int64_t v168 = _StringGuts.nativeUnusedCapacity.getter(v24, v4);
        BOOL v171 = (v169 & 1) == 0 && v168 > 0;
        if ((v165 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v171) {
            goto LABEL_244;
          }
        }
        else if (v171)
        {
LABEL_243:
          _StringGuts.grow(_:)(v164);
LABEL_244:
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v234 = xmmword_18162ACA0;
          char v196 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v234, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v196, v197, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v235;
        }
        uint64_t v192 = _StringGuts.nativeCapacity.getter(v24, v4);
        if (v193) {
          uint64_t v194 = 0;
        }
        else {
          uint64_t v194 = v192;
        }
        if (v194 + 0x4000000000000000 >= 0)
        {
          uint64_t v195 = 2 * v194;
          if (v195 > v164) {
            uint64_t v164 = v195;
          }
          goto LABEL_243;
        }
        __break(1u);
        goto LABEL_265;
      }
    }
    else if (v164 > 15)
    {
      goto LABEL_205;
    }
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    if ((v4 & 0x2000000000000000) == 0)
    {
      if ((v4 & 0x1000000000000000) != 0)
      {
        uint64_t v24 = _StringGuts._foreignConvertedToSmall()(v24, v4);
        uint64_t v30 = v206;
      }
      else
      {
        if ((v24 & 0x1000000000000000) != 0)
        {
          v202 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          v202 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v24, v4);
          uint64_t v30 = v207;
        }
        swift_bridgeObjectRetain(v4);
        closure #1 in _StringGuts._convertedToSmall()(v202, v30, &v234);
        swift_bridgeObjectRelease(v4);
        uint64_t v30 = *((void *)&v234 + 1);
        uint64_t v24 = v234;
      }
      goto LABEL_218;
    }
LABEL_217:
    uint64_t v30 = v4;
LABEL_218:
    v172._rawBits = 65537;
    v173._rawBits = 1;
    v174._rawBits = _StringGuts.validateScalarRange(_:)(v173, v172, 0x5DuLL, 0xE100000000000000);
    if (v174._rawBits < 0x10000) {
      v174._rawBits |= 3;
    }
    unint64_t v35 = specialized String.init(_:)(v174, v175, 0x5DuLL, 0xE100000000000000);
    uint64_t v164 = v176;
    swift_bridgeObjectRelease(0xE100000000000000);
    if ((v164 & 0x2000000000000000) == 0) {
      goto LABEL_256;
    }
    swift_bridgeObjectRelease(v164);
LABEL_222:
    uint64_t v177 = HIBYTE(v30) & 0xF;
    uint64_t v178 = HIBYTE(v164) & 0xF;
    uint64_t v179 = v178 + v177;
    if ((unint64_t)(v178 + v177) <= 0xF)
    {
      if (v178)
      {
        char v180 = 0;
        unint64_t v181 = 0;
        do
        {
          unint64_t v182 = v177 + v181;
          unint64_t v183 = v181 + 1;
          if (v181 >= 8) {
            unint64_t v184 = v164;
          }
          else {
            unint64_t v184 = v35;
          }
          unint64_t v185 = v184 >> (v180 & 0x38);
          char v186 = (8 * v177 + v180) & 0x38;
          uint64_t v187 = (-255 << v186) - 1;
          unint64_t v188 = (unint64_t)v185 << v186;
          unint64_t v189 = v188 | v187 & v30;
          unint64_t v190 = v188 | v187 & v24;
          if (v182 < 8) {
            uint64_t v24 = v190;
          }
          else {
            uint64_t v30 = v189;
          }
          v180 += 8;
          unint64_t v181 = v183;
        }
        while (v178 != v183);
      }
      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0xE100000000000000);
      unint64_t v191 = 0xA000000000000000;
      if (!(v24 & 0x8080808080808080 | v30 & 0x80808080808080)) {
        unint64_t v191 = 0xE000000000000000;
      }
      unint64_t v163 = v191 & 0xFF00000000000000 | (v179 << 56) | v30 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_235;
    }
LABEL_265:
    unint64_t v203 = 266;
    goto LABEL_267;
  }
  unint64_t v156 = 8 * (HIBYTE(v236) & 7);
  uint64_t v157 = (-255 << v156) - 1;
  uint64_t v158 = 93 << v156;
  uint64_t v159 = v158 | v157 & v236;
  uint64_t v160 = v158 | v157 & v235;
  if (v35 >= 8) {
    unint64_t v161 = v159;
  }
  else {
    unint64_t v161 = v236;
  }
  if (v35 < 8) {
    uint64_t v24 = v160;
  }
  swift_bridgeObjectRelease(v236);
  swift_bridgeObjectRelease(0xE100000000000000);
  unint64_t v162 = 0xA000000000000000;
  if (!(v24 & 0x8080808080808080 | v161 & 0x80808080808080)) {
    unint64_t v162 = 0xE000000000000000;
  }
  unint64_t v163 = (v162 & 0xFF00000000000000 | (v35 << 56) | v161 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
LABEL_235:
  unint64_t v236 = v163;
  return v24;
}

uint64_t Dictionary.debugDescription.getter(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = (unint64_t *)type metadata accessor for Dictionary(0, a2, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A : B], v6, v7);
  return specialized Collection._makeKeyValuePairDescription<A, B>(withTypeName:)((uint64_t)v6, a2, a3, WitnessTable);
}

uint64_t static _MergeError.== infix(_:_:)()
{
  return 1;
}

void _MergeError.hash(into:)()
{
}

void protocol witness for Hashable.hash(into:) in conformance _MergeError()
{
}

uint64_t protocol witness for Error._domain.getter in conformance _MergeError(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError(a1, a2, &demangling cache variable for type metadata for _MergeError.Type);
}

uint64_t Error._domain.getter(uint64_t *a1)
{
  v5[0] = 0;
  v5[1] = 0xE000000000000000;
  unint64_t DynamicType = swift_getDynamicType(v1, a1, 0);
  MetatypeMetadata = (Class *)swift_getMetatypeMetadata((unint64_t)a1);
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&DynamicType, (uint64_t)v5, MetatypeMetadata, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  return v5[0];
}

uint64_t protocol witness for Error._code.getter in conformance _MergeError(void *a1)
{
  return _swift_stdlib_getDefaultErrorCode((uint64_t)a1, a1);
}

uint64_t Error._code.getter(void *a1)
{
  return _swift_stdlib_getDefaultErrorCode(v1, a1);
}

uint64_t protocol witness for Error._userInfo.getter in conformance _MergeError(uint64_t a1, uint64_t a2)
{
  return _swift_stdlib_getErrorDefaultUserInfo(a1, a1, a2);
}

uint64_t Error._userInfo.getter(uint64_t a1, uint64_t a2)
{
  return _swift_stdlib_getErrorDefaultUserInfo(v2, a1, a2);
}

unint64_t Dictionary.Index._variant.getter(unint64_t a1, uint64_t a2, char a3)
{
  return a1;
}

uint64_t Dictionary.Index._variant.setter(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  return Dictionary.Index._variant.setter(a1, a2, a3, a4, (uint64_t (*)(void, void, void))outlined consume of [A : B].Index._Variant<A, B>);
}

uint64_t (*Dictionary.Index._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Dictionary.Index._guaranteedNative.getter()
{
  return 0;
}

Swift::Bool __swiftcall Dictionary.Index._isUniquelyReferenced()()
{
  if ((*(unsigned char *)(v0 + 16) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  uint64_t v2 = *(void *)v0;
  uint64_t v1 = *(void *)(v0 + 8);
  if (*(uint64_t *)v0 >= 0) {
    uint64_t v3 = *(void *)v0 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v3 = *(void *)v0;
  }
  uint64_t v4 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v2);
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  Swift::Bool v5 = 1;
  outlined consume of [A : B].Index._Variant<A, B>(v2, v1, 1);
  if (v3) {
    return swift_isUniquelyReferenced_nonNull_native(v3);
  }
  return v5;
}

unint64_t Dictionary.Index._asCocoa.getter(unint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x73AuLL, 0);
  }
  return swift_bridgeObjectRetain(a1);
}

uint64_t __CocoaDictionary.Index.handleBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.handleBitPattern.getter(a1, a2, type metadata accessor for __CocoaDictionary.Index.Storage);
}

BOOL Dictionary.Index._isNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

void Dictionary.Index._asNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  if (a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x72DuLL, 0);
  }
}

uint64_t (*Dictionary.Index._asCocoa.modify(void *a1))(void)
{
  a1[2] = v1;
  if (*(unsigned char *)(v1 + 16) != 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x742uLL, 0);
  }
  uint64_t v2 = *(void *)(v1 + 8);
  *a1 = *(void *)v1;
  a1[1] = v2;
  *(unsigned char *)(v1 + 16) = 0;
  *(void *)uint64_t v1 = 0;
  *(void *)(v1 + 8) = 0;
  return Dictionary.Index._asCocoa.modify;
}

void Dictionary.Index._asCocoa.setter(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(v2 + 16) != 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/Dictionary.swift", 22, 2, 0x742uLL, 0);
  }
  outlined consume of [A : B].Index._Variant<A, B>(*(void *)v2, *(void *)(v2 + 8), 1);
  *(void *)uint64_t v2 = a1;
  *(void *)(v2 + 8) = a2;
  *(unsigned char *)(v2 + 16) = 1;
}

BOOL static Dictionary.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v7 = a4;
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0)
    {
      if (a2 != a5) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xD5uLL, 0);
      }
      return a1 == a4;
    }
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/Dictionary.swift", 22, 2, 0x75CuLL, 0);
  }
  if ((a6 & 1) == 0) {
    goto LABEL_20;
  }
  if (a1 >= 0) {
    uint64_t v10 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v10 = a1;
  }
  uint64_t v11 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v10, v11)) {
    goto LABEL_21;
  }
  if (v7 >= 0) {
    v7 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(v7, v11)) {
LABEL_21:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(void *)(v10 + 16) != *(void *)(v7 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x2A2uLL, 0);
  }
  return a2 == a5;
}

BOOL static _HashTable.Index.== infix(_:_:)(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a2 != a4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xD5uLL, 0);
  }
  return a1 == a3;
}

BOOL static Dictionary.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v7 = a4;
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0)
    {
      if (a2 != a5) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xE2uLL, 0);
      }
      return a1 < a4;
    }
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/Dictionary.swift", 22, 2, 0x770uLL, 0);
  }
  if ((a6 & 1) == 0) {
    goto LABEL_20;
  }
  if (a1 >= 0) {
    uint64_t v10 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v10 = a1;
  }
  uint64_t v11 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v10, v11)) {
    goto LABEL_21;
  }
  if (v7 >= 0) {
    v7 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(v7, v11)) {
LABEL_21:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(void *)(v10 + 16) != *(void *)(v7 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x2AFuLL, 0);
  }
  return a2 < a5;
}

BOOL static _HashTable.Index.< infix(_:_:)(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a2 != a4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xE2uLL, 0);
  }
  return a1 < a3;
}

void Dictionary.Index.hash(into:)(uint64_t a1, Swift::UInt a2, Swift::UInt a3, char a4)
{
  if (a4) {
    a2 = a3;
  }
  Hasher._combine(_:)(a4 & 1);
  Hasher._combine(_:)(a2);
}

Swift::Int Dictionary.Index.hashValue.getter(Swift::UInt a1, Swift::UInt a2, char a3)
{
  if (a3) {
    a1 = a2;
  }
  Hasher._combine(_:)(a3 & 1);
  Hasher._combine(_:)(a1);
  return Hasher._finalize()();
}

uint64_t Dictionary.Iterator._variant.getter@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for Dictionary.Iterator._Variant(0, a1[2], a1[3], a1[4]);
  Swift::Bool v5 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v4 - 1) + 2);

  return v5(a2, v2, v4);
}

__n128 Dictionary.Iterator._variant.setter(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = type metadata accessor for Dictionary.Iterator._Variant(0, a2[2], a2[3], a2[4]);
  (*((void (**)(_OWORD *, uint64_t, Class *))*(v4 - 1) + 4))(v9, a1, v4);
  __n128 v7 = (__n128)v9[1];
  __n128 v8 = (__n128)v9[0];
  unint64_t v5 = v10;
  outlined consume of [A : B].Iterator._Variant<A, B>(v2->n128_u64[0]);
  __n128 result = v7;
  *uint64_t v2 = v8;
  v2[1] = v7;
  v2[2].n128_u64[0] = v5;
  return result;
}

uint64_t (*Dictionary.Iterator._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

double Dictionary.Iterator.init(_variant:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  __n128 v7 = type metadata accessor for Dictionary.Iterator._Variant(0, a2, a3, a4);
  (*((void (**)(_OWORD *, uint64_t, Class *))*(v7 - 1) + 4))(v11, a1, v7);
  uint64_t v8 = v12;
  double result = *(double *)v11;
  long long v10 = v11[1];
  *(_OWORD *)a5 = v11[0];
  *(_OWORD *)(a5 + 16) = v10;
  *(void *)(a5 + 32) = v8;
  return result;
}

__n128 Dictionary.Iterator.init(_native:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v2;
  return result;
}

double Dictionary.Iterator.init(_cocoa:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = a1 | 0x8000000000000000;
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  return result;
}

uint64_t Dictionary.Iterator._guaranteedNative.getter()
{
  return 0;
}

BOOL Dictionary.Iterator._isNative.getter(uint64_t *a1)
{
  uint64_t v2 = type metadata accessor for Dictionary.Iterator._Variant(0, a1[2], a1[3], a1[4]);
  uint64_t v3 = (void (*)(unsigned char *, uint64_t, Class *))*((void *)*(v2 - 1) + 4);
  v3(v5, v1, v2);
  v3(v6, (uint64_t)v5, v2);
  return v6[0] >= 0;
}

void (*Dictionary.Iterator._asNative.modify(void *a1))(atomic_ullong ***a1, char a2)
{
  uint64_t v3 = malloc(0x30uLL);
  *a1 = v3;
  uint64_t v4 = *((void *)v1 + 4);
  long long v5 = *v1;
  long long v6 = v1[1];
  *uint64_t v3 = *v1;
  v3[1] = v6;
  *((void *)v3 + 4) = v4;
  *((void *)v3 + 5) = v1;
  swift_retain((atomic_ullong *)v5);
  return Dictionary.Iterator._asNative.modify;
}

void Dictionary.Iterator._asNative.modify(atomic_ullong ***a1, char a2)
{
}

atomic_ullong *Dictionary.Iterator._asCocoa.getter()
{
  return swift_retain((atomic_ullong *)(*v0 & 0x7FFFFFFFFFFFFFFFLL));
}

uint64_t _NativeDictionary.Iterator.next()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = result;
  unint64_t v5 = v2[4];
  if (!v5)
  {
    uint64_t v18 = v2[3];
    int64_t v19 = v18 + 1;
    if (__OFADD__(v18, 1))
    {
      __break(1u);
      return result;
    }
    int64_t v20 = (unint64_t)(v2[2] + 64) >> 6;
    if (v19 < v20)
    {
      v2[3] = v19;
      uint64_t v21 = v2[1];
      unint64_t v22 = *(void *)(v21 + 8 * v19);
      v2[4] = v22;
      if (v22)
      {
LABEL_11:
        v2[4] = (v22 - 1) & v22;
        unint64_t v6 = __clz(__rbit64(v22)) + (v19 << 6);
        goto LABEL_3;
      }
      uint64_t v23 = v18 + 2;
      while (v20 != v23)
      {
        v2[3] = v23;
        unint64_t v22 = *(void *)(v21 + 8 * v23);
        v2[4] = v22;
        ++v23;
        if (v22)
        {
          int64_t v19 = v23 - 1;
          goto LABEL_11;
        }
      }
    }
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, *(void *)(result + 16), *(void *)(result + 24), "key value ", 0);
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(TupleTypeMetadata2 - 1) + 56);
    uint64_t v17 = TupleTypeMetadata2;
    uint64_t v15 = a2;
    uint64_t v16 = 1;
    goto LABEL_13;
  }
  v2[4] = (v5 - 1) & v5;
  unint64_t v6 = __clz(__rbit64(v5)) | (v2[3] << 6);
LABEL_3:
  uint64_t v7 = *v2;
  uint64_t v8 = *(void *)(result + 16);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(a2, *(void *)(v7 + 48) + *(void *)(*(void *)(v8 - 8) + 72) * v6, v8);
  uint64_t v9 = *(void *)(v7 + 56);
  uint64_t v10 = *(void *)(v3 + 24);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = v9 + *(void *)(v11 + 72) * v6;
  uint64_t v13 = swift_getTupleTypeMetadata2(0, v8, v10, "key value ", 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 16))(a2 + *((int *)v13 + 12), v12, v10);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(v13 - 1) + 56);
  uint64_t v15 = a2;
  uint64_t v16 = 0;
  uint64_t v17 = v13;
LABEL_13:

  return v14(v15, v16, 1, v17);
}

uint64_t Dictionary.Iterator.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v5 = *(_OWORD *)(v2 + 16);
  v8[0] = *(_OWORD *)v2;
  v8[1] = v5;
  uint64_t v9 = *(void *)(v2 + 32);
  unint64_t v6 = type metadata accessor for Dictionary.Iterator._Variant(0, *(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32));
  (*((void (**)(void *, uint64_t, Class *))*(v6 - 1) + 4))(v10, v2, v6);
  outlined retain of [A : B].Iterator._Variant(v10, (void (*)(void, void, void, void, void))outlined copy of [A : B].Iterator._Variant<A, B>);
  return specialized Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)((uint64_t)v8, 8, 0, 0, (Class *)a1, a2);
}

uint64_t specialized Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, unint64_t a3@<X2>, uint64_t a4@<X3>, Class *a5@<X4>, uint64_t a6@<X8>)
{
  HIDWORD(v29) = a2;
  uint64_t v11 = (uint64_t)*(a5 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (unint64_t *)((char *)&v30[-1] - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  v30[0] = v15;
  v30[1] = v16;
  uint64_t v18 = static Mirror._superclassIterator<A>(_:_:)(v12, (uint64_t)v30, v17);
  uint64_t v20 = v19;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v21 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<EmptyCollection<(label: String?, value: Any)>>);
  unint64_t v22 = swift_allocObject(v21, 0x30uLL, 7uLL);
  uint64_t v23 = (unint64_t *)canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v24 = swift_allocObject(v23, 0x18uLL, 7uLL);
  v24[2] = 0;
  unint64_t v25 = swift_allocObject(v23, 0x18uLL, 7uLL);
  v25[2] = 0;
  v22[2] = v24;
  v22[3] = &protocol witness table for _IndexBox<A>;
  v22[4] = v25;
  v22[5] = &protocol witness table for _IndexBox<A>;
  (*(void (**)(unint64_t *, uint64_t, Class *))(v11 + 32))(v14, a1, a5);
  uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v30, v14, a5, v26, 6uLL);
  char v28 = result;
  if (result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  }
  *(void *)a6 = a5;
  *(void *)(a6 + 8) = v22;
  *(unsigned char *)(a6 + 16) = BYTE4(v29);
  *(void *)(a6 + 24) = v18;
  *(void *)(a6 + 32) = v20;
  *(unsigned char *)(a6 + 40) = v28;
  return result;
}

uint64_t Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 *a3@<X2>, unint64_t *a4@<X3>, swift *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, Class **a8@<X8>)
{
  unint64_t v48 = (Class *)a5;
  uint64_t v49 = a1;
  unint64_t v55 = a8;
  uint64_t v54 = *((void *)a5 - 1);
  MEMORY[0x1F4188790](a1);
  unint64_t v52 = (unint64_t *)((char *)&v46 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, v16, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v56 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v20 = (char *)&v46 - v19;
  int v53 = *a3;
  unint64_t v21 = *a4;
  uint64_t v22 = a4[1];
  v57[0] = v21;
  v57[1] = v22;
  uint64_t v23 = static Mirror._superclassIterator<A>(_:_:)(a1, (uint64_t)v57, a5);
  uint64_t v50 = v24;
  uint64_t v51 = v23;
  outlined consume of Mirror.AncestorRepresentation(v21, v22);
  uint64_t v26 = type metadata accessor for _CollectionBox(0, a6, a7, v25);
  uint64_t v27 = (Class *)swift_allocObject((unint64_t *)v26, *((unsigned int *)v26 + 12), *((unsigned __int16 *)v26 + 26));
  char v28 = (char *)v27 + *((void *)*v27 + 45);
  uint64_t v29 = *(void *)(a6 - 8);
  uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t))(v29 + 16);
  uint64_t v47 = a2;
  v30(v28, a2, a6);
  (*(void (**)(uint64_t, uint64_t))(a7 + 64))(a6, a7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v33 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v32);
  uint64_t v34 = (objc_class *)swift_allocObject((unint64_t *)v33, *((unsigned int *)v33 + 12), *((unsigned __int16 *)v33 + 26));
  unint64_t v35 = (char *)v34 + *(void *)(*(void *)v34 + 96);
  uint64_t v36 = *(void (**)(char *, char *, const char *))(v56 + 32);
  v56 += 32;
  v36(v35, v20, AssociatedTypeWitness);
  uint64_t v37 = v47;
  (*(void (**)(uint64_t, uint64_t))(a7 + 72))(a6, a7);
  (*(void (**)(uint64_t, uint64_t))(v29 + 8))(v37, a6);
  uint64_t v38 = v48;
  uint64_t v39 = (objc_class *)swift_allocObject((unint64_t *)v33, *((unsigned int *)v33 + 12), *((unsigned __int16 *)v33 + 26));
  v36((char *)v39 + *(void *)(*(void *)v39 + 96), v20, AssociatedTypeWitness);
  v27[2] = v34;
  uint64_t v27[3] = (Class)&protocol witness table for _IndexBox<A>;
  v27[4] = v39;
  v27[5] = (Class)&protocol witness table for _IndexBox<A>;
  id v40 = v52;
  (*(void (**)(unint64_t *, uint64_t, Class *))(v54 + 32))(v52, v49, v38);
  uint64_t v41 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v57, v40, v38, v41, 6uLL);
  char v43 = result;
  if (result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v57);
  }
  long long v44 = v55;
  *unint64_t v55 = v38;
  v44[1] = v27;
  *((unsigned char *)v44 + 16) = v53;
  uint64_t v45 = v50;
  v44[3] = (Class *)v51;
  v44[4] = v45;
  *((unsigned char *)v44 + 40) = v43;
  return result;
}

uint64_t Dictionary.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, Class **a5@<X8>)
{
  uint64_t v13 = a1;
  uint64_t v14 = a1;
  unsigned __int8 v12 = 6;
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v7 = (unint64_t *)type metadata accessor for Dictionary(0, a2, a3, a4);
  swift_bridgeObjectRetain_n(a1, 2);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A : B], v7, v8);
  return Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)((uint64_t)&v14, (uint64_t)&v13, &v12, v11, (swift *)v7, (uint64_t)v7, WitnessTable, a5);
}

uint64_t Dictionary.popFirst()@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v6 = a1[2];
  if ((*v2 & 0xC000000000000001) != 0)
  {
    if (v5 < 0) {
      uint64_t v7 = (void *)*v2;
    }
    else {
      uint64_t v7 = (void *)(v5 & 0xFFFFFFFFFFFFFF8);
    }
    id v8 = [v7 count];
  }
  else
  {
    id v8 = *(id *)(v5 + 16);
  }
  uint64_t v9 = a1[3];
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v9, "key value ", 0);
  uint64_t v11 = TupleTypeMetadata2;
  if (v8)
  {
    uint64_t v12 = a2 + *((int *)TupleTypeMetadata2 + 12);
    uint64_t v13 = a1[4];
    uint64_t v14 = Dictionary.startIndex.getter(v5);
    uint64_t v16 = v15;
    char v18 = v17 & 1;
    uint64_t v19 = type metadata accessor for Dictionary._Variant(0, v6, v9, v13);
    Dictionary._Variant.remove(at:)(a2, v12, v14, v16, v18, (uint64_t)v19);
    outlined consume of [A : B].Index._Variant<A, B>(v14, v16, v18);
    uint64_t v20 = 0;
  }
  else
  {
    uint64_t v20 = 1;
  }
  unint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(v11 - 1) + 56);

  return v21(a2, v20, 1, v11);
}

id Dictionary.capacity.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return *(id *)(a1 + 24);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return [a1 count];
}

id Dictionary._Variant.capacity.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001) == 0) {
    return *(id *)(a1 + 24);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return [a1 count];
}

Swift::Void __swiftcall Dictionary.reserveCapacity(_:)(Swift::Int a1)
{
  type metadata accessor for Dictionary._Variant(0, v1[2], v1[3], v1[4]);

  Dictionary._Variant.reserveCapacity(_:)(a1);
}

Swift::Void __swiftcall Dictionary._Variant.reserveCapacity(_:)(Swift::Int a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v6 = *v2;
  id v8 = *(char **)(v1 + 16);
  uint64_t v7 = *(uint64_t **)(v1 + 24);
  if ((v6 & 0xC000000000000001) != 0)
  {
    if (v6 < 0) {
      uint64_t v9 = (void *)v6;
    }
    else {
      uint64_t v9 = (void *)(v6 & 0xFFFFFFFFFFFFFF8);
    }
    id v10 = [v9 count];
    if ((uint64_t)v10 <= a1) {
      Swift::Int v11 = a1;
    }
    else {
      Swift::Int v11 = (Swift::Int)v10;
    }
    *uint64_t v3 = (uint64_t)_NativeDictionary.init(_:capacity:)(v9, v11, v8, v7, *(void *)(v4 + 32));
  }
  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v6);
    BOOL v13 = isUniquelyReferenced_nonNull_native;
    uint64_t v16 = *v3;
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    if (*(void *)(v14 + 24) >= a1)
    {
      if (!isUniquelyReferenced_nonNull_native)
      {
        type metadata accessor for _NativeDictionary(0, (uint64_t)v8, (uint64_t)v7, *(void *)(v4 + 32));
        _NativeDictionary.copy()();
      }
    }
    else
    {
      type metadata accessor for _NativeDictionary(0, (uint64_t)v8, (uint64_t)v7, *(void *)(v4 + 32));
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(a1, v13);
    }
    uint64_t v15 = *v3;
    *uint64_t v3 = v16;
    swift_bridgeObjectRelease(v15);
  }
}

__objc2_class **_NativeDictionary.bridged()(__objc2_class **a1, uint64_t *a2, void *a3, uint64_t a4)
{
  if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
    swift_once(&one-time initialization token for _bridgeInitializedSuccessfully, (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully, a3);
  }
  if (!_bridgeInitializedSuccessfully) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0x82uLL, 0);
  }
  _orphanedFoundationSubclassesReparented = 1;
  if (a1 == &_swiftEmptyDictionarySingleton)
  {
    a1 = &_swiftEmptyDictionarySingleton;
    swift_release((uint64_t)&_swiftEmptyDictionarySingleton);
  }
  else if (a1[2])
  {
    if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
      && _swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      id v8 = type metadata accessor for _DictionaryStorage(0, (uint64_t)a2, (uint64_t)a3, a4);
      if (!swift_dynamicCastClass((uint64_t)a1, (uint64_t)v8)) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
      }
    }
    else
    {
      uint64_t v9 = (unint64_t *)type metadata accessor for _SwiftDeferredNSDictionary(0, (uint64_t)a2, (uint64_t)a3, a4);
      id v10 = swift_allocObject(v9, 0x28uLL, 7uLL);
      void v10[2] = 0;
      v10[3] = 0;
      v10[4] = a1;
      return (__objc2_class **)v10;
    }
  }
  else
  {
    swift_release((uint64_t)a1);
    return &_swiftEmptyDictionarySingleton;
  }
  return a1;
}

__objc2_class **static __RawDictionaryStorage.empty.getter()
{
  return &_swiftEmptyDictionarySingleton;
}

uint64_t _NativeDictionary.count.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void @objc _SwiftDictionaryNSEnumerator.init()()
{
}

uint64_t _NativeDictionary.hashTable.getter(uint64_t a1)
{
  return a1 + 64;
}

unint64_t _HashTable.startBucket.getter(unint64_t *a1, unint64_t a2)
{
  unint64_t result = a2 + 1;
  if (a2 <= 0xFFFFFFFFFFFFFFBFLL)
  {
    unint64_t v4 = *a1;
    if (*a1)
    {
      uint64_t v5 = 0;
      return __clz(__rbit64(v4)) + v5;
    }
    unint64_t v6 = a2 + 64;
    if (a2 + 64 >= 0x80)
    {
      unint64_t v4 = a1[1];
      if (v4)
      {
        uint64_t v5 = 64;
        return __clz(__rbit64(v4)) + v5;
      }
      uint64_t v7 = v6 >> 6;
      if (v6 >> 6 <= 2) {
        uint64_t v7 = 2;
      }
      uint64_t v8 = v7 - 2;
      uint64_t v9 = a1 + 2;
      uint64_t v5 = 64;
      while (v8)
      {
        unint64_t v10 = *v9++;
        unint64_t v4 = v10;
        --v8;
        v5 += 64;
        if (v10) {
          return __clz(__rbit64(v4)) + v5;
        }
      }
    }
  }
  return result;
}

uint64_t _HashTable.endBucket.getter(uint64_t a1, uint64_t a2)
{
  return a2 + 1;
}

void *_SwiftDictionaryNSEnumerator.init(_:)(uint64_t a1)
{
  uint64_t v2 = v1;
  v2[3] = 0;
  unint64_t v4 = *(atomic_ullong **)(a1 + 32);
  v2[2] = v4;
  uint64_t v5 = swift_retain(v4);
  unint64_t v6 = _SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v5);
  swift_release(a1);
  uint64_t v7 = v2[3];
  v2[3] = v6;
  swift_release(v7);
  uint64_t v8 = v2[2];
  uint64_t v9 = -1 << *(unsigned char *)(v8 + 32);
  v2[4] = _HashTable.startBucket.getter((unint64_t *)(v8 + 64), ~v9);
  v2[5] = -v9;
  return v2;
}

void *_SwiftDeferredNSDictionary.bridgeKeys()(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(*v1 + 96);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  unint64_t v6 = (id *)((char *)&v34 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v43 = v5;
  MEMORY[0x1F4188790](v4);
  uint64_t v8 = (id *)((char *)&v34 - v7);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2)) {
    return 0;
  }
  uint64_t v9 = (void *)atomic_load(v1 + 2);
  if (v9)
  {
    uint64_t v10 = type metadata accessor for __BridgingHashBuffer(0);
    id v11 = swift_unknownObjectRetain(v9);
    if (!swift_dynamicCastClass((uint64_t)v11, v10)) {
      goto LABEL_35;
    }
    return v9;
  }
  unint64_t v35 = v6;
  uint64_t v12 = v1[4];
  uint64_t v13 = -1 << *(unsigned char *)(v12 + 32);
  uint64_t v14 = (unint64_t *)type metadata accessor for __BridgingHashBuffer(0);
  uint64_t v15 = swift_allocObject(v14, 40 - 8 * v13, 7uLL);
  _OWORD v15[2] = v12;
  v15[3] = v12 + 64;
  uint64_t v40 = v12 + 64;
  v15[4] = ~v13;
  uint64_t v16 = v12;
  swift_retain((atomic_ullong *)v12);
  uint64_t v36 = v14;
  if (!swift_dynamicCastClass((uint64_t)v15, (uint64_t)v14)) {
    goto LABEL_35;
  }
  if (-v13 < 64) {
    uint64_t v17 = ~(-1 << -(char)v13);
  }
  else {
    uint64_t v17 = -1;
  }
  unint64_t v18 = *(void *)(v12 + 64) & v17;
  uint64_t v34 = (void (**)(id *, id *, uint64_t *))(v3 + 32);
  uint64_t v37 = v15;
  uint64_t v41 = v15 + 5;
  uint64_t v42 = v3 + 16;
  uint64_t v38 = v16;
  int64_t v39 = (unint64_t)(63 - v13) >> 6;
  swift_retain_n(v16, 2);
  int64_t v19 = 0;
  while (1)
  {
    if (v18)
    {
      unint64_t v20 = __clz(__rbit64(v18));
      v18 &= v18 - 1;
      unint64_t v21 = v20 | (v19 << 6);
      goto LABEL_23;
    }
    if (__OFADD__(v19++, 1)) {
      goto LABEL_34;
    }
    if (v19 >= v39) {
      break;
    }
    unint64_t v23 = *(void *)(v40 + 8 * v19);
    if (!v23)
    {
      int64_t v24 = v19 + 1;
      if (v19 + 1 >= v39) {
        break;
      }
      unint64_t v23 = *(void *)(v40 + 8 * v24);
      if (!v23)
      {
        while (1)
        {
          int64_t v19 = v24 + 1;
          if (__OFADD__(v24, 1)) {
            break;
          }
          if (v19 >= v39) {
            goto LABEL_27;
          }
          unint64_t v23 = *(void *)(v40 + 8 * v19);
          ++v24;
          if (v23) {
            goto LABEL_22;
          }
        }
        __break(1u);
LABEL_34:
        __break(1u);
LABEL_35:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
      }
      ++v19;
    }
LABEL_22:
    unint64_t v18 = (v23 - 1) & v23;
    unint64_t v21 = __clz(__rbit64(v23)) + (v19 << 6);
LABEL_23:
    (*(void (**)(id *, unint64_t, uint64_t *))(v3 + 16))(v8, *(void *)(v1[4] + 48) + *(void *)(v3 + 72) * v21, v2);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
    {
      if (v43 != 8) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
      id v25 = *v8;
      uint64_t v26 = v1;
      uint64_t v27 = *(void (**)(id *, uint64_t *))(v3 + 8);
      swift_unknownObjectRetain(*v8);
      v27(v8, v2);
      uint64_t v1 = v26;
      v41[v21] = (atomic_ullong)v25;
    }
    else
    {
      char v28 = v35;
      (*v34)(v35, v8, v2);
      uint64_t v29 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v28, v2);
      v41[v21] = (atomic_ullong)v29;
    }
  }
LABEL_27:
  swift_release_n(v38, 2);
  uint64_t v30 = v37;
  swift_retain(v37);
  uint64_t v31 = 0;
  atomic_compare_exchange_strong((atomic_ullong *volatile)v1 + 2, (unint64_t *)&v31, (unint64_t)v30);
  if (v31) {
    swift_release((uint64_t)v30);
  }
  swift_release((uint64_t)v30);
  uint64_t v9 = (void *)atomic_load(v1 + 2);
  if (!v9) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0xEEuLL, 0);
  }
  id v32 = swift_unknownObjectRetain(v9);
  if (!swift_dynamicCastClass((uint64_t)v32, (uint64_t)v36)) {
    goto LABEL_35;
  }
  return v9;
}

Swift::Bool __swiftcall _HashTable.isOccupied(_:)(Swift::_HashTable::Bucket a1)
{
  Swift::Int offset = a1.offset;
  LOBYTE(a1.offset) = 0;
  if ((offset & 0x8000000000000000) == 0 && v2 + 1 > offset) {
    a1.Swift::Int offset = (*(void *)(v1 + (((unint64_t)offset >> 3) & 0x1FFFFFFFFFFFFFF8)) >> offset) & 1;
  }
  return a1.offset;
}

uint64_t _NativeDictionary.uncheckedKey(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, *(void *)(a2 + 48) + *(void *)(*(void *)(a3 - 8) + 72) * a1);
}

atomic_ullong *_SwiftDictionaryNSEnumerator.nextObject()()
{
  uint64_t offset = v0[4].offset;
  if (offset == v0[5].offset) {
    return 0;
  }
  v0[4].uint64_t offset = _HashTable.occupiedBucket(after:)(v0[4]).offset;
  return _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
}

BOOL static _HashTable.Bucket.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.occupiedBucket(after:)(Swift::_HashTable::Bucket after)
{
  unint64_t v3 = (unint64_t)after.offset >> 6;
  if ((*(void *)(v1 + 8 * ((unint64_t)after.offset >> 6)) & (-2 << SLOBYTE(after.offset))) != 0) {
    return (Swift::_HashTable::Bucket)(__clz(__rbit64(*(void *)(v1 + 8 * ((unint64_t)after.offset >> 6)) & (-2 << SLOBYTE(after.offset)))) | after.offset & 0xFFFFFFFFFFFFFFC0);
  }
  unint64_t v5 = v3 + 1;
  result.uint64_t offset = v2 + 1;
  unint64_t v6 = (unint64_t)(v2 + 64) >> 6;
  if (v3 + 1 < v6)
  {
    unint64_t v7 = *(void *)(v1 + 8 * v5);
    if (v7)
    {
      return (Swift::_HashTable::Bucket)(__clz(__rbit64(v7)) + (v5 << 6));
    }
    else
    {
      unint64_t v8 = v3 + 2;
      while (v6 != v8)
      {
        unint64_t v7 = *(void *)(v1 + 8 * v8++);
        if (v7)
        {
          unint64_t v5 = v8 - 1;
          return (Swift::_HashTable::Bucket)(__clz(__rbit64(v7)) + (v5 << 6));
        }
      }
    }
  }
  return result;
}

id @objc _SwiftDictionaryNSEnumerator.nextObject()(atomic_ullong *a1, uint64_t a2)
{
  return @objc _SwiftDictionaryNSEnumerator.nextObject()(a1, a2, (uint64_t (*)(atomic_ullong *))_SwiftDictionaryNSEnumerator.nextObject());
}

uint64_t @objc _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return @objc _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t))specialized _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:));
}

uint64_t @objc _SwiftDictionaryNSEnumerator.init(coder:)(uint64_t a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDictionaryNSEnumerator.init(coder:)(a1, a2, a3, (uint64_t (*)(uint64_t, uint64_t, uint64_t))specialized _SwiftDictionaryNSEnumerator.init(coder:));
}

void @objc _SwiftDeferredNSDictionary.init(objects:forKeys:count:)()
{
}

id _stdlib_atomicLoadARCRef(object:)(unint64_t *a1)
{
  id result = (id)atomic_load(a1);
  if (result) {
    return swift_unknownObjectRetain(result);
  }
  return result;
}

BOOL _stdlib_atomicInitializeARCRef(object:desired:)(atomic_ullong *a1, void *a2)
{
  swift_unknownObjectRetain(a2);
  uint64_t v4 = 0;
  atomic_compare_exchange_strong(a1, (unint64_t *)&v4, (unint64_t)a2);
  BOOL v5 = v4 == 0;
  if (v4) {
    swift_unknownObjectRelease(a2);
  }
  return v5;
}

Swift::_HashTable::Bucket_optional __swiftcall _HashTable.Iterator.next()()
{
  unint64_t v1 = v0[3];
  if (!v1)
  {
    uint64_t v4 = v0[2];
    int64_t v5 = v4 + 1;
    if (__OFADD__(v4, 1))
    {
      __break(1u);
      goto LABEL_13;
    }
    int64_t v6 = (unint64_t)(v0[1] + 64) >> 6;
    if (v5 < v6)
    {
      v0[2] = v5;
      uint64_t v7 = *v0;
      unint64_t v8 = *(void *)(*v0 + 8 * v5);
      v0[3] = v8;
      if (v8)
      {
LABEL_10:
        Swift::Bool v2 = 0;
        v0[3] = (v8 - 1) & v8;
        Swift::Int v3 = __clz(__rbit64(v8)) + (v5 << 6);
        goto LABEL_13;
      }
      uint64_t v9 = v4 + 2;
      while (v6 != v9)
      {
        v0[2] = v9;
        unint64_t v8 = *(void *)(v7 + 8 * v9);
        v0[3] = v8;
        ++v9;
        if (v8)
        {
          int64_t v5 = v9 - 1;
          goto LABEL_10;
        }
      }
    }
    Swift::Int v3 = 0;
    Swift::Bool v2 = 1;
    goto LABEL_13;
  }
  Swift::Bool v2 = 0;
  v0[3] = (v1 - 1) & v1;
  Swift::Int v3 = __clz(__rbit64(v1)) | (v0[2] << 6);
LABEL_13:
  result.value.uint64_t offset = v3;
  result.is_nil = v2;
  return result;
}

void *_SwiftDeferredNSDictionary.bridgeValues()(uint64_t a1)
{
  Swift::Bool v2 = *(uint64_t **)(*v1 + 104);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  int64_t v6 = (id *)((char *)&v34 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v43 = v5;
  MEMORY[0x1F4188790](v4);
  unint64_t v8 = (id *)((char *)&v34 - v7);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2)) {
    return 0;
  }
  uint64_t v9 = (void *)atomic_load(v1 + 3);
  if (v9)
  {
    uint64_t v10 = type metadata accessor for __BridgingHashBuffer(0);
    id v11 = swift_unknownObjectRetain(v9);
    if (!swift_dynamicCastClass((uint64_t)v11, v10)) {
      goto LABEL_35;
    }
    return v9;
  }
  unint64_t v35 = v6;
  uint64_t v12 = v1[4];
  uint64_t v13 = -1 << *(unsigned char *)(v12 + 32);
  uint64_t v14 = (unint64_t *)type metadata accessor for __BridgingHashBuffer(0);
  uint64_t v15 = swift_allocObject(v14, 40 - 8 * v13, 7uLL);
  _OWORD v15[2] = v12;
  v15[3] = v12 + 64;
  uint64_t v40 = v12 + 64;
  v15[4] = ~v13;
  uint64_t v16 = v12;
  swift_retain((atomic_ullong *)v12);
  uint64_t v36 = v14;
  if (!swift_dynamicCastClass((uint64_t)v15, (uint64_t)v14)) {
    goto LABEL_35;
  }
  if (-v13 < 64) {
    uint64_t v17 = ~(-1 << -(char)v13);
  }
  else {
    uint64_t v17 = -1;
  }
  unint64_t v18 = *(void *)(v12 + 64) & v17;
  uint64_t v34 = (void (**)(id *, id *, uint64_t *))(v3 + 32);
  uint64_t v37 = v15;
  uint64_t v41 = v15 + 5;
  uint64_t v42 = v3 + 16;
  uint64_t v38 = v16;
  int64_t v39 = (unint64_t)(63 - v13) >> 6;
  swift_retain_n(v16, 2);
  int64_t v19 = 0;
  while (1)
  {
    if (v18)
    {
      unint64_t v20 = __clz(__rbit64(v18));
      v18 &= v18 - 1;
      unint64_t v21 = v20 | (v19 << 6);
      goto LABEL_23;
    }
    if (__OFADD__(v19++, 1)) {
      goto LABEL_34;
    }
    if (v19 >= v39) {
      break;
    }
    unint64_t v23 = *(void *)(v40 + 8 * v19);
    if (!v23)
    {
      int64_t v24 = v19 + 1;
      if (v19 + 1 >= v39) {
        break;
      }
      unint64_t v23 = *(void *)(v40 + 8 * v24);
      if (!v23)
      {
        while (1)
        {
          int64_t v19 = v24 + 1;
          if (__OFADD__(v24, 1)) {
            break;
          }
          if (v19 >= v39) {
            goto LABEL_27;
          }
          unint64_t v23 = *(void *)(v40 + 8 * v19);
          ++v24;
          if (v23) {
            goto LABEL_22;
          }
        }
        __break(1u);
LABEL_34:
        __break(1u);
LABEL_35:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
      }
      ++v19;
    }
LABEL_22:
    unint64_t v18 = (v23 - 1) & v23;
    unint64_t v21 = __clz(__rbit64(v23)) + (v19 << 6);
LABEL_23:
    (*(void (**)(id *, unint64_t, uint64_t *))(v3 + 16))(v8, *(void *)(v1[4] + 56) + *(void *)(v3 + 72) * v21, v2);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
    {
      if (v43 != 8) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
      id v25 = *v8;
      uint64_t v26 = v1;
      uint64_t v27 = *(void (**)(id *, uint64_t *))(v3 + 8);
      swift_unknownObjectRetain(*v8);
      v27(v8, v2);
      unint64_t v1 = v26;
      v41[v21] = (atomic_ullong)v25;
    }
    else
    {
      char v28 = v35;
      (*v34)(v35, v8, v2);
      uint64_t v29 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v28, v2);
      v41[v21] = (atomic_ullong)v29;
    }
  }
LABEL_27:
  swift_release_n(v38, 2);
  uint64_t v30 = v37;
  swift_retain(v37);
  uint64_t v31 = 0;
  atomic_compare_exchange_strong((atomic_ullong *volatile)v1 + 3, (unint64_t *)&v31, (unint64_t)v30);
  if (v31) {
    swift_release((uint64_t)v30);
  }
  swift_release((uint64_t)v30);
  uint64_t v9 = (void *)atomic_load(v1 + 3);
  if (!v9) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x102uLL, 0);
  }
  id v32 = swift_unknownObjectRetain(v9);
  if (!swift_dynamicCastClass((uint64_t)v32, (uint64_t)v36)) {
    goto LABEL_35;
  }
  return v9;
}

uint64_t _NativeDictionary.uncheckedValue(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, *(void *)(a2 + 56) + *(void *)(*(void *)(a3 - 8) + 72) * a1, a3);
}

atomic_ullong *_SwiftDeferredNSDictionary.object(forKey:)(void *a1)
{
  Swift::Bool v2 = v1;
  uint64_t v34 = *v1;
  uint64_t v4 = *(uint64_t **)(v34 + 104);
  uint64_t v33 = *(v4 - 1);
  MEMORY[0x1F4188790](a1);
  int64_t v6 = (id *)((char *)&v31 - v5);
  unint64_t v8 = *(char **)(v7 + 96);
  id v11 = type metadata accessor for Optional(0, (uint64_t)v8, v9, v10);
  uint64_t v12 = (uint64_t)*(v11 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v31 - v14;
  uint64_t v16 = *((void *)v8 - 1);
  MEMORY[0x1F4188790](v13);
  unint64_t v18 = (char *)&v31 - v17;
  _conditionallyBridgeFromObjectiveC<A>(_:_:)(a1, v8, v19, v15);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v16 + 48))(v15, 1, v8) == 1)
  {
    (*(void (**)(char *, Class *))(v12 + 8))(v15, v11);
    return 0;
  }
  id v32 = v6;
  uint64_t v20 = v33;
  (*(void (**)(char *, char *, char *))(v16 + 32))(v18, v15, v8);
  unint64_t v21 = (atomic_ullong *)v2[4];
  uint64_t v22 = *(void *)(v34 + 112);
  swift_retain(v21);
  unint64_t v23 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v18, (uint64_t)v8, v22);
  LOBYTE(v22) = v24;
  swift_release((uint64_t)v21);
  uint64_t v25 = (*(uint64_t (**)(char *, char *))(v16 + 8))(v18, v8);
  if ((v22 & 1) == 0) {
    return 0;
  }
  uint64_t v26 = _SwiftDeferredNSDictionary.bridgeValues()(v25);
  if (v26)
  {
    uint64_t v27 = (uint64_t)v26;
    char v28 = (atomic_ullong *)v26[v23 + 5];
    swift_unknownObjectRetain(v28);
    swift_release(v27);
  }
  else
  {
    uint64_t v30 = v32;
    (*(void (**)(id *, unint64_t, uint64_t *))(v20 + 16))(v32, *(void *)(v2[4] + 56) + *(void *)(v20 + 72) * v23, v4);
    char v28 = _bridgeAnythingToObjectiveC<A>(_:)(v30, v4);
    (*(void (**)(id *, uint64_t *))(v20 + 8))(v30, v4);
  }
  return v28;
}

id @objc _SwiftDeferredNSDictionary.object(forKey:)(atomic_ullong *a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDeferredNSDictionary.object(forKey:)(a1, a2, a3, (uint64_t (*)(void *))_SwiftDeferredNSDictionary.object(forKey:));
}

void *_SwiftDeferredNSDictionary.keyEnumerator()()
{
  atomic_ullong v1 = *v0;
  Swift::Bool v2 = *(uint64_t **)(*v0 + 96);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
  {
    atomic_ullong v3 = v0[4];
    uint64_t v4 = (unint64_t *)type metadata accessor for _SwiftDictionaryNSEnumerator(0, (uint64_t)v2, *(void *)(v1 + 104), *(void *)(v1 + 112));
    uint64_t v5 = swift_allocObject(v4, 0x30uLL, 7uLL);
    void v5[2] = v3;
    v5[3] = 0;
    uint64_t v6 = -1 << *(unsigned char *)(v3 + 32);
    v5[4] = _HashTable.startBucket.getter((unint64_t *)(v3 + 64), ~v6);
    v5[5] = -v6;
    swift_retain((atomic_ullong *)v3);
  }
  else
  {
    uint64_t v7 = (unint64_t *)type metadata accessor for _SwiftDictionaryNSEnumerator(0, (uint64_t)v2, *(void *)(v1 + 104), *(void *)(v1 + 112));
    uint64_t v5 = swift_allocObject(v7, 0x30uLL, 7uLL);
    unint64_t v8 = swift_retain(v0);
    _SwiftDictionaryNSEnumerator.init(_:)((uint64_t)v8);
  }
  return v5;
}

id @objc _SwiftDeferredNSDictionary.keyEnumerator()(atomic_ullong *a1, uint64_t a2)
{
  return @objc _SwiftDeferredNSDictionary.keyEnumerator()(a1, a2, (uint64_t (*)(atomic_ullong *))_SwiftDeferredNSDictionary.keyEnumerator());
}

void _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)(uint64_t a1, char *a2)
{
  uint64_t v105 = a1;
  Swift::String::Index v106 = a2;
  atomic_ullong v3 = *(uint64_t **)(*(void *)v2 + 104);
  uint64_t v98 = *(v3 - 1);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (id *)((char *)&v83 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v7 = MEMORY[0x1F4188790](v4);
  uint64_t v9 = (id *)((char *)&v83 - v8);
  uint64_t v96 = v10;
  uint64_t v11 = MEMORY[0x1F4188790](v7);
  char v100 = (id *)((char *)&v83 - v12);
  uint64_t v104 = v2;
  uint64_t v14 = *(uint64_t **)(v13 + 96);
  uint64_t v99 = *(v14 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  uint64_t v17 = (id *)((char *)&v83 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (id *)((char *)&v83 - v19);
  uint64_t v97 = v21;
  uint64_t v22 = MEMORY[0x1F4188790](v18);
  uint64_t v101 = (id *)((char *)&v83 - v24);
  if (v23 < 0) {
    goto LABEL_98;
  }
  if (!v23) {
    return;
  }
  uint64_t v102 = v23;
  uint64_t v25 = (char *)_SwiftDeferredNSDictionary.bridgeKeys()(v22);
  Swift::String::Index v107 = (char *)_SwiftDeferredNSDictionary.bridgeValues()((uint64_t)v25);
  if (!v106)
  {
    swift_release((uint64_t)v25);
    if (!v105)
    {
      uint64_t v81 = (uint64_t)v107;
      goto LABEL_86;
    }
    unint64_t v85 = v9;
    uint64_t v47 = *(void **)(v104 + 32);
    unint64_t v48 = v47 + 8;
    uint64_t v49 = 1 << *((unsigned char *)v47 + 32);
    uint64_t v50 = -1;
    if (v49 < 64) {
      uint64_t v50 = ~(-1 << v49);
    }
    unint64_t v51 = v50 & v47[8];
    int64_t v52 = (unint64_t)(v49 + 63) >> 6;
    Swift::String::Index v106 = v107 + 40;
    uint64_t v103 = v98 + 16;
    char v100 = (id *)(v98 + 32);
    uint64_t v101 = (id *)v47;
    int v53 = (void (**)(id *, uint64_t *))(v98 + 8);
    swift_retain_n((uint64_t)v47, 2);
    uint64_t v54 = 0;
    int64_t v55 = 0;
    uint64_t v56 = v102;
    while (1)
    {
      if (v51)
      {
        unint64_t v57 = __clz(__rbit64(v51));
        v51 &= v51 - 1;
        unint64_t v58 = v57 | (v55 << 6);
        if (v107) {
          goto LABEL_40;
        }
      }
      else
      {
        BOOL v38 = __OFADD__(v55++, 1);
        if (v38)
        {
          __break(1u);
LABEL_100:
          __break(1u);
          return;
        }
        if (v55 >= v52)
        {
LABEL_87:
          swift_release_n((uint64_t)v101, 2);
          uint64_t v81 = (uint64_t)v107;
LABEL_86:
          swift_release(v81);
          return;
        }
        unint64_t v60 = v48[v55];
        if (!v60)
        {
          int64_t v61 = v55 + 1;
          if (v55 + 1 >= v52) {
            goto LABEL_87;
          }
          unint64_t v60 = v48[v61];
          if (!v60)
          {
            while (1)
            {
              int64_t v55 = v61 + 1;
              if (__OFADD__(v61, 1)) {
                goto LABEL_95;
              }
              if (v55 >= v52) {
                goto LABEL_87;
              }
              unint64_t v60 = v48[v55];
              ++v61;
              if (v60) {
                goto LABEL_50;
              }
            }
          }
          ++v55;
        }
LABEL_50:
        unint64_t v51 = (v60 - 1) & v60;
        unint64_t v58 = __clz(__rbit64(v60)) + (v55 << 6);
        if (v107)
        {
LABEL_40:
          uint64_t v59 = *(void **)&v106[8 * v58];
          swift_unknownObjectRetain(v59);
          goto LABEL_54;
        }
      }
      (*(void (**)(id *, unint64_t, uint64_t *))(v98 + 16))(v6, *(void *)(*(void *)(v104 + 32) + 56) + *(void *)(v98 + 72) * v58, v3);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
      {
        if (v96 != 8) {
LABEL_91:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        uint64_t v59 = *v6;
        int64_t v62 = *v53;
        swift_unknownObjectRetain(*v6);
        v62(v6, v3);
        uint64_t v56 = v102;
      }
      else
      {
        char v63 = v85;
        ((void (*)(id *, id *, uint64_t *))*v100)(v85, v6, v3);
        uint64_t v59 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v63, v3);
      }
LABEL_54:
      if (v54 == 0x1000000000000000) {
        goto LABEL_94;
      }
      *(void *)(v105 + 8 * v54) = v59;
      swift_unknownObjectRelease(v59);
      if (++v54 == v56)
      {
        swift_release((uint64_t)v107);
        uint64_t v82 = v101;
        goto LABEL_89;
      }
    }
  }
  unint64_t v86 = v20;
  uint64_t v103 = (uint64_t)v25;
  if (!v105)
  {
    swift_release((uint64_t)v107);
    unint64_t v64 = *(id **)(v104 + 32);
    Swift::String::Index v65 = v25;
    Swift::String::Index v66 = v64 + 8;
    uint64_t v67 = 1 << *((unsigned char *)v64 + 32);
    uint64_t v68 = -1;
    if (v67 < 64) {
      uint64_t v68 = ~(-1 << v67);
    }
    unint64_t v69 = v68 & (unint64_t)v64[8];
    int64_t v70 = (unint64_t)(v67 + 63) >> 6;
    Swift::String::Index v107 = v65 + 40;
    uint64_t v105 = v99 + 16;
    uint64_t v98 = v99 + 32;
    char v100 = v64;
    uint64_t v101 = (id *)(v99 + 8);
    swift_retain_n((uint64_t)v64, 2);
    uint64_t v71 = 0;
    int64_t v72 = 0;
    uint64_t v73 = v102;
    while (1)
    {
      if (v69)
      {
        unint64_t v74 = __clz(__rbit64(v69));
        v69 &= v69 - 1;
        unint64_t v75 = v74 | (v72 << 6);
        if (v103) {
          goto LABEL_63;
        }
      }
      else
      {
        BOOL v38 = __OFADD__(v72++, 1);
        if (v38) {
          goto LABEL_100;
        }
        if (v72 >= v70)
        {
LABEL_88:
          swift_release_n((uint64_t)v100, 2);
          uint64_t v81 = v103;
          goto LABEL_86;
        }
        unint64_t v77 = (unint64_t)v66[v72];
        if (!v77)
        {
          int64_t v78 = v72 + 1;
          if (v72 + 1 >= v70) {
            goto LABEL_88;
          }
          unint64_t v77 = (unint64_t)v66[v78];
          if (!v77)
          {
            while (1)
            {
              int64_t v72 = v78 + 1;
              if (__OFADD__(v78, 1)) {
                break;
              }
              if (v72 >= v70) {
                goto LABEL_88;
              }
              unint64_t v77 = (unint64_t)v66[v72];
              ++v78;
              if (v77) {
                goto LABEL_74;
              }
            }
LABEL_96:
            __break(1u);
LABEL_97:
            __break(1u);
LABEL_98:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid count", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x13AuLL, 0);
          }
          ++v72;
        }
LABEL_74:
        unint64_t v69 = (v77 - 1) & v77;
        unint64_t v75 = __clz(__rbit64(v77)) + (v72 << 6);
        if (v103)
        {
LABEL_63:
          unint64_t v76 = *(void **)&v107[8 * v75];
          swift_unknownObjectRetain(v76);
          if (v71 == 0x1000000000000000) {
            goto LABEL_81;
          }
          goto LABEL_78;
        }
      }
      (*(void (**)(id *, unint64_t, uint64_t *))(v99 + 16))(v17, *(void *)(*(void *)(v104 + 32) + 48) + *(void *)(v99 + 72) * v75, v14);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v14, v14))
      {
        if (v97 != 8) {
          goto LABEL_91;
        }
        unint64_t v76 = *v17;
        unint64_t v79 = (void (*)(id *, uint64_t *))*v101;
        swift_unknownObjectRetain(*v17);
        v79(v17, v14);
        uint64_t v73 = v102;
        if (v71 == 0x1000000000000000)
        {
LABEL_81:
          __break(1u);
LABEL_82:
          swift_release_n((uint64_t)v87, 2);
          swift_release(v103);
          uint64_t v81 = (uint64_t)v107;
          goto LABEL_86;
        }
      }
      else
      {
        unint64_t v80 = v86;
        (*(void (**)(id *, id *, uint64_t *))v98)(v86, v17, v14);
        unint64_t v76 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v80, v14);
        if (v71 == 0x1000000000000000) {
          goto LABEL_81;
        }
      }
LABEL_78:
      *(void *)&v106[8 * v71] = v76;
      swift_unknownObjectRelease(v76);
      if (++v71 == v73)
      {
        swift_release(v103);
        uint64_t v82 = v100;
        goto LABEL_89;
      }
    }
  }
  unint64_t v85 = v9;
  uint64_t v26 = *(void *)(v104 + 32);
  uint64_t v27 = 1 << *(unsigned char *)(v26 + 32);
  uint64_t v28 = v26 + 64;
  uint64_t v29 = -1;
  if (v27 < 64) {
    uint64_t v29 = ~(-1 << v27);
  }
  unint64_t v30 = v29 & *(void *)(v26 + 64);
  uint64_t v94 = v25 + 40;
  uint64_t v91 = v99 + 16;
  int64_t v92 = (unint64_t)(v27 + 63) >> 6;
  unint64_t v84 = (void (**)(id *, id *, uint64_t *))(v99 + 32);
  unint64_t v93 = v107 + 40;
  uint64_t v89 = (void (**)(id *, uint64_t *))(v99 + 8);
  uint64_t v90 = v98 + 16;
  unint64_t v83 = (void (**)(id *, id *, uint64_t *))(v98 + 32);
  uint64_t v87 = (id *)v26;
  size_t v88 = (void (**)(id *, uint64_t *))(v98 + 8);
  swift_retain_n(v26, 2);
  uint64_t v31 = 0;
  int64_t v32 = 0;
  uint64_t v33 = v102;
  do
  {
    if (v30)
    {
      unint64_t v35 = __clz(__rbit64(v30));
      v30 &= v30 - 1;
      unint64_t v36 = v35 | (v32 << 6);
      if (v103) {
        goto LABEL_12;
      }
    }
    else
    {
      BOOL v38 = __OFADD__(v32++, 1);
      if (v38) {
        goto LABEL_97;
      }
      if (v32 >= v92) {
        goto LABEL_82;
      }
      unint64_t v39 = *(void *)(v28 + 8 * v32);
      if (!v39)
      {
        int64_t v40 = v32 + 1;
        if (v32 + 1 >= v92) {
          goto LABEL_82;
        }
        unint64_t v39 = *(void *)(v28 + 8 * v40);
        if (!v39)
        {
          while (1)
          {
            int64_t v32 = v40 + 1;
            if (__OFADD__(v40, 1)) {
              goto LABEL_93;
            }
            if (v32 >= v92) {
              goto LABEL_82;
            }
            unint64_t v39 = *(void *)(v28 + 8 * v32);
            ++v40;
            if (v39) {
              goto LABEL_23;
            }
          }
        }
        ++v32;
      }
LABEL_23:
      unint64_t v30 = (v39 - 1) & v39;
      unint64_t v36 = __clz(__rbit64(v39)) + (v32 << 6);
      if (v103)
      {
LABEL_12:
        uint64_t v37 = *(atomic_ullong **)&v94[8 * v36];
        swift_unknownObjectRetain(v37);
        if (v31 == 0x1000000000000000) {
          goto LABEL_92;
        }
        goto LABEL_27;
      }
    }
    (*(void (**)(id *, unint64_t, uint64_t *))(v99 + 16))(v101, *(void *)(*(void *)(v104 + 32) + 48) + *(void *)(v99 + 72) * v36, v14);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v14, v14))
    {
      if (v97 != 8) {
        goto LABEL_91;
      }
      uint64_t v41 = v101;
      uint64_t v37 = (atomic_ullong *)*v101;
      unint64_t v95 = v30;
      uint64_t v42 = *v89;
      swift_unknownObjectRetain(v37);
      v42(v41, v14);
      unint64_t v30 = v95;
      uint64_t v33 = v102;
      if (v31 != 0x1000000000000000) {
        goto LABEL_27;
      }
LABEL_92:
      __break(1u);
LABEL_93:
      __break(1u);
LABEL_94:
      __break(1u);
LABEL_95:
      __break(1u);
      goto LABEL_96;
    }
    uint64_t v45 = v86;
    (*v84)(v86, v101, v14);
    uint64_t v37 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v45, v14);
    if (v31 == 0x1000000000000000) {
      goto LABEL_92;
    }
LABEL_27:
    *(void *)&v106[8 * v31] = v37;
    swift_unknownObjectRelease(v37);
    if (v107)
    {
      uint64_t v34 = *(atomic_ullong **)&v93[8 * v36];
      swift_unknownObjectRetain(v34);
    }
    else
    {
      (*(void (**)(id *, unint64_t, uint64_t *))(v98 + 16))(v100, *(void *)(*(void *)(v104 + 32) + 56) + *(void *)(v98 + 72) * v36, v3);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
      {
        if (v96 != 8) {
          goto LABEL_91;
        }
        uint64_t v43 = v100;
        uint64_t v34 = (atomic_ullong *)*v100;
        long long v44 = *v88;
        swift_unknownObjectRetain(*v100);
        v44(v43, v3);
        uint64_t v33 = v102;
      }
      else
      {
        uint64_t v46 = v85;
        (*v83)(v85, v100, v3);
        uint64_t v34 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v46, v3);
      }
    }
    *(void *)(v105 + 8 * v31) = v34;
    swift_unknownObjectRelease(v34);
    ++v31;
  }
  while (v31 != v33);
  swift_release((uint64_t)v107);
  swift_release(v103);
  uint64_t v82 = v87;
LABEL_89:
  swift_release_n((uint64_t)v82, 2);
}

uint64_t @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)(a1, a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, uint64_t))_SwiftDeferredNSDictionary.getObjects(_:andKeys:count:));
}

uint64_t _convertInOutToPointerArgument<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

void @objc _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)(atomic_ullong *a1, int a2, int a3, void *aBlock)
{
  uint64_t v5 = _Block_copy(aBlock);
  swift_retain(a1);
  specialized _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)((uint64_t)v5);
  swift_release((uint64_t)a1);

  _Block_release(v5);
}

uint64_t @objc _SwiftDeferredNSDictionary.count.getter()
{
  return _SwiftDeferredNSDictionary.count.getter();
}

uint64_t _SwiftDeferredNSDictionary.count.getter()
{
  return *(void *)(*(void *)(v0 + 32) + 16);
}

uint64_t _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v55 = a2;
  uint64_t v5 = a1;
  uint64_t v6 = *(uint64_t **)(*v3 + 96);
  uint64_t v52 = *(v6 - 1);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (id *)((char *)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v51 = v8;
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v56 = (id *)((char *)&v36 - v11);
  int v53 = v3;
  uint64_t v12 = v3[4];
  uint64_t v13 = (unint64_t *)(v12 + 64);
  uint64_t v14 = -1 << *(unsigned char *)(v12 + 32);
  uint64_t v15 = *(void *)v10;
  long long v16 = *(_OWORD *)(v10 + 32);
  long long v44 = *(_OWORD *)(v10 + 48);
  long long v45 = v16;
  if (v15)
  {
    uint64_t v18 = *(void *)(v5 + 8);
    uint64_t v17 = *(Swift::UInt **)(v5 + 16);
    unint64_t v19 = *(void *)(v5 + 24);
    if (v55) {
      goto LABEL_3;
    }
  }
  else
  {
LABEL_31:
    unint64_t v31 = _HashTable.startBucket.getter(v13, ~v14);
    if ((v31 & 0x8000000000000000) != 0) {
      goto LABEL_40;
    }
    unint64_t v19 = v31;
    uint64_t v17 = &_fastEnumerationStorageMutationsTarget;
    uint64_t v15 = 1;
    uint64_t v18 = v55;
    if (v55)
    {
LABEL_3:
      if ((v19 & 0x8000000000000000) != 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      int64_t v20 = -v14;
      if (!(v19 + v14)) {
        goto LABEL_7;
      }
      if ((uint64_t)v19 >= v20)
      {
        swift_retain((atomic_ullong *)v12);
      }
      else if ((*(unint64_t *)((char *)v13 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v19))
      {
LABEL_7:
        uint64_t v41 = v18;
        uint64_t v42 = v17;
        uint64_t v43 = v15;
        unint64_t v39 = v9;
        uint64_t v46 = v12;
        uint64_t v21 = swift_retain((atomic_ullong *)v12);
        uint64_t v22 = (char *)_SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v21);
        if (a3 < 0) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
        }
        uint64_t v9 = (id *)v22;
        if (!a3) {
          goto LABEL_36;
        }
        uint64_t v40 = v5;
        uint64_t v5 = 0;
        uint64_t v54 = v22 + 40;
        uint64_t v49 = v52 + 16;
        unint64_t v36 = (void (**)(id *, id *, uint64_t *))(v52 + 32);
        unint64_t v48 = (void (**)(id *, uint64_t *))(v52 + 8);
        unint64_t v50 = (unint64_t)(63 - v14) >> 6;
        unint64_t v38 = v50 - 3;
        uint64_t v37 = v46 + 88;
        uint64_t v12 = v55;
        uint64_t v47 = -v14;
        while (1)
        {
          if (v19 == v20)
          {
            unint64_t v19 = v20;
            a3 = v5;
LABEL_35:
            uint64_t v5 = v40;
LABEL_36:
            uint64_t v32 = v46;
            swift_release((uint64_t)v9);
            swift_release(v32);
            if ((v19 & 0x8000000000000000) == 0)
            {
              uint64_t v33 = v41;
              *(void *)uint64_t v5 = v43;
              *(void *)(v5 + 8) = v33;
              *(void *)(v5 + 16) = v42;
              *(void *)(v5 + 24) = v19;
              long long v34 = v44;
              *(_OWORD *)(v5 + 32) = v45;
              *(_OWORD *)(v5 + 48) = v34;
              return a3;
            }
LABEL_40:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
          }
          if (v9)
          {
            uint64_t v14 = *(void *)&v54[8 * v19];
            swift_unknownObjectRetain((id)v14);
            if (v5 == 0x1000000000000000) {
              goto LABEL_30;
            }
          }
          else
          {
            (*(void (**)(id *, unint64_t, uint64_t *))(v52 + 16))(v56, *(void *)(v53[4] + 48) + *(void *)(v52 + 72) * v19, v6);
            if (_swift_isClassOrObjCExistentialType((uint64_t)v6, v6))
            {
              if (v51 != 8) {
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
              }
              uint64_t v23 = v13;
              uint64_t v24 = v56;
              uint64_t v14 = (uint64_t)*v56;
              uint64_t v25 = *v48;
              swift_unknownObjectRetain(*v56);
              uint64_t v26 = v24;
              uint64_t v13 = v23;
              uint64_t v9 = 0;
              int64_t v20 = v47;
              v25(v26, v6);
              uint64_t v12 = v55;
              if (v5 == 0x1000000000000000)
              {
LABEL_30:
                __break(1u);
                goto LABEL_31;
              }
            }
            else
            {
              unint64_t v30 = v39;
              (*v36)(v39, v56, v6);
              uint64_t v14 = (uint64_t)_bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v30, v6);
              if (v5 == 0x1000000000000000) {
                goto LABEL_30;
              }
            }
          }
          *(void *)(v12 + 8 * v5) = v14;
          swift_unknownObjectRelease((id)v14);
          unint64_t v27 = v19 >> 6;
          if ((v13[v19 >> 6] & (-2 << v19)) != 0)
          {
            unint64_t v19 = __clz(__rbit64(v13[v19 >> 6] & (-2 << v19))) | v19 & 0xFFFFFFFFFFFFFFC0;
          }
          else
          {
            unint64_t v28 = v27 + 1;
            unint64_t v19 = v20;
            if (v27 + 1 < v50)
            {
              unint64_t v29 = v13[v28];
              if (!v29)
              {
                unint64_t v28 = v27 + 2;
                unint64_t v19 = v20;
                if (v27 + 2 >= v50) {
                  goto LABEL_11;
                }
                unint64_t v29 = v13[v28];
                if (!v29)
                {
                  while (v38 != v27)
                  {
                    unint64_t v29 = *(void *)(v37 + 8 * v27++);
                    if (v29)
                    {
                      unint64_t v28 = v27 + 2;
                      goto LABEL_22;
                    }
                  }
                  unint64_t v19 = v20;
                  goto LABEL_11;
                }
              }
LABEL_22:
              unint64_t v19 = __clz(__rbit64(v29)) + (v28 << 6);
            }
          }
LABEL_11:
          if (++v5 == a3) {
            goto LABEL_35;
          }
        }
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid fast enumeration state", 30, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x195uLL, 0);
    }
  }
  return 0;
}

uint64_t @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)(a1, a2, a3, a4, a5, _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:));
}

void _SwiftDeferredNSDictionary.__allocating_init(coder:)()
{
}

uint64_t @objc _SwiftDeferredNSDictionary.init(coder:)(uint64_t a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDictionaryNSEnumerator.init(coder:)(a1, a2, a3, (uint64_t (*)(uint64_t, uint64_t, uint64_t))_SwiftDeferredNSDictionary.__allocating_init(coder:));
}

uint64_t @objc _SwiftDictionaryNSEnumerator.init(coder:)(uint64_t a1, uint64_t a2, void *a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v4 = *(void *)(*(void *)a1 + 96);
  uint64_t v5 = *(void *)(*(void *)a1 + 104);
  uint64_t v6 = *(void *)(*(void *)a1 + 112);
  swift_unknownObjectRetain(a3);

  return a4(v4, v5, v6);
}

uint64_t _SwiftDeferredNSDictionary.__ivar_destroyer()
{
  swift_unknownObjectRelease(*(id *)(v0 + 16));
  swift_unknownObjectRelease(*(id *)(v0 + 24));
  uint64_t v1 = *(void *)(v0 + 32);

  return swift_release(v1);
}

uint64_t __SwiftNativeNSDictionary.deinit()
{
  return v0;
}

void _SwiftDeferredNSDictionary.__deallocating_deinit()
{
  uint64_t v1 = *(void **)(v0 + 16);
  swift_retain((atomic_ullong *)v0);
  swift_unknownObjectRelease(v1);
  swift_unknownObjectRelease(*(id *)(v0 + 24));
  uint64_t v2 = *(void *)(v0 + 32);
  swift_release(v0);
  swift_release(v2);

  swift_deallocClassInstance(v0);
}

unint64_t *__CocoaDictionary.startIndex.getter(void *a1)
{
  unint64_t v2 = (unint64_t)[swift_unknownObjectRetain(a1) count];
  Swift::_HashTable::Bucket_optional result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v2 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v2, 24))
    {
      uint64_t v4 = swift_bufferAllocate(result, 8 * v2 + 24, 7uLL);
      v4[2] = v2;
      [a1 sel_getObjects_andKeys_count_:0, v4 + 3, v2];
      swift_unknownObjectRelease(a1);
      uint64_t v5 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v6 = swift_allocObject(v5, 0x20uLL, 7uLL);
      v6[2] = a1;
      v6[3] = v4;
      swift_unknownObjectRetain(a1);
      return v6;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

unint64_t *__CocoaDictionary.endIndex.getter(void *a1)
{
  unint64_t v2 = (unint64_t)[swift_unknownObjectRetain(a1) count];
  Swift::_HashTable::Bucket_optional result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v2 - 0x1000000000000000) >> 61 == 7)
  {
    if (!__OFADD__(8 * v2, 24))
    {
      uint64_t v4 = swift_bufferAllocate(result, 8 * v2 + 24, 7uLL);
      v4[2] = v2;
      [a1 sel_getObjects_andKeys_count_:0, v4 + 3, v2];
      swift_unknownObjectRelease(a1);
      uint64_t v5 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v6 = swift_allocObject(v5, 0x20uLL, 7uLL);
      v6[2] = a1;
      v6[3] = v4;
      swift_unknownObjectRetain(a1);
      return v6;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

unint64_t __CocoaDictionary.index(after:)(int64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v7 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v6, v7)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(void *)(v6 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E7uLL, 0);
  }
  if (*(void *)(*(void *)(v6 + 24) + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  return swift_bridgeObjectRetain(a1);
}

uint64_t __CocoaDictionary.formIndex(after:isUnique:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  if (*a1 < 0) {
    uint64_t v6 = *a1;
  }
  else {
    uint64_t v6 = *a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v7 = type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t result = swift_dynamicCastClass(v6, v7);
  if (!result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(void *)(v6 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E7uLL, 0);
  }
  if (v5 >= *(void *)(*(void *)(v6 + 24) + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  a1[1] = v5 + 1;
  return result;
}

void *__CocoaDictionary.index(forKey:)(void *a1, id a2)
{
  id v4 = [a2 objectForKey:a1];
  if (!v4) {
    return 0;
  }
  swift_unknownObjectRelease(v4);
  unint64_t v5 = (unint64_t)[swift_unknownObjectRetain(a2) count];
  uint64_t v6 = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if ((v5 - 0x1000000000000000) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_11;
  }
  if (__OFADD__(8 * v5, 24))
  {
LABEL_11:
    __break(1u);
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v7 = swift_bufferAllocate(v6, 8 * v5 + 24, 7uLL);
  v7[2] = v5;
  [a2 objectsAndKeys:0, v7 + 3, v5, nil];
  swift_unknownObjectRelease(a2);
  if ((v7[2] & 0x8000000000000000) != 0) {
    goto LABEL_12;
  }
  swift_unknownObjectRetain(v7);
  uint64_t v8 = 0;
  do
  {
    uint64_t v9 = v8 + 1;
    uint64_t v10 = (void *)v7[v8 + 3];
    swift_unknownObjectRetain(v10);
    char isEqual = swift_stdlib_NSObject_isEqual(a1, v10);
    swift_unknownObjectRelease(v10);
    uint64_t v8 = v9;
  }
  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v7);
  uint64_t v12 = (unint64_t *)type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v13 = swift_allocObject(v12, 0x20uLL, 7uLL);
  v13[2] = a2;
  v13[3] = v7;
  swift_unknownObjectRetain(a2);
  return v13;
}

id __CocoaDictionary.lookup(_:)(uint64_t a1, id a2)
{
  id v2 = [a2 objectForKey:a1];

  return v2;
}

BOOL __CocoaDictionary.contains(_:)(uint64_t a1, void *a2)
{
  return __CocoaDictionary.contains(_:)(a1, a2, (SEL *)&selRef_objectForKey_);
}

void *__CocoaDictionary.lookup(_:)(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1 < 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6)) {
    goto LABEL_10;
  }
  if (*(void **)(v5 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x21CuLL, 0);
  }
  uint64_t v7 = *(void **)(*(void *)(v5 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v7);
  if (!swift_dynamicCastClass(v5, v6)) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (!objc_msgSend(a3, sel_objectForKey_, v7)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x21EuLL, 0);
  }
  return v7;
}

id __CocoaDictionary.key(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  atomic_ullong v3 = (void *)specialized __CocoaDictionary.key(at:)(a1, a2, a3);

  return swift_unknownObjectRetain(v3);
}

id __CocoaDictionary.Index.key.getter(uint64_t a1, uint64_t a2)
{
  id v2 = (void *)specialized __CocoaDictionary.Index.key.getter(a1, a2);

  return swift_unknownObjectRetain(v2);
}

id __CocoaDictionary.value(at:)(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1 < 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6)) {
    goto LABEL_10;
  }
  if (*(void **)(v5 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x22CuLL, 0);
  }
  uint64_t v7 = *(void **)(*(void *)(v5 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v7);
  if (!swift_dynamicCastClass(v5, v6)) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  id v8 = [a3 objectForKey:v7];
  swift_unknownObjectRelease(v7);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x22EuLL, 0);
  }
  return v8;
}

__objc2_class **__CocoaDictionary.mapValues<A, B, C>(_:)(void (*a1)(char *), uint64_t a2, Class *a3, uint64_t *a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v91 = a1;
  uint64_t v92 = a2;
  MEMORY[0x1F4188790](a1);
  uint64_t v15 = (char *)&v68 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v82 = type metadata accessor for Optional(0, v18, v16, v17);
  uint64_t v89 = (void (**)(char *, char *))*(v82 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v82);
  uint64_t v21 = (char *)&v68 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v68 - v23;
  uint64_t v87 = (__objc2_class **)*((void *)a5 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v90 = (char *)&v68 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v80 = type metadata accessor for Optional(0, (uint64_t)a4, v26, v27);
  unint64_t v93 = (void (**)(void, void, void))*(v80 - 1);
  uint64_t v28 = MEMORY[0x1F4188790](v80);
  int64_t v78 = (char *)&v68 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  unint64_t v83 = (uint64_t *)((char *)&v68 - v31);
  uint64_t v84 = *(a4 - 1);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v95 = (uint64_t)&v68 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v32);
  uint64_t v94 = (char *)&v68 - v34;
  size_t v88 = a3;
  id v35 = [(Class *)a3 count];
  unint64_t v79 = v21;
  uint64_t v81 = v24;
  if (v35)
  {
    uint64_t v36 = (uint64_t)v35;
    type metadata accessor for _DictionaryStorage(0, (uint64_t)a4, a6, a7);
    uint64_t v37 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(v36);
  }
  else
  {
    uint64_t v37 = &_swiftEmptyDictionarySingleton;
  }
  uint64_t v99 = v37;
  unint64_t v38 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
  unint64_t v39 = swift_allocObject(v38, 0xE8uLL, 7uLL);
  *((_OWORD *)v39 + 1) = 0u;
  unint64_t v86 = v39 + 2;
  *((_OWORD *)v39 + 5) = 0u;
  unint64_t v85 = v39 + 10;
  v39[27] = 0;
  uint64_t v96 = v39 + 27;
  *((_OWORD *)v39 + 2) = 0u;
  *((_OWORD *)v39 + 3) = 0u;
  *((_OWORD *)v39 + 4) = 0u;
  *((_OWORD *)v39 + 6) = 0u;
  *((_OWORD *)v39 + 7) = 0u;
  *((_OWORD *)v39 + 8) = 0u;
  *((_OWORD *)v39 + 9) = 0u;
  uint64_t v40 = v84;
  unint64_t v77 = (void (**)(void *, uint64_t, uint64_t, uint64_t *))(v84 + 56);
  unint64_t v76 = (void (**)(char *, void *, Class *))(v93 + 2);
  unint64_t v75 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v84 + 48);
  unint64_t v74 = (void (**)(void *, Class *))(v93 + 1);
  *((_OWORD *)v39 + 10) = 0u;
  *((_OWORD *)v39 + 11) = 0u;
  unint64_t v93 = (void (**)(void, void, void))(v40 + 32);
  uint64_t v41 = v87;
  uint64_t v73 = (void (**)(void *, uint64_t, uint64_t, char *))(v87 + 7);
  *((_OWORD *)v39 + 12) = 0u;
  uint64_t v42 = v89;
  int64_t v72 = (void (**)(char *, void *, Class *))(v89 + 2);
  uint64_t v71 = (unsigned int (**)(char *, uint64_t, char *))(v41 + 6);
  v39[28] = 0;
  int64_t v70 = (void (**)(void *, Class *))(v42 + 1);
  unint64_t v69 = (void (**)(char *, char *, char *))(v41 + 4);
  uint64_t v89 = (void (**)(char *, char *))(v41 + 1);
  uint64_t v43 = v88;
  v39[26] = v88;
  swift_unknownObjectRetain(v43);
  uint64_t v44 = 0;
  size_t v88 = qword_1ECA06328;
  unint64_t v97 = (unint64_t)a4;
  while (1)
  {
    long long v45 = (void *)v39[26];
    if (v44 != v39[28]) {
      goto LABEL_9;
    }
    id v46 = [(id)v39[26] countByEnumeratingWithState:v86 objects:v85 count:16];
    v39[28] = v46;
    if (!v46) {
      break;
    }
    uint64_t v44 = 0;
    uint64_t *v96 = 0;
LABEL_9:
    uint64_t v47 = v39[3];
    if (!v47)
    {
      unint64_t v67 = 773;
      goto LABEL_32;
    }
    if ((unint64_t)(v44 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_29:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
    }
    unint64_t v48 = (void **)(v47 + 8 * v44);
    if ((v48 & 7) != 0) {
      goto LABEL_29;
    }
    uint64_t v87 = v37;
    uint64_t v49 = a5;
    unint64_t v50 = v15;
    uint64_t v51 = a6;
    uint64_t v52 = a7;
    int v53 = *v48;
    uint64_t *v96 = v44 + 1;
    swift_unknownObjectRetain(v53);
    uint64_t v54 = (swift *)[v45 objectForKey:v53];
    if (!v54)
    {
      unint64_t v67 = 784;
LABEL_32:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v67, 0);
    }
    uint64_t v55 = v54;
    if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4))
    {
      uint64_t v56 = (const char *)a4;
      uint64_t v57 = v8;
      v98[0] = (unint64_t)v53;
      swift_dynamicCast(v94, v98, v88, v56, 7uLL);
    }
    else
    {
      (*v77)(v83, 1, 1, a4);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v53, (uint64_t)a4, v83);
      swift_unknownObjectRelease(v53);
      char v63 = v78;
      (*v76)(v78, v83, v80);
      if ((*v75)(v63, 1, a4) == 1) {
        goto LABEL_33;
      }
      uint64_t v57 = v8;
      (*v74)(v83, v80);
      (*v93)(v94, v63, v97);
    }
    a7 = v52;
    a6 = v51;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v49, (uint64_t *)v49))
    {
      v98[0] = (unint64_t)v55;
      unint64_t v58 = v90;
      swift_dynamicCast(v90, v98, qword_1ECA06328, v49, 7uLL);
      uint64_t v15 = v50;
      uint64_t v59 = v58;
    }
    else
    {
      unint64_t v64 = v81;
      (*v73)(v81, 1, 1, v49);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v55, (uint64_t)v49, v64);
      swift_unknownObjectRelease(v55);
      Swift::String::Index v65 = v79;
      (*v72)(v79, v64, v82);
      if ((*v71)(v65, 1, v49) == 1) {
LABEL_33:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
      uint64_t v15 = v50;
      (*v70)(v81, v82);
      uint64_t v59 = v90;
      (*v69)(v90, v65, v49);
    }
    (*v93)(v95, v94, v97);
    v91(v59);
    uint64_t v8 = v57;
    if (v57)
    {
      (*(void (**)(uint64_t, unint64_t))(v84 + 8))(v95, v97);
      swift_release((uint64_t)v39);
      (*v89)(v59, v49);
      swift_release((uint64_t)v99);
      return v87;
    }
    unint64_t v60 = v59;
    a5 = v49;
    (*v89)(v60, v49);
    uint64_t v37 = v99;
    int64_t v61 = v99[2];
    if (v99[3] <= v61)
    {
      Swift::Int v62 = (Swift::Int)&v61->isa + 1;
      type metadata accessor for _NativeDictionary(0, v97, a6, a7);
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v62, 1);
      uint64_t v37 = v99;
    }
    a4 = (uint64_t *)v97;
    _NativeDictionary._unsafeInsertNew(key:value:)(v95, (uint64_t)v15, v37, v97, a6, a7);
    uint64_t v44 = *v96;
    if (*v96 < 0) {
      goto LABEL_26;
    }
  }
  uint64_t *v96 = -1;
LABEL_26:
  swift_release((uint64_t)v39);
  return v37;
}

double __CocoaDictionary.makeIterator()(uint64_t a1)
{
  return __CocoaDictionary.makeIterator()(a1, type metadata accessor for __CocoaDictionary.Iterator);
}

id __CocoaDictionary.Index.dictionary.getter(uint64_t a1)
{
  if (a1 < 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v2 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v1, v2)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  atomic_ullong v3 = *(void **)(v1 + 16);

  return swift_unknownObjectRetain(v3);
}

uint64_t __CocoaDictionary.Index.age.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.age.getter(a1, a2, type metadata accessor for __CocoaDictionary.Index.Storage);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance __CocoaDictionary.Index(uint64_t *a1, uint64_t *a2)
{
  return specialized static __CocoaDictionary.Index.== infix(_:_:)(*a1, a1[1], *a2, a2[1]);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance __CocoaDictionary.Index(uint64_t *a1, uint64_t *a2)
{
  return specialized static __CocoaDictionary.Index.< infix(_:_:)(*a1, a1[1], *a2, a2[1]);
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index(a1, a2, a3, a4, (uint64_t (*)(void, void, void, void))specialized static __CocoaDictionary.Index.< infix(_:_:));
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index(a1, a2, a3, a4, (uint64_t (*)(void, void, void, void))specialized static __CocoaDictionary.Index.< infix(_:_:));
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaDictionary.Index(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaDictionary.Index(a1, a2, a3, a4, (uint64_t (*)(void, void, void, void))specialized static __CocoaDictionary.Index.< infix(_:_:));
}

double protocol witness for Sequence.makeIterator() in conformance __CocoaDictionary@<D0>(void *a1@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance __CocoaDictionary(type metadata accessor for __CocoaDictionary.Iterator, a1);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance __CocoaDictionary()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized _copySequenceToContiguousArray<A>(_:)(*v0);
  swift_unknownObjectRelease(v1);
  return v2;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance __CocoaDictionary(void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

id protocol witness for IteratorProtocol.next() in conformance __CocoaDictionary.Iterator@<X0>(void *a1@<X8>)
{
  id result = __CocoaDictionary.Iterator.next()();
  *a1 = result;
  a1[1] = v3;
  return result;
}

int64_t Dictionary._bridgeToObjectiveCImpl()(int64_t result, uint64_t *a2, void *a3, uint64_t a4)
{
  if ((result & 0xC000000000000001) == 0) {
    return (int64_t)_NativeDictionary.bridged()((__objc2_class **)result, a2, a3, a4);
  }
  if (result >= 0) {
    return result & 0xFFFFFFFFFFFFFF8;
  }
  return result;
}

__objc2_class **static Dictionary._bridgeFromObjectiveCAdoptingNativeStorageOf(_:)(__objc2_class **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for _SwiftDeferredNSDictionary(0, a2, a3, a4);
  id v9 = swift_unknownObjectRetain(a1);
  uint64_t v10 = swift_dynamicCastClass((uint64_t)v9, (uint64_t)v8);
  if (v10)
  {
    uint64_t v11 = v10;
    swift_unknownObjectRelease(a1);
    uint64_t v12 = *(atomic_ullong **)(v11 + 32);
    swift_retain(v12);
    swift_unknownObjectRelease(a1);
  }
  else
  {
    uint64_t v13 = type metadata accessor for _DictionaryStorage(0, a2, a3, a4);
    uint64_t v12 = (atomic_ullong *)swift_dynamicCastClass((uint64_t)a1, (uint64_t)v13);
    swift_unknownObjectRelease(a1);
    if (!v12)
    {
      swift_unknownObjectRelease(a1);
      if (a1 == &_swiftEmptyDictionarySingleton) {
        return &_swiftEmptyDictionarySingleton;
      }
      else {
        return 0;
      }
    }
  }
  return (__objc2_class **)v12;
}

uint64_t (*_DictionaryBuilder._target.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _DictionaryBuilder._requestedCount.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

__objc2_class **_DictionaryBuilder.init(count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptyDictionarySingleton;
  }
  type metadata accessor for _DictionaryStorage(0, a2, a3, a4);
  return (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a1);
}

uint64_t _DictionaryBuilder.add(key:value:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v12 = *(void *)(v11 + 16);
  MEMORY[0x1F4188790](v8);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = (void *)*v3;
  if (*(void *)(*v3 + 16) >= v3[1]) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't add more members than promised", 36, 2, "Swift/DictionaryBuilder.swift", 29, 2, 0x21uLL, 0);
  }
  (*(void (**)(char *))(v13 + 16))(v15);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, a2, v6);
  return _NativeDictionary._unsafeInsertNew(key:value:)((uint64_t)v15, (uint64_t)v10, v16, v12, v6, *(void *)(a3 + 32));
}

__n128 specialized _NativeDictionary._unsafeInsertNew(key:value:)(long long *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[5];
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v19, v7, v8);
  uint64_t v9 = v20;
  uint64_t v10 = v21;
  __swift_project_boxed_opaque_existential_0Tm(v19, v20);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v6, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v19);
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v11);
  if (v13) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  a3[(v12 >> 6) + 8] |= 1 << v12;
  uint64_t v14 = a3[6] + 40 * v12;
  long long v15 = *a1;
  long long v16 = a1[1];
  *(void *)(v14 + 32) = *((void *)a1 + 4);
  *(_OWORD *)uint64_t v14 = v15;
  *(_OWORD *)(v14 + 16) = v16;
  uint64_t v17 = a3[7] + 40 * v12;
  __n128 result = *(__n128 *)(a2 + 16);
  *(_OWORD *)uint64_t v17 = *(_OWORD *)a2;
  *(__n128 *)(v17 + 16) = result;
  *(void *)(v17 + 32) = *(void *)(a2 + 32);
  ++a3[2];
  return result;
}

_OWORD *specialized _NativeDictionary._unsafeInsertNew(key:value:)(unint64_t a1, unint64_t a2, _OWORD *a3, void *a4)
{
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ a4[5];
  v14[0] = 0;
  v14[1] = v8 ^ 0x736F6D6570736575;
  v14[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  _OWORD v14[3] = v8 ^ 0x6C7967656E657261;
  void v14[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v15 = 0u;
  long long v16 = 0u;
  String.hash(into:)(v14, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v9);
  if (v11) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a4[(v10 >> 6) + 8] |= 1 << v10;
  unint64_t v12 = (unint64_t *)(a4[6] + 16 * v10);
  *unint64_t v12 = a1;
  v12[1] = a2;
  __n128 result = outlined init with take of Any(a3, (_OWORD *)(a4[7] + 32 * v10));
  ++a4[2];
  return result;
}

_OWORD *specialized _NativeDictionary._unsafeInsertNew(key:value:)(long long *a1, _OWORD *a2, void *a3)
{
  uint64_t v6 = a3[5];
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v18, v7, v8);
  uint64_t v9 = v19;
  uint64_t v10 = v20;
  __swift_project_boxed_opaque_existential_0Tm(v18, v19);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v6, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v18);
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v11);
  if (v13) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  a3[(v12 >> 6) + 8] |= 1 << v12;
  uint64_t v14 = a3[6] + 40 * v12;
  long long v15 = *a1;
  long long v16 = a1[1];
  *(void *)(v14 + 32) = *((void *)a1 + 4);
  *(_OWORD *)uint64_t v14 = v15;
  *(_OWORD *)(v14 + 16) = v16;
  __n128 result = outlined init with take of Any(a2, (_OWORD *)(a3[7] + 32 * v12));
  ++a3[2];
  return result;
}

__n128 specialized _NativeDictionary._unsafeInsertNew(key:value:)(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = a4[5];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a1, v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v10 + 8))(v20, v9, v10);
  uint64_t v11 = v21;
  uint64_t v12 = v22;
  __swift_project_boxed_opaque_existential_0Tm(v20, v21);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 40))(v8, v11, v12);
  __swift_destroy_boxed_opaque_existential_1Tm(v20);
  unint64_t v14 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)((void *)a1, v13);
  if (v15) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  a4[(v14 >> 6) + 8] |= 1 << v14;
  uint64_t v16 = a4[6] + 40 * v14;
  __n128 result = *(__n128 *)a1;
  long long v18 = *(_OWORD *)(a1 + 16);
  *(void *)(v16 + 32) = *(void *)(a1 + 32);
  *(__n128 *)uint64_t v16 = result;
  *(_OWORD *)(v16 + 16) = v18;
  uint64_t v19 = (void *)(a4[7] + 16 * v14);
  *uint64_t v19 = a2;
  v19[1] = a3;
  ++a4[2];
  return result;
}

__n128 specialized _NativeDictionary._unsafeInsertNew(key:value:)(unint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ a4[5];
  v16[0] = 0;
  v16[1] = v8 ^ 0x736F6D6570736575;
  v16[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v16[3] = v8 ^ 0x6C7967656E657261;
  v16[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v17 = 0u;
  long long v18 = 0u;
  String.hash(into:)(v16, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v9);
  if (v11) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a4[(v10 >> 6) + 8] |= 1 << v10;
  uint64_t v12 = (unint64_t *)(a4[6] + 16 * v10);
  *uint64_t v12 = a1;
  v12[1] = a2;
  uint64_t v13 = a4[7] + 40 * v10;
  __n128 result = *(__n128 *)a3;
  long long v15 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)uint64_t v13 = *(_OWORD *)a3;
  *(_OWORD *)(v13 + 16) = v15;
  *(void *)(v13 + 32) = *(void *)(a3 + 32);
  ++a4[2];
  return result;
}

unint64_t specialized _NativeDictionary._unsafeInsertNew(key:value:)(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v10 = _swift_stdlib_Hashing_parameters ^ a5[5];
  v16[0] = 0;
  v16[1] = v10 ^ 0x736F6D6570736575;
  v16[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v16[3] = v10 ^ 0x6C7967656E657261;
  v16[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v17 = 0u;
  long long v18 = 0u;
  String.hash(into:)(v16, a1, a2);
  Swift::Int v11 = Hasher._finalize()();
  unint64_t result = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v11);
  if (v13) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a5[(result >> 6) + 8] |= 1 << result;
  unint64_t v14 = (unint64_t *)(a5[6] + 16 * result);
  *unint64_t v14 = a1;
  v14[1] = a2;
  long long v15 = (void *)(a5[7] + 16 * result);
  *long long v15 = a3;
  v15[1] = a4;
  ++a5[2];
  return result;
}

unint64_t specialized _NativeDictionary._unsafeInsertNew(key:value:)(unint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ a4[5];
  v13[0] = 0;
  v13[1] = v8 ^ 0x736F6D6570736575;
  v13[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v13[3] = v8 ^ 0x6C7967656E657261;
  v13[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v14 = 0u;
  long long v15 = 0u;
  String.hash(into:)(v13, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  unint64_t result = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v9);
  if (v11) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a4[(result >> 6) + 8] |= 1 << result;
  uint64_t v12 = (unint64_t *)(a4[6] + 16 * result);
  *uint64_t v12 = a1;
  v12[1] = a2;
  *(void *)(a4[7] + 8 * result) = a3;
  ++a4[2];
  return result;
}

uint64_t _NativeDictionary._unsafeInsertNew(key:value:)(uint64_t a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(a6 + 32))(a3[5], a4, a6);
  unint64_t v12 = __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v11, a4);
  if (v13) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(a4);
  }
  unint64_t v14 = v12;
  a3[(v12 >> 6) + 8] |= 1 << v12;
  (*(void (**)(unint64_t, uint64_t, unint64_t))(*(void *)(a4 - 8) + 32))(a3[6] + *(void *)(*(void *)(a4 - 8) + 72) * v12, a1, a4);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32))(a3[7] + *(void *)(*(void *)(a5 - 8) + 72) * v14, a2, a5);
  ++a3[2];
  return result;
}

uint64_t _DictionaryBuilder.take()(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 16) != a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "The number of members added does not match the promised count", 61, 2, "Swift/DictionaryBuilder.swift", 29, 2, 0x28uLL, 0);
  }
  return result;
}

uint64_t _NativeDictionary._keys.getter(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

Swift::Bool __swiftcall _HashTable._isOccupied(_:)(Swift::_HashTable::Bucket a1)
{
  return (*(void *)(v1 + (((unint64_t)a1.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) >> SLOBYTE(a1.offset)) & 1;
}

Swift::Void __swiftcall _NativeDictionary.uncheckedDestroy(at:)(Swift::_HashTable::Bucket at)
{
  id v4 = v3;
  uint64_t v5 = v1;
  swift_arrayDestroy(*(void *)(v1 + 48) + *(void *)(*(v2 - 1) + 72) * at.offset, 1, v2);
  uint64_t v7 = *(void *)(v5 + 56) + *(void *)(*(v4 - 1) + 72) * at.offset;

  swift_arrayDestroy(v7, 1, v4);
}

Swift::Void __swiftcall _HashTable.insert(_:)(Swift::_HashTable::Bucket a1)
{
  *(void *)(v1 + (((unint64_t)a1.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << SLOBYTE(a1.offset);
}

uint64_t _NativeDictionary.hashValue(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(a5 + 32))(*(void *)(a2 + 40), a3, a5);
}

Swift::_HashTable::Bucket __swiftcall _HashTable.insertNew(hashValue:)(Swift::Int hashValue)
{
  uint64_t v3 = v1;
  result.uint64_t offset = _HashTable.nextHole(atOrAfter:)((Swift::_HashTable::Bucket)(v2 & hashValue)).offset;
  *(void *)(v3 + (((unint64_t)result.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << SLOBYTE(result.offset);
  return result;
}

Swift::Void __swiftcall _NativeDictionary.moveEntry(from:to:)(Swift::_HashTable::Bucket from, Swift::_HashTable::Bucket to)
{
  uint64_t v5 = v4;
  uint64_t v6 = v2;
  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(*(void *)(v2 + 48) + *(void *)(*(v3 - 1) + 72) * from.offset), 1, (char *)(*(void *)(v2 + 48) + *(void *)(*(v3 - 1) + 72) * to.offset), v3);
  uint64_t v9 = *(void *)(v6 + 56);
  uint64_t v10 = *(void *)(*(v5 - 1) + 72);

  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v9 + v10 * from.offset), 1, (char *)(v9 + v10 * to.offset), v5);
}

Swift::Void __swiftcall _NativeDictionary.swapEntry(_:with:)(Swift::_HashTable::Bucket _, Swift::_HashTable::Bucket with)
{
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v7 = v2;
  Swift::Int offset = _.offset;
  uint64_t v9 = *(void *)(v4 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](_.offset);
  uint64_t v32 = (char *)&offset - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v10);
  uint64_t v16 = (char *)&offset - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = *(void *)(v17 + 48);
  uint64_t v19 = *(void (**)(char *, char *, uint64_t))(v13 + 32);
  uint64_t v20 = *(void *)(v13 + 72);
  uint64_t v21 = (char *)(v18 + v20 * v14);
  uint64_t v23 = (char *)(v18 + v20 * v22);
  v19(v16, v21, v24);
  v19(v21, v23, v6);
  v19(v23, v16, v6);
  uint64_t v25 = *(void *)(v7 + 56);
  uint64_t v26 = *(void (**)(char *, Swift::Int, uint64_t))(v9 + 32);
  uint64_t v27 = *(void *)(v9 + 72);
  uint64_t v28 = (char *)(v25 + v27 * offset);
  uint64_t v29 = (char *)(v25 + v27 * with.offset);
  uint64_t v30 = v32;
  v26(v32, (Swift::Int)v28, v5);
  v26(v28, (Swift::Int)v29, v5);
  v26(v29, (Swift::Int)v30, v5);
}

void _swift_dictionaryDownCastIndirect(unint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, ValueMetadata *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = *a1;
  unint64_t v16 = swift_bridgeObjectRetain(*a1);
  uint64_t v17 = _dictionaryDownCast<A, B, C, D>(_:)(v16, a3, a4, a5, a6, a7, a8);
  swift_bridgeObjectRelease(v15);
  *a2 = v17;
}

uint64_t _dictionaryDownCast<A, B, C, D>(_:)(int64_t a1, uint64_t *a2, uint64_t *a3, ValueMetadata *a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v274 = a7;
  int64_t v276 = a1;
  v277 = (char *)a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)a4, (uint64_t)a5, "key value ", 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  v270 = (char *)&v223 - v11;
  v269 = swift_getTupleTypeMetadata2(0, (uint64_t)a4, (uint64_t)a5, 0, 0);
  uint64_t v12 = MEMORY[0x1F4188790](v269);
  v268 = (char *)&v223 - v13;
  v275 = a5;
  unint64_t v257 = *(a5 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v262 = (void (**)(char *, char *, uint64_t *))((char *)&v223 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v261 = (unint64_t)&v223 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v254 = (char *)&v223 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  unint64_t v253 = (char *)&v223 - v21;
  Description = (char *)a4[-1].Description;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v260 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))((char *)&v223 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v259 = (char *)&v223 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v223 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v252 = (char *)&v223 - v29;
  uint64_t v30 = swift_getTupleTypeMetadata2(0, (uint64_t)a2, (uint64_t)a3, "key value ", 0);
  v246 = (char *)*(v30 - 1);
  uint64_t v31 = MEMORY[0x1F4188790](v30);
  v258 = (char *)&v223 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v31);
  uint64_t v251 = (char *)&v223 - v33;
  uint64_t v36 = type metadata accessor for Optional(0, (uint64_t)a3, v34, v35);
  v263 = (void (**)(char *, void, uint64_t, uint64_t *))*(v36 - 1);
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  v240 = (char *)&v223 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v239 = (char *)&v223 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v237 = (char *)&v223 - v42;
  MEMORY[0x1F4188790](v41);
  uint64_t v44 = (char *)&v223 - v43;
  uint64_t v47 = type metadata accessor for Optional(0, (uint64_t)a2, v45, v46);
  uint64_t v250 = (uint64_t)*(v47 - 1);
  uint64_t v48 = MEMORY[0x1F4188790](v47);
  v238 = (char *)&v223 - ((v49 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v248 = (char *)&v223 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  unint64_t v236 = (char *)&v223 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  v244 = (char *)&v223 - v55;
  uint64_t v265 = *(a3 - 1);
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  unint64_t v58 = (char *)&v223 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v264 = *(a2 - 1);
  MEMORY[0x1F4188790](v56);
  unint64_t v60 = (char *)&v223 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0);
  v279 = v30;
  char v63 = type metadata accessor for Optional(0, (uint64_t)v30, v61, v62);
  uint64_t v64 = MEMORY[0x1F4188790](v63 - 1);
  v266 = (char *)&v223 - ((v65 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v64);
  v256 = (char *)&v223 - v66;
  v280 = a2;
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
    && _swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    && _swift_isClassOrObjCExistentialType((uint64_t)a4, &a4->Kind)
    && _swift_isClassOrObjCExistentialType((uint64_t)v275, v275))
  {
    if ((v276 & 0xC000000000000001) != 0)
    {
      unint64_t v67 = v276 & 0xFFFFFFFFFFFFFF8;
      if (v276 < 0) {
        unint64_t v67 = v276;
      }
      uint64_t v68 = (__objc2_class **)(~(v67 >> 1) & 0x4000000000000000 | v67);
      swift_bridgeObjectRetain(v276);
    }
    else
    {
      v220 = (__objc2_class **)swift_bridgeObjectRetain(v276);
      unint64_t v221 = _NativeDictionary.bridged()(v220, v280, a3, (uint64_t)v277);
      return ~((unint64_t)v221 >> 1) & 0x4000000000000000 | (unint64_t)v221;
    }
    return (uint64_t)v68;
  }
  uint64_t v233 = v44;
  unint64_t v69 = v276 & 0xC000000000000001;
  if ((v276 & 0xC000000000000001) != 0)
  {
    if (v276 < 0) {
      int64_t v70 = (void *)v276;
    }
    else {
      int64_t v70 = (void *)(v276 & 0xFFFFFFFFFFFFFF8);
    }
    id v71 = [v70 count];
    v277 = v28;
    if (v71) {
      goto LABEL_14;
    }
LABEL_16:
    uint64_t v68 = &_swiftEmptyDictionarySingleton;
    goto LABEL_17;
  }
  id v71 = *(id *)(v276 + 16);
  v277 = v28;
  if (!v71) {
    goto LABEL_16;
  }
LABEL_14:
  type metadata accessor for _DictionaryStorage(0, (uint64_t)a4, (uint64_t)v275, v274);
  uint64_t v68 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v71);
LABEL_17:
  unint64_t v72 = v276;
  uint64_t v235 = v36;
  long long v234 = v47;
  v278 = v58;
  v272 = v68;
  v273 = a3;
  unint64_t v267 = v60;
  if (a4 == &type metadata for String)
  {
    if (v69)
    {
      if (v276 < 0) {
        unint64_t v79 = v276;
      }
      else {
        unint64_t v79 = v276 & 0xFFFFFFFFFFFFFF8;
      }
      unint64_t v80 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v81 = (unint64_t)swift_allocObject(v80, 0xE8uLL, 7uLL);
      int64_t v241 = 0;
      uint64_t v82 = 0;
      unint64_t v261 = 0;
      *(void *)(v81 + 208) = v79;
      *(void *)(v81 + 216) = 0;
      *(_OWORD *)(v81 + 16) = 0u;
      *(_OWORD *)(v81 + 32) = 0u;
      *(_OWORD *)(v81 + 48) = 0u;
      *(_OWORD *)(v81 + 64) = 0u;
      *(_OWORD *)(v81 + 80) = 0u;
      *(_OWORD *)(v81 + 96) = 0u;
      *(_OWORD *)(v81 + 112) = 0u;
      *(_OWORD *)(v81 + 128) = 0u;
      *(_OWORD *)(v81 + 144) = 0u;
      *(_OWORD *)(v81 + 160) = 0u;
      *(_OWORD *)(v81 + 176) = 0u;
      *(_OWORD *)(v81 + 192) = 0u;
      *(void *)(v81 + 224) = 0;
      unint64_t v83 = v81 | 0x8000000000000000;
    }
    else
    {
      uint64_t v147 = -1 << *(unsigned char *)(v276 + 32);
      uint64_t v82 = ~v147;
      uint64_t v148 = *(void *)(v276 + 64);
      int64_t v241 = v276 + 64;
      uint64_t v149 = -v147;
      if (v149 < 64) {
        uint64_t v150 = ~(-1 << v149);
      }
      else {
        uint64_t v150 = -1;
      }
      unint64_t v261 = v150 & v148;
      unint64_t v83 = v276;
    }
    unint64_t v151 = v279;
    unint64_t v152 = v280;
    uint64_t v239 = (char *)((v83 & 0x7FFFFFFFFFFFFFFFLL) + 16);
    uint64_t v243 = v83 & 0x7FFFFFFFFFFFFFFFLL;
    v238 = (char *)((v83 & 0x7FFFFFFFFFFFFFFFLL) + 80);
    v231 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v264 + 56);
    uint64_t v230 = (void (**)(char *, char *, Class *))(v250 + 16);
    int64_t v229 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v264 + 48);
    long long v228 = (void (**)(char *, Class *))(v250 + 8);
    unint64_t v153 = (void (**)(char *, char *, uint64_t *))(v264 + 32);
    uint64_t v227 = (void (**)(void *, uint64_t, uint64_t, uint64_t *))(v265 + 56);
    v226 = (void (**)(char *, void *, Class *))(v263 + 2);
    v225 = (unsigned int (**)(char *, uint64_t, void *))(v265 + 48);
    v224 = (void (**)(void *, Class *))(v263 + 1);
    v263 = (void (**)(char *, void, uint64_t, uint64_t *))(v265 + 32);
    v260 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v246 + 56);
    uint64_t v232 = (void (**)(void *, Class *))v82;
    v240 = (char *)((unint64_t)(v82 + 64) >> 6);
    uint64_t v249 = v264 + 16;
    v248 = (char *)(v265 + 16);
    v259 = v246 + 32;
    int64_t v276 = (int64_t)(Description + 32);
    v266 = (char *)(v257 + 32);
    v245 = v68 + 8;
    uint64_t v247 = (uint64_t)(Description + 40);
    v246 = (char *)(v257 + 40);
    swift_bridgeObjectRetain(v72);
    uint64_t v250 = 0;
    v242 = &unk_1ECA06328;
    v258 = (char *)v83;
    uint64_t v262 = v153;
    uint64_t v154 = v151;
    while (1)
    {
      if ((v83 & 0x8000000000000000) != 0)
      {
        uint64_t v157 = (void *)v243;
        uint64_t v158 = *(void *)(v243 + 216);
        uint64_t v159 = v256;
        if (v158 < 0) {
          goto LABEL_117;
        }
        uint64_t v160 = v154;
        unint64_t v161 = *(void **)(v243 + 208);
        unint64_t v162 = (void (**)(char *, char *, void *))v263;
        if (v158 == *(void *)(v243 + 224))
        {
          id v163 = [*(id *)(v243 + 208) countByEnumeratingWithState:v239 objects:v238 count:16];
          v157[28] = v163;
          if (!v163)
          {
            v157[27] = -1;
            uint64_t v154 = v160;
LABEL_117:
            (*v260)(v159, 1, 1, v154);
            uint64_t v218 = v83;
            goto LABEL_118;
          }
          uint64_t v158 = 0;
          v157[27] = 0;
        }
        uint64_t v164 = v157[3];
        if (!v164) {
          goto LABEL_130;
        }
        if ((unint64_t)(v158 - 0x1000000000000000) >> 61 != 7) {
          goto LABEL_126;
        }
        uint64_t v165 = (void **)(v164 + 8 * v158);
        if ((v165 & 7) != 0) {
LABEL_121:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
        int64_t v166 = *v165;
        v157[27] = v158 + 1;
        swift_unknownObjectRetain(v166);
        char v167 = (swift *)[v161 objectForKey:v166];
        if (!v167)
        {
LABEL_131:
          unint64_t v222 = 784;
          goto LABEL_132;
        }
        int64_t v168 = v167;
        char v169 = v280;
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v280, v280);
        BOOL v171 = v244;
        if (isClassOrObjCExistentialType)
        {
          v281 = (swift *)v166;
          swift_dynamicCast(v159, &v281, v242, v169, 7);
        }
        else
        {
          (*v231)(v244, 1, 1, v169);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v166, (uint64_t)v169, v171);
          swift_unknownObjectRelease(v166);
          int64_t v213 = v236;
          uint64_t v214 = v234;
          (*v230)(v236, v171, v234);
          if ((*v229)(v213, 1, v169) == 1) {
            goto LABEL_133;
          }
          (*v228)(v171, v214);
          (*v262)(v159, v213, v169);
        }
        Swift::String::Index v172 = v279;
        Swift::String::Index v173 = &v159[*((int *)v279 + 12)];
        if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
        {
          v281 = v168;
          swift_dynamicCast(v173, &v281, &unk_1ECA06328, a3, 7);
        }
        else
        {
          uint64_t v215 = v233;
          (*v227)(v233, 1, 1, a3);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v168, (uint64_t)a3, v215);
          swift_unknownObjectRelease(v168);
          uint64_t v216 = v237;
          uint64_t v217 = v235;
          (*v226)(v237, v215, v235);
          if ((*v225)(v216, 1, a3) == 1) {
LABEL_133:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
          (*v224)(v215, v217);
          (*v162)(v173, v216, a3);
        }
        (*v260)(v159, 0, 1, v172);
        Swift::String::Index v174 = v159;
        Swift::String::Index v175 = v280;
        uint64_t v176 = v267;
        uint64_t v177 = v273;
        uint64_t v154 = v172;
        uint64_t v178 = v262;
        uint64_t v179 = (void (**)(char *, char *, uint64_t *))v263;
      }
      else
      {
        if (v261)
        {
          unint64_t v155 = __clz(__rbit64(v261));
          v261 &= v261 - 1;
          unint64_t v156 = v155 | (v250 << 6);
        }
        else
        {
          uint64_t v180 = v250 + 1;
          if (__OFADD__(v250, 1)) {
            goto LABEL_128;
          }
          if (v180 >= (uint64_t)v240) {
            goto LABEL_113;
          }
          unint64_t v181 = *(void *)(v241 + 8 * v180);
          uint64_t v182 = v250 + 1;
          if (!v181)
          {
            uint64_t v182 = v250 + 2;
            if (v250 + 2 >= (uint64_t)v240) {
              goto LABEL_113;
            }
            unint64_t v181 = *(void *)(v241 + 8 * v182);
            if (!v181)
            {
              uint64_t v183 = v250 + 3;
              if (v250 + 3 >= (uint64_t)v240) {
                goto LABEL_113;
              }
              unint64_t v181 = *(void *)(v241 + 8 * v183);
              if (!v181)
              {
                while (1)
                {
                  uint64_t v182 = v183 + 1;
                  if (__OFADD__(v183, 1)) {
                    goto LABEL_129;
                  }
                  if (v182 >= (uint64_t)v240) {
                    break;
                  }
                  unint64_t v181 = *(void *)(v241 + 8 * v182);
                  ++v183;
                  if (v181) {
                    goto LABEL_103;
                  }
                }
LABEL_113:
                (*v260)(v256, 1, 1, v154);
                uint64_t v218 = v83;
                goto LABEL_118;
              }
              uint64_t v182 = v250 + 3;
            }
          }
LABEL_103:
          unint64_t v261 = (v181 - 1) & v181;
          unint64_t v156 = __clz(__rbit64(v181)) + (v182 << 6);
          uint64_t v250 = v182;
        }
        uint64_t v184 = v264;
        uint64_t v176 = v267;
        (*(void (**)(char *, unint64_t, uint64_t *))(v264 + 16))(v267, *(void *)(v83 + 48) + *(void *)(v264 + 72) * v156, v152);
        uint64_t v185 = *(void *)(v83 + 56);
        uint64_t v186 = v265;
        uint64_t v187 = v278;
        Swift::String::Index v175 = v152;
        unint64_t v188 = v273;
        (*(void (**)(char *, unint64_t, uint64_t *))(v265 + 16))(v278, v185 + *(void *)(v265 + 72) * v156, v273);
        Swift::String::Index v174 = v256;
        unint64_t v189 = &v256[*((int *)v154 + 12)];
        (*(void (**)(char *, char *, uint64_t *))(v184 + 32))(v256, v176, v175);
        unint64_t v190 = *(void (**)(char *, char *, uint64_t *))(v186 + 32);
        uint64_t v177 = v188;
        uint64_t v179 = (void (**)(char *, char *, uint64_t *))v263;
        v190(v189, v187, v188);
        (*v260)(v174, 0, 1, v154);
        uint64_t v178 = v153;
      }
      unint64_t v191 = v251;
      (*(void (**)(char *, char *, uint64_t *))v259)(v251, v174, v154);
      uint64_t v192 = &v191[*((int *)v154 + 12)];
      char v193 = v270;
      uint64_t v194 = &v270[*((int *)TupleTypeMetadata2 + 12)];
      (*v178)(v176, v191, v175);
      swift_dynamicCast(v193, v176, v175, &type metadata for String, 7);
      uint64_t v195 = v278;
      (*v179)(v278, v192, v177);
      char v196 = v275;
      swift_dynamicCast(v194, v195, v177, v275, 7);
      size_t v197 = v268;
      BOOL v198 = &v268[*((int *)v269 + 12)];
      Swift::Int v199 = *(void (**)(char *, char *, ValueMetadata *))v276;
      (*(void (**)(char *, char *, ValueMetadata *))v276)(v268, v193, &type metadata for String);
      unint64_t v200 = *(void (**)(char *, char *, uint64_t *))v266;
      (*(void (**)(char *, char *, uint64_t *))v266)(v198, v194, v196);
      uint64_t v201 = v252;
      v202 = v197;
      unint64_t v203 = v196;
      v199(v252, v202, &type metadata for String);
      uint64_t v204 = v253;
      v200(v253, v198, v203);
      uint64_t v205 = (uint64_t)v277;
      v199(v277, v201, &type metadata for String);
      uint64_t v206 = v254;
      v200(v254, v204, v203);
      uint64_t v68 = v272;
      unint64_t v207 = __RawDictionaryStorage.find<A>(_:)(v205, (uint64_t)&type metadata for String, v274);
      unint64_t v208 = v207;
      a3 = v177;
      if (v209)
      {
        (*((void (**)(char *, uint64_t, ValueMetadata *))Description + 5))((char *)v68[6] + *((void *)Description + 9) * v207, v205, &type metadata for String);
        (*(void (**)(char *, char *, uint64_t *))(v257 + 40))((char *)v68[7] + *(void *)(v257 + 72) * v208, v206, v203);
      }
      else
      {
        if (v68[2] >= v68[3]) {
          goto LABEL_123;
        }
        *(__objc2_class **)((char *)v245 + ((v207 >> 3) & 0x1FFFFFFFFFFFFFF8)) = (__objc2_class *)(*(unint64_t *)((char *)v245 + ((v207 >> 3) & 0x1FFFFFFFFFFFFFF8)) | (1 << v207));
        v199((char *)v68[6] + *((void *)Description + 9) * v207, v277, &type metadata for String);
        v200((char *)v68[7] + *(void *)(v257 + 72) * v208, v206, v203);
        long long v210 = v68[2];
        BOOL v211 = __OFADD__(v210, 1);
        uint64_t v212 = (__objc2_class *)((char *)&v210->isa + 1);
        if (v211)
        {
          __break(1u);
LABEL_125:
          __break(1u);
LABEL_126:
          __break(1u);
          goto LABEL_127;
        }
        v68[2] = v212;
      }
      uint64_t v154 = v279;
      unint64_t v152 = v280;
      unint64_t v83 = (unint64_t)v258;
      unint64_t v153 = v262;
    }
  }
  if (v69)
  {
    if (v276 < 0) {
      unint64_t v73 = v276;
    }
    else {
      unint64_t v73 = v276 & 0xFFFFFFFFFFFFFF8;
    }
    unint64_t v74 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v75 = (unint64_t)swift_allocObject(v74, 0xE8uLL, 7uLL);
    v245 = 0;
    uint64_t v76 = 0;
    unint64_t v77 = 0;
    *(void *)(v75 + 208) = v73;
    *(void *)(v75 + 216) = 0;
    *(_OWORD *)(v75 + 16) = 0u;
    *(_OWORD *)(v75 + 32) = 0u;
    *(_OWORD *)(v75 + 48) = 0u;
    *(_OWORD *)(v75 + 64) = 0u;
    *(_OWORD *)(v75 + 80) = 0u;
    *(_OWORD *)(v75 + 96) = 0u;
    *(_OWORD *)(v75 + 112) = 0u;
    *(_OWORD *)(v75 + 128) = 0u;
    *(_OWORD *)(v75 + 144) = 0u;
    *(_OWORD *)(v75 + 160) = 0u;
    *(_OWORD *)(v75 + 176) = 0u;
    *(_OWORD *)(v75 + 192) = 0u;
    *(void *)(v75 + 224) = 0;
    unint64_t v78 = v75 | 0x8000000000000000;
  }
  else
  {
    uint64_t v84 = -1 << *(unsigned char *)(v276 + 32);
    uint64_t v76 = ~v84;
    uint64_t v85 = *(void *)(v276 + 64);
    v245 = (__objc2_class **)(v276 + 64);
    uint64_t v86 = -v84;
    if (v86 < 64) {
      uint64_t v87 = ~(-1 << v86);
    }
    else {
      uint64_t v87 = -1;
    }
    unint64_t v77 = v87 & v85;
    unint64_t v78 = v276;
  }
  uint64_t v243 = (v78 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v247 = v78 & 0x7FFFFFFFFFFFFFFFLL;
  v242 = (void *)((v78 & 0x7FFFFFFFFFFFFFFFLL) + 80);
  v237 = (char *)(v264 + 56);
  unint64_t v236 = (char *)(v250 + 16);
  uint64_t v233 = (void *)(v264 + 48);
  uint64_t v232 = (void (**)(void *, Class *))(v250 + 8);
  v256 = (char *)(v264 + 32);
  v231 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v265 + 56);
  uint64_t v230 = (void (**)(char *, char *, Class *))(v263 + 2);
  int64_t v229 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v265 + 48);
  long long v228 = (void (**)(char *, Class *))(v263 + 1);
  size_t v88 = (void (**)(char *, char *, uint64_t *))(v265 + 32);
  v263 = (void (**)(char *, void, uint64_t, uint64_t *))(v246 + 56);
  int64_t v241 = v76;
  v244 = (char *)((unint64_t)(v76 + 64) >> 6);
  uint64_t v250 = v264 + 16;
  uint64_t v249 = v265 + 16;
  v254 = v246 + 32;
  unint64_t v253 = Description + 32;
  uint64_t v252 = (char *)(v257 + 32);
  swift_bridgeObjectRetain(v72);
  swift_retain((atomic_ullong *)v68);
  uint64_t v251 = 0;
  v246 = (char *)&unk_1ECA06328;
  Description = (char *)a4;
  unint64_t v257 = v78;
  int64_t v276 = (int64_t)v88;
  while ((v78 & 0x8000000000000000) == 0)
  {
    unint64_t v118 = v273;
    unint64_t v119 = v280;
    unint64_t v120 = v278;
    if (v77)
    {
      unint64_t v89 = __clz(__rbit64(v77));
      uint64_t v90 = (v77 - 1) & v77;
      unint64_t v91 = v89 | ((void)v251 << 6);
      uint64_t v92 = v279;
    }
    else
    {
      unint64_t v121 = v251 + 1;
      char v122 = v279;
      uint64_t v99 = v266;
      if (__OFADD__(v251, 1)) {
        goto LABEL_125;
      }
      if ((uint64_t)v121 >= (uint64_t)v244)
      {
LABEL_67:
        uint64_t v68 = v272;
        goto LABEL_115;
      }
      unint64_t v123 = (unint64_t)v245[(void)v121];
      unint64_t v124 = v251 + 1;
      if (!v123)
      {
        unint64_t v124 = v251 + 2;
        if ((uint64_t)(v251 + 2) >= (uint64_t)v244) {
          goto LABEL_67;
        }
        unint64_t v123 = (unint64_t)v245[(void)v124];
        if (!v123)
        {
          unint64_t v125 = v251 + 3;
          if ((uint64_t)(v251 + 3) >= (uint64_t)v244) {
            goto LABEL_67;
          }
          unint64_t v123 = (unint64_t)v245[(void)v125];
          if (!v123)
          {
            while (1)
            {
              unint64_t v124 = v125 + 1;
              if (__OFADD__(v125, 1)) {
                break;
              }
              if ((uint64_t)v124 >= (uint64_t)v244) {
                goto LABEL_67;
              }
              unint64_t v123 = (unint64_t)v245[(void)v124];
              ++v125;
              if (v123) {
                goto LABEL_62;
              }
            }
LABEL_127:
            __break(1u);
LABEL_128:
            __break(1u);
LABEL_129:
            __break(1u);
LABEL_130:
            unint64_t v222 = 773;
LABEL_132:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v222, 0);
          }
          unint64_t v124 = v251 + 3;
        }
      }
LABEL_62:
      uint64_t v90 = (v123 - 1) & v123;
      unint64_t v91 = __clz(__rbit64(v123)) + ((void)v124 << 6);
      uint64_t v251 = v124;
      uint64_t v92 = v279;
    }
    v277 = (char *)v90;
    uint64_t v93 = v264;
    uint64_t v94 = v267;
    (*(void (**)(char *, unint64_t, uint64_t *))(v264 + 16))(v267, *(void *)(v78 + 48) + *(void *)(v264 + 72) * v91, v280);
    uint64_t v95 = *(void *)(v78 + 56);
    uint64_t v96 = v265;
    (*(void (**)(char *, unint64_t, uint64_t *))(v265 + 16))(v120, v95 + *(void *)(v265 + 72) * v91, v118);
    unint64_t v97 = &v266[*((int *)v92 + 12)];
    uint64_t v98 = *(void (**)(char *, char *, uint64_t *))(v93 + 32);
    uint64_t v99 = v266;
    char v100 = v256;
    v98(v266, v94, v119);
    uint64_t v101 = (void (**)(char *, char *, uint64_t *))v276;
    (*(void (**)(char *, char *, uint64_t *))(v96 + 32))(v97, v120, v118);
    (*v263)(v99, 0, 1, v92);
    uint64_t v102 = v92;
LABEL_35:
    uint64_t v103 = v258;
    (*(void (**)(char *, char *, uint64_t *))v254)(v258, v99, v102);
    uint64_t v104 = &v103[*((int *)v102 + 12)];
    uint64_t v105 = v270;
    Swift::String::Index v106 = &v270[*((int *)TupleTypeMetadata2 + 12)];
    (*(void (**)(char *, char *, uint64_t *))v100)(v94, v103, v119);
    Swift::String::Index v107 = v94;
    unint64_t v108 = (unint64_t)Description;
    swift_dynamicCast(v105, v107, v119, Description, 7);
    (*v101)(v120, v104, v118);
    Swift::String::Index v109 = v275;
    swift_dynamicCast(v106, v120, v118, v275, 7);
    unint64_t v110 = v268;
    unint64_t v111 = &v268[*((int *)v269 + 12)];
    unint64_t v112 = *(void (**)(char *, char *, unint64_t))v253;
    (*(void (**)(char *, char *, unint64_t))v253)(v268, v105, v108);
    uint64_t v113 = *(void (**)(unint64_t, char *, uint64_t *))v252;
    (*(void (**)(char *, char *, uint64_t *))v252)(v111, v106, v109);
    uint64_t v114 = v259;
    v112(v259, v110, v108);
    unint64_t v115 = v261;
    v113(v261, v111, v109);
    uint64_t v116 = (uint64_t)v260;
    v112((char *)v260, v114, v108);
    uint64_t v117 = (uint64_t)v262;
    v113((unint64_t)v262, (char *)v115, v109);
    uint64_t v68 = v272;
    _NativeDictionary._unsafeInsertNew(key:value:)(v116, v117, v272, v108, (uint64_t)v109, v274);
    unint64_t v78 = v257;
    size_t v88 = (void (**)(char *, char *, uint64_t *))v276;
    unint64_t v77 = (unint64_t)v277;
  }
  v277 = (char *)v77;
  unint64_t v126 = (void *)v247;
  uint64_t v127 = *(void *)(v247 + 216);
  int64_t v128 = v273;
  unint64_t v120 = v278;
  char v129 = v248;
  if (v127 < 0)
  {
    char v122 = v279;
    uint64_t v99 = v266;
    goto LABEL_115;
  }
  uint64_t v130 = *(void **)(v247 + 208);
  uint64_t v99 = v266;
  if (v127 != *(void *)(v247 + 224))
  {
LABEL_50:
    uint64_t v132 = v126[3];
    if (!v132) {
      goto LABEL_130;
    }
    if ((unint64_t)(v127 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_123:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/NativeDictionary.swift", 28, 2, 0x1FFuLL, 0);
    }
    char v133 = (void **)(v132 + 8 * v127);
    if ((v133 & 7) != 0) {
      goto LABEL_121;
    }
    uint64_t v134 = *v133;
    v126[27] = v127 + 1;
    swift_unknownObjectRetain(v134);
    uint64_t v135 = (swift *)[v130 objectForKey:v134];
    if (!v135) {
      goto LABEL_131;
    }
    uint64_t v136 = v135;
    size_t v137 = v280;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v280, v280))
    {
      v281 = (swift *)v134;
      swift_dynamicCast(v99, &v281, v246, v137, 7);
      unint64_t v138 = v256;
    }
    else
    {
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t *))v237)(v129, 1, 1, v137);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v134, (uint64_t)v137, v129);
      swift_unknownObjectRelease(v134);
      BOOL v141 = v238;
      uint64_t v142 = v234;
      (*(void (**)(char *, void *, Class *))v236)(v238, v129, v234);
      if (((unsigned int (*)(char *, uint64_t, uint64_t *))*v233)(v141, 1, v137) == 1) {
        goto LABEL_133;
      }
      (*v232)(v129, v142);
      unint64_t v138 = v256;
      (*(void (**)(char *, char *, uint64_t *))v256)(v99, v141, v137);
    }
    uint64_t v139 = &v99[*((int *)v279 + 12)];
    if (_swift_isClassOrObjCExistentialType((uint64_t)v128, v128))
    {
      v281 = v136;
      Swift::Int v140 = v128;
      swift_dynamicCast(v139, &v281, &unk_1ECA06328, v128, 7);
      unint64_t v119 = v280;
    }
    else
    {
      unint64_t v143 = v239;
      (*v231)(v239, 1, 1, v128);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v136, (uint64_t)v128, v143);
      swift_unknownObjectRelease(v136);
      unint64_t v144 = v240;
      uint64_t v145 = v235;
      (*v230)(v240, v143, v235);
      if ((*v229)(v144, 1, v128) == 1) {
        goto LABEL_133;
      }
      (*v228)(v143, v145);
      uint64_t v146 = v144;
      Swift::Int v140 = v128;
      (*v88)(v139, v146, v128);
      unint64_t v119 = v280;
      unint64_t v138 = v256;
    }
    uint64_t v102 = v279;
    (*v263)(v99, 0, 1, v279);
    uint64_t v94 = v267;
    char v100 = v138;
    uint64_t v101 = (void (**)(char *, char *, uint64_t *))v276;
    unint64_t v118 = v140;
    goto LABEL_35;
  }
  id v131 = [*(id *)(v247 + 208) countByEnumeratingWithState:v243 objects:v242 count:16];
  v126[28] = v131;
  if (v131)
  {
    uint64_t v127 = 0;
    v126[27] = 0;
    goto LABEL_50;
  }
  v126[27] = -1;
  char v122 = v279;
  unint64_t v78 = v257;
LABEL_115:
  (*v263)(v99, 1, 1, v122);
  swift_release((uint64_t)v68);
  uint64_t v218 = v78;
LABEL_118:
  outlined consume of [A : B].Iterator._Variant<A, B>(v218);
  return (uint64_t)v68;
}

BOOL _swift_dictionaryDownCastConditionalIndirect(unint64_t *a1, __objc2_class ***a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *a1;
  unint64_t v15 = swift_bridgeObjectRetain(*a1);
  uint64_t v17 = _dictionaryDownCastConditional<A, B, C, D>(_:)(v15, a3, a4, a5, a6, v16, a8);
  swift_bridgeObjectRelease(v14);
  if (v17) {
    *a2 = v17;
  }
  return v17 != 0;
}

__objc2_class **_dictionaryDownCastConditional<A, B, C, D>(_:)(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v330 = a7;
  v285 = type metadata accessor for Optional(0, a5, (uint64_t)a3, a4);
  uint64_t v284 = (uint64_t)*(v285 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v285);
  v315 = (void (**)(char *, char *, ValueMetadata *))((char *)&v267 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v12);
  v309 = (char *)&v267 - v14;
  v287 = type metadata accessor for Optional(0, a4, v15, v16);
  uint64_t v286 = (uint64_t)*(v287 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v287);
  unint64_t v321 = (unint64_t)&v267 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  v312 = (char *)&v267 - v19;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a4, a5, "key value ", 0);
  uint64_t v20 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  v307 = (char *)&v267 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  v300 = (char *)&v267 - v22;
  v327 = swift_getTupleTypeMetadata2(0, a4, a5, 0, 0);
  uint64_t v23 = MEMORY[0x1F4188790](v327);
  v306 = (char *)&v267 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v299 = (char *)&v267 - v26;
  uint64_t v338 = a5;
  unint64_t i = *(void *)(a5 - 8);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v305 = (char *)&v267 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  v304 = (char *)&v267 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v303 = (void (**)(void))((char *)&v267 - v32);
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v297 = (char *)&v267 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  v295 = (char *)&v267 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  v294 = (char *)&v267 - v38;
  v298 = (ValueMetadata *)a4;
  uint64_t v296 = *(void *)(a4 - 8);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  v302 = (void (**)(char *, char *, uint64_t *))((char *)&v267 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v314 = (char *)&v267 - v42;
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  v301 = (char *)&v267 - v44;
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  uint64_t v47 = (char *)&v267 - v46;
  uint64_t v48 = MEMORY[0x1F4188790](v45);
  v329 = (char *)&v267 - v49;
  MEMORY[0x1F4188790](v48);
  v293 = (char *)&v267 - v50;
  uint64_t v51 = swift_getTupleTypeMetadata2(0, (uint64_t)a2, (uint64_t)a3, "key value ", 0);
  v334 = (char *)*(v51 - 1);
  uint64_t v52 = MEMORY[0x1F4188790](v51);
  v318 = (char *)&v267 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v52);
  v316 = (char *)&v267 - v54;
  v281 = type metadata accessor for Optional(0, (uint64_t)a3, v55, v56);
  uint64_t v333 = (uint64_t)*(v281 - 1);
  uint64_t v57 = MEMORY[0x1F4188790](v281);
  v279 = (char *)&v267 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  uint64_t v61 = (char *)&v267 - v60;
  uint64_t v62 = MEMORY[0x1F4188790](v59);
  v277 = (char *)&v267 - v63;
  MEMORY[0x1F4188790](v62);
  int64_t v276 = (char *)&v267 - v64;
  v280 = type metadata accessor for Optional(0, (uint64_t)a2, v65, v66);
  uint64_t v67 = (uint64_t)*(v280 - 1);
  uint64_t v68 = MEMORY[0x1F4188790](v280);
  v278 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))((char *)&v267 - ((v69 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v70 = MEMORY[0x1F4188790](v68);
  v322 = (char *)&v267 - v71;
  uint64_t v72 = MEMORY[0x1F4188790](v70);
  v275 = (char *)&v267 - v73;
  uint64_t v74 = MEMORY[0x1F4188790](v72);
  uint64_t v274 = (char *)&v267 - v75;
  uint64_t v324 = *(a3 - 1);
  uint64_t v76 = MEMORY[0x1F4188790](v74);
  v313 = (char *)&v267 - ((v77 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v78 = MEMORY[0x1F4188790](v76);
  v308 = (char *)&v267 - v79;
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  v320 = (char *)&v267 - v81;
  v335 = a2;
  uint64_t v323 = *(a2 - 1);
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  v317 = (void (**)(char *, char *, uint64_t *))((char *)&v267 - ((v83 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  v311 = (char *)&v267 - v85;
  MEMORY[0x1F4188790](v84);
  v319 = (char *)&v267 - v86;
  unint64_t v89 = type metadata accessor for Optional(0, (uint64_t)v51, v87, v88);
  uint64_t v90 = MEMORY[0x1F4188790](v89 - 1);
  v325 = (char *)&v267 - ((v91 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v90);
  v332 = (char *)&v267 - v92;
  unint64_t v93 = a1 & 0xC000000000000001;
  if ((a1 & 0xC000000000000001) != 0)
  {
    int64_t v94 = a1;
    if (a1 < 0) {
      uint64_t v95 = (void *)a1;
    }
    else {
      uint64_t v95 = (void *)(a1 & 0xFFFFFFFFFFFFFF8);
    }
    id v96 = [v95 count];
  }
  else
  {
    int64_t v94 = a1;
    id v96 = *(id *)(a1 + 16);
  }
  v282 = v61;
  if (v96)
  {
    unint64_t v97 = v298;
    type metadata accessor for _DictionaryStorage(0, (uint64_t)v298, v338, v330);
    uint64_t v98 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v96);
  }
  else
  {
    uint64_t v98 = &_swiftEmptyDictionarySingleton;
    unint64_t v97 = v298;
  }
  v336 = v51;
  v337 = a3;
  v331 = v98;
  if (v97 == &type metadata for String)
  {
    if (v93)
    {
      if (v94 < 0) {
        uint64_t v105 = v94;
      }
      else {
        uint64_t v105 = v94 & 0xFFFFFFFFFFFFFF8;
      }
      Swift::String::Index v106 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v107 = (unint64_t)swift_allocObject(v106, 0xE8uLL, 7uLL);
      uint64_t v289 = 0;
      uint64_t v108 = 0;
      unint64_t v109 = 0;
      *(void *)(v107 + 208) = v105;
      *(void *)(v107 + 216) = 0;
      *(_OWORD *)(v107 + 16) = 0u;
      *(_OWORD *)(v107 + 32) = 0u;
      *(_OWORD *)(v107 + 48) = 0u;
      *(_OWORD *)(v107 + 64) = 0u;
      *(_OWORD *)(v107 + 80) = 0u;
      *(_OWORD *)(v107 + 96) = 0u;
      *(_OWORD *)(v107 + 112) = 0u;
      *(_OWORD *)(v107 + 128) = 0u;
      *(_OWORD *)(v107 + 144) = 0u;
      *(_OWORD *)(v107 + 160) = 0u;
      *(_OWORD *)(v107 + 176) = 0u;
      *(_OWORD *)(v107 + 192) = 0u;
      *(void *)(v107 + 224) = 0;
      unint64_t v110 = v107 | 0x8000000000000000;
    }
    else
    {
      uint64_t v180 = -1 << *(unsigned char *)(v94 + 32);
      uint64_t v108 = ~v180;
      uint64_t v181 = *(void *)(v94 + 64);
      uint64_t v289 = v94 + 64;
      uint64_t v182 = -v180;
      if (v182 < 64) {
        uint64_t v183 = ~(-1 << v182);
      }
      else {
        uint64_t v183 = -1;
      }
      unint64_t v109 = v183 & v181;
      unint64_t v110 = v94;
    }
    uint64_t v184 = v332;
    unint64_t v321 = v110;
    uint64_t v185 = v110 & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v283 = v185 + 16;
    uint64_t v291 = v185;
    v282 = (void *)(v185 + 80);
    v278 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v323 + 56);
    v273 = (void (**)(char *, char *, Class *))(v67 + 16);
    v272 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v323 + 48);
    v271 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v67 + 8);
    v303 = (void (**)(void))(v323 + 32);
    v270 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v324 + 56);
    v269 = (void (**)(char *, void *, Class *))(v333 + 16);
    v268 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v324 + 48);
    unint64_t v267 = (void (**)(void *, Class *))(v333 + 8);
    v302 = (void (**)(char *, char *, uint64_t *))(v324 + 32);
    v318 = v334 + 56;
    v279 = (char *)v108;
    int64_t v288 = (unint64_t)(v108 + 64) >> 6;
    v317 = (void (**)(char *, char *, uint64_t *))(v323 + 16);
    v326 = (void (**)(char *, char *, uint64_t *))(v324 + 16);
    v307 = v334 + 32;
    v313 = (char *)(v296 + 56);
    v315 = (void (**)(char *, char *, ValueMetadata *))(v296 + 32);
    v314 = v334 + 8;
    v305 = (char *)(i + 56);
    v325 = (char *)(i + 32);
    v292 = (char *)(v98 + 8);
    v301 = (char *)(v296 + 40);
    v298 = (ValueMetadata *)(i + 40);
    swift_bridgeObjectRetain(v94);
    uint64_t v186 = 0;
    v290 = (char *)&unk_1ECA06328;
    uint64_t v187 = v329;
    v304 = v47;
    while (1)
    {
      unint64_t v188 = v316;
      while (1)
      {
        uint64_t v189 = v321;
        v322 = (char *)v109;
        v306 = v186;
        if ((v321 & 0x8000000000000000) != 0)
        {
          unint64_t v191 = (void *)v291;
          uint64_t v192 = *(void *)(v291 + 216);
          if (v192 < 0) {
            goto LABEL_122;
          }
          char v193 = *(void **)(v291 + 208);
          if (v192 == *(void *)(v291 + 224))
          {
            id v194 = [*(id *)(v291 + 208) countByEnumeratingWithState:v283 objects:v282 count:16];
            v191[28] = v194;
            if (!v194)
            {
              v191[27] = -1;
              goto LABEL_122;
            }
            uint64_t v192 = 0;
            v191[27] = 0;
          }
          uint64_t v195 = v191[3];
          if (!v195) {
            goto LABEL_134;
          }
          char v196 = v312;
          if ((unint64_t)(v192 - 0x1000000000000000) >> 61 != 7) {
            goto LABEL_130;
          }
          size_t v197 = (void **)(v195 + 8 * v192);
          if ((v197 & 7) != 0) {
LABEL_125:
          }
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
          BOOL v198 = *v197;
          v191[27] = v192 + 1;
          swift_unknownObjectRetain(v198);
          Swift::Int v199 = (swift *)[v193 objectForKey:v198];
          if (!v199)
          {
LABEL_135:
            unint64_t v266 = 784;
            goto LABEL_136;
          }
          unint64_t v200 = v199;
          uint64_t v201 = v335;
          if (_swift_isClassOrObjCExistentialType((uint64_t)v335, v335))
          {
            v339 = (swift *)v198;
            swift_dynamicCast(v184, &v339, v290, v201, 7);
          }
          else
          {
            uint64_t v249 = v274;
            (*v278)(v274, 1, 1, v201);
            _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v198, (uint64_t)v201, v249);
            uint64_t v250 = v198;
            uint64_t v251 = v249;
            swift_unknownObjectRelease(v250);
            uint64_t v252 = v275;
            unint64_t v253 = v249;
            v254 = v280;
            (*v273)(v275, v253, v280);
            if ((*v272)(v252, 1, v201) == 1) {
              goto LABEL_137;
            }
            ((void (*)(char *, Class *))*v271)(v251, v254);
            uint64_t v184 = v332;
            (*v303)();
          }
          v202 = v337;
          unint64_t v203 = &v184[*((int *)v336 + 12)];
          if (_swift_isClassOrObjCExistentialType((uint64_t)v337, v337))
          {
            v339 = v200;
            swift_dynamicCast(v203, &v339, &unk_1ECA06328, v202, 7);
          }
          else
          {
            v255 = v276;
            (*v270)(v276, 1, 1, v202);
            _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v200, (uint64_t)v202, v255);
            v256 = v200;
            unint64_t v257 = v255;
            swift_unknownObjectRelease(v256);
            v258 = v277;
            v259 = v255;
            v260 = v281;
            (*v269)(v277, v259, v281);
            if ((*v268)(v258, 1, v202) == 1) {
LABEL_137:
            }
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
            (*v267)(v257, v260);
            (*v302)(v203, v258, v202);
            uint64_t v184 = v332;
          }
          uint64_t v204 = v336;
          (*(void (**)(char *, void, uint64_t, uint64_t *))v318)(v184, 0, 1, v336);
          uint64_t v333 = (uint64_t)v322;
          v334 = v186;
          uint64_t v205 = v335;
          uint64_t v206 = v317;
        }
        else
        {
          if (v109)
          {
            uint64_t v333 = (v109 - 1) & v109;
            v334 = v186;
            unint64_t v190 = __clz(__rbit64(v109)) | ((void)v186 << 6);
          }
          else
          {
            int64_t v207 = (int64_t)(v186 + 1);
            if (__OFADD__(v186, 1)) {
              goto LABEL_132;
            }
            if (v207 >= v288) {
              goto LABEL_122;
            }
            unint64_t v208 = *(void *)(v289 + 8 * v207);
            int64_t v209 = (int64_t)(v186 + 1);
            if (!v208)
            {
              int64_t v209 = (int64_t)(v186 + 2);
              if ((uint64_t)(v186 + 2) >= v288) {
                goto LABEL_122;
              }
              unint64_t v208 = *(void *)(v289 + 8 * v209);
              if (!v208)
              {
                long long v210 = v186 + 3;
                if ((uint64_t)(v186 + 3) >= v288) {
                  goto LABEL_122;
                }
                unint64_t v208 = *(void *)(v289 + 8 * (void)v210);
                if (!v208)
                {
                  while (1)
                  {
                    int64_t v209 = (int64_t)(v210 + 1);
                    if (__OFADD__(v210, 1)) {
                      goto LABEL_133;
                    }
                    if (v209 >= v288) {
                      break;
                    }
                    unint64_t v208 = *(void *)(v289 + 8 * v209);
                    ++v210;
                    if (v208) {
                      goto LABEL_98;
                    }
                  }
LABEL_122:
                  (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))v318)(v184, 1, 1, v336);
                  uint64_t v264 = v189;
                  goto LABEL_123;
                }
                int64_t v209 = (int64_t)(v186 + 3);
              }
            }
LABEL_98:
            uint64_t v333 = (v208 - 1) & v208;
            v334 = (char *)v209;
            unint64_t v190 = __clz(__rbit64(v208)) + (v209 << 6);
          }
          uint64_t v211 = v323;
          uint64_t v212 = v319;
          uint64_t v205 = v335;
          int64_t v213 = v317;
          (*(void (**)(char *, unint64_t, uint64_t *))(v323 + 16))(v319, *(void *)(v321 + 48) + *(void *)(v323 + 72) * v190, v335);
          uint64_t v214 = v324;
          unint64_t v215 = *(void *)(v189 + 56) + *(void *)(v324 + 72) * v190;
          uint64_t v216 = v320;
          uint64_t v217 = v337;
          (*(void (**)(char *, unint64_t, uint64_t *))(v324 + 16))(v320, v215, v337);
          uint64_t v204 = v336;
          uint64_t v218 = &v332[*((int *)v336 + 12)];
          v219 = *(void (**)(char *, char *, uint64_t *))(v211 + 32);
          uint64_t v184 = v332;
          v219(v332, v212, v205);
          v220 = v217;
          uint64_t v206 = v213;
          (*(void (**)(char *, char *, uint64_t *))(v214 + 32))(v218, v216, v220);
          (*(void (**)(char *, void, uint64_t, uint64_t *))v318)(v184, 0, 1, v204);
          char v196 = v312;
          uint64_t v187 = v329;
        }
        unint64_t v221 = v315;
        (*(void (**)(char *, char *, uint64_t *))v307)(v188, v184, v204);
        uint64_t v222 = *((int *)v204 + 12);
        uint64_t v223 = v311;
        (*v206)(v311, v188, v205);
        int v224 = swift_dynamicCast(v196, v223, v205, &type metadata for String, 6);
        v225 = *(void (**)(char *, uint64_t, uint64_t, ValueMetadata *))v313;
        if (!v224)
        {
          v225(v196, 1, 1, &type metadata for String);
          (*(void (**)(char *, uint64_t *))v314)(v188, v204);
          (*(void (**)(char *, Class *))(v286 + 8))(v196, v287);
          goto LABEL_113;
        }
        v225(v196, 0, 1, &type metadata for String);
        v226 = *v221;
        (*v221)(v187, v196, &type metadata for String);
        uint64_t v227 = v308;
        long long v228 = &v188[v222];
        int64_t v229 = v337;
        (*v326)(v308, v228, v337);
        (*(void (**)(char *, uint64_t *))v314)(v188, v204);
        uint64_t v230 = v309;
        char v231 = swift_dynamicCast(v309, v227, v229, v338, 6);
        uint64_t v232 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))v305;
        if ((v231 & 1) == 0)
        {
          v232(v230, 1, 1, v338);
          (*(void (**)(char *, ValueMetadata *))(v296 + 8))(v187, &type metadata for String);
          (*(void (**)(char *, Class *))(v284 + 8))(v230, v285);
LABEL_113:
          outlined consume of [A : B].Iterator._Variant<A, B>(v321);
          uint64_t v179 = v331;
LABEL_114:
          swift_release((uint64_t)v179);
          return 0;
        }
        uint64_t v233 = v338;
        v232(v230, 0, 1, v338);
        long long v234 = *(void (**)(char *, char *, uint64_t))v325;
        uint64_t v235 = v295;
        (*(void (**)(char *, char *, uint64_t))v325)(v295, v230, v233);
        unint64_t v236 = v300;
        v237 = &v300[*((int *)TupleTypeMetadata2 + 12)];
        v226(v300, v187, &type metadata for String);
        v234(v237, v235, v233);
        v238 = v327;
        uint64_t v239 = v299;
        v240 = &v299[*((int *)v327 + 12)];
        v226(v299, v236, &type metadata for String);
        v234(v240, v237, v233);
        int64_t v241 = &v239[*((int *)v238 + 12)];
        v242 = v293;
        v226(v293, v239, &type metadata for String);
        uint64_t v243 = v294;
        v234(v294, v241, v233);
        uint64_t v244 = (uint64_t)v304;
        v226(v304, v242, &type metadata for String);
        v245 = v297;
        v234(v297, v243, v233);
        uint64_t v98 = v331;
        unint64_t v246 = __RawDictionaryStorage.find<A>(_:)(v244, (uint64_t)&type metadata for String, v330);
        unint64_t v247 = v246;
        if ((v248 & 1) == 0) {
          break;
        }
        (*(void (**)(char *, uint64_t, ValueMetadata *))(v296 + 40))((char *)v98[6] + *(void *)(v296 + 72) * v246, v244, &type metadata for String);
        (*(void (**)(char *, char *, uint64_t))(i + 40))((char *)v98[7] + *(void *)(i + 72) * v247, v245, v338);
        unint64_t v109 = v333;
        uint64_t v186 = v334;
        uint64_t v187 = v329;
        unint64_t v188 = v316;
        uint64_t v184 = v332;
      }
      uint64_t v184 = v332;
      if (v98[2] >= v98[3]) {
        goto LABEL_127;
      }
      *(void *)&v292[(v246 >> 3) & 0x1FFFFFFFFFFFFFF8] |= 1 << v246;
      v226((char *)v98[6] + *(void *)(v296 + 72) * v246, (char *)v244, &type metadata for String);
      v234((char *)v98[7] + *(void *)(i + 72) * v247, v245, v338);
      unint64_t v261 = v98[2];
      BOOL v262 = __OFADD__(v261, 1);
      v263 = (__objc2_class *)((char *)&v261->isa + 1);
      if (v262)
      {
        __break(1u);
LABEL_129:
        __break(1u);
LABEL_130:
        __break(1u);
        goto LABEL_131;
      }
      unint64_t v98[2] = v263;
      unint64_t v109 = v333;
      uint64_t v186 = v334;
      uint64_t v187 = v329;
    }
  }
  if (v93)
  {
    if (v94 < 0) {
      uint64_t v99 = v94;
    }
    else {
      uint64_t v99 = v94 & 0xFFFFFFFFFFFFFF8;
    }
    char v100 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v101 = (unint64_t)swift_allocObject(v100, 0xE8uLL, 7uLL);
    uint64_t v291 = 0;
    uint64_t v102 = 0;
    unint64_t v103 = 0;
    *(void *)(v101 + 208) = v99;
    *(void *)(v101 + 216) = 0;
    *(_OWORD *)(v101 + 16) = 0u;
    *(_OWORD *)(v101 + 32) = 0u;
    *(_OWORD *)(v101 + 48) = 0u;
    *(_OWORD *)(v101 + 64) = 0u;
    *(_OWORD *)(v101 + 80) = 0u;
    *(_OWORD *)(v101 + 96) = 0u;
    *(_OWORD *)(v101 + 112) = 0u;
    *(_OWORD *)(v101 + 128) = 0u;
    *(_OWORD *)(v101 + 144) = 0u;
    *(_OWORD *)(v101 + 160) = 0u;
    *(_OWORD *)(v101 + 176) = 0u;
    *(_OWORD *)(v101 + 192) = 0u;
    *(void *)(v101 + 224) = 0;
    unint64_t v104 = v101 | 0x8000000000000000;
  }
  else
  {
    uint64_t v111 = -1 << *(unsigned char *)(v94 + 32);
    uint64_t v102 = ~v111;
    uint64_t v112 = *(void *)(v94 + 64);
    uint64_t v291 = v94 + 64;
    uint64_t v113 = -v111;
    if (v113 < 64) {
      uint64_t v114 = ~(-1 << v113);
    }
    else {
      uint64_t v114 = -1;
    }
    unint64_t v103 = v114 & v112;
    unint64_t v104 = v94;
  }
  uint64_t v289 = (v104 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  v293 = (char *)(v104 & 0x7FFFFFFFFFFFFFFFLL);
  int64_t v288 = (v104 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  v277 = (char *)(v323 + 56);
  int64_t v276 = (char *)(v67 + 16);
  v275 = (char *)(v323 + 48);
  uint64_t v274 = (char *)(v67 + 8);
  v295 = (char *)(v323 + 32);
  v273 = (void (**)(char *, char *, Class *))(v324 + 56);
  v272 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v333 + 16);
  v271 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v324 + 48);
  v270 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v333 + 8);
  v294 = (char *)(v324 + 32);
  v316 = v334 + 56;
  uint64_t v283 = v102;
  v290 = (char *)((unint64_t)(v102 + 64) >> 6);
  v312 = (char *)(v323 + 16);
  v329 = (char *)(v324 + 16);
  v308 = v334 + 32;
  v311 = (char *)(v296 + 56);
  v299 = (char *)(v296 + 32);
  v309 = v334 + 8;
  v300 = (char *)(i + 56);
  v297 = (char *)(i + 32);
  swift_bridgeObjectRetain(v94);
  swift_retain((atomic_ullong *)v98);
  unint64_t v115 = 0;
  v292 = (char *)&unk_1ECA06328;
  uint64_t v116 = v335;
  unint64_t v117 = (unint64_t)v298;
  for (i = v104; ; unint64_t v104 = i)
  {
    unint64_t v118 = v322;
    v326 = (void (**)(char *, char *, uint64_t *))v103;
    v332 = v115;
    if ((v104 & 0x8000000000000000) == 0)
    {
      unint64_t v119 = v336;
      unint64_t v120 = v337;
      unint64_t v121 = (void (**)(char *, char *, uint64_t *))v312;
      if (v103)
      {
        uint64_t v333 = (v103 - 1) & v103;
        v334 = v115;
        unint64_t v122 = __clz(__rbit64(v103)) | ((void)v115 << 6);
      }
      else
      {
        uint64_t v138 = (uint64_t)(v115 + 1);
        if (__OFADD__(v115, 1)) {
          goto LABEL_129;
        }
        if (v138 >= (uint64_t)v290) {
          goto LABEL_119;
        }
        unint64_t v139 = *(void *)(v291 + 8 * v138);
        uint64_t v140 = (uint64_t)(v115 + 1);
        BOOL v141 = v325;
        if (!v139)
        {
          uint64_t v140 = (uint64_t)(v115 + 2);
          if ((uint64_t)(v115 + 2) >= (uint64_t)v290) {
            goto LABEL_120;
          }
          unint64_t v139 = *(void *)(v291 + 8 * v140);
          if (!v139)
          {
            uint64_t v142 = v115 + 3;
            if ((uint64_t)(v115 + 3) >= (uint64_t)v290) {
              goto LABEL_120;
            }
            unint64_t v139 = *(void *)(v291 + 8 * (void)v142);
            if (!v139)
            {
              while (1)
              {
                uint64_t v140 = (uint64_t)(v142 + 1);
                if (__OFADD__(v142, 1)) {
                  break;
                }
                if (v140 >= (uint64_t)v290) {
                  goto LABEL_120;
                }
                unint64_t v139 = *(void *)(v291 + 8 * v140);
                ++v142;
                if (v139) {
                  goto LABEL_53;
                }
              }
LABEL_131:
              __break(1u);
LABEL_132:
              __break(1u);
LABEL_133:
              __break(1u);
LABEL_134:
              unint64_t v266 = 773;
LABEL_136:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v266, 0);
            }
            uint64_t v140 = (uint64_t)(v115 + 3);
          }
        }
LABEL_53:
        uint64_t v333 = (v139 - 1) & v139;
        v334 = (char *)v140;
        unint64_t v122 = __clz(__rbit64(v139)) + (v140 << 6);
      }
      uint64_t v143 = v323;
      unint64_t v144 = v319;
      (*(void (**)(char *, unint64_t, uint64_t *))(v323 + 16))(v319, *(void *)(v104 + 48) + *(void *)(v323 + 72) * v122, v116);
      uint64_t v145 = *(void *)(v104 + 56);
      uint64_t v146 = v324;
      uint64_t v147 = v320;
      (*(void (**)(char *, unint64_t, uint64_t *))(v324 + 16))(v320, v145 + *(void *)(v324 + 72) * v122, v120);
      uint64_t v136 = v325;
      uint64_t v148 = &v325[*((int *)v119 + 12)];
      (*(void (**)(char *, char *, uint64_t *))(v143 + 32))(v325, v144, v116);
      (*(void (**)(char *, char *, uint64_t *))(v146 + 32))(v148, v147, v120);
      (*(void (**)(char *, void, uint64_t, uint64_t *))v316)(v136, 0, 1, v119);
      unint64_t v117 = (unint64_t)v298;
      uint64_t v125 = v321;
      uint64_t v135 = v318;
      char v129 = v311;
      goto LABEL_55;
    }
    unint64_t v123 = v293;
    uint64_t v124 = *((void *)v293 + 27);
    unint64_t v119 = v336;
    unint64_t v120 = v337;
    uint64_t v125 = v321;
    if (v124 < 0) {
      goto LABEL_119;
    }
    unint64_t v126 = (void *)*((void *)v293 + 26);
    if (v124 == *((void *)v293 + 28)) {
      break;
    }
LABEL_33:
    uint64_t v128 = *((void *)v123 + 3);
    if (!v128) {
      goto LABEL_134;
    }
    char v129 = v311;
    if ((unint64_t)(v124 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_127:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/NativeDictionary.swift", 28, 2, 0x1FFuLL, 0);
    }
    uint64_t v130 = (void **)(v128 + 8 * v124);
    if ((v130 & 7) != 0) {
      goto LABEL_125;
    }
    id v131 = *v130;
    *((void *)v123 + 27) = v124 + 1;
    swift_unknownObjectRetain(v131);
    uint64_t v132 = (swift)[v126 objectForKey:v131];
    if (!v132) {
      goto LABEL_135;
    }
    char v133 = v132;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v116, v116);
    uint64_t v135 = v318;
    if (isClassOrObjCExistentialType)
    {
      v339 = (swift *)v131;
      uint64_t v136 = v325;
      swift_dynamicCast(v325, &v339, v292, v116, 7);
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))v277)(v118, 1, 1, v116);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v131, (uint64_t)v116, v118);
      swift_unknownObjectRelease(v131);
      BOOL v171 = v278;
      Swift::String::Index v172 = v118;
      Swift::String::Index v173 = v280;
      (*(void (**)(void (**)(char *, uint64_t, uint64_t, uint64_t *), char *, Class *))v276)(v278, v172, v280);
      if ((*(unsigned int (**)(void (**)(char *, uint64_t, uint64_t, uint64_t *), uint64_t, uint64_t *))v275)(v171, 1, v116) == 1)goto LABEL_137; {
      (*(void (**)(char *, Class *))v274)(v322, v173);
      }
      uint64_t v136 = v325;
      (*(void (**)(char *, void (**)(char *, uint64_t, uint64_t, uint64_t *), uint64_t *))v295)(v325, v171, v116);
    }
    size_t v137 = &v136[*((int *)v119 + 12)];
    if (_swift_isClassOrObjCExistentialType((uint64_t)v120, v120))
    {
      v339 = v133;
      swift_dynamicCast(v137, &v339, &unk_1ECA06328, v120, 7);
    }
    else
    {
      Swift::String::Index v174 = v282;
      ((void (*)(void *, uint64_t, uint64_t, uint64_t *))*v273)(v282, 1, 1, v120);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v133, (uint64_t)v120, v174);
      swift_unknownObjectRelease(v133);
      Swift::String::Index v175 = v279;
      uint64_t v176 = v174;
      uint64_t v177 = v281;
      (*v272)(v279, (uint64_t)v176, (uint64_t *)v281);
      if ((*v271)(v175, 1, v120) == 1) {
        goto LABEL_137;
      }
      ((void (*)(void *, Class *))*v270)(v282, v177);
      (*(void (**)(char *, char *, uint64_t *))v294)(v137, v175, v120);
      uint64_t v136 = v325;
    }
    (*(void (**)(char *, void, uint64_t, uint64_t *))v316)(v136, 0, 1, v119);
    uint64_t v333 = (uint64_t)v326;
    v334 = v332;
    unint64_t v121 = (void (**)(char *, char *, uint64_t *))v312;
LABEL_55:
    (*(void (**)(char *, char *, uint64_t *))v308)(v135, v136, v119);
    uint64_t v149 = *((int *)v119 + 12);
    uint64_t v150 = v317;
    (*v121)((char *)v317, v135, v116);
    int v151 = swift_dynamicCast(v125, v150, v116, v117, 6);
    unint64_t v152 = *(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))v129;
    if (!v151)
    {
      v152(v125, 1, 1, v117);
      (*(void (**)(char *, uint64_t *))v309)(v135, v119);
      (*(void (**)(uint64_t, Class *))(v286 + 8))(v125, v287);
LABEL_64:
      uint64_t v178 = v331;
      swift_release((uint64_t)v331);
      outlined consume of [A : B].Iterator._Variant<A, B>(i);
      uint64_t v179 = v178;
      goto LABEL_114;
    }
    v152(v125, 0, 1, v117);
    unint64_t v153 = *(void (**)(char *, char *, unint64_t))v299;
    uint64_t v154 = v314;
    (*(void (**)(char *, uint64_t, unint64_t))v299)(v314, v125, v117);
    unint64_t v155 = v313;
    (*(void (**)(char *, char *, uint64_t *))v329)(v313, &v135[v149], v120);
    (*(void (**)(char *, uint64_t *))v309)(v135, v119);
    unint64_t v156 = (char *)v315;
    char v157 = swift_dynamicCast(v315, v155, v120, v338, 6);
    uint64_t v158 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))v300;
    if ((v157 & 1) == 0)
    {
      v158(v156, 1, 1, v338);
      (*(void (**)(char *, unint64_t))(v296 + 8))(v154, v117);
      (*(void (**)(char *, Class *))(v284 + 8))(v156, v285);
      goto LABEL_64;
    }
    uint64_t v159 = v338;
    v158(v156, 0, 1, v338);
    uint64_t v160 = *(void (**)(char *, char *, uint64_t))v297;
    unint64_t v161 = v304;
    (*(void (**)(char *, char *, uint64_t))v297)(v304, v156, v159);
    unint64_t v162 = v307;
    id v163 = &v307[*((int *)TupleTypeMetadata2 + 12)];
    v153(v307, v154, v117);
    v160(v163, v161, v159);
    uint64_t v164 = v327;
    uint64_t v165 = v306;
    v332 = &v306[*((int *)v327 + 12)];
    v153(v306, v162, v117);
    v160(v332, v163, v159);
    int64_t v166 = &v165[*((int *)v164 + 12)];
    char v167 = v301;
    v153(v301, v165, v117);
    int64_t v168 = v303;
    v160((char *)v303, v166, v159);
    uint64_t v169 = (uint64_t)v302;
    v153((char *)v302, v167, v117);
    uint64_t v170 = (uint64_t)v305;
    v160(v305, (char *)v168, v159);
    _NativeDictionary._unsafeInsertNew(key:value:)(v169, v170, v331, v117, v159, v330);
    unint64_t v103 = v333;
    unint64_t v115 = v334;
    uint64_t v116 = v335;
  }
  id v127 = [*((id *)v293 + 26) countByEnumeratingWithState:v289 objects:v288 count:16];
  unint64_t v123 = v293;
  *((void *)v293 + 28) = v127;
  if (v127)
  {
    uint64_t v124 = 0;
    *((void *)v123 + 27) = 0;
    goto LABEL_33;
  }
  *((void *)v123 + 27) = -1;
LABEL_119:
  BOOL v141 = v325;
LABEL_120:
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))v316)(v141, 1, 1, v119);
  uint64_t v98 = v331;
  swift_release((uint64_t)v331);
  uint64_t v264 = v104;
LABEL_123:
  outlined consume of [A : B].Iterator._Variant<A, B>(v264);
  return v98;
}

uint64_t (*__RawDictionaryStorage._count.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._capacity.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._scale.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._reservedScale.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._age.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._seed.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._rawKeys.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawDictionaryStorage._rawValues.setter(uint64_t result)
{
  *(void *)(v1 + 56) = result;
  return result;
}

uint64_t (*__RawDictionaryStorage._rawValues.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawDictionaryStorage._metadata.getter()
{
  return v0 + 64;
}

uint64_t __RawDictionaryStorage._hashTable.getter()
{
  return v0 + 64;
}

void __RawDictionaryStorage.__allocating_init(coder:)()
{
}

void __RawDictionaryStorage.init(coder:)()
{
}

uint64_t __RawDictionaryStorage.deinit()
{
  return v0;
}

void __RawDictionaryStorage.__deallocating_deinit()
{
  swift_deallocClassInstance(v0);
}

uint64_t __EmptyDictionarySingleton.deinit()
{
  return v0;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(uint64_t a1)
{
  uint64_t v3 = specialized static Hasher._hash(seed:_:)(*(void *)(v1 + 40), a1);
  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v3);
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ *(void *)(v2 + 40);
  v8[0] = 0;
  v8[1] = v5 ^ 0x736F6D6570736575;
  _OWORD v8[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v8[3] = v5 ^ 0x6C7967656E657261;
  v8[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v9 = 0u;
  long long v10 = 0u;
  String.hash(into:)(v8, a1, a2);
  Swift::Int v6 = Hasher._finalize()();

  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v6);
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(void *a1)
{
  uint64_t v3 = *(void *)(v1 + 40);
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 8))(v10, v4, v5);
  uint64_t v6 = v11;
  uint64_t v7 = v12;
  __swift_project_boxed_opaque_existential_0Tm(v10, v11);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(v3, v6, v7);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v8);
}

unint64_t __RawDictionaryStorage.find<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = (*(uint64_t (**)(void))(a3 + 32))(*(void *)(v4 + 40));

  return __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v7, a2);
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)(void *a1, uint64_t a2)
{
  uint64_t v3 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v4 = a2 & ~v3;
  uint64_t v16 = v2 + 64;
  if ((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4))
  {
    uint64_t v5 = v2;
    uint64_t v7 = ~v3;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v4, (uint64_t)v21);
      uint64_t v8 = v22;
      uint64_t v9 = v23;
      __swift_project_boxed_opaque_existential_0Tm(v21, v22);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v9 + 8))(v18, v8, v9);
      uint64_t v10 = v19;
      uint64_t v11 = v20;
      __swift_project_boxed_opaque_existential_0Tm(v18, v19);
      uint64_t v12 = a1[3];
      uint64_t v13 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v12);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v13 + 8))(v17, v12, v13);
      char v14 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v11 + 16))(v17, v10, v11);
      __swift_destroy_boxed_opaque_existential_1Tm(v17);
      if (v14 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
        if (v14) {
          return v4;
        }
      }
      unint64_t v4 = (v4 + 1) & v7;
    }
    while (((*(void *)(v16 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4) & 1) != 0);
  }
  return v4;
}

{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v16;
  uint64_t v17[5];
  uint64_t v18[3];
  uint64_t v19;
  uint64_t v20;
  uint64_t v21[3];
  uint64_t v22;
  uint64_t v23;

  uint64_t v3 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v4 = a2 & ~v3;
  uint64_t v16 = v2 + 64;
  if ((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4))
  {
    uint64_t v5 = v2;
    uint64_t v7 = ~v3;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v4, (uint64_t)v21);
      uint64_t v8 = v22;
      uint64_t v9 = v23;
      __swift_project_boxed_opaque_existential_0Tm(v21, v22);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v9 + 8))(v18, v8, v9);
      uint64_t v10 = v19;
      uint64_t v11 = v20;
      __swift_project_boxed_opaque_existential_0Tm(v18, v19);
      uint64_t v12 = a1[3];
      uint64_t v13 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v12);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v13 + 8))(v17, v12, v13);
      char v14 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v11 + 16))(v17, v10, v11);
      __swift_destroy_boxed_opaque_existential_1Tm(v17);
      if (v14 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
        if (v14) {
          return v4;
        }
      }
      unint64_t v4 = (v4 + 1) & v7;
    }
    while (((*(void *)(v16 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4) & 1) != 0);
  }
  return v4;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if ((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6))
  {
    uint64_t v9 = ~v5;
    uint64_t v10 = *(void *)(v3 + 48);
    do
    {
      uint64_t v11 = (uint64_t *)(v10 + 16 * v6);
      unint64_t v12 = v11[1];
      if (*v11 == a1 && v12 == a2) {
        break;
      }
      BOOL v14 = (~v12 & 0x6000000000000000) != 0 || (a2 & 0x2000000000000000) == 0;
      BOOL v15 = v14 || (a2 & 0x4000000000000000) == 0;
      if (v15 && (_stringCompareInternal(_:_:expecting:)(*v11, v12, a1, a2, 0) & 1) != 0) {
        break;
      }
      unint64_t v6 = (v6 + 1) & v9;
    }
    while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
  }
  return v6;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  BOOL v14;
  BOOL v15;

  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if ((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6))
  {
    uint64_t v9 = ~v5;
    uint64_t v10 = *(void *)(v3 + 48);
    do
    {
      uint64_t v11 = (uint64_t *)(v10 + 16 * v6);
      unint64_t v12 = v11[1];
      if (*v11 == a1 && v12 == a2) {
        break;
      }
      BOOL v14 = (~v12 & 0x6000000000000000) != 0 || (a2 & 0x2000000000000000) == 0;
      BOOL v15 = v14 || (a2 & 0x4000000000000000) == 0;
      if (v15 && (_stringCompareInternal(_:_:expecting:)(*v11, v12, a1, a2, 0) & 1) != 0) {
        break;
      }
      unint64_t v6 = (v6 + 1) & v9;
    }
    while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
  }
  return v6;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t result = a2 & ~v4;
  if ((*(void *)(v2 + 64 + ((result >> 3) & 0xFFFFFFFFFFFFFF8)) >> result))
  {
    uint64_t v6 = ~v4;
    do
    {
      if (*(void *)(*(void *)(v2 + 48) + 8 * result) == a1) {
        break;
      }
      unint64_t result = (result + 1) & v6;
    }
    while (((*(void *)(v2 + 64 + ((result >> 3) & 0xFFFFFFFFFFFFFF8)) >> result) & 1) != 0);
  }
  return result;
}

unint64_t __RawDictionaryStorage.find<A>(_:hashValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = a1;
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v20 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = v3;
  uint64_t v9 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t v11 = v10 & ~v9;
  uint64_t v23 = v3 + 64;
  if ((*(void *)(v3 + 64 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11))
  {
    uint64_t v20 = ~v9;
    uint64_t v22 = *(void *)(v5 + 8);
    uint64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 8);
    BOOL v14 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    uint64_t v12 = v6 + 16;
    uint64_t v13 = v14;
    uint64_t v15 = *(void *)(v12 + 56);
    uint64_t v16 = (void (**)(char *, uint64_t))(v12 - 8);
    do
    {
      uint64_t v17 = v12;
      v13(v8, *(void *)(v25 + 48) + v15 * v11, a3);
      char v18 = v21(v8, v24, a3, v22);
      (*v16)(v8, a3);
      if (v18) {
        break;
      }
      unint64_t v11 = (v11 + 1) & v20;
      uint64_t v12 = v17;
    }
    while (((*(void *)(v23 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11) & 1) != 0);
  }
  return v11;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.idealBucket(forHashValue:)(Swift::Int forHashValue)
{
  return (Swift::_HashTable::Bucket)(v1 & forHashValue);
}

Swift::_HashTable::Bucket __swiftcall _HashTable.bucket(wrappedAfter:)(Swift::_HashTable::Bucket wrappedAfter)
{
  return (Swift::_HashTable::Bucket)((wrappedAfter.offset + 1) & v1);
}

void _DictionaryStorage.deinit()
{
  if (v0[2] < 1) {
    return;
  }
  uint64_t v1 = *v0;
  uint64_t v2 = *(unint64_t **)(*v0 + 176);
  if ((*(unsigned char *)(*(v2 - 1) + 82) & 1) == 0) {
    goto LABEL_3;
  }
  uint64_t v4 = *(v2 - 1);
  int64_t v5 = 0;
  uint64_t v6 = v0 + 8;
  uint64_t v7 = v0[6];
  uint64_t v8 = 1 << *((unsigned char *)v0 + 32);
  uint64_t v9 = -1;
  if (v8 < 64) {
    uint64_t v9 = ~(-1 << v8);
  }
  unint64_t v10 = v9 & v0[8];
  int64_t v11 = (unint64_t)(v8 + 63) >> 6;
  while (1)
  {
    if (v10)
    {
      unint64_t v12 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v13 = v12 | (v5 << 6);
      goto LABEL_10;
    }
    BOOL v14 = __OFADD__(v5++, 1);
    if (v14) {
      goto LABEL_40;
    }
    if (v5 >= v11) {
      goto LABEL_3;
    }
    unint64_t v15 = v6[v5];
    if (!v15) {
      break;
    }
LABEL_21:
    unint64_t v10 = (v15 - 1) & v15;
    unint64_t v13 = __clz(__rbit64(v15)) + (v5 << 6);
LABEL_10:
    swift_arrayDestroy(v7 + *(void *)(v4 + 72) * v13, 1, v2);
  }
  int64_t v16 = v5 + 1;
  if (v5 + 1 >= v11) {
    goto LABEL_3;
  }
  unint64_t v15 = v6[v16];
  if (v15)
  {
    ++v5;
    goto LABEL_21;
  }
  while (1)
  {
    int64_t v5 = v16 + 1;
    if (__OFADD__(v16, 1))
    {
      __break(1u);
      goto LABEL_39;
    }
    if (v5 >= v11) {
      break;
    }
    unint64_t v15 = v6[v5];
    ++v16;
    if (v15) {
      goto LABEL_21;
    }
  }
LABEL_3:
  uint64_t v3 = *(unint64_t **)(v1 + 184);
  if ((*(unsigned char *)(*(v3 - 1) + 82) & 1) == 0)
  {
LABEL_4:
    v0[2] = 0;
    return;
  }
  uint64_t v17 = *(v3 - 1);
  int64_t v18 = 0;
  uint64_t v19 = v0 + 8;
  uint64_t v20 = v0[7];
  uint64_t v21 = 1 << *((unsigned char *)v0 + 32);
  uint64_t v22 = -1;
  if (v21 < 64) {
    uint64_t v22 = ~(-1 << v21);
  }
  unint64_t v23 = v22 & v0[8];
  int64_t v24 = (unint64_t)(v21 + 63) >> 6;
  while (2)
  {
    if (v23)
    {
      unint64_t v25 = __clz(__rbit64(v23));
      v23 &= v23 - 1;
      unint64_t v26 = v25 | (v18 << 6);
LABEL_26:
      swift_arrayDestroy(v20 + *(void *)(v17 + 72) * v26, 1, v3);
      continue;
    }
    break;
  }
  BOOL v14 = __OFADD__(v18++, 1);
  if (v14) {
    goto LABEL_41;
  }
  if (v18 >= v24) {
    goto LABEL_4;
  }
  unint64_t v27 = v19[v18];
  if (v27)
  {
LABEL_37:
    unint64_t v23 = (v27 - 1) & v27;
    unint64_t v26 = __clz(__rbit64(v27)) + (v18 << 6);
    goto LABEL_26;
  }
  int64_t v28 = v18 + 1;
  if (v18 + 1 >= v24) {
    goto LABEL_4;
  }
  unint64_t v27 = v19[v28];
  if (v27)
  {
    ++v18;
    goto LABEL_37;
  }
  while (1)
  {
    int64_t v18 = v28 + 1;
    if (__OFADD__(v28, 1)) {
      break;
    }
    if (v18 >= v24) {
      goto LABEL_4;
    }
    unint64_t v27 = v19[v18];
    ++v28;
    if (v27) {
      goto LABEL_37;
    }
  }
LABEL_39:
  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
}

uint64_t _DictionaryStorage._values.getter()
{
  return *(void *)(v0 + 56);
}

void _DictionaryStorage.__deallocating_deinit()
{
  _DictionaryStorage.deinit();

  swift_deallocClassInstance(v0);
}

void @objc _DictionaryStorage.init(objects:forKeys:count:)()
{
}

uint64_t @objc _DictionaryStorage.count.getter()
{
  return _ContiguousArrayStorage.count.getter();
}

void *_DictionaryStorage.keyEnumerator()()
{
  uint64_t v1 = (unint64_t *)type metadata accessor for _SwiftDictionaryNSEnumerator(0, *(void *)(*v0 + 176), *(void *)(*v0 + 184), *(void *)(*v0 + 192));
  uint64_t v2 = swift_allocObject(v1, 0x30uLL, 7uLL);
  v2[2] = v0;
  v2[3] = 0;
  uint64_t v3 = -1 << *((unsigned char *)v0 + 32);
  v2[4] = _HashTable.startBucket.getter((unint64_t *)v0 + 8, ~v3);
  v2[5] = -v3;
  swift_retain(v0);
  return v2;
}

void *@objc _DictionaryStorage.keyEnumerator()()
{
  uint64_t v0 = _DictionaryStorage.keyEnumerator()();

  return v0;
}

uint64_t _DictionaryStorage.countByEnumerating(with:objects:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(uint64_t **)(*(void *)v3 + 176);
  uint64_t v8 = *(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  int64_t v11 = (id *)((char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v46 = v10;
  MEMORY[0x1F4188790](v9);
  unint64_t v13 = (id *)((char *)&v32 - v12);
  BOOL v14 = (unint64_t *)(v3 + 64);
  uint64_t v15 = -1 << *(unsigned char *)(v3 + 32);
  uint64_t v16 = *(void *)v6;
  long long v17 = *(_OWORD *)(v6 + 32);
  long long v40 = *(_OWORD *)(v6 + 48);
  long long v41 = v17;
  uint64_t v47 = (unint64_t *)(v3 + 64);
  if (!v16)
  {
    unint64_t v27 = _HashTable.startBucket.getter(v14, ~v15);
    if ((v27 & 0x8000000000000000) != 0) {
      goto LABEL_39;
    }
    unint64_t v19 = v27;
    uint64_t v38 = a2;
    uint64_t v39 = &_fastEnumerationStorageMutationsTarget;
    uint64_t v16 = 1;
    BOOL v14 = v47;
    if (a2) {
      goto LABEL_3;
    }
    return 0;
  }
  int64_t v18 = *(Swift::UInt **)(v6 + 16);
  unint64_t v19 = *(void *)(v6 + 24);
  uint64_t v38 = *(void *)(v6 + 8);
  uint64_t v39 = v18;
  if (!a2) {
    return 0;
  }
LABEL_3:
  if ((v19 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  uint64_t v37 = v16;
  uint64_t v35 = v11;
  uint64_t v20 = -v15;
  if (v19 + v15
    && ((uint64_t)v19 >= v20
     || ((*(unint64_t *)((char *)v14 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v19) & 1) == 0))
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid fast enumeration state", 30, 2, "Swift/DictionaryStorage.swift", 29, 2, 0x167uLL, 0);
  }
  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (!a3)
  {
    uint64_t v28 = v37;
    goto LABEL_35;
  }
  uint64_t v45 = a3;
  uint64_t v36 = v6;
  a3 = 0;
  uint64_t v43 = a2;
  uint64_t v44 = v8 + 16;
  unint64_t v42 = (unint64_t)(63 - v15) >> 6;
  unint64_t v34 = v42 - 3;
  uint64_t v32 = (void (**)(id *, id *, uint64_t *))(v8 + 32);
  uint64_t v33 = v3 + 88;
  do
  {
    if (v19 == v20)
    {
      unint64_t v19 = v20;
      goto LABEL_34;
    }
    (*(void (**)(id *, unint64_t, uint64_t *))(v8 + 16))(v13, *(void *)(v3 + 48) + *(void *)(v8 + 72) * v19, v7);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v7, v7))
    {
      if (v46 != 8) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
      uint64_t v21 = *v13;
      uint64_t v22 = *(void (**)(id *, uint64_t *))(v8 + 8);
      swift_unknownObjectRetain(*v13);
      v22(v13, v7);
    }
    else
    {
      unint64_t v26 = v35;
      (*v32)(v35, v13, v7);
      uint64_t v21 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v26, v7);
    }
    if (a3 == 0x1000000000000000)
    {
      __break(1u);
LABEL_39:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    *(void *)(v43 + 8 * a3) = v21;
    swift_unknownObjectRelease(v21);
    unint64_t v23 = v19 >> 6;
    if ((v47[v19 >> 6] & (-2 << v19)) != 0)
    {
      unint64_t v19 = __clz(__rbit64(v47[v19 >> 6] & (-2 << v19))) | v19 & 0xFFFFFFFFFFFFFFC0;
      goto LABEL_11;
    }
    unint64_t v24 = v23 + 1;
    unint64_t v19 = v20;
    if (v23 + 1 < v42)
    {
      unint64_t v25 = v47[v24];
      if (v25) {
        goto LABEL_20;
      }
      unint64_t v24 = v23 + 2;
      unint64_t v19 = v20;
      if (v23 + 2 < v42)
      {
        unint64_t v25 = v47[v24];
        if (v25)
        {
LABEL_20:
          unint64_t v19 = __clz(__rbit64(v25)) + (v24 << 6);
          goto LABEL_11;
        }
        while (v34 != v23)
        {
          unint64_t v25 = *(void *)(v33 + 8 * v23++);
          if (v25)
          {
            unint64_t v24 = v23 + 2;
            goto LABEL_20;
          }
        }
        unint64_t v19 = v20;
      }
    }
LABEL_11:
    ++a3;
  }
  while (a3 != v45);
  uint64_t v20 = v19;
  a3 = v45;
LABEL_34:
  uint64_t v6 = v36;
  uint64_t v28 = v37;
  if (v20 < 0) {
    goto LABEL_39;
  }
LABEL_35:
  *(void *)uint64_t v6 = v28;
  uint64_t v29 = v39;
  *(void *)(v6 + 8) = v38;
  *(void *)(v6 + 16) = v29;
  *(void *)(v6 + 24) = v19;
  long long v30 = v40;
  *(_OWORD *)(v6 + 32) = v41;
  *(_OWORD *)(v6 + 48) = v30;
  return a3;
}

uint64_t @objc _DictionaryStorage.countByEnumerating(with:objects:count:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)(a1, a2, a3, a4, a5, _DictionaryStorage.countByEnumerating(with:objects:count:));
}

atomic_ullong *_DictionaryStorage.object(forKey:)(void *a1)
{
  uint64_t v26 = *v1;
  uint64_t v3 = *(uint64_t **)(v26 + 184);
  uint64_t v25 = *(v3 - 1);
  MEMORY[0x1F4188790](a1);
  int64_t v5 = (id *)((char *)&v25 - v4);
  uint64_t v7 = *(char **)(v6 + 176);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)v7, v8, v9);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  BOOL v14 = (char *)&v25 - v13;
  uint64_t v15 = *((void *)v7 - 1);
  MEMORY[0x1F4188790](v12);
  long long v17 = (char *)&v25 - v16;
  _conditionallyBridgeFromObjectiveC<A>(_:_:)(a1, v7, v18, v14);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v15 + 48))(v14, 1, v7) == 1)
  {
    (*(void (**)(char *, Class *))(v11 + 8))(v14, v10);
    return 0;
  }
  (*(void (**)(char *, char *, char *))(v15 + 32))(v17, v14, v7);
  unint64_t v19 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)v7, *(void *)(v26 + 192));
  char v21 = v20;
  (*(void (**)(char *, char *))(v15 + 8))(v17, v7);
  if ((v21 & 1) == 0) {
    return 0;
  }
  uint64_t v22 = v25;
  (*(void (**)(id *, unint64_t, uint64_t *))(v25 + 16))(v5, v1[7] + *(void *)(v25 + 72) * v19, v3);
  unint64_t v23 = _bridgeAnythingToObjectiveC<A>(_:)(v5, v3);
  (*(void (**)(id *, uint64_t *))(v22 + 8))(v5, v3);
  return v23;
}

id @objc _DictionaryStorage.object(forKey:)(atomic_ullong *a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDeferredNSDictionary.object(forKey:)(a1, a2, a3, (uint64_t (*)(void *))_DictionaryStorage.object(forKey:));
}

void _DictionaryStorage.getObjects(_:andKeys:count:)(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  id v131 = a2;
  uint64_t v132 = a1;
  uint64_t v134 = *(void *)(*(void *)(*(void *)v3 + 184) - 8);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  uint64_t v128 = (id *)((char *)&v111 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v114 = (id *)((char *)&v111 - v8);
  uint64_t v130 = v9;
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v136 = (id *)((char *)&v111 - v11);
  uint64_t v133 = *(void *)(*(void *)(v12 + 176) - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  int64_t v121 = (int64_t)&v111 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v113 = (id *)((char *)&v111 - v16);
  char v129 = v17;
  MEMORY[0x1F4188790](v15);
  unint64_t v19 = (id *)((char *)&v111 - v18);
  uint64_t v138 = (uint64_t *)v21;
  unint64_t v139 = v20;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, (uint64_t)v20, v21, "key value ", 0);
  size_t v137 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v23, v24);
  uint64_t v25 = MEMORY[0x1F4188790](v137);
  unint64_t v27 = (char *)&v111 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  long long v30 = (char *)&v111 - v29;
  uint64_t v31 = MEMORY[0x1F4188790](v28);
  uint64_t v33 = (char *)&v111 - v32;
  uint64_t v34 = MEMORY[0x1F4188790](v31);
  uint64_t v36 = (char *)&v111 - v35;
  uint64_t v37 = MEMORY[0x1F4188790](v34);
  uint64_t v39 = (char *)&v111 - v38;
  MEMORY[0x1F4188790](v37);
  unint64_t v122 = (id *)((char *)&v111 - v41);
  if (a3 < 0) {
    goto LABEL_101;
  }
  if (a3)
  {
    uint64_t v135 = v3;
    if (v131)
    {
      uint64_t v42 = *(void *)(v3 + 64);
      uint64_t v115 = v3 + 64;
      uint64_t v43 = 1 << *(unsigned char *)(v3 + 32);
      uint64_t v44 = -1;
      if (v43 < 64) {
        uint64_t v44 = ~(-1 << v43);
      }
      unint64_t v45 = v44 & v42;
      unint64_t v46 = (unint64_t)(v43 + 63) >> 6;
      uint64_t v128 = (id *)(TupleTypeMetadata2 - 1);
      uint64_t v124 = v133 + 16;
      uint64_t v123 = v134 + 16;
      id v127 = (void (**)(char *, char *, Class *))(v40 + 32);
      unint64_t v126 = (void (**)(id *, char *, uint64_t *))(v133 + 32);
      uint64_t v125 = (void (**)(char *, uint64_t *))(v134 + 8);
      int64_t v116 = v46;
      if (v132)
      {
        unint64_t v120 = (id *)(v134 + 32);
        unint64_t v118 = (void (**)(id *, uint64_t *))(v133 + 8);
        unint64_t v112 = v46 - 1;
        swift_retain((atomic_ullong *)v3);
        uint64_t v47 = 0;
        int64_t v121 = 0;
        uint64_t v119 = a3;
        uint64_t v48 = (char *)v122;
        while (!v45)
        {
          int64_t v61 = v121 + 1;
          if (__OFADD__(v121, 1)) {
            goto LABEL_100;
          }
          if (v61 >= v116)
          {
            unint64_t v45 = 0;
            uint64_t v51 = 1;
          }
          else
          {
            unint64_t v62 = *(void *)(v115 + 8 * v61);
            if (v62) {
              goto LABEL_24;
            }
            uint64_t v63 = (char *)(v121 + 2);
            if (v121 + 2 >= v116)
            {
              unint64_t v45 = 0;
              uint64_t v51 = 1;
              ++v121;
            }
            else
            {
              unint64_t v62 = *(void *)(v115 + 8 * (void)v63);
              if (v62)
              {
                int64_t v61 = v121 + 2;
LABEL_24:
                unint64_t v45 = (v62 - 1) & v62;
                unint64_t v50 = __clz(__rbit64(v62)) + (v61 << 6);
                int64_t v121 = v61;
LABEL_10:
                (*(void (**)(char *, unint64_t, uint64_t *))(v133 + 16))(v39, *(void *)(v3 + 48) + *(void *)(v133 + 72) * v50, v139);
                (*(void (**)(char *, unint64_t, uint64_t *))(v134 + 16))(&v39[*((int *)TupleTypeMetadata2 + 12)], *(void *)(v3 + 56) + *(void *)(v134 + 72) * v50, v138);
                uint64_t v51 = 0;
                goto LABEL_11;
              }
              while (1)
              {
                int64_t v61 = (int64_t)(v63 + 1);
                if (__OFADD__(v63, 1)) {
                  goto LABEL_104;
                }
                if (v61 >= v116) {
                  break;
                }
                unint64_t v62 = *(void *)(v115 + 8 * v61);
                ++v63;
                if (v62) {
                  goto LABEL_24;
                }
              }
              unint64_t v45 = 0;
              uint64_t v51 = 1;
              int64_t v121 = v112;
            }
          }
LABEL_11:
          uint64_t v52 = *(TupleTypeMetadata2 - 1);
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v52 + 56))(v39, v51, 1, TupleTypeMetadata2);
          (*v127)(v48, v39, v137);
          if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v52 + 48))(v48, 1, TupleTypeMetadata2) == 1) {
            goto LABEL_37;
          }
          uint64_t v53 = &v48[*((int *)TupleTypeMetadata2 + 12)];
          unint64_t v117 = *v126;
          v117(v19, v48, v139);
          uint64_t v54 = (void (*)(id *, id *, uint64_t *))*v120;
          uint64_t v55 = v138;
          ((void (*)(id *, char *, uint64_t *))*v120)(v136, v53, v138);
          if (_swift_isClassOrObjCExistentialType((uint64_t)v55, v55))
          {
            if (v130 != (id *)8) {
              goto LABEL_96;
            }
            uint64_t v56 = v136;
            uint64_t v57 = *v136;
            uint64_t v58 = *v125;
            swift_unknownObjectRetain(*v136);
            v58((char *)v56, v138);
          }
          else
          {
            uint64_t v64 = v114;
            uint64_t v65 = v138;
            v54(v114, v136, v138);
            uint64_t v57 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v64, v65);
          }
          uint64_t v3 = v135;
          uint64_t v48 = (char *)v122;
          if (v47 == 0x1000000000000000)
          {
            __break(1u);
LABEL_98:
            __break(1u);
LABEL_99:
            __break(1u);
LABEL_100:
            __break(1u);
LABEL_101:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid count", 13, 2, "Swift/DictionaryStorage.swift", 29, 2, 0x188uLL, 0);
          }
          *(void *)(v132 + 8 * v47) = v57;
          swift_unknownObjectRelease(v57);
          if (_swift_isClassOrObjCExistentialType((uint64_t)v139, v139))
          {
            if (v129 != (void (**)(id *, char *, uint64_t *))8) {
              goto LABEL_96;
            }
            uint64_t v59 = *v19;
            uint64_t v60 = *v118;
            swift_unknownObjectRetain(*v19);
            v60(v19, v139);
          }
          else
          {
            uint64_t v66 = v113;
            uint64_t v67 = v139;
            v117(v113, (char *)v19, v139);
            uint64_t v59 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v66, v67);
          }
          v131[v47] = (uint64_t)v59;
          swift_unknownObjectRelease(v59);
          if (++v47 == v119)
          {
LABEL_37:
            uint64_t v68 = v3;
            goto LABEL_92;
          }
        }
        unint64_t v49 = __clz(__rbit64(v45));
        v45 &= v45 - 1;
        unint64_t v50 = v49 | (v121 << 6);
        goto LABEL_10;
      }
      uint64_t v92 = (void (**)(id *, uint64_t *))(v133 + 8);
      uint64_t v130 = (id *)(v46 - 1);
      uint64_t v132 = a3 - 1;
      swift_retain((atomic_ullong *)v3);
      uint64_t v93 = 0;
      uint64_t v136 = 0;
      int64_t v94 = (id *)v121;
      if (!v45) {
        goto LABEL_76;
      }
LABEL_67:
      unint64_t v95 = __clz(__rbit64(v45));
      v45 &= v45 - 1;
      unint64_t v96 = v95 | ((void)v136 << 6);
LABEL_68:
      uint64_t v97 = v135;
      (*(void (**)(char *, unint64_t, uint64_t *))(v133 + 16))(v33, *(void *)(v135 + 48) + *(void *)(v133 + 72) * v96, v139);
      (*(void (**)(char *, unint64_t, uint64_t *))(v134 + 16))(&v33[*((int *)TupleTypeMetadata2 + 12)], *(void *)(v97 + 56) + *(void *)(v134 + 72) * v96, v138);
      uint64_t v98 = 0;
      int64_t v94 = (id *)v121;
      while (1)
      {
        uint64_t v99 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v99 + 56))(v33, v98, 1, TupleTypeMetadata2);
        (*v127)(v36, v33, v137);
        if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v99 + 48))(v36, 1, TupleTypeMetadata2) == 1) {
          break;
        }
        char v100 = *v126;
        unint64_t v101 = v139;
        (*v126)(v94, v36, v139);
        if (_swift_isClassOrObjCExistentialType((uint64_t)v101, v101))
        {
          if (v129 != (void (**)(id *, char *, uint64_t *))8) {
            goto LABEL_96;
          }
          uint64_t v102 = *v94;
          unint64_t v103 = *v92;
          swift_unknownObjectRetain(*v94);
          v103(v94, v139);
        }
        else
        {
          uint64_t v108 = v113;
          unint64_t v109 = v139;
          v100(v113, (char *)v121, v139);
          unint64_t v110 = v108;
          int64_t v94 = (id *)v121;
          uint64_t v102 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v110, v109);
        }
        if (v93 == 0x1000000000000000) {
          goto LABEL_99;
        }
        unint64_t v104 = &v36[*((int *)TupleTypeMetadata2 + 12)];
        v131[v93] = (uint64_t)v102;
        swift_unknownObjectRelease(v102);
        if (v93 == v132)
        {
          swift_release(v135);
          (*v125)(v104, v138);
          return;
        }
        ++v93;
        (*v125)(v104, v138);
        if (v45) {
          goto LABEL_67;
        }
LABEL_76:
        uint64_t v105 = (id *)((char *)v136 + 1);
        if (__OFADD__(v136, 1)) {
          goto LABEL_103;
        }
        if ((uint64_t)v105 >= v116)
        {
          unint64_t v45 = 0;
          uint64_t v98 = 1;
        }
        else
        {
          unint64_t v106 = *(void *)(v115 + 8 * (void)v105);
          if (v106) {
            goto LABEL_79;
          }
          unint64_t v107 = (char *)v136 + 2;
          if ((uint64_t)v136 + 2 >= v116)
          {
            unint64_t v45 = 0;
            uint64_t v98 = 1;
            uint64_t v136 = (id *)((char *)v136 + 1);
          }
          else
          {
            unint64_t v106 = *(void *)(v115 + 8 * (void)v107);
            if (v106)
            {
              uint64_t v105 = (id *)((char *)v136 + 2);
LABEL_79:
              unint64_t v45 = (v106 - 1) & v106;
              unint64_t v96 = __clz(__rbit64(v106)) + ((void)v105 << 6);
              uint64_t v136 = v105;
              goto LABEL_68;
            }
            while (1)
            {
              uint64_t v105 = (id *)(v107 + 1);
              if (__OFADD__(v107, 1)) {
                goto LABEL_106;
              }
              if ((uint64_t)v105 >= v116) {
                break;
              }
              unint64_t v106 = *(void *)(v115 + 8 * (void)v105);
              ++v107;
              if (v106) {
                goto LABEL_79;
              }
            }
            unint64_t v45 = 0;
            uint64_t v98 = 1;
            uint64_t v136 = v130;
          }
        }
      }
LABEL_91:
      uint64_t v68 = v135;
LABEL_92:
      swift_release(v68);
    }
    else if (v132)
    {
      uint64_t v69 = *(void *)(v3 + 64);
      int64_t v121 = v3 + 64;
      uint64_t v70 = 1 << *(unsigned char *)(v3 + 32);
      uint64_t v71 = -1;
      if (v70 < 64) {
        uint64_t v71 = ~(-1 << v70);
      }
      unint64_t v72 = v71 & v69;
      id v131 = TupleTypeMetadata2 - 1;
      uint64_t v124 = v133 + 16;
      unint64_t v122 = (id *)((unint64_t)(v70 + 63) >> 6);
      uint64_t v123 = v134 + 16;
      uint64_t v73 = a3;
      uint64_t v74 = (void (**)(char *, char *, Class *))(v40 + 32);
      char v129 = (void (**)(id *, char *, uint64_t *))(v134 + 32);
      id v127 = (void (**)(char *, char *, Class *))(v134 + 8);
      unint64_t v120 = (id *)((char *)v122 - 1);
      uint64_t v125 = (void (**)(char *, uint64_t *))(v133 + 8);
      unint64_t v126 = (void (**)(id *, char *, uint64_t *))(v73 - 1);
      swift_retain((atomic_ullong *)v3);
      uint64_t v75 = 0;
      uint64_t v136 = 0;
      uint64_t v76 = v127;
      if (!v72) {
        goto LABEL_51;
      }
LABEL_42:
      unint64_t v77 = __clz(__rbit64(v72));
      v72 &= v72 - 1;
      unint64_t v78 = v77 | ((void)v136 << 6);
LABEL_43:
      uint64_t v79 = v135;
      (*(void (**)(char *, unint64_t, uint64_t *))(v133 + 16))(v27, *(void *)(v135 + 48) + *(void *)(v133 + 72) * v78, v139);
      (*(void (**)(char *, unint64_t, uint64_t *))(v134 + 16))(&v27[*((int *)TupleTypeMetadata2 + 12)], *(void *)(v79 + 56) + *(void *)(v134 + 72) * v78, v138);
      uint64_t v80 = 0;
      while (1)
      {
LABEL_44:
        uint64_t v81 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v81 + 56))(v27, v80, 1, TupleTypeMetadata2);
        (*v74)(v30, v27, v137);
        if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v81 + 48))(v30, 1, TupleTypeMetadata2) == 1) {
          goto LABEL_91;
        }
        uint64_t v82 = *v129;
        uint64_t v83 = v138;
        (*v129)(v128, &v30[*((int *)TupleTypeMetadata2 + 12)], v138);
        if (_swift_isClassOrObjCExistentialType((uint64_t)v83, v83))
        {
          if (v130 != (id *)8) {
LABEL_96:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
          uint64_t v84 = v128;
          uint64_t v85 = *v128;
          uint64_t v86 = *v76;
          swift_unknownObjectRetain(*v128);
          ((void (*)(id *, uint64_t *))v86)(v84, v138);
        }
        else
        {
          uint64_t v90 = v114;
          uint64_t v91 = v138;
          v82(v114, (char *)v128, v138);
          uint64_t v85 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v90, v91);
        }
        if (v75 == (void (**)(id *, char *, uint64_t *))0x1000000000000000) {
          goto LABEL_98;
        }
        *(void *)(v132 + 8 * (void)v75) = v85;
        swift_unknownObjectRelease(v85);
        if (v75 == v126)
        {
          swift_release(v135);
          (*v125)(v30, v139);
          return;
        }
        uint64_t v75 = (void (**)(id *, char *, uint64_t *))((char *)v75 + 1);
        (*v125)(v30, v139);
        if (v72) {
          goto LABEL_42;
        }
LABEL_51:
        uint64_t v87 = (id *)((char *)v136 + 1);
        if (__OFADD__(v136, 1)) {
          break;
        }
        if ((uint64_t)v87 >= (uint64_t)v122)
        {
          unint64_t v72 = 0;
          uint64_t v80 = 1;
        }
        else
        {
          unint64_t v88 = *(void *)(v121 + 8 * (void)v87);
          if (v88) {
            goto LABEL_54;
          }
          unint64_t v89 = (char *)v136 + 2;
          if ((uint64_t)((char *)v136 + 2) < (uint64_t)v122)
          {
            unint64_t v88 = *(void *)(v121 + 8 * (void)v89);
            if (v88)
            {
              uint64_t v87 = (id *)((char *)v136 + 2);
LABEL_54:
              unint64_t v72 = (v88 - 1) & v88;
              unint64_t v78 = __clz(__rbit64(v88)) + ((void)v87 << 6);
              uint64_t v136 = v87;
              goto LABEL_43;
            }
            while (1)
            {
              uint64_t v87 = (id *)(v89 + 1);
              if (__OFADD__(v89, 1)) {
                goto LABEL_105;
              }
              if ((uint64_t)v87 >= (uint64_t)v122)
              {
                unint64_t v72 = 0;
                uint64_t v80 = 1;
                uint64_t v136 = v120;
                goto LABEL_44;
              }
              unint64_t v88 = *(void *)(v121 + 8 * (void)v87);
              ++v89;
              if (v88) {
                goto LABEL_54;
              }
            }
          }
          unint64_t v72 = 0;
          uint64_t v80 = 1;
          uint64_t v136 = (id *)((char *)v136 + 1);
        }
      }
      __break(1u);
LABEL_103:
      __break(1u);
LABEL_104:
      __break(1u);
LABEL_105:
      __break(1u);
LABEL_106:
      __break(1u);
    }
  }
}

uint64_t _NativeDictionary.makeIterator()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1;
  uint64_t v3 = -1 << *(unsigned char *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t result = a1 + 64;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1 << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0;
  a2[4] = v2 & v5;
  return result;
}

uint64_t @objc _DictionaryStorage.getObjects(_:andKeys:count:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)(a1, a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, uint64_t))_DictionaryStorage.getObjects(_:andKeys:count:));
}

uint64_t @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t, uint64_t))
{
  swift_retain(a1);
  a6(a3, a4, a5);

  return swift_release((uint64_t)a1);
}

int64x2_t *specialized static _DictionaryStorage.copy(original:)(uint64_t a1)
{
  __int8 v1 = *(unsigned char *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1 << v1;
  unint64_t v5 = (unint64_t)((1 << v1) + 63) >> 6;
  uint64_t v6 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, Any>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16 << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8) + (32 << v1), 7uLL);
  v7[1].i64[0] = 0;
  double v8 = (double)(1 << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v5, v10);
  }
  else {
    v10->i64[0] = -1 << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;

  __int8 v1 = *(unsigned char *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1 << v1;
  unint64_t v5 = (unint64_t)((1 << v1) + 63) >> 6;
  uint64_t v6 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, Any>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((40 << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8) + (32 << v1), 7uLL);
  v7[1].i64[0] = 0;
  double v8 = (double)(1 << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 40 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v5, v10);
  }
  else {
    v10->i64[0] = -1 << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;

  __int8 v1 = *(unsigned char *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1 << v1;
  unint64_t v5 = (unint64_t)((1 << v1) + 63) >> 6;
  uint64_t v6 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((40 << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8) + (16 << v1), 7uLL);
  v7[1].i64[0] = 0;
  double v8 = (double)(1 << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 40 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v5, v10);
  }
  else {
    v10->i64[0] = -1 << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;

  __int8 v1 = *(unsigned char *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1 << v1;
  unint64_t v5 = (unint64_t)((1 << v1) + 63) >> 6;
  uint64_t v6 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16 << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8) + (40 << v1), 7uLL);
  v7[1].i64[0] = 0;
  double v8 = (double)(1 << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v5, v10);
  }
  else {
    v10->i64[0] = -1 << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;

  __int8 v1 = *(unsigned char *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1 << v1;
  unint64_t v5 = (unint64_t)((1 << v1) + 63) >> 6;
  uint64_t v6 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16 << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8) + (16 << v1), 7uLL);
  v7[1].i64[0] = 0;
  double v8 = (double)(1 << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v5, v10);
  }
  else {
    v10->i64[0] = -1 << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;

  __int8 v1 = *(unsigned char *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1 << v1;
  unint64_t v5 = (unint64_t)((1 << v1) + 63) >> 6;
  uint64_t v6 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16 << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8) + (8 << v1), 7uLL);
  v7[1].i64[0] = 0;
  double v8 = (double)(1 << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v5, v10);
  }
  else {
    v10->i64[0] = -1 << v4;
  }
  return v9;
}

int64x2_t *specialized static _DictionaryStorage.copy(original:)(uint64_t a1, uint64_t (*a2)(void))
{
  __int8 v2 = *(unsigned char *)(a1 + 32);
  __int32 v3 = *(_DWORD *)(a1 + 36);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = 1 << v2;
  unint64_t v6 = (unint64_t)((1 << v2) + 63) >> 6;
  uint64_t v7 = (unint64_t *)a2(0);
  double v8 = (int64x2_t *)swift_allocObject(v7, (((8 << v2) + 8 * v6 + 71) & 0xFFFFFFFFFFFFFFF8) + (8 << v2), 7uLL);
  v8[1].i64[0] = 0;
  double v9 = (double)(1 << v2) * 0.75;
  if ((~*(void *)&v9 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v9 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v9 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v10 = v8;
  uint64_t v11 = v8 + 4;
  uint64_t v12 = (uint64_t)&v8[4].i64[v6];
  v8[1].i64[1] = (uint64_t)v9;
  v8[2].i8[0] = v2;
  v8[2].i8[1] = 0;
  v8[2].i16[1] = 0;
  v8[2].i32[1] = v3;
  v8[2].i64[1] = v4;
  v8[3].i64[0] = v12;
  v8[3].i64[1] = v12 + 8 * v5;
  if (v5 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v6, v11);
  }
  else {
    v11->i64[0] = -1 << v5;
  }
  return v10;
}

int64x2_t *specialized static _DictionaryStorage.copy(original:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int8 v4 = *(unsigned char *)(a1 + 32);
  __int32 v5 = *(_DWORD *)(a1 + 36);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = 1 << v4;
  unint64_t v8 = (unint64_t)((1 << v4) + 63) >> 6;
  double v9 = (unint64_t *)type metadata accessor for _DictionaryStorage(0, a2, (uint64_t)&unk_1ECA01F50, a3);
  uint64_t v10 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80);
  uint64_t v11 = v10 + 8 * v8;
  uint64_t v12 = (*(void *)(*(void *)(a2 - 8) + 72) << v4) + 7;
  uint64_t v13 = (int64x2_t *)swift_allocObject(v9, ((v12 + ((v11 + 64) & ~v10)) & 0xFFFFFFFFFFFFFFF8) + (16 << v4), v10 | 7);
  v13[1].i64[0] = 0;
  double v14 = (double)(1 << v4) * 0.75;
  if ((~*(void *)&v14 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v14 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v14 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  uint64_t v15 = v13;
  v13[1].i64[1] = (uint64_t)v14;
  uint64_t v16 = v13 + 4;
  uint64_t v17 = ((unint64_t)v13[4].u64 + v11) & ~v10;
  v13[2].i8[0] = v4;
  v13[2].i8[1] = 0;
  v13[2].i16[1] = 0;
  v13[2].i32[1] = v5;
  v13[2].i64[1] = v6;
  v13[3].i64[0] = v17;
  v13[3].i64[1] = (v12 + v17) & 0xFFFFFFFFFFFFFFF8;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v16);
  }
  else {
    v16->i64[0] = -1 << v7;
  }
  return v15;
}

int64x2_t *static _DictionaryStorage.copy(original:)(uint64_t a1)
{
  __int8 v2 = *(unsigned char *)(a1 + 32);
  __int32 v3 = *(_DWORD *)(a1 + 36);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = 1 << v2;
  uint64_t v6 = *(unsigned __int8 *)(*(void *)(v1[22] - 8) + 80);
  uint64_t v7 = v6 + 8 * ((unint64_t)((1 << v2) + 63) >> 6);
  uint64_t v8 = *(void *)(*(void *)(v1[22] - 8) + 72) << v2;
  uint64_t v9 = *(void *)(v1[23] - 8);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = v8 + v10;
  uint64_t v12 = (int64x2_t *)swift_allocObject(v1, ((((v7 + 64) & ~v6) + v8 + v10) & ~v10) + (*(void *)(v9 + 72) << v2), v6 | v10 | 7);
  v12[1].i64[0] = 0;
  double v13 = (double)(1 << v2) * 0.75;
  if ((~*(void *)&v13 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v13 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v13 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  double v14 = v12;
  v12[1].i64[1] = (uint64_t)v13;
  uint64_t v15 = v12 + 4;
  uint64_t v16 = ((unint64_t)v12[4].u64 + v7) & ~v6;
  v12[2].i8[0] = v2;
  v12[2].i8[1] = 0;
  v12[2].i16[1] = 0;
  v12[2].i32[1] = v3;
  v12[2].i64[1] = v4;
  v12[3].i64[0] = v16;
  v12[3].i64[1] = (v16 + v11) & ~v10;
  if (v5 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)((1 << v2) + 63) >> 6, v15);
  }
  else {
    v15->i64[0] = -1 << v5;
  }
  return v14;
}

int64x2_t *static _DictionaryStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, int64x2_t *a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v8 = (int64x2_t *)a1;
  uint64_t v9 = 1 << a1;
  uint64_t v10 = *(void *)(v4[22] - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  unint64_t v20 = (unint64_t)((1 << a1) + 63) >> 6;
  uint64_t v12 = v11 + 8 * v20;
  uint64_t v13 = *(void *)(v10 + 72) << a1;
  uint64_t v14 = *(unsigned __int8 *)(*(void *)(v5[23] - 8) + 80);
  uint64_t v15 = v13 + v14;
  uint64_t v16 = (int64x2_t *)swift_allocObject(v5, ((((v12 + 64) & ~v11) + v13 + v14) & ~v14) + (*(void *)(*(void *)(v5[23] - 8) + 72) << a1), v11 | v14 | 7);
  uint64_t v17 = ((unint64_t)v16[4].u64 + v12) & ~v11;
  v16[1].i64[0] = 0;
  swift_retain(v16->i64);
  v16[1].i64[1] = specialized static _HashTable.capacity(forScale:)(a1);
  v16[2].i8[0] = a1;
  v16[2].i8[1] = 0;
  v16[2].i16[1] = 0;
  if ((a2 & 0x100000000) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v16);
  }
  v16[2].i32[1] = a2;
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v18 = v8;
  }
  else {
    uint64_t v18 = v16;
  }
  if ((a4 & 1) == 0) {
    uint64_t v18 = a3;
  }
  v16[2].i64[1] = (uint64_t)v18;
  v16[3].i64[0] = v17;
  v16[3].i64[1] = (v17 + v15) & ~v14;
  if (v9 > 63)
  {
    swift_release((uint64_t)v16);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v20, v16 + 4);
  }
  else
  {
    v16[4].i64[0] = -1 << v9;
    swift_release((uint64_t)v16);
  }
  return v16;
}

uint64_t static _DictionaryStorage.resize(original:capacity:move:)(uint64_t a1, uint64_t a2)
{
  return specialized static _DictionaryStorage.resize(original:capacity:move:)(a2, v2[22], v2[23], v2[24]);
}

uint64_t specialized static _DictionaryStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, AnyHashable>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((40 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (40 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, Any>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (32 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, Any>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((40 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (32 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

uint64_t specialized static _DictionaryStorage.allocate(capacity:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = result;
  }
  double v4 = ceil((double)v3 / 0.75);
  if ((~*(void *)&v4 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v4 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v4 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v5 = __OFADD__(v3, 1);
  uint64_t v6 = v3 + 1;
  if (v5)
  {
    __break(1u);
    return result;
  }
  if (v6 <= (uint64_t)v4) {
    uint64_t v6 = (uint64_t)v4;
  }
  char v8 = 64 - __clz(v6 - 1);
  unsigned __int8 v9 = (unint64_t)v6 <= 2 ? 1 : v8;
  uint64_t v10 = 1 << v9;
  unint64_t v11 = (unint64_t)((1 << v9) + 63) >> 6;
  uint64_t v12 = (unint64_t *)type metadata accessor for _DictionaryStorage(0, a2, (uint64_t)&unk_1ECA01F50, a3);
  uint64_t v13 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80);
  uint64_t v14 = v13 + 8 * v11;
  uint64_t v15 = (*(void *)(*(void *)(a2 - 8) + 72) << v9) + 7;
  uint64_t v16 = (int64x2_t *)swift_allocObject(v12, ((v15 + ((v14 + 64) & ~v13)) & 0xFFFFFFFFFFFFFFF8) + (16 << v9), v13 | 7);
  v16[1].i64[0] = 0;
  double v17 = (double)(1 << v9) * 0.75;
  if ((~*(void *)&v17 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v17 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v17 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v18 = (uint64_t *)v16;
  unint64_t v19 = v16 + 4;
  uint64_t v20 = ((unint64_t)v16[4].u64 + v14) & ~v13;
  v16[1].i64[1] = (uint64_t)v17;
  v16[2].i8[0] = v9;
  v16[2].i8[1] = 0;
  v16[2].i16[1] = 0;
  v16[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v16);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v21 = (uint64_t *)v9;
  }
  else {
    uint64_t v21 = v18;
  }
  v18[5] = (uint64_t)v21;
  v18[6] = v20;
  v18[7] = (v15 + v20) & 0xFFFFFFFFFFFFFFF8;
  if (v10 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v11, v19);
  }
  else {
    v19->i64[0] = -1 << v10;
  }
  return (uint64_t)v18;
}

uint64_t static _DictionaryStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v2 = 1;
  }
  else {
    uint64_t v2 = result;
  }
  double v3 = ceil((double)v2 / 0.75);
  if ((~*(void *)&v3 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v3 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v3 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v4 = __OFADD__(v2, 1);
  uint64_t v5 = v2 + 1;
  if (v4)
  {
    __break(1u);
    return result;
  }
  if (v5 <= (uint64_t)v3) {
    uint64_t v5 = (uint64_t)v3;
  }
  char v6 = 64 - __clz(v5 - 1);
  unsigned __int8 v7 = (unint64_t)v5 <= 2 ? 1 : v6;
  uint64_t v8 = 1 << v7;
  uint64_t v9 = *(unsigned __int8 *)(*(void *)(v1[22] - 8) + 80);
  uint64_t v10 = v9 + 8 * ((unint64_t)((1 << v7) + 63) >> 6);
  uint64_t v11 = *(void *)(*(void *)(v1[22] - 8) + 72) << v7;
  uint64_t v12 = *(void *)(v1[23] - 8);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 80);
  uint64_t v14 = v11 + v13;
  uint64_t v15 = (int64x2_t *)swift_allocObject(v1, ((((v10 + 64) & ~v9) + v11 + v13) & ~v13) + (*(void *)(v12 + 72) << v7), v9 | v13 | 7);
  v15[1].i64[0] = 0;
  double v16 = (double)(1 << v7) * 0.75;
  if ((~*(void *)&v16 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v16 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v16 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  double v17 = (uint64_t *)v15;
  uint64_t v18 = v15 + 4;
  uint64_t v19 = ((unint64_t)v15[4].u64 + v10) & ~v9;
  v15[1].i64[1] = (uint64_t)v16;
  v15[2].i8[0] = v7;
  v15[2].i8[1] = 0;
  v15[2].i16[1] = 0;
  v15[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v15);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v20 = (uint64_t *)v7;
  }
  else {
    uint64_t v20 = v17;
  }
  uint64_t v17[5] = (uint64_t)v20;
  v17[6] = v19;
  v17[7] = (v19 + v14) & ~v13;
  if (v8 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)((1 << v7) + 63) >> 6, v18);
  }
  else {
    v18->i64[0] = -1 << v8;
  }
  return (uint64_t)v17;
}

uint64_t static _DictionaryStorage.convert(_:capacity:)(uint64_t a1, uint64_t a2)
{
  return static _DictionaryStorage.convert(_:capacity:)(a1, a2, (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))static _DictionaryStorage.allocate(scale:age:seed:));
}

uint64_t static Int.bitWidth.getter()
{
  return 64;
}

uint64_t Int16.init(_builtinIntegerLiteral:)(unsigned __int16 *a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x10) {
    return *a1;
  }
  else {
    return 0;
  }
}

uint64_t ObjectIdentifier.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1);
}

Swift::Void __swiftcall _HashTable.clear()()
{
  if (v1 + 1 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v1 + 64) >> 6, v0);
  }
  else {
    v0->i64[0] = -1 << (v1 + 1);
  }
}

uint64_t (*Dictionary._Variant.object.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Dictionary._Variant.guaranteedNative.getter()
{
  return 0;
}

__objc2_class **_NativeDictionary.init(_:capacity:)(void *a1, uint64_t a2, char *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)a4, (uint64_t)a3, (uint64_t)a4);
  uint64_t v80 = (Class *)*(v10 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v61 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v81 = (char *)&v61 - v15;
  unint64_t v77 = (void (**)(char *, char *, uint64_t *))*(a4 - 1);
  MEMORY[0x1F4188790](v14);
  double v17 = (char *)&v61 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = type metadata accessor for Optional(0, (uint64_t)a3, v18, v19);
  uint64_t v21 = MEMORY[0x1F4188790](v20);
  uint64_t v22 = MEMORY[0x1F4188790](v21);
  uint64_t v23 = *((void *)a3 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v29 = (char *)&v61 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!a2)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyDictionarySingleton;
  }
  uint64_t v74 = v10;
  uint64_t v75 = v25;
  uint64_t v71 = v26;
  uint64_t v72 = v24;
  uint64_t v73 = v13;
  uint64_t v30 = (uint64_t)a1;
  uint64_t v76 = a1;
  uint64_t v31 = v27;
  type metadata accessor for _DictionaryStorage(0, (uint64_t)a3, (uint64_t)a4, a5);
  char v32 = specialized static _HashTable.scale(forCapacity:)(a2);
  unsigned int v33 = specialized static Hasher._hash(seed:_:)(0, v30);
  LOBYTE(v83) = 0;
  uint64_t v34 = static _DictionaryStorage.allocate(scale:age:seed:)(v32, v33, 0, 1);
  uint64_t v83 = v34;
  uint64_t v35 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
  uint64_t v36 = swift_allocObject(v35, 0xE8uLL, 7uLL);
  uint64_t v37 = 0;
  *((_OWORD *)v36 + 1) = 0u;
  uint64_t v79 = v36 + 2;
  *((_OWORD *)v36 + 5) = 0u;
  unint64_t v78 = v36 + 10;
  v36[27] = 0;
  uint64_t v38 = v36 + 27;
  *((_OWORD *)v36 + 2) = 0u;
  *((_OWORD *)v36 + 3) = 0u;
  *((_OWORD *)v36 + 4) = 0u;
  *((_OWORD *)v36 + 6) = 0u;
  *((_OWORD *)v36 + 7) = 0u;
  uint64_t v69 = (void (**)(uint64_t, void *, uint64_t))(v31 + 16);
  uint64_t v70 = (void (**)(void *, uint64_t, uint64_t, char *))(v23 + 56);
  *((_OWORD *)v36 + 8) = 0u;
  *((_OWORD *)v36 + 9) = 0u;
  uint64_t v67 = (void (**)(void *, uint64_t))(v31 + 8);
  uint64_t v68 = (unsigned int (**)(uint64_t, uint64_t, char *))(v23 + 48);
  uint64_t v39 = v77;
  uint64_t v65 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v77 + 7);
  uint64_t v66 = (void (**)(char *, uint64_t, char *))(v23 + 32);
  *((_OWORD *)v36 + 10) = 0u;
  *((_OWORD *)v36 + 11) = 0u;
  uint64_t v40 = v80;
  uint64_t v64 = v80 + 2;
  uint64_t v63 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v39 + 6);
  *((_OWORD *)v36 + 12) = 0u;
  unint64_t v62 = (void (**)(void *, Class *))(v40 + 1);
  unint64_t v77 = v39 + 4;
  v36[26] = v76;
  uint64_t v80 = qword_1ECA06328;
  v36[28] = 0;
  while (1)
  {
    uint64_t v41 = (void *)v36[26];
    if (v37 != v36[28]) {
      goto LABEL_7;
    }
    id v42 = [v36[26] countByEnumeratingWithState:v79 objects:v78 count:16];
    v36[28] = v42;
    if (!v42) {
      break;
    }
    uint64_t v37 = 0;
    uint64_t *v38 = 0;
LABEL_7:
    uint64_t v43 = v36[3];
    if (!v43)
    {
      unint64_t v60 = 773;
      goto LABEL_29;
    }
    if ((unint64_t)(v37 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_26:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
    }
    uint64_t v44 = (void **)(v43 + 8 * v37);
    if ((v44 & 7) != 0) {
      goto LABEL_26;
    }
    uint64_t v45 = a5;
    unint64_t v46 = *v44;
    uint64_t *v38 = v37 + 1;
    swift_unknownObjectRetain(v46);
    uint64_t v47 = (swift)[v41 objectForKey:v46];
    if (!v47)
    {
      unint64_t v60 = 784;
LABEL_29:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v60, 0);
    }
    uint64_t v48 = v47;
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      uint64_t v82 = (swift *)v46;
      swift_dynamicCast(v29, (unint64_t *)&v82, v80, a3, 7uLL);
    }
    else
    {
      uint64_t v53 = v75;
      (*v70)(v75, 1, 1, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v46, (uint64_t)a3, v53);
      swift_unknownObjectRelease(v46);
      uint64_t v54 = v71;
      uint64_t v55 = v53;
      uint64_t v56 = v72;
      (*v69)(v71, v55, v72);
      if ((*v68)(v54, 1, a3) == 1) {
        goto LABEL_30;
      }
      (*v67)(v75, v56);
      (*v66)(v29, v54, a3);
    }
    a5 = v45;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
    unint64_t v50 = v81;
    if (isClassOrObjCExistentialType)
    {
      uint64_t v82 = v48;
      swift_dynamicCast(v17, (unint64_t *)&v82, qword_1ECA06328, (const char *)a4, 7uLL);
    }
    else
    {
      (*v65)(v81, 1, 1, a4);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v48, (uint64_t)a4, v50);
      swift_unknownObjectRelease(v48);
      uint64_t v58 = v73;
      uint64_t v57 = v74;
      ((void (*)(char *, void *, Class *))*v64)(v73, v50, v74);
      if ((*v63)(v58, 1, a4) == 1) {
LABEL_30:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
      (*v62)(v50, v57);
      (*v77)(v17, v58, a4);
    }
    uint64_t v34 = v83;
    unint64_t v51 = v83[1].u64[0];
    if (v83[1].i64[1] <= v51)
    {
      Swift::Int v52 = v51 + 1;
      type metadata accessor for _NativeDictionary(0, (uint64_t)a3, (uint64_t)a4, a5);
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v52, 1);
      uint64_t v34 = v83;
    }
    _NativeDictionary._unsafeInsertNew(key:value:)((uint64_t)v29, (uint64_t)v17, v34, (unint64_t)a3, (uint64_t)a4, a5);
    uint64_t v37 = *v38;
    if (*v38 < 0) {
      goto LABEL_23;
    }
  }
  v36[27] = -1;
LABEL_23:
  swift_release((uint64_t)v36);
  return (__objc2_class **)v34;
}

uint64_t _NativeDictionary.capacity.getter(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t _NativeDictionary.startIndex.getter(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 64);
  if (v1)
  {
    uint64_t v2 = 0;
    return __clz(__rbit64(v1)) + v2;
  }
  char v5 = *(unsigned char *)(a1 + 32);
  unsigned int v6 = v5 & 0x3F;
  uint64_t v3 = 1 << v5;
  if (v6 < 7) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    uint64_t v2 = 64;
    return __clz(__rbit64(v1)) + v2;
  }
  if (v6 < 8) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 80);
  if (v1)
  {
    uint64_t v2 = 128;
    return __clz(__rbit64(v1)) + v2;
  }
  unint64_t v7 = (unint64_t)(v3 + 63) >> 6;
  if (v7 <= 3) {
    unint64_t v7 = 3;
  }
  unint64_t v8 = v7 - 3;
  uint64_t v9 = (unint64_t *)(a1 + 88);
  uint64_t v2 = 128;
  while (v8)
  {
    unint64_t v10 = *v9++;
    unint64_t v1 = v10;
    --v8;
    v2 += 64;
    if (v10) {
      return __clz(__rbit64(v1)) + v2;
    }
  }
  return v3;
}

uint64_t _NativeDictionary.endIndex.getter(uint64_t a1)
{
  return 1 << *(unsigned char *)(a1 + 32);
}

Swift::Int _NativeDictionary.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a1;
  uint64_t v12 = *((void *)a5 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((v15 & 1) == 0)
  {
    if ((v11 & 0x8000000000000000) == 0
      && -(-1 << *(unsigned char *)(a4 + 32)) > v11
      && ((*(void *)(a4 + 64 + (((unint64_t)v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v11) & 1) != 0
      && *(_DWORD *)(a4 + 36) == a2)
    {
      return _HashTable.occupiedBucket(after:)((Swift::_HashTable::Bucket)v11).offset;
    }
    unint64_t v26 = 281;
LABEL_21:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v26, 0);
  }
  if (v11 >= 0) {
    uint64_t v16 = v11 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v16 = v11;
  }
  outlined copy of [A : B].Index._Variant<A, B>(v11, a2, 1);
  uint64_t v17 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v11);
  if (!swift_dynamicCastClass(v16, v17)) {
    goto LABEL_24;
  }
  id v28 = *(id *)(v16 + 16);
  if (*(_DWORD *)(a4 + 36) != specialized static Hasher._hash(seed:_:)(0, (uint64_t)v28)) {
    goto LABEL_25;
  }
  if (!swift_dynamicCastClass(v16, v17)) {
    goto LABEL_24;
  }
  uint64_t v18 = *(void *)(v16 + 24);
  if (*(void *)(v18 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
  }
  uint64_t v27 = v17;
  uint64_t v19 = *(void **)(v18 + 8 * a2 + 24);
  swift_unknownObjectRetain(v19);
  outlined consume of [A : B].Index._Variant<A, B>(v11, a2, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v19, a5, v20, v14);
  swift_unknownObjectRelease(v19);
  uint64_t v21 = v27;
  __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)a5, a7);
  char v23 = v22;
  (*(void (**)(char *, char *))(v12 + 8))(v14, a5);
  if ((v23 & 1) == 0)
  {
LABEL_25:
    unint64_t v26 = 303;
    goto LABEL_21;
  }
  if (!swift_dynamicCastClass(v16, v21)
    || (id v24 = v28, swift_unknownObjectRetain(v28), !swift_dynamicCastClass(v16, v21)))
  {
LABEL_24:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(void *)(*(void *)(v16 + 24) + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempt to access endIndex", 26, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x1E8uLL, 0);
  }
  swift_unknownObjectRelease(v24);
  return v11;
}

unint64_t _NativeDictionary.index(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)(a2 + 16)) {
    return 0;
  }
  unint64_t result = __RawDictionaryStorage.find<A>(_:)(a1, a3, a5);
  if ((v6 & 1) == 0) {
    return 0;
  }
  return result;
}

uint64_t _NativeDictionary.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a2 + 16)) {
    __RawDictionaryStorage.find<A>(_:)(a1, a3, a5);
  }
  else {
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t _NativeDictionary.lookup(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if (*(void *)(a2 + 16) && (unint64_t v9 = __RawDictionaryStorage.find<A>(_:)(a1, a3, a5), (v10 & 1) != 0))
  {
    uint64_t v15 = *(void *)(a4 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v15 + 16))(a6, *(void *)(a2 + 56) + *(void *)(v15 + 72) * v9, a4);
    uint64_t v11 = v15;
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v11 = *(void *)(a4 - 8);
    uint64_t v12 = 1;
  }
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 56);

  return v13(a6, v12, 1, a4);
}

uint64_t _NativeDictionary.lookup(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16 = *((void *)a7 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v18 = (char *)&v29 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v19)
  {
    uint64_t v30 = a2;
    if (a3 >= 0) {
      uint64_t v21 = a3 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v21 = a3;
    }
    uint64_t v22 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a3);
    if (swift_dynamicCastClass(v21, v22))
    {
      if (*(_DWORD *)(a6 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v21 + 16))) {
        goto LABEL_20;
      }
      if (swift_dynamicCastClass(v21, v22))
      {
        uint64_t v23 = *(void *)(v21 + 24);
        if (*(void *)(v23 + 16) <= a4) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        id v24 = *(void **)(v23 + 8 * a4 + 24);
        swift_unknownObjectRetain(v24);
        outlined consume of [A : B].Index._Variant<A, B>(a3, a4, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v24, a7, v25, v18);
        swift_unknownObjectRelease(v24);
        a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v18, (uint64_t)a7, a9);
        char v27 = v26;
        (*(void (**)(char *, char *))(v16 + 8))(v18, a7);
        if (v27)
        {
          a2 = v30;
          goto LABEL_17;
        }
LABEL_20:
        unint64_t v20 = 303;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v20, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (a3 < 0
    || 1 << *(unsigned char *)(a6 + 32) <= a3
    || ((*(void *)(a6 + 8 * ((unint64_t)a3 >> 6) + 64) >> a3) & 1) == 0
    || *(_DWORD *)(a6 + 36) != a4)
  {
    unint64_t v20 = 281;
    goto LABEL_7;
  }
LABEL_17:
  (*(void (**)(uint64_t, uint64_t, char *))(v16 + 16))(a1, *(void *)(a6 + 48) + *(void *)(v16 + 72) * a3, a7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a8 - 8) + 16))(a2, *(void *)(a6 + 56) + *(void *)(*(void *)(a8 - 8) + 72) * a3, a8);
}

uint64_t _NativeDictionary.key(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X8>)
{
  uint64_t v10 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v25 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v15)
  {
    if (v10 >= 0) {
      uint64_t v17 = v10 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v17 = v10;
    }
    uint64_t v18 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v10);
    if (swift_dynamicCastClass(v17, v18))
    {
      if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v17 + 16))) {
        goto LABEL_19;
      }
      if (swift_dynamicCastClass(v17, v18))
      {
        uint64_t v19 = *(void *)(v17 + 24);
        if (*(void *)(v19 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        unint64_t v20 = *(void **)(v19 + 8 * a2 + 24);
        swift_unknownObjectRetain(v20);
        outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v20, a4, v21, v14);
        swift_unknownObjectRelease(v20);
        uint64_t v10 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)a4, a5);
        char v23 = v22;
        (*(void (**)(char *, char *))(v12 + 8))(v14, a4);
        if (v23) {
          return (*(uint64_t (**)(uint64_t, uint64_t, char *))(v12 + 16))(a6, *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10, a4);
        }
LABEL_19:
        unint64_t v16 = 303;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v16, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (v10 < 0
    || 1 << *(unsigned char *)(a3 + 32) <= v10
    || ((*(void *)(a3 + 8 * ((unint64_t)v10 >> 6) + 64) >> v10) & 1) == 0
    || *(_DWORD *)(a3 + 36) != a2)
  {
    unint64_t v16 = 281;
    goto LABEL_7;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(v12 + 16))(a6, *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10, a4);
}

uint64_t _NativeDictionary.value(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v13 = *((void *)a4 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](a7);
  unint64_t v16 = (char *)&v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v17)
  {
    uint64_t v28 = v14;
    if (a1 >= 0) {
      uint64_t v19 = a1 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v19 = a1;
    }
    uint64_t v20 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a1);
    if (swift_dynamicCastClass(v19, v20))
    {
      if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v19 + 16))) {
        goto LABEL_20;
      }
      if (swift_dynamicCastClass(v19, v20))
      {
        uint64_t v21 = *(void *)(v19 + 24);
        if (*(void *)(v21 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
        }
        char v22 = *(void **)(v21 + 8 * a2 + 24);
        swift_unknownObjectRetain(v22);
        outlined consume of [A : B].Index._Variant<A, B>(a1, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v22, a4, v23, v16);
        swift_unknownObjectRelease(v22);
        a1 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v16, (uint64_t)a4, a6);
        char v25 = v24;
        (*(void (**)(char *, char *))(v13 + 8))(v16, a4);
        if (v25)
        {
          uint64_t v14 = v28;
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16))(v14, *(void *)(a3 + 56) + *(void *)(*(void *)(a5 - 8) + 72) * a1, a5);
        }
LABEL_20:
        unint64_t v18 = 303;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, v18, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (a1 < 0
    || 1 << *(unsigned char *)(a3 + 32) <= a1
    || ((*(void *)(a3 + 8 * ((unint64_t)a1 >> 6) + 64) >> a1) & 1) == 0
    || *(_DWORD *)(a3 + 36) != a2)
  {
    unint64_t v18 = 281;
    goto LABEL_7;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16))(v14, *(void *)(a3 + 56) + *(void *)(*(void *)(a5 - 8) + 72) * a1, a5);
}

uint64_t Dictionary.subscript.getter@<X0>(id *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, char *a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  if ((a2 & 0xC000000000000001) != 0)
  {
    unint64_t v9 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    if (a2 < 0) {
      uint64_t v10 = (void *)a2;
    }
    else {
      uint64_t v10 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
    }
    id v11 = [v10 objectForKey:v9];
    swift_unknownObjectRelease(v9);
    if (v11)
    {
      _forceBridgeFromObjectiveC<A>(_:_:)(v11, a4, v12, a6);
      swift_unknownObjectRelease(v11);
      uint64_t v13 = 0;
      uint64_t v14 = *((void *)a4 - 1);
      goto LABEL_11;
    }
  }
  else if (*(void *)(a2 + 16))
  {
    unint64_t v15 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
    if (v16)
    {
      uint64_t v19 = *((void *)a4 - 1);
      (*(void (**)(char *, unint64_t, char *))(v19 + 16))(a6, *(void *)(a2 + 56) + *(void *)(v19 + 72) * v15, a4);
      uint64_t v14 = v19;
      uint64_t v13 = 0;
      goto LABEL_11;
    }
  }
  uint64_t v14 = *((void *)a4 - 1);
  uint64_t v13 = 1;
LABEL_11:
  char v17 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56);

  return v17(a6, v13, 1, a4);
}

void (*_NativeDictionary.subscript.modify(void *a1, uint64_t a2, char a3, void *a4))(uint64_t **a1)
{
  char v5 = v4;
  unint64_t v9 = malloc(0x50uLL);
  *a1 = v9;
  *unint64_t v9 = a2;
  v9[1] = v4;
  uint64_t v10 = a4[3];
  _OWORD v9[2] = v10;
  uint64_t v13 = type metadata accessor for Optional(0, v10, v11, v12);
  v9[3] = v13;
  uint64_t v14 = (uint64_t)*(v13 - 1);
  v9[4] = v14;
  unint64_t v15 = malloc(*(void *)(v14 + 64));
  uint64_t v16 = *v4;
  unint64_t v17 = a4[2];
  uint64_t v31 = v15;
  v9[5] = v15;
  v9[6] = v17;
  uint64_t v18 = a4[4];
  v9[7] = v18;
  unint64_t v20 = __RawDictionaryStorage.find<A>(_:)(a2, v17, v18);
  *((unsigned char *)v9 + 72) = v19 & 1;
  uint64_t v21 = *(void *)(v16 + 16);
  BOOL v22 = (v19 & 1) == 0;
  Swift::Int v23 = v21 + v22;
  if (__OFADD__(v21, v22))
  {
    __break(1u);
    goto LABEL_14;
  }
  char v24 = v19;
  Swift::Int v25 = *(void *)(v16 + 24);
  if (v25 >= v23 && (a3 & 1) != 0) {
    goto LABEL_9;
  }
  if (v25 >= v23 && (a3 & 1) == 0)
  {
    _NativeDictionary.copy()();
    goto LABEL_9;
  }
  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v23, a3 & 1);
  unint64_t v26 = __RawDictionaryStorage.find<A>(_:)(a2, v17, v18);
  if ((v24 & 1) != (v27 & 1)) {
LABEL_14:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v17);
  unint64_t v20 = v26;
LABEL_9:
  v9[8] = v20;
  uint64_t v28 = *(void *)(v10 - 8);
  if (v24)
  {
    (*(void (**)(void *, unint64_t, uint64_t))(*(void *)(v10 - 8) + 32))(v31, *(void *)(*v5 + 56) + *(void *)(*(void *)(v10 - 8) + 72) * v20, v10);
    uint64_t v29 = 0;
  }
  else
  {
    uint64_t v29 = 1;
  }
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v28 + 56))(v31, v29, 1, v10);
  return _NativeDictionary.subscript.modify;
}

void _NativeDictionary.subscript.modify(uint64_t **a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (void *)(*a1)[5];
  uint64_t v3 = (*a1)[3];
  uint64_t v4 = (*a1)[4];
  $defer #1 <A, B>() in _NativeDictionary.subscript.modify((uint64_t)v2, *((unsigned __int8 *)*a1 + 72), (void **)(*a1)[1], (*a1)[8], **a1, (unint64_t *)(*a1)[6], (*a1)[2], (*a1)[7]);
  (*(void (**)(void *, uint64_t))(v4 + 8))(v2, v3);
  free(v2);

  free(v1);
}

uint64_t Dictionary._Variant.subscript.setter(uint64_t a1, uint64_t a2, void *a3)
{
  char v6 = Dictionary._Variant.subscript.modify(v13, a2, a3);
  uint64_t v8 = v7;
  uint64_t v11 = type metadata accessor for Optional(0, a3[3], v9, v10);
  (*((void (**)(uint64_t, uint64_t, Class *))*(v11 - 1) + 5))(v8, a1, v11);
  ((void (*)(void *, void))v6)(v13, 0);
  return (*(uint64_t (**)(uint64_t))(*(void *)(a3[2] - 8) + 8))(a2);
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)(unint64_t a1, unint64_t a2, char a3)
{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)(a1, a2, a3, (void (*)(void))specialized _NativeDictionary.copy(), (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)(a1, a2, a3, (void (*)(void))specialized _NativeDictionary.copy(), (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)(a1, a2, a3, (void (*)(void))specialized _NativeDictionary.copy(), (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)(unint64_t a1, unint64_t a2, char a3, void (*a4)(void), void (*a5)(void))
{
  uint64_t v11 = *v5;
  unint64_t v13 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
  uint64_t v14 = *(void *)(v11 + 16);
  BOOL v15 = (v12 & 1) == 0;
  uint64_t v16 = v14 + v15;
  if (__OFADD__(v14, v15))
  {
    __break(1u);
    goto LABEL_11;
  }
  char v17 = v12;
  uint64_t v18 = *(void *)(v11 + 24);
  if (v18 < v16 || (a3 & 1) == 0)
  {
    if (v18 >= v16 && (a3 & 1) == 0)
    {
      a4();
      return v13;
    }
    a5();
    unint64_t v19 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
    if ((v17 & 1) == (v20 & 1)) {
      return v19;
    }
LABEL_11:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  return v13;
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)(void *a1, char a2)
{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)(a1, a2, (void (*)(void))specialized _NativeDictionary.copy(), (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)(a1, a2, (void (*)(void))specialized _NativeDictionary.copy(), (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)(void *a1, char a2, void (*a3)(void), void (*a4)(void))
{
  uint64_t v9 = *v4;
  unint64_t v11 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
  uint64_t v12 = *(void *)(v9 + 16);
  BOOL v13 = (v10 & 1) == 0;
  uint64_t v14 = v12 + v13;
  if (__OFADD__(v12, v13))
  {
    __break(1u);
    goto LABEL_11;
  }
  char v15 = v10;
  uint64_t v16 = *(void *)(v9 + 24);
  if (v16 < v14 || (a2 & 1) == 0)
  {
    if (v16 >= v14 && (a2 & 1) == 0)
    {
      a3();
      return v11;
    }
    a4();
    unint64_t v17 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
    if ((v15 & 1) == (v18 & 1)) {
      return v17;
    }
LABEL_11:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  return v11;
}

unint64_t _NativeDictionary.mutatingFind(_:isUnique:)(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v6 = *v3;
  unint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = *(void *)(a3 + 32);
  unint64_t v10 = __RawDictionaryStorage.find<A>(_:)(a1, v7, v8);
  uint64_t v11 = *(void *)(v6 + 16);
  BOOL v12 = (v9 & 1) == 0;
  Swift::Int v13 = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_11;
  }
  char v14 = v9;
  Swift::Int v15 = *(void *)(v6 + 24);
  if (v15 < v13 || (a2 & 1) == 0)
  {
    if (v15 >= v13 && (a2 & 1) == 0)
    {
      _NativeDictionary.copy()();
      return v10;
    }
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v13, a2 & 1);
    unint64_t v16 = __RawDictionaryStorage.find<A>(_:)(a1, v7, v8);
    if ((v14 & 1) == (v17 & 1)) {
      return v16;
    }
LABEL_11:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v7);
  }
  return v10;
}

int64x2_t *specialized _NativeDictionary.copy()()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }
  unint64_t result = v2 + 4;
  uint64_t v5 = v1 + 64;
  unint64_t v6 = (unint64_t)((1 << v3[2].i8[0]) + 63) >> 6;
  if (v3 != (int64x2_t *)v1 || (unint64_t)result >= v1 + 64 + 8 * v6) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v1 + 64), 8 * v6);
  }
  int64_t v8 = 0;
  v3[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v8++, 1)) {
      goto LABEL_26;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    unint64_t v25 = *(void *)(v5 + 8 * v8);
    if (!v25) {
      break;
    }
LABEL_23:
    unint64_t v11 = (v25 - 1) & v25;
    unint64_t v14 = __clz(__rbit64(v25)) + (v8 << 6);
LABEL_12:
    uint64_t v15 = 16 * v14;
    unint64_t v16 = (uint64_t *)(*(void *)(v1 + 48) + v15);
    uint64_t v18 = *v16;
    unint64_t v17 = v16[1];
    unint64_t v19 = (uint64_t *)(*(void *)(v1 + 56) + v15);
    uint64_t v20 = *v19;
    unint64_t v21 = v19[1];
    BOOL v22 = (void *)(v3[3].i64[0] + v15);
    *BOOL v22 = v18;
    v22[1] = v17;
    Swift::Int v23 = (void *)(v3[3].i64[1] + v15);
    *Swift::Int v23 = v20;
    v23[1] = v21;
    swift_bridgeObjectRetain(v17);
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v21);
  }
  int64_t v26 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  unint64_t v25 = *(void *)(v5 + 8 * v26);
  if (v25)
  {
    ++v8;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v8 = v26 + 1;
    if (__OFADD__(v26, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    unint64_t v25 = *(void *)(v5 + 8 * v8);
    ++v26;
    if (v25) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  long long v23;
  unint64_t v25;
  int64_t v26;
  uint64_t *v27;
  _OWORD v28[2];
  uint64_t v29;

  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
    unint64_t result = (int64x2_t *)swift_release(v1);
LABEL_26:
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }
  char v27 = v0;
  unint64_t result = v2 + 4;
  uint64_t v5 = v1 + 64;
  unint64_t v6 = (unint64_t)((1 << v3[2].i8[0]) + 63) >> 6;
  if (v3 != (int64x2_t *)v1 || (unint64_t)result >= v1 + 64 + 8 * v6) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v1 + 64), 8 * v6);
  }
  int64_t v8 = 0;
  v3[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v8++, 1)) {
      goto LABEL_28;
    }
    if (v8 >= v12)
    {
LABEL_24:
      unint64_t result = (int64x2_t *)swift_release(v1);
      uint64_t v0 = v27;
      goto LABEL_26;
    }
    unint64_t v25 = *(void *)(v5 + 8 * v8);
    if (!v25) {
      break;
    }
LABEL_23:
    unint64_t v11 = (v25 - 1) & v25;
    unint64_t v14 = __clz(__rbit64(v25)) + (v8 << 6);
LABEL_12:
    uint64_t v15 = 16 * v14;
    unint64_t v16 = (uint64_t *)(*(void *)(v1 + 48) + 16 * v14);
    uint64_t v18 = *v16;
    unint64_t v17 = v16[1];
    unint64_t v19 = 40 * v14;
    outlined init with copy of AnyHashable(*(void *)(v1 + 56) + 40 * v14, (uint64_t)v28);
    uint64_t v20 = (void *)(v3[3].i64[0] + v15);
    *uint64_t v20 = v18;
    v20[1] = v17;
    unint64_t v21 = v3[3].i64[1] + v19;
    BOOL v22 = v29;
    Swift::Int v23 = v28[1];
    *(_OWORD *)unint64_t v21 = v28[0];
    *(_OWORD *)(v21 + 16) = v23;
    *(void *)(v21 + 32) = v22;
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v17);
  }
  int64_t v26 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  unint64_t v25 = *(void *)(v5 + 8 * v26);
  if (v25)
  {
    ++v8;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v8 = v26 + 1;
    if (__OFADD__(v26, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    unint64_t v25 = *(void *)(v5 + 8 * v8);
    ++v26;
    if (v25) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22;
  int64_t v23;
  uint64_t *v24;
  _OWORD v25[2];

  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
    unint64_t result = (int64x2_t *)swift_release(v1);
LABEL_26:
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }
  char v24 = v0;
  unint64_t result = v2 + 4;
  uint64_t v5 = v1 + 64;
  unint64_t v6 = (unint64_t)((1 << v3[2].i8[0]) + 63) >> 6;
  if (v3 != (int64x2_t *)v1 || (unint64_t)result >= v1 + 64 + 8 * v6) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v1 + 64), 8 * v6);
  }
  int64_t v8 = 0;
  v3[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v8++, 1)) {
      goto LABEL_28;
    }
    if (v8 >= v12)
    {
LABEL_24:
      unint64_t result = (int64x2_t *)swift_release(v1);
      uint64_t v0 = v24;
      goto LABEL_26;
    }
    BOOL v22 = *(void *)(v5 + 8 * v8);
    if (!v22) {
      break;
    }
LABEL_23:
    unint64_t v11 = (v22 - 1) & v22;
    unint64_t v14 = __clz(__rbit64(v22)) + (v8 << 6);
LABEL_12:
    uint64_t v15 = 16 * v14;
    unint64_t v16 = (uint64_t *)(*(void *)(v1 + 48) + 16 * v14);
    uint64_t v18 = *v16;
    unint64_t v17 = v16[1];
    unint64_t v19 = 32 * v14;
    outlined init with copy of Any(*(void *)(v1 + 56) + 32 * v14, (uint64_t)v25);
    uint64_t v20 = (void *)(v3[3].i64[0] + v15);
    *uint64_t v20 = v18;
    v20[1] = v17;
    outlined init with take of Any(v25, (_OWORD *)(v3[3].i64[1] + v19));
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v17);
  }
  Swift::Int v23 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  BOOL v22 = *(void *)(v5 + 8 * v23);
  if (v22)
  {
    ++v8;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v8 = v23 + 1;
    if (__OFADD__(v23, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    BOOL v22 = *(void *)(v5 + 8 * v8);
    ++v23;
    if (v22) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  long long v20;
  void *v21;
  unint64_t v23;
  int64_t v24;
  _OWORD v25[2];
  uint64_t v26;

  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }
  unint64_t result = v2 + 4;
  uint64_t v5 = v1 + 64;
  unint64_t v6 = (unint64_t)((1 << v3[2].i8[0]) + 63) >> 6;
  if (v3 != (int64x2_t *)v1 || (unint64_t)result >= v1 + 64 + 8 * v6) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v1 + 64), 8 * v6);
  }
  int64_t v8 = 0;
  v3[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v8++, 1)) {
      goto LABEL_26;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    Swift::Int v23 = *(void *)(v5 + 8 * v8);
    if (!v23) {
      break;
    }
LABEL_23:
    unint64_t v11 = (v23 - 1) & v23;
    unint64_t v14 = __clz(__rbit64(v23)) + (v8 << 6);
LABEL_12:
    outlined init with copy of AnyHashable(*(void *)(v1 + 48) + 40 * v14, (uint64_t)v25);
    uint64_t v15 = (uint64_t *)(*(void *)(v1 + 56) + 16 * v14);
    unint64_t v17 = *v15;
    unint64_t v16 = v15[1];
    uint64_t v18 = v3[3].i64[0] + 40 * v14;
    unint64_t v19 = v26;
    uint64_t v20 = v25[1];
    *(_OWORD *)uint64_t v18 = v25[0];
    *(_OWORD *)(v18 + 16) = v20;
    *(void *)(v18 + 32) = v19;
    unint64_t v21 = (void *)(v3[3].i64[1] + 16 * v14);
    *unint64_t v21 = v17;
    v21[1] = v16;
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v16);
  }
  char v24 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  Swift::Int v23 = *(void *)(v5 + 8 * v24);
  if (v23)
  {
    ++v8;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v8 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    Swift::Int v23 = *(void *)(v5 + 8 * v8);
    ++v24;
    if (v23) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  long long v18;
  long long v19;
  unint64_t v21;
  int64_t v22;
  _OWORD v23[2];
  _OWORD v24[2];
  uint64_t v25;

  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }
  unint64_t result = v2 + 4;
  uint64_t v5 = v1 + 64;
  unint64_t v6 = (unint64_t)((1 << v3[2].i8[0]) + 63) >> 6;
  if (v3 != (int64x2_t *)v1 || (unint64_t)result >= v1 + 64 + 8 * v6) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v1 + 64), 8 * v6);
  }
  int64_t v8 = 0;
  v3[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v8++, 1)) {
      goto LABEL_26;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    unint64_t v21 = *(void *)(v5 + 8 * v8);
    if (!v21) {
      break;
    }
LABEL_23:
    unint64_t v11 = (v21 - 1) & v21;
    unint64_t v14 = __clz(__rbit64(v21)) + (v8 << 6);
LABEL_12:
    uint64_t v15 = 40 * v14;
    outlined init with copy of AnyHashable(*(void *)(v1 + 48) + 40 * v14, (uint64_t)v24);
    unint64_t v16 = 32 * v14;
    outlined init with copy of Any(*(void *)(v1 + 56) + v16, (uint64_t)v23);
    unint64_t v17 = v3[3].i64[0] + v15;
    uint64_t v18 = v24[0];
    unint64_t v19 = v24[1];
    *(void *)(v17 + 32) = v25;
    *(_OWORD *)unint64_t v17 = v18;
    *(_OWORD *)(v17 + 16) = v19;
    unint64_t result = (int64x2_t *)outlined init with take of Any(v23, (_OWORD *)(v3[3].i64[1] + v16));
  }
  BOOL v22 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  unint64_t v21 = *(void *)(v5 + 8 * v22);
  if (v21)
  {
    ++v8;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v8 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    unint64_t v21 = *(void *)(v5 + 8 * v8);
    ++v22;
    if (v21) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  unint64_t v23;
  int64_t v24;

  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }
  unint64_t result = v2 + 4;
  uint64_t v5 = v1 + 64;
  unint64_t v6 = (unint64_t)((1 << v3[2].i8[0]) + 63) >> 6;
  if (v3 != (int64x2_t *)v1 || (unint64_t)result >= v1 + 64 + 8 * v6) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v1 + 64), 8 * v6);
  }
  int64_t v8 = 0;
  v3[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v8++, 1)) {
      goto LABEL_26;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    Swift::Int v23 = *(void *)(v5 + 8 * v8);
    if (!v23) {
      break;
    }
LABEL_23:
    unint64_t v11 = (v23 - 1) & v23;
    unint64_t v14 = __clz(__rbit64(v23)) + (v8 << 6);
LABEL_12:
    uint64_t v15 = 16 * v14;
    unint64_t v16 = (uint64_t *)(*(void *)(v1 + 48) + 16 * v14);
    uint64_t v18 = *v16;
    unint64_t v17 = v16[1];
    unint64_t v19 = 8 * v14;
    uint64_t v20 = *(void *)(*(void *)(v1 + 56) + v19);
    unint64_t v21 = (void *)(v3[3].i64[0] + v15);
    *unint64_t v21 = v18;
    v21[1] = v17;
    *(void *)(v3[3].i64[1] + v19) = v20;
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v17);
  }
  char v24 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  Swift::Int v23 = *(void *)(v5 + 8 * v24);
  if (v23)
  {
    ++v8;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v8 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    Swift::Int v23 = *(void *)(v5 + 8 * v8);
    ++v24;
    if (v23) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

int64x2_t *specialized _NativeDictionary.copy()(uint64_t (*a1)(void))
{
  uint64_t v2 = *v1;
  uint64_t v3 = specialized static _DictionaryStorage.copy(original:)(*v1, a1);
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v2);
    *uint64_t v1 = (uint64_t)v4;
    return result;
  }
  unint64_t result = v3 + 4;
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << v4[2].i8[0]) + 63) >> 6;
  if (v4 != (int64x2_t *)v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  v4[1].i64[0] = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v9++, 1)) {
      goto LABEL_26;
    }
    if (v9 >= v13) {
      goto LABEL_24;
    }
    unint64_t v19 = *(void *)(v6 + 8 * v9);
    if (!v19) {
      break;
    }
LABEL_23:
    unint64_t v12 = (v19 - 1) & v19;
    unint64_t v15 = __clz(__rbit64(v19)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 8 * v15;
    uint64_t v17 = *(void *)(*(void *)(v2 + 56) + v16);
    *(void *)(v4[3].i64[0] + v16) = *(void *)(*(void *)(v2 + 48) + v16);
    *(void *)(v4[3].i64[1] + v16) = v17;
  }
  int64_t v20 = v9 + 1;
  if (v9 + 1 >= v13) {
    goto LABEL_24;
  }
  unint64_t v19 = *(void *)(v6 + 8 * v20);
  if (v19)
  {
    ++v9;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v9 = v20 + 1;
    if (__OFADD__(v20, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_24;
    }
    unint64_t v19 = *(void *)(v6 + 8 * v9);
    ++v20;
    if (v19) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

int64x2_t *specialized _NativeDictionary.copy()(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 16) - 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v38 = (char *)&v32 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v39 = v5;
  uint64_t v6 = *v1;
  unint64_t v7 = specialized static _DictionaryStorage.copy(original:)(*v1, v5, *(void *)(v3 + 32));
  int64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    unint64_t result = (int64x2_t *)swift_release(v6);
LABEL_28:
    *uint64_t v1 = (uint64_t)v8;
    return result;
  }
  unsigned int v33 = v1;
  unint64_t result = v7 + 4;
  unint64_t v10 = (unint64_t)((1 << v8[2].i8[0]) + 63) >> 6;
  if (v8 != (int64x2_t *)v6 || (unint64_t)result >= v6 + 64 + 8 * v10) {
    unint64_t result = (int64x2_t *)memmove(result, (const void *)(v6 + 64), 8 * v10);
  }
  uint64_t v34 = v6 + 64;
  int64_t v12 = 0;
  uint64_t v13 = *(void *)(v6 + 16);
  uint64_t v40 = v6;
  uint64_t v41 = v8;
  v8[1].i64[0] = v13;
  uint64_t v14 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v15 = -1;
  if (v14 < 64) {
    uint64_t v15 = ~(-1 << v14);
  }
  unint64_t v16 = v15 & *(void *)(v6 + 64);
  uint64_t v37 = v2 + 16;
  int64_t v35 = (unint64_t)(v14 + 63) >> 6;
  uint64_t v36 = v2 + 32;
  uint64_t v17 = v38;
  uint64_t v18 = v39;
  while (1)
  {
    if (v16)
    {
      unint64_t v19 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v20 = v19 | (v12 << 6);
      uint64_t v21 = v40;
      goto LABEL_12;
    }
    BOOL v29 = __OFADD__(v12++, 1);
    uint64_t v21 = v40;
    if (v29) {
      goto LABEL_30;
    }
    if (v12 >= v35)
    {
LABEL_27:
      unint64_t result = (int64x2_t *)swift_release(v40);
      uint64_t v1 = v33;
      int64_t v8 = v41;
      goto LABEL_28;
    }
    unint64_t v30 = *(void *)(v34 + 8 * v12);
    if (!v30) {
      break;
    }
LABEL_24:
    unint64_t v16 = (v30 - 1) & v30;
    unint64_t v20 = __clz(__rbit64(v30)) + (v12 << 6);
LABEL_12:
    unint64_t v22 = *(void *)(v2 + 72) * v20;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v17, *(void *)(v21 + 48) + v22, v18);
    uint64_t v23 = 16 * v20;
    uint64_t v24 = *(void *)(v21 + 56) + v23;
    uint64_t v25 = *(void *)v24;
    char v26 = *(unsigned char *)(v24 + 8);
    char v27 = v41;
    unint64_t result = (int64x2_t *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v2 + 32))(v41[3].i64[0] + v22, v17, v18);
    uint64_t v28 = v27[3].i64[1] + v23;
    *(void *)uint64_t v28 = v25;
    *(unsigned char *)(v28 + 8) = v26;
  }
  int64_t v31 = v12 + 1;
  if (v12 + 1 >= v35) {
    goto LABEL_27;
  }
  unint64_t v30 = *(void *)(v34 + 8 * v31);
  if (v30)
  {
    ++v12;
    goto LABEL_24;
  }
  int64_t v8 = v41;
  while (1)
  {
    int64_t v12 = v31 + 1;
    if (__OFADD__(v31, 1)) {
      break;
    }
    if (v12 >= v35)
    {
      unint64_t result = (int64x2_t *)swift_release(v40);
      uint64_t v1 = v33;
      goto LABEL_28;
    }
    unint64_t v30 = *(void *)(v34 + 8 * v12);
    ++v31;
    if (v30) {
      goto LABEL_24;
    }
  }
  __break(1u);
LABEL_30:
  __break(1u);
  return result;
}

Swift::Void __swiftcall _NativeDictionary.copy()()
{
  uint64_t v2 = v1;
  uint64_t v49 = *(void *)(*(void *)(v0 + 24) - 8);
  uint64_t v3 = ((uint64_t (*)())MEMORY[0x1F4188790])();
  uint64_t v45 = (char *)&v36 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v48 = *(void *)(*(void *)(v3 + 16) - 8);
  uint64_t v5 = MEMORY[0x1F4188790](v3);
  uint64_t v43 = (char *)&v36 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v44 = v7;
  uint64_t v8 = *(void *)(v5 + 32);
  uint64_t v46 = v9;
  type metadata accessor for _DictionaryStorage(0, v7, v9, v8);
  uint64_t v10 = *v1;
  uint64_t v11 = static _DictionaryStorage.copy(original:)(*v1);
  uint64_t v12 = *(void *)(v10 + 16);
  unint64_t v50 = v11;
  if (!v12)
  {
    swift_release(v10);
LABEL_23:
    *uint64_t v2 = (uint64_t)v50;
    return;
  }
  uint64_t v13 = v11;
  uint64_t v14 = v11 + 4;
  unint64_t v15 = (unint64_t)((1 << v13[2].i8[0]) + 63) >> 6;
  uint64_t v36 = v1;
  uint64_t v37 = (const void *)(v10 + 64);
  if (v13 != (int64x2_t *)v10 || (unint64_t)v14 >= v10 + 64 + 8 * v15)
  {
    memmove(v14, v37, 8 * v15);
    uint64_t v13 = v50;
  }
  int64_t v17 = 0;
  v13[1].i64[0] = *(void *)(v10 + 16);
  uint64_t v18 = 1 << *(unsigned char *)(v10 + 32);
  uint64_t v19 = -1;
  uint64_t v47 = v10;
  if (v18 < 64) {
    uint64_t v19 = ~(-1 << v18);
  }
  unint64_t v20 = v19 & *(void *)(v10 + 64);
  int64_t v21 = (unint64_t)(v18 + 63) >> 6;
  uint64_t v22 = v49;
  uint64_t v41 = v48 + 16;
  int64_t v42 = v21;
  uint64_t v23 = v48;
  uint64_t v39 = v48 + 32;
  uint64_t v40 = v49 + 16;
  uint64_t v38 = v49 + 32;
  uint64_t v24 = v43;
  uint64_t v25 = v44;
  char v26 = v45;
  char v27 = v50;
  while (1)
  {
    if (v20)
    {
      uint64_t v51 = (v20 - 1) & v20;
      unint64_t v28 = __clz(__rbit64(v20)) | (v17 << 6);
      uint64_t v29 = v47;
      goto LABEL_12;
    }
    int64_t v34 = v17 + 1;
    uint64_t v29 = v47;
    if (__OFADD__(v17, 1)) {
      goto LABEL_25;
    }
    if (v34 >= v21)
    {
LABEL_21:
      swift_release(v47);
      uint64_t v2 = v36;
      goto LABEL_23;
    }
    unint64_t v35 = *((void *)v37 + v34);
    ++v17;
    if (!v35) {
      break;
    }
LABEL_20:
    uint64_t v51 = (v35 - 1) & v35;
    unint64_t v28 = __clz(__rbit64(v35)) + (v17 << 6);
LABEL_12:
    unint64_t v30 = *(void *)(v23 + 72) * v28;
    (*(void (**)(char *, unint64_t, uint64_t))(v23 + 16))(v24, *(void *)(v29 + 48) + v30, v25);
    unint64_t v31 = *(void *)(v22 + 72) * v28;
    unint64_t v32 = *(void *)(v29 + 56) + v31;
    uint64_t v33 = v46;
    (*(void (**)(char *, unint64_t, uint64_t))(v22 + 16))(v26, v32, v46);
    (*(void (**)(unint64_t, char *, uint64_t))(v23 + 32))(v27[3].i64[0] + v30, v24, v25);
    (*(void (**)(unint64_t, char *, uint64_t))(v22 + 32))(v27[3].i64[1] + v31, v26, v33);
    int64_t v21 = v42;
    unint64_t v20 = v51;
  }
  while (1)
  {
    int64_t v17 = v34 + 1;
    if (__OFADD__(v34, 1)) {
      break;
    }
    if (v17 >= v21) {
      goto LABEL_21;
    }
    unint64_t v35 = *((void *)v37 + v17);
    ++v34;
    if (v35) {
      goto LABEL_20;
    }
  }
  __break(1u);
LABEL_25:
  __break(1u);
}

uint64_t _NativeDictionary.updateValue(_:forKey:isUnique:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = (void **)v5;
  uint64_t v37 = a1;
  uint64_t v38 = a5;
  unint64_t v10 = *(void *)(a4 + 16);
  uint64_t v36 = *(void *)(v10 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v35 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = (void *)*v5;
  uint64_t v15 = *(void *)(v14 + 32);
  unint64_t v18 = __RawDictionaryStorage.find<A>(_:)(v16, v10, v15);
  uint64_t v19 = v13[2];
  BOOL v20 = (v17 & 1) == 0;
  Swift::Int v21 = v19 + v20;
  if (__OFADD__(v19, v20))
  {
    __break(1u);
    goto LABEL_15;
  }
  char v22 = v17;
  Swift::Int v23 = v13[3];
  if (v23 < v21 || (a3 & 1) == 0)
  {
    if (v23 >= v21 && (a3 & 1) == 0)
    {
      _NativeDictionary.copy()();
      goto LABEL_7;
    }
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v21, a3 & 1);
    unint64_t v32 = __RawDictionaryStorage.find<A>(_:)(a2, v10, v15);
    if ((v22 & 1) == (v33 & 1))
    {
      unint64_t v18 = v32;
      uint64_t v24 = *v6;
      if (v22) {
        goto LABEL_8;
      }
LABEL_13:
      (*(void (**)(char *, uint64_t, unint64_t))(v36 + 16))(v12, a2, v10);
      uint64_t v34 = *(void *)(a4 + 24);
      _NativeDictionary._insert(at:key:value:)(v18, (uint64_t)v12, v37, v24, v10, v34);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v34 - 8) + 56))(v38, 1, 1, v34);
    }
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v10);
  }
LABEL_7:
  uint64_t v24 = *v6;
  if ((v22 & 1) == 0) {
    goto LABEL_13;
  }
LABEL_8:
  uint64_t v25 = v24[7];
  uint64_t v26 = *(void *)(a4 + 24);
  uint64_t v36 = *(void *)(v26 - 8);
  unint64_t v27 = *(void *)(v36 + 72) * v18;
  unint64_t v28 = *(void (**)(uint64_t, unint64_t, uint64_t))(v36 + 32);
  uint64_t v29 = v38;
  v28(v38, v25 + v27, v26);
  v28(v24[7] + v27, v37, v26);
  unint64_t v30 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v36 + 56);

  return v30(v29, 0, 1, v26);
}

_OWORD *specialized _NativeDictionary.setValue(_:forKey:isUnique:)(_OWORD *a1, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = (void **)v4;
  unint64_t v10 = (void *)*v4;
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
  uint64_t v13 = v10[2];
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
    goto LABEL_17;
  }
  char v16 = v11;
  uint64_t v17 = v10[3];
  if (v17 < v15 || (a4 & 1) == 0)
  {
    if (v17 >= v15 && (a4 & 1) == 0)
    {
      specialized _NativeDictionary.copy()();
      goto LABEL_7;
    }
    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v15, a4 & 1);
    unint64_t v21 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
    if ((v16 & 1) == (v22 & 1))
    {
      unint64_t v12 = v21;
      unint64_t v18 = *v5;
      if (v16) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
LABEL_17:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
LABEL_7:
  unint64_t v18 = *v5;
  if (v16)
  {
LABEL_8:
    uint64_t v19 = (uint64_t *)(v18[7] + 32 * v12);
    __swift_destroy_boxed_opaque_existential_1Tm(v19);
    return outlined init with take of Any(a1, v19);
  }
LABEL_13:
  specialized _NativeDictionary._insert(at:key:value:)(v12, a2, a3, a1, v18);

  return (_OWORD *)swift_bridgeObjectRetain(a3);
}

uint64_t specialized _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:)(a2);
  uint64_t v11 = *(void *)(v8 + 16);
  BOOL v12 = (v9 & 1) == 0;
  uint64_t result = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_14;
  }
  char v14 = v9;
  uint64_t v15 = *(void *)(v8 + 24);
  if (v15 >= result && (a3 & 1) != 0) {
    goto LABEL_7;
  }
  if (v15 >= result && (a3 & 1) == 0)
  {
    uint64_t result = (uint64_t)specialized _NativeDictionary.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<ObjectIdentifier, Int>);
LABEL_7:
    char v16 = (void *)*v4;
    if (v14)
    {
LABEL_8:
      *(void *)(v16[7] + 8 * v10) = a1;
      return result;
    }
    goto LABEL_11;
  }
  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(result, a3 & 1);
  uint64_t result = specialized __RawDictionaryStorage.find<A>(_:)(a2);
  if ((v14 & 1) != (v17 & 1)) {
    goto LABEL_15;
  }
  unint64_t v10 = result;
  char v16 = (void *)*v4;
  if (v14) {
    goto LABEL_8;
  }
LABEL_11:
  v16[(v10 >> 6) + 8] |= 1 << v10;
  uint64_t v18 = 8 * v10;
  *(void *)(v16[6] + v18) = a2;
  *(void *)(v16[7] + v18) = a1;
  uint64_t v19 = v16[2];
  BOOL v20 = __OFADD__(v19, 1);
  uint64_t v21 = v19 + 1;
  if (v20)
  {
LABEL_14:
    __break(1u);
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for ObjectIdentifier);
  }
  v16[2] = v21;
  return result;
}

_OWORD *specialized _NativeDictionary.setValue(_:forKey:isUnique:)(_OWORD *a1, void *a2, char a3)
{
  uint64_t v4 = (void **)v3;
  uint64_t v8 = (void *)*v3;
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:)(a2);
  uint64_t v11 = v8[2];
  BOOL v12 = (v9 & 1) == 0;
  uint64_t v13 = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_15;
  }
  char v14 = v9;
  uint64_t v15 = v8[3];
  if (v15 < v13 || (a3 & 1) == 0)
  {
    if (v15 >= v13 && (a3 & 1) == 0)
    {
      specialized _NativeDictionary.copy()();
      goto LABEL_7;
    }
    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v13, a3 & 1);
    unint64_t v19 = specialized __RawDictionaryStorage.find<A>(_:)(a2);
    if ((v14 & 1) == (v20 & 1))
    {
      unint64_t v10 = v19;
      char v16 = *v4;
      if (v14) {
        goto LABEL_8;
      }
LABEL_13:
      outlined init with copy of AnyHashable((uint64_t)a2, (uint64_t)v21);
      return specialized _NativeDictionary._insert(at:key:value:)(v10, (uint64_t)v21, a1, v16);
    }
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
LABEL_7:
  char v16 = *v4;
  if ((v14 & 1) == 0) {
    goto LABEL_13;
  }
LABEL_8:
  char v17 = (uint64_t *)(v16[7] + 32 * v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v17);

  return outlined init with take of Any(a1, v17);
}

void specialized _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:)(a3);
  uint64_t v13 = *(void *)(v10 + 16);
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
LABEL_16:
    __break(1u);
LABEL_17:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  char v16 = v11;
  uint64_t v17 = *(void *)(v10 + 24);
  if (v17 < v15 || (a4 & 1) == 0)
  {
    if (v17 < v15 || (a4 & 1) != 0)
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v15, a4 & 1);
      unint64_t v21 = specialized __RawDictionaryStorage.find<A>(_:)(a3);
      if ((v16 & 1) != (v22 & 1)) {
        goto LABEL_17;
      }
      unint64_t v12 = v21;
      uint64_t v18 = (void *)*v5;
      if (v16) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
    specialized _NativeDictionary.copy()();
  }
  uint64_t v18 = (void *)*v5;
  if ((v16 & 1) == 0)
  {
LABEL_13:
    outlined init with copy of AnyHashable((uint64_t)a3, (uint64_t)v30);
    v18[(v12 >> 6) + 8] |= 1 << v12;
    uint64_t v23 = v18[6] + 40 * v12;
    uint64_t v24 = v31;
    long long v25 = v30[1];
    *(_OWORD *)uint64_t v23 = v30[0];
    *(_OWORD *)(v23 + 16) = v25;
    *(void *)(v23 + 32) = v24;
    uint64_t v26 = (void *)(v18[7] + 16 * v12);
    *uint64_t v26 = a1;
    v26[1] = a2;
    uint64_t v27 = v18[2];
    BOOL v28 = __OFADD__(v27, 1);
    uint64_t v29 = v27 + 1;
    if (!v28)
    {
      void v18[2] = v29;
      return;
    }
    goto LABEL_16;
  }
LABEL_8:
  unint64_t v19 = (void *)(v18[7] + 16 * v12);
  uint64_t v20 = v19[1];
  *unint64_t v19 = a1;
  v19[1] = a2;

  swift_bridgeObjectRelease(v20);
}

unint64_t specialized _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
  uint64_t v13 = *(void *)(v10 + 16);
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
    goto LABEL_18;
  }
  char v16 = v11;
  uint64_t v17 = *(void *)(v10 + 24);
  if (v17 >= v15 && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v17 >= v15 && (a4 & 1) == 0)
  {
    specialized _NativeDictionary.copy()();
LABEL_7:
    uint64_t v18 = (void *)*v5;
    if (v16)
    {
LABEL_8:
      uint64_t v19 = v18[7] + 40 * v12;
      return outlined assign with take of AnyHashable((long long *)a1, v19);
    }
    goto LABEL_13;
  }
  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v15, a4 & 1);
  unint64_t v21 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
  if ((v16 & 1) != (v22 & 1)) {
    goto LABEL_19;
  }
  unint64_t v12 = v21;
  uint64_t v18 = (void *)*v5;
  if (v16) {
    goto LABEL_8;
  }
LABEL_13:
  v18[(v12 >> 6) + 8] |= 1 << v12;
  uint64_t v23 = (unint64_t *)(v18[6] + 16 * v12);
  *uint64_t v23 = a2;
  v23[1] = a3;
  uint64_t v24 = v18[7] + 40 * v12;
  long long v25 = *(_OWORD *)a1;
  long long v26 = *(_OWORD *)(a1 + 16);
  *(void *)(v24 + 32) = *(void *)(a1 + 32);
  *(_OWORD *)uint64_t v24 = v25;
  *(_OWORD *)(v24 + 16) = v26;
  uint64_t v27 = v18[2];
  BOOL v28 = __OFADD__(v27, 1);
  uint64_t v29 = v27 + 1;
  if (v28)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  void v18[2] = v29;

  return swift_bridgeObjectRetain(a3);
}

void specialized _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v6 = v5;
  uint64_t v12 = *v5;
  unint64_t v14 = specialized __RawDictionaryStorage.find<A>(_:)(a3, a4);
  uint64_t v15 = *(void *)(v12 + 16);
  BOOL v16 = (v13 & 1) == 0;
  uint64_t v17 = v15 + v16;
  if (__OFADD__(v15, v16))
  {
    __break(1u);
    goto LABEL_18;
  }
  char v18 = v13;
  uint64_t v19 = *(void *)(v12 + 24);
  if (v19 >= v17 && (a5 & 1) != 0) {
    goto LABEL_7;
  }
  if (v19 >= v17 && (a5 & 1) == 0)
  {
    specialized _NativeDictionary.copy()();
LABEL_7:
    uint64_t v20 = (void *)*v6;
    if (v18)
    {
LABEL_8:
      unint64_t v21 = (void *)(v20[7] + 16 * v14);
      uint64_t v22 = v21[1];
      *unint64_t v21 = a1;
      v21[1] = a2;
      swift_bridgeObjectRelease(v22);
      return;
    }
    goto LABEL_13;
  }
  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v17, a5 & 1);
  unint64_t v23 = specialized __RawDictionaryStorage.find<A>(_:)(a3, a4);
  if ((v18 & 1) != (v24 & 1)) {
    goto LABEL_19;
  }
  unint64_t v14 = v23;
  uint64_t v20 = (void *)*v6;
  if (v18) {
    goto LABEL_8;
  }
LABEL_13:
  v20[(v14 >> 6) + 8] |= 1 << v14;
  long long v25 = (unint64_t *)(v20[6] + 16 * v14);
  unint64_t *v25 = a3;
  v25[1] = a4;
  long long v26 = (void *)(v20[7] + 16 * v14);
  *long long v26 = a1;
  v26[1] = a2;
  uint64_t v27 = v20[2];
  BOOL v28 = __OFADD__(v27, 1);
  uint64_t v29 = v27 + 1;
  if (v28)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  v20[2] = v29;

  swift_bridgeObjectRetain(a4);
}

uint64_t _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v5 = (void **)v4;
  unint64_t v9 = *(void *)(a4 + 16);
  uint64_t v32 = *(void *)(v9 - 8);
  uint64_t v33 = a1;
  MEMORY[0x1F4188790](a1);
  char v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = (void *)*v4;
  uint64_t v14 = *(void *)(v13 + 32);
  unint64_t v17 = __RawDictionaryStorage.find<A>(_:)(v15, v9, v14);
  uint64_t v18 = v12[2];
  BOOL v19 = (v16 & 1) == 0;
  Swift::Int v20 = v18 + v19;
  if (__OFADD__(v18, v19))
  {
    __break(1u);
    goto LABEL_15;
  }
  char v21 = v16;
  Swift::Int v22 = v12[3];
  if (v22 < v20 || (a3 & 1) == 0)
  {
    if (v22 >= v20 && (a3 & 1) == 0)
    {
      _NativeDictionary.copy()();
      goto LABEL_9;
    }
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v20, a3 & 1);
    unint64_t v23 = __RawDictionaryStorage.find<A>(_:)(a2, v9, v14);
    if ((v21 & 1) == (v24 & 1))
    {
      unint64_t v17 = v23;
      goto LABEL_9;
    }
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v9);
  }
LABEL_9:
  uint64_t v25 = v33;
  long long v26 = *v5;
  if (v21)
  {
    uint64_t v27 = *(void *)(*(void *)(a4 + 24) - 8);
    BOOL v28 = *(uint64_t (**)(unint64_t, uint64_t))(v27 + 40);
    unint64_t v29 = v26[7] + *(void *)(v27 + 72) * v17;
    uint64_t v30 = v33;
    return v28(v29, v30);
  }
  else
  {
    (*(void (**)(char *, uint64_t, unint64_t))(v32 + 16))(v11, a2, v9);
    return _NativeDictionary._insert(at:key:value:)(v17, (uint64_t)v11, v25, v26, v9, *(void *)(a4 + 24));
  }
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(void *a1, Swift::Int a2, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 56);
  uint64_t v8 = *(void *)(*(void *)(*v3 + 48) + 16 * a2);
  unint64_t v9 = (uint64_t *)(v7 + 16 * a2);
  uint64_t v11 = *v9;
  uint64_t v10 = v9[1];
  *a1 = v11;
  a1[1] = v10;
  v12.Swift::Int offset = a2;
  specialized _NativeDictionary._delete(at:)(v12, v6);
  return v8;
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(uint64_t a1, Swift::Int a2, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 56);
  uint64_t v8 = *(void *)(*(void *)(*v3 + 48) + 16 * a2);
  Swift::Int v9 = v7 + 40 * a2;
  long long v10 = *(_OWORD *)(v9 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v9;
  *(_OWORD *)(a1 + 16) = v10;
  *(void *)(a1 + 32) = *(void *)(v9 + 32);
  v11.Swift::Int offset = a2;
  specialized _NativeDictionary._delete(at:)(v11, v6);
  return v8;
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(_OWORD *a1, Swift::Int a2, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*(void *)(v6 + 48) + 16 * a2);
  outlined init with take of Any((_OWORD *)(*(void *)(v6 + 56) + 32 * a2), a1);
  v8.Swift::Int offset = a2;
  specialized _NativeDictionary._delete(at:)(v8, v6);
  return v7;
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(uint64_t a1, Swift::_HashTable::Bucket before, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 56);
  Swift::Int v8 = *(void *)(*v3 + 48) + 40 * before.offset;
  long long v9 = *(_OWORD *)(v8 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v8;
  *(_OWORD *)(a1 + 16) = v9;
  *(void *)(a1 + 32) = *(void *)(v8 + 32);
  uint64_t v10 = *(void *)(v7 + 16 * before.offset);
  v11.Swift::Int offset = before.offset;
  specialized _NativeDictionary._delete(at:)(v11, v6);
  return v10;
}

Swift::Int specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(uint64_t a1, _OWORD *a2, Swift::Int a3, char a4)
{
  if ((a4 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v8 = *v4;
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *(void *)(v8 + 48) + 40 * a3;
  long long v11 = *(_OWORD *)(v10 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v10;
  *(_OWORD *)(a1 + 16) = v11;
  *(void *)(a1 + 32) = *(void *)(v10 + 32);
  outlined init with take of Any((_OWORD *)(v9 + 32 * a3), a2);
  v12.Swift::Int offset = a3;

  return specialized _NativeDictionary._delete(at:)(v12, v8);
}

void _NativeDictionary.uncheckedRemove(at:isUnique:)(uint64_t a1, uint64_t a2, Swift::_HashTable::Bucket a3, char a4, uint64_t a5)
{
  if ((a4 & 1) == 0) {
    _NativeDictionary.copy()();
  }
  uint64_t v10 = *v5;
  (*(void (**)(uint64_t, Swift::Int, void))(*(void *)(*(void *)(a5 + 16) - 8) + 32))(a1, *(void *)(v10 + 48) + *(void *)(*(void *)(*(void *)(a5 + 16) - 8) + 72) * a3.offset, *(void *)(a5 + 16));
  (*(void (**)(uint64_t, Swift::Int, void))(*(void *)(*(void *)(a5 + 24) - 8) + 32))(a2, *(void *)(v10 + 56) + *(void *)(*(void *)(*(void *)(a5 + 24) - 8) + 72) * a3.offset, *(void *)(a5 + 24));

  _NativeDictionary._delete(at:)(a3);
}

Swift::Void __swiftcall _NativeDictionary.removeAll(isUnique:)(Swift::Bool isUnique)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = *v2;
  char v6 = (*v2)[2].i8[0];
  if (!isUnique)
  {
    type metadata accessor for _DictionaryStorage(0, v1[2], v1[3], v1[4]);
    uint64_t v18 = static _DictionaryStorage.allocate(scale:age:seed:)(v6, 0x100000000, 0, 1);
    swift_release((uint64_t)v5);
    *uint64_t v3 = v18;
    return;
  }
  uint64_t v7 = 1 << v6;
  uint64_t v8 = v5 + 4;
  uint64_t v9 = -1;
  if (v7 < 64) {
    uint64_t v9 = ~(-1 << v7);
  }
  unint64_t v10 = v9 & v5[4].i64[0];
  int64_t v11 = (unint64_t)(v7 + 63) >> 6;
  swift_retain(v5->i64);
  int64_t v12 = 0;
  while (1)
  {
    if (v10)
    {
      unint64_t v13 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v14 = v13 | (v12 << 6);
      goto LABEL_6;
    }
    if (__OFADD__(v12++, 1)) {
      goto LABEL_24;
    }
    if (v12 >= v11) {
      break;
    }
    unint64_t v16 = v8->u64[v12];
    if (!v16)
    {
      int64_t v17 = v12 + 1;
      if (v12 + 1 >= v11) {
        break;
      }
      unint64_t v16 = v8->u64[v17];
      if (!v16)
      {
        while (1)
        {
          int64_t v12 = v17 + 1;
          if (__OFADD__(v17, 1)) {
            break;
          }
          if (v12 >= v11) {
            goto LABEL_19;
          }
          unint64_t v16 = v8->u64[v12];
          ++v17;
          if (v16) {
            goto LABEL_17;
          }
        }
        __break(1u);
LABEL_24:
        __break(1u);
        return;
      }
      ++v12;
    }
LABEL_17:
    unint64_t v10 = (v16 - 1) & v16;
    unint64_t v14 = __clz(__rbit64(v16)) + (v12 << 6);
LABEL_6:
    swift_arrayDestroy(v5[3].i64[0] + *(void *)(*(void *)(v4[2] - 8) + 72) * v14, 1, (unint64_t *)v4[2]);
    swift_arrayDestroy(v5[3].i64[1] + *(void *)(*(void *)(v4[3] - 8) + 72) * v14, 1, (unint64_t *)v4[3]);
  }
LABEL_19:
  swift_release((uint64_t)v5);
  uint64_t v19 = 1 << v5[2].i8[0];
  if (v19 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v19 + 63) >> 6, v5 + 4);
  }
  else {
    v8->i64[0] = -1 << v19;
  }
  v5[1].i64[0] = 0;
  ++v5[2].i32[1];
}

int64x2_t *_NativeDictionary.mapValues<A>(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v67 = a1;
  uint64_t v68 = a2;
  uint64_t v9 = *(void *)(a6 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v66 = (char *)&v54 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v10);
  unint64_t v16 = (char *)&v54 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1F4188790](v14);
  uint64_t v74 = (char *)&v54 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v64 = (char *)&v54 - v21;
  uint64_t v59 = v22;
  type metadata accessor for _DictionaryStorage(0, v23, v22, v24);
  uint64_t result = static _DictionaryStorage.copy(original:)(a3);
  int64_t v26 = 0;
  uint64_t v69 = a3;
  uint64_t v70 = v18;
  uint64_t v29 = *(void *)(a3 + 64);
  uint64_t v28 = a3 + 64;
  uint64_t v27 = v29;
  uint64_t v30 = 1 << *(unsigned char *)(v28 - 32);
  uint64_t v31 = -1;
  if (v30 < 64) {
    uint64_t v31 = ~(-1 << v30);
  }
  unint64_t v32 = v31 & v27;
  uint64_t v54 = v28;
  int64_t v55 = (unint64_t)(v30 + 63) >> 6;
  uint64_t v62 = v13 + 16;
  uint64_t v63 = v18 + 16;
  uint64_t v65 = v13;
  uint64_t v33 = (void (**)(char *, uint64_t))(v13 + 8);
  uint64_t v34 = a5;
  unint64_t v60 = v33;
  uint64_t v61 = v18 + 32;
  uint64_t v71 = result;
  uint64_t v57 = result + 4;
  uint64_t v58 = v9;
  uint64_t v56 = v9 + 32;
  if (!v32) {
    goto LABEL_5;
  }
LABEL_4:
  uint64_t v72 = (v32 - 1) & v32;
  int64_t v73 = v26;
  for (unint64_t i = __clz(__rbit64(v32)) | (v26 << 6); ; unint64_t i = __clz(__rbit64(v38)) + (v37 << 6))
  {
    uint64_t v40 = v69;
    uint64_t v41 = v70;
    unint64_t v42 = *(void *)(v70 + 72) * i;
    uint64_t v43 = v64;
    (*(void (**)(char *, unint64_t, uint64_t))(v70 + 16))(v64, *(void *)(v69 + 48) + v42, a4);
    unint64_t v44 = i;
    (*(void (**)(char *, unint64_t, uint64_t))(v65 + 16))(v16, *(void *)(v40 + 56) + *(void *)(v65 + 72) * i, v34);
    uint64_t v45 = a4;
    uint64_t v46 = *(void (**)(char *, char *, uint64_t))(v41 + 32);
    v46(v74, v43, v45);
    uint64_t v47 = v66;
    uint64_t v48 = v75;
    v67(v16);
    if (v48)
    {
      uint64_t v53 = (uint64_t)v71;
      swift_release((uint64_t)v71);
      (*(void (**)(char *, uint64_t))(v70 + 8))(v74, v45);
      (*v60)(v16, v34);
      return (int64x2_t *)v53;
    }
    uint64_t v75 = 0;
    uint64_t v49 = v16;
    (*v60)(v16, v34);
    *(uint64_t *)((char *)v57->i64 + ((v44 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v44;
    uint64_t v50 = (uint64_t)v71;
    v46((char *)(v71[3].i64[0] + v42), v74, v45);
    uint64_t result = (int64x2_t *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v58 + 32))(*(void *)(v50 + 56) + *(void *)(v58 + 72) * v44, v47, v59);
    uint64_t v51 = *(void *)(v50 + 16);
    BOOL v36 = __OFADD__(v51, 1);
    uint64_t v52 = v51 + 1;
    if (v36) {
      break;
    }
    *(void *)(v50 + 16) = v52;
    a4 = v45;
    unint64_t v16 = v49;
    unint64_t v32 = v72;
    int64_t v26 = v73;
    if (v72) {
      goto LABEL_4;
    }
LABEL_5:
    BOOL v36 = __OFADD__(v26, 1);
    int64_t v37 = v26 + 1;
    if (v36) {
      goto LABEL_24;
    }
    if (v37 >= v55) {
      return v71;
    }
    unint64_t v38 = *(void *)(v54 + 8 * v37);
    if (v38) {
      goto LABEL_14;
    }
    int64_t v39 = v37 + 1;
    if (v37 + 1 >= v55) {
      return v71;
    }
    unint64_t v38 = *(void *)(v54 + 8 * v39);
    if (!v38)
    {
      while (1)
      {
        int64_t v37 = v39 + 1;
        if (__OFADD__(v39, 1)) {
          goto LABEL_23;
        }
        if (v37 >= v55) {
          return v71;
        }
        unint64_t v38 = *(void *)(v54 + 8 * v37);
        ++v39;
        if (v38) {
          goto LABEL_14;
        }
      }
    }
    ++v37;
LABEL_14:
    uint64_t v72 = (v38 - 1) & v38;
    int64_t v73 = v37;
  }
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

atomic_ullong *DiscontiguousSlice.subranges.getter@<X0>(uint64_t a1@<X0>, atomic_ullong **a2@<X8>)
{
  uint64_t v3 = *(atomic_ullong **)(v2 + *(int *)(a1 + 36));
  *a2 = v3;
  return swift_retain(v3);
}

Class *DiscontiguousSlice.init(_base:subranges:)@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8 = *a2;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 32))(a5, a1);
  uint64_t result = type metadata accessor for DiscontiguousSlice(0, a3, a4, v9);
  *(void *)(a5 + *((int *)result + 9)) = v8;
  return result;
}

uint64_t static DiscontiguousSlice<>.== infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (unint64_t *)type metadata accessor for DiscontiguousSlice(0, a3, a4, a4);
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, v7, v8);
  return Sequence<>.elementsEqual<A>(_:)(a2, (uint64_t)v7, (uint64_t)v7, (uint64_t)WitnessTable, WitnessTable, a5) & 1;
}

uint64_t Sequence<>.elementsEqual<A>(_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5, uint64_t a6)
{
  uint64_t v79 = a1;
  uint64_t v76 = a6;
  uint64_t v68 = (uint64_t)a5;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v61 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v65 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v64 = (char *)&v58 - v13;
  unint64_t v16 = type metadata accessor for Optional(255, (uint64_t)AssociatedTypeWitness, v14, v15);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v16, (uint64_t)v16, 0, 0);
  uint64_t v17 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v19 = (char *)&v58 - v18;
  uint64_t v75 = v16;
  uint64_t v62 = (uint64_t)*(v16 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  int64_t v73 = (char *)&v58 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v72 = (char *)&v58 - v23;
  uint64_t v67 = a3;
  uint64_t AssociatedConformanceWitness = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v58 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v80 = swift_getAssociatedTypeWitness(0, a5, v26, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v60 = *((void *)v80 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v80);
  uint64_t v29 = (char *)&v58 - v28;
  uint64_t v30 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v27);
  unint64_t v32 = (char *)&v58 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v33 = swift_getAssociatedTypeWitness(0, (int **)a4, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v59 = *((void *)v33 - 1);
  MEMORY[0x1F4188790](v33);
  uint64_t v35 = (char *)&v58 - v34;
  (*(void (**)(char *, const char *, uint64_t))(v30 + 16))(v32, v78, a2);
  BOOL v36 = *(void (**)(uint64_t, uint64_t))(a4 + 32);
  unint64_t v77 = v35;
  v36(a2, a4);
  uint64_t v37 = v67;
  (*(void (**)(char *, char *, uint64_t))(AssociatedConformanceWitness + 16))(v25, v79, v67);
  unint64_t v38 = *(void (**)(uint64_t))(v68 + 32);
  uint64_t v79 = v29;
  uint64_t v39 = v68;
  v38(v37);
  unint64_t v78 = v33;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a2, (uint64_t)v33, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v69 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v70 = AssociatedConformanceWitness + 16;
  uint64_t v68 = swift_getAssociatedConformanceWitness(v39, v37, (uint64_t)v80, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v66 = *(void (**)(const char *, uint64_t))(v68 + 16);
  uint64_t v67 = v68 + 16;
  uint64_t v40 = (void (**)(char *, char *, Class *))(v62 + 32);
  uint64_t v41 = (unsigned int (**)(char *, uint64_t, const char *))(v61 + 48);
  unint64_t v42 = (void (**)(char *, char *, const char *))(v61 + 32);
  uint64_t v63 = v76 + 8;
  uint64_t v43 = (void (**)(char *, const char *))(v61 + 8);
  while (1)
  {
    unint64_t v44 = v72;
    v69(v78, AssociatedConformanceWitness);
    uint64_t v45 = v73;
    v66(v80, v68);
    uint64_t v46 = &v19[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v47 = *v40;
    uint64_t v48 = v44;
    uint64_t v49 = v75;
    (*v40)(v19, v48, v75);
    v47(v46, v45, v49);
    uint64_t v50 = *v41;
    if ((*v41)(v19, 1, AssociatedTypeWitness) == 1) {
      break;
    }
    if (v50(v46, 1, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, const char *))(v60 + 8))(v79, v80);
      (*(void (**)(char *, const char *))(v59 + 8))(v77, v78);
      (*v43)(v19, AssociatedTypeWitness);
      return 0;
    }
    uint64_t v51 = *v42;
    uint64_t v52 = v64;
    (*v42)(v64, v19, AssociatedTypeWitness);
    uint64_t v53 = v65;
    v51(v65, v46, AssociatedTypeWitness);
    char v54 = (*(uint64_t (**)(char *, char *, const char *))(v76 + 8))(v52, v53, AssociatedTypeWitness);
    int64_t v55 = *v43;
    (*v43)(v53, AssociatedTypeWitness);
    v55(v52, AssociatedTypeWitness);
    if ((v54 & 1) == 0)
    {
      (*(void (**)(char *, const char *))(v60 + 8))(v79, v80);
      (*(void (**)(char *, const char *))(v59 + 8))(v77, v78);
      return 0;
    }
  }
  (*(void (**)(char *, const char *))(v60 + 8))(v79, v80);
  (*(void (**)(char *, const char *))(v59 + 8))(v77, v78);
  uint64_t v56 = 1;
  if (v50(v46, 1, AssociatedTypeWitness) == 1) {
    return v56;
  }
  (*(void (**)(char *, Class *))(v62 + 8))(v46, v75);
  return 0;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <> DiscontiguousSlice<A>(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  return static DiscontiguousSlice<>.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24), *(void *)(a4 - 8));
}

uint64_t DiscontiguousSlice<>.hash(into:)(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v124 = a3;
  uint64_t v7 = a2[2];
  uint64_t v6 = a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  unint64_t v88 = (void (**)(char *, const char *))*((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v108 = (char *)&v83 - v8;
  uint64_t v9 = swift_getAssociatedTypeWitness(255, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v7, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v123 = v9;
  unint64_t v107 = type metadata accessor for Range(0, (uint64_t)v9, AssociatedConformanceWitness, v10);
  uint64_t v122 = (uint64_t)*(v107 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v107);
  unint64_t v106 = (char *)&v83 - v12;
  uint64_t v90 = *(void (***)(char *, uint64_t))(v7 - 8);
  MEMORY[0x1F4188790](v11);
  id v127 = (char *)&v83 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v125 = v6;
  uint64_t v105 = swift_getAssociatedTypeWitness(0, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v85 = (void (**)(char *, const char *))*((void *)v105 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v105);
  unint64_t v104 = (char *)&v83 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v103 = (char *)&v83 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v102 = (char *)&v83 - v18;
  uint64_t v119 = v7;
  uint64_t v20 = type metadata accessor for DiscontiguousSlice.Index(0, v7, v6, v19);
  uint64_t v126 = (uint64_t)*(v20 - 1);
  uint64_t v21 = MEMORY[0x1F4188790](v20);
  int64_t v121 = (char *)&v83 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v120 = (char *)&v83 - v24;
  uint64_t v25 = *(a2 - 1);
  MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v83 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, a2, v28);
  uint64_t v31 = type metadata accessor for IndexingIterator(0, (uint64_t)a2, WitnessTable, v30);
  uint64_t v84 = (uint64_t)*(v31 - 1);
  uint64_t v32 = MEMORY[0x1F4188790](v31);
  uint64_t v34 = (char *)&v83 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v32);
  BOOL v36 = (char *)&v83 - v35;
  Swift::UInt v37 = DiscontiguousSlice.count.getter((uint64_t)a2);
  uint64_t v110 = a1;
  Hasher._combine(_:)(v37);
  unint64_t v38 = *(void (**)(char *, uint64_t, unint64_t *))(v25 + 16);
  uint64_t v39 = (uint64_t)a2;
  v38(v27, v3, a2);
  uint64_t v99 = v25 + 16;
  uint64_t v98 = (void (*)(char *, char *, uint64_t))v38;
  v38(v34, (uint64_t)v27, a2);
  uint64_t v40 = v120;
  DiscontiguousSlice.startIndex.getter(v39, v41, v120);
  unint64_t v42 = *(void (**)(char *, uint64_t))(v25 + 8);
  char v100 = v27;
  uint64_t v101 = v25 + 8;
  uint64_t v97 = v42;
  v42(v27, v39);
  uint64_t v43 = &v34[*((int *)v31 + 9)];
  uint64_t v44 = v126;
  uint64_t v45 = *(void (**)(uint64_t *, char *, Class *))(v126 + 32);
  uint64_t v96 = v126 + 32;
  unint64_t v95 = v45;
  v45((uint64_t *)v43, v40, v20);
  (*(void (**)(char *, char *, Class *))(v84 + 32))(v36, v34, v31);
  uint64_t v83 = v31;
  uint64_t v46 = *((int *)v31 + 9);
  char v129 = v36;
  uint64_t v47 = (uint64_t *)&v36[v46];
  unint64_t v117 = *(void (**)(void))(v125 + 72);
  uint64_t v118 = v125 + 72;
  uint64_t v116 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v114 = *(uint64_t (**)(char *, char *))(v116 + 8);
  uint64_t v115 = v116 + 8;
  uint64_t v113 = *(void (**)(char *, uint64_t *, Class *))(v44 + 16);
  uint64_t v126 = v44 + 16;
  unint64_t v112 = (void (**)(char *, char *, uint64_t))(v90 + 2);
  uint64_t v93 = v122 + 16;
  uint64_t v92 = v125 + 88;
  uint64_t v48 = v40;
  uint64_t v111 = v39;
  uint64_t AssociatedConformanceWitness = *(int *)(v39 + 36);
  uint64_t v91 = v122 + 8;
  ++v90;
  unint64_t v89 = (void (**)(char *))(v85 + 2);
  ++v88;
  uint64_t v87 = (void (**)(char *, char *, const char *))(v85 + 4);
  uint64_t v86 = v124 + 24;
  ++v85;
  uint64_t v49 = (void (**)(char *, Class *))(v44 + 8);
  int64_t v94 = (void (**)(char *, Class *))(v44 + 8);
  while (1)
  {
    v113(v48, v47, v20);
    uint64_t v50 = *(void *)(*(void *)&v129[AssociatedConformanceWitness] + 16);
    uint64_t v51 = v121;
    uint64_t v52 = &v121[*((int *)v20 + 9)];
    uint64_t v53 = v48;
    uint64_t v54 = v119;
    uint64_t v55 = v125;
    v117();
    *(void *)uint64_t v51 = v50;
    char v56 = v114(&v53[*((int *)v20 + 9)], v52);
    uint64_t v57 = *v49;
    (*v49)(v51, v20);
    uint64_t v58 = v47;
    uint64_t v59 = v20;
    v57(v53, v20);
    if (v56) {
      break;
    }
    uint64_t v60 = v54;
    (*v112)(v127, v129, v54);
    unint64_t v61 = *v58;
    if (*v58 < 0 || (uint64_t v62 = *(void *)&v129[AssociatedConformanceWitness], v61 >= *(void *)(v62 + 16))) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
    uint64_t v63 = v58;
    uint64_t v64 = v122;
    uint64_t v65 = v106;
    uint64_t v66 = v107;
    (*(void (**)(char *, unint64_t, Class *))(v122 + 16))(v106, v62+ ((*(unsigned __int8 *)(v122 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v122 + 80))+ *(void *)(v122 + 72) * v61, v107);
    uint64_t v67 = v108;
    uint64_t v68 = v127;
    (*(void (**)(char *, uint64_t, uint64_t))(v55 + 88))(v65, v60, v55);
    (*(void (**)(char *, Class *))(v64 + 8))(v65, v66);
    (*v90)(v68, v60);
    uint64_t v69 = (char *)v63 + *((int *)v59 + 9);
    uint64_t v70 = v55;
    uint64_t v71 = AssociatedTypeWitness;
    uint64_t v72 = swift_getAssociatedConformanceWitness(v70, v60, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    int64_t v73 = (void (*)(char *, void))(*(uint64_t (**)(char *, char *, const char *, uint64_t))(v72 + 80))(v130, v69, v71, v72);
    uint64_t v74 = v103;
    uint64_t v75 = v105;
    (*v89)(v103);
    v73(v130, 0);
    (*v88)(v67, v71);
    uint64_t v76 = v100;
    uint64_t v77 = v111;
    v98(v100, v129, v111);
    uint64_t v48 = v120;
    uint64_t v20 = v59;
    uint64_t v47 = v63;
    DiscontiguousSlice.index(after:)(v63, v77, (uint64_t *)v120);
    v97(v76, v77);
    unint64_t v78 = v63;
    uint64_t v49 = v94;
    v57((char *)v78, v20);
    v95(v47, v48, v20);
    uint64_t v79 = *v87;
    uint64_t v80 = v102;
    (*v87)(v102, v74, v75);
    uint64_t v81 = v104;
    v79(v104, v80, v75);
    (*(void (**)(uint64_t, const char *))(v124 + 24))(v110, v75);
    (*v85)(v81, v75);
  }
  return (*(uint64_t (**)(char *, Class *))(v84 + 8))(v129, v83);
}

uint64_t DiscontiguousSlice.count.getter(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v3, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v5 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v47 = (char *)&v40 - v6;
  uint64_t v7 = swift_getAssociatedTypeWitness(255, (int **)v3, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v3, v4, (uint64_t)v7, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v10 = type metadata accessor for Range(0, (uint64_t)v7, AssociatedConformanceWitness, v9);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v46 = (char *)&v40 - v15;
  uint64_t v16 = *(int *)(a1 + 36);
  uint64_t v49 = v1;
  uint64_t v17 = *(atomic_ullong **)(v1 + v16);
  uint64_t v18 = v11 + 16;
  uint64_t v19 = v11 + 32;
  uint64_t v44 = v11 + 8;
  uint64_t v45 = v3 + 88;
  uint64_t v43 = (void (**)(char *, const char *))(v5 + 8);
  swift_retain(v17);
  unint64_t v20 = 0;
  uint64_t v21 = 0;
  while (1)
  {
    unint64_t v22 = v17[2];
    if (v20 == v22) {
      break;
    }
    if (v20 >= v22) {
      goto LABEL_7;
    }
    (*(void (**)(char *, unint64_t, Class *))(v11 + 16))(v14, (unint64_t)v17+ ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))+ *(void *)(v11 + 72) * v20++, v10);
    uint64_t v23 = *(void (**)(char *, char *, Class *))(v11 + 32);
    uint64_t v41 = v18;
    uint64_t v24 = v46;
    v23(v46, v14, v10);
    uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v3 + 88);
    uint64_t v40 = v19;
    uint64_t v26 = v47;
    unint64_t v42 = v17;
    v25(v24, v4, v3);
    (*(void (**)(char *, Class *))(v11 + 8))(v24, v10);
    uint64_t v27 = v3;
    uint64_t v28 = v4;
    uint64_t v29 = v14;
    uint64_t v30 = v3;
    uint64_t v31 = v10;
    uint64_t v32 = v4;
    uint64_t v33 = AssociatedTypeWitness;
    uint64_t v34 = swift_getAssociatedConformanceWitness(v27, v28, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v35 = (*(uint64_t (**)(const char *, uint64_t))(v34 + 112))(v33, v34);
    BOOL v36 = v26;
    Swift::UInt v37 = v33;
    uint64_t v4 = v32;
    uint64_t v10 = v31;
    uint64_t v3 = v30;
    uint64_t v14 = v29;
    uint64_t v19 = v40;
    uint64_t v18 = v41;
    (*v43)(v36, v37);
    BOOL v38 = __OFADD__(v21, v35);
    v21 += v35;
    uint64_t v17 = v42;
    if (v38)
    {
      __break(1u);
LABEL_7:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
  }
  swift_release((uint64_t)v17);
  return v21;
}

Swift::Int DiscontiguousSlice<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter(a1, a2, (void (*)(void *, uint64_t, uint64_t))DiscontiguousSlice<>.hash(into:));
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> DiscontiguousSlice<A>(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> DiscontiguousSlice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return DiscontiguousSlice<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> DiscontiguousSlice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 - 8);
  v5[0] = 0;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  void v5[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v5[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v6 = 0u;
  long long v7 = 0u;
  DiscontiguousSlice<>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

uint64_t DiscontiguousSlice.description.getter(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(int ***)(v3 + 8);
  uint64_t v165 = v2;
  int64_t v166 = (int **)v3;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v170 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v169 = (char *)&v138 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  unint64_t v153 = (unint64_t)&v138 - v8;
  uint64_t v10 = type metadata accessor for DiscontiguousSlice.Index(0, v2, v3, v9);
  uint64_t v167 = (uint64_t)*(v10 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v164 = (char *)&v138 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v140 = (char *)&v138 - v14;
  uint64_t v15 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v138 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, (unint64_t *)a1, v18);
  uint64_t v21 = type metadata accessor for IndexingIterator(0, a1, WitnessTable, v20);
  uint64_t v141 = (uint64_t)*(v21 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v21);
  uint64_t v24 = (char *)&v138 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v138 - v25;
  swift_bridgeObjectRelease(0xE000000000000000);
  uint64_t v173 = 91;
  unint64_t v174 = 0xE100000000000000;
  uint64_t v27 = *(void (**)(char *, uint64_t *, uint64_t))(v15 + 16);
  v27(v17, v168, a1);
  uint64_t v150 = v15 + 16;
  uint64_t v149 = (void (*)(char *, char *, uint64_t))v27;
  v27(v24, (uint64_t *)v17, a1);
  uint64_t v28 = v140;
  DiscontiguousSlice.startIndex.getter(a1, v29, v140);
  uint64_t v30 = *(void (**)(char *, uint64_t))(v15 + 8);
  int v151 = v17;
  uint64_t v152 = v15 + 8;
  uint64_t v148 = v30;
  v30(v17, a1);
  uint64_t v31 = &v24[*((int *)v21 + 9)];
  uint64_t v32 = v167;
  uint64_t v33 = *(void (**)(unint64_t *, uint64_t *, Class *))(v167 + 32);
  uint64_t v147 = v167 + 32;
  uint64_t v146 = v33;
  v33((unint64_t *)v31, (uint64_t *)v28, v10);
  (*(void (**)(char *, char *, Class *))(v141 + 32))(v26, v24, v21);
  unint64_t v139 = v21;
  uint64_t v34 = *((int *)v21 + 9);
  uint64_t v35 = v26;
  BOOL v36 = (unint64_t *)&v26[v34];
  uint64_t v154 = a1;
  uint64_t v163 = *(int *)(a1 + 36);
  unint64_t v161 = v166[9];
  unint64_t v162 = v166 + 9;
  Swift::UInt v37 = v166;
  uint64_t v38 = v165;
  uint64_t v160 = swift_getAssociatedTypeWitness(0, v166, v165, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v159 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v37, v38, (uint64_t)v160, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  char v157 = *(uint64_t (**)(char *, char *))(v159 + 8);
  uint64_t v158 = v159 + 8;
  unint64_t v156 = *(void (**)(uint64_t *, unint64_t *, Class *))(v32 + 16);
  uint64_t v167 = v32 + 16;
  unint64_t v155 = (void (**)(uint64_t *, Class *))(v32 + 8);
  uint64_t v39 = (uint64_t *)v28;
  uint64_t v40 = v170 + 32;
  uint64_t v170 = 1;
  long long v144 = xmmword_18162AC80;
  long long v142 = xmmword_18162AC90;
  uint64_t v143 = AssociatedTypeWitness;
  uint64_t v145 = v35;
  int64_t v168 = (uint64_t *)v40;
  v156(v39, v36, v10);
  while (1)
  {
    uint64_t v47 = (uint64_t *)v164;
    uint64_t v48 = *(void *)(*(void *)&v35[v163] + 16);
    uint64_t v49 = v39;
    uint64_t v50 = v35;
    uint64_t v51 = &v164[*((int *)v10 + 9)];
    ((void (*)(uint64_t, int **))v161)(v165, v166);
    *uint64_t v47 = v48;
    char v52 = v157((char *)v49 + *((int *)v10 + 9), v51);
    uint64_t v53 = *v155;
    (*v155)(v47, v10);
    v53(v49, v10);
    if (v52) {
      break;
    }
    unint64_t v54 = v153;
    uint64_t v55 = v154;
    DiscontiguousSlice.subscript.getter(v36, v154, v153);
    char v56 = v151;
    v149(v151, v50, v55);
    DiscontiguousSlice.index(after:)((uint64_t *)v36, v55, v49);
    v148(v56, v55);
    v53((uint64_t *)v36, v10);
    uint64_t v57 = v168;
    v146(v36, v49, v10);
    uint64_t v58 = *v57;
    uint64_t v43 = v169;
    ((void (*)(char *, unint64_t, const char *))*v57)(v169, v54, AssociatedTypeWitness);
    uint64_t v39 = v49;
    if ((v170 & 1) == 0)
    {
      uint64_t v60 = v173;
      uint64_t v59 = v174;
      unint64_t v61 = HIBYTE(v174) & 0xF;
      if ((v174 & 0x2000000000000000) != 0) {
        unint64_t v62 = HIBYTE(v174) & 0xF;
      }
      else {
        unint64_t v62 = v173 & 0xFFFFFFFFFFFFLL;
      }
      if (!v62 && (v173 & ~v174 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v174);
        uint64_t v173 = 8236;
        unint64_t v93 = 0xE200000000000000;
        goto LABEL_44;
      }
      if ((v174 & 0x2000000000000000) != 0 && v61 <= 0xD)
      {
        unint64_t v63 = 8 * (HIBYTE(v174) & 7);
        uint64_t v64 = (-255 << v63) - 1;
        uint64_t v65 = 44 << v63;
        char v66 = v61 + 1;
        if (v61 >= 8)
        {
          uint64_t v67 = v65 | v64 & v174;
LABEL_38:
          uint64_t v92 = (32 << (8 * (v66 & 7u))) | ((-255 << (8 * (v66 & 7u))) - 1) & v67;
        }
        else
        {
          uint64_t v60 = v65 | v64 & v173;
          if (v61 == 7)
          {
            char v66 = 8;
            uint64_t v67 = v174;
            goto LABEL_38;
          }
          uint64_t v60 = (32 << (8 * (v66 & 7u))) | ((-255 << (8 * (v66 & 7u))) - 1) & v60;
          uint64_t v92 = v174;
        }
        swift_bridgeObjectRelease(v174);
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v94 = 0xE000000000000000;
        if (v60 & 0x8080808080808080 | v92 & 0x80808080808080) {
          unint64_t v94 = 0xA000000000000000;
        }
        unint64_t v93 = (v94 & 0xFF00000000000000 | (v61 << 56) | v92 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
        uint64_t v173 = v60;
LABEL_44:
        unint64_t v174 = v93;
LABEL_45:
        AssociatedTypeWitness = v143;
LABEL_3:
        uint64_t v43 = v169;
        goto LABEL_4;
      }
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v59 & 0x1000000000000000) != 0) {
        unint64_t v62 = String.UTF8View._foreignCount()();
      }
      BOOL v68 = __OFADD__(v62, 2);
      uint64_t v69 = v62 + 2;
      AssociatedTypeWitness = v143;
      if (v68)
      {
        __break(1u);
LABEL_105:
        Swift::Int v129 = String.UTF8View._foreignCount()();
        uint64_t v96 = v129 + 1;
        if (!__OFADD__(v129, 1)) {
          goto LABEL_58;
        }
LABEL_107:
        __break(1u);
LABEL_108:
        if ((v96 & 0x1000000000000000) != 0)
        {
          uint64_t v69 = _StringGuts._foreignConvertedToSmall()(v69, v96);
          uint64_t v135 = v134;
          swift_bridgeObjectRelease(v96);
          uint64_t v96 = v135;
        }
        else
        {
          if ((v69 & 0x1000000000000000) != 0)
          {
            uint64_t v130 = (unsigned __int8 *)((v96 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v131 = v69 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v130 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v69, v96);
          }
          closure #1 in _StringGuts._convertedToSmall()(v130, v131, &v171);
          swift_bridgeObjectRelease(v96);
          uint64_t v96 = *((void *)&v171 + 1);
          uint64_t v69 = v171;
        }
        goto LABEL_81;
      }
      if ((v60 & ~v59 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v59 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v70 = _StringGuts.nativeUnusedCapacity.getter(v60, v59);
        if (v71) {
          goto LABEL_118;
        }
        BOOL v73 = (v59 & 0x2000000000000000) == 0 && v70 > 1;
        if (v69 > 15 || v73) {
          goto LABEL_2;
        }
      }
      else if (v69 > 15)
      {
LABEL_2:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v69, 2);
        swift_bridgeObjectRelease_n(0xE200000000000000, 6);
        long long v171 = v142;
        uint64_t v41 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v171, 2);
        _StringGuts.appendInPlace(_:isASCII:)(v41, v42, 1);
        swift_bridgeObjectRelease(0xE200000000000000);
        goto LABEL_3;
      }
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      swift_bridgeObjectRetain(v59);
      unint64_t v74 = _StringGuts._convertedToSmall()(v60, v59);
      unint64_t v76 = v75;
      swift_bridgeObjectRelease(v59);
      v77._rawBits = 131073;
      v78._rawBits = 1;
      v79._rawBits = _StringGuts.validateScalarRange(_:)(v78, v77, 0x202CuLL, 0xE200000000000000);
      if (v79._rawBits < 0x10000) {
        v79._rawBits |= 3;
      }
      unint64_t v81 = specialized String.init(_:)(v79, v80, 0x202CuLL, 0xE200000000000000);
      unint64_t v83 = v82;
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v84 = _StringGuts._convertedToSmall()(v81, v83);
      unint64_t v86 = v85;
      swift_bridgeObjectRelease(v83);
      unint64_t v87 = specialized _SmallString.init(_:appending:)(v74, v76, v84, v86);
      if (v89) {
        goto LABEL_117;
      }
      uint64_t v90 = v87;
      unint64_t v91 = v88;
      swift_bridgeObjectRelease(v59);
      swift_bridgeObjectRelease(0xE200000000000000);
      uint64_t v173 = v90;
      unint64_t v174 = v91;
      goto LABEL_45;
    }
LABEL_4:
    uint64_t v44 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    uint64_t inited = swift_initStackObject(v44, &v172);
    *((_OWORD *)inited + 1) = v144;
    inited[7] = AssociatedTypeWitness;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    ((void (*)(void *, char *, const char *))v58)(boxed_opaque_existential_0Tm, v43, AssociatedTypeWitness);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v173);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    uint64_t v170 = 0;
    uint64_t v35 = v145;
    v156(v39, v36, v10);
  }
  (*(void (**)(char *, Class *))(v141 + 8))(v50, v139);
  uint64_t v58 = v173;
  uint64_t v59 = v174;
  uint64_t v69 = HIBYTE(v174) & 0xF;
  unint64_t v54 = v173 & 0xFFFFFFFFFFFFLL;
  if ((v174 & 0x2000000000000000) != 0) {
    unint64_t v95 = HIBYTE(v174) & 0xF;
  }
  else {
    unint64_t v95 = v173 & 0xFFFFFFFFFFFFLL;
  }
  if (!v95 && (v173 & ~v174 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v174);
    return 93;
  }
  if ((v174 & 0x2000000000000000) == 0 || v69 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v59 & 0x1000000000000000) != 0) {
      goto LABEL_105;
    }
    BOOL v68 = __OFADD__(v95, 1);
    uint64_t v96 = v95 + 1;
    if (v68) {
      goto LABEL_107;
    }
LABEL_58:
    uint64_t v97 = v58 & ~v59;
    if ((v97 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v59 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v98 = _StringGuts.nativeUnusedCapacity.getter(v58, v59);
      if (v99)
      {
LABEL_118:
        unint64_t v133 = 258;
LABEL_119:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v133, 0);
      }
      if (v96 > 15) {
        goto LABEL_64;
      }
      if ((v59 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        goto LABEL_76;
      }
      if (v98 > 0)
      {
LABEL_64:
        int64_t v100 = _StringGuts.nativeUnusedCapacity.getter(v58, v59);
        BOOL v103 = (v101 & 1) == 0 && v100 > 0;
        if ((v97 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v59 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v103) {
            goto LABEL_100;
          }
        }
        else if (v103)
        {
LABEL_99:
          _StringGuts.grow(_:)(v96);
LABEL_100:
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v171 = xmmword_18162ACA0;
          uint64_t v126 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v171, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v126, v127, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v173;
        }
        uint64_t v122 = _StringGuts.nativeCapacity.getter(v58, v59);
        if (v123) {
          uint64_t v124 = 0;
        }
        else {
          uint64_t v124 = v122;
        }
        if (v124 + 0x4000000000000000 >= 0)
        {
          uint64_t v125 = 2 * v124;
          if (v125 > v96) {
            uint64_t v96 = v125;
          }
          goto LABEL_99;
        }
        __break(1u);
        goto LABEL_117;
      }
    }
    else if (v96 > 15)
    {
      goto LABEL_64;
    }
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    if ((v59 & 0x2000000000000000) == 0)
    {
      if ((v59 & 0x1000000000000000) != 0)
      {
        uint64_t v58 = _StringGuts._foreignConvertedToSmall()(v58, v59);
        unint64_t v54 = v136;
      }
      else
      {
        if ((v58 & 0x1000000000000000) != 0)
        {
          uint64_t v132 = (unsigned __int8 *)((v59 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          uint64_t v132 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v58, v59);
          unint64_t v54 = v137;
        }
        swift_bridgeObjectRetain(v59);
        closure #1 in _StringGuts._convertedToSmall()(v132, v54, &v171);
        swift_bridgeObjectRelease(v59);
        unint64_t v54 = *((void *)&v171 + 1);
        uint64_t v58 = v171;
      }
      goto LABEL_77;
    }
LABEL_76:
    unint64_t v54 = v59;
LABEL_77:
    v104._rawBits = 1;
    v105._rawBits = 65537;
    v106._rawBits = _StringGuts.validateScalarRange(_:)(v104, v105, 0x5DuLL, 0xE100000000000000);
    if (v106._rawBits < 0x10000) {
      v106._rawBits |= 3;
    }
    uint64_t v69 = specialized String.init(_:)(v106, v107, 0x5DuLL, 0xE100000000000000);
    uint64_t v96 = v108;
    swift_bridgeObjectRelease(0xE100000000000000);
    if ((v96 & 0x2000000000000000) == 0) {
      goto LABEL_108;
    }
    swift_bridgeObjectRelease(v96);
LABEL_81:
    uint64_t v109 = HIBYTE(v54) & 0xF;
    uint64_t v110 = HIBYTE(v96) & 0xF;
    if ((unint64_t)(v110 + v109) <= 0xF)
    {
      if (v110)
      {
        char v111 = 0;
        unint64_t v112 = 0;
        do
        {
          unint64_t v113 = v109 + v112;
          unint64_t v114 = v112 + 1;
          if (v112 >= 8) {
            unint64_t v115 = v96;
          }
          else {
            unint64_t v115 = v69;
          }
          unint64_t v116 = v115 >> (v111 & 0x38);
          char v117 = (8 * v109 + v111) & 0x38;
          uint64_t v118 = (-255 << v117) - 1;
          unint64_t v119 = (unint64_t)v116 << v117;
          unint64_t v120 = v119 | v118 & v54;
          unint64_t v121 = v119 | v118 & v58;
          if (v113 < 8) {
            uint64_t v58 = v121;
          }
          else {
            unint64_t v54 = v120;
          }
          v111 += 8;
          unint64_t v112 = v114;
        }
        while (v110 != v114);
      }
      swift_bridgeObjectRelease(v59);
      swift_bridgeObjectRelease(0xE100000000000000);
      return v58;
    }
LABEL_117:
    unint64_t v133 = 266;
    goto LABEL_119;
  }
  if ((unint64_t)v69 < 8) {
    uint64_t v58 = (93 << (8 * (HIBYTE(v174) & 7u))) | ((-255 << (8 * (HIBYTE(v174) & 7u))) - 1) & v173;
  }
  swift_bridgeObjectRelease(v174);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v58;
}

uint64_t static DiscontiguousSlice.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((int *)type metadata accessor for DiscontiguousSlice.Index(0, a3, (uint64_t)a4, v9) + 9);
  uint64_t v11 = a1 + v10;
  uint64_t v12 = a2 + v10;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v11, v12, AssociatedTypeWitness) & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance DiscontiguousSlice<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static DiscontiguousSlice.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(int ***)(a3 + 24));
}

uint64_t DiscontiguousSlice.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  return v5(a1, AssociatedTypeWitness, a3);
}

Swift::Int DiscontiguousSlice.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = *(void (**)(void *, const char *, uint64_t))(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v3(v6, AssociatedTypeWitness, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> DiscontiguousSlice<A>.Index(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> DiscontiguousSlice<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DiscontiguousSlice.Index<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> DiscontiguousSlice<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 - 8);
  v5[0] = 0;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  void v5[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v5[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v6 = 0u;
  long long v7 = 0u;
  DiscontiguousSlice.Index<>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

uint64_t static DiscontiguousSlice.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((int *)type metadata accessor for DiscontiguousSlice.Index(0, a3, (uint64_t)a4, v9) + 9);
  uint64_t v11 = a1 + v10;
  uint64_t v12 = a2 + v10;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 16))(v11, v12, AssociatedTypeWitness, AssociatedConformanceWitness) & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance DiscontiguousSlice<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static DiscontiguousSlice.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(int ***)(a3 + 24));
}

uint64_t DiscontiguousSlice.Index.description.getter(uint64_t a1)
{
  uint64_t countAndFlagsBits = a1;
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  Swift::Int v3 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v5 = (uint64_t)&v258 - v4;
  uint64_t v6 = specialized static String._createEmpty(withInitialCapacity:)(27);
  uint64_t v8 = v6;
  unint64_t object = v7;
  v263._uint64_t countAndFlagsBits = v6;
  v263._unint64_t object = (void *)v7;
  unint64_t v10 = HIBYTE(v7) & 0xF;
  uint64_t v11 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000) != 0) {
    uint64_t v12 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v12 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v6 & ~v7 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v263._uint64_t countAndFlagsBits = 0x203A657361623CLL;
    v263._unint64_t object = (void *)0xE700000000000000;
    goto LABEL_78;
  }
  if ((v7 & 0x2000000000000000) == 0 || v10 > 8)
  {
    swift_bridgeObjectRetain_n(0xE700000000000000, 6);
    if ((object & 0x1000000000000000) == 0)
    {
      Swift::Int v18 = v12 + 7;
      if (!__OFADD__(v12, 7)) {
        goto LABEL_13;
      }
      goto LABEL_303;
    }
    goto LABEL_301;
  }
  uint64_t v13 = 8 * HIBYTE(v7);
  uint64_t v14 = (-255 << (v13 & 0x38)) - 1;
  uint64_t v15 = 60 << (v13 & 0x38);
  if (v10 >= 8)
  {
    unint64_t v17 = v15 | v14 & v7;
    char v16 = 8;
    goto LABEL_32;
  }
  uint64_t v8 = v15 | v14 & v6;
  if (v10 == 7)
  {
    char v16 = 0;
    unint64_t v17 = v7;
LABEL_32:
    uint64_t v26 = (98 << v16) | ((-255 << v16) - 1) & v17;
    char v27 = v10 + 2;
LABEL_33:
    uint64_t v28 = (97 << (8 * (v27 & 7u))) | ((-255 << (8 * (v27 & 7u))) - 1) & v26;
    char v29 = v10 + 3;
LABEL_34:
    uint64_t v30 = (115 << (8 * (v29 & 7u))) | ((-255 << (8 * (v29 & 7u))) - 1) & v28;
    char v31 = v10 + 4;
LABEL_35:
    uint64_t v32 = (101 << (8 * (v31 & 7u))) | ((-255 << (8 * (v31 & 7u))) - 1) & v30;
    char v33 = v10 + 5;
LABEL_36:
    uint64_t v34 = (58 << (8 * (v33 & 7u))) | ((-255 << (8 * (v33 & 7u))) - 1) & v32;
    char v35 = v10 + 6;
LABEL_37:
    uint64_t v36 = (32 << (8 * (v35 & 7u))) | ((-255 << (8 * (v35 & 7u))) - 1) & v34;
    goto LABEL_38;
  }
  uint64_t v8 = (98 << ((v13 + 8) & 0x38)) | ((-255 << ((v13 + 8) & 0x38)) - 1) & v8;
  if (v10 >= 6)
  {
    char v27 = 8;
    uint64_t v26 = v7;
    goto LABEL_33;
  }
  uint64_t v8 = (97 << ((v13 + 16) & 0x38)) | ((-255 << ((v13 + 16) & 0x38)) - 1) & v8;
  if (v10 == 5)
  {
    char v29 = 8;
    uint64_t v28 = v7;
    goto LABEL_34;
  }
  uint64_t v8 = (115 << ((v13 + 24) & 0x38)) | ((-255 << ((v13 + 24) & 0x38)) - 1) & v8;
  if (v10 >= 4)
  {
    char v31 = 8;
    uint64_t v30 = v7;
    goto LABEL_35;
  }
  uint64_t v8 = (101 << ((v13 + 32) & 0x38)) | ((-255 << ((v13 + 32) & 0x38)) - 1) & v8;
  if (v10 == 3)
  {
    char v33 = 8;
    uint64_t v32 = v7;
    goto LABEL_36;
  }
  uint64_t v8 = (58 << ((v13 + 40) & 0x38)) | ((-255 << ((v13 + 40) & 0x38)) - 1) & v8;
  if (v10 >= 2)
  {
    char v35 = 8;
    uint64_t v34 = v7;
    goto LABEL_37;
  }
  uint64_t v8 = (32 << ((v13 + 48) & 0x38)) | ((-255 << ((v13 + 48) & 0x38)) - 1) & v8;
  uint64_t v36 = v7;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE700000000000000);
  unint64_t v37 = 0xA000000000000000;
  if (!(v8 & 0x8080808080808080 | v36 & 0x80808080808080)) {
    unint64_t v37 = 0xE000000000000000;
  }
  uint64_t v38 = (void *)((v37 & 0xFF00000000000000 | (v10 << 56) | v36 & 0xFFFFFFFFFFFFFFLL) + 0x700000000000000);
LABEL_77:
  v263._uint64_t countAndFlagsBits = v8;
  v263._unint64_t object = v38;
LABEL_78:
  (*(void (**)(uint64_t, char *, uint64_t))(v3 + 16))(v5, (char *)v261 + *(int *)(countAndFlagsBits + 36), AssociatedTypeWitness);
  *(void *)&long long v262 = 0;
  *((void *)&v262 + 1) = 0xE000000000000000;
  _debugPrint_unlocked<A, B>(_:_:)(v5, (uint64_t)&v262, (Class *)AssociatedTypeWitness, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v5, AssociatedTypeWitness);
  uint64_t AssociatedTypeWitness = *((void *)&v262 + 1);
  uint64_t v5 = v262;
  uint64_t countAndFlagsBits = v263._countAndFlagsBits;
  unint64_t object = (unint64_t)v263._object;
  unint64_t v69 = ((unint64_t)v263._object >> 56) & 0xF;
  unint64_t v51 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v263._object & 0x2000000000000000) != 0) {
    unint64_t v70 = ((unint64_t)v263._object >> 56) & 0xF;
  }
  else {
    unint64_t v70 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v70 && (v263._countAndFlagsBits & ~(uint64_t)v263._object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v263._object);
    v263._uint64_t countAndFlagsBits = v5;
    v263._unint64_t object = (void *)AssociatedTypeWitness;
    goto LABEL_163;
  }
  unint64_t v53 = *((void *)&v262 + 1) & 0x2000000000000000;
  unint64_t v46 = HIBYTE(*((void *)&v262 + 1)) & 0xFLL;
  if (((uint64_t)v263._object & 0x2000000000000000) != 0 && v53)
  {
    unint64_t v71 = v69 + v46;
    if (v69 + v46 <= 0xF)
    {
      if (v46)
      {
        char v107 = 0;
        unint64_t v108 = 0;
        unint64_t v109 = (unint64_t)v263._object;
        do
        {
          unint64_t v110 = v69 + v108;
          unint64_t v111 = v108 + 1;
          if (v108 >= 8) {
            unint64_t v112 = *((void *)&v262 + 1);
          }
          else {
            unint64_t v112 = v262;
          }
          unint64_t v113 = v112 >> (v107 & 0x38);
          char v114 = (8 * v69 + v107) & 0x38;
          uint64_t v115 = (-255 << v114) - 1;
          unint64_t v116 = (unint64_t)v113 << v114;
          unint64_t v117 = v116 | v115 & v109;
          unint64_t v118 = v116 | v115 & countAndFlagsBits;
          if (v110 < 8) {
            uint64_t countAndFlagsBits = v118;
          }
          else {
            unint64_t v109 = v117;
          }
          v107 += 8;
          unint64_t v108 = v111;
        }
        while (v46 != v111);
      }
      else
      {
        unint64_t v109 = (unint64_t)v263._object;
      }
      swift_bridgeObjectRelease((uint64_t)v263._object);
      swift_bridgeObjectRelease(AssociatedTypeWitness);
      unint64_t v124 = 0xA000000000000000;
      if (!(countAndFlagsBits & 0x8080808080808080 | v109 & 0x80808080808080)) {
        unint64_t v124 = 0xE000000000000000;
      }
      for (unint64_t i = (void *)(v124 & 0xFF00000000000000 | (v71 << 56) | v109 & 0xFFFFFFFFFFFFFFLL);
            ;
            unint64_t i = (void *)(v99 & 0xFF00000000000000 | (v87 << 56) | v11 & 0xFFFFFFFFFFFFFFLL))
      {
        v263._uint64_t countAndFlagsBits = countAndFlagsBits;
        v263._unint64_t object = i;
LABEL_163:
        Swift::String v125 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", rangeOffset: ", 0xFuLL, 1);
        uint64_t countAndFlagsBits = v125._countAndFlagsBits;
        uint64_t AssociatedTypeWitness = (uint64_t)v125._object;
        uint64_t v11 = v263._countAndFlagsBits;
        unint64_t object = (unint64_t)v263._object;
        unint64_t v126 = ((unint64_t)v263._object >> 56) & 0xF;
        unint64_t v127 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (((uint64_t)v263._object & 0x2000000000000000) != 0) {
          unint64_t v127 = ((unint64_t)v263._object >> 56) & 0xF;
        }
        if (!v127 && (v263._countAndFlagsBits & ~(uint64_t)v263._object & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease((uint64_t)v263._object);
          Swift::String v263 = v125;
          goto LABEL_215;
        }
        Swift::Int v3 = (uint64_t)v125._object & 0x2000000000000000;
        uint64_t v5 = ((unint64_t)v125._object >> 56) & 0xF;
        if (((uint64_t)v263._object & 0x2000000000000000) != 0 && v3)
        {
          unint64_t v128 = v126 + v5;
          if (v126 + v5 <= 0xF)
          {
            if (v5)
            {
              char v155 = 0;
              unint64_t v156 = 0;
              unint64_t v157 = (unint64_t)v263._object;
              do
              {
                unint64_t v158 = v126 + v156;
                unint64_t v159 = v156 + 1;
                if (v156 >= 8) {
                  unint64_t v160 = (unint64_t)v125._object;
                }
                else {
                  unint64_t v160 = v125._countAndFlagsBits;
                }
                unint64_t v161 = v160 >> (v155 & 0x38);
                char v162 = (8 * v126 + v155) & 0x38;
                uint64_t v163 = (-255 << v162) - 1;
                unint64_t v164 = (unint64_t)v161 << v162;
                unint64_t v165 = v164 | v163 & v157;
                unint64_t v166 = v164 | v163 & v11;
                if (v158 < 8) {
                  uint64_t v11 = v166;
                }
                else {
                  unint64_t v157 = v165;
                }
                v155 += 8;
                unint64_t v156 = v159;
              }
              while (v5 != v159);
            }
            else
            {
              unint64_t v157 = (unint64_t)v263._object;
            }
            swift_bridgeObjectRelease((uint64_t)v263._object);
            swift_bridgeObjectRelease((uint64_t)v125._object);
            unint64_t v171 = 0xA000000000000000;
            if (!(v11 & 0x8080808080808080 | v157 & 0x80808080808080)) {
              unint64_t v171 = 0xE000000000000000;
            }
            v263._uint64_t countAndFlagsBits = v11;
            v263._unint64_t object = (void *)(v171 & 0xFF00000000000000 | (v128 << 56) | v157 & 0xFFFFFFFFFFFFFFLL);
            goto LABEL_215;
          }
          Swift::Int v3 = 1;
        }
        uint64_t v8 = v125._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (v3) {
          unint64_t v53 = ((unint64_t)v125._object >> 56) & 0xF;
        }
        else {
          unint64_t v53 = v125._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n((uint64_t)v125._object, 2);
        if (((uint64_t)v125._object & 0x1000000000000000) != 0) {
          goto LABEL_289;
        }
        swift_bridgeObjectRetain_n((uint64_t)v125._object, 4);
        Swift::Int v129 = v53;
        if ((object & 0x1000000000000000) != 0) {
          goto LABEL_292;
        }
LABEL_176:
        if ((object & 0x2000000000000000) != 0)
        {
          uint64_t v131 = HIBYTE(object) & 0xF;
          uint64_t v130 = v131 + v129;
          if (!__OFADD__(v131, v129)) {
            goto LABEL_181;
          }
        }
        else
        {
          uint64_t v130 = (v11 & 0xFFFFFFFFFFFFLL) + v129;
          if (!__OFADD__(v11 & 0xFFFFFFFFFFFFLL, v129)) {
            goto LABEL_181;
          }
        }
LABEL_294:
        __break(1u);
LABEL_295:
        swift_bridgeObjectRetain_n(v130, 5);
        v235._rawBits = 1;
        v236._rawBits = (v8 << 16) | 1;
        v237._rawBits = _StringGuts.validateScalarRange(_:)(v235, v236, AssociatedTypeWitness, v130);
        if (v237._rawBits < 0x10000) {
          v237._rawBits |= 3;
        }
        Swift::Int v176 = specialized Collection.count.getter(v237, v238, AssociatedTypeWitness, v130);
        swift_bridgeObjectRelease(v130);
        if ((v5 & 0x1000000000000000) == 0) {
          goto LABEL_229;
        }
LABEL_298:
        Swift::Int v239 = String.UTF8View._foreignCount()();
        int64_t v177 = v239 + v176;
        if (!__OFADD__(v239, v176)) {
          goto LABEL_230;
        }
LABEL_300:
        __break(1u);
LABEL_301:
        Swift::Int v240 = String.UTF8View._foreignCount()();
        Swift::Int v18 = v240 + 7;
        if (!__OFADD__(v240, 7))
        {
LABEL_13:
          unint64_t v19 = v8 & ~object;
          if ((v19 & 0x2000000000000000) == 0
            || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v18 > 15) {
              goto LABEL_21;
            }
            if ((object & 0x2000000000000000) == 0) {
              goto LABEL_51;
            }
            goto LABEL_59;
          }
          int64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v8, object);
          if ((v21 & 1) == 0)
          {
            if (v18 > 15) {
              goto LABEL_21;
            }
            if ((object & 0x2000000000000000) == 0)
            {
              if (v20 <= 6)
              {
LABEL_51:
                swift_bridgeObjectRelease_n(0xE700000000000000, 5);
                if ((object & 0x1000000000000000) == 0)
                {
                  if ((v8 & 0x1000000000000000) != 0)
                  {
                    uint64_t v45 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
                  }
                  else
                  {
                    uint64_t v45 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, object);
                    uint64_t v11 = v247;
                  }
                  swift_bridgeObjectRetain(object);
                  closure #1 in _StringGuts._convertedToSmall()(v45, v11, &v262);
                  swift_bridgeObjectRelease(object);
                  unint64_t v46 = *((void *)&v262 + 1);
                  uint64_t v8 = v262;
LABEL_60:
                  v47._rawBits = 1;
                  v48._rawBits = 458753;
                  v49._rawBits = _StringGuts.validateScalarRange(_:)(v47, v48, 0x203A657361623CuLL, 0xE700000000000000);
                  if (v49._rawBits < 0x10000) {
                    v49._rawBits |= 3;
                  }
                  unint64_t v51 = specialized String.init(_:)(v49, v50, 0x203A657361623CuLL, 0xE700000000000000);
                  unint64_t v53 = v52;
                  swift_bridgeObjectRelease(0xE700000000000000);
                  if ((v53 & 0x2000000000000000) != 0)
                  {
                    swift_bridgeObjectRelease(v53);
                    goto LABEL_64;
                  }
LABEL_313:
                  if ((v53 & 0x1000000000000000) != 0)
                  {
                    unint64_t v51 = _StringGuts._foreignConvertedToSmall()(v51, v53);
                    unint64_t v257 = v256;
                    swift_bridgeObjectRelease(v53);
                    unint64_t v53 = v257;
                  }
                  else
                  {
                    if ((v51 & 0x1000000000000000) != 0)
                    {
                      uint64_t v244 = (unsigned __int8 *)((v53 & 0xFFFFFFFFFFFFFFFLL) + 32);
                      uint64_t v245 = v51 & 0xFFFFFFFFFFFFLL;
                    }
                    else
                    {
                      uint64_t v244 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v51, v53);
                    }
                    closure #1 in _StringGuts._convertedToSmall()(v244, v245, &v262);
                    swift_bridgeObjectRelease(v53);
                    unint64_t v53 = *((void *)&v262 + 1);
                    unint64_t v51 = v262;
                  }
LABEL_64:
                  uint64_t v54 = HIBYTE(v46) & 0xF;
                  uint64_t v55 = HIBYTE(v53) & 0xF;
                  uint64_t v56 = v55 + v54;
                  if ((unint64_t)(v55 + v54) <= 0xF)
                  {
                    if (v55)
                    {
                      char v57 = 0;
                      unint64_t v58 = 0;
                      do
                      {
                        unint64_t v59 = v54 + v58;
                        unint64_t v60 = v58 + 1;
                        if (v58 >= 8) {
                          unint64_t v61 = v53;
                        }
                        else {
                          unint64_t v61 = v51;
                        }
                        unint64_t v62 = v61 >> (v57 & 0x38);
                        char v63 = (8 * v54 + v57) & 0x38;
                        uint64_t v64 = (-255 << v63) - 1;
                        unint64_t v65 = (unint64_t)v62 << v63;
                        unint64_t v66 = v65 | v64 & v46;
                        unint64_t v67 = v65 | v64 & v8;
                        if (v59 < 8) {
                          uint64_t v8 = v67;
                        }
                        else {
                          unint64_t v46 = v66;
                        }
                        v57 += 8;
                        unint64_t v58 = v60;
                      }
                      while (v55 != v60);
                    }
                    swift_bridgeObjectRelease(object);
                    swift_bridgeObjectRelease(0xE700000000000000);
                    unint64_t v68 = 0xA000000000000000;
                    if (!(v8 & 0x8080808080808080 | v46 & 0x80808080808080)) {
                      unint64_t v68 = 0xE000000000000000;
                    }
                    uint64_t v38 = (void *)(v68 & 0xFF00000000000000 | (v56 << 56) | v46 & 0xFFFFFFFFFFFFFFLL);
                    goto LABEL_77;
                  }
LABEL_326:
                  unint64_t v251 = 266;
LABEL_328:
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v251, 0);
                }
LABEL_318:
                uint64_t v8 = _StringGuts._foreignConvertedToSmall()(v8, object);
                unint64_t v46 = v246;
                goto LABEL_60;
              }
LABEL_21:
              int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v8, object);
              BOOL v25 = (v23 & 1) == 0 && v22 > 6;
              if ((v19 & 0x2000000000000000) != 0
                && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
              {
                if (v25)
                {
LABEL_49:
                  swift_bridgeObjectRelease_n(0xE700000000000000, 6);
                  long long v262 = xmmword_18162AD40;
                  uint64_t v43 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 7, (uint64_t)&v262, 7);
                  _StringGuts.appendInPlace(_:isASCII:)(v43, v44, 1);
                  swift_bridgeObjectRelease(0xE700000000000000);
                  goto LABEL_78;
                }
LABEL_42:
                uint64_t v39 = _StringGuts.nativeCapacity.getter(v8, object);
                if (v40) {
                  uint64_t v41 = 0;
                }
                else {
                  uint64_t v41 = v39;
                }
                if (v41 + 0x4000000000000000 < 0)
                {
                  __break(1u);
                  goto LABEL_318;
                }
                uint64_t v42 = 2 * v41;
                if (v42 > v18) {
                  Swift::Int v18 = v42;
                }
              }
              else if (!v25)
              {
                goto LABEL_42;
              }
              _StringGuts.grow(_:)(v18);
              goto LABEL_49;
            }
LABEL_59:
            swift_bridgeObjectRelease_n(0xE700000000000000, 5);
            unint64_t v46 = object;
            goto LABEL_60;
          }
LABEL_327:
          unint64_t v251 = 258;
          goto LABEL_328;
        }
LABEL_303:
        __break(1u);
LABEL_304:
        if ((v5 & 0x1000000000000000) != 0)
        {
          uint64_t v8 = _StringGuts._foreignConvertedToSmall()(v8, v5);
          uint64_t v253 = v252;
          swift_bridgeObjectRelease(v5);
          uint64_t v5 = v253;
        }
        else
        {
          if ((v8 & 0x1000000000000000) != 0)
          {
            int64_t v241 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v242 = v8 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            int64_t v241 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, v5);
          }
          closure #1 in _StringGuts._convertedToSmall()(v241, v242, &v262);
          swift_bridgeObjectRelease(v5);
          uint64_t v5 = *((void *)&v262 + 1);
          uint64_t v8 = v262;
        }
LABEL_116:
        uint64_t v85 = HIBYTE(v11) & 0xF;
        uint64_t v86 = HIBYTE(v5) & 0xF;
        uint64_t v87 = v86 + v85;
        if ((unint64_t)(v86 + v85) > 0xF) {
          goto LABEL_326;
        }
        if (v86)
        {
          char v88 = 0;
          unint64_t v89 = 0;
          do
          {
            unint64_t v90 = v85 + v89;
            unint64_t v91 = v89 + 1;
            if (v89 >= 8) {
              unint64_t v92 = v5;
            }
            else {
              unint64_t v92 = v8;
            }
            unint64_t v93 = v92 >> (v88 & 0x38);
            char v94 = (8 * v85 + v88) & 0x38;
            uint64_t v95 = (-255 << v94) - 1;
            unint64_t v96 = (unint64_t)v93 << v94;
            unint64_t v97 = v96 | v95 & v11;
            unint64_t v98 = v96 | v95 & countAndFlagsBits;
            if (v90 < 8) {
              uint64_t countAndFlagsBits = v98;
            }
            else {
              uint64_t v11 = v97;
            }
            v88 += 8;
            unint64_t v89 = v91;
          }
          while (v86 != v91);
        }
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        unint64_t v99 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v11 & 0x80808080808080)) {
          unint64_t v99 = 0xE000000000000000;
        }
      }
    }
    unint64_t v53 = 1;
  }
  uint64_t v259 = v262 & 0xFFFFFFFFFFFFLL;
  if (v53) {
    uint64_t v8 = HIBYTE(*((void *)&v262 + 1)) & 0xFLL;
  }
  else {
    uint64_t v8 = v262 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v262 + 1), 2);
  uint64_t v260 = v8;
  if ((AssociatedTypeWitness & 0x1000000000000000) == 0)
  {
    swift_bridgeObjectRetain_n(AssociatedTypeWitness, 4);
    if ((object & 0x1000000000000000) == 0) {
      goto LABEL_92;
    }
LABEL_286:
    Swift::Int v229 = String.UTF8View._foreignCount()();
    Swift::Int v3 = v229 + v8;
    if (!__OFADD__(v229, v8)) {
      goto LABEL_93;
    }
    goto LABEL_288;
  }
  swift_bridgeObjectRetain_n(AssociatedTypeWitness, 5);
  v225._rawBits = 1;
  v226._rawBits = (v8 << 16) | 1;
  v227._rawBits = _StringGuts.validateScalarRange(_:)(v225, v226, v5, AssociatedTypeWitness);
  if (v227._rawBits < 0x10000) {
    v227._rawBits |= 3;
  }
  uint64_t v8 = specialized Collection.count.getter(v227, v228, v5, AssociatedTypeWitness);
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  if ((object & 0x1000000000000000) != 0) {
    goto LABEL_286;
  }
LABEL_92:
  BOOL v72 = __OFADD__(v70, v8);
  Swift::Int v3 = v70 + v8;
  if (!v72)
  {
LABEL_93:
    unint64_t v73 = countAndFlagsBits & ~object;
    if ((v73 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v74 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
      if (v75) {
        goto LABEL_327;
      }
      if (v3 <= 15)
      {
        if ((object & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease_n(AssociatedTypeWitness, 5);
          uint64_t v11 = object;
          uint64_t v79 = v260;
          goto LABEL_112;
        }
        if (v74 >= v8) {
          goto LABEL_99;
        }
LABEL_110:
        swift_bridgeObjectRelease_n(AssociatedTypeWitness, 5);
        uint64_t v79 = v260;
        if ((object & 0x2000000000000000) != 0)
        {
          uint64_t v11 = object;
        }
        else if ((object & 0x1000000000000000) != 0)
        {
          uint64_t countAndFlagsBits = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
          uint64_t v11 = v254;
        }
        else
        {
          if ((countAndFlagsBits & 0x1000000000000000) != 0)
          {
            uint64_t v243 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            uint64_t v243 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
            unint64_t v51 = v255;
          }
          swift_bridgeObjectRetain(object);
          closure #1 in _StringGuts._convertedToSmall()(v243, v51, &v262);
          swift_bridgeObjectRelease(object);
          uint64_t v11 = *((void *)&v262 + 1);
          uint64_t countAndFlagsBits = v262;
        }
LABEL_112:
        v80._rawBits = (v79 << 16) | 1;
        v81._rawBits = 1;
        v82._rawBits = _StringGuts.validateScalarRange(_:)(v81, v80, v5, AssociatedTypeWitness);
        if (v82._rawBits < 0x10000) {
          v82._rawBits |= 3;
        }
        uint64_t v8 = specialized String.init(_:)(v82, v83, v5, AssociatedTypeWitness);
        uint64_t v5 = v84;
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        if ((v5 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v5);
          goto LABEL_116;
        }
        goto LABEL_304;
      }
    }
    else if (v3 <= 15)
    {
      goto LABEL_110;
    }
LABEL_99:
    int64_t v76 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
    uint64_t v8 = (v77 & 1) == 0 && v76 >= v8;
    if ((v73 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v8) {
        goto LABEL_137;
      }
    }
    else if (v8)
    {
LABEL_136:
      _StringGuts.grow(_:)(v3);
LABEL_137:
      swift_bridgeObjectRelease_n(AssociatedTypeWitness, 4);
      if ((AssociatedTypeWitness & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        _StringGuts._foreignAppendInPlace(_:)(v5, AssociatedTypeWitness, 0, v260);
LABEL_155:
        swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2);
        goto LABEL_163;
      }
      if (v53)
      {
        swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2);
        *(void *)&long long v262 = v5;
        *((void *)&v262 + 1) = AssociatedTypeWitness & 0xFFFFFFFFFFFFFFLL;
        Swift::String::Index v105 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(AssociatedTypeWitness) & 0xF, (uint64_t)&v262, HIBYTE(AssociatedTypeWitness) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v105, v106, (AssociatedTypeWitness & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        goto LABEL_163;
      }
      if ((v5 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        id v119 = (id)((AssociatedTypeWitness & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v120 = v259;
        uint64_t v121 = v259;
LABEL_154:
        uint64_t v122 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v120, (uint64_t)v119, v121);
        _StringGuts.appendInPlace(_:isASCII:)(v122, v123, v5 < 0);
        goto LABEL_155;
      }
      id v119 = _StringObject.sharedUTF8.getter(v5, AssociatedTypeWitness);
      uint64_t v121 = v250;
      swift_bridgeObjectRelease(AssociatedTypeWitness);
      if (v121 >= v259)
      {
        uint64_t v120 = v259;
        goto LABEL_154;
      }
LABEL_325:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    uint64_t v101 = _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
    if (v102) {
      uint64_t v103 = 0;
    }
    else {
      uint64_t v103 = v101;
    }
    if (v103 + 0x4000000000000000 < 0)
    {
      __break(1u);
      goto LABEL_313;
    }
    uint64_t v104 = 2 * v103;
    if (v104 > v3) {
      Swift::Int v3 = v104;
    }
    goto LABEL_136;
  }
LABEL_288:
  __break(1u);
LABEL_289:
  swift_bridgeObjectRetain_n(AssociatedTypeWitness, 5);
  v230._rawBits = 1;
  v231._rawBits = (v53 << 16) | 1;
  v232._rawBits = _StringGuts.validateScalarRange(_:)(v230, v231, countAndFlagsBits, AssociatedTypeWitness);
  if (v232._rawBits < 0x10000) {
    v232._rawBits |= 3;
  }
  Swift::Int v129 = specialized Collection.count.getter(v232, v233, countAndFlagsBits, AssociatedTypeWitness);
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  uint64_t v11 = v263._countAndFlagsBits;
  unint64_t object = (unint64_t)v263._object;
  if (((uint64_t)v263._object & 0x1000000000000000) == 0) {
    goto LABEL_176;
  }
LABEL_292:
  Swift::Int v234 = String.UTF8View._foreignCount()();
  uint64_t v130 = v234 + v129;
  if (__OFADD__(v234, v129)) {
    goto LABEL_294;
  }
LABEL_181:
  if ((v11 & ~object & 0x2000000000000000) != 0
    && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v132 = _StringGuts.nativeUnusedCapacity.getter(v11, object);
    if (v133) {
      goto LABEL_327;
    }
    if (v130 > 15 || (object & 0x2000000000000000) == 0 && v132 >= v129)
    {
LABEL_187:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v130, v129);
      swift_bridgeObjectRelease_n(AssociatedTypeWitness, 4);
      if ((AssociatedTypeWitness & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, AssociatedTypeWitness, 0, v53);
      }
      else
      {
        if (v3)
        {
          swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2);
          *(void *)&long long v262 = countAndFlagsBits;
          *((void *)&v262 + 1) = AssociatedTypeWitness & 0xFFFFFFFFFFFFFFLL;
          uint64_t v134 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v5, (uint64_t)&v262, v5);
          _StringGuts.appendInPlace(_:isASCII:)(v134, v135, (AssociatedTypeWitness & 0x4000000000000000) != 0);
          swift_bridgeObjectRelease(AssociatedTypeWitness);
          goto LABEL_215;
        }
        if ((countAndFlagsBits & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRelease(AssociatedTypeWitness);
          id v167 = (id)((AssociatedTypeWitness & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v168 = v8;
        }
        else
        {
          id v167 = _StringObject.sharedUTF8.getter(countAndFlagsBits, AssociatedTypeWitness);
          uint64_t v168 = v248;
          swift_bridgeObjectRelease(AssociatedTypeWitness);
          if (v168 < v8) {
            goto LABEL_325;
          }
        }
        uint64_t v169 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v8, (uint64_t)v167, v168);
        _StringGuts.appendInPlace(_:isASCII:)(v169, v170, countAndFlagsBits < 0);
      }
      swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2);
      goto LABEL_215;
    }
  }
  else if (v130 > 15)
  {
    goto LABEL_187;
  }
  swift_bridgeObjectRelease_n(AssociatedTypeWitness, 5);
  unint64_t v136 = v263._countAndFlagsBits;
  swift_bridgeObjectRetain(object);
  unint64_t v137 = _StringGuts._convertedToSmall()(v136, object);
  unint64_t v139 = v138;
  swift_bridgeObjectRelease(object);
  v140._rawBits = (v53 << 16) | 1;
  v141._rawBits = 1;
  v142._rawBits = _StringGuts.validateScalarRange(_:)(v141, v140, countAndFlagsBits, AssociatedTypeWitness);
  if (v142._rawBits < 0x10000) {
    v142._rawBits |= 3;
  }
  unint64_t v144 = specialized String.init(_:)(v142, v143, countAndFlagsBits, AssociatedTypeWitness);
  unint64_t v146 = v145;
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  unint64_t v147 = _StringGuts._convertedToSmall()(v144, v146);
  unint64_t v149 = v148;
  swift_bridgeObjectRelease(v146);
  unint64_t v150 = specialized _SmallString.init(_:appending:)(v137, v139, v147, v149);
  if (v152) {
    goto LABEL_326;
  }
  uint64_t v153 = v150;
  uint64_t v154 = v151;
  swift_bridgeObjectRelease(object);
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  v263._uint64_t countAndFlagsBits = v153;
  v263._unint64_t object = v154;
LABEL_215:
  unint64_t v172 = _int64ToString(_:radix:uppercase:)(*v261, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  uint64_t AssociatedTypeWitness = v172;
  uint64_t v130 = v173;
  unint64_t object = v263._countAndFlagsBits;
  uint64_t v5 = (uint64_t)v263._object;
  unint64_t v174 = ((unint64_t)v263._object >> 56) & 0xF;
  if (((uint64_t)v263._object & 0x2000000000000000) != 0) {
    unint64_t v53 = ((unint64_t)v263._object >> 56) & 0xF;
  }
  else {
    unint64_t v53 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v53 && (v263._countAndFlagsBits & ~(uint64_t)v263._object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v263._object);
    v263._uint64_t countAndFlagsBits = AssociatedTypeWitness;
    v263._unint64_t object = (void *)v130;
    goto LABEL_266;
  }
  Swift::Int v3 = v173 & 0x2000000000000000;
  uint64_t countAndFlagsBits = HIBYTE(v173) & 0xF;
  if (((uint64_t)v263._object & 0x2000000000000000) != 0 && v3)
  {
    unint64_t v175 = v174 + countAndFlagsBits;
    if (v174 + countAndFlagsBits <= 0xF)
    {
      if (countAndFlagsBits)
      {
        char v202 = 0;
        unint64_t v203 = 0;
        unint64_t v204 = (unint64_t)v263._object;
        do
        {
          unint64_t v205 = v174 + v203;
          unint64_t v206 = v203 + 1;
          if (v203 >= 8) {
            unint64_t v207 = v173;
          }
          else {
            unint64_t v207 = v172;
          }
          unint64_t v208 = v207 >> (v202 & 0x38);
          char v209 = (8 * v174 + v202) & 0x38;
          uint64_t v210 = (-255 << v209) - 1;
          unint64_t v211 = (unint64_t)v208 << v209;
          unint64_t v212 = v211 | v210 & v204;
          unint64_t v213 = v211 | v210 & object;
          if (v205 < 8) {
            unint64_t object = v213;
          }
          else {
            unint64_t v204 = v212;
          }
          v202 += 8;
          unint64_t v203 = v206;
        }
        while (countAndFlagsBits != v206);
      }
      else
      {
        unint64_t v204 = (unint64_t)v263._object;
      }
      swift_bridgeObjectRelease((uint64_t)v263._object);
      swift_bridgeObjectRelease(v130);
      unint64_t v218 = 0xA000000000000000;
      if (!(object & 0x8080808080808080 | v204 & 0x80808080808080)) {
        unint64_t v218 = 0xE000000000000000;
      }
      v263._uint64_t countAndFlagsBits = object;
      v263._unint64_t object = (void *)(v218 & 0xFF00000000000000 | (v175 << 56) | v204 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_266;
    }
    Swift::Int v3 = 1;
  }
  uint64_t v11 = v172 & 0xFFFFFFFFFFFFLL;
  if (v3) {
    uint64_t v8 = HIBYTE(v173) & 0xF;
  }
  else {
    uint64_t v8 = v172 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v173, 2);
  if ((v130 & 0x1000000000000000) != 0) {
    goto LABEL_295;
  }
  swift_bridgeObjectRetain_n(v130, 4);
  Swift::Int v176 = v8;
  if ((v5 & 0x1000000000000000) != 0) {
    goto LABEL_298;
  }
LABEL_229:
  BOOL v72 = __OFADD__(v53, v176);
  int64_t v177 = v53 + v176;
  if (v72) {
    goto LABEL_300;
  }
LABEL_230:
  if ((object & ~v5 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v178 = (unint64_t)v263._object;
    int64_t v179 = _StringGuts.nativeUnusedCapacity.getter(v263._countAndFlagsBits, (uint64_t)v263._object);
    if (v180) {
      goto LABEL_327;
    }
    if (v177 <= 15 && ((v178 & 0x2000000000000000) != 0 || v179 < v176)) {
      goto LABEL_242;
    }
  }
  else if (v177 <= 15)
  {
    unint64_t v178 = (unint64_t)v263._object;
LABEL_242:
    swift_bridgeObjectRelease_n(v130, 5);
    unint64_t v183 = v263._countAndFlagsBits;
    swift_bridgeObjectRetain(v178);
    unint64_t v184 = _StringGuts._convertedToSmall()(v183, v178);
    unint64_t v186 = v185;
    swift_bridgeObjectRelease(v178);
    v187._rawBits = (v8 << 16) | 1;
    v188._rawBits = 1;
    v189._rawBits = _StringGuts.validateScalarRange(_:)(v188, v187, AssociatedTypeWitness, v130);
    if (v189._rawBits < 0x10000) {
      v189._rawBits |= 3;
    }
    unint64_t v191 = specialized String.init(_:)(v189, v190, AssociatedTypeWitness, v130);
    unint64_t v193 = v192;
    swift_bridgeObjectRelease(v130);
    unint64_t v194 = _StringGuts._convertedToSmall()(v191, v193);
    unint64_t v196 = v195;
    swift_bridgeObjectRelease(v193);
    unint64_t v197 = specialized _SmallString.init(_:appending:)(v184, v186, v194, v196);
    if (v199) {
      goto LABEL_326;
    }
    uint64_t v200 = v197;
    uint64_t v201 = v198;
    swift_bridgeObjectRelease(v178);
    swift_bridgeObjectRelease(v130);
    v263._uint64_t countAndFlagsBits = v200;
    v263._unint64_t object = v201;
    goto LABEL_266;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v177, v176);
  swift_bridgeObjectRelease_n(v130, 4);
  if ((v130 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v130);
    _StringGuts._foreignAppendInPlace(_:)(AssociatedTypeWitness, v130, 0, v8);
  }
  else
  {
    if (v3)
    {
      swift_bridgeObjectRelease_n(v130, 2);
      *(void *)&long long v262 = AssociatedTypeWitness;
      *((void *)&v262 + 1) = v130 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v181 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, countAndFlagsBits, (uint64_t)&v262, countAndFlagsBits);
      _StringGuts.appendInPlace(_:isASCII:)(v181, v182, (v130 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v130);
      goto LABEL_266;
    }
    if ((AssociatedTypeWitness & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v130);
      id v214 = (id)((v130 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v215 = v11;
    }
    else
    {
      id v214 = _StringObject.sharedUTF8.getter(AssociatedTypeWitness, v130);
      uint64_t v215 = v249;
      swift_bridgeObjectRelease(v130);
      if (v215 < v11) {
        goto LABEL_325;
      }
    }
    uint64_t v216 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v11, (uint64_t)v214, v215);
    _StringGuts.appendInPlace(_:isASCII:)(v216, v217, AssociatedTypeWitness < 0);
  }
  swift_bridgeObjectRelease_n(v130, 2);
LABEL_266:
  v219 = v263._object;
  unint64_t v220 = ((unint64_t)v263._object >> 56) & 0xF;
  if (((uint64_t)v263._object & 0x2000000000000000) == 0) {
    unint64_t v220 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v220 || (v263._countAndFlagsBits & ~(uint64_t)v263._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v263._object & 0x2000000000000000) == 0
      || (unint64_t v221 = specialized _SmallString.init(_:appending:)(v263._countAndFlagsBits, (unint64_t)v263._object, 0x3EuLL, 0xE100000000000000), (v222 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(62, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v263._countAndFlagsBits;
    }
    else
    {
      unint64_t v223 = v221;
      swift_bridgeObjectRelease((uint64_t)v219);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v263._object);
    return 62;
  }
  return v223;
}

uint64_t DiscontiguousSlice._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for DiscontiguousSlice.Index(255, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)v6, v7, v8);
  uint64_t v10 = (uint64_t)*(v9 - 1);
  MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v24 - v11;
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)v9, v13, v14);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v19 = (char *)&v24 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  char v21 = (char *)&v24 - v20;
  DiscontiguousSlice._customIndexOfEquatableElement(_:)(a1, a2, (uint64_t *)((char *)&v24 - v20));
  (*(void (**)(char *, char *, Class *))(v16 + 32))(v19, v21, v15);
  if ((*(unsigned int (**)(char *, uint64_t, Class *))(v10 + 48))(v19, 1, v9) == 1) {
    return 2;
  }
  (*(void (**)(char *, char *, Class *))(v10 + 32))(v12, v19, v9);
  BOOL v22 = (*((unsigned int (**)(char *, uint64_t, Class *))*(v6 - 1) + 6))(v12, 1, v6) != 1;
  (*(void (**)(char *, Class *))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t DiscontiguousSlice._customIndexOfEquatableElement(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v128 = a1;
  Swift::String::Index v105 = a3;
  uint64_t v138 = a2;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v101 = (char *)&v101 - v8;
  unint64_t v127 = swift_getAssociatedTypeWitness(0, v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v121 = (void (**)(char *, const char *))*((void *)v127 - 1);
  MEMORY[0x1F4188790](v127);
  unint64_t v126 = (char *)&v101 - v9;
  uint64_t v12 = type metadata accessor for Optional(255, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v104 = type metadata accessor for Optional(0, (uint64_t)v12, v13, v14);
  uint64_t v114 = (uint64_t)*(v104 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v104);
  uint64_t v115 = (void (**)(char *, Class *))*(v12 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  id v119 = (char *)&v101 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  unint64_t v118 = (char *)&v101 - v18;
  uint64_t v134 = v4;
  uint64_t v19 = v4;
  uint64_t v21 = v20;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v19, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v136 = AssociatedTypeWitness;
  uint64_t v113 = AssociatedConformanceWitness;
  uint64_t v24 = type metadata accessor for Range(255, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v23);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)&type metadata for Int, (uint64_t)v24, "offset element ", 0);
  uint64_t v26 = *(TupleTypeMetadata2 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v112 = (char *)&v101 - v28;
  uint64_t v29 = (uint64_t)*(v24 - 1);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  unint64_t v124 = (char *)&v101 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  unint64_t v110 = (char *)&v101 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  unint64_t v109 = (char *)&v101 - v35;
  MEMORY[0x1F4188790](v34);
  unint64_t v108 = (char *)&v101 - v36;
  char v133 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v37, v38);
  uint64_t v39 = MEMORY[0x1F4188790](v133);
  unint64_t v137 = (char **)((char *)&v101 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v39);
  uint64_t v42 = (uint64_t *)((char *)&v101 - v41);
  uint64_t v43 = *(int *)(v138 + 36);
  uint64_t v129 = v3;
  size_t v44 = *(atomic_ullong **)(v3 + v43);
  char v107 = (char *)&v141;
  uint64_t v106 = v29 + 16;
  unint64_t v141 = 0;
  uint64_t v142 = 0;
  uint64_t v138 = v29 + 32;
  uint64_t v131 = (void (**)(uint64_t *, void *, Class *))(v45 + 32);
  int64_t v132 = (void (**)(void *, uint64_t, uint64_t, uint64_t *))(v26 + 56);
  uint64_t v130 = (unsigned int (**)(uint64_t *, uint64_t, uint64_t *))(v26 + 48);
  Swift::String::Index v140 = v44;
  size_t v135 = v5;
  size_t v123 = v5 + 11;
  uint64_t v111 = v29;
  uint64_t v122 = (void (**)(char *, Class *))(v29 + 8);
  ++v121;
  uint64_t v120 = (unsigned int (**)(uint64_t, uint64_t, Class *))(v115 + 6);
  unint64_t v117 = (void (**)(char *, uint64_t, Class *))(v115 + 4);
  uint64_t v102 = v7;
  unint64_t v116 = (unsigned int (**)(char *, uint64_t, const char *))(v7 + 48);
  ++v115;
  uint64_t v103 = (void (**)(uint64_t, Class *))(v114 + 8);
  swift_retain(v44);
  LODWORD(v114) = 1;
  Swift::String v125 = v12;
  while (1)
  {
    unint64_t v46 = (void (**)(char *, char *, Class *))v138;
    unint64_t v47 = v141;
    unint64_t v48 = v140[2];
    if (v141 == v48)
    {
      uint64_t v49 = 1;
    }
    else
    {
      if (v141 >= v48) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      }
      uint64_t v50 = v111;
      unint64_t v51 = v110;
      (*(void (**)(char *, unint64_t, Class *))(v111 + 16))(v110, (unint64_t)v140+ ((*(unsigned __int8 *)(v111 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v111 + 80))+ *(void *)(v111 + 72) * v141, v24);
      unint64_t v52 = *(void (**)(char *, char *, Class *))(v50 + 32);
      unint64_t v53 = v109;
      v52(v109, v51, v24);
      v139[0] = 0;
      v139[1] = v48;
      uint64_t v55 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, (uint64_t)v136, v113, v54);
      uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v55, v56);
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v107, (uint64_t)v139, (uint64_t)v55, WitnessTable);
      unint64_t v141 = v47 + 1;
      unint64_t v58 = v108;
      v52(v108, v53, v24);
      unint64_t v59 = &v112[*((int *)TupleTypeMetadata2 + 12)];
      uint64_t v60 = v142;
      uint64_t result = ((uint64_t (*)(char *, char *, Class *))v52)(v59, v58, v24);
      if (__OFADD__(v60, 1))
      {
        __break(1u);
        return result;
      }
      uint64_t v142 = v60 + 1;
      unint64_t v62 = (char *)v137 + *((int *)TupleTypeMetadata2 + 12);
      void *v137 = v60;
      v52(v62, v59, v24);
      uint64_t v49 = 0;
    }
    char v63 = v137;
    (*v132)(v137, v49, 1, TupleTypeMetadata2);
    (*v131)(v42, v63, v133);
    if ((*v130)(v42, 1, TupleTypeMetadata2) == 1) {
      break;
    }
    uint64_t v64 = *v42;
    unint64_t v65 = TupleTypeMetadata2;
    unint64_t v66 = (char *)v42 + *((int *)TupleTypeMetadata2 + 12);
    unint64_t v67 = v24;
    unint64_t v68 = v124;
    (*v46)(v124, v66, v67);
    uint64_t v69 = v134;
    uint64_t v70 = (uint64_t)v135;
    uint64_t v71 = v21;
    BOOL v72 = v126;
    ((void (*)(char *, uint64_t, int **))v135[11])(v68, v134, v135);
    unint64_t v73 = v68;
    uint64_t v24 = v67;
    (*v122)(v73, v67);
    uint64_t v74 = v69;
    char v75 = v127;
    uint64_t v76 = swift_getAssociatedConformanceWitness(v70, v74, (uint64_t)v127, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    (*(void (**)(uint64_t, const char *, uint64_t))(v76 + 120))(v128, v75, v76);
    char v77 = v72;
    uint64_t v21 = v71;
    (*v121)(v77, v75);
    Swift::String::Index v78 = v125;
    if ((*v120)(v71, 1, v125) == 1)
    {
      (*v103)(v71, v104);
      LODWORD(v114) = 0;
      TupleTypeMetadata2 = v65;
    }
    else
    {
      uint64_t v79 = *v117;
      Swift::String::Index v80 = v118;
      (*v117)(v118, v21, v78);
      Swift::String::Index v81 = v119;
      v79(v119, (uint64_t)v80, v78);
      if ((*v116)(v81, 1, v136) != 1)
      {
        swift_release((uint64_t)v140);
        char v88 = *(void (**)(char *, char *, const char *))(v102 + 32);
        unint64_t v89 = v101;
        uint64_t v90 = (uint64_t)v136;
        v88(v101, v81, v136);
        unint64_t v92 = type metadata accessor for DiscontiguousSlice.Index(0, v134, (uint64_t)v135, v91);
        unint64_t v93 = v105;
        v88((char *)v105 + *((int *)v92 + 9), v89, (const char *)v90);
        *unint64_t v93 = v64;
        (*((void (**)(void *, void, uint64_t, Class *))*(v92 - 1) + 7))(v93, 0, 1, v92);
        unint64_t v96 = type metadata accessor for Optional(0, (uint64_t)v92, v94, v95);
        return (*((uint64_t (**)(void *, void, uint64_t, Class *))*(v96 - 1) + 7))(v93, 0, 1, v96);
      }
      (*v115)(v81, v78);
      TupleTypeMetadata2 = v65;
    }
  }
  swift_release((uint64_t)v140);
  if (v114)
  {
    Swift::String::Index v83 = type metadata accessor for DiscontiguousSlice.Index(0, v134, (uint64_t)v135, v82);
    uint64_t v84 = v105;
    (*((void (**)(void *, uint64_t, uint64_t, Class *))*(v83 - 1) + 7))(v105, 1, 1, v83);
    uint64_t v87 = type metadata accessor for Optional(0, (uint64_t)v83, v85, v86);
    return (*((uint64_t (**)(void *, void, uint64_t, Class *))*(v87 - 1) + 7))(v84, 0, 1, v87);
  }
  else
  {
    unint64_t v97 = type metadata accessor for DiscontiguousSlice.Index(255, v134, (uint64_t)v135, v82);
    int64_t v100 = type metadata accessor for Optional(0, (uint64_t)v97, v98, v99);
    return (*((uint64_t (**)(void *, uint64_t, uint64_t, Class *))*(v100 - 1) + 7))(v105, 1, 1, v100);
  }
}

__objc2_class **DiscontiguousSlice._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v3 = specialized DiscontiguousSlice._copyToContiguousArray()(v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8))(v1, a1);
  return v3;
}

atomic_ullong *RangeSet.ranges.getter@<X0>(atomic_ullong **a1@<X8>)
{
  uint64_t v2 = *v1;
  *a1 = *v1;
  return swift_retain(v2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance DiscontiguousSlice<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v6 = type metadata accessor for DiscontiguousSlice.Index(0, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  uint64_t v7 = (uint64_t)*(v6 - 1);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)&v17 - v8;
  uint64_t v10 = *(void *)(a1 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 16))(a3, v3, a1);
  DiscontiguousSlice.startIndex.getter(a1, v11, v9);
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(v3, a1);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, (unint64_t *)a1, v12);
  uint64_t v15 = type metadata accessor for IndexingIterator(0, a1, WitnessTable, v14);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v7 + 32))(a3 + *((int *)v15 + 9), v9, v6);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance DiscontiguousSlice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance DiscontiguousSlice<A>(uint64_t a1)
{
  uint64_t v3 = specialized DiscontiguousSlice._copyToContiguousArray()(v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8))(v1, a1);
  return v3;
}

uint64_t DiscontiguousSlice.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, char *a3@<X8>)
{
  uint64_t v5 = *(void *)(v3 + *(int *)(a1 + 36));
  uint64_t v6 = *(void *)(a1 + 24);
  if (*(void *)(v5 + 16))
  {
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
    uint64_t v11 = (uint64_t)*(type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v10)- 1);
    uint64_t v12 = v5 + ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    uint64_t v14 = type metadata accessor for DiscontiguousSlice.Index(0, v7, v6, v13);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(&a3[*((int *)v14 + 9)], v12, AssociatedTypeWitness);
  }
  else
  {
    uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 72);
    uint64_t v17 = *(void *)(a1 + 16);
    type metadata accessor for DiscontiguousSlice.Index(0, v17, v6, a2);
    uint64_t result = v16(v17, v6);
  }
  *(void *)a3 = 0;
  return result;
}

BOOL RangeSet.isEmpty.getter()
{
  return *(void *)(*(void *)v0 + 16) == 0;
}

uint64_t DiscontiguousSlice.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(*(void *)(v3 + *(int *)(a1 + 36)) + 16);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 72);
  type metadata accessor for DiscontiguousSlice.Index(0, v7, v6, a2);
  uint64_t result = v8(v7, v6);
  *a3 = v5;
  return result;
}

uint64_t RangeSet.Ranges.subscript.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if ((a1 & 0x8000000000000000) != 0 || (uint64_t v7 = *v4, *(void *)(v7 + 16) <= a1)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
  uint64_t v8 = type metadata accessor for Range(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  uint64_t v10 = *(uint64_t (**)(uint64_t, unint64_t, Class *))(v9 + 16);
  unint64_t v11 = v7
      + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
      + *(void *)(v9 + 72) * a1;

  return v10(a4, v11, v8);
}

BOOL DiscontiguousSlice.isEmpty.getter(uint64_t a1)
{
  return *(void *)(*(void *)(v1 + *(int *)(a1 + 36)) + 16) == 0;
}

uint64_t DiscontiguousSlice.distance(from:to:)(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v105 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v104 = (char *)&v96 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v10 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v12 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v111 = (char *)&v96 - v13;
  uint64_t v14 = swift_getAssociatedTypeWitness(255, (int **)v11, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v113 = v8;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v11, v8, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for Range(255, (uint64_t)v14, AssociatedConformanceWitness, v16);
  uint64_t v20 = type metadata accessor for Optional(0, (uint64_t)v17, v18, v19);
  uint64_t v21 = MEMORY[0x1F4188790](v20 - 1);
  uint64_t v103 = (char *)&v96 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  BOOL v25 = (char *)&v96 - v24;
  uint64_t v115 = v17;
  uint64_t v114 = (uint64_t)*(v17 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v28 = (char *)&v96 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  unint64_t v108 = (char *)&v96 - v30;
  MEMORY[0x1F4188790](v29);
  unint64_t v110 = (char *)a1;
  uint64_t v33 = *a1;
  unint64_t v112 = a2;
  uint64_t v34 = *a2;
  if (v34 < v33) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v106 = (char *)&v96 - v32;
  uint64_t v107 = v12;
  uint64_t v35 = *(atomic_ullong **)(v4 + *(int *)(a3 + 36));
  uint64_t v120 = v35;
  uint64_t v121 = 0;
  uint64_t v118 = v34;
  uint64_t v122 = v35[2];
  uint64_t v36 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, (uint64_t)v14, AssociatedConformanceWitness, v31);
  swift_retain(v35);
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v36, v37);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v118, (uint64_t)&v121, (uint64_t)v36, WitnessTable);
  if (__OFADD__(v34, 1))
  {
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v116 = v4;
  uint64_t v118 = v33;
  uint64_t v119 = v34 + 1;
  Collection<>.subscript.getter((uint64_t)&v118, (uint64_t)v36, (uint64_t)WitnessTable, (char *)&v121);
  swift_release((uint64_t)v35);
  uint64_t v40 = (char *)v121;
  uint64_t v39 = v122;
  uint64_t v41 = v123;
  uint64_t v118 = v121;
  uint64_t v120 = (atomic_ullong *)v122;
  uint64_t v43 = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v36, v42);
  if (RandomAccessCollection<>.distance(from:to:)((uint64_t)&v118, (uint64_t)&v120, (uint64_t)v36, v43, (uint64_t)&protocol witness table for Int) < 2)goto LABEL_12; {
  uint64_t v104 = (char *)v11;
  }
  uint64_t v121 = (uint64_t)v40;
  uint64_t v122 = v39;
  uint64_t v123 = v41;
  uint64_t v101 = WitnessTable;
  uint64_t v45 = (unint64_t *)type metadata accessor for Slice(0, (uint64_t)v36, (uint64_t)WitnessTable, v44);
  uint64_t v47 = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, v45, v46);
  Collection.first.getter((uint64_t)v45, v47, (uint64_t)v25);
  uint64_t v48 = v114;
  uint64_t v49 = v115;
  uint64_t v102 = *(Class **)(v114 + 48);
  int v50 = ((uint64_t (*)(char *, uint64_t, Class *))v102)(v25, 1, v115);
  uint64_t v105 = v39;
  if (v50 == 1) {
    goto LABEL_21;
  }
  unint64_t v51 = v106;
  unint64_t v52 = v25;
  unint64_t v53 = *(void (**)(char *, char *, Class *))(v48 + 32);
  v53(v106, v52, v49);
  uint64_t v98 = v40;
  uint64_t v121 = (uint64_t)v40;
  uint64_t v122 = v105;
  uint64_t v99 = v41;
  uint64_t v123 = v41;
  int64_t v100 = v36;
  uint64_t v117 = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v36, v54);
  uint64_t v55 = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, v45, (uint64_t)&v117);
  uint64_t v56 = v103;
  unint64_t v97 = v45;
  BidirectionalCollection.last.getter((uint64_t)v45, v55, (uint64_t)v103);
  if (((unsigned int (*)(char *, uint64_t, Class *))v102)(v56, 1, v49) == 1)
  {
    unint64_t v92 = 161;
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DiscontiguousSlice.swift", 30, 2, v92, 0);
  }
  uint64_t v40 = v108;
  v53(v108, v56, v49);
  uint64_t v57 = (uint64_t)v104;
  uint64_t v103 = (char *)*((void *)v104 + 11);
  unint64_t v58 = v111;
  uint64_t v59 = v113;
  ((void (*)(char *, uint64_t, char *))v103)(v51, v113, v104);
  uint64_t v102 = type metadata accessor for DiscontiguousSlice.Index(0, v59, v57, v60);
  unint64_t v61 = &v110[*((int *)v102 + 9)];
  unint64_t v62 = &v51[*((int *)v49 + 9)];
  char v63 = AssociatedTypeWitness;
  uint64_t v64 = v59;
  uint64_t v65 = swift_getAssociatedConformanceWitness(v57, v59, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  unint64_t v110 = *(char **)(v65 + 152);
  uint64_t v96 = ((uint64_t (*)(char *, char *, const char *, uint64_t))v110)(v61, v62, v63, v65);
  uint64_t v39 = v107 + 8;
  uint64_t v41 = *(void *)(v107 + 8);
  ((void (*)(char *, const char *))v41)(v58, v63);
  uint64_t v66 = v64;
  uint64_t v11 = (uint64_t)v104;
  ((void (*)(char *, uint64_t, char *))v103)(v40, v66, v104);
  uint64_t v28 = (char *)((uint64_t (*)(char *, char *, const char *, uint64_t))v110)(v40, (char *)v112 + *((int *)v102 + 9), v63, v65);
  ((void (*)(char *, const char *))v41)(v58, v63);
  uint64_t v67 = v105;
  uint64_t v68 = v105 - 1;
  if (__OFSUB__(v105, 1))
  {
LABEL_17:
    __break(1u);
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
  if (v68 <= 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v69 = v115;
  uint64_t v70 = *(void (**)(char *, Class *))(v114 + 8);
  v70(v108, v115);
  v70(v106, v69);
  uint64_t v121 = 1;
  uint64_t v122 = v68;
  uint64_t v118 = (uint64_t)v98;
  uint64_t v119 = v67;
  uint64_t v71 = specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v121, (uint64_t)&v118, (uint64_t)v100, v101);
  uint64_t v36 = (unint64_t *)&v96;
  uint64_t v121 = 1;
  uint64_t v122 = v68;
  uint64_t v123 = v99;
  MEMORY[0x1F4188790](v71);
  uint64_t WitnessTable = (int **)(&v96 - 6);
  uint64_t v93 = v113;
  uint64_t v94 = v11;
  uint64_t v95 = v116;
  BOOL v72 = v97;
  uint64_t v74 = (int **)swift_getWitnessTable(protocol conformance descriptor for Slice<A>, v97, v73);
  uint64_t v75 = _sSTsE6reduceyqd__qd___qd__qd___7ElementQztKXEtKlFSixq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySiACSiIsgnnrzo_xSisAD_pSTRzSiRsd__r__lIetMygndzo_Tp5(0, (void (*)(char **__return_ptr, char **, char *))partial apply for closure #1 in DiscontiguousSlice.distance(from:to:), (uint64_t)(&v96 - 6), (uint64_t)v72, v74);
  swift_release(v123);
  uint64_t v76 = v96 + v75;
  if (__OFADD__(v96, v75))
  {
    __break(1u);
LABEL_21:
    unint64_t v92 = 160;
    goto LABEL_23;
  }
  uint64_t v77 = (uint64_t)&v28[v76];
  if (!__OFADD__(v76, v28)) {
    return v77;
  }
  __break(1u);
LABEL_12:
  uint64_t v78 = v39;
  uint64_t v79 = v104;
  uint64_t v80 = v105;
  uint64_t v81 = v113;
  (*(void (**)(char *, uint64_t, uint64_t))(v105 + 16))(v104, v116, v113);
  uint64_t v118 = 0;
  uint64_t v121 = (uint64_t)v40;
  uint64_t v122 = v78;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v118, (uint64_t)&v121, (uint64_t)v36, WitnessTable);
  uint64_t v83 = v114;
  uint64_t v82 = v115;
  if (!*(void *)(v41 + 16)) {
    goto LABEL_18;
  }
  (*(void (**)(char *, unint64_t, Class *))(v114 + 16))(v28, v41 + ((*(unsigned __int8 *)(v114 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v114 + 80)), v115);
  swift_release(v41);
  uint64_t v84 = v111;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 88))(v28, v81, v11);
  (*(void (**)(char *, Class *))(v83 + 8))(v28, v82);
  (*(void (**)(char *, uint64_t))(v80 + 8))(v79, v81);
  uint64_t v86 = *((int *)type metadata accessor for DiscontiguousSlice.Index(0, v81, v11, v85) + 9);
  uint64_t v87 = AssociatedTypeWitness;
  char v88 = &v110[v86];
  unint64_t v89 = (char *)v112 + v86;
  uint64_t v90 = swift_getAssociatedConformanceWitness(v11, v81, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v77 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v90 + 152))(v88, v89, v87, v90);
  (*(void (**)(char *, const char *))(v107 + 8))(v84, v87);
  return v77;
}

uint64_t specialized Slice.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x714uLL, 0);
  }
  if (a1 >= a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x715uLL, 0);
  }
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
  }
  if (a1 >= a5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  return *(unsigned __int8 *)(a4 + a1);
}

uint64_t specialized Slice.subscript.getter(unsigned int a1, uint64_t a2)
{
  if (a2 < a1 || HIDWORD(a2) >= a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  return a1 - 1;
}

uint64_t Slice.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v55 = a1;
  uint64_t v56 = a3;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(int ***)(a2 + 24);
  uint64_t v50 = a2;
  unint64_t v53 = v5;
  uint64_t v54 = v4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v9 = TupleTypeMetadata2 - 1;
  uint64_t v10 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v47 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v47 - v13;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = (uint64_t)*(v17 - 1);
  unint64_t v51 = v17;
  uint64_t v52 = v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v48 = v3;
  uint64_t v49 = (char *)&v47 - v22;
  uint64_t v23 = v3;
  uint64_t v24 = v3 + *(int *)(a2 + 36);
  BOOL v25 = &v14[*((int *)v9 + 14)];
  uint64_t v26 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v27 = (void (*)(char *, uint64_t, const char *))v26[2];
  v27(v14, v23, AssociatedTypeWitness);
  uint64_t v47 = v25;
  v27(v25, v24, AssociatedTypeWitness);
  uint64_t v28 = &v12[*((int *)v9 + 14)];
  v27(v12, (uint64_t)v14, AssociatedTypeWitness);
  v27(v28, (uint64_t)v25, AssociatedTypeWitness);
  uint64_t v29 = (void (*)(char *, char *, const char *))v26[4];
  v29(v21, v12, AssociatedTypeWitness);
  uint64_t v30 = (void (*)(char *, const char *))v26[1];
  v30(v28, AssociatedTypeWitness);
  uint64_t v31 = &v12[*((int *)v9 + 14)];
  v29(v12, v14, AssociatedTypeWitness);
  v29(v31, v47, AssociatedTypeWitness);
  uint64_t v32 = v51;
  uint64_t v33 = v21;
  v29(&v21[*((int *)v51 + 9)], v31, AssociatedTypeWitness);
  v30(v12, AssociatedTypeWitness);
  uint64_t v34 = v52;
  uint64_t v35 = v49;
  uint64_t v36 = v32;
  (*(void (**)(char *, char *, Class *))(v52 + 32))(v49, v33, v32);
  uint64_t v38 = v53;
  uint64_t v37 = v54;
  uint64_t v39 = v55;
  ((void (*)(uint64_t, char *, uint64_t, int **))v53[20])(v55, v35, v54, v53);
  (*(void (**)(char *, Class *))(v34 + 8))(v35, v36);
  uint64_t v40 = v39;
  uint64_t v41 = v37;
  uint64_t v42 = (uint64_t (*)(unsigned char *, void))((uint64_t (*)(unsigned char *, uint64_t, uint64_t, int **))v38[10])(v57, v40, v37, v38);
  uint64_t v44 = v43;
  uint64_t v45 = swift_getAssociatedTypeWitness(0, (int **)v38[1], v41, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v45 - 1) + 16))(v56, v44, v45);
  return v42(v57, 0);
}

uint64_t specialized Slice.subscript.getter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result < a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x71BuLL, 0);
  }
  if (a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x71CuLL, 0);
  }
  return result;
}

uint64_t Slice.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v53 = a1;
  uint64_t v54 = a3;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(int ***)(a2 + 24);
  uint64_t v56 = a2;
  unint64_t v51 = v5;
  uint64_t v52 = v4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v9 = TupleTypeMetadata2 - 1;
  uint64_t v10 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v45 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v45 - v13;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = (uint64_t)*(v17 - 1);
  uint64_t v49 = v17;
  uint64_t v50 = v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v55 = (char *)&v45 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v47 = v3;
  uint64_t v48 = (char *)&v45 - v21;
  uint64_t v22 = v3;
  uint64_t v23 = v3 + *(int *)(a2 + 36);
  uint64_t v24 = &v14[*((int *)v9 + 14)];
  BOOL v25 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v26 = (void (*)(char *, uint64_t, const char *))v25[2];
  v26(v14, v22, AssociatedTypeWitness);
  uint64_t v46 = v24;
  v26(v24, v23, AssociatedTypeWitness);
  uint64_t v27 = &v12[*((int *)v9 + 14)];
  v26(v12, (uint64_t)v14, AssociatedTypeWitness);
  v26(v27, (uint64_t)v24, AssociatedTypeWitness);
  uint64_t v28 = (void (*)(char *, char *, const char *))v25[4];
  uint64_t v29 = v55;
  v28(v55, v12, AssociatedTypeWitness);
  uint64_t v30 = (void (*)(char *, const char *))v25[1];
  v30(v27, AssociatedTypeWitness);
  uint64_t v31 = &v12[*((int *)v9 + 14)];
  v28(v12, v14, AssociatedTypeWitness);
  v28(v31, v46, AssociatedTypeWitness);
  uint64_t v32 = v49;
  v28(&v29[*((int *)v49 + 9)], v31, AssociatedTypeWitness);
  v30(v12, AssociatedTypeWitness);
  uint64_t v33 = v50;
  uint64_t v34 = v48;
  uint64_t v35 = v32;
  (*(void (**)(char *, char *, Class *))(v50 + 32))(v48, v55, v32);
  uint64_t v36 = v56;
  uint64_t v37 = v47 + *(int *)(v56 + 40);
  uint64_t v38 = v53;
  uint64_t v39 = v34;
  uint64_t v40 = v34;
  uint64_t v41 = v52;
  ((void (*)(uint64_t, char *, uint64_t))v51[22])(v53, v39, v52);
  (*(void (**)(char *, Class *))(v33 + 8))(v40, v35);
  uint64_t v42 = *(int *)(v36 + 40);
  uint64_t v43 = v54;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v41 - 8) + 16))(&v54[v42], v37, v41);
  (*(void (**)(char *, uint64_t, Class *))(v33 + 16))(v40, v38, v35);
  v28(v43, v40, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, const char *))v28)(&v43[*(int *)(v56 + 36)], &v40[*((int *)v35 + 9)], AssociatedTypeWitness);
}

uint64_t closure #1 in DiscontiguousSlice.distance(from:to:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  uint64_t v14 = *a1;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 88))(a2, a3, a4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v16 = (*(uint64_t (**)(const char *, uint64_t))(AssociatedConformanceWitness + 112))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t result = (*(uint64_t (**)(char *, const char *))(v11 + 8))(v13, AssociatedTypeWitness);
  if (__OFADD__(v14, v16)) {
    __break(1u);
  }
  else {
    *a5 = v14 + v16;
  }
  return result;
}

uint64_t _sSTsE6reduceyqd__qd___qd__qd___7ElementQztKXEtKlFSixq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySiACSiIsgnnrzo_xSisAD_pSTRzSiRsd__r__lIetMygndzo_Tp5(char *a1, void (*a2)(char **__return_ptr, char **, char *), uint64_t a3, uint64_t a4, int **a5)
{
  void (*v35)(char **__return_ptr, char **, char *);
  uint64_t v36;
  char *v37;
  const char *v38;
  char *v39;
  char *v40;

  uint64_t v37 = a1;
  uint64_t v35 = a2;
  uint64_t v36 = a3;
  uint64_t v34 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v33 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v30 - v9;
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1F4188790](v13 - 1);
  uint64_t v16 = (char *)&v30 - v15;
  uint64_t v17 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v30 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v30 = *((void *)v20 - 1);
  MEMORY[0x1F4188790](v20);
  uint64_t v22 = (char *)&v30 - v21;
  uint64_t v40 = v37;
  (*(void (**)(char *, const char *, uint64_t))(v17 + 16))(v19, v38, a4);
  uint64_t v23 = (uint64_t)v34;
  ((void (*)(uint64_t, int **))v34[4])(a4, v34);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v23, a4, (uint64_t)v20, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  BOOL v25 = *(int ***)(AssociatedConformanceWitness + 16);
  uint64_t v37 = v22;
  uint64_t v38 = v20;
  uint64_t v34 = v25;
  ((void (*)(const char *, uint64_t))v25)(v20, AssociatedConformanceWitness);
  uint64_t v26 = v33;
  uint64_t v27 = *(unsigned int (**)(char *, uint64_t, const char *))(v33 + 48);
  if (v27(v16, 1, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(char *, const char *))(v30 + 8))(v37, v38);
    return (uint64_t)v40;
  }
  else
  {
    uint64_t v31 = v27;
    uint64_t v32 = AssociatedConformanceWitness;
    uint64_t v33 = *(void *)(v26 + 32);
    uint64_t v28 = (void (**)(char *, const char *))(v26 + 8);
    while (1)
    {
      ((void (*)(char *, char *, const char *))v33)(v10, v16, AssociatedTypeWitness);
      v35(&v39, &v40, v10);
      if (v5) {
        break;
      }
      (*v28)(v10, AssociatedTypeWitness);
      uint64_t v40 = v39;
      ((void (*)(const char *, uint64_t))v34)(v38, v32);
      if (v31(v16, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }
    (*v28)(v10, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, const char *))(v30 + 8))(v37, v38);
  }
}

uint64_t Sequence.reduce<A>(_:_:)@<X0>(char *a1@<X0>, void (*a2)(uint64_t, char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v56 = a5;
  uint64_t v52 = a2;
  uint64_t v53 = a3;
  uint64_t v54 = a1;
  uint64_t v59 = a7;
  uint64_t v44 = *(void (***)(uint64_t, char *, uint64_t))(a5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v42 = (char *)&v41 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v11, v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v57 = (char *)&v41 - v14;
  uint64_t v17 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v15, v16);
  uint64_t v18 = MEMORY[0x1F4188790](v17 - 1);
  uint64_t v20 = (char *)&v41 - v19;
  uint64_t v21 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = swift_getAssociatedTypeWitness(0, (int **)a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v43 = *((void *)v24 - 1);
  MEMORY[0x1F4188790](v24);
  uint64_t v26 = (char *)&v41 - v25;
  v44[2](v59, v54, v56);
  (*(void (**)(char *, const char *, uint64_t))(v21 + 16))(v23, v55, a4);
  (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a4, a6);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v28 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v54 = v26;
  uint64_t v55 = v24;
  v28(v24, AssociatedConformanceWitness);
  uint64_t v29 = v28;
  uint64_t v30 = *(unsigned int (**)(char *, uint64_t, const char *))(v13 + 48);
  if (v30(v20, 1, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, const char *))(v43 + 8))(v54, v55);
  }
  uint64_t v49 = *(void (**)(char *, char *, const char *))(v13 + 32);
  uint64_t v50 = (void (**)(char *, const char *))(v13 + 8);
  unint64_t v51 = (void (**)(uint64_t, uint64_t))(v44 + 1);
  v44 += 4;
  uint64_t v45 = v30;
  uint64_t v31 = v42;
  uint64_t v47 = AssociatedConformanceWitness;
  uint64_t v48 = AssociatedConformanceWitness + 16;
  uint64_t v46 = v13 + 48;
  while (1)
  {
    uint64_t v32 = v29;
    uint64_t v33 = v57;
    v49(v57, v20, AssociatedTypeWitness);
    uint64_t v34 = v58;
    v52(v59, v33);
    uint64_t v58 = v34;
    if (v34) {
      break;
    }
    (*v50)(v57, AssociatedTypeWitness);
    uint64_t v35 = v31;
    uint64_t v36 = v59;
    uint64_t v37 = v56;
    (*v51)(v59, v56);
    uint64_t v38 = v36;
    uint64_t v31 = v35;
    uint64_t v39 = v47;
    (*v44)(v38, v31, v37);
    v32(v55, v39);
    uint64_t v29 = v32;
    if (v45(v20, 1, AssociatedTypeWitness) == 1) {
      return (*(uint64_t (**)(char *, const char *))(v43 + 8))(v54, v55);
    }
  }
  (*v50)(v57, AssociatedTypeWitness);
  (*(void (**)(char *, const char *))(v43 + 8))(v54, v55);
  return ((uint64_t (*)(uint64_t, uint64_t))*v51)(v59, v56);
}

uint64_t DiscontiguousSlice.index(after:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v55 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v58 = AssociatedTypeWitness;
  uint64_t v59 = v9;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v49 - v10;
  uint64_t v12 = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v60 = *((void *)v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v52 = (char *)&v49 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v56 = (char *)&v49 - v15;
  uint64_t v62 = v7;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v7, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v57 = v12;
  uint64_t v18 = type metadata accessor for Range(0, (uint64_t)v12, AssociatedConformanceWitness, v17);
  uint64_t v19 = (uint64_t)*(v18 - 1);
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v49 - v20;
  unint64_t v61 = a1;
  unint64_t v22 = *a1;
  if (*a1 < 0) {
    goto LABEL_11;
  }
  uint64_t v23 = *(void *)(v3 + *(int *)(a2 + 36));
  if (v22 >= *(void *)(v23 + 16)) {
    goto LABEL_11;
  }
  uint64_t v53 = *(int *)(a2 + 36);
  unint64_t v50 = (*(unsigned __int8 *)(v19 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80);
  uint64_t v49 = *(void *)(v19 + 72);
  (*(void (**)(char *, unint64_t, Class *))(v19 + 16))(v21, v23 + v50 + v49 * v22, v18);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 88);
  uint64_t v54 = v3;
  uint64_t v25 = AssociatedConformanceWitness;
  uint64_t v26 = v62;
  v24(v21, v62, v6);
  uint64_t v28 = type metadata accessor for DiscontiguousSlice.Index(0, v26, v6, v27);
  uint64_t v29 = v6;
  uint64_t v30 = v28;
  uint64_t v31 = v61;
  uint64_t v32 = (char *)v61 + *((int *)v28 + 9);
  uint64_t v51 = v29;
  uint64_t v33 = v26;
  uint64_t v34 = (uint64_t)v58;
  uint64_t v35 = swift_getAssociatedConformanceWitness(v29, v33, (uint64_t)v58, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v36 = v56;
  (*(void (**)(char *, uint64_t, uint64_t))(v35 + 184))(v32, v34, v35);
  (*(void (**)(char *, uint64_t))(v59 + 8))(v11, v34);
  uint64_t v37 = v57;
  LOBYTE(v32) = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v25 + 16))(v36, &v21[*((int *)v18 + 9)], v57, v25);
  (*(void (**)(char *, Class *))(v19 + 8))(v21, v18);
  if (v32)
  {
    uint64_t v38 = *v31;
    uint64_t v39 = v55;
    uint64_t result = (*(uint64_t (**)(char *, char *, const char *))(v60 + 32))((char *)v55 + *((int *)v30 + 9), v36, v37);
    *uint64_t v39 = v38;
    return result;
  }
  uint64_t v41 = v60;
  uint64_t result = (*(uint64_t (**)(char *, const char *))(v60 + 8))(v36, v37);
  BOOL v42 = __OFADD__(*v31, 1);
  uint64_t v43 = *v31 + 1;
  if (v42)
  {
    __break(1u);
  }
  else
  {
    uint64_t v44 = *(void *)(v54 + v53);
    uint64_t v45 = *(void *)(v44 + 16);
    if (v43 < v45)
    {
      if ((v43 & 0x8000000000000000) == 0)
      {
        uint64_t v46 = v52;
        (*(void (**)(char *, unint64_t, const char *))(v41 + 16))(v52, v44 + v50 + v43 * v49, v37);
        uint64_t v47 = v55;
        *uint64_t v55 = v43;
        return (*(uint64_t (**)(char *, char *, const char *))(v41 + 32))((char *)v47 + *((int *)v30 + 9), v46, v37);
      }
LABEL_11:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
    uint64_t v48 = v55;
    uint64_t result = (*(uint64_t (**)(uint64_t))(v51 + 72))(v62);
    *uint64_t v48 = v45;
  }
  return result;
}

uint64_t DiscontiguousSlice.subscript.getter@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v38 = a1;
  uint64_t v36 = a3;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v35 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v34 = (char *)&v33 - v8;
  uint64_t v9 = swift_getAssociatedTypeWitness(255, (int **)v7, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v6, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0, (uint64_t)v9, AssociatedConformanceWitness, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v19, v4, v6);
  unint64_t v20 = *v38;
  if ((*v38 & 0x8000000000000000) != 0 || (uint64_t v21 = *(void *)(v4 + *(int *)(a2 + 36)), v20 >= *(void *)(v21 + 16))) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
  (*(void (**)(char *, unint64_t, Class *))(v13 + 16))(v16, v21+ ((*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80))+ *(void *)(v13 + 72) * v20, v12);
  unint64_t v22 = v34;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 88))(v16, v6, v7);
  (*(void (**)(char *, Class *))(v13 + 8))(v16, v12);
  (*(void (**)(char *, uint64_t))(v17 + 8))(v19, v6);
  uint64_t v24 = type metadata accessor for DiscontiguousSlice.Index(0, v6, v7, v23);
  uint64_t v25 = AssociatedTypeWitness;
  uint64_t v26 = (char *)v38 + *((int *)v24 + 9);
  uint64_t v27 = swift_getAssociatedConformanceWitness(v7, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v28 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, char *, const char *, uint64_t))(v27 + 80))(v39, v26, v25, v27);
  uint64_t v30 = v29;
  uint64_t v31 = swift_getAssociatedTypeWitness(0, *(int ***)(v7 + 8), v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v31 - 1) + 16))(v36, v30, v31);
  v28(v39, 0);
  return (*(uint64_t (**)(char *, const char *))(v35 + 8))(v22, v25);
}

uint64_t DiscontiguousSlice.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v112 = a3;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(int ***)(a2 + 24);
  uint64_t v113 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v111 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v117 = (char *)&v110 - v6;
  uint64_t v7 = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v7, (uint64_t)v7, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v131 = (char *)&v110 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v130 = (char *)&v110 - v11;
  uint64_t v140 = *((void *)v7 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v115 = (char *)&v110 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  unint64_t v127 = (char *)&v110 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v129 = (char *)&v110 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v128 = (char *)&v110 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v120 = (char *)&v110 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v121 = (char *)&v110 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v119 = (char *)&v110 - v25;
  MEMORY[0x1F4188790](v24);
  size_t v135 = (char *)&v110 - v26;
  uint64_t v28 = type metadata accessor for DiscontiguousSlice.Index(0, v4, (uint64_t)v5, v27);
  uint64_t v29 = (uint64_t)*(v28 - 1);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v32 = (char *)&v110 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v30);
  uint64_t v34 = (char *)&v110 - v33;
  uint64_t v116 = v5;
  uint64_t v133 = v4;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)v7, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v137 = type metadata accessor for Range(0, (uint64_t)v7, AssociatedConformanceWitness, v35);
  uint64_t v125 = (uint64_t)*(v137 - 1);
  uint64_t v36 = MEMORY[0x1F4188790](v137);
  unint64_t v110 = (char *)&v110 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  unint64_t v126 = (char *)&v110 - v39;
  MEMORY[0x1F4188790](v38);
  unint64_t v124 = (char *)&v110 - v40;
  uint64_t v41 = *(void (**)(char *, uint64_t, Class *))(v29 + 16);
  v41(v34, a1, v28);
  BOOL v42 = &v34[*((int *)v28 + 9)];
  uint64_t v43 = v140;
  uint64_t v45 = v140 + 32;
  uint64_t v44 = *(void (**)(char *, char *, const char *))(v140 + 32);
  uint64_t v46 = v135;
  v44(v135, v42, v7);
  uint64_t v48 = a1
      + *((int *)type metadata accessor for Range(0, (uint64_t)v28, (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index, v47)+ 9);
  uint64_t v49 = v120;
  v41(v32, v48, v28);
  unint64_t v50 = v119;
  uint64_t v51 = &v32[*((int *)v28 + 9)];
  uint64_t v123 = v44;
  uint64_t v122 = v45;
  v44(v119, v51, v7);
  uint64_t v52 = v121;
  uint64_t v54 = (char *)(v43 + 16);
  uint64_t v53 = *(void (**)(char *, char *, const char *))(v43 + 16);
  v53(v121, v46, v7);
  uint64_t v138 = v53;
  v53(v49, v50, v7);
  uint64_t v55 = (char *)(AssociatedConformanceWitness + 24);
  uint64_t v114 = *(uint64_t (**)(char *, char *, const char *))(AssociatedConformanceWitness + 24);
  if ((v114(v52, v49, v7) & 1) == 0) {
    goto LABEL_4;
  }
  uint64_t v56 = *(void (**)(char *, const char *))(v43 + 8);
  unint64_t v136 = v56;
  uint64_t v140 = v43 + 8;
  v56(v49, v7);
  v56(v52, v7);
  uint64_t v121 = v55;
  uint64_t v57 = TupleTypeMetadata2;
  uint64_t v58 = v130;
  uint64_t v59 = &v130[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v60 = v123;
  v123(v130, v135, v7);
  uint64_t v120 = v59;
  v60(v59, v50, v7);
  unint64_t v61 = v131;
  uint64_t v62 = &v131[*((int *)v57 + 12)];
  char v63 = v138;
  v138(v131, v58, v7);
  v63(v62, v59, v7);
  size_t v135 = v54;
  uint64_t v64 = v126;
  v60(v126, v61, v7);
  uint64_t v65 = v136;
  v136(v62, v7);
  uint64_t v66 = *((int *)v57 + 12);
  uint64_t v67 = (uint64_t)AssociatedTypeWitness;
  uint64_t v68 = &v61[v66];
  v60(v61, v58, v7);
  v60(v68, v120, v7);
  uint64_t v69 = v137;
  v60(&v64[*((int *)v137 + 9)], v68, v7);
  uint64_t v70 = v67;
  v65(v61, v7);
  uint64_t v71 = v124;
  BOOL v72 = (char *)(v125 + 32);
  uint64_t v73 = *(void (**)(char *, char *, Class *))(v125 + 32);
  v73(v124, v64, v69);
  uint64_t v74 = (uint64_t)v116;
  uint64_t v75 = v117;
  uint64_t v76 = v133;
  ((void (*)(char *, uint64_t, int **))v116[11])(v71, v133, v116);
  uint64_t v77 = swift_getAssociatedConformanceWitness(v74, v76, v67, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v78 = v128;
  (*(void (**)(uint64_t, uint64_t))(v77 + 64))(v70, v77);
  uint64_t v79 = v129;
  (*(void (**)(uint64_t, uint64_t))(v77 + 72))(v70, v77);
  uint64_t v80 = v127;
  uint64_t v81 = v78;
  uint64_t v82 = v138;
  v138(v127, v81, v7);
  uint64_t v83 = v115;
  v82(v115, v79, v7);
  if ((((uint64_t (*)(char *, char *, const char *, uint64_t))v114)(v80, v83, v7, AssociatedConformanceWitness) & 1) == 0)LABEL_4:_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v121 = v72;
  }
  uint64_t v84 = v136;
  v136(v83, v7);
  v84(v127, v7);
  (*(void (**)(char *, uint64_t))(v111 + 8))(v75, v70);
  (*(void (**)(char *, Class *))(v125 + 8))(v124, v137);
  uint64_t v85 = TupleTypeMetadata2;
  uint64_t v86 = v130;
  uint64_t v87 = &v130[*((int *)TupleTypeMetadata2 + 12)];
  char v88 = v128;
  uint64_t v128 = (char *)v73;
  unint64_t v89 = v123;
  v123(v130, v88, v7);
  v89(v87, v129, v7);
  uint64_t v90 = v131;
  uint64_t v91 = &v131[*((int *)v85 + 12)];
  unint64_t v92 = v138;
  v138(v131, v86, v7);
  v92(v91, v87, v7);
  uint64_t v93 = v126;
  v89(v126, v90, v7);
  uint64_t v94 = v136;
  v136(v91, v7);
  uint64_t v95 = &v90[*((int *)v85 + 12)];
  v89(v90, v86, v7);
  v89(v95, v87, v7);
  uint64_t v96 = v137;
  v89(&v93[*((int *)v137 + 9)], v95, v7);
  v94(v90, v7);
  unint64_t v97 = v110;
  ((void (*)(char *, char *, Class *))v128)(v110, v93, v96);
  uint64_t v98 = v113;
  uint64_t v99 = v134;
  int64_t v100 = *(atomic_ullong **)(v134 + *(int *)(v113 + 36));
  swift_retain(v100);
  uint64_t v101 = (uint64_t)v97;
  uint64_t v102 = AssociatedConformanceWitness;
  RangeSet.init(_:)(v101, (uint64_t)v7, AssociatedConformanceWitness, v103, &v143);
  uint64_t v104 = v143;
  v141[0] = v143;
  v141[1] = (uint64_t)v100;
  uint64_t v106 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)v7, v102, v105);
  RangeSet.Ranges._intersection(_:)(v141, (uint64_t)v106, &v142);
  swift_release(v104);
  swift_release((uint64_t)v100);
  uint64_t v107 = v142;
  uint64_t v108 = v112;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v133 - 8) + 16))(v112, v99);
  *(void *)(v108 + *(int *)(v98 + 36)) = v107;
  return result;
}

void RangeSet.init(_:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9 = type metadata accessor for Range(0, a2, a3, a4);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 + 8) + 8))(a1, a1 + *((int *)v9 + 9), a2) & 1) == 0)
  {
    uint64_t v18 = (unint64_t *)type metadata accessor for _ContiguousArrayStorage(0, (uint64_t)v9, v10, v11);
    uint64_t v19 = (uint64_t)*(v9 - 1);
    uint64_t v20 = swift_allocObject(v18, ((*(unsigned __int8 *)(v19 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80))+ *(void *)(v19 + 72), *(unsigned __int8 *)(v19 + 80) | 7);
    uint64_t v12 = (__objc2_class **)static Array._adoptStorage(_:count:)(v20, 1);
    (*(void (**)(uint64_t, uint64_t, Class *))(v19 + 32))(v21, a1, v9);
    uint64_t v13 = _ArrayBuffer.requestNativeBuffer()((unint64_t)v12, (uint64_t *)v9);
    if (v13)
    {
LABEL_6:
      uint64_t v16 = v13;
      uint64_t v17 = v12;
      goto LABEL_7;
    }
LABEL_5:
    uint64_t v25 = v12;
    uint64_t v22 = (unint64_t *)type metadata accessor for Array(v13, (uint64_t)v9, v14, v15);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v22, v23);
    uint64_t v13 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v25, (uint64_t)v22, WitnessTable);
    goto LABEL_6;
  }
  (*((void (**)(uint64_t, Class *))*(v9 - 1) + 1))(a1, v9);
  _swift_isClassOrObjCExistentialType((uint64_t)v9, (uint64_t *)v9);
  uint64_t v12 = &_swiftEmptyArrayStorage;
  uint64_t v13 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, (uint64_t *)v9);
  if (!v13) {
    goto LABEL_5;
  }
  uint64_t v16 = v13;
  uint64_t v17 = &_swiftEmptyArrayStorage;
LABEL_7:
  swift_bridgeObjectRelease((uint64_t)v17);
  *a5 = v16;
}

uint64_t RangeSet.intersection(_:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v6 = *v4;
  v9[0] = *a1;
  v9[1] = v6;
  uint64_t v7 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  RangeSet.Ranges._intersection(_:)(v9, (uint64_t)v7, &v10);
  uint64_t result = swift_release(v6);
  *a4 = v10;
  return result;
}

uint64_t DiscontiguousSlice._index(of:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  uint64_t v46 = a1;
  BOOL v42 = a3;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v4 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v47 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v45 = (char *)&v39 - v7;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v44 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v9);
  uint64_t v10 = (uint64_t)*(v44 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v44);
  uint64_t v43 = (char *)&v39 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v39 - v13;
  uint64_t v15 = *(int *)(a2 + 36);
  uint64_t v54 = *(atomic_ullong **)(v48 + v15);
  uint64_t v16 = v54;
  uint64_t v40 = v5;
  uint64_t v41 = v4;
  uint64_t v50 = v5;
  uint64_t v51 = v4;
  uint64_t v17 = v46;
  uint64_t v52 = v46;
  uint64_t v19 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  uint64_t v20 = v10;
  swift_retain(v16);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v19, v21);
  Collection._partitioningIndex(where:)((uint64_t (*)(char *))partial apply for closure #1 in DiscontiguousSlice._index(of:), (uint64_t)v49, (uint64_t)v19, WitnessTable, (char *)&v55);
  swift_release((uint64_t)v54);
  unint64_t v23 = v55;
  uint64_t v53 = *(void *)(v48 + v15);
  RangeSet.Ranges.subscript.getter(v55, (uint64_t)v19, v24, (uint64_t)v14);
  LOBYTE(v10) = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v14, v17, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v25 = *(void (**)(void))(v47 + 16);
  uint64_t v26 = v45;
  v25();
  uint64_t v27 = v43;
  uint64_t v28 = v44;
  (*(void (**)(void))(v20 + 32))();
  if (v10)
  {
    uint64_t v39 = v25;
    unint64_t v48 = v23;
    char v29 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 16))(v26, &v27[*((int *)v28 + 9)], AssociatedTypeWitness, AssociatedConformanceWitness);
    uint64_t v30 = v28;
    char v31 = v29;
    (*(void (**)(char *, Class *))(v20 + 8))(v27, v30);
    (*(void (**)(char *, const char *))(v47 + 8))(v26, AssociatedTypeWitness);
    uint64_t v33 = (uint64_t)v41;
    uint64_t v34 = v42;
    uint64_t v35 = v40;
    if (v31)
    {
      uint64_t v36 = type metadata accessor for DiscontiguousSlice.Index(0, v40, (uint64_t)v41, v32);
      ((void (*)(char *, uint64_t, const char *))v39)((char *)v34 + *((int *)v36 + 9), v46, AssociatedTypeWitness);
      unint64_t *v34 = v48;
      return (*((uint64_t (**)(unint64_t *, void, uint64_t, Class *))*(v36 - 1) + 7))(v34, 0, 1, v36);
    }
  }
  else
  {
    (*(void (**)(char *, Class *))(v20 + 8))(v27, v28);
    (*(void (**)(char *, const char *))(v47 + 8))(v26, AssociatedTypeWitness);
    uint64_t v33 = (uint64_t)v41;
    uint64_t v34 = v42;
    uint64_t v35 = v40;
  }
  uint64_t v38 = type metadata accessor for DiscontiguousSlice.Index(0, v35, v33, v32);
  return (*((uint64_t (**)(unint64_t *, uint64_t, uint64_t, Class *))*(v38 - 1) + 7))(v34, 1, 1, v38);
}

uint64_t Range.contains(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = *(void *)(v15 + 24);
  char v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 24))(v3, a1, v11, v16);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, a1, v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v9, v3, a2);
  if (v17) {
    char v18 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v16 + 16))(v14, &v9[*(int *)(a2 + 36)], v11, v16);
  }
  else {
    char v18 = 0;
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  return v18 & 1;
}

uint64_t Sequence.lazy.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a2, v2, a1);
}

uint64_t DiscontiguousSlice._customLastIndexOfEquatableElement(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v118 = a1;
  uint64_t v96 = a3;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v98 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v93 = (char *)&v93 - v8;
  uint64_t v117 = swift_getAssociatedTypeWitness(0, v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  unint64_t v110 = (void (**)(char *, const char *))*((void *)v117 - 1);
  MEMORY[0x1F4188790](v117);
  uint64_t v116 = (char *)&v93 - v9;
  uint64_t v124 = v5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v111 = (void (**)(char *, Class *))*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v114 = (char *)&v93 - v13;
  uint64_t v16 = type metadata accessor for Optional(255, (uint64_t)AssociatedTypeWitness, v14, v15);
  uint64_t v95 = type metadata accessor for Optional(0, (uint64_t)v16, v17, v18);
  uint64_t v102 = (uint64_t)*(v95 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v95);
  uint64_t v21 = (char *)&v93 - v20;
  uint64_t v22 = (uint64_t)*(v16 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v19);
  uint64_t v25 = (char *)&v93 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  uint64_t v105 = (char *)&v93 - v26;
  uint64_t v115 = v12;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, (uint64_t)&type metadata for Int, (uint64_t)v12, "offset element ", 0);
  uint64_t v121 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v28, v29);
  uint64_t v125 = (int **)*(v121 - 1);
  uint64_t v30 = MEMORY[0x1F4188790](v121);
  uint64_t v123 = (char *)&v93 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v30);
  uint64_t v122 = (char *)&v93 - v32;
  uint64_t v33 = *(int *)(a2 + 36);
  uint64_t v119 = v3;
  uint64_t v34 = *(atomic_ullong **)(v3 + v33);
  unint64_t v127 = v34;
  uint64_t v108 = AssociatedTypeWitness;
  uint64_t v36 = (unint64_t *)type metadata accessor for RangeSet.Ranges(255, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v35);
  swift_retain(v34);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v36, v37);
  uint64_t v40 = (unint64_t *)type metadata accessor for EnumeratedSequence(0, (uint64_t)v36, WitnessTable, v39);
  uint64_t v42 = swift_getWitnessTable(protocol conformance descriptor for EnumeratedSequence<A>, v40, v41);
  uint64_t v43 = Sequence.reversed()((uint64_t)v40, v42);
  Swift::Int v44 = Array._getCount()();
  int64_t v100 = v43;
  unint64_t v99 = (unint64_t)v43 & 0xC000000000000001;
  uint64_t v120 = (void (**)(uint64_t *, char *, Class *))(v125 + 4);
  uint64_t v125 = v6;
  unint64_t v126 = TupleTypeMetadata2 - 1;
  uint64_t v112 = v6 + 11;
  uint64_t v113 = (void (**)(char *, char *, Class *))(v111 + 4);
  ++v110;
  ++v111;
  unint64_t v109 = (unsigned int (**)(char *, uint64_t, Class *))(v22 + 48);
  uint64_t v45 = v22;
  uint64_t v104 = (void (**)(char *, char *, Class *))(v22 + 32);
  uint64_t v103 = (unsigned int (**)(char *, uint64_t, const char *))(v98 + 48);
  unint64_t v46 = 0;
  uint64_t v101 = (void (**)(char *, Class *))(v45 + 8);
  uint64_t v94 = (void (**)(char *, Class *))(v102 + 8);
  int v97 = 1;
  Swift::Int v107 = v44;
  uint64_t v106 = TupleTypeMetadata2;
LABEL_2:
  unint64_t v48 = (uint64_t *)v122;
  uint64_t v47 = v123;
  if (v46 == v44)
  {
LABEL_3:
    uint64_t v49 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v49 + 56))(v47, 1, 1, TupleTypeMetadata2);
    Swift::Int v50 = v44;
    goto LABEL_7;
  }
  while (1)
  {
    BOOL v51 = v99 == 0;
    char v52 = v51 | ~_swift_isClassOrObjCExistentialType((uint64_t)TupleTypeMetadata2, TupleTypeMetadata2);
    uint64_t v53 = v100;
    Array._checkSubscript(_:wasNativeTypeChecked:)(v46, v52 & 1);
    if (v52)
    {
      uint64_t v54 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, unint64_t, uint64_t *))(v54 + 16))(v47, (unint64_t)v53+ ((*(unsigned __int8 *)(v54 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v54 + 80))+ *(void *)(v54 + 72) * v46, TupleTypeMetadata2);
      BOOL v55 = __OFADD__(v46, 1);
      Swift::Int v50 = v46 + 1;
      if (v55) {
        goto LABEL_22;
      }
    }
    else
    {
      BOOL v72 = (atomic_ullong *)_ArrayBuffer._getElementSlowPath(_:)(v46, (uint64_t)v53, TupleTypeMetadata2);
      uint64_t v53 = v72;
      uint64_t v54 = *(TupleTypeMetadata2 - 1);
      if (*(void *)(v54 + 64) != 8) {
        goto LABEL_23;
      }
      unint64_t v127 = v72;
      (*(void (**)(char *, atomic_ullong **, uint64_t *))(v54 + 16))(v47, &v127, TupleTypeMetadata2);
      swift_unknownObjectRelease(v53);
      BOOL v55 = __OFADD__(v46, 1);
      Swift::Int v50 = v46 + 1;
      if (v55)
      {
LABEL_22:
        __break(1u);
LABEL_23:
        swift_unknownObjectRelease(v53);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
    }
    uint64_t v49 = v54;
    (*(void (**)(char *, void, uint64_t, uint64_t *))(v54 + 56))(v47, 0, 1, TupleTypeMetadata2);
LABEL_7:
    (*v120)(v48, v47, v121);
    if ((*(unsigned int (**)(uint64_t *, uint64_t, uint64_t *))(v49 + 48))(v48, 1, TupleTypeMetadata2) == 1) {
      break;
    }
    unint64_t v56 = v50;
    uint64_t v57 = v25;
    uint64_t v102 = *v48;
    uint64_t v58 = (char *)v48 + *((int *)TupleTypeMetadata2 + 12);
    uint64_t v59 = v114;
    uint64_t v60 = v21;
    unint64_t v61 = v16;
    uint64_t v62 = v115;
    (*v113)(v114, v58, v115);
    uint64_t v63 = v124;
    uint64_t v64 = (uint64_t)v125;
    uint64_t v65 = v116;
    ((void (*)(char *, uint64_t, int **))v125[11])(v59, v124, v125);
    uint64_t v66 = v62;
    uint64_t v16 = v61;
    uint64_t v21 = v60;
    (*v111)(v59, v66);
    uint64_t v67 = v63;
    uint64_t v68 = v117;
    uint64_t v69 = swift_getAssociatedConformanceWitness(v64, v67, (uint64_t)v117, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    (*(void (**)(uint64_t, const char *, uint64_t))(v69 + 128))(v118, v68, v69);
    (*v110)(v65, v68);
    if ((*v109)(v60, 1, v16) == 1)
    {
      (*v94)(v60, v95);
      int v97 = 0;
      uint64_t v25 = v57;
      TupleTypeMetadata2 = v106;
      Swift::Int v44 = v107;
      unint64_t v46 = v56;
      goto LABEL_2;
    }
    uint64_t v70 = *v104;
    uint64_t v71 = v105;
    (*v104)(v105, v21, v16);
    uint64_t v25 = v57;
    v70(v57, v71, v16);
    if ((*v103)(v57, 1, v108) != 1)
    {
      swift_bridgeObjectRelease((uint64_t)v100);
      uint64_t v80 = *(void (**)(char *, char *, const char *))(v98 + 32);
      uint64_t v81 = v93;
      uint64_t v82 = v108;
      v80(v93, v57, v108);
      uint64_t v84 = type metadata accessor for DiscontiguousSlice.Index(0, v124, (uint64_t)v125, v83);
      uint64_t v85 = v96;
      v80((char *)v96 + *((int *)v84 + 9), v81, v82);
      *uint64_t v85 = v102;
      (*((void (**)(void *, void, uint64_t, Class *))*(v84 - 1) + 7))(v85, 0, 1, v84);
      char v88 = type metadata accessor for Optional(0, (uint64_t)v84, v86, v87);
      return (*((uint64_t (**)(void *, void, uint64_t, Class *))*(v88 - 1) + 7))(v85, 0, 1, v88);
    }
    unint64_t v46 = v56;
    (*v101)(v57, v16);
    TupleTypeMetadata2 = v106;
    unint64_t v48 = (uint64_t *)v122;
    uint64_t v47 = v123;
    Swift::Int v44 = v107;
    if (v56 == v107) {
      goto LABEL_3;
    }
  }
  swift_bridgeObjectRelease((uint64_t)v100);
  if (v97)
  {
    uint64_t v74 = type metadata accessor for DiscontiguousSlice.Index(0, v124, (uint64_t)v125, v73);
    uint64_t v75 = v96;
    (*((void (**)(void *, uint64_t, uint64_t, Class *))*(v74 - 1) + 7))(v96, 1, 1, v74);
    uint64_t v78 = type metadata accessor for Optional(0, (uint64_t)v74, v76, v77);
    return (*((uint64_t (**)(void *, void, uint64_t, Class *))*(v78 - 1) + 7))(v75, 0, 1, v78);
  }
  else
  {
    unint64_t v89 = type metadata accessor for DiscontiguousSlice.Index(255, v124, (uint64_t)v125, v73);
    unint64_t v92 = type metadata accessor for Optional(0, (uint64_t)v89, v90, v91);
    return (*((uint64_t (**)(void *, uint64_t, uint64_t, Class *))*(v92 - 1) + 7))(v96, 1, 1, v92);
  }
}

atomic_ullong *Sequence.reversed()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v7 = *(AssociatedTypeWitness - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v52 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v52 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  unint64_t v61 = (char *)&v52 - v15;
  uint64_t v16 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](v14);
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))((char *)&v52 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0), v2, a1);
  uint64_t v18 = (atomic_ullong *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  uint64_t v63 = v18;
  swift_retain(v18);
  Swift::Int v19 = Array._getCount()();
  swift_release((uint64_t)v18);
  if (v19 >= 0) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = v19 + 1;
  }
  if (v19 <= -2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v22 = *(void (**)(uint64_t, uint64_t))(v16 + 8);
  uint64_t v21 = (void *)(v16 + 8);
  v22(v3, a1);
  if ((unint64_t)(v19 + 1) >= 3)
  {
    unint64_t v24 = 0;
    uint64_t v25 = v20 >> 1;
    uint64_t v59 = v7 + 32;
    uint64_t v60 = (Class **)(v7 + 16);
    uint64_t v26 = v7 + 40;
    while (1)
    {
      if (v25 == v24) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
      }
      unint64_t v27 = v24 + 1;
      Swift::Int v28 = v19 - (v24 + 1);
      if (__OFSUB__(v19, v24 + 1)) {
        break;
      }
      if (v24 != v28)
      {
        unint64_t v55 = v24 + 1;
        uint64_t v56 = v26;
        uint64_t v57 = v25;
        uint64_t v29 = (uint64_t)v63;
        char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        unint64_t v58 = v29 & 0xC000000000000001;
        char v31 = ((v29 & 0xC000000000000001) == 0) | ~isClassOrObjCExistentialType;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v24, (v29 & 0xC000000000000001) == 0 || (isClassOrObjCExistentialType & 1) == 0);
        if (v31)
        {
          unint64_t v32 = v29
              + ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
              + *(void *)(v7 + 72) * v24;
          uint64_t v54 = *(Class **)(v7 + 16);
          ((void (*)(char *, unint64_t, uint64_t *))v54)(v61, v32, AssociatedTypeWitness);
        }
        else
        {
          id v49 = _ArrayBuffer._getElementSlowPath(_:)(v24, v29, AssociatedTypeWitness);
          uint64_t v21 = v49;
          if (v8 != 8) {
            goto LABEL_29;
          }
          id v62 = v49;
          uint64_t v54 = *v60;
          ((void (*)(char *, id *, uint64_t *))v54)(v61, &v62, AssociatedTypeWitness);
          swift_unknownObjectRelease(v21);
        }
        BOOL v33 = v58 == 0;
        char v34 = v33 | ~_swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v19 - (v24 + 1), v34 & 1);
        if (v34)
        {
          ((void (*)(char *, unint64_t, uint64_t *))v54)(v13, v29+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(void *)(v7 + 72) * v28, AssociatedTypeWitness);
        }
        else
        {
          id v50 = _ArrayBuffer._getElementSlowPath(_:)(v19 - (v24 + 1), v29, AssociatedTypeWitness);
          BOOL v51 = v50;
          if (v8 != 8) {
            goto LABEL_30;
          }
          id v62 = v50;
          ((void (*)(char *, id *, uint64_t *))v54)(v13, &v62, AssociatedTypeWitness);
          swift_unknownObjectRelease(v51);
        }
        (*(void (**)(char *, char *, uint64_t *))(v7 + 32))(v10, v13, AssociatedTypeWitness);
        uint64_t v54 = type metadata accessor for Array(0, (uint64_t)AssociatedTypeWitness, v35, v36);
        Array._makeMutableAndUnique()();
        uint64_t v37 = (uint64_t)v63;
        Array._checkSubscript_mutating(_:)(v24);
        BOOL v38 = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v39 = v37 & 0xFFFFFFFFFFFFFF8;
        if (!v38) {
          uint64_t v39 = v37;
        }
        uint64_t v40 = *(unsigned __int8 *)(v7 + 80);
        unint64_t v58 = (unint64_t)v13;
        uint64_t v41 = v10;
        uint64_t v42 = (v40 + 32) & ~v40;
        uint64_t v21 = *(void **)(v7 + 72);
        unint64_t v43 = v39 + v42 + (void)v21 * v24;
        uint64_t v53 = *(void (**)(unint64_t, char *, uint64_t *))(v7 + 40);
        uint64_t v44 = v56;
        v53(v43, v41, AssociatedTypeWitness);
        Array._makeMutableAndUnique()();
        uint64_t v45 = (uint64_t)v63;
        Array._checkSubscript_mutating(_:)(v28);
        BOOL v46 = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v47 = v45 & 0xFFFFFFFFFFFFFF8;
        if (!v46) {
          uint64_t v47 = v45;
        }
        uint64_t v26 = v44;
        uint64_t v48 = v47 + v42;
        uint64_t v10 = v41;
        uint64_t v13 = (char *)v58;
        v53(v48 + (void)v21 * v28, v61, AssociatedTypeWitness);
        uint64_t v25 = v57;
        unint64_t v27 = v55;
      }
      unint64_t v24 = v27;
      if (v25 == v27) {
        return v63;
      }
    }
    __break(1u);
LABEL_29:
    id v50 = v21;
LABEL_30:
    swift_unknownObjectRelease(v50);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  return v63;
}

uint64_t DiscontiguousSlice._failEarlyRangeCheck(_:bounds:)(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v156 = a1;
  uint64_t v151 = a3;
  uint64_t v139 = *(void *)(a3 - 8);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v138 = (char *)&v127 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v4);
  uint64_t v134 = (char *)&v127 - v6;
  uint64_t v9 = *(void *)(v7 + 24);
  uint64_t v8 = *(int ***)(v7 + 32);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v149 = (char *)&v127 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  unint64_t v148 = (char *)&v127 - v14;
  uint64_t v15 = (char *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v133 = (char *)&v127 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  int64_t v132 = (char *)&v127 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v163 = (char *)&v127 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v162 = (char *)&v127 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v164 = (char *)&v127 - v25;
  MEMORY[0x1F4188790](v24);
  unint64_t v161 = (char *)&v127 - v26;
  Swift::Int v28 = type metadata accessor for DiscontiguousSlice.Index(0, v9, (uint64_t)v8, v27);
  uint64_t v29 = (uint64_t)*(v28 - 1);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  unint64_t v137 = (unint64_t *)((char *)&v127 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  unint64_t v136 = (char *)&v127 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v140 = (char *)&v127 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v143 = (char *)&v127 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  unint64_t v166 = (char *)&v127 - v39;
  MEMORY[0x1F4188790](v38);
  uint64_t v41 = (char *)&v127 - v40;
  uint64_t v152 = v9;
  uint64_t v153 = v8;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v44 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v43);
  uint64_t v158 = (uint64_t)*(v44 - 1);
  unint64_t v159 = v44;
  uint64_t v45 = MEMORY[0x1F4188790](v44);
  uint64_t v131 = (char *)&v127 - ((v46 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  uint64_t v130 = (uint64_t)&v127 - v48;
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  unint64_t v147 = (char *)&v127 - v50;
  MEMORY[0x1F4188790](v49);
  unint64_t v157 = (char *)&v127 - v51;
  uint64_t v141 = v29;
  uint64_t v52 = *(void (**)(char *, uint64_t *, Class *))(v29 + 16);
  v52(v41, a2, v28);
  uint64_t v53 = (void (*)(char *, char *, const char *))*((void *)v15 + 4);
  uint64_t v54 = v161;
  v53(v161, &v41[*((int *)v28 + 9)], AssociatedTypeWitness);
  uint64_t v56 = *((int *)type metadata accessor for Range(0, (uint64_t)v28, (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index, v55)+ 9);
  unint64_t v150 = a2;
  uint64_t v57 = (uint64_t *)((char *)a2 + v56);
  unint64_t v58 = v166;
  unint64_t v145 = v57;
  uint64_t v154 = v52;
  uint64_t v155 = v29 + 16;
  ((void (*)(char *))v52)(v166);
  uint64_t v59 = &v58[*((int *)v28 + 9)];
  uint64_t v60 = (uint64_t)v164;
  unint64_t v146 = v53;
  v53((char *)v164, v59, AssociatedTypeWitness);
  unint64_t v166 = v15;
  unint64_t v61 = v15 + 16;
  id v62 = (void (*)(char *, char *, const char *))*((void *)v15 + 2);
  uint64_t v63 = v162;
  v62(v162, v54, AssociatedTypeWitness);
  uint64_t v64 = v163;
  v62(v163, (char *)v60, AssociatedTypeWitness);
  uint64_t v65 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24);
  if ((v65(v63, v64, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_14;
  }
  uint64_t v128 = (uint64_t (*)(uint64_t, char *, uint64_t, uint64_t))v65;
  uint64_t v129 = AssociatedConformanceWitness + 24;
  uint64_t v142 = v28;
  uint64_t v135 = AssociatedConformanceWitness;
  uint64_t v67 = v166 + 8;
  uint64_t v66 = (void (*)(char *, const char *))*((void *)v166 + 1);
  unint64_t v165 = v66;
  v66(v163, AssociatedTypeWitness);
  v66(v162, AssociatedTypeWitness);
  uint64_t v68 = TupleTypeMetadata2;
  uint64_t v69 = v148;
  uint64_t v70 = &v148[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v71 = (void (*)(char *, const char *, const char *))v146;
  v146(v148, v161, AssociatedTypeWitness);
  v71(v70, v164, AssociatedTypeWitness);
  BOOL v72 = v149;
  uint64_t v73 = &v149[*((int *)v68 + 12)];
  v62(v149, v69, AssociatedTypeWitness);
  char v162 = (char *)v62;
  uint64_t v163 = v61;
  v62(v73, v70, AssociatedTypeWitness);
  uint64_t v74 = v147;
  v71(v147, v72, AssociatedTypeWitness);
  v165(v73, AssociatedTypeWitness);
  uint64_t v75 = &v72[*((int *)TupleTypeMetadata2 + 12)];
  v71(v72, v69, AssociatedTypeWitness);
  v71(v75, v70, AssociatedTypeWitness);
  uint64_t v76 = v159;
  v71(&v74[*((int *)v159 + 9)], v75, AssociatedTypeWitness);
  unint64_t v164 = AssociatedTypeWitness;
  unint64_t v166 = v67;
  v165(v72, AssociatedTypeWitness);
  uint64_t v77 = v157;
  uint64_t v78 = *(void (**)(char *, char *, Class *))(v158 + 32);
  v78(v157, v74, v76);
  uint64_t v79 = *v150;
  uint64_t v80 = *v145;
  if (*v145 < *v150) {
LABEL_14:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v81 = v142;
  uint64_t v82 = v156;
  uint64_t v84 = v152;
  uint64_t v83 = v153;
  uint64_t v85 = v77;
  uint64_t v86 = v144;
  ((void (*)(char *, char *, uint64_t, int **))v153[20])((char *)v156 + *((int *)v142 + 9), v85, v152, v153);
  uint64_t v87 = v143;
  v154(v143, v82, v81);
  if (*v87 < v79 || *v87 >= v80) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x106uLL, 0);
  }
  unint64_t v161 = (char *)v78;
  uint64_t v89 = v141 + 8;
  char v88 = *(void (**)(char *, Class *))(v141 + 8);
  v88((char *)v87, v81);
  uint64_t v90 = *v82;
  uint64_t v91 = v84;
  uint64_t v92 = *(void *)(*(void *)(v86 + *(int *)(v151 + 36)) + 16);
  uint64_t v93 = (uint64_t *)v83[9];
  uint64_t v94 = v140;
  uint64_t v95 = v83;
  uint64_t v96 = v88;
  TupleTypeMetadata2 = v93;
  ((void (*)(uint64_t, int **))v93)(v91, v95);
  char *v94 = v92;
  v88((char *)v94, v81);
  if (v90 == v92)
  {
    int v97 = v136;
    v154(v136, v156, v81);
    uint64_t v98 = v151;
    uint64_t v99 = v139;
    int64_t v100 = v134;
    (*(void (**)(char *, uint64_t, uint64_t))(v139 + 16))(v134, v86, v151);
    uint64_t v101 = &v97[*((int *)v81 + 9)];
    uint64_t v102 = v132;
    ((void (*)(uint64_t, int **))TupleTypeMetadata2)(v152, v153);
    uint64_t v103 = (uint64_t)v164;
    LOBYTE(v101) = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(v135 + 8) + 8))(v101, v102, v164);
    v165(v102, (const char *)v103);
    if ((v101 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x108uLL, 0);
    }
    (*(void (**)(char *, uint64_t))(v99 + 8))(v100, v98);
    v96(v136, v81);
    return (*(uint64_t (**)(char *, Class *))(v158 + 8))(v157, v159);
  }
  else
  {
    TupleTypeMetadata2 = (uint64_t *)v88;
    uint64_t v141 = v89;
    uint64_t v105 = v139;
    uint64_t v106 = v138;
    uint64_t v107 = v86;
    uint64_t v108 = v151;
    (*(void (**)(char *, uint64_t, uint64_t))(v139 + 16))(v138, v107, v151);
    unint64_t v109 = v137;
    v154((char *)v137, v156, v81);
    uint64_t v110 = *(void *)&v106[*(int *)(v108 + 36)];
    unint64_t v111 = *v109;
    uint64_t v167 = v110;
    uint64_t v112 = (uint64_t)v164;
    uint64_t v113 = v135;
    uint64_t v115 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)v164, v135, v114);
    uint64_t v116 = v130;
    RangeSet.Ranges.subscript.getter(v111, (uint64_t)v115, v117, v130);
    uint64_t v118 = (char *)v109 + *((int *)v81 + 9);
    LOBYTE(v108) = v128(v116, v118, v112, v113);
    uint64_t v119 = v133;
    ((void (*)(char *, char *, uint64_t))v162)(v133, v118, v112);
    uint64_t v120 = v131;
    uint64_t v121 = v116;
    uint64_t v122 = v159;
    ((void (*)(char *, uint64_t, Class *))v161)(v131, v121, v159);
    if (v108)
    {
      char v123 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v113 + 16))(v119, &v120[*((int *)v122 + 9)], v112, v113);
      uint64_t v124 = v120;
      char v125 = v123;
    }
    else
    {
      uint64_t v124 = v120;
      char v125 = 0;
    }
    unint64_t v126 = *(void (**)(char *, Class *))(v158 + 8);
    v126(v124, v122);
    v165(v119, (const char *)v112);
    if ((v125 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x10AuLL, 0);
    }
    ((void (*)(unint64_t *, Class *))TupleTypeMetadata2)(v137, v81);
    (*(void (**)(char *, uint64_t))(v105 + 8))(v138, v151);
    return ((uint64_t (*)(char *, Class *))v126)(v157, v122);
  }
}

uint64_t DiscontiguousSlice._failEarlyRangeCheck(_:bounds:)(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v155 = a1;
  unint64_t v160 = a2;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v4 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v157 = AssociatedConformanceWitness;
  uint64_t v128 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v8);
  uint64_t v127 = (uint64_t)*(v128 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v128);
  unint64_t v126 = (char *)v122 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  char v125 = (char *)v122 - v12;
  uint64_t v148 = a3;
  uint64_t v135 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v131 = (char *)v122 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  int64_t v132 = (char *)v122 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v144 = (char *)v122 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v143 = (char *)v122 - v19;
  uint64_t v20 = (char *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v124 = (char *)v122 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v130 = (char *)v122 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)v122 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  unint64_t v146 = (char *)v122 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  unint64_t v159 = (char *)v122 - v31;
  MEMORY[0x1F4188790](v30);
  uint64_t v158 = (char *)v122 - v32;
  uint64_t v138 = v5;
  uint64_t v139 = v4;
  uint64_t v34 = type metadata accessor for DiscontiguousSlice.Index(0, v5, (uint64_t)v4, v33);
  uint64_t v35 = (uint64_t)*(v34 - 1);
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v134 = (char *)v122 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v129 = (char *)v122 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  uint64_t v133 = (uint64_t **)((char *)v122 - v41);
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  unint64_t v136 = (char *)v122 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  unint64_t v161 = (char *)v122 - v45;
  MEMORY[0x1F4188790](v44);
  uint64_t v47 = (char *)v122 - v46;
  uint64_t v49 = type metadata accessor for ClosedRange(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v48);
  uint64_t v153 = (uint64_t)*(v49 - 1);
  uint64_t v154 = v49;
  uint64_t v50 = MEMORY[0x1F4188790](v49);
  uint64_t v142 = (char *)v122 - ((v51 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v50);
  uint64_t v152 = (char *)v122 - v52;
  uint64_t v147 = v35;
  uint64_t v54 = v35 + 16;
  uint64_t v53 = *(void (**)(char *, uint64_t *, Class *))(v35 + 16);
  uint64_t v55 = v160;
  v53(v47, v160, v34);
  uint64_t v56 = v20;
  uint64_t v57 = (void (*)(char *, char *, const char *))*((void *)v20 + 4);
  unint64_t v58 = v158;
  v57(v158, &v47[*((int *)v34 + 9)], AssociatedTypeWitness);
  uint64_t v60 = (uint64_t *)((char *)v55
                  + *((int *)type metadata accessor for ClosedRange(0, (uint64_t)v34, (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index, v59)+ 9));
  unint64_t v61 = v161;
  uint64_t v140 = v60;
  unint64_t v150 = (void (*)(char *, uint64_t **, Class *))v53;
  uint64_t v151 = v54;
  ((void (*)(char *))v53)(v161);
  unint64_t v137 = v34;
  id v62 = &v61[*((int *)v34 + 9)];
  uint64_t v63 = v159;
  uint64_t v141 = (void (*)(void, void, void))v57;
  v57(v159, v62, AssociatedTypeWitness);
  unint64_t v161 = v56;
  uint64_t v64 = v56 + 16;
  uint64_t v65 = (void (*)(char *, char *, const char *))*((void *)v56 + 2);
  uint64_t v66 = v146;
  v65(v146, v58, AssociatedTypeWitness);
  v65(v27, v63, AssociatedTypeWitness);
  uint64_t v67 = v157 + 24;
  uint64_t v68 = *(uint64_t (**)(char *, char *, const char *))(v157 + 24);
  if ((v68(v66, v27, AssociatedTypeWitness) & 1) == 0) {
    goto LABEL_15;
  }
  v122[0] = v68;
  v122[1] = v67;
  uint64_t v69 = (void (*)(void, void))*((void *)v161 + 1);
  unint64_t v149 = v69;
  v161 += 8;
  v69(v27, AssociatedTypeWitness);
  v69(v66, AssociatedTypeWitness);
  uint64_t v70 = v144;
  uint64_t v71 = TupleTypeMetadata2;
  BOOL v72 = v143;
  uint64_t v73 = &v143[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v74 = (void (*)(char *, char *, const char *))v141;
  v141(v143, v158, AssociatedTypeWitness);
  unint64_t v146 = v73;
  v74(v73, v159, AssociatedTypeWitness);
  uint64_t v75 = &v70[*((int *)v71 + 12)];
  v65(v70, v72, AssociatedTypeWitness);
  uint64_t v158 = v64;
  char v123 = (void (*)(char *, char *, char *))v65;
  v65(v75, v73, AssociatedTypeWitness);
  uint64_t v76 = v142;
  v74(v142, v70, AssociatedTypeWitness);
  uint64_t v77 = v75;
  uint64_t v78 = (void (*)(char *, const char *))v149;
  v149(v77, AssociatedTypeWitness);
  uint64_t v79 = &v70[*((int *)v71 + 12)];
  v74(v70, v72, AssociatedTypeWitness);
  v74(v79, v146, AssociatedTypeWitness);
  uint64_t v80 = v154;
  v74(&v76[*((int *)v154 + 9)], v79, AssociatedTypeWitness);
  unint64_t v159 = (char *)AssociatedTypeWitness;
  v78(v70, AssociatedTypeWitness);
  uint64_t v81 = v152;
  (*(void (**)(char *, char *, Class *))(v153 + 32))(v152, v76, v80);
  uint64_t v82 = *v160;
  uint64_t v83 = *v140;
  if (*v140 < *v160) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  uint64_t v84 = v137;
  uint64_t v85 = v155;
  uint64_t v86 = v139;
  uint64_t v87 = v81;
  uint64_t v88 = v156;
  uint64_t v89 = v138;
  ((void (*)(char *, char *, uint64_t, int **))v139[21])((char *)v155 + *((int *)v137 + 9), v87, v138, v139);
  uint64_t v90 = v136;
  v150(v136, v85, v84);
  if (*v90 < v82 || v83 < *v90) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x113uLL, 0);
  }
  uint64_t v91 = v84;
  uint64_t v92 = v147 + 8;
  uint64_t v93 = *(char **)(v147 + 8);
  ((void (*)(void *, Class *))v93)(v90, v91);
  unint64_t v160 = *v85;
  uint64_t v94 = *(uint64_t **)(*(void *)(v88 + *(int *)(v148 + 36)) + 16);
  uint64_t v95 = v86[9];
  uint64_t v96 = v133;
  ((void (*)(uint64_t, int **))v95)(v89, v86);
  void *v96 = v94;
  unint64_t v146 = v93;
  uint64_t v147 = v92;
  ((void (*)(uint64_t **, Class *))v93)(v96, v91);
  if (v160 != v94)
  {
    uint64_t v103 = v131;
    uint64_t v104 = v148;
    (*(void (**)(char *, uint64_t, uint64_t))(v135 + 16))(v131, v156, v148);
    uint64_t v105 = (unint64_t *)v134;
    v150(v134, v155, v91);
    unint64_t v106 = *v105;
    uint64_t v107 = v159;
    if ((*v105 & 0x8000000000000000) != 0
      || (uint64_t v108 = *(void *)&v103[*(int *)(v104 + 36)], v106 >= *(void *)(v108 + 16)))
    {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
    unint64_t v109 = v91;
    uint64_t v110 = v127;
    unint64_t v111 = v125;
    uint64_t v112 = v128;
    (*(void (**)(char *, unint64_t, Class *))(v127 + 16))(v125, v108+ ((*(unsigned __int8 *)(v127 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v127 + 80))+ *(void *)(v127 + 72) * v106, v128);
    uint64_t v113 = &v134[*((int *)v109 + 9)];
    uint64_t v114 = v157;
    char v115 = ((uint64_t (*)(char *, char *, char *, uint64_t))v122[0])(v111, v113, v107, v157);
    uint64_t v116 = v124;
    v123(v124, v113, v107);
    uint64_t v117 = v110;
    uint64_t v118 = *(void (**)(char *, char *, Class *))(v110 + 32);
    uint64_t v119 = v126;
    v118(v126, v111, v112);
    if (v115)
    {
      char v120 = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v114 + 16))(v116, &v119[*((int *)v112 + 9)], v107, v114);
      (*(void (**)(char *, Class *))(v117 + 8))(v119, v112);
      v149(v116, v107);
      if (v120)
      {
        ((void (*)(char *, Class *))v146)(v134, v109);
        (*(void (**)(char *, uint64_t))(v135 + 8))(v131, v148);
        return (*(uint64_t (**)(char *, Class *))(v153 + 8))(v152, v154);
      }
    }
    else
    {
      (*(void (**)(char *, Class *))(v117 + 8))(v119, v112);
      v149(v116, v107);
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x117uLL, 0);
  }
  int v97 = v86;
  uint64_t v98 = v129;
  v150(v129, v155, v91);
  uint64_t v99 = v135;
  (*(void (**)(char *, uint64_t, uint64_t))(v135 + 16))(v132, v156, v148);
  int64_t v100 = &v98[*((int *)v91 + 9)];
  uint64_t v101 = v130;
  ((void (*)(uint64_t, int **))v95)(v89, v97);
  uint64_t v102 = v159;
  LOBYTE(v100) = (*(uint64_t (**)(char *, char *, char *))(*(void *)(v157 + 8) + 8))(v100, v101, v159);
  v149(v101, v102);
  if ((v100 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x115uLL, 0);
  }
  (*(void (**)(char *, uint64_t))(v99 + 8))(v132, v148);
  ((void (*)(char *, Class *))v146)(v98, v91);
  return (*(uint64_t (**)(char *, Class *))(v153 + 8))(v152, v154);
}

uint64_t DiscontiguousSlice._failEarlyRangeCheck(_:bounds:)(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v244 = a2;
  Swift::String::Index v236 = a1;
  uint64_t v234 = a3;
  uint64_t v233 = *(void *)(a3 - 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  unint64_t v204 = (char *)&v200 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = MEMORY[0x1F4188790](v3);
  unint64_t v203 = (char *)&v200 - v6;
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  unint64_t v211 = (char *)&v200 - v8;
  MEMORY[0x1F4188790](v7);
  char v209 = (char *)&v200 - v9;
  uint64_t v12 = *(void *)(v10 + 24);
  uint64_t v11 = *(int ***)(v10 + 32);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v14 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v243 = (char *)&v200 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v242 = (char *)&v200 - v17;
  uint64_t v18 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  char v202 = (char *)&v200 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  unint64_t v207 = (char *)&v200 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v212 = (char *)&v200 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int v224 = (char *)&v200 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v223 = (char *)&v200 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  int64_t v241 = (char *)&v200 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  Swift::Int v240 = (char *)&v200 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  Swift::String::Index v230 = (char *)&v200 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  Swift::Int v229 = (char *)&v200 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v245 = (char *)&v200 - v38;
  MEMORY[0x1F4188790](v37);
  uint64_t v40 = (char *)&v200 - v39;
  uint64_t v42 = type metadata accessor for DiscontiguousSlice.Index(0, v12, (uint64_t)v11, v41);
  uint64_t v43 = (uint64_t)*(v42 - 1);
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  uint64_t v215 = (char *)&v200 - ((v45 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  char v222 = (char **)((char *)&v200 - v47);
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  unint64_t v221 = (char *)&v200 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  uint64_t v254 = (char *)&v200 - v51;
  MEMORY[0x1F4188790](v50);
  uint64_t v53 = (char *)&v200 - v52;
  Swift::String::Index v227 = v11;
  uint64_t v226 = v12;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v11, v12, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v253 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v54);
  uint64_t v249 = *(v253 - 1);
  uint64_t v55 = MEMORY[0x1F4188790](v253);
  uint64_t v201 = (char *)&v200 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  uint64_t v200 = (char *)&v200 - v58;
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  unint64_t v213 = (char *)&v200 - v60;
  uint64_t v61 = MEMORY[0x1F4188790](v59);
  uint64_t v210 = (char *)&v200 - v62;
  uint64_t v63 = MEMORY[0x1F4188790](v61);
  unint64_t v206 = (char *)&v200 - v64;
  uint64_t v65 = MEMORY[0x1F4188790](v63);
  unint64_t v205 = (char *)&v200 - v66;
  uint64_t v67 = MEMORY[0x1F4188790](v65);
  id v214 = (char *)&v200 - v68;
  uint64_t v69 = MEMORY[0x1F4188790](v67);
  unint64_t v208 = (char *)&v200 - v70;
  uint64_t v71 = MEMORY[0x1F4188790](v69);
  unint64_t v246 = (char *)&v200 - v72;
  uint64_t v73 = MEMORY[0x1F4188790](v71);
  Swift::Int v239 = (char *)&v200 - v74;
  MEMORY[0x1F4188790](v73);
  uint64_t v247 = (char *)&v200 - v75;
  uint64_t v225 = v43;
  uint64_t v76 = *(void (**)(char *, uint64_t *, Class *))(v43 + 16);
  uint64_t v77 = v244;
  v76(v53, v244, v42);
  uint64_t v78 = &v53[*((int *)v42 + 9)];
  uint64_t v79 = *(void (**)(char *, char *, const char *))(v18 + 32);
  v79(v40, v78, AssociatedTypeWitness);
  size_t v217 = type metadata accessor for Range(0, (uint64_t)v42, (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index, v80);
  uint64_t v81 = (uint64_t *)((char *)v77 + *((int *)v217 + 9));
  uint64_t v82 = v254;
  uint64_t v219 = v43 + 16;
  unint64_t v218 = v76;
  v76(v254, v81, v42);
  Swift::String::Index v235 = v42;
  uint64_t v83 = &v82[*((int *)v42 + 9)];
  uint64_t v84 = v245;
  uint64_t v237 = v18 + 32;
  Swift::String::Index v238 = v79;
  v79(v245, v83, AssociatedTypeWitness);
  uint64_t v85 = v18;
  uint64_t v87 = v18 + 16;
  uint64_t v86 = *(void (**)(char *, char *, const char *))(v18 + 16);
  uint64_t v88 = v229;
  unint64_t v220 = v40;
  v86(v229, v40, AssociatedTypeWitness);
  uint64_t v89 = v230;
  v86(v230, v84, AssociatedTypeWitness);
  uint64_t v90 = (char *)(AssociatedConformanceWitness + 24);
  uint64_t v91 = v88;
  uint64_t v92 = v88;
  uint64_t v93 = v89;
  Swift::String::Index v232 = *(uint64_t (**)(char *, char *, const char *))(AssociatedConformanceWitness + 24);
  if ((v232(v92, v89, AssociatedTypeWitness) & 1) == 0) {
    goto LABEL_28;
  }
  uint64_t v216 = v81;
  uint64_t v94 = *(void (**)(char *, const char *))(v85 + 8);
  uint64_t v250 = v94;
  uint64_t v254 = (char *)(v85 + 8);
  v94(v93, AssociatedTypeWitness);
  v94(v91, AssociatedTypeWitness);
  uint64_t v95 = TupleTypeMetadata2;
  uint64_t v96 = AssociatedTypeWitness;
  int v97 = v242;
  uint64_t v98 = &v242[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v99 = v238;
  Swift::String::Index v230 = v90;
  v238(v242, v220, AssociatedTypeWitness);
  v99(v98, v245, AssociatedTypeWitness);
  uint64_t v100 = *((int *)v95 + 12);
  uint64_t v248 = v87;
  uint64_t v101 = v243;
  uint64_t v102 = &v243[v100];
  Swift::String::Index v231 = v86;
  v86(v243, v97, AssociatedTypeWitness);
  v86(v102, v98, AssociatedTypeWitness);
  uint64_t v103 = v239;
  v99(v239, v101, AssociatedTypeWitness);
  uint64_t v104 = v250;
  v250(v102, v96);
  uint64_t v105 = &v101[*((int *)v95 + 12)];
  v99(v101, v97, v96);
  v99(v105, v98, v96);
  unint64_t v106 = v253;
  v99(&v103[*((int *)v253 + 9)], v105, v96);
  v104(v101, v96);
  uint64_t v107 = (char *)v249[4];
  uint64_t v245 = (char *)(v249 + 4);
  Swift::Int v229 = v107;
  ((void (*)(char *, char *, Class *))v107)(v247, v103, v106);
  uint64_t v108 = v221;
  uint64_t v110 = v235;
  unint64_t v109 = v236;
  unint64_t v111 = v218;
  v218(v221, v236, v235);
  uint64_t v112 = v240;
  v99(v240, &v108[*((int *)v110 + 9)], v96);
  uint64_t v113 = (void *)((char *)v109 + *((int *)v217 + 9));
  uint64_t v114 = v222;
  v111((char *)v222, v113, v110);
  char v115 = (char *)v114 + *((int *)v110 + 9);
  uint64_t v116 = v241;
  v99(v241, v115, v96);
  uint64_t v117 = v231;
  uint64_t v118 = v223;
  v231(v223, v112, v96);
  uint64_t v119 = v224;
  v117(v224, v116, v96);
  if ((((uint64_t (*)(char *, char *, const char *, uint64_t))v232)(v118, v119, v96, AssociatedConformanceWitness) & 1) == 0)goto LABEL_28; {
  char v222 = v113;
  }
  char v120 = v250;
  v250(v119, v96);
  v120(v118, v96);
  uint64_t v121 = TupleTypeMetadata2;
  uint64_t v122 = v242;
  char v123 = &v242[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v124 = v238;
  v238(v242, v240, v96);
  v124(v123, v241, v96);
  char v125 = v243;
  unint64_t v126 = &v243[*((int *)v121 + 12)];
  v117(v243, v122, v96);
  v117(v126, v123, v96);
  uint64_t v127 = v239;
  v124(v239, v125, v96);
  v120(v126, v96);
  uint64_t v128 = &v125[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v129 = v122;
  uint64_t v130 = v96;
  v124(v125, v129, v96);
  v124(v128, v123, v96);
  uint64_t v131 = v253;
  v124(&v127[*((int *)v253 + 9)], v128, v96);
  v120(v125, v96);
  int64_t v132 = v246;
  ((void (*)(char *, char *, Class *))v229)(v246, v127, v131);
  uint64_t v133 = *v244;
  uint64_t v134 = *v216;
  if (*v216 < *v244 || (uint64_t v135 = *v236, v136 = (uint64_t *)*v222, *v222 < *v236)) {
LABEL_28:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  unint64_t v137 = v227;
  uint64_t v138 = v228;
  uint64_t v139 = v226;
  ((void (*)(char *, char *, uint64_t, int **))v227[22])(v132, v247, v226, v227);
  if (v135 < v133 || v135 >= v134) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x124uLL, 0);
  }
  if (v134 < (uint64_t)v136) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x125uLL, 0);
  }
  uint64_t v244 = v136;
  uint64_t v140 = v234;
  uint64_t v141 = v235;
  uint64_t v243 = (char *)*(int *)(v234 + 36);
  uint64_t v142 = *(void *)(*(void *)&v243[v138] + 16);
  uint64_t v143 = v215;
  TupleTypeMetadata2 = (uint64_t *)v137[9];
  ((void (*)(uint64_t, int **))TupleTypeMetadata2)(v139, v137);
  *uint64_t v143 = v142;
  uint64_t v144 = *(char **)(v225 + 8);
  v225 += 8;
  uint64_t v242 = v144;
  ((void (*)(void *, Class *))v144)(v143, v141);
  if (v135 == v142)
  {
    uint64_t v145 = v139;
    uint64_t v146 = v140;
    uint64_t v147 = v208;
    Swift::Int v240 = (char *)v249[2];
    ((void (*)(char *, char *, Class *))v240)(v208, v246, v253);
    uint64_t v148 = v233;
    unint64_t v149 = v209;
    int64_t v241 = *(char **)(v233 + 16);
    ((void (*)(char *, uint64_t, uint64_t))v241)(v209, v138, v146);
    unint64_t v150 = v212;
    ((void (*)(uint64_t, int **))TupleTypeMetadata2)(v145, v137);
    LOBYTE(v146) = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                           + 8))(v147, v150, v130);
    v250(v150, v130);
    if ((v146 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x128uLL, 0);
    }
    Swift::String::Index v238 = *(void (**)(char *, char *, const char *))(v148 + 8);
    ((void (*)(char *, uint64_t))v238)(v149, v234);
    Swift::Int v239 = (char *)v249[1];
    ((void (*)(char *, Class *))v239)(v147, v253);
  }
  else
  {
    uint64_t v151 = *(void (**)(char *, uint64_t, uint64_t))(v233 + 16);
    uint64_t v152 = v211;
    v151(v211, v138, v140);
    uint64_t v153 = v249;
    uint64_t v154 = (void (*)(char *, char *, Class *))v249[2];
    uint64_t v155 = v253;
    v154(v214, v246, v253);
    if (v135 < 0) {
      goto LABEL_30;
    }
    uint64_t v156 = *(void *)&v152[*(int *)(v140 + 36)];
    if ((unint64_t)v135 >= *(void *)(v156 + 16)) {
      goto LABEL_30;
    }
    int64_t v241 = (char *)v151;
    uint64_t v157 = v205;
    v154(v205, (char *)(v156+ ((*((unsigned __int8 *)v153 + 80) + 32) & ~(unint64_t)*((unsigned __int8 *)v153 + 80))+ v153[9] * v135), v155);
    uint64_t v158 = v214;
    uint64_t v159 = AssociatedConformanceWitness;
    char v160 = ((uint64_t (*)(char *, char *, const char *, uint64_t))v232)(v157, v214, v130, AssociatedConformanceWitness);
    unint64_t v161 = v207;
    v231(v207, v158, v130);
    char v162 = v206;
    ((void (*)(char *, char *, Class *))v229)(v206, v157, v155);
    if (v160) {
      char v163 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v159 + 16))(v161, &v162[*((int *)v155 + 9)], v130, v159);
    }
    else {
      char v163 = 0;
    }
    unint64_t v164 = (void (*)(char *, Class *))v249[1];
    v164(v162, v155);
    v250(v161, v130);
    uint64_t v165 = v234;
    if ((v163 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x12AuLL, 0);
    }
    Swift::Int v240 = (char *)v154;
    Swift::Int v239 = (char *)v164;
    v164(v214, v155);
    Swift::String::Index v238 = *(void (**)(char *, char *, const char *))(v233 + 8);
    ((void (*)(char *, uint64_t))v238)(v211, v165);
  }
  uint64_t v166 = v228;
  uint64_t v167 = *(uint64_t **)(*(void *)&v243[v228] + 16);
  uint64_t v168 = v235;
  uint64_t v169 = (uint64_t **)v215;
  uint64_t v170 = v226;
  unint64_t v171 = v227;
  unint64_t v172 = TupleTypeMetadata2;
  ((void (*)(uint64_t, int **))TupleTypeMetadata2)(v226, v227);
  *uint64_t v169 = v167;
  ((void (*)(uint64_t **, Class *))v242)(v169, v168);
  unint64_t v173 = (unint64_t)v244;
  if (v244 == v167)
  {
    unint64_t v174 = v210;
    unint64_t v175 = v253;
    ((void (*)(char *, char *, Class *))v240)(v210, v246, v253);
    Swift::Int v176 = v203;
    ((void (*)(char *, uint64_t, uint64_t))v241)(v203, v166, v234);
    int64_t v177 = &v174[*((int *)v175 + 9)];
    unint64_t v178 = v212;
    ((void (*)(uint64_t, int **))v172)(v170, v171);
    LOBYTE(v177) = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                           + 8))(v177, v178, v130);
    v250(v178, v130);
    if ((v177 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x12FuLL, 0);
    }
    ((void (*)(char *, uint64_t))v238)(v176, v234);
    int64_t v179 = (void (*)(char *, Class *))v239;
    ((void (*)(char *, Class *))v239)(v210, v175);
    char v180 = v175;
    uint64_t v181 = v246;
    size_t v182 = v247;
    goto LABEL_27;
  }
  unint64_t v183 = v204;
  uint64_t v184 = v166;
  uint64_t v185 = v234;
  ((void (*)(char *, uint64_t, uint64_t))v241)(v204, v184, v234);
  unint64_t v186 = v249;
  uint64_t v181 = v246;
  char v180 = v253;
  Swift::String::Index v187 = (void (*)(char *, unint64_t, Class *))v240;
  ((void (*)(char *, char *, Class *))v240)(v213, v246, v253);
  if ((v173 & 0x8000000000000000) != 0
    || (uint64_t v188 = *(void *)&v183[*(int *)(v185 + 36)], v173 >= *(void *)(v188 + 16)))
  {
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
  unint64_t v189 = v188
       + ((*((unsigned __int8 *)v186 + 80) + 32) & ~(unint64_t)*((unsigned __int8 *)v186 + 80))
       + v186[9] * v173;
  Swift::String::Index v190 = v200;
  v187(v200, v189, v180);
  unint64_t v191 = &v213[*((int *)v180 + 9)];
  uint64_t v192 = AssociatedConformanceWitness;
  char v193 = ((uint64_t (*)(char *, char *, const char *, uint64_t))v232)(v190, v191, v130, AssociatedConformanceWitness);
  unint64_t v194 = v202;
  v231(v202, v191, v130);
  unint64_t v195 = v201;
  ((void (*)(char *, char *, Class *))v229)(v201, v190, v180);
  if (v193)
  {
    char v196 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v192 + 16))(v194, &v195[*((int *)v180 + 9)], v130, v192);
    unint64_t v197 = v195;
    char v198 = v196;
  }
  else
  {
    unint64_t v197 = v195;
    char v198 = 0;
  }
  size_t v182 = v247;
  int64_t v179 = (void (*)(char *, Class *))v239;
  ((void (*)(char *, Class *))v239)(v197, v180);
  v250(v194, v130);
  if ((v198 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x131uLL, 0);
  }
  v179(v213, v180);
  ((void (*)(char *, uint64_t))v238)(v183, v234);
LABEL_27:
  v179(v181, v180);
  return ((uint64_t (*)(char *, Class *))v179)(v182, v180);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance DiscontiguousSlice<A>(const char ***a1, unint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = (const char **)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (const char *)DiscontiguousSlice.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*DiscontiguousSlice.subscript.read(const char **a1, unint64_t *a2, uint64_t a3))()
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  *a1 = AssociatedTypeWitness;
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  a1[1] = (const char *)v7;
  uint64_t v8 = (const char *)malloc(*(void *)(v7 + 64));
  a1[2] = v8;
  DiscontiguousSlice.subscript.getter(a2, a3, (uint64_t)v8);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance DiscontiguousSlice<A>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for DiscontiguousSlice.Index(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  uint64_t v7 = (uint64_t)*(v6 - 1);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)&v11 - v8;
  DiscontiguousSlice.index(after:)(a1, a2, (uint64_t *)((char *)&v11 - v8));
  (*(void (**)(uint64_t *, Class *))(v7 + 8))(a1, v6);
  return (*(uint64_t (**)(uint64_t *, char *, Class *))(v7 + 32))(a1, v9, v6);
}

uint64_t DiscontiguousSlice<>.index(before:)@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v131 = a1;
  uint64_t v4 = a2;
  uint64_t v112 = a4;
  uint64_t v108 = a3;
  uint64_t v5 = *(int ***)(a3 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v110 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v109 = (char *)&v98 - v7;
  uint64_t v8 = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v123 = type metadata accessor for Range(0, (uint64_t)v8, AssociatedConformanceWitness, v10);
  uint64_t v121 = (uint64_t)*(v123 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v123);
  uint64_t v100 = (char *)&v98 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  unint64_t v106 = (char *)&v98 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v105 = (char *)&v98 - v16;
  uint64_t v124 = *((void *)v8 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  char v115 = (char *)&v98 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v98 - v20;
  uint64_t v22 = *(void *)(v4 - 8);
  uint64_t v23 = MEMORY[0x1F4188790](v19);
  char v120 = (char *)&v98 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v98 - v25;
  char v125 = v5;
  uint64_t v126 = v6;
  uint64_t v28 = type metadata accessor for DiscontiguousSlice.Index(0, v6, (uint64_t)v5, v27);
  uint64_t v29 = (uint64_t)*(v28 - 1);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v127 = (char *)&v98 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v34 = (char *)&v98 - v33;
  MEMORY[0x1F4188790](v32);
  uint64_t v36 = (char *)&v98 - v35;
  uint64_t v117 = *(void (**)(char *, void *, Class *))(v29 + 16);
  uint64_t v118 = v29 + 16;
  v117((char *)&v98 - v35, v131, v28);
  uint64_t v130 = v22;
  uint64_t v116 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  v116(v26, v132, v4);
  uint64_t v119 = v4;
  DiscontiguousSlice.startIndex.getter(v4, v37, v34);
  uint64_t v38 = *((int *)v28 + 9);
  uint64_t v39 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v129 = v8;
  uint64_t v122 = (char *)AssociatedConformanceWitness;
  LOBYTE(v4) = v39(&v34[v38], &v36[v38], v8, AssociatedConformanceWitness);
  uint64_t v40 = *(void (**)(char *, Class *))(v29 + 8);
  unint64_t v128 = v29 + 8;
  v40(v34, v28);
  if ((v4 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't move index before startIndex", 34, 2, "Swift/DiscontiguousSlice.swift", 30, 2, 0x13CuLL, 0);
  }
  uint64_t v41 = *(void (**)(char *, uint64_t))(v130 + 8);
  uint64_t v42 = v119;
  v130 += 8;
  uint64_t v113 = v41;
  v41(v26, v119);
  uint64_t v114 = (uint64_t (*)(char *, Class *))v40;
  v40(v36, v28);
  uint64_t v44 = v131;
  uint64_t v43 = v132;
  uint64_t v45 = (char *)v131 + *((int *)v28 + 9);
  ((void (*)(uint64_t))v125[9])(v126);
  uint64_t v46 = *((void *)v122 + 1);
  uint64_t v47 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v46 + 8);
  uint64_t v99 = v45;
  uint64_t v48 = v129;
  uint64_t v104 = v46;
  uint64_t v103 = v46 + 8;
  uint64_t v102 = v47;
  char v49 = ((uint64_t (*)(char *, char *, const char *))v47)(v45, v21, v129);
  uint64_t v50 = v124;
  uint64_t v51 = *(uint64_t (**)(char *, const char *))(v124 + 8);
  uint64_t v122 = v21;
  uint64_t v101 = v51;
  v51(v21, v48);
  v117(v127, v44, v28);
  uint64_t v52 = v120;
  v116(v120, v43, v42);
  uint64_t v107 = v28;
  if (v49)
  {
    v113(v52, v42);
    uint64_t result = v114(v127, v28);
    uint64_t v54 = v129;
  }
  else
  {
    uint64_t v55 = v50;
    uint64_t v56 = (unint64_t *)v127;
    uint64_t v57 = *(void (**)(char *, char *, const char *))(v55 + 16);
    v57(v115, &v127[*((int *)v28 + 9)], v129);
    uint64_t v58 = *(atomic_ullong **)&v52[*(int *)(v42 + 36)];
    swift_retain(v58);
    v113(v52, v42);
    unint64_t v59 = *v56;
    v114((char *)v56, v28);
    if ((v59 & 0x8000000000000000) != 0 || v59 >= v58[2]) {
      goto LABEL_15;
    }
    uint64_t v60 = v121;
    unint64_t v128 = (*(unsigned __int8 *)(v60 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v60 + 80);
    uint64_t v127 = *(char **)(v121 + 72);
    uint64_t v61 = v105;
    uint64_t v62 = v123;
    uint64_t v130 = *(void *)(v121 + 16);
    ((void (*)(char *, char *, Class *))v130)(v105, (char *)v58 + v128 + (void)v127 * v59, v123);
    swift_release((uint64_t)v58);
    uint64_t v63 = v57;
    uint64_t v64 = v42;
    uint64_t v65 = v122;
    uint64_t v66 = v129;
    v63(v122, v61, v129);
    uint64_t v67 = v61;
    uint64_t v68 = *(void (**)(char *, Class *))(v60 + 8);
    v68(v67, v62);
    uint64_t v69 = v115;
    char v70 = v102(v115, v65, v66, v104);
    uint64_t v71 = v65;
    uint64_t v42 = v64;
    uint64_t v72 = v101;
    v101(v71, v66);
    uint64_t result = v72(v69, v66);
    uint64_t v54 = v66;
    if ((v70 & 1) == 0)
    {
      unint64_t v86 = *v131;
      uint64_t v88 = v125;
      uint64_t v87 = v126;
      if ((*v131 & 0x8000000000000000) == 0)
      {
        uint64_t v89 = *(void *)(v132 + *(int *)(v64 + 36));
        if (v86 < *(void *)(v89 + 16))
        {
          uint64_t v90 = v131;
          uint64_t v91 = v100;
          uint64_t v92 = v123;
          ((void (*)(char *, unint64_t, Class *))v130)(v100, v89 + v128 + v86 * (void)v127, v123);
          uint64_t v93 = v109;
          ((void (*)(char *, uint64_t, int **))v88[11])(v91, v87, v88);
          v68(v91, v92);
          uint64_t v94 = v87;
          uint64_t v95 = AssociatedTypeWitness;
          uint64_t v96 = swift_getAssociatedConformanceWitness(v108, v94, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
          uint64_t v85 = v122;
          (*(void (**)(char *, const char *, uint64_t))(v96 + 32))(v99, v95, v96);
          (*(void (**)(char *, const char *))(v110 + 8))(v93, v95);
          unint64_t v73 = *v90;
          goto LABEL_14;
        }
      }
LABEL_15:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
  }
  unint64_t v73 = *v131 - 1;
  uint64_t v74 = v125;
  uint64_t v75 = v126;
  if (!__OFSUB__(*v131, 1))
  {
    if ((v73 & 0x8000000000000000) == 0)
    {
      uint64_t v76 = *(void *)(v132 + *(int *)(v42 + 36));
      if (v73 < *(void *)(v76 + 16))
      {
        uint64_t v77 = v121;
        uint64_t v78 = v106;
        uint64_t v79 = v123;
        (*(void (**)(char *, unint64_t, Class *))(v121 + 16))(v106, v76+ ((*(unsigned __int8 *)(v77 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v77 + 80))+ *(void *)(v77 + 72) * v73, v123);
        uint64_t v80 = v109;
        ((void (*)(char *, uint64_t, int **))v74[11])(v78, v75, v74);
        uint64_t v81 = &v78[*((int *)v79 + 9)];
        uint64_t v82 = v75;
        uint64_t v83 = AssociatedTypeWitness;
        uint64_t v84 = swift_getAssociatedConformanceWitness(v108, v82, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
        uint64_t v85 = v122;
        (*(void (**)(char *, const char *, uint64_t))(v84 + 32))(v81, v83, v84);
        (*(void (**)(char *, const char *))(v110 + 8))(v80, v83);
        (*(void (**)(char *, Class *))(v77 + 8))(v78, v79);
LABEL_14:
        int v97 = v112;
        unint64_t *v112 = v73;
        return (*(uint64_t (**)(char *, char *, const char *))(v124 + 32))((char *)v97 + *((int *)v107 + 9), v85, v54);
      }
    }
    goto LABEL_15;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> DiscontiguousSlice<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  return DiscontiguousSlice<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> DiscontiguousSlice<A>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = type metadata accessor for DiscontiguousSlice.Index(0, *(void *)(a2 + 16), *(void *)(v6 + 8), a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v12 - v9;
  DiscontiguousSlice<>.index(before:)(a1, a2, v6, (unint64_t *)((char *)&v12 - v9));
  (*(void (**)(void *, Class *))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(void *, char *, Class *))(v8 + 32))(a1, v10, v7);
}

uint64_t DiscontiguousSlice<>.subscript.getter@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v39 = a4;
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v37 = AssociatedTypeWitness;
  uint64_t v38 = v10;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v36 = (char *)&v34 - v11;
  uint64_t v12 = swift_getAssociatedTypeWitness(255, (int **)v7, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v8, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v35 = type metadata accessor for Range(0, (uint64_t)v12, AssociatedConformanceWitness, v14);
  uint64_t v15 = (uint64_t)*(v35 - 1);
  MEMORY[0x1F4188790](v35);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = *(void *)(v4 + *(int *)(a2 + 36));
  uint64_t v19 = a1;
  unint64_t v20 = *a1;
  v40[0] = v18;
  uint64_t v22 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)v12, AssociatedConformanceWitness, v21);
  RangeSet.Ranges.subscript.getter(v20, (uint64_t)v22, v23, (uint64_t)v17);
  uint64_t v24 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 88))(v17, v8, v7);
  (*(void (**)(char *, Class *))(v15 + 8))(v17, v35);
  uint64_t v26 = (char *)v19 + *((int *)type metadata accessor for DiscontiguousSlice.Index(0, v8, v7, v25) + 9);
  uint64_t v27 = (uint64_t)v37;
  uint64_t v28 = swift_getAssociatedConformanceWitness(v7, v8, (uint64_t)v37, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v29 = (void (*)(void *, void))(*(uint64_t (**)(void *, char *, uint64_t, uint64_t))(v28 + 80))(v40, v26, v27, v28);
  uint64_t v31 = v30;
  uint64_t v32 = swift_getAssociatedTypeWitness(0, *(int ***)(v7 + 8), v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v32 - 1) + 16))(v39, v31, v32);
  v29(v40, 0);
  return (*(uint64_t (**)(char *, uint64_t))(v38 + 8))(v24, v27);
}

uint64_t key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for DiscontiguousSlice, (uint64_t (*)(uint64_t, uint64_t, uint64_t))DiscontiguousSlice<>.subscript.getter);
}

uint64_t key path setter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + a3 - 16);
  uint64_t v6 = *(void *)(a4 + a3 - 8);
  uint64_t v8 = *(void *)(v6 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v8 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v21 - v11;
  uint64_t v14 = type metadata accessor for DiscontiguousSlice.Index(0, v7, v8, v13);
  MEMORY[0x1F4188790](v14);
  uint64_t v16 = (unint64_t *)((char *)&v21 - v15);
  (*(void (**)(char *, uint64_t))(v17 + 16))((char *)&v21 - v15, a3);
  (*(void (**)(char *, uint64_t, const char *))(v10 + 16))(v12, a1, AssociatedTypeWitness);
  uint64_t v19 = type metadata accessor for DiscontiguousSlice(0, v7, v8, v18);
  return DiscontiguousSlice<>.subscript.setter((uint64_t)v12, v16, (uint64_t)v19, v6);
}

uint64_t DiscontiguousSlice<>.subscript.setter(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v34 = a2;
  uint64_t v37 = a1;
  uint64_t v7 = *(int ***)(a4 + 8);
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v33 = (char *)&v32 - v11;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v35 = (uint64_t)*(v14 - 1);
  uint64_t v36 = v14;
  MEMORY[0x1F4188790](v14);
  uint64_t v16 = (char *)&v32 - v15;
  uint64_t v17 = *(void *)(v4 + *(int *)(a3 + 36));
  uint64_t v18 = v34;
  unint64_t v19 = *v34;
  v38[0] = v17;
  uint64_t v21 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v20);
  RangeSet.Ranges.subscript.getter(v19, (uint64_t)v21, v22, (uint64_t)v16);
  uint64_t v24 = type metadata accessor for DiscontiguousSlice.Index(0, v8, (uint64_t)v7, v23);
  uint64_t v25 = v33;
  (*(void (**)(char *, char *, const char *))(v10 + 32))(v33, (char *)v18 + *((int *)v24 + 9), AssociatedTypeWitness);
  uint64_t v26 = (void (*)(void *, void))(*(uint64_t (**)(void *, char *, uint64_t, uint64_t))(a4 + 48))(v38, v16, v8, a4);
  uint64_t v27 = swift_getAssociatedTypeWitness(255, v7, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v28 = swift_getAssociatedConformanceWitness(a4, v8, (uint64_t)v27, (uint64_t)&protocol requirements base descriptor for MutableCollection, associated conformance descriptor for MutableCollection.Collection.SubSequence: MutableCollection);
  uint64_t v29 = *(void (**)(uint64_t, char *, uint64_t *, uint64_t))(v28 + 24);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v27);
  v29(v37, v25, v30, v28);
  v26(v38, 0);
  return (*(uint64_t (**)(char *, Class *))(v35 + 8))(v16, v36);
}

void (*DiscontiguousSlice<>.subscript.modify(void *a1, unint64_t *a2, uint64_t a3, uint64_t a4))(uint64_t *a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = malloc(0x120uLL);
  *a1 = v8;
  v8[12] = a4;
  v8[13] = v4;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(void *)(a3 + 16);
  v8[14] = v10;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, v10, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8[15] = AssociatedTypeWitness;
  uint64_t v12 = *((void *)AssociatedTypeWitness - 1);
  v8[16] = v12;
  v8[17] = malloc(*(void *)(v12 + 64));
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)v9, v10, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  v8[18] = v13;
  uint64_t v41 = (uint64_t)v13;
  uint64_t v42 = *((void *)v13 - 1);
  uint64_t v39 = malloc(*(void *)(v42 + 64));
  v8[19] = v39;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  v8[20] = v15;
  uint64_t v37 = (uint64_t)*(v15 - 1);
  uint64_t v38 = v15;
  uint64_t v16 = malloc(*(void *)(v37 + 64));
  v8[21] = v16;
  uint64_t v40 = swift_getAssociatedTypeWitness(0, *(int ***)(v9 + 8), v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v8[22] = v40;
  uint64_t v17 = *((void *)v40 - 1);
  uint64_t v18 = v17;
  v8[23] = v17;
  size_t v19 = *(void *)(v17 + 64);
  v8[24] = malloc(v19);
  uint64_t v36 = malloc(v19);
  v8[25] = v36;
  uint64_t v21 = type metadata accessor for DiscontiguousSlice.Index(0, v10, v9, v20);
  v8[26] = v21;
  uint64_t v22 = (uint64_t)*(v21 - 1);
  uint64_t v23 = v22;
  v8[27] = v22;
  size_t v24 = *(void *)(v22 + 64);
  v8[28] = malloc(v24);
  v8[29] = malloc(v24);
  (*(void (**)(void))(v23 + 16))();
  *((_DWORD *)v8 + 70) = *(_DWORD *)(a3 + 36);
  unint64_t v25 = *a2;
  uint64_t v27 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v26);
  v8[30] = v27;
  RangeSet.Ranges.subscript.getter(v25, (uint64_t)v27, v28, (uint64_t)v16);
  (*(void (**)(void *, uint64_t, uint64_t))(v9 + 88))(v16, v10, v9);
  uint64_t v29 = *(void (**)(void *, Class *))(v37 + 8);
  v8[31] = v29;
  v8[32] = (v37 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  v29(v16, v38);
  uint64_t v30 = (char *)a2 + *((int *)v21 + 9);
  uint64_t v31 = swift_getAssociatedConformanceWitness(v9, v10, v41, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v32 = (void (*)(void *, void))(*(uint64_t (**)(void *, char *, uint64_t, uint64_t))(v31 + 80))(v8, v30, v41, v31);
  uint64_t v33 = *(void (**)(void *))(v18 + 16);
  v8[33] = v33;
  v8[34] = (v18 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  v33(v36);
  v32(v8, 0);
  (*(void (**)(void *, uint64_t))(v42 + 8))(v39, v41);
  return DiscontiguousSlice<>.subscript.modify;
}

void DiscontiguousSlice<>.subscript.modify(uint64_t *a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  uint64_t v40 = *(void (**)(void *, uint64_t))(*a1 + 248);
  if (a2)
  {
    uint64_t v5 = *(unint64_t **)(v4 + 232);
    uint64_t v46 = *(void *)(v4 + 240);
    uint64_t v6 = *(void *)(v4 + 216);
    uint64_t v7 = *(unint64_t **)(v4 + 224);
    uint64_t v8 = *(void *)(v4 + 208);
    uint64_t v41 = *(void **)(v4 + 192);
    uint64_t v43 = *(void **)(v4 + 200);
    uint64_t v9 = *(void **)(v4 + 168);
    uint64_t v33 = v5;
    uint64_t v35 = *(void *)(v4 + 176);
    uint64_t v37 = *(void *)(v4 + 160);
    uint64_t v38 = *(void *)(v4 + 184);
    uint64_t v45 = *(void **)(v4 + 152);
    uint64_t v10 = *(void **)(v4 + 136);
    uint64_t v11 = *(void *)(v4 + 128);
    uint64_t v30 = *(void *)(v4 + 120);
    uint64_t v31 = *(void *)(v4 + 112);
    uint64_t v32 = *(void *)(v4 + 144);
    uint64_t v12 = *(void *)(v4 + 96);
    (*(void (**)(void))(v4 + 264))();
    (*(void (**)(unint64_t *, unint64_t *, uint64_t))(v6 + 32))(v7, v5, v8);
    RangeSet.Ranges.subscript.getter(*v7, v46, v13, (uint64_t)v9);
    uint64_t v47 = v7;
    uint64_t v14 = v41;
    (*(void (**)(void *, char *, uint64_t))(v11 + 32))(v10, (char *)v7 + *(int *)(v8 + 36), v30);
    uint64_t v15 = v10;
    uint64_t v16 = (void (*)(uint64_t, void))(*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(v12 + 48))(v4 + 32, v9, v31, v12);
    uint64_t v17 = v12;
    uint64_t v18 = v43;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v17, v31, v32, (uint64_t)&protocol requirements base descriptor for MutableCollection, associated conformance descriptor for MutableCollection.Collection.SubSequence: MutableCollection);
    (*(void (**)(void *, void *, uint64_t, uint64_t))(AssociatedConformanceWitness + 24))(v41, v10, v32, AssociatedConformanceWitness);
    v16(v4 + 32, 0);
    v40(v9, v37);
    (*(void (**)(void *, uint64_t))(v38 + 8))(v43, v35);
    uint64_t v20 = v33;
  }
  else
  {
    uint64_t v21 = *(unint64_t **)(v4 + 232);
    uint64_t v47 = *(unint64_t **)(v4 + 224);
    uint64_t v42 = *(void **)(v4 + 192);
    uint64_t v44 = *(void **)(v4 + 200);
    uint64_t v9 = *(void **)(v4 + 168);
    uint64_t v39 = *(void *)(v4 + 160);
    uint64_t v45 = *(void **)(v4 + 152);
    uint64_t v15 = *(void **)(v4 + 136);
    uint64_t v34 = *(void *)(v4 + 208);
    uint64_t v36 = *(void *)(v4 + 144);
    uint64_t v22 = *(void *)(v4 + 120);
    uint64_t v23 = *(void *)(v4 + 128);
    uint64_t v24 = *(void *)(v4 + 112);
    uint64_t v25 = *(void *)(v4 + 96);
    RangeSet.Ranges.subscript.getter(*v21, *(void *)(v4 + 240), a4, (uint64_t)v9);
    uint64_t v26 = v22;
    uint64_t v14 = v42;
    (*(void (**)(void *, char *, uint64_t))(v23 + 32))(v15, (char *)v21 + *(int *)(v34 + 36), v26);
    uint64_t v27 = (void (*)(uint64_t, void))(*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(v25 + 48))(v4 + 64, v9, v24, v25);
    uint64_t v28 = v24;
    uint64_t v18 = v44;
    uint64_t v29 = swift_getAssociatedConformanceWitness(v25, v28, v36, (uint64_t)&protocol requirements base descriptor for MutableCollection, associated conformance descriptor for MutableCollection.Collection.SubSequence: MutableCollection);
    (*(void (**)(void *, void *, uint64_t, uint64_t))(v29 + 24))(v44, v15, v36, v29);
    v27(v4 + 64, 0);
    v40(v9, v39);
    uint64_t v20 = v21;
  }
  free(v20);
  free(v47);
  free(v18);
  free(v14);
  free(v9);
  free(v45);
  free(v15);

  free((void *)v4);
}

atomic_ullong *Collection.subscript.getter@<X0>(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *a1;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v4, a2);
  *(void *)(a4 + *((int *)type metadata accessor for DiscontiguousSlice(0, a2, a3, v9) + 9)) = v8;

  return swift_retain(v8);
}

Class *Collection.removingSubranges(_:)@<X0>(uint64_t a1@<X1>, int **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a2, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a2, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v11 = type metadata accessor for RangeSet(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v10);
  RangeSet._inverted<A>(within:)((uint64_t)v11, a1, (uint64_t)a2, &v15);
  uint64_t v12 = v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a3, v4, a1);
  uint64_t result = type metadata accessor for DiscontiguousSlice(0, a1, (uint64_t)a2, v13);
  *(void *)(a3 + *((int *)result + 9)) = v12;
  return result;
}

uint64_t RangeSet._inverted<A>(within:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  unint64_t v59 = a4;
  uint64_t v8 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v8, v8, "lower upper ", 0);
  uint64_t v9 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v58 = (char *)&v50 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v56 = (char *)&v50 - v12;
  uint64_t v61 = *(void *)(v8 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v60 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v50 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v50 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v50 - v21;
  uint64_t v23 = *(void *)(a1 + 24);
  uint64_t v54 = type metadata accessor for Range(0, v8, v23, v24);
  uint64_t v57 = (uint64_t)*(v54 - 1);
  uint64_t v25 = MEMORY[0x1F4188790](v54);
  uint64_t v52 = (char *)&v50 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v25);
  uint64_t v53 = (char *)&v50 - v27;
  uint64_t v64 = *v4;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t))(a3 + 64);
  swift_retain(v64);
  v28(a2, a3);
  uint64_t v29 = a2;
  uint64_t v30 = v60;
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v29, a3);
  uint64_t v31 = v61;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v61 + 16);
  v32(v17, v22, v8);
  uint64_t v51 = v20;
  v32(v30, v20, v8);
  uint64_t v33 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v23 + 24);
  uint64_t v55 = v23;
  if ((v33(v17, v30, v8, v23) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v50 = v32;
  uint64_t v34 = *(void (**)(char *, uint64_t))(v31 + 8);
  uint64_t v62 = v34;
  v34(v30, v8);
  v34(v17, v8);
  uint64_t v35 = TupleTypeMetadata2;
  uint64_t v36 = v56;
  uint64_t v37 = &v56[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v38 = *(void (**)(char *, char *, uint64_t))(v31 + 32);
  v38(v56, v22, v8);
  uint64_t v60 = v37;
  v38(v37, v51, v8);
  uint64_t v39 = v58;
  uint64_t v40 = &v58[*((int *)v35 + 12)];
  uint64_t v41 = v50;
  v50(v58, v36, v8);
  v41(v40, v37, v8);
  uint64_t v42 = v52;
  v38(v52, v39, v8);
  v62(v40, v8);
  uint64_t v43 = &v39[*((int *)TupleTypeMetadata2 + 12)];
  v38(v39, v36, v8);
  v38(v43, v60, v8);
  uint64_t v44 = v54;
  v38(&v42[*((int *)v54 + 9)], v43, v8);
  v62(v39, v8);
  uint64_t v45 = v57;
  uint64_t v46 = (uint64_t)v53;
  (*(void (**)(char *, char *, Class *))(v57 + 32))(v53, v42, v44);
  uint64_t v48 = type metadata accessor for RangeSet.Ranges(0, v8, v55, v47);
  RangeSet.Ranges._gaps(boundedBy:)(v46, (uint64_t)v48, &v65);
  (*(void (**)(uint64_t, Class *))(v45 + 8))(v46, v44);
  uint64_t result = swift_release((uint64_t)v64);
  *unint64_t v59 = v65;
  return result;
}

uint64_t (*LazyDropWhileSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.init(_base:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return LazyDropWhileSequence.init(_base:predicate:)(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyDropWhileSequence, a6);
}

uint64_t LazyDropWhileSequence.Iterator._predicateHasFailed.getter()
{
  return *v0;
}

uint64_t LazyDropWhileSequence.Iterator._predicateHasFailed.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*LazyDropWhileSequence.Iterator._predicateHasFailed.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t LazyDropWhileSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*LazyDropWhileSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.Iterator.init(_base:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, unsigned char *a6@<X8>)
{
  return LazyDropWhileSequence.Iterator.init(_base:predicate:)(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, int **))type metadata accessor for LazyDropWhileSequence.Iterator, a6);
}

uint64_t LazyDropWhileSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v28 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t v26 = (uint64_t)*(v9 - 1);
  uint64_t v27 = v9;
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v26 - v11;
  uint64_t v29 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v26 - v13;
  int v15 = *v2;
  uint64_t v16 = *(int *)(a1 + 36);
  uint64_t v35 = v2;
  uint64_t v17 = &v2[v16];
  uint64_t v18 = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)v18, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v20 = *(uint64_t (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v21 = swift_checkMetadataState(0, (uint64_t)v18);
  if (v15 == 1) {
    return v20(v21, AssociatedConformanceWitness);
  }
  uint64_t v33 = v17;
  uint64_t v34 = a1;
  uint64_t v32 = (void (*)(uint64_t *, uint64_t))v20;
  v20(v21, AssociatedConformanceWitness);
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, const char *))(v29 + 48);
  if (v31(v12, 1, AssociatedTypeWitness) == 1)
  {
LABEL_7:
    (*(void (**)(char *, Class *))(v26 + 8))(v12, v27);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v29 + 56))(v28, 1, 1, AssociatedTypeWitness);
  }
  else
  {
    uint64_t v30 = *(void (**)(char *, char *, const char *))(v29 + 32);
    uint64_t v23 = (void (**)(char *, const char *))(v29 + 8);
    while (1)
    {
      v30(v14, v12, AssociatedTypeWitness);
      if (((*(uint64_t (**)(char *))&v35[*(int *)(v34 + 40)])(v14) & 1) == 0) {
        break;
      }
      (*v23)(v14, AssociatedTypeWitness);
      uint64_t v24 = swift_checkMetadataState(0, (uint64_t)v18);
      v32(v24, AssociatedConformanceWitness);
      if (v31(v12, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_7;
      }
    }
    *uint64_t v35 = 1;
    uint64_t v25 = v28;
    v30(v28, v14, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, void, uint64_t, const char *))(v29 + 56))(v25, 0, 1, AssociatedTypeWitness);
  }
}

double LazyDropWhileSequence.makeIterator()@<D0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  *(void *)&double result = LazyDropWhileSequence.makeIterator()(a1, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyDropWhileSequence.Iterator, a2).n128_u64[0];
  return result;
}

atomic_ullong *LazySequenceProtocol.drop(while:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazySequenceProtocol.drop(while:)(a1, a2, a3, a4, (uint64_t (*)(void, const char *, uint64_t))type metadata accessor for LazyDropWhileSequence, a5);
}

uint64_t LazyDropWhileSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 8), v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v43 = (char *)v39 - v11;
  uint64_t v45 = *(void (***)(char *, uint64_t))(v6 - 8);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)v39 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = swift_getAssociatedTypeWitness(0, (int **)v5, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v15 = *((void *)v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v55 = (char *)v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = (char *)v39 - v18;
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v58 = a3;
  v19(v8, v5);
  uint64_t v52 = *(void (**)(uint64_t, uint64_t))(v5 + 72);
  uint64_t v53 = v5 + 72;
  uint64_t v57 = v8;
  uint64_t v51 = *(void *)(swift_getAssociatedConformanceWitness(v5, v8, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  char v49 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v51 + 8);
  uint64_t v50 = v51 + 8;
  uint64_t v20 = *(void (**)(char *, uint64_t, const char *))(v15 + 16);
  uint64_t v56 = v15 + 16;
  uint64_t v47 = (void (**)(char *, const char *))(v15 + 8);
  uint64_t v48 = v20;
  uint64_t v46 = (void (**)(char *, uint64_t, uint64_t))(v45 + 2);
  uint64_t v42 = v5 + 80;
  uint64_t v41 = (void (**)(char *))(v9 + 16);
  ++v45;
  uint64_t v40 = (uint64_t (**)(char *, const char *))(v9 + 8);
  v39[1] = v5 + 192;
  while (1)
  {
    uint64_t v21 = v54;
    v48(v54, v58, v14);
    uint64_t v22 = v55;
    v52(v57, v5);
    char v23 = v49(v21, v22, v14, v51);
    uint64_t v24 = *v47;
    (*v47)(v22, v14);
    v24(v21, v14);
    (*v46)(v13, v4, v6);
    if (v23) {
      break;
    }
    uint64_t v25 = v4;
    uint64_t v26 = &v13[*(int *)(v6 + 36)];
    uint64_t v27 = v13;
    uint64_t v29 = *(uint64_t (**)(char *))v26;
    uint64_t v28 = (atomic_ullong *)*((void *)v26 + 1);
    uint64_t v30 = v6;
    uint64_t v31 = *(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v5 + 80);
    swift_retain(v28);
    uint64_t v32 = v5;
    uint64_t v33 = v31(v59, v58, v57, v5);
    uint64_t v6 = v30;
    uint64_t v34 = (void (*)(unsigned char *, void))v33;
    uint64_t v36 = v43;
    uint64_t v35 = AssociatedTypeWitness;
    (*v41)(v43);
    v34(v59, 0);
    uint64_t v37 = v27;
    (*v45)(v27, v6);
    LOBYTE(v27) = v29(v36);
    swift_release((uint64_t)v28);
    uint64_t result = (*v40)(v36, v35);
    if ((v27 & 1) == 0) {
      return result;
    }
    uint64_t v5 = v32;
    uint64_t v4 = v25;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v32 + 192))(v58, v57, v32);
    uint64_t v13 = v37;
  }
  return ((uint64_t (*)(char *, uint64_t))*v45)(v13, v6);
}

uint64_t LazyDropWhileSequence<>.index(after:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a2;
  v25[1] = a4;
  uint64_t v7 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)v25 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v12, v11, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v15 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v17 = (char *)v25 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)v25 - v18;
  uint64_t v20 = *(void (**)(char *, uint64_t, const char *))(v14 + 16);
  uint64_t v26 = a1;
  v20((char *)v25 - v18, a1, AssociatedTypeWitness);
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v25[0] = v5;
  v21(v9, v27, v5);
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v11, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v5) = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 16))(v19, v17, AssociatedTypeWitness, AssociatedConformanceWitness);
  char v23 = *(void (**)(char *, const char *))(v14 + 8);
  v23(v17, AssociatedTypeWitness);
  if ((v5 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't advance past endIndex", 27, 2, "Swift/DropWhile.swift", 21, 2, 0x94uLL, 0);
  }
  (*(void (**)(char *, void))(v7 + 8))(v9, v25[0]);
  v23(v19, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(v26, v11, a3);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazyDropWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyDropWhileSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), a3);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> LazyDropWhileSequence<A>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x28uLL);
  *a1 = v8;
  v8[4] = LazyDropWhileSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*LazyDropWhileSequence<>.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x38uLL);
  *a1 = v8;
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 8), v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v8[4] = AssociatedTypeWitness;
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = v11;
  unint64_t v8[5] = v11;
  uint64_t v13 = malloc(*(void *)(v11 + 64));
  v8[6] = v13;
  uint64_t v14 = (void (*)(void *, void))(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(a4 + 80))(v8, a2, v9, a4);
  (*(void (**)(void *))(v12 + 16))(v13);
  v14(v8, 0);
  return LazyDropWhileSequence<>.subscript.read;
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazyDropWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyDropWhileSequence<>.index(after:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>(a1, a2, a3, (void (*)(uint64_t, uint64_t, int **))LazyDropWhileSequence<>.index(after:));
}

uint64_t LazyDropWhileSequence<>.index(before:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v27[1] = a3;
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)v27 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = v9;
  uint64_t v10 = *(int ***)(v9 + 8);
  uint64_t v31 = *(void *)(v11 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v31, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v16 = (char *)v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)v27 - v17;
  uint64_t v19 = *(void (**)(char *, uint64_t, const char *))(v13 + 16);
  uint64_t v28 = a1;
  v19((char *)v27 - v17, a1, AssociatedTypeWitness);
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 16);
  uint64_t v29 = v3;
  v20(v8, v3, a2);
  LazyDropWhileSequence<>.startIndex.getter(a2, (uint64_t)v10, (uint64_t)v16);
  uint64_t v21 = (uint64_t)v10;
  uint64_t v22 = v31;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v21, v31, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v24 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 40))(v18, v16, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v25 = *(void (**)(char *, const char *))(v13 + 8);
  v25(v16, AssociatedTypeWitness);
  if ((v24 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't move before startIndex", 28, 2, "Swift/DropWhile.swift", 21, 2, 0xA2uLL, 0);
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, a2);
  v25(v18, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v30 + 32))(v28, v22);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> LazyDropWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyDropWhileSequence<>.index(before:)(a1, a2, a3);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t))LazyDropWhileSequence<>.index(before:));
}

uint64_t dump<A, B>(_:to:name:indent:maxDepth:maxItems:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>, uint64_t a10, uint64_t a11)
{
  uint64_t v24 = a7;
  char v23 = &_swiftEmptyDictionarySingleton;
  (*(void (**)(uint64_t, uint64_t))(a11 + 8))(a10, a11);
  v22[3] = a8;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v22);
  uint64_t v18 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(a8 - 8) + 16);
  v18(boxed_opaque_existential_0Tm, a1, a8);
  _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)((uint64_t)v22, a2, a3, a4, a5, a6, &v24, (uint64_t)&v23, a10, a11);
  swift_bridgeObjectRelease((uint64_t)v23);
  __swift_destroy_boxed_opaque_existential_1Tm(v22);
  v18(a9, a1, a8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a11 + 16))(a10, a11);
}

void _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  void (*v54)(uint64_t *__return_ptr, id, atomic_ullong);
  id v55;
  uint64_t v56;
  uint64_t v57;
  int isUniquelyReferenced_nonNull;
  atomic_ullong v59;
  uint64_t v60;
  uint64_t v61;
  void (*v62)(id, atomic_ullong);
  id v63;
  uint64_t v64;
  atomic_ullong v65;
  uint64_t v66;
  Swift::String v67;
  uint64_t v68;
  void (*v69)(uint64_t, unint64_t, uint64_t, uint64_t);
  char v72;
  BOOL v73;
  void (*v74)(uint64_t *__return_ptr, atomic_ullong *);
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  atomic_ullong v80;
  atomic_ullong *v81;
  uint64_t v82;
  atomic_ullong *v83;
  uint64_t v84;
  atomic_ullong *v85;
  long long v86;
  atomic_ullong *v87;
  char v88;
  _OWORD v89[2];

  if (*a7 < 1) {
    return;
  }
  --*a7;
  if (a5 < 0) {
    goto LABEL_60;
  }
  uint64_t v14 = a10;
  if (a5)
  {
    uint64_t v15 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a10 + 24);
    uint64_t v16 = a5;
    do
    {
      v15(32, 0xE100000000000000, a9, a10);
      swift_bridgeObjectRelease(0xE100000000000000);
      --v16;
    }
    while (v16);
  }
  uint64_t v68 = a5;
  outlined init with copy of Any(a1, (uint64_t)v89);
  Mirror.init(reflecting:)((uint64_t *)v89, (uint64_t)&v84);
  uint64_t v76 = v84;
  uint64_t v72 = v86;
  uint64_t v74 = (void (*)(uint64_t *__return_ptr, atomic_ullong *))*((void *)&v86 + 1);
  uint64_t v81 = v87;
  char v17 = v88;
  uint64_t v18 = *(uint64_t (**)(void))(*v85 + 320);
  uint64_t v83 = (atomic_ullong *)swift_retain_n((uint64_t)v85, 3);
  uint64_t v19 = v18();
  uint64_t v20 = 12162786;
  if (a6 > 0) {
    uint64_t v20 = 12556002;
  }
  uint64_t v78 = v19;
  BOOL v21 = v19 == 0;
  if (v19) {
    uint64_t v22 = v20;
  }
  else {
    uint64_t v22 = 45;
  }
  if (v21) {
    uint64_t v23 = 0xE100000000000000;
  }
  else {
    uint64_t v23 = 0xA300000000000000;
  }
  uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a10 + 24);
  v24(v22, v23, a9, a10);
  swift_bridgeObjectRelease(v23);
  v24(32, 0xE100000000000000, a9, a10);
  swift_bridgeObjectRelease(0xE100000000000000);
  if (a4)
  {
    v24(a3, a4, a9, a10);
    v24(8250, 0xE200000000000000, a9, a10);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  uint64_t v69 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v24;
  uint64_t v84 = v76;
  uint64_t v85 = v83;
  LOBYTE(v86) = v72;
  *((void *)&v86 + 1) = v74;
  uint64_t v87 = v81;
  uint64_t v88 = v17;
  _dumpPrint_unlocked<A, B>(_:_:_:)((swift::SwiftError **)a1, (uint64_t)&v84, a2, qword_1ECA06310, a9, a10);
  uint64_t v25 = *(uint64_t **)(a1 + 24);
  uint64_t v26 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm((void *)a1, (uint64_t)v25);
  unint64_t DynamicType = (uint64_t *)swift_getDynamicType(v26, v25, 1);
  if (swift_isClassType(DynamicType)) {
    uint64_t v28 = DynamicType;
  }
  else {
    uint64_t v28 = 0;
  }
  if (v28)
  {
    uint64_t v29 = _unsafeDowncastToAnyObject(fromAny:)((void *)a1);
    swift_unknownObjectRelease(v29);
    uint64_t v30 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v24;
    uint64_t v31 = (uint64_t *)a8;
  }
  else
  {
    outlined init with copy of Any(a1, (uint64_t)&v84);
    uint64_t v32 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any.Type);
    uint64_t v30 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v24;
    uint64_t v31 = (uint64_t *)a8;
    if (!swift_dynamicCast((char *)v89, (unint64_t *)&v84, qword_1ECA06310, v32, 6uLL)) {
      goto LABEL_29;
    }
    uint64_t v29 = *(atomic_ullong **)&v89[0];
  }
  uint64_t v33 = *v31;
  if (*(void *)(*v31 + 16))
  {
    unint64_t v34 = specialized __RawDictionaryStorage.find<A>(_:)((uint64_t)v29);
    if (v35)
    {
      uint64_t v36 = *(void *)(*(void *)(v33 + 56) + 8 * v34);
      swift_release((uint64_t)v81);
      swift_release_n((uint64_t)v83, 4);
      v30(8992, 0xE200000000000000, a9, a10);
      swift_bridgeObjectRelease(0xE200000000000000);
      uint64_t v84 = v36;
      _print_unlocked<A, B>(_:_:)((uint64_t)&v84, a2, (Class *)&type metadata for Int, a9, a10);
      v30(10, 0xE100000000000000, a9, a10);
      swift_bridgeObjectRelease(0xE100000000000000);
      return;
    }
    uint64_t v37 = *(void *)(v33 + 16);
    uint64_t v33 = *v31;
  }
  else
  {
    uint64_t v37 = 0;
  }
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v33);
  uint64_t v84 = *v31;
  *uint64_t v31 = 0x8000000000000000;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(v37, (uint64_t)v29, isUniquelyReferenced_nonNull_native);
  uint64_t v39 = *v31;
  *uint64_t v31 = v84;
  swift_bridgeObjectRelease(v39);
  v30(8992, 0xE200000000000000, a9, a10);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v84 = v37;
  _print_unlocked<A, B>(_:_:)((uint64_t)&v84, a2, (Class *)&type metadata for Int, a9, a10);
LABEL_29:
  v30(10, 0xE100000000000000, a9, a10);
  swift_bridgeObjectRelease(0xE100000000000000);
  uint64_t v77 = a6 - 1;
  if (a6 < 1)
  {
    swift_release((uint64_t)v81);
    uint64_t v46 = (uint64_t)v83;
    uint64_t v47 = 4;
LABEL_48:
    swift_release_n(v46, v47);
    return;
  }
  swift_retain(v83);
  uint64_t v40 = swift_retain(v81);
  v74(&v84, v40);
  swift_release((uint64_t)v81);
  swift_release((uint64_t)v83);
  uint64_t v41 = v84;
  if (v84)
  {
    uint64_t v42 = (uint64_t)v85;
    long long v44 = v86;
    uint64_t v43 = (uint64_t)v87;
    v88 &= 1u;
    uint64_t v45 = a7;
    if (__OFADD__(v68, 2))
    {
      __break(1u);
LABEL_62:
      __break(1u);
      return;
    }
    _dumpSuperclass_unlocked<A>(mirror:to:indent:maxDepth:maxItemCounter:visitedItems:)(&v84, a2, v68 + 2, v77, a7, a8, a9, a10);
    outlined consume of Mirror?(v41, v42, v44, *((uint64_t *)&v44 + 1), v43);
  }
  else
  {
    uint64_t v45 = a7;
  }
  uint64_t v48 = (uint64_t)v83;
  uint64_t v50 = (void *)v83[2];
  atomic_ullong v49 = v83[3];
  swift_unknownObjectRetain(v50);
  swift_release((uint64_t)v81);
  swift_release((uint64_t)v83);
  if (v78 < 0) {
    goto LABEL_60;
  }
  if (!v78)
  {
LABEL_47:
    swift_unknownObjectRelease(v50);
    uint64_t v46 = v48;
    uint64_t v47 = 3;
    goto LABEL_48;
  }
  uint64_t v80 = v49;
  uint64_t v51 = 0;
  BOOL v52 = __OFADD__(v68, 2);
  unint64_t v73 = v52;
  uint64_t v53 = a8;
  while (*v45 > 0)
  {
    uint64_t v82 = v51;
    uint64_t v54 = *(void (**)(uint64_t *__return_ptr, id, atomic_ullong))(*(void *)v48 + 256);
    uint64_t v55 = swift_unknownObjectRetain(v50);
    v54(&v84, v55, v80);
    swift_unknownObjectRelease(v50);
    uint64_t v56 = v84;
    uint64_t v57 = (uint64_t)v85;
    outlined init with take of Any(&v86, v89);
    isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v50);
    unint64_t v59 = *v83;
    if (isUniquelyReferenced_nonNull)
    {
      uint64_t v60 = v14;
      uint64_t v61 = a2;
      uint64_t v62 = *(void (**)(id, atomic_ullong))(v59 + 272);
      uint64_t v63 = swift_unknownObjectRetain(v50);
      v62(v63, v80);
      uint64_t v53 = a8;
      a2 = v61;
      uint64_t v14 = v60;
      uint64_t v45 = a7;
      swift_unknownObjectRelease(v50);
    }
    else
    {
      uint64_t v64 = (*(uint64_t (**)(void *, atomic_ullong))(v59 + 264))(v50, v80);
      uint64_t v80 = v65;
      swift_unknownObjectRelease(v50);
      uint64_t v50 = (void *)v64;
    }
    if (v73)
    {
      __break(1u);
LABEL_60:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    ++v51;
    _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)(v89, a2, v56, v57, v68 + 2, v77, v45, v53, a9, v14);
    swift_bridgeObjectRelease(v57);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v89);
    uint64_t v48 = (uint64_t)v83;
    if (v78 == v82 + 1) {
      goto LABEL_47;
    }
  }
  swift_release_n(v48, 3);
  uint64_t v66 = v68 + 4;
  if (__OFADD__(v68, 4)) {
    goto LABEL_62;
  }
  if (v66 < 0) {
    goto LABEL_60;
  }
  swift_unknownObjectRelease(v50);
  if (v68 != -4)
  {
    do
    {
      uint64_t v84 = 32;
      uint64_t v85 = (atomic_ullong *)0xE100000000000000;
      _print_unlocked<A, B>(_:_:)((uint64_t)&v84, a2, (Class *)&type metadata for String, a9, v14);
      swift_bridgeObjectRelease(0xE100000000000000);
      --v66;
    }
    while (v66);
  }
  v69(40, 0xE100000000000000, a9, v14);
  swift_bridgeObjectRelease(0xE100000000000000);
  uint64_t v84 = v78 - v51;
  _print_unlocked<A, B>(_:_:)((uint64_t)&v84, a2, (Class *)&type metadata for Int, a9, v14);
  if (v51)
  {
    v69(0x65726F6D20, 0xE500000000000000, a9, v14);
    swift_bridgeObjectRelease(0xE500000000000000);
  }
  if (v78 - 1 == v51)
  {
    v69(0xA29646C69686320, 0xE800000000000000, a9, v14);
    swift_bridgeObjectRelease(0xE800000000000000);
  }
  else
  {
    uint64_t v67 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" children)\n", 0xBuLL, 1);
    ((void (*)(uint64_t))v69)(v67._countAndFlagsBits);
    swift_bridgeObjectRelease((uint64_t)v67._object);
  }
}

void dump<A>(_:name:indent:maxDepth:maxItems:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  uint64_t v20 = a6;
  uint64_t v19 = &_swiftEmptyDictionarySingleton;
  _swift_stdlib_flockfile_stdout();
  uint64_t v18[3] = a7;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v18);
  uint64_t v16 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16);
  v16(boxed_opaque_existential_0Tm, a1, a7);
  _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)((uint64_t)v18, v17, a2, a3, a4, a5, &v20, (uint64_t)&v19, (uint64_t)&type metadata for _Stdout, (uint64_t)&protocol witness table for _Stdout);
  swift_bridgeObjectRelease((uint64_t)v19);
  __swift_destroy_boxed_opaque_existential_1Tm(v18);
  v16(a8, a1, a7);
  _swift_stdlib_funlockfile_stdout();
}

void _dumpPrint_unlocked<A, B>(_:_:_:)(swift::SwiftError **a1, uint64_t a2, uint64_t a3, Class *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v183 = a3;
  uint64_t v184 = a5;
  uint64_t v9 = (uint64_t)*(a4 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (unint64_t *)((char *)&v180 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (unint64_t *)((char *)&v180 - v14);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v19 = (unint64_t *)((char *)&v180 - v18);
  uint64_t v20 = *(Class **)v17;
  unint64_t v21 = *(void *)(v17 + 8);
  unsigned int v22 = *(unsigned __int8 *)(v17 + 16);
  __n128 v23 = *(__n128 *)(v17 + 24);
  char v24 = *(unsigned char *)(v17 + 40);
  if (v22 != 8)
  {
    switch(*(unsigned char *)(v17 + 16))
    {
      case 3:
        uint64_t v27 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v21 + 320))(v16, v23);
        if (v27 == 1)
        {
          uint64_t v28 = a6;
          uint64_t v29 = "(1 element)";
          Builtin::Word v30 = 11;
          goto LABEL_15;
        }
        uint64_t v64 = v27;
        uint64_t v28 = a6;
        unint64_t v65 = specialized static String._createEmpty(withInitialCapacity:)(13);
        uint64_t v67 = v66;
        uint64_t v185 = (Class *)v65;
        unint64_t v186 = v66;
        uint64_t v68 = HIBYTE(v66) & 0xF;
        if ((v66 & 0x2000000000000000) == 0) {
          uint64_t v68 = v65 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v45 = v184;
        if (v68 || (v65 & ~v66 & 0x2000000000000000) != 0)
        {
          if ((v66 & 0x2000000000000000) == 0
            || (unint64_t v69 = specialized _SmallString.init(_:appending:)(v65, v66, 0x28uLL, 0xE100000000000000),
                (v71 & 1) != 0))
          {
            _StringGuts.append(_:)(40, 0xE100000000000000, 0, 1);
            swift_bridgeObjectRelease(0xE100000000000000);
            unint64_t v72 = (unint64_t)v185;
            unint64_t v73 = v186;
            goto LABEL_67;
          }
          unint64_t v72 = v69;
          unint64_t v73 = v70;
          swift_bridgeObjectRelease(v67);
          swift_bridgeObjectRelease(0xE100000000000000);
        }
        else
        {
          swift_bridgeObjectRelease(v66);
          unint64_t v72 = 40;
          unint64_t v73 = 0xE100000000000000;
        }
        uint64_t v185 = (Class *)v72;
        unint64_t v186 = v73;
LABEL_67:
        uint64_t v116 = _int64ToString(_:radix:uppercase:)(v64, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v117 = v115;
        uint64_t v118 = HIBYTE(v73) & 0xF;
        if ((v73 & 0x2000000000000000) == 0) {
          uint64_t v118 = v72 & 0xFFFFFFFFFFFFLL;
        }
        if (v118 || (v72 & ~v73 & 0x2000000000000000) != 0)
        {
          if ((v73 & 0x2000000000000000) != 0)
          {
            if ((v115 & 0x2000000000000000) != 0)
            {
              unint64_t v120 = specialized _SmallString.init(_:appending:)(v72, v73, v116, v115);
              if ((v122 & 1) == 0)
              {
                uint64_t v123 = v120;
                unint64_t v124 = v121;
                swift_bridgeObjectRelease(v73);
                swift_bridgeObjectRelease(v117);
                uint64_t v185 = (Class *)v123;
                unint64_t v186 = v124;
                unint64_t v117 = v124;
                uint64_t v116 = v123;
                goto LABEL_80;
              }
              goto LABEL_78;
            }
          }
          else if ((v115 & 0x2000000000000000) != 0)
          {
LABEL_78:
            uint64_t v119 = HIBYTE(v117) & 0xF;
            goto LABEL_79;
          }
          uint64_t v119 = v116 & 0xFFFFFFFFFFFFLL;
LABEL_79:
          _StringGuts.append(_:)(v116, v117, 0, v119);
          swift_bridgeObjectRelease(v117);
          uint64_t v116 = (uint64_t)v185;
          unint64_t v117 = v186;
          goto LABEL_80;
        }
        swift_bridgeObjectRelease(v73);
        uint64_t v185 = (Class *)v116;
        unint64_t v186 = v117;
LABEL_80:
        Swift::String v125 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements)", 0xAuLL, 1);
        uint64_t countAndFlagsBits = v125._countAndFlagsBits;
        unint64_t object = (unint64_t)v125._object;
        uint64_t v126 = HIBYTE(v117) & 0xF;
        if ((v117 & 0x2000000000000000) == 0) {
          uint64_t v126 = v116 & 0xFFFFFFFFFFFFLL;
        }
        if (v126 || (v116 & ~v117 & 0x2000000000000000) != 0) {
          goto LABEL_104;
        }
LABEL_114:
        swift_bridgeObjectRelease(v117);
        goto LABEL_113;
      case 5:
        uint64_t v41 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v21 + 320))(v16, v23);
        if (v41 == 1)
        {
          uint64_t v28 = a6;
          uint64_t v29 = "1 element";
          Builtin::Word v30 = 9;
LABEL_15:
          Swift::String v42 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(v29, v30, 1);
          uint64_t countAndFlagsBits = v42._countAndFlagsBits;
          unint64_t object = (unint64_t)v42._object;
          uint64_t v45 = v184;
          goto LABEL_113;
        }
        uint64_t v74 = v41;
        uint64_t v28 = a6;
        unint64_t v75 = specialized static String._createEmpty(withInitialCapacity:)(11);
        uint64_t v77 = v76;
        uint64_t v185 = (Class *)v75;
        unint64_t v186 = v76;
        uint64_t v78 = HIBYTE(v76) & 0xF;
        if ((v76 & 0x2000000000000000) == 0) {
          uint64_t v78 = v75 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v45 = v184;
        if (v78 || (v75 & ~v76 & 0x2000000000000000) != 0)
        {
          if ((v76 & 0x2000000000000000) == 0
            || (unint64_t v79 = specialized _SmallString.init(_:appending:)(v75, v76, 0, 0xE000000000000000), (v81 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            unint64_t v82 = (unint64_t)v185;
            unint64_t v83 = v186;
            goto LABEL_87;
          }
          unint64_t v82 = v79;
          unint64_t v83 = v80;
          swift_bridgeObjectRelease(v77);
          swift_bridgeObjectRelease(0xE000000000000000);
          uint64_t v185 = (Class *)v82;
        }
        else
        {
          swift_bridgeObjectRelease(v76);
          unint64_t v82 = 0;
          unint64_t v83 = 0xE000000000000000;
          uint64_t v185 = 0;
        }
        unint64_t v186 = v83;
LABEL_87:
        uint64_t v116 = _int64ToString(_:radix:uppercase:)(v74, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v117 = v127;
        uint64_t v128 = HIBYTE(v83) & 0xF;
        if ((v83 & 0x2000000000000000) == 0) {
          uint64_t v128 = v82 & 0xFFFFFFFFFFFFLL;
        }
        if (v128 || (v82 & ~v83 & 0x2000000000000000) != 0)
        {
          if ((v83 & 0x2000000000000000) != 0)
          {
            if ((v127 & 0x2000000000000000) != 0)
            {
              unint64_t v130 = specialized _SmallString.init(_:appending:)(v82, v83, v116, v127);
              if ((v132 & 1) == 0)
              {
                uint64_t v133 = v130;
                unint64_t v134 = v131;
                swift_bridgeObjectRelease(v83);
                swift_bridgeObjectRelease(v117);
                uint64_t v185 = (Class *)v133;
                unint64_t v186 = v134;
                unint64_t v117 = v134;
                uint64_t v116 = v133;
                goto LABEL_100;
              }
              goto LABEL_98;
            }
          }
          else if ((v127 & 0x2000000000000000) != 0)
          {
LABEL_98:
            uint64_t v129 = HIBYTE(v117) & 0xF;
            goto LABEL_99;
          }
          uint64_t v129 = v116 & 0xFFFFFFFFFFFFLL;
LABEL_99:
          _StringGuts.append(_:)(v116, v117, 0, v129);
          swift_bridgeObjectRelease(v117);
          uint64_t v116 = (uint64_t)v185;
          unint64_t v117 = v186;
          goto LABEL_100;
        }
        swift_bridgeObjectRelease(v83);
        uint64_t v185 = (Class *)v116;
        unint64_t v186 = v117;
LABEL_100:
        Swift::String v135 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements", 9uLL, 1);
        uint64_t countAndFlagsBits = v135._countAndFlagsBits;
        unint64_t object = (unint64_t)v135._object;
        uint64_t v136 = HIBYTE(v117) & 0xF;
        if ((v117 & 0x2000000000000000) == 0) {
          uint64_t v136 = v116 & 0xFFFFFFFFFFFFLL;
        }
        if (!v136 && (v116 & ~v117 & 0x2000000000000000) == 0) {
          goto LABEL_114;
        }
LABEL_104:
        if ((v117 & 0x2000000000000000) != 0)
        {
          if ((object & 0x2000000000000000) != 0)
          {
            unint64_t v138 = specialized _SmallString.init(_:appending:)(v116, v117, countAndFlagsBits, object);
            if ((v140 & 1) == 0)
            {
              unint64_t v141 = v138;
              unint64_t v142 = v139;
              swift_bridgeObjectRelease(v117);
              swift_bridgeObjectRelease(object);
              uint64_t countAndFlagsBits = v141;
              unint64_t object = v142;
LABEL_113:
              (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v28 + 24))(countAndFlagsBits, object, v45, v28);
LABEL_143:
              uint64_t v158 = object;
LABEL_168:
              swift_bridgeObjectRelease(v158);
              return;
            }
            goto LABEL_111;
          }
        }
        else if ((object & 0x2000000000000000) != 0)
        {
LABEL_111:
          uint64_t v137 = HIBYTE(object) & 0xF;
          goto LABEL_112;
        }
        uint64_t v137 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_112:
        _StringGuts.append(_:)(countAndFlagsBits, object, 0, v137);
        swift_bridgeObjectRelease(object);
        uint64_t countAndFlagsBits = (uint64_t)v185;
        unint64_t object = v186;
        goto LABEL_113;
      case 6:
        uint64_t v46 = a6;
        uint64_t v47 = (Class *)0xD000000000000010;
        uint64_t v48 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v21 + 320))(v16, v23);
        if (v48 == 1)
        {
          unint64_t object = 0x80000001816E3090 | 0x8000000000000000;
          uint64_t v49 = v184;
          goto LABEL_142;
        }
        uint64_t v84 = v48;
        unint64_t v85 = specialized static String._createEmpty(withInitialCapacity:)(18);
        uint64_t v87 = v86;
        uint64_t v185 = (Class *)v85;
        unint64_t v186 = v86;
        uint64_t v88 = HIBYTE(v86) & 0xF;
        if ((v86 & 0x2000000000000000) == 0) {
          uint64_t v88 = v85 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v49 = v184;
        if (v88 || (v85 & ~v86 & 0x2000000000000000) != 0)
        {
          if ((v86 & 0x2000000000000000) == 0
            || (unint64_t v89 = specialized _SmallString.init(_:appending:)(v85, v86, 0, 0xE000000000000000), (v91 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            unint64_t v92 = (unint64_t)v185;
            unint64_t v93 = v186;
            goto LABEL_117;
          }
          unint64_t v92 = v89;
          unint64_t v93 = v90;
          swift_bridgeObjectRelease(v87);
          swift_bridgeObjectRelease(0xE000000000000000);
          uint64_t v185 = (Class *)v92;
        }
        else
        {
          swift_bridgeObjectRelease(v86);
          unint64_t v92 = 0;
          unint64_t v93 = 0xE000000000000000;
          uint64_t v185 = 0;
        }
        unint64_t v186 = v93;
LABEL_117:
        uint64_t v144 = _int64ToString(_:radix:uppercase:)(v84, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v145 = v143;
        uint64_t v146 = HIBYTE(v93) & 0xF;
        if ((v93 & 0x2000000000000000) == 0) {
          uint64_t v146 = v92 & 0xFFFFFFFFFFFFLL;
        }
        if (!v146 && (v92 & ~v93 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v93);
          uint64_t v185 = (Class *)v144;
          unint64_t v186 = v145;
LABEL_130:
          uint64_t v153 = HIBYTE(v145) & 0xF;
          if ((v145 & 0x2000000000000000) == 0) {
            uint64_t v153 = v144 & 0xFFFFFFFFFFFFLL;
          }
          if (v153 || (v144 & ~v145 & 0x2000000000000000) != 0)
          {
            if ((v145 & 0x2000000000000000) != 0
              && (0x80000001816E3070 & 0x2000000000000000) != 0
              && (unint64_t v154 = specialized _SmallString.init(_:appending:)(v144, v145, 0xD000000000000010, 0x80000001816E3070 | 0x8000000000000000), (v156 & 1) == 0))
            {
              uint64_t v47 = (Class *)v154;
              unint64_t object = v155;
              swift_bridgeObjectRelease(v145);
              swift_bridgeObjectRelease(0x80000001816E3070 | 0x8000000000000000);
            }
            else
            {
              if ((0x80000001816E3070 & 0x2000000000000000) != 0) {
                unint64_t v157 = (0x80000001816E3070 >> 56) & 0xF;
              }
              else {
                unint64_t v157 = 16;
              }
              _StringGuts.append(_:)(0xD000000000000010, 0x80000001816E3070 | 0x8000000000000000, 0, v157);
              swift_bridgeObjectRelease(0x80000001816E3070 | 0x8000000000000000);
              uint64_t v47 = v185;
              unint64_t object = v186;
            }
          }
          else
          {
            swift_bridgeObjectRelease(v145);
            unint64_t object = 0x80000001816E3070 | 0x8000000000000000;
          }
LABEL_142:
          (*(void (**)(Class *, unint64_t, uint64_t, uint64_t))(v46 + 24))(v47, object, v49, v46);
          goto LABEL_143;
        }
        if ((v93 & 0x2000000000000000) != 0)
        {
          if ((v143 & 0x2000000000000000) != 0)
          {
            unint64_t v148 = specialized _SmallString.init(_:appending:)(v92, v93, v144, v143);
            if ((v150 & 1) == 0)
            {
              uint64_t v151 = v148;
              unint64_t v152 = v149;
              swift_bridgeObjectRelease(v93);
              swift_bridgeObjectRelease(v145);
              uint64_t v185 = (Class *)v151;
              unint64_t v186 = v152;
              unint64_t v145 = v152;
              uint64_t v144 = v151;
              goto LABEL_130;
            }
            goto LABEL_128;
          }
        }
        else if ((v143 & 0x2000000000000000) != 0)
        {
LABEL_128:
          uint64_t v147 = HIBYTE(v145) & 0xF;
          goto LABEL_129;
        }
        uint64_t v147 = v144 & 0xFFFFFFFFFFFFLL;
LABEL_129:
        _StringGuts.append(_:)(v144, v145, 0, v147);
        swift_bridgeObjectRelease(v145);
        uint64_t v144 = (uint64_t)v185;
        unint64_t v145 = v186;
        goto LABEL_130;
      case 7:
        uint64_t v50 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v21 + 320))(v16, v23);
        if (v50 == 1)
        {
          unint64_t v51 = 0xE800000000000000;
          uint64_t v52 = 0x7265626D656D2031;
          uint64_t v53 = v184;
          goto LABEL_167;
        }
        uint64_t v94 = v50;
        uint64_t v95 = a6;
        unint64_t v96 = specialized static String._createEmpty(withInitialCapacity:)(10);
        uint64_t v98 = v97;
        uint64_t v185 = (Class *)v96;
        unint64_t v186 = v97;
        uint64_t v99 = HIBYTE(v97) & 0xF;
        if ((v97 & 0x2000000000000000) == 0) {
          uint64_t v99 = v96 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v53 = v184;
        if (v99 || (v96 & ~v97 & 0x2000000000000000) != 0)
        {
          if ((v97 & 0x2000000000000000) == 0
            || (unint64_t v100 = specialized _SmallString.init(_:appending:)(v96, v97, 0, 0xE000000000000000), (v102 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            unint64_t v103 = (unint64_t)v185;
            unint64_t v104 = v186;
            goto LABEL_146;
          }
          unint64_t v103 = v100;
          unint64_t v104 = v101;
          swift_bridgeObjectRelease(v98);
          swift_bridgeObjectRelease(0xE000000000000000);
          uint64_t v185 = (Class *)v103;
        }
        else
        {
          swift_bridgeObjectRelease(v97);
          unint64_t v103 = 0;
          unint64_t v104 = 0xE000000000000000;
          uint64_t v185 = 0;
        }
        unint64_t v186 = v104;
LABEL_146:
        uint64_t v160 = _int64ToString(_:radix:uppercase:)(v94, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v161 = v159;
        uint64_t v162 = HIBYTE(v104) & 0xF;
        if ((v104 & 0x2000000000000000) == 0) {
          uint64_t v162 = v103 & 0xFFFFFFFFFFFFLL;
        }
        if (!v162 && (v103 & ~v104 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v104);
          uint64_t v185 = (Class *)v160;
          unint64_t v186 = v161;
LABEL_159:
          a6 = v95;
          uint64_t v52 = 0x737265626D656D20;
          uint64_t v169 = HIBYTE(v161) & 0xF;
          if ((v161 & 0x2000000000000000) == 0) {
            uint64_t v169 = v160 & 0xFFFFFFFFFFFFLL;
          }
          if (v169 || (v160 & ~v161 & 0x2000000000000000) != 0)
          {
            if ((v161 & 0x2000000000000000) == 0
              || (unint64_t v170 = specialized _SmallString.init(_:appending:)(v160, v161, 0x737265626D656D20uLL, 0xE800000000000000), (v172 & 1) != 0))
            {
              _StringGuts.append(_:)(0x737265626D656D20, 0xE800000000000000, 0, 8);
              swift_bridgeObjectRelease(0xE800000000000000);
              uint64_t v52 = (uint64_t)v185;
              unint64_t v51 = v186;
            }
            else
            {
              uint64_t v52 = v170;
              unint64_t v51 = v171;
              swift_bridgeObjectRelease(v161);
              swift_bridgeObjectRelease(0xE800000000000000);
            }
          }
          else
          {
            swift_bridgeObjectRelease(v161);
            unint64_t v51 = 0xE800000000000000;
          }
LABEL_167:
          (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a6 + 24))(v52, v51, v53, a6);
          uint64_t v158 = v51;
          goto LABEL_168;
        }
        if ((v104 & 0x2000000000000000) != 0)
        {
          if ((v159 & 0x2000000000000000) != 0)
          {
            unint64_t v164 = specialized _SmallString.init(_:appending:)(v103, v104, v160, v159);
            if ((v166 & 1) == 0)
            {
              uint64_t v167 = v164;
              unint64_t v168 = v165;
              swift_bridgeObjectRelease(v104);
              swift_bridgeObjectRelease(v161);
              uint64_t v185 = (Class *)v167;
              unint64_t v186 = v168;
              unint64_t v161 = v168;
              uint64_t v160 = v167;
              goto LABEL_159;
            }
            goto LABEL_157;
          }
        }
        else if ((v159 & 0x2000000000000000) != 0)
        {
LABEL_157:
          uint64_t v163 = HIBYTE(v161) & 0xF;
          goto LABEL_158;
        }
        uint64_t v163 = v160 & 0xFFFFFFFFFFFFLL;
LABEL_158:
        _StringGuts.append(_:)(v160, v161, 0, v163);
        swift_bridgeObjectRelease(v161);
        uint64_t v160 = (uint64_t)v185;
        unint64_t v161 = v186;
        goto LABEL_159;
      default:
        break;
    }
  }
  long long v180 = *(_OWORD *)(v17 + 24);
  uint64_t v181 = v20;
  uint64_t v182 = a6;
  uint64_t v25 = *(void (**)(char *, swift::SwiftError **, Class *))(v9 + 16);
  v25((char *)&v180 - v18, a1, a4);
  uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v190, v19, a4, v26, 6uLL)) {
    goto LABEL_8;
  }
  uint64_t v192 = 0;
  long long v190 = 0u;
  long long v191 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v190, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  v25((char *)v15, a1, a4);
  uint64_t v31 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  int v32 = swift_dynamicCast((char *)&v190, v15, a4, v31, 6uLL);
  uint64_t v34 = v183;
  uint64_t v33 = v184;
  if (v32)
  {
LABEL_8:
    outlined init with take of MirrorPath(&v190, (uint64_t)&v185);
    long long v35 = v188;
    __swift_project_boxed_opaque_existential_0Tm(&v185, v188);
    uint64_t v36 = (*(uint64_t (**)(void, void))(*((void *)&v35 + 1) + 8))(v35, *((void *)&v35 + 1));
    uint64_t v38 = v37;
    (*(void (**)(uint64_t))(v182 + 24))(v36);
    swift_bridgeObjectRelease(v38);
LABEL_9:
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v185);
    return;
  }
  uint64_t v192 = 0;
  long long v190 = 0u;
  long long v191 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v190, &demangling cache variable for type metadata for CustomStringConvertible?);
  v25((char *)v12, a1, a4);
  uint64_t v39 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v190, v12, a4, v39, 6uLL))
  {
    outlined init with take of MirrorPath(&v190, (uint64_t)&v185);
    long long v40 = v188;
    __swift_project_boxed_opaque_existential_0Tm(&v185, v188);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*((void *)&v40 + 1) + 8))(v34, v33, v182, v40, *((void *)&v40 + 1));
    goto LABEL_9;
  }
  uint64_t v192 = 0;
  long long v190 = 0u;
  long long v191 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v190, &demangling cache variable for type metadata for TextOutputStreamable?);
  uint64_t v54 = v182;
  if (v22 == 8) {
    goto LABEL_61;
  }
  if (v22 < 2)
  {
    TypeName = (uint64_t *)swift_getTypeName(v181, 1);
    if ((v56 & 0x8000000000000000) == 0)
    {
      uint64_t v57 = (uint8x16_t *)TypeName;
      int64_t v58 = v56;
      int64_t v59 = validateUTF8(_:)(TypeName, v56);
      if (v61) {
        uint64_t v62 = repairUTF8(_:firstKnownBrokenRange:)(v57->i8, v58, v59, v60);
      }
      else {
        uint64_t v62 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v57, v58, v59 & 1);
      }
      uint64_t v114 = v63;
      (*(void (**)(uint64_t))(v54 + 24))(v62);
      goto LABEL_64;
    }
LABEL_181:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  if (v22 != 2)
  {
LABEL_61:
    uint64_t v185 = v181;
    unint64_t v186 = v21;
    char v187 = v22;
    long long v188 = v180;
    char v189 = v24;
    ((void (*)(swift::SwiftError **, Class **, uint64_t, uint64_t, Class *, uint64_t, uint64_t))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(a1, &v185, v34, 1, a4, v33, v182);
    return;
  }
  uint64_t v105 = (uint64_t *)swift_getTypeName(v181, 1);
  if (v106 < 0) {
    goto LABEL_181;
  }
  uint64_t v107 = (uint8x16_t *)v105;
  int64_t v108 = v106;
  int64_t v109 = validateUTF8(_:)(v105, v106);
  if (v111) {
    uint64_t v112 = repairUTF8(_:firstKnownBrokenRange:)(v107->i8, v108, v109, v110);
  }
  else {
    uint64_t v112 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v107, v108, v109 & 1);
  }
  uint64_t v173 = v113;
  unint64_t v174 = *(void (**)(uint64_t))(v182 + 24);
  v174(v112);
  swift_bridgeObjectRelease(v173);
  uint64_t v175 = swift_EnumCaseName(a1, (unint64_t *)a4);
  if (v175)
  {
    unint64_t v176 = specialized String.init(validatingUTF8:)(v175);
    if (v177)
    {
      unint64_t v178 = v176;
      uint64_t v114 = v177;
      uint64_t v179 = v182;
      ((void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v174)(46, 0xE100000000000000, v33, v182);
      swift_bridgeObjectRelease(0xE100000000000000);
      ((void (*)(unint64_t, uint64_t, uint64_t, uint64_t))v174)(v178, v114, v33, v179);
LABEL_64:
      swift_bridgeObjectRelease(v114);
    }
  }
}

void _print_unlocked<A, B>(_:_:)(uint64_t a1, uint64_t a2, Class *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v59 = a2;
  uint64_t v60 = a4;
  uint64_t v8 = (uint64_t)*(a3 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  int64_t v58 = (unint64_t *)((char *)&v57 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (unint64_t *)((char *)&v57 - v12);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (unint64_t *)((char *)&v57 - v15);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (unint64_t *)((char *)&v57 - v18);
  MEMORY[0x1F4188790](v17);
  unint64_t v21 = (unint64_t *)((char *)&v57 - v20);
  uint64_t v63 = (uint64_t *)v22;
  __n128 v23 = __swift_allocate_boxed_opaque_existential_0Tm(&v61);
  char v24 = *(void (**)(unint64_t *, uint64_t, Class *))(v8 + 16);
  v24(v23, a1, a3);
  uint64_t v25 = v63;
  uint64_t v26 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v61, (uint64_t)v63);
  unint64_t DynamicType = (void *)swift_getDynamicType(v26, v25, 1);
  LODWORD(v25) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v61);
  if (v25)
  {
    v24(v21, a1, a3);
    uint64_t v28 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v61, v21, a3, v28, 7uLL);
    uint64_t v29 = (uint64_t)v63;
    uint64_t v30 = v64;
    __swift_project_boxed_opaque_existential_0Tm(&v61, (uint64_t)v63);
    uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v30 + 8))(v29, v30);
    uint64_t v33 = v32;
    uint64_t v34 = *(void (**)(uint64_t))(a5 + 24);
LABEL_3:
    v34(v31);
LABEL_4:
    swift_bridgeObjectRelease(v33);
LABEL_5:
    __swift_destroy_boxed_opaque_existential_1Tm(&v61);
    return;
  }
  uint64_t v35 = v59;
  v24(v19, a1, a3);
  if (swift_dynamicCast((char *)&v61, v19, a3, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v36 = v62;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(v61, v62, v60, a5);
    swift_bridgeObjectRelease(v36);
  }
  else
  {
    v24(v16, a1, a3);
    uint64_t v37 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v65, v16, a3, v37, 6uLL))
    {
      outlined init with take of MirrorPath(&v65, (uint64_t)&v61);
      uint64_t v38 = (uint64_t)v63;
      uint64_t v39 = v64;
      __swift_project_boxed_opaque_existential_0Tm(&v61, (uint64_t)v63);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v39 + 8))(v35, v60, a5, v38, v39);
      goto LABEL_5;
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v65, &demangling cache variable for type metadata for TextOutputStreamable?);
    v24(v13, a1, a3);
    long long v40 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    uint64_t v41 = v35;
    if (swift_dynamicCast((char *)&v65, v13, a3, v40, 6uLL))
    {
      outlined init with take of MirrorPath(&v65, (uint64_t)&v61);
      uint64_t v42 = (uint64_t)v63;
      uint64_t v43 = v64;
      __swift_project_boxed_opaque_existential_0Tm(&v61, (uint64_t)v63);
      uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v43 + 8))(v42, v43);
      uint64_t v33 = v44;
      uint64_t v34 = *(void (**)(uint64_t))(a5 + 24);
      goto LABEL_3;
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v65, &demangling cache variable for type metadata for CustomStringConvertible?);
    uint64_t v45 = v58;
    v24(v58, a1, a3);
    uint64_t v46 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    int v47 = swift_dynamicCast((char *)&v65, v45, a3, v46, 6uLL);
    uint64_t v48 = a5;
    uint64_t v49 = v60;
    if (v47)
    {
      outlined init with take of MirrorPath(&v65, (uint64_t)&v61);
      uint64_t v50 = (uint64_t)v63;
      uint64_t v51 = v64;
      __swift_project_boxed_opaque_existential_0Tm(&v61, (uint64_t)v63);
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(v51 + 8))(v50, v51);
      uint64_t v33 = v53;
      (*(void (**)(uint64_t))(a5 + 24))(v52);
      goto LABEL_4;
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v65, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v66 + 1) = a3;
    uint64_t v54 = __swift_allocate_boxed_opaque_existential_0Tm(&v65);
    v24(v54, a1, a3);
    Mirror.init(reflecting:)((uint64_t *)&v65, (uint64_t)&v61);
    uint64_t v55 = v62;
    uint64_t v56 = v64;
    ((void (*)(uint64_t, uint64_t *, uint64_t, void, Class *, uint64_t, uint64_t))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(a1, &v61, v41, 0, a3, v49, v48);
    swift_release(v56);
    swift_release(v55);
  }
}

void _dumpSuperclass_unlocked<A>(mirror:to:indent:maxDepth:maxItemCounter:visitedItems:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void (*v10)(uint64_t *__return_ptr, atomic_ullong *);
  atomic_ullong *v11;
  uint64_t v12;
  void (*v14)(uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v15;
  atomic_ullong *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t, uint64_t);
  Class *v23;
  atomic_ullong *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  long long v28;
  uint64_t v29;
  atomic_ullong v30;
  void *v31;
  uint64_t v32;
  BOOL v33;
  uint64_t *v34;
  void (*v35)(uint64_t *__return_ptr, id, atomic_ullong);
  id v36;
  uint64_t v37;
  uint64_t v38;
  int isUniquelyReferenced_nonNull;
  atomic_ullong v40;
  uint64_t v41;
  void (*v42)(id, atomic_ullong);
  id v43;
  uint64_t v44;
  atomic_ullong v45;
  uint64_t v46;
  Swift::String v47;
  void (*v49)(uint64_t, unint64_t, uint64_t, uint64_t);
  BOOL v51;
  atomic_ullong *v52;
  uint64_t v53;
  uint64_t v54;
  void (*v56)(uint64_t *__return_ptr, atomic_ullong *);
  atomic_ullong v57;
  atomic_ullong *v58;
  uint64_t v61;
  uint64_t v62;
  long long v63;
  uint64_t v64;
  char v65;
  uint64_t v66[5];

  if (*a5 < 1) {
    return;
  }
  uint64_t v9 = *a1;
  uint64_t v8 = (atomic_ullong *)a1[1];
  uint64_t v10 = (void (*)(uint64_t *__return_ptr, atomic_ullong *))a1[3];
  uint64_t v11 = (atomic_ullong *)a1[4];
  --*a5;
  if (a3 < 0) {
    goto LABEL_42;
  }
  uint64_t v12 = a8;
  uint64_t v52 = v11;
  uint64_t v56 = v10;
  int64_t v58 = v8;
  if (a3)
  {
    uint64_t v14 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a8 + 24);
    uint64_t v15 = a3;
    do
    {
      v14(32, 0xE100000000000000, a7, v12);
      swift_bridgeObjectRelease(0xE100000000000000);
      --v15;
    }
    while (v15);
  }
  uint64_t v16 = v58;
  uint64_t v17 = (*(uint64_t (**)(void))(*v58 + 320))();
  uint64_t v18 = 12162786;
  if (a4 > 0) {
    uint64_t v18 = 12556002;
  }
  uint64_t v54 = v17;
  uint64_t v19 = v17 == 0;
  uint64_t v20 = v17 ? v18 : 45;
  unint64_t v21 = v19 ? 0xE100000000000000 : 0xA300000000000000;
  uint64_t v22 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 24);
  v22(v20, v21, a7, v12);
  swift_bridgeObjectRelease(v21);
  v22(0x203A726570757320, 0xE800000000000000, a7, v12);
  swift_bridgeObjectRelease(0xE800000000000000);
  uint64_t v61 = v9;
  __n128 v23 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any.Type);
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v61, a2, v23, a7, v12);
  uint64_t v49 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v22;
  v22(10, 0xE100000000000000, a7, v12);
  swift_bridgeObjectRelease(0xE100000000000000);
  uint64_t v53 = a4 - 1;
  if (a4 < 1) {
    return;
  }
  swift_retain(v58);
  char v24 = swift_retain(v52);
  v56(&v61, v24);
  swift_release((uint64_t)v52);
  swift_release((uint64_t)v58);
  uint64_t v25 = v61;
  if (v61)
  {
    uint64_t v26 = v62;
    uint64_t v28 = v63;
    uint64_t v27 = v64;
    v65 &= 1u;
    if (__OFADD__(a3, 2))
    {
      __break(1u);
      goto LABEL_44;
    }
    _dumpSuperclass_unlocked<A>(mirror:to:indent:maxDepth:maxItemCounter:visitedItems:)(&v61, a2, a3 + 2, v53, a5, a6, a7, v12);
    outlined consume of Mirror?(v25, v26, v28, *((uint64_t *)&v28 + 1), v27);
    uint64_t v16 = v58;
  }
  uint64_t v29 = v54;
  if (v54 < 0) {
    goto LABEL_42;
  }
  uint64_t v31 = (void *)v16[2];
  uint64_t v30 = v16[3];
  swift_unknownObjectRetain(v31);
  if (!v54)
  {
LABEL_30:
    swift_unknownObjectRelease(v31);
    return;
  }
  uint64_t v32 = 0;
  uint64_t v33 = __OFADD__(a3, 2);
  uint64_t v51 = v33;
  uint64_t v34 = a5;
  while (*v34 > 0)
  {
    uint64_t v35 = *(void (**)(uint64_t *__return_ptr, id, atomic_ullong))(*v16 + 256);
    uint64_t v36 = swift_unknownObjectRetain(v31);
    v35(&v61, v36, v30);
    uint64_t v16 = v58;
    swift_unknownObjectRelease(v31);
    uint64_t v37 = v61;
    uint64_t v38 = v62;
    outlined init with take of Any(&v63, v66);
    isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v31);
    long long v40 = *v58;
    if (isUniquelyReferenced_nonNull)
    {
      uint64_t v41 = v12;
      uint64_t v42 = *(void (**)(id, atomic_ullong))(v40 + 272);
      uint64_t v43 = swift_unknownObjectRetain(v31);
      uint64_t v57 = v30;
      v42(v43, v30);
      uint64_t v16 = v58;
      uint64_t v12 = v41;
      uint64_t v34 = a5;
      swift_unknownObjectRelease(v31);
    }
    else
    {
      uint64_t v44 = (*(uint64_t (**)(void *, atomic_ullong))(v40 + 264))(v31, v30);
      uint64_t v57 = v45;
      swift_unknownObjectRelease(v31);
      uint64_t v31 = (void *)v44;
    }
    if (v51)
    {
      __break(1u);
LABEL_42:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    ++v32;
    _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)(v66, a2, v37, v38, a3 + 2, v53, v34, a6, a7, v12);
    swift_bridgeObjectRelease(v38);
    __swift_destroy_boxed_opaque_existential_1Tm(v66);
    uint64_t v29 = v54;
    uint64_t v30 = v57;
    if (v54 == v32) {
      goto LABEL_30;
    }
  }
  uint64_t v46 = a3 + 4;
  if (__OFADD__(a3, 4))
  {
LABEL_44:
    __break(1u);
    return;
  }
  if (v46 < 0) {
    goto LABEL_42;
  }
  swift_unknownObjectRelease(v31);
  if (a3 != -4)
  {
    do
    {
      v49(32, 0xE100000000000000, a7, v12);
      swift_bridgeObjectRelease(0xE100000000000000);
      --v46;
    }
    while (v46);
  }
  v49(40, 0xE100000000000000, a7, v12);
  swift_bridgeObjectRelease(0xE100000000000000);
  uint64_t v61 = v29 - v32;
  _print_unlocked<A, B>(_:_:)((uint64_t)&v61, a2, (Class *)&type metadata for Int, a7, v12);
  if (v32)
  {
    v49(0x65726F6D20, 0xE500000000000000, a7, v12);
    swift_bridgeObjectRelease(0xE500000000000000);
  }
  if (v29 - 1 == v32)
  {
    v49(0xA29646C69686320, 0xE800000000000000, a7, v12);
    swift_bridgeObjectRelease(0xE800000000000000);
  }
  else
  {
    int v47 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" children)\n", 0xBuLL, 1);
    ((void (*)(uint64_t))v49)(v47._countAndFlagsBits);
    swift_bridgeObjectRelease((uint64_t)v47._object);
  }
}

id AnyCollection.startIndex.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized AnyCollection.startIndex.getter(a1);
  return swift_unknownObjectRetain(v1);
}

uint64_t _debugPrint_unlocked<A, B>(_:_:)(uint64_t a1, uint64_t a2, Class *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (uint64_t)*(a3 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (unint64_t *)((char *)v34 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (unint64_t *)((char *)v34 - v15);
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (unint64_t *)((char *)v34 - v17);
  uint64_t v19 = *(void (**)(char *, uint64_t))(v10 + 16);
  v19((char *)v34 - v17, a1);
  uint64_t v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v37, v18, a3, v20, 6uLL)
    || (uint64_t v39 = 0,
        long long v37 = 0u,
        long long v38 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v37, &demangling cache variable for type metadata for CustomDebugStringConvertible?), ((void (*)(unint64_t *, uint64_t, Class *))v19)(v16, a1, a3), unint64_t v21 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible), swift_dynamicCast((char *)&v37, v16, a3, v21, 6uLL)))
  {
    outlined init with take of MirrorPath(&v37, (uint64_t)v34);
    uint64_t v22 = v35;
    uint64_t v23 = v36;
    __swift_project_boxed_opaque_existential_0Tm(v34, v35);
    uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 8))(v22, v23);
    uint64_t v26 = v25;
    (*(void (**)(uint64_t))(a5 + 24))(v24);
    swift_bridgeObjectRelease(v26);
    return __swift_destroy_boxed_opaque_existential_1Tm(v34);
  }
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v37, &demangling cache variable for type metadata for CustomStringConvertible?);
  ((void (*)(unint64_t *, uint64_t, Class *))v19)(v13, a1, a3);
  uint64_t v28 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v37, v13, a3, v28, 6uLL))
  {
    outlined init with take of MirrorPath(&v37, (uint64_t)v34);
    uint64_t v29 = v35;
    uint64_t v30 = v36;
    __swift_project_boxed_opaque_existential_0Tm(v34, v35);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v30 + 8))(a2, a4, a5, v29, v30);
    return __swift_destroy_boxed_opaque_existential_1Tm(v34);
  }
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v37, &demangling cache variable for type metadata for TextOutputStreamable?);
  *((void *)&v38 + 1) = a3;
  uint64_t v31 = __swift_allocate_boxed_opaque_existential_0Tm(&v37);
  ((void (*)(void *, uint64_t, Class *))v19)(v31, a1, a3);
  Mirror.init(reflecting:)((uint64_t *)&v37, (uint64_t)v34);
  uint64_t v32 = v34[1];
  uint64_t v33 = v36;
  ((void (*)(uint64_t, uint64_t *, uint64_t, uint64_t, Class *, uint64_t, uint64_t))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(a1, v34, a2, 1, a3, a4, a5);
  swift_release(v32);
  return swift_release(v33);
}

uint64_t EmptyCollection.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 56))(a2, 1, 1);
}

uint64_t protocol witness for IteratorProtocol.next() in conformance EmptyCollection<A>.Iterator@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return EmptyCollection.Iterator.next()(a1, a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance EmptyCollection<A>.Iterator@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return Sequence<>.makeIterator()(a1, a2);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance EmptyCollection<A>.Iterator(uint64_t a1, uint64_t a2)
{
  return Sequence._copyToContiguousArray()(a1, a2);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance EmptyCollection<A>.Iterator()
{
  return Sequence._copyContents(initializing:)();
}

uint64_t protocol witness for Sequence.makeIterator() in conformance EmptyCollection<A>(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence._base.modify(*(void *)(a1 + 16), a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance EmptyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance EmptyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a3);
  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t EmptyCollection.startIndex.getter()
{
  return 0;
}

uint64_t EmptyCollection.endIndex.getter()
{
  return 0;
}

Swift::Int __swiftcall EmptyCollection.index(after:)(Swift::Int after)
{
}

Swift::Int __swiftcall EmptyCollection.index(before:)(Swift::Int before)
{
}

void EmptyCollection.subscript.getter()
{
}

void key path getter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A()
{
}

void key path setter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void EmptyCollection.subscript.setter()
{
}

void EmptyCollection.subscript.modify()
{
}

uint64_t EmptyCollection.subscript.getter(uint64_t result, uint64_t a2)
{
  if (result | a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x71uLL, 0);
  }
  return result;
}

uint64_t key path getter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A(uint64_t a1, uint64_t *a2)
{
  return EmptyCollection.subscript.getter(*a2, a2[1]);
}

uint64_t key path setter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  type metadata accessor for EmptyCollection(0, *(uint64_t *)((char *)a3 + a4 - 8), (uint64_t)a3, a4);
  return specialized EmptyCollection.subscript.setter(v4, v5);
}

uint64_t (*EmptyCollection.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3))()
{
  if (a2 | a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x71uLL, 0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t EmptyCollection.count.getter()
{
  return 0;
}

Swift::Int __swiftcall EmptyCollection.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  if (_ | offsetBy) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x83uLL, 0);
  }
  return 0;
}

Swift::Int_optional __swiftcall EmptyCollection.index(_:offsetBy:limitedBy:)(Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  if (_ | limitedBy) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x8BuLL, 0);
  }
  Swift::Bool v3 = offsetBy != 0;
  Swift::Int v4 = 0;
  result.value = v4;
  result.is_nil = v3;
  return result;
}

Swift::Int __swiftcall EmptyCollection.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  if (from) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "From must be startIndex (or endIndex)", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x93uLL, 0);
  }
  if (to) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "To must be endIndex (or startIndex)", 35, 2, "Swift/EmptyCollection.swift", 27, 2, 0x94uLL, 0);
  }
  return 0;
}

uint64_t EmptyCollection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "out of bounds", 13, 2, "Swift/EmptyCollection.swift", 27, 2, 0x9AuLL, 0);
  }
  uint64_t v6 = (unint64_t *)type metadata accessor for EmptyCollection(0, a4, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, v6, v7);
  uint64_t result = RandomAccessCollection<>.indices.getter((uint64_t)v6, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)v10);
  if (v10[0] != a2 || v10[1] != a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid bounds for an empty collection", 38, 2, "Swift/EmptyCollection.swift", 27, 2, 0x9BuLL, 0);
  }
  return result;
}

uint64_t static Range.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return static ClosedRange.== infix(_:_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for Range);
}

uint64_t static ClosedRange.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, uint64_t, uint64_t))
{
  uint64_t v6 = a3;
  uint64_t v24 = a2;
  uint64_t v9 = a5(0, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v21 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v21 - v14;
  uint64_t v16 = *(void *)(a4 + 8);
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 8);
  uint64_t v23 = v6;
  LOBYTE(v6) = v22(a1, a2, v6, v16);
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v17(v15, a1, v9);
  v17(v13, v24, v9);
  if (v6) {
    char v18 = ((uint64_t (*)(char *, char *))v22)(&v15[*(int *)(v9 + 36)], &v13[*(int *)(v9 + 36)]);
  }
  else {
    char v18 = 0;
  }
  uint64_t v19 = *(void (**)(char *, uint64_t))(v10 + 8);
  v19(v13, v9);
  v19(v15, v9);
  return v18 & 1;
}

uint64_t EmptyCollection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (unint64_t *)type metadata accessor for EmptyCollection(0, a5, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, v9, v10);
  RandomAccessCollection<>.indices.getter((uint64_t)v9, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)&v13);
  if (v13 != a1 || v14 != a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid range for an empty collection", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0xA2uLL, 0);
  }
  uint64_t result = RandomAccessCollection<>.indices.getter((uint64_t)v9, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)&v13);
  if (v13 != a3 || v14 != a4) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid bounds for an empty collection", 38, 2, "Swift/EmptyCollection.swift", 27, 2, 0xA3uLL, 0);
  }
  return result;
}

void protocol witness for MutableCollection.subscript.setter in conformance EmptyCollection<A>()
{
}

void protocol witness for MutableCollection.subscript.modify in conformance EmptyCollection<A>()
{
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance EmptyCollection<A>(uint64_t a1, uint64_t *a2)
{
  return specialized EmptyCollection.subscript.setter(*a2, a2[1]);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance EmptyCollection<A>(uint64_t a1, _OWORD *a2))()
{
  if (*a2 != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x71uLL, 0);
  }
  return EnumeratedSequence._base.modify;
}

void *protocol witness for MutableCollection.partition(by:) in conformance EmptyCollection<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a3, (uint64_t)a3);
  return MutableCollection<>.partition(by:)(a1, a2, (uint64_t)a3, WitnessTable, a4, a5);
}

void protocol witness for BidirectionalCollection.index(before:) in conformance EmptyCollection<A>()
{
}

void protocol witness for Collection.subscript.read in conformance EmptyCollection<A>(void **a1)
{
  *a1 = malloc(0x28uLL);
  protocol witness for MutableCollection.subscript.modify in conformance EmptyCollection<A>();
}

uint64_t protocol witness for Collection.subscript.getter in conformance EmptyCollection<A>(uint64_t *a1)
{
  return EmptyCollection.subscript.getter(*a1, a1[1]);
}

uint64_t protocol witness for Collection.indices.getter in conformance EmptyCollection<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance EmptyCollection<A>@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*result | a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x83uLL, 0);
  }
  *a3 = 0;
  return result;
}

void *protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance EmptyCollection<A>@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  if (*result | *a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x8BuLL, 0);
  }
  *(void *)a4 = 0;
  *(unsigned char *)(a4 + 8) = a2 != 0;
  return result;
}

uint64_t protocol witness for RandomAccessCollection.distance(from:to:) in conformance EmptyCollection<A>(void *a1, void *a2)
{
  if (*a1) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "From must be startIndex (or endIndex)", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x93uLL, 0);
  }
  if (*a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "To must be endIndex (or startIndex)", 35, 2, "Swift/EmptyCollection.swift", 27, 2, 0x94uLL, 0);
  }
  return 0;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance EmptyCollection<A>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return EmptyCollection._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1], *(void *)(a3 + 16));
}

{
  return EmptyCollection._failEarlyRangeCheck(_:bounds:)(*a1, a1[1], *a2, a2[1], *(void *)(a3 + 16));
}

void protocol witness for Collection.index(after:) in conformance EmptyCollection<A>()
{
}

uint64_t static EmptyCollection.== infix(_:_:)()
{
  return 1;
}

uint64_t _swift_stdlib_Equatable_isEqual_indirect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v16 - v11;
  uint64_t v13 = *(void (**)(char *))(v7 + 16);
  v13((char *)&v16 - v11);
  ((void (*)(char *, uint64_t, uint64_t))v13)(v10, a2, a3);
  LOBYTE(a4) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a4 + 8))(v12, v10, a3, a4);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v7 + 8);
  v14(v10, a3);
  v14(v12, a3);
  return a4 & 1;
}

BOOL static ObjectIdentifier.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL !== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = (a1 | a2) == 0;
  BOOL v3 = a1 == a2;
  if (!a2) {
    BOOL v3 = a1 == 0;
  }
  if (a1) {
    BOOL v2 = v3;
  }
  return !v2;
}

uint64_t protocol self-conformance witness for Error._domain.getter()
{
  swift_getErrorValue(*v0, &v3, v2);
  return (*(uint64_t (**)(unint64_t))(v2[2] + 8))(v2[1]);
}

uint64_t protocol self-conformance witness for Error._code.getter()
{
  swift_getErrorValue(*v0, &v3, v2);
  return (*(uint64_t (**)(unint64_t))(v2[2] + 16))(v2[1]);
}

uint64_t protocol self-conformance witness for Error._userInfo.getter()
{
  swift_getErrorValue(*v0, &v3, v2);
  return (*(uint64_t (**)(unint64_t))(v2[2] + 24))(v2[1]);
}

uint64_t protocol self-conformance witness for Error._getEmbeddedNSError()()
{
  swift_getErrorValue(*v0, &v3, v2);
  return (*(uint64_t (**)(unint64_t))(v2[2] + 32))(v2[1]);
}

unint64_t _getErrorDomainNSString<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v14 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  unint64_t v10 = v9;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  unint64_t v12 = String._bridgeToObjectiveCImpl()(v8, v10, v11);
  swift_bridgeObjectRelease(v10);
  return v12;
}

unint64_t String._bridgeToObjectiveCImpl()(uint64_t a1, unint64_t a2, void *a3)
{
  if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
    swift_once(&one-time initialization token for _bridgeInitializedSuccessfully, (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully, a3);
  }
  if (!_bridgeInitializedSuccessfully) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0x82uLL, 0);
  }
  _orphanedFoundationSubclassesReparented = 1;
  if ((a2 & 0x2000000000000000) != 0)
  {
    if ((a2 & 0x4000000000000000) == 0
      || (uint64_t v11 = a1,
          uint64_t v12 = a2 & 0xFFFFFFFFFFFFFFLL,
          (uint64_t v5 = objc_msgSend((id)type metadata accessor for __StringStorage(), sel_newTaggedNSStringWithASCIIBytes__length__, &v11, HIBYTE(a2) & 0xF)) == 0))
    {
      uint64_t v11 = a1;
      uint64_t v12 = a2;
      swift_bridgeObjectRetain(a2);
      _StringGuts.grow(_:)(16);
      uint64_t v6 = v12;
      uint64_t v5 = (void *)String._bridgeToObjectiveCImpl()(v11, v12);
      swift_bridgeObjectRelease(v6);
    }
  }
  else if ((a2 & 0x8000000000000000) != 0)
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      id v7 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      id v7 = _StringObject.sharedUTF8.getter(a1, a2);
      if (!v7) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringBridge.swift", 24, 2, 0x2BDuLL, 0);
      }
    }
    if (a1 >= 0) {
      unint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v8 = a1 & 0xFFFFFFFFFFFFLL | 0xC000000000000000;
    }
    unint64_t v9 = (unint64_t *)type metadata accessor for __SharedStringStorage();
    uint64_t v5 = swift_allocObject(v9, 0x31uLL, 7uLL);
    void v5[2] = 0;
    v5[3] = v7;
    *((unsigned char *)v5 + 48) = 1;
    v5[4] = v8;
    void v5[5] = 0;
  }
  else
  {
    uint64_t v5 = (void *)(a2 & 0xFFFFFFFFFFFFFFFLL);
    swift_unknownObjectRetain((id)(a2 & 0xFFFFFFFFFFFFFFFLL));
    if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
    {
      swift_unknownObjectRetain((id)(a2 & 0xFFFFFFFFFFFFFF8 | 0xC000000000000007));
      swift_unknownObjectRelease((id)(a2 & 0xFFFFFFFFFFFFFFFLL));
      return a2 & 0xFFFFFFFFFFFFFF8 | 0xC000000000000007;
    }
  }
  return (unint64_t)v5;
}

uint64_t _getErrorCode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  id v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _getErrorUserInfoNSDictionary<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  id v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _getErrorEmbeddedNSErrorIndirect<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  id v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _getErrorEmbeddedNSError<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
}

void swift_errorInMain(uint64_t a1)
{
  unint64_t v2 = 0xD00000000000001BLL;
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(29);
  uint64_t v5 = v4;
  unint64_t v28 = v3;
  unint64_t v29 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 || (v3 & ~v4 & 0x2000000000000000) != 0)
  {
    if ((v4 & 0x2000000000000000) == 0
      || ((unint64_t)"Swift/StringBridge.swift" & 0x2000000000000000) == 0
      || (unint64_t v8 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD00000000000001BLL, 0x80000001816DE3A0),
          (v10 & 1) != 0))
    {
      if (((unint64_t)"Swift/StringBridge.swift" & 0x2000000000000000) != 0) {
        unint64_t v11 = (0x80000001816DE3A0 >> 56) & 0xF;
      }
      else {
        unint64_t v11 = 27;
      }
      _StringGuts.append(_:)(0xD00000000000001BLL, 0x80000001816DE3A0, 0, v11);
      unint64_t v2 = v28;
      unint64_t v7 = v29;
LABEL_15:
      unint64_t v25 = 0;
      unint64_t v26 = 0xE000000000000000;
      uint64_t v27 = a1;
      uint64_t v12 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
      _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v27, (uint64_t)&v25, v12, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
      uint64_t v13 = v25;
      unint64_t v14 = v26;
      uint64_t v15 = HIBYTE(v7) & 0xF;
      if ((v7 & 0x2000000000000000) == 0) {
        uint64_t v15 = v2 & 0xFFFFFFFFFFFFLL;
      }
      if (!v15 && (v2 & ~v7 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v7);
        unint64_t v28 = v13;
        unint64_t v29 = v14;
        goto LABEL_29;
      }
      if ((v7 & 0x2000000000000000) != 0)
      {
        if ((v26 & 0x2000000000000000) != 0)
        {
          unint64_t v17 = specialized _SmallString.init(_:appending:)(v2, v7, v25, v26);
          if ((v19 & 1) == 0)
          {
            unint64_t v20 = v17;
            unint64_t v21 = v18;
            swift_bridgeObjectRelease(v7);
            swift_bridgeObjectRelease(v14);
            unint64_t v28 = v20;
            unint64_t v29 = v21;
            unint64_t v14 = v21;
            uint64_t v13 = v20;
            goto LABEL_29;
          }
          goto LABEL_27;
        }
      }
      else if ((v26 & 0x2000000000000000) != 0)
      {
LABEL_27:
        uint64_t v16 = HIBYTE(v14) & 0xF;
        goto LABEL_28;
      }
      uint64_t v16 = v25 & 0xFFFFFFFFFFFFLL;
LABEL_28:
      _StringGuts.append(_:)(v13, v14, 0, v16);
      swift_bridgeObjectRelease(v14);
      uint64_t v13 = v28;
      unint64_t v14 = v29;
LABEL_29:
      uint64_t v22 = v13 & 0xFFFFFFFFFFFFLL;
      if ((v14 & 0x2000000000000000) != 0) {
        uint64_t v22 = HIBYTE(v14) & 0xF;
      }
      if (v22 || (v13 & ~v14 & 0x2000000000000000) != 0)
      {
        if ((v14 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v14);
          unint64_t v24 = 0xA000000000000000;
          if (!(v14 & 0x80808080808080 | v13 & 0x8080808080808080)) {
            unint64_t v24 = 0xE000000000000000;
          }
          unint64_t v23 = v24 & 0xFF00000000000000 | ((HIBYTE(v14) & 0xF) << 56) | v14 & 0xFFFFFFFFFFFFFFLL;
        }
        else
        {
          _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
          uint64_t v13 = v28;
          unint64_t v23 = v29;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v14);
        uint64_t v13 = 0;
        unint64_t v23 = 0xE000000000000000;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v13, v23, "Swift/ErrorType.swift", 21, 2, 0xFDuLL, 0);
    }
    unint64_t v2 = v8;
    unint64_t v7 = v9;
    swift_bridgeObjectRelease(v5);
  }
  else
  {
    swift_bridgeObjectRelease(v4);
    unint64_t v7 = 0x80000001816DE3A0;
  }
  unint64_t v28 = v2;
  unint64_t v29 = v7;
  goto LABEL_15;
}

uint64_t Error<>._code.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a1, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v10 = (char *)&v16 - v9;
  uint64_t v11 = *(void *)(a4 + 8);
  char v12 = (*(uint64_t (**)(void))(v11 + 64))();
  (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a1, a3);
  if (v12) {
    uint64_t v13 = specialized numericCast<A, B>(_:)((uint64_t)v10, (uint64_t)AssociatedTypeWitness, v11);
  }
  else {
    uint64_t v13 = specialized numericCast<A, B>(_:)((uint64_t)v10, (uint64_t)AssociatedTypeWitness, v11);
  }
  uint64_t v14 = v13;
  (*(void (**)(char *, const char *))(v8 + 8))(v10, AssociatedTypeWitness);
  return v14;
}

void _abstract(file:line:)(const char *a1, uint64_t a2, char a3, unint64_t a4)
{
}

char *AnyIterator.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _IteratorBox(0, a3, a4, a4);
  unint64_t v7 = (char *)swift_allocObject((unint64_t *)v6, *((unsigned int *)v6 + 12), *((unsigned __int16 *)v6 + 26));
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32))(&v7[*(void *)(*(void *)v7 + 120)], a1, a3);
  return v7;
}

char *_IteratorBox.__allocating_init(_:)(uint64_t a1)
{
  unint64_t v3 = (char *)swift_allocObject((unint64_t *)v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v1 + 104) - 8) + 32))(&v3[*(void *)(*(void *)v3 + 120)], a1);
  return v3;
}

void *AnyIterator.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (unint64_t *)type metadata accessor for _ClosureBasedIterator(255, a3, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _ClosureBasedIterator<A>, v6, v7);
  char v10 = (unint64_t *)type metadata accessor for _IteratorBox(0, (uint64_t)v6, WitnessTable, v9);
  uint64_t result = swift_allocObject(v10, 0x20uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  return result;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance AnyIterator<A>()
{
  return AnyIterator.next()(*v0);
}

uint64_t _ClosureBasedIterator._body.getter(uint64_t a1, atomic_ullong *a2)
{
  return a1;
}

uint64_t _ClosureBasedIterator.next()(uint64_t (*a1)(void))
{
  return a1();
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _ClosureBasedIterator<A>()
{
  return _ClosureBasedIterator.next()(*v0);
}

void *_AnyIteratorBoxBase.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t _AnyIteratorBoxBase.init()()
{
  return v0;
}

uint64_t _AnyIteratorBoxBase.deinit()
{
  return v0;
}

void _AnyIteratorBoxBase.next()()
{
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _AnyIteratorBoxBase<A>()
{
  return (*(uint64_t (**)(void))(**(void **)v0 + 96))();
}

uint64_t _IteratorBox.init(_:)(uint64_t a1)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 104) - 8) + 32))(v1 + *(void *)(*(void *)v1 + 120), a1);
  return v1;
}

uint64_t _IteratorBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 104) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 120));
}

uint64_t _IteratorBox.deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 104) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 120));
  return v0;
}

void _IteratorBox.__deallocating_deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 104) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 120));

  swift_deallocClassInstance(v0);
}

uint64_t _IteratorBox.next()()
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)v0 + 112) + 16))(*(void *)(*(void *)v0 + 104));
}

uint64_t _IteratorBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 104) - 8) + 16))(a1, v1 + *(void *)(*(void *)v1 + 120));
}

uint64_t _IteratorBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 104) - 8) + 40))(v1 + *(void *)(*(void *)v1 + 120), a1);
}

uint64_t (*_IteratorBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _IteratorBox.__allocating_init()()
{
}

void _IteratorBox.init()()
{
}

void *_AnySequenceBox.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t _AnySequenceBox.init()()
{
  return v0;
}

void _AnySequenceBox._makeIterator()()
{
}

void _AnySequenceBox._underestimatedCount.getter()
{
}

void _AnySequenceBox._map<A>(_:)()
{
}

void _AnySequenceBox._filter(_:)()
{
}

void _AnySequenceBox._forEach(_:)()
{
}

void _AnySequenceBox.__customContainsEquatableElement(_:)()
{
}

void _AnySequenceBox.__copyToContiguousArray()()
{
}

void _AnySequenceBox.__copyContents(initializing:)()
{
}

uint64_t _AnySequenceBox.deinit()
{
  return v0;
}

void _AnySequenceBox.__deallocating_deinit()
{
  swift_deallocClassInstance(v0);
}

void _AnySequenceBox._drop(while:)()
{
}

void _AnySequenceBox._dropFirst(_:)()
{
}

void _AnySequenceBox._dropLast(_:)()
{
}

void _AnySequenceBox._prefix(_:)()
{
}

void _AnySequenceBox._prefix(while:)()
{
}

void _AnySequenceBox._suffix(_:)()
{
}

void _AnyCollectionBox.__ivar_destroyer()
{
  swift_unknownObjectRelease(*(id *)(v0 + 16));
  uint64_t v1 = *(void **)(v0 + 32);

  swift_unknownObjectRelease(v1);
}

void _AnyCollectionBox.__deallocating_deinit()
{
  uint64_t v1 = (void *)v0[2];
  swift_retain(v0);
  swift_unknownObjectRelease(v1);
  unint64_t v2 = (void *)v0[4];
  swift_release((uint64_t)v0);
  swift_unknownObjectRelease(v2);

  swift_deallocClassInstance((uint64_t)v0);
}

void _AnyCollectionBox._drop(while:)()
{
}

void _AnyCollectionBox._dropFirst(_:)()
{
}

void _AnyCollectionBox._dropLast(_:)()
{
}

void _AnyCollectionBox._prefix(_:)()
{
}

void _AnyCollectionBox._prefix(while:)()
{
}

void _AnyCollectionBox._suffix(_:)()
{
}

void _AnyCollectionBox.subscript.getter()
{
}

{
  _abstract(file:line:)("Swift/ExistentialCollection.swift", 33, 2, 0x192uLL);
}

void _AnyCollectionBox._index(after:)()
{
}

void _AnyCollectionBox._formIndex(after:)()
{
}

void _AnyCollectionBox._index(_:offsetBy:)()
{
}

void _AnyCollectionBox._index(_:offsetBy:limitedBy:)()
{
}

void _AnyCollectionBox._formIndex(_:offsetBy:)()
{
}

void _AnyCollectionBox._formIndex(_:offsetBy:limitedBy:)()
{
}

void _AnyCollectionBox._distance(from:to:)()
{
}

void _AnyCollectionBox._count.getter()
{
}

void *_AnyCollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_allocObject(v4, 0x30uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

void *_AnyCollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = a3;
  v4[5] = a4;
  return v4;
}

id _AnyCollectionBox._startIndex.getter()
{
  return swift_unknownObjectRetain(*(id *)(v0 + 16));
}

id _AnyCollectionBox._endIndex.getter()
{
  return swift_unknownObjectRetain(*(id *)(v0 + 32));
}

void _AnyCollectionBox.__allocating_init()()
{
}

void _AnyCollectionBox.init()()
{
}

void _AnyBidirectionalCollectionBox._drop(while:)()
{
}

void _AnyBidirectionalCollectionBox._dropFirst(_:)()
{
}

void _AnyBidirectionalCollectionBox._dropLast(_:)()
{
}

void _AnyBidirectionalCollectionBox._prefix(_:)()
{
}

void _AnyBidirectionalCollectionBox._prefix(while:)()
{
}

void _AnyBidirectionalCollectionBox._suffix(_:)()
{
}

void _AnyBidirectionalCollectionBox.subscript.getter()
{
}

void _AnyBidirectionalCollectionBox._index(before:)()
{
}

void _AnyBidirectionalCollectionBox._formIndex(before:)()
{
}

void *_AnyBidirectionalCollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_allocObject(v4, 0x30uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

void *_AnyBidirectionalCollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = a3;
  v4[5] = a4;
  return v4;
}

uint64_t _AnyCollectionBox.deinit()
{
  swift_unknownObjectRelease(*(id *)(v0 + 16));
  swift_unknownObjectRelease(*(id *)(v0 + 32));
  return v0;
}

void _AnyBidirectionalCollectionBox.__deallocating_deinit()
{
  swift_unknownObjectRelease(*(id *)(v0 + 16));
  swift_unknownObjectRelease(*(id *)(v0 + 32));

  swift_deallocClassInstance(v0);
}

void _AnyRandomAccessCollectionBox._drop(while:)()
{
}

void _AnyRandomAccessCollectionBox._dropFirst(_:)()
{
}

void _AnyRandomAccessCollectionBox._dropLast(_:)()
{
}

void _AnyRandomAccessCollectionBox._prefix(_:)()
{
}

void _AnyRandomAccessCollectionBox._prefix(while:)()
{
}

void _AnyRandomAccessCollectionBox._suffix(_:)()
{
}

void _AnyRandomAccessCollectionBox.subscript.getter()
{
}

void *_AnyRandomAccessCollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_allocObject(v4, 0x30uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

void *_AnyRandomAccessCollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = a3;
  v4[5] = a4;
  return v4;
}

char *_SequenceBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 208);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - v5;
  uint64_t v7 = *(void *)(v2 + 216);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 224), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject((unint64_t *)v14, *((unsigned int *)v14 + 12), *((unsigned __int16 *)v14 + 26));
  (*(void (**)(char *, char *, const char *))(v9 + 32))(&v15[*(void *)(*(void *)v15 + 120)], v11, AssociatedTypeWitness);
  return v15;
}

uint64_t _SequenceBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 208);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 224), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 216) + 40))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_SequenceBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 208);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = &v14[-v10];
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v9 + 16))(&v14[-v10], (uint64_t)v3 + *(void *)(v7 + 224), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 216);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  char v12 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSTRzsAE_pRsd_0_r_0_lIetMgnozo_Tpq5Tm((void (*)(char *, uint64_t *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error), (uint64_t)v14, v8, a3, v17);
  (*(void (**)(unsigned char *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s15CollectionOfOneVys7UnicodeO6ScalarVG_Tg506_sSS17ij42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n(int a1)
{
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, 1, 0);
  uint64_t result = &_swiftEmptyArrayStorage;
  uint64_t v3 = qword_1EC07DB60;
  uint64_t v4 = qword_1EC07DB60 + 1;
  if (qword_1EC07DB60 >= (unint64_t)qword_1EC07DB68 >> 1)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((unint64_t)qword_1EC07DB68 > 1, qword_1EC07DB60 + 1, 1);
    uint64_t result = &_swiftEmptyArrayStorage;
  }
  qword_1EC07DB60 = v4;
  *((_DWORD *)&_swiftEmptyArrayStorage + v3 + 8) = a1;
  return result;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s8RepeatedVys7UnicodeO6ScalarVG_Tg506_sSS17gh42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n(uint64_t a1, int a2)
{
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, a1 & ~(a1 >> 63), 0);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t result = &_swiftEmptyArrayStorage;
  if (a1)
  {
    uint64_t v5 = a1 - 1;
    if (a1 < (unint64_t)(a1 - 1)) {
      uint64_t v5 = a1;
    }
    uint64_t v6 = v5 + 1;
    uint64_t v7 = a1;
    do
    {
      uint64_t v13 = result;
      uint64_t v9 = result[2];
      unint64_t v8 = (unint64_t)result[3];
      if ((unint64_t)v9 >= v8 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v8 > 1, (int64_t)&v9->isa + 1, 1);
        uint64_t result = v13;
      }
      result[2] = (__objc2_class *)((char *)&v9->isa + 1);
      *((_DWORD *)result + (void)v9 + 8) = a2;
      --v7;
    }
    while (v7);
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v10 = a1 - v6;
  if (a1 != v6)
  {
    uint64_t v11 = result[2];
    do
    {
      uint64_t v14 = result;
      unint64_t v12 = (unint64_t)result[3];
      if ((unint64_t)v11 >= v12 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v12 > 1, (int64_t)&v11->isa + 1, 1);
        uint64_t result = v14;
      }
      result[2] = (__objc2_class *)((char *)&v11->isa + 1);
      *((_DWORD *)result + (void)v11 + 8) = a2;
      uint64_t v11 = (__objc2_class *)((char *)v11 + 1);
      --v10;
    }
    while (v10);
  }
  return result;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5(void (*a1)(uint64_t *__return_ptr, char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v55)(uint64_t *__return_ptr, char *);
  uint64_t v56;
  const char *v57;
  char *v58;
  uint64_t v59;
  __objc2_class **v60;

  uint64_t v5 = v4;
  uint64_t v55 = a1;
  uint64_t v56 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v48 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v49 = (char *)&v44 - v9;
  unint64_t v12 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v45 = (uint64_t)*(v12 - 1);
  uint64_t v46 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v50 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v44 - v16;
  int64_t v58 = *(char **)(a3 - 8);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v44 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v57 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v47 = *((void *)v57 - 1);
  MEMORY[0x1F4188790](v57);
  unint64_t v21 = (char *)&v44 - v20;
  uint64_t v22 = a4;
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a3, a4);
  uint64_t v60 = &_swiftEmptyArrayStorage;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v23 & ~(v23 >> 63), 0);
  (*((void (**)(char *, uint64_t, uint64_t))v58 + 2))(v19, v54, a3);
  unint64_t v24 = *(void (**)(uint64_t, uint64_t))(v22 + 32);
  int64_t v58 = v21;
  v24(a3, v22);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v25 = v22;
  unint64_t v26 = v57;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v25, a3, (uint64_t)v57, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v28 = AssociatedConformanceWitness;
  uint64_t v53 = AssociatedTypeWitness;
  uint64_t v54 = AssociatedConformanceWitness;
  if (v23)
  {
    uint64_t v51 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v52 = (void (*)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
    unint64_t v29 = (unsigned int (**)(char *, uint64_t, const char *))(v48 + 48);
    uint64_t v30 = (void (**)(char *, const char *))(v48 + 8);
    while (1)
    {
      v51(v26, v28);
      if ((*v29)(v17, 1, AssociatedTypeWitness) == 1) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Sequence.swift", 20, 2, 0x2B9uLL, 0);
      }
      v55(&v59, v17);
      if (v5) {
        break;
      }
      uint64_t v5 = 0;
      (*v30)(v17, AssociatedTypeWitness);
      int v31 = v59;
      uint64_t v32 = v60;
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v60))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v32[2]->isa + 1, 1);
        uint64_t v32 = v60;
      }
      uint64_t v28 = v54;
      uint64_t v34 = v32[2];
      unint64_t v33 = (unint64_t)v32[3];
      if ((unint64_t)v34 >= v33 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v33 > 1, (int64_t)&v34->isa + 1, 1);
        uint64_t v28 = v54;
        uint64_t v32 = v60;
      }
      v32[2] = (__objc2_class *)((char *)&v34->isa + 1);
      *((_DWORD *)v32 + (void)v34 + 8) = v31;
      --v23;
      uint64_t AssociatedTypeWitness = v53;
      unint64_t v26 = v57;
      if (!v23) {
        goto LABEL_11;
      }
    }
    (*(void (**)(char *, const char *))(v47 + 8))(v58, v26);
    swift_release((uint64_t)v60);
    return (__objc2_class **)((uint64_t (*)(char *, const char *))*v30)(v17, AssociatedTypeWitness);
  }
  else
  {
LABEL_11:
    uint64_t v35 = v50;
    uint64_t v52 = *(void (**)(const char *, uint64_t))(v28 + 16);
    v52(v26, v28);
    uint64_t v36 = v48;
    uint64_t v51 = *(void (**)(const char *, uint64_t))(v48 + 48);
    if (((unsigned int (*)(char *, uint64_t, const char *))v51)(v35, 1, AssociatedTypeWitness) == 1)
    {
LABEL_12:
      (*(void (**)(char *, const char *))(v47 + 8))(v58, v57);
      (*(void (**)(char *, Class *))(v45 + 8))(v35, v46);
      return v60;
    }
    else
    {
      uint64_t v48 = *(void *)(v36 + 32);
      long long v38 = (void (**)(char *, const char *))(v36 + 8);
      while (1)
      {
        uint64_t v39 = v49;
        ((void (*)(char *, char *, const char *))v48)(v49, v35, AssociatedTypeWitness);
        v55(&v59, v39);
        if (v5) {
          break;
        }
        uint64_t v5 = 0;
        (*v38)(v39, AssociatedTypeWitness);
        int v40 = v59;
        uint64_t v41 = v60;
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v60))
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v41[2]->isa + 1, 1);
          uint64_t v41 = v60;
        }
        uint64_t v43 = v41[2];
        unint64_t v42 = (unint64_t)v41[3];
        if ((unint64_t)v43 >= v42 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v42 > 1, (int64_t)&v43->isa + 1, 1);
          uint64_t v41 = v60;
        }
        v41[2] = (__objc2_class *)((char *)&v43->isa + 1);
        *((_DWORD *)v41 + (void)v43 + 8) = v40;
        uint64_t v35 = v50;
        ((void (*)(const char *))v52)(v57);
        uint64_t AssociatedTypeWitness = v53;
        if (((unsigned int (*)(char *, uint64_t, const char *))v51)(v35, 1, v53) == 1) {
          goto LABEL_12;
        }
      }
      (*v38)(v39, AssociatedTypeWitness);
      (*(void (**)(char *, const char *))(v47 + 8))(v58, v57);
      return (__objc2_class **)swift_release((uint64_t)v60);
    }
  }
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSTRzsAE_pRsd_0_r_0_lIetMgnozo_Tpq5Tm(void (*a1)(char *, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  unint64_t v69 = (char *)a4;
  long long v66 = a1;
  uint64_t v67 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v59 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v53 - v10;
  uint64_t v64 = v11;
  uint64_t v14 = type metadata accessor for Optional(0, v11, v12, v13);
  uint64_t v55 = (uint64_t)*(v14 - 1);
  uint64_t v56 = v14;
  uint64_t v15 = MEMORY[0x1F4188790](v14);
  uint64_t v57 = (char *)&v53 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v53 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v53 = (char *)&v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v63 = (char *)&v53 - v23;
  uint64_t v24 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v22);
  unint64_t v26 = (char *)&v53 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v62 = (unsigned int (*)(char *, uint64_t, uint64_t))a3;
  uint64_t v27 = swift_getAssociatedTypeWitness(0, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v58 = *((void *)v27 - 1);
  MEMORY[0x1F4188790](v27);
  unint64_t v29 = (char *)&v53 - v28;
  uint64_t v30 = a3;
  uint64_t v31 = a5;
  Swift::Int v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 40))(v30, a5);
  char v71 = &_swiftEmptyArrayStorage;
  long long v65 = type metadata accessor for ContiguousArray(0, (uint64_t)v69, v33, v34);
  ContiguousArray.reserveCapacity(_:)(v32);
  uint64_t v35 = (uint64_t)v62;
  (*(void (**)(char *, const char *, unsigned int (*)(char *, uint64_t, uint64_t)))(v24 + 16))(v26, v68, v62);
  uint64_t v36 = *(void (**)(uint64_t, uint64_t))(v31 + 32);
  unint64_t v69 = v29;
  v36(v35, v31);
  if (v32 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v68 = v27;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v31, v35, (uint64_t)v27, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v38 = AssociatedConformanceWitness;
  if (v32)
  {
    uint64_t v61 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v62 = (unsigned int (*)(char *, uint64_t, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v39 = (unsigned int (**)(char *, uint64_t, uint64_t))(v59 + 48);
    int v40 = (void (**)(char *, uint64_t))(v59 + 8);
    uint64_t v41 = v64;
    while (1)
    {
      v61(v68, v38);
      if ((*v39)(v19, 1, v41) == 1) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Sequence.swift", 20, 2, 0x2B9uLL, 0);
      }
      unint64_t v42 = v63;
      v66(v19, &v70);
      if (v6) {
        break;
      }
      uint64_t v6 = 0;
      uint64_t v43 = v38;
      uint64_t v44 = (uint64_t)v42;
      uint64_t v41 = v64;
      (*v40)(v19, v64);
      uint64_t v45 = v44;
      uint64_t v38 = v43;
      ContiguousArray.append(_:)(v45, (uint64_t)v65);
      if (!--v32) {
        goto LABEL_9;
      }
    }
    (*(void (**)(char *, const char *))(v58 + 8))(v69, v68);
    swift_release((uint64_t)v71);
    return (__objc2_class **)((uint64_t (*)(char *, uint64_t))*v40)(v19, v64);
  }
  else
  {
    uint64_t v41 = v64;
LABEL_9:
    uint64_t v46 = v57;
    uint64_t v63 = *(char **)(v38 + 16);
    uint64_t v64 = v38 + 16;
    ((void (*)(const char *, uint64_t))v63)(v68, v38);
    uint64_t v47 = v59;
    uint64_t v62 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v59 + 48);
    if (v62(v46, 1, v41) == 1)
    {
LABEL_13:
      (*(void (**)(char *, const char *))(v58 + 8))(v69, v68);
      (*(void (**)(char *, Class *))(v55 + 8))(v46, v56);
      return v71;
    }
    else
    {
      uint64_t v48 = *(void (**)(const char *, uint64_t))(v47 + 32);
      uint64_t v60 = v38;
      uint64_t v61 = v48;
      uint64_t v49 = (void (**)(char *, uint64_t))(v47 + 8);
      uint64_t v50 = (uint64_t)v53;
      uint64_t v51 = v54;
      while (1)
      {
        ((void (*)(char *, char *, uint64_t))v61)(v51, v46, v41);
        v66(v51, &v70);
        if (v6) {
          break;
        }
        uint64_t v6 = 0;
        (*v49)(v51, v41);
        ContiguousArray.append(_:)(v50, (uint64_t)v65);
        ((void (*)(const char *, uint64_t))v63)(v68, v60);
        if (v62(v46, 1, v41) == 1) {
          goto LABEL_13;
        }
      }
      (*v49)(v51, v41);
      (*(void (**)(char *, const char *))(v58 + 8))(v69, v68);
      return (__objc2_class **)swift_release((uint64_t)v71);
    }
  }
}

uint64_t _SequenceBox._filter(_:)(uint64_t a1, uint64_t a2)
{
  return _SequenceBox._filter(_:)(a1, a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))Sequence.filter(_:));
}

__objc2_class **Sequence.filter(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v46 = a1;
  uint64_t v47 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v37 = (uint64_t)*(v10 - 1);
  uint64_t v38 = v10;
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v36 - v12;
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  unint64_t v42 = (char *)&v36 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v17 = (char *)&v36 - v16;
  uint64_t v18 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v39 = *((void *)v18 - 1);
  MEMORY[0x1F4188790](v18);
  uint64_t v20 = (char *)&v36 - v19;
  uint64_t v50 = &_swiftEmptyArrayStorage;
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v18, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v23 = AssociatedConformanceWitness + 16;
  uint64_t v22 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v48 = v18;
  uint64_t v45 = v22;
  v22(v18, AssociatedConformanceWitness);
  uint64_t v24 = v49;
  uint64_t v25 = v49 + 48;
  uint64_t v44 = *(unsigned int (**)(char *, uint64_t, const char *))(v49 + 48);
  if (v44(v13, 1, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, const char *))(v39 + 8))(v20, v48);
    (*(void (**)(char *, Class *))(v37 + 8))(v13, v38);
    return v50;
  }
  else
  {
    uint64_t v43 = v25;
    uint64_t v49 = *(void *)(v24 + 32);
    int v40 = v13;
    uint64_t v41 = (void (**)(char *, const char *))(v24 + 8);
    while (1)
    {
      ((void (*)(char *, char *, const char *))v49)(v17, v13, AssociatedTypeWitness);
      char v27 = v46(v17);
      if (v4) {
        break;
      }
      if (v27)
      {
        uint64_t v28 = v23;
        uint64_t v29 = AssociatedConformanceWitness;
        uint64_t v30 = v20;
        uint64_t v31 = v42;
        ((void (*)(char *, char *, const char *))v49)(v42, v17, AssociatedTypeWitness);
        uint64_t v34 = type metadata accessor for ContiguousArray(0, (uint64_t)AssociatedTypeWitness, v32, v33);
        uint64_t v35 = (uint64_t)v31;
        uint64_t v20 = v30;
        uint64_t AssociatedConformanceWitness = v29;
        uint64_t v23 = v28;
        uint64_t v13 = v40;
        ContiguousArray.append(_:)(v35, (uint64_t)v34);
      }
      else
      {
        (*v41)(v17, AssociatedTypeWitness);
      }
      v45(v48, AssociatedConformanceWitness);
      if (v44(v13, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }
    (*v41)(v17, AssociatedTypeWitness);
    (*(void (**)(char *, const char *))(v39 + 8))(v20, v48);
    return (__objc2_class **)swift_release((uint64_t)v50);
  }
}

uint64_t _SequenceBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 208);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))((char *)&v11 - v8, (uint64_t)v2 + *(void *)(v5 + 224), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(int ***)(v5 + 216));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t Sequence.forEach(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t v37 = a1;
  uint64_t v38 = a2;
  uint64_t v39 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v31 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v30 - v8;
  uint64_t v12 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v13 = MEMORY[0x1F4188790](v12 - 1);
  uint64_t v15 = (char *)&v30 - v14;
  uint64_t v16 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v32 = *((void *)v19 - 1);
  MEMORY[0x1F4188790](v19);
  uint64_t v21 = (int **)((char *)&v30 - v20);
  (*(void (**)(char *, const char *, uint64_t))(v16 + 16))(v18, v40, a3);
  uint64_t v22 = (uint64_t)v39;
  ((void (*)(uint64_t, int **))v39[4])(a3, v39);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v22, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v39 = v21;
  int v40 = v19;
  uint64_t v36 = v24;
  v24(v19, AssociatedConformanceWitness);
  uint64_t v25 = v31;
  unint64_t v26 = *(unsigned int (**)(char *, uint64_t, const char *))(v31 + 48);
  if (v26(v15, 1, AssociatedTypeWitness) != 1)
  {
    uint64_t v33 = v26;
    uint64_t v34 = AssociatedConformanceWitness + 16;
    uint64_t v35 = AssociatedConformanceWitness;
    char v27 = *(void (**)(char *, char *, const char *))(v25 + 32);
    uint64_t v28 = (void (**)(char *, const char *))(v25 + 8);
    while (1)
    {
      v27(v9, v15, AssociatedTypeWitness);
      v37(v9);
      if (v4) {
        break;
      }
      (*v28)(v9, AssociatedTypeWitness);
      v36(v40, v35);
      if (v33(v15, 1, AssociatedTypeWitness) == 1) {
        return (*(uint64_t (**)(int **, const char *))(v32 + 8))(v39, v40);
      }
    }
    (*v28)(v9, AssociatedTypeWitness);
  }
  return (*(uint64_t (**)(int **, const char *))(v32 + 8))(v39, v40);
}

uint64_t _SequenceBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - v6;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v10 - v6, (uint64_t)v1 + *(void *)(v3 + 224), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v3 + 216) + 48))(a1, v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _SequenceBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 208);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v7 - v4, (uint64_t)v1 + *(void *)(v2 + 224), v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 216) + 56))(v3);
}

char *_SequenceBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v8 = *(void *)(v3 + 216);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 224), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject((unint64_t *)v15, *((unsigned int *)v15 + 12), *((unsigned __int16 *)v15 + 26));
  (*(void (**)(char *, char *, const char *))(v10 + 32))(&v16[*(void *)(*(void *)v16 + 120)], v12, AssociatedTypeWitness);
  return v16;
}

char *_SequenceBox._dropFirst(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v23 - v6;
  Sequence = type metadata accessor for DropFirstSequence(0, v4, *(void *)(v3 + 216), v8);
  uint64_t v10 = (uint64_t)*(Sequence - 1);
  uint64_t v11 = MEMORY[0x1F4188790](Sequence);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v23 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 224), v4);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't drop a negative number of elements from a sequence", 56, 2, "Swift/Sequence.swift", 20, 2, 0x1E3uLL, 0);
  }
  (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v13, v7, v4);
  *(void *)&v13[*((int *)Sequence + 9)] = a1;
  uint64_t v16 = *(void (**)(char *, char *, Class *))(v10 + 32);
  v16(v15, v13, Sequence);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DropFirstSequence<A>, (unint64_t *)Sequence, v17);
  uint64_t v20 = type metadata accessor for _SequenceBox(0, (uint64_t)Sequence, WitnessTable, v19);
  uint64_t v21 = (char *)swift_allocObject((unint64_t *)v20, *((unsigned int *)v20 + 12), *((unsigned __int16 *)v20 + 26));
  v16(&v21[*(void *)(*(void *)v21 + 224)], v15, Sequence);
  return v21;
}

uint64_t Sequence.dropFirst(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Sequence.dropFirst(_:)(a1, a2, a3, "Can't drop a negative number of elements from a sequence", 56, 0x1E3uLL, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for DropFirstSequence, a4);
}

char *_SequenceBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v3 = (char *)swift_allocObject((unint64_t *)v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v1 + 208) - 8) + 32))(&v3[*(void *)(*(void *)v3 + 224)], a1);
  return v3;
}

char *_SequenceBox._drop(while:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v44 = a1;
  uint64_t v45 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 216);
  uint64_t v5 = *(void *)(*v2 + 208);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v43 = (char *)&v38 - v8;
  uint64_t v9 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v38 - v10;
  uint64_t v13 = type metadata accessor for DropWhileSequence(0, v5, v4, v12);
  uint64_t v42 = (uint64_t)*(v13 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v38 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v38 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v41 = (char *)&v38 - v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, (uint64_t)v2 + *(void *)(v3 + 224), v5);
  uint64_t v39 = v19;
  int v40 = (unint64_t *)v13;
  uint64_t v21 = &v19[*((int *)v13 + 9)];
  uint64_t v22 = (char *)swift_getAssociatedTypeWitness(0, (int **)v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(char *, uint64_t, uint64_t, char *))(*((void *)v22 - 1) + 56))(v21, 1, 1, v22);
  uint64_t v23 = (uint64_t)v43;
  (*(void (**)(uint64_t, uint64_t))(v4 + 32))(v5, v4);
  uint64_t v24 = v16;
  uint64_t v25 = v46;
  DropWhileSequence.init(iterator:predicate:)(v23, v44, v45, v5, (int **)v4, (uint64_t)v16);
  uint64_t v28 = type metadata accessor for Optional(0, (uint64_t)v22, v26, v27);
  (*((void (**)(char *, Class *))*(v28 - 1) + 1))(v21, v28);
  if (!v25)
  {
    uint64_t v29 = *(void (**)(char *, char *, unint64_t *))(v42 + 32);
    uint64_t v30 = v39;
    uint64_t v31 = v40;
    v29(v39, v24, v40);
    uint64_t v32 = v41;
    v29(v41, v30, v31);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DropWhileSequence<A>, v31, v33);
    uint64_t v36 = type metadata accessor for _SequenceBox(0, (uint64_t)v31, WitnessTable, v35);
    uint64_t v22 = (char *)swift_allocObject((unint64_t *)v36, *((unsigned int *)v36 + 12), *((unsigned __int16 *)v36 + 26));
    v29(&v22[*(void *)(*(void *)v22 + 224)], v32, v31);
  }
  return v22;
}

uint64_t Sequence.drop(while:)@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v10 = (char *)&v25 - v9;
  uint64_t v12 = type metadata accessor for DropWhileSequence(0, a3, a4, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v25 - v15;
  uint64_t v17 = *(int *)(v14 + 36);
  uint64_t v26 = a5;
  uint64_t v18 = a5 + v17;
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v19 - 1) + 56))(v18, 1, 1, v19);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t v20 = v29;
  DropWhileSequence.init(iterator:predicate:)((uint64_t)v10, v27, v28, a3, (int **)a4, (uint64_t)v16);
  uint64_t v23 = type metadata accessor for Optional(0, (uint64_t)v19, v21, v22);
  if (v20) {
    return (*((uint64_t (**)(uint64_t, Class *))*(v23 - 1) + 1))(v18, v23);
  }
  (*((void (**)(uint64_t, Class *))*(v23 - 1) + 1))(v18, v23);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v13 + 32))(v26, v16, v12);
}

uint64_t _SequenceBox._dropLast(_:)(uint64_t a1)
{
  return _SequenceBox._dropLast(_:)(a1, Sequence.dropLast(_:));
}

uint64_t Sequence.dropLast(_:)(int64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v38 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v38 - v11;
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  MEMORY[0x1F4188790](v15 - 1);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v51 = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  MEMORY[0x1F4188790](v51);
  uint64_t v50 = (char *)&v38 - v19;
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't drop a negative number of elements from a sequence", 56, 2, "Swift/Sequence.swift", 20, 2, 0x436uLL, 0);
  }
  if (a1)
  {
    uint64_t v43 = v10;
    uint64_t v44 = v18;
    uint64_t v52 = &_swiftEmptyArrayStorage;
    uint64_t v53 = &_swiftEmptyArrayStorage;
    uint64_t v48 = v12;
    int64_t v49 = a1;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t))(a3 + 32);
    swift_retain((atomic_ullong *)&_swiftEmptyArrayStorage);
    v20(a2, a3);
    uint64_t v21 = (uint64_t)v48;
    uint64_t v22 = v51;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)v51, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v47 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
    v47(v22, AssociatedConformanceWitness);
    uint64_t v46 = *(unsigned int (**)(char *, uint64_t, const char *))(v7 + 48);
    if (v46(v17, 1, AssociatedTypeWitness) != 1)
    {
      unint64_t v27 = 0;
      uint64_t v45 = *(void (**)(uint64_t, char *, const char *))(v7 + 32);
      uint64_t v41 = (void (**)(char *, uint64_t, const char *))(v7 + 40);
      uint64_t v42 = v7 + 16;
      do
      {
        v45(v21, v17, AssociatedTypeWitness);
        uint64_t v30 = v52[2];
        if ((uint64_t)v30 >= v49)
        {
          if (v27 >= (unint64_t)v30) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
          }
          unint64_t v40 = (*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
          unint64_t v32 = *(void *)(v7 + 72) * v27;
          uint64_t v38 = AssociatedConformanceWitness;
          unint64_t v39 = v32;
          uint64_t v33 = (uint64_t)v43;
          (*(void (**)(char *, unint64_t, const char *))(v7 + 16))(v43, (unint64_t)v52 + v40 + v32, AssociatedTypeWitness);
          uint64_t v36 = type metadata accessor for ContiguousArray(0, (uint64_t)AssociatedTypeWitness, v34, v35);
          ContiguousArray.append(_:)(v33, (uint64_t)v36);
          uint64_t v37 = v52;
          if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v52))
          {
            uint64_t v37 = _ContiguousArrayBuffer._consumeAndCreateNew()((uint64_t)v37, (uint64_t *)v36[2]);
            uint64_t v52 = v37;
          }
          uint64_t v21 = (uint64_t)v48;
          uint64_t AssociatedConformanceWitness = v38;
          specialized Array._checkSubscript_mutating(_:)(v27, (uint64_t)v37);
          (*v41)((char *)v37 + v40 + v39, v21, AssociatedTypeWitness);
          if ((uint64_t)(v27 + 1) < v49) {
            ++v27;
          }
          else {
            unint64_t v27 = 0;
          }
        }
        else
        {
          uint64_t v31 = type metadata accessor for ContiguousArray(0, (uint64_t)AssociatedTypeWitness, v28, v29);
          ContiguousArray.append(_:)(v21, (uint64_t)v31);
        }
        v47(v51, AssociatedConformanceWitness);
      }
      while (v46(v17, 1, AssociatedTypeWitness) != 1);
    }
    (*(void (**)(char *, const char *))(v44 + 8))(v50, v51);
    uint64_t v24 = v53;
    swift_release((uint64_t)v52);
    return (uint64_t)v24;
  }
  else
  {
    uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 56);
    return v26(a2, a3);
  }
}

char *_SequenceBox._prefix(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v23 - v6;
  uint64_t v9 = type metadata accessor for PrefixSequence(0, v4, *(void *)(v3 + 216), v8);
  uint64_t v10 = (uint64_t)*(v9 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v23 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 224), v4);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't take a prefix of negative length", 38, 2, "Swift/Sequence.swift", 20, 2, 0x211uLL, 0);
  }
  (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v13, v7, v4);
  *(void *)&v13[*((int *)v9 + 9)] = a1;
  uint64_t v16 = *(void (**)(char *, char *, Class *))(v10 + 32);
  v16(v15, v13, v9);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for PrefixSequence<A>, (unint64_t *)v9, v17);
  uint64_t v20 = type metadata accessor for _SequenceBox(0, (uint64_t)v9, WitnessTable, v19);
  uint64_t v21 = (char *)swift_allocObject((unint64_t *)v20, *((unsigned int *)v20 + 12), *((unsigned __int16 *)v20 + 26));
  v16(&v21[*(void *)(*(void *)v21 + 224)], v15, v9);
  return v21;
}

uint64_t Sequence.prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Sequence.dropFirst(_:)(a1, a2, a3, "Can't take a prefix of negative length", 38, 0x211uLL, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for PrefixSequence, a4);
}

uint64_t Sequence.dropFirst(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t (*a7)(void, uint64_t, uint64_t)@<X6>, uint64_t a8@<X8>)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a4, a5, 2, "Swift/Sequence.swift", 20, 2, a6, 0);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a8, v8, a2);
  uint64_t result = a7(0, a2, a3);
  *(void *)(a8 + *(int *)(result + 36)) = a1;
  return result;
}

uint64_t _SequenceBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _SequenceBox._filter(_:)(a1, a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))Sequence.prefix(while:));
}

uint64_t _SequenceBox._filter(_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, void))
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 208);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))((char *)&v12 - v9, (uint64_t)v3 + *(void *)(v7 + 224), v8);
  return a3(a1, a2, v8, *(void *)(v7 + 216));
}

__objc2_class **Sequence.prefix(while:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v39 = a1;
  uint64_t v40 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v33 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v38 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v11 = (char *)&v31 - v10;
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v12, v13);
  MEMORY[0x1F4188790](v14 - 1);
  uint64_t v16 = (char *)&v31 - v15;
  uint64_t v17 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v32 = *((void *)v17 - 1);
  MEMORY[0x1F4188790](v17);
  uint64_t v19 = (char *)&v31 - v18;
  uint64_t v43 = &_swiftEmptyArrayStorage;
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t v20 = a3;
  uint64_t v21 = v33;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, v20, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v23 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v41 = v19;
  uint64_t v42 = v17;
  uint64_t v36 = AssociatedConformanceWitness + 16;
  uint64_t v37 = AssociatedConformanceWitness;
  uint64_t v35 = v23;
  ((void (*)(const char *))v23)(v17);
  uint64_t v34 = *(unsigned int (**)(char *, uint64_t, const char *))(v21 + 48);
  if (v34(v16, 1, AssociatedTypeWitness) != 1)
  {
    uint64_t v24 = *(void (**)(char *, char *, const char *))(v21 + 32);
    uint64_t v25 = (uint64_t)v38;
    while (1)
    {
      v24(v11, v16, AssociatedTypeWitness);
      char v26 = v39(v11);
      if (v4)
      {
        (*(void (**)(char *, const char *))(v33 + 8))(v11, AssociatedTypeWitness);
        (*(void (**)(char *, const char *))(v32 + 8))(v41, v42);
        return (__objc2_class **)swift_release((uint64_t)v43);
      }
      if ((v26 & 1) == 0) {
        break;
      }
      v24((char *)v25, v11, AssociatedTypeWitness);
      uint64_t v29 = type metadata accessor for ContiguousArray(0, (uint64_t)AssociatedTypeWitness, v27, v28);
      ContiguousArray.append(_:)(v25, (uint64_t)v29);
      v35(v42, v37);
      if (v34(v16, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_9;
      }
    }
    (*(void (**)(char *, const char *))(v33 + 8))(v11, AssociatedTypeWitness);
  }
LABEL_9:
  (*(void (**)(char *, const char *))(v32 + 8))(v41, v42);
  return v43;
}

uint64_t _SequenceBox._suffix(_:)(uint64_t a1)
{
  return _SequenceBox._dropLast(_:)(a1, (uint64_t (*)(uint64_t, uint64_t, void))Sequence.suffix(_:));
}

uint64_t _SequenceBox._dropLast(_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, void))
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 208);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))((char *)&v10 - v7, (uint64_t)v2 + *(void *)(v5 + 224), v6);
  return a2(a1, v6, *(void *)(v5 + 216));
}

__objc2_class **Sequence.suffix(_:)(Swift::Int a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v49 = *(AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v44 - v8;
  uint64_t v12 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v13 = MEMORY[0x1F4188790](v12 - 1);
  uint64_t v15 = (char *)&v44 - v14;
  uint64_t v16 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v44 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v55 = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  MEMORY[0x1F4188790](v55);
  uint64_t v54 = (char *)&v44 - v20;
  if (a1 < 0) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't take a suffix of negative length from a sequence", 54, 2, "Swift/Sequence.swift", 20, 2, 0x3E6uLL, 0);
  if (a1)
  {
    uint64_t v45 = v19;
    uint64_t v61 = &_swiftEmptyArrayStorage;
    uint64_t v47 = v16;
    uint64_t v53 = v18;
    uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 40);
    swift_retain((atomic_ullong *)&_swiftEmptyArrayStorage);
    uint64_t v22 = v21(a2, a3);
    Swift::Int v25 = a1;
    if (v22 < a1) {
      a1 = v22;
    }
    uint64_t v50 = type metadata accessor for ContiguousArray(0, (uint64_t)AssociatedTypeWitness, v23, v24);
    ContiguousArray.reserveCapacity(_:)(a1);
    char v26 = *(void (**)(char *, uint64_t, uint64_t))(v47 + 16);
    uint64_t v46 = v3;
    v26(v53, v3, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
    uint64_t v44 = a2;
    uint64_t v27 = v55;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)v55, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v52 = *(void (**)(const char *))(AssociatedConformanceWitness + 16);
    uint64_t v53 = (char *)AssociatedConformanceWitness;
    v52(v27);
    uint64_t v51 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v49 + 48);
    int64_t v29 = 0;
    if (v51(v15, 1, AssociatedTypeWitness) != 1)
    {
      int64_t v29 = 0;
      uint64_t v42 = *(void (**)(char *, char *, uint64_t *))(v49 + 32);
      uint64_t v48 = v49 + 40;
      v42(v9, v15, AssociatedTypeWitness);
      while (1)
      {
        uint64_t v43 = v61;
        if ((uint64_t)v61[2] < v25)
        {
          ContiguousArray.append(_:)((uint64_t)v9, (uint64_t)v50);
        }
        else
        {
          if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v61))
          {
            uint64_t v43 = _ContiguousArrayBuffer._consumeAndCreateNew()((uint64_t)v43, (uint64_t *)v50[2]);
            uint64_t v61 = v43;
          }
          specialized Array._checkSubscript_mutating(_:)(v29, (uint64_t)v43);
          (*(void (**)(unint64_t, char *, uint64_t *))(v49 + 40))((unint64_t)v43+ ((*(unsigned __int8 *)(v49 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v49 + 80))+ *(void *)(v49 + 72) * v29, v9, AssociatedTypeWitness);
          if (__OFADD__(v29, 1))
          {
            __break(1u);
            goto LABEL_24;
          }
          if (v29 + 1 >= v25) {
            int64_t v29 = 0;
          }
          else {
            ++v29;
          }
        }
        ((void (*)(const char *, char *))v52)(v55, v53);
        if (v51(v15, 1, AssociatedTypeWitness) == 1) {
          break;
        }
        v42(v9, v15, AssociatedTypeWitness);
      }
    }
    (*(void (**)(char *, const char *))(v45 + 8))(v54, v55);
    if (v29)
    {
      uint64_t v60 = &_swiftEmptyArrayStorage;
      uint64_t v30 = (atomic_ullong *)v61;
      Swift::Int v31 = (Swift::Int)v61[2];
      uint64_t v32 = v50;
      ContiguousArray.reserveCapacity(_:)(v31);
      uint64_t v33 = v46;
      if (v31 < v29) {
        goto LABEL_25;
      }
      ContiguousArray._checkIndex(_:)(v29);
      ContiguousArray._checkIndex(_:)(v31);
      unint64_t v34 = (*(unsigned __int8 *)(v49 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v49 + 80);
      uint64_t v56 = v30;
      uint64_t v57 = (char *)v30 + v34;
      int64_t v58 = v29;
      uint64_t v59 = (2 * v31) | 1;
      uint64_t v37 = (unint64_t *)type metadata accessor for ArraySlice(0, (uint64_t)AssociatedTypeWitness, v35, v36);
      swift_retain(v30);
      uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, v37, v38);
      ContiguousArray.append<A>(contentsOf:)((void (*)(void, void, void))&v56, (uint64_t)v32, (uint64_t)v37, WitnessTable);
      if (v29 < 0) {
LABEL_25:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      (*(void (**)(uint64_t, uint64_t))(v47 + 8))(v33, v44);
      uint64_t v40 = v61;
      ContiguousArray._checkIndex(_:)(0);
      ContiguousArray._checkIndex(_:)(v29);
      uint64_t v56 = v40;
      uint64_t v57 = (char *)v40 + v34;
      int64_t v58 = 0;
      uint64_t v59 = (2 * v29) | 1;
      ContiguousArray.append<A>(contentsOf:)((void (*)(void, void, void))&v56, (uint64_t)v32, (uint64_t)v37, WitnessTable);
      return v60;
    }
    else
    {
      swift_release((uint64_t)&_swiftEmptyArrayStorage);
      (*(void (**)(uint64_t, uint64_t))(v47 + 8))(v46, v44);
      return v61;
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(v16 + 8))(v3, a2);
    _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    return &_swiftEmptyArrayStorage;
  }
}

uint64_t _SequenceBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 208) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 224));
}

uint64_t _SequenceBox.deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 208) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 224));
  return v0;
}

void _SequenceBox.__deallocating_deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 208) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 224));

  swift_deallocClassInstance(v0);
}

uint64_t _SequenceBox.init(_base:)(uint64_t a1)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 208) - 8) + 32))(v1 + *(void *)(*(void *)v1 + 224), a1);
  return v1;
}

uint64_t _SequenceBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 208) - 8) + 16))(a1, v1 + *(void *)(*(void *)v1 + 224));
}

uint64_t _SequenceBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 208) - 8) + 40))(v1 + *(void *)(*(void *)v1 + 224), a1);
}

uint64_t (*_SequenceBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _SequenceBox.__allocating_init()()
{
}

void _SequenceBox.init()()
{
}

char *_CollectionBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - v5;
  uint64_t v7 = *(void *)(*(void *)(v2 + 352) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject((unint64_t *)v14, *((unsigned int *)v14 + 12), *((unsigned __int16 *)v14 + 26));
  (*(void (**)(char *, char *, const char *))(v9 + 32))(&v15[*(void *)(*(void *)v15 + 120)], v11, AssociatedTypeWitness);
  return v15;
}

uint64_t _CollectionBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v2 + 352) + 8) + 40))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_CollectionBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 344);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = &v14[-v10];
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v9 + 16))(&v14[-v10], (uint64_t)v3 + *(void *)(v7 + 360), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 352);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm((void (*)(char *, void *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error), (uint64_t)v14, v8, a3, v17);
  (*(void (**)(unsigned char *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_CollectionBox._filter(_:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 344);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))((char *)&v10 - v7, (uint64_t)v2 + *(void *)(v5 + 360), v6);
  return Sequence.filter(_:)(a1, a2, v6, *(void *)(*(void *)(v5 + 352) + 8));
}

uint64_t _CollectionBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 344);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))((char *)&v11 - v8, (uint64_t)v2 + *(void *)(v5 + 360), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(int ***)(*(void *)(v5 + 352) + 8));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t _CollectionBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - v6;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v10 - v6, (uint64_t)v1 + *(void *)(v3 + 360), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v3 + 352) + 8) + 48))(a1, v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _CollectionBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v7 - v4, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v2 + 352) + 8) + 56))(v3);
}

char *_CollectionBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v8 = *(void *)(*(void *)(v3 + 352) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 360), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject((unint64_t *)v15, *((unsigned int *)v15 + 12), *((unsigned __int16 *)v15 + 26));
  (*(void (**)(char *, char *, const char *))(v10 + 32))(&v16[*(void *)(*(void *)v16 + 120)], v12, AssociatedTypeWitness);
  return v16;
}

char *_CollectionBox._drop(while:)(uint64_t a1, uint64_t a2)
{
  return _CollectionBox._drop(while:)(a1, a2, (void (*)(uint64_t, uint64_t, uint64_t, int **))Collection.drop(while:));
}

char *_CollectionBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_allocObject((unint64_t *)v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  uint64_t v4 = specialized _CollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 344) - 8) + 8))(a1);
  return v4;
}

char *_CollectionBox._dropFirst(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.dropFirst(_:));
}

char *_CollectionBox._dropLast(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.dropLast(_:));
}

char *_CollectionBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _CollectionBox._drop(while:)(a1, a2, (void (*)(uint64_t, uint64_t, uint64_t, int **))Collection.prefix(while:));
}

char *_CollectionBox._drop(while:)(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, uint64_t, int **))
{
  uint64_t v24 = a3;
  uint64_t v22 = a2;
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 344);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v20 - v8;
  uint64_t v10 = *(int ***)(v5 + 352);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v21 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v20 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v3 + *(void *)(v5 + 360), v6);
  uint64_t v14 = v23;
  uint64_t v15 = v9;
  v24(a1, v22, v6, v10);
  if (!v14)
  {
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v18 = type metadata accessor for _CollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v17);
    swift_allocObject((unint64_t *)v18, *((unsigned int *)v18 + 12), *((unsigned __int16 *)v18 + 26));
    uint64_t v15 = specialized _CollectionBox.init(_base:)((uint64_t)v13);
    (*(void (**)(char *, const char *))(v21 + 8))(v13, AssociatedTypeWitness);
  }
  return v15;
}

char *_CollectionBox._prefix(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.prefix(_:));
}

char *_CollectionBox._suffix(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.suffix(_:));
}

char *_CollectionBox._dropFirst(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, int **))
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v8 = *(int ***)(v3 + 352);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v8, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 360), v4);
  v19(v18, v4, v8);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v15 = type metadata accessor for _CollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  swift_allocObject((unint64_t *)v15, *((unsigned int *)v15 + 12), *((unsigned __int16 *)v15 + 26));
  uint64_t v16 = specialized _CollectionBox.init(_base:)((uint64_t)v12);
  (*(void (**)(char *, const char *))(v10 + 8))(v12, AssociatedTypeWitness);
  return v16;
}

uint64_t _CollectionBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 344) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 360));
}

id *_CollectionBox.deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[43] - 8) + 8))((char *)v0 + *((void *)*v0 + 45));
  return v0;
}

void _CollectionBox.__deallocating_deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[43] - 8) + 8))((char *)v0 + *((void *)*v0 + 45));

  swift_deallocClassInstance((uint64_t)v0);
}

char *_CollectionBox.init(_base:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = specialized _CollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v3 + 344) - 8) + 8))(a1);
  return v4;
}

char *_IndexBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v3 = (char *)swift_allocObject((unint64_t *)v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v1 + 80) - 8) + 32))(&v3[*(void *)(*(void *)v3 + 96)], a1);
  return v3;
}

uint64_t _CollectionBox._unbox(_:file:line:)@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v26 = a6;
  uint64_t v27 = a3;
  int v29 = a5;
  uint64_t v28 = a4;
  uint64_t v30 = a7;
  uint64_t v10 = *(int ***)(*(void *)v7 + 352);
  uint64_t v11 = *(void *)(*(void *)v7 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v11, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t v24 = (uint64_t)*(v15 - 1);
  Swift::Int v25 = v15;
  MEMORY[0x1F4188790](v15);
  uint64_t v17 = (char *)&v23 - v16;
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v19 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v19(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v21 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v21 + 48))(v17, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v24 + 8))(v17, v25);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, v27, v28, v29, v26, 0);
  }
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v21 + 32))(v30, v17, AssociatedTypeWitness);
}

uint64_t _CollectionBox.subscript.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v42 = a3;
  uint64_t v6 = *v3;
  uint64_t v43 = *(int ***)(*v3 + 352);
  uint64_t v7 = *(void *)(v6 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v43, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v37 = (uint64_t)*(v11 - 1);
  uint64_t v38 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v36 - v13;
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v12);
  uint64_t v18 = (char *)&v36 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v40 = (char *)&v36 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v41 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 16);
  unint64_t v39 = (char *)&v36 - v23;
  v22();
  unint64_t ObjectType = swift_getObjectType(a1);
  Swift::Int v25 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v43, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v37 + 8))(v14, v38);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x2F0uLL, 0);
  }
  uint64_t v27 = *(void (**)(char *, char *, const char *))(v15 + 32);
  v27(v18, v14, AssociatedTypeWitness);
  uint64_t v28 = v40;
  v27(v40, v18, AssociatedTypeWitness);
  int v29 = v43;
  uint64_t v30 = v39;
  Swift::Int v31 = (void (*)(unsigned char *, void))((uint64_t (*)(unsigned char *, char *, uint64_t, int **))v43[10])(v44, v28, v7, v43);
  uint64_t v33 = v32;
  unint64_t v34 = swift_getAssociatedTypeWitness(0, (int **)v29[1], v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v34 - 1) + 16))(v42, v33, v34);
  v31(v44, 0);
  (*(void (**)(char *, const char *))(v15 + 8))(v28, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v41 + 8))(v30, v7);
}

char *_CollectionBox.subscript.getter(void (*a1)(char *, char *, const char *), uint64_t a2, void (*a3)(char *, const char *), void (**a4)(const char *, uint64_t, unint64_t))
{
  uint64_t v95 = a3;
  unint64_t v96 = a4;
  uint64_t v99 = a1;
  uint64_t v97 = *v4;
  uint64_t v6 = *(int ***)(v97 + 352);
  uint64_t v7 = *(void *)(v97 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v89 = *((void *)AssociatedTypeWitness - 1);
  unint64_t v90 = AssociatedTypeWitness;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v88 = (char *)&v77 - v9;
  uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v10, (uint64_t)v10, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v86 = (char *)&v77 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  unint64_t v85 = (char *)&v77 - v13;
  uint64_t v78 = type metadata accessor for Optional(0, (uint64_t)v10, v14, v15);
  uint64_t v77 = (uint64_t)*(v78 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v78);
  uint64_t v18 = (char *)&v77 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v77 - v20;
  uint64_t v22 = *((void *)v10 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v19);
  unint64_t v92 = (char *)&v77 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  char v91 = (char *)&v77 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v93 = (char *)&v77 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v94 = (char *)&v77 - v29;
  uint64_t v87 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range(0, (uint64_t)v10, AssociatedConformanceWitness, v31);
  uint64_t v83 = (uint64_t)*(v32 - 1);
  uint64_t v84 = v32;
  uint64_t v33 = MEMORY[0x1F4188790](v32);
  unint64_t v79 = (char *)&v77 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  char v81 = (char *)&v77 - v36;
  MEMORY[0x1F4188790](v35);
  uint64_t v82 = v37;
  uint64_t v38 = *(void (**)(void))(v37 + 16);
  unint64_t v80 = (char *)&v77 - v39;
  uint64_t v97 = v7;
  v38();
  unint64_t ObjectType = swift_getObjectType((unint64_t)v99);
  (*(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16))(v10, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v41 = *(unsigned int (**)(char *, uint64_t, const char *))(v22 + 48);
  if (v41(v21, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v77 + 8))(v21, v78);
    goto LABEL_8;
  }
  uint64_t v42 = v22;
  uint64_t v43 = *(void (**)(char *, char *, const char *))(v22 + 32);
  uint64_t v44 = v94;
  uint64_t v99 = v43;
  v43(v94, v21, v10);
  unint64_t v45 = swift_getObjectType((unint64_t)v95);
  v96[2](v10, AssociatedConformanceWitness, v45);
  if (v41(v18, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v77 + 8))(v18, v78);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x2F8uLL, 0);
  }
  uint64_t v46 = v93;
  v99(v93, v18, v10);
  uint64_t v47 = *(void (***)(const char *, uint64_t, unint64_t))(v42 + 16);
  uint64_t v48 = v91;
  ((void (*)(char *, char *, const char *))v47)(v91, v44, v10);
  uint64_t v49 = v92;
  unint64_t v96 = v47;
  ((void (*)(char *, char *, const char *))v47)(v92, v46, v10);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v48, v49, v10, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v50 = *(void (**)(char *, const char *))(v42 + 8);
  }
  uint64_t v95 = v50;
  v50(v49, v10);
  v50(v48, v10);
  uint64_t v51 = v85;
  uint64_t v52 = v99;
  uint64_t v53 = TupleTypeMetadata2;
  uint64_t v54 = &v85[*((int *)TupleTypeMetadata2 + 12)];
  v99(v85, v44, v10);
  uint64_t v55 = v54;
  v52(v54, v46, v10);
  uint64_t v56 = *((int *)v53 + 12);
  uint64_t v57 = v86;
  int64_t v58 = &v86[v56];
  uint64_t v59 = v96;
  ((void (*)(char *, char *, const char *))v96)(v86, v51, v10);
  ((void (*)(char *, char *, const char *))v59)(v58, v55, v10);
  uint64_t v60 = v79;
  v52(v79, v57, v10);
  uint64_t v61 = v95;
  v95(v58, v10);
  uint64_t v62 = &v57[*((int *)TupleTypeMetadata2 + 12)];
  v52(v57, v51, v10);
  v52(v62, v55, v10);
  uint64_t v63 = v84;
  v52(&v60[*((int *)v84 + 9)], v62, v10);
  v61(v57, v10);
  uint64_t v64 = v83;
  long long v65 = v81;
  (*(void (**)(char *, char *, Class *))(v83 + 32))(v81, v60, v63);
  uint64_t v66 = (uint64_t)v87;
  uint64_t v67 = (uint64_t)v88;
  uint64_t v68 = v80;
  uint64_t v69 = v97;
  ((void (*)(char *, uint64_t, int **))v87[11])(v65, v97, v87);
  (*(void (**)(char *, Class *))(v64 + 8))(v65, v63);
  (*(void (**)(char *, uint64_t))(v82 + 8))(v68, v69);
  uint64_t v70 = v69;
  uint64_t v71 = (uint64_t)v90;
  uint64_t v72 = swift_getAssociatedConformanceWitness(v66, v70, (uint64_t)v90, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v74 = type metadata accessor for _CollectionBox(0, v71, v72, v73);
  swift_allocObject((unint64_t *)v74, *((unsigned int *)v74 + 12), *((unsigned __int16 *)v74 + 26));
  unint64_t v75 = specialized _CollectionBox.init(_base:)(v67);
  (*(void (**)(uint64_t, uint64_t))(v89 + 8))(v67, v71);
  return v75;
}

char *_CollectionBox._index(after:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v39 = *(int ***)(*v2 + 352);
  uint64_t v6 = *(void *)(v5 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v39, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v33 = (uint64_t)*(v10 - 1);
  uint64_t v34 = v10;
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v32 - v12;
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790]((char *)&v32 - v14);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v37 = (char *)&v32 - v20;
  uint64_t v21 = (uint64_t)v2 + *(void *)(v5 + 360);
  uint64_t v38 = v22;
  uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 16);
  uint64_t v36 = v19;
  v23(v19, v21, v6);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v39, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v13, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v13, v34);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x2FEuLL, 0);
  }
  uint64_t v25 = *(void (**)(char *, char *, const char *))(v15 + 32);
  v25(v18, v13, AssociatedTypeWitness);
  uint64_t v26 = v36;
  uint64_t v27 = v37;
  ((void (*)(char *, uint64_t))v39[23])(v18, v6);
  (*(void (**)(char *, const char *))(v15 + 8))(v18, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v26, v6);
  uint64_t v29 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v28);
  uint64_t v30 = (char *)swift_allocObject((unint64_t *)v29, *((unsigned int *)v29 + 12), *((unsigned __int16 *)v29 + 26));
  v25(&v30[*(void *)(*(void *)v30 + 96)], v27, AssociatedTypeWitness);
  return v30;
}

uint64_t _CollectionBox._formIndex(after:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  uint64_t v9 = *(void *)(v8 + 352);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = swift_dynamicCastClass(a1, (uint64_t)v13);
  if (!v14) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x306uLL, 0);
  }
  uint64_t v15 = v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 360), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 192))(v15 + *(void *)(*(void *)v15 + 96), v4, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

char *_CollectionBox._index(_:offsetBy:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v39 = a3;
  uint64_t v6 = *v3;
  uint64_t v40 = *(int ***)(*v3 + 352);
  uint64_t v7 = *(void *)(v6 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v40, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v33 = (uint64_t)*(v11 - 1);
  uint64_t v34 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v33 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790]((char *)&v33 - v15);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v37 = (char *)&v33 - v21;
  uint64_t v22 = (uint64_t)v3 + *(void *)(v6 + 360);
  uint64_t v38 = v23;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(v23 + 16);
  uint64_t v36 = v20;
  v24(v20, v22, v7);
  swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v40, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v14, v34);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x30DuLL, 0);
  }
  uint64_t v26 = *(void (**)(char *, char *, const char *))(v16 + 32);
  v26(v19, v14, AssociatedTypeWitness);
  uint64_t v27 = v36;
  uint64_t v28 = v37;
  ((void (*)(char *, uint64_t, uint64_t))v40[17])(v19, v39, v7);
  (*(void (**)(char *, const char *))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v27, v7);
  uint64_t v30 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v29);
  uint64_t v31 = (char *)swift_allocObject((unint64_t *)v30, *((unsigned int *)v30 + 12), *((unsigned __int16 *)v30 + 26));
  v26(&v31[*(void *)(*(void *)v31 + 96)], v28, AssociatedTypeWitness);
  return v31;
}

char *_CollectionBox._index(_:offsetBy:limitedBy:)(unint64_t a1, unsigned int (*a2)(char *, uint64_t, const char *), uint64_t a3, unint64_t a4, void (*a5)(char *, char *, const char *))
{
  unint64_t v64 = a4;
  long long v65 = a5;
  uint64_t v63 = a3;
  uint64_t v68 = a2;
  uint64_t v7 = *v5;
  uint64_t v70 = *(int ***)(*v5 + 352);
  uint64_t v8 = *(void *)(v7 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v70, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v56 = (char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v61 = (char *)&v55 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v69 = (char *)&v55 - v16;
  uint64_t v17 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v55 - v18;
  uint64_t v22 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v20, v21);
  uint64_t v66 = (uint64_t)*(v22 - 1);
  uint64_t v67 = v22;
  uint64_t v23 = MEMORY[0x1F4188790](v22);
  uint64_t v60 = (char *)&v55 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v55 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v30 = (char *)&v55 - v29;
  MEMORY[0x1F4188790](v28);
  int64_t v58 = (char *)&v55 - v31;
  uint64_t v32 = (uint64_t)v5 + *(void *)(v7 + 360);
  uint64_t v62 = v17;
  uint64_t v33 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 16);
  uint64_t v59 = v19;
  v33(v19, v32, v8);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v35 = v68;
  uint64_t v36 = (void (*)(const char *, uint64_t, unint64_t, unsigned int (*)(char *, uint64_t, const char *)))*((void *)v68 + 2);
  uint64_t v57 = v8;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v70, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v36(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, v35);
  uint64_t v38 = (unsigned int (*)(char *, uint64_t, const char *))v10[6];
  if (v38(v30, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v66 + 8))(v30, v67);
    goto LABEL_9;
  }
  uint64_t v39 = (void (*)(char *, char *, const char *))v10[4];
  v39(v69, v30, AssociatedTypeWitness);
  unint64_t v40 = swift_getObjectType(v64);
  uint64_t v41 = (void (*)(const char *, uint64_t, unint64_t))*((void *)v65 + 2);
  uint64_t v55 = AssociatedConformanceWitness;
  v41(AssociatedTypeWitness, AssociatedConformanceWitness, v40);
  uint64_t v68 = v38;
  if (v38(v27, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v66 + 8))(v27, v67);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x316uLL, 0);
  }
  uint64_t v42 = v61;
  long long v65 = v39;
  v39(v61, v27, AssociatedTypeWitness);
  uint64_t v43 = v69;
  uint64_t v44 = v58;
  unint64_t v45 = v59;
  uint64_t v46 = v57;
  ((void (*)(char *, uint64_t, char *, uint64_t))v70[18])(v69, v63, v42, v57);
  uint64_t v47 = (void (*)(char *, const char *))v10[1];
  v47(v42, AssociatedTypeWitness);
  v47(v43, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v62 + 8))(v45, v46);
  uint64_t v48 = v60;
  (*(void (**)(char *, char *, Class *))(v66 + 32))(v60, v44, v67);
  if (v68(v48, 1, AssociatedTypeWitness) == 1) {
    return 0;
  }
  uint64_t v50 = v56;
  uint64_t v51 = v65;
  v65(v56, v48, AssociatedTypeWitness);
  uint64_t v53 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, v55, v52);
  uint64_t v49 = (char *)swift_allocObject((unint64_t *)v53, *((unsigned int *)v53 + 12), *((unsigned __int16 *)v53 + 26));
  v51(&v49[*(void *)(*(void *)v49 + 96)], v50, AssociatedTypeWitness);
  return v49;
}

uint64_t _CollectionBox._formIndex(_:offsetBy:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v24 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 352);
  uint64_t v6 = *(void *)(*v2 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v23 = (char *)&v23 - v10;
  uint64_t v11 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v23 - v12;
  uint64_t v14 = *a1;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = swift_dynamicCastClass(v14, (uint64_t)v17);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x321uLL, 0);
  }
  uint64_t v19 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, (uint64_t)v2 + *(void *)(v4 + 360), v6);
  uint64_t v20 = v19 + *(void *)(*(void *)v19 + 96);
  uint64_t v21 = v23;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 136))(v20, v24, v6, v5);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v6);
  (*(void (**)(uint64_t, const char *))(v8 + 8))(v20, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v8 + 32))(v20, v21, AssociatedTypeWitness);
}

BOOL _CollectionBox._formIndex(_:offsetBy:limitedBy:)(uint64_t *a1, uint64_t a2, void (*a3)(char *, char *, const char *), uint64_t a4)
{
  uint64_t v42 = a3;
  uint64_t v43 = a4;
  uint64_t v39 = a2;
  uint64_t v41 = *(void **)v4;
  uint64_t v6 = (int **)v41[44];
  uint64_t v7 = v41[43];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v35 = (uint64_t)*(v11 - 1);
  uint64_t v36 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  unint64_t v40 = (char *)&v35 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v35 - v15;
  uint64_t v17 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v14);
  uint64_t v37 = (char *)&v35 - v19;
  uint64_t v44 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v35 - v20;
  uint64_t v22 = *a1;
  uint64_t v38 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v25 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v24);
  uint64_t v26 = swift_dynamicCastClass(v22, (uint64_t)v25);
  if (!v26) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x32BuLL, 0);
  }
  uint64_t v27 = v26;
  (*(void (**)(char *, char *, uint64_t))(v44 + 16))(v21, &v4[v41[45]], v7);
  unint64_t ObjectType = swift_getObjectType((unint64_t)v42);
  (*(void (**)(const char *, uint64_t, unint64_t))(v43 + 16))(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType);
  uint64_t v43 = v17[6];
  if (((unsigned int (*)(char *, uint64_t, const char *))v43)(v16, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v35 + 8))(v16, v36);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x329uLL, 0);
  }
  uint64_t v29 = v37;
  uint64_t v42 = (void (*)(char *, char *, const char *))v17[4];
  v42(v37, v16, AssociatedTypeWitness);
  uint64_t v30 = v27 + *(void *)(*(void *)v27 + 96);
  uint64_t v31 = v40;
  ((void (*)(uint64_t, uint64_t, char *, uint64_t))v38[18])(v30, v39, v29, v7);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v21, v7);
  uint64_t v32 = (void (*)(uint64_t, const char *))v17[1];
  v32(v30, AssociatedTypeWitness);
  int v33 = ((uint64_t (*)(char *, uint64_t, const char *))v43)(v31, 1, AssociatedTypeWitness);
  if (v33 == 1)
  {
    (*(void (**)(char *, Class *))(v35 + 8))(v31, v36);
    uint64_t v31 = v29;
  }
  else
  {
    v32((uint64_t)v29, AssociatedTypeWitness);
  }
  v42((char *)v30, v31, AssociatedTypeWitness);
  return v33 != 1;
}

uint64_t _CollectionBox._distance(from:to:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v47 = a3;
  uint64_t v48 = a4;
  uint64_t v7 = *v4;
  uint64_t v50 = *(int ***)(*v4 + 352);
  uint64_t v8 = *(void *)(v7 + 344);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v50, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v12 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v40 = (uint64_t)*(v12 - 1);
  uint64_t v41 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v46 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v15);
  uint64_t v43 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v49 = (char *)&v39 - v22;
  MEMORY[0x1F4188790](v21);
  uint64_t v44 = v23;
  uint64_t v24 = *(void (**)(void))(v23 + 16);
  uint64_t v42 = (char *)&v39 - v25;
  v24();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v27 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t v45 = v8;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v50, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v27(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v29 = (unsigned int (*)(char *, uint64_t, const char *))v18[6];
  if (v29(v17, 1, AssociatedTypeWitness) == 1
    || (uint64_t v30 = (void (*)(char *, char *, const char *))v18[4],
        v30(v49, v17, AssociatedTypeWitness),
        unint64_t v31 = swift_getObjectType(v47),
        uint64_t v17 = v46,
        (*(void (**)(const char *, uint64_t, unint64_t))(v48 + 16))(AssociatedTypeWitness, AssociatedConformanceWitness, v31), v29(v17, 1, AssociatedTypeWitness) == 1))
  {
    (*(void (**)(char *, Class *))(v40 + 8))(v17, v41);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x333uLL, 0);
  }
  uint64_t v32 = v43;
  v30(v43, v17, AssociatedTypeWitness);
  int v33 = v49;
  uint64_t v34 = v42;
  uint64_t v35 = v45;
  uint64_t v36 = ((uint64_t (*)(char *, char *, uint64_t))v50[19])(v49, v32, v45);
  uint64_t v37 = (void (*)(char *, const char *))v18[1];
  v37(v32, AssociatedTypeWitness);
  v37(v33, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v34, v35);
  return v36;
}

uint64_t _CollectionBox._count.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 352) + 112))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

uint64_t _CollectionBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 344) - 8) + 16))(a1, v1 + *(void *)(*(void *)v1 + 360));
}

uint64_t _CollectionBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 344) - 8) + 40))(v1 + *(void *)(*(void *)v1 + 360), a1);
}

uint64_t (*_CollectionBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _CollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _CollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

char *_BidirectionalCollectionBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - v5;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(v2 + 376) + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject((unint64_t *)v14, *((unsigned int *)v14 + 12), *((unsigned __int16 *)v14 + 26));
  (*(void (**)(char *, char *, const char *))(v9 + 32))(&v15[*(void *)(*(void *)v15 + 120)], v11, AssociatedTypeWitness);
  return v15;
}

uint64_t _BidirectionalCollectionBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(v2 + 376) + 8) + 8) + 40))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_BidirectionalCollectionBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 368);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = &v14[-v10];
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v9 + 16))(&v14[-v10], (uint64_t)v3 + *(void *)(v7 + 384), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 376);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm((void (*)(char *, void *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error), (uint64_t)v14, v8, a3, *(void *)(v17 + 8));
  (*(void (**)(unsigned char *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_BidirectionalCollectionBox._filter(_:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 368);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))((char *)&v10 - v7, (uint64_t)v2 + *(void *)(v5 + 384), v6);
  return Sequence.filter(_:)(a1, a2, v6, *(void *)(*(void *)(*(void *)(v5 + 376) + 8) + 8));
}

uint64_t _BidirectionalCollectionBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 368);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))((char *)&v11 - v8, (uint64_t)v2 + *(void *)(v5 + 384), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(int ***)(*(void *)(*(void *)(v5 + 376) + 8) + 8));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t _BidirectionalCollectionBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - v6;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v10 - v6, (uint64_t)v1 + *(void *)(v3 + 384), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)(v3 + 376) + 8) + 8) + 48))(a1, v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _BidirectionalCollectionBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v7 - v4, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(v2 + 376) + 8) + 8) + 56))(v3);
}

char *_BidirectionalCollectionBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v3 + 376) + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 384), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject((unint64_t *)v15, *((unsigned int *)v15 + 12), *((unsigned __int16 *)v15 + 26));
  (*(void (**)(char *, char *, const char *))(v10 + 32))(&v16[*(void *)(*(void *)v16 + 120)], v12, AssociatedTypeWitness);
  return v16;
}

char *_BidirectionalCollectionBox._drop(while:)(uint64_t a1, uint64_t a2)
{
  return _BidirectionalCollectionBox._drop(while:)(a1, a2, (void (*)(uint64_t, uint64_t, uint64_t, int **))Collection.drop(while:));
}

char *_BidirectionalCollectionBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_allocObject((unint64_t *)v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  uint64_t v4 = specialized _BidirectionalCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 368) - 8) + 8))(a1);
  return v4;
}

char *_BidirectionalCollectionBox._dropFirst(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.dropFirst(_:));
}

char *_BidirectionalCollectionBox._dropLast(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropLast(_:)(a1, (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.dropLast(_:));
}

char *_BidirectionalCollectionBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _BidirectionalCollectionBox._drop(while:)(a1, a2, (void (*)(uint64_t, uint64_t, uint64_t, int **))Collection.prefix(while:));
}

char *_BidirectionalCollectionBox._drop(while:)(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, uint64_t, int **))
{
  uint64_t v24 = a3;
  uint64_t v22 = a2;
  uint64_t v21 = a1;
  uint64_t v4 = *v3;
  uint64_t v5 = *(void *)(*v3 + 368);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v20 - v7;
  uint64_t v9 = *(void *)(v4 + 376);
  uint64_t v10 = *(int ***)(v9 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v20 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v20 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, (uint64_t)v3 + *(void *)(v4 + 384), v5);
  uint64_t v14 = v8;
  uint64_t v15 = v23;
  v24(v21, v22, v5, v10);
  if (!v15)
  {
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
    uint64_t v18 = type metadata accessor for _BidirectionalCollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v17);
    swift_allocObject((unint64_t *)v18, *((unsigned int *)v18 + 12), *((unsigned __int16 *)v18 + 26));
    uint64_t v14 = specialized _BidirectionalCollectionBox.init(_base:)((uint64_t)v13);
    (*(void (**)(char *, const char *))(v20 + 8))(v13, AssociatedTypeWitness);
  }
  return v14;
}

char *_BidirectionalCollectionBox._prefix(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.prefix(_:));
}

char *_BidirectionalCollectionBox._dropFirst(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, int **))
{
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v19 - v6;
  uint64_t v8 = *(void *)(v3 + 376);
  uint64_t v9 = *(int ***)(v8 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v9, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 384), v4);
  v20(v19, v4, v9);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
  uint64_t v16 = type metadata accessor for _BidirectionalCollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  swift_allocObject((unint64_t *)v16, *((unsigned int *)v16 + 12), *((unsigned __int16 *)v16 + 26));
  uint64_t v17 = specialized _BidirectionalCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, const char *))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

char *_BidirectionalCollectionBox._suffix(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropLast(_:)(a1, (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.suffix(_:));
}

char *_BidirectionalCollectionBox._dropLast(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v20 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 368);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v19 - v7;
  uint64_t v9 = *(void *)(v4 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v9 + 8), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, (uint64_t)v2 + *(void *)(v4 + 384), v5);
  v20(a1, v5, v9);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
  uint64_t v16 = type metadata accessor for _BidirectionalCollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  swift_allocObject((unint64_t *)v16, *((unsigned int *)v16 + 12), *((unsigned __int16 *)v16 + 26));
  uint64_t v17 = specialized _BidirectionalCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, const char *))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

uint64_t _BidirectionalCollectionBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 368) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 384));
}

id *_BidirectionalCollectionBox.deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[46] - 8) + 8))((char *)v0 + *((void *)*v0 + 48));
  return v0;
}

void _BidirectionalCollectionBox.__deallocating_deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[46] - 8) + 8))((char *)v0 + *((void *)*v0 + 48));

  swift_deallocClassInstance((uint64_t)v0);
}

char *_BidirectionalCollectionBox.init(_base:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = specialized _BidirectionalCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v3 + 368) - 8) + 8))(a1);
  return v4;
}

uint64_t _BidirectionalCollectionBox._unbox(_:file:line:)@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v26 = a6;
  uint64_t v27 = a3;
  int v29 = a5;
  uint64_t v28 = a4;
  uint64_t v30 = a7;
  uint64_t v10 = *(int ***)(*(void *)(*(void *)v7 + 376) + 8);
  uint64_t v11 = *(void *)(*(void *)v7 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v11, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t v24 = (uint64_t)*(v15 - 1);
  uint64_t v25 = v15;
  MEMORY[0x1F4188790](v15);
  uint64_t v17 = (char *)&v23 - v16;
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v19 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v19(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v21 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v21 + 48))(v17, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v24 + 8))(v17, v25);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, v27, v28, v29, v26, 0);
  }
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v21 + 32))(v30, v17, AssociatedTypeWitness);
}

uint64_t _BidirectionalCollectionBox.subscript.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v42 = a3;
  uint64_t v6 = *v3;
  uint64_t v43 = *(int ***)(*(void *)(*v3 + 376) + 8);
  uint64_t v7 = *(void *)(v6 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v43, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v37 = (uint64_t)*(v11 - 1);
  uint64_t v38 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v36 - v13;
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v12);
  uint64_t v18 = (char *)&v36 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v40 = (char *)&v36 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v41 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 16);
  uint64_t v39 = (char *)&v36 - v23;
  v22();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v43, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v37 + 8))(v14, v38);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3BEuLL, 0);
  }
  uint64_t v27 = *(void (**)(char *, char *, const char *))(v15 + 32);
  v27(v18, v14, AssociatedTypeWitness);
  uint64_t v28 = v40;
  v27(v40, v18, AssociatedTypeWitness);
  int v29 = v43;
  uint64_t v30 = v39;
  unint64_t v31 = (void (*)(unsigned char *, void))((uint64_t (*)(unsigned char *, char *, uint64_t, int **))v43[10])(v44, v28, v7, v43);
  uint64_t v33 = v32;
  uint64_t v34 = swift_getAssociatedTypeWitness(0, (int **)v29[1], v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v34 - 1) + 16))(v42, v33, v34);
  v31(v44, 0);
  (*(void (**)(char *, const char *))(v15 + 8))(v28, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v41 + 8))(v30, v7);
}

char *_BidirectionalCollectionBox.subscript.getter(void (*a1)(char *, char *, const char *), uint64_t a2, unint64_t a3, void (**a4)(const char *, uint64_t, unint64_t))
{
  unint64_t v87 = a3;
  uint64_t v88 = a4;
  char v91 = a1;
  uint64_t v89 = *v4;
  uint64_t v80 = *(void *)(v89 + 376);
  uint64_t v6 = *(int ***)(v80 + 8);
  uint64_t v7 = *(void *)(v89 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v82 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v83 = AssociatedTypeWitness;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v81 = (char *)&v70 - v9;
  uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v10, (uint64_t)v10, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v78 = (char *)&v70 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v77 = (char *)&v70 - v13;
  uint64_t v71 = type metadata accessor for Optional(0, (uint64_t)v10, v14, v15);
  uint64_t v70 = (uint64_t)*(v71 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v71);
  uint64_t v18 = (char *)&v70 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v70 - v20;
  uint64_t v22 = (void *)*((void *)v10 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v19);
  unint64_t v85 = (char *)&v70 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v84 = (char *)&v70 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v86 = (char *)&v70 - v28;
  MEMORY[0x1F4188790](v27);
  unint64_t v92 = (char *)&v70 - v29;
  unint64_t v79 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range(0, (uint64_t)v10, AssociatedConformanceWitness, v31);
  uint64_t v76 = (uint64_t)*(v32 - 1);
  uint64_t v33 = MEMORY[0x1F4188790](v32);
  uint64_t v72 = (char *)&v70 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v74 = (char *)&v70 - v36;
  MEMORY[0x1F4188790](v35);
  uint64_t v75 = v37;
  uint64_t v38 = *(void (**)(void))(v37 + 16);
  uint64_t v73 = (char *)&v70 - v39;
  uint64_t v89 = v7;
  v38();
  unint64_t ObjectType = swift_getObjectType((unint64_t)v91);
  (*(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16))(v10, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v41 = (unsigned int (*)(char *, uint64_t, const char *))v22[6];
  if (v41(v21, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v70 + 8))(v21, v71);
    goto LABEL_8;
  }
  char v91 = (void (*)(char *, char *, const char *))v22[4];
  v91(v92, v21, v10);
  unint64_t v42 = swift_getObjectType(v87);
  v88[2](v10, AssociatedConformanceWitness, v42);
  if (v41(v18, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v70 + 8))(v18, v71);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3C7uLL, 0);
  }
  uint64_t v43 = v86;
  v91(v86, v18, v10);
  uint64_t v44 = (void (**)(const char *, uint64_t, unint64_t))v22[2];
  uint64_t v45 = v84;
  ((void (*)(char *, char *, const char *))v44)(v84, v92, v10);
  uint64_t v46 = v85;
  uint64_t v88 = v44;
  ((void (*)(char *, char *, const char *))v44)(v85, v43, v10);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v45, v46, v10, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  unint64_t v47 = (Class *)v22[1];
  }
  uint64_t v71 = v47;
  ((void (*)(char *, const char *))v47)(v46, v10);
  ((void (*)(char *, const char *))v47)(v45, v10);
  uint64_t v48 = v77;
  unint64_t v87 = (unint64_t)v32;
  uint64_t v49 = v91;
  uint64_t v50 = TupleTypeMetadata2;
  uint64_t v51 = &v77[*((int *)TupleTypeMetadata2 + 12)];
  v91(v77, v92, v10);
  v49(v51, v43, v10);
  uint64_t v52 = v78;
  uint64_t v53 = &v78[*((int *)v50 + 12)];
  uint64_t v54 = v88;
  ((void (*)(char *, char *, const char *))v88)(v78, v48, v10);
  ((void (*)(char *, char *, const char *))v54)(v53, v51, v10);
  uint64_t v55 = v72;
  v49(v72, v52, v10);
  uint64_t v56 = v71;
  ((void (*)(char *, const char *))v71)(v53, v10);
  uint64_t v57 = &v52[*((int *)TupleTypeMetadata2 + 12)];
  v49(v52, v48, v10);
  v49(v57, v51, v10);
  unint64_t v58 = v87;
  v49(&v55[*(int *)(v87 + 36)], v57, v10);
  ((void (*)(char *, const char *))v56)(v52, v10);
  uint64_t v59 = v76;
  uint64_t v60 = v74;
  (*(void (**)(char *, char *, unint64_t))(v76 + 32))(v74, v55, v58);
  uint64_t v61 = (uint64_t)v81;
  uint64_t v62 = v73;
  uint64_t v63 = v89;
  ((void (*)(char *, uint64_t))v79[11])(v60, v89);
  (*(void (**)(char *, unint64_t))(v59 + 8))(v60, v58);
  (*(void (**)(char *, uint64_t))(v75 + 8))(v62, v63);
  uint64_t v64 = (uint64_t)v83;
  uint64_t v65 = swift_getAssociatedConformanceWitness(v80, v63, (uint64_t)v83, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
  uint64_t v67 = type metadata accessor for _BidirectionalCollectionBox(0, v64, v65, v66);
  swift_allocObject((unint64_t *)v67, *((unsigned int *)v67 + 12), *((unsigned __int16 *)v67 + 26));
  uint64_t v68 = specialized _BidirectionalCollectionBox.init(_base:)(v61);
  (*(void (**)(uint64_t, uint64_t))(v82 + 8))(v61, v64);
  return v68;
}

char *_BidirectionalCollectionBox._index(after:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v39 = *(int ***)(*(void *)(*v2 + 376) + 8);
  uint64_t v6 = *(void *)(v5 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v39, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v33 = (uint64_t)*(v10 - 1);
  uint64_t v34 = v10;
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v32 - v12;
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790]((char *)&v32 - v14);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v37 = (char *)&v32 - v20;
  uint64_t v21 = (uint64_t)v2 + *(void *)(v5 + 384);
  uint64_t v38 = v22;
  uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 16);
  uint64_t v36 = v19;
  v23(v19, v21, v6);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v39, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v13, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v13, v34);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3CDuLL, 0);
  }
  uint64_t v25 = *(void (**)(char *, char *, const char *))(v15 + 32);
  v25(v18, v13, AssociatedTypeWitness);
  uint64_t v26 = v36;
  uint64_t v27 = v37;
  ((void (*)(char *, uint64_t))v39[23])(v18, v6);
  (*(void (**)(char *, const char *))(v15 + 8))(v18, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v26, v6);
  uint64_t v29 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v28);
  uint64_t v30 = (char *)swift_allocObject((unint64_t *)v29, *((unsigned int *)v29 + 12), *((unsigned __int16 *)v29 + 26));
  v25(&v30[*(void *)(*(void *)v30 + 96)], v27, AssociatedTypeWitness);
  return v30;
}

uint64_t _BidirectionalCollectionBox._formIndex(after:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  uint64_t v9 = *(void *)(*(void *)(v8 + 376) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = swift_dynamicCastClass(a1, (uint64_t)v13);
  if (!v14) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3D5uLL, 0);
  }
  uint64_t v15 = v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 384), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 192))(v15 + *(void *)(*(void *)v15 + 96), v4, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

char *_BidirectionalCollectionBox._index(_:offsetBy:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v39 = a3;
  uint64_t v6 = *v3;
  uint64_t v38 = *(void *)(*v3 + 376);
  uint64_t AssociatedConformanceWitness = *(int ***)(v38 + 8);
  uint64_t v7 = *(void *)(v6 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, AssociatedConformanceWitness, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v33 = (uint64_t)*(v11 - 1);
  uint64_t v34 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v33 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790]((char *)&v33 - v15);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v36 = (char *)&v33 - v21;
  uint64_t v22 = (uint64_t)v3 + *(void *)(v6 + 384);
  uint64_t v37 = v23;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(v23 + 16);
  uint64_t v35 = v20;
  v24(v20, v22, v7);
  swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = (int **)swift_getAssociatedConformanceWitness((uint64_t)AssociatedConformanceWitness, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v14, v34);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3DCuLL, 0);
  }
  uint64_t v26 = *(void (**)(char *, char *, const char *))(v16 + 32);
  v26(v19, v14, AssociatedTypeWitness);
  uint64_t v27 = v35;
  uint64_t v28 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v38 + 48))(v19, v39, v7);
  (*(void (**)(char *, const char *))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v37 + 8))(v27, v7);
  uint64_t v30 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedConformanceWitness, v29);
  uint64_t v31 = (char *)swift_allocObject((unint64_t *)v30, *((unsigned int *)v30 + 12), *((unsigned __int16 *)v30 + 26));
  v26(&v31[*(void *)(*(void *)v31 + 96)], v28, AssociatedTypeWitness);
  return v31;
}

char *_BidirectionalCollectionBox._index(_:offsetBy:limitedBy:)(unint64_t a1, unsigned int (*a2)(char *, uint64_t, const char *), uint64_t a3, unint64_t a4, void (*a5)(char *, char *, const char *))
{
  unint64_t v65 = a4;
  uint64_t v66 = a5;
  uint64_t v64 = a3;
  uint64_t v70 = a2;
  uint64_t v7 = *v5;
  uint64_t v63 = *(void *)(*v5 + 376);
  uint64_t v69 = *(int ***)(v63 + 8);
  uint64_t v8 = *(int ***)(v7 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v69, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v57 = (char *)&v56 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v61 = (char *)&v56 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v71 = (char *)&v56 - v16;
  uint64_t v17 = (uint64_t)*(v8 - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v56 - v18;
  uint64_t v22 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v20, v21);
  uint64_t v67 = (uint64_t)*(v22 - 1);
  uint64_t v68 = v22;
  uint64_t v23 = MEMORY[0x1F4188790](v22);
  uint64_t v60 = (char *)&v56 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v56 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v30 = (char *)&v56 - v29;
  MEMORY[0x1F4188790](v28);
  uint64_t v59 = (char *)&v56 - v31;
  uint64_t v32 = (uint64_t)v5 + *(void *)(v7 + 384);
  uint64_t v62 = v17;
  uint64_t v33 = *(void (**)(char *, uint64_t, int **))(v17 + 16);
  unint64_t v58 = v19;
  v33(v19, v32, v8);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v35 = v69;
  uint64_t v36 = v70;
  uint64_t v37 = (void (*)(const char *, uint64_t, unint64_t, unsigned int (*)(char *, uint64_t, const char *)))*((void *)v70 + 2);
  uint64_t v69 = v8;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v35, (uint64_t)v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v37(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, v36);
  uint64_t v39 = (unsigned int (*)(char *, uint64_t, const char *))v10[6];
  if (v39(v30, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v67 + 8))(v30, v68);
    goto LABEL_9;
  }
  uint64_t v40 = (void (*)(char *, char *, const char *))v10[4];
  v40(v71, v30, AssociatedTypeWitness);
  unint64_t v41 = swift_getObjectType(v65);
  unint64_t v42 = (void (*)(const char *, uint64_t, unint64_t))*((void *)v66 + 2);
  uint64_t v56 = AssociatedConformanceWitness;
  v42(AssociatedTypeWitness, AssociatedConformanceWitness, v41);
  uint64_t v70 = v39;
  if (v39(v27, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v67 + 8))(v27, v68);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3E5uLL, 0);
  }
  uint64_t v43 = v61;
  uint64_t v66 = v40;
  v40(v61, v27, AssociatedTypeWitness);
  uint64_t v45 = v58;
  uint64_t v44 = v59;
  uint64_t v46 = v71;
  unint64_t v47 = v69;
  (*(void (**)(char *, uint64_t, char *, int **))(v63 + 56))(v71, v64, v43, v69);
  uint64_t v48 = (void (*)(char *, const char *))v10[1];
  v48(v43, AssociatedTypeWitness);
  v48(v46, AssociatedTypeWitness);
  (*(void (**)(char *, int **))(v62 + 8))(v45, v47);
  uint64_t v49 = v60;
  (*(void (**)(char *, char *, Class *))(v67 + 32))(v60, v44, v68);
  if (v70(v49, 1, AssociatedTypeWitness) == 1) {
    return 0;
  }
  uint64_t v51 = v57;
  uint64_t v52 = v66;
  v66(v57, v49, AssociatedTypeWitness);
  uint64_t v54 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, v56, v53);
  uint64_t v50 = (char *)swift_allocObject((unint64_t *)v54, *((unsigned int *)v54 + 12), *((unsigned __int16 *)v54 + 26));
  v52(&v50[*(void *)(*(void *)v50 + 96)], v51, AssociatedTypeWitness);
  return v50;
}

uint64_t _BidirectionalCollectionBox._formIndex(_:offsetBy:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v24 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*(void *)(*v2 + 376) + 8);
  uint64_t v6 = *(void *)(*v2 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v23 = (char *)&v23 - v10;
  uint64_t v11 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v23 - v12;
  uint64_t v14 = *a1;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = swift_dynamicCastClass(v14, (uint64_t)v17);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3F0uLL, 0);
  }
  uint64_t v19 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, (uint64_t)v2 + *(void *)(v4 + 384), v6);
  uint64_t v20 = v19 + *(void *)(*(void *)v19 + 96);
  uint64_t v21 = v23;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 136))(v20, v24, v6, v5);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v6);
  (*(void (**)(uint64_t, const char *))(v8 + 8))(v20, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v8 + 32))(v20, v21, AssociatedTypeWitness);
}

BOOL _BidirectionalCollectionBox._formIndex(_:offsetBy:limitedBy:)(uint64_t *a1, uint64_t a2, void (*a3)(char *, char *, const char *), uint64_t a4)
{
  unint64_t v42 = a3;
  uint64_t v43 = a4;
  uint64_t v39 = a2;
  unint64_t v41 = *(void **)v4;
  uint64_t v6 = *(int ***)(v41[47] + 8);
  uint64_t v7 = v41[46];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v35 = (uint64_t)*(v11 - 1);
  uint64_t v36 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v40 = (char *)&v35 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v35 - v15;
  uint64_t v17 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v14);
  uint64_t v37 = (char *)&v35 - v19;
  uint64_t v44 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v35 - v20;
  uint64_t v22 = *a1;
  uint64_t v38 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v25 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v24);
  uint64_t v26 = swift_dynamicCastClass(v22, (uint64_t)v25);
  if (!v26) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3FAuLL, 0);
  }
  uint64_t v27 = v26;
  (*(void (**)(char *, char *, uint64_t))(v44 + 16))(v21, &v4[v41[48]], v7);
  unint64_t ObjectType = swift_getObjectType((unint64_t)v42);
  (*(void (**)(const char *, uint64_t, unint64_t))(v43 + 16))(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType);
  uint64_t v43 = v17[6];
  if (((unsigned int (*)(char *, uint64_t, const char *))v43)(v16, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v35 + 8))(v16, v36);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x3F8uLL, 0);
  }
  uint64_t v29 = v37;
  unint64_t v42 = (void (*)(char *, char *, const char *))v17[4];
  v42(v37, v16, AssociatedTypeWitness);
  uint64_t v30 = v27 + *(void *)(*(void *)v27 + 96);
  uint64_t v31 = v40;
  ((void (*)(uint64_t, uint64_t, char *, uint64_t))v38[18])(v30, v39, v29, v7);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v21, v7);
  uint64_t v32 = (void (*)(uint64_t, const char *))v17[1];
  v32(v30, AssociatedTypeWitness);
  int v33 = ((uint64_t (*)(char *, uint64_t, const char *))v43)(v31, 1, AssociatedTypeWitness);
  if (v33 == 1)
  {
    (*(void (**)(char *, Class *))(v35 + 8))(v31, v36);
    uint64_t v31 = v29;
  }
  else
  {
    v32((uint64_t)v29, AssociatedTypeWitness);
  }
  v42((char *)v30, v31, AssociatedTypeWitness);
  return v33 != 1;
}

uint64_t _BidirectionalCollectionBox._distance(from:to:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v49 = a3;
  uint64_t v50 = a4;
  uint64_t v7 = *v4;
  uint64_t v46 = *(void *)(*v4 + 376);
  uint64_t v8 = *(int ***)(v46 + 8);
  uint64_t v9 = *(void *)(v7 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v41 = (uint64_t)*(v13 - 1);
  unint64_t v42 = v13;
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v48 = (char *)&v40 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  uint64_t v44 = (char *)&v40 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v51 = (char *)&v40 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v45 = v24;
  uint64_t v25 = *(void (**)(void))(v24 + 16);
  uint64_t v43 = (char *)&v40 - v26;
  v25();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v28 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t v47 = v9;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v28(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v30 = (unsigned int (*)(char *, uint64_t, const char *))v19[6];
  if (v30(v18, 1, AssociatedTypeWitness) == 1
    || (uint64_t v31 = (void (*)(char *, char *, const char *))v19[4],
        v31(v51, v18, AssociatedTypeWitness),
        unint64_t v32 = swift_getObjectType(v49),
        uint64_t v18 = v48,
        (*(void (**)(const char *, uint64_t, unint64_t))(v50 + 16))(AssociatedTypeWitness, AssociatedConformanceWitness, v32), v30(v18, 1, AssociatedTypeWitness) == 1))
  {
    (*(void (**)(char *, Class *))(v41 + 8))(v18, v42);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x402uLL, 0);
  }
  int v33 = v44;
  v31(v44, v18, AssociatedTypeWitness);
  uint64_t v34 = v47;
  uint64_t v35 = v51;
  uint64_t v36 = v43;
  uint64_t v37 = (*(uint64_t (**)(char *, char *, uint64_t))(v46 + 64))(v51, v33, v47);
  uint64_t v38 = (void (*)(char *, const char *))v19[1];
  v38(v33, AssociatedTypeWitness);
  v38(v35, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v45 + 8))(v36, v34);
  return v37;
}

uint64_t _BidirectionalCollectionBox._count.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v2 + 376) + 8) + 112))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

char *_BidirectionalCollectionBox._index(before:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(int ***)(*(void *)(*v2 + 376) + 8);
  uint64_t v39 = *(void *)(*v2 + 376);
  uint64_t AssociatedConformanceWitness = (uint64_t)v6;
  uint64_t v7 = *(void *)(v5 + 368);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v34 = (uint64_t)*(v11 - 1);
  uint64_t v35 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v33 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790]((char *)&v33 - v15);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v37 = (char *)&v33 - v21;
  uint64_t v22 = (uint64_t)v2 + *(void *)(v5 + 384);
  uint64_t v38 = v23;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(v23 + 16);
  uint64_t v36 = v20;
  v24(v20, v22, v7);
  swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(AssociatedConformanceWitness, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v34 + 8))(v14, v35);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x40CuLL, 0);
  }
  uint64_t v26 = *(void (**)(char *, char *, const char *))(v16 + 32);
  v26(v19, v14, AssociatedTypeWitness);
  uint64_t v27 = v36;
  uint64_t v28 = v37;
  (*(void (**)(char *, uint64_t))(v39 + 32))(v19, v7);
  (*(void (**)(char *, const char *))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v27, v7);
  uint64_t v30 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v29);
  uint64_t v31 = (char *)swift_allocObject((unint64_t *)v30, *((unsigned int *)v30 + 12), *((unsigned __int16 *)v30 + 26));
  v26(&v31[*(void *)(*(void *)v31 + 96)], v28, AssociatedTypeWitness);
  return v31;
}

uint64_t _BidirectionalCollectionBox._formIndex(before:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v9 = *(void *)(v8 + 376);
  uint64_t v10 = *(int ***)(v9 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = swift_dynamicCastClass(a1, (uint64_t)v14);
  if (!v15) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x414uLL, 0);
  }
  uint64_t v16 = v15;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 384), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 40))(v16 + *(void *)(*(void *)v16 + 96), v4, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

uint64_t _BidirectionalCollectionBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 368) - 8) + 16))(a1, v1 + *(void *)(*(void *)v1 + 384));
}

uint64_t _BidirectionalCollectionBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 368) - 8) + 40))(v1 + *(void *)(*(void *)v1 + 384), a1);
}

uint64_t (*_BidirectionalCollectionBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _BidirectionalCollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _BidirectionalCollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

char *_RandomAccessCollectionBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - v5;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(*(void *)(v2 + 384) + 8) + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject((unint64_t *)v14, *((unsigned int *)v14 + 12), *((unsigned __int16 *)v14 + 26));
  (*(void (**)(char *, char *, const char *))(v9 + 32))(&v15[*(void *)(*(void *)v15 + 120)], v11, AssociatedTypeWitness);
  return v15;
}

uint64_t _RandomAccessCollectionBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(*(void *)(v2 + 384) + 8) + 8) + 8)
                                          + 40))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_RandomAccessCollectionBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 376);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = &v14[-v10];
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v9 + 16))(&v14[-v10], (uint64_t)v3 + *(void *)(v7 + 392), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 384);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm((void (*)(char *, void *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error), (uint64_t)v14, v8, a3, *(void *)(*(void *)(v17 + 8) + 8));
  (*(void (**)(unsigned char *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_RandomAccessCollectionBox._filter(_:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 376);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))((char *)&v10 - v7, (uint64_t)v2 + *(void *)(v5 + 392), v6);
  return Sequence.filter(_:)(a1, a2, v6, *(void *)(*(void *)(*(void *)(*(void *)(v5 + 384) + 8) + 8) + 8));
}

uint64_t _RandomAccessCollectionBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 376);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))((char *)&v11 - v8, (uint64_t)v2 + *(void *)(v5 + 392), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(int ***)(*(void *)(*(void *)(*(void *)(v5 + 384) + 8) + 8) + 8));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t _RandomAccessCollectionBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - v6;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v10 - v6, (uint64_t)v1 + *(void *)(v3 + 392), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)(*(void *)(v3 + 384) + 8)
                                                                           + 8)
                                                               + 8)
                                                   + 48))(a1, v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _RandomAccessCollectionBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v7 - v4, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(*(void *)(v2 + 384) + 8) + 8)
                                                        + 8)
                                            + 56))(v3);
}

char *_RandomAccessCollectionBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v8 = *(void *)(*(void *)(*(void *)(*(void *)(v3 + 384) + 8) + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 392), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject((unint64_t *)v15, *((unsigned int *)v15 + 12), *((unsigned __int16 *)v15 + 26));
  (*(void (**)(char *, char *, const char *))(v10 + 32))(&v16[*(void *)(*(void *)v16 + 120)], v12, AssociatedTypeWitness);
  return v16;
}

char *_RandomAccessCollectionBox._drop(while:)(uint64_t a1, uint64_t a2)
{
  return _RandomAccessCollectionBox._drop(while:)(a1, a2, (void (*)(uint64_t, uint64_t, uint64_t, int **))Collection.drop(while:));
}

char *_RandomAccessCollectionBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_allocObject((unint64_t *)v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  uint64_t v4 = specialized _RandomAccessCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 376) - 8) + 8))(a1);
  return v4;
}

char *_RandomAccessCollectionBox._dropFirst(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.dropFirst(_:));
}

char *_RandomAccessCollectionBox._dropLast(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropLast(_:)(a1, (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.dropLast(_:));
}

char *_RandomAccessCollectionBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _RandomAccessCollectionBox._drop(while:)(a1, a2, (void (*)(uint64_t, uint64_t, uint64_t, int **))Collection.prefix(while:));
}

char *_RandomAccessCollectionBox._drop(while:)(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, uint64_t, int **))
{
  uint64_t v24 = a3;
  uint64_t v22 = a2;
  uint64_t v21 = a1;
  uint64_t v4 = *v3;
  uint64_t v5 = *(void *)(*v3 + 376);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v20 - v7;
  uint64_t v9 = *(void *)(v4 + 384);
  uint64_t v10 = *(int ***)(*(void *)(v9 + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v20 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v20 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, (uint64_t)v3 + *(void *)(v4 + 392), v5);
  uint64_t v14 = v8;
  uint64_t v15 = v23;
  v24(v21, v22, v5, v10);
  if (!v15)
  {
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
    uint64_t v18 = type metadata accessor for _RandomAccessCollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v17);
    swift_allocObject((unint64_t *)v18, *((unsigned int *)v18 + 12), *((unsigned __int16 *)v18 + 26));
    uint64_t v14 = specialized _RandomAccessCollectionBox.init(_base:)((uint64_t)v13);
    (*(void (**)(char *, const char *))(v20 + 8))(v13, AssociatedTypeWitness);
  }
  return v14;
}

char *_RandomAccessCollectionBox._prefix(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, int **))Collection.prefix(_:));
}

char *_RandomAccessCollectionBox._dropFirst(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, int **))
{
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v19 - v6;
  uint64_t v8 = *(void *)(v3 + 384);
  uint64_t v9 = *(int ***)(*(void *)(v8 + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v9, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 392), v4);
  v20(v19, v4, v9);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
  uint64_t v16 = type metadata accessor for _RandomAccessCollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  swift_allocObject((unint64_t *)v16, *((unsigned int *)v16 + 12), *((unsigned __int16 *)v16 + 26));
  uint64_t v17 = specialized _RandomAccessCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, const char *))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

char *_RandomAccessCollectionBox._suffix(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropLast(_:)(a1, (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.suffix(_:));
}

char *_RandomAccessCollectionBox._dropLast(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v19 - v6;
  uint64_t v8 = *(void *)(v3 + 384);
  uint64_t v9 = *(void *)(v8 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v9 + 8), v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 392), v4);
  v20(v19, v4, v9);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
  uint64_t v16 = type metadata accessor for _RandomAccessCollectionBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  swift_allocObject((unint64_t *)v16, *((unsigned int *)v16 + 12), *((unsigned __int16 *)v16 + 26));
  uint64_t v17 = specialized _RandomAccessCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, const char *))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

uint64_t _RandomAccessCollectionBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 376) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 392));
}

id *_RandomAccessCollectionBox.deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[47] - 8) + 8))((char *)v0 + *((void *)*v0 + 49));
  return v0;
}

void _RandomAccessCollectionBox.__deallocating_deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[47] - 8) + 8))((char *)v0 + *((void *)*v0 + 49));

  swift_deallocClassInstance((uint64_t)v0);
}

char *_RandomAccessCollectionBox.init(_base:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = specialized _RandomAccessCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v3 + 376) - 8) + 8))(a1);
  return v4;
}

uint64_t _RandomAccessCollectionBox._unbox(_:file:line:)@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v26 = a6;
  uint64_t v27 = a3;
  int v29 = a5;
  uint64_t v28 = a4;
  uint64_t v30 = a7;
  uint64_t v10 = *(int ***)(*(void *)(*(void *)(*(void *)v7 + 384) + 8) + 8);
  uint64_t v11 = *(void *)(*(void *)v7 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v11, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t v24 = (uint64_t)*(v15 - 1);
  uint64_t v25 = v15;
  MEMORY[0x1F4188790](v15);
  uint64_t v17 = (char *)&v23 - v16;
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v19 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v19(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v21 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v21 + 48))(v17, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v24 + 8))(v17, v25);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, v27, v28, v29, v26, 0);
  }
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v21 + 32))(v30, v17, AssociatedTypeWitness);
}

uint64_t _RandomAccessCollectionBox.subscript.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v42 = a3;
  uint64_t v6 = *v3;
  uint64_t v43 = *(int ***)(*(void *)(*(void *)(*v3 + 384) + 8) + 8);
  uint64_t v7 = *(void *)(v6 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v43, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v37 = (uint64_t)*(v11 - 1);
  uint64_t v38 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v36 - v13;
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v12);
  uint64_t v18 = (char *)&v36 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v40 = (char *)&v36 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v41 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 16);
  uint64_t v39 = (char *)&v36 - v23;
  v22();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v43, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v37 + 8))(v14, v38);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x49AuLL, 0);
  }
  uint64_t v27 = *(void (**)(char *, char *, const char *))(v15 + 32);
  v27(v18, v14, AssociatedTypeWitness);
  uint64_t v28 = v40;
  v27(v40, v18, AssociatedTypeWitness);
  int v29 = v43;
  uint64_t v30 = v39;
  uint64_t v31 = (void (*)(unsigned char *, void))((uint64_t (*)(unsigned char *, char *, uint64_t, int **))v43[10])(v44, v28, v7, v43);
  uint64_t v33 = v32;
  uint64_t v34 = swift_getAssociatedTypeWitness(0, (int **)v29[1], v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v34 - 1) + 16))(v42, v33, v34);
  v31(v44, 0);
  (*(void (**)(char *, const char *))(v15 + 8))(v28, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v41 + 8))(v30, v7);
}

char *_RandomAccessCollectionBox.subscript.getter(void (*a1)(char *, char *, const char *), uint64_t a2, unint64_t a3, void (**a4)(const char *, uint64_t, unint64_t))
{
  unint64_t v87 = a3;
  uint64_t v88 = a4;
  char v91 = a1;
  uint64_t v89 = *v4;
  uint64_t v80 = *(void *)(v89 + 384);
  uint64_t v6 = *(int ***)(*(void *)(v80 + 8) + 8);
  uint64_t v7 = *(void *)(v89 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v82 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v83 = AssociatedTypeWitness;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v81 = (char *)&v70 - v9;
  uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v10, (uint64_t)v10, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v78 = (char *)&v70 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v77 = (char *)&v70 - v13;
  uint64_t v71 = type metadata accessor for Optional(0, (uint64_t)v10, v14, v15);
  uint64_t v70 = (uint64_t)*(v71 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v71);
  uint64_t v18 = (char *)&v70 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v70 - v20;
  uint64_t v22 = (void *)*((void *)v10 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v19);
  unint64_t v85 = (char *)&v70 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v84 = (char *)&v70 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v86 = (char *)&v70 - v28;
  MEMORY[0x1F4188790](v27);
  unint64_t v92 = (char *)&v70 - v29;
  unint64_t v79 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range(0, (uint64_t)v10, AssociatedConformanceWitness, v31);
  uint64_t v76 = (uint64_t)*(v32 - 1);
  uint64_t v33 = MEMORY[0x1F4188790](v32);
  uint64_t v72 = (char *)&v70 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v74 = (char *)&v70 - v36;
  MEMORY[0x1F4188790](v35);
  uint64_t v75 = v37;
  uint64_t v38 = *(void (**)(void))(v37 + 16);
  uint64_t v73 = (char *)&v70 - v39;
  uint64_t v89 = v7;
  v38();
  unint64_t ObjectType = swift_getObjectType((unint64_t)v91);
  (*(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16))(v10, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v41 = (unsigned int (*)(char *, uint64_t, const char *))v22[6];
  if (v41(v21, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v70 + 8))(v21, v71);
    goto LABEL_8;
  }
  char v91 = (void (*)(char *, char *, const char *))v22[4];
  v91(v92, v21, v10);
  unint64_t v42 = swift_getObjectType(v87);
  v88[2](v10, AssociatedConformanceWitness, v42);
  if (v41(v18, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v70 + 8))(v18, v71);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4A2uLL, 0);
  }
  uint64_t v43 = v86;
  v91(v86, v18, v10);
  uint64_t v44 = (void (**)(const char *, uint64_t, unint64_t))v22[2];
  uint64_t v45 = v84;
  ((void (*)(char *, char *, const char *))v44)(v84, v92, v10);
  uint64_t v46 = v85;
  uint64_t v88 = v44;
  ((void (*)(char *, char *, const char *))v44)(v85, v43, v10);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v45, v46, v10, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v47 = (Class *)v22[1];
  }
  uint64_t v71 = v47;
  ((void (*)(char *, const char *))v47)(v46, v10);
  ((void (*)(char *, const char *))v47)(v45, v10);
  uint64_t v48 = v77;
  unint64_t v87 = (unint64_t)v32;
  unint64_t v49 = v91;
  uint64_t v50 = TupleTypeMetadata2;
  uint64_t v51 = &v77[*((int *)TupleTypeMetadata2 + 12)];
  v91(v77, v92, v10);
  v49(v51, v43, v10);
  uint64_t v52 = v78;
  uint64_t v53 = &v78[*((int *)v50 + 12)];
  uint64_t v54 = v88;
  ((void (*)(char *, char *, const char *))v88)(v78, v48, v10);
  ((void (*)(char *, char *, const char *))v54)(v53, v51, v10);
  uint64_t v55 = v72;
  v49(v72, v52, v10);
  uint64_t v56 = v71;
  ((void (*)(char *, const char *))v71)(v53, v10);
  uint64_t v57 = &v52[*((int *)TupleTypeMetadata2 + 12)];
  v49(v52, v48, v10);
  v49(v57, v51, v10);
  unint64_t v58 = v87;
  v49(&v55[*(int *)(v87 + 36)], v57, v10);
  ((void (*)(char *, const char *))v56)(v52, v10);
  uint64_t v59 = v76;
  uint64_t v60 = v74;
  (*(void (**)(char *, char *, unint64_t))(v76 + 32))(v74, v55, v58);
  uint64_t v61 = (uint64_t)v81;
  uint64_t v62 = v73;
  uint64_t v63 = v89;
  ((void (*)(char *, uint64_t))v79[11])(v60, v89);
  (*(void (**)(char *, unint64_t))(v59 + 8))(v60, v58);
  (*(void (**)(char *, uint64_t))(v75 + 8))(v62, v63);
  uint64_t v64 = (uint64_t)v83;
  uint64_t v65 = swift_getAssociatedConformanceWitness(v80, v63, (uint64_t)v83, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
  uint64_t v67 = type metadata accessor for _RandomAccessCollectionBox(0, v64, v65, v66);
  swift_allocObject((unint64_t *)v67, *((unsigned int *)v67 + 12), *((unsigned __int16 *)v67 + 26));
  uint64_t v68 = specialized _RandomAccessCollectionBox.init(_base:)(v61);
  (*(void (**)(uint64_t, uint64_t))(v82 + 8))(v61, v64);
  return v68;
}

char *_RandomAccessCollectionBox._index(after:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v39 = *(int ***)(*(void *)(*(void *)(*v2 + 384) + 8) + 8);
  uint64_t v6 = *(void *)(v5 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v39, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v33 = (uint64_t)*(v10 - 1);
  uint64_t v34 = v10;
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v32 - v12;
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v16 = MEMORY[0x1F4188790]((char *)&v32 - v14);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v37 = (char *)&v32 - v20;
  uint64_t v21 = (uint64_t)v2 + *(void *)(v5 + 392);
  uint64_t v38 = v22;
  uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 16);
  uint64_t v36 = v19;
  v23(v19, v21, v6);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v39, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v13, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v13, v34);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4A8uLL, 0);
  }
  uint64_t v25 = *(void (**)(char *, char *, const char *))(v15 + 32);
  v25(v18, v13, AssociatedTypeWitness);
  uint64_t v26 = v36;
  uint64_t v27 = v37;
  ((void (*)(char *, uint64_t))v39[23])(v18, v6);
  (*(void (**)(char *, const char *))(v15 + 8))(v18, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v26, v6);
  uint64_t v29 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v28);
  uint64_t v30 = (char *)swift_allocObject((unint64_t *)v29, *((unsigned int *)v29 + 12), *((unsigned __int16 *)v29 + 26));
  v25(&v30[*(void *)(*(void *)v30 + 96)], v27, AssociatedTypeWitness);
  return v30;
}

uint64_t _RandomAccessCollectionBox._formIndex(after:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  uint64_t v9 = *(void *)(*(void *)(*(void *)(v8 + 384) + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = swift_dynamicCastClass(a1, (uint64_t)v13);
  if (!v14) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4B0uLL, 0);
  }
  uint64_t v15 = v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 392), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 192))(v15 + *(void *)(*(void *)v15 + 96), v4, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

char *_RandomAccessCollectionBox._index(_:offsetBy:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v39 = a3;
  uint64_t v6 = *v3;
  uint64_t v38 = *(void *)(*v3 + 384);
  uint64_t AssociatedConformanceWitness = *(int ***)(*(void *)(v38 + 8) + 8);
  uint64_t v7 = *(void *)(v6 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, AssociatedConformanceWitness, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v33 = (uint64_t)*(v11 - 1);
  uint64_t v34 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v33 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790]((char *)&v33 - v15);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v36 = (char *)&v33 - v21;
  uint64_t v22 = (uint64_t)v3 + *(void *)(v6 + 392);
  uint64_t v37 = v23;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(v23 + 16);
  uint64_t v35 = v20;
  v24(v20, v22, v7);
  swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = (int **)swift_getAssociatedConformanceWitness((uint64_t)AssociatedConformanceWitness, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v14, v34);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4B7uLL, 0);
  }
  uint64_t v26 = *(void (**)(char *, char *, const char *))(v16 + 32);
  v26(v19, v14, AssociatedTypeWitness);
  uint64_t v27 = v35;
  uint64_t v28 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v38 + 32))(v19, v39, v7);
  (*(void (**)(char *, const char *))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v37 + 8))(v27, v7);
  uint64_t v30 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedConformanceWitness, v29);
  uint64_t v31 = (char *)swift_allocObject((unint64_t *)v30, *((unsigned int *)v30 + 12), *((unsigned __int16 *)v30 + 26));
  v26(&v31[*(void *)(*(void *)v31 + 96)], v28, AssociatedTypeWitness);
  return v31;
}

char *_RandomAccessCollectionBox._index(_:offsetBy:limitedBy:)(unint64_t a1, unsigned int (*a2)(char *, uint64_t, const char *), uint64_t a3, unint64_t a4, void (*a5)(char *, char *, const char *))
{
  unint64_t v65 = a4;
  uint64_t v66 = a5;
  uint64_t v64 = a3;
  uint64_t v70 = a2;
  uint64_t v7 = *v5;
  uint64_t v63 = *(void *)(*v5 + 384);
  uint64_t v69 = *(int ***)(*(void *)(v63 + 8) + 8);
  uint64_t v8 = *(int ***)(v7 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v69, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v57 = (char *)&v56 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v61 = (char *)&v56 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v71 = (char *)&v56 - v16;
  uint64_t v17 = (uint64_t)*(v8 - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v56 - v18;
  uint64_t v22 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v20, v21);
  uint64_t v67 = (uint64_t)*(v22 - 1);
  uint64_t v68 = v22;
  uint64_t v23 = MEMORY[0x1F4188790](v22);
  uint64_t v60 = (char *)&v56 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v56 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v30 = (char *)&v56 - v29;
  MEMORY[0x1F4188790](v28);
  unint64_t v58 = (char *)&v56 - v31;
  uint64_t v32 = (uint64_t)v5 + *(void *)(v7 + 392);
  uint64_t v62 = v17;
  uint64_t v33 = *(void (**)(char *, uint64_t, int **))(v17 + 16);
  uint64_t v59 = v19;
  v33(v19, v32, v8);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v35 = v69;
  uint64_t v36 = v70;
  uint64_t v37 = (void (*)(const char *, uint64_t, unint64_t, unsigned int (*)(char *, uint64_t, const char *)))*((void *)v70 + 2);
  uint64_t v69 = v8;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v35, (uint64_t)v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v37(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, v36);
  uint64_t v39 = (unsigned int (*)(char *, uint64_t, const char *))v10[6];
  if (v39(v30, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v67 + 8))(v30, v68);
    goto LABEL_9;
  }
  uint64_t v40 = (void (*)(char *, char *, const char *))v10[4];
  v40(v71, v30, AssociatedTypeWitness);
  unint64_t v41 = swift_getObjectType(v65);
  unint64_t v42 = (void (*)(const char *, uint64_t, unint64_t))*((void *)v66 + 2);
  uint64_t v56 = AssociatedConformanceWitness;
  v42(AssociatedTypeWitness, AssociatedConformanceWitness, v41);
  uint64_t v70 = v39;
  if (v39(v27, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v67 + 8))(v27, v68);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4C0uLL, 0);
  }
  uint64_t v43 = v61;
  uint64_t v66 = v40;
  v40(v61, v27, AssociatedTypeWitness);
  uint64_t v44 = v58;
  uint64_t v45 = v59;
  uint64_t v46 = v71;
  uint64_t v47 = v69;
  (*(void (**)(char *, uint64_t, char *, int **))(v63 + 40))(v71, v64, v43, v69);
  uint64_t v48 = (void (*)(char *, const char *))v10[1];
  v48(v43, AssociatedTypeWitness);
  v48(v46, AssociatedTypeWitness);
  (*(void (**)(char *, int **))(v62 + 8))(v45, v47);
  unint64_t v49 = v60;
  (*(void (**)(char *, char *, Class *))(v67 + 32))(v60, v44, v68);
  if (v70(v49, 1, AssociatedTypeWitness) == 1) {
    return 0;
  }
  uint64_t v51 = v57;
  uint64_t v52 = v66;
  v66(v57, v49, AssociatedTypeWitness);
  uint64_t v54 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, v56, v53);
  uint64_t v50 = (char *)swift_allocObject((unint64_t *)v54, *((unsigned int *)v54 + 12), *((unsigned __int16 *)v54 + 26));
  v52(&v50[*(void *)(*(void *)v50 + 96)], v51, AssociatedTypeWitness);
  return v50;
}

uint64_t _RandomAccessCollectionBox._formIndex(_:offsetBy:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v24 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*v2 + 384) + 8) + 8);
  uint64_t v6 = *(void *)(*v2 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v23 = (char *)&v23 - v10;
  uint64_t v11 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v23 - v12;
  uint64_t v14 = *a1;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = swift_dynamicCastClass(v14, (uint64_t)v17);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4CBuLL, 0);
  }
  uint64_t v19 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, (uint64_t)v2 + *(void *)(v4 + 392), v6);
  uint64_t v20 = v19 + *(void *)(*(void *)v19 + 96);
  uint64_t v21 = v23;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 136))(v20, v24, v6, v5);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v6);
  (*(void (**)(uint64_t, const char *))(v8 + 8))(v20, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v8 + 32))(v20, v21, AssociatedTypeWitness);
}

BOOL _RandomAccessCollectionBox._formIndex(_:offsetBy:limitedBy:)(uint64_t *a1, uint64_t a2, void (*a3)(char *, char *, const char *), uint64_t a4)
{
  unint64_t v42 = a3;
  uint64_t v43 = a4;
  uint64_t v39 = a2;
  unint64_t v41 = *(void **)v4;
  uint64_t v6 = *(int ***)(*(void *)(v41[48] + 8) + 8);
  uint64_t v7 = v41[47];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v35 = (uint64_t)*(v11 - 1);
  uint64_t v36 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v40 = (char *)&v35 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v35 - v15;
  uint64_t v17 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v14);
  uint64_t v37 = (char *)&v35 - v19;
  uint64_t v44 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v35 - v20;
  uint64_t v22 = *a1;
  uint64_t v38 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v25 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v24);
  uint64_t v26 = swift_dynamicCastClass(v22, (uint64_t)v25);
  if (!v26) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4D5uLL, 0);
  }
  uint64_t v27 = v26;
  (*(void (**)(char *, char *, uint64_t))(v44 + 16))(v21, &v4[v41[49]], v7);
  unint64_t ObjectType = swift_getObjectType((unint64_t)v42);
  (*(void (**)(const char *, uint64_t, unint64_t))(v43 + 16))(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType);
  uint64_t v43 = v17[6];
  if (((unsigned int (*)(char *, uint64_t, const char *))v43)(v16, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v35 + 8))(v16, v36);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4D3uLL, 0);
  }
  uint64_t v29 = v37;
  unint64_t v42 = (void (*)(char *, char *, const char *))v17[4];
  v42(v37, v16, AssociatedTypeWitness);
  uint64_t v30 = v27 + *(void *)(*(void *)v27 + 96);
  uint64_t v31 = v40;
  ((void (*)(uint64_t, uint64_t, char *, uint64_t))v38[18])(v30, v39, v29, v7);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v21, v7);
  uint64_t v32 = (void (*)(uint64_t, const char *))v17[1];
  v32(v30, AssociatedTypeWitness);
  int v33 = ((uint64_t (*)(char *, uint64_t, const char *))v43)(v31, 1, AssociatedTypeWitness);
  if (v33 == 1)
  {
    (*(void (**)(char *, Class *))(v35 + 8))(v31, v36);
    uint64_t v31 = v29;
  }
  else
  {
    v32((uint64_t)v29, AssociatedTypeWitness);
  }
  v42((char *)v30, v31, AssociatedTypeWitness);
  return v33 != 1;
}

uint64_t _RandomAccessCollectionBox._distance(from:to:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v49 = a3;
  uint64_t v50 = a4;
  uint64_t v7 = *v4;
  uint64_t v46 = *(void *)(*v4 + 384);
  uint64_t v8 = *(int ***)(*(void *)(v46 + 8) + 8);
  uint64_t v9 = *(void *)(v7 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v41 = (uint64_t)*(v13 - 1);
  unint64_t v42 = v13;
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v48 = (char *)&v40 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  uint64_t v44 = (char *)&v40 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v51 = (char *)&v40 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v45 = v24;
  uint64_t v25 = *(void (**)(void))(v24 + 16);
  uint64_t v43 = (char *)&v40 - v26;
  v25();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v28 = *(void (**)(const char *, uint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t v47 = v9;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v28(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v30 = (unsigned int (*)(char *, uint64_t, const char *))v19[6];
  if (v30(v18, 1, AssociatedTypeWitness) == 1
    || (uint64_t v31 = (void (*)(char *, char *, const char *))v19[4],
        v31(v51, v18, AssociatedTypeWitness),
        unint64_t v32 = swift_getObjectType(v49),
        uint64_t v18 = v48,
        (*(void (**)(const char *, uint64_t, unint64_t))(v50 + 16))(AssociatedTypeWitness, AssociatedConformanceWitness, v32), v30(v18, 1, AssociatedTypeWitness) == 1))
  {
    (*(void (**)(char *, Class *))(v41 + 8))(v18, v42);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4DDuLL, 0);
  }
  int v33 = v44;
  v31(v44, v18, AssociatedTypeWitness);
  uint64_t v34 = v47;
  uint64_t v35 = v51;
  uint64_t v36 = v43;
  uint64_t v37 = (*(uint64_t (**)(char *, char *, uint64_t))(v46 + 48))(v51, v33, v47);
  uint64_t v38 = (void (*)(char *, const char *))v19[1];
  v38(v33, AssociatedTypeWitness);
  v38(v35, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v45 + 8))(v36, v34);
  return v37;
}

uint64_t _RandomAccessCollectionBox._count.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v9 - v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - v5, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(v2 + 384) + 8) + 8) + 112))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

char *_RandomAccessCollectionBox._index(before:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(int ***)(*(void *)(*(void *)(*v2 + 384) + 8) + 8);
  uint64_t v39 = *(void *)(*(void *)(*v2 + 384) + 8);
  uint64_t AssociatedConformanceWitness = (uint64_t)v6;
  uint64_t v7 = *(void *)(v5 + 376);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v34 = (uint64_t)*(v11 - 1);
  uint64_t v35 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v33 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790]((char *)&v33 - v15);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v37 = (char *)&v33 - v21;
  uint64_t v22 = (uint64_t)v2 + *(void *)(v5 + 392);
  uint64_t v38 = v23;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(v23 + 16);
  uint64_t v36 = v20;
  v24(v20, v22, v7);
  swift_getObjectType(a1);
  uint64_t v25 = *(void (**)(const char *))(a2 + 16);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(AssociatedConformanceWitness, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  v25(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v34 + 8))(v14, v35);
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4E7uLL, 0);
  }
  uint64_t v26 = *(void (**)(char *, char *, const char *))(v16 + 32);
  v26(v19, v14, AssociatedTypeWitness);
  uint64_t v27 = v36;
  uint64_t v28 = v37;
  (*(void (**)(char *, uint64_t))(v39 + 32))(v19, v7);
  (*(void (**)(char *, const char *))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v27, v7);
  uint64_t v30 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v29);
  uint64_t v31 = (char *)swift_allocObject((unint64_t *)v30, *((unsigned int *)v30 + 12), *((unsigned __int16 *)v30 + 26));
  v26(&v31[*(void *)(*(void *)v31 + 96)], v28, AssociatedTypeWitness);
  return v31;
}

uint64_t _RandomAccessCollectionBox._formIndex(before:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v18 - v6;
  uint64_t v9 = *(void *)(*(void *)(v8 + 384) + 8);
  uint64_t v10 = *(int ***)(v9 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = swift_dynamicCastClass(a1, (uint64_t)v14);
  if (!v15) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000014, 0x80000001816DE560, "Swift/ExistentialCollection.swift", 33, 2, 0x4EFuLL, 0);
  }
  uint64_t v16 = v15;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 392), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 40))(v16 + *(void *)(*(void *)v16 + 96), v4, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

uint64_t _RandomAccessCollectionBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 376) - 8) + 16))(a1, v1 + *(void *)(*(void *)v1 + 392));
}

uint64_t _RandomAccessCollectionBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 376) - 8) + 40))(v1 + *(void *)(*(void *)v1 + 392), a1);
}

uint64_t (*_RandomAccessCollectionBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _RandomAccessCollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _CollectionBox.__allocating_init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7)
{
}

void _RandomAccessCollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t _ClosureBasedSequence._makeUnderlyingIterator.getter(uint64_t a1, atomic_ullong *a2)
{
  return a1;
}

uint64_t _ClosureBasedSequence._makeUnderlyingIterator.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_release(v2[1]);
  *uint64_t v2 = a1;
  v2[1] = a2;
  return result;
}

uint64_t (*_ClosureBasedSequence._makeUnderlyingIterator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _ClosureBasedSequence.makeIterator()(uint64_t (*a1)(void))
{
  return a1();
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _ClosureBasedSequence<A>()
{
  uint64_t v1 = *(void *)(v0 + 8);
  _ClosureBasedSequence.makeIterator()(*(uint64_t (**)(void))v0);

  return swift_release(v1);
}

void *AnySequence.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (unint64_t *)type metadata accessor for _ClosureBasedSequence(255, a4, a5, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _ClosureBasedSequence<A>, v7, v8);
  uint64_t v11 = (unint64_t *)type metadata accessor for _SequenceBox(0, (uint64_t)v7, WitnessTable, v10);
  uint64_t result = swift_allocObject(v11, 0x20uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  return result;
}

char *AnySequence.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _SequenceBox(0, a3, a4, a4);
  uint64_t v7 = (char *)swift_allocObject((unint64_t *)v6, *((unsigned int *)v6 + 12), *((unsigned __int16 *)v6 + 26));
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32))(&v7[*(void *)(*(void *)v7 + 224)], a1, a3);
  return v7;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance AnySequence<A>()
{
  return AnySequence.underestimatedCount.getter(*v0);
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance AnySequence<A>(uint64_t a1)
{
  return AnySequence._customContainsEquatableElement(_:)(a1, *v1);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance AnySequence<A>()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized AnyBidirectionalCollection._copyToContiguousArray()(*v0);
  swift_release(v1);
  return v2;
}

uint64_t AnySequence._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = specialized AnyBidirectionalCollection._copyToContiguousArray()(a1);
  swift_release(a1);
  return v2;
}

void *AnySequence._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = specialized AnyBidirectionalCollection._copyContents(initializing:)(a1, a2, a3, a4);
  swift_release(a3);
  return v5;
}

uint64_t AnySequence.dropLast(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 176))();
  swift_release(a2);
  return v3;
}

uint64_t AnySequence.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 192))();
  swift_release(a3);
  return v4;
}

uint64_t AnySequence.suffix(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 200))();
  swift_release(a2);
  return v3;
}

void *specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *))
{
  uint64_t result = (void *)a2(a1, &v7);
  if (v2)
  {
    uint64_t v4 = v7;
    uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
    uint64_t result = swift_allocError(v5, (uint64_t)&protocol self-conformance witness table for Error, 0, 0);
    *uint64_t v6 = v4;
  }
  return result;
}

uint64_t AnySequence.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)(a1, a2, a3, a4, a5, (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error), (uint64_t)partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1));
}

uint64_t AnySequence.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

{
  uint64_t v4;

  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 120))();
  swift_release(a3);
  return v4;
}

uint64_t AnySequence.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

{
  (*(void (**)(void))(*(void *)a3 + 128))();
  return swift_release(a3);
}

uint64_t AnySequence.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

{
  uint64_t v4;

  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 160))();
  swift_release(a3);
  return v4;
}

uint64_t AnyCollection.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnyCollection.prefix(while:)(a1, a2, a3);
}

{
  uint64_t v4;

  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 240))();
  swift_release(a3);
  return v4;
}

uint64_t AnyCollection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)(a1, a2, a3, a4, a5, (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error), (uint64_t)thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply);
}

uint64_t AnyCollection.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

uint64_t AnyCollection.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

uint64_t AnyCollection.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnyCollection.prefix(while:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)(a1, a2, a3, a4, a5, (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error), (uint64_t)thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply);
}

uint64_t AnyBidirectionalCollection.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

uint64_t AnyCollection.makeIterator()(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  swift_release(a1);
  return v2;
}

uint64_t AnyCollection.dropLast(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 232))();
  swift_release(a2);
  return v3;
}

uint64_t AnyRandomAccessCollection.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnyCollection.prefix(while:)(a1, a2, a3);
}

uint64_t AnyCollection.suffix(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 248))();
  swift_release(a2);
  return v3;
}

uint64_t AnySequence.underestimatedCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 104))();
}

uint64_t AnyRandomAccessCollection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)(a1, a2, a3, a4, a5, (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error), (uint64_t)thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply);
}

uint64_t AnySequence.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = a4;
  uint64_t v14 = a5;
  uint64_t v15 = a1;
  uint64_t v16 = a2;
  unint64_t v11[2] = a4;
  v11[3] = a5;
  v11[4] = a6;
  uint64_t v11[5] = &v12;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a3 + 112))(a7, v11, a5);
  if (v7)
  {
    uint64_t v17 = v7;
    uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
    swift_willThrowTypedImpl((uint64_t)&v17, v9, (uint64_t)&protocol self-conformance witness table for Error);
  }
  return v8;
}

uint64_t AnyRandomAccessCollection.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

uint64_t AnyRandomAccessCollection.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

uint64_t AnyRandomAccessCollection.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

uint64_t AnySequence.dropFirst(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 168))();
  swift_release(a2);
  return v3;
}

uint64_t AnySequence.prefix(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 184))();
  swift_release(a2);
  return v3;
}

uint64_t AnySequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 136))();
}

uint64_t (*_IndexBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _IndexBox.init(_base:)(uint64_t a1)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 80) - 8) + 32))(v1 + *(void *)(*(void *)v1 + 96), a1);
  return v1;
}

uint64_t _IndexBox._unsafeUnbox(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  if (!swift_dynamicCastClass(a1, *v2)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  uint64_t v6 = a1 + *(void *)(*(void *)a1 + 96);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v5 + 80) - 8) + 16);

  return v7(a2, v6);
}

uint64_t _IndexBox._typeID.getter()
{
  return *(void *)v0;
}

uint64_t _IndexBox._unbox<A>()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v8 = type metadata accessor for _IndexBox(0, a1, a2, a3);
  uint64_t v9 = swift_dynamicCastClass(v5, (uint64_t)v8);
  if (v9)
  {
    uint64_t v14 = *(void *)(a1 - 8);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v14 + 16))(a4, v9 + *(void *)(*(void *)v9 + 96), a1);
    uint64_t v10 = v14;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 - 8);
    uint64_t v11 = 1;
  }
  char v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56);

  return v12(a4, v11, 1, a1);
}

uint64_t _IndexBox._isEqual(to:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 80);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)&v16 - v9;
  char v12 = *(void (**)(char *, char *, uint64_t))(v5 + 16);
  v12((char *)&v16 - v9, (char *)v1 + *(void *)(v11 + 96), v4);
  if (!swift_dynamicCastClass(a1, v3)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  v12(v8, (char *)(a1 + *(void *)(*(void *)a1 + 96)), v4);
  char v13 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v3 + 88) + 8) + 8))(v10, v8, v4);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v8, v4);
  v14(v10, v4);
  return v13 & 1;
}

uint64_t _IndexBox._isLess(than:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 80);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)&v16 - v9;
  char v12 = *(void (**)(char *, char *, uint64_t))(v5 + 16);
  v12((char *)&v16 - v9, (char *)v1 + *(void *)(v11 + 96), v4);
  if (!swift_dynamicCastClass(a1, v3)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  v12(v8, (char *)(a1 + *(void *)(*(void *)a1 + 96)), v4);
  char v13 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v3 + 88) + 16))(v10, v8, v4);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v8, v4);
  v14(v10, v4);
  return v13 & 1;
}

uint64_t ManagedBuffer.deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 80) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 96));
  return v0;
}

id AnyIndex._box.getter(void *a1)
{
  return swift_unknownObjectRetain(a1);
}

void AnyIndex._box.setter(uint64_t a1, uint64_t a2)
{
  swift_unknownObjectRelease(*(id *)v2);
  *(void *)uint64_t v2 = a1;
  *(void *)(v2 + 8) = a2;
}

uint64_t (*AnyIndex._box.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

char *AnyIndex.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _IndexBox(0, a2, a3, a4);
  uint64_t v7 = (char *)swift_allocObject((unint64_t *)v6, *((unsigned int *)v6 + 12), *((unsigned __int16 *)v6 + 26));
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(&v7[*(void *)(*(void *)v7 + 96)], a1, a2);
  return v7;
}

uint64_t AnyIndex._typeID.getter(unint64_t a1, uint64_t a2)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance AnyIndex(uint64_t a1, uint64_t a2)
{
  return specialized static AnyIndex.< infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), *(void *)a2, *(void *)(a2 + 8));
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance AnyIndex(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index(a1, a2, a3, a4, (uint64_t (*)(void, void, void, void))static AnyIndex.< infix(_:_:));
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void))
{
  return (a5(*a2, a2[1], *a1, a1[1]) & 1) == 0;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance AnyIndex(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index(a1, a2, a3, a4, (uint64_t (*)(void, void, void, void))static AnyIndex.< infix(_:_:));
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void))
{
  return (a5(*a1, a1[1], *a2, a2[1]) & 1) == 0;
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance AnyIndex(uint64_t a1, uint64_t a2)
{
  return specialized static Comparable.> infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), *(void *)a2, *(void *)(a2 + 8));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance AnyIndex(uint64_t a1, uint64_t a2)
{
  return specialized static AnyIndex.== infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), *(void *)a2, *(void *)(a2 + 8));
}

uint64_t AnyCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AnyCollection.init<A>(_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _CollectionBox, (uint64_t (*)(uint64_t))specialized _CollectionBox.init(_base:));
}

{
  return AnyCollection.init<A>(_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _BidirectionalCollectionBox, (uint64_t (*)(uint64_t))specialized _BidirectionalCollectionBox.init(_base:));
}

{
  return AnyCollection.init<A>(_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _RandomAccessCollectionBox, (uint64_t (*)(uint64_t))specialized _RandomAccessCollectionBox.init(_base:));
}

id AnyCollection.endIndex.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized AnyCollection.endIndex.getter(a1);
  return swift_unknownObjectRetain(v1);
}

id protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void))specialized AnyCollection.startIndex.getter, a2);
}

id protocol witness for Collection.endIndex.getter in conformance AnyCollection<A>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void))specialized AnyCollection.endIndex.getter, a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance AnyCollection<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = AnyCollection.subscript.read(v7, *a2, a2[1], *v3, *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*AnyCollection.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  *a1 = a5;
  uint64_t v8 = *(void *)(a5 - 8);
  a1[1] = v8;
  a1[2] = malloc(*(void *)(v8 + 64));
  (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 256))(a2, a3);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void, void, void))AnyCollection.subscript.getter, a2);
}

uint64_t protocol witness for Collection.count.getter in conformance AnyCollection<A>()
{
  return AnyCollection.count.getter(*v0);
}

double protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance AnyCollection<A>@<D0>(_OWORD *a1@<X8>)
{
  *(void *)&double result = 1;
  *a1 = xmmword_18162AD50;
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>(a1, a2, (uint64_t (*)(void, void, uint64_t, void))AnyCollection.index(_:offsetBy:), a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>(a1, a2, a3, (uint64_t (*)(void, void, uint64_t, void, void, void))AnyCollection.index(_:offsetBy:limitedBy:), a4);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance AnyCollection<A>(void *a1, void *a2)
{
  return AnyCollection.distance(from:to:)(*a1, a1[1], *a2, a2[1], *v2);
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void))AnyCollection.index(after:), a2);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance AnyCollection<A>(uint64_t a1)
{
  return AnyCollection.formIndex(after:)(a1, *v1);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance AnySequence<A>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *v4;
  uint64_t v7 = specialized AnyBidirectionalCollection._copyContents(initializing:)(a2, a3, v6, *(void *)(a4 + 16));
  uint64_t v9 = v8;
  swift_release(v6);
  *a1 = v7;
  return v9;
}

uint64_t AnyBidirectionalCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AnyCollection.init<A>(_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _BidirectionalCollectionBox, (uint64_t (*)(uint64_t))specialized _BidirectionalCollectionBox.init(_base:));
}

{
  return AnyCollection.init<A>(_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _RandomAccessCollectionBox, (uint64_t (*)(uint64_t))specialized _RandomAccessCollectionBox.init(_base:));
}

uint64_t AnyBidirectionalCollection.init(_:)(uint64_t a1, uint64_t a2)
{
  return AnyBidirectionalCollection.init(_:)(a1, a2, (uint64_t (*)(void))type metadata accessor for _AnyBidirectionalCollectionBox);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance AnyBidirectionalCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void))AnyBidirectionalCollection.index(before:), a2);
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t (*a2)(void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], *v3);
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance AnyBidirectionalCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>(a1, a2, (uint64_t (*)(void, void, uint64_t, void))AnyBidirectionalCollection.index(_:offsetBy:), a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(void, void, uint64_t, void)@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = a3(*a1, a1[1], a2, *v4);
  *a4 = result;
  a4[1] = v7;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance AnyBidirectionalCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>(a1, a2, a3, (uint64_t (*)(void, void, uint64_t, void, void, void))AnyBidirectionalCollection.index(_:offsetBy:limitedBy:), a4);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, void, uint64_t, void, void, void)@<X5>, uint64_t *a5@<X8>)
{
  uint64_t result = a4(*a1, a1[1], a2, *a3, a3[1], *v5);
  *a5 = result;
  a5[1] = v8;
  return result;
}

id protocol witness for Collection.startIndex.getter in conformance AnyBidirectionalCollection<A>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void))specialized AnyRandomAccessCollection.startIndex.getter, a2);
}

id protocol witness for Collection.endIndex.getter in conformance AnyBidirectionalCollection<A>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void))specialized AnyRandomAccessCollection.endIndex.getter, a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyBidirectionalCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void, void, void))AnyBidirectionalCollection.subscript.getter, a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyCollection<A>@<X0>(void *a1@<X0>, uint64_t (*a2)(void, void, void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], a1[2], a1[3], *v3);
  *a3 = result;
  return result;
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyBidirectionalCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void))AnyBidirectionalCollection.index(after:), a2);
}

uint64_t AnyRandomAccessCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AnyCollection.init<A>(_:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _RandomAccessCollectionBox, (uint64_t (*)(uint64_t))specialized _RandomAccessCollectionBox.init(_base:));
}

uint64_t AnyCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, uint64_t, uint64_t), uint64_t (*a6)(uint64_t))
{
  uint64_t v9 = a5(0, a3, a4);
  swift_allocObject((unint64_t *)v9, *(unsigned int *)(v9 + 48), *(unsigned __int16 *)(v9 + 52));
  uint64_t v10 = a6(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
  return v10;
}

uint64_t AnyRandomAccessCollection.init(_:)(uint64_t a1, uint64_t a2)
{
  return AnyBidirectionalCollection.init(_:)(a1, a2, (uint64_t (*)(void))type metadata accessor for _AnyRandomAccessCollectionBox);
}

{
  return AnyBidirectionalCollection.init(_:)(a1, a2, (uint64_t (*)(void))type metadata accessor for _AnyRandomAccessCollectionBox);
}

uint64_t AnyBidirectionalCollection.init(_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v4 = a3(0);
  uint64_t result = swift_dynamicCastClass(a1, v4);
  if (!result)
  {
    swift_release(a1);
    return 0;
  }
  return result;
}

uint64_t AnyCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 256))();
}

uint64_t AnyCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(*(void *)a5 + 336))();
}

uint64_t AnyCollection.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 264))();
}

void AnyCollection.formIndex(after:)(unint64_t *a1, uint64_t *a2)
{
  int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*a1);
  uint64_t v5 = (void *)*a1;
  unint64_t v6 = a1[1];
  uint64_t v7 = *a2;
  if (isUniquelyReferenced_nonNull)
  {
    uint64_t v8 = *(void (**)(id, unint64_t))(v7 + 272);
    id v9 = swift_unknownObjectRetain(v5);
    v8(v9, v6);
    swift_unknownObjectRelease(v5);
  }
  else
  {
    uint64_t v10 = (*(uint64_t (**)(void *, unint64_t))(v7 + 264))(v5, v6);
    unint64_t v12 = v11;
    swift_unknownObjectRelease(v5);
    *a1 = v10;
    a1[1] = v12;
  }
}

uint64_t AnyCollection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(void *)a4 + 280))();
}

uint64_t AnyCollection.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(*(void *)a6 + 288))();
}

void AnyCollection.formIndex(_:offsetBy:)(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (swift_isUniquelyReferenced_nonNull(*a1))
  {
    (*(void (**)(unint64_t *, uint64_t))(*(void *)a3 + 296))(a1, a2);
  }
  else
  {
    unint64_t v6 = (void *)*a1;
    uint64_t v7 = (*(uint64_t (**)(unint64_t, unint64_t, uint64_t))(*(void *)a3 + 280))(*a1, a1[1], a2);
    unint64_t v9 = v8;
    swift_unknownObjectRelease(v6);
    *a1 = v7;
    a1[1] = v9;
  }
}

uint64_t AnyCollection.formIndex(_:offsetBy:limitedBy:)(unint64_t *a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5)
{
  if (swift_isUniquelyReferenced_nonNull(*a1)) {
    return (*(uint64_t (**)(unint64_t *, uint64_t, void *, unint64_t))(*(void *)a5 + 304))(a1, a2, a3, a4) & 1;
  }
  unint64_t v11 = (void *)*a1;
  uint64_t v12 = (*(uint64_t (**)(unint64_t, unint64_t, uint64_t, void *, unint64_t))(*(void *)a5 + 288))(*a1, a1[1], a2, a3, a4);
  unint64_t v14 = v13;
  swift_unknownObjectRelease(v11);
  if (v12)
  {
    *a1 = v12;
    a1[1] = v14;
    return 1;
  }
  else
  {
    *a1 = (unint64_t)a3;
    a1[1] = a4;
    swift_unknownObjectRetain(a3);
    return 0;
  }
}

uint64_t AnyCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(*(void *)a5 + 312))();
}

uint64_t AnyCollection.count.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 320))();
}

uint64_t AnyBidirectionalCollection.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 352))();
}

void AnyBidirectionalCollection.formIndex(before:)(unint64_t *a1, uint64_t *a2)
{
  int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*a1);
  uint64_t v5 = (void *)*a1;
  unint64_t v6 = a1[1];
  uint64_t v7 = *a2;
  if (isUniquelyReferenced_nonNull)
  {
    unint64_t v8 = *(void (**)(id, unint64_t))(v7 + 360);
    id v9 = swift_unknownObjectRetain(v5);
    v8(v9, v6);
    swift_unknownObjectRelease(v5);
  }
  else
  {
    uint64_t v10 = (*(uint64_t (**)(void *, unint64_t))(v7 + 352))(v5, v6);
    unint64_t v12 = v11;
    swift_unknownObjectRelease(v5);
    *a1 = v10;
    a1[1] = v12;
  }
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance AnyRandomAccessCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>(a1, a2, (uint64_t (*)(void, void, uint64_t, void))AnyRandomAccessCollection.index(_:offsetBy:), a3);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance AnyRandomAccessCollection<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>(a1, a2, a3, (uint64_t (*)(void, void, uint64_t, void, void, void))AnyRandomAccessCollection.index(_:offsetBy:limitedBy:), a4);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance AnyRandomAccessCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void))AnyRandomAccessCollection.index(before:), a2);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance AnyRandomAccessCollection<A>(uint64_t a1)
{
  return AnyRandomAccessCollection.formIndex(before:)(a1, *v1);
}

id protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(void, void)@<X2>, void *a3@<X8>)
{
  uint64_t v5 = (void *)a2(*v3, *(void *)(a1 + 16));
  *a3 = v5;
  a3[1] = v6;

  return swift_unknownObjectRetain(v5);
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyRandomAccessCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void, void, void))AnyRandomAccessCollection.subscript.getter, a2);
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyRandomAccessCollection<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>(a1, (uint64_t (*)(void, void, void))AnyRandomAccessCollection.index(after:), a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance AnySequence<A>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v3 + 96))();
  uint64_t result = swift_release(v3);
  *a1 = v4;
  return result;
}

uint64_t (*LazyFilterSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyFilterSequence.init(_base:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return LazyDropWhileSequence.init(_base:predicate:)(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyFilterSequence, a6);
}

uint64_t LazyFilterSequence.Iterator.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t LazyFilterSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t LazyFilterSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*LazyFilterSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Class *LazyFilterSequence.Iterator.init(_base:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a6, a1, AssociatedTypeWitness);
  uint64_t result = type metadata accessor for LazyFilterSequence.Iterator(0, a4, (uint64_t)a5, v13);
  uint64_t v15 = (void *)(a6 + *((int *)result + 9));
  *uint64_t v15 = a2;
  v15[1] = a3;
  return result;
}

uint64_t LazyFilterSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v28 = a2;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v3 = *(int ***)(a1 + 24);
  uint64_t v34 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v8 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v6, v7);
  uint64_t v26 = (uint64_t)*(v8 - 1);
  uint64_t v27 = v8;
  uint64_t v9 = MEMORY[0x1F4188790](v8);
  unint64_t v11 = (char *)&v25 - v10;
  uint64_t v12 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v9);
  unint64_t v14 = (char *)&v25 - v13;
  uint64_t v15 = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v33 = v15;
  uint64_t v18 = swift_checkMetadataState(0, (uint64_t)v15);
  uint64_t v31 = v17;
  uint64_t v32 = AssociatedConformanceWitness;
  v17(v18, AssociatedConformanceWitness);
  uint64_t v29 = v12;
  uint64_t v30 = *(unsigned int (**)(char *, uint64_t, const char *))(v12 + 48);
  if (v30(v11, 1, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(char *, Class *))(v26 + 8))(v11, v27);
    uint64_t v22 = 1;
    uint64_t v23 = v28;
  }
  else
  {
    uint64_t v19 = *(void (**)(char *, char *, const char *))(v29 + 32);
    uint64_t v20 = (void (**)(char *, const char *))(v29 + 8);
    while (1)
    {
      v19(v14, v11, AssociatedTypeWitness);
      if ((*(uint64_t (**)(char *))(v2 + *(int *)(v34 + 36)))(v14)) {
        break;
      }
      (*v20)(v14, AssociatedTypeWitness);
      uint64_t v21 = swift_checkMetadataState(0, (uint64_t)v33);
      v31(v21, v32);
      if (v30(v11, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }
    uint64_t v23 = v28;
    v19(v28, v14, AssociatedTypeWitness);
    uint64_t v22 = 0;
  }
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v29 + 56))(v23, v22, 1, AssociatedTypeWitness);
}

__n128 LazyFilterSequence.makeIterator()@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 32))((char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v2, v6);
  uint64_t v9 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t))(v9 + 32))(v6, v9);
  uint64_t v10 = *(int *)(a1 + 36);
  uint64_t v12 = type metadata accessor for LazyFilterSequence.Iterator(0, v6, v9, v11);
  __n128 result = *(__n128 *)(v3 + v10);
  *(__n128 *)(a2 + *((int *)v12 + 9)) = result;
  return result;
}

uint64_t LazyFilterSequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(void))(v2 + *(int *)(a2 + 36)))() & 1) == 0) {
    return 0;
  }
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 48);

  return v6(a1, v5);
}

uint64_t LazyFilterSequence<>.underestimatedCount.getter()
{
  return 0;
}

uint64_t LazyFilterSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 8), v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v43 = (char *)v39 - v11;
  uint64_t v45 = *(void (***)(char *, uint64_t))(v6 - 8);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)v39 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = swift_getAssociatedTypeWitness(0, (int **)v5, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v15 = *((void *)v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v55 = (char *)v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = (char *)v39 - v18;
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v58 = a3;
  v19(v8, v5);
  uint64_t v52 = *(void (**)(uint64_t, uint64_t))(v5 + 72);
  uint64_t v53 = v5 + 72;
  uint64_t v57 = v8;
  uint64_t v51 = *(void *)(swift_getAssociatedConformanceWitness(v5, v8, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  unint64_t v49 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v51 + 8);
  uint64_t v50 = v51 + 8;
  uint64_t v20 = *(void (**)(char *, uint64_t, const char *))(v15 + 16);
  uint64_t v56 = v15 + 16;
  uint64_t v47 = (void (**)(char *, const char *))(v15 + 8);
  uint64_t v48 = v20;
  uint64_t v46 = (void (**)(char *, uint64_t, uint64_t))(v45 + 2);
  uint64_t v42 = v5 + 80;
  uint64_t v41 = (void (**)(char *))(v9 + 16);
  ++v45;
  uint64_t v40 = (uint64_t (**)(char *, const char *))(v9 + 8);
  v39[1] = v5 + 192;
  while (1)
  {
    uint64_t v21 = v54;
    v48(v54, v58, v14);
    uint64_t v22 = v55;
    v52(v57, v5);
    char v23 = v49(v21, v22, v14, v51);
    uint64_t v24 = *v47;
    (*v47)(v22, v14);
    v24(v21, v14);
    (*v46)(v13, v4, v6);
    if (v23) {
      break;
    }
    uint64_t v25 = v4;
    uint64_t v26 = &v13[*(int *)(v6 + 36)];
    uint64_t v27 = v13;
    uint64_t v29 = *(uint64_t (**)(char *))v26;
    uint64_t v28 = (atomic_ullong *)*((void *)v26 + 1);
    uint64_t v30 = v6;
    uint64_t v31 = *(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v5 + 80);
    swift_retain(v28);
    uint64_t v32 = v5;
    uint64_t v33 = v31(v59, v58, v57, v5);
    uint64_t v6 = v30;
    uint64_t v34 = (void (*)(unsigned char *, void))v33;
    uint64_t v36 = v43;
    uint64_t v35 = AssociatedTypeWitness;
    (*v41)(v43);
    v34(v59, 0);
    uint64_t v37 = v27;
    (*v45)(v27, v6);
    LOBYTE(v27) = v29(v36);
    swift_release((uint64_t)v28);
    uint64_t result = (*v40)(v36, v35);
    if (v27) {
      return result;
    }
    uint64_t v5 = v32;
    uint64_t v4 = v25;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v32 + 192))(v58, v57, v32);
    uint64_t v13 = v37;
  }
  return ((uint64_t (*)(char *, uint64_t))*v45)(v13, v6);
}

uint64_t LazyFilterSequence<>.index(after:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int **a3@<X2>, char *a4@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3, *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(a4, a1, AssociatedTypeWitness);

  return LazyFilterSequence<>.formIndex(after:)(a4, a2, (uint64_t)a3);
}

uint64_t LazyFilterSequence<>.formIndex(after:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v57 = a1;
  uint64_t v5 = *(int ***)(a3 + 8);
  uint64_t v82 = (void *)a3;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v58 = (void (**)(char *, const char *))*((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v56 - v8;
  uint64_t v80 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v56 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v56 - v12;
  uint64_t v14 = swift_getAssociatedTypeWitness(0, (int **)a3, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v56 = *((void *)v14 - 1);
  uint64_t v15 = v56;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v56 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v56 - v20;
  MEMORY[0x1F4188790](v19);
  char v23 = (char *)&v56 - v22;
  uint64_t v24 = *(void (**)(char *, uint64_t, const char *))(v15 + 16);
  v24((char *)&v56 - v22, (uint64_t)v57, v14);
  uint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v80 + 16);
  uint64_t v74 = v80 + 16;
  v73(v13, v79, a2);
  char v81 = v23;
  uint64_t v75 = (void (*)(char *, char *, const char *))v24;
  uint64_t v76 = v15 + 16;
  v24(v21, (uint64_t)v23, v14);
  uint64_t v25 = (uint64_t)v82;
  uint64_t v26 = (void (*)(uint64_t, void *))v82[9];
  unint64_t v65 = v13;
  uint64_t v71 = v26;
  uint64_t v72 = v82 + 9;
  v26(v6, v82);
  uint64_t v27 = *(void *)(swift_getAssociatedConformanceWitness(v25, v6, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  uint64_t v28 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v27 + 8);
  uint64_t v69 = v27 + 8;
  uint64_t v70 = v27;
  uint64_t v68 = v28;
  char v29 = ((uint64_t (*)(char *, char *, const char *))v28)(v21, v18, v14);
  uint64_t v30 = v56 + 8;
  uint64_t v31 = *(void (**)(char *, const char *))(v56 + 8);
  uint64_t v78 = v18;
  v31(v18, v14);
  uint64_t v77 = v21;
  v31(v21, v14);
  if (v29) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't advance past endIndex", 27, 2, "Swift/Filter.swift", 18, 2, 0xB1uLL, 0);
  }
  uint64_t v66 = v31;
  uint64_t v67 = v30;
  v31(v57, v14);
  uint64_t v32 = *(void (**)(char *, uint64_t))(v80 + 8);
  v80 += 8;
  uint64_t v63 = v32;
  v32(v65, a2);
  uint64_t v64 = (void (*)(char *, uint64_t, void *))v82[24];
  unint64_t v65 = (char *)(v82 + 24);
  uint64_t v60 = v82 + 10;
  uint64_t v59 = (void (**)(char *))(v58 + 2);
  ++v58;
  uint64_t v33 = v81;
  uint64_t v34 = v77;
  while (1)
  {
    uint64_t v35 = v79;
    uint64_t v36 = v82;
    v64(v33, v6, v82);
    v75(v34, v33, v14);
    uint64_t v37 = v78;
    v71(v6, v36);
    char v38 = v68(v34, v37, v14, v70);
    uint64_t v39 = v37;
    uint64_t v40 = v66;
    v66(v39, v14);
    v40(v34, v14);
    v73(v11, v35, a2);
    if (v38) {
      break;
    }
    uint64_t v41 = &v11[*(int *)(a2 + 36)];
    uint64_t v42 = *(uint64_t (**)(char *))v41;
    uint64_t v43 = (atomic_ullong *)*((void *)v41 + 1);
    uint64_t v44 = a2;
    uint64_t v45 = v11;
    uint64_t v46 = v6;
    uint64_t v47 = v82;
    uint64_t v48 = (uint64_t (*)(unsigned char *, char *, uint64_t, void *))v82[10];
    swift_retain(v43);
    unint64_t v49 = v47;
    uint64_t v6 = v46;
    uint64_t v50 = v48(v83, v81, v46, v49);
    a2 = v44;
    uint64_t v51 = (void (*)(unsigned char *, void))v50;
    uint64_t v52 = v61;
    uint64_t v53 = AssociatedTypeWitness;
    (*v59)(v61);
    v51(v83, 0);
    v63(v45, a2);
    LOBYTE(v51) = v42(v52);
    swift_release((uint64_t)v43);
    uint64_t v54 = v52;
    uint64_t v11 = v45;
    uint64_t v33 = v81;
    (*v58)(v54, v53);
    if (v51) {
      return (*(uint64_t (**)(char *, char *, const char *))(v56 + 32))(v57, v33, v14);
    }
  }
  v63(v11, a2);
  return (*(uint64_t (**)(char *, char *, const char *))(v56 + 32))(v57, v33, v14);
}

uint64_t LazyFilterSequence<>._advanceIndex(_:step:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v58 = a2;
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v43 = (char *)&v39 - v10;
  uint64_t v62 = a3;
  uint64_t v11 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v63 = (char *)&v39 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)a4, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v57 = (char *)&v39 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 136);
  uint64_t v56 = a4 + 136;
  uint64_t v53 = *(void (**)(uint64_t, uint64_t))(a4 + 72);
  uint64_t v54 = a4 + 72;
  uint64_t v60 = v7;
  uint64_t v52 = *(void *)(swift_getAssociatedConformanceWitness(a4, v7, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  uint64_t v50 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v52 + 8);
  uint64_t v51 = v52 + 8;
  uint64_t v48 = (void (**)(uint64_t, char *, const char *))(v14 + 32);
  unint64_t v49 = (void (**)(uint64_t, const char *))(v14 + 8);
  uint64_t v47 = (void (**)(char *, uint64_t, const char *))(v14 + 16);
  uint64_t v46 = (void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v61 = a4;
  uint64_t v42 = a4 + 80;
  uint64_t v41 = (void (**)(char *))(v8 + 16);
  uint64_t v45 = (uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t v40 = (uint64_t (**)(char *, const char *))(v8 + 8);
  while (1)
  {
    uint64_t v19 = v59;
    uint64_t v21 = v60;
    uint64_t v20 = v61;
    v55(a1, v58, v60, v61);
    uint64_t v22 = *v49;
    (*v49)(a1, v13);
    (*v48)(a1, v18, v13);
    (*v47)(v18, a1, v13);
    char v23 = v57;
    v53(v21, v20);
    char v24 = v50(v18, v23, v13, v52);
    v22((uint64_t)v23, v13);
    v22((uint64_t)v18, v13);
    (*v46)(v63, v19, v62);
    if (v24) {
      break;
    }
    uint64_t v26 = v62;
    uint64_t v25 = v63;
    uint64_t v27 = &v63[*(int *)(v62 + 36)];
    char v29 = *(uint64_t (**)(char *))v27;
    uint64_t v28 = (atomic_ullong *)*((void *)v27 + 1);
    uint64_t v30 = v61;
    uint64_t v31 = *(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v61 + 80);
    swift_retain(v28);
    uint64_t v32 = v31(v64, a1, v60, v30);
    uint64_t v33 = v26;
    uint64_t v34 = a1;
    uint64_t v35 = (void (*)(unsigned char *, void))v32;
    uint64_t v36 = v43;
    uint64_t v37 = AssociatedTypeWitness;
    (*v41)(v43);
    v35(v64, 0);
    a1 = v34;
    (*v45)(v25, v33);
    LOBYTE(v25) = v29(v36);
    swift_release((uint64_t)v28);
    uint64_t result = (*v40)(v36, v37);
    if (v25) {
      return result;
    }
  }
  return (*v45)(v63, v62);
}

uint64_t LazyFilterSequence<>._ensureBidirectional(step:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v23 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v22 - v10;
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v12, v13);
  uint64_t result = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v22 - v17;
  if (a1 < 0)
  {
    uint64_t v19 = a1;
    uint64_t v20 = v16;
    (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v5, a3);
    (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v5, a3);
    (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v11, v19, v9, v5, a3);
    uint64_t v21 = *(void (**)(char *, const char *))(v23 + 8);
    v21(v9, AssociatedTypeWitness);
    v21(v11, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, Class *))(v20 + 8))(v18, v14);
  }
  return result;
}

uint64_t LazyFilterSequence<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v33 = a3;
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v31 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = v31;
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v31 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v31 - v14;
  uint64_t v16 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 152);
  uint64_t v34 = v4;
  v16(a1, a2, v8, a4);
  uint64_t v32 = a4;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v18 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 40))(a1, a2, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v19 = *(void (**)(char *, uint64_t, const char *))(v10 + 16);
  if (v18) {
    uint64_t v20 = a2;
  }
  else {
    uint64_t v20 = a1;
  }
  if (v18) {
    uint64_t v21 = a1;
  }
  else {
    uint64_t v21 = a2;
  }
  if (v18) {
    uint64_t v22 = -1;
  }
  else {
    uint64_t v22 = 1;
  }
  v19(v15, v20, AssociatedTypeWitness);
  v19(v13, v21, AssociatedTypeWitness);
  uint64_t v23 = v13;
  uint64_t v24 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v25 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v24 + 8);
  uint64_t result = v25(v15, v23, AssociatedTypeWitness, v24);
  uint64_t v27 = v31;
  uint64_t v28 = 0;
  if (result)
  {
LABEL_15:
    uint64_t v30 = *(void (**)(char *, const char *))(v27 + 8);
    v30(v23, AssociatedTypeWitness);
    v30(v15, AssociatedTypeWitness);
    return v28;
  }
  else
  {
    uint64_t v29 = 0;
    while (1)
    {
      uint64_t v28 = v29 + v22;
      if (__OFADD__(v29, v22)) {
        break;
      }
      LazyFilterSequence<>.formIndex(after:)(v15, v33, v32);
      uint64_t result = v25(v15, v23, AssociatedTypeWitness, v24);
      v29 += v22;
      if (result)
      {
        uint64_t v27 = v31;
        goto LABEL_15;
      }
    }
    __break(1u);
  }
  return result;
}

uint64_t LazyFilterSequence<>.index(_:offsetBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4[1], v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v66 = (uint64_t (**)(char *, const char *))*((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v69 = (char *)&v63 - v12;
  uint64_t v91 = a3;
  uint64_t v13 = *(void **)(a3 - 8);
  MEMORY[0x1F4188790](v11);
  uint64_t v89 = a4;
  unint64_t v90 = (char *)&v63 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v88 = v10;
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)a4, v10, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v16 = *((void *)v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v85 = (char *)&v63 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v84 = (char *)&v63 - v19;
  uint64_t v22 = type metadata accessor for Optional(0, (uint64_t)v15, v20, v21);
  uint64_t v23 = (uint64_t)*(v22 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v63 - v24;
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  unint64_t v87 = v15;
  char v81 = v26;
  uint64_t v82 = v16 + 16;
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, const char *))v26)(a5, a1, v15);
  unint64_t v83 = (a2 > 0) | (unint64_t)(a2 >> 63);
  if ((v83 & 0x8000000000000000) != 0)
  {
    uint64_t v28 = v89;
    uint64_t v29 = (void (*)(uint64_t, void *))v89[9];
    uint64_t v79 = v22;
    uint64_t v80 = v13;
    uint64_t v30 = v16;
    uint64_t v31 = v84;
    uint64_t v32 = v88;
    v29(v88, v89);
    uint64_t v33 = v85;
    ((void (*)(uint64_t, void *))v28[8])(v32, v28);
    ((void (*)(char *, unint64_t, char *, uint64_t, void *))v28[18])(v31, v83, v33, v32, v28);
    uint64_t v34 = a2;
    uint64_t v35 = *(void (**)(char *, const char *))(v30 + 8);
    uint64_t v36 = (uint64_t)v87;
    v35(v33, v87);
    uint64_t v37 = v31;
    uint64_t v16 = v30;
    uint64_t v13 = v80;
    v35(v37, (const char *)v36);
    a2 = v34;
    uint64_t result = (*(uint64_t (**)(char *, Class *))(v23 + 8))(v25, v79);
    if ((v34 & 0x8000000000000000) == 0)
    {
LABEL_3:
      if (!a2) {
        return result;
      }
      goto LABEL_8;
    }
  }
  else if ((a2 & 0x8000000000000000) == 0)
  {
    goto LABEL_3;
  }
  BOOL v38 = __OFSUB__(0, a2);
  a2 = -a2;
  if (v38)
  {
    __break(1u);
    return result;
  }
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_8:
  uint64_t v39 = v89;
  uint64_t v79 = (Class *)v89[17];
  uint64_t v80 = v89 + 17;
  uint64_t v77 = (void (*)(uint64_t, void *))v89[9];
  uint64_t v78 = v89 + 9;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v89, v88, (uint64_t)v87, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v41 = 0;
  uint64_t v76 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v74 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v76 + 8);
  uint64_t v75 = v76 + 8;
  uint64_t v42 = (void (**)(uint64_t, const char *))(v16 + 8);
  uint64_t v73 = (void (**)(uint64_t, char *, uint64_t))(v16 + 32);
  uint64_t v72 = (void (**)(char *, uint64_t, uint64_t))(v13 + 2);
  uint64_t v68 = v39 + 10;
  uint64_t v67 = (void (**)(char *))(v66 + 2);
  uint64_t v71 = (uint64_t (**)(char *, uint64_t))(v13 + 1);
  ++v66;
  uint64_t v64 = a2;
  uint64_t v43 = v85;
  do
  {
    uint64_t v65 = v41 + 1;
    while (1)
    {
      uint64_t v44 = v84;
      uint64_t v45 = v86;
      uint64_t v47 = v88;
      uint64_t v46 = v89;
      ((void (*)(uint64_t, unint64_t, uint64_t, void *))v79)(a5, v83, v88, v89);
      uint64_t v48 = *v42;
      uint64_t v49 = (uint64_t)v87;
      (*v42)(a5, v87);
      (*v73)(a5, v44, v49);
      v81(v44, a5, v49);
      v77(v47, v46);
      char v50 = v74(v44, v43, v49, v76);
      v48((uint64_t)v43, (const char *)v49);
      v48((uint64_t)v44, (const char *)v49);
      (*v72)(v90, v45, v91);
      if (v50) {
        break;
      }
      uint64_t v52 = v90;
      uint64_t v51 = v91;
      uint64_t v53 = &v90[*(int *)(v91 + 36)];
      uint64_t v55 = *(uint64_t (**)(char *))v53;
      uint64_t v54 = (atomic_ullong *)*((void *)v53 + 1);
      uint64_t v56 = v89;
      uint64_t v57 = (uint64_t (*)(unsigned char *, uint64_t, uint64_t, void *))v89[10];
      swift_retain(v54);
      uint64_t v58 = v57(v92, a5, v88, v56);
      uint64_t v59 = v51;
      uint64_t v60 = (void (*)(unsigned char *, void))v58;
      uint64_t v61 = v69;
      uint64_t v62 = AssociatedTypeWitness;
      (*v67)(v69);
      v60(v92, 0);
      (*v71)(v52, v59);
      LOBYTE(v6_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = v55(v61);
      swift_release((uint64_t)v54);
      uint64_t result = (*v66)(v61, v62);
      if (v60) {
        goto LABEL_10;
      }
    }
    uint64_t result = (*v71)(v90, v91);
LABEL_10:
    uint64_t v41 = v65;
  }
  while (v65 != v64);
  return result;
}

Swift::Int __swiftcall Int.signum()()
{
  return (v0 > 0) | (unint64_t)(v0 >> 63);
}

uint64_t abs<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v26 = a3;
  uint64_t v27 = a4;
  uint64_t v28 = *(void *)(a2 - 8);
  uint64_t v29 = a1;
  uint64_t v5 = *(void *)(v28 + 64);
  MEMORY[0x1F4188790](a1);
  uint64_t v25 = v6;
  uint64_t v7 = *(void *)(v6 + 8);
  uint64_t v8 = *(void *)(v7 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v24 - v10;
  uint64_t v12 = swift_getAssociatedTypeWitness(0, (int **)v7, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t v13 = *((void *)v12 - 1);
  uint64_t v14 = *(void *)(v13 + 64);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v24 - v16;
  if (v15 == a2)
  {
    uint64_t v23 = v28;
    (*(void (**)(uint64_t, uint64_t))(v7 + 56))(a2, v7);
    if (v14 != v5) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
    }
    (*(void (**)(uint64_t, char *, uint64_t))(v23 + 16))(v27, v17, a2);
    return (*(uint64_t (**)(char *, uint64_t))(v13 + 8))(v17, a2);
  }
  else
  {
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v11, a2, v8);
    uint64_t v19 = v29;
    char v20 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v26 + 16))(v29, (char *)&v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), a2);
    uint64_t v21 = v28;
    (*(void (**)(char *, uint64_t))(v28 + 8))((char *)&v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), a2);
    if (v20) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(v25 + 16))(v19, a2);
    }
    else {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v21 + 16))(v27, v19, a2);
    }
  }
}

uint64_t LazyFilterSequence<>.formIndex(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  LazyFilterSequence<>.index(_:offsetBy:)(a1, a2, a3, a4, (uint64_t)&v13 - v10);
  (*(void (**)(uint64_t, const char *))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

uint64_t LazyFilterSequence<>.index(_:offsetBy:limitedBy:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char *a5@<X8>)
{
  uint64_t v72 = a2;
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 8), v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v92 = (char *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v77 = (char *)&v68 - v11;
  uint64_t v100 = a3;
  uint64_t v12 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v10);
  uint64_t v101 = a4;
  char v102 = (char *)&v68 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = swift_getAssociatedTypeWitness(255, (int **)a4, v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v17 = type metadata accessor for Optional(0, (uint64_t)v14, v15, v16);
  uint64_t v18 = (uint64_t)*(v17 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v68 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v89 = (char *)&v68 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v88 = (char *)&v68 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v70 = v26;
  uint64_t v27 = *(uint64_t (**)(void))(v26 + 16);
  uint64_t v79 = (char *)&v68 - v28;
  uint64_t v98 = v14;
  uint64_t v85 = v26 + 16;
  uint64_t v84 = v27;
  uint64_t result = v27();
  unint64_t v87 = (a1 > 0) | (unint64_t)(a1 >> 63);
  uint64_t v69 = a5;
  if ((v87 & 0x8000000000000000) == 0)
  {
    if ((a1 & 0x8000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    BOOL v40 = __OFSUB__(0, a1);
    a1 = -a1;
    if (v40)
    {
      __break(1u);
      return result;
    }
    if (a1 < 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_8;
  }
  uint64_t v30 = v101;
  uint64_t v31 = *(void (**)(uint64_t, uint64_t))(v101 + 72);
  uint64_t v99 = v12;
  uint64_t v32 = v88;
  v31(v9, v101);
  uint64_t v33 = v18;
  uint64_t v34 = v89;
  (*(void (**)(uint64_t, uint64_t))(v30 + 64))(v9, v30);
  (*(void (**)(char *, unint64_t, char *, uint64_t, uint64_t))(v30 + 144))(v32, v87, v34, v9, v30);
  uint64_t v35 = *(void (**)(char *, const char *))(v70 + 8);
  uint64_t v36 = v34;
  uint64_t v37 = v17;
  uint64_t v38 = (uint64_t)v98;
  v35(v36, v98);
  uint64_t v39 = v32;
  uint64_t v12 = v99;
  v35(v39, (const char *)v38);
  uint64_t result = (*(uint64_t (**)(char *, Class *))(v33 + 8))(v21, v37);
  a5 = v69;
  if (a1 < 0) {
    goto LABEL_6;
  }
LABEL_3:
  if (a1)
  {
LABEL_8:
    uint64_t v41 = v101;
    uint64_t v99 = v9;
    uint64_t v42 = 0;
    uint64_t v97 = *(void *)(swift_getAssociatedConformanceWitness(v101, v9, (uint64_t)v98, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
    uint64_t v95 = *(uint64_t (**)(char *, uint64_t))(v97 + 8);
    uint64_t v96 = v97 + 8;
    unint64_t v93 = (void (**)(uint64_t, uint64_t))(v41 + 72);
    uint64_t v94 = (char **)(v41 + 136);
    uint64_t v86 = (void (**)(char *, const char *))(v70 + 8);
    uint64_t v82 = (void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    uint64_t v76 = v41 + 80;
    uint64_t v75 = (void (**)(char *))(v92 + 16);
    char v81 = (void (**)(char *, uint64_t))(v12 + 8);
    uint64_t v74 = (void (**)(char *, const char *))(v92 + 8);
    unint64_t v83 = (void (**)(char *, char *, uint64_t))(v70 + 32);
    uint64_t v68 = (v70 + 32) & 0xFFFFFFFFFFFFLL | 0x48D8000000000000;
    uint64_t v43 = v79;
    uint64_t v71 = a1;
    for (char i = v95(v79, v72); ; char i = v95(v43, v72))
    {
      if (i)
      {
        (*v86)(v43, v98);
        uint64_t v67 = 1;
        a5 = v69;
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v70 + 56))(a5, v67, 1, v98);
      }
      uint64_t v73 = v42 + 1;
      uint64_t v45 = *v94;
      uint64_t v91 = *v93;
      unint64_t v92 = v45;
      while (1)
      {
        uint64_t v46 = v88;
        uint64_t v47 = v90;
        uint64_t v48 = v99;
        uint64_t v49 = v101;
        ((void (*)(char *, unint64_t, uint64_t, uint64_t))v92)(v43, v87, v99, v101);
        char v50 = *v86;
        uint64_t v51 = (uint64_t)v98;
        (*v86)(v43, v98);
        uint64_t v80 = *v83;
        v80(v43, v46, v51);
        ((void (*)(char *, char *, uint64_t))v84)(v46, v43, v51);
        uint64_t v52 = v89;
        v91(v48, v49);
        char v53 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v95)(v46, v52, v51, v97);
        v50(v52, (const char *)v51);
        v50(v46, (const char *)v51);
        uint64_t v54 = v100;
        (*v82)(v102, v47, v100);
        if (v53) {
          break;
        }
        uint64_t v56 = v101;
        uint64_t v55 = v102;
        uint64_t v57 = &v102[*(int *)(v54 + 36)];
        uint64_t v59 = *(uint64_t (**)(char *))v57;
        uint64_t v58 = (atomic_ullong *)*((void *)v57 + 1);
        uint64_t v60 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v101 + 80);
        swift_retain(v58);
        uint64_t v61 = v60(v103, v43, v99, v56);
        uint64_t v62 = v100;
        uint64_t v63 = (void (*)(char *, void))v61;
        uint64_t v64 = v77;
        uint64_t v65 = AssociatedTypeWitness;
        (*v75)(v77);
        v63(v103, 0);
        (*v81)(v55, v62);
        char v66 = v59(v64);
        swift_release((uint64_t)v58);
        uint64_t v43 = v79;
        (*v74)(v64, v65);
        if (v66) {
          goto LABEL_10;
        }
      }
      (*v81)(v102, v54);
LABEL_10:
      uint64_t v42 = v73;
      if (v73 == v71) {
        break;
      }
    }
    a5 = v69;
    v80(v69, v43, (uint64_t)v98);
    goto LABEL_19;
  }
  (*(void (**)(char *, char *, const char *))(v70 + 32))(a5, v79, v98);
LABEL_19:
  uint64_t v67 = 0;
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v70 + 56))(a5, v67, 1, v98);
}

BOOL LazyFilterSequence<>.formIndex(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a5, *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v20 - v15;
  LazyFilterSequence<>.index(_:offsetBy:limitedBy:)(a2, a3, a4, (uint64_t)a5, (char *)&v20 - v15);
  uint64_t v17 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(uint64_t, const char *))(v17 + 8))(a1, AssociatedTypeWitness);
  int v18 = (*(uint64_t (**)(char *, uint64_t, const char *))(v17 + 48))(v16, 1, AssociatedTypeWitness);
  if (v18 == 1)
  {
    (*(void (**)(char *, Class *))(v14 + 8))(v16, v13);
    (*(void (**)(uint64_t, uint64_t, const char *))(v17 + 16))(a1, a3, AssociatedTypeWitness);
  }
  else
  {
    (*(void (**)(uint64_t, char *, const char *))(v17 + 32))(a1, v16, AssociatedTypeWitness);
  }
  return v18 != 1;
}

atomic_ullong *LazyFilterSequence<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t))(a3 + 88))(a1, v8);
  uint64_t v9 = (uint64_t *)(v4 + *(int *)(a2 + 36));
  uint64_t v11 = *v9;
  uint64_t v10 = (atomic_ullong *)v9[1];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a3, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v15 = (void *)(a4
                 + *((int *)type metadata accessor for LazyFilterSequence(0, (uint64_t)AssociatedTypeWitness, *(void *)(AssociatedConformanceWitness + 8), v14)+ 9));
  *uint64_t v15 = v11;
  v15[1] = v10;

  return swift_retain(v10);
}

uint64_t LazyFilterSequence<>._customLastIndexOfEquatableElement(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if ((*(uint64_t (**)(void))(v4 + *(int *)(a2 + 36)))())
  {
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 128);
    uint64_t v10 = *(void *)(a2 + 16);
    return v9(a1, v10, a3);
  }
  else
  {
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56))(a4, 1, 1, AssociatedTypeWitness);
    uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
    uint64_t v16 = (uint64_t (*)(uint64_t, void, uint64_t, Class *))*((void *)*(v15 - 1) + 7);
    return v16(a4, 0, 1, v15);
  }
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyFilterSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), a3);
}

atomic_ullong *protocol witness for Collection.subscript.getter in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyFilterSequence<>.subscript.getter(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyFilterSequence<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void **)(a4 - 8), a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char *a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, *(void *)(a4 - 8), a5);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazyFilterSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  return LazyFilterSequence<>.index(after:)(a1, a2, *(int ***)(a3 - 8), a4);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyFilterSequence<A>(char *a1, uint64_t a2, uint64_t a3)
{
  return LazyFilterSequence<>.formIndex(after:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t LazyFilterSequence<>.index(before:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(a4, a1, AssociatedTypeWitness);

  return LazyFilterSequence<>.formIndex(before:)(a4, a2, a3);
}

uint64_t LazyFilterSequence<>.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v47 = a3;
  uint64_t v41 = a1;
  uint64_t v4 = *(void *)(a3 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v4 + 8), v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v40 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v39 = (char *)&v35 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)&v35 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = swift_getAssociatedTypeWitness(0, (int **)v4, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v12 = *((void *)v11 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v35 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  int v18 = (char *)&v35 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v35 - v19;
  uint64_t v36 = *(void (**)(char *, uint64_t, const char *))(v12 + 32);
  uint64_t v37 = v12 + 32;
  v36((char *)&v35 - v19, v41, v11);
  uint64_t v45 = v8;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, v48, a2);
  uint64_t v21 = v20;
  uint64_t v22 = v20;
  uint64_t v23 = v10;
  (*(void (**)(char *, char *, const char *))(v12 + 16))(v18, v22, v11);
  (*(void (**)(uint64_t, uint64_t))(v4 + 64))(v5, v4);
  uint64_t v46 = v4;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v4, v5, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v1_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v18, v15, v11);
  uint64_t v25 = *(void (**)(char *, const char *))(v12 + 8);
  v25(v15, v11);
  v25(v18, v11);
  if (v10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't retreat before startIndex", 31, 2, "Swift/Filter.swift", 18, 2, 0x140uLL, 0);
  }
  uint64_t v35 = v11;
  (*(void (**)(char *, uint64_t))(v45 + 8))(v23, a2);
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v47 + 40);
  uint64_t v45 = v47 + 40;
  uint64_t v27 = AssociatedTypeWitness;
  uint64_t v26 = v39;
  uint64_t v28 = (uint64_t (**)(char *))(v48 + *(int *)(a2 + 36));
  uint64_t v42 = *(uint64_t (**)(unsigned char *, char *, uint64_t, uint64_t))(v46 + 80);
  uint64_t v43 = v46 + 80;
  uint64_t v29 = (void (**)(char *))(v40 + 16);
  uint64_t v30 = (void (**)(char *, const char *))(v40 + 8);
  uint64_t v31 = v21;
  do
  {
    v44(v31, v5, v47);
    uint64_t v32 = *v28;
    uint64_t v33 = v42(v49, v31, v5, v46);
    (*v29)(v26);
    ((void (*)(unsigned char *, void))v33)(v49, 0);
    LOBYTE(v33) = v32(v26);
    (*v30)(v26, v27);
  }
  while ((v33 & 1) == 0);
  return ((uint64_t (*)(uint64_t, char *, const char *))v36)(v41, v31, v35);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyFilterSequence<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazyFilterSequence<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void **)(*(void *)(a4 - 8) + 8), a5);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance <> LazyFilterSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char *a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8), a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazyFilterSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8));
}

atomic_ullong *LazySequenceProtocol.filter(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazySequenceProtocol.drop(while:)(a1, a2, a3, a4, (uint64_t (*)(void, const char *, uint64_t))type metadata accessor for LazyFilterSequence, a5);
}

atomic_ullong *LazyFilterSequence.filter(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v28 = a1;
  uint64_t v29 = a2;
  uint64_t v30 = a4;
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v27 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v15 = (char *)&v27 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, v5, v12);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 32);
  v16(v10, v5, a3);
  uint64_t v17 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v18 = (v17 + 32) & ~v17;
  unint64_t v19 = (v8 + v18 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v20 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))swift_allocObject(qword_1EC9F2A28, v19 + 16, v17 | 7);
  uint64_t v21 = *(void *)(a3 + 24);
  *((void *)v20 + 2) = v12;
  *((void *)v20 + 3) = v21;
  v16((char *)v20 + v18, (uint64_t)v10, a3);
  uint64_t v22 = (void *)((char *)v20 + v19);
  uint64_t v23 = v29;
  *uint64_t v22 = v28;
  v22[1] = v23;
  uint64_t v24 = v30;
  (*(void (**)(uint64_t, char *, uint64_t))(v13 + 32))(v30, v15, v12);
  uint64_t v25 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v24 + *(int *)(a3 + 36));
  char *v25 = partial apply for closure #1 in LazyFilterSequence.filter(_:);
  v25[1] = v20;
  return swift_retain(v23);
}

uint64_t closure #1 in LazyFilterSequence.filter(_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(char *), uint64_t a4, uint64_t a5, int **a6)
{
  uint64_t v6 = (uint64_t)a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a6, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v12 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v19 - v13;
  uint64_t v16 = type metadata accessor for LazyFilterSequence(0, a5, v6, v15);
  LOBYTE(v6) = (*(uint64_t (**)(uint64_t))(a2 + *((int *)v16 + 9)))(a1);
  (*(void (**)(char *, uint64_t, const char *))(v12 + 16))(v14, a1, AssociatedTypeWitness);
  if (v6) {
    char v17 = a3(v14);
  }
  else {
    char v17 = 0;
  }
  (*(void (**)(char *, const char *))(v12 + 8))(v14, AssociatedTypeWitness);
  return v17 & 1;
}

uint64_t _FixedArray16.endIndex.getter(uint64_t a1)
{
  return *(char *)(v1 + *(int *)(a1 + 28));
}

uint64_t UnsafeRawBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  if (a1) {
    return a2 - a1;
  }
  else {
    return 0;
  }
}

uint64_t _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned __int8 *)(v3 + *(int *)(a3 + 28));
  v7[0] = *(void *)(a3 + 16);
  v7[1] = v7[0];
  v7[2] = v7[0];
  v7[3] = v7[0];
  v7[4] = v7[0];
  v7[5] = v7[0];
  v7[6] = v7[0];
  v7[7] = v7[0];
  v7[8] = v7[0];
  v7[9] = v7[0];
  v7[10] = v7[0];
  v7[11] = v7[0];
  v7[12] = v7[0];
  v7[13] = v7[0];
  v7[14] = v7[0];
  v7[15] = v7[0];
  if ((*(void *)(*(swift_getTupleTypeMetadata(0, 16, (uint64_t)v7, 0, 0) - 1) + 64) & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if ((v5 & 0x80) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  return a1(v3, v5);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _FixedArray16<A>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v5 = v8;
  uint64_t v9 = v4;
  uint64_t v10 = a1;
  _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5((uint64_t (*)(uint64_t, uint64_t))partial apply for closure #1 in _FixedArray16.subscript.setter, (uint64_t)&v7, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8))(a1, v5);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _FixedArray16<A>(void *a1, uint64_t *a2, uint64_t a3))(void **a1, char a2)
{
  uint64_t v5 = v3;
  uint64_t v8 = malloc(0xD8uLL);
  *a1 = v8;
  uint64_t v69 = a3;
  v8[16] = v5;
  v8[17] = a3;
  uint64_t v9 = *(void *)(a3 + 16);
  v8[18] = v9;
  *uint64_t v8 = v9;
  v8[1] = v9;
  _OWORD v8[2] = v9;
  v8[3] = v9;
  v8[4] = v9;
  unint64_t v8[5] = v9;
  v8[6] = v9;
  v8[7] = v9;
  v8[8] = v9;
  v8[9] = v9;
  v8[10] = v9;
  v8[11] = v9;
  v8[12] = v9;
  v8[13] = v9;
  v8[14] = v9;
  v8[15] = v9;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 16, (uint64_t)v8, 0, 0);
  uint64_t v44 = *((void *)TupleTypeMetadata - 1);
  size_t v71 = *(void *)(v44 + 64);
  uint64_t v11 = (char *)malloc(v71);
  v8[19] = v11;
  uint64_t v12 = (char *)malloc(v71);
  v8[20] = v12;
  uint64_t v13 = *(void **)(v9 - 8);
  uint64_t v14 = v13;
  v8[21] = v13;
  size_t v15 = v13[8];
  v8[22] = malloc(v15);
  uint64_t v16 = (char *)malloc(v15);
  uint64_t v41 = *a2;
  uint64_t v17 = *a2;
  uint64_t v42 = v16;
  v8[23] = v16;
  v8[24] = v17;
  uint64_t v18 = TupleTypeMetadata[12];
  uint64_t v72 = &v12[v18];
  uint64_t v19 = TupleTypeMetadata[16];
  uint64_t v73 = &v12[v19];
  uint64_t v20 = TupleTypeMetadata[20];
  uint64_t v75 = &v12[v20];
  uint64_t v21 = TupleTypeMetadata[24];
  uint64_t v78 = &v12[v21];
  uint64_t v22 = TupleTypeMetadata[28];
  uint64_t v80 = &v12[v22];
  uint64_t v23 = TupleTypeMetadata[32];
  uint64_t v82 = &v12[v23];
  uint64_t v24 = TupleTypeMetadata[36];
  unint64_t v83 = &v12[v24];
  uint64_t v25 = TupleTypeMetadata[40];
  uint64_t v85 = &v12[v25];
  uint64_t v26 = TupleTypeMetadata[44];
  uint64_t v86 = &v12[v26];
  uint64_t v27 = TupleTypeMetadata[48];
  uint64_t v28 = TupleTypeMetadata[52];
  uint64_t v29 = TupleTypeMetadata[56];
  uint64_t v30 = TupleTypeMetadata[60];
  uint64_t v31 = TupleTypeMetadata[64];
  uint64_t v32 = TupleTypeMetadata[68];
  uint64_t v33 = (void (*)(char *, uint64_t, uint64_t))v14[2];
  v8[25] = v33;
  v8[26] = (unint64_t)(v14 + 2) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  uint64_t v74 = &v12[v27];
  uint64_t v77 = &v12[v28];
  uint64_t v34 = v5 + v18;
  uint64_t v35 = v5 + v19;
  uint64_t v36 = v5 + v20;
  uint64_t v45 = v5 + v21;
  uint64_t v47 = v5 + v22;
  uint64_t v49 = v5 + v23;
  uint64_t v51 = v5 + v24;
  uint64_t v53 = v5 + v25;
  uint64_t v55 = v5 + v26;
  uint64_t v57 = v5 + v27;
  uint64_t v59 = v5 + v28;
  uint64_t v76 = &v12[v29];
  uint64_t v61 = v5 + v29;
  uint64_t v79 = &v12[v30];
  uint64_t v63 = v5 + v30;
  char v81 = &v12[v31];
  uint64_t v65 = v5 + v31;
  uint64_t v84 = &v12[v32];
  uint64_t v67 = v5 + v32;
  int v43 = *(char *)(v5 + *(int *)(v69 + 28));
  v33(v12, v5, v9);
  v33(v72, v34, v9);
  v33(v73, v35, v9);
  v33(v75, v36, v9);
  v33(v78, v45, v9);
  v33(v80, v47, v9);
  v33(v82, v49, v9);
  v33(v83, v51, v9);
  v33(v85, v53, v9);
  v33(v86, v55, v9);
  v33(v74, v57, v9);
  v33(v77, v59, v9);
  v33(v76, v61, v9);
  v33(v79, v63, v9);
  v33(v81, v65, v9);
  v33(v84, v67, v9);
  uint64_t v37 = &v11[TupleTypeMetadata[12]];
  uint64_t v38 = &v11[TupleTypeMetadata[16]];
  uint64_t v46 = &v11[TupleTypeMetadata[20]];
  uint64_t v48 = &v11[TupleTypeMetadata[24]];
  char v50 = &v11[TupleTypeMetadata[28]];
  uint64_t v52 = &v11[TupleTypeMetadata[32]];
  uint64_t v54 = &v11[TupleTypeMetadata[36]];
  uint64_t v56 = &v11[TupleTypeMetadata[40]];
  uint64_t v58 = &v11[TupleTypeMetadata[44]];
  uint64_t v60 = &v11[TupleTypeMetadata[48]];
  uint64_t v62 = &v11[TupleTypeMetadata[52]];
  uint64_t v64 = &v11[TupleTypeMetadata[56]];
  char v66 = &v11[TupleTypeMetadata[60]];
  uint64_t v68 = &v11[TupleTypeMetadata[64]];
  uint64_t v70 = &v11[TupleTypeMetadata[68]];
  uint64_t v39 = (void (*)(char *, char *, uint64_t))v14[4];
  v39(v11, v12, v9);
  v39(v37, v72, v9);
  v39(v38, v73, v9);
  v39(v46, v75, v9);
  v39(v48, v78, v9);
  v39(v50, v80, v9);
  v39(v52, v82, v9);
  v39(v54, v83, v9);
  v39(v56, v85, v9);
  v39(v58, v86, v9);
  v39(v60, v74, v9);
  v39(v62, v77, v9);
  v39(v64, v76, v9);
  v39(v66, v79, v9);
  v39(v68, v81, v9);
  v39(v70, v84, v9);
  if ((v71 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  (*(void (**)(char *, int *))(v44 + 8))(v11, TupleTypeMetadata);
  if (v43 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  v33(v42, (uint64_t)&v11[v14[9] * v41], v9);
  return protocol witness for MutableCollection.subscript.modify in conformance _FixedArray16<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _FixedArray16<A>(void **a1, char a2)
{
  uint64_t v2 = *a1;
  if (a2)
  {
    uint64_t v3 = (uint64_t (*)(void *, void *, uint64_t))v2[25];
    uint64_t v4 = (void *)v2[23];
    uint64_t v5 = v2[24];
    uint64_t v7 = v2[21];
    uint64_t v6 = (void *)v2[22];
    uint64_t v8 = (void *)v2[19];
    uint64_t v22 = (void *)v2[20];
    uint64_t v9 = v2[17];
    uint64_t v10 = v2[18];
    uint64_t v11 = v3(v6, v4, v10);
    MEMORY[0x1F4188790](v11);
    uint64_t v19 = v10;
    uint64_t v20 = v5;
    uint64_t v21 = v6;
    _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5((uint64_t (*)(uint64_t, uint64_t))partial apply for closure #1 in _FixedArray16.subscript.setter, (uint64_t)v18, v9);
    uint64_t v12 = v22;
    uint64_t v13 = *(void (**)(void *, uint64_t))(v7 + 8);
    v13(v6, v10);
    v13(v4, v10);
  }
  else
  {
    uint64_t v4 = (void *)v2[23];
    uint64_t v14 = v2[21];
    uint64_t v6 = (void *)v2[22];
    uint64_t v8 = (void *)v2[19];
    uint64_t v12 = (void *)v2[20];
    uint64_t v15 = v2[18];
    MEMORY[0x1F4188790](a1);
    uint64_t v19 = v15;
    uint64_t v20 = v16;
    uint64_t v21 = v4;
    _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5((uint64_t (*)(uint64_t, uint64_t))partial apply for closure #1 in _FixedArray16.subscript.setter, (uint64_t)v18, v17);
    (*(void (**)(void *, uint64_t))(v14 + 8))(v4, v15);
  }
  free(v4);
  free(v6);
  free(v12);
  free(v8);
  free(v2);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _FixedArray16<A>(uint64_t a1, long long *a2, unint64_t *a3, uint64_t a4)
{
  long long v11 = *a2;
  specialized MutableCollection<>.subscript.setter(a1, (char *)&v11, (uint64_t)a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a3, v6);
  uint64_t v9 = type metadata accessor for Slice(0, (uint64_t)a3, WitnessTable, v8);
  return (*((uint64_t (**)(uint64_t, Class *))*(v9 - 1) + 1))(a1, v9);
}

void *protocol witness for MutableCollection.partition(by:) in conformance _FixedArray16<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a3, (uint64_t)a3);
  return MutableCollection<>.partition(by:)(a1, a2, (uint64_t)a3, WitnessTable, a4, a5);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _FixedArray16<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _FixedArray16<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _FixedArray16<A>(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance _FixedArray16<A>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = _FixedArray16.endIndex.getter(a1);
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _FixedArray16<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = _FixedArray16.subscript.read(v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*_FixedArray16.subscript.read(void *a1, uint64_t a2, uint64_t a3))(uint64_t a1)
{
  uint64_t v6 = malloc(0xA8uLL);
  *a1 = v6;
  uint64_t v7 = *(void *)(a3 + 16);
  v6[15] = v7;
  v6[16] = v7;
  *uint64_t v6 = v7;
  v6[1] = v7;
  v6[2] = v7;
  v6[3] = v7;
  v6[4] = v7;
  void v6[5] = v7;
  v6[6] = v7;
  v6[7] = v7;
  v6[8] = v7;
  v6[9] = v7;
  v6[10] = v7;
  v6[11] = v7;
  v6[12] = v7;
  v6[13] = v7;
  v6[14] = v7;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 16, (uint64_t)v6, 0, 0);
  uint64_t v38 = *((void *)TupleTypeMetadata - 1);
  size_t v68 = *(void *)(v38 + 64);
  uint64_t v9 = (char *)malloc(v68);
  v6[17] = v9;
  uint64_t v10 = (char *)malloc(v68);
  v6[18] = v10;
  long long v11 = *(void **)(v7 - 8);
  uint64_t v82 = v11;
  v6[19] = v11;
  uint64_t v35 = (char *)malloc(v11[8]);
  v6[20] = v35;
  uint64_t v12 = TupleTypeMetadata[12];
  uint64_t v13 = &v10[v12];
  uint64_t v14 = TupleTypeMetadata[16];
  uint64_t v15 = &v10[v14];
  char v66 = &v10[v12];
  uint64_t v67 = &v10[v14];
  uint64_t v16 = TupleTypeMetadata[20];
  uint64_t v69 = &v10[v16];
  uint64_t v17 = TupleTypeMetadata[24];
  uint64_t v70 = &v10[v17];
  uint64_t v18 = TupleTypeMetadata[28];
  size_t v71 = &v10[v18];
  uint64_t v19 = TupleTypeMetadata[32];
  uint64_t v72 = &v10[v19];
  uint64_t v20 = TupleTypeMetadata[36];
  uint64_t v73 = &v10[v20];
  uint64_t v21 = TupleTypeMetadata[40];
  uint64_t v74 = &v10[v21];
  uint64_t v22 = TupleTypeMetadata[44];
  uint64_t v75 = &v10[v22];
  uint64_t v23 = TupleTypeMetadata[48];
  uint64_t v76 = &v10[v23];
  uint64_t v24 = TupleTypeMetadata[52];
  uint64_t v77 = &v10[v24];
  uint64_t v25 = TupleTypeMetadata[56];
  uint64_t v79 = &v10[v25];
  uint64_t v26 = TupleTypeMetadata[60];
  uint64_t v80 = &v10[v26];
  uint64_t v27 = TupleTypeMetadata[64];
  char v81 = &v10[v27];
  uint64_t v28 = v3 + v12;
  uint64_t v39 = v3 + v14;
  uint64_t v40 = v3 + v16;
  uint64_t v42 = v3 + v17;
  uint64_t v44 = v3 + v18;
  uint64_t v46 = v3 + v19;
  uint64_t v48 = v3 + v20;
  uint64_t v50 = v3 + v21;
  uint64_t v52 = v3 + v22;
  uint64_t v54 = v3 + v23;
  uint64_t v56 = v3 + v24;
  uint64_t v58 = v3 + v25;
  uint64_t v60 = v3 + v26;
  uint64_t v62 = v3 + v27;
  int v37 = *(char *)(v3 + *(int *)(a3 + 28));
  uint64_t v29 = TupleTypeMetadata[68];
  uint64_t v78 = &v10[v29];
  uint64_t v64 = v3 + v29;
  uint64_t v30 = (void (*)(char *, uint64_t, uint64_t))v82[2];
  v30(v10, v3, v7);
  v30(v13, v28, v7);
  v30(v15, v39, v7);
  v30(v69, v40, v7);
  v30(v70, v42, v7);
  v30(v71, v44, v7);
  v30(v72, v46, v7);
  v30(v73, v48, v7);
  v30(v74, v50, v7);
  v30(v75, v52, v7);
  v30(v76, v54, v7);
  v30(v77, v56, v7);
  v30(v79, v58, v7);
  v30(v80, v60, v7);
  v30(v81, v62, v7);
  v30(v78, v64, v7);
  uint64_t v31 = &v9[TupleTypeMetadata[12]];
  uint64_t v32 = &v9[TupleTypeMetadata[16]];
  uint64_t v41 = &v9[TupleTypeMetadata[20]];
  int v43 = &v9[TupleTypeMetadata[24]];
  uint64_t v45 = &v9[TupleTypeMetadata[28]];
  uint64_t v47 = &v9[TupleTypeMetadata[32]];
  uint64_t v49 = &v9[TupleTypeMetadata[36]];
  uint64_t v51 = &v9[TupleTypeMetadata[40]];
  uint64_t v53 = &v9[TupleTypeMetadata[44]];
  uint64_t v55 = &v9[TupleTypeMetadata[48]];
  uint64_t v57 = &v9[TupleTypeMetadata[52]];
  uint64_t v59 = &v9[TupleTypeMetadata[56]];
  uint64_t v61 = &v9[TupleTypeMetadata[60]];
  uint64_t v63 = &v9[TupleTypeMetadata[64]];
  uint64_t v65 = &v9[TupleTypeMetadata[68]];
  uint64_t v33 = (void (*)(char *, char *, uint64_t))v82[4];
  v33(v9, v10, v7);
  v33(v31, v66, v7);
  v33(v32, v67, v7);
  v33(v41, v69, v7);
  v33(v43, v70, v7);
  v33(v45, v71, v7);
  v33(v47, v72, v7);
  v33(v49, v73, v7);
  v33(v51, v74, v7);
  v33(v53, v75, v7);
  v33(v55, v76, v7);
  v33(v57, v77, v7);
  v33(v59, v79, v7);
  v33(v61, v80, v7);
  v33(v63, v81, v7);
  v33(v65, v78, v7);
  if ((v68 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  (*(void (**)(char *, int *))(v38 + 8))(v9, TupleTypeMetadata);
  if (v37 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  v30(v35, (uint64_t)&v9[v82[9] * a2], v7);
  return _FixedArray16.subscript.read;
}

void _FixedArray16.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 160);
  uint64_t v4 = *(void **)(*(void *)a1 + 136);
  uint64_t v3 = *(void **)(*(void *)a1 + 144);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 152) + 8))(v2, *(void *)(*(void *)a1 + 128));
  free(v2);
  free(v3);
  free(v4);

  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance _FixedArray16<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);

  return MutableCollection<>.subscript.getter(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Collection.indices.getter in conformance _FixedArray16<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

Class *protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>(a1, protocol conformance descriptor for _FixedArray16<A>, a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _FixedArray16<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _FixedArray16<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

unsigned char *static Int8.+= infix(_:_:)(unsigned char *result, char a2)
{
  int v2 = (char)*result + a2;
  if ((char)(*result + a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

atomic_ullong *LazySequenceProtocol.flatMap<A>(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v14 = (void *)(a6
                 + *((int *)type metadata accessor for LazyMapSequence(0, (uint64_t)AssociatedTypeWitness, a4, AssociatedConformanceWitness)+ 11));
  *uint64_t v14 = a1;
  v14[1] = a2;

  return swift_retain(a2);
}

{
  const char *AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  Class *v13;
  uint64_t AssociatedConformanceWitness;
  Class *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t WitnessTable;
  uint64_t v21;
  Class *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  atomic_ullong *v27;
  void *v28;
  uint64_t v29;
  char *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  atomic_ullong *v40;

  uint64_t v38 = a4;
  uint64_t v39 = a6;
  uint64_t v40 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v13 = type metadata accessor for Optional(255, a4, v11, v12);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v15 = type metadata accessor for LazyMapSequence(0, (uint64_t)AssociatedTypeWitness, (uint64_t)v13, AssociatedConformanceWitness);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v37 - v17;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>, (unint64_t *)v15, v19);
  uint64_t v22 = type metadata accessor for LazyFilterSequence(0, (uint64_t)v15, WitnessTable, v21);
  uint64_t v23 = (uint64_t)*(v22 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v37 - v24;
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t v26 = &v18[*((int *)v15 + 11)];
  uint64_t v27 = v40;
  *(void *)uint64_t v26 = a1;
  *((void *)v26 + 1) = v27;
  uint64_t v28 = swift_allocObject(qword_1EC9F2B18, 0x28uLL, 7uLL);
  uint64_t v29 = v38;
  v28[2] = a3;
  v28[3] = v29;
  v28[4] = a5;
  (*(void (**)(char *, char *, Class *))(v16 + 32))(v25, v18, v15);
  uint64_t v30 = &v25[*((int *)v22 + 9)];
  *(void *)uint64_t v30 = partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:);
  *((void *)v30 + 1) = v28;
  uint64_t v31 = swift_allocObject(qword_1EC9F2B40, 0x28uLL, 7uLL);
  v31[2] = a3;
  uint64_t v31[3] = v29;
  v31[4] = a5;
  uint64_t v32 = v39;
  (*(void (**)(uint64_t, char *, Class *))(v23 + 32))(v39, v25, v22);
  uint64_t v34 = swift_getWitnessTable(protocol conformance descriptor for LazyFilterSequence<A>, (unint64_t *)v22, v33);
  uint64_t v35 = (void *)(v32 + *((int *)type metadata accessor for LazyMapSequence(0, (uint64_t)v22, v29, v34) + 11));
  *uint64_t v35 = closure #2 in LazySequenceProtocol.compactMap<A>(_:)partial apply;
  v35[1] = v31;
  return swift_retain(v40);
}

uint64_t LazySequenceProtocol<>.joined()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v12 - v9;
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8))(v3, a1);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v8 + 32))(a3, v10, AssociatedTypeWitness);
}

atomic_ullong *LazySequenceProtocol.compactMap<A>(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v38 = a4;
  uint64_t v39 = a6;
  uint64_t v40 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v13 = type metadata accessor for Optional(255, a4, v11, v12);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v15 = type metadata accessor for LazyMapSequence(0, (uint64_t)AssociatedTypeWitness, (uint64_t)v13, AssociatedConformanceWitness);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v37 - v17;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>, (unint64_t *)v15, v19);
  uint64_t v22 = type metadata accessor for LazyFilterSequence(0, (uint64_t)v15, WitnessTable, v21);
  uint64_t v23 = (uint64_t)*(v22 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v37 - v24;
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t v26 = &v18[*((int *)v15 + 11)];
  uint64_t v27 = v40;
  *(void *)uint64_t v26 = a1;
  *((void *)v26 + 1) = v27;
  uint64_t v28 = swift_allocObject(qword_1EC9F2A50, 0x28uLL, 7uLL);
  uint64_t v29 = v38;
  v28[2] = a3;
  v28[3] = v29;
  v28[4] = a5;
  (*(void (**)(char *, char *, Class *))(v16 + 32))(v25, v18, v15);
  uint64_t v30 = &v25[*((int *)v22 + 9)];
  *(void *)uint64_t v30 = partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:);
  *((void *)v30 + 1) = v28;
  uint64_t v31 = (uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X8>))swift_allocObject(qword_1EC9F2A78, 0x28uLL, 7uLL);
  *((void *)v31 + 2) = a3;
  *((void *)v31 + 3) = v29;
  *((void *)v31 + 4) = a5;
  uint64_t v32 = v39;
  (*(void (**)(uint64_t, char *, Class *))(v23 + 32))(v39, v25, v22);
  uint64_t v34 = swift_getWitnessTable(protocol conformance descriptor for LazyFilterSequence<A>, (unint64_t *)v22, v33);
  uint64_t v35 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v32
                                                                 + *((int *)type metadata accessor for LazyMapSequence(0, (uint64_t)v22, v29, v34)+ 11));
  *uint64_t v35 = partial apply for closure #2 in LazySequenceProtocol.compactMap<A>(_:);
  v35[1] = v31;
  return swift_retain(v40);
}

uint64_t closure #2 in LazySequenceProtocol.compactMap<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = type metadata accessor for Optional(0, a2, a2, a3);
  MEMORY[0x1F4188790](v7);
  uint64_t v9 = (char *)&v13 - v8;
  (*(void (**)(char *, uint64_t))(v10 + 16))((char *)&v13 - v8, a1);
  uint64_t v11 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v11 + 48))(v9, 1, a2) == 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/FlatMap.swift", 19, 2, 0x31uLL, 0);
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(a4, v9, a2);
}

uint64_t (*FlattenSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t FlattenSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*FlattenSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*FlattenSequence.Iterator._inner.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.Iterator.init(_base:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int **a3@<X2>, int **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = a5 + *((int *)type metadata accessor for FlattenSequence.Iterator(0, a2, (uint64_t)a3, (uint64_t)a4) + 11);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v12 = swift_getAssociatedTypeWitness(0, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v12 - 1) + 56))(v10, 1, 1, v12);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)v13 - 1) + 32);

  return v14(a5, a1, v13);
}

uint64_t specialized FlattenSequence.Iterator.next()()
{
  unint64_t v1 = v0[7];
  if (!v1) {
    goto LABEL_6;
  }
  while (1)
  {
    Swift::UInt64 rawBits = v0[8];
    unint64_t v3 = v0[6];
    if ((v1 & 0x2000000000000000) != 0) {
      unint64_t v4 = HIBYTE(v1) & 0xF;
    }
    else {
      unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 != 4 * v4)
    {
      uint64_t v9 = (v3 >> 59) & 1;
      if ((v1 & 0x1000000000000000) == 0) {
        LOBYTE(v9) = 1;
      }
      if ((v0[8] & 0xCLL) == 4 << v9) {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
      }
      Swift::UInt64 v10 = rawBits >> 16;
      if (rawBits >> 16 >= v4)
      {
        unint64_t v18 = 228;
      }
      else
      {
        if ((v1 & 0x1000000000000000) != 0)
        {
          LOBYTE(v1) = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }
        else if ((v1 & 0x2000000000000000) != 0)
        {
          v20[0] = v3;
          v20[1] = v1 & 0xFFFFFFFFFFFFFFLL;
          LOBYTE(v1) = *((unsigned char *)v20 + v10);
        }
        else
        {
          if ((v3 & 0x1000000000000000) != 0) {
            uint64_t v11 = (unsigned char *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            uint64_t v11 = _StringObject.sharedUTF8.getter(v3, v1);
          }
          LOBYTE(v1) = v11[v10];
        }
        unint64_t v12 = v0[6];
        unint64_t v13 = v0[7];
        Swift::UInt64 v14 = v0[8];
        uint64_t v15 = (v12 >> 59) & 1;
        if ((v13 & 0x1000000000000000) == 0) {
          LOBYTE(v15) = 1;
        }
        if ((v0[8] & 0xCLL) == 4 << v15)
        {
          Swift::UInt64 v14 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v14)._rawBits;
          if ((v13 & 0x1000000000000000) == 0) {
            goto LABEL_24;
          }
        }
        else if ((v13 & 0x1000000000000000) == 0)
        {
LABEL_24:
          Swift::UInt64 v16 = (v14 & 0xFFFFFFFFFFFF0000) + 65540;
LABEL_25:
          int v8 = 0;
          v0[8] = v16;
          return v1 | (v8 << 8);
        }
        unint64_t v19 = HIBYTE(v13) & 0xF;
        if ((v13 & 0x2000000000000000) == 0) {
          unint64_t v19 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (v19 > v14 >> 16)
        {
          Swift::UInt64 v16 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v14)._rawBits;
          goto LABEL_25;
        }
        unint64_t v18 = 144;
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v18, 0);
    }
LABEL_6:
    uint64_t v5 = specialized LazyMapSequence.Iterator.next()();
    unint64_t v1 = v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = v5;
    swift_bridgeObjectRelease(v0[7]);
    v0[6] = v7;
    v0[7] = v1;
    v0[8] = 15;
  }
  int v8 = 1;
  return v1 | (v8 << 8);
}

{
  void *v0;
  unint64_t v1;
  Swift::UInt64 rawBits;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  Swift::UInt64 v10;
  unsigned char *v11;
  unint64_t v12;
  unint64_t v13;
  Swift::UInt64 v14;
  uint64_t v15;
  Swift::UInt64 v16;
  unint64_t v18;
  unint64_t v19;
  void v20[3];

  unint64_t v1 = v0[8];
  if (!v1) {
    goto LABEL_6;
  }
  while (1)
  {
    Swift::UInt64 rawBits = v0[9];
    unint64_t v3 = v0[7];
    if ((v1 & 0x2000000000000000) != 0) {
      unint64_t v4 = HIBYTE(v1) & 0xF;
    }
    else {
      unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 != 4 * v4)
    {
      uint64_t v9 = (v3 >> 59) & 1;
      if ((v1 & 0x1000000000000000) == 0) {
        LOBYTE(v9) = 1;
      }
      if ((v0[9] & 0xCLL) == 4 << v9) {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
      }
      Swift::UInt64 v10 = rawBits >> 16;
      if (rawBits >> 16 >= v4)
      {
        unint64_t v18 = 228;
      }
      else
      {
        if ((v1 & 0x1000000000000000) != 0)
        {
          LOBYTE(v1) = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }
        else if ((v1 & 0x2000000000000000) != 0)
        {
          v20[0] = v3;
          v20[1] = v1 & 0xFFFFFFFFFFFFFFLL;
          LOBYTE(v1) = *((unsigned char *)v20 + v10);
        }
        else
        {
          if ((v3 & 0x1000000000000000) != 0) {
            uint64_t v11 = (unsigned char *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            uint64_t v11 = _StringObject.sharedUTF8.getter(v3, v1);
          }
          LOBYTE(v1) = v11[v10];
        }
        unint64_t v12 = v0[7];
        unint64_t v13 = v0[8];
        Swift::UInt64 v14 = v0[9];
        uint64_t v15 = (v12 >> 59) & 1;
        if ((v13 & 0x1000000000000000) == 0) {
          LOBYTE(v15) = 1;
        }
        if ((v0[9] & 0xCLL) == 4 << v15)
        {
          Swift::UInt64 v14 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v14)._rawBits;
          if ((v13 & 0x1000000000000000) == 0) {
            goto LABEL_24;
          }
        }
        else if ((v13 & 0x1000000000000000) == 0)
        {
LABEL_24:
          Swift::UInt64 v16 = (v14 & 0xFFFFFFFFFFFF0000) + 65540;
LABEL_25:
          int v8 = 0;
          v0[9] = v16;
          return v1 | (v8 << 8);
        }
        unint64_t v19 = HIBYTE(v13) & 0xF;
        if ((v13 & 0x2000000000000000) == 0) {
          unint64_t v19 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (v19 > v14 >> 16)
        {
          Swift::UInt64 v16 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v14)._rawBits;
          goto LABEL_25;
        }
        unint64_t v18 = 144;
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v18, 0);
    }
LABEL_6:
    uint64_t v5 = specialized LazyMapSequence.Iterator.next()();
    unint64_t v1 = v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = v5;
    swift_bridgeObjectRelease(v0[8]);
    v0[7] = v7;
    v0[8] = v1;
    v0[9] = 15;
  }
  int v8 = 1;
  return v1 | (v8 << 8);
}

{
  Swift::String::Index *v0;
  Swift::String::Index *v1;
  unint64_t rawBits;
  Swift::UInt64 v3;
  unint64_t v4;
  unint64_t v5;
  Swift::UInt64 v6;
  Swift::UInt64 v7;
  Swift::UInt64 v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  void (*v12)(unint64_t *__return_ptr, void *);
  Swift::UInt64 v13;
  Swift::UInt8 v14;
  int v15;
  uint64_t v16;
  Swift::UInt64 v17;
  unsigned char *v18;
  Swift::UInt64 v19;
  Swift::UInt64 v20;
  Swift::UInt64 v21;
  uint64_t v22;
  Swift::UInt64 v23;
  unint64_t v25;
  unint64_t v26;
  Swift::UInt8 v27;
  Swift::String::Index v28;
  unint64_t v29;
  Swift::UInt8 v30;
  Swift::UInt64 v31;
  Swift::UInt64 v32;
  void v33[2];
  unint64_t v34;
  uint64_t v35;

  unint64_t v1 = v0;
  Swift::UInt64 rawBits = v0[5]._rawBits;
  if (!rawBits) {
    goto LABEL_5;
  }
LABEL_2:
  unint64_t v3 = v1[6]._rawBits;
  unint64_t v4 = v1[4]._rawBits;
  uint64_t v5 = HIBYTE(rawBits) & 0xF;
  if ((rawBits & 0x2000000000000000) == 0) {
    uint64_t v5 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v3 >> 14 != 4 * v5)
  {
    Swift::UInt64 v16 = (v4 >> 59) & 1;
    if ((rawBits & 0x1000000000000000) == 0) {
      LOBYTE(v16) = 1;
    }
    if ((v1[6]._rawBits & 0xC) == 4 << v16)
    {
      uint64_t v31 = v1[4]._rawBits;
      uint64_t v25 = v5;
      unint64_t v3 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v3)._rawBits;
      uint64_t v5 = v25;
      unint64_t v4 = v31;
    }
    uint64_t v17 = v3 >> 16;
    if (v3 >> 16 >= v5)
    {
      uint64_t v26 = 228;
    }
    else
    {
      if ((rawBits & 0x1000000000000000) != 0)
      {
        Swift::UInt64 v14 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)v3);
      }
      else if ((rawBits & 0x2000000000000000) != 0)
      {
        uint64_t v34 = v4;
        uint64_t v35 = rawBits & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt64 v14 = *((unsigned char *)&v34 + v17);
      }
      else
      {
        if ((v4 & 0x1000000000000000) != 0) {
          unint64_t v18 = (unsigned char *)((rawBits & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          unint64_t v18 = _StringObject.sharedUTF8.getter(v4, rawBits);
        }
        Swift::UInt64 v14 = v18[v17];
      }
      uint64_t v20 = v1[4]._rawBits;
      unint64_t v19 = v1[5]._rawBits;
      uint64_t v21 = v1[6]._rawBits;
      uint64_t v22 = (v20 >> 59) & 1;
      if ((v19 & 0x1000000000000000) == 0) {
        LOBYTE(v22) = 1;
      }
      if ((v1[6]._rawBits & 0xC) == 4 << v22)
      {
        uint64_t v27 = v14;
        uint64_t v32 = v1[5]._rawBits;
        v28._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v1[6])._rawBits;
        unint64_t v19 = v32;
        uint64_t v21 = v28._rawBits;
        Swift::UInt64 v14 = v27;
        if ((v32 & 0x1000000000000000) == 0) {
          goto LABEL_26;
        }
      }
      else if ((v19 & 0x1000000000000000) == 0)
      {
LABEL_26:
        uint64_t v23 = (v21 & 0xFFFFFFFFFFFF0000) + 65540;
LABEL_27:
        uint64_t v15 = 0;
        v1[6]._Swift::UInt64 rawBits = v23;
        return v14 | (v15 << 8);
      }
      if ((v19 & 0x2000000000000000) != 0) {
        uint64_t v29 = HIBYTE(v19) & 0xF;
      }
      else {
        uint64_t v29 = v20 & 0xFFFFFFFFFFFFLL;
      }
      if (v29 > v21 >> 16)
      {
        uint64_t v30 = v14;
        uint64_t v23 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v21)._rawBits;
        Swift::UInt64 v14 = v30;
        goto LABEL_27;
      }
      uint64_t v26 = 144;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v26, 0);
  }
LABEL_5:
  while (1)
  {
    unint64_t v6 = v1[1]._rawBits;
    uint64_t v7 = *(void *)(v1->_rawBits + 16);
    if (v6 == v7) {
      break;
    }
    if (v6 >= v7) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
    int v8 = v6 + 1;
    uint64_t v11 = (uint64_t *)(v1->_rawBits + 16 * v6 + 32);
    uint64_t v9 = *v11;
    Swift::UInt64 v10 = v11[1];
    v1[1]._Swift::UInt64 rawBits = v8;
    unint64_t v12 = (void (*)(unint64_t *__return_ptr, void *))v1[2]._rawBits;
    v33[0] = v9;
    v33[1] = v10;
    swift_bridgeObjectRetain(v10);
    v12(&v34, v33);
    swift_bridgeObjectRelease(v10);
    unint64_t v13 = v34;
    Swift::UInt64 rawBits = v35;
    swift_bridgeObjectRelease(v1[5]._rawBits);
    v1[4]._Swift::UInt64 rawBits = v13;
    v1[5]._Swift::UInt64 rawBits = rawBits;
    v1[6]._Swift::UInt64 rawBits = 15;
    if (rawBits) {
      goto LABEL_2;
    }
  }
  Swift::UInt64 v14 = 0;
  uint64_t v15 = 1;
  return v14 | (v15 << 8);
}

{
  unint64_t *v0;
  unint64_t *v1;
  unint64_t v2;
  Swift::UInt64 rawBits;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void (*v8)(void *__return_ptr, unint64_t *);
  unint64_t v9;
  Swift::UInt8 v10;
  int v11;
  uint64_t v12;
  Swift::UInt64 v13;
  unsigned char *v14;
  unint64_t v15;
  unint64_t v16;
  Swift::UInt64 v17;
  uint64_t v18;
  Swift::UInt64 v19;
  unint64_t v21;
  unint64_t v22;
  void v23[2];
  unint64_t v24;
  uint64_t v25;

  unint64_t v1 = v0;
  int v2 = v0[5];
  if (!v2) {
    goto LABEL_6;
  }
LABEL_2:
  Swift::UInt64 rawBits = v1[6];
  unint64_t v4 = v1[4];
  if ((v2 & 0x2000000000000000) != 0) {
    uint64_t v5 = HIBYTE(v2) & 0xF;
  }
  else {
    uint64_t v5 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (rawBits >> 14 != 4 * v5)
  {
    unint64_t v12 = (v4 >> 59) & 1;
    if ((v2 & 0x1000000000000000) == 0) {
      LOBYTE(v12) = 1;
    }
    if ((v1[6] & 0xC) == 4 << v12) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    unint64_t v13 = rawBits >> 16;
    if (rawBits >> 16 >= v5)
    {
      uint64_t v21 = 228;
    }
    else
    {
      if ((v2 & 0x1000000000000000) != 0)
      {
        Swift::UInt64 v10 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
      }
      else if ((v2 & 0x2000000000000000) != 0)
      {
        uint64_t v24 = v4;
        uint64_t v25 = v2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt64 v10 = *((unsigned char *)&v24 + v13);
      }
      else
      {
        if ((v4 & 0x1000000000000000) != 0) {
          Swift::UInt64 v14 = (unsigned char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          Swift::UInt64 v14 = _StringObject.sharedUTF8.getter(v4, v2);
        }
        Swift::UInt64 v10 = v14[v13];
      }
      uint64_t v15 = v1[4];
      Swift::UInt64 v16 = v1[5];
      uint64_t v17 = v1[6];
      unint64_t v18 = (v15 >> 59) & 1;
      if ((v16 & 0x1000000000000000) == 0) {
        LOBYTE(v18) = 1;
      }
      if ((v1[6] & 0xC) == 4 << v18)
      {
        uint64_t v17 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v17)._rawBits;
        if ((v16 & 0x1000000000000000) == 0) {
          goto LABEL_25;
        }
      }
      else if ((v16 & 0x1000000000000000) == 0)
      {
LABEL_25:
        unint64_t v19 = (v17 & 0xFFFFFFFFFFFF0000) + 65540;
LABEL_26:
        uint64_t v11 = 0;
        v1[6] = v19;
        return v10 | (v11 << 8);
      }
      uint64_t v22 = HIBYTE(v16) & 0xF;
      if ((v16 & 0x2000000000000000) == 0) {
        uint64_t v22 = v15 & 0xFFFFFFFFFFFFLL;
      }
      if (v22 > v17 >> 16)
      {
        unint64_t v19 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v17)._rawBits;
        goto LABEL_26;
      }
      uint64_t v21 = 144;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v21, 0);
  }
LABEL_6:
  while (1)
  {
    unint64_t v6 = *v1;
    uint64_t v7 = v1[1];
    *unint64_t v1 = 0;
    v1[1] = 0;
    if (!v7) {
      break;
    }
    int v8 = (void (*)(void *__return_ptr, unint64_t *))v1[2];
    uint64_t v24 = v6;
    uint64_t v25 = v7;
    v8(v23, &v24);
    swift_bridgeObjectRelease(v7);
    uint64_t v9 = v23[0];
    int v2 = v23[1];
    swift_bridgeObjectRelease(v1[5]);
    v1[4] = v9;
    v1[5] = v2;
    v1[6] = 15;
    if (v2) {
      goto LABEL_2;
    }
  }
  Swift::UInt64 v10 = 0;
  uint64_t v11 = 1;
  return v10 | (v11 << 8);
}

{
  void *v0;
  unint64_t v1;
  Swift::UInt64 rawBits;
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  Swift::UInt64 v7;
  unsigned char *v8;
  unint64_t v9;
  unint64_t v10;
  Swift::UInt64 v11;
  uint64_t v12;
  Swift::UInt64 v13;
  unint64_t v15;
  unint64_t v16;
  void v17[3];

  unint64_t v1 = v0[3];
  if (!v1) {
    goto LABEL_7;
  }
  Swift::UInt64 rawBits = v0[4];
  unint64_t v3 = v0[2];
  if ((v1 & 0x2000000000000000) != 0) {
    unint64_t v4 = HIBYTE(v1) & 0xF;
  }
  else {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (rawBits >> 14 != 4 * v4)
  {
    unint64_t v6 = (v3 >> 59) & 1;
    if ((v1 & 0x1000000000000000) == 0) {
      LOBYTE(v6) = 1;
    }
    if ((v0[4] & 0xCLL) == 4 << v6) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    uint64_t v7 = rawBits >> 16;
    if (rawBits >> 16 >= v4)
    {
      uint64_t v15 = 228;
    }
    else
    {
      if ((v1 & 0x1000000000000000) != 0)
      {
        LOBYTE(v1) = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
      }
      else if ((v1 & 0x2000000000000000) != 0)
      {
        v17[0] = v3;
        v17[1] = v1 & 0xFFFFFFFFFFFFFFLL;
        LOBYTE(v1) = *((unsigned char *)v17 + v7);
      }
      else
      {
        if ((v3 & 0x1000000000000000) != 0) {
          int v8 = (unsigned char *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          int v8 = _StringObject.sharedUTF8.getter(v3, v1);
        }
        LOBYTE(v1) = v8[v7];
      }
      uint64_t v9 = v0[2];
      Swift::UInt64 v10 = v0[3];
      uint64_t v11 = v0[4];
      unint64_t v12 = (v9 >> 59) & 1;
      if ((v10 & 0x1000000000000000) == 0) {
        LOBYTE(v12) = 1;
      }
      if ((v0[4] & 0xCLL) == 4 << v12)
      {
        uint64_t v11 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v11)._rawBits;
        if ((v10 & 0x1000000000000000) == 0) {
          goto LABEL_23;
        }
      }
      else if ((v10 & 0x1000000000000000) == 0)
      {
LABEL_23:
        unint64_t v13 = (v11 & 0xFFFFFFFFFFFF0000) + 65540;
LABEL_24:
        uint64_t v5 = 0;
        v0[4] = v13;
        return v1 | (v5 << 8);
      }
      Swift::UInt64 v16 = HIBYTE(v10) & 0xF;
      if ((v10 & 0x2000000000000000) == 0) {
        Swift::UInt64 v16 = v9 & 0xFFFFFFFFFFFFLL;
      }
      if (v16 > v11 >> 16)
      {
        unint64_t v13 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v11)._rawBits;
        goto LABEL_24;
      }
      uint64_t v15 = 144;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v15, 0);
  }
  LOBYTE(v1) = 0;
LABEL_7:
  uint64_t v5 = 1;
  return v1 | (v5 << 8);
}

uint64_t FlattenSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v56 = a2;
  unint64_t v4 = *(int ***)(a1 + 24);
  uint64_t v71 = *(void *)(a1 + 16);
  uint64_t v72 = v4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v71, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int v8 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v6, v7);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v67 = (char *)&v54 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v70 = (char *)&v54 - v12;
  unint64_t v13 = *(int ***)(a1 + 32);
  Swift::UInt64 v14 = swift_getAssociatedTypeWitness(255, v13, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v58 = type metadata accessor for Optional(0, (uint64_t)v14, v15, v16);
  uint64_t v17 = (uint64_t)*(v58 - 1);
  MEMORY[0x1F4188790](v58);
  uint64_t v59 = (char *)&v54 - v18;
  unint64_t v19 = swift_getAssociatedTypeWitness(255, v13, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v22 = type metadata accessor for Optional(0, (uint64_t)v19, v20, v21);
  uint64_t v23 = MEMORY[0x1F4188790](v22);
  uint64_t v65 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v77 = (char *)&v54 - v26;
  uint64_t v27 = (char *)(v2 + *(int *)(a1 + 44));
  uint64_t v29 = *(void (**)(char *, uint64_t, uint64_t))(v28 + 16);
  v28 += 16;
  uint64_t v75 = v19 - 8;
  uint64_t v76 = v29;
  uint64_t v73 = v2;
  uint64_t v74 = (void (**)(char *, uint64_t))(v28 - 8);
  uint64_t v60 = v14 - 8;
  uint64_t v61 = v14;
  uint64_t v30 = v25;
  uint64_t v55 = v17;
  uint64_t v57 = (void (**)(char *, Class *))(v17 + 8);
  uint64_t v31 = v27;
  uint64_t v79 = v13;
  uint64_t v80 = AssociatedTypeWitness;
  char v66 = (void (**)(char *, char *, Class *))(v9 + 16);
  size_t v68 = (void (**)(char *, Class *))(v9 + 8);
  uint64_t v69 = AssociatedTypeWitness - 8;
  uint64_t v78 = v28;
  uint64_t v63 = (void (**)(uint64_t, char *, uint64_t))(v28 + 24);
  uint64_t v64 = v13 + 4;
  for (uint64_t i = v25; ; (*v63)((uint64_t)v39, v51, i))
  {
    uint64_t v32 = v77;
    v76(v77, (uint64_t)v31, v30);
    uint64_t v33 = *((void *)v19 - 1);
    uint64_t v34 = *(uint64_t (**)(char *, uint64_t, const char *))(v33 + 48);
    int v35 = v34(v32, 1, v19);
    (*v74)(v32, v30);
    if (v35 == 1) {
      goto LABEL_6;
    }
    if (v34(v31, 1, v19) == 1)
    {
      unint64_t v53 = 76;
LABEL_14:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Flatten.swift", 19, 2, v53, 0);
    }
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v79, (uint64_t)v80, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v37 = v59;
    (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16))(v19, AssociatedConformanceWitness);
    if ((*(unsigned int (**)(char *, uint64_t))(*((void *)v61 - 1) + 48))(v37, 1) != 1) {
      break;
    }
    (*v57)(v37, v58);
LABEL_6:
    uint64_t v38 = v19;
    uint64_t v39 = v31;
    uint64_t v40 = v8;
    uint64_t v42 = v71;
    uint64_t v41 = v72;
    int v43 = swift_getAssociatedTypeWitness(255, v72, v71, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    uint64_t v44 = swift_getAssociatedConformanceWitness((uint64_t)v41, v42, (uint64_t)v43, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v45 = *(void (**)(uint64_t *, uint64_t))(v44 + 16);
    uint64_t v46 = swift_checkMetadataState(0, (uint64_t)v43);
    uint64_t v47 = v70;
    v45(v46, v44);
    uint64_t v48 = (uint64_t)v80;
    uint64_t v49 = *(unsigned int (**)(char *, uint64_t, const char *))(*((void *)v80 - 1) + 48);
    if (v49(v47, 1, v80) == 1)
    {
      (*v68)(v47, v40);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)v61 - 1) + 56))(v56, 1, 1);
    }
    uint64_t v50 = v67;
    int v8 = v40;
    (*v66)(v67, v47, v40);
    if (v49(v50, 1, (const char *)v48) == 1)
    {
      unint64_t v53 = 85;
      goto LABEL_14;
    }
    uint64_t v51 = v65;
    ((void (*)(uint64_t))v79[4])(v48);
    (*v68)(v47, v40);
    unint64_t v19 = v38;
    (*(void (**)(char *, void, uint64_t, const char *))(v33 + 56))(v51, 0, 1, v38);
    uint64_t v30 = i;
    uint64_t v31 = v39;
  }
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v55 + 32))(v56, v37, v58);
}

uint64_t FlattenSequence.makeIterator()@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1[2];
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *))(v6 + 32))((char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v7 = a1[3];
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v4, v7);
  int v8 = (int **)a1[4];
  uint64_t v9 = a2 + *((int *)type metadata accessor for FlattenSequence.Iterator(0, v4, v7, (uint64_t)v8) + 11);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = swift_getAssociatedTypeWitness(0, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v11 - 1) + 56))(v9, 1, 1, v11);
}

uint64_t Sequence<>.joined()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32))(a2, v2, a1);
}

uint64_t FlattenSequence<>.Index._outer.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index, a2);
}

uint64_t FlattenSequence<>.Index._inner.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 44);
  uint64_t v5 = *(int ***)(a1 + 32);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(*(void *)(a1 + 24) + 8), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v7 = swift_getAssociatedTypeWitness(255, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)v7, v8, v9);
  uint64_t v11 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v10 - 1) + 2);

  return v11(a2, v4, v10);
}

uint64_t FlattenSequence<>.Index.init(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a6, a1, AssociatedTypeWitness);
  uint64_t v13 = a6 + *((int *)type metadata accessor for FlattenSequence<>.Index(0, a3, a4, (uint64_t)a5) + 11);
  Swift::UInt64 v14 = swift_getAssociatedTypeWitness(255, *(int ***)(a4 + 8), a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v15 = swift_getAssociatedTypeWitness(255, a5, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v18 = type metadata accessor for Optional(0, (uint64_t)v15, v16, v17);
  unint64_t v19 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v18 - 1) + 4);

  return v19(v13, a2, v18);
}

uint64_t static FlattenSequence<>.Index.== infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, int **a5)
{
  uint64_t v7 = a3;
  uint64_t v55 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a4 + 8), a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v51 = *((void *)v9 - 1);
  MEMORY[0x1F4188790](v9);
  uint64_t v45 = (char *)&v44 - v10;
  uint64_t v52 = v11;
  Swift::UInt64 v14 = type metadata accessor for Optional(0, v11, v12, v13);
  uint64_t v54 = (uint64_t)*(v14 - 1);
  MEMORY[0x1F4188790](v14);
  uint64_t v49 = (char *)&v44 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v14, (uint64_t)v14, 0, 0);
  uint64_t v48 = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v50 = (char *)&v44 - v16;
  uint64_t v47 = a5;
  uint64_t v17 = type metadata accessor for FlattenSequence<>.Index(0, v7, a4, (uint64_t)a5);
  uint64_t v18 = (uint64_t)*(v17 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v44 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v44 - v22;
  uint64_t v24 = swift_getAssociatedTypeWitness(0, (int **)a4, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, v7, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v26 = v55;
  LOBYTE(v7) = (*(uint64_t (**)(uint64_t, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(a1, v55, v24);
  uint64_t v27 = *(void (**)(char *, uint64_t, Class *))(v18 + 16);
  v27(v23, a1, v17);
  v27(v21, (uint64_t)v26, v17);
  if ((v7 & 1) == 0)
  {
    uint64_t v37 = *(void (**)(char *, Class *))(v18 + 8);
    v37(v21, v17);
    v37(v23, v17);
LABEL_9:
    char v36 = 0;
    return v36 & 1;
  }
  uint64_t v28 = *((int *)v17 + 11);
  uint64_t v55 = &v21[v28];
  uint64_t v29 = v50;
  uint64_t v30 = &v50[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v31 = *(void (**)(char *, char *, Class *))(v54 + 16);
  v31(v50, &v23[v28], v14);
  uint64_t v32 = *(void (**)(char *, Class *))(v18 + 8);
  v32(v23, v17);
  uint64_t v44 = v30;
  v31(v30, v55, v14);
  v32(v21, v17);
  uint64_t v33 = v51;
  uint64_t v34 = v52;
  int v35 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v51 + 48);
  if (v35(v29, 1, v52) != 1)
  {
    uint64_t v38 = v49;
    v31(v49, v29, v14);
    uint64_t v39 = v44;
    if (v35(v44, 1, v34) != 1)
    {
      uint64_t v41 = v45;
      (*(void (**)(char *, char *, uint64_t))(v33 + 32))(v45, v39, v34);
      uint64_t v42 = swift_getAssociatedConformanceWitness((uint64_t)v47, (uint64_t)AssociatedTypeWitness, v34, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
      char v36 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v42 + 8) + 8))(v38, v41, v34);
      int v43 = *(void (**)(char *, uint64_t))(v33 + 8);
      v43(v41, v34);
      v43(v38, v34);
      (*(void (**)(char *, Class *))(v54 + 8))(v29, v14);
      return v36 & 1;
    }
    (*(void (**)(char *, uint64_t))(v33 + 8))(v38, v34);
    goto LABEL_8;
  }
  if (v35(v44, 1, v34) != 1)
  {
LABEL_8:
    (*(void (**)(char *, uint64_t *))(v48 + 8))(v29, TupleTypeMetadata2);
    goto LABEL_9;
  }
  (*(void (**)(char *, Class *))(v54 + 8))(v29, v14);
  char v36 = 1;
  return v36 & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance FlattenSequence<A><>.Index(uint64_t a1, char *a2, uint64_t a3)
{
  return static FlattenSequence<>.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24), *(int ***)(a3 + 32));
}

BOOL specialized static FlattenSequence<>.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  BOOL v6 = a1 < a4;
  if (a1 != a4) {
    return v6;
  }
  if (a3)
  {
    if (a6) {
      return 0;
    }
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
  }
  if (a6) {
    goto LABEL_10;
  }
  return a2 < a5;
}

BOOL specialized static FlattenSequence<>.Index.< infix(_:_:)(uint64_t a1, unint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6)
{
  if (a1 != a4) {
    return a1 < a4;
  }
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0) {
      return a2 >> 14 < a5 >> 14;
    }
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
  }
  if ((a6 & 1) == 0) {
    goto LABEL_8;
  }
  return 0;
}

uint64_t static FlattenSequence<>.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5)
{
  uint64_t v77 = type metadata accessor for FlattenSequence<>.Index(0, a3, a4, (uint64_t)a5);
  uint64_t v75 = (uint64_t)*(v77 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v77);
  uint64_t v74 = (char *)&v64 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v79 = (char *)&v64 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v78 = (char *)&v64 - v14;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a4 + 8), a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v70 = a5;
  uint64_t v15 = swift_getAssociatedTypeWitness(255, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  char v81 = type metadata accessor for Optional(0, (uint64_t)v15, v16, v17);
  uint64_t v76 = (uint64_t)*(v81 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v81);
  uint64_t v72 = (char *)&v64 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v73 = (char *)&v64 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v64 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v64 - v26;
  uint64_t v80 = (const char *)*((void *)v15 - 1);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  size_t v68 = (char *)&v64 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v28);
  uint64_t v31 = (char *)&v64 - v30;
  uint64_t v32 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v32, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  if (((*(uint64_t (**)(uint64_t, uint64_t, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(a1, a2, v32) & 1) == 0)return (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 16))(a1, a2, v32, AssociatedConformanceWitness) & 1; {
  uint64_t v66 = a1;
  }
  uint64_t v67 = v31;
  uint64_t v71 = a2;
  uint64_t v34 = v77;
  uint64_t v35 = a1 + *((int *)v77 + 11);
  uint64_t v36 = v76;
  uint64_t v38 = (Class *)(v76 + 16);
  uint64_t v37 = *(const char **)(v76 + 16);
  ((void (*)(char *, uint64_t, Class *))v37)(v27, v35, v81);
  uint64_t v39 = (char *)(v80 + 48);
  uint64_t v40 = (int **)*((void *)v80 + 6);
  if (((unsigned int (*)(char *, uint64_t, const char *))v40)(v27, 1, v15) == 1)
  {
    uint64_t v80 = v15;
    size_t v68 = v39;
    uint64_t AssociatedTypeWitness = v37;
    uint64_t v70 = v40;
    uint64_t v41 = *(char **)(v36 + 8);
    uint64_t v76 = (v36 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    uint64_t v42 = v27;
  }
  else
  {
    uint64_t v65 = (void (*)(void (*)(void, void), char *, const char *))*((void *)v80 + 4);
    v65((void (*)(void, void))v67, v27, v15);
    ((void (*)(char *, uint64_t, Class *))v37)(v24, v71 + *((int *)v34 + 11), v81);
    if (((unsigned int (*)(char *, uint64_t, const char *))v40)(v24, 1, v15) != 1)
    {
      uint64_t v60 = v68;
      v65((void (*)(void, void))v68, v24, v15);
      uint64_t v61 = swift_getAssociatedConformanceWitness((uint64_t)v70, (uint64_t)AssociatedTypeWitness, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
      uint64_t v62 = v67;
      char v59 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v61 + 16))(v67, v60, v15, v61);
      uint64_t v63 = (void (*)(char *, const char *))*((void *)v80 + 1);
      v63(v60, v15);
      v63(v62, v15);
      return v59 & 1;
    }
    size_t v68 = v39;
    uint64_t AssociatedTypeWitness = v37;
    uint64_t v70 = v40;
    uint64_t v44 = (void (*)(char *, const char *))*((void *)v80 + 1);
    uint64_t v80 = v15;
    v44(v67, v15);
    uint64_t v41 = *(char **)(v36 + 8);
    uint64_t v76 = (v36 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    uint64_t v42 = v24;
  }
  uint64_t v67 = v41;
  ((void (*)(char *, Class *))v41)(v42, v81);
  uint64_t v45 = v75;
  uint64_t v46 = *(void (**)(char *, uint64_t, Class *))(v75 + 16);
  uint64_t v47 = v78;
  v46(v78, v66, v34);
  uint64_t v48 = v79;
  v46(v79, v71, v34);
  uint64_t v49 = v73;
  uint64_t v50 = v81;
  uint64_t v51 = AssociatedTypeWitness;
  ((void (*)(char *, char *, Class *))AssociatedTypeWitness)(v73, &v47[*((int *)v34 + 11)], v81);
  uint64_t v77 = v38;
  LODWORD(v47) = ((uint64_t (*)(char *, uint64_t, const char *))v70)(v49, 1, v80);
  uint64_t v52 = v50;
  unint64_t v53 = (void (*)(char *, Class *))v67;
  ((void (*)(char *, Class *))v67)(v49, v52);
  uint64_t v54 = v74;
  v46(v74, (uint64_t)v48, v34);
  if (v47 != 1)
  {
    (*(void (**)(char *, Class *))(v45 + 8))(v54, v34);
LABEL_14:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
  }
  uint64_t v55 = v72;
  uint64_t v56 = v81;
  ((void (*)(char *, char *, Class *))v51)(v72, &v54[*((int *)v34 + 11)], v81);
  uint64_t v57 = *(void (**)(char *, Class *))(v45 + 8);
  v57(v54, v34);
  int v58 = ((uint64_t (*)(char *, uint64_t, const char *))v70)(v55, 1, v80);
  v53(v55, v56);
  if (v58 != 1) {
    goto LABEL_14;
  }
  v57(v79, v34);
  v57(v78, v34);
  char v59 = 0;
  return v59 & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance FlattenSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static FlattenSequence<>.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24), *(int ***)(a3 + 32));
}

void FlattenSequence<>.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = a1;
  uint64_t v25 = a4;
  BOOL v6 = *(int ***)(a2 + 32);
  uint64_t v27 = *(int ***)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v27[1], v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v26 = *((void *)v9 - 1);
  MEMORY[0x1F4188790](v9);
  uint64_t v24 = (char *)&v24 - v10;
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)v9, v11, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v24 - v15;
  uint64_t v17 = *(void (**)(uint64_t, const char *, uint64_t))(a3 + 24);
  uint64_t v18 = v28;
  uint64_t v19 = swift_getAssociatedTypeWitness(0, v27, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v20 = v29;
  v17(v18, v19, a3);
  uint64_t v21 = v13;
  uint64_t v22 = v26;
  (*(void (**)(char *, uint64_t, Class *))(v14 + 16))(v16, v20 + *(int *)(a2 + 44), v21);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v22 + 48))(v16, 1, v9) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    uint64_t v23 = v24;
    (*(void (**)(char *, char *, const char *))(v22 + 32))(v24, v16, v9);
    Hasher._combine(_:)(1u);
    (*(void (**)(uint64_t, const char *))(v25 + 24))(v18, v9);
    (*(void (**)(char *, const char *))(v22 + 8))(v23, v9);
  }
}

Swift::Int FlattenSequence<>.Index<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = a3;
  uint64_t v5 = *(int ***)(a1 + 32);
  uint64_t v25 = *(int ***)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v25[1], v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = swift_getAssociatedTypeWitness(0, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v24 = *((void *)v8 - 1);
  MEMORY[0x1F4188790](v8);
  uint64_t v22 = (char *)&v22 - v9;
  uint64_t v12 = type metadata accessor for Optional(0, (uint64_t)v8, v10, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v22 - v14;
  v27[0] = 0;
  v27[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  void v27[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  uint64_t v27[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v27[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v16 = *(void (**)(void *, const char *, uint64_t))(a2 + 24);
  uint64_t v17 = swift_getAssociatedTypeWitness(0, v25, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v18 = v26;
  v16(v27, v17, a2);
  (*(void (**)(char *, uint64_t, Class *))(v13 + 16))(v15, v18 + *(int *)(a1 + 44), v12);
  uint64_t v19 = v24;
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v24 + 48))(v15, 1, v8) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    uint64_t v20 = v22;
    (*(void (**)(char *, char *, const char *))(v19 + 32))(v22, v15, v8);
    Hasher._combine(_:)(1u);
    (*(void (**)(void *, const char *))(v23 + 24))(v27, v8);
    (*(void (**)(char *, const char *))(v19 + 8))(v20, v8);
  }
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> FlattenSequence<A><>.Index(uint64_t a1, uint64_t a2)
{
  return FlattenSequence<>.Index<>.hashValue.getter(a1, *(void *)(a2 - 8), *(void *)(a2 - 16));
}

void protocol witness for Hashable.hash(into:) in conformance <> FlattenSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t, uint64_t))FlattenSequence<>.Index<>.hash(into:));
}

uint64_t specialized FlattenSequence<>.startIndex.getter(uint64_t a1, unint64_t a2, void (*a3)(void *__return_ptr, Swift::UInt32 *))
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v6 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v6)
  {
    uint64_t v7 = 15;
    v8._Swift::UInt64 rawBits = 15;
    specialized LazyMapSequence<>.subscript.getter(v8, a1, a2, a3);
  }
  else if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0)
  {
    return 11;
  }
  else
  {
    return 7;
  }
  return v7;
}

Swift::UInt64 specialized FlattenSequence<>.startIndex.getter(uint64_t a1, unint64_t a2, void (*a3)(uint64_t *__return_ptr, void *), atomic_ullong *a4)
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  BOOL v17 = (a1 & 0x800000000000000) == 0;
  v18._Swift::UInt64 rawBits = 15;
  if (v5)
  {
    Swift::UInt64 rawBits = 15;
    while (1)
    {
      v10._Swift::UInt64 rawBits = rawBits;
      uint64_t v11 = specialized LazyMapSequence<>.subscript.getter(v10, a1, a2, a3);
      unint64_t v13 = v12;
      swift_bridgeObjectRelease(v12);
      uint64_t v14 = HIBYTE(v13) & 0xF;
      if ((v13 & 0x2000000000000000) == 0) {
        uint64_t v14 = v11 & 0xFFFFFFFFFFFFLL;
      }
      if (v14) {
        break;
      }
      swift_bridgeObjectRetain(a2);
      swift_retain(a4);
      specialized LazyMapSequence<>.formIndex(after:)(&v18, a1, a2);
      swift_release((uint64_t)a4);
      swift_bridgeObjectRelease(a2);
      Swift::UInt64 rawBits = v18._rawBits;
      if (4 * v5 == v18._rawBits >> 14) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    uint64_t v15 = 7;
    if (((a2 >> 60) & v17) != 0) {
      uint64_t v15 = 11;
    }
    return (v5 << 16) | v15;
  }
  return rawBits;
}

Swift::UInt64 specialized FlattenSequence<>.startIndex.getter()
{
  long long v1 = v0[2];
  long long v13 = v0[1];
  long long v14 = v1;
  long long v12 = *v0;
  v15[0] = v12;
  v15[1] = v13;
  uint64_t v2 = (atomic_ullong *)*((void *)&v1 + 1);
  uint64_t v3 = *((void *)&v12 + 1);
  Swift::UInt64 v4 = v12;
  Swift::UInt64 v11 = v12;
  uint64_t v5 = *((void *)&v12 + 1) >> 14;
  if (*((void *)&v12 + 1) >> 14 != (unint64_t)v12 >> 14)
  {
    while (1)
    {
      uint64_t v6 = specialized LazyMapSequence<>.subscript.getter(v4);
      unint64_t v8 = v7;
      swift_bridgeObjectRelease(v7);
      uint64_t v9 = HIBYTE(v8) & 0xF;
      if ((v8 & 0x2000000000000000) == 0) {
        uint64_t v9 = v6 & 0xFFFFFFFFFFFFLL;
      }
      if (v9) {
        break;
      }
      outlined retain of Substring((uint64_t)v15);
      swift_retain(v2);
      specialized LazyMapSequence<>.formIndex(after:)(&v11);
      outlined release of Substring((uint64_t)v15);
      swift_release((uint64_t)v2);
      Swift::UInt64 v4 = v11;
      if (v5 == v11 >> 14) {
        return v3;
      }
    }
    return v4;
  }
  return v3;
}

uint64_t FlattenSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int **a3@<X2>, char *a4@<X8>)
{
  int v58 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v53 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v67 = (char *)&v49 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(v9 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v70 = a3;
  uint64_t v57 = swift_getAssociatedTypeWitness(255, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v52 = type metadata accessor for Optional(0, (uint64_t)v57, v11, v12);
  uint64_t v51 = (uint64_t)*(v52 - 1);
  MEMORY[0x1F4188790](v52);
  uint64_t v50 = (char *)&v49 - v13;
  long long v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v63 = *(v14 - 1);
  MEMORY[0x1F4188790](v14);
  uint64_t v16 = (char *)&v49 - v15;
  BOOL v17 = swift_getAssociatedTypeWitness(0, (int **)a2, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v56 = *((void *)v17 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v17);
  uint64_t v49 = (char *)&v49 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v49 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, char *, const char *))((char *)&v49 - v23);
  uint64_t v25 = *(void (**)(uint64_t, uint64_t))(a2 + 72);
  uint64_t v55 = a2 + 72;
  uint64_t v54 = v25;
  v25(v7, a2);
  uint64_t v26 = v4;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(v7, a2);
  uint64_t v71 = a2;
  uint64_t v27 = *(void *)(swift_getAssociatedConformanceWitness(a2, v7, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  long long v28 = *(uint64_t (**)(void, void))(v27 + 8);
  size_t v68 = v24;
  uint64_t v69 = v17;
  uint64_t v65 = v27 + 8;
  uint64_t v66 = v27;
  uint64_t v64 = (uint64_t (*)(char *, void (*)(char *, char *, const char *)))v28;
  if (((uint64_t (*)(char *, void, const char *))v28)(v22, v24, v17))
  {
LABEL_5:
    uint64_t v36 = *(void (**)(char *, const char *))(v56 + 8);
    uint64_t v37 = v69;
    v36(v22, v69);
    v36((char *)v68, v37);
    uint64_t v38 = v58;
    uint64_t v39 = v71;
    v54(v7, v71);
    uint64_t v40 = type metadata accessor for FlattenSequence<>.Index(0, v7, v39, (uint64_t)v70);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*((void *)v57 - 1) + 56))(&v38[*((int *)v40 + 11)], 1, 1);
  }
  else
  {
    long long v29 = *(uint64_t (**)(unsigned char *, char *, uint64_t, uint64_t))(v71 + 80);
    uint64_t v60 = v70[13];
    uint64_t v61 = v70 + 13;
    uint64_t v62 = v29;
    uint64_t v30 = (void (**)(char *))(v63 + 16);
    uint64_t v31 = (void (**)(char *, uint64_t *))(v63 + 8);
    uint64_t v32 = (void (**)(char *, uint64_t, uint64_t))(v53 + 16);
    uint64_t v63 = v71 + 80;
    uint64_t v59 = v71 + 192;
    uint64_t v33 = (void (**)(char *, uint64_t))(v53 + 8);
    while (1)
    {
      uint64_t v34 = (void (*)(unsigned char *, void))v62(v72, v22, v7, v71);
      (*v30)(v16);
      v34(v72, 0);
      if ((((uint64_t (*)(uint64_t *, int **))v60)(v14, v70) & 1) == 0) {
        break;
      }
      (*v31)(v16, v14);
      uint64_t v35 = v67;
      (*v32)(v67, v26, v7);
      (*(void (**)(char *, uint64_t))(v71 + 192))(v22, v7);
      (*v33)(v35, v7);
      if (v64(v22, v68)) {
        goto LABEL_5;
      }
    }
    uint64_t v42 = v56;
    int v43 = v69;
    (*(void (**)(void (*)(char *, char *, const char *), const char *))(v56 + 8))(v68, v69);
    size_t v68 = *(void (**)(char *, char *, const char *))(v42 + 32);
    uint64_t v44 = v49;
    v68(v49, v22, v43);
    uint64_t v45 = (uint64_t)v70;
    uint64_t v46 = v50;
    ((void (*)(uint64_t *, int **))v70[8])(v14, v70);
    (*v31)(v16, v14);
    (*(void (**)(char *, void, uint64_t))(*((void *)v57 - 1) + 56))(v46, 0, 1);
    uint64_t v47 = v58;
    v68(v58, v44, v43);
    uint64_t v48 = type metadata accessor for FlattenSequence<>.Index(0, v7, v71, v45);
    return (*(uint64_t (**)(char *, char *, Class *))(v51 + 32))(&v47[*((int *)v48 + 11)], v46, v52);
  }
}

uint64_t FlattenSequence<>.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(a2 + 72))(v7);
  uint64_t v8 = a4 + *((int *)type metadata accessor for FlattenSequence<>.Index(0, v7, a2, (uint64_t)a3) + 11);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a2 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  Swift::String::Index v10 = swift_getAssociatedTypeWitness(0, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v10 - 1) + 56);

  return v11(v8, 1, 1, v10);
}

uint64_t FlattenSequence<>._index(after:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v113 = a1;
  uint64_t v114 = a4;
  uint64_t v105 = a5;
  uint64_t v89 = a2;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v103 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v92 = (char *)v80 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v108 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v99 = (char *)v80 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v100 = (char *)v80 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v91 = (char *)v80 - v15;
  uint64_t v16 = swift_getAssociatedTypeWitness(255, *(int ***)(a3 + 8), v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  BOOL v17 = swift_getAssociatedTypeWitness(255, a4, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v107 = type metadata accessor for Optional(0, (uint64_t)v17, v18, v19);
  uint64_t v20 = (uint64_t)*(v107 - 1);
  uint64_t v21 = MEMORY[0x1F4188790](v107);
  uint64_t v88 = (char *)v80 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)v80 - v24;
  uint64_t v109 = *((void *)v17 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v106 = (char *)v80 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v112 = (char *)v80 - v28;
  long long v29 = swift_checkMetadataState(0, (uint64_t)v16);
  uint64_t v30 = *(v29 - 1);
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v98 = (char *)v80 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v31);
  uint64_t v34 = (char *)v80 - v33;
  uint64_t v35 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a3 + 80);
  uint64_t v36 = v113;
  uint64_t v101 = v5;
  uint64_t v97 = a3 + 80;
  uint64_t v96 = v35;
  uint64_t v37 = (void (*)(char *, void))v35(v115, v113, v8, a3);
  uint64_t v110 = v30;
  uint64_t v38 = *(void (**)(char *))(v30 + 16);
  uint64_t v95 = v30 + 16;
  uint64_t v94 = v38;
  v38(v34);
  v37(v115, 0);
  uint64_t v93 = v8;
  uint64_t v102 = a3;
  uint64_t v39 = a3;
  uint64_t v40 = v109;
  unint64_t v104 = type metadata accessor for FlattenSequence<>.Index(0, v8, v39, (uint64_t)v114);
  (*(void (**)(char *, char *, Class *))(v20 + 16))(v25, &v36[*((int *)v104 + 11)], v107);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v40 + 48))(v25, 1, v17) == 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Flatten.swift", 19, 2, 0xFCuLL, 0);
  }
  uint64_t v41 = v114;
  uint64_t v42 = v112;
  ((void (*)(char *, uint64_t *, int **))v114[23])(v25, v29, v114);
  int v43 = *(void (**)(char *, const char *))(v40 + 8);
  v43(v25, v17);
  uint64_t v44 = v106;
  ((void (*)(uint64_t *, int **))v41[9])(v29, v41);
  uint64_t v45 = v34;
  uint64_t v46 = v110 + 8;
  uint64_t v107 = *(Class **)(v110 + 8);
  ((void (*)(char *, uint64_t *))v107)(v45, v29);
  uint64_t v90 = associated conformance descriptor for Collection.Collection.Index: Comparable;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v41, (uint64_t)v29, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v48 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v42, v44, v17);
  v43(v44, v17);
  uint64_t v49 = v17;
  if (v48)
  {
    uint64_t v110 = v46;
    char v81 = v29;
    v43(v112, v17);
    uint64_t v53 = v103;
    uint64_t v54 = *(char **)(v103 + 16);
    uint64_t v55 = v92;
    uint64_t v56 = v93;
    uint64_t v112 = (char *)(v103 + 16);
    uint64_t v106 = v54;
    ((void (*)(char *, uint64_t, uint64_t))v54)(v92, v101, v93);
    uint64_t v57 = v108;
    int v58 = *(void (**)(char *, char *, const char *))(v108 + 16);
    uint64_t v59 = v100;
    uint64_t v60 = (uint64_t)AssociatedTypeWitness;
    uint64_t v87 = v108 + 16;
    uint64_t v86 = v58;
    v58(v100, v113, AssociatedTypeWitness);
    uint64_t v61 = v102;
    uint64_t v62 = v91;
    (*(void (**)(char *, uint64_t, uint64_t))(v102 + 184))(v59, v56, v102);
    uint64_t v63 = v56;
    uint64_t v64 = *(Class **)(v57 + 8);
    uint64_t v113 = (char *)(v57 + 8);
    unint64_t v104 = v64;
    ((void (*)(char *, uint64_t))v64)(v59, v60);
    uint64_t v65 = *(void (**)(char *, uint64_t))(v53 + 8);
    uint64_t v103 = v53 + 8;
    v65(v55, v56);
    uint64_t v84 = *(void (**)(uint64_t, uint64_t))(v61 + 72);
    uint64_t v85 = v61 + 72;
    uint64_t v90 = *(_DWORD **)(swift_getAssociatedConformanceWitness(v61, v56, v60, (uint64_t)&protocol requirements base descriptor for Collection, v90)+ 8);
    uint64_t v82 = (uint64_t (*)(char *, char *, const char *, _DWORD *))*((void *)v90 + 1);
    unint64_t v83 = v90 + 2;
    v80[2] = v114 + 13;
    v80[1] = v61 + 192;
    while (1)
    {
      uint64_t v66 = v100;
      uint64_t v67 = AssociatedTypeWitness;
      v86(v100, v62, AssociatedTypeWitness);
      ((void (*)(char *, uint64_t, uint64_t))v106)(v55, v101, v63);
      size_t v68 = v62;
      uint64_t v69 = v99;
      uint64_t v70 = v63;
      v84(v63, v102);
      uint64_t v71 = v65;
      v65(v55, v63);
      char v72 = v82(v66, v69, v67, v90);
      uint64_t v73 = v104;
      ((void (*)(char *, const char *))v104)(v69, v67);
      ((void (*)(char *, const char *))v73)(v66, v67);
      if (v72)
      {
        ((void (*)(char *, const char *))v104)(v68, AssociatedTypeWitness);
        return FlattenSequence<>.endIndex.getter(v89, v102, v114, v105);
      }
      ((void (*)(char *, uint64_t, uint64_t))v106)(v55, v101, v70);
      uint64_t v74 = (void (*)(char *, void))v96(v115, v68, v70, v102);
      uint64_t v75 = v98;
      uint64_t v76 = v81;
      v94(v98);
      v74(v115, 0);
      uint64_t v65 = v71;
      v71(v55, v70);
      uint64_t v62 = v68;
      if ((((uint64_t (*)(uint64_t *))v114[13])(v76) & 1) == 0) {
        break;
      }
      ((void (*)(char *, uint64_t *))v107)(v75, v76);
      ((void (*)(char *, uint64_t, uint64_t))v106)(v55, v101, v70);
      (*(void (**)(char *, uint64_t))(v102 + 192))(v68, v70);
      v71(v55, v70);
      uint64_t v63 = v70;
    }
    uint64_t v77 = (uint64_t)v100;
    (*(void (**)(char *, char *, const char *))(v108 + 32))(v100, v68, AssociatedTypeWitness);
    uint64_t v78 = v114;
    uint64_t v79 = (uint64_t)v88;
    ((void (*)(uint64_t *, int **))v114[8])(v76, v114);
    ((void (*)(char *, uint64_t *))v107)(v75, v76);
    (*(void (**)(uint64_t, void, uint64_t, const char *))(v109 + 56))(v79, 0, 1, v49);
    return FlattenSequence<>.Index.init(_:_:)(v77, v79, v70, v102, v78, v105);
  }
  else
  {
    uint64_t v50 = v105;
    (*(void (**)(uint64_t, char *, const char *))(v108 + 16))(v105, v113, AssociatedTypeWitness);
    uint64_t v51 = v50 + *((int *)v104 + 11);
    (*(void (**)(uint64_t, char *, const char *))(v40 + 32))(v51, v112, v17);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v40 + 56))(v51, 0, 1, v17);
  }
}

uint64_t FlattenSequence<>._index(before:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, char *a5@<X8>)
{
  uint64_t v112 = a1;
  uint64_t v80 = a5;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v84 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v95 = (char *)&v78 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(v9 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = (uint64_t)a4;
  uint64_t v12 = swift_getAssociatedTypeWitness(255, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  unint64_t v83 = type metadata accessor for Optional(0, (uint64_t)v12, v13, v14);
  uint64_t v82 = (uint64_t)*(v83 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v83);
  uint64_t v79 = (char *)&v78 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v103 = (char *)&v78 - v18;
  uint64_t v118 = v12;
  uint64_t v81 = *((void *)v12 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v106 = (char *)&v78 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v107 = (char *)&v78 - v21;
  unint64_t v115 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  unint64_t v104 = (void (**)(void, void, void))*(v115 - 1);
  uint64_t v110 = v104;
  MEMORY[0x1F4188790](v115);
  uint64_t v116 = (char *)&v78 - v22;
  uint64_t v23 = swift_getAssociatedTypeWitness(0, (int **)a3, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v24 = *((void *)v23 - 1);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v78 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v30 = (char *)&v78 - v29;
  MEMORY[0x1F4188790](v28);
  uint64_t v32 = (char *)&v78 - v31;
  uint64_t v33 = *(void (**)(char *, char *, const char *))(v24 + 16);
  v33((char *)&v78 - v31, v112, v23);
  uint64_t v93 = v24 + 16;
  unint64_t v92 = v33;
  v33(v30, v32, v23);
  uint64_t v34 = v7;
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v7, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, v7, (uint64_t)v23, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v7) = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                       + 8))(v30, v27, v23);
  uint64_t v111 = v24;
  uint64_t v36 = v24 + 8;
  uint64_t v37 = *(void (**)(char *, const char *))(v24 + 8);
  uint64_t v94 = v27;
  v37(v27, v23);
  uint64_t v108 = v30;
  uint64_t v109 = v23;
  uint64_t v113 = v37;
  uint64_t v114 = v36;
  v37(v30, v23);
  if (v7)
  {
    uint64_t v38 = v108;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(a3 + 136))(v32, -1, v34, a3);
    uint64_t v39 = v109;
    v113(v32, v109);
    (*(void (**)(char *, char *, const char *))(v111 + 32))(v32, v38, v39);
  }
  uint64_t v40 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a3 + 80);
  uint64_t v105 = v32;
  uint64_t v90 = a3 + 80;
  uint64_t v89 = v40;
  uint64_t v41 = (void (*)(char *, void))v40(v119, v32, v34, a3);
  uint64_t v42 = (void (*)(char *))v110[2];
  uint64_t v43 = (uint64_t)v115;
  v110 += 2;
  uint64_t v88 = v42;
  v42(v116);
  v41(v119, 0);
  uint64_t v78 = type metadata accessor for FlattenSequence<>.Index(0, v34, a3, v11);
  uint64_t v44 = v82;
  uint64_t v45 = v103;
  uint64_t v46 = v83;
  (*(void (**)(char *, char *, Class *))(v82 + 16))(v103, &v112[*((int *)v78 + 11)], v83);
  uint64_t v47 = v81;
  int v48 = (*(uint64_t (**)(char *, uint64_t, const char *))(v81 + 48))(v45, 1, v118);
  uint64_t v96 = v34;
  uint64_t v49 = v107;
  if (v48 == 1)
  {
    (*(void (**)(uint64_t, uint64_t))(v11 + 72))(v43, v11);
    (*(void (**)(char *, Class *))(v44 + 8))(v45, v46);
  }
  else
  {
    (*(void (**)(char *, char *, const char *))(v47 + 32))(v107, v45, v118);
  }
  uint64_t v101 = *(void (**)(uint64_t, uint64_t))(v11 + 64);
  uint64_t v102 = v11 + 64;
  uint64_t v100 = *(void *)(swift_getAssociatedConformanceWitness(v11, v43, (uint64_t)v118, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  uint64_t v98 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(v100 + 8);
  uint64_t v99 = v100 + 8;
  uint64_t v50 = (void (**)(char *, uint64_t))(v47 + 8);
  uint64_t v103 = (char *)(v104 + 1);
  uint64_t v86 = (uint64_t *)(v84 + 16);
  unint64_t v104 = (void (**)(void, void, void))(v111 + 32);
  uint64_t v97 = a3;
  uint64_t v85 = a3 + 136;
  uint64_t v112 = (char *)(v84 + 8);
  uint64_t v84 = v11 + 72;
  uint64_t v51 = v116;
  uint64_t v91 = v11;
  uint64_t v87 = (void (**)(char *, uint64_t))(v47 + 8);
  uint64_t v52 = (void (**)(char *, char *, const char *))(v111 + 32);
  while (1)
  {
    uint64_t v53 = v106;
    v101(v43, v11);
    uint64_t v54 = (uint64_t)v118;
    char v55 = v98(v49, v53, v118, v100);
    uint64_t v56 = *v50;
    (*v50)(v53, v54);
    if ((v55 & 1) == 0) {
      break;
    }
    v56(v49, (uint64_t)v118);
    (*(void (**)(char *, uint64_t))v103)(v51, v43);
    uint64_t v111 = *v86;
    uint64_t v57 = v95;
    uint64_t v58 = v96;
    ((void (*)(char *, void, uint64_t))v111)(v95, v117, v96);
    uint64_t v59 = *v52;
    uint64_t v60 = v94;
    uint64_t v61 = v105;
    uint64_t v62 = v109;
    (*v52)(v94, v105, v109);
    uint64_t v63 = v97;
    uint64_t v64 = v108;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v97 + 136))(v60, -1, v58, v97);
    v113(v60, v62);
    uint64_t v65 = *(void (**)(char *, uint64_t))v112;
    (*(void (**)(char *, uint64_t))v112)(v57, v58);
    v59(v61, v64, v62);
    uint64_t v66 = v91;
    ((void (*)(char *, void, uint64_t))v111)(v57, v117, v58);
    uint64_t v49 = v107;
    v92(v64, v61, v62);
    uint64_t v67 = (void (*)(char *, void))v89(v119, v64, v58, v63);
    v88(v116);
    v67(v119, 0);
    size_t v68 = v62;
    uint64_t v51 = v116;
    v113(v64, v68);
    uint64_t v69 = v58;
    uint64_t v43 = (uint64_t)v115;
    v65(v57, v69);
    uint64_t v70 = *(void (**)(uint64_t, uint64_t))(v66 + 72);
    uint64_t v11 = v66;
    uint64_t v71 = v66;
    uint64_t v50 = v87;
    v70(v43, v71);
  }
  unint64_t v117 = (void (*)(char *, char *, const char *))*v104;
  uint64_t v73 = v108;
  char v72 = v109;
  v117(v108, v105, v109);
  uint64_t v74 = v79;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 136))(v49, -1, v43, v11);
  uint64_t v75 = (uint64_t)v118;
  v56(v49, (uint64_t)v118);
  (*(void (**)(char *, uint64_t))v103)(v51, v43);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v81 + 56))(v74, 0, 1, v75);
  uint64_t v76 = v80;
  v117(v80, v73, v72);
  return (*(uint64_t (**)(char *, char *, Class *))(v82 + 32))(&v76[*((int *)v78 + 11)], v74, v83);
}

uint64_t FlattenSequence<>.formIndex(after:)(char *a1, uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t v8 = type metadata accessor for FlattenSequence<>.Index(0, *(void *)(a2 + 16), a3, (uint64_t)a4);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  MEMORY[0x1F4188790](v8);
  uint64_t v11 = (char *)&v13 - v10;
  FlattenSequence<>._index(after:)(a1, a2, a3, a4, (uint64_t)&v13 - v10);
  (*(void (**)(char *, Class *))(v9 + 8))(a1, v8);
  return (*(uint64_t (**)(char *, char *, Class *))(v9 + 32))(a1, v11, v8);
}

unint64_t specialized FlattenSequence<>.distance(from:to:)(unint64_t a1, int64_t a2, char a3, Swift::UInt64 a4, int64_t a5, char a6, uint64_t a7, unint64_t a8, void (*a9)(void *__return_ptr, Swift::UInt32 *), atomic_ullong *a10)
{
  Swift::UInt64 rawBits = a4;
  unint64_t v13 = a2;
  unint64_t v14 = a1;
  int v15 = a3 & 1;
  char v16 = a3 & 1;
  Swift::UInt64 v17 = a4 >> 14;
  unint64_t v18 = a1 >> 14;
  if (a4 >> 14 != a1 >> 14)
  {
    int v63 = a6 & 1;
    if (a4 >> 14 >= a1 >> 14) {
      goto LABEL_16;
    }
    goto LABEL_9;
  }
  if (a6)
  {
    if ((a3 & 1) == 0) {
LABEL_54:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
    return 0;
  }
  int v63 = 0;
  if (a3) {
    goto LABEL_54;
  }
  if (a5 < a2)
  {
LABEL_9:
    uint64_t v19 = HIBYTE(a8) & 0xF;
    if ((a8 & 0x2000000000000000) == 0) {
      uint64_t v19 = a7;
    }
    uint64_t v20 = 7;
    if (((a8 >> 60) & ((a7 & 0x800000000000000) == 0)) != 0) {
      uint64_t v20 = 11;
    }
    Swift::UInt64 v22 = v20 | (v19 << 16);
    char v61 = a3 & 1;
    swift_bridgeObjectRetain(a8);
    swift_retain(a10);
    v23._Swift::UInt64 rawBits = v22;
    Swift::UInt64 rawBits = a4;
    unint64_t v14 = a1;
    v24._Swift::UInt64 rawBits = 15;
    specialized Collection.count.getter(v23, v24, a7, a8);
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    char v16 = v61;
    if (v17 == v18) {
      goto LABEL_14;
    }
LABEL_16:
    char v26 = v16;
    char v27 = v63;
    uint64_t v58 = v13;
    Swift::UInt64 v59 = rawBits;
    char v62 = v16;
    if (specialized static Comparable.<= infix(_:_:)(v14, v13, v16, rawBits, a5, v63))
    {
      char v28 = specialized static Comparable.<= infix(_:_:)(v14, v13, v26, rawBits, a5, v63);
      unint64_t v29 = a5;
      char v30 = v63;
      Swift::UInt64 v31 = rawBits;
      unint64_t v32 = v14;
      Swift::UInt64 rawBits = v14;
      char v27 = v15;
      if ((v28 & 1) == 0) {
        goto LABEL_18;
      }
    }
    else
    {
      char v33 = specialized static Comparable.<= infix(_:_:)(rawBits, a5, v63, v14, v13, v26);
      unint64_t v29 = v13;
      char v30 = v15;
      unint64_t v32 = v14;
      Swift::UInt64 v31 = v14;
      unint64_t v13 = a5;
      if ((v33 & 1) == 0) {
LABEL_18:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    char v57 = v30;
    v65._Swift::UInt64 rawBits = rawBits;
    unint64_t v56 = v29;
    if (v27)
    {
      unint64_t v25 = 0;
    }
    else
    {
      Swift::UInt64 v34 = v31;
      swift_bridgeObjectRetain(a8);
      swift_retain(a10);
      v35._Swift::UInt64 rawBits = rawBits;
      unsigned int v36 = specialized LazyMapSequence<>.subscript.getter(v35, a7, a8, a9);
      swift_release((uint64_t)a10);
      swift_bridgeObjectRelease(a8);
      uint64_t v37 = 2;
      uint64_t v38 = 3;
      if (v36 >= 0x10000) {
        uint64_t v38 = 4;
      }
      if (v36 >= 0x800) {
        uint64_t v37 = v38;
      }
      if (v36 <= 0x7F) {
        unint64_t v39 = 1;
      }
      else {
        unint64_t v39 = v37;
      }
      unint64_t v25 = specialized RandomAccessCollection<>.distance(from:to:)(v13, v39, v36);
      swift_bridgeObjectRetain(a8);
      swift_retain(a10);
      specialized LazyMapSequence<>.formIndex(after:)(&v65, a7, a8);
      swift_release((uint64_t)a10);
      swift_bridgeObjectRelease(a8);
      Swift::UInt64 v31 = v34;
      Swift::UInt64 rawBits = v65._rawBits;
    }
    Swift::UInt64 v40 = v31 >> 14;
    if (v31 >> 14 > rawBits >> 14)
    {
      while (1)
      {
        swift_bridgeObjectRetain(a8);
        swift_retain(a10);
        v41._Swift::UInt64 rawBits = rawBits;
        unsigned int v42 = specialized LazyMapSequence<>.subscript.getter(v41, a7, a8, a9);
        swift_release((uint64_t)a10);
        swift_bridgeObjectRelease(a8);
        if (v42 < 0x10000) {
          uint64_t v43 = 3;
        }
        else {
          uint64_t v43 = 4;
        }
        if (v42 <= 0x7FF) {
          uint64_t v43 = 2;
        }
        unint64_t v44 = v42 >= 0x80 ? v43 : 1;
        unint64_t v45 = specialized RandomAccessCollection<>.distance(from:to:)(0, v44, v42);
        BOOL v46 = __OFADD__(v25, v45);
        v25 += v45;
        if (v46) {
          break;
        }
        swift_bridgeObjectRetain(a8);
        swift_retain(a10);
        specialized LazyMapSequence<>.formIndex(after:)(&v65, a7, a8);
        swift_release((uint64_t)a10);
        swift_bridgeObjectRelease(a8);
        Swift::UInt64 rawBits = v65._rawBits;
        if (v40 <= v65._rawBits >> 14) {
          goto LABEL_41;
        }
      }
      __break(1u);
      goto LABEL_52;
    }
LABEL_41:
    if (v57)
    {
      uint64_t v47 = a5;
      unint64_t v49 = v59;
      unint64_t v48 = v32;
    }
    else
    {
      swift_bridgeObjectRetain(a8);
      swift_retain(a10);
      v50._Swift::UInt64 rawBits = rawBits;
      unsigned int v51 = specialized LazyMapSequence<>.subscript.getter(v50, a7, a8, a9);
      swift_release((uint64_t)a10);
      swift_bridgeObjectRelease(a8);
      unint64_t v52 = specialized RandomAccessCollection<>.distance(from:to:)(0, v56, v51);
      BOOL v46 = __OFADD__(v25, v52);
      v25 += v52;
      uint64_t v47 = a5;
      unint64_t v48 = v32;
      if (v46)
      {
LABEL_52:
        __break(1u);
        goto LABEL_53;
      }
      unint64_t v49 = v59;
    }
    if (specialized static Comparable.<= infix(_:_:)(v48, v58, v62, v49, v47, v63)) {
      return v25;
    }
    BOOL v46 = __OFSUB__(0, v25);
    unint64_t v25 = -(uint64_t)v25;
    if (!v46) {
      return v25;
    }
LABEL_53:
    __break(1u);
    goto LABEL_54;
  }
LABEL_14:
  if (v15 | v63) {
    return 0;
  }
  v54._Swift::UInt64 rawBits = v14;
  unsigned int v55 = specialized LazyMapSequence<>.subscript.getter(v54, a7, a8, a9);

  return specialized RandomAccessCollection<>.distance(from:to:)(v13, a5, v55);
}

Swift::UInt64 specialized FlattenSequence<>.distance(from:to:)(Swift::UInt64 a1, unint64_t a2, char a3, Swift::UInt64 a4, unint64_t a5, char a6, uint64_t a7, unint64_t a8, void (*a9)(uint64_t *__return_ptr, void *), atomic_ullong *a10)
{
  unint64_t v12 = a5;
  Swift::UInt64 v13 = a4;
  unint64_t v14 = a2;
  Swift::UInt64 v15 = a1;
  v16._char rawBits = a3 & 1;
  int v17 = a3 & 1;
  Swift::UInt64 v18 = a4 >> 14;
  Swift::UInt64 v19 = a1 >> 14;
  if (a4 >> 14 == a1 >> 14)
  {
    if (a6)
    {
      if (!v17) {
LABEL_86:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
      return 0;
    }
    unsigned int v78 = 0;
    if (v17) {
      goto LABEL_86;
    }
    if (a5 >> 14 >= a2 >> 14)
    {
LABEL_14:
      if (!(LODWORD(v16._rawBits) | v78))
      {
        Swift::UInt64 v46 = v12;
        v47._char rawBits = v15;
        v16._char rawBits = specialized LazyMapSequence<>.subscript.getter(v47, a7, a8, a9);
        Swift::UInt64 v34 = v48;
        uint64_t v49 = (v16._rawBits >> 59) & 1;
        if ((v48 & 0x1000000000000000) == 0) {
          LOBYTE(v49) = 1;
        }
        Swift::UInt64 v13 = v14;
        unint64_t v50 = v14 & 0xC;
        unint64_t v14 = 4 << v49;
        if (v50 == 4 << v49) {
          goto LABEL_78;
        }
        goto LABEL_34;
      }
      return 0;
    }
  }
  else
  {
    unsigned int v78 = a6 & 1;
    if (a4 >> 14 >= a1 >> 14) {
      goto LABEL_16;
    }
  }
  uint64_t v20 = HIBYTE(a8) & 0xF;
  if ((a8 & 0x2000000000000000) == 0) {
    uint64_t v20 = a7;
  }
  uint64_t v21 = 7;
  if (((a8 >> 60) & ((a7 & 0x800000000000000) == 0)) != 0) {
    uint64_t v21 = 11;
  }
  Swift::UInt64 v25 = v21 | (v20 << 16);
  char v76 = v17;
  swift_bridgeObjectRetain(a8);
  swift_retain(a10);
  v26._char rawBits = v25;
  unint64_t v12 = a5;
  unint64_t v14 = a2;
  Swift::UInt64 v13 = a4;
  Swift::UInt64 v15 = a1;
  v27._char rawBits = 15;
  specialized LazyMapSequence<>.distance(from:to:)(v26, v27, a7, a8);
  swift_release((uint64_t)a10);
  swift_bridgeObjectRelease(a8);
  LOBYTE(v17) = v76;
  if (v18 == v19) {
    goto LABEL_14;
  }
LABEL_16:
  char v29 = v17;
  unint64_t v75 = v12;
  char v77 = v17;
  if (specialized static Comparable.<= infix(_:_:)(v15, v14, v17, v13, v12, v78))
  {
    char v30 = specialized static Comparable.<= infix(_:_:)(v15, v14, v29, v13, v12, v78);
    to._char rawBits = v12;
    char rawBits = v78;
    Swift::UInt64 v32 = v13;
    Swift::UInt64 v33 = v14;
    Swift::UInt64 v34 = v15;
    if ((v30 & 1) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    char v35 = specialized static Comparable.<= infix(_:_:)(v13, v12, v78, v15, v14, v29);
    to._char rawBits = v14;
    char rawBits = v16._rawBits;
    Swift::UInt64 v32 = v15;
    Swift::UInt64 v33 = v12;
    v16._char rawBits = v78;
    Swift::UInt64 v34 = v13;
    if ((v35 & 1) == 0) {
LABEL_18:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  char v74 = rawBits;
  v79._char rawBits = v34;
  if (v16._rawBits)
  {
    Swift::Int v36 = 0;
    goto LABEL_45;
  }
  Swift::UInt64 v71 = v32;
  swift_bridgeObjectRetain(a8);
  swift_retain(a10);
  v37._char rawBits = v34;
  uint64_t v38 = specialized LazyMapSequence<>.subscript.getter(v37, a7, a8, a9);
  unint64_t v40 = v39;
  swift_release((uint64_t)a10);
  swift_bridgeObjectRelease(a8);
  uint64_t v41 = v38;
  if ((v40 & 0x2000000000000000) != 0) {
    unint64_t v42 = HIBYTE(v40) & 0xF;
  }
  else {
    unint64_t v42 = v38 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v43 = v42 << 16;
  int v44 = (v40 & 0x1000000000000000) == 0 || (v38 & 0x800000000000000) != 0;
  if (v44 == 1)
  {
    v16._char rawBits = v43 | 7;
    if ((v40 & 0x1000000000000000) == 0)
    {
      LOBYTE(v45) = 1;
      goto LABEL_39;
    }
  }
  else
  {
    v16._char rawBits = v43 | 0xB;
  }
  unint64_t v45 = (v41 & 0x800000000000000uLL) >> 59;
LABEL_39:
  if ((v33 & 0xC) == 4 << v45)
  {
    v61._char rawBits = v33;
    unint64_t v62 = v42;
    v63._char rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v61)._rawBits;
    unint64_t v42 = v62;
    Swift::UInt64 v33 = v63._rawBits;
  }
  if ((v16._rawBits & 0xC) == 4 << v44)
  {
    v64._char rawBits = v16._rawBits;
    Swift::UInt64 v65 = v33;
    unint64_t v66 = v42;
    v67._char rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v64)._rawBits;
    unint64_t v42 = v66;
    Swift::UInt64 v33 = v65;
    v16._char rawBits = v67._rawBits;
    if ((v40 & 0x1000000000000000) == 0) {
      goto LABEL_43;
    }
LABEL_68:
    if (v42 < v33 >> 16 || v42 < v16._rawBits >> 16) {
      goto LABEL_85;
    }
    Swift::Int v36 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v33, v16);
    swift_bridgeObjectRelease(v40);
    goto LABEL_44;
  }
  if ((v40 & 0x1000000000000000) != 0) {
    goto LABEL_68;
  }
LABEL_43:
  swift_bridgeObjectRelease(v40);
  Swift::Int v36 = (v16._rawBits >> 16) - (v33 >> 16);
LABEL_44:
  swift_bridgeObjectRetain(a8);
  swift_retain(a10);
  specialized LazyMapSequence<>.formIndex(after:)(&v79, a7, a8);
  swift_release((uint64_t)a10);
  swift_bridgeObjectRelease(a8);
  Swift::UInt64 v34 = v79._rawBits;
  Swift::UInt64 v32 = v71;
LABEL_45:
  Swift::UInt64 v46 = v32 >> 14;
  if (v32 >> 14 <= v34 >> 14) {
    goto LABEL_56;
  }
  while (1)
  {
    swift_bridgeObjectRetain(a8);
    swift_retain(a10);
    v52._char rawBits = v34;
    uint64_t v53 = specialized LazyMapSequence<>.subscript.getter(v52, a7, a8, a9);
    Swift::UInt64 v34 = v54;
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    if ((v34 & 0x1000000000000000) == 0) {
      break;
    }
    v16._char rawBits = String.UTF8View._foreignCount()();
    swift_bridgeObjectRelease(v34);
    BOOL v55 = __OFADD__(v36, v16._rawBits);
    v36 += v16._rawBits;
    if (v55) {
      goto LABEL_55;
    }
LABEL_51:
    swift_bridgeObjectRetain(a8);
    swift_retain(a10);
    specialized LazyMapSequence<>.formIndex(after:)(&v79, a7, a8);
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    Swift::UInt64 v34 = v79._rawBits;
    if (v46 <= v79._rawBits >> 14) {
      goto LABEL_56;
    }
  }
  swift_bridgeObjectRelease(v34);
  if ((v34 & 0x2000000000000000) != 0) {
    v16._char rawBits = HIBYTE(v34) & 0xF;
  }
  else {
    v16._char rawBits = v53 & 0xFFFFFFFFFFFFLL;
  }
  BOOL v55 = __OFADD__(v36, v16._rawBits);
  v36 += v16._rawBits;
  if (!v55) {
    goto LABEL_51;
  }
LABEL_55:
  __break(1u);
LABEL_56:
  if ((v74 & 1) == 0)
  {
    swift_bridgeObjectRetain(a8);
    swift_retain(a10);
    v57._char rawBits = v34;
    unint64_t v58 = specialized LazyMapSequence<>.subscript.getter(v57, a7, a8, a9);
    Swift::UInt64 v34 = v59;
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    uint64_t v60 = (v58 >> 59) & 1;
    if ((v34 & 0x1000000000000000) == 0) {
      LOBYTE(v6_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = 1;
    }
    Swift::UInt64 v46 = to._rawBits;
    if ((to._rawBits & 0xC) == 4 << v60)
    {
      Swift::UInt64 v46 = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
      if ((v34 & 0x1000000000000000) == 0) {
        goto LABEL_62;
      }
    }
    else if ((v34 & 0x1000000000000000) == 0)
    {
LABEL_62:
      swift_bridgeObjectRelease(v34);
      v16._char rawBits = v46 >> 16;
      goto LABEL_63;
    }
    unint64_t v68 = v58 & 0xFFFFFFFFFFFFLL;
    if ((v34 & 0x2000000000000000) != 0) {
      unint64_t v68 = HIBYTE(v34) & 0xF;
    }
    if (v68 < v46 >> 16) {
      goto LABEL_85;
    }
    v16._char rawBits = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15, (Swift::String::Index)v46);
    swift_bridgeObjectRelease(v34);
LABEL_63:
    BOOL v55 = __OFADD__(v36, v16._rawBits);
    v36 += v16._rawBits;
    unint64_t v56 = v75;
    if (!v55) {
      goto LABEL_64;
    }
    __break(1u);
    goto LABEL_77;
  }
  unint64_t v56 = v75;
LABEL_64:
  if (specialized static Comparable.<= infix(_:_:)(v15, v14, v77, v13, v56, v78)) {
    return v36;
  }
  BOOL v55 = __OFSUB__(0, v36);
  Swift::Int v36 = -v36;
  if (!v55) {
    return v36;
  }
LABEL_77:
  __break(1u);
LABEL_78:
  Swift::UInt64 v13 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v13)._rawBits;
LABEL_34:
  if ((v46 & 0xC) == v14)
  {
    Swift::UInt64 v46 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v46)._rawBits;
    Swift::UInt64 v51 = v13;
    if ((v34 & 0x1000000000000000) == 0) {
      goto LABEL_36;
    }
  }
  else
  {
    Swift::UInt64 v51 = v13;
    if ((v34 & 0x1000000000000000) == 0)
    {
LABEL_36:
      swift_bridgeObjectRelease(v34);
      return (v46 >> 16) - (v51 >> 16);
    }
  }
  unint64_t v69 = HIBYTE(v34) & 0xF;
  if ((v34 & 0x2000000000000000) == 0) {
    unint64_t v69 = v16._rawBits & 0xFFFFFFFFFFFFLL;
  }
  if (v69 < v51 >> 16 || v69 < v46 >> 16) {
LABEL_85:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xCFuLL, 0);
  Swift::Int v70 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v13, (Swift::String::Index)v46);
  swift_bridgeObjectRelease(v34);
  return v70;
}

unint64_t specialized FlattenSequence<>.distance(from:to:)(Swift::UInt64 a1, Swift::UInt64 a2, char a3, unint64_t a4, unint64_t a5, char a6)
{
  unint64_t v7 = a5;
  Swift::UInt64 v8 = a2;
  Swift::UInt64 v9 = a1;
  Swift::UInt64 v10 = a3 & 1;
  char v11 = a3 & 1;
  Swift::UInt64 v12 = a6 & 1;
  long long v13 = *(_OWORD *)(v6 + 16);
  long long v71 = *(_OWORD *)v6;
  long long v72 = v13;
  long long v73 = *(_OWORD *)(v6 + 32);
  unint64_t v14 = a4 >> 14;
  Swift::UInt64 v15 = a1 >> 14;
  if (a4 >> 14 == a1 >> 14)
  {
    if (a6)
    {
      if ((a3 & 1) == 0) {
LABEL_83:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
      return 0;
    }
    if (a3) {
      goto LABEL_83;
    }
    if (a5 >> 14 >= a2 >> 14)
    {
LABEL_10:
      if (v10 | v12) {
        return 0;
      }
      Swift::UInt64 v31 = specialized LazyMapSequence<>.subscript.getter(v9);
      unint64_t v6 = v43;
      uint64_t v44 = (v31 >> 59) & 1;
      if ((v43 & 0x1000000000000000) == 0) {
        LOBYTE(v44) = 1;
      }
      Swift::UInt64 v33 = 4 << v44;
      if ((v8 & 0xC) != 4 << v44) {
        goto LABEL_30;
      }
      goto LABEL_75;
    }
  }
  else if (a4 >> 14 >= a1 >> 14)
  {
    goto LABEL_12;
  }
  long long v16 = *(_OWORD *)(v6 + 16);
  v74[0] = *(_OWORD *)v6;
  v74[1] = v16;
  Swift::UInt64 v17 = a6 & 1;
  Swift::UInt64 v19 = *((void *)&v74[0] + 1);
  Swift::UInt64 v18 = *(void *)&v74[0];
  uint64_t v21 = *((void *)&v73 + 1);
  outlined retain of Substring((uint64_t)v74);
  swift_retain(*((atomic_ullong **)&v73 + 1));
  unint64_t v6 = (unint64_t)&v71;
  v22._Swift::UInt64 rawBits = v19;
  Swift::UInt64 v12 = v17;
  v23._Swift::UInt64 rawBits = v18;
  specialized LazyMapSequence<>.distance(from:to:)(v22, v23, v24);
  outlined release of Substring((uint64_t)v74);
  uint64_t v25 = v21;
  unint64_t v7 = a5;
  Swift::UInt64 v8 = a2;
  Swift::UInt64 v9 = a1;
  swift_release(v25);
  if (v14 == v15) {
    goto LABEL_10;
  }
LABEL_12:
  char v68 = v11;
  if (specialized static Comparable.<= infix(_:_:)(v9, v8, v11, a4, v7, v12))
  {
    char v26 = v11;
    unint64_t v27 = a4;
    char v28 = specialized static Comparable.<= infix(_:_:)(v9, v8, v26, a4, v7, v12);
    to._Swift::UInt64 rawBits = v7;
    Swift::UInt64 v29 = v12;
    Swift::UInt64 rawBits = v8;
    Swift::UInt64 v31 = v9;
    if ((v28 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else
  {
    char v32 = specialized static Comparable.<= infix(_:_:)(a4, v7, v12, v9, v8, v11);
    to._Swift::UInt64 rawBits = v8;
    Swift::UInt64 v29 = v10;
    unint64_t v27 = v9;
    Swift::UInt64 rawBits = v7;
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = v12;
    Swift::UInt64 v31 = a4;
    if ((v32 & 1) == 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  Swift::UInt64 v33 = v29;
  unint64_t v66 = v7;
  Swift::UInt64 v70 = v31;
  char v67 = v12;
  if ((v10 & 1) == 0)
  {
    v75[0] = v71;
    v75[1] = v72;
    Swift::UInt64 v34 = (atomic_ullong *)*((void *)&v73 + 1);
    outlined retain of Substring((uint64_t)v75);
    swift_retain(v34);
    uint64_t v35 = specialized LazyMapSequence<>.subscript.getter(v31);
    unint64_t v37 = v36;
    outlined release of Substring((uint64_t)v75);
    swift_release((uint64_t)v34);
    if ((v37 & 0x2000000000000000) != 0) {
      unint64_t v38 = HIBYTE(v37) & 0xF;
    }
    else {
      unint64_t v38 = v35 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v39 = v38 << 16;
    int v40 = (v37 & 0x1000000000000000) == 0 || (v35 & 0x800000000000000) != 0;
    if (v40 == 1)
    {
      v41._Swift::UInt64 rawBits = v39 | 7;
      if ((v37 & 0x1000000000000000) == 0)
      {
        LOBYTE(v42) = 1;
        goto LABEL_35;
      }
    }
    else
    {
      v41._Swift::UInt64 rawBits = v39 | 0xB;
    }
    unint64_t v42 = (v35 & 0x800000000000000uLL) >> 59;
LABEL_35:
    if ((rawBits & 0xC) == 4 << v42)
    {
      v55._Swift::UInt64 rawBits = rawBits;
      unint64_t v56 = v38;
      v57._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v55)._rawBits;
      unint64_t v38 = v56;
      Swift::UInt64 rawBits = v57._rawBits;
    }
    if ((v41._rawBits & 0xC) == 4 << v40)
    {
      v58._Swift::UInt64 rawBits = v41._rawBits;
      unint64_t v59 = v38;
      v60._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v58)._rawBits;
      unint64_t v38 = v59;
      v41._Swift::UInt64 rawBits = v60._rawBits;
      if ((v37 & 0x1000000000000000) == 0) {
        goto LABEL_39;
      }
    }
    else if ((v37 & 0x1000000000000000) == 0)
    {
LABEL_39:
      swift_bridgeObjectRelease(v37);
      unint64_t v7 = (v41._rawBits >> 16) - (rawBits >> 16);
LABEL_40:
      outlined retain of Substring((uint64_t)v75);
      swift_retain(v34);
      unint64_t v6 = (unint64_t)&v71;
      specialized LazyMapSequence<>.formIndex(after:)(&v70);
      outlined release of Substring((uint64_t)v75);
      swift_release((uint64_t)v34);
      Swift::UInt64 v31 = v70;
      goto LABEL_41;
    }
    if (v38 < rawBits >> 16 || v38 < v41._rawBits >> 16) {
      goto LABEL_82;
    }
    unint64_t v7 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, v41);
    swift_bridgeObjectRelease(v37);
    goto LABEL_40;
  }
  unint64_t v7 = 0;
LABEL_41:
  if (v27 >> 14 <= v31 >> 14) {
    goto LABEL_53;
  }
  v76[0] = v71;
  v76[1] = v72;
  unint64_t v45 = (atomic_ullong *)*((void *)&v73 + 1);
  while (1)
  {
    outlined retain of Substring((uint64_t)v76);
    swift_retain(v45);
    uint64_t v46 = specialized LazyMapSequence<>.subscript.getter(v31);
    unint64_t v6 = v47;
    outlined release of Substring((uint64_t)v76);
    swift_release((uint64_t)v45);
    if ((v6 & 0x1000000000000000) == 0) {
      break;
    }
    Swift::UInt64 v31 = String.UTF8View._foreignCount()();
    swift_bridgeObjectRelease(v6);
    BOOL v48 = __OFADD__(v7, v31);
    v7 += v31;
    if (v48) {
      goto LABEL_52;
    }
LABEL_48:
    outlined retain of Substring((uint64_t)v76);
    swift_retain(v45);
    unint64_t v6 = (unint64_t)&v71;
    specialized LazyMapSequence<>.formIndex(after:)(&v70);
    outlined release of Substring((uint64_t)v76);
    swift_release((uint64_t)v45);
    Swift::UInt64 v31 = v70;
    if (v27 >> 14 <= v70 >> 14) {
      goto LABEL_53;
    }
  }
  swift_bridgeObjectRelease(v6);
  if ((v6 & 0x2000000000000000) != 0) {
    Swift::UInt64 v31 = HIBYTE(v6) & 0xF;
  }
  else {
    Swift::UInt64 v31 = v46 & 0xFFFFFFFFFFFFLL;
  }
  BOOL v48 = __OFADD__(v7, v31);
  v7 += v31;
  if (!v48) {
    goto LABEL_48;
  }
LABEL_52:
  __break(1u);
LABEL_53:
  if ((v33 & 1) == 0)
  {
    v77[0] = v71;
    v77[1] = v72;
    unint64_t v50 = (atomic_ullong *)*((void *)&v73 + 1);
    outlined retain of Substring((uint64_t)v77);
    swift_retain(v50);
    unint64_t v51 = specialized LazyMapSequence<>.subscript.getter(v31);
    unint64_t v6 = v52;
    outlined release of Substring((uint64_t)v77);
    swift_release((uint64_t)v50);
    uint64_t v53 = (v51 >> 59) & 1;
    if ((v6 & 0x1000000000000000) == 0) {
      LOBYTE(v53) = 1;
    }
    Swift::UInt64 v33 = to._rawBits;
    if ((to._rawBits & 0xC) == 4 << v53)
    {
      Swift::UInt64 v33 = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
      char v49 = v67;
      if ((v6 & 0x1000000000000000) == 0)
      {
LABEL_59:
        swift_bridgeObjectRelease(v6);
        Swift::UInt64 v31 = v33 >> 16;
        BOOL v48 = __OFADD__(v7, v33 >> 16);
        v7 += v33 >> 16;
        if (!v48) {
          goto LABEL_60;
        }
LABEL_73:
        __break(1u);
LABEL_74:
        __break(1u);
LABEL_75:
        Swift::UInt64 v8 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v8)._rawBits;
LABEL_30:
        if ((v7 & 0xC) == v33)
        {
          unint64_t v7 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v7)._rawBits;
          if ((v6 & 0x1000000000000000) == 0) {
            goto LABEL_32;
          }
        }
        else if ((v6 & 0x1000000000000000) == 0)
        {
LABEL_32:
          swift_bridgeObjectRelease(v6);
          return (v7 >> 16) - (v8 >> 16);
        }
        unint64_t v62 = HIBYTE(v6) & 0xF;
        if ((v6 & 0x2000000000000000) == 0) {
          unint64_t v62 = v31 & 0xFFFFFFFFFFFFLL;
        }
        if (v62 >= v8 >> 16 && v62 >= v7 >> 16)
        {
          unint64_t v7 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v8, (Swift::String::Index)v7);
          swift_bridgeObjectRelease(v6);
          return v7;
        }
LABEL_82:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xCFuLL, 0);
      }
    }
    else
    {
      char v49 = v67;
      if ((v6 & 0x1000000000000000) == 0) {
        goto LABEL_59;
      }
    }
    unint64_t v61 = v51 & 0xFFFFFFFFFFFFLL;
    if ((v6 & 0x2000000000000000) != 0) {
      unint64_t v61 = HIBYTE(v6) & 0xF;
    }
    if (v61 < v33 >> 16) {
      goto LABEL_82;
    }
    Swift::UInt64 v31 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15, (Swift::String::Index)v33);
    swift_bridgeObjectRelease(v6);
    BOOL v48 = __OFADD__(v7, v31);
    v7 += v31;
    if (!v48) {
      goto LABEL_60;
    }
    goto LABEL_73;
  }
  char v49 = v67;
LABEL_60:
  if ((specialized static Comparable.<= infix(_:_:)(v9, v8, v68, a4, v66, v49) & 1) == 0)
  {
    BOOL v48 = __OFSUB__(0, v7);
    unint64_t v7 = -(uint64_t)v7;
    if (v48) {
      goto LABEL_74;
    }
  }
  return v7;
}

Swift::UInt64 specialized FlattenSequence<>.distance(from:to:)(uint64_t a1, unint64_t a2, char a3, unint64_t a4, unint64_t a5, char a6, uint64_t a7, void (*a8)(unint64_t *__return_ptr, uint64_t *), atomic_ullong *a9)
{
  Swift::UInt64 rawBits = a7;
  Swift::UInt64 v11 = a5;
  Swift::UInt64 v13 = a2;
  unint64_t v14 = (unint64_t)a9;
  char v15 = a3 & 1;
  char v16 = a3 & 1;
  char v17 = a6 & 1;
  if (a4 != a1)
  {
    uint64_t v19 = a1;
    char v69 = a6 & 1;
    if (specialized static Comparable.<= infix(_:_:)(a1, a2, a3 & 1, a4, a5, a6 & 1))
    {
      char v20 = specialized static Comparable.<= infix(_:_:)(v19, v13, v16, a4, v11, v17);
      to._Swift::UInt64 rawBits = v11;
      char v67 = v17;
      int64_t v21 = v19;
      uint64_t v19 = a4;
      Swift::UInt64 v22 = v13;
      if ((v20 & 1) == 0) {
        goto LABEL_7;
      }
    }
    else
    {
      char v30 = specialized static Comparable.<= infix(_:_:)(a4, v11, v17, v19, v13, v16);
      to._Swift::UInt64 rawBits = v13;
      char v67 = v15;
      Swift::UInt64 v22 = v11;
      char v15 = v17;
      int64_t v21 = a4;
      if ((v30 & 1) == 0) {
LABEL_7:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    char v63 = v16;
    unint64_t v64 = a4;
    Swift::UInt64 v65 = v13;
    Swift::UInt64 v66 = v11;
    if (v15)
    {
      Swift::Int v29 = 0;
LABEL_35:
      if (v21 >= v19) {
        goto LABEL_49;
      }
      int64_t v41 = v21;
      unint64_t v42 = (unint64_t *)(rawBits + 16 * v21 + 40);
      while (1)
      {
        if (v41 < 0 || (unint64_t)v21 >= *(void *)(rawBits + 16)) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
        unint64_t v43 = *v42;
        uint64_t v70 = *(v42 - 1);
        unint64_t v71 = v43;
        swift_bridgeObjectRetain(rawBits);
        swift_retain(a9);
        swift_bridgeObjectRetain(v43);
        a8(&v72, &v70);
        swift_release((uint64_t)a9);
        swift_bridgeObjectRelease(rawBits);
        swift_bridgeObjectRelease(v43);
        unint64_t v45 = v72;
        unint64_t v44 = v73;
        if ((v73 & 0x1000000000000000) != 0)
        {
          Swift::Int v47 = String.UTF8View._foreignCount()();
          swift_bridgeObjectRelease(v44);
          BOOL v40 = __OFADD__(v29, v47);
          v29 += v47;
          if (v40) {
            goto LABEL_48;
          }
        }
        else
        {
          swift_bridgeObjectRelease(v73);
          if ((v44 & 0x2000000000000000) != 0) {
            uint64_t v46 = HIBYTE(v44) & 0xF;
          }
          else {
            uint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
          }
          BOOL v40 = __OFADD__(v29, v46);
          v29 += v46;
          if (v40)
          {
LABEL_48:
            __break(1u);
LABEL_49:
            if (v67)
            {
              unint64_t v38 = v65;
              Swift::UInt64 v31 = v66;
              uint64_t v37 = v64;
              char v48 = v69;
              a8 = (void (*)(unint64_t *__return_ptr, uint64_t *))a1;
LABEL_56:
              if (specialized static Comparable.<= infix(_:_:)((uint64_t)a8, v38, v63, v37, v31, v48)) {
                return v29;
              }
              BOOL v40 = __OFSUB__(0, v29);
              Swift::Int v29 = -v29;
              if (!v40) {
                return v29;
              }
              __break(1u);
LABEL_81:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
            }
            swift_bridgeObjectRetain(rawBits);
            swift_retain(a9);
            specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v21, 1, rawBits);
            Swift::UInt64 v49 = rawBits + 16 * v21;
            unint64_t v50 = *(void *)(v49 + 40);
            uint64_t v70 = *(void *)(v49 + 32);
            unint64_t v71 = v50;
            swift_bridgeObjectRetain(v50);
            a8(&v72, &v70);
            swift_release((uint64_t)a9);
            swift_bridgeObjectRelease(rawBits);
            swift_bridgeObjectRelease(v50);
            uint64_t v34 = v72;
            unint64_t v14 = v73;
            uint64_t v51 = (v72 >> 59) & 1;
            if ((v73 & 0x1000000000000000) == 0) {
              LOBYTE(v51) = 1;
            }
            Swift::UInt64 rawBits = to._rawBits;
            unint64_t v38 = v65;
            Swift::UInt64 v31 = v66;
            uint64_t v37 = v64;
            a8 = (void (*)(unint64_t *__return_ptr, uint64_t *))a1;
            if ((to._rawBits & 0xC) != 4 << v51)
            {
              char v48 = v69;
              if ((v73 & 0x1000000000000000) == 0)
              {
LABEL_55:
                swift_bridgeObjectRelease(v14);
                BOOL v40 = __OFADD__(v29, rawBits >> 16);
                v29 += rawBits >> 16;
                if (!v40) {
                  goto LABEL_56;
                }
LABEL_78:
                __break(1u);
                goto LABEL_79;
              }
LABEL_73:
              unint64_t v60 = v34 & 0xFFFFFFFFFFFFLL;
              if ((v14 & 0x2000000000000000) != 0) {
                unint64_t v60 = HIBYTE(v14) & 0xF;
              }
              if (v60 >= rawBits >> 16)
              {
                Swift::Int v61 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15, (Swift::String::Index)rawBits);
                swift_bridgeObjectRelease(v14);
                BOOL v40 = __OFADD__(v29, v61);
                v29 += v61;
                if (!v40) {
                  goto LABEL_56;
                }
                goto LABEL_78;
              }
LABEL_79:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xCFuLL, 0);
            }
LABEL_72:
            Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
            char v48 = v69;
            if ((v14 & 0x1000000000000000) == 0) {
              goto LABEL_55;
            }
            goto LABEL_73;
          }
        }
        ++v21;
        v42 += 2;
        if (v21 >= v19) {
          goto LABEL_49;
        }
      }
    }
    Swift::UInt64 v31 = v22;
    swift_bridgeObjectRetain(rawBits);
    swift_retain(a9);
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v21, 1, rawBits);
    Swift::UInt64 v32 = rawBits + 16 * v21;
    unint64_t v33 = *(void *)(v32 + 40);
    uint64_t v70 = *(void *)(v32 + 32);
    unint64_t v71 = v33;
    swift_bridgeObjectRetain(v33);
    a8(&v72, &v70);
    swift_release((uint64_t)a9);
    swift_bridgeObjectRelease(rawBits);
    swift_bridgeObjectRelease(v33);
    uint64_t v34 = v73;
    if ((v73 & 0x2000000000000000) != 0) {
      unint64_t v35 = HIBYTE(v73) & 0xF;
    }
    else {
      unint64_t v35 = v72 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v36 = v35 << 16;
    if ((v73 & 0x1000000000000000) != 0) {
      uint64_t v37 = (v72 >> 59) & 1;
    }
    else {
      uint64_t v37 = 1;
    }
    if (v37 == 1)
    {
      unint64_t v38 = v36 | 7;
      if ((v73 & 0x1000000000000000) == 0)
      {
        LOBYTE(v39) = 1;
        goto LABEL_30;
      }
    }
    else
    {
      unint64_t v38 = v36 | 0xB;
    }
    unint64_t v39 = (v72 & 0x800000000000000) >> 59;
LABEL_30:
    if ((v31 & 0xC) == 4 << v39)
    {
      v54._Swift::UInt64 rawBits = v31;
      unint64_t v55 = v35;
      v56._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v54)._rawBits;
      unint64_t v35 = v55;
      Swift::UInt64 v31 = v56._rawBits;
    }
    if ((v38 & 0xC) == 4 << v37)
    {
      v57._Swift::UInt64 rawBits = v38;
      unint64_t v58 = v35;
      v59._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v57)._rawBits;
      unint64_t v35 = v58;
      unint64_t v38 = v59._rawBits;
      if ((v34 & 0x1000000000000000) == 0)
      {
LABEL_34:
        swift_bridgeObjectRelease(v34);
        Swift::Int v29 = (v38 >> 16) - (v31 >> 16);
        BOOL v40 = __OFADD__(v21++, 1);
        if (!v40) {
          goto LABEL_35;
        }
LABEL_71:
        __break(1u);
        goto LABEL_72;
      }
    }
    else if ((v34 & 0x1000000000000000) == 0)
    {
      goto LABEL_34;
    }
    if (v35 < v31 >> 16 || v35 < v38 >> 16) {
      goto LABEL_79;
    }
    Swift::Int v29 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v31, (Swift::String::Index)v38);
    swift_bridgeObjectRelease(v34);
    BOOL v40 = __OFADD__(v21++, 1);
    if (!v40) {
      goto LABEL_35;
    }
    goto LABEL_71;
  }
  if (a6)
  {
    if (a3) {
      return 0;
    }
    goto LABEL_81;
  }
  if (a3) {
    goto LABEL_81;
  }
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(a4, 1, a7);
  Swift::UInt64 v23 = rawBits + 16 * a4;
  unint64_t v24 = *(void *)(v23 + 40);
  uint64_t v70 = *(void *)(v23 + 32);
  unint64_t v71 = v24;
  swift_bridgeObjectRetain(v24);
  a8(&v72, &v70);
  swift_bridgeObjectRelease(v24);
  unint64_t v26 = v72;
  unint64_t v25 = v73;
  uint64_t v27 = (v72 >> 59) & 1;
  if ((v73 & 0x1000000000000000) == 0) {
    LOBYTE(v27) = 1;
  }
  uint64_t v28 = 4 << v27;
  if ((v13 & 0xC) == 4 << v27) {
    Swift::UInt64 v13 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v13)._rawBits;
  }
  if ((v11 & 0xC) == v28)
  {
    Swift::UInt64 v11 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v11)._rawBits;
    if ((v25 & 0x1000000000000000) == 0) {
      goto LABEL_15;
    }
  }
  else if ((v25 & 0x1000000000000000) == 0)
  {
LABEL_15:
    swift_bridgeObjectRelease(v25);
    return (v11 >> 16) - (v13 >> 16);
  }
  unint64_t v52 = HIBYTE(v25) & 0xF;
  if ((v25 & 0x2000000000000000) == 0) {
    unint64_t v52 = v26 & 0xFFFFFFFFFFFFLL;
  }
  if (v52 < v13 >> 16 || v52 < v11 >> 16) {
    goto LABEL_79;
  }
  Swift::Int v53 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v13, (Swift::String::Index)v11);
  swift_bridgeObjectRelease(v25);
  return v53;
}

unint64_t specialized FlattenSequence<>.distance(from:to:)(uint64_t a1, unint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6, int a7, void (*a8)(uint64_t *__return_ptr, int *), atomic_ullong *a9)
{
  char v12 = a3 & 1;
  char v13 = a6 & 1;
  char v14 = a6 & 1;
  if (a4 != a1)
  {
    if (specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, a6 & 1, a1, a2, v12))
    {
      BOOL v17 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a1, a2, v12, a4, a5, v14);
      unint64_t v35 = a2;
      char v18 = v12;
      unint64_t v19 = a5;
      uint64_t v20 = a4;
      uint64_t v21 = a1;
      if (v17) {
        goto LABEL_7;
      }
    }
    else
    {
      BOOL v24 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, v14, a1, a2, v12);
      unint64_t v35 = a5;
      char v18 = v13;
      unint64_t v19 = a2;
      char v13 = v12;
      uint64_t v20 = a1;
      uint64_t v21 = a4;
      if (v24) {
LABEL_7:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    if (v13)
    {
      if (v20 >= v21)
      {
        unint64_t v15 = 0;
        if (v18) {
          goto LABEL_40;
        }
        goto LABEL_38;
      }
      if (v20) {
        goto LABEL_43;
      }
      char v25 = v18;
      int v38 = a7;
      swift_retain(a9);
      a8(&v39, &v38);
      swift_release((uint64_t)a9);
      uint64_t v26 = 2;
      uint64_t v27 = 3;
      if (v39 >= 0x10000) {
        uint64_t v27 = 4;
      }
      if (v39 >= 0x800) {
        uint64_t v26 = v27;
      }
      unint64_t v28 = v39 >= 0x80 ? v26 : 1;
      unint64_t v29 = specialized RandomAccessCollection<>.distance(from:to:)(0, v28, v39);
      if (v21 > 1) {
        goto LABEL_43;
      }
    }
    else
    {
      if (v20) {
        goto LABEL_43;
      }
      char v25 = v18;
      int v38 = a7;
      swift_retain(a9);
      a8(&v39, &v38);
      swift_release((uint64_t)a9);
      uint64_t v30 = 2;
      uint64_t v31 = 3;
      if (v39 >= 0x10000) {
        uint64_t v31 = 4;
      }
      if (v39 >= 0x800) {
        uint64_t v30 = v31;
      }
      unint64_t v32 = v39 >= 0x80 ? v30 : 1;
      unint64_t v29 = specialized RandomAccessCollection<>.distance(from:to:)(v19, v32, v39);
      if (v21 >= 2) {
        goto LABEL_43;
      }
    }
    unint64_t v15 = v29;
    uint64_t v20 = 1;
    if (v25) {
      goto LABEL_40;
    }
LABEL_38:
    if (v20) {
      goto LABEL_43;
    }
    int v38 = a7;
    swift_retain(a9);
    a8(&v39, &v38);
    swift_release((uint64_t)a9);
    unint64_t v33 = specialized RandomAccessCollection<>.distance(from:to:)(0, v35, v39);
    BOOL v34 = __OFADD__(v15, v33);
    v15 += v33;
    if (v34)
    {
      __break(1u);
LABEL_45:
      __break(1u);
      goto LABEL_46;
    }
LABEL_40:
    if (!specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, v14, a1, a2, v12)) {
      return v15;
    }
    BOOL v34 = __OFSUB__(0, v15);
    unint64_t v15 = -(uint64_t)v15;
    if (!v34) {
      return v15;
    }
    goto LABEL_45;
  }
  if (a6)
  {
    if (a3) {
      return 0;
    }
LABEL_46:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
  }
  if (a3) {
    goto LABEL_46;
  }
  if (a4) {
LABEL_43:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x83uLL, 0);
  int v38 = a7;
  a8(&v39, &v38);
  unsigned int v22 = v39;

  return specialized RandomAccessCollection<>.distance(from:to:)(a2, a5, v22);
}

Swift::UInt64 specialized FlattenSequence<>.distance(from:to:)(uint64_t a1, unint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6, uint64_t a7, unint64_t a8, void (*a9)(unint64_t *__return_ptr, uint64_t *), atomic_ullong *a10)
{
  Swift::UInt64 rawBits = a8;
  uint64_t v11 = a7;
  unint64_t v12 = a5;
  Swift::UInt64 v14 = a2;
  unint64_t v15 = (unint64_t)a10;
  unint64_t v16 = a3 & 1;
  unint64_t v17 = a6 & 1;
  char v18 = a6 & 1;
  if (a4 != a1)
  {
    if (specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, a6 & 1, a1, a2, a3 & 1))
    {
      BOOL v21 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a1, v14, v16, a4, v12, v18);
      to._Swift::UInt64 rawBits = v14;
      char v22 = v16;
      unint64_t v23 = v12;
      uint64_t v24 = a4;
      uint64_t v25 = a1;
      if (v21) {
        goto LABEL_7;
      }
    }
    else
    {
      BOOL v32 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, v12, v18, a1, v14, v16);
      to._Swift::UInt64 rawBits = v12;
      char v22 = v17;
      unint64_t v23 = v14;
      unint64_t v17 = v16;
      uint64_t v24 = a1;
      uint64_t v25 = a4;
      if (v32) {
LABEL_7:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    unint64_t v58 = v14;
    uint64_t v59 = v25;
    char v60 = v22;
    if (v17)
    {
      Swift::Int v31 = 0;
      if (v24 < v25)
      {
LABEL_20:
        if (!v24)
        {
          uint64_t v61 = v11;
          Swift::UInt64 v62 = rawBits;
          swift_bridgeObjectRetain(rawBits);
          swift_retain(a10);
          a9(&v63, &v61);
          swift_release((uint64_t)a10);
          swift_bridgeObjectRelease(rawBits);
          unint64_t v33 = v63;
          unint64_t v15 = v64;
          if ((v64 & 0x1000000000000000) != 0)
          {
            unint64_t v17 = String.UTF8View._foreignCount()();
            swift_bridgeObjectRelease(v15);
          }
          else
          {
            swift_bridgeObjectRelease(v64);
            if ((v15 & 0x2000000000000000) != 0) {
              unint64_t v17 = HIBYTE(v15) & 0xF;
            }
            else {
              unint64_t v17 = v33 & 0xFFFFFFFFFFFFLL;
            }
          }
          BOOL v34 = __OFADD__(v31, v17);
          v31 += v17;
          if (v34)
          {
            __break(1u);
            goto LABEL_69;
          }
          if (v59 < 2 && (v60 & 1) != 0)
          {
            do
            {
              while (1)
              {
LABEL_53:
                if (!specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, v12, v18, a1, v58, v16)) {
                  return v31;
                }
                BOOL v34 = __OFSUB__(0, v31);
                Swift::Int v31 = -v31;
                if (!v34) {
                  return v31;
                }
LABEL_69:
                __break(1u);
LABEL_70:
                Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
                if ((v15 & 0x1000000000000000) != 0) {
                  break;
                }
LABEL_52:
                swift_bridgeObjectRelease(v15);
                unint64_t v17 = rawBits >> 16;
                BOOL v34 = __OFADD__(v31, rawBits >> 16);
                v31 += rawBits >> 16;
                if (v34) {
                  goto LABEL_76;
                }
              }
LABEL_71:
              unint64_t v52 = v17 & 0xFFFFFFFFFFFFLL;
              if ((v15 & 0x2000000000000000) != 0) {
                unint64_t v52 = HIBYTE(v15) & 0xF;
              }
              if (v52 < rawBits >> 16) {
                goto LABEL_77;
              }
              unint64_t v17 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15, (Swift::String::Index)rawBits);
              swift_bridgeObjectRelease(v15);
              BOOL v34 = __OFADD__(v31, v17);
              v31 += v17;
            }
            while (!v34);
LABEL_76:
            __break(1u);
            goto LABEL_77;
          }
        }
LABEL_56:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x83uLL, 0);
      }
LABEL_46:
      if (v22) {
        goto LABEL_53;
      }
      if (!v24)
      {
        uint64_t v61 = v11;
        Swift::UInt64 v62 = rawBits;
        swift_bridgeObjectRetain(rawBits);
        swift_retain(a10);
        a9(&v63, &v61);
        swift_release((uint64_t)a10);
        swift_bridgeObjectRelease(rawBits);
        unint64_t v17 = v63;
        unint64_t v15 = v64;
        uint64_t v45 = (v63 >> 59) & 1;
        if ((v64 & 0x1000000000000000) == 0) {
          LOBYTE(v45) = 1;
        }
        Swift::UInt64 rawBits = to._rawBits;
        if ((to._rawBits & 0xC) == 4 << v45) {
          goto LABEL_70;
        }
        if ((v64 & 0x1000000000000000) != 0) {
          goto LABEL_71;
        }
        goto LABEL_52;
      }
      goto LABEL_56;
    }
    if (v24) {
      goto LABEL_56;
    }
    uint64_t v35 = v11;
    Swift::UInt64 v36 = v23;
    unint64_t v54 = v12;
    uint64_t v55 = v35;
    uint64_t v61 = v35;
    Swift::UInt64 v62 = rawBits;
    swift_bridgeObjectRetain(rawBits);
    swift_retain(a10);
    a9(&v63, &v61);
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(rawBits);
    unint64_t v17 = v64;
    if ((v64 & 0x2000000000000000) != 0) {
      unint64_t v37 = HIBYTE(v64) & 0xF;
    }
    else {
      unint64_t v37 = v63 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v38 = v37 << 16;
    uint64_t v39 = (v63 >> 59) & 1;
    int v40 = (v64 & 0x1000000000000000) == 0 || (v63 & 0x800000000000000) != 0;
    if (v40 == 1)
    {
      v41._Swift::UInt64 rawBits = v38 | 7;
      Swift::UInt64 v42 = v36;
      if ((v64 & 0x1000000000000000) == 0) {
        LOBYTE(v39) = 1;
      }
    }
    else
    {
      v41._Swift::UInt64 rawBits = v38 | 0xB;
      Swift::UInt64 v42 = v36;
    }
    uint64_t v11 = v55;
    if ((v42 & 0xC) == 4 << v39)
    {
      unint64_t v53 = v37;
      v48._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v42)._rawBits;
      unint64_t v37 = v53;
      Swift::UInt64 v42 = v48._rawBits;
    }
    if ((v41._rawBits & 0xC) == 4 << v40)
    {
      v49._Swift::UInt64 rawBits = v41._rawBits;
      Swift::UInt64 v56 = v42;
      unint64_t v50 = v37;
      v51._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v49)._rawBits;
      unint64_t v37 = v50;
      Swift::UInt64 v42 = v56;
      v41._Swift::UInt64 rawBits = v51._rawBits;
      Swift::UInt64 v43 = v51._rawBits >> 16;
      if ((v17 & 0x1000000000000000) == 0) {
        goto LABEL_44;
      }
    }
    else
    {
      Swift::UInt64 v43 = v41._rawBits >> 16;
      if ((v17 & 0x1000000000000000) == 0)
      {
LABEL_44:
        uint64_t v44 = v17;
        unint64_t v17 = v42;
        swift_bridgeObjectRelease(v44);
        Swift::Int v31 = v43 - (v17 >> 16);
        goto LABEL_45;
      }
    }
    if (v37 < v42 >> 16 || v37 < v43) {
      goto LABEL_77;
    }
    Swift::Int v31 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v42, v41);
    swift_bridgeObjectRelease(v17);
LABEL_45:
    uint64_t v24 = 1;
    unint64_t v12 = v54;
    char v22 = v60;
    if (v59 > 1) {
      goto LABEL_20;
    }
    goto LABEL_46;
  }
  if (a6)
  {
    if (a3) {
      return 0;
    }
LABEL_78:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Flatten.swift", 19, 2, 0xC8uLL, 0);
  }
  if (a3) {
    goto LABEL_78;
  }
  if (a4) {
    goto LABEL_56;
  }
  Swift::UInt64 v26 = a5;
  uint64_t v61 = a7;
  Swift::UInt64 v62 = a8;
  swift_bridgeObjectRetain(a8);
  a9(&v63, &v61);
  swift_bridgeObjectRelease(rawBits);
  unint64_t v28 = v63;
  unint64_t v27 = v64;
  uint64_t v29 = (v63 >> 59) & 1;
  if ((v64 & 0x1000000000000000) == 0) {
    LOBYTE(v29) = 1;
  }
  uint64_t v30 = 4 << v29;
  if ((v14 & 0xC) == 4 << v29) {
    Swift::UInt64 v14 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v14)._rawBits;
  }
  if ((v26 & 0xC) != v30)
  {
    if ((v27 & 0x1000000000000000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_58;
  }
  Swift::UInt64 v26 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v26)._rawBits;
  if ((v27 & 0x1000000000000000) != 0)
  {
LABEL_58:
    unint64_t v46 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000) == 0) {
      unint64_t v46 = v28 & 0xFFFFFFFFFFFFLL;
    }
    if (v46 >= v14 >> 16 && v46 >= v26 >> 16)
    {
      Swift::Int v47 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v14, (Swift::String::Index)v26);
      swift_bridgeObjectRelease(v27);
      return v47;
    }
LABEL_77:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xCFuLL, 0);
  }
LABEL_16:
  swift_bridgeObjectRelease(v27);
  return (v26 >> 16) - (v14 >> 16);
}

uint64_t FlattenSequence<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5)
{
  uint64_t v7 = a4;
  uint64_t v10 = *(void *)(a3 + 16);
  uint64_t v11 = type metadata accessor for FlattenSequence<>.Index(255, v10, a4, (uint64_t)a5);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v11, (uint64_t)v11, "lower upper ", 0);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  Swift::String::Index v227 = (uint64_t (**)(char *, uint64_t, uint64_t))((char *)v199 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  int v224 = (char *)v199 - v15;
  uint64_t v238 = (uint64_t)*(v11 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v221 = (int **)((char *)v199 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v220 = (void (**)(char *, uint64_t))((char *)v199 - v19);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v228 = (void (**)(char *, uint64_t))((char *)v199 - v21);
  MEMORY[0x1F4188790](v20);
  uint64_t v219 = (void (**)(char *, uint64_t))((char *)v199 - v22);
  unint64_t v218 = v11;
  uint64_t v23 = a2;
  unint64_t v211 = type metadata accessor for Range(0, (uint64_t)v11, (uint64_t)&protocol witness table for FlattenSequence<A><>.Index, v24);
  uint64_t v25 = (uint64_t)*(v211 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v211);
  unint64_t v223 = (char *)v199 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v210 = (char *)v199 - v28;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v7 + 8), v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v208 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  Swift::String::Index v230 = (char *)v199 - v31;
  uint64_t v231 = v30;
  BOOL v32 = swift_getAssociatedTypeWitness(255, a5, v30, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  unint64_t v212 = type metadata accessor for Optional(0, (uint64_t)v32, v33, v34);
  uint64_t v209 = (uint64_t)*(v212 - 1);
  uint64_t v35 = MEMORY[0x1F4188790](v212);
  unint64_t v204 = (char *)v199 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  char v222 = (void (**)(char *))((char *)v199 - v38);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  char v202 = (void (*)(void))((char *)v199 - v40);
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  uint64_t v234 = (char *)v199 - v42;
  uint64_t v216 = v32;
  uint64_t v217 = *((void *)v32 - 1);
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  unint64_t v203 = (char *)v199 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  unint64_t v205 = (char *)v199 - v46;
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  uint64_t v225 = (char *)v199 - v48;
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  uint64_t v201 = (char *)v199 - v50;
  MEMORY[0x1F4188790](v49);
  unint64_t v52 = (char *)v199 - v51;
  uint64_t v53 = v23;
  unint64_t v54 = swift_getAssociatedTypeWitness(0, (int **)v7, v10, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v214 = *((void *)v54 - 1);
  uint64_t v55 = MEMORY[0x1F4188790](v54);
  Swift::String::Index v232 = (char *)v199 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  uint64_t v59 = (char *)v199 - v58;
  uint64_t v60 = MEMORY[0x1F4188790](v57);
  uint64_t v237 = (char *)v199 - v61;
  uint64_t v215 = *(void *)(v10 - 8);
  MEMORY[0x1F4188790](v60);
  Swift::String::Index v236 = (char *)v199 - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v213 = a1;
  uint64_t v233 = a5;
  char v63 = static FlattenSequence<>.Index.< infix(_:_:)(v53, a1, v10, v7, a5);
  uint64_t v207 = v53;
  uint64_t v206 = v25;
  if (v63)
  {
    unint64_t v64 = v236;
    (*(void (**)(char *, uint64_t, uint64_t))(v215 + 16))(v236, v5, v10);
    Swift::UInt64 v65 = v237;
    (*(void (**)(uint64_t, uint64_t))(v7 + 72))(v10, v7);
    (*(void (**)(uint64_t, uint64_t))(v7 + 64))(v10, v7);
    (*(void (**)(char *, char *, uint64_t, uint64_t))(v7 + 152))(v65, v59, v10, v7);
    Swift::UInt64 v66 = v52;
    char v67 = *(void (**)(char *, const char *))(v214 + 8);
    v67(v59, v54);
    v67(v65, v54);
    unint64_t v52 = v66;
    uint64_t v53 = v207;
    (*(void (**)(char *, uint64_t))(v215 + 8))(v64, v10);
  }
  uint64_t v239 = v5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v10, (uint64_t)v54, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v68 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8);
  uint64_t v69 = v213;
  Swift::String::Index v235 = v54;
  char v70 = v68(v213, v53, v54);
  uint64_t v240 = v10;
  if (v70)
  {
    uint64_t v238 = (uint64_t)v52;
    unint64_t v71 = v218;
    uint64_t v72 = v69 + *((int *)v218 + 11);
    uint64_t v73 = v209;
    char v74 = v234;
    unint64_t v75 = v212;
    uint64_t v237 = *(char **)(v209 + 16);
    ((void (*)(char *, uint64_t, Class *))v237)(v234, v72, v212);
    char v76 = *(unsigned int (**)(char *, uint64_t, const char *))(v217 + 48);
    char v77 = v216;
    if (v76(v74, 1, v216) == 1)
    {
      (*(void (**)(char *, Class *))(v73 + 8))(v74, v75);
      return 0;
    }
    uint64_t v96 = v53;
    uint64_t v97 = (char *)v77;
    Swift::String::Index v227 = (uint64_t (**)(char *, uint64_t, uint64_t))v7;
    uint64_t v98 = *(char **)(v217 + 32);
    ((void (*)(uint64_t, char *, char *))v98)(v238, v74, v97);
    uint64_t v99 = v96 + *((int *)v71 + 11);
    uint64_t v100 = v97;
    uint64_t v78 = (uint64_t)v202;
    ((void (*)(void (*)(void), uint64_t, Class *))v237)(v202, v99, v75);
    if (v76((char *)v78, 1, v100) == 1)
    {
      (*(void (**)(uint64_t, char *))(v217 + 8))(v238, v100);
      (*(void (**)(uint64_t, Class *))(v209 + 8))(v78, v75);
      return 0;
    }
LABEL_30:
    uint64_t v192 = v201;
    ((void (*)(char *, uint64_t, char *))v98)(v201, v78, v100);
    char v193 = (void (*)(char *, void))v227[10](v241, v213, v240);
    uint64_t v194 = v208;
    unint64_t v195 = v230;
    uint64_t v196 = v231;
    (*(void (**)(char *))(v208 + 16))(v230);
    v193(v241, 0);
    uint64_t v197 = v238;
    uint64_t v78 = ((uint64_t (*)(uint64_t, char *, uint64_t))v233[19])(v238, v192, v196);
    (*(void (**)(char *, uint64_t))(v194 + 8))(v195, v196);
    char v198 = *(void (**)(char *, char *))(v217 + 8);
    v198(v192, v100);
    v198((char *)v197, v100);
    return v78;
  }
  Swift::String::Index v79 = v233;
  char v80 = static FlattenSequence<>.Index.< infix(_:_:)(v53, v69, v10, v7, v233);
  uint64_t v81 = *(void (**)(void (**)(char *, uint64_t), uint64_t, Class *))(v238 + 16);
  if (v80)
  {
    uint64_t v82 = (uint64_t)v220;
    uint64_t v83 = v53;
    uint64_t v84 = v53;
    uint64_t v85 = v218;
    v81(v220, v83, v218);
    uint64_t v86 = (uint64_t)v221;
    v81((void (**)(char *, uint64_t))v221, v69, v85);
    if (static FlattenSequence<>.Index.< infix(_:_:)(v86, v82, v10, v7, v79)) {
      goto LABEL_33;
    }
    uint64_t v87 = v86;
    uint64_t v88 = v238;
    uint64_t v89 = v84;
    uint64_t v90 = *(char **)(v238 + 8);
    uint64_t v234 = v90;
    ((void (*)(uint64_t, Class *))v90)(v87, v85);
    ((void (*)(uint64_t, Class *))v90)(v82, v85);
    uint64_t v91 = TupleTypeMetadata2;
    unint64_t v92 = v224;
    uint64_t v93 = &v224[*((int *)TupleTypeMetadata2 + 12)];
    v81((void (**)(char *, uint64_t))v224, v89, v218);
    uint64_t v94 = v93;
    uint64_t v95 = v69;
  }
  else
  {
    uint64_t v101 = (uint64_t)v219;
    uint64_t v102 = v53;
    uint64_t v103 = v218;
    v81(v219, v69, v218);
    uint64_t v104 = (uint64_t)v228;
    v81(v228, v102, v103);
    if (static FlattenSequence<>.Index.< infix(_:_:)(v104, v101, v10, v7, v79)) {
      goto LABEL_33;
    }
    uint64_t v105 = v101;
    uint64_t v88 = v238;
    uint64_t v106 = v102;
    uint64_t v107 = *(char **)(v238 + 8);
    uint64_t v234 = v107;
    ((void (*)(void, Class *))v107)(v228, v103);
    ((void (*)(uint64_t, Class *))v107)(v105, v103);
    uint64_t v91 = TupleTypeMetadata2;
    unint64_t v92 = v224;
    uint64_t v93 = &v224[*((int *)TupleTypeMetadata2 + 12)];
    v81((void (**)(char *, uint64_t))v224, v69, v218);
    uint64_t v94 = v93;
    uint64_t v95 = v106;
  }
  v81((void (**)(char *, uint64_t))v94, v95, v218);
  uint64_t v108 = v227;
  uint64_t v109 = (char *)v227 + *((int *)v91 + 12);
  v81((void (**)(char *, uint64_t))v227, (uint64_t)v92, v218);
  v81((void (**)(char *, uint64_t))v109, (uint64_t)v93, v218);
  uint64_t v110 = *(void (**)(char *, uint64_t (**)(char *, uint64_t, uint64_t), Class *))(v88 + 32);
  uint64_t v111 = v223;
  v110(v223, v108, v218);
  ((void (*)(char *, Class *))v234)(v109, v218);
  uint64_t v112 = (char *)v108 + *((int *)v91 + 12);
  uint64_t v113 = (uint64_t (**)(char *, uint64_t, uint64_t))v92;
  uint64_t v114 = v111;
  v110((char *)v108, v113, v218);
  unint64_t v115 = v93;
  uint64_t v116 = v218;
  v110(v112, (uint64_t (**)(char *, uint64_t, uint64_t))v115, v218);
  unint64_t v117 = v211;
  v110(&v114[*((int *)v211 + 9)], (uint64_t (**)(char *, uint64_t, uint64_t))v112, v116);
  ((void (*)(uint64_t (**)(char *, uint64_t, uint64_t), Class *))v234)(v108, v116);
  uint64_t v118 = v210;
  (*(void (**)(char *, char *, Class *))(v206 + 32))(v210, v114, v117);
  uint64_t v119 = *(void (**)(void))(v214 + 16);
  uint64_t v100 = v232;
  unint64_t v120 = v235;
  uint64_t v228 = (void (**)(char *, uint64_t))(v214 + 16);
  char v202 = v119;
  v119();
  unint64_t v121 = &v118[*((int *)v116 + 11)];
  uint64_t v122 = v209;
  uint64_t v123 = *(void (**)(void (**)(char *), char *, Class *))(v209 + 16);
  unint64_t v124 = v222;
  Swift::String v125 = v212;
  v199[1] = v209 + 16;
  v199[0] = v123;
  v123(v222, v121, v212);
  uint64_t v126 = v217;
  unint64_t v127 = *(unsigned int (**)(char *, uint64_t, const char *))(v217 + 48);
  uint64_t v128 = v216;
  uint64_t v201 = (char *)(v217 + 48);
  uint64_t v200 = v127;
  unsigned int v129 = v127((char *)v124, 1, v216);
  uint64_t v130 = v240;
  uint64_t v131 = v208;
  if (v129 == 1)
  {
    (*(void (**)(void (**)(char *), Class *))(v122 + 8))(v124, v125);
    uint64_t v238 = 0;
    char v132 = v236;
    uint64_t v98 = v237;
    uint64_t v133 = v211;
  }
  else
  {
    (*(void (**)(char *, void (**)(char *), const char *))(v126 + 32))(v225, v124, v128);
    uint64_t v134 = v215;
    TupleTypeMetadata2 = *(uint64_t **)(v215 + 16);
    uint64_t v234 = (char *)(v215 + 16);
    Swift::String v135 = v236;
    ((void (*)(char *, uint64_t, uint64_t))TupleTypeMetadata2)(v236, v239, v130);
    uint64_t v136 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v7 + 80);
    Swift::String::Index v227 = (uint64_t (**)(char *, uint64_t, uint64_t))v7;
    uint64_t v137 = (void (*)(char *, void))v136(v241, v232, v130, v7);
    unint64_t v138 = *(void (**)(char *))(v131 + 16);
    unint64_t v139 = v230;
    uint64_t v140 = v231;
    uint64_t v141 = v126;
    v138(v230);
    v137(v241, 0);
    char v132 = v135;
    int v224 = *(char **)(v134 + 8);
    ((void (*)(char *, uint64_t))v224)(v135, v130);
    unint64_t v142 = v233;
    unint64_t v143 = v205;
    ((void (*)(uint64_t, int **))v233[9])(v140, v233);
    uint64_t v144 = v225;
    uint64_t v238 = ((uint64_t (*)(char *, char *, uint64_t, int **))v142[19])(v225, v143, v140, v142);
    unint64_t v145 = *(void (**)(char *, const char *))(v141 + 8);
    uint64_t v146 = v143;
    uint64_t v100 = v232;
    uint64_t v147 = v216;
    v145(v146, v216);
    unint64_t v148 = v139;
    uint64_t v133 = v211;
    (*(void (**)(char *, uint64_t))(v208 + 8))(v148, v140);
    v145(v144, v147);
    uint64_t v7 = (uint64_t)v227;
    ((void (*)(char *, uint64_t, uint64_t))TupleTypeMetadata2)(v135, v239, v130);
    (*(void (**)(char *, uint64_t, uint64_t))(v7 + 192))(v100, v130, v7);
    ((void (*)(char *, uint64_t))v224)(v135, v130);
    unint64_t v120 = v235;
    uint64_t v98 = v237;
  }
  unint64_t v149 = (uint64_t (**)(char *, uint64_t, uint64_t))&v210[*((int *)v133 + 9)];
  uint64_t v150 = AssociatedConformanceWitness;
  uint64_t v151 = (char *)(AssociatedConformanceWitness + 16);
  unint64_t v152 = *(char **)(AssociatedConformanceWitness + 16);
  ((void (*)(char *, char *, const char *))v202)(v98, v100, v120);
  Swift::String::Index v227 = v149;
  int v224 = v152;
  uint64_t v225 = v151;
  LOBYTE(v149) = ((uint64_t (*)(char *, uint64_t (**)(char *, uint64_t, uint64_t), const char *, uint64_t))v152)(v98, v149, v120, v150);
  uint64_t v153 = (uint64_t *)(v214 + 8);
  uint64_t v237 = *(char **)(v214 + 8);
  ((void (*)(char *, const char *))v237)(v98, v120);
  TupleTypeMetadata2 = v153;
  if (v149)
  {
    Swift::String::Index v235 = *(const char **)(v215 + 16);
    unint64_t v223 = (char *)(v7 + 80);
    char v222 = (void (**)(char *))(v208 + 16);
    Swift::String::Index v236 = (char *)(v215 + 16);
    uint64_t v234 = (char *)(v215 + 8);
    unint64_t v221 = v233 + 14;
    unint64_t v220 = (void (**)(char *, uint64_t))(v208 + 8);
    uint64_t v219 = (void (**)(char *, uint64_t))(v7 + 192);
    unint64_t v154 = v202;
    unint64_t v155 = v232;
    while (1)
    {
      uint64_t v156 = v240;
      ((void (*)(char *, uint64_t, uint64_t))v235)(v132, v239, v240);
      ((void (*)(char *, char *, const char *))v154)(v98, v155, v120);
      unint64_t v157 = (void (*)(char *, void))(*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v7 + 80))(v241, v98, v156, v7);
      uint64_t v158 = v230;
      uint64_t v159 = v231;
      (*v222)(v230);
      v157(v241, 0);
      ((void (*)(char *, const char *))v237)(v98, v120);
      uint64_t v160 = v7;
      unint64_t v161 = *(void (**)(char *, uint64_t))v234;
      (*(void (**)(char *, uint64_t))v234)(v132, v156);
      uint64_t v162 = ((uint64_t (*)(uint64_t))v233[14])(v159);
      uint64_t v100 = v232;
      uint64_t v163 = v154;
      uint64_t v164 = v162;
      (*v220)(v158, v159);
      if (__OFADD__(v238, v164)) {
        break;
      }
      v238 += v164;
      uint64_t v165 = v240;
      ((void (*)(char *, uint64_t, uint64_t))v235)(v132, v239, v240);
      (*(void (**)(char *, uint64_t, uint64_t))(v160 + 192))(v100, v165, v160);
      v161(v132, v165);
      ((void (*)(char *, char *, const char *))v163)(v98, v100, v120);
      char v166 = ((uint64_t (*)(char *, uint64_t (**)(char *, uint64_t, uint64_t), const char *, uint64_t))v224)(v98, v227, v120, AssociatedConformanceWitness);
      ((void (*)(char *, const char *))v237)(v98, v120);
      uint64_t v167 = v160;
      unint64_t v155 = v100;
      unint64_t v154 = v163;
      uint64_t v7 = v167;
      if ((v166 & 1) == 0) {
        goto LABEL_22;
      }
    }
    __break(1u);
LABEL_33:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unint64_t v155 = v232;
LABEL_22:
  unint64_t v168 = v204;
  uint64_t v169 = v212;
  ((void (*)(char *, char *, Class *))v199[0])(v204, (char *)v227 + *((int *)v218 + 11), v212);
  (*(void (**)(char *, Class *))(v206 + 8))(v210, v211);
  unint64_t v170 = v216;
  if (v200(v168, 1, v216) == 1)
  {
    ((void (*)(char *, const char *))v237)(v155, v120);
    (*(void (**)(char *, Class *))(v209 + 8))(v168, v169);
    unint64_t v171 = v233;
    uint64_t v172 = v240;
    uint64_t v173 = v213;
    uint64_t result = v207;
    uint64_t v78 = v238;
    goto LABEL_26;
  }
  (*(void (**)(char *, char *, const char *))(v217 + 32))(v203, v168, v170);
  uint64_t v175 = v132;
  unint64_t v176 = v98;
  uint64_t v177 = v215;
  unint64_t v178 = v155;
  uint64_t v179 = v240;
  (*(void (**)(char *, uint64_t, uint64_t))(v215 + 16))(v175, v239, v240);
  (*(void (**)(char *, char *, const char *))(v214 + 32))(v176, v178, v120);
  long long v180 = (void (*)(char *, void))(*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v7 + 80))(v241, v176, v179, v7);
  uint64_t v181 = v208;
  uint64_t v182 = v230;
  uint64_t v183 = v120;
  uint64_t v184 = v231;
  (*(void (**)(char *))(v208 + 16))(v230);
  v180(v241, 0);
  ((void (*)(char *, const char *))v237)(v176, v183);
  (*(void (**)(char *, uint64_t))(v177 + 8))(v175, v179);
  unint64_t v171 = v233;
  uint64_t v185 = v205;
  ((void (*)(uint64_t, int **))v233[8])(v184, v233);
  unint64_t v186 = v203;
  uint64_t v187 = ((uint64_t (*)(char *, char *, uint64_t, int **))v171[19])(v185, v203, v184, v171);
  long long v188 = *(void (**)(char *, const char *))(v217 + 8);
  char v189 = v185;
  uint64_t v98 = (char *)v216;
  v188(v189, v216);
  long long v190 = *(void (**)(char *, uint64_t))(v181 + 8);
  uint64_t v100 = (char *)(v181 + 8);
  v190(v182, v184);
  v188(v186, v98);
  uint64_t v78 = v238 + v187;
  uint64_t v173 = v213;
  uint64_t result = v207;
  if (!__OFADD__(v238, v187))
  {
    uint64_t v172 = v240;
LABEL_26:
    if ((static FlattenSequence<>.Index.< infix(_:_:)(result, v173, v172, v7, v171) & 1) == 0) {
      return v78;
    }
    BOOL v191 = __OFSUB__(0, v78);
    uint64_t v78 = -v78;
    if (!v191) {
      return v78;
    }
    __break(1u);
    goto LABEL_30;
  }
  __break(1u);
  return result;
}

uint64_t FlattenSequence<>._advanceIndex(_:step:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5)
{
  uint64_t v10 = type metadata accessor for FlattenSequence<>.Index(0, *(void *)(a3 + 16), a4, (uint64_t)a5);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v16 - v12;
  uint64_t v14 = (char *)&v16 - v12;
  if (a2 < 0) {
    FlattenSequence<>._index(before:)(a1, a3, a4, a5, v14);
  }
  else {
    FlattenSequence<>._index(after:)(a1, a3, a4, a5, (uint64_t)v14);
  }
  (*(void (**)(char *, Class *))(v11 + 8))(a1, v10);
  return (*(uint64_t (**)(char *, char *, Class *))(v11 + 32))(a1, v13, v10);
}

uint64_t static RangeExpression.~= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 32))(a2, a3, a4) & 1;
}

uint64_t FlattenSequence<>._ensureBidirectional(step:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v23 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  Swift::UInt64 v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v22 - v10;
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v12, v13);
  uint64_t result = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v22 - v17;
  if (a1 < 0)
  {
    uint64_t v19 = a1;
    uint64_t v20 = v16;
    (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v5, a3);
    (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v5, a3);
    (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v11, v19, v9, v5, a3);
    uint64_t v21 = *(void (**)(char *, const char *))(v23 + 8);
    v21(v9, AssociatedTypeWitness);
    v21(v11, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, Class *))(v20 + 8))(v18, v14);
  }
  return result;
}

uint64_t FlattenSequence<>.index(_:offsetBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, char *a6@<X8>)
{
  uint64_t v11 = *(void *)(a3 + 16);
  uint64_t v45 = a5;
  uint64_t v12 = type metadata accessor for FlattenSequence<>.Index(0, v11, a4, (uint64_t)a5);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v36 - v14;
  uint64_t v42 = (void (*)(void, void))v11;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, v11, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v41 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v39 = (char *)&v36 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v20 = (char *)&v36 - v19;
  uint64_t v40 = v21;
  uint64_t v24 = type metadata accessor for Optional(0, v21, v22, v23);
  uint64_t v37 = (uint64_t)*(v24 - 1);
  uint64_t v38 = v24;
  MEMORY[0x1F4188790](v24);
  uint64_t v43 = (char *)&v36 - v25;
  uint64_t v44 = v13;
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, Class *))(v13 + 16))(a6, a1, v12);
  unint64_t v27 = (a2 > 0) | (unint64_t)(a2 >> 63);
  if ((v27 & 0x8000000000000000) != 0)
  {
    uint64_t v28 = *(void (**)(void, uint64_t))(a4 + 72);
    uint64_t v36 = v20;
    uint64_t v29 = v42;
    v28(v42, a4);
    uint64_t v30 = v39;
    (*(void (**)(void, uint64_t))(a4 + 64))(v29, a4);
    (*(void (**)(char *, unint64_t, char *, void (*)(void, void), uint64_t))(a4 + 144))(v36, (a2 > 0) | (unint64_t)(a2 >> 63), v30, v29, a4);
    uint64_t v42 = *(void (**)(void, void))(v41 + 8);
    uint64_t v31 = v30;
    uint64_t v32 = v40;
    v42(v31, v40);
    v42(v36, v32);
    uint64_t result = (*(uint64_t (**)(char *, Class *))(v37 + 8))(v43, v38);
    if ((a2 & 0x8000000000000000) == 0)
    {
LABEL_3:
      if (!a2) {
        return result;
      }
      goto LABEL_8;
    }
  }
  else if ((a2 & 0x8000000000000000) == 0)
  {
    goto LABEL_3;
  }
  BOOL v33 = __OFSUB__(0, a2);
  a2 = -a2;
  if (v33)
  {
    __break(1u);
    return result;
  }
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_8:
  uint64_t v34 = (void (**)(char *, Class *))(v44 + 8);
  uint64_t v35 = (uint64_t (**)(char *, char *, Class *))(v44 + 32);
  do
  {
    if ((v27 & 0x8000000000000000) != 0) {
      FlattenSequence<>._index(before:)(a6, a3, a4, v45, v15);
    }
    else {
      FlattenSequence<>._index(after:)(a6, a3, a4, v45, (uint64_t)v15);
    }
    (*v34)(a6, v12);
    uint64_t result = (*v35)(a6, v15, v12);
    --a2;
  }
  while (a2);
  return result;
}

uint64_t FlattenSequence<>.formIndex(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5)
{
  uint64_t v10 = type metadata accessor for FlattenSequence<>.Index(0, *(void *)(a3 + 16), a4, (uint64_t)a5);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v15 - v12;
  FlattenSequence<>.index(_:offsetBy:)(a1, a2, a3, a4, a5, (char *)&v15 - v12);
  (*(void (**)(uint64_t, Class *))(v11 + 8))(a1, v10);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v11 + 32))(a1, v13, v10);
}

uint64_t FlattenSequence<>.index(_:offsetBy:limitedBy:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, int **a5@<X5>, char *a6@<X8>)
{
  uint64_t v108 = a2;
  uint64_t v10 = *(int ***)(a4 + 8);
  uint64_t v105 = a3;
  uint64_t v11 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v11, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v12 = swift_getAssociatedTypeWitness(0, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v98 = (void (**)(char *, char *, Class *))*((void *)v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v86 = (char *)v81 - v13;
  uint64_t v94 = v14;
  uint64_t v17 = type metadata accessor for Optional(0, v14, v15, v16);
  uint64_t v100 = (Class *)*(v17 - 1);
  MEMORY[0x1F4188790](v17);
  uint64_t v89 = (char *)v81 - v18;
  uint64_t v96 = v19;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v19, v19, 0, 0);
  uint64_t v99 = (char *)*(TupleTypeMetadata2 - 1);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v91 = (char *)v81 - v20;
  uint64_t v21 = swift_getAssociatedTypeWitness(0, (int **)a4, v11, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v22 = *((void *)v21 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)v81 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  unint64_t v27 = (char *)v81 - v26;
  uint64_t v112 = v28;
  uint64_t v31 = type metadata accessor for Optional(0, v28, v29, v30);
  uint64_t v102 = (Class *)*(v31 - 1);
  uint64_t v103 = v31;
  MEMORY[0x1F4188790](v31);
  uint64_t v114 = (char *)v81 - v32;
  uint64_t v115 = v11;
  uint64_t v111 = a4;
  uint64_t v113 = a5;
  BOOL v33 = type metadata accessor for FlattenSequence<>.Index(0, v11, a4, (uint64_t)a5);
  uint64_t v34 = (uint64_t)*(v33 - 1);
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v104 = (char *)v81 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v39 = (char *)v81 - v38;
  uint64_t v40 = MEMORY[0x1F4188790](v37);
  uint64_t v42 = (char *)v81 - v41;
  MEMORY[0x1F4188790](v40);
  uint64_t v43 = *(uint64_t (**)(void))(v34 + 16);
  uint64_t v95 = (char *)v81 - v44;
  uint64_t v106 = v43;
  uint64_t v107 = v34 + 16;
  uint64_t result = v43();
  unint64_t v109 = (a1 > 0) | (unint64_t)(a1 >> 63);
  uint64_t v110 = v42;
  uint64_t v83 = a6;
  if ((v109 & 0x8000000000000000) != 0)
  {
    uint64_t v46 = v111;
    uint64_t v47 = v115;
    (*(void (**)(uint64_t, uint64_t))(v111 + 72))(v115, v111);
    (*(void (**)(uint64_t, uint64_t))(v46 + 64))(v47, v46);
    uint64_t v48 = v47;
    a6 = v83;
    (*(void (**)(char *, unint64_t, char *, uint64_t, uint64_t))(v46 + 144))(v27, v109, v25, v48, v46);
    uint64_t v49 = *(void (**)(char *, uint64_t))(v22 + 8);
    uint64_t v50 = v34;
    uint64_t v51 = v112;
    v49(v25, v112);
    uint64_t v52 = v51;
    uint64_t v34 = v50;
    uint64_t v42 = v110;
    v49(v27, v52);
    uint64_t result = ((uint64_t (*)(char *, Class *))v102[1])(v114, v103);
    if ((a1 & 0x8000000000000000) == 0)
    {
LABEL_3:
      if (!a1)
      {
        (*(void (**)(char *, char *, Class *))(v34 + 32))(a6, v95, v33);
        return (*(uint64_t (**)(char *, void, uint64_t, Class *))(v34 + 56))(a6, 0, 1, v33);
      }
      goto LABEL_8;
    }
  }
  else if ((a1 & 0x8000000000000000) == 0)
  {
    goto LABEL_3;
  }
  BOOL v53 = __OFSUB__(0, a1);
  a1 = -a1;
  if (v53)
  {
    __break(1u);
    return result;
  }
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_8:
  uint64_t v103 = *(Class **)(swift_getAssociatedConformanceWitness(v111, v115, v112, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
  uint64_t v101 = (uint64_t (*)(char *, uint64_t))v103[1];
  uint64_t v102 = v103 + 1;
  uint64_t v114 = (char *)(v34 + 8);
  uint64_t v93 = (void (**)(char *, char *, uint64_t))(v100 + 2);
  unint64_t v92 = (unsigned int (**)(char *, uint64_t, uint64_t))(v98 + 6);
  uint64_t v84 = (void (**)(char *, char *, uint64_t))(v98 + 4);
  uint64_t v88 = (void (**)(char *, uint64_t))(v98 + 1);
  uint64_t v85 = (void (**)(char *, uint64_t))(v100 + 1);
  uint64_t v90 = (void (**)(char *, uint64_t *))(v99 + 8);
  uint64_t v82 = v34;
  uint64_t v98 = (void (**)(char *, char *, Class *))(v34 + 32);
  v81[1] = (v34 + 32) & 0xFFFFFFFFFFFFLL | 0x48D8000000000000;
  uint64_t v54 = v96;
  uint64_t v55 = v91;
  uint64_t v56 = v95;
  uint64_t v99 = v39;
  uint64_t v100 = v33;
  while (1)
  {
    uint64_t v115 = a1;
    uint64_t v59 = v108;
    char v60 = v101(v56, v108);
    uint64_t v61 = v106;
    ((void (*)(char *, char *, Class *))v106)(v42, v56, v33);
    ((void (*)(char *, uint64_t, Class *))v61)(v39, v59, v33);
    if ((v60 & 1) == 0)
    {
      uint64_t v73 = v42;
      char v67 = *(void (**)(char *, Class *))v114;
      (*(void (**)(char *, Class *))v114)(v39, v33);
      v67(v73, v33);
      uint64_t v71 = v115;
      if ((v109 & 0x8000000000000000) != 0) {
        goto LABEL_23;
      }
      goto LABEL_9;
    }
    uint64_t v62 = *((int *)v33 + 11);
    char v63 = &v39[v62];
    unint64_t v64 = &v55[*((int *)TupleTypeMetadata2 + 12)];
    Swift::UInt64 v65 = *v93;
    (*v93)(v55, &v42[v62], v54);
    Swift::UInt64 v66 = v42;
    char v67 = *(void (**)(char *, Class *))v114;
    (*(void (**)(char *, Class *))v114)(v66, v33);
    v65(v64, v63, v54);
    v67(v39, v33);
    char v68 = *v92;
    uint64_t v69 = v94;
    unsigned int v70 = (*v92)(v55, 1, v94);
    uint64_t v71 = v115;
    if (v70 == 1) {
      break;
    }
    char v74 = v89;
    v65(v89, v55, v96);
    if (v68(v64, 1, v69) == 1)
    {
      (*v88)(v74, v69);
      uint64_t v71 = v115;
      uint64_t v56 = v95;
LABEL_19:
      uint64_t v55 = v91;
      (*v90)(v91, TupleTypeMetadata2);
      uint64_t v54 = v96;
      if ((v109 & 0x8000000000000000) != 0) {
        goto LABEL_23;
      }
      goto LABEL_9;
    }
    unint64_t v75 = v86;
    (*v84)(v86, v64, v69);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v113, (uint64_t)AssociatedTypeWitness, v69, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
    char v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v74, v75, v69);
    uint64_t v78 = *v88;
    (*v88)(v75, v69);
    v78(v74, v69);
    uint64_t v79 = v96;
    (*v85)(v55, v96);
    uint64_t v56 = v95;
    if (v77) {
      goto LABEL_26;
    }
    uint64_t v71 = v115;
    uint64_t v54 = v79;
    if ((v109 & 0x8000000000000000) != 0)
    {
LABEL_23:
      uint64_t v57 = v104;
      FlattenSequence<>._index(before:)(v56, v105, v111, v113, v104);
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v57 = v104;
    FlattenSequence<>._index(after:)(v56, v105, v111, v113, (uint64_t)v104);
LABEL_10:
    BOOL v33 = v100;
    v67(v56, v100);
    uint64_t v58 = *v98;
    (*v98)(v56, v57, v33);
    a1 = v71 - 1;
    uint64_t v39 = v99;
    uint64_t v42 = v110;
    if (!a1)
    {
      a6 = v83;
      uint64_t v34 = v82;
      v58(v83, v95, v33);
      return (*(uint64_t (**)(char *, void, uint64_t, Class *))(v34 + 56))(a6, 0, 1, v33);
    }
  }
  unsigned int v72 = v68(v64, 1, v69);
  uint64_t v56 = v95;
  if (v72 != 1) {
    goto LABEL_19;
  }
  (*v85)(v91, v96);
LABEL_26:
  char v80 = v100;
  v67(v56, v100);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, Class *))(v82 + 56))(v83, 1, 1, v80);
}

BOOL FlattenSequence<>.formIndex(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int **a6)
{
  uint64_t v12 = type metadata accessor for FlattenSequence<>.Index(255, *(void *)(a4 + 16), a5, (uint64_t)a6);
  uint64_t v22 = type metadata accessor for Optional(0, (uint64_t)v12, v13, v14);
  uint64_t v15 = (uint64_t)*(v22 - 1);
  MEMORY[0x1F4188790](v22);
  uint64_t v17 = (char *)&v21 - v16;
  FlattenSequence<>.index(_:offsetBy:limitedBy:)(a2, a3, a4, a5, a6, (char *)&v21 - v16);
  uint64_t v18 = (uint64_t)*(v12 - 1);
  (*(void (**)(uint64_t, Class *))(v18 + 8))(a1, v12);
  int v19 = (*(uint64_t (**)(char *, uint64_t, Class *))(v18 + 48))(v17, 1, v12);
  if (v19 == 1)
  {
    (*(void (**)(char *, Class *))(v15 + 8))(v17, v22);
    (*(void (**)(uint64_t, uint64_t, Class *))(v18 + 16))(a1, a3, v12);
  }
  else
  {
    (*(void (**)(uint64_t, char *, Class *))(v18 + 32))(a1, v17, v12);
  }
  return v19 != 1;
}

uint64_t FlattenSequence<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v32 = a5;
  uint64_t v8 = *(void *)(a2 + 16);
  Swift::UInt64 v9 = *(int ***)(a3 + 8);
  uint64_t v31 = associated type descriptor for Sequence.Element;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  BOOL v33 = swift_getAssociatedTypeWitness(255, (int **)a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v34 = type metadata accessor for Optional(0, (uint64_t)v33, v11, v12);
  uint64_t v13 = (uint64_t)*(v34 - 1);
  MEMORY[0x1F4188790](v34);
  uint64_t v15 = (char *)&v30 - v14;
  uint64_t v16 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v17 = *(v16 - 1);
  MEMORY[0x1F4188790](v16);
  int v19 = (char *)&v30 - v18;
  uint64_t v20 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a3 + 80))(v35, a1, v8, a3);
  (*(void (**)(char *))(v17 + 16))(v19);
  v20(v35, 0);
  uint64_t v21 = v8;
  uint64_t v22 = v33;
  uint64_t v23 = type metadata accessor for FlattenSequence<>.Index(0, v21, a3, a4);
  (*(void (**)(char *, uint64_t, Class *))(v13 + 16))(v15, a1 + *((int *)v23 + 11), v34);
  uint64_t v24 = *((void *)v22 - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v24 + 48))(v15, 1, v22) == 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Flatten.swift", 19, 2, 0x19BuLL, 0);
  }
  uint64_t v25 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, char *, uint64_t *, uint64_t))(a4 + 80))(v35, v15, v16, a4);
  uint64_t v27 = v26;
  uint64_t v28 = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 8), (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for Sequence, v31);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v28 - 1) + 16))(v32, v27, v28);
  v25(v35, 0);
  (*(void (**)(char *, uint64_t *))(v17 + 8))(v19, v16);
  return (*(uint64_t (**)(char *, const char *))(v24 + 8))(v15, v22);
}

uint64_t FlattenSequence<>.subscript.getter@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return ClosedRange<>.subscript.getter(a1, a2, a3, a4, (uint64_t (*)(uint64_t, unint64_t))type metadata accessor for FlattenSequence<>.Index, (uint64_t)&protocol witness table for FlattenSequence<A><>.Index, protocol conformance descriptor for <> FlattenSequence<A>, a5);
}

uint64_t ClosedRange<>.subscript.getter@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(uint64_t, unint64_t)@<X4>, uint64_t a6@<X5>, int *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v11 = v8;
  uint64_t v28 = a1;
  uint64_t v16 = a5(255, a2[2]);
  uint64_t v18 = type metadata accessor for Range(0, v16, a6, v17);
  uint64_t v19 = (uint64_t)*(v18 - 1);
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v27 - v20;
  v29[0] = a3;
  v29[1] = a4;
  uint64_t WitnessTable = swift_getWitnessTable(a7, a2, (uint64_t)v29);
  uint64_t v24 = type metadata accessor for Slice(0, (uint64_t)a2, WitnessTable, v23);
  (*(void (**)(uint64_t, uint64_t, unint64_t *))(*(a2 - 1) + 16))(a8 + *((int *)v24 + 10), v11, a2);
  (*(void (**)(char *, uint64_t, Class *))(v19 + 16))(v21, v28, v18);
  uint64_t v25 = *(void (**)(uint64_t, char *, uint64_t))(*(void *)(v16 - 8) + 32);
  v25(a8, v21, v16);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v25)(a8 + *((int *)v24 + 9), &v21[*((int *)v18 + 9)], v16);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  return FlattenSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), *(int ***)(a2 - 16), a3);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return FlattenSequence<>.endIndex.getter(a1, *(void *)(a2 - 8), *(int ***)(a2 - 16), a3);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> FlattenSequence<A>(const char ***a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = (const char **)malloc(0x28uLL);
  *a1 = v8;
  v8[4] = (const char *)FlattenSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*FlattenSequence<>.subscript.read(const char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v10 = *(int ***)(a5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a4 + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v12 = swift_getAssociatedTypeWitness(0, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  *a1 = v12;
  uint64_t v13 = *((void *)v12 - 1);
  a1[1] = (const char *)v13;
  uint64_t v14 = (const char *)malloc(*(void *)(v13 + 64));
  a1[2] = v14;
  FlattenSequence<>.subscript.getter(a2, a3, a4, a5, (uint64_t)v14);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return FlattenSequence<>.subscript.getter(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = type metadata accessor for FlattenSequence<>.Index(255, *(void *)(a1 + 16), *(void *)(a2 - 8), *(void *)(a2 - 16));
  uint64_t v7 = type metadata accessor for Optional(0, (uint64_t)v4, v5, v6);
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, Class *))*((void *)*(v7 - 1) + 7);

  return v8(a3, 1, 1, v7);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8), *(int ***)(a4 - 16), a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char *a5@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, *(void *)(a4 - 8), *(int ***)(a4 - 16), a5);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> FlattenSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return FlattenSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8), *(int ***)(a4 - 16));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> FlattenSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return FlattenSequence<>.index(after:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> FlattenSequence<A>(char *a1, uint64_t a2, uint64_t a3)
{
  return FlattenSequence<>.formIndex(after:)(a1, a2, *(void *)(a3 - 8), *(int ***)(a3 - 16));
}

uint64_t FlattenSequence<>.index(before:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return FlattenSequence<>._index(before:)(a1, a2, *(void *)(a3 + 8), *(int ***)(a4 + 8), a5);
}

uint64_t FlattenSequence<>.formIndex(before:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t v7 = *(int ***)(a4 + 8);
  uint64_t v8 = type metadata accessor for FlattenSequence<>.Index(0, *(void *)(a2 + 16), v6, (uint64_t)v7);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  MEMORY[0x1F4188790](v8);
  uint64_t v11 = (char *)&v13 - v10;
  FlattenSequence<>._index(before:)(a1, a2, v6, v7, (char *)&v13 - v10);
  (*(void (**)(char *, Class *))(v9 + 8))(a1, v8);
  return (*(uint64_t (**)(char *, char *, Class *))(v9 + 32))(a1, v11, v8);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> FlattenSequence<A>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  return FlattenSequence<>.index(before:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> FlattenSequence<A>(char *a1, uint64_t a2, uint64_t a3)
{
  return FlattenSequence<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8), *(int ***)(*(void *)(a4 - 16) + 8), a5);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance <> FlattenSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char *a5@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8), *(int ***)(*(void *)(a4 - 16) + 8), a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> FlattenSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return FlattenSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8), *(int ***)(*(void *)(a4 - 16) + 8));
}

uint64_t static FloatingPoint.ulpOfOne.getter(uint64_t a1, uint64_t a2)
{
  return static FloatingPoint.ulpOfOne.getter(a1, a2);
}

{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  char *v11;
  uint64_t AssociatedConformanceWitness;
  uint64_t v14;

  uint64_t v4 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v7 + 16) + 8) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v14 - v10;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v11, a1, v8);
  (*(void (**)(uint64_t, uint64_t))(a2 + 136))(a1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, a1);
}

uint64_t FloatingPoint.remainder(dividingBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v7, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 216))(a1, a2, a3);
}

{
  uint64_t v4;

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 216))(a1, a2, a3);
}

uint64_t FloatingPoint.truncatingRemainder(dividingBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v7, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 232))(a1, a2, a3);
}

{
  uint64_t v4;

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 232))(a1, a2, a3);
}

uint64_t FloatingPoint.squareRoot()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a3, v3, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 248))(a1, a2);
}

{
  uint64_t v3;

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a3, v3, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 248))(a1, a2);
}

uint64_t FloatingPoint.addingProduct(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, v5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 264))(a1, a2, a3, a4);
}

{
  uint64_t v5;

  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, v5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 264))(a1, a2, a3, a4);
}

uint64_t static FloatingPoint.minimum(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.minimum(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  char v17;
  uint64_t v19;

  uint64_t v8 = a1;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v14 + 24) + 8) + 24))(v11);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v16(v13, a2, a3);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
  }
  else
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
    if ((v17 & 1) == 0) {
      uint64_t v8 = a2;
    }
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v16)(a5, v8, a3);
}

uint64_t static FloatingPoint.maximum(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.maximum(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  char v17;
  uint64_t v19;

  uint64_t v8 = a1;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v14 + 24) + 8) + 40))(v11);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v16(v13, a2, a3);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
  }
  else
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
    if ((v17 & 1) == 0) {
      uint64_t v8 = a2;
    }
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v16)(a5, v8, a3);
}

uint64_t static FloatingPoint.minimumMagnitude(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.minimumMagnitude(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(char *, uint64_t);
  void (*v24)(char *, uint64_t, uint64_t);
  uint64_t v25;
  char v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  uint64_t v29 = a2;
  uint64_t v31 = a5;
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v28 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v28 - v15;
  uint64_t v18 = *(void *)(*(void *)(v17 + 16) + 8);
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v18 + 56);
  uint64_t v30 = v14;
  v19(v20, v18);
  uint64_t v21 = v29;
  v19(a3, v18);
  uint64_t v22 = v21;
  LOBYTE(v21) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 24) + 8) + 24))(v16, v13, a3);
  uint64_t v23 = *(void (**)(char *, uint64_t))(v7 + 8);
  v23(v13, a3);
  v23(v16, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v24(v10, v22, a3);
  if (v21)
  {
    v23(v10, a3);
    uint64_t v25 = v30;
  }
  else
  {
    uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    v23(v10, a3);
    uint64_t v25 = v30;
    if ((v26 & 1) == 0) {
      uint64_t v25 = v22;
    }
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v24)(v31, v25, a3);
}

uint64_t static FloatingPoint.maximumMagnitude(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.maximumMagnitude(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(char *, uint64_t);
  void (*v24)(char *, uint64_t, uint64_t);
  uint64_t v25;
  char v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  uint64_t v29 = a2;
  uint64_t v31 = a5;
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v28 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v28 - v15;
  uint64_t v18 = *(void *)(*(void *)(v17 + 16) + 8);
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v18 + 56);
  uint64_t v30 = v14;
  v19(v20, v18);
  uint64_t v21 = v29;
  v19(a3, v18);
  uint64_t v22 = v21;
  LOBYTE(v21) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 24) + 8) + 40))(v16, v13, a3);
  uint64_t v23 = *(void (**)(char *, uint64_t))(v7 + 8);
  v23(v13, a3);
  v23(v16, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v24(v10, v22, a3);
  if (v21)
  {
    v23(v10, a3);
    uint64_t v25 = v30;
  }
  else
  {
    uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    v23(v10, a3);
    uint64_t v25 = v30;
    if ((v26 & 1) == 0) {
      uint64_t v25 = v22;
    }
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v24)(v31, v25, a3);
}

uint64_t FloatingPoint.rounded(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v7, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 312))(a1, a2, a3);
}

{
  uint64_t v4;

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a4, v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 312))(a1, a2, a3);
}

uint64_t FloatingPoint.nextDown.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](v2);
  uint64_t v8 = (char *)&v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v11 = (char *)&v17 - v10;
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16);
  v14(v9, a1, v13);
  (*(void (**)(uint64_t, uint64_t))(a2 + 320))(a1, a2);
  uint64_t v15 = *(void (**)(char *, uint64_t))(v5 + 8);
  v15(v11, a1);
  v14((uint64_t)v8, a1, v13);
  return ((uint64_t (*)(char *, uint64_t))v15)(v8, a1);
}

{
  char *v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(char *, uint64_t, uint64_t);
  void (*v14)(char *, uint64_t);
  uint64_t v16;

  uint64_t v5 = *(void *)(a1 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)&v16 - v9;
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v13(v2, a1, v12);
  (*(void (**)(uint64_t, uint64_t))(a2 + 320))(a1, a2);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v10, a1);
  v13(v8, a1, v12);
  return ((uint64_t (*)(char *, uint64_t))v14)(v8, a1);
}

uint64_t specialized FloatingPoint.floatingPointClass.getter(float a1)
{
  int v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (SLOWORD(a1) < 0) {
    unsigned int v2 = 5;
  }
  else {
    unsigned int v2 = 6;
  }
  if (SLOWORD(a1) < 0) {
    int v3 = 4;
  }
  else {
    int v3 = 7;
  }
  if ((LOWORD(a1) & 0x3FF) != 0) {
    unsigned int v2 = v3;
  }
  if (SLOWORD(a1) < 0) {
    int v4 = 3;
  }
  else {
    int v4 = 8;
  }
  if (SLOWORD(a1) < 0) {
    int v5 = 2;
  }
  else {
    int v5 = 9;
  }
  if ((SLOWORD(a1) & 0x3FF) != 0) {
    unsigned int v6 = (SLOWORD(a1) >> 9) & 1;
  }
  else {
    unsigned int v6 = v5;
  }
  if (v1 != 31) {
    unsigned int v6 = v4;
  }
  if (v1) {
    return v6;
  }
  else {
    return v2;
  }
}

{
  unsigned int v1;
  int v2;
  int v3;
  int v4;
  unsigned int v5;

  if (a1 < 0.0) {
    int v1 = 5;
  }
  else {
    int v1 = 6;
  }
  if (a1 < 0.0) {
    unsigned int v2 = 4;
  }
  else {
    unsigned int v2 = 7;
  }
  if ((LODWORD(a1) & 0x7FFFFF) != 0) {
    int v1 = v2;
  }
  if (a1 < 0.0) {
    int v3 = 3;
  }
  else {
    int v3 = 8;
  }
  if (a1 < 0.0) {
    int v4 = 2;
  }
  else {
    int v4 = 9;
  }
  if ((LODWORD(a1) & 0x7FFFFF) != 0) {
    int v5 = (LODWORD(a1) >> 22) & 1;
  }
  else {
    int v5 = v4;
  }
  if ((LODWORD(a1) >> 23) != 255) {
    int v5 = v3;
  }
  if ((LODWORD(a1) >> 23)) {
    return v5;
  }
  else {
    return v1;
  }
}

uint64_t specialized FloatingPoint.floatingPointClass.getter(double a1)
{
  uint64_t v1 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (a1 < 0.0) {
    unsigned int v2 = 5;
  }
  else {
    unsigned int v2 = 6;
  }
  if (a1 < 0.0) {
    int v3 = 4;
  }
  else {
    int v3 = 7;
  }
  if ((*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0) {
    unsigned int v2 = v3;
  }
  if (a1 < 0.0) {
    int v4 = 3;
  }
  else {
    int v4 = 8;
  }
  if (a1 < 0.0) {
    int v5 = 2;
  }
  else {
    int v5 = 9;
  }
  if ((*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0) {
    unsigned int v6 = (*(void *)&a1 >> 51) & 1;
  }
  else {
    unsigned int v6 = v5;
  }
  if (v1 != 2047) {
    unsigned int v6 = v4;
  }
  if (v1) {
    return v6;
  }
  else {
    return v2;
  }
}

uint64_t FloatingPoint.floatingPointClass.getter(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(void))(a2 + 416))()) {
    return 0;
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 408))(a1, a2)) {
    return 1;
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 400))(a1, a2))
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a1, a2)) {
      return 2;
    }
    else {
      return 9;
    }
  }
  else if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 368))(a1, a2))
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a1, a2)) {
      return 3;
    }
    else {
      return 8;
    }
  }
  else
  {
    char v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 392))(a1, a2);
    char v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a1, a2);
    if (v6) {
      unsigned int v7 = 5;
    }
    else {
      unsigned int v7 = 6;
    }
    if (v6) {
      unsigned int v8 = 4;
    }
    else {
      unsigned int v8 = 7;
    }
    if (v5) {
      return v8;
    }
    else {
      return v7;
    }
  }
}

Swift::FloatingPointSign_optional __swiftcall FloatingPointSign.init(rawValue:)(Swift::Int rawValue)
{
  if (rawValue == 1) {
    v1.value = Swift_FloatingPointSign_minus;
  }
  else {
    v1.value = Swift_FloatingPointSign_unknownDefault;
  }
  if (rawValue) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t FloatingPointSign.rawValue.getter(char a1)
{
  return a1 & 1;
}

BOOL static FloatingPointSign.== infix(_:_:)(int a1, int a2)
{
  return ((a2 ^ a1) & 1) == 0;
}

uint64_t FloatingPointSign.hashValue.getter(char a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1 & 1);
}

uint64_t Int.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1);
}

void FloatingPointSign.hash(into:)(uint64_t a1, char a2)
{
}

Swift::Int __swiftcall FloatingPointSign._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:_:)(seed, v1 & 1);
}

Swift::Int __swiftcall Int._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:_:)(seed, v1);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance FloatingPointSign()
{
  return specialized static Hasher._hash(seed:_:)(0, *v0);
}

void protocol witness for Hashable.hash(into:) in conformance FloatingPointSign()
{
  Hasher._combine(_:)(*v0);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance FloatingPointSign(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(a1, *v1);
}

void *protocol witness for RawRepresentable.init(rawValue:) in conformance FloatingPointSign@<X0>(void *result@<X0>, char *a2@<X8>)
{
  if (*result == 1) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  if (*result) {
    char v3 = v2;
  }
  else {
    char v3 = 0;
  }
  *a2 = v3;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance FloatingPointSign(void *a1@<X8>)
{
  *a1 = *v1;
}

BOOL static FloatingPointClassification.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

void FloatingPointClassification.hash(into:)(uint64_t a1, unsigned __int8 a2)
{
}

Swift::Int FloatingPointClassification.hashValue.getter(unsigned __int8 a1)
{
  return Hasher._finalize()();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance FloatingPointClassification(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance FloatingPointClassification()
{
  Hasher._combine(_:)(*v0);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance FloatingPointClassification()
{
  Hasher._combine(_:)(*v0);
  return Hasher._finalize()();
}

BOOL static FloatingPointRoundingRule.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void FloatingPointRoundingRule.hash(into:)()
{
  Hasher._combine(_:)(*v0);
}

uint64_t static FloatingPoint.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 336))(a2, a3, a4) & 1;
}

uint64_t static FloatingPoint.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 344))(a2, a3, a4) & 1;
}

uint64_t static FloatingPoint.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 352))(a2, a3, a4) & 1;
}

uint64_t static FloatingPoint.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 344))(a1, a3, a4) & 1;
}

uint64_t static FloatingPoint.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 352))(a1, a3, a4) & 1;
}

uint64_t specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

double specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, Class *a2, uint64_t a3)
{
  uint64_t v85 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v83 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v84 = AssociatedTypeWitness;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v82 = (char *)&v77 - v6;
  unsigned int v7 = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v80 = *((void *)v7 - 1);
  uint64_t v81 = v7;
  uint64_t v8 = MEMORY[0x1F4188790](v7);
  uint64_t v79 = (char *)&v77 - v9;
  uint64_t v10 = (uint64_t)*(a2 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v77 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (unint64_t *)((char *)&v77 - v15);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v78 = (char *)&v77 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (unint64_t *)((char *)&v77 - v20);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v77 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (unint64_t *)((char *)&v77 - v25);
  uint64_t v27 = (*(uint64_t (**)(Class *, uint64_t))(a3 + 96))(a2, a3);
  uint64_t v28 = (*(uint64_t (**)(Class *, uint64_t))(a3 + 104))(a2, a3);
  if (v27 == 11)
  {
    if (v28 == 52)
    {
      uint64_t v32 = v10;
      uint64_t v33 = v85;
      (*(void (**)(unint64_t *, uint64_t, Class *))(v10 + 16))(v16, v85, a2);
      int v34 = swift_dynamicCast((char *)&v86, v16, a2, (const char *)&type metadata for Double, 6uLL);
      _D8 = v86;
      (*(void (**)(char *, uint64_t, Class *))(v10 + 32))(v13, v33, a2);
      if (v34)
      {
        (*(void (**)(char *, Class *))(v10 + 8))(v13, a2);
      }
      else
      {
        uint64_t v57 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
        uint64_t v58 = v79;
        (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
        uint64_t v59 = (uint64_t)v81;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        __int16 v61 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120))(v59);
        (*(void (**)(char *, uint64_t))(v80 + 8))(v58, v59);
        uint64_t v62 = v82;
        (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, Class *))(v32 + 8))(v13, a2);
        uint64_t v63 = (uint64_t)a2;
        uint64_t v64 = (uint64_t)v84;
        uint64_t v65 = swift_getAssociatedConformanceWitness(a3, v63, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)(v65 + 8) + 120))(v64);
        (*(void (**)(char *, uint64_t))(v83 + 8))(v62, v64);
        *(void *)&_D8 = (v57 << 63) | ((unint64_t)(v61 & 0x7FF) << 52) | v66 & 0xFFFFFFFFFFFFFLL;
      }
      return _D8;
    }
LABEL_13:
    uint64_t v41 = v85;
    specialized static BinaryFloatingPoint._convert<A>(from:)(&v86, v85, (uint64_t)a2, a3);
    (*(void (**)(uint64_t, Class *))(v10 + 8))(v41, a2);
    return v86;
  }
  if (v27 == 8)
  {
    if (v28 == 23)
    {
      uint64_t v36 = v10;
      uint64_t v37 = v85;
      (*(void (**)(unint64_t *, uint64_t, Class *))(v10 + 16))(v21, v85, a2);
      int v38 = swift_dynamicCast((char *)&v86, v21, a2, (const char *)&type metadata for Float, 6uLL);
      float v39 = *(float *)&v86;
      uint64_t v40 = v78;
      (*(void (**)(char *, uint64_t, Class *))(v10 + 32))(v78, v37, a2);
      if (v38)
      {
        (*(void (**)(char *, Class *))(v10 + 8))(v40, a2);
        return v39;
      }
      else
      {
        int v67 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
        char v68 = v79;
        (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
        uint64_t v69 = (uint64_t)v81;
        uint64_t v70 = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        unsigned __int8 v71 = (*(uint64_t (**)(uint64_t))(*(void *)(v70 + 8) + 120))(v69);
        (*(void (**)(char *, uint64_t))(v80 + 8))(v68, v69);
        unsigned int v72 = v82;
        (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, Class *))(v36 + 8))(v40, a2);
        uint64_t v73 = (uint64_t)a2;
        uint64_t v74 = (uint64_t)v84;
        uint64_t v75 = swift_getAssociatedConformanceWitness(a3, v73, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        int v76 = (*(uint64_t (**)(uint64_t))(*(void *)(v75 + 8) + 120))(v74);
        (*(void (**)(char *, uint64_t))(v83 + 8))(v72, v74);
        return COERCE_FLOAT((v67 << 31) | (v71 << 23) | v76 & 0x7FFFFF);
      }
    }
    goto LABEL_13;
  }
  if (v27 != 5 || v28 != 10) {
    goto LABEL_13;
  }
  uint64_t v29 = v85;
  (*(void (**)(unint64_t *, uint64_t, Class *))(v10 + 16))(v26, v85, a2);
  int v30 = swift_dynamicCast((char *)&v86, v26, a2, (const char *)&type metadata for Float16, 6uLL);
  _H8 = LOWORD(v86);
  (*(void (**)(char *, uint64_t, Class *))(v10 + 32))(v24, v29, a2);
  if (v30)
  {
    (*(void (**)(char *, Class *))(v10 + 8))(v24, a2);
  }
  else
  {
    __int16 v43 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
    uint64_t v44 = v79;
    (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
    uint64_t v45 = (uint64_t)v81;
    uint64_t v46 = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
    char v47 = (*(uint64_t (**)(uint64_t))(*(void *)(v46 + 8) + 120))(v45);
    (*(void (**)(char *, uint64_t))(v80 + 8))(v44, v45);
    uint64_t v48 = v82;
    (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
    (*(void (**)(char *, Class *))(v10 + 8))(v24, a2);
    uint64_t v49 = (uint64_t)a2;
    uint64_t v50 = (uint64_t)v84;
    uint64_t v51 = swift_getAssociatedConformanceWitness(a3, v49, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
    __int16 v52 = (*(uint64_t (**)(uint64_t))(*(void *)(v51 + 8) + 120))(v50);
    (*(void (**)(char *, uint64_t))(v83 + 8))(v48, v50);
    _H8 = (v43 << 15) | ((v47 & 0x1F) << 10) | v52 & 0x3FF;
  }
  __asm { FCVT            D8, H8 }
  return _D8;
}

float specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, Class *a2, uint64_t a3)
{
  uint64_t v85 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v83 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v84 = AssociatedTypeWitness;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v82 = (char *)&v77 - v6;
  unsigned int v7 = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v80 = *((void *)v7 - 1);
  uint64_t v81 = v7;
  uint64_t v8 = MEMORY[0x1F4188790](v7);
  uint64_t v79 = (char *)&v77 - v9;
  uint64_t v10 = (uint64_t)*(a2 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v77 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (unint64_t *)((char *)&v77 - v15);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v78 = (char *)&v77 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (unint64_t *)((char *)&v77 - v20);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v77 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (unint64_t *)((char *)&v77 - v25);
  uint64_t v27 = (*(uint64_t (**)(Class *, uint64_t))(a3 + 96))(a2, a3);
  uint64_t v28 = (*(uint64_t (**)(Class *, uint64_t))(a3 + 104))(a2, a3);
  if (v27 == 11)
  {
    if (v28 == 52)
    {
      uint64_t v32 = v10;
      uint64_t v33 = v85;
      (*(void (**)(unint64_t *, uint64_t, Class *))(v10 + 16))(v16, v85, a2);
      int v34 = swift_dynamicCast((char *)&v86, v16, a2, (const char *)&type metadata for Double, 6uLL);
      double v35 = v86;
      (*(void (**)(char *, uint64_t, Class *))(v10 + 32))(v13, v33, a2);
      if (v34)
      {
        (*(void (**)(char *, Class *))(v10 + 8))(v13, a2);
        *(float *)&_S8 = v35;
      }
      else
      {
        uint64_t v57 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
        uint64_t v58 = v79;
        (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
        uint64_t v59 = (uint64_t)v81;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        __int16 v61 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120))(v59);
        (*(void (**)(char *, uint64_t))(v80 + 8))(v58, v59);
        uint64_t v62 = v82;
        (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, Class *))(v32 + 8))(v13, a2);
        uint64_t v63 = (uint64_t)a2;
        uint64_t v64 = (uint64_t)v84;
        uint64_t v65 = swift_getAssociatedConformanceWitness(a3, v63, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)(v65 + 8) + 120))(v64);
        (*(void (**)(char *, uint64_t))(v83 + 8))(v62, v64);
        *(float *)&_S8 = COERCE_DOUBLE((v57 << 63) | ((unint64_t)(v61 & 0x7FF) << 52) | v66 & 0xFFFFFFFFFFFFFLL);
      }
      return *(float *)&_S8;
    }
LABEL_13:
    uint64_t v41 = v85;
    specialized static BinaryFloatingPoint._convert<A>(from:)((float *)&v86, v85, (uint64_t)a2, a3);
    (*(void (**)(uint64_t, Class *))(v10 + 8))(v41, a2);
    _S8 = SLODWORD(v86);
    return *(float *)&_S8;
  }
  if (v27 == 8)
  {
    if (v28 == 23)
    {
      uint64_t v37 = v10;
      uint64_t v38 = v85;
      (*(void (**)(unint64_t *, uint64_t, Class *))(v10 + 16))(v21, v85, a2);
      int v39 = swift_dynamicCast((char *)&v86, v21, a2, (const char *)&type metadata for Float, 6uLL);
      _S8 = SLODWORD(v86);
      uint64_t v40 = v78;
      (*(void (**)(char *, uint64_t, Class *))(v10 + 32))(v78, v38, a2);
      if (v39)
      {
        (*(void (**)(char *, Class *))(v10 + 8))(v40, a2);
      }
      else
      {
        int v67 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
        char v68 = v79;
        (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
        uint64_t v69 = (uint64_t)v81;
        uint64_t v70 = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        unsigned __int8 v71 = (*(uint64_t (**)(uint64_t))(*(void *)(v70 + 8) + 120))(v69);
        (*(void (**)(char *, uint64_t))(v80 + 8))(v68, v69);
        unsigned int v72 = v82;
        (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, Class *))(v37 + 8))(v40, a2);
        uint64_t v73 = (uint64_t)a2;
        uint64_t v74 = (uint64_t)v84;
        uint64_t v75 = swift_getAssociatedConformanceWitness(a3, v73, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        int v76 = (*(uint64_t (**)(uint64_t))(*(void *)(v75 + 8) + 120))(v74);
        (*(void (**)(char *, uint64_t))(v83 + 8))(v72, v74);
        _S8 = (v67 << 31) | (v71 << 23) | v76 & 0x7FFFFF;
      }
      return *(float *)&_S8;
    }
    goto LABEL_13;
  }
  if (v27 != 5 || v28 != 10) {
    goto LABEL_13;
  }
  uint64_t v29 = v85;
  (*(void (**)(unint64_t *, uint64_t, Class *))(v10 + 16))(v26, v85, a2);
  int v30 = swift_dynamicCast((char *)&v86, v26, a2, (const char *)&type metadata for Float16, 6uLL);
  _H8 = LOWORD(v86);
  (*(void (**)(char *, uint64_t, Class *))(v10 + 32))(v24, v29, a2);
  if (v30)
  {
    (*(void (**)(char *, Class *))(v10 + 8))(v24, a2);
  }
  else
  {
    __int16 v43 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
    uint64_t v44 = v79;
    (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
    uint64_t v45 = (uint64_t)v81;
    uint64_t v46 = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
    char v47 = (*(uint64_t (**)(uint64_t))(*(void *)(v46 + 8) + 120))(v45);
    (*(void (**)(char *, uint64_t))(v80 + 8))(v44, v45);
    uint64_t v48 = v82;
    (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
    (*(void (**)(char *, Class *))(v10 + 8))(v24, a2);
    uint64_t v49 = (uint64_t)a2;
    uint64_t v50 = (uint64_t)v84;
    uint64_t v51 = swift_getAssociatedConformanceWitness(a3, v49, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
    __int16 v52 = (*(uint64_t (**)(uint64_t))(*(void *)(v51 + 8) + 120))(v50);
    (*(void (**)(char *, uint64_t))(v83 + 8))(v48, v50);
    _H8 = (v43 << 15) | ((v47 & 0x1F) << 10) | v52 & 0x3FF;
  }
  __asm { FCVT            S8, H8 }
  return *(float *)&_S8;
}

{
  const char *AssociatedTypeWitness;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v39;
  uint64_t v40;
  int v41;
  char *v42;
  uint64_t v43;
  int v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t AssociatedConformanceWitness;
  __int16 v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t v80;
  const char *v81;
  char *v82;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  uint64_t v86;

  uint64_t v85 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v83 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v84 = AssociatedTypeWitness;
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v82 = (char *)&v77 - v7;
  uint64_t v8 = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v80 = *((void *)v8 - 1);
  uint64_t v81 = v8;
  uint64_t v9 = MEMORY[0x1F4188790](v8);
  uint64_t v79 = (char *)&v77 - v10;
  uint64_t v11 = (uint64_t)*(a2 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v77 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (unint64_t *)((char *)&v77 - v16);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v78 = (char *)&v77 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (unint64_t *)((char *)&v77 - v21);
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = (char *)&v77 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v27 = (unint64_t *)((char *)&v77 - v26);
  uint64_t v28 = (*(uint64_t (**)(Class *, uint64_t))(a3 + 96))(a2, a3);
  uint64_t v29 = (*(uint64_t (**)(Class *, uint64_t))(a3 + 104))(a2, a3);
  if (v28 == 11)
  {
    if (v29 != 52) {
      goto LABEL_13;
    }
    uint64_t v32 = v11;
    uint64_t v33 = v85;
    (*(void (**)(unint64_t *, uint64_t, Class *))(v11 + 16))(v17, v85, a2);
    int v34 = swift_dynamicCast((char *)&v86, v17, a2, (const char *)&type metadata for Double, 6uLL);
    _D8 = v86;
    (*(void (**)(char *, uint64_t, Class *))(v11 + 32))(v14, v33, a2);
    if (v34)
    {
      (*(void (**)(char *, Class *))(v11 + 8))(v14, a2);
      __asm { FCVT            H8, D8 }
    }
    else
    {
      uint64_t v55 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
      uint64_t v56 = v79;
      (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
      uint64_t v57 = (uint64_t)v81;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      uint64_t v59 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120))(v57);
      (*(void (**)(char *, uint64_t))(v80 + 8))(v56, v57);
      char v60 = v82;
      (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
      (*(void (**)(char *, Class *))(v32 + 8))(v14, a2);
      __int16 v61 = (uint64_t)a2;
      uint64_t v62 = (uint64_t)v84;
      uint64_t v63 = swift_getAssociatedConformanceWitness(a3, v61, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)(v63 + 8) + 120))(v62);
      (*(void (**)(char *, uint64_t))(v83 + 8))(v60, v62);
      _D0 = (v55 << 63) | ((unint64_t)(v59 & 0x7FF) << 52) | v64 & 0xFFFFFFFFFFFFFLL;
      __asm { FCVT            H8, D0 }
    }
  }
  else
  {
    if (v28 != 8)
    {
      if (v28 == 5 && v29 == 10)
      {
        int v30 = v85;
        (*(void (**)(unint64_t *, uint64_t, Class *))(v11 + 16))(v27, v85, a2);
        uint64_t v31 = swift_dynamicCast((char *)&v86, v27, a2, (const char *)&type metadata for Float16, 6uLL);
        LOWORD(_D8) = v86;
        (*(void (**)(char *, uint64_t, Class *))(v11 + 32))(v25, v30, a2);
        if (v31)
        {
          (*(void (**)(char *, Class *))(v11 + 8))(v25, a2);
        }
        else
        {
          uint64_t v45 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
          uint64_t v46 = v79;
          (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
          char v47 = (uint64_t)v81;
          uint64_t v48 = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
          uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)(v48 + 8) + 120))(v47);
          (*(void (**)(char *, uint64_t))(v80 + 8))(v46, v47);
          uint64_t v50 = v82;
          (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
          (*(void (**)(char *, Class *))(v11 + 8))(v25, a2);
          uint64_t v51 = (uint64_t)a2;
          __int16 v52 = (uint64_t)v84;
          BOOL v53 = swift_getAssociatedConformanceWitness(a3, v51, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
          uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)(v53 + 8) + 120))(v52);
          (*(void (**)(char *, uint64_t))(v83 + 8))(v50, v52);
          LODWORD(_D8) = (v45 << 15) | ((v49 & 0x1F) << 10) | v54 & 0x3FF;
        }
        return *(float *)&_D8;
      }
LABEL_13:
      __int16 v43 = v85;
      specialized static BinaryFloatingPoint._convert<A>(from:)((short float *)&v86, v85, (uint64_t)a2, a3);
      (*(void (**)(uint64_t, Class *))(v11 + 8))(v43, a2);
      LOWORD(_D8) = v86;
      return *(float *)&_D8;
    }
    if (v29 != 23) {
      goto LABEL_13;
    }
    int v39 = v11;
    uint64_t v40 = v85;
    (*(void (**)(unint64_t *, uint64_t, Class *))(v11 + 16))(v22, v85, a2);
    uint64_t v41 = swift_dynamicCast((char *)&v86, v22, a2, (const char *)&type metadata for Float, 6uLL);
    LODWORD(_D8) = v86;
    uint64_t v42 = v78;
    (*(void (**)(char *, uint64_t, Class *))(v11 + 32))(v78, v40, a2);
    if (v41)
    {
      (*(void (**)(char *, Class *))(v11 + 8))(v42, a2);
      __asm { FCVT            H8, S8 }
    }
    else
    {
      uint64_t v66 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 16) + 168))(a2);
      int v67 = v79;
      (*(void (**)(Class *, uint64_t))(a3 + 112))(a2, a3);
      char v68 = (uint64_t)v81;
      uint64_t v69 = swift_getAssociatedConformanceWitness(a3, (uint64_t)a2, (uint64_t)v81, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)(v69 + 8) + 120))(v68);
      (*(void (**)(char *, uint64_t))(v80 + 8))(v67, v68);
      unsigned __int8 v71 = v82;
      (*(void (**)(Class *, uint64_t))(a3 + 120))(a2, a3);
      (*(void (**)(char *, Class *))(v39 + 8))(v42, a2);
      unsigned int v72 = (uint64_t)a2;
      uint64_t v73 = (uint64_t)v84;
      uint64_t v74 = swift_getAssociatedConformanceWitness(a3, v72, (uint64_t)v84, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v75 = (*(uint64_t (**)(uint64_t))(*(void *)(v74 + 8) + 120))(v73);
      (*(void (**)(char *, uint64_t))(v83 + 8))(v71, v73);
      _S0 = (v66 << 31) | (v70 << 23) | v75 & 0x7FFFFF;
      __asm { FCVT            H8, S0 }
    }
  }
  return *(float *)&_D8;
}

uint64_t BinaryFloatingPoint.init<A>(_:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, Class *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v110 = a4;
  uint64_t v111 = a6;
  uint64_t v107 = *(void *)(*(void *)(*(void *)(a4 + 16) + 16) + 8);
  uint64_t v108 = a1;
  uint64_t v106 = *(int ***)(v107 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v106, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v104 = (char *)&v94 - v11;
  uint64_t v112 = a2;
  uint64_t v105 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v103 = (char *)&v94 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v94 - v14;
  uint64_t v16 = swift_getAssociatedTypeWitness(0, (int **)a5, (uint64_t)a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v101 = *((void *)v16 - 1);
  uint64_t v102 = v16;
  MEMORY[0x1F4188790](v16);
  uint64_t v100 = (char *)&v94 - v17;
  uint64_t v18 = swift_getAssociatedTypeWitness(0, (int **)a5, (uint64_t)a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v98 = *((void *)v18 - 1);
  uint64_t v99 = v18;
  uint64_t v19 = MEMORY[0x1F4188790](v18);
  uint64_t v97 = (char *)&v94 - v20;
  uint64_t v109 = (uint64_t)*(a3 - 1);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v94 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  uint64_t v26 = (unint64_t *)((char *)&v94 - v25);
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  uint64_t v96 = (char *)&v94 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v31 = (unint64_t *)((char *)&v94 - v30);
  uint64_t v32 = MEMORY[0x1F4188790](v29);
  uint64_t v95 = (char *)&v94 - v33;
  MEMORY[0x1F4188790](v32);
  double v35 = (unint64_t *)((char *)&v94 - v34);
  uint64_t v36 = (*(uint64_t (**)(Class *, uint64_t))(a5 + 96))(a3, a5);
  uint64_t v37 = (*(uint64_t (**)(Class *, uint64_t))(a5 + 104))(a3, a5);
  if (v36 == 11)
  {
    if (v37 != 52) {
      goto LABEL_13;
    }
    uint64_t v44 = v108;
    uint64_t v45 = v109;
    (*(void (**)(unint64_t *, char *, Class *))(v109 + 16))(v26, v108, a3);
    int v46 = swift_dynamicCast((char *)v115, v26, a3, (const char *)&type metadata for Double, 6uLL);
    double v47 = v115[0];
    uint64_t v48 = v23;
    (*(void (**)(char *, char *, Class *))(v45 + 32))(v23, v44, a3);
    if (v46)
    {
      (*(void (**)(char *, Class *))(v45 + 8))(v23, a3);
    }
    else
    {
      uint64_t v76 = (*(uint64_t (**)(Class *))(*(void *)(a5 + 16) + 168))(a3);
      uint64_t v77 = v97;
      (*(void (**)(Class *, uint64_t))(a5 + 112))(a3, a5);
      uint64_t v78 = (uint64_t)v99;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, (uint64_t)a3, (uint64_t)v99, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      __int16 v80 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120))(v78);
      (*(void (**)(char *, uint64_t))(v98 + 8))(v77, v78);
      uint64_t v81 = v100;
      (*(void (**)(Class *, uint64_t))(a5 + 120))(a3, a5);
      (*(void (**)(char *, Class *))(v45 + 8))(v48, a3);
      uint64_t v82 = (uint64_t)v102;
      uint64_t v83 = swift_getAssociatedConformanceWitness(a5, (uint64_t)a3, (uint64_t)v102, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v84 = (*(uint64_t (**)(uint64_t))(*(void *)(v83 + 8) + 120))(v82);
      (*(void (**)(char *, uint64_t))(v101 + 8))(v81, v82);
      *(void *)&double v47 = (v76 << 63) | ((unint64_t)(v80 & 0x7FF) << 52) | v84 & 0xFFFFFFFFFFFFFLL;
    }
    return (*(uint64_t (**)(double))(v110 + 72))(v47);
  }
  else
  {
    if (v36 != 8)
    {
      if (v36 == 5 && v37 == 10)
      {
        uint64_t v38 = v108;
        uint64_t v39 = v109;
        (*(void (**)(unint64_t *, char *, Class *))(v109 + 16))(v35, v108, a3);
        int v40 = swift_dynamicCast((char *)&v113, v35, a3, (const char *)&type metadata for Float16, 6uLL);
        _H8 = v113;
        uint64_t v42 = v95;
        (*(void (**)(char *, char *, Class *))(v39 + 32))(v95, v38, a3);
        if (v40)
        {
          (*(void (**)(char *, Class *))(v39 + 8))(v42, a3);
        }
        else
        {
          __int16 v63 = (*(uint64_t (**)(Class *))(*(void *)(a5 + 16) + 168))(a3);
          uint64_t v64 = v97;
          (*(void (**)(Class *, uint64_t))(a5 + 112))(a3, a5);
          uint64_t v65 = (uint64_t)v99;
          uint64_t v66 = swift_getAssociatedConformanceWitness(a5, (uint64_t)a3, (uint64_t)v99, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
          char v67 = (*(uint64_t (**)(uint64_t))(*(void *)(v66 + 8) + 120))(v65);
          (*(void (**)(char *, uint64_t))(v98 + 8))(v64, v65);
          char v68 = v100;
          (*(void (**)(Class *, uint64_t))(a5 + 120))(a3, a5);
          (*(void (**)(char *, Class *))(v39 + 8))(v42, a3);
          uint64_t v69 = (uint64_t)v102;
          uint64_t v70 = swift_getAssociatedConformanceWitness(a5, (uint64_t)a3, (uint64_t)v102, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
          __int16 v71 = (*(uint64_t (**)(uint64_t))(*(void *)(v70 + 8) + 120))(v69);
          (*(void (**)(char *, uint64_t))(v101 + 8))(v68, v69);
          _H8 = (v63 << 15) | ((v67 & 0x1F) << 10) | v71 & 0x3FF;
        }
        __asm { FCVT            S0, H8 }
        return (*(uint64_t (**)(__n128))(v110 + 64))(_Q0);
      }
LABEL_13:
      uint64_t v55 = v108;
      uint64_t v56 = v112;
      static BinaryFloatingPoint._convert<A>(from:)(v15, v108, v112, (uint64_t)a3, v110, a5);
      (*(void (**)(char *, Class *))(v109 + 8))(v55, a3);
      uint64_t v57 = v106;
      uint64_t v58 = swift_getAssociatedConformanceWitness((uint64_t)v106, v56, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v59 = v104;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v58 + 8))(&qword_18162B0C0, 512, AssociatedTypeWitness, v58);
      char v60 = v103;
      ((void (*)(char *, uint64_t, int **))v57[3])(v59, v56, v57);
      (*(void (**)(char *, char *, uint64_t))(v107 + 64))(v15, v60, v56);
      __int16 v61 = *(void (**)(char *, uint64_t))(v105 + 8);
      v61(v60, v56);
      return ((uint64_t (*)(char *, uint64_t))v61)(v15, v56);
    }
    if (v37 != 23) {
      goto LABEL_13;
    }
    uint64_t v49 = v108;
    uint64_t v50 = v109;
    (*(void (**)(unint64_t *, char *, Class *))(v109 + 16))(v31, v108, a3);
    int v51 = swift_dynamicCast((char *)&v114, v31, a3, (const char *)&type metadata for Float, 6uLL);
    int v52 = v114;
    BOOL v53 = v96;
    (*(void (**)(char *, char *, Class *))(v50 + 32))(v96, v49, a3);
    if (v51)
    {
      (*(void (**)(char *, Class *))(v50 + 8))(v53, a3);
    }
    else
    {
      int v85 = (*(uint64_t (**)(Class *))(*(void *)(a5 + 16) + 168))(a3);
      double v86 = v97;
      (*(void (**)(Class *, uint64_t))(a5 + 112))(a3, a5);
      uint64_t v87 = (uint64_t)v99;
      uint64_t v88 = swift_getAssociatedConformanceWitness(a5, (uint64_t)a3, (uint64_t)v99, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      int v89 = (*(unsigned __int8 (**)(uint64_t))(*(void *)(v88 + 8) + 120))(v87);
      (*(void (**)(char *, uint64_t))(v98 + 8))(v86, v87);
      uint64_t v90 = v100;
      (*(void (**)(Class *, uint64_t))(a5 + 120))(a3, a5);
      (*(void (**)(char *, Class *))(v50 + 8))(v53, a3);
      uint64_t v91 = (uint64_t)v102;
      uint64_t v92 = swift_getAssociatedConformanceWitness(a5, (uint64_t)a3, (uint64_t)v102, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      int v93 = (*(uint64_t (**)(uint64_t))(*(void *)(v92 + 8) + 120))(v91);
      (*(void (**)(char *, uint64_t))(v101 + 8))(v90, v91);
      int v52 = (v85 << 31) | (v89 << 23) | v93 & 0x7FFFFF;
    }
    v54.n128_u32[0] = v52;
    return (*(uint64_t (**)(__n128))(v110 + 64))(v54);
  }
}

uint64_t BinaryFloatingPoint.init<A>(_:)@<X0>(char *a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return BinaryFloatingPoint.init<A>(_:)(a1, a4, a2, a5, a3, a6);
}

uint64_t BinaryFloatingPoint.init<A>(exactly:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return BinaryFloatingPoint.init<A>(exactly:)(a1, a4, a2, a5, a3, a6);
}

{
  int **v9;
  const char *AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint64_t (**v86)(uint64_t, void);
  char *v87;
  char *v88;
  void (*v89)(char *, uint64_t, uint64_t);
  void (*v90)(char *, uint64_t);
  uint64_t v91;
  void (*v92)(char *, uint64_t);
  uint64_t v93;
  char v94;
  uint64_t v95;
  char *v96;
  int **v97;
  char *v98;
  int *v99;
  char *v100;
  uint64_t (**v101)(uint64_t, void);
  uint64_t v102;
  uint64_t (*v103)(uint64_t, uint64_t);
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int (*v107)(uint64_t *, uint64_t);
  uint64_t *v108;
  unsigned int v109;
  char v110;
  uint64_t v111;
  char v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  uint64_t (*v115)(uint64_t *, uint64_t);
  uint64_t v116;
  char *v117;
  char v118;
  uint64_t v120;
  char *v121;
  char *v122;
  char *v123;
  void (*v124)(char *, uint64_t *);
  char *v125;
  char *v126;
  char *v127;
  char *v128;
  void (*v129)(char *, uint64_t *);
  char *v130;
  char *v131;
  char *v132;
  int **v133;
  const char *v134;
  uint64_t AssociatedConformanceWitness;
  char *v136;
  char *v137;
  char *v138;
  uint64_t v139;
  void (*v140)(char *, uint64_t);
  char *v141;
  uint64_t v142;
  char *v143;
  int **v144;
  int **v145;
  const char *v146;
  uint64_t v147;
  char *v148;
  char *v149;
  char *v150;
  uint64_t v151;
  uint64_t v152;
  void (*v153)(char *, uint64_t *);
  char *v154;
  char *v155;
  char *v156;
  char *v157;
  char v158;
  void (*v159)(char *, uint64_t);
  uint64_t v160;
  char *v161;
  void (*v162)(char *, uint64_t *);
  char *v163;
  char *v164;
  char *v165;
  uint64_t v166;
  char *v167;
  uint64_t (*v168)(uint64_t, uint64_t);
  uint64_t v169;
  char v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  char *v174;
  uint64_t v175;
  uint64_t v176;
  char *v177;
  char *v178;
  char *v179;
  void (*v180)(char *, uint64_t *);
  char *v181;
  uint64_t v182;
  char *v183;
  char *v184;
  char *v185;
  uint64_t v186;
  char *v187;
  void (*v188)(char *, uint64_t *);
  char v189;
  char *v190;
  char *v191;
  uint64_t v192;
  char *v193;
  uint64_t (*v194)(uint64_t *, uint64_t);
  char v195;
  uint64_t v196;
  char *v197;
  uint64_t v198;
  char *v199;
  uint64_t v200;
  uint64_t v201;
  char *v202;
  uint64_t *v203;
  char *v204;
  char v205;
  void (*v206)(char *, uint64_t *);
  uint64_t v207;
  char *v208;
  void (*v209)(char *, uint64_t);
  uint64_t v210;
  char *v211;
  char *v212;
  uint64_t v213;
  char *v214;
  uint64_t v215;
  char *v216;
  int **v217;
  const char *v218;
  uint64_t v219;
  char *v220;
  char *v221;
  char *v222;
  uint64_t v223;
  void (*v224)(char *, uint64_t);
  char *v225;
  uint64_t v226;
  char *v227;
  int **v228;
  const char *v229;
  uint64_t v230;
  char *v231;
  char *v232;
  uint64_t v233;
  void (*v234)(char *, uint64_t *);
  char *v235;
  char *v236;
  void (*v237)(char *, char *, uint64_t *);
  char *v238;
  uint64_t v239;
  char *v240;
  void (*v241)(char *, uint64_t);
  int **v242;
  uint64_t *v243;
  const char *v244;
  uint64_t v245;
  char *v246;
  char *v247;
  char *v248;
  uint64_t v249;
  char *v250;
  uint64_t v251;
  char *v252;
  uint64_t v253;
  char *v254;
  int **v255;
  const char *v256;
  uint64_t v257;
  char *v258;
  char *v259;
  uint64_t v260;
  void (*v261)(char *, uint64_t);
  uint64_t v262;
  char *v263;
  uint64_t *v264;
  char *v265;
  uint64_t v266;
  char *v267;
  char v268;
  void (*v269)(char *, uint64_t);
  char *v270;
  uint64_t v271;
  uint64_t v272;
  char *v273;
  char *v274;
  uint64_t v275;
  void (*v276)(char *, uint64_t *);
  char *v277;
  char *v278;
  uint64_t v279;
  int **v280;
  char *v281;
  char *v282;
  uint64_t v283;
  void (*v284)(char *, uint64_t *);
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  unint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  char *v292;
  uint64_t v293;
  char *v294;
  uint64_t v295;
  void v296[2];
  uint64_t (*v297)(uint64_t *, uint64_t);
  uint64_t (*v298)(uint64_t, uint64_t);
  void (*v299)(uint64_t, uint64_t);
  unsigned int (*v300)(uint64_t *, uint64_t);
  uint64_t v301;
  uint64_t (*v302)(uint64_t, uint64_t);
  int *v303;
  char *v304;
  char *v305;
  char *v306;
  char *v307;
  char *v308;
  uint64_t (**v309)(uint64_t, void);
  char *v310;
  char *v311;
  char *v312;
  char *v313;
  char *v314;
  char *v315;
  char *v316;
  char *v317;
  char *v318;
  char *v319;
  const char *v320;
  char *v321;
  int **v322;
  const char *v323;
  char *v324;
  int **v325;
  char *v326;
  char *v327;
  uint64_t v328;
  char *v329;
  char *v330;
  char *v331;
  char *v332;
  char *v333;
  char *v334;
  char *v335;
  uint64_t v336;
  char *v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t *v342;
  int **v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t *v351;

  v350 = a1;
  v345 = a4;
  v346 = a6;
  uint64_t v9 = *(int ***)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  v343 = v9;
  v339 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v9, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  v328 = *(void *)(v339 + 24);
  v325 = *(int ***)(v328 + 16);
  uint64_t v323 = swift_getAssociatedTypeWitness(0, v325, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v323);
  uint64_t v324 = (char *)v296 - v11;
  v344 = a5;
  uint64_t v12 = *(void *)(a5 + 16);
  v347 = a3;
  uint64_t v13 = swift_getAssociatedTypeWitness(255, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v338 = *(void *)(swift_getAssociatedConformanceWitness(v12, a3, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  v322 = *(int ***)(*(void *)(v338 + 24) + 16);
  v320 = swift_getAssociatedTypeWitness(0, v322, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v320);
  unint64_t v321 = (char *)v296 - v14;
  v342 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v336 = *(v342 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v342);
  v317 = (char *)v296 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v316 = (char *)v296 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v333 = (char *)v296 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v327 = (char *)v296 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v326 = (char *)v296 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v314 = (char *)v296 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v315 = (char *)v296 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  v332 = (char *)v296 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v318 = (char *)v296 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v319 = (char *)v296 - v34;
  double v35 = MEMORY[0x1F4188790](v33);
  v335 = (char *)v296 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  v337 = (char *)v296 - v38;
  v349 = a2;
  v348 = *(void *)(a2 - 8);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  v331 = (char *)v296 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v329 = (char *)v296 - v42;
  __int16 v43 = MEMORY[0x1F4188790](v41);
  uint64_t v330 = (char *)v296 - v44;
  MEMORY[0x1F4188790](v43);
  v334 = (char *)v296 - v45;
  int v46 = swift_checkMetadataState(0, (uint64_t)v13);
  double v47 = *(v46 - 1);
  v340 = (uint64_t)v46;
  v341 = v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v311 = (char *)v296 - ((v49 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v313 = (char *)v296 - v51;
  int v52 = MEMORY[0x1F4188790](v50);
  v312 = (char *)v296 - v53;
  __n128 v54 = MEMORY[0x1F4188790](v52);
  v310 = (char *)v296 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  uint64_t v58 = (char *)v296 - v57;
  uint64_t v59 = MEMORY[0x1F4188790](v56);
  __int16 v61 = (char *)v296 - v60;
  uint64_t v62 = MEMORY[0x1F4188790](v59);
  uint64_t v64 = (char *)v296 - v63;
  MEMORY[0x1F4188790](v62);
  uint64_t v66 = (char *)v296 - v65;
  char v67 = *(void *)(v347 - 8);
  char v68 = MEMORY[0x1F4188790](v347);
  uint64_t v70 = (char *)v296 - ((v69 + 15) & 0xFFFFFFFFFFFFFFF0);
  __int16 v71 = MEMORY[0x1F4188790](v68);
  uint64_t v73 = (char *)v296 - v72;
  uint64_t v74 = v71;
  if (((*(uint64_t (**)(void))(v12 + 408))() & 1) == 0)
  {
    v308 = v73;
    v304 = v61;
    v305 = v58;
    v309 = (uint64_t (**)(uint64_t, void))v12;
    v307 = v66;
    v306 = v64;
    uint64_t v78 = v344;
    uint64_t v79 = (*(uint64_t (**)(uint64_t, uint64_t))(v344 + 96))(v74, v344);
    __int16 v80 = v345;
    uint64_t v81 = v349;
    uint64_t v82 = v74;
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v345 + 96))(v349, v345) >= v79)
    {
      int v85 = (*(uint64_t (**)(uint64_t))(v78 + 104))(v74);
      uint64_t v83 = v81;
      uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(v80 + 104))(v81, v80) < v85;
    }
    else
    {
      uint64_t v83 = v81;
      uint64_t v84 = 1;
    }
    double v86 = v309;
    uint64_t v87 = v70;
    uint64_t v88 = v308;
    int v89 = *(void (**)(char *, uint64_t, uint64_t))(v67 + 16);
    v89(v308, v350, v82);
    if (v84) {
      LOBYTE(v84) = v86[47](v82, v86);
    }
    uint64_t v92 = *(void (**)(char *, uint64_t))(v67 + 8);
    uint64_t v91 = v67 + 8;
    uint64_t v90 = v92;
    v92(v88, v82);
    v89(v87, v350, v82);
    int v93 = v82;
    if ((v84 & 1) == 0)
    {
      v90(v87, v82);
      uint64_t v77 = v83;
      uint64_t v95 = v345;
      uint64_t v76 = v346;
      goto LABEL_15;
    }
    uint64_t v94 = v86[48](v82, v86);
    v90(v87, v82);
    uint64_t v77 = v83;
    uint64_t v95 = v345;
    uint64_t v76 = v346;
    if (v94)
    {
LABEL_15:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v95 + 80))(v350, v93, v344, v77, v95);
      uint64_t v75 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v348 + 56))(v76, v75, 1, v77);
    }
    v299 = (void (*)(uint64_t, uint64_t))v90;
    v296[1] = v91;
    uint64_t v96 = v307;
    v86[22](v93, v86);
    uint64_t v97 = v343;
    uint64_t v98 = v334;
    ((void (*)(uint64_t, int **))v343[19])(v83, v343);
    uint64_t v99 = v97[22];
    uint64_t v100 = v337;
    v308 = (char *)(v97 + 22);
    v303 = v99;
    ((void (*)(uint64_t, int **))v99)(v83, v97);
    uint64_t v101 = *(uint64_t (***)(uint64_t, void))(v348 + 8);
    v334 = (char *)(v348 + 8);
    v309 = v101;
    ((void (*)(char *, uint64_t))v101)(v98, v83);
    uint64_t v102 = v338;
    uint64_t v104 = v338 + 64;
    uint64_t v103 = *(uint64_t (**)(uint64_t, uint64_t))(v338 + 64);
    uint64_t v105 = v340;
    LODWORD(v97) = v103(v340, v338);
    uint64_t v106 = v339;
    uint64_t v107 = *(unsigned int (**)(uint64_t *, uint64_t))(v339 + 64);
    uint64_t v108 = v342;
    v301 = v339 + 64;
    v300 = v107;
    uint64_t v109 = v107(v342, v339);
    v302 = v103;
    if ((v97 ^ v109))
    {
      v296[0] = v104;
      uint64_t v110 = v103(v105, v102);
      uint64_t v111 = v102;
      uint64_t v112 = v110;
      __int16 v113 = *(uint64_t (**)(uint64_t, uint64_t))(v102 + 128);
      int v114 = v113(v105, v111);
      uint64_t v115 = *(uint64_t (**)(uint64_t *, uint64_t))(v106 + 128);
      uint64_t v116 = v115(v108, v106);
      v298 = v113;
      v297 = v115;
      if (v112)
      {
        if (v116 >= v114)
        {
          uint64_t v133 = v322;
          uint64_t v134 = v320;
          uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v322, v105, (uint64_t)v320, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v136 = v321;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v134, AssociatedConformanceWitness);
          uint64_t v137 = v306;
          ((void (*)(char *, uint64_t, int **))v133[3])(v136, v105, v133);
          uint64_t v102 = v338;
          unint64_t v138 = v307;
          LOBYTE(v133) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v338 + 32) + 8)
                                                                            + 16))(v307, v137, v105);
          unint64_t v139 = v341;
          uint64_t v140 = *(void (**)(char *, uint64_t))(v341 + 8);
          v140(v137, v105);
          uint64_t v141 = v304;
          (*(void (**)(char *, char *, uint64_t))(v139 + 16))(v304, v138, v105);
          unint64_t v142 = v336;
          unint64_t v143 = v319;
          uint64_t v108 = v342;
          (*(void (**)(char *, char *, uint64_t *))(v336 + 32))(v319, v337, v342);
          if (v133)
          {
            (*(void (**)(char *, uint64_t *))(v142 + 8))(v143, v108);
            v140(v141, v105);
            uint64_t v106 = v339;
            uint64_t v144 = v343;
            goto LABEL_29;
          }
          uint64_t v160 = v142;
          uint64_t v106 = v339;
          unint64_t v161 = v335;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v339 + 96))(v141, v340, v102, v108, v339);
          uint64_t v118 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32) + 8) + 16))(v161, v143, v108);
          uint64_t v162 = *(void (**)(char *, uint64_t *))(v160 + 8);
          uint64_t v163 = v161;
          uint64_t v105 = v340;
          v162(v163, v108);
          v162(v143, v108);
        }
        else
        {
          uint64_t v102 = v338;
          unint64_t v117 = v306;
          uint64_t v108 = v342;
          uint64_t v106 = v339;
          (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v338 + 96))(v337, v342, v339, v105, v338);
          uint64_t v118 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v307, v117, v105);
          (*(void (**)(char *, uint64_t))(v341 + 8))(v117, v105);
        }
      }
      else
      {
        if (v114 >= v116)
        {
          unint64_t v145 = v325;
          uint64_t v108 = v342;
          uint64_t v146 = v323;
          uint64_t v147 = swift_getAssociatedConformanceWitness((uint64_t)v325, (uint64_t)v342, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v148 = v324;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v147 + 8))(&qword_18162B0B8, 256, v146, v147);
          unint64_t v149 = v335;
          ((void (*)(char *, uint64_t *, int **))v145[3])(v148, v108, v145);
          uint64_t v106 = v339;
          uint64_t v150 = v337;
          LODWORD(v319) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v339 + 32) + 8)
                                                                               + 40))(v337, v149, v108);
          uint64_t v151 = v105;
          unint64_t v152 = v336;
          uint64_t v153 = *(void (**)(char *, uint64_t *))(v336 + 8);
          v153(v149, v108);
          unint64_t v154 = v305;
          (*(void (**)(char *, char *, uint64_t))(v341 + 16))(v305, v307, v151);
          unint64_t v155 = v318;
          (*(void (**)(char *, char *, uint64_t *))(v152 + 32))(v318, v150, v108);
          if (v319)
          {
            uint64_t v156 = v154;
            uint64_t v102 = v338;
            unint64_t v157 = v306;
            (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v338 + 96))(v155, v108, v106, v151, v338);
            uint64_t v158 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v156, v157, v151);
            uint64_t v159 = *(void (**)(char *, uint64_t))(v341 + 8);
            v159(v157, v151);
            v159(v156, v151);
            uint64_t v105 = v151;
            uint64_t v144 = v343;
            if (v158) {
              goto LABEL_29;
            }
          }
          else
          {
            v153(v155, v108);
            (*(void (**)(char *, uint64_t))(v341 + 8))(v154, v151);
            uint64_t v102 = v338;
            uint64_t v105 = v151;
            uint64_t v144 = v343;
          }
          goto LABEL_43;
        }
        uint64_t v126 = v306;
        (*(void (**)(char *, char *, uint64_t))(v341 + 16))(v306, v307, v105);
        uint64_t v106 = v339;
        unint64_t v127 = v335;
        uint64_t v102 = v338;
        uint64_t v108 = v342;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v339 + 96))(v126, v340, v338, v342, v339);
        uint64_t v128 = v337;
        uint64_t v118 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32) + 8) + 16))(v127, v337, v108);
        unsigned int v129 = *(void (**)(char *, uint64_t *))(v336 + 8);
        uint64_t v130 = v127;
        uint64_t v105 = v340;
        v129(v130, v108);
        v129(v128, v108);
      }
    }
    else
    {
      v298 = *(uint64_t (**)(uint64_t, uint64_t))(v102 + 128);
      unint64_t v120 = v298(v105, v102);
      v297 = *(uint64_t (**)(uint64_t *, uint64_t))(v106 + 128);
      if (v120 >= v297(v108, v106))
      {
        uint64_t v131 = v100;
        char v132 = v306;
        (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v102 + 96))(v131, v108, v106, v105, v102);
        uint64_t v118 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v96, v132, v105);
        (*(void (**)(char *, uint64_t))(v341 + 8))(v132, v105);
      }
      else
      {
        unint64_t v121 = v306;
        (*(void (**)(char *, char *, uint64_t))(v341 + 16))(v306, v96, v105);
        uint64_t v122 = v335;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v106 + 96))(v121, v340, v102, v108, v106);
        uint64_t v118 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32) + 8) + 16))(v122, v100, v108);
        uint64_t v123 = v100;
        unint64_t v124 = *(void (**)(char *, uint64_t *))(v336 + 8);
        Swift::String v125 = v122;
        uint64_t v105 = v340;
        v124(v125, v108);
        v124(v123, v108);
      }
    }
    uint64_t v144 = v343;
    if (v118)
    {
LABEL_29:
      uint64_t v164 = (char *)v144[20];
      uint64_t v165 = v330;
      char v166 = v349;
      v337 = (char *)(v144 + 20);
      uint64_t v333 = v164;
      ((void (*)(uint64_t, int **))v164)(v349, v144);
      uint64_t v167 = v332;
      ((void (*)(uint64_t, int **))v303)(v166, v144);
      ((void (*)(char *, uint64_t))v309)(v165, v166);
      unint64_t v168 = v302;
      LODWORD(v166) = v302(v105, v102);
      uint64_t v169 = v102;
      if ((v166 ^ v300(v108, v106)))
      {
        unint64_t v170 = v168(v105, v102);
        unint64_t v171 = v307;
        uint64_t v172 = ((uint64_t (*)(uint64_t))v298)(v105);
        uint64_t v173 = v297(v108, v106);
        if (v170)
        {
          if (v173 < v172)
          {
            uint64_t v169 = v338;
            uint64_t v106 = v339;
            unint64_t v174 = v306;
            uint64_t v108 = v342;
            uint64_t v105 = v340;
            (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v338 + 96))(v167, v342, v339, v340, v338);
            goto LABEL_40;
          }
          uint64_t v217 = v322;
          uint64_t v105 = v340;
          unint64_t v218 = v320;
          uint64_t v219 = swift_getAssociatedConformanceWitness((uint64_t)v322, v340, (uint64_t)v320, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v220 = v321;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v219 + 8))(&qword_18162B0B8, 256, v218, v219);
          unint64_t v221 = v167;
          char v222 = v306;
          ((void (*)(char *, uint64_t, int **))v217[3])(v220, v105, v217);
          LOBYTE(v217) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v338 + 32) + 8)
                                                                            + 16))(v171, v222, v105);
          unint64_t v223 = v341;
          int v224 = *(void (**)(char *, uint64_t))(v341 + 8);
          v224(v222, v105);
          uint64_t v225 = v310;
          (*(void (**)(char *, char *, uint64_t))(v223 + 16))(v310, v171, v105);
          uint64_t v226 = v336;
          Swift::String::Index v227 = v315;
          uint64_t v108 = v342;
          (*(void (**)(char *, char *, uint64_t *))(v336 + 32))(v315, v221, v342);
          uint64_t v76 = v346;
          int v93 = v347;
          if (v217)
          {
            (*(void (**)(char *, uint64_t *))(v226 + 8))(v227, v108);
            v224(v225, v105);
            uint64_t v182 = v341;
            uint64_t v183 = v307;
            goto LABEL_66;
          }
          v272 = v226;
          uint64_t v106 = v339;
          v273 = v335;
          uint64_t v274 = v225;
          v275 = v338;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v339 + 96))(v274, v105, v338, v108, v339);
          LODWORD(v332) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32) + 8)
                                                                               + 16))(v273, v227, v108);
          int64_t v276 = *(void (**)(char *, uint64_t *))(v272 + 8);
          v276(v273, v108);
          v276(v227, v108);
          uint64_t v169 = v275;
          uint64_t v182 = v341;
          unint64_t v174 = v306;
        }
        else
        {
          if (v172 < v173)
          {
            uint64_t v183 = v171;
            uint64_t v105 = v340;
            uint64_t v184 = v167;
            uint64_t v185 = v306;
            (*(void (**)(char *, char *, uint64_t))(v341 + 16))(v306, v183, v340);
            unint64_t v186 = v338;
            uint64_t v106 = v339;
            uint64_t v187 = v335;
            uint64_t v108 = v342;
            (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v339 + 96))(v185, v105, v338, v342, v339);
            LODWORD(v331) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32)
                                                                                             + 8)
                                                                                 + 16))(v187, v184, v108);
            long long v188 = *(void (**)(char *, uint64_t *))(v336 + 8);
            v188(v187, v108);
            v188(v184, v108);
            uint64_t v169 = v186;
            unint64_t v174 = v185;
            uint64_t v182 = v341;
            uint64_t v76 = v346;
            int v93 = v347;
            if ((v331 & 1) == 0) {
              goto LABEL_69;
            }
            goto LABEL_66;
          }
          uint64_t v228 = v325;
          uint64_t v108 = v342;
          Swift::Int v229 = v323;
          Swift::String::Index v230 = swift_getAssociatedConformanceWitness((uint64_t)v325, (uint64_t)v342, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v231 = v324;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v230 + 8))(&qword_18162B0B8, 256, v229, v230);
          Swift::String::Index v232 = v335;
          ((void (*)(char *, uint64_t *, int **))v228[3])(v231, v108, v228);
          LOBYTE(v228) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v339 + 32) + 8)
                                                                              + 40))(v167, v232, v108);
          uint64_t v233 = v336;
          uint64_t v234 = *(void (**)(char *, uint64_t *))(v336 + 8);
          v234(v232, v108);
          Swift::String::Index v235 = v167;
          uint64_t v105 = v340;
          uint64_t v182 = v341;
          Swift::String::Index v236 = v312;
          (*(void (**)(char *, char *, uint64_t))(v341 + 16))(v312, v171, v340);
          uint64_t v237 = *(void (**)(char *, char *, uint64_t *))(v233 + 32);
          uint64_t v238 = v314;
          v237(v314, v235, v108);
          uint64_t v76 = v346;
          int v93 = v347;
          if ((v228 & 1) == 0)
          {
            v234(v238, v108);
            (*(void (**)(char *, uint64_t))(v182 + 8))(v236, v105);
            uint64_t v169 = v338;
            uint64_t v106 = v339;
            unint64_t v174 = v306;
            uint64_t v183 = v307;
            goto LABEL_69;
          }
          uint64_t v239 = v338;
          uint64_t v240 = v238;
          unint64_t v174 = v306;
          (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v338 + 96))(v240, v108, v339, v105, v338);
          LODWORD(v332) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v239 + 32) + 8)
                                                                             + 16))(v236, v174, v105);
          int64_t v241 = *(void (**)(char *, uint64_t))(v182 + 8);
          v241(v174, v105);
          v241(v236, v105);
          uint64_t v169 = v239;
          uint64_t v106 = v339;
        }
        uint64_t v183 = v307;
        if ((v332 & 1) == 0) {
          goto LABEL_69;
        }
        goto LABEL_66;
      }
      unint64_t v171 = v307;
      uint64_t v175 = v298(v105, v102);
      if (v175 >= v297(v108, v106))
      {
        unint64_t v174 = v306;
        (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v102 + 96))(v167, v108, v106, v105, v102);
LABEL_40:
        char v189 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v169 + 32) + 8) + 16))(v171, v174, v105);
        uint64_t v182 = v341;
        (*(void (**)(char *, uint64_t))(v341 + 8))(v174, v105);
        uint64_t v183 = v171;
        uint64_t v76 = v346;
        int v93 = v347;
        if ((v189 & 1) == 0)
        {
LABEL_69:
          v342 = (uint64_t *)(*(uint64_t (**)(uint64_t))(v344 + 136))(v93);
          (*(void (**)(char *, char *, uint64_t))(v182 + 32))(v174, v183, v105);
          v277 = v326;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v106 + 88))(v174, v105, v169, v108, v106);
          v278 = v329;
          v279 = v349;
          v280 = v343;
          ((void (*)(uint64_t, int **))v333)(v349, v343);
          v281 = v327;
          ((void (*)(uint64_t, int **))v303)(v279, v280);
          v282 = v278;
          uint64_t v77 = v279;
          ((void (*)(char *, uint64_t))v309)(v282, v279);
          uint64_t v283 = (uint64_t)v335;
          (*(void (**)(char *, char *, uint64_t *))(*(void *)(v328 + 8) + 40))(v277, v281, v108);
          uint64_t v284 = *(void (**)(char *, uint64_t *))(v336 + 8);
          v284(v281, v108);
          v285 = ((uint64_t (*)(char *, uint64_t *))v284)(v277, v108);
          int64_t v288 = lazy protocol witness table accessor for type Int and conformance Int(v285, v286, v287);
          lazy protocol witness table accessor for type Int and conformance Int(v288, v289, v290);
          SignedInteger<>.init<A>(_:)(v283, (uint64_t)&type metadata for Int, (uint64_t)v108, v288, (void *)v106, (uint64_t)&v351);
          uint64_t v95 = v345;
          if ((uint64_t)v351 < (uint64_t)v342) {
            goto LABEL_76;
          }
          goto LABEL_15;
        }
        goto LABEL_66;
      }
      unint64_t v176 = v341;
      uint64_t v177 = v167;
      unint64_t v178 = v306;
      (*(void (**)(char *, char *, uint64_t))(v341 + 16))(v306, v171, v105);
      uint64_t v179 = v335;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v106 + 96))(v178, v105, v169, v108, v106);
      LODWORD(v34_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32) + 8)
                                                                           + 16))(v179, v177, v108);
      long long v180 = *(void (**)(char *, uint64_t *))(v336 + 8);
      uint64_t v181 = v179;
      unint64_t v174 = v178;
      uint64_t v182 = v176;
      v180(v181, v342);
      v180(v177, v342);
      uint64_t v169 = v338;
      uint64_t v106 = v339;
      uint64_t v108 = v342;
      uint64_t v183 = v171;
      uint64_t v76 = v346;
      int v93 = v347;
      if ((v340 & 1) == 0) {
        goto LABEL_69;
      }
LABEL_66:
      v299(v350, v93);
      (*(void (**)(char *, uint64_t))(v182 + 8))(v183, v105);
      goto LABEL_67;
    }
LABEL_43:
    long long v190 = (char *)v144[15];
    BOOL v191 = v331;
    uint64_t v192 = v349;
    v337 = (char *)(v144 + 15);
    v332 = v190;
    ((void (*)(uint64_t, int **))v190)(v349, v144);
    char v193 = v333;
    ((void (*)(uint64_t, int **))v303)(v192, v144);
    ((void (*)(char *, uint64_t))v309)(v191, v192);
    uint64_t v194 = (uint64_t (*)(uint64_t *, uint64_t))v300;
    LODWORD(v192) = v300(v108, v106);
    if ((v192 ^ v302(v105, v102)))
    {
      unint64_t v195 = v194(v108, v106);
      uint64_t v196 = v297(v108, v106);
      uint64_t v197 = v307;
      char v198 = v298(v105, v102);
      if (v195)
      {
        if (v198 < v196)
        {
          char v199 = v306;
          (*(void (**)(char *, char *, uint64_t))(v341 + 32))(v306, v197, v105);
          uint64_t v200 = v339;
          uint64_t v201 = v105;
          char v202 = v335;
          unint64_t v203 = v342;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v339 + 96))(v199, v201, v338, v342, v339);
          unint64_t v204 = v333;
          unint64_t v205 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v200 + 32) + 8) + 16))(v333, v202, v203);
          uint64_t v206 = *(void (**)(char *, uint64_t *))(v336 + 8);
          v206(v202, v203);
          v206(v204, v203);
          goto LABEL_54;
        }
        uint64_t v242 = v325;
        uint64_t v243 = v342;
        uint64_t v244 = v323;
        uint64_t v245 = swift_getAssociatedConformanceWitness((uint64_t)v325, (uint64_t)v342, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v246 = v324;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v245 + 8))(&qword_18162B0B8, 256, v244, v245);
        uint64_t v247 = v335;
        ((void (*)(char *, uint64_t *, int **))v242[3])(v246, v243, v242);
        uint64_t v248 = v333;
        LOBYTE(v242) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v339 + 32) + 8)
                                                                            + 16))(v333, v247, v243);
        uint64_t v249 = v336;
        uint64_t v250 = v247;
        unint64_t v251 = v340;
        v335 = *(char **)(v336 + 8);
        ((void (*)(char *, uint64_t *))v335)(v250, v243);
        uint64_t v252 = v316;
        (*(void (**)(char *, char *, uint64_t *))(v249 + 32))(v316, v248, v243);
        uint64_t v253 = v341;
        uint64_t v254 = v313;
        (*(void (**)(char *, char *, uint64_t))(v341 + 32))(v313, v197, v251);
        uint64_t v76 = v346;
        int v93 = v347;
        if (v242)
        {
          (*(void (**)(char *, uint64_t))(v253 + 8))(v254, v251);
          ((void (*)(char *, uint64_t *))v335)(v252, v243);
          goto LABEL_55;
        }
        uint64_t v291 = v338;
        (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v338 + 96))(v252, v243, v339, v251, v338);
        v292 = v306;
        v268 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v291 + 32) + 8) + 16))(v306, v254, v251);
        v269 = *(void (**)(char *, uint64_t))(v253 + 8);
        v269(v292, v251);
        v270 = v254;
        v271 = v251;
        goto LABEL_72;
      }
      if (v196 >= v198)
      {
        unint64_t v255 = v322;
        unint64_t v256 = v320;
        unint64_t v257 = swift_getAssociatedConformanceWitness((uint64_t)v322, v105, (uint64_t)v320, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v258 = v321;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v257 + 8))(&qword_18162B0B8, 256, v256, v257);
        uint64_t v259 = v306;
        ((void (*)(char *, uint64_t, int **))v255[3])(v258, v105, v255);
        LOBYTE(v255) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v338 + 32) + 8)
                                                                          + 40))(v197, v259, v105);
        uint64_t v260 = v341;
        unint64_t v261 = *(void (**)(char *, uint64_t))(v341 + 8);
        v261(v259, v105);
        long long v262 = v336;
        Swift::String v263 = v317;
        uint64_t v264 = v342;
        (*(void (**)(char *, char *, uint64_t *))(v336 + 32))(v317, v333, v342);
        uint64_t v265 = v311;
        (*(void (**)(char *, char *, uint64_t))(v260 + 32))(v311, v197, v105);
        uint64_t v76 = v346;
        int v93 = v347;
        if ((v255 & 1) == 0)
        {
          v261(v265, v105);
          (*(void (**)(char *, uint64_t *))(v262 + 8))(v263, v264);
LABEL_75:
          v293 = (*(uint64_t (**)(uint64_t))(v344 + 136))(v93);
          v294 = v329;
          uint64_t v77 = v349;
          ((void (*)(uint64_t, int **))v332)(v349, v343);
          uint64_t v95 = v345;
          v295 = (*(uint64_t (**)(uint64_t, uint64_t))(v345 + 136))(v77, v345);
          ((void (*)(char *, uint64_t))v309)(v294, v77);
          if (v295 < v293)
          {
LABEL_76:
            v299(v350, v93);
            uint64_t v75 = 1;
            return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v348 + 56))(v76, v75, 1, v77);
          }
          goto LABEL_15;
        }
        unint64_t v266 = v339;
        unint64_t v267 = v335;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v339 + 96))(v265, v105, v338, v264, v339);
        v268 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v266 + 32) + 8) + 16))(v263, v267, v264);
        v269 = *(void (**)(char *, uint64_t))(v262 + 8);
        v269(v267, (uint64_t)v264);
        v270 = v263;
        v271 = (uint64_t)v264;
LABEL_72:
        v269(v270, v271);
        if (v268) {
          goto LABEL_55;
        }
        goto LABEL_75;
      }
      uint64_t v210 = v338;
      unint64_t v211 = v306;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v338 + 96))(v333, v342, v339, v105, v338);
      unint64_t v205 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v210 + 32) + 8) + 16))(v211, v197, v105);
      uint64_t v209 = *(void (**)(char *, uint64_t))(v341 + 8);
      v209(v211, v105);
    }
    else
    {
      uint64_t v207 = v297(v108, v106);
      uint64_t v197 = v307;
      if (v207 >= v298(v105, v102))
      {
        uint64_t v214 = v306;
        (*(void (**)(char *, char *, uint64_t))(v341 + 32))(v306, v197, v105);
        uint64_t v215 = v105;
        uint64_t v216 = v335;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v106 + 96))(v214, v215, v102, v108, v106);
        unint64_t v205 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v106 + 32) + 8) + 16))(v193, v216, v108);
        uint64_t v209 = *(void (**)(char *, uint64_t))(v336 + 8);
        v209(v216, (uint64_t)v108);
        unint64_t v212 = v193;
        uint64_t v213 = (uint64_t)v108;
        goto LABEL_53;
      }
      uint64_t v208 = v306;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v102 + 96))(v193, v108, v106, v105, v102);
      unint64_t v205 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v208, v197, v105);
      uint64_t v209 = *(void (**)(char *, uint64_t))(v341 + 8);
      v209(v208, v105);
    }
    unint64_t v212 = v197;
    uint64_t v213 = v105;
LABEL_53:
    v209(v212, v213);
LABEL_54:
    uint64_t v76 = v346;
    int v93 = v347;
    if (v205)
    {
LABEL_55:
      v299(v350, v93);
LABEL_67:
      uint64_t v75 = 1;
      uint64_t v77 = v349;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v348 + 56))(v76, v75, 1, v77);
    }
    goto LABEL_75;
  }
  (*(void (**)(uint64_t, uint64_t))(v67 + 8))(v350, v74);
  uint64_t v75 = 1;
  uint64_t v76 = v346;
  uint64_t v77 = v349;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v348 + 56))(v76, v75, 1, v77);
}

uint64_t specialized BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, Class *a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v310 = *(void *)(swift_getAssociatedConformanceWitness(v7, (uint64_t)a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  v287 = *(int ***)(*(void *)(v310 + 24) + 16);
  uint64_t v286 = swift_getAssociatedTypeWitness(0, v287, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v286);
  v285 = (char *)&v271 - v9;
  uint64_t v10 = swift_getAssociatedTypeWitness(0, (int **)v4, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v302 = *((void *)v10 - 1);
  v303 = v10;
  MEMORY[0x1F4188790](v10);
  v301 = (char *)&v271 - v11;
  uint64_t v12 = swift_getAssociatedTypeWitness(0, (int **)v4, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v299 = *((void *)v12 - 1);
  v300 = v12;
  MEMORY[0x1F4188790](v12);
  v298 = (char *)&v271 - v13;
  v305 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v308 = *(v305 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v305);
  uint64_t v16 = (char *)&v271 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v271 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  v290 = (char *)&v271 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v282 = (char *)&v271 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v283 = (char *)&v271 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v281 = (char *)&v271 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v297 = (char *)&v271 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  int64_t v288 = (char *)&v271 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v284 = (char *)&v271 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v289 = (char *)&v271 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  v304 = (char *)&v271 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v309 = (char *)&v271 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  v311 = (char *)&v271 - v41;
  uint64_t v42 = (uint64_t)*(a2 - 1);
  uint64_t v43 = MEMORY[0x1F4188790](v40);
  uint64_t v296 = (char *)&v271 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  v293 = (unint64_t *)((char *)&v271 - v46);
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  v295 = (char *)&v271 - v48;
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  v292 = (unint64_t *)((char *)&v271 - v50);
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  v294 = (char *)&v271 - v52;
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  uint64_t v291 = (unint64_t *)((char *)&v271 - v54);
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  uint64_t v57 = (char *)&v271 - v56;
  MEMORY[0x1F4188790](v55);
  uint64_t v59 = (char *)&v271 - v58;
  if (((*(uint64_t (**)(Class *, uint64_t))(v7 + 408))(a2, v7) & 1) == 0)
  {
    uint64_t v312 = a1;
    v279 = *(uint64_t (**)(Class *, uint64_t))(v4 + 96);
    int v62 = v279(a2, v4) > 5 || (*(uint64_t (**)(Class *, uint64_t))(v4 + 104))(a2, v4) > 10;
    v306 = *(void (**)(char *, uint64_t, Class *))(v42 + 16);
    uint64_t v307 = v42 + 16;
    v306(v59, v312, a2);
    uint64_t v280 = v4 + 96;
    if (v62) {
      LOBYTE(v62) = (*(uint64_t (**)(Class *, uint64_t))(v7 + 376))(a2, v7);
    }
    uint64_t v278 = v42;
    uint64_t v63 = v42 + 8;
    uint64_t v64 = *(void (**)(char *, Class *))(v42 + 8);
    v64(v59, a2);
    v306(v57, v312, a2);
    if ((v62 & 1) == 0)
    {
      v64(v57, a2);
      goto LABEL_16;
    }
    char v65 = (*(uint64_t (**)(Class *, uint64_t))(v7 + 384))(a2, v7);
    v64(v57, a2);
    if (v65) {
      goto LABEL_16;
    }
    uint64_t v272 = v4;
    uint64_t v273 = v63;
    v271 = v64;
    uint64_t v66 = v311;
    (*(void (**)(Class *, uint64_t))(v7 + 176))(a2, v7);
    int64_t v314 = -14;
    uint64_t v67 = v310;
    uint64_t v68 = v310 + 64;
    uint64_t v69 = *(uint64_t (**)(uint64_t *, uint64_t))(v310 + 64);
    uint64_t v70 = v305;
    char v71 = v69(v305, v310);
    uint64_t v274 = v68;
    v275 = v69;
    if (v71)
    {
      int64_t v276 = *(char **)(v67 + 128);
      uint64_t v72 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v67);
      uint64_t v75 = v67;
      if (v72 >= 64)
      {
        uint64_t v105 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
        unint64_t v106 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
        uint64_t v107 = v309;
        v105(&v314, &type metadata for Int, v106, v70, v75);
        char v108 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8) + 16))(v66, v107, v70);
        uint64_t v76 = v308;
        v277 = *(void (**)(char *, uint64_t *))(v308 + 8);
        v277(v107, v70);
        uint64_t v79 = v275;
        if ((v108 & 1) == 0) {
          goto LABEL_51;
        }
      }
      else
      {
        uint64_t v76 = v308;
        uint64_t v77 = v309;
        (*(void (**)(char *, char *, uint64_t *))(v308 + 16))(v309, v66, v70);
        uint64_t v78 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v70, v67);
        v277 = *(void (**)(char *, uint64_t *))(v76 + 8);
        v277(v77, v70);
        uint64_t v79 = v275;
        if (v78 >= v314) {
          goto LABEL_51;
        }
      }
    }
    else
    {
      char v97 = v69(v70, v67);
      int64_t v276 = *(char **)(v67 + 128);
      uint64_t v98 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v67);
      if (v97)
      {
        if (v98 <= 64)
        {
          unint64_t v145 = v287;
          uint64_t v146 = v286;
          uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v287, (uint64_t)v70, (uint64_t)v286, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v148 = v285;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v146, AssociatedConformanceWitness);
          unint64_t v149 = v309;
          ((void (*)(char *, uint64_t *, int **))v145[3])(v148, v70, v145);
          uint64_t v150 = v311;
          LOBYTE(v146) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v310 + 32) + 8)
                                                                              + 16))(v311, v149, v70);
          uint64_t v151 = v308;
          v277 = *(void (**)(char *, uint64_t *))(v308 + 8);
          v277(v149, v70);
          (*(void (**)(char *, char *, uint64_t *))(v151 + 16))(v19, v150, v70);
          if (v146)
          {
            v277(v19, v70);
            uint64_t v75 = v310;
            uint64_t v76 = v308;
            uint64_t v79 = v275;
          }
          else
          {
            int64_t v152 = v314;
            uint64_t v75 = v310;
            uint64_t v153 = (*(uint64_t (**)(uint64_t *, uint64_t))(v310 + 120))(v70, v310);
            v277(v19, v70);
            BOOL v154 = v153 < v152;
            uint64_t v76 = v308;
            uint64_t v79 = v275;
            if (!v154) {
              goto LABEL_51;
            }
          }
        }
        else
        {
          uint64_t v75 = v310;
          uint64_t v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v310 + 96);
          unint64_t v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
          uint64_t v103 = v309;
          v101(&v314, &type metadata for Int, v102, v70, v75);
          char v104 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8) + 16))(v311, v103, v70);
          uint64_t v76 = v308;
          v277 = *(void (**)(char *, uint64_t *))(v308 + 8);
          v277(v103, v70);
          uint64_t v79 = v275;
          if ((v104 & 1) == 0) {
            goto LABEL_51;
          }
        }
      }
      else
      {
        uint64_t v109 = v308;
        uint64_t v110 = *(void (**)(char *, char *, uint64_t *))(v308 + 16);
        if (v98 >= 64)
        {
          v110(v16, v311, v70);
          v277 = *(void (**)(char *, uint64_t *))(v109 + 8);
          v277(v16, v70);
          uint64_t v75 = v310;
          uint64_t v76 = v109;
          uint64_t v79 = v275;
LABEL_51:
          int64_t v314 = 15;
          char v161 = v79(v70, v75);
          uint64_t v162 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v75);
          if (v161)
          {
            uint64_t v64 = v271;
            if (v162 <= 64)
            {
              uint64_t v182 = v309;
              (*(void (**)(char *, char *, uint64_t *))(v76 + 32))(v309, v311, v70);
              uint64_t v183 = (*(uint64_t (**)(uint64_t *, uint64_t))(v75 + 120))(v70, v75);
              v277(v182, v70);
              uint64_t v171 = v312;
              uint64_t v4 = v272;
              if (v314 < v183) {
                goto LABEL_65;
              }
            }
            else
            {
              uint64_t v165 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v75 + 96);
              unint64_t v166 = lazy protocol witness table accessor for type Int and conformance Int(v162, v163, v164);
              uint64_t v167 = v309;
              v165(&v314, &type metadata for Int, v166, v70, v75);
              unint64_t v168 = v311;
              char v169 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8)
                                                                          + 16))(v167, v311, v70);
              unint64_t v170 = v277;
              v277(v167, v70);
              v170(v168, v70);
              uint64_t v171 = v312;
              uint64_t v4 = v272;
              if (v169) {
                goto LABEL_65;
              }
            }
          }
          else
          {
            uint64_t v64 = v271;
            uint64_t v4 = v272;
            if (v162 > 63)
            {
              uint64_t v313 = 15;
              uint64_t v184 = *(uint64_t (**)(char *, char *, uint64_t *))(v76 + 32);
              uint64_t v308 = v76 + 32;
              uint64_t v185 = v184(v290, v311, v70);
              v311 = *(char **)(v75 + 96);
              unint64_t v188 = lazy protocol witness table accessor for type Int and conformance Int(v185, v186, v187);
              char v189 = v309;
              ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))v311)(&v313, &type metadata for Int, v188, v70, v75);
              char v190 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8)
                                                                          + 16))(v189, v290, v70);
              BOOL v191 = v277;
              v277(v189, v70);
              v191(v290, v70);
              uint64_t v171 = v312;
              if (v190)
              {
LABEL_65:
                uint64_t v192 = v171;
LABEL_117:
                v64((char *)v192, a2);
                goto LABEL_3;
              }
            }
            else
            {
              uint64_t v172 = v309;
              (*(void (**)(char *, char *, uint64_t *))(v76 + 32))(v309, v311, v70);
              uint64_t v173 = (*(uint64_t (**)(uint64_t *, uint64_t))(v75 + 120))(v70, v75);
              v277(v172, v70);
              uint64_t v171 = v312;
              if (v314 < v173) {
                goto LABEL_65;
              }
            }
          }
          if ((*(uint64_t (**)(Class *, uint64_t))(v4 + 136))(a2, v4) >= 11) {
            goto LABEL_65;
          }
LABEL_16:
          uint64_t v80 = v279(a2, v4);
          uint64_t v81 = (*(uint64_t (**)(Class *, uint64_t))(v4 + 104))(a2, v4);
          if (v80 == 11)
          {
            if (v81 == 52)
            {
              int v85 = v293;
              uint64_t v86 = v312;
              v306((char *)v293, v312, a2);
              LODWORD(v85) = swift_dynamicCast((char *)&v314, v85, a2, (const char *)&type metadata for Double, 6uLL);
              _D8 = v314;
              uint64_t v87 = v296;
              (*(void (**)(char *, uint64_t, Class *))(v278 + 32))(v296, v86, a2);
              if (v85)
              {
                v64(v87, a2);
                __asm { FCVT            H8, D8 }
              }
              else
              {
                uint64_t v312 = (*(uint64_t (**)(Class *, uint64_t))(v7 + 168))(a2, v7);
                uint64_t v123 = v298;
                (*(void (**)(Class *, uint64_t))(v4 + 112))(a2, v4);
                uint64_t v124 = (uint64_t)v300;
                uint64_t v125 = swift_getAssociatedConformanceWitness(v4, (uint64_t)a2, (uint64_t)v300, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                uint64_t v126 = v4;
                __int16 v127 = (*(uint64_t (**)(uint64_t))(*(void *)(v125 + 8) + 120))(v124);
                (*(void (**)(char *, uint64_t))(v299 + 8))(v123, v124);
                uint64_t v128 = v301;
                (*(void (**)(Class *, uint64_t))(v126 + 120))(a2, v126);
                v64(v87, a2);
                uint64_t v129 = v126;
                uint64_t v130 = (uint64_t)v303;
                uint64_t v131 = swift_getAssociatedConformanceWitness(v129, (uint64_t)a2, (uint64_t)v303, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                uint64_t v132 = (*(uint64_t (**)(uint64_t))(*(void *)(v131 + 8) + 120))(v130);
                (*(void (**)(char *, uint64_t))(v302 + 8))(v128, v130);
                _D0 = (v312 << 63) | ((unint64_t)(v127 & 0x7FF) << 52) | v132 & 0xFFFFFFFFFFFFFLL;
                __asm { FCVT            H8, D0 }
              }
              goto LABEL_29;
            }
          }
          else if (v80 == 8)
          {
            if (v81 == 23)
            {
              uint64_t v92 = v292;
              uint64_t v93 = v312;
              v306((char *)v292, v312, a2);
              LODWORD(v92) = swift_dynamicCast((char *)&v314, v92, a2, (const char *)&type metadata for Float, 6uLL);
              LODWORD(_D8) = v314;
              uint64_t v94 = v295;
              (*(void (**)(char *, uint64_t, Class *))(v278 + 32))(v295, v93, a2);
              if (v92)
              {
                v64(v94, a2);
                __asm { FCVT            H8, S8 }
              }
              else
              {
                LODWORD(v312) = (*(uint64_t (**)(Class *, uint64_t))(v7 + 168))(a2, v7);
                uint64_t v134 = v298;
                (*(void (**)(Class *, uint64_t))(v4 + 112))(a2, v4);
                uint64_t v135 = (uint64_t)v300;
                uint64_t v136 = swift_getAssociatedConformanceWitness(v4, (uint64_t)a2, (uint64_t)v300, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                uint64_t v137 = v4;
                unsigned __int8 v138 = (*(uint64_t (**)(uint64_t))(*(void *)(v136 + 8) + 120))(v135);
                (*(void (**)(char *, uint64_t))(v299 + 8))(v134, v135);
                unint64_t v139 = v301;
                (*(void (**)(Class *, uint64_t))(v137 + 120))(a2, v137);
                v64(v94, a2);
                uint64_t v140 = v137;
                uint64_t v141 = (uint64_t)v303;
                uint64_t v142 = swift_getAssociatedConformanceWitness(v140, (uint64_t)a2, (uint64_t)v303, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                int v143 = (*(uint64_t (**)(uint64_t))(*(void *)(v142 + 8) + 120))(v141);
                (*(void (**)(char *, uint64_t))(v302 + 8))(v139, v141);
                _S0 = (v312 << 31) | (v138 << 23) | v143 & 0x7FFFFF;
                __asm { FCVT            H8, S0 }
              }
              goto LABEL_29;
            }
          }
          else if (v80 == 5 && v81 == 10)
          {
            uint64_t v82 = v291;
            uint64_t v83 = v312;
            v306((char *)v291, v312, a2);
            LODWORD(v82) = swift_dynamicCast((char *)&v314, v82, a2, (const char *)&type metadata for Float16, 6uLL);
            LOWORD(_D8) = v314;
            uint64_t v84 = v294;
            (*(void (**)(char *, uint64_t, Class *))(v278 + 32))(v294, v83, a2);
            if (v82)
            {
              v64(v84, a2);
            }
            else
            {
              LODWORD(v312) = (*(uint64_t (**)(Class *, uint64_t))(v7 + 168))(a2, v7);
              __int16 v113 = v298;
              (*(void (**)(Class *, uint64_t))(v4 + 112))(a2, v4);
              uint64_t v114 = (uint64_t)v300;
              uint64_t v115 = swift_getAssociatedConformanceWitness(v4, (uint64_t)a2, (uint64_t)v300, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
              uint64_t v116 = v4;
              char v117 = (*(uint64_t (**)(uint64_t))(*(void *)(v115 + 8) + 120))(v114);
              (*(void (**)(char *, uint64_t))(v299 + 8))(v113, v114);
              uint64_t v118 = v301;
              (*(void (**)(Class *, uint64_t))(v116 + 120))(a2, v116);
              v64(v84, a2);
              uint64_t v119 = v116;
              uint64_t v120 = (uint64_t)v303;
              uint64_t v121 = swift_getAssociatedConformanceWitness(v119, (uint64_t)a2, (uint64_t)v303, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
              __int16 v122 = (*(uint64_t (**)(uint64_t))(*(void *)(v121 + 8) + 120))(v120);
              (*(void (**)(char *, uint64_t))(v302 + 8))(v118, v120);
              LODWORD(_D8) = (v312 << 15) | ((v117 & 0x1F) << 10) | v122 & 0x3FF;
            }
            goto LABEL_29;
          }
          uint64_t v95 = v312;
          specialized static BinaryFloatingPoint._convert<A>(from:)((short float *)&v314, v312, (uint64_t)a2, v4);
          v64((char *)v95, a2);
          LOWORD(_D8) = v314;
LABEL_29:
          int v61 = 0;
          int v60 = _D8;
          return v60 | (v61 << 16);
        }
        uint64_t v111 = v309;
        v110(v309, v311, v70);
        uint64_t v75 = v310;
        uint64_t v112 = (*(uint64_t (**)(uint64_t *, uint64_t))(v310 + 120))(v70, v310);
        v277 = *(void (**)(char *, uint64_t *))(v109 + 8);
        v277(v111, v70);
        uint64_t v76 = v109;
        uint64_t v79 = v275;
        if (v112 >= v314) {
          goto LABEL_51;
        }
      }
    }
    int64_t v314 = -24;
    if (v79(v70, v75))
    {
      unint64_t v155 = v311;
      uint64_t v156 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v75);
      if (v156 < 64)
      {
        uint64_t v159 = v309;
        (*(void (**)(char *, char *, uint64_t *))(v76 + 16))(v309, v155, v70);
        uint64_t v160 = (*(uint64_t (**)(uint64_t *, uint64_t))(v75 + 120))(v70, v75);
LABEL_71:
        v277(v159, v70);
        if (v160 < v314) {
          goto LABEL_72;
        }
        goto LABEL_76;
      }
      char v193 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v75 + 96);
      unint64_t v194 = lazy protocol witness table accessor for type Int and conformance Int(v156, v157, v158);
      long long v180 = v309;
      v193(&v314, &type metadata for Int, v194, v70, v75);
      uint64_t v76 = v308;
      char v181 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8) + 16))(v155, v180, v70);
    }
    else
    {
      char v174 = v79(v70, v75);
      uint64_t v175 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v75);
      if ((v174 & 1) == 0)
      {
        uint64_t v196 = *(void (**)(char *, char *, uint64_t *))(v76 + 16);
        if (v175 >= 64)
        {
          uint64_t v206 = v282;
          unint64_t v155 = v311;
          v196(v282, v311, v70);
          v277(v206, v70);
          goto LABEL_76;
        }
        uint64_t v159 = v309;
        unint64_t v155 = v311;
        v196(v309, v311, v70);
        uint64_t v160 = (*(uint64_t (**)(uint64_t *, uint64_t))(v75 + 120))(v70, v75);
        goto LABEL_71;
      }
      if (v175 <= 64)
      {
        uint64_t v197 = v287;
        char v198 = v286;
        uint64_t v199 = swift_getAssociatedConformanceWitness((uint64_t)v287, (uint64_t)v70, (uint64_t)v286, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v200 = v285;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v199 + 8))(&qword_18162B0B8, 256, v198, v199);
        uint64_t v201 = v309;
        ((void (*)(char *, uint64_t *, int **))v197[3])(v200, v70, v197);
        LOBYTE(v198) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8)
                                                                            + 16))(v311, v201, v70);
        char v202 = v201;
        unint64_t v203 = v277;
        v277(v202, v70);
        unint64_t v204 = *(void (**)(char *, char *, uint64_t *))(v76 + 16);
        unint64_t v205 = v283;
        v204(v283, v311, v70);
        if (v198)
        {
          v203(v205, v70);
          unint64_t v155 = v311;
          goto LABEL_72;
        }
        int64_t v230 = v314;
        uint64_t v231 = (*(uint64_t (**)(uint64_t *, uint64_t))(v310 + 120))(v70, v310);
        v203(v205, v70);
        BOOL v154 = v231 < v230;
        uint64_t v75 = v310;
        unint64_t v155 = v311;
        uint64_t v76 = v308;
        if (v154) {
          goto LABEL_72;
        }
        goto LABEL_76;
      }
      unint64_t v178 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v75 + 96);
      unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v175, v176, v177);
      long long v180 = v309;
      v178(&v314, &type metadata for Int, v179, v70, v75);
      uint64_t v76 = v308;
      unint64_t v155 = v311;
      char v181 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v75 + 32) + 8) + 16))(v311, v180, v70);
    }
    char v195 = v181;
    v277(v180, v70);
    if (v195)
    {
LABEL_72:
      v271((char *)v312, a2);
      v277(v155, v70);
      goto LABEL_3;
    }
LABEL_76:
    uint64_t v283 = (char *)(*(uint64_t (**)(Class *))(v272 + 136))(a2);
    uint64_t v207 = v304;
    (*(void (**)(char *, char *, uint64_t *))(v76 + 32))(v304, v155, v70);
    char v208 = v275(v70, v75);
    uint64_t v209 = v75;
    uint64_t v210 = *(char **)(v76 + 16);
    unint64_t v211 = v289;
    v311 = (char *)(v76 + 16);
    v290 = v210;
    ((void (*)(char *, char *, uint64_t *))v210)(v289, v207, v70);
    if ((v208 & 1) == 0)
    {
      v277(v211, v70);
      goto LABEL_99;
    }
    uint64_t v212 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v209);
    v277(v211, v70);
    if (v212 <= 64) {
      goto LABEL_99;
    }
    uint64_t v289 = (char *)(v76 + 8);
    uint64_t v213 = v284;
    ((void (*)(char *, char *, uint64_t *))v290)(v284, v304, v70);
    int64_t v314 = 0x8000000000000000;
    uint64_t v214 = v275;
    if (v275(v70, v209))
    {
      uint64_t v215 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v209);
      if (v215 >= 64)
      {
        Swift::String::Index v232 = v213;
        uint64_t v233 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v209 + 96);
        unint64_t v234 = lazy protocol witness table accessor for type Int and conformance Int(v215, v216, v217);
        Swift::String::Index v235 = v309;
        v233(&v314, &type metadata for Int, v234, v70, v209);
        uint64_t v213 = v232;
        char v236 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v209 + 32) + 8) + 16))(v232, v235, v70);
        unint64_t v220 = v277;
        v277(v235, v70);
        if (v236) {
          goto LABEL_120;
        }
LABEL_97:
        v270 = v213;
        goto LABEL_98;
      }
      unint64_t v218 = v309;
      ((void (*)(char *, char *, uint64_t *))v290)(v309, v213, v70);
      uint64_t v219 = (*(uint64_t (**)(uint64_t *, uint64_t))(v209 + 120))(v70, v209);
      unint64_t v220 = v277;
      v277(v218, v70);
    }
    else
    {
      char v221 = v214(v70, v209);
      uint64_t v222 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v209);
      if (v221)
      {
        if (v222 <= 64)
        {
          uint64_t v238 = v287;
          uint64_t v70 = v305;
          uint64_t v239 = v286;
          uint64_t v240 = swift_getAssociatedConformanceWitness((uint64_t)v287, (uint64_t)v305, (uint64_t)v286, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          int64_t v241 = v285;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v240 + 8))(&qword_18162B0B8, 256, v239, v240);
          uint64_t v242 = v309;
          ((void (*)(char *, uint64_t *, int **))v238[3])(v241, v70, v238);
          uint64_t v243 = v310;
          uint64_t v244 = v284;
          LOBYTE(v239) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v310 + 32) + 8)
                                                                              + 16))(v284, v242, v70);
          unint64_t v220 = v277;
          v277(v242, v70);
          uint64_t v245 = v281;
          ((void (*)(char *, char *, uint64_t *))v290)(v281, v244, v70);
          if (v239)
          {
LABEL_119:
            v220(v245, v70);
            goto LABEL_120;
          }
          int64_t v246 = v314;
          uint64_t v247 = (*(uint64_t (**)(uint64_t *, uint64_t))(v243 + 120))(v70, v243);
          v220(v245, v70);
          uint64_t v213 = v284;
          if (v247 < v246) {
            goto LABEL_120;
          }
        }
        else
        {
          uint64_t v225 = v310;
          uint64_t v226 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v310 + 96);
          unint64_t v227 = lazy protocol witness table accessor for type Int and conformance Int(v222, v223, v224);
          uint64_t v228 = v309;
          uint64_t v70 = v305;
          v226(&v314, &type metadata for Int, v227, v305, v225);
          uint64_t v213 = v284;
          char v229 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v225 + 32) + 8) + 16))(v284, v228, v70);
          unint64_t v220 = v277;
          v277(v228, v70);
          if (v229) {
            goto LABEL_120;
          }
        }
        goto LABEL_97;
      }
      unint64_t v220 = v277;
      if (v222 >= 64)
      {
        v270 = v284;
        uint64_t v70 = v305;
LABEL_98:
        v220(v270, v70);
        uint64_t v209 = v310;
LABEL_99:
        uint64_t v248 = v304;
        uint64_t v245 = v276;
        uint64_t v249 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v209);
        uint64_t v250 = v288;
        ((void (*)(char *, char *, uint64_t *))v290)(v288, v248, v70);
        uint64_t v289 = (char *)(v209 + 128);
        if (v249 < 65)
        {
          uint64_t v262 = ((uint64_t (*)(uint64_t *, uint64_t))v245)(v70, v209);
          v277(v250, v70);
          uint64_t v251 = v312;
          uint64_t v252 = v275;
          if (v262 != 64)
          {
            unint64_t v220 = v277;
LABEL_114:
            v268 = v304;
            uint64_t v269 = (*(uint64_t (**)(uint64_t *))(v310 + 120))(v70);
            v220(v268, v70);
            if (!__OFADD__(v269, 24))
            {
              uint64_t v64 = v271;
              uint64_t v4 = v272;
              if (v269 + 24 < (uint64_t)v283)
              {
                uint64_t v192 = v251;
                goto LABEL_117;
              }
              goto LABEL_16;
            }
            __break(1u);
            goto LABEL_119;
          }
          char v263 = v275(v70, v209);
          unint64_t v220 = v277;
          if (v263) {
            goto LABEL_114;
          }
        }
        else
        {
          v277(v250, v70);
          uint64_t v251 = v312;
          uint64_t v252 = v275;
        }
        ((void (*)(char *, char *, uint64_t *))v290)(v297, v304, v70);
        int64_t v314 = 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v253 = v310;
        char v254 = v252(v70, v310);
        uint64_t v255 = ((uint64_t (*)(uint64_t *, uint64_t))v276)(v70, v253);
        if (v254)
        {
          if (v255 > 64)
          {
            uint64_t v258 = v310;
            uint64_t v259 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v310 + 96);
            unint64_t v260 = lazy protocol witness table accessor for type Int and conformance Int(v255, v256, v257);
            unint64_t v261 = &v314;
            goto LABEL_112;
          }
        }
        else if (v255 >= 64)
        {
          uint64_t v313 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v258 = v310;
          uint64_t v259 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v310 + 96);
          unint64_t v260 = lazy protocol witness table accessor for type Int and conformance Int(v255, v256, v257);
          unint64_t v261 = &v313;
LABEL_112:
          uint64_t v245 = v309;
          uint64_t v70 = v305;
          v259(v261, &type metadata for Int, v260, v305, v258);
          uint64_t v251 = v312;
          char v267 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v258 + 32) + 8) + 16))(v245, v297, v70);
          unint64_t v220 = v277;
          v277(v245, v70);
          if ((v267 & 1) == 0) {
            goto LABEL_113;
          }
          goto LABEL_110;
        }
        uint64_t v264 = v309;
        uint64_t v70 = v305;
        ((void (*)(char *, char *, uint64_t *))v290)(v309, v297, v305);
        uint64_t v265 = (*(uint64_t (**)(uint64_t *))(v310 + 120))(v70);
        unint64_t v266 = v264;
        unint64_t v220 = v277;
        v277(v266, v70);
        if (v314 >= v265)
        {
LABEL_113:
          v220(v297, v70);
          goto LABEL_114;
        }
LABEL_110:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      uint64_t v237 = v309;
      uint64_t v213 = v284;
      uint64_t v70 = v305;
      ((void (*)(char *, char *, uint64_t *))v290)(v309, v284, v305);
      uint64_t v219 = (*(uint64_t (**)(uint64_t *))(v310 + 120))(v70);
      v220(v237, v70);
    }
    if (v219 < v314) {
LABEL_120:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_97;
  }
  (*(void (**)(uint64_t, Class *))(v42 + 8))(a1, a2);
LABEL_3:
  int v60 = 0;
  int v61 = 1;
  return v60 | (v61 << 16);
}

unint64_t specialized BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, Class *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v311 = *(void *)(swift_getAssociatedConformanceWitness(v6, (uint64_t)a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  int64_t v288 = *(int ***)(*(void *)(v311 + 24) + 16);
  v287 = swift_getAssociatedTypeWitness(0, v288, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v287);
  uint64_t v286 = (char *)&v271 - v8;
  uint64_t v9 = swift_getAssociatedTypeWitness(0, (int **)v3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v303 = *((void *)v9 - 1);
  v304 = v9;
  MEMORY[0x1F4188790](v9);
  uint64_t v302 = (char *)&v271 - v10;
  uint64_t v11 = swift_getAssociatedTypeWitness(0, (int **)v3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v300 = *((void *)v11 - 1);
  v301 = v11;
  MEMORY[0x1F4188790](v11);
  uint64_t v299 = (char *)&v271 - v12;
  v306 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v309 = *(v306 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v306);
  uint64_t v15 = (char *)&v271 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v271 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v291 = (char *)&v271 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v283 = (char *)&v271 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v284 = (char *)&v271 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v282 = (char *)&v271 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v298 = (char *)&v271 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v289 = (char *)&v271 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v285 = (char *)&v271 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v290 = (char *)&v271 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  v305 = (char *)&v271 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v310 = (char *)&v271 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v312 = (char *)&v271 - v40;
  uint64_t v41 = (uint64_t)*(a2 - 1);
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  v297 = (char *)&v271 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  v294 = (unint64_t *)((char *)&v271 - v45);
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  uint64_t v296 = (char *)&v271 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v293 = (unint64_t *)((char *)&v271 - v49);
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v295 = (char *)&v271 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  v292 = (unint64_t *)((char *)&v271 - v53);
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  uint64_t v56 = (char *)&v271 - v55;
  MEMORY[0x1F4188790](v54);
  uint64_t v58 = (char *)&v271 - v57;
  if (((*(uint64_t (**)(Class *, uint64_t))(v6 + 408))(a2, v6) & 1) == 0)
  {
    uint64_t v313 = a1;
    uint64_t v280 = *(uint64_t (**)(Class *, uint64_t))(v3 + 96);
    int v61 = v280(a2, v3) > 8 || (*(uint64_t (**)(Class *, uint64_t))(v3 + 104))(a2, v3) > 23;
    uint64_t v307 = *(void (**)(char *, uint64_t, Class *))(v41 + 16);
    uint64_t v308 = v41 + 16;
    v307(v58, v313, a2);
    uint64_t v281 = v3 + 96;
    if (v61) {
      LOBYTE(v61) = (*(uint64_t (**)(Class *, uint64_t))(v6 + 376))(a2, v6);
    }
    uint64_t v279 = v41;
    uint64_t v62 = v41 + 8;
    uint64_t v63 = *(void (**)(char *, Class *))(v41 + 8);
    v63(v58, a2);
    v307(v56, v313, a2);
    if ((v61 & 1) == 0)
    {
      v63(v56, a2);
      goto LABEL_16;
    }
    char v64 = (*(uint64_t (**)(Class *, uint64_t))(v6 + 384))(a2, v6);
    v63(v56, a2);
    if (v64) {
      goto LABEL_16;
    }
    uint64_t v273 = v3;
    uint64_t v274 = v62;
    uint64_t v272 = v63;
    char v65 = v312;
    (*(void (**)(Class *, uint64_t))(v6 + 176))(a2, v6);
    int64_t v315 = -126;
    uint64_t v66 = v311;
    uint64_t v67 = v311 + 64;
    uint64_t v68 = *(uint64_t (**)(uint64_t *, uint64_t))(v311 + 64);
    uint64_t v69 = v306;
    char v70 = v68(v306, v311);
    uint64_t v275 = v67;
    int64_t v276 = v68;
    if (v70)
    {
      v277 = *(char **)(v66 + 128);
      uint64_t v71 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v66);
      uint64_t v74 = v66;
      if (v71 >= 64)
      {
        uint64_t v103 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v66 + 96);
        unint64_t v104 = lazy protocol witness table accessor for type Int and conformance Int(v71, v72, v73);
        uint64_t v105 = v310;
        v103(&v315, &type metadata for Int, v104, v69, v74);
        char v106 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8) + 16))(v65, v105, v69);
        uint64_t v75 = v309;
        uint64_t v278 = *(void (**)(char *, uint64_t *))(v309 + 8);
        v278(v105, v69);
        uint64_t v78 = v276;
        if ((v106 & 1) == 0) {
          goto LABEL_52;
        }
      }
      else
      {
        uint64_t v75 = v309;
        uint64_t v76 = v310;
        (*(void (**)(char *, char *, uint64_t *))(v309 + 16))(v310, v65, v69);
        uint64_t v77 = (*(uint64_t (**)(uint64_t *, uint64_t))(v66 + 120))(v69, v66);
        uint64_t v278 = *(void (**)(char *, uint64_t *))(v75 + 8);
        v278(v76, v69);
        uint64_t v78 = v276;
        if (v77 >= v315) {
          goto LABEL_52;
        }
      }
    }
    else
    {
      char v95 = v68(v69, v66);
      v277 = *(char **)(v66 + 128);
      uint64_t v96 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v66);
      if (v95)
      {
        if (v96 <= 64)
        {
          unint64_t v145 = v288;
          uint64_t v146 = v287;
          uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v288, (uint64_t)v69, (uint64_t)v287, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v148 = v286;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v146, AssociatedConformanceWitness);
          unint64_t v149 = v310;
          ((void (*)(char *, uint64_t *, int **))v145[3])(v148, v69, v145);
          uint64_t v150 = v312;
          LOBYTE(v146) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v311 + 32) + 8)
                                                                              + 16))(v312, v149, v69);
          uint64_t v151 = v309;
          uint64_t v278 = *(void (**)(char *, uint64_t *))(v309 + 8);
          v278(v149, v69);
          (*(void (**)(char *, char *, uint64_t *))(v151 + 16))(v18, v150, v69);
          if (v146)
          {
            v278(v18, v69);
            uint64_t v74 = v311;
            uint64_t v75 = v309;
            uint64_t v78 = v276;
          }
          else
          {
            int64_t v152 = v315;
            uint64_t v74 = v311;
            uint64_t v153 = (*(uint64_t (**)(uint64_t *, uint64_t))(v311 + 120))(v69, v311);
            v278(v18, v69);
            BOOL v154 = v153 < v152;
            uint64_t v75 = v309;
            uint64_t v78 = v276;
            if (!v154) {
              goto LABEL_52;
            }
          }
        }
        else
        {
          uint64_t v74 = v311;
          uint64_t v99 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v311 + 96);
          unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
          uint64_t v101 = v310;
          v99(&v315, &type metadata for Int, v100, v69, v74);
          char v102 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8) + 16))(v312, v101, v69);
          uint64_t v75 = v309;
          uint64_t v278 = *(void (**)(char *, uint64_t *))(v309 + 8);
          v278(v101, v69);
          uint64_t v78 = v276;
          if ((v102 & 1) == 0) {
            goto LABEL_52;
          }
        }
      }
      else
      {
        uint64_t v107 = v309;
        char v108 = *(void (**)(char *, char *, uint64_t *))(v309 + 16);
        if (v96 >= 64)
        {
          v108(v15, v312, v69);
          uint64_t v278 = *(void (**)(char *, uint64_t *))(v107 + 8);
          v278(v15, v69);
          uint64_t v74 = v311;
          uint64_t v75 = v107;
          uint64_t v78 = v276;
LABEL_52:
          int64_t v315 = 127;
          char v161 = v78(v69, v74);
          uint64_t v162 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v74);
          if (v161)
          {
            uint64_t v63 = v272;
            if (v162 <= 64)
            {
              uint64_t v182 = v310;
              (*(void (**)(char *, char *, uint64_t *))(v75 + 32))(v310, v312, v69);
              uint64_t v183 = (*(uint64_t (**)(uint64_t *, uint64_t))(v74 + 120))(v69, v74);
              v278(v182, v69);
              uint64_t v171 = v313;
              uint64_t v3 = v273;
              if (v315 < v183) {
                goto LABEL_66;
              }
            }
            else
            {
              uint64_t v165 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v74 + 96);
              unint64_t v166 = lazy protocol witness table accessor for type Int and conformance Int(v162, v163, v164);
              uint64_t v167 = v310;
              v165(&v315, &type metadata for Int, v166, v69, v74);
              unint64_t v168 = v312;
              char v169 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8)
                                                                          + 16))(v167, v312, v69);
              unint64_t v170 = v278;
              v278(v167, v69);
              v170(v168, v69);
              uint64_t v171 = v313;
              uint64_t v3 = v273;
              if (v169) {
                goto LABEL_66;
              }
            }
          }
          else
          {
            uint64_t v63 = v272;
            uint64_t v3 = v273;
            if (v162 > 63)
            {
              uint64_t v314 = 127;
              uint64_t v184 = *(uint64_t (**)(char *, char *, uint64_t *))(v75 + 32);
              uint64_t v309 = v75 + 32;
              uint64_t v185 = v184(v291, v312, v69);
              uint64_t v312 = *(char **)(v74 + 96);
              unint64_t v188 = lazy protocol witness table accessor for type Int and conformance Int(v185, v186, v187);
              char v189 = v310;
              ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))v312)(&v314, &type metadata for Int, v188, v69, v74);
              char v190 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8)
                                                                          + 16))(v189, v291, v69);
              BOOL v191 = v278;
              v278(v189, v69);
              v191(v291, v69);
              uint64_t v171 = v313;
              if (v190)
              {
LABEL_66:
                uint64_t v192 = v171;
LABEL_118:
                v63((char *)v192, a2);
                goto LABEL_3;
              }
            }
            else
            {
              uint64_t v172 = v310;
              (*(void (**)(char *, char *, uint64_t *))(v75 + 32))(v310, v312, v69);
              uint64_t v173 = (*(uint64_t (**)(uint64_t *, uint64_t))(v74 + 120))(v69, v74);
              v278(v172, v69);
              uint64_t v171 = v313;
              if (v315 < v173) {
                goto LABEL_66;
              }
            }
          }
          if ((*(uint64_t (**)(Class *, uint64_t))(v3 + 136))(a2, v3) >= 24) {
            goto LABEL_66;
          }
LABEL_16:
          uint64_t v79 = v280(a2, v3);
          uint64_t v80 = (*(uint64_t (**)(Class *, uint64_t))(v3 + 104))(a2, v3);
          if (v79 == 11)
          {
            if (v80 == 52)
            {
              int v85 = v294;
              uint64_t v86 = v313;
              v307((char *)v294, v313, a2);
              LODWORD(v85) = swift_dynamicCast((char *)&v315, v85, a2, (const char *)&type metadata for Double, 6uLL);
              double v87 = *(double *)&v315;
              uint64_t v88 = v297;
              (*(void (**)(char *, uint64_t, Class *))(v279 + 32))(v297, v86, a2);
              if (v85)
              {
                v63(v88, a2);
                *(float *)&_S8 = v87;
              }
              else
              {
                uint64_t v313 = (*(uint64_t (**)(Class *, uint64_t))(v6 + 168))(a2, v6);
                uint64_t v125 = v299;
                (*(void (**)(Class *, uint64_t))(v3 + 112))(a2, v3);
                uint64_t v126 = (uint64_t)v301;
                uint64_t v127 = swift_getAssociatedConformanceWitness(v3, (uint64_t)a2, (uint64_t)v301, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                uint64_t v128 = v3;
                __int16 v129 = (*(uint64_t (**)(uint64_t))(*(void *)(v127 + 8) + 120))(v126);
                (*(void (**)(char *, uint64_t))(v300 + 8))(v125, v126);
                uint64_t v130 = v302;
                (*(void (**)(Class *, uint64_t))(v128 + 120))(a2, v128);
                v63(v88, a2);
                uint64_t v131 = v128;
                uint64_t v132 = (uint64_t)v304;
                uint64_t v133 = swift_getAssociatedConformanceWitness(v131, (uint64_t)a2, (uint64_t)v304, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                uint64_t v134 = (*(uint64_t (**)(uint64_t))(*(void *)(v133 + 8) + 120))(v132);
                (*(void (**)(char *, uint64_t))(v303 + 8))(v130, v132);
                *(float *)&_S8 = COERCE_DOUBLE((v313 << 63) | ((unint64_t)(v129 & 0x7FF) << 52) | v134 & 0xFFFFFFFFFFFFFLL);
              }
              goto LABEL_29;
            }
          }
          else if (v79 == 8)
          {
            if (v80 == 23)
            {
              uint64_t v90 = v293;
              uint64_t v91 = v313;
              v307((char *)v293, v313, a2);
              LODWORD(v9_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = swift_dynamicCast((char *)&v315, v90, a2, (const char *)&type metadata for Float, 6uLL);
              _S8 = v315;
              uint64_t v92 = v296;
              (*(void (**)(char *, uint64_t, Class *))(v279 + 32))(v296, v91, a2);
              if (v90)
              {
                v63(v92, a2);
              }
              else
              {
                LODWORD(v313) = (*(uint64_t (**)(Class *, uint64_t))(v6 + 168))(a2, v6);
                uint64_t v135 = v299;
                (*(void (**)(Class *, uint64_t))(v3 + 112))(a2, v3);
                uint64_t v136 = (uint64_t)v301;
                uint64_t v137 = swift_getAssociatedConformanceWitness(v3, (uint64_t)a2, (uint64_t)v301, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                uint64_t v138 = v3;
                unsigned __int8 v139 = (*(uint64_t (**)(uint64_t))(*(void *)(v137 + 8) + 120))(v136);
                (*(void (**)(char *, uint64_t))(v300 + 8))(v135, v136);
                uint64_t v140 = v302;
                (*(void (**)(Class *, uint64_t))(v138 + 120))(a2, v138);
                v63(v92, a2);
                uint64_t v141 = v138;
                uint64_t v142 = (uint64_t)v304;
                uint64_t v143 = swift_getAssociatedConformanceWitness(v141, (uint64_t)a2, (uint64_t)v304, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                int v144 = (*(uint64_t (**)(uint64_t))(*(void *)(v143 + 8) + 120))(v142);
                (*(void (**)(char *, uint64_t))(v303 + 8))(v140, v142);
                _S8 = (v313 << 31) | (v139 << 23) | v144 & 0x7FFFFF;
              }
              goto LABEL_29;
            }
          }
          else if (v79 == 5 && v80 == 10)
          {
            uint64_t v81 = v292;
            uint64_t v82 = v313;
            v307((char *)v292, v313, a2);
            LODWORD(v81) = swift_dynamicCast((char *)&v315, v81, a2, (const char *)&type metadata for Float16, 6uLL);
            _H8 = v315;
            uint64_t v84 = v295;
            (*(void (**)(char *, uint64_t, Class *))(v279 + 32))(v295, v82, a2);
            if (v81)
            {
              v63(v84, a2);
            }
            else
            {
              LODWORD(v313) = (*(uint64_t (**)(Class *, uint64_t))(v6 + 168))(a2, v6);
              uint64_t v111 = v299;
              (*(void (**)(Class *, uint64_t))(v3 + 112))(a2, v3);
              uint64_t v112 = (uint64_t)v301;
              uint64_t v113 = swift_getAssociatedConformanceWitness(v3, (uint64_t)a2, (uint64_t)v301, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
              uint64_t v114 = v3;
              char v115 = (*(uint64_t (**)(uint64_t))(*(void *)(v113 + 8) + 120))(v112);
              (*(void (**)(char *, uint64_t))(v300 + 8))(v111, v112);
              uint64_t v116 = v302;
              (*(void (**)(Class *, uint64_t))(v114 + 120))(a2, v114);
              v63(v84, a2);
              uint64_t v117 = v114;
              uint64_t v118 = (uint64_t)v304;
              uint64_t v119 = swift_getAssociatedConformanceWitness(v117, (uint64_t)a2, (uint64_t)v304, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
              __int16 v120 = (*(uint64_t (**)(uint64_t))(*(void *)(v119 + 8) + 120))(v118);
              (*(void (**)(char *, uint64_t))(v303 + 8))(v116, v118);
              _H8 = ((_WORD)v313 << 15) | ((v115 & 0x1F) << 10) | v120 & 0x3FF;
            }
            __asm { FCVT            S8, H8 }
            goto LABEL_29;
          }
          uint64_t v93 = v313;
          specialized static BinaryFloatingPoint._convert<A>(from:)((float *)&v315, v313, (uint64_t)a2, v3);
          v63((char *)v93, a2);
          _S8 = v315;
LABEL_29:
          unsigned __int8 v60 = 0;
          uint64_t v59 = _S8;
          goto LABEL_30;
        }
        uint64_t v109 = v310;
        v108(v310, v312, v69);
        uint64_t v74 = v311;
        uint64_t v110 = (*(uint64_t (**)(uint64_t *, uint64_t))(v311 + 120))(v69, v311);
        uint64_t v278 = *(void (**)(char *, uint64_t *))(v107 + 8);
        v278(v109, v69);
        uint64_t v75 = v107;
        uint64_t v78 = v276;
        if (v110 >= v315) {
          goto LABEL_52;
        }
      }
    }
    int64_t v315 = -149;
    if (v78(v69, v74))
    {
      unint64_t v155 = v312;
      uint64_t v156 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v74);
      if (v156 < 64)
      {
        uint64_t v159 = v310;
        (*(void (**)(char *, char *, uint64_t *))(v75 + 16))(v310, v155, v69);
        uint64_t v160 = (*(uint64_t (**)(uint64_t *, uint64_t))(v74 + 120))(v69, v74);
LABEL_72:
        v278(v159, v69);
        if (v160 < v315) {
          goto LABEL_73;
        }
        goto LABEL_77;
      }
      char v193 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v74 + 96);
      unint64_t v194 = lazy protocol witness table accessor for type Int and conformance Int(v156, v157, v158);
      long long v180 = v310;
      v193(&v315, &type metadata for Int, v194, v69, v74);
      uint64_t v75 = v309;
      char v181 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8) + 16))(v155, v180, v69);
    }
    else
    {
      char v174 = v78(v69, v74);
      uint64_t v175 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v74);
      if ((v174 & 1) == 0)
      {
        uint64_t v196 = *(void (**)(char *, char *, uint64_t *))(v75 + 16);
        if (v175 >= 64)
        {
          uint64_t v206 = v283;
          unint64_t v155 = v312;
          v196(v283, v312, v69);
          v278(v206, v69);
          goto LABEL_77;
        }
        uint64_t v159 = v310;
        unint64_t v155 = v312;
        v196(v310, v312, v69);
        uint64_t v160 = (*(uint64_t (**)(uint64_t *, uint64_t))(v74 + 120))(v69, v74);
        goto LABEL_72;
      }
      if (v175 <= 64)
      {
        uint64_t v197 = v288;
        char v198 = v287;
        uint64_t v199 = swift_getAssociatedConformanceWitness((uint64_t)v288, (uint64_t)v69, (uint64_t)v287, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v200 = v286;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v199 + 8))(&qword_18162B0B8, 256, v198, v199);
        uint64_t v201 = v310;
        ((void (*)(char *, uint64_t *, int **))v197[3])(v200, v69, v197);
        LOBYTE(v198) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8)
                                                                            + 16))(v312, v201, v69);
        char v202 = v201;
        unint64_t v203 = v278;
        v278(v202, v69);
        unint64_t v204 = *(void (**)(char *, char *, uint64_t *))(v75 + 16);
        unint64_t v205 = v284;
        v204(v284, v312, v69);
        if (v198)
        {
          v203(v205, v69);
          unint64_t v155 = v312;
          goto LABEL_73;
        }
        int64_t v230 = v315;
        uint64_t v231 = (*(uint64_t (**)(uint64_t *, uint64_t))(v311 + 120))(v69, v311);
        v203(v205, v69);
        BOOL v154 = v231 < v230;
        uint64_t v74 = v311;
        unint64_t v155 = v312;
        uint64_t v75 = v309;
        if (v154) {
          goto LABEL_73;
        }
        goto LABEL_77;
      }
      unint64_t v178 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v74 + 96);
      unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v175, v176, v177);
      long long v180 = v310;
      v178(&v315, &type metadata for Int, v179, v69, v74);
      uint64_t v75 = v309;
      unint64_t v155 = v312;
      char v181 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v74 + 32) + 8) + 16))(v312, v180, v69);
    }
    char v195 = v181;
    v278(v180, v69);
    if (v195)
    {
LABEL_73:
      v272((char *)v313, a2);
      v278(v155, v69);
      goto LABEL_3;
    }
LABEL_77:
    uint64_t v284 = (char *)(*(uint64_t (**)(Class *))(v273 + 136))(a2);
    uint64_t v207 = v305;
    (*(void (**)(char *, char *, uint64_t *))(v75 + 32))(v305, v155, v69);
    char v208 = v276(v69, v74);
    uint64_t v209 = v74;
    uint64_t v210 = *(char **)(v75 + 16);
    unint64_t v211 = v290;
    uint64_t v312 = (char *)(v75 + 16);
    uint64_t v291 = v210;
    ((void (*)(char *, char *, uint64_t *))v210)(v290, v207, v69);
    if ((v208 & 1) == 0)
    {
      v278(v211, v69);
      goto LABEL_100;
    }
    uint64_t v212 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v209);
    v278(v211, v69);
    if (v212 <= 64) {
      goto LABEL_100;
    }
    v290 = (char *)(v75 + 8);
    uint64_t v213 = v285;
    ((void (*)(char *, char *, uint64_t *))v291)(v285, v305, v69);
    int64_t v315 = 0x8000000000000000;
    uint64_t v214 = v276;
    if (v276(v69, v209))
    {
      uint64_t v215 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v209);
      if (v215 >= 64)
      {
        Swift::String::Index v232 = v213;
        uint64_t v233 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v209 + 96);
        unint64_t v234 = lazy protocol witness table accessor for type Int and conformance Int(v215, v216, v217);
        Swift::String::Index v235 = v310;
        v233(&v315, &type metadata for Int, v234, v69, v209);
        uint64_t v213 = v232;
        char v236 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v209 + 32) + 8) + 16))(v232, v235, v69);
        unint64_t v220 = v278;
        v278(v235, v69);
        if (v236) {
          goto LABEL_121;
        }
LABEL_98:
        v270 = v213;
        goto LABEL_99;
      }
      unint64_t v218 = v310;
      ((void (*)(char *, char *, uint64_t *))v291)(v310, v213, v69);
      uint64_t v219 = (*(uint64_t (**)(uint64_t *, uint64_t))(v209 + 120))(v69, v209);
      unint64_t v220 = v278;
      v278(v218, v69);
    }
    else
    {
      char v221 = v214(v69, v209);
      uint64_t v222 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v209);
      if (v221)
      {
        if (v222 <= 64)
        {
          uint64_t v238 = v288;
          uint64_t v69 = v306;
          uint64_t v239 = v287;
          uint64_t v240 = swift_getAssociatedConformanceWitness((uint64_t)v288, (uint64_t)v306, (uint64_t)v287, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          int64_t v241 = v286;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v240 + 8))(&qword_18162B0B8, 256, v239, v240);
          uint64_t v242 = v310;
          ((void (*)(char *, uint64_t *, int **))v238[3])(v241, v69, v238);
          uint64_t v243 = v311;
          uint64_t v244 = v285;
          LOBYTE(v239) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v311 + 32) + 8)
                                                                              + 16))(v285, v242, v69);
          unint64_t v220 = v278;
          v278(v242, v69);
          uint64_t v245 = v282;
          ((void (*)(char *, char *, uint64_t *))v291)(v282, v244, v69);
          if (v239)
          {
LABEL_120:
            v220(v245, v69);
            goto LABEL_121;
          }
          int64_t v246 = v315;
          uint64_t v247 = (*(uint64_t (**)(uint64_t *, uint64_t))(v243 + 120))(v69, v243);
          v220(v245, v69);
          uint64_t v213 = v285;
          if (v247 < v246) {
            goto LABEL_121;
          }
        }
        else
        {
          uint64_t v225 = v311;
          uint64_t v226 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v311 + 96);
          unint64_t v227 = lazy protocol witness table accessor for type Int and conformance Int(v222, v223, v224);
          uint64_t v228 = v310;
          uint64_t v69 = v306;
          v226(&v315, &type metadata for Int, v227, v306, v225);
          uint64_t v213 = v285;
          char v229 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v225 + 32) + 8) + 16))(v285, v228, v69);
          unint64_t v220 = v278;
          v278(v228, v69);
          if (v229) {
            goto LABEL_121;
          }
        }
        goto LABEL_98;
      }
      unint64_t v220 = v278;
      if (v222 >= 64)
      {
        v270 = v285;
        uint64_t v69 = v306;
LABEL_99:
        v220(v270, v69);
        uint64_t v209 = v311;
LABEL_100:
        uint64_t v248 = v305;
        uint64_t v245 = v277;
        uint64_t v249 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v209);
        uint64_t v250 = v289;
        ((void (*)(char *, char *, uint64_t *))v291)(v289, v248, v69);
        v290 = (char *)(v209 + 128);
        if (v249 < 65)
        {
          uint64_t v262 = ((uint64_t (*)(uint64_t *, uint64_t))v245)(v69, v209);
          v278(v250, v69);
          uint64_t v251 = v313;
          uint64_t v252 = v276;
          if (v262 != 64)
          {
            unint64_t v220 = v278;
LABEL_115:
            v268 = v305;
            uint64_t v269 = (*(uint64_t (**)(uint64_t *))(v311 + 120))(v69);
            v220(v268, v69);
            if (!__OFADD__(v269, 149))
            {
              uint64_t v63 = v272;
              uint64_t v3 = v273;
              if (v269 + 149 < (uint64_t)v284)
              {
                uint64_t v192 = v251;
                goto LABEL_118;
              }
              goto LABEL_16;
            }
            __break(1u);
            goto LABEL_120;
          }
          char v263 = v276(v69, v209);
          unint64_t v220 = v278;
          if (v263) {
            goto LABEL_115;
          }
        }
        else
        {
          v278(v250, v69);
          uint64_t v251 = v313;
          uint64_t v252 = v276;
        }
        ((void (*)(char *, char *, uint64_t *))v291)(v298, v305, v69);
        int64_t v315 = 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v253 = v311;
        char v254 = v252(v69, v311);
        uint64_t v255 = ((uint64_t (*)(uint64_t *, uint64_t))v277)(v69, v253);
        if (v254)
        {
          if (v255 > 64)
          {
            uint64_t v258 = v311;
            uint64_t v259 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v311 + 96);
            unint64_t v260 = lazy protocol witness table accessor for type Int and conformance Int(v255, v256, v257);
            unint64_t v261 = &v315;
            goto LABEL_113;
          }
        }
        else if (v255 >= 64)
        {
          uint64_t v314 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v258 = v311;
          uint64_t v259 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v311 + 96);
          unint64_t v260 = lazy protocol witness table accessor for type Int and conformance Int(v255, v256, v257);
          unint64_t v261 = &v314;
LABEL_113:
          uint64_t v245 = v310;
          uint64_t v69 = v306;
          v259(v261, &type metadata for Int, v260, v306, v258);
          uint64_t v251 = v313;
          char v267 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v258 + 32) + 8) + 16))(v245, v298, v69);
          unint64_t v220 = v278;
          v278(v245, v69);
          if ((v267 & 1) == 0) {
            goto LABEL_114;
          }
          goto LABEL_111;
        }
        uint64_t v264 = v310;
        uint64_t v69 = v306;
        ((void (*)(char *, char *, uint64_t *))v291)(v310, v298, v306);
        uint64_t v265 = (*(uint64_t (**)(uint64_t *))(v311 + 120))(v69);
        unint64_t v266 = v264;
        unint64_t v220 = v278;
        v278(v266, v69);
        if (v315 >= v265)
        {
LABEL_114:
          v220(v298, v69);
          goto LABEL_115;
        }
LABEL_111:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      uint64_t v237 = v310;
      uint64_t v213 = v285;
      uint64_t v69 = v306;
      ((void (*)(char *, char *, uint64_t *))v291)(v310, v285, v306);
      uint64_t v219 = (*(uint64_t (**)(uint64_t *))(v311 + 120))(v69);
      v220(v237, v69);
    }
    if (v219 < v315) {
LABEL_121:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_98;
  }
  (*(void (**)(uint64_t, Class *))(v41 + 8))(a1, a2);
LABEL_3:
  uint64_t v59 = 0;
  unsigned __int8 v60 = 1;
LABEL_30:
  LOBYTE(v315) = v60;
  return v59 | ((unint64_t)v60 << 32);
}

{
  uint64_t v3;
  uint64_t v6;
  const char *AssociatedTypeWitness;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  char *v58;
  int v60;
  uint64_t v61;
  void (*v62)(char *, Class *);
  char v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t (*v67)(uint64_t *, uint64_t);
  uint64_t *v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t (*v77)(uint64_t *, uint64_t);
  uint64_t v78;
  uint64_t v79;
  unint64_t *v80;
  uint64_t v81;
  char *v83;
  unint64_t *v84;
  uint64_t v85;
  char *v87;
  unint64_t *v88;
  uint64_t v89;
  float v90;
  char *v91;
  uint64_t v92;
  char v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  void (*v97)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v98;
  char *v99;
  char v100;
  void (*v101)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v102;
  char *v103;
  char v104;
  uint64_t v105;
  void (*v106)(char *, char *, uint64_t *);
  char *v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  __int16 v118;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  __int16 v127;
  char *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unsigned __int8 v137;
  char *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  int **v143;
  const char *v144;
  uint64_t v145;
  char *v146;
  char *v147;
  char *v148;
  uint64_t v149;
  int64_t v150;
  uint64_t v151;
  BOOL v152;
  char *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  char *v157;
  uint64_t v158;
  char v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  void (*v163)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v164;
  char *v165;
  char *v166;
  char v167;
  void (*v168)(char *, uint64_t *);
  uint64_t v169;
  char *v170;
  uint64_t v171;
  char v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  void (*v176)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v177;
  char *v178;
  char v179;
  char *v180;
  uint64_t v181;
  uint64_t (*v182)(char *, char *, uint64_t *);
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186;
  char *v187;
  char v188;
  void (*v189)(char *, uint64_t *);
  uint64_t v190;
  void (*v191)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v192;
  char v193;
  void (*v194)(char *, char *, uint64_t *);
  int **v195;
  const char *v196;
  uint64_t AssociatedConformanceWitness;
  char *v198;
  char *v199;
  char *v200;
  void (*v201)(char *, uint64_t *);
  void (*v202)(char *, char *, uint64_t *);
  char *v203;
  char *v204;
  char *v205;
  char v206;
  uint64_t v207;
  char *v208;
  char *v209;
  uint64_t v210;
  char *v211;
  uint64_t (*v212)(uint64_t *, uint64_t);
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  char *v216;
  uint64_t v217;
  void (*v218)(char *, uint64_t *);
  char v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  void (*v224)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v225;
  char *v226;
  char v227;
  int64_t v228;
  uint64_t v229;
  char *v230;
  void (*v231)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v232;
  char *v233;
  char v234;
  char *v235;
  int **v236;
  const char *v237;
  uint64_t v238;
  char *v239;
  char *v240;
  uint64_t v241;
  char *v242;
  char *v243;
  int64_t v244;
  uint64_t v245;
  char *v246;
  uint64_t v247;
  char *v248;
  uint64_t v249;
  uint64_t (*v250)(uint64_t *, uint64_t);
  uint64_t v251;
  char v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  void (*v257)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v258;
  int64_t *v259;
  uint64_t v260;
  char v261;
  char *v262;
  uint64_t v263;
  char *v264;
  char v265;
  char *v266;
  uint64_t v267;
  char *v268;
  uint64_t v269;
  void (*v270)(uint64_t, Class *);
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t (*v274)(uint64_t *, uint64_t);
  char *v275;
  void (*v276)(char *, uint64_t *);
  uint64_t v277;
  uint64_t (*v278)(Class *, uint64_t);
  uint64_t v279;
  char *v280;
  char *v281;
  char *v282;
  char *v283;
  char *v284;
  const char *v285;
  int **v286;
  char *v287;
  char *v288;
  char *v289;
  unint64_t *v290;
  unint64_t *v291;
  unint64_t *v292;
  char *v293;
  char *v294;
  char *v295;
  char *v296;
  char *v297;
  uint64_t v298;
  const char *v299;
  char *v300;
  uint64_t v301;
  const char *v302;
  char *v303;
  uint64_t *v304;
  void (*v305)(char *, uint64_t, Class *);
  uint64_t v306;
  uint64_t v307;
  char *v308;
  uint64_t v309;
  char *v310;
  uint64_t v311;
  uint64_t v312;
  int64_t v313;

  uint64_t v3 = a3;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v309 = *(void *)(swift_getAssociatedConformanceWitness(v6, (uint64_t)a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  uint64_t v286 = *(int ***)(*(void *)(v309 + 24) + 16);
  v285 = swift_getAssociatedTypeWitness(0, v286, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v285);
  uint64_t v284 = (char *)&v269 - v8;
  uint64_t v9 = swift_getAssociatedTypeWitness(0, (int **)v3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v301 = *((void *)v9 - 1);
  uint64_t v302 = v9;
  MEMORY[0x1F4188790](v9);
  uint64_t v300 = (char *)&v269 - v10;
  uint64_t v11 = swift_getAssociatedTypeWitness(0, (int **)v3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  v298 = *((void *)v11 - 1);
  uint64_t v299 = v11;
  MEMORY[0x1F4188790](v11);
  v297 = (char *)&v269 - v12;
  v304 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v307 = *(v304 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v304);
  uint64_t v15 = (char *)&v269 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v269 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v289 = (char *)&v269 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v281 = (char *)&v269 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v282 = (char *)&v269 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v280 = (char *)&v269 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v296 = (char *)&v269 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  v287 = (char *)&v269 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v283 = (char *)&v269 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  int64_t v288 = (char *)&v269 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v303 = (char *)&v269 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v308 = (char *)&v269 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v310 = (char *)&v269 - v40;
  uint64_t v41 = (uint64_t)*(a2 - 1);
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  v295 = (char *)&v269 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  v292 = (unint64_t *)((char *)&v269 - v45);
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v294 = (char *)&v269 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  uint64_t v291 = (unint64_t *)((char *)&v269 - v49);
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v293 = (char *)&v269 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  v290 = (unint64_t *)((char *)&v269 - v53);
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  uint64_t v56 = (char *)&v269 - v55;
  MEMORY[0x1F4188790](v54);
  uint64_t v58 = (char *)&v269 - v57;
  if ((*(uint64_t (**)(Class *, uint64_t))(v6 + 408))(a2, v6))
  {
    (*(void (**)(uint64_t, Class *))(v41 + 8))(a1, a2);
    return 0;
  }
  uint64_t v311 = a1;
  uint64_t v278 = *(uint64_t (**)(Class *, uint64_t))(v3 + 96);
  unsigned __int8 v60 = v278(a2, v3) > 11 || (*(uint64_t (**)(Class *, uint64_t))(v3 + 104))(a2, v3) > 52;
  v305 = *(void (**)(char *, uint64_t, Class *))(v41 + 16);
  v306 = v41 + 16;
  v305(v58, v311, a2);
  uint64_t v279 = v3 + 96;
  if (v60) {
    LOBYTE(v6_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(Class *, uint64_t))(v6 + 376))(a2, v6);
  }
  v277 = v41;
  int v61 = v41 + 8;
  uint64_t v62 = *(void (**)(char *, Class *))(v41 + 8);
  v62(v58, a2);
  v305(v56, v311, a2);
  if ((v60 & 1) == 0)
  {
    v62(v56, a2);
    goto LABEL_16;
  }
  uint64_t v63 = (*(uint64_t (**)(Class *, uint64_t))(v6 + 384))(a2, v6);
  v62(v56, a2);
  if (v63) {
    goto LABEL_16;
  }
  uint64_t v271 = v3;
  uint64_t v272 = v61;
  v270 = (void (*)(uint64_t, Class *))v62;
  char v64 = v310;
  (*(void (**)(Class *, uint64_t))(v6 + 176))(a2, v6);
  uint64_t v313 = -1022;
  char v65 = v309;
  uint64_t v66 = v309 + 64;
  uint64_t v67 = *(uint64_t (**)(uint64_t *, uint64_t))(v309 + 64);
  uint64_t v68 = v304;
  uint64_t v69 = v67(v304, v309);
  uint64_t v273 = v66;
  uint64_t v274 = v67;
  if (v69)
  {
    uint64_t v275 = *(char **)(v65 + 128);
    char v70 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v65);
    uint64_t v73 = v65;
    if (v70 >= 64)
    {
      uint64_t v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v65 + 96);
      char v102 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      uint64_t v103 = v308;
      v101(&v313, &type metadata for Int, v102, v68, v73);
      unint64_t v104 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8) + 16))(v64, v103, v68);
      uint64_t v74 = v307;
      int64_t v276 = *(void (**)(char *, uint64_t *))(v307 + 8);
      v276(v103, v68);
      uint64_t v77 = v274;
      if ((v104 & 1) == 0) {
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v74 = v307;
      uint64_t v75 = v308;
      (*(void (**)(char *, char *, uint64_t *))(v307 + 16))(v308, v64, v68);
      uint64_t v76 = (*(uint64_t (**)(uint64_t *, uint64_t))(v65 + 120))(v68, v65);
      int64_t v276 = *(void (**)(char *, uint64_t *))(v74 + 8);
      v276(v75, v68);
      uint64_t v77 = v274;
      if (v76 >= v313) {
        goto LABEL_51;
      }
    }
LABEL_48:
    uint64_t v313 = -1074;
    if (v77(v68, v73))
    {
      uint64_t v153 = v310;
      BOOL v154 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v73);
      if (v154 < 64)
      {
        uint64_t v157 = v308;
        (*(void (**)(char *, char *, uint64_t *))(v74 + 16))(v308, v153, v68);
        uint64_t v158 = (*(uint64_t (**)(uint64_t *, uint64_t))(v73 + 120))(v68, v73);
LABEL_71:
        v276(v157, v68);
        if (v158 < v313) {
          goto LABEL_72;
        }
        goto LABEL_76;
      }
      BOOL v191 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v73 + 96);
      uint64_t v192 = lazy protocol witness table accessor for type Int and conformance Int(v154, v155, v156);
      unint64_t v178 = v308;
      v191(&v313, &type metadata for Int, v192, v68, v73);
      uint64_t v74 = v307;
      unint64_t v179 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8) + 16))(v153, v178, v68);
    }
    else
    {
      uint64_t v172 = v77(v68, v73);
      uint64_t v173 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v73);
      if ((v172 & 1) == 0)
      {
        unint64_t v194 = *(void (**)(char *, char *, uint64_t *))(v74 + 16);
        if (v173 >= 64)
        {
          unint64_t v204 = v281;
          uint64_t v153 = v310;
          v194(v281, v310, v68);
          v276(v204, v68);
          goto LABEL_76;
        }
        uint64_t v157 = v308;
        uint64_t v153 = v310;
        v194(v308, v310, v68);
        uint64_t v158 = (*(uint64_t (**)(uint64_t *, uint64_t))(v73 + 120))(v68, v73);
        goto LABEL_71;
      }
      if (v173 <= 64)
      {
        char v195 = v286;
        uint64_t v196 = v285;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v286, (uint64_t)v68, (uint64_t)v285, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v198 = v284;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v196, AssociatedConformanceWitness);
        uint64_t v199 = v308;
        ((void (*)(char *, uint64_t *, int **))v195[3])(v198, v68, v195);
        LOBYTE(v196) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8)
                                                                            + 16))(v310, v199, v68);
        uint64_t v200 = v199;
        uint64_t v201 = v276;
        v276(v200, v68);
        char v202 = *(void (**)(char *, char *, uint64_t *))(v74 + 16);
        unint64_t v203 = v282;
        v202(v282, v310, v68);
        if (v196)
        {
          v201(v203, v68);
          uint64_t v153 = v310;
          goto LABEL_72;
        }
        uint64_t v228 = v313;
        char v229 = (*(uint64_t (**)(uint64_t *, uint64_t))(v309 + 120))(v68, v309);
        v201(v203, v68);
        int64_t v152 = v229 < v228;
        uint64_t v73 = v309;
        uint64_t v153 = v310;
        uint64_t v74 = v307;
        if (v152) {
          goto LABEL_72;
        }
        goto LABEL_76;
      }
      uint64_t v176 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v73 + 96);
      uint64_t v177 = lazy protocol witness table accessor for type Int and conformance Int(v173, v174, v175);
      unint64_t v178 = v308;
      v176(&v313, &type metadata for Int, v177, v68, v73);
      uint64_t v74 = v307;
      uint64_t v153 = v310;
      unint64_t v179 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8) + 16))(v310, v178, v68);
    }
    char v193 = v179;
    v276(v178, v68);
    if (v193)
    {
LABEL_72:
      v270(v311, a2);
      v276(v153, v68);
      return 0;
    }
LABEL_76:
    v282 = (char *)(*(uint64_t (**)(Class *))(v271 + 136))(a2);
    unint64_t v205 = v303;
    (*(void (**)(char *, char *, uint64_t *))(v74 + 32))(v303, v153, v68);
    uint64_t v206 = v274(v68, v73);
    uint64_t v207 = v73;
    char v208 = *(char **)(v74 + 16);
    uint64_t v209 = v288;
    uint64_t v310 = (char *)(v74 + 16);
    uint64_t v289 = v208;
    ((void (*)(char *, char *, uint64_t *))v208)(v288, v205, v68);
    if ((v206 & 1) == 0)
    {
      v276(v209, v68);
      goto LABEL_99;
    }
    uint64_t v210 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v207);
    v276(v209, v68);
    if (v210 <= 64) {
      goto LABEL_99;
    }
    int64_t v288 = (char *)(v74 + 8);
    unint64_t v211 = v283;
    ((void (*)(char *, char *, uint64_t *))v289)(v283, v303, v68);
    uint64_t v313 = 0x8000000000000000;
    uint64_t v212 = v274;
    if (v274(v68, v207))
    {
      uint64_t v213 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v207);
      if (v213 >= 64)
      {
        int64_t v230 = v211;
        uint64_t v231 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v207 + 96);
        Swift::String::Index v232 = lazy protocol witness table accessor for type Int and conformance Int(v213, v214, v215);
        uint64_t v233 = v308;
        v231(&v313, &type metadata for Int, v232, v68, v207);
        unint64_t v211 = v230;
        unint64_t v234 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v207 + 32) + 8) + 16))(v230, v233, v68);
        unint64_t v218 = v276;
        v276(v233, v68);
        if (v234) {
          goto LABEL_120;
        }
LABEL_97:
        v268 = v211;
        goto LABEL_98;
      }
      uint64_t v216 = v308;
      ((void (*)(char *, char *, uint64_t *))v289)(v308, v211, v68);
      uint64_t v217 = (*(uint64_t (**)(uint64_t *, uint64_t))(v207 + 120))(v68, v207);
      unint64_t v218 = v276;
      v276(v216, v68);
    }
    else
    {
      uint64_t v219 = v212(v68, v207);
      unint64_t v220 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v207);
      if (v219)
      {
        if (v220 <= 64)
        {
          char v236 = v286;
          uint64_t v68 = v304;
          uint64_t v237 = v285;
          uint64_t v238 = swift_getAssociatedConformanceWitness((uint64_t)v286, (uint64_t)v304, (uint64_t)v285, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v239 = v284;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v238 + 8))(&qword_18162B0B8, 256, v237, v238);
          uint64_t v240 = v308;
          ((void (*)(char *, uint64_t *, int **))v236[3])(v239, v68, v236);
          int64_t v241 = v309;
          uint64_t v242 = v283;
          LOBYTE(v237) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v309 + 32) + 8)
                                                                              + 16))(v283, v240, v68);
          unint64_t v218 = v276;
          v276(v240, v68);
          uint64_t v243 = v280;
          ((void (*)(char *, char *, uint64_t *))v289)(v280, v242, v68);
          if (v237)
          {
LABEL_119:
            v218(v243, v68);
            goto LABEL_120;
          }
          uint64_t v244 = v313;
          uint64_t v245 = (*(uint64_t (**)(uint64_t *, uint64_t))(v241 + 120))(v68, v241);
          v218(v243, v68);
          unint64_t v211 = v283;
          if (v245 < v244) {
            goto LABEL_120;
          }
        }
        else
        {
          uint64_t v223 = v309;
          uint64_t v224 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v309 + 96);
          uint64_t v225 = lazy protocol witness table accessor for type Int and conformance Int(v220, v221, v222);
          uint64_t v226 = v308;
          uint64_t v68 = v304;
          v224(&v313, &type metadata for Int, v225, v304, v223);
          unint64_t v211 = v283;
          unint64_t v227 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v223 + 32) + 8) + 16))(v283, v226, v68);
          unint64_t v218 = v276;
          v276(v226, v68);
          if (v227) {
            goto LABEL_120;
          }
        }
        goto LABEL_97;
      }
      unint64_t v218 = v276;
      if (v220 >= 64)
      {
        v268 = v283;
        uint64_t v68 = v304;
LABEL_98:
        v218(v268, v68);
        uint64_t v207 = v309;
LABEL_99:
        int64_t v246 = v303;
        uint64_t v243 = v275;
        uint64_t v247 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v207);
        uint64_t v248 = v287;
        ((void (*)(char *, char *, uint64_t *))v289)(v287, v246, v68);
        int64_t v288 = (char *)(v207 + 128);
        if (v247 < 65)
        {
          unint64_t v260 = ((uint64_t (*)(uint64_t *, uint64_t))v243)(v68, v207);
          v276(v248, v68);
          uint64_t v249 = v311;
          uint64_t v250 = v274;
          if (v260 != 64)
          {
            unint64_t v218 = v276;
LABEL_114:
            unint64_t v266 = v303;
            char v267 = (*(uint64_t (**)(uint64_t *))(v309 + 120))(v68);
            v218(v266, v68);
            if (!__OFADD__(v267, 1074))
            {
              uint64_t v62 = (void (*)(char *, Class *))v270;
              uint64_t v3 = v271;
              if (v267 + 1074 < (uint64_t)v282)
              {
                char v190 = v249;
                goto LABEL_117;
              }
              goto LABEL_16;
            }
            __break(1u);
            goto LABEL_119;
          }
          unint64_t v261 = v274(v68, v207);
          unint64_t v218 = v276;
          if (v261) {
            goto LABEL_114;
          }
        }
        else
        {
          v276(v248, v68);
          uint64_t v249 = v311;
          uint64_t v250 = v274;
        }
        ((void (*)(char *, char *, uint64_t *))v289)(v296, v303, v68);
        uint64_t v313 = 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v251 = v309;
        uint64_t v252 = v250(v68, v309);
        uint64_t v253 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v251);
        if (v252)
        {
          if (v253 > 64)
          {
            uint64_t v256 = v309;
            uint64_t v257 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v309 + 96);
            uint64_t v258 = lazy protocol witness table accessor for type Int and conformance Int(v253, v254, v255);
            uint64_t v259 = &v313;
            goto LABEL_112;
          }
        }
        else if (v253 >= 64)
        {
          uint64_t v312 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v256 = v309;
          uint64_t v257 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v309 + 96);
          uint64_t v258 = lazy protocol witness table accessor for type Int and conformance Int(v253, v254, v255);
          uint64_t v259 = &v312;
LABEL_112:
          uint64_t v243 = v308;
          uint64_t v68 = v304;
          v257(v259, &type metadata for Int, v258, v304, v256);
          uint64_t v249 = v311;
          uint64_t v265 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v256 + 32) + 8) + 16))(v243, v296, v68);
          unint64_t v218 = v276;
          v276(v243, v68);
          if ((v265 & 1) == 0) {
            goto LABEL_113;
          }
          goto LABEL_110;
        }
        uint64_t v262 = v308;
        uint64_t v68 = v304;
        ((void (*)(char *, char *, uint64_t *))v289)(v308, v296, v304);
        char v263 = (*(uint64_t (**)(uint64_t *))(v309 + 120))(v68);
        uint64_t v264 = v262;
        unint64_t v218 = v276;
        v276(v264, v68);
        if (v313 >= v263)
        {
LABEL_113:
          v218(v296, v68);
          goto LABEL_114;
        }
LABEL_110:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      Swift::String::Index v235 = v308;
      unint64_t v211 = v283;
      uint64_t v68 = v304;
      ((void (*)(char *, char *, uint64_t *))v289)(v308, v283, v304);
      uint64_t v217 = (*(uint64_t (**)(uint64_t *))(v309 + 120))(v68);
      v218(v235, v68);
    }
    if (v217 < v313) {
LABEL_120:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_97;
  }
  uint64_t v93 = v67(v68, v65);
  uint64_t v275 = *(char **)(v65 + 128);
  uint64_t v94 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v65);
  if (v93)
  {
    if (v94 <= 64)
    {
      uint64_t v143 = v286;
      int v144 = v285;
      unint64_t v145 = swift_getAssociatedConformanceWitness((uint64_t)v286, (uint64_t)v68, (uint64_t)v285, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v146 = v284;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v145 + 8))(&qword_18162B0B8, 256, v144, v145);
      uint64_t v147 = v308;
      ((void (*)(char *, uint64_t *, int **))v143[3])(v146, v68, v143);
      unint64_t v148 = v310;
      LOBYTE(v144) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v309 + 32) + 8)
                                                                          + 16))(v310, v147, v68);
      unint64_t v149 = v307;
      int64_t v276 = *(void (**)(char *, uint64_t *))(v307 + 8);
      v276(v147, v68);
      (*(void (**)(char *, char *, uint64_t *))(v149 + 16))(v18, v148, v68);
      if (v144)
      {
        v276(v18, v68);
        uint64_t v73 = v309;
        uint64_t v74 = v307;
        uint64_t v77 = v274;
      }
      else
      {
        uint64_t v150 = v313;
        uint64_t v73 = v309;
        uint64_t v151 = (*(uint64_t (**)(uint64_t *, uint64_t))(v309 + 120))(v68, v309);
        v276(v18, v68);
        int64_t v152 = v151 < v150;
        uint64_t v74 = v307;
        uint64_t v77 = v274;
        if (!v152) {
          goto LABEL_51;
        }
      }
    }
    else
    {
      uint64_t v73 = v309;
      uint64_t v97 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v309 + 96);
      uint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
      uint64_t v99 = v308;
      v97(&v313, &type metadata for Int, v98, v68, v73);
      unint64_t v100 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8) + 16))(v310, v99, v68);
      uint64_t v74 = v307;
      int64_t v276 = *(void (**)(char *, uint64_t *))(v307 + 8);
      v276(v99, v68);
      uint64_t v77 = v274;
      if ((v100 & 1) == 0) {
        goto LABEL_51;
      }
    }
    goto LABEL_48;
  }
  uint64_t v105 = v307;
  char v106 = *(void (**)(char *, char *, uint64_t *))(v307 + 16);
  if (v94 < 64)
  {
    uint64_t v107 = v308;
    v106(v308, v310, v68);
    uint64_t v73 = v309;
    char v108 = (*(uint64_t (**)(uint64_t *, uint64_t))(v309 + 120))(v68, v309);
    int64_t v276 = *(void (**)(char *, uint64_t *))(v105 + 8);
    v276(v107, v68);
    uint64_t v74 = v105;
    uint64_t v77 = v274;
    if (v108 >= v313) {
      goto LABEL_51;
    }
    goto LABEL_48;
  }
  v106(v15, v310, v68);
  int64_t v276 = *(void (**)(char *, uint64_t *))(v105 + 8);
  v276(v15, v68);
  uint64_t v73 = v309;
  uint64_t v74 = v105;
  uint64_t v77 = v274;
LABEL_51:
  uint64_t v313 = 1023;
  uint64_t v159 = v77(v68, v73);
  uint64_t v160 = ((uint64_t (*)(uint64_t *, uint64_t))v275)(v68, v73);
  if (v159)
  {
    uint64_t v62 = (void (*)(char *, Class *))v270;
    if (v160 <= 64)
    {
      long long v180 = v308;
      (*(void (**)(char *, char *, uint64_t *))(v74 + 32))(v308, v310, v68);
      char v181 = (*(uint64_t (**)(uint64_t *, uint64_t))(v73 + 120))(v68, v73);
      v276(v180, v68);
      char v169 = v311;
      uint64_t v3 = v271;
      if (v313 < v181) {
        goto LABEL_65;
      }
    }
    else
    {
      uint64_t v163 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v73 + 96);
      uint64_t v164 = lazy protocol witness table accessor for type Int and conformance Int(v160, v161, v162);
      uint64_t v165 = v308;
      v163(&v313, &type metadata for Int, v164, v68, v73);
      unint64_t v166 = v310;
      uint64_t v167 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8) + 16))(v165, v310, v68);
      unint64_t v168 = v276;
      v276(v165, v68);
      v168(v166, v68);
      char v169 = v311;
      uint64_t v3 = v271;
      if (v167) {
        goto LABEL_65;
      }
    }
  }
  else
  {
    uint64_t v62 = (void (*)(char *, Class *))v270;
    uint64_t v3 = v271;
    if (v160 > 63)
    {
      uint64_t v312 = 1023;
      uint64_t v182 = *(uint64_t (**)(char *, char *, uint64_t *))(v74 + 32);
      uint64_t v307 = v74 + 32;
      uint64_t v183 = v182(v289, v310, v68);
      uint64_t v310 = *(char **)(v73 + 96);
      uint64_t v186 = lazy protocol witness table accessor for type Int and conformance Int(v183, v184, v185);
      uint64_t v187 = v308;
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))v310)(&v312, &type metadata for Int, v186, v68, v73);
      unint64_t v188 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v73 + 32) + 8) + 16))(v187, v289, v68);
      char v189 = v276;
      v276(v187, v68);
      v189(v289, v68);
      char v169 = v311;
      if (v188)
      {
LABEL_65:
        char v190 = v169;
LABEL_117:
        v62((char *)v190, a2);
        return 0;
      }
    }
    else
    {
      unint64_t v170 = v308;
      (*(void (**)(char *, char *, uint64_t *))(v74 + 32))(v308, v310, v68);
      uint64_t v171 = (*(uint64_t (**)(uint64_t *, uint64_t))(v73 + 120))(v68, v73);
      v276(v170, v68);
      char v169 = v311;
      if (v313 < v171) {
        goto LABEL_65;
      }
    }
  }
  if ((*(uint64_t (**)(Class *, uint64_t))(v3 + 136))(a2, v3) >= 53) {
    goto LABEL_65;
  }
LABEL_16:
  uint64_t v78 = v278(a2, v3);
  uint64_t v79 = (*(uint64_t (**)(Class *, uint64_t))(v3 + 104))(a2, v3);
  if (v78 == 11)
  {
    if (v79 == 52)
    {
      uint64_t v84 = v292;
      int v85 = v311;
      v305((char *)v292, v311, a2);
      LODWORD(v84) = swift_dynamicCast((char *)&v313, v84, a2, (const char *)&type metadata for Double, 6uLL);
      _D8 = *(double *)&v313;
      double v87 = v295;
      (*(void (**)(char *, uint64_t, Class *))(v277 + 32))(v295, v85, a2);
      if (v84)
      {
        v62(v87, a2);
      }
      else
      {
        uint64_t v311 = (*(uint64_t (**)(Class *, uint64_t))(v6 + 168))(a2, v6);
        uint64_t v123 = v297;
        (*(void (**)(Class *, uint64_t))(v3 + 112))(a2, v3);
        uint64_t v124 = (uint64_t)v299;
        uint64_t v125 = swift_getAssociatedConformanceWitness(v3, (uint64_t)a2, (uint64_t)v299, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        uint64_t v126 = v3;
        uint64_t v127 = (*(uint64_t (**)(uint64_t))(*(void *)(v125 + 8) + 120))(v124);
        (*(void (**)(char *, uint64_t))(v298 + 8))(v123, v124);
        uint64_t v128 = v300;
        (*(void (**)(Class *, uint64_t))(v126 + 120))(a2, v126);
        v62(v87, a2);
        __int16 v129 = v126;
        uint64_t v130 = (uint64_t)v302;
        uint64_t v131 = swift_getAssociatedConformanceWitness(v129, (uint64_t)a2, (uint64_t)v302, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v132 = (*(uint64_t (**)(uint64_t))(*(void *)(v131 + 8) + 120))(v130);
        (*(void (**)(char *, uint64_t))(v301 + 8))(v128, v130);
        *(void *)&_D8 = (v311 << 63) | ((unint64_t)(v127 & 0x7FF) << 52) | v132 & 0xFFFFFFFFFFFFFLL;
      }
      return *(void *)&_D8;
    }
  }
  else if (v78 == 8)
  {
    if (v79 == 23)
    {
      uint64_t v88 = v291;
      int v89 = v311;
      v305((char *)v291, v311, a2);
      LODWORD(v88) = swift_dynamicCast((char *)&v313, v88, a2, (const char *)&type metadata for Float, 6uLL);
      uint64_t v90 = *(float *)&v313;
      uint64_t v91 = v294;
      (*(void (**)(char *, uint64_t, Class *))(v277 + 32))(v294, v89, a2);
      if (v88)
      {
        v62(v91, a2);
        _D8 = v90;
      }
      else
      {
        LODWORD(v311) = (*(uint64_t (**)(Class *, uint64_t))(v6 + 168))(a2, v6);
        uint64_t v133 = v297;
        (*(void (**)(Class *, uint64_t))(v3 + 112))(a2, v3);
        uint64_t v134 = (uint64_t)v299;
        uint64_t v135 = swift_getAssociatedConformanceWitness(v3, (uint64_t)a2, (uint64_t)v299, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        uint64_t v136 = v3;
        uint64_t v137 = (*(uint64_t (**)(uint64_t))(*(void *)(v135 + 8) + 120))(v134);
        (*(void (**)(char *, uint64_t))(v298 + 8))(v133, v134);
        uint64_t v138 = v300;
        (*(void (**)(Class *, uint64_t))(v136 + 120))(a2, v136);
        v62(v91, a2);
        unsigned __int8 v139 = v136;
        uint64_t v140 = (uint64_t)v302;
        uint64_t v141 = swift_getAssociatedConformanceWitness(v139, (uint64_t)a2, (uint64_t)v302, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v142 = (*(uint64_t (**)(uint64_t))(*(void *)(v141 + 8) + 120))(v140);
        (*(void (**)(char *, uint64_t))(v301 + 8))(v138, v140);
        _D8 = COERCE_FLOAT((v311 << 31) | (v137 << 23) | v142 & 0x7FFFFF);
      }
      return *(void *)&_D8;
    }
  }
  else if (v78 == 5 && v79 == 10)
  {
    uint64_t v80 = v290;
    uint64_t v81 = v311;
    v305((char *)v290, v311, a2);
    LODWORD(v8_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = swift_dynamicCast((char *)&v313, v80, a2, (const char *)&type metadata for Float16, 6uLL);
    _H8 = v313;
    uint64_t v83 = v293;
    (*(void (**)(char *, uint64_t, Class *))(v277 + 32))(v293, v81, a2);
    if (v80)
    {
      v62(v83, a2);
    }
    else
    {
      LODWORD(v311) = (*(uint64_t (**)(Class *, uint64_t))(v6 + 168))(a2, v6);
      uint64_t v109 = v297;
      (*(void (**)(Class *, uint64_t))(v3 + 112))(a2, v3);
      uint64_t v110 = (uint64_t)v299;
      uint64_t v111 = swift_getAssociatedConformanceWitness(v3, (uint64_t)a2, (uint64_t)v299, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      uint64_t v112 = v3;
      uint64_t v113 = (*(uint64_t (**)(uint64_t))(*(void *)(v111 + 8) + 120))(v110);
      (*(void (**)(char *, uint64_t))(v298 + 8))(v109, v110);
      uint64_t v114 = v300;
      (*(void (**)(Class *, uint64_t))(v112 + 120))(a2, v112);
      v62(v83, a2);
      char v115 = v112;
      uint64_t v116 = (uint64_t)v302;
      uint64_t v117 = swift_getAssociatedConformanceWitness(v115, (uint64_t)a2, (uint64_t)v302, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v118 = (*(uint64_t (**)(uint64_t))(*(void *)(v117 + 8) + 120))(v116);
      (*(void (**)(char *, uint64_t))(v301 + 8))(v114, v116);
      _H8 = ((_WORD)v311 << 15) | ((v113 & 0x1F) << 10) | v118 & 0x3FF;
    }
    __asm { FCVT            D8, H8 }
    return *(void *)&_D8;
  }
  uint64_t v92 = v311;
  specialized static BinaryFloatingPoint._convert<A>(from:)((double *)&v313, v311, (uint64_t)a2, v3);
  v62((char *)v92, a2);
  _D8 = *(double *)&v313;
  return *(void *)&_D8;
}

uint64_t FloatingPoint.rounded()(uint64_t a1, uint64_t a2)
{
  char v3 = 0;
  return (*(uint64_t (**)(char *, uint64_t))(a2 + 304))(&v3, a1);
}

Swift::Void __swiftcall FloatingPoint.round()()
{
  char v1 = 0;
  (*(void (**)(char *))(v0 + 312))(&v1);
}

uint64_t static BinaryFloatingPoint.radix.getter()
{
  return 2;
}

uint64_t BinaryFloatingPoint.init(signOf:magnitudeOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v10 = (char *)&v17 - v9;
  uint64_t v11 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  MEMORY[0x1F4188790](v11 - 8);
  uint64_t v13 = (char *)&v17 - v12;
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)(a4 + 16) + 168))(a3) & 1;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8);
  v15(a1, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 112))(a3, a4);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v15(a2, a3);
  return (*(uint64_t (**)(uint64_t, char *, char *, uint64_t, uint64_t))(a4 + 56))(v14, v13, v10, a3, a4);
}

uint64_t specialized static BinaryFloatingPoint._convert<A>(from:)(double *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v736 = a1;
  unint64_t v750 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  v748 = (int *)((char *)&v687 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v9);
  v742 = (uint64_t (**)(void))((char *)&v687 - v11);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, v12, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v741 = *(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8);
  uint64_t v721 = *(void *)(v741 + 24);
  v743 = *(int ***)(v721 + 16);
  v734 = swift_getAssociatedTypeWitness(0, v743, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v734);
  v735 = (char *)&v687 - v15;
  v732 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v740 = *(v732 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v732);
  v727 = (char *)&v687 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v751 = (char *)&v687 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v744 = (char *)&v687 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v693 = (char *)&v687 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v712 = (char *)&v687 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v707 = (char *)&v687 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v717 = (void (*)(uint64_t *, uint64_t))((char *)&v687 - v29);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v689 = (char *)&v687 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v699 = (char *)&v687 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  v700 = (char *)&v687 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  v714 = (char *)&v687 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v723 = (char *)&v687 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  v722 = (char *)&v687 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  v730 = (int **)((char *)&v687 - v43);
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  v725 = (char *)&v687 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v731 = (char *)&v687 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v691 = (char *)&v687 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v704 = (char *)&v687 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  v705 = (char *)&v687 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  v726 = (char *)&v687 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  v688 = (char *)&v687 - v57;
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  v697 = (char *)&v687 - v59;
  uint64_t v60 = MEMORY[0x1F4188790](v58);
  v698 = (char *)&v687 - v61;
  uint64_t v62 = MEMORY[0x1F4188790](v60);
  v713 = (char *)&v687 - v63;
  MEMORY[0x1F4188790](v62);
  v745 = (char *)&v687 - v64;
  uint64_t v746 = a4;
  uint64_t v65 = *(void *)(a4 + 16);
  uint64_t v66 = swift_getAssociatedTypeWitness(255, (int **)v65, a3, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v65, a3, (uint64_t)v66, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  uint64_t v67 = *(void *)(AssociatedConformanceWitness + 8);
  v729 = *(int ***)(v67 + 24);
  v739 = (int **)v729[2];
  v737 = swift_getAssociatedTypeWitness(0, v739, (uint64_t)v66, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v737);
  uint64_t v738 = (uint64_t)&v687 - v68;
  uint64_t v69 = (uint64_t)v66;
  uint64_t v70 = a3;
  uint64_t v71 = swift_checkMetadataState(0, v69);
  uint64_t v747 = *(v71 - 1);
  uint64_t v72 = MEMORY[0x1F4188790](v71);
  uint64_t v74 = (char *)&v687 - ((v73 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v75 = MEMORY[0x1F4188790](v72);
  uint64_t v77 = (char *)&v687 - v76;
  uint64_t v78 = MEMORY[0x1F4188790](v75);
  v711 = (char *)&v687 - v79;
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  v696 = (char *)&v687 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  v692 = (char *)&v687 - v83;
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  v716 = (char *)&v687 - v85;
  uint64_t v86 = MEMORY[0x1F4188790](v84);
  v706 = (char *)&v687 - v87;
  uint64_t v88 = MEMORY[0x1F4188790](v86);
  v728 = (char *)&v687 - v89;
  uint64_t v90 = MEMORY[0x1F4188790](v88);
  v690 = (char *)&v687 - v91;
  uint64_t v92 = MEMORY[0x1F4188790](v90);
  v709 = (char *)&v687 - v93;
  uint64_t v94 = MEMORY[0x1F4188790](v92);
  v701 = (char *)&v687 - v95;
  uint64_t v96 = MEMORY[0x1F4188790](v94);
  v715 = (int *)((char *)&v687 - v97);
  uint64_t v98 = MEMORY[0x1F4188790](v96);
  v702 = (char *)&v687 - v99;
  uint64_t v100 = MEMORY[0x1F4188790](v98);
  v703 = (char *)&v687 - v101;
  uint64_t v102 = MEMORY[0x1F4188790](v100);
  v694 = (char *)&v687 - v103;
  uint64_t v104 = MEMORY[0x1F4188790](v102);
  v695 = (char *)&v687 - v105;
  uint64_t v106 = MEMORY[0x1F4188790](v104);
  char v108 = (char *)&v687 - v107;
  uint64_t v109 = MEMORY[0x1F4188790](v106);
  v724 = (char *)&v687 - v110;
  uint64_t v111 = MEMORY[0x1F4188790](v109);
  v718 = (char *)&v687 - v112;
  uint64_t v113 = MEMORY[0x1F4188790](v111);
  v708 = (char *)&v687 - v114;
  uint64_t v115 = MEMORY[0x1F4188790](v113);
  v719 = (char *)&v687 - v116;
  uint64_t v117 = MEMORY[0x1F4188790](v115);
  v733 = (int *)((char *)&v687 - v118);
  uint64_t v119 = MEMORY[0x1F4188790](v117);
  v720 = (char *)&v687 - v120;
  uint64_t v121 = MEMORY[0x1F4188790](v119);
  uint64_t v123 = (char *)&v687 - v122;
  uint64_t v124 = MEMORY[0x1F4188790](v121);
  v752 = (char *)&v687 - v125;
  MEMORY[0x1F4188790](v124);
  uint64_t v127 = (char *)&v687 - v126;
  uint64_t v128 = *(uint64_t (**)(uint64_t, uint64_t))(v65 + 384);
  uint64_t v753 = v70;
  if (v128(v70, v65))
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v753, v65) & 1) == 0)
    {
      double *v736 = 0.0;
      return 1;
    }
    unint64_t v666 = 0x8000000000000000;
    goto LABEL_284;
  }
  char v129 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 376))(v753, v65);
  uint64_t v749 = a2;
  if ((v129 & 1) == 0)
  {
    uint64_t v665 = v65;
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 400))(v753, v65) & 1) == 0)
    {
      uint64_t v667 = v746;
      v668 = *(void (**)(uint64_t, uint64_t))(v746 + 120);
      uint64_t v669 = v753;
      v668(v753, v746);
      v670 = v742;
      (*(void (**)(uint64_t, uint64_t))(v665 + 96))(v669, v665);
      v668(v669, v667);
      v671 = *(void (**)(uint64_t (**)(void), uint64_t))(v750 + 8);
      v671(v670, v669);
      v672 = (char *)v748;
      (*(void (**)(uint64_t, uint64_t))(v665 + 104))(v669, v665);
      v673 = v727;
      v668(v669, v667);
      v671((uint64_t (**)(void))v672, v669);
      uint64_t v674 = v741;
      v675 = v722;
      v676 = v751;
      v677 = v732;
      (*(void (**)(char *, char *, uint64_t *, uint64_t))(v741 + 208))(v751, v673, v732, v741);
      v678 = *(void (**)(char *, uint64_t *))(v740 + 8);
      v678(v673, v677);
      v678(v676, v677);
      v679 = v730;
      (*(void (**)(char *, uint64_t *, uint64_t))(v674 + 184))(v675, v677, v674);
      v678(v675, v677);
      v681 = v744;
      v680 = v745;
      (*(void (**)(char *, int **, uint64_t *, uint64_t))(v674 + 192))(v745, v679, v677, v674);
      v678((char *)v679, v677);
      v678(v680, v677);
      uint64_t v682 = (*(uint64_t (**)(uint64_t *, uint64_t))(v674 + 120))(v677, v674);
      v678(v681, v677);
      uint64_t v683 = v682 & 0x3FFFFFFFFFFFFLL;
      LOBYTE(v682) = (*(uint64_t (**)(uint64_t, uint64_t))(v665 + 416))(v669, v665);
      uint64_t v684 = (*(uint64_t (**)(uint64_t, uint64_t))(v665 + 168))(v669, v665);
      uint64_t result = 0;
      uint64_t v685 = v683 | (v684 << 63);
      uint64_t v686 = 0x7FF8000000000000;
      if (v682) {
        uint64_t v686 = 0x7FF4000000000000;
      }
      unint64_t v218 = v685 | v686;
      goto LABEL_106;
    }
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v753, v65))
    {
LABEL_283:
      unint64_t v666 = 0xFFF0000000000000;
      goto LABEL_284;
    }
    unint64_t v666 = 0x7FF0000000000000;
LABEL_284:
    *(void *)v736 = v666;
    return 1;
  }
  v687 = v108;
  uint64_t v130 = *(void (**)(uint64_t, uint64_t))(v65 + 176);
  v742 = (uint64_t (**)(void))v65;
  v130(v753, v65);
  unint64_t v755 = -1022;
  uint64_t v131 = *(uint64_t (**)(uint64_t *, uint64_t))(v67 + 64);
  char v132 = v131(v71, v67);
  v744 = (char *)(v67 + 64);
  unint64_t v750 = (unint64_t)v131;
  v751 = v127;
  if (v132)
  {
    v748 = *(int **)(v67 + 128);
    uint64_t v133 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
    if (v133 >= 64)
    {
      uint64_t v150 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
      unint64_t v151 = lazy protocol witness table accessor for type Int and conformance Int(v133, v134, v135);
      int64_t v152 = v752;
      v150(&v755, &type metadata for Int, v151, v71, v67);
      char v153 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v127, v152, v71);
      uint64_t v138 = v747;
      uint64_t v141 = v747 + 8;
      BOOL v154 = v152;
      uint64_t v140 = *(int ***)(v747 + 8);
      ((void (*)(char *, uint64_t *))v140)(v154, v71);
      if ((v153 & 1) == 0) {
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v136 = v752;
      uint64_t v137 = v127;
      uint64_t v138 = v747;
      (*(void (**)(char *, char *, uint64_t *))(v747 + 16))(v752, v137, v71);
      uint64_t v139 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
      uint64_t v141 = v138 + 8;
      uint64_t v140 = *(int ***)(v138 + 8);
      ((void (*)(char *, uint64_t *))v140)(v136, v71);
      if (v139 >= (uint64_t)v755) {
        goto LABEL_34;
      }
    }
    goto LABEL_12;
  }
  char v142 = v131(v71, v67);
  v748 = *(int **)(v67 + 128);
  uint64_t v143 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
  if ((v142 & 1) == 0)
  {
    uint64_t v138 = v747;
    unint64_t v170 = *(void (**)(char *, char *, uint64_t *))(v747 + 16);
    if (v143 >= 64)
    {
      v170(v74, v751, v71);
      uint64_t v140 = *(int ***)(v138 + 8);
      ((void (*)(char *, uint64_t *))v140)(v74, v71);
      goto LABEL_34;
    }
    uint64_t v171 = v752;
    v170(v752, v751, v71);
    uint64_t v172 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
    uint64_t v140 = *(int ***)(v138 + 8);
    ((void (*)(char *, uint64_t *))v140)(v171, v71);
    if (v172 >= (uint64_t)v755) {
      goto LABEL_34;
    }
    uint64_t v155 = (v138 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
LABEL_13:
    uint64_t v156 = v739;
    uint64_t v157 = v737;
    uint64_t v158 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v159 = *(void (**)(uint64_t *, uint64_t))(v158 + 8);
    uint64_t v160 = v738;
    v728 = (char *)v158;
    v723 = (char *)(v158 + 8);
    v717 = v159;
    ((void (*)(uint64_t *, uint64_t, const char *))v159)(&qword_18162B0C0, 512, v157);
    char v161 = v156[3];
    uint64_t v162 = v752;
    v716 = (char *)(v156 + 3);
    v715 = v161;
    ((void (*)(uint64_t, uint64_t *, int **))v161)(v160, v71, v156);
    uint64_t v163 = v729[1];
    v729 = (int **)*((void *)v163 + 3);
    ((void (*)(char *, char *, uint64_t *, int *))v729)(v751, v162, v71, v163);
    v727 = (char *)v155;
    ((void (*)(char *, uint64_t *))v140)(v162, v71);
    uint64_t v164 = (uint64_t (*)(uint64_t *, uint64_t))v750;
    if (((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67))
    {
      uint64_t v165 = (char *)v748;
      uint64_t v166 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
      if (v166 >= 64)
      {
        unint64_t v755 = -1074;
        char v190 = v140;
        BOOL v191 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
        unint64_t v192 = lazy protocol witness table accessor for type Int and conformance Int(v166, v167, v168);
        char v193 = v163;
        unint64_t v194 = v752;
        v191(&v755, &type metadata for Int, v192, v71, v67);
        uint64_t v140 = v190;
        char v195 = (char *)v748;
        char v196 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v123, v194, v71);
        uint64_t v197 = v194;
        uint64_t v163 = v193;
        uint64_t v165 = v195;
        ((void (*)(char *, uint64_t *))v190)(v197, v71);
        ((void (*)(char *, uint64_t *))v190)(v123, v71);
        if (v196) {
          goto LABEL_103;
        }
      }
      else
      {
        uint64_t v169 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        ((void (*)(char *, uint64_t *))v140)(v123, v71);
        if (v169 <= -1075) {
          goto LABEL_103;
        }
      }
    }
    else
    {
      char v173 = v164(v71, v67);
      uint64_t v165 = (char *)v748;
      uint64_t v174 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
      if (v173)
      {
        v714 = (char *)v163;
        if (v174 <= 64)
        {
          uint64_t v278 = v738;
          v717(&qword_18162B0B8, 256);
          uint64_t v279 = v752;
          ((void (*)(uint64_t, uint64_t *, int **))v715)(v278, v71, v739);
          char v280 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v123, v279, v71);
          ((void (*)(char *, uint64_t *))v140)(v279, v71);
          uint64_t v281 = v703;
          (*(void (**)(char *, char *, uint64_t *))(v747 + 32))(v703, v123, v71);
          if (v280)
          {
            ((void (*)(char *, uint64_t *))v140)(v281, v71);
          }
          else
          {
            uint64_t v348 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
            ((void (*)(char *, uint64_t *))v140)(v281, v71);
            uint64_t v163 = (int *)v714;
            if (v348 >= -1074) {
              goto LABEL_67;
            }
          }
LABEL_103:
          ((void (*)(char *, uint64_t *))v140)(v751, v71);
          if ((v742[21](v753) & 1) == 0)
          {
            uint64_t result = 0;
            double *v736 = 0.0;
            return result;
          }
          uint64_t result = 0;
          unint64_t v218 = 0x8000000000000000;
          goto LABEL_106;
        }
        unint64_t v755 = -1074;
        uint64_t v177 = v140;
        unint64_t v178 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
        unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v174, v175, v176);
        long long v180 = v752;
        v178(&v755, &type metadata for Int, v179, v71, v67);
        uint64_t v140 = v177;
        uint64_t v165 = (char *)v748;
        char v181 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v123, v180, v71);
        ((void (*)(char *, uint64_t *))v177)(v180, v71);
        ((void (*)(char *, uint64_t *))v177)(v123, v71);
        uint64_t v163 = (int *)v714;
        if (v181) {
          goto LABEL_103;
        }
      }
      else if (v174 >= 64)
      {
        v282 = v702;
        (*(void (**)(char *, char *, uint64_t *))(v747 + 32))(v702, v123, v71);
        ((void (*)(char *, uint64_t *))v140)(v282, v71);
      }
      else
      {
        uint64_t v198 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        ((void (*)(char *, uint64_t *))v140)(v123, v71);
        if (v198 < -1074) {
          goto LABEL_103;
        }
      }
    }
LABEL_67:
    uint64_t v283 = v738;
    v717(&qword_18162B0C0, 512);
    uint64_t v284 = v752;
    ((void (*)(uint64_t, uint64_t *, int **))v715)(v283, v71, v739);
    v285 = v720;
    ((void (*)(char *, char *, uint64_t *, int *))v729)(v751, v284, v71, v163);
    ((void (*)(char *, uint64_t *))v140)(v284, v71);
    uint64_t v286 = (uint64_t (*)(uint64_t *, uint64_t))v750;
    if (((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67))
    {
      uint64_t v287 = ((uint64_t (*)(uint64_t *, uint64_t))v165)(v71, v67);
      uint64_t v290 = v747;
      if (v287 >= 64)
      {
        unint64_t v755 = -1074;
        uint64_t v291 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
        unint64_t v292 = lazy protocol witness table accessor for type Int and conformance Int(v287, v288, v289);
        v748 = (int *)v165;
        v293 = v140;
        v294 = v752;
        v291(&v755, &type metadata for Int, v292, v71, v67);
        char v295 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 16) + 8) + 8))(v285, v294, v71);
        uint64_t v296 = v294;
        uint64_t v140 = v293;
        uint64_t v165 = (char *)v748;
        ((void (*)(char *, uint64_t *))v140)(v296, v71);
        ((void (*)(char *, uint64_t *))v140)(v285, v71);
        if (v295) {
          goto LABEL_79;
        }
        goto LABEL_91;
      }
      goto LABEL_77;
    }
    char v297 = v286(v71, v67);
    uint64_t v298 = ((uint64_t (*)(uint64_t *, uint64_t))v165)(v71, v67);
    uint64_t v290 = v747;
    if (v297)
    {
      if (v298 > 64)
      {
        unint64_t v755 = -1074;
        v301 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
        unint64_t v302 = lazy protocol witness table accessor for type Int and conformance Int(v298, v299, v300);
        v748 = (int *)v165;
        uint64_t v303 = v285;
        v304 = v140;
        v305 = v752;
        v301(&v755, &type metadata for Int, v302, v71, v67);
        char v306 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 16) + 8) + 8))(v303, v305, v71);
        uint64_t v307 = v305;
        uint64_t v140 = v304;
        ((void (*)(char *, uint64_t *))v304)(v307, v71);
        uint64_t v308 = v303;
        uint64_t v165 = (char *)v748;
        ((void (*)(char *, uint64_t *))v304)(v308, v71);
        if (v306) {
          goto LABEL_79;
        }
        goto LABEL_91;
      }
      uint64_t v324 = v738;
      v717(&qword_18162B0B8, 256);
      v325 = v752;
      ((void (*)(uint64_t, uint64_t *, int **))v715)(v324, v71, v739);
      LOBYTE(v324) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8)
                                                                          + 32))(v285, v325, v71);
      ((void (*)(char *, uint64_t *))v140)(v325, v71);
      v326 = v695;
      (*(void (**)(char *, char *, uint64_t *))(v290 + 32))(v695, v285, v71);
      if (v324)
      {
        uint64_t v309 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        uint64_t v310 = v326;
LABEL_78:
        ((void (*)(char *, uint64_t *))v140)(v310, v71);
        if (v309 == -1074)
        {
LABEL_79:
          ((void (*)(char *, uint64_t *))v140)(v751, v71);
          uint64_t v311 = v753;
          uint64_t v312 = (*(uint64_t (**)(uint64_t))(v746 + 136))(v753);
          char v313 = v742[21](v311);
          uint64_t result = 0;
          double v314 = -0.0;
          if ((v313 & 1) == 0) {
            double v314 = 0.0;
          }
          *(void *)&double v315 = 0x8000000000000001;
          if ((v313 & 1) == 0) {
            double v315 = COERCE_DOUBLE(1);
          }
          if (v312) {
            double v314 = v315;
          }
          goto LABEL_290;
        }
LABEL_91:
        v327 = v733;
        (*(void (**)(int *, char *, uint64_t *))(v290 + 32))(v733, v751, v71);
        char v328 = ((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67);
        v329 = v719;
        v751 = *(char **)(v290 + 16);
        ((void (*)(char *, int *, uint64_t *))v751)(v719, v327, v71);
        if ((v328 & 1) == 0)
        {
          v339 = v329;
LABEL_144:
          v419 = v71;
LABEL_145:
          ((void (*)(char *, uint64_t *))v140)(v339, v419);
LABEL_146:
          v420 = v733;
          uint64_t v421 = ((uint64_t (*)(uint64_t *, uint64_t))v165)(v71, v67);
          v422 = v718;
          ((void (*)(char *, int *, uint64_t *))v751)(v718, v420, v71);
          if (v421 < 65)
          {
            uint64_t v430 = ((uint64_t (*)(uint64_t *, uint64_t))v165)(v71, v67);
            ((void (*)(char *, uint64_t *))v140)(v422, v71);
            if (v430 != 64 || (((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67) & 1) != 0)
            {
LABEL_160:
              v439 = v733;
              uint64_t v440 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
              uint64_t result = ((uint64_t (*)(int *, uint64_t *))v140)(v439, v71);
              uint64_t v441 = v440 + 1074;
              if (__OFADD__(v440, 1074))
              {
                __break(1u);
                goto LABEL_286;
              }
              uint64_t v442 = v746;
              v443 = *(char **)(v746 + 136);
              uint64_t v444 = v753;
              uint64_t v747 = v746 + 136;
              v748 = (int *)v443;
              uint64_t v445 = ((uint64_t (*)(uint64_t, uint64_t))v443)(v753, v746);
              v446 = v745;
              v751 = *(char **)(v442 + 120);
              ((void (*)(uint64_t, uint64_t))v751)(v444, v442);
              unint64_t v266 = (void (*)(void, void, void))v741;
              char v254 = v732;
              uint64_t v447 = (*(uint64_t (**)(uint64_t *, uint64_t))(v741 + 144))(v732, v741);
              uint64_t v264 = *(int ***)(v740 + 8);
              v744 = (char *)(v740 + 8);
              ((void (*)(char *, uint64_t *))v264)(v446, v254);
              unint64_t v448 = v441 - (v445 + v447);
              char v449 = v742[46](v444);
              unint64_t v750 = v448;
              v752 = (char *)v264;
              v739 = (int **)v441;
              if (v449)
              {
                BOOL v201 = v441 < -64;
                uint64_t v140 = v743;
                uint64_t v450 = v441;
                uint64_t v265 = v745;
                unint64_t v451 = (unint64_t)v726;
                if (v201 || v450 > 64 || v450 < 0 || (unint64_t)v450 > 0x3F) {
                  goto LABEL_164;
                }
                uint64_t v738 = 1 << v450;
                unint64_t v448 = v750;
                if ((v750 & 0x8000000000000000) != 0) {
                  goto LABEL_165;
                }
              }
              else
              {
                uint64_t v738 = 0;
                uint64_t v140 = v743;
                uint64_t v265 = v745;
                unint64_t v451 = (unint64_t)v726;
                if ((v448 & 0x8000000000000000) != 0) {
                  goto LABEL_165;
                }
              }
LABEL_176:
              ((void (*)(uint64_t, uint64_t))v751)(v753, v746);
              v479 = (const char *)*((void *)v266 + 8);
              if (((uint64_t (*)(uint64_t *, void (*)(void, void, void)))v479)(v254, v266))
              {
                v737 = v479;
                uint64_t v480 = (uint64_t)v140;
                v481 = v705;
                (*(void (**)(char *, unint64_t, uint64_t *))(v740 + 16))(v705, v451, v254);
                v482 = v734;
                uint64_t v483 = swift_getAssociatedConformanceWitness(v480, (uint64_t)v254, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v484 = v735;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v483 + 8))(&qword_18162B0B8, 256, v482, v483);
                (*(void (**)(char *, uint64_t *, uint64_t))(v480 + 24))(v484, v254, v480);
                LOBYTE(v484) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v266 + 4)
                                                                                                + 8)
                                                                                    + 32))(v481, v265, v254);
                v485 = v752;
                ((void (*)(char *, uint64_t *))v752)(v265, v254);
                if ((v484 & 1) == 0) {
                  goto LABEL_281;
                }
                ((void (*)(char *, uint64_t *))v485)(v481, v254);
                unint64_t v451 = (unint64_t)v726;
                v479 = v737;
              }
              v486 = (uint64_t (*)(void, void))*((void *)v266 + 16);
              if (v486(v254, v266) < 64)
              {
LABEL_201:
                uint64_t v512 = (*((uint64_t (**)(uint64_t *, void (*)(void, void, void)))v266 + 15))(v254, v266);
                unint64_t v513 = v451;
                uint64_t v514 = v512;
                ((void (*)(unint64_t, uint64_t *))v752)(v513, v254);
                unint64_t v515 = v750;
                if (v750 >= 0x40) {
                  uint64_t v516 = 0;
                }
                else {
                  uint64_t v516 = v514 << v750;
                }
                goto LABEL_257;
              }
              v487 = v704;
              v737 = *(const char **)(v740 + 16);
              ((void (*)(char *, unint64_t, uint64_t *))v737)(v704, v451, v254);
              unint64_t v755 = -1;
              char v488 = ((uint64_t (*)(uint64_t *, void (*)(void, void, void)))v479)(v254, v266);
              uint64_t v489 = v486(v254, v266);
              if (v488)
              {
                v492 = v745;
                v493 = v752;
                if (v489 <= 64)
                {
                  v494 = v743;
                  v495 = v732;
                  v496 = v734;
                  uint64_t v497 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v732, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v498 = v735;
                  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v497 + 8))(&qword_18162B0B8, 256, v496, v497);
                  ((void (*)(char *, uint64_t *, int **))v494[3])(v498, v495, v494);
                  uint64_t v499 = v741;
                  LOBYTE(v494) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v741 + 32)
                                                                                                  + 8)
                                                                                      + 40))(v487, v492, v495);
                  ((void (*)(char *, uint64_t *))v493)(v492, v495);
                  unint64_t v500 = v755;
                  v501 = v691;
                  ((void (*)(char *, char *, uint64_t *))v737)(v691, v487, v495);
                  if (v494)
                  {
                    unint64_t v502 = (*(uint64_t (**)(uint64_t *, uint64_t))(v499 + 120))(v495, v499);
                    ((void (*)(char *, uint64_t *))v493)(v501, v495);
                    if (v500 < v502) {
                      goto LABEL_243;
                    }
                  }
                  else
                  {
                    ((void (*)(char *, uint64_t *))v493)(v501, v495);
                  }
                  goto LABEL_200;
                }
              }
              else
              {
                v492 = v745;
                v493 = v752;
                if (v489 <= 64)
                {
                  v495 = v732;
                  ((void (*)(char *, char *, uint64_t *))v737)(v745, v487, v732);
                  unint64_t v510 = (*(uint64_t (**)(uint64_t *))(v741 + 120))(v495);
                  ((void (*)(char *, uint64_t *))v493)(v492, v495);
                  if (v755 < v510) {
                    goto LABEL_243;
                  }
LABEL_200:
                  ((void (*)(char *, uint64_t *))v493)(v487, v495);
                  char v254 = v495;
                  unint64_t v266 = (void (*)(void, void, void))v741;
                  unint64_t v451 = (unint64_t)v726;
                  goto LABEL_201;
                }
              }
              uint64_t v503 = v741;
              v504 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v741 + 96);
              unint64_t v505 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v489, v490, v491);
              v495 = v732;
              v504(&v755, &type metadata for UInt64, v505, v732, v503);
              char v506 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v503 + 32) + 8)
                                                                          + 16))(v492, v487, v495);
              ((void (*)(char *, uint64_t *))v493)(v492, v495);
              if (v506) {
                goto LABEL_243;
              }
              goto LABEL_200;
            }
          }
          else
          {
            ((void (*)(char *, uint64_t *))v140)(v422, v71);
          }
          ((void (*)(char *, int *, uint64_t *))v751)(v724, v733, v71);
          unint64_t v755 = 0x7FFFFFFFFFFFFFFFLL;
          char v423 = ((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67);
          uint64_t v424 = ((uint64_t (*)(uint64_t *, uint64_t))v165)(v71, v67);
          if (v423)
          {
            if (v424 > 64)
            {
              v427 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
              unint64_t v428 = lazy protocol witness table accessor for type Int and conformance Int(v424, v425, v426);
              v429 = &v755;
              goto LABEL_158;
            }
          }
          else if (v424 >= 64)
          {
            uint64_t v754 = 0x7FFFFFFFFFFFFFFFLL;
            v427 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
            unint64_t v428 = lazy protocol witness table accessor for type Int and conformance Int(v424, v425, v426);
            v429 = (unint64_t *)&v754;
LABEL_158:
            v435 = v140;
            v436 = v752;
            v427(v429, &type metadata for Int, v428, v71, v67);
            v432 = v724;
            char v437 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v436, v724, v71);
            v438 = v436;
            uint64_t v140 = v435;
            ((void (*)(char *, uint64_t *))v435)(v438, v71);
            if ((v437 & 1) == 0) {
              goto LABEL_159;
            }
            goto LABEL_157;
          }
          v431 = v752;
          v432 = v724;
          ((void (*)(char *, char *, uint64_t *))v751)(v752, v724, v71);
          uint64_t v433 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
          ((void (*)(char *, uint64_t *))v140)(v431, v71);
          if ((uint64_t)v755 >= v433)
          {
LABEL_159:
            ((void (*)(char *, uint64_t *))v140)(v432, v71);
            goto LABEL_160;
          }
LABEL_157:
          unint64_t v434 = 3687;
          goto LABEL_244;
        }
        uint64_t v330 = ((uint64_t (*)(uint64_t *, uint64_t))v165)(v71, v67);
        ((void (*)(char *, uint64_t *))v140)(v329, v71);
        if (v330 <= 64) {
          goto LABEL_146;
        }
        v331 = v708;
        ((void (*)(char *, int *, uint64_t *))v751)(v708, v733, v71);
        unint64_t v755 = 0x8000000000000000;
        v332 = (uint64_t (*)(uint64_t *, uint64_t))v750;
        if (((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67))
        {
          uint64_t v333 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
          if (v333 < 64)
          {
            v336 = v752;
            ((void (*)(char *, char *, uint64_t *))v751)(v752, v331, v71);
            uint64_t v337 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
            ((void (*)(char *, uint64_t *))v140)(v336, v71);
            uint64_t v338 = v331;
            uint64_t v165 = (char *)v748;
            if (v337 < (uint64_t)v755) {
              goto LABEL_296;
            }
            goto LABEL_143;
          }
          v729 = v140;
          v394 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
          unint64_t v395 = lazy protocol witness table accessor for type Int and conformance Int(v333, v334, v335);
          v396 = v752;
          v394(&v755, &type metadata for Int, v395, v71, v67);
          uint64_t v140 = v729;
          char v397 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v331, v396, v71);
          ((void (*)(char *, uint64_t *))v140)(v396, v71);
          uint64_t v338 = v331;
          uint64_t v165 = (char *)v748;
          if (v397) {
LABEL_296:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        }
        else
        {
          char v340 = v332(v71, v67);
          uint64_t v165 = (char *)v748;
          uint64_t v341 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
          if ((v340 & 1) == 0)
          {
            if (v341 >= 64)
            {
              v339 = v708;
              v419 = v71;
              goto LABEL_145;
            }
            v398 = v752;
            uint64_t v338 = v708;
            ((void (*)(char *, char *, uint64_t *))v751)(v752, v708, v71);
            uint64_t v399 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
            ((void (*)(char *, uint64_t *))v140)(v398, v71);
            if (v399 >= (uint64_t)v755) {
              goto LABEL_143;
            }
            goto LABEL_296;
          }
          v729 = v140;
          if (v341 <= 64)
          {
            uint64_t v411 = v738;
            v717(&qword_18162B0B8, 256);
            v412 = v752;
            ((void (*)(uint64_t, uint64_t *, int **))v715)(v411, v71, v739);
            v413 = v708;
            char v414 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v708, v412, v71);
            v415 = v729;
            ((void (*)(char *, uint64_t *))v729)(v412, v71);
            v416 = v687;
            ((void (*)(char *, char *, uint64_t *))v751)(v687, v413, v71);
            if (v414)
            {
              ((void (*)(char *, uint64_t *))v415)(v416, v71);
              goto LABEL_296;
            }
            int64_t v417 = v755;
            uint64_t v418 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
            ((void (*)(char *, uint64_t *))v415)(v416, v71);
            BOOL v201 = v418 < v417;
            uint64_t v140 = v415;
            uint64_t v338 = v708;
            if (v201) {
              goto LABEL_296;
            }
          }
          else
          {
            v344 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
            unint64_t v345 = lazy protocol witness table accessor for type Int and conformance Int(v341, v342, v343);
            v346 = v752;
            v344(&v755, &type metadata for Int, v345, v71, v67);
            uint64_t v338 = v708;
            char v347 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v708, v346, v71);
            uint64_t v140 = v729;
            ((void (*)(char *, uint64_t *))v729)(v346, v71);
            if (v347) {
              goto LABEL_296;
            }
          }
        }
LABEL_143:
        v339 = v338;
        goto LABEL_144;
      }
    }
    else
    {
      if (v298 < 64)
      {
LABEL_77:
        uint64_t v309 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        uint64_t v310 = v285;
        goto LABEL_78;
      }
      v326 = v694;
      (*(void (**)(char *, char *, uint64_t *))(v747 + 32))(v694, v285, v71);
    }
    ((void (*)(char *, uint64_t *))v140)(v326, v71);
    goto LABEL_91;
  }
  if (v143 <= 64)
  {
    uint64_t v182 = v739;
    uint64_t v183 = v737;
    uint64_t v184 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v185 = v738;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v184 + 8))(&qword_18162B0B8, 256, v183, v184);
    uint64_t v186 = v752;
    ((void (*)(uint64_t, uint64_t *, int **))v182[3])(v185, v71, v182);
    uint64_t v187 = v751;
    LOBYTE(v183) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v751, v186, v71);
    uint64_t v188 = v747;
    char v189 = *(int ***)(v747 + 8);
    v727 = (char *)((v747 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
    ((void (*)(char *, uint64_t *))v189)(v186, v71);
    (*(void (**)(char *, char *, uint64_t *))(v188 + 16))(v77, v187, v71);
    if (v183)
    {
      ((void (*)(char *, uint64_t *))v189)(v77, v71);
      uint64_t v140 = v189;
      uint64_t v155 = (uint64_t)v727;
    }
    else
    {
      int64_t v199 = v755;
      uint64_t v200 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
      ((void (*)(char *, uint64_t *))v189)(v77, v71);
      BOOL v201 = v200 < v199;
      uint64_t v140 = v189;
      uint64_t v138 = v747;
      uint64_t v155 = (uint64_t)v727;
      if (!v201) {
        goto LABEL_34;
      }
    }
    goto LABEL_13;
  }
  uint64_t v146 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
  unint64_t v147 = lazy protocol witness table accessor for type Int and conformance Int(v143, v144, v145);
  unint64_t v148 = v752;
  v146(&v755, &type metadata for Int, v147, v71, v67);
  char v149 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v751, v148, v71);
  uint64_t v138 = v747;
  uint64_t v141 = v747 + 8;
  uint64_t v140 = *(int ***)(v747 + 8);
  ((void (*)(char *, uint64_t *))v140)(v148, v71);
  if (v149)
  {
LABEL_12:
    uint64_t v155 = v141 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    goto LABEL_13;
  }
LABEL_34:
  unint64_t v755 = 1023;
  char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
  char v203 = ((uint64_t (*)(uint64_t *, uint64_t))v750)(v71, v67);
  unint64_t v204 = (int *)(v67 + 128);
  unint64_t v205 = v751;
  uint64_t v206 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
  if ((v203 & 1) == 0)
  {
    if (v206 > 63)
    {
      uint64_t v754 = 1023;
      uint64_t v219 = *(uint64_t (**)(char *, char *, uint64_t *))(v138 + 16);
      v733 = (int *)(v67 + 128);
      unint64_t v220 = v711;
      uint64_t v221 = v219(v711, v205, v71);
      uint64_t v222 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
      unint64_t v225 = lazy protocol witness table accessor for type Int and conformance Int(v221, v223, v224);
      uint64_t v226 = v752;
      v222(&v754, &type metadata for Int, v225, v71, v67);
      char v227 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v226, v220, v71);
      uint64_t v228 = v226;
      char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
      ((void (*)(char *, uint64_t *))v140)(v228, v71);
      char v229 = v220;
      unint64_t v204 = v733;
      ((void (*)(char *, uint64_t *))v140)(v229, v71);
      if ((v227 & 1) == 0) {
        goto LABEL_43;
      }
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  if (v206 <= 64)
  {
LABEL_39:
    uint64_t v215 = v752;
    (*(void (**)(char *, char *, uint64_t *))(v138 + 16))(v752, v205, v71);
    uint64_t v216 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
    ((void (*)(char *, uint64_t *))v140)(v215, v71);
    if ((uint64_t)v755 >= v216) {
      goto LABEL_43;
    }
    goto LABEL_40;
  }
  uint64_t v209 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
  unint64_t v210 = lazy protocol witness table accessor for type Int and conformance Int(v206, v207, v208);
  unint64_t v211 = v140;
  uint64_t v212 = v752;
  v209(&v755, &type metadata for Int, v210, v71, v67);
  char v213 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v212, v205, v71);
  uint64_t v214 = v212;
  uint64_t v140 = v211;
  char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
  ((void (*)(char *, uint64_t *))v140)(v214, v71);
  if (v213)
  {
LABEL_40:
    ((void (*)(char *, uint64_t *))v140)(v751, v71);
    if (v742[21](v753))
    {
      uint64_t result = 0;
      unint64_t v218 = 0xFFF0000000000000;
    }
    else
    {
      uint64_t result = 0;
      unint64_t v218 = 0x7FF0000000000000;
    }
LABEL_106:
    *(void *)v736 = v218;
    return result;
  }
LABEL_43:
  char v230 = v202(v71, v67);
  v733 = v204;
  if (v230)
  {
    uint64_t v231 = v751;
    uint64_t v232 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
    if (v232 < 64)
    {
      Swift::String::Index v235 = v752;
      (*(void (**)(char *, char *, uint64_t *))(v138 + 16))(v752, v231, v71);
      uint64_t v236 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
      uint64_t v237 = v138 + 8;
      ((void (*)(char *, uint64_t *))v140)(v235, v71);
      uint64_t v238 = v728;
      if (v236 < 0) {
        goto LABEL_53;
      }
      goto LABEL_112;
    }
    unint64_t v755 = 0;
    uint64_t v248 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
    unint64_t v249 = lazy protocol witness table accessor for type Int and conformance Int(v232, v233, v234);
    uint64_t v250 = v140;
    uint64_t v251 = v752;
    v248(&v755, &type metadata for Int, v249, v71, v67);
    char v246 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v231, v251, v71);
    uint64_t v237 = v138 + 8;
    uint64_t v252 = v251;
    uint64_t v140 = v250;
    char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
    ((void (*)(char *, uint64_t *))v140)(v252, v71);
  }
  else
  {
    char v239 = v202(v71, v67);
    uint64_t v240 = ((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67);
    if ((v239 & 1) == 0)
    {
      uint64_t v238 = v728;
      if (v240 < 64)
      {
        int64_t v276 = v752;
        (*(void (**)(char *, char *, uint64_t *))(v138 + 16))(v752, v751, v71);
        uint64_t v277 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        uint64_t v237 = v138 + 8;
        ((void (*)(char *, uint64_t *))v140)(v276, v71);
        if (v277 < 0) {
          goto LABEL_53;
        }
      }
      goto LABEL_112;
    }
    v729 = v140;
    if (v240 <= 64)
    {
      v316 = v739;
      v317 = v737;
      uint64_t v318 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v319 = v738;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v318 + 8))(&qword_18162B0B8, 256, v317, v318);
      v320 = v752;
      ((void (*)(uint64_t, uint64_t *, int **))v316[3])(v319, v71, v316);
      unint64_t v321 = v751;
      LOBYTE(v316) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8)
                                                                          + 16))(v751, v320, v71);
      uint64_t v253 = (v138 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      v322 = v320;
      uint64_t v140 = v729;
      ((void (*)(char *, uint64_t *))v729)(v322, v71);
      uint64_t v323 = v696;
      (*(void (**)(char *, char *, uint64_t *))(v138 + 16))(v696, v321, v71);
      if (v316)
      {
        ((void (*)(char *, uint64_t *))v140)(v323, v71);
        char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
        uint64_t v138 = v747;
      }
      else
      {
        uint64_t v353 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        ((void (*)(char *, uint64_t *))v140)(v323, v71);
        char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
        uint64_t v238 = v728;
        uint64_t v138 = v747;
        if ((v353 & 0x8000000000000000) == 0) {
          goto LABEL_112;
        }
      }
LABEL_54:
      char v254 = (uint64_t *)v715;
      uint64_t v255 = v751;
      (*(void (**)(char *, uint64_t *))(*(void *)(AssociatedConformanceWitness + 16) + 16))(v751, v71);
      ((void (*)(char *, uint64_t *))v140)(v255, v71);
      if (v202(v71, v67))
      {
        uint64_t v256 = v701;
        (*(void (**)(char *, uint64_t *, uint64_t *))(v138 + 16))(v701, v254, v71);
        uint64_t v257 = v739;
        uint64_t v258 = v737;
        uint64_t v259 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v260 = v738;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v259 + 8))(&qword_18162B0B8, 256, v258, v259);
        unint64_t v261 = v140;
        uint64_t v262 = v752;
        ((void (*)(uint64_t, uint64_t *, int **))v257[3])(v260, v71, v257);
        LOBYTE(v257) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8)
                                                                            + 32))(v256, v262, v71);
        char v263 = v262;
        uint64_t v140 = v261;
        ((void (*)(char *, uint64_t *))v261)(v263, v71);
        if ((v257 & 1) == 0) {
          goto LABEL_281;
        }
        ((void (*)(char *, uint64_t *))v261)(v256, v71);
        char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
        char v254 = (uint64_t *)v715;
      }
      v751 = (char *)v253;
      uint64_t v264 = (int **)v138;
      uint64_t v265 = (char *)v748;
      unint64_t v266 = (void (*)(void, void, void))v733;
      if (((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67) < 64) {
        goto LABEL_207;
      }
      char v267 = v264[2];
      v264 += 2;
      uint64_t v747 = (uint64_t)v264;
      unint64_t v750 = (unint64_t)v267;
      ((void (*)(char *, uint64_t *, uint64_t *))v267)(v709, v254, v71);
      unint64_t v755 = -1;
      char v268 = v202(v71, v67);
      uint64_t v269 = ((uint64_t (*)(uint64_t *, uint64_t))v265)(v71, v67);
      if (v268)
      {
        uint64_t v264 = v140;
        unint64_t v266 = (void (*)(void, void, void))v751;
        if (v269 > 64)
        {
          uint64_t v272 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
          unint64_t v273 = lazy protocol witness table accessor for type UInt and conformance UInt(v269, v270, v271);
          uint64_t v274 = v752;
          v272(&v755, &type metadata for UInt, v273, v71, v67);
          uint64_t v265 = v709;
          char v275 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v274, v709, v71);
          uint64_t v140 = v264;
          ((void (*)(char *, uint64_t *))v264)(v274, v71);
          goto LABEL_109;
        }
        v400 = v739;
        v401 = v737;
        uint64_t v402 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v403 = v738;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v402 + 8))(&qword_18162B0B8, 256, v401, v402);
        v404 = v752;
        ((void (*)(uint64_t, uint64_t *, int **))v400[3])(v403, v71, v400);
        uint64_t v265 = v709;
        LOBYTE(v40_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8)
                                                                            + 40))(v709, v404, v71);
        ((void (*)(char *, uint64_t *))v264)(v404, v71);
        unint64_t v405 = v755;
        v406 = v690;
        ((void (*)(char *, char *, uint64_t *))v750)(v690, v265, v71);
        if ((v400 & 1) == 0)
        {
          ((void (*)(char *, uint64_t *))v264)(v406, v71);
          uint64_t v140 = v264;
          char v254 = (uint64_t *)v715;
LABEL_206:
          ((void (*)(char *, uint64_t *))v140)(v265, v71);
LABEL_207:
          unint64_t v451 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
          ((void (*)(uint64_t *, uint64_t *))v140)(v254, v71);
          if (v451 > 0x3FF)
          {
            __break(1u);
            goto LABEL_292;
          }
          uint64_t v738 = 1023 - v451;
          v392 = v743;
          v355 = v745;
          uint64_t v393 = v746;
LABEL_209:
          v517 = *(char **)(v393 + 136);
          uint64_t v747 = (v393 + 136) & 0xFFFFFFFFFFFFLL | 0x1E66000000000000;
          v748 = (int *)v517;
          uint64_t v518 = v753;
          uint64_t v519 = ((uint64_t (*)(uint64_t, uint64_t))v517)(v753, v393);
          v520 = *(char **)(v393 + 120);
          v739 = (int **)(v393 + 120);
          v751 = v520;
          ((void (*)(uint64_t, uint64_t))v520)(v518, v393);
          char v254 = v732;
          v729 = *(int ***)(v741 + 144);
          v728 = (char *)(v741 + 144);
          uint64_t v521 = ((uint64_t (*)(uint64_t *))v729)(v732);
          v523 = (char *)(v740 + 8);
          v522 = *(void (**)(char *, uint64_t *))(v740 + 8);
          v522(v355, v254);
          unint64_t v750 = 52 - v519 - v521;
          LOBYTE(v519) = v742[49](v518);
          v524 = v734;
          uint64_t v525 = swift_getAssociatedConformanceWitness((uint64_t)v392, (uint64_t)v254, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v526 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v525 + 8);
          v752 = (char *)v522;
          v744 = v523;
          v737 = (const char *)(v392 + 3);
          if (v519)
          {
            v527 = v735;
            v526(&qword_18162B0C0, 512, v524, v525);
            v733 = v392[3];
            ((void (*)(char *, uint64_t *, int **))v733)(v527, v254, v392);
            uint64_t v528 = v753;
            uint64_t v529 = v746;
            uint64_t v530 = ((uint64_t (*)(uint64_t, uint64_t))v748)(v753, v746);
            v531 = v730;
            ((void (*)(uint64_t, uint64_t))v751)(v528, v529);
            unint64_t v266 = (void (*)(void, void, void))v741;
            uint64_t v532 = ((uint64_t (*)(uint64_t *, uint64_t))v729)(v254, v741);
            v533 = v752;
            uint64_t v534 = ((uint64_t (*)(int **, uint64_t *))v752)(v531, v254);
            unint64_t v755 = v532 + v530;
            v535 = (void (*)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t *, void (*)(void, void, void)))*((void *)v266 + 32);
            unint64_t v538 = lazy protocol witness table accessor for type Int and conformance Int(v534, v536, v537);
            v539 = v723;
            v540 = v745;
            v535(v745, &v755, &type metadata for Int, v538, v254, v266);
            ((void (*)(char *, uint64_t *))v533)(v540, v254);
            uint64_t v541 = v529;
            uint64_t v264 = (int **)v540;
          }
          else
          {
            v542 = v735;
            v526(&qword_18162B0B8, 256, v524, v525);
            v539 = v723;
            v733 = v392[3];
            ((void (*)(char *, uint64_t *, int **))v733)(v542, v254, v392);
            unint64_t v266 = (void (*)(void, void, void))v741;
            uint64_t v264 = (int **)v745;
            uint64_t v541 = v746;
          }
          unint64_t v543 = v750;
          unint64_t v451 = (unint64_t)v266 + 224;
          if ((v750 & 0x8000000000000000) == 0)
          {
            ((void (*)(uint64_t, uint64_t))v751)(v753, v541);
            v544 = (char *)v717;
            (*((void (**)(char *, int **, uint64_t *, void (*)(void, void, void)))v266 + 28))(v539, v264, v254, v266);
            v545 = v752;
            ((void (*)(int **, uint64_t *))v752)(v264, v254);
            ((void (*)(char *, uint64_t *))v545)(v539, v254);
            v546 = (uint64_t (*)(void, void))*((void *)v266 + 8);
            if ((v546(v254, v266) & 1) == 0) {
              goto LABEL_216;
            }
            v547 = v707;
            (*(void (**)(char *, char *, uint64_t *))(v740 + 16))(v707, v544, v254);
            v548 = v743;
            v549 = v734;
            uint64_t v550 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v254, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v551 = v735;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v550 + 8))(&qword_18162B0B8, 256, v549, v550);
            ((void (*)(char *, uint64_t *, int **))v733)(v551, v254, v548);
            LOBYTE(v551) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v266 + 4) + 8)
                                                                                + 32))(v547, v264, v254);
            v552 = v752;
            ((void (*)(int **, uint64_t *))v752)(v264, v254);
            if (v551)
            {
              ((void (*)(char *, uint64_t *))v552)(v547, v254);
LABEL_216:
              v553 = v544;
              v554 = (uint64_t (*)(void, void))*((void *)v266 + 16);
              if (v554(v254, v266) < 64)
              {
LABEL_247:
                uint64_t v624 = (*((uint64_t (**)(uint64_t *, void (*)(void, void, void)))v266 + 15))(v254, v266);
                ((void (*)(char *, uint64_t *))v752)(v553, v254);
                unint64_t v515 = v750;
                if (v750 >= 0x40) {
                  uint64_t v625 = 0;
                }
                else {
                  uint64_t v625 = v624 << v750;
                }
                uint64_t v626 = 52;
                uint64_t v627 = (uint64_t)v254;
                v628 = v742;
                v629 = v748;
                __int16 v630 = v738;
                uint64_t v631 = v753;
                goto LABEL_258;
              }
              v555 = *(void (**)(char *, char *, uint64_t *))(v740 + 16);
              v555(v712, v553, v254);
              unint64_t v755 = -1;
              char v556 = v546(v254, v266);
              uint64_t v557 = v554(v254, v266);
              if (v556)
              {
                v560 = v555;
                v561 = v735;
                v562 = v745;
                if (v557 > 64)
                {
                  uint64_t v563 = v741;
                  v564 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v741 + 96);
                  unint64_t v565 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v557, v558, v559);
                  v566 = v732;
                  v564(&v755, &type metadata for UInt64, v565, v732, v563);
                  v567 = v712;
                  char v568 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v563 + 32) + 8)
                                                                              + 16))(v562, v712, v566);
                  v569 = v562;
                  goto LABEL_232;
                }
                v613 = v743;
                v566 = v732;
                v614 = v734;
                uint64_t v615 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v732, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v615 + 8))(&qword_18162B0B8, 256, v614, v615);
                ((void (*)(char *, uint64_t *, int **))v733)(v561, v566, v613);
                uint64_t v616 = v741;
                v567 = v712;
                LOBYTE(v613) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v741 + 32)
                                                                                                + 8)
                                                                                    + 40))(v712, v562, v566);
                v617 = v562;
                v607 = v752;
                ((void (*)(char *, uint64_t *))v752)(v617, v566);
                unint64_t v618 = v755;
                v619 = v693;
                v560(v693, v567, v566);
                if (v613)
                {
                  unint64_t v620 = (*(uint64_t (**)(uint64_t *, uint64_t))(v616 + 120))(v566, v616);
                  ((void (*)(char *, uint64_t *))v607)(v619, v566);
                  if (v618 < v620) {
                    goto LABEL_243;
                  }
                }
                else
                {
                  ((void (*)(char *, uint64_t *))v607)(v619, v566);
                }
              }
              else
              {
                v603 = v745;
                if (v557 > 64)
                {
                  uint64_t v604 = v741;
                  v605 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v741 + 96);
                  unint64_t v606 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v557, v558, v559);
                  v566 = v732;
                  v605(&v755, &type metadata for UInt64, v606, v732, v604);
                  v567 = v712;
                  char v568 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v604 + 32) + 8)
                                                                              + 16))(v603, v712, v566);
                  v569 = v603;
LABEL_232:
                  v607 = v752;
                  ((void (*)(char *, uint64_t *))v752)(v569, v566);
                  if (v568) {
                    goto LABEL_243;
                  }
                  goto LABEL_246;
                }
                v567 = v712;
                v566 = v732;
                v555(v745, v712, v732);
                unint64_t v621 = (*(uint64_t (**)(uint64_t *))(v741 + 120))(v566);
                v607 = v752;
                ((void (*)(char *, uint64_t *))v752)(v603, v566);
                if (v755 < v621) {
                  goto LABEL_243;
                }
              }
LABEL_246:
              ((void (*)(char *, uint64_t *))v607)(v567, v566);
              char v254 = v566;
              unint64_t v266 = (void (*)(void, void, void))v741;
              v553 = (char *)v717;
              goto LABEL_247;
            }
LABEL_281:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
          }
          uint64_t v140 = v730;
          ((void (*)(uint64_t, uint64_t))v751)(v753, v541);
          (*((void (**)(char *, int **, uint64_t *, void (*)(void, void, void)))v266 + 28))(v539, v140, v254, v266);
          v570 = v752;
          uint64_t v265 = v744;
          ((void (*)(int **, uint64_t *))v752)(v140, v254);
          uint64_t v571 = ((uint64_t (*)(char *, uint64_t *))v570)(v539, v254);
          if (!__OFSUB__(0, v543))
          {
            unint64_t v755 = -(uint64_t)v543;
            v574 = (void (*)(int **, unint64_t *, ValueMetadata *, unint64_t, uint64_t *, void (*)(void, void, void)))*((void *)v266 + 30);
            unint64_t v575 = lazy protocol witness table accessor for type Int and conformance Int(v571, v572, v573);
            v576 = v714;
            v574(v264, &v755, &type metadata for Int, v575, v254, v266);
            ((void (*)(int **, uint64_t *))v570)(v264, v254);
            v739 = (int **)*((void *)v266 + 8);
            if (((uint64_t (*)(uint64_t *, void (*)(void, void, void)))v739)(v254, v266))
            {
              v577 = v700;
              (*(void (**)(char *, char *, uint64_t *))(v740 + 16))(v700, v576, v254);
              v578 = v743;
              v579 = v734;
              uint64_t v580 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v254, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v581 = v735;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v580 + 8))(&qword_18162B0B8, 256, v579, v580);
              ((void (*)(char *, uint64_t *, int **))v733)(v581, v254, v578);
              LOBYTE(v581) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v266 + 4)
                                                                                              + 8)
                                                                                  + 32))(v577, v264, v254);
              v582 = v752;
              ((void (*)(int **, uint64_t *))v752)(v264, v254);
              if ((v581 & 1) == 0) {
                goto LABEL_281;
              }
              ((void (*)(char *, uint64_t *))v582)(v577, v254);
              v576 = v714;
            }
            v583 = v576;
            v584 = v266;
            v585 = (uint64_t (*)(void, void))*((void *)v266 + 16);
            if (v585(v254, v584) < 64) {
              goto LABEL_253;
            }
            v586 = v699;
            v729 = *(int ***)(v740 + 16);
            ((void (*)(char *, char *, uint64_t *))v729)(v699, v576, v254);
            unint64_t v755 = -1;
            char v587 = ((uint64_t (*)(uint64_t *, void (*)(void, void, void)))v739)(v254, v584);
            uint64_t v588 = v585(v254, v584);
            if (v587)
            {
              v591 = v745;
              if (v588 <= 64)
              {
                v592 = v743;
                v593 = v732;
                v594 = v734;
                uint64_t v595 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v732, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v596 = v735;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v595 + 8))(&qword_18162B0B8, 256, v594, v595);
                ((void (*)(char *, uint64_t *, int **))v733)(v596, v593, v592);
                uint64_t v597 = v741;
                LOBYTE(v596) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v741 + 32)
                                                                                                + 8)
                                                                                    + 40))(v586, v591, v593);
                v598 = v591;
                v599 = v752;
                ((void (*)(char *, uint64_t *))v752)(v598, v593);
                unint64_t v600 = v755;
                v601 = v689;
                ((void (*)(char *, char *, uint64_t *))v729)(v689, v586, v593);
                if (v596)
                {
                  unint64_t v602 = (*(uint64_t (**)(uint64_t *, uint64_t))(v597 + 120))(v593, v597);
                  ((void (*)(char *, uint64_t *))v599)(v601, v593);
                  if (v600 < v602) {
                    goto LABEL_243;
                  }
                }
                else
                {
                  ((void (*)(char *, uint64_t *))v599)(v601, v593);
                }
                goto LABEL_252;
              }
              goto LABEL_235;
            }
            v591 = v745;
            if (v588 > 64)
            {
LABEL_235:
              uint64_t v608 = v741;
              v609 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v741 + 96);
              unint64_t v610 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v588, v589, v590);
              v593 = v732;
              v609(&v755, &type metadata for UInt64, v610, v732, v608);
              char v611 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v608 + 32) + 8)
                                                                          + 16))(v591, v586, v593);
              v612 = v591;
              v599 = v752;
              ((void (*)(char *, uint64_t *))v752)(v612, v593);
              if (v611) {
                goto LABEL_243;
              }
              goto LABEL_252;
            }
            v593 = v732;
            ((void (*)(char *, char *, uint64_t *))v729)(v745, v586, v732);
            unint64_t v622 = (*(uint64_t (**)(uint64_t *))(v741 + 120))(v593);
            v623 = v591;
            v599 = v752;
            ((void (*)(char *, uint64_t *))v752)(v623, v593);
            if (v755 >= v622)
            {
LABEL_252:
              ((void (*)(char *, uint64_t *))v599)(v586, v593);
              char v254 = v593;
              v584 = (void (*)(void, void, void))v741;
              v583 = v714;
LABEL_253:
              uint64_t v625 = (*((uint64_t (**)(uint64_t *, void (*)(void, void, void)))v584 + 15))(v254, v584);
              ((void (*)(char *, uint64_t *))v752)(v583, v254);
              uint64_t v626 = 52;
              uint64_t v627 = (uint64_t)v254;
              uint64_t v631 = v753;
              v628 = v742;
              v629 = v748;
              unint64_t v515 = v750;
              __int16 v630 = v738;
LABEL_258:
              v632 = (int **)v628[21];
              v744 = (char *)(v628 + 21);
              v739 = v632;
              v633 = (const char *)(((unint64_t)(v630 & 0x7FF) << 52) | (((uint64_t (*)(uint64_t))v632)(v631) << 63) | v625 & 0xFFFFFFFFFFFFFLL);
              if (v626 < ((uint64_t (*)(uint64_t, uint64_t))v629)(v631, v746))
              {
                v737 = v633;
                v733 = (int *)v625;
                v634 = v743;
                v635 = v734;
                uint64_t v636 = swift_getAssociatedConformanceWitness((uint64_t)v743, v627, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v637 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v636 + 8);
                v638 = v735;
                v637(&qword_18162B0C0, 512, v635, v636);
                v639 = v634[3];
                v640 = v745;
                unint64_t v750 = (unint64_t)(v634 + 3);
                v748 = v639;
                uint64_t v641 = ((uint64_t (*)(char *, uint64_t, int **))v639)(v638, v627, v634);
                if (!__OFSUB__(0, v515))
                {
                  unint64_t v755 = -(uint64_t)v515;
                  uint64_t v738 = v636 + 8;
                  uint64_t v747 = (uint64_t)v637;
                  uint64_t v644 = v741;
                  uint64_t v645 = v627;
                  v646 = *(void (**)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v741 + 256);
                  unint64_t v647 = lazy protocol witness table accessor for type Int and conformance Int(v641, v642, v643);
                  v646(v640, &v755, &type metadata for Int, v647, v645, v644);
                  v648 = v752;
                  ((void (*)(char *, uint64_t))v752)(v640, v645);
                  ((void (*)(uint64_t))v751)(v753);
                  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v747)(&qword_18162B0C0, 512, v635, v636);
                  v751 = (char *)v636;
                  v649 = v722;
                  ((void (*)(char *, uint64_t, int **))v748)(v638, v645, v743);
                  v650 = v730;
                  (*(void (**)(char *, char *, uint64_t))(*(void *)(v721 + 8) + 40))(v731, v649, v645);
                  ((void (*)(char *, uint64_t))v648)(v649, v645);
                  v651 = v725;
                  (*(void (**)(char *, int **, uint64_t, uint64_t))(v644 + 192))(v640, v650, v645, v644);
                  ((void (*)(int **, uint64_t))v648)(v650, v645);
                  ((void (*)(char *, uint64_t))v648)(v640, v645);
                  ((void (*)(void *, uint64_t, const char *, char *))v747)(&unk_18162B0D0, 768, v635, v751);
                  v652 = v638;
                  v653 = v731;
                  ((void (*)(char *, uint64_t, int **))v748)(v652, v645, v743);
                  uint64_t v746 = *(void *)(v644 + 152);
                  ((void (*)(char *, int **, uint64_t, uint64_t))v746)(v653, v650, v645, v644);
                  ((void (*)(int **, uint64_t))v648)(v650, v645);
                  uint64_t v654 = *(void *)(*(void *)(v644 + 32) + 8);
                  char v655 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v654 + 16))(v651, v640, v645, v654);
                  ((void (*)(char *, uint64_t))v648)(v640, v645);
                  if (v655)
                  {
                    ((void (*)(char *, uint64_t))v648)(v651, v645);
                    ((void (*)(char *, uint64_t))v648)(v653, v645);
                    uint64_t result = 0;
                    *(void *)v736 = v737;
                    return result;
                  }
                  uint64_t v4 = v737;
                  if (((uint64_t (*)(uint64_t, uint64_t (**)(void)))v739)(v753, v742))
                  {
                    double v659 = 0.0 - *(double *)&v4;
                    v656 = v743;
                    v657 = v735;
                    v658 = (void (*)(void *, uint64_t))v747;
                    if (0.0 - *(double *)&v4 < INFINITY) {
                      *(void *)&v659 += (*(uint64_t *)&v659 >> 63) | 1;
                    }
                    double v5 = -v659;
                  }
                  else
                  {
                    double v5 = *(double *)&v4 + 0.0;
                    v656 = v743;
                    v657 = v735;
                    v658 = (void (*)(void *, uint64_t))v747;
                    if (*(double *)&v4 + 0.0 < INFINITY) {
                      *(void *)&v5 += (*(uint64_t *)&v5 >> 63) | 1;
                    }
                  }
                  v658(&unk_18162B0D0, 768);
                  v660 = v730;
                  v661 = v657;
                  v662 = v732;
                  ((void (*)(char *, uint64_t *, int **))v748)(v661, v732, v656);
                  ((void (*)(char *, int **, uint64_t *, uint64_t))v746)(v653, v660, v662, v741);
                  ((void (*)(int **, uint64_t *))v648)(v660, v662);
                  ((void (*)(char *, uint64_t *))v648)(v653, v662);
                  v663 = v725;
                  char v664 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v654 + 40))(v725, v640, v662, v654);
                  ((void (*)(char *, uint64_t *))v648)(v640, v662);
                  ((void (*)(char *, uint64_t *))v648)(v663, v662);
                  uint64_t result = 0;
                  if (v664)
                  {
                    double *v736 = v5;
                    return result;
                  }
                  goto LABEL_287;
                }
                __break(1u);
                goto LABEL_283;
              }
              *(void *)v736 = v633;
              return 1;
            }
LABEL_243:
            unint64_t v434 = 3455;
LABEL_244:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, v434, 0);
          }
LABEL_292:
          __break(1u);
          do
          {
            __break(1u);
LABEL_164:
            uint64_t v738 = 0;
            unint64_t v448 = v750;
            if ((v750 & 0x8000000000000000) == 0) {
              goto LABEL_176;
            }
LABEL_165:
            uint64_t v452 = ((uint64_t (*)(uint64_t, uint64_t))v751)(v753, v746);
          }
          while (__OFSUB__(0, v448));
          unint64_t v755 = -(uint64_t)v448;
          v455 = (void (*)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t *, void (*)(void, void, void)))*((void *)v266 + 30);
          unint64_t v456 = lazy protocol witness table accessor for type Int and conformance Int(v452, v453, v454);
          v457 = v713;
          v455(v265, &v755, &type metadata for Int, v456, v254, v266);
          ((void (*)(char *, uint64_t *))v264)(v265, v254);
          v458 = (const char *)*((void *)v266 + 8);
          if (((uint64_t (*)(uint64_t *, void (*)(void, void, void)))v458)(v254, v266))
          {
            v737 = v458;
            v459 = v698;
            (*(void (**)(char *, char *, uint64_t *))(v740 + 16))(v698, v457, v254);
            v460 = v743;
            v461 = v734;
            uint64_t v462 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v254, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v463 = v735;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v462 + 8))(&qword_18162B0B8, 256, v461, v462);
            ((void (*)(char *, uint64_t *, int **))v460[3])(v463, v254, v460);
            LOBYTE(v463) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v266 + 4) + 8)
                                                                                + 32))(v459, v265, v254);
            ((void (*)(char *, uint64_t *))v264)(v265, v254);
            if ((v463 & 1) == 0) {
              goto LABEL_281;
            }
            ((void (*)(char *, uint64_t *))v264)(v459, v254);
            v457 = v713;
            v458 = v737;
          }
          v464 = (uint64_t (*)(void, void))*((void *)v266 + 16);
          v465 = v457;
          if (v464(v254, v266) < 64) {
            goto LABEL_256;
          }
          v466 = v697;
          v737 = *(const char **)(v740 + 16);
          ((void (*)(char *, char *, uint64_t *))v737)(v697, v465, v254);
          unint64_t v755 = -1;
          char v467 = ((uint64_t (*)(uint64_t *, void (*)(void, void, void)))v458)(v254, v266);
          uint64_t v468 = v464(v254, v266);
          if (v467)
          {
            v471 = v745;
            if (v468 <= 64)
            {
              v472 = v743;
              v473 = v734;
              uint64_t v474 = swift_getAssociatedConformanceWitness((uint64_t)v743, (uint64_t)v254, (uint64_t)v734, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v475 = v735;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v474 + 8))(&qword_18162B0B8, 256, v473, v474);
              ((void (*)(char *, uint64_t *, int **))v472[3])(v475, v254, v472);
              LOBYTE(v472) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v266 + 4)
                                                                                              + 8)
                                                                                  + 40))(v466, v471, v254);
              ((void (*)(char *, uint64_t *))v264)(v471, v254);
              unint64_t v476 = v755;
              v477 = v688;
              ((void (*)(char *, char *, uint64_t *))v737)(v688, v466, v254);
              if (v472)
              {
                unint64_t v478 = (*((uint64_t (**)(uint64_t *, void (*)(void, void, void)))v266 + 15))(v254, v266);
                ((void (*)(char *, uint64_t *))v264)(v477, v254);
                if (v476 < v478) {
                  goto LABEL_243;
                }
              }
              else
              {
                ((void (*)(char *, uint64_t *))v264)(v477, v254);
              }
              goto LABEL_255;
            }
          }
          else
          {
            v471 = v745;
            if (v468 <= 64)
            {
              ((void (*)(char *, char *, uint64_t *))v737)(v745, v466, v254);
              unint64_t v511 = (*((uint64_t (**)(uint64_t *, void (*)(void, void, void)))v266 + 15))(v254, v266);
              ((void (*)(char *, uint64_t *))v264)(v471, v254);
              if (v755 < v511) {
                goto LABEL_243;
              }
LABEL_255:
              ((void (*)(char *, uint64_t *))v264)(v466, v254);
              v465 = v713;
LABEL_256:
              uint64_t v516 = (*((uint64_t (**)(uint64_t *, void (*)(void, void, void)))v266 + 15))(v254, v266);
              ((void (*)(char *, uint64_t *))v264)(v465, v254);
              unint64_t v515 = v750;
LABEL_257:
              uint64_t v627 = (uint64_t)v254;
              __int16 v630 = 0;
              uint64_t v626 = (uint64_t)v739;
              uint64_t v625 = v738 | v516;
              uint64_t v631 = v753;
              v628 = v742;
              v629 = v748;
              goto LABEL_258;
            }
          }
          v507 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, void (*)(void, void, void)))*((void *)v266 + 12);
          unint64_t v508 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v468, v469, v470);
          v507(&v755, &type metadata for UInt64, v508, v254, v266);
          char v509 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v266 + 4) + 8) + 16))(v471, v466, v254);
          ((void (*)(char *, uint64_t *))v264)(v471, v254);
          if (v509) {
            goto LABEL_243;
          }
          goto LABEL_255;
        }
        unint64_t v407 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        ((void (*)(char *, uint64_t *))v264)(v406, v71);
        BOOL v408 = v405 >= v407;
        uint64_t v140 = v264;
      }
      else
      {
        unint64_t v266 = (void (*)(void, void, void))v751;
        if (v269 > 64)
        {
          v349 = v140;
          v350 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
          unint64_t v351 = lazy protocol witness table accessor for type UInt and conformance UInt(v269, v270, v271);
          v352 = v752;
          v350(&v755, &type metadata for UInt, v351, v71, v67);
          uint64_t v140 = v349;
          uint64_t v265 = v709;
          char v275 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v352, v709, v71);
          ((void (*)(char *, uint64_t *))v349)(v352, v71);
LABEL_109:
          char v254 = (uint64_t *)v715;
          if (v275) {
            goto LABEL_243;
          }
          goto LABEL_206;
        }
        v409 = v752;
        uint64_t v265 = v709;
        ((void (*)(char *, char *, uint64_t *))v750)(v752, v709, v71);
        unint64_t v410 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        ((void (*)(char *, uint64_t *))v140)(v409, v71);
        BOOL v408 = v755 >= v410;
      }
      char v254 = (uint64_t *)v715;
      if (!v408) {
        goto LABEL_243;
      }
      goto LABEL_206;
    }
    unint64_t v755 = 0;
    uint64_t v243 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
    unint64_t v244 = lazy protocol witness table accessor for type Int and conformance Int(v240, v241, v242);
    uint64_t v245 = v752;
    v243(&v755, &type metadata for Int, v244, v71, v67);
    char v246 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v751, v245, v71);
    uint64_t v237 = v138 + 8;
    uint64_t v247 = v245;
    uint64_t v140 = v729;
    ((void (*)(char *, uint64_t *))v729)(v247, v71);
    char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
  }
  uint64_t v238 = v728;
  if (v246)
  {
LABEL_53:
    uint64_t v253 = v237 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    goto LABEL_54;
  }
LABEL_112:
  (*(void (**)(char *, char *, uint64_t *))(v138 + 32))(v238, v751, v71);
  char v354 = v202(v71, v67);
  v355 = v745;
  if (v354)
  {
    v356 = v706;
    (*(void (**)(char *, char *, uint64_t *))(v138 + 16))(v706, v238, v71);
    v357 = v739;
    v358 = v737;
    uint64_t v359 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v360 = v738;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v359 + 8))(&qword_18162B0B8, 256, v358, v359);
    v361 = v140;
    v362 = v752;
    ((void (*)(uint64_t, uint64_t *, int **))v357[3])(v360, v71, v357);
    LOBYTE(v357) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 32))(v356, v362, v71);
    v363 = v362;
    uint64_t v140 = v361;
    ((void (*)(char *, uint64_t *))v361)(v363, v71);
    if ((v357 & 1) == 0) {
      goto LABEL_281;
    }
    ((void (*)(char *, uint64_t *))v361)(v356, v71);
    v355 = v745;
    char v202 = (uint64_t (*)(uint64_t *, uint64_t))v750;
    uint64_t v238 = v728;
  }
  v364 = v748;
  if (((uint64_t (*)(uint64_t *, uint64_t))v748)(v71, v67) >= 64)
  {
    unint64_t v750 = *(void *)(v747 + 16);
    v751 = (char *)(v747 + 16);
    ((void (*)(char *, char *, uint64_t *))v750)(v716, v238, v71);
    unint64_t v755 = -1;
    char v365 = v202(v71, v67);
    uint64_t v366 = ((uint64_t (*)(uint64_t *, uint64_t))v364)(v71, v67);
    if (v365)
    {
      v729 = v140;
      if (v366 <= 64)
      {
        v379 = v739;
        v380 = v737;
        uint64_t v381 = swift_getAssociatedConformanceWitness((uint64_t)v739, (uint64_t)v71, (uint64_t)v737, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v382 = v738;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v381 + 8))(&qword_18162B0B8, 256, v380, v381);
        v383 = v752;
        ((void (*)(uint64_t, uint64_t *, int **))v379[3])(v382, v71, v379);
        v384 = v716;
        LOBYTE(v379) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8)
                                                                            + 40))(v716, v383, v71);
        v385 = v383;
        uint64_t v140 = v729;
        ((void (*)(char *, uint64_t *))v729)(v385, v71);
        unint64_t v386 = v755;
        v387 = v692;
        ((void (*)(char *, char *, uint64_t *))v750)(v692, v384, v71);
        if (v379)
        {
          unint64_t v388 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
          ((void (*)(char *, uint64_t *))v140)(v387, v71);
          uint64_t v238 = v728;
          if (v386 < v388) {
            goto LABEL_243;
          }
        }
        else
        {
          ((void (*)(char *, uint64_t *))v140)(v387, v71);
          uint64_t v238 = v728;
        }
LABEL_127:
        ((void (*)(char *, uint64_t *))v140)(v716, v71);
        goto LABEL_128;
      }
      v369 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
      unint64_t v370 = lazy protocol witness table accessor for type UInt and conformance UInt(v366, v367, v368);
      v371 = v752;
      v369(&v755, &type metadata for UInt, v370, v71, v67);
      char v372 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v371, v716, v71);
      v373 = v371;
      uint64_t v140 = v729;
      ((void (*)(char *, uint64_t *))v729)(v373, v71);
    }
    else
    {
      if (v366 <= 64)
      {
        v389 = v752;
        ((void (*)(char *, char *, uint64_t *))v750)(v752, v716, v71);
        unint64_t v390 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
        ((void (*)(char *, uint64_t *))v140)(v389, v71);
        uint64_t v238 = v728;
        if (v755 < v390) {
          goto LABEL_243;
        }
        goto LABEL_127;
      }
      v374 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
      unint64_t v375 = lazy protocol witness table accessor for type UInt and conformance UInt(v366, v367, v368);
      v376 = v140;
      v377 = v752;
      v374(&v755, &type metadata for UInt, v375, v71, v67);
      char v372 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v67 + 32) + 8) + 16))(v377, v716, v71);
      v378 = v377;
      uint64_t v140 = v376;
      ((void (*)(char *, uint64_t *))v376)(v378, v71);
    }
    uint64_t v238 = v728;
    if (v372) {
      goto LABEL_243;
    }
    goto LABEL_127;
  }
LABEL_128:
  unint64_t v391 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v71, v67);
  uint64_t result = ((uint64_t (*)(char *, uint64_t *))v140)(v238, v71);
  if (v391 < 0xFFFFFFFFFFFFFC01)
  {
    uint64_t v738 = v391 + 1023;
    v392 = v743;
    uint64_t v393 = v746;
    goto LABEL_209;
  }
LABEL_286:
  __break(1u);
LABEL_287:
  if (__clz(__rbit64(*(void *)&v5 & 0xFFFFFFFFFFFFFLL)) >= __clz(__rbit64((unint64_t)v733))) {
    double v314 = v5;
  }
  else {
    double v314 = *(double *)&v4;
  }
LABEL_290:
  double *v736 = v314;
  return result;
}

uint64_t specialized static BinaryFloatingPoint._convert<A>(from:)(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v703 = a1;
  v718 = *(int ***)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  v715 = (int *)((char *)&v657 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v9);
  uint64_t v683 = (char *)&v657 - v11;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, v12, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v711 = *(char **)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8);
  uint64_t v691 = *((void *)v711 + 3);
  v714 = *(int ***)(v691 + 16);
  v709 = swift_getAssociatedTypeWitness(0, v714, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v709);
  v708 = (char *)&v657 - v15;
  v704 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v710 = *(v704 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v704);
  v679 = (char *)&v657 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v719 = (int *)((char *)&v657 - v19);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v713 = (char *)&v657 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v664 = (char *)&v657 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v684 = (char *)&v657 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v695 = (char *)&v657 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v687 = (char *)&v657 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v660 = (char *)&v657 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v670 = (char *)&v657 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  v671 = (char *)&v657 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v682 = (char *)&v657 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v694 = (char *)&v657 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  v693 = (char *)&v657 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  v700 = (char *)&v657 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  v692 = (char *)&v657 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v701 = (char *)&v657 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v662 = (char *)&v657 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v675 = (char *)&v657 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  v676 = (char *)&v657 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  v697 = (char *)&v657 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  double v659 = (char *)&v657 - v57;
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  v668 = (char *)&v657 - v59;
  uint64_t v60 = MEMORY[0x1F4188790](v58);
  uint64_t v669 = (char *)&v657 - v61;
  uint64_t v62 = MEMORY[0x1F4188790](v60);
  uint64_t v685 = (char *)&v657 - v63;
  MEMORY[0x1F4188790](v62);
  v716 = (int **)((char *)&v657 - v64);
  uint64_t v712 = a4;
  uint64_t v65 = *(void *)(a4 + 16);
  uint64_t v66 = swift_getAssociatedTypeWitness(255, (int **)v65, a3, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v65, a3, (uint64_t)v66, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  uint64_t v67 = *(int ***)(AssociatedConformanceWitness + 8);
  v699 = v67[3];
  v707 = (int **)*((void *)v699 + 2);
  v705 = swift_getAssociatedTypeWitness(0, v707, (uint64_t)v66, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v705);
  v706 = (char *)&v657 - v68;
  uint64_t v69 = (uint64_t)v66;
  uint64_t v70 = a3;
  uint64_t v71 = (uint64_t)swift_checkMetadataState(0, v69);
  uint64_t v717 = *(void *)(v71 - 8);
  uint64_t v72 = MEMORY[0x1F4188790](v71);
  uint64_t v74 = (char *)&v657 - ((v73 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v75 = MEMORY[0x1F4188790](v72);
  uint64_t v77 = (char *)&v657 - v76;
  uint64_t v78 = MEMORY[0x1F4188790](v75);
  v681 = (char *)&v657 - v79;
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  uint64_t v667 = (char *)&v657 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  v663 = (char *)&v657 - v83;
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  uint64_t v86 = (char *)&v657 - v85;
  uint64_t v87 = MEMORY[0x1F4188790](v84);
  v677 = (char *)&v657 - v88;
  uint64_t v89 = MEMORY[0x1F4188790](v87);
  v696 = (char *)&v657 - v90;
  uint64_t v91 = MEMORY[0x1F4188790](v89);
  v661 = (char *)&v657 - v92;
  uint64_t v93 = MEMORY[0x1F4188790](v91);
  uint64_t v95 = (char *)&v657 - v94;
  uint64_t v96 = MEMORY[0x1F4188790](v93);
  v672 = (char *)&v657 - v97;
  uint64_t v98 = MEMORY[0x1F4188790](v96);
  uint64_t v686 = (uint64_t *)((char *)&v657 - v99);
  uint64_t v100 = MEMORY[0x1F4188790](v98);
  v673 = (char *)&v657 - v101;
  uint64_t v102 = MEMORY[0x1F4188790](v100);
  uint64_t v674 = (char *)&v657 - v103;
  uint64_t v104 = MEMORY[0x1F4188790](v102);
  uint64_t v665 = (char *)&v657 - v105;
  uint64_t v106 = MEMORY[0x1F4188790](v104);
  unint64_t v666 = (char *)&v657 - v107;
  uint64_t v108 = MEMORY[0x1F4188790](v106);
  v658 = (char *)&v657 - v109;
  uint64_t v110 = MEMORY[0x1F4188790](v108);
  v689 = (char *)&v657 - v111;
  uint64_t v112 = MEMORY[0x1F4188790](v110);
  v688 = (char *)&v657 - v113;
  uint64_t v114 = MEMORY[0x1F4188790](v112);
  v678 = (char *)&v657 - v115;
  uint64_t v116 = MEMORY[0x1F4188790](v114);
  v690 = (char *)&v657 - v117;
  uint64_t v118 = MEMORY[0x1F4188790](v116);
  v702 = (int *)((char *)&v657 - v119);
  uint64_t v120 = MEMORY[0x1F4188790](v118);
  v698 = (char *)&v657 - v121;
  uint64_t v122 = MEMORY[0x1F4188790](v120);
  uint64_t v124 = (char *)&v657 - v123;
  uint64_t v125 = MEMORY[0x1F4188790](v122);
  unint64_t v721 = (unint64_t)&v657 - v126;
  MEMORY[0x1F4188790](v125);
  v722 = (char *)&v657 - v127;
  uint64_t v723 = v70;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 384))(v70, v65))
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v723, v65) & 1) == 0)
    {
      float *v703 = 0.0;
      return 1;
    }
    unsigned int v638 = 0x80000000;
    goto LABEL_277;
  }
  char v128 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 376))(v723, v65);
  uint64_t v720 = a2;
  if ((v128 & 1) == 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 400))(v723, v65) & 1) == 0)
    {
      uint64_t v639 = v712;
      v640 = *(void (**)(uint64_t, uint64_t))(v712 + 120);
      uint64_t v641 = v723;
      v640(v723, v712);
      uint64_t v642 = v683;
      (*(void (**)(uint64_t, uint64_t))(v65 + 96))(v641, v65);
      v640(v641, v639);
      uint64_t v643 = v718[1];
      ((void (*)(char *, uint64_t))v643)(v642, v641);
      uint64_t v644 = (char *)v715;
      (*(void (**)(uint64_t, uint64_t))(v65 + 104))(v641, v65);
      uint64_t v645 = v679;
      v640(v641, v639);
      ((void (*)(char *, uint64_t))v643)(v644, v641);
      uint64_t v646 = (uint64_t)v711;
      unint64_t v647 = v693;
      v648 = v719;
      v649 = v704;
      (*((void (**)(int *, char *, uint64_t *, char *))v711 + 26))(v719, v645, v704, v711);
      v650 = *(void (**)(char *, uint64_t *))(v710 + 8);
      v650(v645, v649);
      v650((char *)v648, v649);
      v651 = v700;
      (*(void (**)(char *, uint64_t *, uint64_t))(v646 + 184))(v647, v649, v646);
      v650(v647, v649);
      v652 = v713;
      v653 = v716;
      (*(void (**)(int **, char *, uint64_t *, uint64_t))(v646 + 192))(v716, v651, v649, v646);
      v650(v651, v649);
      v650((char *)v653, v649);
      LODWORD(v646) = (*(uint64_t (**)(uint64_t *, uint64_t))(v646 + 120))(v649, v646);
      v650(v652, v649);
      LODWORD(v65_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = v646 & 0x1FFFFF;
      LOBYTE(v646) = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 416))(v641, v65);
      int v654 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v641, v65);
      uint64_t result = 0;
      unsigned int v655 = v650 | (v654 << 31);
      if (v646) {
        int v656 = 2141192192;
      }
      else {
        int v656 = 2143289344;
      }
      int v215 = v655 | v656;
      goto LABEL_91;
    }
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v723, v65))
    {
LABEL_276:
      unsigned int v638 = -8388608;
      goto LABEL_277;
    }
    unsigned int v638 = 2139095040;
LABEL_277:
    *(_DWORD *)v703 = v638;
    return 1;
  }
  v679 = v95;
  uint64_t v683 = v86;
  char v129 = *(void (**)(uint64_t, uint64_t))(v65 + 176);
  uint64_t v130 = v722;
  v713 = (char *)v65;
  v129(v723, v65);
  int64_t v725 = -126;
  char v132 = (void (*)(char *, uint64_t))(v67 + 8);
  uint64_t v131 = v67[8];
  char v133 = ((uint64_t (*)(uint64_t, int **))v131)(v71, v67);
  v718 = v67 + 8;
  v715 = v131;
  if (v133)
  {
    v719 = v67[16];
    uint64_t v134 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
    uint64_t v137 = v130;
    if (v134 < 64)
    {
      uint64_t v138 = (int *)v717;
      unint64_t v139 = v721;
      (*(void (**)(unint64_t, char *, uint64_t))(v717 + 16))(v721, v137, v71);
      uint64_t v140 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      uint64_t v142 = (uint64_t)(v138 + 2);
      uint64_t v141 = (int *)*((void *)v138 + 1);
      ((void (*)(unint64_t, uint64_t))v141)(v139, v71);
      if (v140 >= v725)
      {
LABEL_6:
        char v132 = (void (*)(char *, uint64_t))v718;
        goto LABEL_34;
      }
      goto LABEL_12;
    }
    unint64_t v151 = v67[12];
    unint64_t v152 = lazy protocol witness table accessor for type Int and conformance Int(v134, v135, v136);
    unint64_t v153 = v721;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v151)(&v725, &type metadata for Int, v152, v71, v67);
    char v150 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v130, v153, v71);
    uint64_t v138 = (int *)v717;
    uint64_t v142 = v717 + 8;
    uint64_t v141 = *(int **)(v717 + 8);
    ((void (*)(unint64_t, uint64_t))v141)(v153, v71);
LABEL_11:
    if ((v150 & 1) == 0) {
      goto LABEL_6;
    }
LABEL_12:
    uint64_t v154 = v142 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    goto LABEL_13;
  }
  char v143 = ((uint64_t (*)(uint64_t, int **))v131)(v71, v67);
  v719 = v67[16];
  uint64_t v144 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
  if ((v143 & 1) == 0)
  {
    uint64_t v138 = (int *)v717;
    uint64_t v171 = *(void (**)(char *, char *, uint64_t))(v717 + 16);
    if (v144 >= 64)
    {
      v171(v74, v722, v71);
      uint64_t v141 = (int *)*((void *)v138 + 1);
      ((void (*)(char *, uint64_t))v141)(v74, v71);
    }
    else
    {
      unint64_t v172 = v721;
      v171((char *)v721, v722, v71);
      uint64_t v173 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      uint64_t v141 = (int *)*((void *)v138 + 1);
      ((void (*)(unint64_t, uint64_t))v141)(v172, v71);
      if (v173 < v725)
      {
        uint64_t v154 = (unint64_t)(v138 + 2) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        uint64_t v131 = v715;
        goto LABEL_13;
      }
      uint64_t v131 = v715;
    }
    goto LABEL_34;
  }
  if (v144 > 64)
  {
    unint64_t v147 = v67[12];
    unint64_t v148 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
    unint64_t v149 = v721;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v147)(&v725, &type metadata for Int, v148, v71, v67);
    char v150 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v722, v149, v71);
    uint64_t v138 = (int *)v717;
    uint64_t v142 = v717 + 8;
    uint64_t v141 = *(int **)(v717 + 8);
    ((void (*)(unint64_t, uint64_t))v141)(v149, v71);
    goto LABEL_11;
  }
  uint64_t v183 = v707;
  uint64_t v184 = v705;
  uint64_t v185 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v186 = v706;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v185 + 8))(&qword_18162B0B8, 256, v184, v185);
  unint64_t v187 = v721;
  ((void (*)(char *, uint64_t, int **))v183[3])(v186, v71, v183);
  uint64_t v188 = v722;
  LOBYTE(v184) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v722, v187, v71);
  uint64_t v189 = v717;
  char v190 = *(int **)(v717 + 8);
  uint64_t v657 = (v717 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  ((void (*)(unint64_t, uint64_t))v190)(v187, v71);
  (*(void (**)(char *, char *, uint64_t))(v189 + 16))(v77, v188, v71);
  if (v184)
  {
    ((void (*)(char *, uint64_t))v190)(v77, v71);
    uint64_t v141 = v190;
    uint64_t v131 = v715;
    uint64_t v154 = v657;
    goto LABEL_13;
  }
  int64_t v198 = v725;
  uint64_t v199 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
  ((void (*)(char *, uint64_t))v190)(v77, v71);
  BOOL v200 = v199 < v198;
  char v132 = (void (*)(char *, uint64_t))v718;
  uint64_t v141 = v190;
  uint64_t v138 = (int *)v717;
  uint64_t v131 = v715;
  uint64_t v154 = v657;
  if (!v200)
  {
LABEL_34:
    int64_t v725 = 127;
    char v201 = ((uint64_t (*)(uint64_t, int **))v131)(v71, v67);
    char v202 = v67 + 16;
    char v203 = v722;
    uint64_t v204 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
    if (v201)
    {
      if (v204 > 64)
      {
        uint64_t v207 = v67[12];
        unint64_t v208 = lazy protocol witness table accessor for type Int and conformance Int(v204, v205, v206);
        unint64_t v209 = v721;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v207)(&v725, &type metadata for Int, v208, v71, v67);
        char v210 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v209, v203, v71);
        unint64_t v211 = v209;
        char v132 = (void (*)(char *, uint64_t))v718;
        ((void (*)(unint64_t, uint64_t))v141)(v211, v71);
        if ((v210 & 1) == 0) {
          goto LABEL_43;
        }
        goto LABEL_40;
      }
    }
    else if (v204 > 63)
    {
      uint64_t v724 = 127;
      uint64_t v216 = (uint64_t (*)(char *, char *, uint64_t))*((void *)v138 + 2);
      v702 = (int *)(v67 + 16);
      uint64_t v217 = v681;
      uint64_t v218 = v216(v681, v203, v71);
      uint64_t v219 = v67[12];
      unint64_t v222 = lazy protocol witness table accessor for type Int and conformance Int(v218, v220, v221);
      uint64_t v223 = v141;
      unint64_t v224 = v721;
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v219)(&v724, &type metadata for Int, v222, v71, v67);
      char v203 = v722;
      char v132 = (void (*)(char *, uint64_t))v718;
      char v225 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v224, v217, v71);
      unint64_t v226 = v224;
      uint64_t v141 = v223;
      ((void (*)(unint64_t, uint64_t))v223)(v226, v71);
      char v227 = v217;
      char v202 = (int **)v702;
      ((void (*)(char *, uint64_t))v223)(v227, v71);
      if (v225)
      {
LABEL_40:
        ((void (*)(char *, uint64_t))v141)(v203, v71);
        if ((*((uint64_t (**)(void))v713 + 21))(v723))
        {
          uint64_t result = 0;
          int v215 = -8388608;
        }
        else
        {
          uint64_t result = 0;
          int v215 = 2139095040;
        }
LABEL_91:
        *(_DWORD *)v703 = v215;
        return result;
      }
LABEL_43:
      uint64_t v228 = v715;
      if (((uint64_t (*)(uint64_t, int **))v715)(v71, v67))
      {
        uint64_t v229 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
        if (v229 >= 64)
        {
          int64_t v725 = 0;
          uint64_t v232 = v67[12];
          unint64_t v233 = lazy protocol witness table accessor for type Int and conformance Int(v229, v230, v231);
          unint64_t v234 = v721;
          ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v232)(&v725, &type metadata for Int, v233, v71, v67);
          char v235 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v203, v234, v71);
          uint64_t v236 = v138 + 2;
          unint64_t v237 = v234;
          char v132 = (void (*)(char *, uint64_t))v718;
          ((void (*)(unint64_t, uint64_t))v141)(v237, v71);
          if ((v235 & 1) == 0) {
            goto LABEL_54;
          }
          goto LABEL_63;
        }
LABEL_53:
        unint64_t v246 = v721;
        (*((void (**)(unint64_t, char *, uint64_t))v138 + 2))(v721, v203, v71);
        uint64_t v247 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        uint64_t v236 = v138 + 2;
        ((void (*)(unint64_t, uint64_t))v141)(v246, v71);
        if ((v247 & 0x8000000000000000) == 0) {
          goto LABEL_54;
        }
        goto LABEL_63;
      }
      char v238 = ((uint64_t (*)(uint64_t, int **))v228)(v71, v67);
      uint64_t v239 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
      if ((v238 & 1) == 0)
      {
        if (v239 >= 64) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
      if (v239 <= 64)
      {
        v305 = v707;
        char v306 = v705;
        uint64_t v307 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v308 = v706;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v307 + 8))(&qword_18162B0B8, 256, v306, v307);
        unint64_t v309 = v721;
        ((void (*)(char *, uint64_t, int **))v305[3])(v308, v71, v305);
        LOBYTE(v305) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v203, v309, v71);
        uint64_t v248 = (unint64_t)(v138 + 2) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        ((void (*)(unint64_t, uint64_t))v141)(v309, v71);
        char v132 = (void (*)(char *, uint64_t))v667;
        (*((void (**)(char *, char *, uint64_t))v138 + 2))(v667, v203, v71);
        if ((v305 & 1) == 0) {
          goto LABEL_122;
        }
        ((void (*)(void, uint64_t))v141)(v132, v71);
        char v203 = v722;
LABEL_64:
        v702 = (int *)v202;
        uint64_t v269 = v686;
        (*(void (**)(char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 16) + 16))(v203, v71);
        uint64_t v270 = v203;
        uint64_t v271 = v269;
        ((void (*)(char *, uint64_t))v141)(v270, v71);
        uint64_t v272 = v715;
        if (((uint64_t (*)(uint64_t, int **))v715)(v71, v67))
        {
          unint64_t v273 = v672;
          (*((void (**)(char *, uint64_t *, uint64_t))v138 + 2))(v672, v271, v71);
          uint64_t v274 = v707;
          char v275 = v705;
          uint64_t v276 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v277 = v706;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v276 + 8))(&qword_18162B0B8, 256, v275, v276);
          unint64_t v278 = v721;
          ((void (*)(char *, uint64_t, int **))v274[3])(v277, v71, v274);
          LOBYTE(v274) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 32))(v273, v278, v71);
          ((void (*)(unint64_t, uint64_t))v141)(v278, v71);
          if ((v274 & 1) == 0) {
            goto LABEL_274;
          }
          ((void (*)(char *, uint64_t))v141)(v273, v71);
          uint64_t v272 = v715;
          uint64_t v271 = v686;
        }
        v722 = (char *)v248;
        uint64_t v279 = v138;
        char v280 = v719;
        uint64_t v281 = (char *)v702;
        if (((uint64_t (*)(uint64_t, int **))v719)(v71, v67) < 64)
        {
LABEL_199:
          unint64_t v409 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
          ((void (*)(uint64_t *, uint64_t))v141)(v271, v71);
          v358 = (char *)(127 - v409);
          if (v409 > 0x7F)
          {
            __break(1u);
          }
          else
          {
LABEL_200:
            v706 = v358;
            v481 = v714;
            uint64_t v482 = v712;
            uint64_t v483 = *(int ***)(v712 + 136);
            uint64_t v717 = (v712 + 136) & 0xFFFFFFFFFFFFLL | 0x1E66000000000000;
            v718 = v483;
            uint64_t v484 = v723;
            unint64_t v721 = ((uint64_t (*)(uint64_t, uint64_t))v483)(v723, v712);
            v485 = v716;
            v719 = *(int **)(v482 + 120);
            ((void (*)(uint64_t, uint64_t))v719)(v484, v482);
            v486 = (char *)*((void *)v711 + 18);
            uint64_t v271 = v704;
            v699 = (int *)(v711 + 144);
            v698 = v486;
            uint64_t v487 = ((uint64_t (*)(uint64_t *))v486)(v704);
            char v488 = *(void (**)(int **, uint64_t *))(v710 + 8);
            v715 = (int *)(v710 + 8);
            v488(v485, v271);
            unint64_t v721 = 23 - v721 - v487;
            LOBYTE(v484) = (*((uint64_t (**)(void))v713 + 49))(v484);
            uint64_t v489 = v709;
            uint64_t v490 = swift_getAssociatedConformanceWitness((uint64_t)v481, (uint64_t)v271, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v491 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v490 + 8);
            v722 = (char *)v488;
            v705 = (const char *)(v481 + 3);
            v707 = (int **)(v482 + 120);
            if (v484)
            {
              v492 = v708;
              v491(&qword_18162B0C0, 512, v489, v490);
              v702 = v481[3];
              ((void (*)(char *, uint64_t *, int **))v702)(v492, v271, v481);
              uint64_t v493 = v723;
              uint64_t v494 = ((uint64_t (*)(uint64_t, uint64_t))v718)(v723, v482);
              v495 = v700;
              v496 = v719;
              ((void (*)(uint64_t, uint64_t))v719)(v493, v482);
              uint64_t v281 = v711;
              uint64_t v497 = ((uint64_t (*)(uint64_t *, char *))v698)(v271, v711);
              v498 = v722;
              uint64_t v499 = ((uint64_t (*)(char *, uint64_t *))v722)(v495, v271);
              int64_t v725 = v497 + v494;
              unint64_t v500 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 32);
              unint64_t v503 = lazy protocol witness table accessor for type Int and conformance Int(v499, v501, v502);
              v504 = v694;
              unint64_t v505 = v716;
              v500(v716, &v725, &type metadata for Int, v503, v271, v281);
              ((void (*)(int **, uint64_t *))v498)(v505, v271);
              char v506 = v695;
              v507 = v496;
            }
            else
            {
              unint64_t v508 = v708;
              v491(&qword_18162B0B8, 256, v489, v490);
              v504 = v694;
              v702 = v481[3];
              ((void (*)(char *, uint64_t *, int **))v702)(v508, v271, v481);
              uint64_t v281 = v711;
              char v506 = v695;
              v507 = v719;
            }
            unint64_t v409 = (unint64_t)(v281 + 224);
            uint64_t v71 = v721;
            if ((v721 & 0x8000000000000000) == 0)
            {
              char v509 = v716;
              uint64_t v477 = v723;
              ((void (*)(uint64_t, uint64_t))v507)(v723, v712);
              unint64_t v510 = v687;
              (*((void (**)(char *, int **, uint64_t *, char *))v281 + 28))(v504, v509, v271, v281);
              unint64_t v511 = v722;
              ((void (*)(int **, uint64_t *))v722)(v509, v271);
              ((void (*)(char *, uint64_t *))v511)(v504, v271);
              uint64_t v512 = (int **)*((void *)v281 + 8);
              if ((((uint64_t (*)(uint64_t *, char *))v512)(v271, v281) & 1) == 0) {
                goto LABEL_207;
              }
              v707 = v512;
              (*(void (**)(char *, char *, uint64_t *))(v710 + 16))(v506, v510, v271);
              unint64_t v513 = v714;
              uint64_t v514 = v709;
              uint64_t v515 = swift_getAssociatedConformanceWitness((uint64_t)v714, (uint64_t)v271, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v516 = v708;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v515 + 8))(&qword_18162B0B8, 256, v514, v515);
              ((void (*)(char *, uint64_t *, int **))v702)(v516, v271, v513);
              LOBYTE(v516) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4)
                                                                                              + 8)
                                                                                  + 32))(v506, v509, v271);
              v517 = v722;
              ((void (*)(int **, uint64_t *))v722)(v509, v271);
              if (v516)
              {
                ((void (*)(char *, uint64_t *))v517)(v506, v271);
                uint64_t v512 = v707;
LABEL_207:
                uint64_t v518 = v281;
                uint64_t v519 = v281;
                v520 = v271;
                uint64_t v521 = (uint64_t (*)(uint64_t *, char *))*((void *)v518 + 16);
                if (v521(v520, v519) < 32)
                {
LABEL_238:
                  int v598 = (*((uint64_t (**)(uint64_t *, char *))v519 + 15))(v520, v519);
                  ((void (*)(char *, uint64_t *))v722)(v510, v520);
                  if (v721 < 0x20) {
                    uint64_t v599 = (v598 << v721);
                  }
                  else {
                    uint64_t v599 = 0;
                  }
                  uint64_t v600 = 23;
                  uint64_t v479 = v712;
                  unint64_t v478 = (uint64_t (**)(void))v713;
                  goto LABEL_245;
                }
                v522 = *(void (**)(char *, char *, uint64_t *))(v710 + 16);
                v522(v684, v510, v520);
                LODWORD(v725) = -1;
                char v523 = ((uint64_t (*)(uint64_t *, char *))v512)(v520, v519);
                uint64_t v524 = v521(v520, v519);
                v527 = v519;
                if (v523)
                {
                  uint64_t v528 = v522;
                  uint64_t v529 = v716;
                  if (v524 > 32)
                  {
                    uint64_t v530 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v519 + 12);
                    unint64_t v531 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v524, v525, v526);
                    uint64_t v532 = v704;
                    v530(&v725, &type metadata for UInt32, v531, v704, v519);
                    v533 = *(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v519 + 4) + 8)
                                                                               + 16);
                    uint64_t v534 = v684;
                    char v535 = v533(v529, v684, v532);
                    uint64_t v536 = v529;
                    goto LABEL_223;
                  }
                  v584 = v714;
                  uint64_t v532 = v704;
                  v585 = v709;
                  uint64_t v586 = swift_getAssociatedConformanceWitness((uint64_t)v714, (uint64_t)v704, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  char v587 = v708;
                  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v586 + 8))(&qword_18162B0B8, 256, v585, v586);
                  ((void (*)(char *, uint64_t *, int **))v702)(v587, v532, v584);
                  uint64_t v588 = *(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v519 + 4) + 8)
                                                                             + 40);
                  uint64_t v534 = v684;
                  LOBYTE(v584) = v588(v684, v529, v532);
                  uint64_t v589 = v529;
                  v578 = v722;
                  ((void (*)(int **, uint64_t *))v722)(v589, v532);
                  uint64_t v590 = v527;
                  unsigned int v591 = v725;
                  v592 = v664;
                  v528(v664, v534, v532);
                  if ((v584 & 1) == 0)
                  {
                    ((void (*)(char *, uint64_t *))v578)(v592, v532);
                    uint64_t v477 = v723;
                    unint64_t v510 = v687;
LABEL_237:
                    ((void (*)(char *, uint64_t *))v578)(v534, v532);
                    v520 = v532;
                    uint64_t v519 = v711;
                    goto LABEL_238;
                  }
                  unsigned int v593 = (*((uint64_t (**)(uint64_t *, char *))v590 + 15))(v532, v590);
                  ((void (*)(char *, uint64_t *))v578)(v592, v532);
                  BOOL v594 = v591 >= v593;
                }
                else
                {
                  v574 = v716;
                  if (v524 > 32)
                  {
                    unint64_t v575 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v519 + 12);
                    unint64_t v576 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v524, v525, v526);
                    uint64_t v532 = v704;
                    v575(&v725, &type metadata for UInt32, v576, v704, v519);
                    v577 = *(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v519 + 4) + 8)
                                                                               + 16);
                    uint64_t v534 = v684;
                    char v535 = v577(v574, v684, v532);
                    uint64_t v536 = v574;
LABEL_223:
                    v578 = v722;
                    ((void (*)(int **, uint64_t *))v722)(v536, v532);
                    uint64_t v477 = v723;
                    unint64_t v510 = v687;
                    if (v535) {
                      goto LABEL_234;
                    }
                    goto LABEL_237;
                  }
                  uint64_t v534 = v684;
                  uint64_t v532 = v704;
                  v522((char *)v716, v684, v704);
                  unsigned int v595 = (*((uint64_t (**)(uint64_t *, char *))v527 + 15))(v532, v527);
                  v578 = v722;
                  ((void (*)(int **, uint64_t *))v722)(v574, v532);
                  BOOL v594 = v725 >= v595;
                }
                uint64_t v477 = v723;
                unint64_t v510 = v687;
                if (!v594) {
                  goto LABEL_234;
                }
                goto LABEL_237;
              }
LABEL_274:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
            }
            uint64_t v537 = v700;
            ((void (*)(uint64_t, uint64_t))v507)(v723, v712);
            uint64_t v67 = v716;
            (*((void (**)(char *, char *, uint64_t *, char *))v281 + 28))(v504, v537, v271, v281);
            unint64_t v538 = v722;
            ((void (*)(char *, uint64_t *))v722)(v537, v271);
            uint64_t v539 = ((uint64_t (*)(char *, uint64_t *))v538)(v504, v271);
            if (!__OFSUB__(0, v71))
            {
              int64_t v725 = -v71;
              v542 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 30);
              unint64_t v543 = lazy protocol witness table accessor for type Int and conformance Int(v539, v540, v541);
              v544 = v682;
              v542(v67, &v725, &type metadata for Int, v543, v271, v281);
              ((void (*)(int **, uint64_t *))v538)(v67, v271);
              v545 = (int **)*((void *)v281 + 8);
              char v546 = ((uint64_t (*)(uint64_t *, char *))v545)(v271, v281);
              v547 = v714;
              if (v546)
              {
                v707 = v545;
                v548 = v544;
                v549 = v671;
                (*(void (**)(void))(v710 + 16))();
                uint64_t v550 = v709;
                uint64_t v551 = swift_getAssociatedConformanceWitness((uint64_t)v547, (uint64_t)v271, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v552 = v708;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v551 + 8))(&qword_18162B0B8, 256, v550, v551);
                ((void (*)(char *, uint64_t *, int **))v702)(v552, v271, v547);
                LOBYTE(v552) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4)
                                                                                                + 8)
                                                                                    + 32))(v549, v67, v271);
                v553 = v722;
                ((void (*)(int **, uint64_t *))v722)(v67, v271);
                if ((v552 & 1) == 0) {
                  goto LABEL_274;
                }
                ((void (*)(char *, uint64_t *))v553)(v549, v271);
                v544 = v548;
                v545 = v707;
              }
              v554 = v281;
              v555 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 16);
              if (v555(v271, v554) < 32)
              {
LABEL_244:
                uint64_t v599 = (*((uint64_t (**)(uint64_t *, char *))v554 + 15))(v271, v554);
                ((void (*)(char *, uint64_t *))v722)(v544, v271);
                uint64_t v600 = 23;
                uint64_t v477 = v723;
                uint64_t v479 = v712;
                unint64_t v478 = (uint64_t (**)(void))v713;
LABEL_245:
                uint64_t v480 = v718;
                unsigned __int8 v601 = v706;
LABEL_250:
                unint64_t v602 = (char *)v478[21];
                v707 = (int **)(v478 + 21);
                v706 = v602;
                uint64_t v603 = v477;
                int v604 = (v601 << 23) | (((unsigned int (*)(uint64_t))v602)(v477) << 31) | v599 & 0x7FFFFF;
                if (v600 < ((uint64_t (*)(uint64_t, uint64_t))v480)(v603, v479))
                {
                  uint64_t v605 = v599;
                  LODWORD(v702) = v604;
                  unint64_t v606 = v714;
                  v607 = v704;
                  uint64_t v608 = v709;
                  uint64_t v609 = swift_getAssociatedConformanceWitness((uint64_t)v714, (uint64_t)v704, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  unint64_t v610 = v716;
                  char v611 = v708;
                  v705 = *(const char **)(v609 + 8);
                  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v705)(&qword_18162B0C0, 512, v608, v609);
                  v718 = (int **)v606[3];
                  uint64_t v612 = ((uint64_t (*)(char *, uint64_t *, int **))v718)(v611, v607, v606);
                  if (!__OFSUB__(0, v721))
                  {
                    unint64_t v615 = (unint64_t)(v606 + 3);
                    v699 = (int *)v605;
                    int64_t v725 = -(uint64_t)v721;
                    uint64_t v717 = v609;
                    v715 = (int *)(v609 + 8);
                    v617 = v711;
                    uint64_t v616 = v712;
                    unint64_t v618 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v711 + 32);
                    unint64_t v619 = lazy protocol witness table accessor for type Int and conformance Int(v612, v613, v614);
                    unint64_t v721 = v615;
                    v618(v610, &v725, &type metadata for Int, v619, v607, v617);
                    unint64_t v620 = v722;
                    ((void (*)(int **, uint64_t *))v722)(v610, v607);
                    ((void (*)(uint64_t, uint64_t))v719)(v723, v616);
                    unint64_t v621 = v611;
                    unint64_t v622 = v705;
                    ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v705)(&qword_18162B0C0, 512, v608, v717);
                    v623 = v693;
                    ((void (*)(char *, uint64_t *, int **))v718)(v621, v607, v714);
                    uint64_t v624 = v700;
                    (*(void (**)(char *, char *, uint64_t *))(*(void *)(v691 + 8) + 40))(v701, v623, v607);
                    ((void (*)(char *, uint64_t *))v620)(v623, v607);
                    uint64_t v625 = v692;
                    (*((void (**)(int **, char *, uint64_t *, char *))v617 + 24))(v610, v624, v607, v617);
                    ((void (*)(char *, uint64_t *))v620)(v624, v607);
                    ((void (*)(int **, uint64_t *))v620)(v610, v607);
                    uint64_t v626 = v708;
                    ((void (*)(void *, uint64_t))v622)(&unk_18162B0D0, 768);
                    uint64_t v627 = v701;
                    ((void (*)(char *, uint64_t *, int **))v718)(v626, v607, v714);
                    v628 = v625;
                    v719 = (int *)*((void *)v617 + 19);
                    ((void (*)(char *, char *, uint64_t *, char *))v719)(v627, v624, v607, v617);
                    ((void (*)(char *, uint64_t *))v620)(v624, v607);
                    uint64_t v629 = *(void *)(*((void *)v617 + 4) + 8);
                    LOBYTE(v615) = (*(uint64_t (**)(char *, int **, uint64_t *, uint64_t))(v629 + 16))(v625, v610, v607, v629);
                    ((void (*)(int **, uint64_t *))v620)(v610, v607);
                    if (v615)
                    {
                      ((void (*)(char *, uint64_t *))v620)(v625, v607);
                      ((void (*)(char *, uint64_t *))v620)(v627, v607);
                      uint64_t result = 0;
                      *(_DWORD *)v703 = v702;
                      return result;
                    }
                    float v4 = *(float *)&v702;
                    if (((uint64_t (*)(uint64_t, char *))v706)(v723, v713))
                    {
                      float v632 = 0.0 - v4;
                      __int16 v630 = v714;
                      uint64_t v631 = v708;
                      if ((float)(0.0 - v4) < INFINITY) {
                        LODWORD(v632) += (SLODWORD(v632) >> 31) | 1;
                      }
                      float v5 = -v632;
                    }
                    else
                    {
                      float v5 = v4 + 0.0;
                      __int16 v630 = v714;
                      uint64_t v631 = v708;
                      if ((float)(v4 + 0.0) < INFINITY) {
                        LODWORD(v5) += (SLODWORD(v5) >> 31) | 1;
                      }
                    }
                    ((void (*)(void *, uint64_t))v705)(&unk_18162B0D0, 768);
                    v633 = v700;
                    v634 = v631;
                    v635 = v704;
                    ((void (*)(char *, uint64_t *, int **))v718)(v634, v704, v630);
                    ((void (*)(char *, char *, uint64_t *, char *))v719)(v627, v633, v635, v711);
                    uint64_t v636 = v722;
                    ((void (*)(char *, uint64_t *))v722)(v633, v635);
                    ((void (*)(char *, uint64_t *))v636)(v627, v635);
                    char v637 = (*(uint64_t (**)(char *, int **, uint64_t *, uint64_t))(v629 + 40))(v628, v610, v635, v629);
                    ((void (*)(int **, uint64_t *))v636)(v610, v635);
                    ((void (*)(char *, uint64_t *))v636)(v628, v635);
                    uint64_t result = 0;
                    if (v637)
                    {
                      float *v703 = v5;
                      return result;
                    }
                    goto LABEL_279;
                  }
                  __break(1u);
                  goto LABEL_276;
                }
                *(_DWORD *)v703 = v604;
                return 1;
              }
              char v556 = *(void (**)(void))(v710 + 16);
              uint64_t v557 = v670;
              v556();
              LODWORD(v725) = -1;
              char v558 = ((uint64_t (*)(uint64_t *, char *))v545)(v271, v554);
              uint64_t v559 = v555(v271, v554);
              if (v558)
              {
                v562 = v716;
                if (v559 <= 32)
                {
                  uint64_t v563 = v714;
                  v564 = v704;
                  unint64_t v565 = v709;
                  uint64_t v566 = swift_getAssociatedConformanceWitness((uint64_t)v714, (uint64_t)v704, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v567 = v708;
                  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v566 + 8))(&qword_18162B0B8, 256, v565, v566);
                  ((void (*)(char *, uint64_t *, int **))v702)(v567, v564, v563);
                  char v568 = v711;
                  LOBYTE(v563) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v711 + 4)
                                                                                                  + 8)
                                                                                      + 40))(v557, v562, v564);
                  v569 = v562;
                  v570 = v722;
                  ((void (*)(int **, uint64_t *))v722)(v569, v564);
                  unsigned int v571 = v725;
                  uint64_t v572 = v660;
                  ((void (*)(char *, char *, uint64_t *))v556)(v660, v557, v564);
                  if (v563)
                  {
                    unsigned int v573 = (*((uint64_t (**)(uint64_t *, char *))v568 + 15))(v564, v568);
                    ((void (*)(char *, uint64_t *))v570)(v572, v564);
                    if (v571 < v573) {
                      goto LABEL_234;
                    }
                  }
                  else
                  {
                    ((void (*)(char *, uint64_t *))v570)(v572, v564);
                  }
                  goto LABEL_243;
                }
                goto LABEL_226;
              }
              v562 = v716;
              if (v559 > 32)
              {
LABEL_226:
                v579 = v711;
                uint64_t v580 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v711 + 12);
                unint64_t v581 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v559, v560, v561);
                v564 = v704;
                v580(&v725, &type metadata for UInt32, v581, v704, v579);
                char v582 = (*(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v579 + 4) + 8)
                                                                            + 16))(v562, v557, v564);
                v583 = v562;
                v570 = v722;
                ((void (*)(int **, uint64_t *))v722)(v583, v564);
                if (v582) {
                  goto LABEL_234;
                }
                goto LABEL_243;
              }
              v564 = v704;
              ((void (*)(int **, char *, uint64_t *))v556)(v716, v557, v704);
              unsigned int v596 = (*((uint64_t (**)(uint64_t *))v711 + 15))(v564);
              uint64_t v597 = v562;
              v570 = v722;
              ((void (*)(int **, uint64_t *))v722)(v597, v564);
              if (v725 >= v596)
              {
LABEL_243:
                ((void (*)(char *, uint64_t *))v570)(v557, v564);
                uint64_t v271 = v564;
                v554 = v711;
                v544 = v682;
                goto LABEL_244;
              }
LABEL_234:
              unint64_t v395 = 3455;
LABEL_235:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, v395, 0);
            }
          }
          __break(1u);
          do
          {
            __break(1u);
LABEL_156:
            LODWORD(v706) = 0;
            uint64_t v407 = v721;
            if ((v721 & 0x8000000000000000) == 0) {
              goto LABEL_168;
            }
LABEL_157:
            unint64_t v410 = v716;
            uint64_t v411 = ((uint64_t (*)(uint64_t, uint64_t))v719)(v723, v71);
          }
          while (__OFSUB__(0, v407));
          int64_t v725 = -v407;
          char v414 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 30);
          unint64_t v415 = lazy protocol witness table accessor for type Int and conformance Int(v411, v412, v413);
          v416 = v685;
          v414(v410, &v725, &type metadata for Int, v415, v271, v281);
          ((void (*)(int **, uint64_t *))v722)(v410, v271);
          int64_t v417 = (const char *)*((void *)v281 + 8);
          if (((uint64_t (*)(uint64_t *, char *))v417)(v271, v281))
          {
            v705 = v417;
            uint64_t v418 = v669;
            (*(void (**)(char *, char *, uint64_t *))(v710 + 16))(v669, v416, v271);
            v419 = v709;
            uint64_t v420 = swift_getAssociatedConformanceWitness((uint64_t)v67, (uint64_t)v271, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v421 = v708;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v420 + 8))(&qword_18162B0B8, 256, v419, v420);
            ((void (*)(char *, uint64_t *, int **))v67[3])(v421, v271, v67);
            LOBYTE(v421) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4) + 8)
                                                                                + 32))(v418, v410, v271);
            v422 = v722;
            ((void (*)(int **, uint64_t *))v722)(v410, v271);
            if ((v421 & 1) == 0) {
              goto LABEL_274;
            }
            ((void (*)(char *, uint64_t *))v422)(v418, v271);
            v416 = v685;
            int64_t v417 = v705;
          }
          char v423 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 16);
          uint64_t v424 = v416;
          if (v423(v271, v281) < 32) {
            goto LABEL_248;
          }
          uint64_t v425 = v668;
          v705 = *(const char **)(v710 + 16);
          ((void (*)(char *, char *, uint64_t *))v705)(v668, v424, v271);
          LODWORD(v725) = -1;
          char v426 = ((uint64_t (*)(uint64_t *, char *))v417)(v271, v281);
          uint64_t v427 = v423(v271, v281);
          if (v426)
          {
            uint64_t v430 = v716;
            v431 = v722;
            if (v427 <= 32)
            {
              v432 = v714;
              uint64_t v433 = v709;
              uint64_t v434 = swift_getAssociatedConformanceWitness((uint64_t)v714, (uint64_t)v271, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v435 = v708;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v434 + 8))(&qword_18162B0B8, 256, v433, v434);
              ((void (*)(char *, uint64_t *, int **))v432[3])(v435, v271, v432);
              LOBYTE(v432) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4)
                                                                                              + 8)
                                                                                  + 40))(v425, v430, v271);
              ((void (*)(int **, uint64_t *))v431)(v430, v271);
              unsigned int v436 = v725;
              char v437 = v659;
              ((void (*)(char *, char *, uint64_t *))v705)(v659, v425, v271);
              if (v432)
              {
                unsigned int v438 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
                ((void (*)(char *, uint64_t *))v431)(v437, v271);
                if (v436 < v438) {
                  goto LABEL_234;
                }
              }
              else
              {
                ((void (*)(char *, uint64_t *))v431)(v437, v271);
              }
              goto LABEL_247;
            }
          }
          else
          {
            uint64_t v430 = v716;
            v431 = v722;
            if (v427 <= 32)
            {
              ((void (*)(int **, char *, uint64_t *))v705)(v716, v425, v271);
              unsigned int v472 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
              ((void (*)(int **, uint64_t *))v431)(v430, v271);
              if (v725 < v472) {
                goto LABEL_234;
              }
LABEL_247:
              ((void (*)(char *, uint64_t *))v431)(v425, v271);
              uint64_t v424 = v685;
LABEL_248:
              int v476 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
              ((void (*)(char *, uint64_t *))v722)(v424, v271);
              uint64_t v477 = v723;
              uint64_t v479 = v712;
              unint64_t v478 = (uint64_t (**)(void))v713;
              uint64_t v480 = v718;
LABEL_249:
              uint64_t v599 = v706 | v476;
              unsigned __int8 v601 = 0;
              uint64_t v600 = (uint64_t)v707;
              goto LABEL_250;
            }
          }
          uint64_t v468 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 12);
          unint64_t v469 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v427, v428, v429);
          v468(&v725, &type metadata for UInt32, v469, v271, v281);
          char v470 = (*(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v281 + 4) + 8) + 16))(v430, v425, v271);
          ((void (*)(int **, uint64_t *))v431)(v430, v271);
          if (v470) {
            goto LABEL_234;
          }
          goto LABEL_247;
        }
        v282 = (int **)*((void *)v279 + 2);
        uint64_t v717 = (uint64_t)(v279 + 4);
        v718 = v282;
        ((void (*)(char *, uint64_t *, uint64_t))v282)(v679, v271, v71);
        int64_t v725 = -1;
        char v283 = ((uint64_t (*)(uint64_t, int **))v272)(v71, v67);
        uint64_t v284 = ((uint64_t (*)(uint64_t, int **))v280)(v71, v67);
        if (v283)
        {
          uint64_t v281 = v722;
          if (v284 <= 64)
          {
            uint64_t v287 = v707;
            uint64_t v288 = v705;
            uint64_t v289 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v290 = v706;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v289 + 8))(&qword_18162B0B8, 256, v288, v289);
            unint64_t v291 = v721;
            ((void (*)(char *, uint64_t, int **))v287[3])(v290, v71, v287);
            unint64_t v292 = v679;
            LOBYTE(v287) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 40))(v679, v291, v71);
            ((void (*)(unint64_t, uint64_t))v141)(v291, v71);
            unint64_t v293 = v725;
            v294 = v661;
            ((void (*)(char *, char *, uint64_t))v718)(v661, v292, v71);
            if ((v287 & 1) == 0)
            {
              ((void (*)(char *, uint64_t))v141)(v294, v71);
              uint64_t v271 = v686;
LABEL_198:
              ((void (*)(char *, uint64_t))v141)(v292, v71);
              goto LABEL_199;
            }
            unint64_t v295 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
            ((void (*)(char *, uint64_t))v141)(v294, v71);
            BOOL v296 = v293 >= v295;
LABEL_131:
            uint64_t v271 = v686;
            if (!v296) {
              goto LABEL_234;
            }
            goto LABEL_198;
          }
        }
        else
        {
          uint64_t v281 = v722;
          if (v284 <= 64)
          {
            unint64_t v366 = v721;
            unint64_t v292 = v679;
            ((void (*)(unint64_t, char *, uint64_t))v718)(v721, v679, v71);
            unint64_t v367 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
            ((void (*)(unint64_t, uint64_t))v141)(v366, v71);
            BOOL v296 = v725 >= v367;
            goto LABEL_131;
          }
        }
        uint64_t v348 = v67[12];
        unint64_t v349 = lazy protocol witness table accessor for type UInt and conformance UInt(v284, v285, v286);
        v350 = v141;
        unint64_t v351 = v721;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v348)(&v725, &type metadata for UInt, v349, v71, v67);
        unint64_t v292 = v679;
        char v352 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v351, v679, v71);
        unint64_t v353 = v351;
        uint64_t v141 = v350;
        ((void (*)(unint64_t, uint64_t))v350)(v353, v71);
        uint64_t v271 = v686;
        if (v352) {
          goto LABEL_234;
        }
        goto LABEL_198;
      }
      int64_t v725 = 0;
      uint64_t v242 = v67[12];
      unint64_t v243 = lazy protocol witness table accessor for type Int and conformance Int(v239, v240, v241);
      unint64_t v244 = v721;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v242)(&v725, &type metadata for Int, v243, v71, v67);
      char v245 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v203, v244, v71);
      uint64_t v236 = v138 + 2;
      ((void (*)(unint64_t, uint64_t))v141)(v244, v71);
      char v132 = (void (*)(char *, uint64_t))v718;
      if (v245)
      {
LABEL_63:
        uint64_t v248 = (unint64_t)v236 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        goto LABEL_64;
      }
      while (1)
      {
LABEL_54:
        uint64_t v248 = (uint64_t)v696;
        (*((void (**)(char *, char *, uint64_t))v138 + 4))(v696, v203, v71);
        unint64_t v249 = v715;
        if (((uint64_t (*)(uint64_t, int **))v715)(v71, v67))
        {
          v702 = (int *)v202;
          uint64_t v250 = v677;
          (*((void (**)(char *, uint64_t, uint64_t))v138 + 2))(v677, v248, v71);
          uint64_t v251 = v707;
          uint64_t v252 = v705;
          uint64_t v253 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v254 = v706;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v253 + 8))(&qword_18162B0B8, 256, v252, v253);
          unint64_t v255 = v721;
          ((void (*)(char *, uint64_t, int **))v251[3])(v254, v71, v251);
          LOBYTE(v251) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 32))(v250, v255, v71);
          ((void (*)(unint64_t, uint64_t))v141)(v255, v71);
          if ((v251 & 1) == 0) {
            goto LABEL_274;
          }
          ((void (*)(char *, uint64_t))v141)(v250, v71);
          char v132 = (void (*)(char *, uint64_t))v718;
          unint64_t v249 = v715;
          uint64_t v248 = (uint64_t)v696;
          char v202 = (int **)v702;
        }
        uint64_t v138 = v719;
        if (((uint64_t (*)(uint64_t, int **))v719)(v71, v67) < 64) {
          goto LABEL_120;
        }
        v722 = *(char **)(v717 + 16);
        ((void (*)(char *, uint64_t, uint64_t))v722)(v683, v248, v71);
        int64_t v725 = -1;
        char v256 = ((uint64_t (*)(uint64_t, int **))v249)(v71, v67);
        uint64_t v257 = ((uint64_t (*)(uint64_t, int **))v138)(v71, v67);
        v699 = v141;
        if ((v256 & 1) == 0) {
          break;
        }
        if (v257 > 64) {
          goto LABEL_75;
        }
        uint64_t v260 = v707;
        unint64_t v261 = v705;
        uint64_t v262 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v263 = v706;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v262 + 8))(&qword_18162B0B8, 256, v261, v262);
        unint64_t v264 = v721;
        ((void (*)(char *, uint64_t, int **))v260[3])(v263, v71, v260);
        uint64_t v138 = (int *)v683;
        LOBYTE(v26_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 40))(v683, v264, v71);
        char v202 = (int **)(v717 + 8);
        unint64_t v265 = v264;
        char v132 = (void (*)(char *, uint64_t))v699;
        ((void (*)(unint64_t, uint64_t))v699)(v265, v71);
        unint64_t v266 = v725;
        char v267 = v663;
        ((void (*)(char *, int *, uint64_t))v722)(v663, v138, v71);
        if (v260)
        {
          unint64_t v268 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
          v132(v267, v71);
          uint64_t v248 = (uint64_t)v696;
          if (v266 < v268) {
            goto LABEL_234;
          }
        }
        else
        {
          v132(v267, v71);
          uint64_t v248 = (uint64_t)v696;
        }
LABEL_119:
        v356 = v699;
        ((void (*)(int *, uint64_t))v699)(v138, v71);
        uint64_t v141 = v356;
LABEL_120:
        unint64_t v357 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        ((void (*)(uint64_t, uint64_t))v141)(v248, v71);
        v358 = (char *)(v357 + 127);
        if (v357 < 0xFFFFFFFFFFFFFF81) {
          goto LABEL_200;
        }
        __break(1u);
LABEL_122:
        uint64_t v359 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        ((void (*)(void, uint64_t))v141)(v132, v71);
        char v132 = (void (*)(char *, uint64_t))v718;
        char v203 = v722;
        if (v359 < 0) {
          goto LABEL_64;
        }
      }
      if (v257 <= 64)
      {
        unint64_t v354 = v721;
        uint64_t v138 = (int *)v683;
        ((void (*)(unint64_t, char *, uint64_t))v722)(v721, v683, v71);
        unint64_t v355 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        ((void (*)(unint64_t, uint64_t))v699)(v354, v71);
        uint64_t v248 = (uint64_t)v696;
        if (v725 < v355) {
          goto LABEL_234;
        }
        goto LABEL_119;
      }
LABEL_75:
      unint64_t v302 = v67[12];
      unint64_t v303 = lazy protocol witness table accessor for type UInt and conformance UInt(v257, v258, v259);
      char v132 = (void (*)(char *, uint64_t))v721;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v302)(&v725, &type metadata for UInt, v303, v71, v67);
      uint64_t v138 = (int *)v683;
      char v304 = (*(uint64_t (**)(void (*)(char *, uint64_t), char *, uint64_t))(*((void *)v67[4] + 1)
                                                                                              + 16))(v132, v683, v71);
      ((void (*)(void, uint64_t))v699)(v132, v71);
      uint64_t v248 = (uint64_t)v696;
      if (v304) {
        goto LABEL_234;
      }
      goto LABEL_119;
    }
    unint64_t v212 = v721;
    (*((void (**)(unint64_t, char *, uint64_t))v138 + 2))(v721, v203, v71);
    uint64_t v213 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
    ((void (*)(unint64_t, uint64_t))v141)(v212, v71);
    if (v725 < v213) {
      goto LABEL_40;
    }
    goto LABEL_43;
  }
LABEL_13:
  uint64_t v155 = v131;
  uint64_t v156 = v707;
  uint64_t v157 = v705;
  uint64_t v158 = swift_getAssociatedConformanceWitness((uint64_t)v707, v71, (uint64_t)v705, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v159 = *(char **)(v158 + 8);
  uint64_t v160 = v706;
  v696 = (char *)v158;
  v695 = (char *)(v158 + 8);
  v694 = v159;
  ((void (*)(uint64_t *, uint64_t, const char *))v159)(&qword_18162B0C0, 512, v157);
  char v161 = v156[3];
  unint64_t v162 = v721;
  v687 = (char *)(v156 + 3);
  uint64_t v686 = (uint64_t *)v161;
  ((void (*)(char *, uint64_t, int **))v161)(v160, v71, v156);
  uint64_t v163 = *(char **)(*((void *)v699 + 1) + 24);
  uint64_t v684 = (char *)*((void *)v699 + 1);
  uint64_t v683 = v163;
  ((void (*)(char *, unint64_t, uint64_t))v163)(v722, v162, v71);
  ((void (*)(unint64_t, uint64_t))v141)(v162, v71);
  char v164 = ((uint64_t (*)(uint64_t, int **))v155)(v71, v67);
  v699 = v141;
  if ((v164 & 1) == 0)
  {
    char v174 = ((uint64_t (*)(uint64_t, int **))v155)(v71, v67);
    uint64_t v165 = v719;
    uint64_t v175 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
    if (v174)
    {
      unint64_t v170 = v698;
      if (v175 > 64)
      {
        int64_t v725 = -149;
        unint64_t v178 = v67[12];
        unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v175, v176, v177);
        v719 = v165;
        unint64_t v180 = v721;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v178)(&v725, &type metadata for Int, v179, v71, v67);
        char v181 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v124, v180, v71);
        unint64_t v182 = v180;
        uint64_t v165 = v719;
        uint64_t v141 = v699;
        ((void (*)(unint64_t, uint64_t))v699)(v182, v71);
        ((void (*)(char *, uint64_t))v141)(v124, v71);
        if (v181) {
          goto LABEL_81;
        }
        goto LABEL_83;
      }
      char v297 = v706;
      ((void (*)(uint64_t *, uint64_t))v694)(&qword_18162B0B8, 256);
      unint64_t v298 = v721;
      ((void (*)(char *, uint64_t, int **))v686)(v297, v71, v707);
      char v299 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v124, v298, v71);
      uint64_t v141 = v699;
      ((void (*)(unint64_t, uint64_t))v699)(v298, v71);
      uint64_t v300 = v674;
      (*(void (**)(char *, char *, uint64_t))(v717 + 32))(v674, v124, v71);
      if (v299)
      {
        ((void (*)(char *, uint64_t))v141)(v300, v71);
        goto LABEL_81;
      }
      uint64_t v197 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      ((void (*)(char *, uint64_t))v141)(v300, v71);
    }
    else
    {
      unint64_t v170 = v698;
      if (v175 >= 64)
      {
        v301 = v673;
        (*(void (**)(char *, char *, uint64_t))(v717 + 32))(v673, v124, v71);
        uint64_t v141 = v699;
        ((void (*)(char *, uint64_t))v699)(v301, v71);
        goto LABEL_83;
      }
      uint64_t v197 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      uint64_t v141 = v699;
      ((void (*)(char *, uint64_t))v699)(v124, v71);
    }
    if (v197 >= -149) {
      goto LABEL_83;
    }
    goto LABEL_81;
  }
  uint64_t v165 = v719;
  uint64_t v166 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
  if (v166 < 64)
  {
    uint64_t v169 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
    ((void (*)(char *, uint64_t))v141)(v124, v71);
    unint64_t v170 = v698;
    if (v169 > -150) {
      goto LABEL_83;
    }
LABEL_81:
    ((void (*)(char *, uint64_t))v141)(v722, v71);
    if (((*((uint64_t (**)(void))v713 + 21))(v723) & 1) == 0)
    {
      uint64_t result = 0;
      float *v703 = 0.0;
      return result;
    }
    uint64_t result = 0;
    int v215 = 0x80000000;
    goto LABEL_91;
  }
  int64_t v725 = -149;
  BOOL v191 = v67[12];
  unint64_t v192 = lazy protocol witness table accessor for type Int and conformance Int(v166, v167, v168);
  char v193 = (char *)v165;
  unint64_t v194 = v721;
  ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v191)(&v725, &type metadata for Int, v192, v71, v67);
  uint64_t v141 = v699;
  char v195 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v124, v194, v71);
  unint64_t v196 = v194;
  uint64_t v165 = (int *)v193;
  ((void (*)(unint64_t, uint64_t))v141)(v196, v71);
  ((void (*)(char *, uint64_t))v141)(v124, v71);
  unint64_t v170 = v698;
  if (v195) {
    goto LABEL_81;
  }
LABEL_83:
  uint64_t v310 = v706;
  ((void (*)(uint64_t *, uint64_t))v694)(&qword_18162B0C0, 512);
  unint64_t v311 = v721;
  ((void (*)(char *, uint64_t, int **))v686)(v310, v71, v707);
  ((void (*)(char *, unint64_t, uint64_t, char *))v683)(v722, v311, v71, v684);
  ((void (*)(unint64_t, uint64_t))v141)(v311, v71);
  uint64_t v312 = v715;
  char v313 = ((uint64_t (*)(uint64_t, int **))v715)(v71, v67);
  v719 = v165;
  if (v313)
  {
    uint64_t v314 = ((uint64_t (*)(uint64_t, int **))v165)(v71, v67);
    uint64_t v317 = v717;
    if (v314 < 64) {
      goto LABEL_94;
    }
LABEL_88:
    int64_t v725 = -149;
    uint64_t v319 = v67[12];
    unint64_t v320 = lazy protocol witness table accessor for type Int and conformance Int(v314, v315, v316);
    unint64_t v321 = v721;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v319)(&v725, &type metadata for Int, v320, v71, v67);
    char v322 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[2] + 1) + 8))(v170, v321, v71);
    ((void (*)(unint64_t, uint64_t))v141)(v321, v71);
    ((void (*)(char *, uint64_t))v141)(v170, v71);
    if (v322) {
      goto LABEL_96;
    }
    goto LABEL_106;
  }
  char v318 = ((uint64_t (*)(uint64_t, int **))v312)(v71, v67);
  uint64_t v314 = ((uint64_t (*)(uint64_t, int **))v165)(v71, v67);
  uint64_t v317 = v717;
  if ((v318 & 1) == 0)
  {
    if (v314 < 64)
    {
LABEL_94:
      uint64_t v323 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      uint64_t v324 = v170;
      goto LABEL_95;
    }
    v332 = v665;
    (*(void (**)(char *, char *, uint64_t))(v717 + 32))(v665, v170, v71);
    goto LABEL_105;
  }
  if (v314 > 64) {
    goto LABEL_88;
  }
  uint64_t v330 = v706;
  ((void (*)(uint64_t *, uint64_t))v694)(&qword_18162B0B8, 256);
  unint64_t v331 = v721;
  ((void (*)(char *, uint64_t, int **))v686)(v330, v71, v707);
  LOBYTE(v33_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 32))(v170, v331, v71);
  ((void (*)(unint64_t, uint64_t))v141)(v331, v71);
  v332 = v666;
  (*(void (**)(char *, char *, uint64_t))(v317 + 32))(v666, v170, v71);
  if ((v330 & 1) == 0)
  {
LABEL_105:
    ((void (*)(char *, uint64_t))v141)(v332, v71);
    goto LABEL_106;
  }
  uint64_t v323 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
  uint64_t v324 = v332;
LABEL_95:
  ((void (*)(char *, uint64_t))v141)(v324, v71);
  if (v323 == -149)
  {
LABEL_96:
    ((void (*)(char *, uint64_t))v141)(v722, v71);
    uint64_t v325 = v723;
    uint64_t v326 = (*(uint64_t (**)(uint64_t))(v712 + 136))(v723);
    char v327 = (*((uint64_t (**)(void))v713 + 21))(v325);
    uint64_t result = 0;
    float v328 = -0.0;
    if ((v327 & 1) == 0) {
      float v328 = 0.0;
    }
    LODWORD(v329) = -2147483647;
    if ((v327 & 1) == 0) {
      float v329 = COERCE_FLOAT(1);
    }
    if (v326) {
      float v328 = v329;
    }
    goto LABEL_282;
  }
LABEL_106:
  uint64_t v333 = v702;
  (*(void (**)(int *, char *, uint64_t))(v317 + 32))(v702, v722, v71);
  char v334 = ((uint64_t (*)(uint64_t, int **))v715)(v71, v67);
  uint64_t v335 = v690;
  v722 = *(char **)(v317 + 16);
  ((void (*)(char *, int *, uint64_t))v722)(v690, v333, v71);
  if ((v334 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v141)(v335, v71);
    uint64_t v337 = v689;
    goto LABEL_137;
  }
  uint64_t v336 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
  ((void (*)(char *, uint64_t))v141)(v335, v71);
  uint64_t v337 = v689;
  if (v336 <= 64) {
    goto LABEL_137;
  }
  uint64_t v657 = v154;
  uint64_t v338 = v678;
  ((void (*)(char *, int *, uint64_t))v722)(v678, v702, v71);
  int64_t v725 = 0x8000000000000000;
  v339 = v715;
  if (((uint64_t (*)(uint64_t, int **))v715)(v71, v67))
  {
    uint64_t v340 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
    if (v340 < 64)
    {
      uint64_t v343 = v338;
      unint64_t v344 = v721;
      ((void (*)(unint64_t, char *, uint64_t))v722)(v721, v338, v71);
      uint64_t v345 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      v346 = v699;
      ((void (*)(unint64_t, uint64_t))v699)(v344, v71);
      goto LABEL_128;
    }
    goto LABEL_124;
  }
  char v347 = ((uint64_t (*)(uint64_t, int **))v339)(v71, v67);
  uint64_t v340 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
  if (v347)
  {
    if (v340 > 64)
    {
LABEL_124:
      uint64_t v360 = v67[12];
      unint64_t v361 = lazy protocol witness table accessor for type Int and conformance Int(v340, v341, v342);
      unint64_t v362 = v721;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v360)(&v725, &type metadata for Int, v361, v71, v67);
      uint64_t v343 = v678;
      char v363 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v678, v362, v71);
      unint64_t v364 = v362;
      v346 = v699;
      ((void (*)(unint64_t, uint64_t))v699)(v364, v71);
      if (v363) {
        goto LABEL_288;
      }
      goto LABEL_136;
    }
    uint64_t v368 = v706;
    ((void (*)(uint64_t *, uint64_t))v694)(&qword_18162B0B8, 256);
    unint64_t v369 = v721;
    ((void (*)(char *, uint64_t, int **))v686)(v368, v71, v707);
    unint64_t v370 = v678;
    char v371 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v678, v369, v71);
    v346 = v699;
    ((void (*)(unint64_t, uint64_t))v699)(v369, v71);
    char v372 = v658;
    ((void (*)(char *, char *, uint64_t))v722)(v658, v370, v71);
    if (v371)
    {
      ((void (*)(char *, uint64_t))v346)(v372, v71);
      goto LABEL_288;
    }
    int64_t v373 = v725;
    uint64_t v374 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
    ((void (*)(char *, uint64_t))v346)(v372, v71);
    BOOL v200 = v374 < v373;
    uint64_t v343 = v678;
    if (v200) {
      goto LABEL_288;
    }
  }
  else
  {
    uint64_t v343 = v338;
    v346 = v699;
    if (v340 < 64)
    {
      unint64_t v365 = v721;
      ((void (*)(unint64_t, char *, uint64_t))v722)(v721, v338, v71);
      uint64_t v345 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      ((void (*)(unint64_t, uint64_t))v346)(v365, v71);
LABEL_128:
      if (v345 < v725) {
LABEL_288:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    }
  }
LABEL_136:
  ((void (*)(char *, uint64_t))v346)(v343, v71);
LABEL_137:
  unint64_t v375 = v337;
  v376 = v702;
  v377 = v719;
  uint64_t v378 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
  v379 = v688;
  ((void (*)(char *, int *, uint64_t))v722)(v688, v376, v71);
  if (v378 >= 65)
  {
    ((void (*)(char *, uint64_t))v699)(v379, v71);
    v380 = v715;
    goto LABEL_139;
  }
  uint64_t v390 = ((uint64_t (*)(uint64_t, int **))v377)(v71, v67);
  unint64_t v391 = v699;
  ((void (*)(char *, uint64_t))v699)(v379, v71);
  BOOL v392 = v390 == 64;
  v380 = v715;
  if (v392 && (((uint64_t (*)(uint64_t, int **))v715)(v71, v67) & 1) == 0)
  {
LABEL_139:
    uint64_t v381 = v375;
    ((void (*)(char *, int *, uint64_t))v722)(v375, v702, v71);
    int64_t v725 = 0x7FFFFFFFFFFFFFFFLL;
    char v382 = ((uint64_t (*)(uint64_t, int **))v380)(v71, v67);
    uint64_t v383 = ((uint64_t (*)(uint64_t, int **))v719)(v71, v67);
    if (v382)
    {
      unint64_t v386 = v699;
      if (v383 > 64)
      {
        v387 = v67[12];
        unint64_t v388 = lazy protocol witness table accessor for type Int and conformance Int(v383, v384, v385);
        v389 = &v725;
        goto LABEL_150;
      }
    }
    else
    {
      unint64_t v386 = v699;
      if (v383 >= 64)
      {
        uint64_t v724 = 0x7FFFFFFFFFFFFFFFLL;
        v387 = v67[12];
        unint64_t v388 = lazy protocol witness table accessor for type Int and conformance Int(v383, v384, v385);
        v389 = &v724;
LABEL_150:
        unint64_t v396 = v721;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v387)(v389, &type metadata for Int, v388, v71, v67);
        char v397 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v396, v381, v71);
        ((void (*)(unint64_t, uint64_t))v386)(v396, v71);
        if ((v397 & 1) == 0) {
          goto LABEL_151;
        }
        goto LABEL_149;
      }
    }
    unint64_t v393 = v721;
    ((void (*)(unint64_t, char *, uint64_t))v722)(v721, v375, v71);
    uint64_t v394 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
    ((void (*)(unint64_t, uint64_t))v386)(v393, v71);
    if (v725 >= v394)
    {
LABEL_151:
      ((void (*)(char *, uint64_t))v386)(v381, v71);
      unint64_t v391 = v386;
      goto LABEL_152;
    }
LABEL_149:
    unint64_t v395 = 3687;
    goto LABEL_235;
  }
LABEL_152:
  v398 = v702;
  uint64_t v399 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
  uint64_t result = ((uint64_t (*)(int *, uint64_t))v391)(v398, v71);
  uint64_t v400 = v399 + 149;
  if (!__OFADD__(v399, 149))
  {
    uint64_t v71 = v712;
    v401 = *(int ***)(v712 + 136);
    uint64_t v402 = v723;
    uint64_t v717 = v712 + 136;
    v718 = v401;
    uint64_t v403 = ((uint64_t (*)(uint64_t, uint64_t))v401)(v723, v712);
    v404 = v716;
    v719 = *(int **)(v71 + 120);
    ((void (*)(uint64_t, uint64_t))v719)(v402, v71);
    uint64_t v281 = v711;
    uint64_t v271 = v704;
    uint64_t v405 = (*((uint64_t (**)(uint64_t *, char *))v711 + 18))(v704, v711);
    v406 = *(char **)(v710 + 8);
    v715 = (int *)(v710 + 8);
    v722 = v406;
    ((void (*)(int **, uint64_t *))v406)(v404, v271);
    uint64_t v407 = v400 - (v403 + v405);
    char v408 = (*((uint64_t (**)(void))v713 + 46))(v402);
    unint64_t v721 = v407;
    v707 = (int **)v400;
    if (v408)
    {
      uint64_t v67 = v714;
      unint64_t v409 = (unint64_t)v697;
      if (v400 < -32 || v400 > 32 || v400 < 0 || (unint64_t)v400 > 0x1F) {
        goto LABEL_156;
      }
      LODWORD(v706) = 1 << v400;
      uint64_t v407 = v721;
      if ((v721 & 0x8000000000000000) != 0) {
        goto LABEL_157;
      }
    }
    else
    {
      LODWORD(v706) = 0;
      uint64_t v67 = v714;
      unint64_t v409 = (unint64_t)v697;
      if (v407 < 0) {
        goto LABEL_157;
      }
    }
LABEL_168:
    ((void (*)(uint64_t, uint64_t))v719)(v723, v71);
    v439 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 8);
    if (v439(v271, v281))
    {
      uint64_t v440 = v676;
      (*(void (**)(char *, unint64_t, uint64_t *))(v710 + 16))(v676, v409, v271);
      uint64_t v441 = v709;
      uint64_t v442 = swift_getAssociatedConformanceWitness((uint64_t)v67, (uint64_t)v271, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v443 = v708;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v442 + 8))(&qword_18162B0B8, 256, v441, v442);
      uint64_t v444 = v716;
      ((void (*)(char *, uint64_t *, int **))v67[3])(v443, v271, v67);
      LOBYTE(v443) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4) + 8)
                                                                          + 32))(v440, v444, v271);
      uint64_t v445 = v722;
      ((void (*)(int **, uint64_t *))v722)(v444, v271);
      if ((v443 & 1) == 0) {
        goto LABEL_274;
      }
      ((void (*)(char *, uint64_t *))v445)(v440, v271);
      unint64_t v409 = (unint64_t)v697;
    }
    v446 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 16);
    if (v446(v271, v281) < 32) {
      goto LABEL_193;
    }
    uint64_t v447 = v675;
    v705 = *(const char **)(v710 + 16);
    ((void (*)(char *, unint64_t, uint64_t *))v705)(v675, v409, v271);
    LODWORD(v725) = -1;
    char v448 = v439(v271, v281);
    uint64_t v449 = v446(v271, v281);
    if (v448)
    {
      uint64_t v452 = v716;
      uint64_t v453 = v722;
      if (v449 <= 32)
      {
        uint64_t v454 = v714;
        v455 = v704;
        unint64_t v456 = v709;
        uint64_t v457 = swift_getAssociatedConformanceWitness((uint64_t)v714, (uint64_t)v704, (uint64_t)v709, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v458 = v708;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v457 + 8))(&qword_18162B0B8, 256, v456, v457);
        ((void (*)(char *, uint64_t *, int **))v454[3])(v458, v455, v454);
        v459 = v711;
        LOBYTE(v454) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v711 + 4) + 8)
                                                                            + 40))(v447, v452, v455);
        ((void (*)(int **, uint64_t *))v453)(v452, v455);
        unsigned int v460 = v725;
        v461 = v662;
        ((void (*)(char *, char *, uint64_t *))v705)(v662, v447, v455);
        if ((v454 & 1) == 0)
        {
          ((void (*)(char *, uint64_t *))v453)(v461, v455);
LABEL_192:
          ((void (*)(char *, uint64_t *))v453)(v447, v455);
          uint64_t v271 = v455;
          uint64_t v281 = v711;
          unint64_t v409 = (unint64_t)v697;
LABEL_193:
          int v473 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
          unint64_t v474 = v409;
          int v475 = v473;
          ((void (*)(unint64_t, uint64_t *))v722)(v474, v271);
          if (v721 < 0x20) {
            int v476 = v475 << v721;
          }
          else {
            int v476 = 0;
          }
          uint64_t v477 = v723;
          uint64_t v479 = v712;
          unint64_t v478 = (uint64_t (**)(void))v713;
          uint64_t v480 = v718;
          goto LABEL_249;
        }
        unsigned int v462 = (*((uint64_t (**)(uint64_t *, char *))v459 + 15))(v455, v459);
        ((void (*)(char *, uint64_t *))v453)(v461, v455);
        BOOL v463 = v460 >= v462;
LABEL_187:
        if (!v463) {
          goto LABEL_234;
        }
        goto LABEL_192;
      }
    }
    else
    {
      uint64_t v452 = v716;
      uint64_t v453 = v722;
      if (v449 <= 32)
      {
        v455 = v704;
        ((void (*)(int **, char *, uint64_t *))v705)(v716, v447, v704);
        unsigned int v471 = (*((uint64_t (**)(uint64_t *))v711 + 15))(v455);
        ((void (*)(int **, uint64_t *))v453)(v452, v455);
        BOOL v463 = v725 >= v471;
        goto LABEL_187;
      }
    }
    v464 = v711;
    v465 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v711 + 12);
    unint64_t v466 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v449, v450, v451);
    v455 = v704;
    v465(&v725, &type metadata for UInt32, v466, v704, v464);
    char v467 = (*(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v464 + 4) + 8) + 16))(v452, v447, v455);
    ((void (*)(int **, uint64_t *))v453)(v452, v455);
    if (v467) {
      goto LABEL_234;
    }
    goto LABEL_192;
  }
  __break(1u);
LABEL_279:
  if (__clz(__rbit32(LODWORD(v5) & 0x7FFFFF)) >= __clz(__rbit32(v699))) {
    float v328 = v5;
  }
  else {
    float v328 = v4;
  }
LABEL_282:
  float *v703 = v328;
  return result;
}

uint64_t specialized static BinaryFloatingPoint._convert<A>(from:)(short float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v705 = a1;
  uint64_t v720 = *(int ***)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v717 = (int *)((char *)&v659 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v9);
  uint64_t v685 = (char *)&v659 - v11;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, v12, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v713 = *(char **)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8);
  uint64_t v693 = *((void *)v713 + 3);
  v716 = *(int ***)(v693 + 16);
  v711 = swift_getAssociatedTypeWitness(0, v716, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v711);
  uint64_t v710 = (char *)&v659 - v15;
  v706 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v712 = *(v706 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v706);
  v681 = (char *)&v659 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v721 = (int *)((char *)&v659 - v19);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v715 = (uint64_t (**)(void))((char *)&v659 - v21);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  unint64_t v666 = (char *)&v659 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v686 = (char *)&v659 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v697 = (char *)&v659 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v689 = (char *)&v659 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v662 = (char *)&v659 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v672 = (char *)&v659 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  v673 = (char *)&v659 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v684 = (char *)&v659 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v696 = (void (*)(uint64_t *, uint64_t))((char *)&v659 - v39);
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  v695 = (char *)&v659 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  v702 = (char *)&v659 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  v694 = (char *)&v659 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v703 = (char *)&v659 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  char v664 = (char *)&v659 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v677 = (char *)&v659 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  v678 = (char *)&v659 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  v699 = (char *)&v659 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  v661 = (char *)&v659 - v57;
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  v670 = (char *)&v659 - v59;
  uint64_t v60 = MEMORY[0x1F4188790](v58);
  v671 = (char *)&v659 - v61;
  uint64_t v62 = MEMORY[0x1F4188790](v60);
  v687 = (char *)&v659 - v63;
  MEMORY[0x1F4188790](v62);
  v718 = (int **)((char *)&v659 - v64);
  uint64_t v714 = a4;
  uint64_t v65 = *(void *)(a4 + 16);
  uint64_t v66 = swift_getAssociatedTypeWitness(255, (int **)v65, a3, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v65, a3, (uint64_t)v66, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  uint64_t v67 = *(int ***)(AssociatedConformanceWitness + 8);
  v701 = v67[3];
  v709 = (int **)*((void *)v701 + 2);
  v707 = swift_getAssociatedTypeWitness(0, v709, (uint64_t)v66, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v707);
  v708 = (char *)&v659 - v68;
  uint64_t v69 = (uint64_t)v66;
  uint64_t v70 = a3;
  uint64_t v71 = (uint64_t)swift_checkMetadataState(0, v69);
  uint64_t v719 = *(void *)(v71 - 8);
  uint64_t v72 = MEMORY[0x1F4188790](v71);
  uint64_t v74 = (char *)&v659 - ((v73 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v75 = MEMORY[0x1F4188790](v72);
  uint64_t v77 = (char *)&v659 - v76;
  uint64_t v78 = MEMORY[0x1F4188790](v75);
  uint64_t v683 = (char *)&v659 - v79;
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  uint64_t v669 = (char *)&v659 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  uint64_t v665 = (char *)&v659 - v83;
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  uint64_t v86 = (char *)&v659 - v85;
  uint64_t v87 = MEMORY[0x1F4188790](v84);
  v679 = (char *)&v659 - v88;
  uint64_t v89 = MEMORY[0x1F4188790](v87);
  v698 = (char *)&v659 - v90;
  uint64_t v91 = MEMORY[0x1F4188790](v89);
  v663 = (char *)&v659 - v92;
  uint64_t v93 = MEMORY[0x1F4188790](v91);
  uint64_t v95 = (char *)&v659 - v94;
  uint64_t v96 = MEMORY[0x1F4188790](v93);
  uint64_t v674 = (char *)&v659 - v97;
  uint64_t v98 = MEMORY[0x1F4188790](v96);
  v688 = (int *)((char *)&v659 - v99);
  uint64_t v100 = MEMORY[0x1F4188790](v98);
  v675 = (char *)&v659 - v101;
  uint64_t v102 = MEMORY[0x1F4188790](v100);
  v676 = (char *)&v659 - v103;
  uint64_t v104 = MEMORY[0x1F4188790](v102);
  uint64_t v667 = (char *)&v659 - v105;
  uint64_t v106 = MEMORY[0x1F4188790](v104);
  v668 = (char *)&v659 - v107;
  uint64_t v108 = MEMORY[0x1F4188790](v106);
  v660 = (char *)&v659 - v109;
  uint64_t v110 = MEMORY[0x1F4188790](v108);
  uint64_t v691 = (char *)&v659 - v111;
  uint64_t v112 = MEMORY[0x1F4188790](v110);
  v690 = (char *)&v659 - v113;
  uint64_t v114 = MEMORY[0x1F4188790](v112);
  v680 = (char *)&v659 - v115;
  uint64_t v116 = MEMORY[0x1F4188790](v114);
  v692 = (char *)&v659 - v117;
  uint64_t v118 = MEMORY[0x1F4188790](v116);
  v704 = (int *)((char *)&v659 - v119);
  uint64_t v120 = MEMORY[0x1F4188790](v118);
  v700 = (char *)&v659 - v121;
  uint64_t v122 = MEMORY[0x1F4188790](v120);
  uint64_t v124 = (char *)&v659 - v123;
  uint64_t v125 = MEMORY[0x1F4188790](v122);
  unint64_t v723 = (unint64_t)&v659 - v126;
  MEMORY[0x1F4188790](v125);
  uint64_t v724 = (char *)&v659 - v127;
  uint64_t v725 = v70;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 384))(v70, v65))
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v725, v65) & 1) == 0)
    {
      __int16 v639 = 0;
LABEL_279:
      *(_WORD *)v705 = v639;
      return 1;
    }
    __int16 v640 = 0x8000;
    goto LABEL_278;
  }
  char v128 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 376))(v725, v65);
  uint64_t v722 = a2;
  if (v128)
  {
    v681 = v95;
    uint64_t v685 = v86;
    char v129 = *(void (**)(uint64_t, uint64_t))(v65 + 176);
    uint64_t v130 = v724;
    v715 = (uint64_t (**)(void))v65;
    v129(v725, v65);
    int64_t v727 = -14;
    char v132 = (void (*)(char *, uint64_t))(v67 + 8);
    uint64_t v131 = v67[8];
    char v133 = ((uint64_t (*)(uint64_t, int **))v131)(v71, v67);
    uint64_t v720 = v67 + 8;
    uint64_t v717 = v131;
    if (v133)
    {
      unint64_t v721 = v67[16];
      uint64_t v134 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
      uint64_t v137 = v130;
      if (v134 < 64)
      {
        uint64_t v138 = (int *)v719;
        unint64_t v139 = v723;
        (*(void (**)(unint64_t, char *, uint64_t))(v719 + 16))(v723, v137, v71);
        uint64_t v140 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        uint64_t v142 = (uint64_t)(v138 + 2);
        uint64_t v141 = (int *)*((void *)v138 + 1);
        ((void (*)(unint64_t, uint64_t))v141)(v139, v71);
        if (v140 >= v727)
        {
LABEL_6:
          char v132 = (void (*)(char *, uint64_t))v720;
          goto LABEL_34;
        }
        goto LABEL_12;
      }
      unint64_t v151 = v67[12];
      unint64_t v152 = lazy protocol witness table accessor for type Int and conformance Int(v134, v135, v136);
      unint64_t v153 = v723;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v151)(&v727, &type metadata for Int, v152, v71, v67);
      char v150 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v130, v153, v71);
      uint64_t v138 = (int *)v719;
      uint64_t v142 = v719 + 8;
      uint64_t v141 = *(int **)(v719 + 8);
      ((void (*)(unint64_t, uint64_t))v141)(v153, v71);
LABEL_11:
      if ((v150 & 1) == 0) {
        goto LABEL_6;
      }
LABEL_12:
      uint64_t v154 = v142 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      goto LABEL_13;
    }
    char v143 = ((uint64_t (*)(uint64_t, int **))v131)(v71, v67);
    unint64_t v721 = v67[16];
    uint64_t v144 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
    if (v143)
    {
      if (v144 > 64)
      {
        unint64_t v147 = v67[12];
        unint64_t v148 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
        unint64_t v149 = v723;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v147)(&v727, &type metadata for Int, v148, v71, v67);
        char v150 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v724, v149, v71);
        uint64_t v138 = (int *)v719;
        uint64_t v142 = v719 + 8;
        uint64_t v141 = *(int **)(v719 + 8);
        ((void (*)(unint64_t, uint64_t))v141)(v149, v71);
        goto LABEL_11;
      }
      uint64_t v183 = v709;
      uint64_t v184 = v707;
      uint64_t v185 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v186 = v708;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v185 + 8))(&qword_18162B0B8, 256, v184, v185);
      unint64_t v187 = v723;
      ((void (*)(char *, uint64_t, int **))v183[3])(v186, v71, v183);
      uint64_t v188 = v724;
      LOBYTE(v184) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v724, v187, v71);
      uint64_t v189 = v719;
      char v190 = *(int **)(v719 + 8);
      uint64_t v659 = (v719 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      ((void (*)(unint64_t, uint64_t))v190)(v187, v71);
      (*(void (**)(char *, char *, uint64_t))(v189 + 16))(v77, v188, v71);
      if (v184)
      {
        ((void (*)(char *, uint64_t))v190)(v77, v71);
        uint64_t v141 = v190;
        uint64_t v131 = v717;
        uint64_t v154 = v659;
        goto LABEL_13;
      }
      int64_t v198 = v727;
      uint64_t v199 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
      ((void (*)(char *, uint64_t))v190)(v77, v71);
      BOOL v200 = v199 < v198;
      char v132 = (void (*)(char *, uint64_t))v720;
      uint64_t v141 = v190;
      uint64_t v138 = (int *)v719;
      uint64_t v131 = v717;
      uint64_t v154 = v659;
      if (v200)
      {
LABEL_13:
        uint64_t v155 = v131;
        uint64_t v156 = v709;
        uint64_t v157 = v707;
        uint64_t v158 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v159 = *(void (**)(uint64_t *, uint64_t))(v158 + 8);
        uint64_t v160 = v708;
        v698 = (char *)v158;
        v697 = (char *)(v158 + 8);
        v696 = v159;
        ((void (*)(uint64_t *, uint64_t, const char *))v159)(&qword_18162B0C0, 512, v157);
        char v161 = v156[3];
        unint64_t v162 = v723;
        v689 = (char *)(v156 + 3);
        v688 = v161;
        ((void (*)(char *, uint64_t, int **))v161)(v160, v71, v156);
        uint64_t v163 = *(char **)(*((void *)v701 + 1) + 24);
        uint64_t v686 = (char *)*((void *)v701 + 1);
        uint64_t v685 = v163;
        ((void (*)(char *, unint64_t, uint64_t))v163)(v724, v162, v71);
        ((void (*)(unint64_t, uint64_t))v141)(v162, v71);
        char v164 = ((uint64_t (*)(uint64_t, int **))v155)(v71, v67);
        v701 = v141;
        if (v164)
        {
          uint64_t v165 = v721;
          uint64_t v166 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
          if (v166 < 64)
          {
            uint64_t v169 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
            ((void (*)(char *, uint64_t))v141)(v124, v71);
            unint64_t v170 = v700;
            if (v169 > -25) {
              goto LABEL_83;
            }
LABEL_81:
            ((void (*)(char *, uint64_t))v141)(v724, v71);
            if ((v715[21](v725) & 1) == 0)
            {
              uint64_t result = 0;
              LOWORD(v31_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = 0;
LABEL_92:
              short float *v705 = v310;
              return result;
            }
            uint64_t result = 0;
            __int16 v215 = 0x8000;
LABEL_91:
            short float v310 = *(short float *)&v215;
            goto LABEL_92;
          }
          int64_t v727 = -24;
          BOOL v191 = v67[12];
          unint64_t v192 = lazy protocol witness table accessor for type Int and conformance Int(v166, v167, v168);
          char v193 = (char *)v165;
          unint64_t v194 = v723;
          ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v191)(&v727, &type metadata for Int, v192, v71, v67);
          uint64_t v141 = v701;
          char v195 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v124, v194, v71);
          unint64_t v196 = v194;
          uint64_t v165 = (int *)v193;
          ((void (*)(unint64_t, uint64_t))v141)(v196, v71);
          ((void (*)(char *, uint64_t))v141)(v124, v71);
          unint64_t v170 = v700;
          if (v195) {
            goto LABEL_81;
          }
LABEL_83:
          unint64_t v311 = v708;
          v696(&qword_18162B0C0, 512);
          unint64_t v312 = v723;
          ((void (*)(char *, uint64_t, int **))v688)(v311, v71, v709);
          ((void (*)(char *, unint64_t, uint64_t, char *))v685)(v724, v312, v71, v686);
          ((void (*)(unint64_t, uint64_t))v141)(v312, v71);
          char v313 = v717;
          char v314 = ((uint64_t (*)(uint64_t, int **))v717)(v71, v67);
          unint64_t v721 = v165;
          if (v314)
          {
            uint64_t v315 = ((uint64_t (*)(uint64_t, int **))v165)(v71, v67);
            uint64_t v318 = v719;
            if (v315 < 64) {
              goto LABEL_95;
            }
LABEL_88:
            int64_t v727 = -24;
            unint64_t v320 = v67[12];
            unint64_t v321 = lazy protocol witness table accessor for type Int and conformance Int(v315, v316, v317);
            unint64_t v322 = v723;
            ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v320)(&v727, &type metadata for Int, v321, v71, v67);
            char v323 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[2] + 1) + 8))(v170, v322, v71);
            ((void (*)(unint64_t, uint64_t))v141)(v322, v71);
            ((void (*)(char *, uint64_t))v141)(v170, v71);
            if (v323) {
              goto LABEL_97;
            }
            goto LABEL_107;
          }
          char v319 = ((uint64_t (*)(uint64_t, int **))v313)(v71, v67);
          uint64_t v315 = ((uint64_t (*)(uint64_t, int **))v165)(v71, v67);
          uint64_t v318 = v719;
          if (v319)
          {
            if (v315 > 64) {
              goto LABEL_88;
            }
            uint64_t v330 = v708;
            v696(&qword_18162B0B8, 256);
            unint64_t v331 = v723;
            ((void (*)(char *, uint64_t, int **))v688)(v330, v71, v709);
            LOBYTE(v33_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 32))(v170, v331, v71);
            ((void (*)(unint64_t, uint64_t))v141)(v331, v71);
            v332 = v668;
            (*(void (**)(char *, char *, uint64_t))(v318 + 32))(v668, v170, v71);
            if (v330)
            {
              uint64_t v324 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
              uint64_t v325 = v332;
LABEL_96:
              ((void (*)(char *, uint64_t))v141)(v325, v71);
              if (v324 == -24)
              {
LABEL_97:
                ((void (*)(char *, uint64_t))v141)(v724, v71);
                uint64_t v326 = v725;
                uint64_t v327 = (*(uint64_t (**)(uint64_t))(v714 + 136))(v725);
                char v328 = v715[21](v326);
                uint64_t result = 0;
                LOWORD(v31_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = 0x8000;
                if ((v328 & 1) == 0) {
                  short float v310 = COERCE_SHORT_FLOAT(0);
                }
                LOWORD(v329) = -32767;
                if ((v328 & 1) == 0) {
                  short float v329 = COERCE_SHORT_FLOAT(1);
                }
                if (v327) {
                  short float v310 = v329;
                }
                goto LABEL_92;
              }
LABEL_107:
              uint64_t v333 = v704;
              (*(void (**)(int *, char *, uint64_t))(v318 + 32))(v704, v724, v71);
              char v334 = ((uint64_t (*)(uint64_t, int **))v717)(v71, v67);
              uint64_t v335 = v692;
              uint64_t v724 = *(char **)(v318 + 16);
              ((void (*)(char *, int *, uint64_t))v724)(v692, v333, v71);
              if ((v334 & 1) == 0)
              {
                ((void (*)(char *, uint64_t))v141)(v335, v71);
                uint64_t v337 = v691;
                goto LABEL_138;
              }
              uint64_t v336 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
              ((void (*)(char *, uint64_t))v141)(v335, v71);
              uint64_t v337 = v691;
              if (v336 <= 64) {
                goto LABEL_138;
              }
              uint64_t v659 = v154;
              uint64_t v338 = v680;
              ((void (*)(char *, int *, uint64_t))v724)(v680, v704, v71);
              int64_t v727 = 0x8000000000000000;
              v339 = v717;
              if (((uint64_t (*)(uint64_t, int **))v717)(v71, v67))
              {
                uint64_t v340 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
                if (v340 < 64)
                {
                  uint64_t v343 = v338;
                  unint64_t v344 = v723;
                  ((void (*)(unint64_t, char *, uint64_t))v724)(v723, v338, v71);
                  uint64_t v345 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
                  v346 = (void (*)(char *, uint64_t))v701;
                  ((void (*)(unint64_t, uint64_t))v701)(v344, v71);
                  goto LABEL_129;
                }
                goto LABEL_125;
              }
              char v347 = ((uint64_t (*)(uint64_t, int **))v339)(v71, v67);
              uint64_t v340 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
              if (v347)
              {
                if (v340 > 64)
                {
LABEL_125:
                  uint64_t v360 = v67[12];
                  unint64_t v361 = lazy protocol witness table accessor for type Int and conformance Int(v340, v341, v342);
                  unint64_t v362 = v723;
                  ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v360)(&v727, &type metadata for Int, v361, v71, v67);
                  uint64_t v343 = v680;
                  char v363 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v680, v362, v71);
                  unint64_t v364 = v362;
                  v346 = (void (*)(char *, uint64_t))v701;
                  ((void (*)(unint64_t, uint64_t))v701)(v364, v71);
                  if (v363) {
                    goto LABEL_289;
                  }
                  goto LABEL_137;
                }
                uint64_t v368 = v708;
                v696(&qword_18162B0B8, 256);
                unint64_t v369 = v723;
                ((void (*)(char *, uint64_t, int **))v688)(v368, v71, v709);
                unint64_t v370 = v680;
                char v371 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v680, v369, v71);
                v346 = (void (*)(char *, uint64_t))v701;
                ((void (*)(unint64_t, uint64_t))v701)(v369, v71);
                char v372 = v660;
                ((void (*)(char *, char *, uint64_t))v724)(v660, v370, v71);
                if (v371)
                {
                  v346(v372, v71);
                  goto LABEL_289;
                }
                int64_t v373 = v727;
                uint64_t v374 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
                v346(v372, v71);
                BOOL v200 = v374 < v373;
                uint64_t v343 = v680;
                if (v200) {
                  goto LABEL_289;
                }
              }
              else
              {
                uint64_t v343 = v338;
                v346 = (void (*)(char *, uint64_t))v701;
                if (v340 < 64)
                {
                  unint64_t v365 = v723;
                  ((void (*)(unint64_t, char *, uint64_t))v724)(v723, v338, v71);
                  uint64_t v345 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
                  v346((char *)v365, v71);
LABEL_129:
                  if (v345 < v727) {
LABEL_289:
                  }
                    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
                }
              }
LABEL_137:
              v346(v343, v71);
LABEL_138:
              unint64_t v375 = v337;
              v376 = v704;
              v377 = v721;
              uint64_t v378 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
              v379 = v690;
              ((void (*)(char *, int *, uint64_t))v724)(v690, v376, v71);
              if (v378 < 65)
              {
                uint64_t v390 = ((uint64_t (*)(uint64_t, int **))v377)(v71, v67);
                unint64_t v391 = (uint64_t (*)(int *, uint64_t))v701;
                ((void (*)(char *, uint64_t))v701)(v379, v71);
                BOOL v392 = v390 == 64;
                v380 = v717;
                if (!v392 || (((uint64_t (*)(uint64_t, int **))v717)(v71, v67) & 1) != 0)
                {
LABEL_153:
                  v398 = v704;
                  uint64_t v399 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
                  uint64_t result = v391(v398, v71);
                  uint64_t v400 = v399 + 24;
                  if (__OFADD__(v399, 24))
                  {
                    __break(1u);
LABEL_281:
                    if (__clz(__rbit32(LOWORD(v5) & 0x3FF | 0x10000)) >= __clz(__rbit32(v701 | 0x10000))) {
                      short float v310 = v5;
                    }
                    else {
                      short float v310 = v4;
                    }
                    goto LABEL_92;
                  }
                  uint64_t v71 = v714;
                  v401 = *(int ***)(v714 + 136);
                  uint64_t v402 = v725;
                  uint64_t v719 = v714 + 136;
                  uint64_t v720 = v401;
                  uint64_t v403 = ((uint64_t (*)(uint64_t, uint64_t))v401)(v725, v714);
                  v404 = v718;
                  unint64_t v721 = *(int **)(v71 + 120);
                  ((void (*)(uint64_t, uint64_t))v721)(v402, v71);
                  uint64_t v281 = v713;
                  uint64_t v271 = v706;
                  uint64_t v405 = (*((uint64_t (**)(uint64_t *, char *))v713 + 18))(v706, v713);
                  v406 = *(char **)(v712 + 8);
                  uint64_t v717 = (int *)(v712 + 8);
                  uint64_t v724 = v406;
                  ((void (*)(int **, uint64_t *))v406)(v404, v271);
                  uint64_t v407 = v400 - (v403 + v405);
                  char v408 = v715[46](v402);
                  unint64_t v723 = v407;
                  v709 = (int **)v400;
                  if (v408)
                  {
                    uint64_t v67 = v716;
                    unint64_t v409 = (unint64_t)v699;
                    if (v400 < -16 || v400 > 16 || v400 < 0 || (unint64_t)v400 > 0xF) {
                      goto LABEL_157;
                    }
                    LODWORD(v708) = 1 << v400;
                    uint64_t v407 = v723;
                    if ((v723 & 0x8000000000000000) != 0) {
                      goto LABEL_158;
                    }
                  }
                  else
                  {
                    LODWORD(v708) = 0;
                    uint64_t v67 = v716;
                    unint64_t v409 = (unint64_t)v699;
                    if (v407 < 0) {
                      goto LABEL_158;
                    }
                  }
LABEL_169:
                  ((void (*)(uint64_t, uint64_t))v721)(v725, v71);
                  v439 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 8);
                  if (v439(v271, v281))
                  {
                    uint64_t v440 = v678;
                    (*(void (**)(char *, unint64_t, uint64_t *))(v712 + 16))(v678, v409, v271);
                    uint64_t v441 = v711;
                    uint64_t v442 = swift_getAssociatedConformanceWitness((uint64_t)v67, (uint64_t)v271, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    v443 = v710;
                    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v442 + 8))(&qword_18162B0B8, 256, v441, v442);
                    uint64_t v444 = v718;
                    ((void (*)(char *, uint64_t *, int **))v67[3])(v443, v271, v67);
                    LOBYTE(v443) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4) + 8)
                                                                                        + 32))(v440, v444, v271);
                    uint64_t v445 = v724;
                    ((void (*)(int **, uint64_t *))v724)(v444, v271);
                    if ((v443 & 1) == 0) {
                      goto LABEL_275;
                    }
                    ((void (*)(char *, uint64_t *))v445)(v440, v271);
                    unint64_t v409 = (unint64_t)v699;
                  }
                  v446 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 16);
                  if (v446(v271, v281) < 16) {
                    goto LABEL_194;
                  }
                  uint64_t v447 = v677;
                  v707 = *(const char **)(v712 + 16);
                  ((void (*)(char *, unint64_t, uint64_t *))v707)(v677, v409, v271);
                  LOWORD(v727) = -1;
                  char v448 = v439(v271, v281);
                  uint64_t v449 = v446(v271, v281);
                  if (v448)
                  {
                    uint64_t v452 = v718;
                    uint64_t v453 = v724;
                    if (v449 <= 16)
                    {
                      uint64_t v454 = v716;
                      v455 = v706;
                      unint64_t v456 = v711;
                      uint64_t v457 = swift_getAssociatedConformanceWitness((uint64_t)v716, (uint64_t)v706, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                      v458 = v710;
                      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v457 + 8))(&qword_18162B0B8, 256, v456, v457);
                      ((void (*)(char *, uint64_t *, int **))v454[3])(v458, v455, v454);
                      v459 = v713;
                      LOBYTE(v454) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v713 + 4) + 8)
                                                                                          + 40))(v447, v452, v455);
                      ((void (*)(int **, uint64_t *))v453)(v452, v455);
                      unsigned int v460 = (unsigned __int16)v727;
                      v461 = v664;
                      ((void (*)(char *, char *, uint64_t *))v707)(v664, v447, v455);
                      if ((v454 & 1) == 0)
                      {
                        ((void (*)(char *, uint64_t *))v453)(v461, v455);
LABEL_193:
                        ((void (*)(char *, uint64_t *))v453)(v447, v455);
                        uint64_t v271 = v455;
                        uint64_t v281 = v713;
                        unint64_t v409 = (unint64_t)v699;
LABEL_194:
                        int v473 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
                        unint64_t v474 = v409;
                        int v475 = v473;
                        ((void (*)(unint64_t, uint64_t *))v724)(v474, v271);
                        if (v723 < 0x10) {
                          int v476 = v475 << v723;
                        }
                        else {
                          int v476 = 0;
                        }
                        uint64_t v477 = v725;
                        uint64_t v479 = v714;
                        unint64_t v478 = v715;
                        uint64_t v480 = v720;
                        goto LABEL_250;
                      }
                      unsigned __int16 v462 = (*((uint64_t (**)(uint64_t *, char *))v459 + 15))(v455, v459);
                      ((void (*)(char *, uint64_t *))v453)(v461, v455);
                      BOOL v463 = v460 >= v462;
LABEL_188:
                      if (!v463) {
                        goto LABEL_235;
                      }
                      goto LABEL_193;
                    }
                  }
                  else
                  {
                    uint64_t v452 = v718;
                    uint64_t v453 = v724;
                    if (v449 <= 16)
                    {
                      v455 = v706;
                      ((void (*)(int **, char *, uint64_t *))v707)(v718, v447, v706);
                      unsigned __int16 v471 = (*((uint64_t (**)(uint64_t *))v713 + 15))(v455);
                      ((void (*)(int **, uint64_t *))v453)(v452, v455);
                      BOOL v463 = (unsigned __int16)v727 >= v471;
                      goto LABEL_188;
                    }
                  }
                  v464 = v713;
                  v465 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v713 + 12);
                  unint64_t v466 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v449, v450, v451);
                  v455 = v706;
                  v465(&v727, &type metadata for UInt16, v466, v706, v464);
                  char v467 = (*(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v464 + 4) + 8)
                                                                              + 16))(v452, v447, v455);
                  ((void (*)(int **, uint64_t *))v453)(v452, v455);
                  if (v467) {
                    goto LABEL_235;
                  }
                  goto LABEL_193;
                }
              }
              else
              {
                ((void (*)(char *, uint64_t))v701)(v379, v71);
                v380 = v717;
              }
              uint64_t v381 = v375;
              ((void (*)(char *, int *, uint64_t))v724)(v375, v704, v71);
              int64_t v727 = 0x7FFFFFFFFFFFFFFFLL;
              char v382 = ((uint64_t (*)(uint64_t, int **))v380)(v71, v67);
              uint64_t v383 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
              if (v382)
              {
                unint64_t v386 = (void (*)(unint64_t, uint64_t))v701;
                if (v383 > 64)
                {
                  v387 = v67[12];
                  unint64_t v388 = lazy protocol witness table accessor for type Int and conformance Int(v383, v384, v385);
                  v389 = &v727;
                  goto LABEL_151;
                }
              }
              else
              {
                unint64_t v386 = (void (*)(unint64_t, uint64_t))v701;
                if (v383 >= 64)
                {
                  uint64_t v726 = 0x7FFFFFFFFFFFFFFFLL;
                  v387 = v67[12];
                  unint64_t v388 = lazy protocol witness table accessor for type Int and conformance Int(v383, v384, v385);
                  v389 = &v726;
LABEL_151:
                  unint64_t v396 = v723;
                  ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v387)(v389, &type metadata for Int, v388, v71, v67);
                  char v397 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v396, v381, v71);
                  v386(v396, v71);
                  if ((v397 & 1) == 0) {
                    goto LABEL_152;
                  }
                  goto LABEL_150;
                }
              }
              unint64_t v393 = v723;
              ((void (*)(unint64_t, char *, uint64_t))v724)(v723, v375, v71);
              uint64_t v394 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
              v386(v393, v71);
              if (v727 >= v394)
              {
LABEL_152:
                v386((unint64_t)v381, v71);
                unint64_t v391 = (uint64_t (*)(int *, uint64_t))v386;
                goto LABEL_153;
              }
LABEL_150:
              unint64_t v395 = 3687;
              goto LABEL_236;
            }
          }
          else
          {
            if (v315 < 64)
            {
LABEL_95:
              uint64_t v324 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
              uint64_t v325 = v170;
              goto LABEL_96;
            }
            v332 = v667;
            (*(void (**)(char *, char *, uint64_t))(v719 + 32))(v667, v170, v71);
          }
          ((void (*)(char *, uint64_t))v141)(v332, v71);
          goto LABEL_107;
        }
        char v174 = ((uint64_t (*)(uint64_t, int **))v155)(v71, v67);
        uint64_t v165 = v721;
        uint64_t v175 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
        if (v174)
        {
          unint64_t v170 = v700;
          if (v175 > 64)
          {
            int64_t v727 = -24;
            unint64_t v178 = v67[12];
            unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v175, v176, v177);
            unint64_t v721 = v165;
            unint64_t v180 = v723;
            ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v178)(&v727, &type metadata for Int, v179, v71, v67);
            char v181 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v124, v180, v71);
            unint64_t v182 = v180;
            uint64_t v165 = v721;
            uint64_t v141 = v701;
            ((void (*)(unint64_t, uint64_t))v701)(v182, v71);
            ((void (*)(char *, uint64_t))v141)(v124, v71);
            if (v181) {
              goto LABEL_81;
            }
            goto LABEL_83;
          }
          char v297 = v708;
          v696(&qword_18162B0B8, 256);
          unint64_t v298 = v723;
          ((void (*)(char *, uint64_t, int **))v688)(v297, v71, v709);
          char v299 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v124, v298, v71);
          uint64_t v141 = v701;
          ((void (*)(unint64_t, uint64_t))v701)(v298, v71);
          uint64_t v300 = v676;
          (*(void (**)(char *, char *, uint64_t))(v719 + 32))(v676, v124, v71);
          if (v299)
          {
            ((void (*)(char *, uint64_t))v141)(v300, v71);
            goto LABEL_81;
          }
          uint64_t v197 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
          ((void (*)(char *, uint64_t))v141)(v300, v71);
        }
        else
        {
          unint64_t v170 = v700;
          if (v175 >= 64)
          {
            v301 = v675;
            (*(void (**)(char *, char *, uint64_t))(v719 + 32))(v675, v124, v71);
            uint64_t v141 = v701;
            ((void (*)(char *, uint64_t))v701)(v301, v71);
            goto LABEL_83;
          }
          uint64_t v197 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
          uint64_t v141 = v701;
          ((void (*)(char *, uint64_t))v701)(v124, v71);
        }
        if (v197 >= -24) {
          goto LABEL_83;
        }
        goto LABEL_81;
      }
    }
    else
    {
      uint64_t v138 = (int *)v719;
      uint64_t v171 = *(void (**)(char *, char *, uint64_t))(v719 + 16);
      if (v144 >= 64)
      {
        v171(v74, v724, v71);
        uint64_t v141 = (int *)*((void *)v138 + 1);
        ((void (*)(char *, uint64_t))v141)(v74, v71);
      }
      else
      {
        unint64_t v172 = v723;
        v171((char *)v723, v724, v71);
        uint64_t v173 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        uint64_t v141 = (int *)*((void *)v138 + 1);
        ((void (*)(unint64_t, uint64_t))v141)(v172, v71);
        if (v173 < v727)
        {
          uint64_t v154 = (unint64_t)(v138 + 2) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
          uint64_t v131 = v717;
          goto LABEL_13;
        }
        uint64_t v131 = v717;
      }
    }
LABEL_34:
    int64_t v727 = 15;
    char v201 = ((uint64_t (*)(uint64_t, int **))v131)(v71, v67);
    char v202 = v67 + 16;
    char v203 = v724;
    uint64_t v204 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
    if (v201)
    {
      if (v204 > 64)
      {
        uint64_t v207 = v67[12];
        unint64_t v208 = lazy protocol witness table accessor for type Int and conformance Int(v204, v205, v206);
        unint64_t v209 = v723;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v207)(&v727, &type metadata for Int, v208, v71, v67);
        char v210 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v209, v203, v71);
        unint64_t v211 = v209;
        char v132 = (void (*)(char *, uint64_t))v720;
        ((void (*)(unint64_t, uint64_t))v141)(v211, v71);
        if ((v210 & 1) == 0) {
          goto LABEL_43;
        }
        goto LABEL_40;
      }
    }
    else if (v204 > 63)
    {
      uint64_t v726 = 15;
      uint64_t v216 = (uint64_t (*)(char *, char *, uint64_t))*((void *)v138 + 2);
      v704 = (int *)(v67 + 16);
      uint64_t v217 = v683;
      uint64_t v218 = v216(v683, v203, v71);
      uint64_t v219 = v67[12];
      unint64_t v222 = lazy protocol witness table accessor for type Int and conformance Int(v218, v220, v221);
      uint64_t v223 = v141;
      unint64_t v224 = v723;
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v219)(&v726, &type metadata for Int, v222, v71, v67);
      char v203 = v724;
      char v132 = (void (*)(char *, uint64_t))v720;
      char v225 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v224, v217, v71);
      unint64_t v226 = v224;
      uint64_t v141 = v223;
      ((void (*)(unint64_t, uint64_t))v223)(v226, v71);
      char v227 = v217;
      char v202 = (int **)v704;
      ((void (*)(char *, uint64_t))v223)(v227, v71);
      if (v225)
      {
LABEL_40:
        ((void (*)(char *, uint64_t))v141)(v203, v71);
        if (v715[21](v725))
        {
          uint64_t result = 0;
          __int16 v215 = -1024;
        }
        else
        {
          uint64_t result = 0;
          __int16 v215 = 31744;
        }
        goto LABEL_91;
      }
LABEL_43:
      uint64_t v228 = v717;
      if (((uint64_t (*)(uint64_t, int **))v717)(v71, v67))
      {
        uint64_t v229 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
        if (v229 >= 64)
        {
          int64_t v727 = 0;
          uint64_t v232 = v67[12];
          unint64_t v233 = lazy protocol witness table accessor for type Int and conformance Int(v229, v230, v231);
          unint64_t v234 = v723;
          ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v232)(&v727, &type metadata for Int, v233, v71, v67);
          char v235 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v203, v234, v71);
          uint64_t v236 = v138 + 2;
          unint64_t v237 = v234;
          char v132 = (void (*)(char *, uint64_t))v720;
          ((void (*)(unint64_t, uint64_t))v141)(v237, v71);
          if ((v235 & 1) == 0) {
            goto LABEL_54;
          }
          goto LABEL_63;
        }
LABEL_53:
        unint64_t v246 = v723;
        (*((void (**)(unint64_t, char *, uint64_t))v138 + 2))(v723, v203, v71);
        uint64_t v247 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        uint64_t v236 = v138 + 2;
        ((void (*)(unint64_t, uint64_t))v141)(v246, v71);
        if ((v247 & 0x8000000000000000) == 0) {
          goto LABEL_54;
        }
        goto LABEL_63;
      }
      char v238 = ((uint64_t (*)(uint64_t, int **))v228)(v71, v67);
      uint64_t v239 = ((uint64_t (*)(uint64_t, int **))v721)(v71, v67);
      if ((v238 & 1) == 0)
      {
        if (v239 >= 64) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
      if (v239 <= 64)
      {
        v305 = v709;
        char v306 = v707;
        uint64_t v307 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v308 = v708;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v307 + 8))(&qword_18162B0B8, 256, v306, v307);
        unint64_t v309 = v723;
        ((void (*)(char *, uint64_t, int **))v305[3])(v308, v71, v305);
        LOBYTE(v305) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v203, v309, v71);
        uint64_t v248 = (unint64_t)(v138 + 2) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        ((void (*)(unint64_t, uint64_t))v141)(v309, v71);
        char v132 = (void (*)(char *, uint64_t))v669;
        (*((void (**)(char *, char *, uint64_t))v138 + 2))(v669, v203, v71);
        if ((v305 & 1) == 0) {
          goto LABEL_123;
        }
        ((void (*)(void, uint64_t))v141)(v132, v71);
        char v203 = v724;
LABEL_64:
        v704 = (int *)v202;
        uint64_t v269 = (uint64_t *)v688;
        (*(void (**)(char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 16) + 16))(v203, v71);
        uint64_t v270 = v203;
        uint64_t v271 = v269;
        ((void (*)(char *, uint64_t))v141)(v270, v71);
        uint64_t v272 = v717;
        if (((uint64_t (*)(uint64_t, int **))v717)(v71, v67))
        {
          unint64_t v273 = v674;
          (*((void (**)(char *, uint64_t *, uint64_t))v138 + 2))(v674, v271, v71);
          uint64_t v274 = v709;
          char v275 = v707;
          uint64_t v276 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v277 = v708;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v276 + 8))(&qword_18162B0B8, 256, v275, v276);
          unint64_t v278 = v723;
          ((void (*)(char *, uint64_t, int **))v274[3])(v277, v71, v274);
          LOBYTE(v274) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 32))(v273, v278, v71);
          ((void (*)(unint64_t, uint64_t))v141)(v278, v71);
          if ((v274 & 1) == 0) {
            goto LABEL_275;
          }
          ((void (*)(char *, uint64_t))v141)(v273, v71);
          uint64_t v272 = v717;
          uint64_t v271 = (uint64_t *)v688;
        }
        uint64_t v724 = (char *)v248;
        uint64_t v279 = v138;
        char v280 = v721;
        uint64_t v281 = (char *)v704;
        if (((uint64_t (*)(uint64_t, int **))v721)(v71, v67) < 64)
        {
LABEL_200:
          unint64_t v409 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
          ((void (*)(uint64_t *, uint64_t))v141)(v271, v71);
          v358 = (char *)(15 - v409);
          if (v409 > 0xF)
          {
            __break(1u);
          }
          else
          {
LABEL_201:
            v708 = v358;
            v481 = v716;
            uint64_t v482 = v714;
            uint64_t v483 = *(int ***)(v714 + 136);
            uint64_t v719 = (v714 + 136) & 0xFFFFFFFFFFFFLL | 0x1E66000000000000;
            uint64_t v720 = v483;
            uint64_t v484 = v725;
            unint64_t v723 = ((uint64_t (*)(uint64_t, uint64_t))v483)(v725, v714);
            v485 = v718;
            unint64_t v721 = *(int **)(v482 + 120);
            ((void (*)(uint64_t, uint64_t))v721)(v484, v482);
            v486 = (char *)*((void *)v713 + 18);
            uint64_t v271 = v706;
            v701 = (int *)(v713 + 144);
            v700 = v486;
            uint64_t v487 = ((uint64_t (*)(uint64_t *))v486)(v706);
            char v488 = *(void (**)(int **, uint64_t *))(v712 + 8);
            uint64_t v717 = (int *)(v712 + 8);
            v488(v485, v271);
            unint64_t v723 = 10 - v723 - v487;
            LOBYTE(v484) = v715[49](v484);
            uint64_t v489 = v711;
            uint64_t v490 = swift_getAssociatedConformanceWitness((uint64_t)v481, (uint64_t)v271, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v491 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v490 + 8);
            uint64_t v724 = (char *)v488;
            v707 = (const char *)(v481 + 3);
            v709 = (int **)(v482 + 120);
            if (v484)
            {
              v492 = v710;
              v491(&qword_18162B0C0, 512, v489, v490);
              v704 = v481[3];
              ((void (*)(char *, uint64_t *, int **))v704)(v492, v271, v481);
              uint64_t v493 = v725;
              uint64_t v494 = ((uint64_t (*)(uint64_t, uint64_t))v720)(v725, v482);
              v495 = v702;
              v496 = v721;
              ((void (*)(uint64_t, uint64_t))v721)(v493, v482);
              uint64_t v281 = v713;
              uint64_t v497 = ((uint64_t (*)(uint64_t *, char *))v700)(v271, v713);
              v498 = v724;
              uint64_t v499 = ((uint64_t (*)(char *, uint64_t *))v724)(v495, v271);
              int64_t v727 = v497 + v494;
              unint64_t v500 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 32);
              unint64_t v503 = lazy protocol witness table accessor for type Int and conformance Int(v499, v501, v502);
              v504 = (char *)v696;
              unint64_t v505 = v718;
              v500(v718, &v727, &type metadata for Int, v503, v271, v281);
              ((void (*)(int **, uint64_t *))v498)(v505, v271);
              char v506 = v697;
              v507 = v496;
            }
            else
            {
              unint64_t v508 = v710;
              v491(&qword_18162B0B8, 256, v489, v490);
              v504 = (char *)v696;
              v704 = v481[3];
              ((void (*)(char *, uint64_t *, int **))v704)(v508, v271, v481);
              uint64_t v281 = v713;
              char v506 = v697;
              v507 = v721;
            }
            unint64_t v409 = (unint64_t)(v281 + 224);
            uint64_t v71 = v723;
            if ((v723 & 0x8000000000000000) == 0)
            {
              char v509 = v718;
              uint64_t v477 = v725;
              ((void (*)(uint64_t, uint64_t))v507)(v725, v714);
              unint64_t v510 = v689;
              (*((void (**)(char *, int **, uint64_t *, char *))v281 + 28))(v504, v509, v271, v281);
              unint64_t v511 = v724;
              ((void (*)(int **, uint64_t *))v724)(v509, v271);
              ((void (*)(char *, uint64_t *))v511)(v504, v271);
              uint64_t v512 = (int **)*((void *)v281 + 8);
              if ((((uint64_t (*)(uint64_t *, char *))v512)(v271, v281) & 1) == 0) {
                goto LABEL_208;
              }
              v709 = v512;
              (*(void (**)(char *, char *, uint64_t *))(v712 + 16))(v506, v510, v271);
              unint64_t v513 = v716;
              uint64_t v514 = v711;
              uint64_t v515 = swift_getAssociatedConformanceWitness((uint64_t)v716, (uint64_t)v271, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v516 = v710;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v515 + 8))(&qword_18162B0B8, 256, v514, v515);
              ((void (*)(char *, uint64_t *, int **))v704)(v516, v271, v513);
              LOBYTE(v516) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4)
                                                                                              + 8)
                                                                                  + 32))(v506, v509, v271);
              v517 = v724;
              ((void (*)(int **, uint64_t *))v724)(v509, v271);
              if (v516)
              {
                ((void (*)(char *, uint64_t *))v517)(v506, v271);
                uint64_t v512 = v709;
LABEL_208:
                uint64_t v518 = v281;
                uint64_t v519 = v281;
                v520 = v271;
                uint64_t v521 = (uint64_t (*)(uint64_t *, char *))*((void *)v518 + 16);
                if (v521(v520, v519) < 16)
                {
LABEL_239:
                  int v598 = (*((uint64_t (**)(uint64_t *, char *))v519 + 15))(v520, v519);
                  ((void (*)(char *, uint64_t *))v724)(v510, v520);
                  if (v723 < 0x10) {
                    uint64_t v599 = (v598 << v723);
                  }
                  else {
                    uint64_t v599 = 0;
                  }
                  uint64_t v600 = 10;
                  uint64_t v479 = v714;
                  unint64_t v478 = v715;
                  goto LABEL_246;
                }
                v522 = *(void (**)(char *, char *, uint64_t *))(v712 + 16);
                v522(v686, v510, v520);
                LOWORD(v727) = -1;
                char v523 = ((uint64_t (*)(uint64_t *, char *))v512)(v520, v519);
                uint64_t v524 = v521(v520, v519);
                v527 = v519;
                if (v523)
                {
                  uint64_t v528 = v522;
                  uint64_t v529 = v718;
                  if (v524 > 16)
                  {
                    uint64_t v530 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v519 + 12);
                    unint64_t v531 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v524, v525, v526);
                    uint64_t v532 = v706;
                    v530(&v727, &type metadata for UInt16, v531, v706, v519);
                    v533 = *(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v519 + 4) + 8)
                                                                               + 16);
                    uint64_t v534 = v686;
                    char v535 = v533(v529, v686, v532);
                    uint64_t v536 = v529;
                    goto LABEL_224;
                  }
                  v584 = v716;
                  uint64_t v532 = v706;
                  v585 = v711;
                  uint64_t v586 = swift_getAssociatedConformanceWitness((uint64_t)v716, (uint64_t)v706, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  char v587 = v710;
                  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v586 + 8))(&qword_18162B0B8, 256, v585, v586);
                  ((void (*)(char *, uint64_t *, int **))v704)(v587, v532, v584);
                  uint64_t v588 = *(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v519 + 4) + 8)
                                                                             + 40);
                  uint64_t v534 = v686;
                  LOBYTE(v584) = v588(v686, v529, v532);
                  uint64_t v589 = v529;
                  v578 = v724;
                  ((void (*)(int **, uint64_t *))v724)(v589, v532);
                  uint64_t v590 = v527;
                  unsigned int v591 = (unsigned __int16)v727;
                  v592 = v666;
                  v528(v666, v534, v532);
                  if ((v584 & 1) == 0)
                  {
                    ((void (*)(char *, uint64_t *))v578)(v592, v532);
                    uint64_t v477 = v725;
                    unint64_t v510 = v689;
LABEL_238:
                    ((void (*)(char *, uint64_t *))v578)(v534, v532);
                    v520 = v532;
                    uint64_t v519 = v713;
                    goto LABEL_239;
                  }
                  unsigned __int16 v593 = (*((uint64_t (**)(uint64_t *, char *))v590 + 15))(v532, v590);
                  ((void (*)(char *, uint64_t *))v578)(v592, v532);
                  BOOL v594 = v591 >= v593;
                }
                else
                {
                  v574 = v718;
                  if (v524 > 16)
                  {
                    unint64_t v575 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v519 + 12);
                    unint64_t v576 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v524, v525, v526);
                    uint64_t v532 = v706;
                    v575(&v727, &type metadata for UInt16, v576, v706, v519);
                    v577 = *(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v519 + 4) + 8)
                                                                               + 16);
                    uint64_t v534 = v686;
                    char v535 = v577(v574, v686, v532);
                    uint64_t v536 = v574;
LABEL_224:
                    v578 = v724;
                    ((void (*)(int **, uint64_t *))v724)(v536, v532);
                    uint64_t v477 = v725;
                    unint64_t v510 = v689;
                    if (v535) {
                      goto LABEL_235;
                    }
                    goto LABEL_238;
                  }
                  uint64_t v534 = v686;
                  uint64_t v532 = v706;
                  v522((char *)v718, v686, v706);
                  unsigned __int16 v595 = (*((uint64_t (**)(uint64_t *, char *))v527 + 15))(v532, v527);
                  v578 = v724;
                  ((void (*)(int **, uint64_t *))v724)(v574, v532);
                  BOOL v594 = (unsigned __int16)v727 >= v595;
                }
                uint64_t v477 = v725;
                unint64_t v510 = v689;
                if (!v594) {
                  goto LABEL_235;
                }
                goto LABEL_238;
              }
LABEL_275:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
            }
            uint64_t v537 = v702;
            ((void (*)(uint64_t, uint64_t))v507)(v725, v714);
            uint64_t v67 = v718;
            (*((void (**)(char *, char *, uint64_t *, char *))v281 + 28))(v504, v537, v271, v281);
            unint64_t v538 = v724;
            ((void (*)(char *, uint64_t *))v724)(v537, v271);
            uint64_t v539 = ((uint64_t (*)(char *, uint64_t *))v538)(v504, v271);
            if (!__OFSUB__(0, v71))
            {
              int64_t v727 = -v71;
              v542 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 30);
              unint64_t v543 = lazy protocol witness table accessor for type Int and conformance Int(v539, v540, v541);
              v544 = v684;
              v542(v67, &v727, &type metadata for Int, v543, v271, v281);
              ((void (*)(int **, uint64_t *))v538)(v67, v271);
              v545 = (int **)*((void *)v281 + 8);
              char v546 = ((uint64_t (*)(uint64_t *, char *))v545)(v271, v281);
              v547 = v716;
              if (v546)
              {
                v709 = v545;
                v548 = v544;
                v549 = v673;
                (*(void (**)(void))(v712 + 16))();
                uint64_t v550 = v711;
                uint64_t v551 = swift_getAssociatedConformanceWitness((uint64_t)v547, (uint64_t)v271, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v552 = v710;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v551 + 8))(&qword_18162B0B8, 256, v550, v551);
                ((void (*)(char *, uint64_t *, int **))v704)(v552, v271, v547);
                LOBYTE(v552) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4)
                                                                                                + 8)
                                                                                    + 32))(v549, v67, v271);
                v553 = v724;
                ((void (*)(int **, uint64_t *))v724)(v67, v271);
                if ((v552 & 1) == 0) {
                  goto LABEL_275;
                }
                ((void (*)(char *, uint64_t *))v553)(v549, v271);
                v544 = v548;
                v545 = v709;
              }
              v554 = v281;
              v555 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 16);
              if (v555(v271, v554) < 16)
              {
LABEL_245:
                uint64_t v599 = (*((uint64_t (**)(uint64_t *, char *))v554 + 15))(v271, v554);
                ((void (*)(char *, uint64_t *))v724)(v544, v271);
                uint64_t v600 = 10;
                uint64_t v477 = v725;
                uint64_t v479 = v714;
                unint64_t v478 = v715;
LABEL_246:
                uint64_t v480 = v720;
                char v601 = (char)v708;
LABEL_251:
                unint64_t v602 = (char *)v478[21];
                v709 = (int **)(v478 + 21);
                v708 = v602;
                uint64_t v603 = v477;
                int v604 = ((v601 & 0x1F) << 10) | (((unsigned int (*)(uint64_t))v602)(v477) << 15) | v599 & 0x3FF;
                if (v600 >= ((uint64_t (*)(uint64_t, uint64_t))v480)(v603, v479))
                {
                  *(_WORD *)v705 = v604;
                  return 1;
                }
                uint64_t v605 = v599;
                LODWORD(v704) = v604;
                unint64_t v606 = v716;
                v607 = v706;
                uint64_t v608 = v711;
                uint64_t v609 = swift_getAssociatedConformanceWitness((uint64_t)v716, (uint64_t)v706, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                unint64_t v610 = v718;
                char v611 = v710;
                v707 = *(const char **)(v609 + 8);
                ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v707)(&qword_18162B0C0, 512, v608, v609);
                uint64_t v720 = (int **)v606[3];
                uint64_t v612 = ((uint64_t (*)(char *, uint64_t *, int **))v720)(v611, v607, v606);
                if (!__OFSUB__(0, v723))
                {
                  unint64_t v615 = (unint64_t)(v606 + 3);
                  v701 = (int *)v605;
                  int64_t v727 = -(uint64_t)v723;
                  uint64_t v719 = v609;
                  uint64_t v717 = (int *)(v609 + 8);
                  v617 = v713;
                  uint64_t v616 = v714;
                  unint64_t v618 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v713 + 32);
                  unint64_t v619 = lazy protocol witness table accessor for type Int and conformance Int(v612, v613, v614);
                  unint64_t v723 = v615;
                  v618(v610, &v727, &type metadata for Int, v619, v607, v617);
                  unint64_t v620 = v724;
                  ((void (*)(int **, uint64_t *))v724)(v610, v607);
                  ((void (*)(uint64_t, uint64_t))v721)(v725, v616);
                  unint64_t v621 = v611;
                  unint64_t v622 = v707;
                  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v707)(&qword_18162B0C0, 512, v608, v719);
                  v623 = v695;
                  ((void (*)(char *, uint64_t *, int **))v720)(v621, v607, v716);
                  uint64_t v624 = v702;
                  (*(void (**)(char *, char *, uint64_t *))(*(void *)(v693 + 8) + 40))(v703, v623, v607);
                  ((void (*)(char *, uint64_t *))v620)(v623, v607);
                  uint64_t v625 = v694;
                  (*((void (**)(int **, char *, uint64_t *, char *))v617 + 24))(v610, v624, v607, v617);
                  ((void (*)(char *, uint64_t *))v620)(v624, v607);
                  ((void (*)(int **, uint64_t *))v620)(v610, v607);
                  uint64_t v626 = v710;
                  ((void (*)(void *, uint64_t))v622)(&unk_18162B0D0, 768);
                  uint64_t v627 = v703;
                  ((void (*)(char *, uint64_t *, int **))v720)(v626, v607, v716);
                  v628 = v625;
                  unint64_t v721 = (int *)*((void *)v617 + 19);
                  ((void (*)(char *, char *, uint64_t *, char *))v721)(v627, v624, v607, v617);
                  ((void (*)(char *, uint64_t *))v620)(v624, v607);
                  uint64_t v629 = *(void *)(*((void *)v617 + 4) + 8);
                  LOBYTE(v615) = (*(uint64_t (**)(char *, int **, uint64_t *, uint64_t))(v629 + 16))(v625, v610, v607, v629);
                  ((void (*)(int **, uint64_t *))v620)(v610, v607);
                  if (v615)
                  {
                    ((void (*)(char *, uint64_t *))v620)(v625, v607);
                    ((void (*)(char *, uint64_t *))v620)(v627, v607);
                    uint64_t result = 0;
                    *(_WORD *)v705 = (_WORD)v704;
                    return result;
                  }
                  short float v4 = *(short float *)&v704;
                  char v630 = ((uint64_t (*)(uint64_t, uint64_t (**)(void)))v708)(v725, v715);
                  HIWORD(v631) = 0;
                  if (v630)
                  {
                    *(short float *)&int v631 = COERCE_SHORT_FLOAT(0) - v4;
                    float v632 = v716;
                    v633 = v710;
                    if ((short float)(COERCE_SHORT_FLOAT(0) - v4) < COERCE_SHORT_FLOAT(31744)) {
                      v631 += ((__int16)v631 >> 15) | 1;
                    }
                    short float v5 = -*(short float *)&v631;
                  }
                  else
                  {
                    short float v5 = v4 + COERCE_SHORT_FLOAT(0);
                    float v632 = v716;
                    v633 = v710;
                    if ((short float)(v4 + COERCE_SHORT_FLOAT(0)) < COERCE_SHORT_FLOAT(31744)) {
                      LOWORD(v5) += (SLOWORD(v5) >> 15) | 1;
                    }
                  }
                  ((void (*)(void *, uint64_t))v707)(&unk_18162B0D0, 768);
                  v634 = v702;
                  v635 = v633;
                  uint64_t v636 = v706;
                  ((void (*)(char *, uint64_t *, int **))v720)(v635, v706, v632);
                  ((void (*)(char *, char *, uint64_t *, char *))v721)(v627, v634, v636, v713);
                  char v637 = v724;
                  ((void (*)(char *, uint64_t *))v724)(v634, v636);
                  ((void (*)(char *, uint64_t *))v637)(v627, v636);
                  char v638 = (*(uint64_t (**)(char *, int **, uint64_t *, uint64_t))(v629 + 40))(v628, v610, v636, v629);
                  ((void (*)(int **, uint64_t *))v637)(v610, v636);
                  ((void (*)(char *, uint64_t *))v637)(v628, v636);
                  uint64_t result = 0;
                  if (v638)
                  {
                    short float *v705 = v5;
                    return result;
                  }
                  goto LABEL_281;
                }
                __break(1u);
                goto LABEL_277;
              }
              char v556 = *(void (**)(void))(v712 + 16);
              uint64_t v557 = v672;
              v556();
              LOWORD(v727) = -1;
              char v558 = ((uint64_t (*)(uint64_t *, char *))v545)(v271, v554);
              uint64_t v559 = v555(v271, v554);
              if (v558)
              {
                v562 = v718;
                if (v559 <= 16)
                {
                  uint64_t v563 = v716;
                  v564 = v706;
                  unint64_t v565 = v711;
                  uint64_t v566 = swift_getAssociatedConformanceWitness((uint64_t)v716, (uint64_t)v706, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v567 = v710;
                  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v566 + 8))(&qword_18162B0B8, 256, v565, v566);
                  ((void (*)(char *, uint64_t *, int **))v704)(v567, v564, v563);
                  char v568 = v713;
                  LOBYTE(v563) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v713 + 4)
                                                                                                  + 8)
                                                                                      + 40))(v557, v562, v564);
                  v569 = v562;
                  v570 = v724;
                  ((void (*)(int **, uint64_t *))v724)(v569, v564);
                  unsigned int v571 = (unsigned __int16)v727;
                  uint64_t v572 = v662;
                  ((void (*)(char *, char *, uint64_t *))v556)(v662, v557, v564);
                  if (v563)
                  {
                    unsigned __int16 v573 = (*((uint64_t (**)(uint64_t *, char *))v568 + 15))(v564, v568);
                    ((void (*)(char *, uint64_t *))v570)(v572, v564);
                    if (v571 < v573) {
                      goto LABEL_235;
                    }
                  }
                  else
                  {
                    ((void (*)(char *, uint64_t *))v570)(v572, v564);
                  }
                  goto LABEL_244;
                }
                goto LABEL_227;
              }
              v562 = v718;
              if (v559 > 16)
              {
LABEL_227:
                v579 = v713;
                uint64_t v580 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v713 + 12);
                unint64_t v581 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v559, v560, v561);
                v564 = v706;
                v580(&v727, &type metadata for UInt16, v581, v706, v579);
                char v582 = (*(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v579 + 4) + 8)
                                                                            + 16))(v562, v557, v564);
                v583 = v562;
                v570 = v724;
                ((void (*)(int **, uint64_t *))v724)(v583, v564);
                if (v582) {
                  goto LABEL_235;
                }
                goto LABEL_244;
              }
              v564 = v706;
              ((void (*)(int **, char *, uint64_t *))v556)(v718, v557, v706);
              unsigned __int16 v596 = (*((uint64_t (**)(uint64_t *))v713 + 15))(v564);
              uint64_t v597 = v562;
              v570 = v724;
              ((void (*)(int **, uint64_t *))v724)(v597, v564);
              if ((unsigned __int16)v727 >= v596)
              {
LABEL_244:
                ((void (*)(char *, uint64_t *))v570)(v557, v564);
                uint64_t v271 = v564;
                v554 = v713;
                v544 = v684;
                goto LABEL_245;
              }
LABEL_235:
              unint64_t v395 = 3455;
LABEL_236:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, v395, 0);
            }
          }
          __break(1u);
          do
          {
            __break(1u);
LABEL_157:
            LODWORD(v708) = 0;
            uint64_t v407 = v723;
            if ((v723 & 0x8000000000000000) == 0) {
              goto LABEL_169;
            }
LABEL_158:
            unint64_t v410 = v718;
            uint64_t v411 = ((uint64_t (*)(uint64_t, uint64_t))v721)(v725, v71);
          }
          while (__OFSUB__(0, v407));
          int64_t v727 = -v407;
          char v414 = (void (*)(int **, int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 30);
          unint64_t v415 = lazy protocol witness table accessor for type Int and conformance Int(v411, v412, v413);
          v416 = v687;
          v414(v410, &v727, &type metadata for Int, v415, v271, v281);
          ((void (*)(int **, uint64_t *))v724)(v410, v271);
          int64_t v417 = (const char *)*((void *)v281 + 8);
          if (((uint64_t (*)(uint64_t *, char *))v417)(v271, v281))
          {
            v707 = v417;
            uint64_t v418 = v671;
            (*(void (**)(char *, char *, uint64_t *))(v712 + 16))(v671, v416, v271);
            v419 = v711;
            uint64_t v420 = swift_getAssociatedConformanceWitness((uint64_t)v67, (uint64_t)v271, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v421 = v710;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v420 + 8))(&qword_18162B0B8, 256, v419, v420);
            ((void (*)(char *, uint64_t *, int **))v67[3])(v421, v271, v67);
            LOBYTE(v421) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4) + 8)
                                                                                + 32))(v418, v410, v271);
            v422 = v724;
            ((void (*)(int **, uint64_t *))v724)(v410, v271);
            if ((v421 & 1) == 0) {
              goto LABEL_275;
            }
            ((void (*)(char *, uint64_t *))v422)(v418, v271);
            v416 = v687;
            int64_t v417 = v707;
          }
          char v423 = (uint64_t (*)(uint64_t *, char *))*((void *)v281 + 16);
          uint64_t v424 = v416;
          if (v423(v271, v281) < 16) {
            goto LABEL_249;
          }
          uint64_t v425 = v670;
          v707 = *(const char **)(v712 + 16);
          ((void (*)(char *, char *, uint64_t *))v707)(v670, v424, v271);
          LOWORD(v727) = -1;
          char v426 = ((uint64_t (*)(uint64_t *, char *))v417)(v271, v281);
          uint64_t v427 = v423(v271, v281);
          if (v426)
          {
            uint64_t v430 = v718;
            v431 = v724;
            if (v427 <= 16)
            {
              v432 = v716;
              uint64_t v433 = v711;
              uint64_t v434 = swift_getAssociatedConformanceWitness((uint64_t)v716, (uint64_t)v271, (uint64_t)v711, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v435 = v710;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v434 + 8))(&qword_18162B0B8, 256, v433, v434);
              ((void (*)(char *, uint64_t *, int **))v432[3])(v435, v271, v432);
              LOBYTE(v432) = (*(uint64_t (**)(char *, int **, uint64_t *))(*(void *)(*((void *)v281 + 4)
                                                                                              + 8)
                                                                                  + 40))(v425, v430, v271);
              ((void (*)(int **, uint64_t *))v431)(v430, v271);
              unsigned int v436 = (unsigned __int16)v727;
              char v437 = v661;
              ((void (*)(char *, char *, uint64_t *))v707)(v661, v425, v271);
              if (v432)
              {
                unsigned __int16 v438 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
                ((void (*)(char *, uint64_t *))v431)(v437, v271);
                if (v436 < v438) {
                  goto LABEL_235;
                }
              }
              else
              {
                ((void (*)(char *, uint64_t *))v431)(v437, v271);
              }
              goto LABEL_248;
            }
          }
          else
          {
            uint64_t v430 = v718;
            v431 = v724;
            if (v427 <= 16)
            {
              ((void (*)(int **, char *, uint64_t *))v707)(v718, v425, v271);
              unsigned __int16 v472 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
              ((void (*)(int **, uint64_t *))v431)(v430, v271);
              if ((unsigned __int16)v727 < v472) {
                goto LABEL_235;
              }
LABEL_248:
              ((void (*)(char *, uint64_t *))v431)(v425, v271);
              uint64_t v424 = v687;
LABEL_249:
              int v476 = (*((uint64_t (**)(uint64_t *, char *))v281 + 15))(v271, v281);
              ((void (*)(char *, uint64_t *))v724)(v424, v271);
              uint64_t v477 = v725;
              uint64_t v479 = v714;
              unint64_t v478 = v715;
              uint64_t v480 = v720;
LABEL_250:
              uint64_t v599 = v708 | v476;
              char v601 = 0;
              uint64_t v600 = (uint64_t)v709;
              goto LABEL_251;
            }
          }
          uint64_t v468 = (void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v281 + 12);
          unint64_t v469 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v427, v428, v429);
          v468(&v727, &type metadata for UInt16, v469, v271, v281);
          char v470 = (*(uint64_t (**)(int **, char *, uint64_t *))(*(void *)(*((void *)v281 + 4) + 8) + 16))(v430, v425, v271);
          ((void (*)(int **, uint64_t *))v431)(v430, v271);
          if (v470) {
            goto LABEL_235;
          }
          goto LABEL_248;
        }
        v282 = (int **)*((void *)v279 + 2);
        uint64_t v719 = (uint64_t)(v279 + 4);
        uint64_t v720 = v282;
        ((void (*)(char *, uint64_t *, uint64_t))v282)(v681, v271, v71);
        int64_t v727 = -1;
        char v283 = ((uint64_t (*)(uint64_t, int **))v272)(v71, v67);
        uint64_t v284 = ((uint64_t (*)(uint64_t, int **))v280)(v71, v67);
        if (v283)
        {
          uint64_t v281 = v724;
          if (v284 <= 64)
          {
            uint64_t v287 = v709;
            uint64_t v288 = v707;
            uint64_t v289 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v290 = v708;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v289 + 8))(&qword_18162B0B8, 256, v288, v289);
            unint64_t v291 = v723;
            ((void (*)(char *, uint64_t, int **))v287[3])(v290, v71, v287);
            unint64_t v292 = v681;
            LOBYTE(v287) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 40))(v681, v291, v71);
            ((void (*)(unint64_t, uint64_t))v141)(v291, v71);
            unint64_t v293 = v727;
            v294 = v663;
            ((void (*)(char *, char *, uint64_t))v720)(v663, v292, v71);
            if ((v287 & 1) == 0)
            {
              ((void (*)(char *, uint64_t))v141)(v294, v71);
              uint64_t v271 = (uint64_t *)v688;
LABEL_199:
              ((void (*)(char *, uint64_t))v141)(v292, v71);
              goto LABEL_200;
            }
            unint64_t v295 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
            ((void (*)(char *, uint64_t))v141)(v294, v71);
            BOOL v296 = v293 >= v295;
LABEL_132:
            uint64_t v271 = (uint64_t *)v688;
            if (!v296) {
              goto LABEL_235;
            }
            goto LABEL_199;
          }
        }
        else
        {
          uint64_t v281 = v724;
          if (v284 <= 64)
          {
            unint64_t v366 = v723;
            unint64_t v292 = v681;
            ((void (*)(unint64_t, char *, uint64_t))v720)(v723, v681, v71);
            unint64_t v367 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
            ((void (*)(unint64_t, uint64_t))v141)(v366, v71);
            BOOL v296 = v727 >= v367;
            goto LABEL_132;
          }
        }
        uint64_t v348 = v67[12];
        unint64_t v349 = lazy protocol witness table accessor for type UInt and conformance UInt(v284, v285, v286);
        v350 = v141;
        unint64_t v351 = v723;
        ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v348)(&v727, &type metadata for UInt, v349, v71, v67);
        unint64_t v292 = v681;
        char v352 = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*((void *)v67[4] + 1) + 16))(v351, v681, v71);
        unint64_t v353 = v351;
        uint64_t v141 = v350;
        ((void (*)(unint64_t, uint64_t))v350)(v353, v71);
        uint64_t v271 = (uint64_t *)v688;
        if (v352) {
          goto LABEL_235;
        }
        goto LABEL_199;
      }
      int64_t v727 = 0;
      uint64_t v242 = v67[12];
      unint64_t v243 = lazy protocol witness table accessor for type Int and conformance Int(v239, v240, v241);
      unint64_t v244 = v723;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v242)(&v727, &type metadata for Int, v243, v71, v67);
      char v245 = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 16))(v203, v244, v71);
      uint64_t v236 = v138 + 2;
      ((void (*)(unint64_t, uint64_t))v141)(v244, v71);
      char v132 = (void (*)(char *, uint64_t))v720;
      if (v245)
      {
LABEL_63:
        uint64_t v248 = (unint64_t)v236 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        goto LABEL_64;
      }
      while (1)
      {
LABEL_54:
        uint64_t v248 = (uint64_t)v698;
        (*((void (**)(char *, char *, uint64_t))v138 + 4))(v698, v203, v71);
        unint64_t v249 = v717;
        if (((uint64_t (*)(uint64_t, int **))v717)(v71, v67))
        {
          v704 = (int *)v202;
          uint64_t v250 = v679;
          (*((void (**)(char *, uint64_t, uint64_t))v138 + 2))(v679, v248, v71);
          uint64_t v251 = v709;
          uint64_t v252 = v707;
          uint64_t v253 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v254 = v708;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v253 + 8))(&qword_18162B0B8, 256, v252, v253);
          unint64_t v255 = v723;
          ((void (*)(char *, uint64_t, int **))v251[3])(v254, v71, v251);
          LOBYTE(v251) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 32))(v250, v255, v71);
          ((void (*)(unint64_t, uint64_t))v141)(v255, v71);
          if ((v251 & 1) == 0) {
            goto LABEL_275;
          }
          ((void (*)(char *, uint64_t))v141)(v250, v71);
          char v132 = (void (*)(char *, uint64_t))v720;
          unint64_t v249 = v717;
          uint64_t v248 = (uint64_t)v698;
          char v202 = (int **)v704;
        }
        uint64_t v138 = v721;
        if (((uint64_t (*)(uint64_t, int **))v721)(v71, v67) < 64) {
          goto LABEL_121;
        }
        uint64_t v724 = *(char **)(v719 + 16);
        ((void (*)(char *, uint64_t, uint64_t))v724)(v685, v248, v71);
        int64_t v727 = -1;
        char v256 = ((uint64_t (*)(uint64_t, int **))v249)(v71, v67);
        uint64_t v257 = ((uint64_t (*)(uint64_t, int **))v138)(v71, v67);
        v701 = v141;
        if ((v256 & 1) == 0) {
          break;
        }
        if (v257 > 64) {
          goto LABEL_75;
        }
        uint64_t v260 = v709;
        unint64_t v261 = v707;
        uint64_t v262 = swift_getAssociatedConformanceWitness((uint64_t)v709, v71, (uint64_t)v707, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v263 = v708;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v262 + 8))(&qword_18162B0B8, 256, v261, v262);
        unint64_t v264 = v723;
        ((void (*)(char *, uint64_t, int **))v260[3])(v263, v71, v260);
        uint64_t v138 = (int *)v685;
        LOBYTE(v26_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, unint64_t, uint64_t))(*((void *)v67[4] + 1) + 40))(v685, v264, v71);
        char v202 = (int **)(v719 + 8);
        unint64_t v265 = v264;
        char v132 = (void (*)(char *, uint64_t))v701;
        ((void (*)(unint64_t, uint64_t))v701)(v265, v71);
        unint64_t v266 = v727;
        char v267 = v665;
        ((void (*)(char *, int *, uint64_t))v724)(v665, v138, v71);
        if (v260)
        {
          unint64_t v268 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
          v132(v267, v71);
          uint64_t v248 = (uint64_t)v698;
          if (v266 < v268) {
            goto LABEL_235;
          }
        }
        else
        {
          v132(v267, v71);
          uint64_t v248 = (uint64_t)v698;
        }
LABEL_120:
        v356 = v701;
        ((void (*)(int *, uint64_t))v701)(v138, v71);
        uint64_t v141 = v356;
LABEL_121:
        unint64_t v357 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        ((void (*)(uint64_t, uint64_t))v141)(v248, v71);
        v358 = (char *)(v357 + 15);
        if (v357 < 0xFFFFFFFFFFFFFFF1) {
          goto LABEL_201;
        }
        __break(1u);
LABEL_123:
        uint64_t v359 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        ((void (*)(void, uint64_t))v141)(v132, v71);
        char v132 = (void (*)(char *, uint64_t))v720;
        char v203 = v724;
        if (v359 < 0) {
          goto LABEL_64;
        }
      }
      if (v257 <= 64)
      {
        unint64_t v354 = v723;
        uint64_t v138 = (int *)v685;
        ((void (*)(unint64_t, char *, uint64_t))v724)(v723, v685, v71);
        unint64_t v355 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
        ((void (*)(unint64_t, uint64_t))v701)(v354, v71);
        uint64_t v248 = (uint64_t)v698;
        if (v727 < v355) {
          goto LABEL_235;
        }
        goto LABEL_120;
      }
LABEL_75:
      unint64_t v302 = v67[12];
      unint64_t v303 = lazy protocol witness table accessor for type UInt and conformance UInt(v257, v258, v259);
      char v132 = (void (*)(char *, uint64_t))v723;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, int **))v302)(&v727, &type metadata for UInt, v303, v71, v67);
      uint64_t v138 = (int *)v685;
      char v304 = (*(uint64_t (**)(void (*)(char *, uint64_t), char *, uint64_t))(*((void *)v67[4] + 1)
                                                                                              + 16))(v132, v685, v71);
      ((void (*)(void, uint64_t))v701)(v132, v71);
      uint64_t v248 = (uint64_t)v698;
      if (v304) {
        goto LABEL_235;
      }
      goto LABEL_120;
    }
    unint64_t v212 = v723;
    (*((void (**)(unint64_t, char *, uint64_t))v138 + 2))(v723, v203, v71);
    uint64_t v213 = ((uint64_t (*)(uint64_t, int **))v67[15])(v71, v67);
    ((void (*)(unint64_t, uint64_t))v141)(v212, v71);
    if (v727 < v213) {
      goto LABEL_40;
    }
    goto LABEL_43;
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 400))(v725, v65))
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v725, v65))
    {
LABEL_277:
      __int16 v640 = -1024;
      goto LABEL_278;
    }
    __int16 v640 = 31744;
LABEL_278:
    __int16 v639 = v640;
    goto LABEL_279;
  }
  uint64_t v641 = v714;
  uint64_t v642 = *(void (**)(uint64_t, uint64_t))(v714 + 120);
  uint64_t v643 = v725;
  v642(v725, v714);
  uint64_t v644 = v685;
  (*(void (**)(uint64_t, uint64_t))(v65 + 96))(v643, v65);
  v642(v643, v641);
  uint64_t v645 = v720[1];
  ((void (*)(char *, uint64_t))v645)(v644, v643);
  uint64_t v646 = (char *)v717;
  (*(void (**)(uint64_t, uint64_t))(v65 + 104))(v643, v65);
  unint64_t v647 = v681;
  v642(v643, v641);
  ((void (*)(char *, uint64_t))v645)(v646, v643);
  uint64_t v648 = (uint64_t)v713;
  v649 = v695;
  v650 = v721;
  v651 = v706;
  (*((void (**)(int *, char *, uint64_t *, char *))v713 + 26))(v721, v647, v706, v713);
  v652 = *(void (**)(char *, uint64_t *))(v712 + 8);
  v652(v647, v651);
  v652((char *)v650, v651);
  v653 = v702;
  (*(void (**)(char *, uint64_t *, uint64_t))(v648 + 184))(v649, v651, v648);
  v652(v649, v651);
  int v654 = (char *)v715;
  unsigned int v655 = v718;
  (*(void (**)(int **, char *, uint64_t *, uint64_t))(v648 + 192))(v718, v653, v651, v648);
  v652(v653, v651);
  v652((char *)v655, v651);
  LOBYTE(v648) = (*(uint64_t (**)(uint64_t *, uint64_t))(v648 + 120))(v651, v648);
  v652(v654, v651);
  LOWORD(v652) = v648;
  LOBYTE(v648) = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 416))(v643, v65);
  __int16 v656 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(v643, v65);
  uint64_t result = 0;
  __int16 v657 = (unsigned __int16)v652 | (v656 << 15);
  if (v648) {
    __int16 v658 = 32000;
  }
  else {
    __int16 v658 = 32256;
  }
  *(_WORD *)v705 = v657 | v658;
  return result;
}

uint64_t static BinaryFloatingPoint._convert<A>(from:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v812 = (void *)a6;
  v814 = a2;
  v783 = a1;
  v791 = *(uint64_t (**)(uint64_t *, uint64_t))(a4 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  v790 = (char *)&v711 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  v787 = (char *)&v711 - v12;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v14, v13, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v797 = *(void *)(swift_getAssociatedConformanceWitness(a6, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8);
  uint64_t v737 = *(void *)(v797 + 24);
  v789 = *(int ***)(v737 + 16);
  v788 = swift_getAssociatedTypeWitness(0, v789, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v788);
  v779 = (char *)&v711 - v16;
  uint64_t v17 = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v818 = (char *)v17;
  uint64_t v766 = *(void *)(swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8);
  uint64_t v746 = *(int ***)(*(void *)(v766 + 24) + 16);
  v745 = swift_getAssociatedTypeWitness(0, v746, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v745);
  uint64_t v740 = (char *)&v711 - v18;
  v799 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v794 = *(v799 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v799);
  v777 = (char *)&v711 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v804 = (char *)&v711 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v806 = (int *)((char *)&v711 - v24);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v756 = (char *)&v711 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v778 = (char *)&v711 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  unint64_t v755 = (char *)&v711 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v763 = (char *)&v711 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v773 = (char *)&v711 - v34;
  MEMORY[0x1F4188790](v33);
  v803 = (char *)&v711 - v35;
  uint64_t v36 = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v749 = *(uint64_t **)(swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)v36, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)+ 8);
  unint64_t v750 = (void *)v749[3];
  v744 = (int **)v750[2];
  v743 = swift_getAssociatedTypeWitness(0, v744, (uint64_t)v36, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v743);
  v742 = (char *)&v711 - v37;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a3, (uint64_t)&type metadata for Bool, 0, 0);
  uint64_t v39 = MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  v711 = (char *)&v711 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v39);
  uint64_t v712 = (char *)&v711 - v41;
  uint64_t v42 = *(void *)(a5 + 16);
  uint64_t v732 = *(void *)(v42 + 16);
  v759 = *(int ***)(*(void *)(v732 + 8) + 16);
  v757 = swift_getAssociatedTypeWitness(0, v759, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v757);
  v758 = (char *)&v711 - v43;
  uint64_t v771 = a5;
  v735 = *(int ***)(a5 + 8);
  v733 = swift_getAssociatedTypeWitness(0, v735, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  MEMORY[0x1F4188790](v733);
  v734 = (char *)&v711 - v44;
  uint64_t v45 = swift_getAssociatedTypeWitness(255, (int **)v42, a3, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v810 = v42;
  uint64_t v817 = *(void *)(swift_getAssociatedConformanceWitness(v42, a3, (uint64_t)v45, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  uint64_t v741 = *(void *)(v817 + 24);
  uint64_t v753 = *(int ***)(v741 + 16);
  v751 = swift_getAssociatedTypeWitness(0, v753, (uint64_t)v45, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v751);
  v752 = (char *)&v711 - v46;
  uint64_t v47 = v812[2];
  uint64_t v48 = a4;
  uint64_t v49 = swift_getAssociatedTypeWitness(255, (int **)v47, a4, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v47, v48, (uint64_t)v49, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  v811 = *(char **)(AssociatedConformanceWitness + 8);
  v765 = (void (*)(char *, uint64_t *))*((void *)v811 + 3);
  v786 = (int **)*((void *)v765 + 2);
  v784 = swift_getAssociatedTypeWitness(0, v786, (uint64_t)v49, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v784);
  v785 = (char *)&v711 - v50;
  uint64_t v51 = swift_checkMetadataState(0, (uint64_t)v45);
  v808 = (void *)*(v51 - 1);
  uint64_t v52 = MEMORY[0x1F4188790](v51);
  uint64_t v726 = (char *)&v711 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  unint64_t v723 = (char *)&v711 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  v769 = (char *)&v711 - v57;
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  uint64_t v60 = (char *)&v711 - v59;
  uint64_t v61 = MEMORY[0x1F4188790](v58);
  uint64_t v717 = (char *)&v711 - v62;
  uint64_t v63 = MEMORY[0x1F4188790](v61);
  v718 = (char *)&v711 - v64;
  uint64_t v65 = MEMORY[0x1F4188790](v63);
  uint64_t v724 = (char *)&v711 - v66;
  uint64_t v67 = MEMORY[0x1F4188790](v65);
  uint64_t v725 = (char *)&v711 - v68;
  uint64_t v69 = MEMORY[0x1F4188790](v67);
  v809 = (char *)&v711 - v70;
  uint64_t v71 = MEMORY[0x1F4188790](v69);
  v730 = (char *)&v711 - v72;
  uint64_t v73 = MEMORY[0x1F4188790](v71);
  v731 = (char *)&v711 - v74;
  uint64_t v75 = MEMORY[0x1F4188790](v73);
  v805 = (uint64_t (*)(void))((char *)&v711 - v76);
  MEMORY[0x1F4188790](v75);
  v793 = (char *)&v711 - v77;
  v782 = swift_checkMetadataState(0, (uint64_t)v818);
  uint64_t v774 = *(v782 - 1);
  uint64_t v78 = MEMORY[0x1F4188790](v782);
  v801 = (char *)&v711 - ((v79 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  uint64_t v714 = (char *)&v711 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  v798 = (char *)&v711 - v83;
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  v736 = (char *)&v711 - v85;
  uint64_t v86 = MEMORY[0x1F4188790](v84);
  v800 = (char *)&v711 - v87;
  uint64_t v88 = MEMORY[0x1F4188790](v86);
  v776 = (char *)&v711 - v89;
  uint64_t v90 = MEMORY[0x1F4188790](v88);
  uint64_t v747 = (char *)&v711 - v91;
  uint64_t v92 = MEMORY[0x1F4188790](v90);
  v739 = (char *)&v711 - v93;
  uint64_t v94 = MEMORY[0x1F4188790](v92);
  v775 = (char *)&v711 - v95;
  uint64_t v96 = MEMORY[0x1F4188790](v94);
  v762 = (char *)&v711 - v97;
  MEMORY[0x1F4188790](v96);
  v767 = (char *)&v711 - v98;
  v781 = swift_checkMetadataState(0, (uint64_t)v36);
  uint64_t v768 = *(v781 - 1);
  uint64_t v99 = MEMORY[0x1F4188790](v781);
  v748 = (char *)&v711 - ((v100 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v101 = MEMORY[0x1F4188790](v99);
  v770 = (char *)&v711 - v102;
  uint64_t v103 = MEMORY[0x1F4188790](v101);
  v761 = (int *)((char *)&v711 - v104);
  uint64_t v105 = MEMORY[0x1F4188790](v103);
  v780 = (char *)&v711 - v106;
  uint64_t v816 = a3;
  uint64_t v802 = *(void *)(a3 - 8);
  uint64_t v107 = MEMORY[0x1F4188790](v105);
  v713 = (char *)&v711 - ((v108 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v109 = MEMORY[0x1F4188790](v107);
  uint64_t v111 = (char *)&v711 - v110;
  uint64_t v112 = MEMORY[0x1F4188790](v109);
  v792 = (char *)&v711 - v113;
  uint64_t v114 = MEMORY[0x1F4188790](v112);
  uint64_t v738 = (char *)&v711 - v115;
  uint64_t v116 = MEMORY[0x1F4188790](v114);
  v772 = (char *)&v711 - v117;
  uint64_t v118 = MEMORY[0x1F4188790](v116);
  v760 = (char *)&v711 - v119;
  MEMORY[0x1F4188790](v118);
  uint64_t v121 = (int *)((char *)&v711 - v120);
  uint64_t v122 = swift_checkMetadataState(0, (uint64_t)v49);
  v807 = (void (*)(uint64_t, uint64_t))*(v122 - 1);
  uint64_t v123 = MEMORY[0x1F4188790](v122);
  v715 = (char *)&v711 - ((v124 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v125 = MEMORY[0x1F4188790](v123);
  uint64_t v719 = (char *)&v711 - v126;
  uint64_t v127 = MEMORY[0x1F4188790](v125);
  unint64_t v721 = (char *)&v711 - v128;
  uint64_t v129 = MEMORY[0x1F4188790](v127);
  uint64_t v131 = (char *)&v711 - v130;
  uint64_t v132 = MEMORY[0x1F4188790](v129);
  v716 = (char *)&v711 - v133;
  uint64_t v134 = MEMORY[0x1F4188790](v132);
  uint64_t v754 = (char *)&v711 - v135;
  uint64_t v136 = MEMORY[0x1F4188790](v134);
  uint64_t v722 = (char *)&v711 - v137;
  uint64_t v138 = MEMORY[0x1F4188790](v136);
  uint64_t v720 = (char *)&v711 - v139;
  uint64_t v140 = MEMORY[0x1F4188790](v138);
  v764 = (char *)&v711 - v141;
  uint64_t v142 = MEMORY[0x1F4188790](v140);
  v729 = (char *)&v711 - v143;
  uint64_t v144 = MEMORY[0x1F4188790](v142);
  v728 = (char *)&v711 - v145;
  uint64_t v146 = MEMORY[0x1F4188790](v144);
  v815 = (char *)&v711 - v147;
  MEMORY[0x1F4188790](v146);
  v818 = (char *)&v711 - v148;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v47 + 384))(v48, v47))
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v47 + 168))(v48, v47))
    {
      uint64_t v629 = v735;
      uint64_t v630 = v816;
      v635 = v733;
      uint64_t v636 = swift_getAssociatedConformanceWitness((uint64_t)v735, v816, (uint64_t)v733, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
      v633 = v734;
      (*(void (**)(const char *, uint64_t, double))(v636 + 8))(v635, v636, -0.0);
    }
    else
    {
      uint64_t v629 = v759;
      uint64_t v630 = v816;
      int v631 = v757;
      uint64_t v632 = swift_getAssociatedConformanceWitness((uint64_t)v759, v816, (uint64_t)v757, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v633 = v758;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(v632 + 8))(&qword_18162B0B8, 256, v631, v632);
    }
    ((void (*)(char *, uint64_t, int **))v629[3])(v633, v630, v629);
    return 1;
  }
  uint64_t v795 = v794;
  char v149 = (*(uint64_t (**)(uint64_t, uint64_t))(v47 + 376))(v48, v47);
  uint64_t v813 = v48;
  uint64_t v796 = v47;
  if ((v149 & 1) == 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v47 + 400))(v48, v47) & 1) == 0)
    {
      uint64_t v637 = v47;
      char v638 = v812;
      __int16 v639 = (char *)v812[15];
      ((void (*)(uint64_t, void *))v639)(v48, v812);
      v818 = v639;
      __int16 v640 = *(void (**)(uint64_t, uint64_t))(v47 + 96);
      uint64_t v641 = v787;
      v640(v48, v637);
      ((void (*)(uint64_t, void *))v639)(v48, v638);
      uint64_t v642 = (void (*)(char *, uint64_t))*((void *)v791 + 1);
      v642(v641, v48);
      uint64_t v643 = v790;
      (*(void (**)(uint64_t, uint64_t))(v637 + 104))(v48, v637);
      uint64_t v644 = v777;
      ((void (*)(uint64_t, void *))v818)(v48, v638);
      v642(v643, v48);
      uint64_t v645 = v797;
      uint64_t v646 = v755;
      unint64_t v647 = v804;
      uint64_t v648 = v799;
      (*(void (**)(char *, char *, uint64_t *, uint64_t))(v797 + 208))(v804, v644, v799, v797);
      v649 = *(void (**)(char *, uint64_t *))(v795 + 8);
      v649(v644, v648);
      v649(v647, v648);
      uint64_t v650 = v645;
      v651 = *(void (**)(char *, uint64_t *))(v645 + 184);
      v652 = v773;
      uint64_t v653 = v650;
      v651(v646, v648);
      v649(v646, v648);
      int v654 = v803;
      (*(void (**)(char *, char *, uint64_t *, uint64_t))(v653 + 192))(v803, v652, v648, v653);
      v649(v652, v648);
      v649(v654, v648);
      uint64_t v655 = v810;
      __int16 v656 = v760;
      uint64_t v657 = v816;
      (*(void (**)(uint64_t, uint64_t))(v810 + 120))(v816, v810);
      uint64_t v658 = v771;
      uint64_t v659 = (char *)(v771 + 120);
      v660 = *(void (**)(uint64_t, uint64_t))(v771 + 120);
      v660(v657, v771);
      v662 = (char *)(v802 + 8);
      v661 = *(void (**)(char *, uint64_t))(v802 + 8);
      v661(v656, v657);
      v663 = v792;
      v807 = *(void (**)(uint64_t, uint64_t))(v655 + 96);
      v808 = (void *)(v655 + 96);
      v807(v657, v655);
      v660(v657, v658);
      v661(v663, v657);
      v804 = *(char **)(v655 + 104);
      v805 = (uint64_t (*)(void))(v655 + 104);
      ((void (*)(uint64_t, uint64_t))v804)(v657, v655);
      char v664 = v714;
      v815 = v659;
      v812 = v660;
      v660(v657, v658);
      uint64_t v817 = (uint64_t)v661;
      v818 = v662;
      v661(v111, v657);
      uint64_t v665 = v766;
      unint64_t v666 = *(char **)(v766 + 208);
      uint64_t v667 = v736;
      v668 = v798;
      uint64_t v669 = v782;
      v811 = (char *)(v766 + 208);
      v809 = v666;
      ((void (*)(char *, char *, uint64_t *, uint64_t))v666)(v798, v664, v782, v766);
      uint64_t v670 = v774 + 8;
      v671 = *(void (**)(char *, uint64_t *))(v774 + 8);
      v671(v664, v669);
      v671(v668, v669);
      v672 = v800;
      (*(void (**)(char *, uint64_t *, uint64_t))(v665 + 184))(v667, v669, v665);
      v671(v667, v669);
      v673 = *(void (**)(char *, char *, uint64_t *, uint64_t))(v665 + 192);
      uint64_t v674 = v776;
      v675 = v775;
      v673(v775, v672, v669, v665);
      v671(v672, v669);
      v671(v675, v669);
      (*(void (**)(int *, uint64_t *, uint64_t, uint64_t *, uint64_t))(v665 + 96))(v806, v799, v797, v669, v665);
      v673(v675, v674, v669, v665);
      uint64_t v676 = v771;
      v677 = v675;
      v678 = v671;
      v671(v677, v669);
      uint64_t v774 = v670;
      v671(v674, v669);
      uint64_t v679 = v796;
      uint64_t v680 = v813;
      LOBYTE(v665) = (*(uint64_t (**)(uint64_t, uint64_t))(v796 + 416))(v813, v796);
      LODWORD(v813) = (*(uint64_t (**)(uint64_t, uint64_t))(v679 + 168))(v680, v679) & 1;
      v814 = (char *)(v676 + 56);
      v681 = v760;
      if (v665)
      {
        uint64_t v682 = v810;
        uint64_t v683 = v804;
        ((void (*)(uint64_t, uint64_t))v804)(v657, v810);
      }
      else
      {
        uint64_t v682 = v810;
        uint64_t v683 = (char *)v807;
        v807(v657, v810);
      }
      uint64_t v684 = v770;
      (*(void (**)(uint64_t, uint64_t))(v676 + 112))(v657, v676);
      ((void (*)(char *, uint64_t))v817)(v681, v657);
      uint64_t v685 = v792;
      ((void (*)(uint64_t, uint64_t))v683)(v657, v682);
      uint64_t v686 = v713;
      v687 = v685;
      v688 = v800;
      ((void (*)(uint64_t, uint64_t))v812)(v657, v676);
      ((void (*)(char *, uint64_t))v817)(v687, v657);
      v689 = v775;
      v690 = v801;
      uint64_t v691 = v782;
      ((void (*)(char *, char *, uint64_t *, uint64_t))v809)(v801, v688, v782, v766);
      v678(v688, v691);
      v678(v690, v691);
      (*(void (**)(void, char *, char *, uint64_t, uint64_t))(v676 + 56))(v813, v684, v689, v657, v676);
      (*(void (**)(char *, char *, uint64_t))(v802 + 32))(v783, v686, v657);
      return 0;
    }
    char v634 = (*(uint64_t (**)(uint64_t, uint64_t))(v47 + 168))(v48, v47);
    uint64_t v603 = *(void (**)(uint64_t))(v810 + 112);
    uint64_t v599 = v816;
    uint64_t v586 = v760;
    if (v634)
    {
LABEL_150:
      v603(v599);
      (*(void (**)(char *, uint64_t))(v732 + 16))(v586, v599);
      (*(void (**)(char *, uint64_t))(v802 + 8))(v586, v599);
      return 1;
    }
    v603(v816);
    return 1;
  }
  uint64_t v714 = v131;
  v736 = v60;
  char v150 = v818;
  (*(void (**)(uint64_t, uint64_t))(v47 + 176))(v48, v47);
  uint64_t v151 = v810;
  uint64_t v152 = v816;
  (*(void (**)(uint64_t, uint64_t))(v810 + 152))(v816, v810);
  unint64_t v153 = *(char **)(v151 + 176);
  uint64_t v154 = v793;
  v776 = (char *)(v151 + 176);
  v777 = v153;
  ((void (*)(uint64_t, uint64_t))v153)(v152, v151);
  uint64_t v155 = *(char **)(v802 + 8);
  v806 = v121;
  v798 = (char *)(v802 + 8);
  v787 = v155;
  ((void (*)(int *, uint64_t))v155)(v121, v152);
  uint64_t v156 = v811;
  uint64_t v157 = v811 + 64;
  uint64_t v158 = (uint64_t (*)(uint64_t *, char *))*((void *)v811 + 8);
  LODWORD(v151) = v158(v122, v811);
  uint64_t v159 = v817;
  uint64_t v160 = *(uint64_t (**)(uint64_t *, uint64_t))(v817 + 64);
  v792 = (char *)(v817 + 64);
  v791 = v160;
  int v161 = v160(v51, v817);
  v804 = v157;
  v801 = (char *)v158;
  if (((v151 ^ v161) & 1) == 0)
  {
    v800 = (char *)*((void *)v156 + 16);
    uint64_t v167 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
    v790 = *(char **)(v159 + 128);
    if (v167 < ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v159))
    {
      uint64_t v168 = v807;
      uint64_t v169 = v815;
      (*((void (**)(char *, char *, uint64_t *))v807 + 2))(v815, v150, v122);
      unint64_t v170 = v805;
      (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v159 + 96))(v169, v122, v156, v51, v159);
      char v171 = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v159 + 32) + 8)
                                                                                          + 16))(v170, v154, v51);
      unint64_t v172 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
      v172(v170, v51);
      v172((uint64_t (*)(void))v154, v51);
LABEL_13:
      uint64_t v182 = v816;
      uint64_t v173 = v810;
LABEL_19:
      if (v171) {
        goto LABEL_20;
      }
LABEL_35:
      (*(void (**)(uint64_t, uint64_t))(v173 + 120))(v182, v173);
      uint64_t v253 = v769;
      ((void (*)(uint64_t, uint64_t))v777)(v182, v173);
      char v254 = v791;
      int v255 = v791(v51, v817);
      if ((v255 ^ ((unsigned int (*)(uint64_t *, char *))v801)(v122, v156)))
      {
        char v256 = v156;
        uint64_t v257 = v817;
        char v258 = v254(v51, v817);
        uint64_t v259 = v257;
        uint64_t v156 = v256;
        uint64_t v260 = ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v259);
        uint64_t v261 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v256);
        uint64_t v262 = v813;
        if (v258)
        {
          if (v261 >= v260)
          {
            v305 = v753;
            char v306 = v751;
            uint64_t v307 = swift_getAssociatedConformanceWitness((uint64_t)v753, (uint64_t)v51, (uint64_t)v751, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v308 = v752;
            (*(void (**)(void *, uint64_t, const char *, uint64_t))(v307 + 8))(&qword_18162B0B8, 256, v306, v307);
            unint64_t v309 = v805;
            ((void (*)(char *, uint64_t *, int **))v305[3])(v308, v51, v305);
            uint64_t v310 = v817;
            unint64_t v311 = v769;
            LOBYTE(v305) = (*(uint64_t (**)(char *, uint64_t (*)(void), uint64_t *))(*(void *)(*(void *)(v817 + 32) + 8) + 16))(v769, v309, v51);
            unint64_t v312 = v808;
            v809 = (char *)v808[1];
            ((void (*)(uint64_t (*)(void), uint64_t *))v809)(v309, v51);
            char v313 = v723;
            ((void (*)(char *, char *, uint64_t *))v312[4])(v723, v311, v51);
            char v314 = v721;
            (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v721, v818, v122);
            if (v305)
            {
              (*((void (**)(char *, uint64_t *))v168 + 1))(v314, v122);
              ((void (*)(char *, uint64_t *))v809)(v313, v51);
              uint64_t v262 = v813;
              goto LABEL_79;
            }
            unint64_t v367 = v815;
            (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v156 + 12))(v313, v51, v310, v122, v156);
            char v267 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v367, v314, v122);
            uint64_t v368 = v314;
            unint64_t v369 = (void (*)(char *, uint64_t *))*((void *)v807 + 1);
            uint64_t v168 = v807;
            v369(v367, v122);
            v369(v368, v122);
          }
          else
          {
            char v263 = v815;
            (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v815, v818, v122);
            uint64_t v264 = v817;
            unint64_t v265 = v805;
            (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v263, v122, v156, v51, v817);
            unint64_t v266 = v769;
            char v267 = (*(uint64_t (**)(char *, uint64_t (*)(void), uint64_t *))(*(void *)(*(void *)(v264 + 32) + 8)
                                                                                                + 16))(v769, v265, v51);
            unint64_t v268 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
            v268(v265, v51);
            v268((uint64_t (*)(void))v266, v51);
          }
          uint64_t v262 = v813;
          if (v267)
          {
LABEL_79:
            uint64_t v370 = v816;
            char v371 = (void (*)(char *, uint64_t))v787;
            ((void (*)(int *, uint64_t))v787)(v806, v816);
            (*((void (**)(char *, uint64_t *))v168 + 1))(v818, v122);
            char v372 = (*(uint64_t (**)(uint64_t))(v796 + 168))(v262);
            int64_t v373 = *(void (**)(uint64_t))(v810 + 112);
            if (v372)
            {
              uint64_t v374 = v760;
              v373(v370);
              (*(void (**)(char *, uint64_t))(v732 + 16))(v374, v370);
              v371(v374, v370);
            }
            else
            {
              v373(v370);
            }
            return 0;
          }
LABEL_83:
          unint64_t v375 = (uint64_t (*)(uint64_t *, char *))v801;
          if (((uint64_t (*)(uint64_t *, char *))v801)(v122, v156))
          {
            v376 = v818;
            uint64_t v377 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
            uint64_t v380 = v771;
            if (v377 < 64)
            {
              uint64_t v381 = v815;
              (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v815, v376, v122);
              uint64_t v382 = (*((uint64_t (**)(uint64_t *, char *))v156 + 15))(v122, v156);
              goto LABEL_94;
            }
            uint64_t v819 = 0;
            unint64_t v393 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v156 + 12);
            unint64_t v394 = lazy protocol witness table accessor for type Int and conformance Int(v377, v378, v379);
            unint64_t v395 = v815;
            v393(&v819, &type metadata for Int, v394, v122, v156);
            char v391 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v376, v395, v122);
            BOOL v392 = (void (*)(char *, uint64_t *))*((void *)v807 + 1);
            uint64_t v168 = v807;
            v392(v395, v122);
          }
          else
          {
            char v383 = v375(v122, v156);
            uint64_t v384 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
            uint64_t v380 = v771;
            if ((v383 & 1) == 0)
            {
              if (v384 < 64)
              {
                uint64_t v381 = v815;
                (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v815, v818, v122);
                uint64_t v382 = (*((uint64_t (**)(uint64_t *, char *))v811 + 15))(v122, v811);
LABEL_94:
                uint64_t v396 = v382;
                BOOL v392 = (void (*)(char *, uint64_t *))*((void *)v168 + 1);
                v392(v381, v122);
                if ((v396 & 0x8000000000000000) == 0) {
                  goto LABEL_95;
                }
LABEL_96:
                uint64_t v411 = v759;
                uint64_t v398 = v816;
                uint64_t v412 = v757;
                uint64_t v413 = swift_getAssociatedConformanceWitness((uint64_t)v759, v816, (uint64_t)v757, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                char v414 = v758;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v413 + 8))(&qword_18162B0C0, 512, v412, v413);
                unint64_t v415 = v760;
                ((void (*)(char *, uint64_t, int **))v411[3])(v414, v398, v411);
                v416 = v770;
                (*(void (**)(uint64_t, uint64_t))(v380 + 112))(v398, v380);
                v404 = (void (*)(int *, uint64_t))v787;
                ((void (*)(char *, uint64_t))v787)(v415, v398);
                int64_t v417 = v815;
                uint64_t v418 = v818;
                (*(void (**)(char *, uint64_t *))(*(void *)(AssociatedConformanceWitness + 16) + 16))(v818, v122);
                v392(v418, v122);
                v419 = v748;
                uint64_t v420 = v417;
                unint64_t v410 = (char *)v761;
                uint64_t v407 = v781;
                ((void (*)(char *, uint64_t *, char *, uint64_t *))v749[11])(v420, v122, v811, v781);
                (*(void (**)(char *, char *, uint64_t *))(v750[1] + 40))(v416, v419, v407);
                uint64_t v408 = v768;
                uint64_t v421 = *(void (**)(char *, uint64_t *))(v768 + 8);
                v421(v419, v407);
                v421(v416, v407);
LABEL_97:
                (*(void (**)(char *, char *, uint64_t *))(v408 + 32))(v780, v410, v407);
                v422 = v806;
                uint64_t v423 = (*(uint64_t (**)(uint64_t, uint64_t))(v380 + 136))(v398, v380);
                v404(v422, v398);
                uint64_t v424 = v812;
                uint64_t v425 = v813;
                char v426 = (char *)(v812 + 17);
                v811 = (char *)v812[17];
                uint64_t v817 = ((uint64_t (*)(uint64_t, void *))v811)(v813, v812);
                uint64_t v427 = (char *)v424[15];
                uint64_t v428 = v803;
                v807 = (void (*)(uint64_t, uint64_t))(v424 + 15);
                v815 = v427;
                ((void (*)(uint64_t, void *))v427)(v425, v424);
                uint64_t v429 = v799;
                v805 = *(uint64_t (**)(void))(v797 + 144);
                uint64_t v430 = v805(v799);
                uint64_t v431 = v795 + 8;
                v432 = *(char **)(v795 + 8);
                ((void (*)(char *, uint64_t *))v432)(v428, v429);
                v809 = (char *)v423;
                uint64_t v817 = v423 - v817 - v430;
                LOBYTE(v428) = (*(uint64_t (**)(uint64_t))(v796 + 392))(v425);
                uint64_t v433 = v789;
                uint64_t v434 = v788;
                uint64_t v435 = swift_getAssociatedConformanceWitness((uint64_t)v789, (uint64_t)v429, (uint64_t)v788, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                unsigned int v436 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v435 + 8);
                v806 = (int *)(v433 + 3);
                v818 = v432;
                uint64_t v795 = v431;
                v808 = v426;
                if (v428)
                {
                  char v437 = v779;
                  v436(&qword_18162B0C0, 512, v434, v435);
                  ((void (*)(char *, uint64_t *, int **))v433[3])(v437, v429, v433);
                  unsigned __int16 v438 = v812;
                  uint64_t v439 = ((uint64_t (*)(uint64_t, void *))v811)(v425, v812);
                  uint64_t v440 = v425;
                  uint64_t v441 = v773;
                  uint64_t v442 = v815;
                  ((void (*)(uint64_t, void *))v815)(v440, v438);
                  uint64_t v443 = v797;
                  uint64_t v444 = ((uint64_t (*)(uint64_t *, uint64_t))v805)(v429, v797);
                  uint64_t v445 = v818;
                  uint64_t v446 = ((uint64_t (*)(char *, uint64_t *))v818)(v441, v429);
                  uint64_t v819 = v444 + v439;
                  uint64_t v447 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v443 + 256);
                  unint64_t v450 = lazy protocol witness table accessor for type Int and conformance Int(v446, v448, v449);
                  uint64_t v451 = v803;
                  v447(v803, &v819, &type metadata for Int, v450, v429, v443);
                  ((void (*)(char *, uint64_t *))v445)(v451, v429);
                  uint64_t v452 = v766;
                  uint64_t v453 = v443;
                  uint64_t v454 = v774;
                  v455 = v442;
                }
                else
                {
                  unint64_t v456 = v779;
                  v436((uint64_t *)&qword_18162B0B8, 256, v434, v435);
                  ((void (*)(char *, uint64_t *, int **))v433[3])(v456, v429, v433);
                  uint64_t v452 = v766;
                  uint64_t v453 = v797;
                  uint64_t v454 = v774;
                  uint64_t v441 = v773;
                  v455 = v815;
                }
                uint64_t v457 = (char *)(v453 + 224);
                uint64_t v458 = v817;
                if (v817 < 0)
                {
                  unint64_t v474 = v755;
                  ((void (*)(uint64_t, void *))v455)(v813, v812);
                  int v475 = v763;
                  int v476 = v799;
                  (*(void (**)(char *, char *, uint64_t *, uint64_t))(v453 + 224))(v763, v474, v799, v453);
                  uint64_t v477 = v474;
                  unint64_t v478 = v818;
                  ((void (*)(char *, uint64_t *))v818)(v477, v476);
                  uint64_t v479 = ((uint64_t (*)(char *, uint64_t *))v478)(v475, v476);
                  if (__OFSUB__(0, v458))
                  {
                    __break(1u);
                    goto LABEL_156;
                  }
                  uint64_t v482 = v441;
                  uint64_t v819 = -v458;
                  uint64_t v483 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v453 + 240);
                  unint64_t v484 = lazy protocol witness table accessor for type Int and conformance Int(v479, v480, v481);
                  v485 = v803;
                  v483(v482, &v819, &type metadata for Int, v484, v476, v453);
                  ((void (*)(char *, uint64_t *))v478)(v482, v476);
                  v486 = *(void (**)(char *, uint64_t *, uint64_t))(v452 + 88);
                  unsigned __int16 v471 = v747;
                  int v473 = v782;
                  v486(v485, v476, v453);
                }
                else
                {
                  ((void (*)(uint64_t, void *))v455)(v813, v812);
                  v459 = v803;
                  unsigned int v460 = v763;
                  v461 = v799;
                  (*(void (**)(char *, char *, uint64_t *, uint64_t))(v453 + 224))(v763, v441, v799, v453);
                  unsigned __int16 v462 = v818;
                  ((void (*)(char *, uint64_t *))v818)(v441, v461);
                  ((void (*)(char *, uint64_t *))v462)(v460, v461);
                  BOOL v463 = v775;
                  v464 = v461;
                  v465 = v782;
                  uint64_t v466 = (*(uint64_t (**)(char *, uint64_t *, uint64_t, uint64_t *, uint64_t))(v452 + 88))(v459, v464, v453, v782, v452);
                  uint64_t v819 = v458;
                  char v467 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v452 + 256);
                  unint64_t v470 = lazy protocol witness table accessor for type Int and conformance Int(v466, v468, v469);
                  unsigned __int16 v471 = v747;
                  uint64_t v472 = v452;
                  int v473 = v465;
                  v467(v463, &v819, &type metadata for Int, v470, v465, v472);
                  (*(void (**)(char *, uint64_t *))(v454 + 8))(v463, v465);
                }
                uint64_t v487 = v767;
                (*(void (**)(char *, char *, uint64_t *))(v454 + 32))(v767, v471, v473);
                uint64_t v488 = v796;
LABEL_126:
                uint64_t v580 = v813;
                v579 = v814;
                v807 = *(void (**)(uint64_t, uint64_t))(v488 + 168);
                v808 = (void *)(v488 + 168);
                uint64_t v581 = ((uint64_t (*)(uint64_t, uint64_t))v807)(v813, v488) & 1;
                char v582 = v770;
                (*(void (**)(char *, char *, uint64_t *))(v768 + 32))(v770, v780, v781);
                v583 = v775;
                (*(void (**)(char *, char *, uint64_t *))(v454 + 16))(v775, v487, v473);
                v584 = v772;
                uint64_t v585 = v581;
                uint64_t v586 = v579;
                char v587 = v583;
                uint64_t v588 = v816;
                (*(void (**)(uint64_t, char *, char *, uint64_t))(v771 + 56))(v585, v582, v587, v816);
                uint64_t v589 = v812;
                uint64_t v590 = ((uint64_t (*)(uint64_t, void *))v811)(v580, v812);
                if ((uint64_t)v809 < v590)
                {
                  unsigned int v591 = v789;
                  v592 = v799;
                  unsigned __int16 v593 = v788;
                  uint64_t v594 = swift_getAssociatedConformanceWitness((uint64_t)v789, (uint64_t)v799, (uint64_t)v788, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  unsigned __int16 v595 = (char *)(v594 + 8);
                  unsigned __int16 v596 = v779;
                  v811 = *(char **)(v594 + 8);
                  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v811)(&qword_18162B0C0, 512, v593, v594);
                  uint64_t v597 = v591[3];
                  int v598 = v803;
                  uint64_t v599 = (uint64_t)v592;
                  v809 = (char *)(v591 + 3);
                  v806 = v597;
                  uint64_t v600 = ((uint64_t (*)(char *, uint64_t *, int **))v597)(v596, v592, v591);
                  if (!__OFSUB__(0, v817))
                  {
                    uint64_t v819 = -v817;
                    uint64_t v604 = v797;
                    v805 = (uint64_t (*)(void))v594;
                    uint64_t v605 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v797 + 256);
                    unint64_t v606 = lazy protocol witness table accessor for type Int and conformance Int(v600, v601, v602);
                    v605(v598, &v819, &type metadata for Int, v606, v592, v604);
                    v804 = v595;
                    v607 = v818;
                    ((void (*)(char *, uint64_t *))v818)(v598, v592);
                    ((void (*)(uint64_t, void *))v815)(v813, v589);
                    uint64_t v608 = v779;
                    ((void (*)(uint64_t *, uint64_t))v811)(&qword_18162B0C0, 512);
                    uint64_t v609 = v755;
                    unint64_t v610 = v608;
                    char v611 = v806;
                    ((void (*)(char *, uint64_t *, int **))v806)(v608, v592, v789);
                    uint64_t v612 = v773;
                    (*(void (**)(char *, char *, uint64_t *))(*(void *)(v737 + 8) + 40))(v778, v609, v592);
                    ((void (*)(char *, uint64_t *))v607)(v609, v592);
                    uint64_t v613 = v756;
                    (*(void (**)(char *, char *, uint64_t *, uint64_t))(v604 + 192))(v598, v612, v592, v604);
                    ((void (*)(char *, uint64_t *))v607)(v612, v592);
                    ((void (*)(char *, uint64_t *))v607)(v598, v592);
                    ((void (*)(void *, uint64_t))v811)(&unk_18162B0D0, 768);
                    ((void (*)(char *, uint64_t *, int **))v611)(v610, v592, v789);
                    uint64_t v817 = *(void *)(v604 + 152);
                    ((void (*)(char *, char *, uint64_t *, uint64_t))v817)(v778, v612, v592, v604);
                    ((void (*)(char *, uint64_t *))v607)(v612, v592);
                    uint64_t v614 = *(void *)(v604 + 32);
                    unint64_t v615 = v613;
                    uint64_t v616 = *(void *)(v614 + 8);
                    LOBYTE(v612) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v616 + 16))(v615, v598, v592, v616);
                    ((void (*)(char *, uint64_t *))v607)(v598, v592);
                    v617 = v779;
                    if (v612)
                    {
                      ((void (*)(char *, uint64_t *))v607)(v615, v592);
                      ((void (*)(char *, uint64_t *))v607)(v778, v592);
                      (*(void (**)(char *, uint64_t *))(v774 + 8))(v767, v782);
                      (*(void (**)(char *, char *, uint64_t))(v802 + 32))(v783, v772, v816);
                    }
                    else
                    {
                      if (((uint64_t (*)(uint64_t, uint64_t))v807)(v813, v796)) {
                        (*(void (**)(uint64_t))(v810 + 328))(v816);
                      }
                      else {
                        (*(void (**)(uint64_t))(v810 + 320))(v816);
                      }
                      uint64_t v619 = v797;
                      unint64_t v620 = v773;
                      unint64_t v621 = v778;
                      unint64_t v622 = v806;
                      ((void (*)(void *, uint64_t))v811)(&unk_18162B0D0, 768);
                      v623 = v799;
                      ((void (*)(char *, uint64_t *, int **))v622)(v617, v799, v789);
                      uint64_t v624 = v803;
                      ((void (*)(char *, char *, uint64_t *, uint64_t))v817)(v621, v620, v623, v619);
                      uint64_t v625 = v818;
                      ((void (*)(char *, uint64_t *))v818)(v620, v623);
                      ((void (*)(char *, uint64_t *))v625)(v621, v623);
                      uint64_t v626 = v756;
                      LOBYTE(v619) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v616 + 40))(v756, v624, v623, v616);
                      ((void (*)(char *, uint64_t *))v625)(v624, v623);
                      ((void (*)(char *, uint64_t *))v625)(v626, v623);
                      if (v619)
                      {
                        uint64_t v627 = v816;
                        ((void (*)(char *, uint64_t))v787)(v772, v816);
                        (*(void (**)(char *, uint64_t *))(v774 + 8))(v767, v782);
                        (*(void (**)(char *, char *, uint64_t))(v802 + 32))(v783, v738, v627);
                      }
                      else
                      {
                        uint64_t v692 = v766;
                        uint64_t v693 = *(uint64_t (**)(uint64_t *, uint64_t))(v766 + 144);
                        v694 = v767;
                        v695 = v782;
                        uint64_t v696 = v693(v782, v766);
                        v697 = *(void (**)(char *, uint64_t *))(v774 + 8);
                        v697(v694, v695);
                        v698 = v775;
                        uint64_t v699 = v816;
                        (*(void (**)(uint64_t))(v771 + 120))(v816);
                        uint64_t v700 = v693(v695, v692);
                        v697(v698, v695);
                        v701 = (void (**)(char *, char *, uint64_t))(v802 + 32);
                        if (v700 >= v696)
                        {
                          ((void (*)(char *, uint64_t))v787)(v772, v699);
                          v702 = *v701;
                          v703 = v711;
                          (*v701)(v711, v738, v699);
                        }
                        else
                        {
                          ((void (*)(char *, uint64_t))v787)(v738, v699);
                          v702 = *v701;
                          v703 = v711;
                          (*v701)(v711, v772, v699);
                        }
                        v702(v783, v703, v699);
                      }
                    }
                    return 0;
                  }
                  __break(1u);
                  goto LABEL_150;
                }
                (*(void (**)(char *, uint64_t *))(v454 + 8))(v487, v473);
                (*(void (**)(char *, char *, uint64_t))(v802 + 32))(v783, v584, v588);
                return 1;
              }
LABEL_95:
              char v397 = v759;
              uint64_t v398 = v816;
              uint64_t v399 = v757;
              uint64_t v400 = swift_getAssociatedConformanceWitness((uint64_t)v759, v816, (uint64_t)v757, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v401 = v758;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v400 + 8))(&qword_18162B0C0, 512, v399, v400);
              uint64_t v402 = v760;
              ((void (*)(char *, uint64_t, int **))v397[3])(v401, v398, v397);
              uint64_t v403 = v770;
              (*(void (**)(uint64_t, uint64_t))(v380 + 112))(v398, v380);
              v404 = (void (*)(int *, uint64_t))v787;
              ((void (*)(char *, uint64_t))v787)(v402, v398);
              uint64_t v405 = v815;
              (*((void (**)(char *, char *, uint64_t *))v168 + 4))(v815, v818, v122);
              v406 = v748;
              uint64_t v407 = v781;
              ((void (*)(char *, uint64_t *, char *, uint64_t *))v749[11])(v405, v122, v811, v781);
              (*(void (**)(char *, char *, uint64_t *))(v750[1] + 24))(v403, v406, v407);
              uint64_t v408 = v768;
              unint64_t v409 = *(void (**)(char *, uint64_t *))(v768 + 8);
              v409(v406, v407);
              v409(v403, v407);
              unint64_t v410 = (char *)v761;
              goto LABEL_97;
            }
            if (v384 <= 64)
            {
              unint64_t v511 = v786;
              uint64_t v512 = v784;
              uint64_t v513 = swift_getAssociatedConformanceWitness((uint64_t)v786, (uint64_t)v122, (uint64_t)v784, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v514 = v785;
              (*(void (**)(void *, uint64_t, const char *, uint64_t))(v513 + 8))(&qword_18162B0B8, 256, v512, v513);
              uint64_t v515 = v815;
              ((void (*)(char *, uint64_t *, int **))v511[3])(v514, v122, v511);
              uint64_t v516 = (uint64_t (**)(uint64_t *, char *))v811;
              v517 = v818;
              LOBYTE(v512) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v811 + 4)
                                                                                              + 8)
                                                                                  + 16))(v818, v515, v122);
              BOOL v392 = (void (*)(char *, uint64_t *))*((void *)v807 + 1);
              uint64_t v168 = v807;
              v392(v515, v122);
              uint64_t v518 = v715;
              (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v715, v517, v122);
              if (v512)
              {
                v392(v518, v122);
              }
              else
              {
                uint64_t v628 = v516[15](v122, (char *)v516);
                v392(v518, v122);
                if ((v628 & 0x8000000000000000) == 0) {
                  goto LABEL_95;
                }
              }
              goto LABEL_96;
            }
            uint64_t v819 = 0;
            v387 = v811;
            unint64_t v388 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, char *))*((void *)v811 + 12);
            unint64_t v389 = lazy protocol witness table accessor for type Int and conformance Int(v384, v385, v386);
            uint64_t v390 = v815;
            v388(&v819, &type metadata for Int, v389, v122, v387);
            char v391 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v387 + 4) + 8) + 16))(v818, v390, v122);
            BOOL v392 = (void (*)(char *, uint64_t *))*((void *)v168 + 1);
            v392(v390, v122);
          }
          if (v391) {
            goto LABEL_96;
          }
          goto LABEL_95;
        }
        if (v260 >= v261)
        {
          uint64_t v315 = v786;
          uint64_t v316 = v784;
          uint64_t v317 = swift_getAssociatedConformanceWitness((uint64_t)v786, (uint64_t)v122, (uint64_t)v784, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v318 = v785;
          (*(void (**)(void *, uint64_t, const char *, uint64_t))(v317 + 8))(&qword_18162B0B8, 256, v316, v317);
          char v319 = v815;
          ((void (*)(char *, uint64_t *, int **))v315[3])(v318, v122, v315);
          unint64_t v320 = v818;
          LOBYTE(v315) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8)
                                                                              + 40))(v818, v319, v122);
          unint64_t v321 = (void (*)(char *, uint64_t *))*((void *)v807 + 1);
          v321(v319, v122);
          unint64_t v322 = v808;
          char v323 = v726;
          ((void (*)(char *, char *, uint64_t *))v808[4])(v726, v769, v51);
          uint64_t v324 = v719;
          (*((void (**)(char *, char *, uint64_t *))v807 + 2))(v719, v320, v122);
          if (v315)
          {
            uint64_t v325 = v817;
            uint64_t v326 = v805;
            (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v324, v122, v156, v51, v817);
            LOBYTE(v325) = (*(uint64_t (**)(char *, uint64_t (*)(void), uint64_t *))(*(void *)(*(void *)(v325 + 32) + 8) + 16))(v323, v326, v51);
            uint64_t v327 = (void (*)(uint64_t (*)(void), uint64_t *))v322[1];
            v327(v326, v51);
            v327((uint64_t (*)(void))v323, v51);
            uint64_t v168 = v807;
            uint64_t v262 = v813;
            if (v325) {
              goto LABEL_79;
            }
          }
          else
          {
            v321(v324, v122);
            ((void (*)(char *, uint64_t *))v322[1])(v323, v51);
            uint64_t v168 = v807;
          }
          goto LABEL_83;
        }
        unint64_t v273 = v815;
        (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v156 + 12))(v769, v51, v817, v122, v156);
      }
      else
      {
        uint64_t v269 = v817;
        uint64_t v270 = ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v817);
        uint64_t v271 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
        uint64_t v262 = v813;
        if (v270 >= v271)
        {
          char v275 = v815;
          (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v815, v818, v122);
          uint64_t v276 = v262;
          uint64_t v277 = v805;
          (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v269 + 96))(v275, v122, v156, v51, v269);
          LOBYTE(v275) = (*(uint64_t (**)(char *, uint64_t (*)(void), uint64_t *))(*(void *)(*(void *)(v269 + 32) + 8) + 16))(v253, v277, v51);
          unint64_t v278 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
          uint64_t v279 = v277;
          uint64_t v262 = v276;
          v278(v279, v51);
          v278((uint64_t (*)(void))v253, v51);
          if (v275) {
            goto LABEL_79;
          }
          goto LABEL_83;
        }
        uint64_t v272 = v253;
        unint64_t v273 = v815;
        (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v156 + 12))(v272, v51, v269, v122, v156);
      }
      char v274 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v273, v818, v122);
      (*((void (**)(char *, uint64_t *))v168 + 1))(v273, v122);
      if (v274) {
        goto LABEL_79;
      }
      goto LABEL_83;
    }
    uint64_t v165 = v815;
    (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v156 + 12))(v154, v51, v159, v122, v156);
    char v166 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v150, v165, v122);
LABEL_12:
    char v171 = v166;
    uint64_t v168 = v807;
    (*((void (**)(char *, uint64_t *))v807 + 1))(v165, v122);
    goto LABEL_13;
  }
  char v162 = v158(v122, v156);
  v800 = (char *)*((void *)v156 + 16);
  uint64_t v163 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
  v790 = *(char **)(v159 + 128);
  uint64_t v164 = ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v159);
  if ((v162 & 1) == 0)
  {
    uint64_t v173 = v810;
    uint64_t v168 = v807;
    char v174 = (char *)v805;
    if (v163 >= v164)
    {
      char v193 = v753;
      unint64_t v194 = v751;
      uint64_t v195 = swift_getAssociatedConformanceWitness((uint64_t)v753, (uint64_t)v51, (uint64_t)v751, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v196 = v752;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(v195 + 8))(&qword_18162B0B8, 256, v194, v195);
      ((void (*)(char *, uint64_t *, int **))v193[3])(v196, v51, v193);
      uint64_t v197 = v793;
      LOBYTE(v193) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v817 + 32) + 8)
                                                                          + 40))(v793, v174, v51);
      int64_t v198 = v808;
      uint64_t v199 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
      v199((uint64_t (*)(void))v174, v51);
      BOOL v200 = v729;
      (*((void (**)(char *, char *, uint64_t *))v168 + 2))(v729, v818, v122);
      char v201 = (void (*)(char *, char *, uint64_t *))v198[4];
      char v202 = v730;
      v201(v730, v197, v51);
      if ((v193 & 1) == 0)
      {
        v199((uint64_t (*)(void))v202, v51);
        (*((void (**)(char *, uint64_t *))v168 + 1))(v200, v122);
        uint64_t v182 = v816;
        uint64_t v156 = v811;
        goto LABEL_35;
      }
      char v203 = v200;
      uint64_t v156 = v811;
      uint64_t v204 = v202;
      uint64_t v205 = v815;
      (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v811 + 12))(v204, v51, v817, v122, v811);
      char v171 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v203, v205, v122);
      unint64_t v179 = (void (*)(char *, uint64_t *))*((void *)v168 + 1);
      v179(v205, v122);
      unint64_t v180 = v203;
      char v181 = v122;
    }
    else
    {
      uint64_t v175 = v815;
      (*((void (**)(char *, char *, uint64_t *))v807 + 2))(v815, v818, v122);
      uint64_t v176 = v817;
      uint64_t v177 = v174;
      uint64_t v156 = v811;
      (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v175, v122, v811, v51, v817);
      unint64_t v178 = v793;
      char v171 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v176 + 32) + 8) + 16))(v177, v793, v51);
      unint64_t v179 = (void (*)(char *, uint64_t *))v808[1];
      v179(v177, v51);
      unint64_t v180 = v178;
      char v181 = v51;
    }
    v179(v180, v181);
    uint64_t v182 = v816;
    goto LABEL_19;
  }
  if (v164 < v163)
  {
    uint64_t v156 = v811;
    uint64_t v165 = v815;
    (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v811 + 12))(v154, v51, v159, v122, v811);
    char v166 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v818, v165, v122);
    goto LABEL_12;
  }
  uint64_t v183 = v786;
  uint64_t v184 = v784;
  uint64_t v185 = swift_getAssociatedConformanceWitness((uint64_t)v786, (uint64_t)v122, (uint64_t)v784, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v186 = v785;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v185 + 8))(&qword_18162B0B8, 256, v184, v185);
  unint64_t v187 = v815;
  ((void (*)(char *, uint64_t *, int **))v183[3])(v186, v122, v183);
  uint64_t v156 = v811;
  uint64_t v188 = v818;
  LOBYTE(v183) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v811 + 4) + 8) + 16))(v818, v187, v122);
  uint64_t v189 = v807;
  v730 = (char *)*((void *)v807 + 1);
  ((void (*)(char *, uint64_t *))v730)(v187, v122);
  char v190 = v728;
  (*((void (**)(char *, char *, uint64_t *))v189 + 2))(v728, v188, v122);
  BOOL v191 = v808;
  unint64_t v192 = v731;
  ((void (*)(char *, char *, uint64_t *))v808[4])(v731, v154, v51);
  uint64_t v182 = v816;
  if (v183)
  {
    ((void (*)(char *, uint64_t *))v191[1])(v192, v51);
    ((void (*)(char *, uint64_t *))v730)(v190, v122);
    uint64_t v173 = v810;
    uint64_t v168 = v807;
    goto LABEL_20;
  }
  uint64_t v250 = v817;
  uint64_t v251 = v805;
  (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v190, v122, v156, v51, v817);
  LODWORD(v793) = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v250 + 32) + 8)
                                                                                               + 16))(v251, v192, v51);
  uint64_t v252 = (void (*)(uint64_t (*)(void), uint64_t *))v191[1];
  v252(v251, v51);
  v252((uint64_t (*)(void))v192, v51);
  uint64_t v173 = v810;
  uint64_t v168 = v807;
  if ((v793 & 1) == 0) {
    goto LABEL_35;
  }
LABEL_20:
  (*(void (**)(uint64_t, uint64_t))(v173 + 160))(v182, v173);
  ((void (*)(uint64_t, uint64_t))v777)(v182, v173);
  uint64_t v206 = v786;
  uint64_t v207 = v784;
  uint64_t v208 = swift_getAssociatedConformanceWitness((uint64_t)v786, (uint64_t)v122, (uint64_t)v784, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v209 = *(char **)(v208 + 8);
  char v210 = v785;
  v777 = (char *)v208;
  v776 = (char *)(v208 + 8);
  v769 = v209;
  ((void (*)(uint64_t *, uint64_t, const char *))v209)(&qword_18162B0C0, 512, v207);
  unint64_t v211 = v206[3];
  unint64_t v212 = v815;
  v763 = (char *)(v206 + 3);
  v761 = v211;
  ((void (*)(char *, uint64_t *, int **))v211)(v210, v122, v206);
  uint64_t v213 = *((void *)v765 + 1);
  uint64_t v214 = *(void **)(v213 + 24);
  __int16 v215 = v764;
  v765 = (void (*)(char *, uint64_t *))v213;
  v760 = (char *)(v213 + 24);
  unint64_t v750 = v214;
  ((void (*)(char *, char *, uint64_t *))v214)(v818, v212, v122);
  uint64_t v216 = (char *)v168 + 8;
  uint64_t v217 = (void (*)(char *, uint64_t *))*((void *)v168 + 1);
  v217(v212, v122);
  uint64_t v218 = (uint64_t (*)(uint64_t *, char *))v801;
  LODWORD(v212) = ((uint64_t (*)(uint64_t *, char *))v801)(v122, v156);
  int v219 = v791(v51, v817);
  v793 = v216;
  if ((v212 ^ v219))
  {
    char v220 = v218(v122, v156);
    uint64_t v749 = v122;
    uint64_t v221 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
    unint64_t v222 = v809;
    uint64_t v223 = v51;
    uint64_t v224 = ((uint64_t (*)(uint64_t *))v790)(v51);
    char v225 = v215;
    if (v220)
    {
      if (v224 < v221)
      {
        unint64_t v226 = v805;
        ((void (*)(uint64_t (*)(void), char *, uint64_t *))v808[2])(v805, v222, v51);
        uint64_t v156 = v811;
        char v227 = v815;
        uint64_t v228 = v226;
        uint64_t v229 = v225;
        uint64_t v230 = v817;
        uint64_t v122 = v749;
        (*((void (**)(uint64_t (*)(void), uint64_t *, uint64_t, uint64_t *, char *))v811 + 12))(v228, v51, v817, v749, v811);
        char v231 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v229, v227, v122);
        uint64_t v232 = v227;
        unint64_t v233 = v808;
        v217(v232, v122);
        v217(v229, v122);
        if ((v231 & 1) == 0) {
          goto LABEL_64;
        }
LABEL_59:
        ((void (*)(char *, uint64_t *))v233[1])(v222, v51);
        uint64_t v333 = v816;
        ((void (*)(int *, uint64_t))v787)(v806, v816);
        v217(v818, v122);
        if ((*(uint64_t (**)(uint64_t))(v796 + 168))(v813))
        {
          char v334 = v735;
          uint64_t v338 = v733;
          uint64_t v339 = swift_getAssociatedConformanceWitness((uint64_t)v735, v333, (uint64_t)v733, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
          uint64_t v337 = v734;
          (*(void (**)(const char *, uint64_t, double))(v339 + 8))(v338, v339, -0.0);
        }
        else
        {
          char v334 = v759;
          uint64_t v335 = v757;
          uint64_t v336 = swift_getAssociatedConformanceWitness((uint64_t)v759, v333, (uint64_t)v757, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v337 = v758;
          (*(void (**)(void *, uint64_t, const char *, uint64_t))(v336 + 8))(&qword_18162B0B8, 256, v335, v336);
        }
        ((void (*)(char *, uint64_t, int **))v334[3])(v337, v333, v334);
        return 0;
      }
      char v280 = v785;
      uint64_t v281 = v222;
      v282 = v808;
      ((void (*)(void *, uint64_t))v769)(&qword_18162B0B8, 256);
      char v283 = v815;
      uint64_t v122 = v749;
      ((void (*)(char *, uint64_t *, int **))v761)(v280, v749, v786);
      uint64_t v284 = v811;
      LOBYTE(v28_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v811 + 4) + 8)
                                                                          + 16))(v225, v283, v122);
      v217(v283, v122);
      uint64_t v285 = v720;
      (*((void (**)(char *, char *, uint64_t *))v807 + 4))(v720, v225, v122);
      uint64_t v286 = v282;
      unint64_t v222 = v281;
      uint64_t v287 = v725;
      uint64_t v288 = v281;
      uint64_t v51 = v223;
      ((void (*)(char *, char *, uint64_t *))v286[2])(v725, v288, v223);
      if (v280)
      {
        uint64_t v289 = v287;
        unint64_t v233 = v808;
        ((void (*)(char *, uint64_t *))v808[1])(v289, v223);
        v217(v285, v122);
        goto LABEL_59;
      }
      uint64_t v230 = v817;
      char v328 = v805;
      (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v285, v122, v284, v223, v817);
      char v244 = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v230 + 32) + 8)
                                                                                          + 16))(v328, v287, v223);
      short float v329 = v808;
      uint64_t v330 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
      unint64_t v331 = v328;
      unint64_t v222 = v809;
      v330(v331, v51);
      v332 = v287;
      unint64_t v233 = v329;
      v330((uint64_t (*)(void))v332, v51);
      uint64_t v156 = v811;
LABEL_58:
      if ((v244 & 1) == 0) {
        goto LABEL_64;
      }
      goto LABEL_59;
    }
    if (v221 < v224)
    {
      uint64_t v230 = v817;
      uint64_t v242 = v805;
      uint64_t v122 = v749;
      uint64_t v156 = v811;
      (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v215, v749, v811, v51, v817);
      unint64_t v243 = v809;
      char v244 = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v230 + 32) + 8)
                                                                                          + 16))(v242, v809, v51);
      unint64_t v233 = v808;
      char v245 = v242;
      unint64_t v222 = v243;
      ((void (*)(uint64_t (*)(void), uint64_t *))v808[1])(v245, v51);
      goto LABEL_58;
    }
    uint64_t v290 = v753;
    unint64_t v291 = v751;
    uint64_t v292 = swift_getAssociatedConformanceWitness((uint64_t)v753, (uint64_t)v51, (uint64_t)v751, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    unint64_t v293 = v752;
    (*(void (**)(void *, uint64_t, const char *, uint64_t))(v292 + 8))(&qword_18162B0B8, 256, v291, v292);
    v294 = v805;
    ((void (*)(char *, uint64_t *, int **))v290[3])(v293, v51, v290);
    unint64_t v295 = v809;
    LOBYTE(v29_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, uint64_t (*)(void), uint64_t *))(*(void *)(*(void *)(v817 + 32) + 8)
                                                                                                + 40))(v809, v294, v51);
    BOOL v296 = v808;
    char v297 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
    unint64_t v298 = v294;
    unint64_t v222 = v295;
    v297(v298, v51);
    char v299 = v722;
    uint64_t v122 = v749;
    (*((void (**)(char *, char *, uint64_t *))v807 + 4))(v722, v225, v749);
    uint64_t v300 = (void (*)(char *, char *, uint64_t *))v296[2];
    v301 = v724;
    v300(v724, v222, v51);
    if ((v290 & 1) == 0)
    {
      v297((uint64_t (*)(void))v301, v51);
      v217(v299, v122);
      uint64_t v156 = v811;
      uint64_t v230 = v817;
      goto LABEL_64;
    }
    uint64_t v156 = v811;
    unint64_t v302 = v299;
    unint64_t v303 = v815;
    (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v811 + 12))(v301, v51, v817, v122, v811);
    char v304 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8) + 16))(v302, v303, v122);
    v217(v303, v122);
    v217(v302, v122);
    uint64_t v230 = v817;
    unint64_t v233 = v808;
    if (v304) {
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v234 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
    uint64_t v230 = v817;
    char v235 = v809;
    uint64_t v236 = ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v817);
    unint64_t v237 = v808;
    if (v234 >= v236)
    {
      unint64_t v246 = v805;
      ((void (*)(uint64_t (*)(void), char *, uint64_t *))v808[2])(v805, v235, v51);
      uint64_t v247 = v815;
      (*((void (**)(uint64_t (*)(void), uint64_t *, uint64_t, uint64_t *, char *))v156 + 12))(v246, v51, v817, v122, v156);
      LOBYTE(v246) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 4) + 8)
                                                                          + 16))(v215, v247, v122);
      uint64_t v248 = v247;
      uint64_t v230 = v817;
      v217(v248, v122);
      unint64_t v249 = v215;
      unint64_t v233 = v237;
      unint64_t v222 = v809;
      v217(v249, v122);
      if (v246) {
        goto LABEL_59;
      }
    }
    else
    {
      char v238 = v805;
      uint64_t v239 = v215;
      unint64_t v233 = v808;
      (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v230 + 96))(v239, v122, v156, v51, v230);
      char v240 = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v230 + 32) + 8)
                                                                                          + 16))(v238, v809, v51);
      uint64_t v241 = v238;
      unint64_t v222 = v809;
      ((void (*)(uint64_t (*)(void), uint64_t *))v233[1])(v241, v51);
      if (v240) {
        goto LABEL_59;
      }
    }
  }
LABEL_64:
  uint64_t v340 = v785;
  ((void (*)(uint64_t *, uint64_t))v769)(&qword_18162B0C0, 512);
  uint64_t v341 = v815;
  ((void (*)(char *, uint64_t *, int **))v761)(v340, v122, v786);
  uint64_t v342 = v754;
  ((void (*)(char *, char *, uint64_t *, void (*)(char *, uint64_t *)))v750)(v818, v341, v122, v765);
  v765 = v217;
  v217(v341, v122);
  uint64_t v343 = (uint64_t (*)(uint64_t *, char *))v801;
  LODWORD(v341) = ((uint64_t (*)(uint64_t *, char *))v801)(v122, v156);
  if ((v341 ^ v791(v51, v230)))
  {
    char v344 = v343(v122, v156);
    uint64_t v345 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
    v346 = v809;
    uint64_t v347 = ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v230);
    if (v344)
    {
      uint64_t v348 = v765;
      if (v347 < v345)
      {
        unint64_t v349 = v346;
        v350 = v808;
        unint64_t v351 = v805;
        ((void (*)(uint64_t (*)(void), char *, uint64_t *))v808[2])(v805, v349, v51);
        char v352 = v811;
        unint64_t v353 = v815;
        (*((void (**)(uint64_t (*)(void), uint64_t *, uint64_t, uint64_t *, char *))v811 + 12))(v351, v51, v817, v122, v811);
        char v354 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v352 + 2) + 8) + 8))(v342, v353, v122);
        v348(v353, v122);
        v348(v342, v122);
        unint64_t v355 = v812;
        goto LABEL_75;
      }
      uint64_t v489 = v785;
      ((void (*)(void *, uint64_t))v769)(&qword_18162B0B8, 256);
      uint64_t v490 = v815;
      ((void (*)(char *, uint64_t *, int **))v761)(v489, v122, v786);
      LOBYTE(v489) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v811 + 4) + 8)
                                                                          + 32))(v342, v490, v122);
      v348(v490, v122);
      uint64_t v491 = v716;
      (*((void (**)(char *, char *, uint64_t *))v807 + 4))(v716, v342, v122);
      v492 = v808;
      uint64_t v493 = v718;
      ((void (*)(char *, char *, uint64_t *))v808[2])(v718, v346, v51);
      if (v489)
      {
        uint64_t v494 = v817;
        v495 = v805;
        (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v491, v122, v811, v51, v817);
        char v496 = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v494 + 16) + 8)
                                                                                            + 8))(v495, v493, v51);
        uint64_t v497 = (void (*)(uint64_t (*)(void), uint64_t *))v492[1];
        v497(v495, v51);
        v497((uint64_t (*)(void))v493, v51);
        unint64_t v355 = v812;
        v350 = v492;
        uint64_t v360 = v818;
        goto LABEL_109;
      }
      ((void (*)(char *, uint64_t *))v492[1])(v493, v51);
      uint64_t v360 = v818;
    }
    else
    {
      uint64_t v360 = v818;
      unint64_t v361 = v805;
      if (v345 < v347)
      {
        uint64_t v362 = v817;
        (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 96))(v754, v122, v811, v51, v817);
        LOBYTE(v362) = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v362 + 16) + 8) + 8))(v361, v346, v51);
        v350 = v808;
        ((void (*)(uint64_t (*)(void), uint64_t *))v808[1])(v361, v51);
        unint64_t v355 = v812;
        if (v362) {
          goto LABEL_110;
        }
        goto LABEL_118;
      }
      v498 = v753;
      uint64_t v499 = v751;
      uint64_t v500 = swift_getAssociatedConformanceWitness((uint64_t)v753, (uint64_t)v51, (uint64_t)v751, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v501 = v752;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(v500 + 8))(&qword_18162B0B8, 256, v499, v500);
      ((void (*)(char *, uint64_t *, int **))v498[3])(v501, v51, v498);
      LOBYTE(v498) = (*(uint64_t (**)(char *, uint64_t (*)(void), uint64_t *))(*(void *)(*(void *)(v817 + 32) + 8)
                                                                                                  + 32))(v346, v361, v51);
      uint64_t v502 = v808;
      unint64_t v503 = (void (*)(uint64_t (*)(void), uint64_t *))v808[1];
      v503(v361, v51);
      uint64_t v491 = v714;
      (*((void (**)(char *, char *, uint64_t *))v807 + 4))(v714, v754, v122);
      v504 = v717;
      ((void (*)(char *, char *, uint64_t *))v502[2])(v717, v809, v51);
      if (v498)
      {
        unint64_t v505 = v811;
        char v506 = v815;
        (*((void (**)(char *, uint64_t *, uint64_t, uint64_t *, char *))v811 + 12))(v504, v51, v817, v122, v811);
        char v496 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v505 + 2) + 8) + 8))(v491, v506, v122);
        v507 = v506;
        unint64_t v508 = v765;
        v765(v507, v122);
        v508(v491, v122);
        v350 = v808;
        unint64_t v355 = v812;
LABEL_109:
        if (v496) {
          goto LABEL_110;
        }
        goto LABEL_118;
      }
      v503((uint64_t (*)(void))v504, v51);
    }
    v765(v491, v122);
    v350 = v808;
    unint64_t v355 = v812;
    goto LABEL_118;
  }
  uint64_t v356 = ((uint64_t (*)(uint64_t *, char *))v800)(v122, v156);
  unint64_t v357 = v809;
  if (v356 < ((uint64_t (*)(uint64_t *, uint64_t))v790)(v51, v230))
  {
    v358 = v805;
    (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v230 + 96))(v342, v122, v156, v51, v230);
    char v359 = (*(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v230 + 16) + 8)
                                                                                        + 8))(v358, v357, v51);
    v350 = v808;
    ((void (*)(uint64_t (*)(void), uint64_t *))v808[1])(v358, v51);
    unint64_t v355 = v812;
    uint64_t v360 = v818;
    if (v359) {
      goto LABEL_110;
    }
    goto LABEL_118;
  }
  v350 = v808;
  char v363 = v805;
  ((void (*)(uint64_t (*)(void), char *, uint64_t *))v808[2])(v805, v357, v51);
  unint64_t v364 = v815;
  (*((void (**)(uint64_t (*)(void), uint64_t *, uint64_t, uint64_t *, char *))v156 + 12))(v363, v51, v230, v122, v156);
  char v354 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*((void *)v156 + 2) + 8) + 8))(v342, v364, v122);
  unint64_t v365 = v364;
  unint64_t v366 = v765;
  v765(v365, v122);
  v366(v342, v122);
  unint64_t v355 = v812;
LABEL_75:
  uint64_t v360 = v818;
  if ((v354 & 1) == 0)
  {
LABEL_118:
    ((void (*)(int *, uint64_t))v787)(v806, v816);
    v806 = associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral;
    uint64_t v519 = v744;
    v520 = v781;
    uint64_t v521 = v743;
    uint64_t v522 = swift_getAssociatedConformanceWitness((uint64_t)v744, (uint64_t)v781, (uint64_t)v743, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    char v523 = v742;
    (*(void (**)(void *, uint64_t, const char *, uint64_t))(v522 + 8))(&qword_18162B0B8, 256, v521, v522);
    ((void (*)(char *, uint64_t *, int **))v519[3])(v523, v520, v519);
    uint64_t v524 = v815;
    (*((void (**)(char *, char *, uint64_t *))v807 + 4))(v815, v360, v122);
    uint64_t v525 = (void *)v817;
    uint64_t v526 = v736;
    (*(void (**)(char *, uint64_t *, char *, uint64_t *, uint64_t))(v817 + 88))(v524, v122, v811, v51, v817);
    uint64_t v527 = (uint64_t)v805;
    uint64_t v528 = v809;
    (*(void (**)(char *, char *, uint64_t *))(*(void *)(v741 + 8) + 40))(v526, v809, v51);
    uint64_t v529 = (void (*)(char *, uint64_t *))v350[1];
    v529(v526, v51);
    uint64_t v530 = ((uint64_t (*)(char *, uint64_t *))v529)(v528, v51);
    unint64_t v533 = lazy protocol witness table accessor for type Int and conformance Int(v530, v531, v532);
    lazy protocol witness table accessor for type Int and conformance Int(v533, v534, v535);
    SignedInteger<>.init<A>(_:)(v527, (uint64_t)&type metadata for Int, (uint64_t)v51, v533, v525, (uint64_t)&v819);
    uint64_t v536 = (char *)v819;
    uint64_t v537 = (char *)v355[17];
    uint64_t v538 = v813;
    v808 = v355 + 17;
    v811 = v537;
    uint64_t v539 = ((uint64_t (*)(uint64_t, void *))v537)(v813, v355);
    uint64_t v540 = v803;
    v815 = (char *)v355[15];
    ((void (*)(uint64_t, void *))v815)(v538, v355);
    uint64_t v541 = v799;
    uint64_t v542 = (*(uint64_t (**)(uint64_t *))(v797 + 144))(v799);
    v818 = *(char **)(v795 + 8);
    v795 += 8;
    ((void (*)(char *, uint64_t *))v818)(v540, v541);
    v809 = v536;
    uint64_t v817 = (uint64_t)&v536[-v539 - v542];
    uint64_t v488 = v796;
    LOBYTE(v539) = (*(uint64_t (**)(uint64_t, uint64_t))(v796 + 368))(v538, v796);
    unint64_t v543 = v746;
    v544 = v782;
    v545 = v745;
    uint64_t v546 = swift_getAssociatedConformanceWitness((uint64_t)v746, (uint64_t)v782, (uint64_t)v745, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, v806);
    v547 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v546 + 8);
    if (v539)
    {
      v548 = v740;
      v547(&qword_18162B0C0, 512, v545, v546);
      v549 = v775;
      uint64_t v550 = ((uint64_t (*)(char *, uint64_t *, int **))v543[3])(v548, v544, v543);
      uint64_t v819 = (uint64_t)v809;
      uint64_t v551 = v766;
      uint64_t v457 = (char *)(v766 + 256);
      v552 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v766 + 256);
      unint64_t v555 = lazy protocol witness table accessor for type Int and conformance Int(v550, v553, v554);
      v552(v549, &v819, &type metadata for Int, v555, v544, v551);
      (*(void (**)(char *, uint64_t *))(v774 + 8))(v549, v544);
    }
    else
    {
      uint64_t v457 = v740;
      v547((uint64_t *)&qword_18162B0B8, 256, v545, v546);
      ((void (*)(char *, uint64_t *, int **))v543[3])(v457, v544, v543);
    }
    char v556 = v773;
    uint64_t v557 = v799;
    uint64_t v558 = v817;
    if ((v817 & 0x8000000000000000) == 0)
    {
      uint64_t v559 = v803;
      ((void (*)(uint64_t, void *))v815)(v813, v812);
      uint64_t v560 = v766;
      uint64_t v561 = v775;
      v562 = v782;
      uint64_t v563 = (*(uint64_t (**)(char *, uint64_t *, uint64_t, uint64_t *, uint64_t))(v766 + 88))(v559, v557, v797, v782, v766);
      uint64_t v819 = v558;
      v564 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v560 + 256);
      unint64_t v567 = lazy protocol witness table accessor for type Int and conformance Int(v563, v565, v566);
      char v568 = v739;
      v564(v561, &v819, &type metadata for Int, v567, v562, v560);
      uint64_t v454 = v774;
      (*(void (**)(char *, uint64_t *))(v774 + 8))(v561, v562);
LABEL_125:
      uint64_t v487 = v767;
      v577 = v762;
      (*(void (**)(char *, char *, uint64_t *, uint64_t))(v560 + 208))(v762, v568, v562, v560);
      v578 = *(void (**)(char *, uint64_t *))(v454 + 8);
      v578(v568, v562);
      v578(v577, v562);
      int v473 = v562;
      goto LABEL_126;
    }
    uint64_t v569 = ((uint64_t (*)(uint64_t, void *))v815)(v813, v812);
    if (!__OFSUB__(0, v558))
    {
      uint64_t v819 = -v558;
      uint64_t v572 = v797;
      unsigned __int16 v573 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v797 + 240);
      unint64_t v574 = lazy protocol witness table accessor for type Int and conformance Int(v569, v570, v571);
      unint64_t v575 = v803;
      unint64_t v576 = v799;
      v573(v556, &v819, &type metadata for Int, v574, v799, v572);
      ((void (*)(char *, uint64_t *))v818)(v556, v576);
      uint64_t v560 = v766;
      char v568 = v739;
      v562 = v782;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t *, uint64_t))(v766 + 88))(v575, v576, v572, v782, v766);
      uint64_t v454 = v774;
      goto LABEL_125;
    }
LABEL_156:
    __break(1u);
    goto LABEL_157;
  }
LABEL_110:
  ((void (*)(char *, uint64_t *))v350[1])(v809, v51);
  v765(v360, v122);
  uint64_t v457 = (char *)v813;
  if (!((uint64_t (*)(uint64_t, void *))v355[17])(v813, v355))
  {
LABEL_157:
    ((void (*)(int *, uint64_t))v787)(v806, v816);
    if ((*(uint64_t (**)(char *))(v796 + 168))(v457))
    {
      v704 = v735;
      uint64_t v510 = v816;
      v709 = v733;
      uint64_t v710 = swift_getAssociatedConformanceWitness((uint64_t)v735, v816, (uint64_t)v733, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
      v707 = v734;
      (*(void (**)(const char *, uint64_t, double))(v710 + 8))(v709, v710, -0.0);
    }
    else
    {
      v704 = v759;
      uint64_t v510 = v816;
      v705 = v757;
      uint64_t v706 = swift_getAssociatedConformanceWitness((uint64_t)v759, v816, (uint64_t)v757, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v707 = v758;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(v706 + 8))(&qword_18162B0B8, 256, v705, v706);
    }
    char v509 = v712;
    ((void (*)(char *, uint64_t, int **))v704[3])(v707, v510, v704);
    goto LABEL_164;
  }
  if ((*(uint64_t (**)(char *))(v796 + 168))(v457))
  {
    char v509 = v712;
    v708 = v806;
    uint64_t v510 = v816;
    (*(void (**)(int *, uint64_t))(v732 + 16))(v806, v816);
    ((void (*)(int *, uint64_t))v787)(v708, v510);
  }
  else
  {
    char v509 = v712;
    uint64_t v510 = v816;
    (*(void (**)(char *, int *, uint64_t))(v802 + 32))(v712, v806, v816);
  }
LABEL_164:
  (*(void (**)(char *, char *, uint64_t))(v802 + 32))(v783, v509, v510);
  return 0;
}

uint64_t static BinaryInteger.> infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v87 = a2;
  uint64_t v88 = a1;
  uint64_t v82 = *(int ***)(*(void *)(a5 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v82, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v78 = (char *)&v73 - v10;
  uint64_t v77 = *(int ***)(*(void *)(a6 + 24) + 16);
  uint64_t v76 = swift_getAssociatedTypeWitness(0, v77, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](v76);
  uint64_t v75 = (char *)&v73 - v12;
  uint64_t v86 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v80 = (char *)&v73 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v81 = (char *)&v73 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v84 = (char *)&v73 - v18;
  uint64_t v85 = *(void *)(a4 - 8);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v73 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v73 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v83 = (char *)&v73 - v25;
  uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  int v27 = v26(a4, a6);
  if (((v27 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a5 + 64))(a3, a5)) & 1) == 0)
  {
    uint64_t v39 = v87;
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
    uint64_t v41 = v88;
    BOOL v42 = v40 < (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
    uint64_t v32 = v41;
    uint64_t v43 = v39;
    if (!v42)
    {
      uint64_t v46 = v84;
      (*(void (**)(char *, uint64_t, uint64_t))(v86 + 16))(v84, v32, a3);
      uint64_t v47 = v83;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v46, a3, a5, a4, a6);
      char v36 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v43, v47, a4);
      uint64_t v37 = *(void (**)(char *, uint64_t))(v85 + 8);
      uint64_t v38 = v47;
      goto LABEL_11;
    }
    uint64_t v44 = v83;
    (*(void (**)(char *, uint64_t, uint64_t))(v85 + 16))(v83, v39, a4);
    goto LABEL_10;
  }
  uint64_t v73 = v24;
  uint64_t v74 = v21;
  uint64_t v28 = v82;
  char v29 = v26(a4, a6);
  uint64_t v30 = v87;
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
  uint64_t v32 = v88;
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
  if ((v29 & 1) == 0)
  {
    if (v31 >= v33)
    {
      uint64_t v59 = AssociatedTypeWitness;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v28, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v61 = v78;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v59, AssociatedConformanceWitness);
      uint64_t v62 = v84;
      ((void (*)(char *, uint64_t, int **))v28[3])(v61, a3, v28);
      LODWORD(v82) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8) + 40))(v32, v62, a3);
      uint64_t v63 = v30;
      uint64_t v64 = v86;
      uint64_t v65 = *(void (**)(char *, uint64_t))(v86 + 8);
      v65(v62, a3);
      uint64_t v66 = v85;
      uint64_t v67 = v74;
      (*(void (**)(char *, uint64_t, uint64_t))(v85 + 16))(v74, v63, a4);
      uint64_t v68 = v80;
      (*(void (**)(char *, uint64_t, uint64_t))(v64 + 16))(v80, v88, a3);
      if (v82)
      {
        uint64_t v69 = v83;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v68, a3, a5, a4, a6);
        char v36 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v67, v69, a4);
        uint64_t v70 = *(void (**)(char *, uint64_t))(v66 + 8);
        v70(v69, a4);
        v70(v67, a4);
      }
      else
      {
        v65(v68, a3);
        (*(void (**)(char *, uint64_t))(v66 + 8))(v67, a4);
        char v36 = 0;
      }
      return v36 & 1;
    }
    uint64_t v44 = v83;
    (*(void (**)(char *, uint64_t, uint64_t))(v85 + 16))(v83, v30, a4);
LABEL_10:
    uint64_t v45 = v84;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v44, a4, a6, a3, a5);
    char v36 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8) + 16))(v45, v32, a3);
    (*(void (**)(char *, uint64_t))(v86 + 8))(v45, a3);
    return v36 & 1;
  }
  if (v33 < v31)
  {
    uint64_t v34 = v84;
    (*(void (**)(char *, uint64_t, uint64_t))(v86 + 16))(v84, v32, a3);
    uint64_t v35 = v83;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v34, a3, a5, a4, a6);
    char v36 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v30, v35, a4);
    uint64_t v37 = *(void (**)(char *, uint64_t))(v85 + 8);
    uint64_t v38 = v35;
LABEL_11:
    v37(v38, a4);
    return v36 & 1;
  }
  uint64_t v49 = v76;
  uint64_t v50 = v77;
  uint64_t v51 = swift_getAssociatedConformanceWitness((uint64_t)v77, a4, (uint64_t)v76, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v52 = v75;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v51 + 8))(&qword_18162B0B8, 256, v49, v51);
  uint64_t v53 = v83;
  ((void (*)(char *, uint64_t, int **))v50[3])(v52, a4, v50);
  LOBYTE(v49) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v30, v53, a4);
  uint64_t v54 = v85;
  uint64_t v55 = *(void (**)(char *, uint64_t))(v85 + 8);
  v55(v53, a4);
  uint64_t v56 = v73;
  (*(void (**)(void))(v54 + 16))();
  uint64_t v57 = v86;
  uint64_t v58 = v81;
  (*(void (**)(char *, uint64_t, uint64_t))(v86 + 16))(v81, v88, a3);
  if (v49)
  {
    (*(void (**)(char *, uint64_t))(v57 + 8))(v58, a3);
    v55(v56, a4);
    char v36 = 1;
  }
  else
  {
    uint64_t v71 = v84;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v56, a4, a6, a3, a5);
    char v36 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8) + 16))(v71, v58, a3);
    uint64_t v72 = *(void (**)(char *, uint64_t))(v57 + 8);
    v72(v71, a3);
    v72(v58, a3);
  }
  return v36 & 1;
}

float Float16.init(sign:exponentBitPattern:significandBitPattern:)(char a1, char a2, __int16 a3)
{
  return specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, a2, a3);
}

Swift::Float __swiftcall Float.init(sign:exponentBitPattern:significandBitPattern:)(Swift::FloatingPointSign sign, Swift::UInt exponentBitPattern, Swift::UInt32 significandBitPattern)
{
  return specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(sign & 1, exponentBitPattern, significandBitPattern);
}

Swift::Double __swiftcall Double.init(sign:exponentBitPattern:significandBitPattern:)(Swift::FloatingPointSign sign, Swift::UInt exponentBitPattern, Swift::UInt64 significandBitPattern)
{
  return specialized Double.init(sign:exponentBitPattern:significandBitPattern:)(sign & 1, exponentBitPattern, significandBitPattern);
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(__n128 a1, __n128 a2)
{
  if (*(short float *)a2.n128_u16 < *(short float *)a1.n128_u16) {
    return 1;
  }
  uint64_t result = a2.n128_i16[0] >= 0;
  if ((a1.n128_u16[0] & 0x8000) != 0)
  {
    if ((a2.n128_i16[0] & 0x80000000) == 0) {
      return a2.n128_i16[0] < 0;
    }
  }
  else if (a2.n128_i16[0] < 0)
  {
    return a2.n128_i16[0] < 0;
  }
  unsigned int v3 = (a2.n128_i16[0] >> 10) & 0x1F;
  unsigned int v4 = (a1.n128_i16[0] >> 10) & 0x1F;
  if (v4 < v3) {
    return a2.n128_i16[0] < 0;
  }
  if (v3 >= v4)
  {
    unsigned int v5 = a1.n128_u16[0] & 0x3FF;
    if (v5 < (a2.n128_u16[0] & 0x3FFu)) {
      return a2.n128_i16[0] < 0;
    }
    return a2.n128_i16[0] >= 0 || (a2.n128_u16[0] & 0x3FFu) >= v5;
  }
  return result;
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(float a1, float a2)
{
  if (a2 < a1) {
    return 1;
  }
  if ((LODWORD(a1) & 0x80000000) != 0)
  {
    if ((LODWORD(a2) & 0x80000000) != 0) {
      goto LABEL_5;
    }
    return LODWORD(a2) >> 31;
  }
  if ((LODWORD(a2) & 0x80000000) != 0) {
    return LODWORD(a2) >> 31;
  }
LABEL_5:
  unsigned int v3 = (LODWORD(a2) >> 23);
  unsigned int v4 = (LODWORD(a1) >> 23);
  unsigned int v5 = LODWORD(a2) & 0x7FFFFF;
  unsigned int v6 = LODWORD(a1) & 0x7FFFFF;
  BOOL v8 = a2 >= 0.0 || v5 >= v6;
  if (v6 < v5) {
    BOOL v9 = LODWORD(a2) >> 31;
  }
  else {
    BOOL v9 = v8;
  }
  if (v3 < v4) {
    BOOL v9 = a2 >= 0.0;
  }
  if (v4 < v3) {
    return LODWORD(a2) >> 31;
  }
  else {
    return v9;
  }
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(double a1, double a2)
{
  if (a2 < a1) {
    return 1;
  }
  uint64_t result = *(void *)&a2 >> 63;
  if ((*(void *)&a1 & 0x8000000000000000) != 0)
  {
    if ((*(void *)&a2 & 0x8000000000000000) == 0) {
      return result;
    }
  }
  else if ((*(void *)&a2 & 0x8000000000000000) != 0)
  {
    return result;
  }
  unint64_t v3 = (*(void *)&a2 >> 52) & 0x7FFLL;
  unint64_t v4 = (*(void *)&a1 >> 52) & 0x7FFLL;
  unint64_t v5 = *(void *)&a2 & 0xFFFFFFFFFFFFFLL;
  unint64_t v6 = *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
  BOOL v8 = a2 >= 0.0 || v5 >= v6;
  if (v6 < v5) {
    BOOL v8 = *(void *)&a2 >> 63;
  }
  if (v3 < v4) {
    BOOL v8 = a2 >= 0.0;
  }
  if (v4 < v3) {
    return result;
  }
  else {
    return v8;
  }
}

BOOL BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v62 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)v52 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v63 = (char *)v52 - v10;
  uint64_t v11 = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v64 = (void (*)(char *, const char *))*((void *)v11 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)v52 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (void (*)(uint64_t, uint64_t))((char *)v52 - v15);
  uint64_t v17 = *(void *)(a3 + 16);
  uint64_t v18 = *(void *)(*(void *)(v17 + 24) + 8);
  if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 16))(v4, a1, a2, v18)) {
    return 1;
  }
  uint64_t v56 = v14;
  uint64_t v57 = v16;
  uint64_t v59 = v17;
  uint64_t v20 = v4;
  if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 40))(a1, v4, a2, v18)) {
    return 0;
  }
  uint64_t v21 = v59;
  uint64_t v23 = (void (*)(char *, const char *))(v59 + 168);
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(v59 + 168);
  uint64_t v58 = v20;
  char v24 = v22(a2, v59);
  if (v22(a2, v21))
  {
    if ((v24 & 1) == 0) {
      return v22(a2, v21) & 1;
    }
  }
  else if (v24)
  {
    return v22(a2, v21) & 1;
  }
  uint64_t v54 = v22;
  uint64_t v25 = a3;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t))(a3 + 112);
  int v27 = (char *)v57;
  v26(a2, a3);
  uint64_t v28 = v56;
  v52[0] = v26;
  v52[1] = a1;
  v26(a2, v25);
  uint64_t v53 = v25;
  uint64_t v55 = a2;
  uint64_t v29 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(v25, a2, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)+ 8)+ 32)+ 8);
  char v30 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v29 + 40))(v27, v28, v11, v29);
  uint64_t v31 = (void (*)(char *, const char *))*((void *)v64 + 1);
  v31(v28, v11);
  v31(v27, v11);
  if (v30) {
    return v54(v55, v59) & 1;
  }
  uint64_t v32 = v55;
  uint64_t v64 = v31;
  uint64_t v33 = v53;
  uint64_t v34 = (void (*)(uint64_t, uint64_t))v52[0];
  ((void (*)(uint64_t, uint64_t))v52[0])(v55, v53);
  v34(v32, v33);
  uint64_t v35 = v57;
  char v36 = (*(uint64_t (**)(void (*)(uint64_t, uint64_t), char *, const char *, uint64_t))(v29 + 16))(v57, v28, v11, v29);
  uint64_t v37 = v64;
  v64(v28, v11);
  v37((char *)v35, v11);
  if ((v36 & 1) == 0)
  {
    uint64_t v64 = v23;
    uint64_t v38 = v53;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t))(v53 + 120);
    uint64_t v40 = v63;
    uint64_t v41 = v55;
    v39(v55, v53);
    BOOL v42 = v61;
    uint64_t v57 = v39;
    v39(v41, v38);
    uint64_t v43 = AssociatedTypeWitness;
    uint64_t v44 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(v38, v41, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8)+ 32)+ 8);
    char v45 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v44 + 40))(v40, v42, v43, v44);
    uint64_t v46 = *(void (**)(char *, const char *))(v62 + 8);
    v46(v42, v43);
    v46(v40, v43);
    if (v45) {
      return v54(v55, v59) & 1;
    }
    uint64_t v47 = v57;
    uint64_t v48 = v55;
    uint64_t v49 = v53;
    v57(v55, v53);
    v47(v48, v49);
    uint64_t v50 = v63;
    char v51 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(v44 + 16))(v63, v42, v43, v44);
    v46(v42, v43);
    v46(v50, v43);
    if ((v51 & 1) == 0) {
      return 1;
    }
  }
  return (v54(v55, v59) & 1) == 0;
}

BOOL specialized static BinaryFloatingPoint<>._convert<A>(from:)(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  if (!(a3 | a2))
  {
    *a1 = 0;
    return 1;
  }
  unint64_t v6 = (unsigned __int128)-(__int128)__PAIR128__(v3, a2) >> 64;
  if (a3 >= 0) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = -(uint64_t)a2;
  }
  if (a3 >= 0) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = v6;
  }
  int64_t v9 = specialized FixedWidthInteger._binaryLogarithm()(v7, v8);
  if (v9 > 1023)
  {
    if ((a3 & 0x8000000000000000) == 0)
    {
LABEL_10:
      BOOL result = 0;
      *a1 = 0x7FF0000000000000;
      return result;
    }
    goto LABEL_45;
  }
  unint64_t v11 = v9;
  unint64_t v12 = v9 - 52;
  if (v9 <= 52)
  {
    if (v8) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    }
    if (v9 < 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    *a1 = ((v9 << 52) + 0x3FF0000000000000) & 0xFFF0000000000000 | a3 & 0x8000000000000000 | (v7 << (52 - v9)) & 0xFFFFFFFFFFFFFLL;
    return 1;
  }
  unint64_t v13 = v9 - 53;
  uint64_t v14 = 1 << (v9 - 53);
  uint64_t v15 = 1;
  unint64_t v16 = 1uLL >> (53 - v9);
  if (v9 == 53) {
    unint64_t v16 = 0;
  }
  else {
    uint64_t v15 = 1 << (v9 - 53);
  }
  if (v13 > 0x3F) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v14 = v16;
  }
  if (v13 >= 0x80) {
    unint64_t v17 = 0;
  }
  else {
    unint64_t v17 = v14;
  }
  if (v13 >= 0x80) {
    unint64_t v18 = 0;
  }
  else {
    unint64_t v18 = v15;
  }
  unint64_t v19 = specialized static _UInt128.* infix(_:_:)(2uLL, 0, v18, v17);
  if (!v20 && !v19) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
  }
  unint64_t v21 = (v19 - 1) & v7;
  unint64_t v22 = ((__PAIR128__(v20, v19) - 1) >> 64) & v8;
  if (v12 >= 0x80)
  {
    LOBYTE(v23) = 0;
    unint64_t v24 = 0;
    if (v17 == v22) {
      goto LABEL_30;
    }
LABEL_38:
    if (v17 < v22) {
      goto LABEL_42;
    }
LABEL_39:
    if (v22 != v17 || v21 != v18 || (v23 & 1) == 0) {
      goto LABEL_48;
    }
    goto LABEL_42;
  }
  unint64_t v23 = v8 >> v12;
  if (v12 < 0x40) {
    unint64_t v23 = (v8 << (52 - v11)) | (v7 >> v12);
  }
  unint64_t v24 = v23 & 0xFFFFFFFFFFFFFLL;
  if (v17 != v22) {
    goto LABEL_38;
  }
LABEL_30:
  if (v18 >= v21) {
    goto LABEL_39;
  }
LABEL_42:
  if (v24 < 0xFFFFFFFFFFFFFLL)
  {
    ++v24;
  }
  else
  {
    if (v11 >= 0x3FF)
    {
      if ((a3 & 0x8000000000000000) == 0) {
        goto LABEL_10;
      }
LABEL_45:
      BOOL result = 0;
      *a1 = 0xFFF0000000000000;
      return result;
    }
    ++v11;
    unint64_t v24 = 0x10000000000000;
  }
LABEL_48:
  *a1 = a3 & 0x8000000000000000 | v24 & 0xFFFFFFFFFFFFFLL | ((v11 << 52) + 0x3FF0000000000000);
  return (v22 | v21) == 0;
}

uint64_t specialized static BinaryFloatingPoint<>._convert<A>(from:)(unint64_t *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v324 = *(int ***)(AssociatedConformanceWitness + 16);
  char v323 = swift_getAssociatedTypeWitness(0, v324, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v323);
  char v319 = (char *)v295 - v10;
  uint64_t v329 = v8;
  char v334 = *(int ***)(v8 + 16);
  v332 = swift_getAssociatedTypeWitness(0, v334, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v332);
  uint64_t v333 = (char *)v295 - v11;
  unint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v331 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  char v306 = (char *)v295 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v305 = (char *)v295 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v315 = (char *)v295 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v308 = (char *)v295 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v316 = (uint64_t)v295 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v312 = (char *)v295 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  char v313 = (char *)v295 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v325 = (char *)v295 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  unint64_t v309 = (char *)v295 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v310 = (char *)v295 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  unint64_t v320 = (char *)v295 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  unint64_t v321 = (char *)v295 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  char v328 = (char *)v295 - v38;
  uint64_t v335 = *(void *)(a3 - 8);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v41 = (char *)v295 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  unint64_t v303 = (char *)v295 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  unint64_t v302 = (char *)v295 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  uint64_t v318 = (char *)v295 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v301 = (char *)v295 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  uint64_t v307 = (char *)v295 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  char v314 = (char *)v295 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  char v304 = (char *)v295 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  unint64_t v322 = (char *)v295 - v57;
  MEMORY[0x1F4188790](v56);
  uint64_t v59 = (char *)v295 - v58;
  uint64_t v60 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v61 = v60(a3, a4);
  uint64_t v326 = v60;
  uint64_t v327 = a4 + 64;
  uint64_t v330 = v12;
  if ((v61 & 1) == 0)
  {
    uint64_t v68 = a1;
    char v69 = v60(a3, a4);
    uint64_t v317 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v70 = v317(a3, a4);
    if (v69)
    {
      if (v70 <= 64)
      {
        uint64_t v73 = a2;
        uint64_t v74 = v334;
        uint64_t v75 = v332;
        uint64_t v76 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v77 = v333;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v76 + 8))(&qword_18162B0B8, 256, v75, v76);
        ((void (*)(char *, uint64_t, int **))v74[3])(v77, a3, v74);
        LOBYTE(v75) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 32))(v73, v59, a3);
        uint64_t v78 = v335;
        uint64_t v67 = *(void (**)(void))(v335 + 8);
        uint64_t v300 = v59;
        v67();
        a2 = v73;
        (*(void (**)(char *, char *, uint64_t))(v78 + 16))(v41, v73, a3);
        if ((v75 & 1) == 0)
        {
          ((void (*)(char *, uint64_t))v67)(v41, a3);
          a1 = v68;
          uint64_t v65 = v335;
          uint64_t v59 = v300;
          goto LABEL_20;
        }
        uint64_t v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        ((void (*)(char *, uint64_t))v67)(v41, a3);
        a1 = v68;
        uint64_t v65 = v335;
        uint64_t v59 = v300;
        if (!v79) {
          goto LABEL_16;
        }
        goto LABEL_20;
      }
    }
    else if (v70 < 64)
    {
      uint64_t v65 = v335;
      (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v59, a2, a3);
      uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v67 = *(void (**)(void))(v65 + 8);
      ((void (*)(char *, uint64_t))v67)(v59, a3);
      a1 = v68;
      if (!v84) {
        goto LABEL_16;
      }
      goto LABEL_20;
    }
    unint64_t v336 = 0;
    uint64_t v85 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
    v85(&v336, &type metadata for Int, v86, a3, a4);
    char v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8) + 8))(a2, v59, a3);
    uint64_t v65 = v335;
    uint64_t v67 = *(void (**)(void))(v335 + 8);
    ((void (*)(char *, uint64_t))v67)(v59, a3);
    a1 = v68;
    if ((v87 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  uint64_t v317 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v62 = v317(a3, a4);
  if (v62 < 64)
  {
    uint64_t v65 = v335;
    (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v59, a2, a3);
    uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v67 = *(void (**)(void))(v65 + 8);
    ((void (*)(char *, uint64_t))v67)(v59, a3);
    if (v66) {
      goto LABEL_20;
    }
LABEL_16:
    *a1 = 0;
LABEL_17:
    char v88 = 1;
    return v88 & 1;
  }
  unint64_t v336 = 0;
  uint64_t v80 = a1;
  uint64_t v81 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v82 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
  v81(&v336, &type metadata for Int, v82, a3, a4);
  a1 = v80;
  char v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8) + 8))(a2, v59, a3);
  uint64_t v65 = v335;
  uint64_t v67 = *(void (**)(void))(v335 + 8);
  ((void (*)(char *, uint64_t))v67)(v59, a3);
  if (v83) {
    goto LABEL_16;
  }
LABEL_20:
  uint64_t v300 = v59;
  uint64_t v90 = v328;
  (*(void (**)(uint64_t))(v329 + 56))(a3);
  uint64_t v91 = (uint64_t)v330;
  uint64_t v92 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v330, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(v92 + 136))(v91, v92);
  if (v93 > 1023)
  {
    (*(void (**)(char *, uint64_t))(v331 + 8))(v90, v91);
    uint64_t v94 = v326;
    char v95 = v326(a3, a4);
    uint64_t v96 = v322;
    (*(void (**)(char *, char *, uint64_t))(v65 + 16))(v322, a2, a3);
    if (v95)
    {
      if (v94(a3, a4))
      {
        uint64_t v97 = v322;
        uint64_t v98 = v317(a3, a4);
        if (v98 < 64)
        {
          uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v102 = v97;
          goto LABEL_54;
        }
        unint64_t v336 = 0;
        uint64_t v184 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v185 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
        uint64_t v186 = v300;
        v184(&v336, &type metadata for Int, v185, a3, a4);
        char v187 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v97, v186, a3);
        ((void (*)(char *, uint64_t))v67)(v186, a3);
        ((void (*)(char *, uint64_t))v67)(v97, a3);
        if (v187)
        {
LABEL_96:
          char v88 = 0;
          *a1 = 0xFFF0000000000000;
          return v88 & 1;
        }
        goto LABEL_57;
      }
      uint64_t v168 = v94;
      uint64_t v169 = v67;
      char v170 = v168(a3, a4);
      uint64_t v171 = v317(a3, a4);
      if (v170)
      {
        if (v171 <= 64)
        {
          uint64_t v223 = v334;
          uint64_t v224 = v332;
          uint64_t v225 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v226 = v333;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v225 + 8))(&qword_18162B0B8, 256, v224, v225);
          char v227 = v300;
          ((void (*)(char *, uint64_t, int **))v223[3])(v226, a3, v223);
          uint64_t v228 = v322;
          LOBYTE(v223) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                            + 16))(v322, v227, a3);
          uint64_t v229 = v335;
          ((void (*)(char *, uint64_t))v169)(v227, a3);
          (*(void (**)(char *, char *, uint64_t))(v229 + 32))(v304, v228, a3);
          if (v223)
          {
            ((void (*)(char *, uint64_t))v169)(v304, a3);
            goto LABEL_96;
          }
          uint64_t v236 = v304;
          uint64_t v237 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v169)(v236, a3);
          if (v237 < 0) {
            goto LABEL_96;
          }
        }
        else
        {
          unint64_t v336 = 0;
          char v174 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v175 = lazy protocol witness table accessor for type Int and conformance Int(v171, v172, v173);
          uint64_t v176 = v300;
          v174(&v336, &type metadata for Int, v175, a3, a4);
          uint64_t v177 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16);
          unint64_t v178 = v322;
          char v179 = v177(v322, v176, a3);
          ((void (*)(char *, uint64_t))v169)(v176, a3);
          ((void (*)(char *, uint64_t))v169)(v178, a3);
          if (v179) {
            goto LABEL_96;
          }
        }
LABEL_57:
        char v88 = 0;
        *a1 = 0x7FF0000000000000;
        return v88 & 1;
      }
      uint64_t v96 = v322;
      if (v171 < 64)
      {
        uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t v102 = v96;
LABEL_54:
        ((void (*)(char *, uint64_t))v67)(v102, a3);
        if (v101 < 0) {
          goto LABEL_96;
        }
        goto LABEL_57;
      }
    }
    ((void (*)(char *, uint64_t))v67)(v96, a3);
    goto LABEL_57;
  }
  char v304 = a2;
  unint64_t v298 = v67;
  unint64_t v299 = v93;
  if (v93 <= 52)
  {
    uint64_t v134 = v316;
    (*(void (**)(uint64_t, char *, uint64_t))(v331 + 32))(v316, v90, v91);
    char v328 = *(char **)(v92 + 64);
    if (((uint64_t (*)(uint64_t, uint64_t))v328)(v91, v92))
    {
      uint64_t v135 = v308;
      (*(void (**)(char *, uint64_t, uint64_t))(v331 + 16))(v308, v134, v91);
      uint64_t v136 = v323;
      uint64_t v137 = v324;
      uint64_t v138 = swift_getAssociatedConformanceWitness((uint64_t)v324, v91, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v139 = v319;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v138 + 8))(&qword_18162B0B8, 256, v136, v138);
      uint64_t v140 = v320;
      ((void (*)(char *, uint64_t *, int **))v137[3])(v139, v330, v137);
      uint64_t v141 = swift_getAssociatedConformanceWitness(v329, a3, (uint64_t)v330, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v136) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v141 + 32))(v135, v140, v330, v141);
      uint64_t v142 = *(void (**)(char *, uint64_t *))(v331 + 8);
      uint64_t v143 = v140;
      uint64_t v91 = (uint64_t)v330;
      v142(v143, v330);
      if ((v136 & 1) == 0) {
        goto LABEL_136;
      }
      v142(v135, (uint64_t *)v91);
      uint64_t v134 = v316;
    }
    uint64_t v144 = *(uint64_t (**)(uint64_t, uint64_t))(v92 + 128);
    uint64_t v145 = v134;
    uint64_t v146 = v144(v91, v92);
    uint64_t v147 = v304;
    if (v146 < 64)
    {
LABEL_61:
      uint64_t v195 = (*(uint64_t (**)(uint64_t, uint64_t))(v92 + 120))(v91, v92);
      uint64_t v196 = v91;
      uint64_t v197 = v195;
      (*(void (**)(uint64_t, uint64_t))(v331 + 8))(v145, v196);
      int64_t v198 = v326;
      char v199 = v326(a3, a4);
      BOOL v200 = v314;
      (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v314, v147, a3);
      if (v199)
      {
        if (v198(a3, a4))
        {
          uint64_t v201 = v317(a3, a4);
          if (v201 < 64)
          {
            uint64_t v204 = v314;
            uint64_t v205 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            uint64_t v206 = v204;
            goto LABEL_85;
          }
          goto LABEL_67;
        }
        char v207 = v198(a3, a4);
        uint64_t v201 = v317(a3, a4);
        if (v207)
        {
          if (v201 <= 64)
          {
            char v238 = v334;
            uint64_t v239 = v332;
            uint64_t v240 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v241 = v333;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v240 + 8))(&qword_18162B0B8, 256, v239, v240);
            uint64_t v242 = v300;
            ((void (*)(char *, uint64_t, int **))v238[3])(v241, a3, v238);
            unint64_t v243 = v314;
            LOBYTE(v239) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                              + 16))(v314, v242, a3);
            uint64_t v244 = v335;
            ((void (*)(char *, uint64_t))v298)(v242, a3);
            (*(void (**)(char *, char *, uint64_t))(v244 + 32))(v303, v243, a3);
            if (v239)
            {
              ((void (*)(char *, uint64_t))v298)(v303, a3);
            }
            else
            {
              char v258 = v303;
              uint64_t v259 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              ((void (*)(char *, uint64_t))v298)(v258, a3);
              if ((v259 & 0x8000000000000000) == 0) {
                goto LABEL_88;
              }
            }
            goto LABEL_106;
          }
LABEL_67:
          unint64_t v336 = 0;
          uint64_t v208 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v209 = lazy protocol witness table accessor for type Int and conformance Int(v201, v202, v203);
          char v210 = v300;
          v208(&v336, &type metadata for Int, v209, a3, a4);
          unint64_t v211 = v314;
          char v212 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v314, v210, a3);
          uint64_t v213 = v298;
          ((void (*)(char *, uint64_t))v298)(v210, a3);
          ((void (*)(char *, uint64_t))v213)(v211, a3);
          if ((v212 & 1) == 0) {
            goto LABEL_88;
          }
LABEL_106:
          unint64_t v232 = 0x8000000000000000;
LABEL_107:
          if ((v299 & 0x8000000000000000) == 0)
          {
            *a1 = (((v197 << (52 - v299)) & 0xFFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v299 << 52))
                 + 0x3FF0000000000000) | v232;
            goto LABEL_17;
          }
LABEL_136:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
        }
        BOOL v200 = v314;
        if (v201 < 64)
        {
          uint64_t v205 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v206 = v200;
LABEL_85:
          ((void (*)(char *, uint64_t))v298)(v206, a3);
          if (v205 < 0) {
            goto LABEL_106;
          }
LABEL_88:
          unint64_t v232 = 0;
          goto LABEL_107;
        }
      }
      ((void (*)(char *, uint64_t))v298)(v200, a3);
      goto LABEL_88;
    }
    char v297 = a1;
    uint64_t v148 = *(char **)(v331 + 16);
    uint64_t v325 = (char *)(v331 + 16);
    unint64_t v322 = v148;
    ((void (*)(char *, uint64_t, uint64_t))v148)(v315, v145, v91);
    unint64_t v336 = -1;
    char v149 = ((uint64_t (*)(uint64_t, uint64_t))v328)(v91, v92);
    uint64_t v150 = v91;
    char v151 = v149;
    uint64_t v152 = v150;
    char v328 = (char *)v92;
    uint64_t v153 = v144(v150, v92);
    if (v151)
    {
      if (v153 <= 64)
      {
        uint64_t v157 = v323;
        uint64_t v156 = v324;
        uint64_t v158 = swift_getAssociatedConformanceWitness((uint64_t)v324, v152, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v159 = v319;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v158 + 8))(&qword_18162B0B8, 256, v157, v158);
        uint64_t v160 = v320;
        ((void (*)(char *, uint64_t, int **))v156[3])(v159, v152, v156);
        uint64_t v161 = swift_getAssociatedConformanceWitness(v329, a3, v152, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        char v162 = v315;
        LOBYTE(v157) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v161 + 40))(v315, v160, v152, v161);
        uint64_t v163 = *(void (**)(char *, uint64_t))(v331 + 8);
        v163(v160, v152);
        unint64_t v164 = v336;
        ((void (*)(char *, char *, uint64_t))v322)(v305, v162, v152);
        if (v157)
        {
          uint64_t v165 = v305;
          unint64_t v166 = (*((uint64_t (**)(uint64_t))v328 + 15))(v152);
          uint64_t v167 = v152;
          v163(v165, v152);
          if (v164 < v166) {
LABEL_82:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          uint64_t v167 = v152;
          v163(v305, v152);
        }
        goto LABEL_60;
      }
    }
    else if (v153 <= 64)
    {
      uint64_t v230 = v320;
      ((void (*)(char *, char *, uint64_t))v322)(v320, v315, v152);
      unint64_t v231 = (*((uint64_t (**)(uint64_t))v328 + 15))(v152);
      uint64_t v163 = *(void (**)(char *, uint64_t))(v331 + 8);
      uint64_t v167 = v152;
      v163(v230, v152);
      if (v336 < v231) {
        goto LABEL_82;
      }
      goto LABEL_60;
    }
    uint64_t v188 = v328;
    uint64_t v189 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v328 + 12);
    unint64_t v190 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v153, v154, v155);
    BOOL v191 = v320;
    v189(&v336, &type metadata for UInt64, v190, v152, v188);
    uint64_t v192 = swift_getAssociatedConformanceWitness(v329, a3, v152, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v193 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v192 + 16))(v191, v315, v152, v192);
    uint64_t v163 = *(void (**)(char *, uint64_t))(v331 + 8);
    unint64_t v194 = v191;
    uint64_t v167 = v152;
    v163(v194, v152);
    if (v193) {
      goto LABEL_82;
    }
LABEL_60:
    uint64_t v91 = v167;
    v163(v315, v167);
    a1 = v297;
    uint64_t v147 = v304;
    uint64_t v92 = (uint64_t)v328;
    uint64_t v145 = v316;
    goto LABEL_61;
  }
  uint64_t v103 = v93;
  char v297 = a1;
  uint64_t v104 = v323;
  uint64_t v105 = v324;
  uint64_t v316 = v93 - 52;
  uint64_t v315 = (char *)swift_getAssociatedConformanceWitness((uint64_t)v324, v91, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v308 = (char *)*((void *)v315 + 1);
  char v314 = v315 + 8;
  uint64_t v106 = v319;
  ((void (*)(uint64_t *, uint64_t, const char *, char *))v308)(&qword_18162B0C0, 512, v104, v315);
  uint64_t v107 = v105;
  uint64_t v108 = v105[3];
  v305 = (char *)(v105 + 3);
  unint64_t v303 = (char *)v108;
  uint64_t v109 = v91;
  uint64_t v110 = v320;
  uint64_t v111 = ((uint64_t (*)(char *, uint64_t, int **))v108)(v106, v91, v107);
  unint64_t v336 = v103 - 53;
  uint64_t v112 = *(void (**)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v92 + 256);
  unint64_t v296 = lazy protocol witness table accessor for type Int and conformance Int(v111, v113, v114);
  v112(v110, &v336, &type metadata for Int, v296, v109, v92);
  uint64_t v115 = v331 + 8;
  unint64_t v322 = *(char **)(v331 + 8);
  ((void (*)(char *, uint64_t))v322)(v110, v109);
  uint64_t v116 = v319;
  ((void (*)(void *, uint64_t))v308)(&unk_18162B0D0, 768);
  uint64_t v117 = v309;
  ((void (*)(char *, uint64_t, int **))v303)(v116, v109, v324);
  uint64_t v118 = AssociatedConformanceWitness;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(AssociatedConformanceWitness + 64))(v117, v321, v109, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t))v322)(v117, v109);
  ((void (*)(uint64_t *, uint64_t))v308)(&qword_18162B0C0, 512);
  ((void (*)(char *, uint64_t, int **))v303)(v116, v109, v324);
  uint64_t v119 = v310;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v118 + 8) + 40))(v110, v117, v109);
  uint64_t v120 = v322;
  ((void (*)(char *, uint64_t))v322)(v117, v109);
  uint64_t v121 = v110;
  ((void (*)(char *, uint64_t))v120)(v110, v109);
  uint64_t v122 = v120;
  uint64_t v123 = v328;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v92 + 192))(v328, v119, v109, v92);
  ((void (*)(char *, uint64_t))v120)(v119, v109);
  unint64_t v336 = v316;
  (*(void (**)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v92 + 240))(v123, &v336, &type metadata for Int, v296, v109, v92);
  ((void (*)(char *, uint64_t))v120)(v123, v109);
  uint64_t v124 = *(char **)(v92 + 120);
  char v328 = (char *)v92;
  uint64_t v310 = (char *)(v92 + 120);
  unint64_t v309 = v124;
  uint64_t v125 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v109, v92);
  ((void (*)(char *, uint64_t))v122)(v121, v109);
  uint64_t AssociatedConformanceWitness = v125;
  uint64_t v316 = v125 & 0xFFFFFFFFFFFFFLL;
  uint64_t v126 = swift_getAssociatedConformanceWitness(v329, a3, v109, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  uint64_t v127 = v325;
  uint64_t v128 = v321;
  LOBYTE(v125) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v126 + 40))(v325, v321, v109, v126);
  uint64_t v129 = v331;
  uint64_t v130 = v313;
  (*(void (**)(char *, char *, uint64_t))(v331 + 16))(v313, v127, v109);
  uint64_t v131 = *(char **)(v129 + 32);
  uint64_t v132 = v312;
  uint64_t v331 = v129 + 32;
  unint64_t v321 = v131;
  ((void (*)(char *, char *, uint64_t))v131)(v312, v128, v109);
  v295[1] = v115;
  uint64_t v329 = v126;
  if (v125)
  {
    uint64_t v133 = v322;
    ((void (*)(char *, uint64_t))v322)(v132, v109);
    ((void (*)(char *, uint64_t))v133)(v130, v109);
  }
  else
  {
    char v180 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v126 + 8) + 8))(v130, v132, v109);
    char v181 = v322;
    ((void (*)(char *, uint64_t))v322)(v132, v109);
    ((void (*)(char *, uint64_t))v181)(v130, v109);
    if ((v180 & 1) == 0 || (AssociatedConformanceWitness & 1) == 0) {
      goto LABEL_71;
    }
  }
  if (v316 == 0xFFFFFFFFFFFFFLL)
  {
    if (v299 >= 0x3FF)
    {
      ((void (*)(char *, uint64_t *))v322)(v325, v330);
      char v182 = v326(a3, a4);
      (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v307, v304, a3);
      if (v182)
      {
        if (v326(a3, a4))
        {
          if (v317(a3, a4) < 64)
          {
LABEL_127:
            char v283 = v307;
            uint64_t v284 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            ((void (*)(char *, uint64_t))v298)(v283, a3);
            if (v284 < 0) {
              goto LABEL_134;
            }
LABEL_130:
            char v88 = 0;
            unint64_t v285 = 0x7FF0000000000000;
LABEL_135:
            unint64_t *v297 = v285;
            return v88 & 1;
          }
          goto LABEL_103;
        }
        char v252 = v326(a3, a4);
        uint64_t v253 = v317(a3, a4);
        if (v252)
        {
          if (v253 <= 64)
          {
            uint64_t v286 = v334;
            uint64_t v287 = v332;
            uint64_t v288 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v289 = v333;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v288 + 8))(&qword_18162B0B8, 256, v287, v288);
            uint64_t v290 = v300;
            ((void (*)(char *, uint64_t, int **))v286[3])(v289, a3, v286);
            unint64_t v291 = v307;
            LOBYTE(v286) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                              + 16))(v307, v290, a3);
            uint64_t v292 = v335;
            ((void (*)(char *, uint64_t))v298)(v290, a3);
            (*(void (**)(char *, char *, uint64_t))(v292 + 32))(v301, v291, a3);
            if (v286)
            {
              ((void (*)(char *, uint64_t))v298)(v301, a3);
            }
            else
            {
              unint64_t v293 = v301;
              uint64_t v294 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              ((void (*)(char *, uint64_t))v298)(v293, a3);
              if ((v294 & 0x8000000000000000) == 0) {
                goto LABEL_130;
              }
            }
            goto LABEL_134;
          }
LABEL_103:
          unint64_t v336 = 0;
          char v254 = v300;
          (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96))(&v336, &type metadata for Int, v296, a3, a4);
          int v255 = v307;
          char v256 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v307, v254, a3);
          uint64_t v257 = v298;
          ((void (*)(char *, uint64_t))v298)(v254, a3);
          ((void (*)(char *, uint64_t))v257)(v255, a3);
          if ((v256 & 1) == 0) {
            goto LABEL_130;
          }
LABEL_134:
          char v88 = 0;
          unint64_t v285 = 0xFFF0000000000000;
          goto LABEL_135;
        }
        if (v253 < 64) {
          goto LABEL_127;
        }
      }
      ((void (*)(char *, uint64_t))v298)(v307, a3);
      goto LABEL_130;
    }
    ++v299;
    uint64_t v183 = 0x10000000000000;
  }
  else
  {
    uint64_t v183 = v316 + 1;
  }
  uint64_t v316 = v183;
LABEL_71:
  uint64_t v214 = v326;
  char v215 = v326(a3, a4);
  (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v318, v304, a3);
  if ((v215 & 1) == 0) {
    goto LABEL_92;
  }
  if ((v214(a3, a4) & 1) == 0)
  {
    char v216 = v214(a3, a4);
    uint64_t v217 = v317(a3, a4);
    if (v216)
    {
      if (v217 <= 64)
      {
        char v245 = v334;
        unint64_t v246 = v332;
        uint64_t v247 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v248 = v333;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v247 + 8))(&qword_18162B0B8, 256, v246, v247);
        unint64_t v249 = v300;
        ((void (*)(char *, uint64_t, int **))v245[3])(v248, a3, v245);
        uint64_t v250 = v318;
        LOBYTE(v246) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                          + 16))(v318, v249, a3);
        uint64_t v251 = v335;
        ((void (*)(char *, uint64_t))v298)(v249, a3);
        (*(void (**)(char *, char *, uint64_t))(v251 + 32))(v302, v250, a3);
        if (v246)
        {
          ((void (*)(char *, uint64_t))v298)(v302, a3);
        }
        else
        {
          uint64_t v260 = v302;
          uint64_t v261 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v298)(v260, a3);
          if ((v261 & 0x8000000000000000) == 0) {
            goto LABEL_93;
          }
        }
        goto LABEL_110;
      }
LABEL_77:
      unint64_t v336 = 0;
      uint64_t v218 = v300;
      (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96))(&v336, &type metadata for Int, v296, a3, a4);
      int v219 = v318;
      char v220 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v318, v218, a3);
      uint64_t v221 = v218;
      unint64_t v222 = v298;
      ((void (*)(char *, uint64_t))v298)(v221, a3);
      ((void (*)(char *, uint64_t))v222)(v219, a3);
      if ((v220 & 1) == 0) {
        goto LABEL_93;
      }
LABEL_110:
      unint64_t v235 = 0x8000000000000000;
      goto LABEL_111;
    }
    if (v217 < 64) {
      goto LABEL_90;
    }
LABEL_92:
    ((void (*)(char *, uint64_t))v298)(v318, a3);
    goto LABEL_93;
  }
  if (v317(a3, a4) >= 64) {
    goto LABEL_77;
  }
LABEL_90:
  unint64_t v233 = v318;
  uint64_t v234 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v298)(v233, a3);
  if (v234 < 0) {
    goto LABEL_110;
  }
LABEL_93:
  unint64_t v235 = 0;
LABEL_111:
  unint64_t *v297 = ((v316 & 0xFFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v299 << 52)) + 0x3FF0000000000000) | v235;
  uint64_t v262 = v328;
  char v263 = (uint64_t (*)(uint64_t *, char *))*((void *)v328 + 8);
  uint64_t v264 = (uint64_t)v330;
  if (v263(v330, v328))
  {
    if ((*((uint64_t (**)(uint64_t, char *))v262 + 16))(v264, v262) < 64) {
      goto LABEL_120;
    }
    unint64_t v336 = 0;
    uint64_t v271 = v320;
    uint64_t v272 = v264;
    (*((void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t))v328 + 12))(&v336, &type metadata for Int, v296, v264);
    unint64_t v273 = v325;
    char v274 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8))(v325, v271, v264);
    goto LABEL_123;
  }
  char v265 = v263((uint64_t *)v264, v262);
  uint64_t v266 = (*((uint64_t (**)(uint64_t, char *))v262 + 16))(v264, v262);
  if ((v265 & 1) == 0)
  {
    if (v266 < 64)
    {
LABEL_120:
      char v275 = v320;
      ((void (*)(char *, char *, uint64_t))v321)(v320, v325, v264);
      uint64_t v276 = ((uint64_t (*)(uint64_t, char *))v309)(v264, v328);
      ((void (*)(char *, uint64_t))v322)(v275, v264);
      char v88 = v276 == 0;
      return v88 & 1;
    }
    unint64_t v336 = 0;
    unint64_t v273 = v320;
    uint64_t v272 = v264;
    (*((void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t))v328 + 12))(&v336, &type metadata for Int, v296, v264);
    uint64_t v271 = v325;
    char v274 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8))(v325, v273, v264);
LABEL_123:
    char v88 = v274;
    uint64_t v281 = v271;
    v282 = v322;
    ((void (*)(char *, uint64_t))v322)(v281, v272);
    ((void (*)(char *, uint64_t))v282)(v273, v272);
    return v88 & 1;
  }
  if (v266 <= 64)
  {
    uint64_t v277 = v319;
    ((void (*)(uint64_t *, uint64_t))v308)(&qword_18162B0B8, 256);
    unint64_t v278 = v320;
    ((void (*)(char *, uint64_t, int **))v303)(v277, v264, v324);
    uint64_t v279 = v325;
    char v280 = (*(uint64_t (**)(char *, char *, uint64_t))(v329 + 32))(v325, v278, v264);
    ((void (*)(char *, uint64_t))v322)(v278, v264);
    ((void (*)(char *, char *, uint64_t))v321)(v306, v279, v264);
    char v88 = (v280 & 1) != 0 && ((uint64_t (*)(uint64_t, char *))v309)(v264, v328) == 0;
    ((void (*)(char *, uint64_t))v322)(v306, v264);
  }
  else
  {
    unint64_t v336 = 0;
    char v267 = v320;
    (*((void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t))v328 + 12))(&v336, &type metadata for Int, v296, v264);
    unint64_t v268 = v325;
    char v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8))(v325, v267, v264);
    uint64_t v269 = v267;
    uint64_t v270 = v322;
    ((void (*)(char *, uint64_t))v322)(v269, v264);
    ((void (*)(char *, uint64_t))v270)(v268, v264);
  }
  return v88 & 1;
}

uint64_t specialized static BinaryFloatingPoint<>._convert<A>(from:)(unsigned int *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v324 = *(int ***)(AssociatedConformanceWitness + 16);
  char v323 = swift_getAssociatedTypeWitness(0, v324, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v323);
  char v319 = (char *)v295 - v10;
  uint64_t v329 = v8;
  char v334 = *(int ***)(v8 + 16);
  v332 = swift_getAssociatedTypeWitness(0, v334, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v332);
  uint64_t v333 = (char *)v295 - v11;
  unint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v331 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  char v306 = (char *)v295 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v305 = (char *)v295 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v315 = (char *)v295 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v308 = (char *)v295 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v316 = (uint64_t)v295 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v312 = (char *)v295 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  char v313 = (char *)v295 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v325 = (char *)v295 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  unint64_t v309 = (char *)v295 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v310 = (char *)v295 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  unint64_t v320 = (char *)v295 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  unint64_t v321 = (char *)v295 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  char v328 = (char *)v295 - v38;
  uint64_t v335 = *(void *)(a3 - 8);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v41 = (char *)v295 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  unint64_t v303 = (char *)v295 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  unint64_t v302 = (char *)v295 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  uint64_t v318 = (char *)v295 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v301 = (char *)v295 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  uint64_t v307 = (char *)v295 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  char v314 = (char *)v295 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  char v304 = (char *)v295 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  unint64_t v322 = (char *)v295 - v57;
  MEMORY[0x1F4188790](v56);
  uint64_t v59 = (char *)v295 - v58;
  uint64_t v60 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v61 = v60(a3, a4);
  uint64_t v326 = v60;
  uint64_t v327 = a4 + 64;
  uint64_t v330 = v12;
  if ((v61 & 1) == 0)
  {
    uint64_t v68 = a1;
    char v69 = v60(a3, a4);
    uint64_t v317 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v70 = v317(a3, a4);
    if (v69)
    {
      if (v70 <= 64)
      {
        uint64_t v73 = a2;
        uint64_t v74 = v334;
        uint64_t v75 = v332;
        uint64_t v76 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v77 = v333;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v76 + 8))(&qword_18162B0B8, 256, v75, v76);
        ((void (*)(char *, uint64_t, int **))v74[3])(v77, a3, v74);
        LOBYTE(v75) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 32))(v73, v59, a3);
        uint64_t v78 = v335;
        uint64_t v67 = *(void (**)(void))(v335 + 8);
        uint64_t v300 = v59;
        v67();
        a2 = v73;
        (*(void (**)(char *, char *, uint64_t))(v78 + 16))(v41, v73, a3);
        if ((v75 & 1) == 0)
        {
          ((void (*)(char *, uint64_t))v67)(v41, a3);
          a1 = v68;
          uint64_t v65 = v335;
          uint64_t v59 = v300;
          goto LABEL_20;
        }
        uint64_t v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        ((void (*)(char *, uint64_t))v67)(v41, a3);
        a1 = v68;
        uint64_t v65 = v335;
        uint64_t v59 = v300;
        if (!v79) {
          goto LABEL_16;
        }
        goto LABEL_20;
      }
    }
    else if (v70 < 64)
    {
      uint64_t v65 = v335;
      (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v59, a2, a3);
      uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v67 = *(void (**)(void))(v65 + 8);
      ((void (*)(char *, uint64_t))v67)(v59, a3);
      a1 = v68;
      if (!v84) {
        goto LABEL_16;
      }
      goto LABEL_20;
    }
    uint64_t v336 = 0;
    uint64_t v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
    v85(&v336, &type metadata for Int, v86, a3, a4);
    char v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8) + 8))(a2, v59, a3);
    uint64_t v65 = v335;
    uint64_t v67 = *(void (**)(void))(v335 + 8);
    ((void (*)(char *, uint64_t))v67)(v59, a3);
    a1 = v68;
    if ((v87 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  uint64_t v317 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v62 = v317(a3, a4);
  if (v62 < 64)
  {
    uint64_t v65 = v335;
    (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v59, a2, a3);
    uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v67 = *(void (**)(void))(v65 + 8);
    ((void (*)(char *, uint64_t))v67)(v59, a3);
    if (v66) {
      goto LABEL_20;
    }
LABEL_16:
    *a1 = 0;
LABEL_17:
    char v88 = 1;
    return v88 & 1;
  }
  uint64_t v336 = 0;
  uint64_t v80 = a1;
  uint64_t v81 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v82 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
  v81(&v336, &type metadata for Int, v82, a3, a4);
  a1 = v80;
  char v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8) + 8))(a2, v59, a3);
  uint64_t v65 = v335;
  uint64_t v67 = *(void (**)(void))(v335 + 8);
  ((void (*)(char *, uint64_t))v67)(v59, a3);
  if (v83) {
    goto LABEL_16;
  }
LABEL_20:
  uint64_t v300 = v59;
  uint64_t v90 = v328;
  (*(void (**)(uint64_t))(v329 + 56))(a3);
  uint64_t v91 = (uint64_t)v330;
  uint64_t v92 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v330, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(v92 + 136))(v91, v92);
  if (v93 > 127)
  {
    (*(void (**)(char *, uint64_t))(v331 + 8))(v90, v91);
    uint64_t v94 = v326;
    char v95 = v326(a3, a4);
    uint64_t v96 = v322;
    (*(void (**)(char *, char *, uint64_t))(v65 + 16))(v322, a2, a3);
    if (v95)
    {
      if (v94(a3, a4))
      {
        uint64_t v97 = v322;
        uint64_t v98 = v317(a3, a4);
        if (v98 < 64)
        {
          uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v102 = v97;
          goto LABEL_54;
        }
        uint64_t v336 = 0;
        uint64_t v184 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v185 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
        uint64_t v186 = v300;
        v184(&v336, &type metadata for Int, v185, a3, a4);
        char v187 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v97, v186, a3);
        ((void (*)(char *, uint64_t))v67)(v186, a3);
        ((void (*)(char *, uint64_t))v67)(v97, a3);
        if (v187)
        {
LABEL_96:
          char v88 = 0;
          *a1 = -8388608;
          return v88 & 1;
        }
        goto LABEL_57;
      }
      uint64_t v168 = v94;
      uint64_t v169 = v67;
      char v170 = v168(a3, a4);
      uint64_t v171 = v317(a3, a4);
      if (v170)
      {
        if (v171 <= 64)
        {
          uint64_t v223 = v334;
          uint64_t v224 = v332;
          uint64_t v225 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v226 = v333;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v225 + 8))(&qword_18162B0B8, 256, v224, v225);
          char v227 = v300;
          ((void (*)(char *, uint64_t, int **))v223[3])(v226, a3, v223);
          uint64_t v228 = v322;
          LOBYTE(v223) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                            + 16))(v322, v227, a3);
          uint64_t v229 = v335;
          ((void (*)(char *, uint64_t))v169)(v227, a3);
          (*(void (**)(char *, char *, uint64_t))(v229 + 32))(v304, v228, a3);
          if (v223)
          {
            ((void (*)(char *, uint64_t))v169)(v304, a3);
            goto LABEL_96;
          }
          uint64_t v236 = v304;
          uint64_t v237 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v169)(v236, a3);
          if (v237 < 0) {
            goto LABEL_96;
          }
        }
        else
        {
          uint64_t v336 = 0;
          char v174 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v175 = lazy protocol witness table accessor for type Int and conformance Int(v171, v172, v173);
          uint64_t v176 = v300;
          v174(&v336, &type metadata for Int, v175, a3, a4);
          uint64_t v177 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16);
          unint64_t v178 = v322;
          char v179 = v177(v322, v176, a3);
          ((void (*)(char *, uint64_t))v169)(v176, a3);
          ((void (*)(char *, uint64_t))v169)(v178, a3);
          if (v179) {
            goto LABEL_96;
          }
        }
LABEL_57:
        char v88 = 0;
        *a1 = 2139095040;
        return v88 & 1;
      }
      uint64_t v96 = v322;
      if (v171 < 64)
      {
        uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t v102 = v96;
LABEL_54:
        ((void (*)(char *, uint64_t))v67)(v102, a3);
        if (v101 < 0) {
          goto LABEL_96;
        }
        goto LABEL_57;
      }
    }
    ((void (*)(char *, uint64_t))v67)(v96, a3);
    goto LABEL_57;
  }
  char v304 = a2;
  unint64_t v298 = v67;
  unint64_t v299 = v93;
  if (v93 <= 23)
  {
    uint64_t v134 = v316;
    (*(void (**)(uint64_t, char *, uint64_t))(v331 + 32))(v316, v90, v91);
    char v328 = *(char **)(v92 + 64);
    if (((uint64_t (*)(uint64_t, uint64_t))v328)(v91, v92))
    {
      uint64_t v135 = v308;
      (*(void (**)(char *, uint64_t, uint64_t))(v331 + 16))(v308, v134, v91);
      uint64_t v136 = v323;
      uint64_t v137 = v324;
      uint64_t v138 = swift_getAssociatedConformanceWitness((uint64_t)v324, v91, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v139 = v319;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v138 + 8))(&qword_18162B0B8, 256, v136, v138);
      uint64_t v140 = v320;
      ((void (*)(char *, uint64_t *, int **))v137[3])(v139, v330, v137);
      uint64_t v141 = swift_getAssociatedConformanceWitness(v329, a3, (uint64_t)v330, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v136) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v141 + 32))(v135, v140, v330, v141);
      uint64_t v142 = *(void (**)(char *, uint64_t *))(v331 + 8);
      uint64_t v143 = v140;
      uint64_t v91 = (uint64_t)v330;
      v142(v143, v330);
      if ((v136 & 1) == 0) {
        goto LABEL_136;
      }
      v142(v135, (uint64_t *)v91);
      uint64_t v134 = v316;
    }
    uint64_t v144 = *(uint64_t (**)(uint64_t, uint64_t))(v92 + 128);
    uint64_t v145 = v134;
    uint64_t v146 = v144(v91, v92);
    uint64_t v147 = v304;
    if (v146 < 32)
    {
LABEL_61:
      int v195 = (*(uint64_t (**)(uint64_t, uint64_t))(v92 + 120))(v91, v92);
      uint64_t v196 = v91;
      int v197 = v195;
      (*(void (**)(uint64_t, uint64_t))(v331 + 8))(v145, v196);
      int64_t v198 = v326;
      char v199 = v326(a3, a4);
      BOOL v200 = v314;
      (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v314, v147, a3);
      if (v199)
      {
        if (v198(a3, a4))
        {
          uint64_t v201 = v317(a3, a4);
          if (v201 < 64)
          {
            uint64_t v204 = v314;
            uint64_t v205 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            uint64_t v206 = v204;
            goto LABEL_85;
          }
          goto LABEL_67;
        }
        char v207 = v198(a3, a4);
        uint64_t v201 = v317(a3, a4);
        if (v207)
        {
          if (v201 <= 64)
          {
            char v238 = v334;
            uint64_t v239 = v332;
            uint64_t v240 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v241 = v333;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v240 + 8))(&qword_18162B0B8, 256, v239, v240);
            uint64_t v242 = v300;
            ((void (*)(char *, uint64_t, int **))v238[3])(v241, a3, v238);
            unint64_t v243 = v314;
            LOBYTE(v239) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                              + 16))(v314, v242, a3);
            uint64_t v244 = v335;
            ((void (*)(char *, uint64_t))v298)(v242, a3);
            (*(void (**)(char *, char *, uint64_t))(v244 + 32))(v303, v243, a3);
            if (v239)
            {
              ((void (*)(char *, uint64_t))v298)(v303, a3);
            }
            else
            {
              char v258 = v303;
              uint64_t v259 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              ((void (*)(char *, uint64_t))v298)(v258, a3);
              if ((v259 & 0x8000000000000000) == 0) {
                goto LABEL_88;
              }
            }
            goto LABEL_106;
          }
LABEL_67:
          uint64_t v336 = 0;
          uint64_t v208 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v209 = lazy protocol witness table accessor for type Int and conformance Int(v201, v202, v203);
          char v210 = v300;
          v208(&v336, &type metadata for Int, v209, a3, a4);
          unint64_t v211 = v314;
          char v212 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v314, v210, a3);
          uint64_t v213 = v298;
          ((void (*)(char *, uint64_t))v298)(v210, a3);
          ((void (*)(char *, uint64_t))v213)(v211, a3);
          if ((v212 & 1) == 0) {
            goto LABEL_88;
          }
LABEL_106:
          unsigned int v232 = 0x80000000;
LABEL_107:
          if ((v299 & 0x8000000000000000) == 0)
          {
            *a1 = ((v299 << 23) + 1065353216) & 0x7F800000 | (v197 << (23 - v299)) & 0x7FFFFF | v232;
            goto LABEL_17;
          }
LABEL_136:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
        }
        BOOL v200 = v314;
        if (v201 < 64)
        {
          uint64_t v205 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v206 = v200;
LABEL_85:
          ((void (*)(char *, uint64_t))v298)(v206, a3);
          if (v205 < 0) {
            goto LABEL_106;
          }
LABEL_88:
          unsigned int v232 = 0;
          goto LABEL_107;
        }
      }
      ((void (*)(char *, uint64_t))v298)(v200, a3);
      goto LABEL_88;
    }
    char v297 = (int *)a1;
    uint64_t v148 = *(char **)(v331 + 16);
    uint64_t v325 = (char *)(v331 + 16);
    unint64_t v322 = v148;
    ((void (*)(char *, uint64_t, uint64_t))v148)(v315, v145, v91);
    LODWORD(v336) = -1;
    char v149 = ((uint64_t (*)(uint64_t, uint64_t))v328)(v91, v92);
    uint64_t v150 = v91;
    char v151 = v149;
    uint64_t v152 = v150;
    char v328 = (char *)v92;
    uint64_t v153 = v144(v150, v92);
    if (v151)
    {
      if (v153 <= 32)
      {
        uint64_t v157 = v323;
        uint64_t v156 = v324;
        uint64_t v158 = swift_getAssociatedConformanceWitness((uint64_t)v324, v152, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v159 = v319;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v158 + 8))(&qword_18162B0B8, 256, v157, v158);
        uint64_t v160 = v320;
        ((void (*)(char *, uint64_t, int **))v156[3])(v159, v152, v156);
        uint64_t v161 = swift_getAssociatedConformanceWitness(v329, a3, v152, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        char v162 = v315;
        LOBYTE(v157) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v161 + 40))(v315, v160, v152, v161);
        uint64_t v163 = *(void (**)(char *, uint64_t))(v331 + 8);
        v163(v160, v152);
        unsigned int v164 = v336;
        ((void (*)(char *, char *, uint64_t))v322)(v305, v162, v152);
        if (v157)
        {
          uint64_t v165 = v305;
          unsigned int v166 = (*((uint64_t (**)(uint64_t))v328 + 15))(v152);
          uint64_t v167 = v152;
          v163(v165, v152);
          if (v164 < v166) {
LABEL_82:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          uint64_t v167 = v152;
          v163(v305, v152);
        }
        goto LABEL_60;
      }
    }
    else if (v153 <= 32)
    {
      uint64_t v230 = v320;
      ((void (*)(char *, char *, uint64_t))v322)(v320, v315, v152);
      unsigned int v231 = (*((uint64_t (**)(uint64_t))v328 + 15))(v152);
      uint64_t v163 = *(void (**)(char *, uint64_t))(v331 + 8);
      uint64_t v167 = v152;
      v163(v230, v152);
      if (v336 < v231) {
        goto LABEL_82;
      }
      goto LABEL_60;
    }
    uint64_t v188 = v328;
    uint64_t v189 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v328 + 12);
    unint64_t v190 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v153, v154, v155);
    BOOL v191 = v320;
    v189(&v336, &type metadata for UInt32, v190, v152, v188);
    uint64_t v192 = swift_getAssociatedConformanceWitness(v329, a3, v152, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v193 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v192 + 16))(v191, v315, v152, v192);
    uint64_t v163 = *(void (**)(char *, uint64_t))(v331 + 8);
    unint64_t v194 = v191;
    uint64_t v167 = v152;
    v163(v194, v152);
    if (v193) {
      goto LABEL_82;
    }
LABEL_60:
    uint64_t v91 = v167;
    v163(v315, v167);
    a1 = (unsigned int *)v297;
    uint64_t v147 = v304;
    uint64_t v92 = (uint64_t)v328;
    uint64_t v145 = v316;
    goto LABEL_61;
  }
  uint64_t v103 = v93;
  char v297 = (int *)a1;
  uint64_t v104 = v323;
  uint64_t v105 = v324;
  uint64_t v316 = v93 - 23;
  uint64_t v315 = (char *)swift_getAssociatedConformanceWitness((uint64_t)v324, v91, (uint64_t)v323, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v308 = (char *)*((void *)v315 + 1);
  char v314 = v315 + 8;
  uint64_t v106 = v319;
  ((void (*)(uint64_t *, uint64_t, const char *, char *))v308)(&qword_18162B0C0, 512, v104, v315);
  uint64_t v107 = v105;
  uint64_t v108 = v105[3];
  v305 = (char *)(v105 + 3);
  unint64_t v303 = (char *)v108;
  uint64_t v109 = v91;
  uint64_t v110 = v320;
  uint64_t v111 = ((uint64_t (*)(char *, uint64_t, int **))v108)(v106, v91, v107);
  uint64_t v336 = v103 - 24;
  uint64_t v112 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v92 + 256);
  unint64_t v296 = lazy protocol witness table accessor for type Int and conformance Int(v111, v113, v114);
  v112(v110, &v336, &type metadata for Int, v296, v109, v92);
  uint64_t v115 = v331 + 8;
  unint64_t v322 = *(char **)(v331 + 8);
  ((void (*)(char *, uint64_t))v322)(v110, v109);
  uint64_t v116 = v319;
  ((void (*)(void *, uint64_t))v308)(&unk_18162B0D0, 768);
  uint64_t v117 = v309;
  ((void (*)(char *, uint64_t, int **))v303)(v116, v109, v324);
  uint64_t v118 = AssociatedConformanceWitness;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(AssociatedConformanceWitness + 64))(v117, v321, v109, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t))v322)(v117, v109);
  ((void (*)(uint64_t *, uint64_t))v308)(&qword_18162B0C0, 512);
  ((void (*)(char *, uint64_t, int **))v303)(v116, v109, v324);
  uint64_t v119 = v310;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v118 + 8) + 40))(v110, v117, v109);
  uint64_t v120 = v322;
  ((void (*)(char *, uint64_t))v322)(v117, v109);
  uint64_t v121 = v110;
  ((void (*)(char *, uint64_t))v120)(v110, v109);
  uint64_t v122 = v120;
  uint64_t v123 = v328;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v92 + 192))(v328, v119, v109, v92);
  ((void (*)(char *, uint64_t))v120)(v119, v109);
  uint64_t v336 = v316;
  (*(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v92 + 240))(v123, &v336, &type metadata for Int, v296, v109, v92);
  ((void (*)(char *, uint64_t))v120)(v123, v109);
  uint64_t v124 = *(char **)(v92 + 120);
  char v328 = (char *)v92;
  uint64_t v310 = (char *)(v92 + 120);
  unint64_t v309 = v124;
  uint64_t v125 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v109, v92);
  ((void (*)(char *, uint64_t))v122)(v121, v109);
  uint64_t AssociatedConformanceWitness = v125;
  LODWORD(v316) = v125 & 0x7FFFFF;
  uint64_t v126 = swift_getAssociatedConformanceWitness(v329, a3, v109, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  uint64_t v127 = v325;
  uint64_t v128 = v321;
  LOBYTE(v125) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v126 + 40))(v325, v321, v109, v126);
  uint64_t v129 = v331;
  uint64_t v130 = v313;
  (*(void (**)(char *, char *, uint64_t))(v331 + 16))(v313, v127, v109);
  uint64_t v131 = *(char **)(v129 + 32);
  uint64_t v132 = v312;
  uint64_t v331 = v129 + 32;
  unint64_t v321 = v131;
  ((void (*)(char *, char *, uint64_t))v131)(v312, v128, v109);
  v295[1] = v115;
  uint64_t v329 = v126;
  if (v125)
  {
    uint64_t v133 = v322;
    ((void (*)(char *, uint64_t))v322)(v132, v109);
    ((void (*)(char *, uint64_t))v133)(v130, v109);
  }
  else
  {
    char v180 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v126 + 8) + 8))(v130, v132, v109);
    char v181 = v322;
    ((void (*)(char *, uint64_t))v322)(v132, v109);
    ((void (*)(char *, uint64_t))v181)(v130, v109);
    if ((v180 & 1) == 0 || (AssociatedConformanceWitness & 1) == 0) {
      goto LABEL_71;
    }
  }
  if (v316 == 0x7FFFFF)
  {
    if (v299 >= 0x7F)
    {
      ((void (*)(char *, uint64_t *))v322)(v325, v330);
      char v182 = v326(a3, a4);
      (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v307, v304, a3);
      if (v182)
      {
        if (v326(a3, a4))
        {
          if (v317(a3, a4) < 64)
          {
LABEL_127:
            char v283 = v307;
            uint64_t v284 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            ((void (*)(char *, uint64_t))v298)(v283, a3);
            if (v284 < 0) {
              goto LABEL_134;
            }
LABEL_130:
            char v88 = 0;
            int v285 = 2139095040;
LABEL_135:
            int *v297 = v285;
            return v88 & 1;
          }
          goto LABEL_103;
        }
        char v252 = v326(a3, a4);
        uint64_t v253 = v317(a3, a4);
        if (v252)
        {
          if (v253 <= 64)
          {
            uint64_t v286 = v334;
            uint64_t v287 = v332;
            uint64_t v288 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v289 = v333;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v288 + 8))(&qword_18162B0B8, 256, v287, v288);
            uint64_t v290 = v300;
            ((void (*)(char *, uint64_t, int **))v286[3])(v289, a3, v286);
            unint64_t v291 = v307;
            LOBYTE(v286) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                              + 16))(v307, v290, a3);
            uint64_t v292 = v335;
            ((void (*)(char *, uint64_t))v298)(v290, a3);
            (*(void (**)(char *, char *, uint64_t))(v292 + 32))(v301, v291, a3);
            if (v286)
            {
              ((void (*)(char *, uint64_t))v298)(v301, a3);
            }
            else
            {
              unint64_t v293 = v301;
              uint64_t v294 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              ((void (*)(char *, uint64_t))v298)(v293, a3);
              if ((v294 & 0x8000000000000000) == 0) {
                goto LABEL_130;
              }
            }
            goto LABEL_134;
          }
LABEL_103:
          uint64_t v336 = 0;
          char v254 = v300;
          (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96))(&v336, &type metadata for Int, v296, a3, a4);
          int v255 = v307;
          char v256 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v307, v254, a3);
          uint64_t v257 = v298;
          ((void (*)(char *, uint64_t))v298)(v254, a3);
          ((void (*)(char *, uint64_t))v257)(v255, a3);
          if ((v256 & 1) == 0) {
            goto LABEL_130;
          }
LABEL_134:
          char v88 = 0;
          int v285 = -8388608;
          goto LABEL_135;
        }
        if (v253 < 64) {
          goto LABEL_127;
        }
      }
      ((void (*)(char *, uint64_t))v298)(v307, a3);
      goto LABEL_130;
    }
    ++v299;
    int v183 = 0x800000;
  }
  else
  {
    int v183 = v316 + 1;
  }
  LODWORD(v316) = v183;
LABEL_71:
  uint64_t v214 = v326;
  char v215 = v326(a3, a4);
  (*(void (**)(char *, char *, uint64_t))(v335 + 16))(v318, v304, a3);
  if ((v215 & 1) == 0) {
    goto LABEL_92;
  }
  if ((v214(a3, a4) & 1) == 0)
  {
    char v216 = v214(a3, a4);
    uint64_t v217 = v317(a3, a4);
    if (v216)
    {
      if (v217 <= 64)
      {
        char v245 = v334;
        unint64_t v246 = v332;
        uint64_t v247 = swift_getAssociatedConformanceWitness((uint64_t)v334, a3, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v248 = v333;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v247 + 8))(&qword_18162B0B8, 256, v246, v247);
        unint64_t v249 = v300;
        ((void (*)(char *, uint64_t, int **))v245[3])(v248, a3, v245);
        uint64_t v250 = v318;
        LOBYTE(v246) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                          + 16))(v318, v249, a3);
        uint64_t v251 = v335;
        ((void (*)(char *, uint64_t))v298)(v249, a3);
        (*(void (**)(char *, char *, uint64_t))(v251 + 32))(v302, v250, a3);
        if (v246)
        {
          ((void (*)(char *, uint64_t))v298)(v302, a3);
        }
        else
        {
          uint64_t v260 = v302;
          uint64_t v261 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v298)(v260, a3);
          if ((v261 & 0x8000000000000000) == 0) {
            goto LABEL_93;
          }
        }
        goto LABEL_110;
      }
LABEL_77:
      uint64_t v336 = 0;
      uint64_t v218 = v300;
      (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96))(&v336, &type metadata for Int, v296, a3, a4);
      int v219 = v318;
      char v220 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v318, v218, a3);
      uint64_t v221 = v218;
      unint64_t v222 = v298;
      ((void (*)(char *, uint64_t))v298)(v221, a3);
      ((void (*)(char *, uint64_t))v222)(v219, a3);
      if ((v220 & 1) == 0) {
        goto LABEL_93;
      }
LABEL_110:
      unsigned int v235 = 0x80000000;
      goto LABEL_111;
    }
    if (v217 < 64) {
      goto LABEL_90;
    }
LABEL_92:
    ((void (*)(char *, uint64_t))v298)(v318, a3);
    goto LABEL_93;
  }
  if (v317(a3, a4) >= 64) {
    goto LABEL_77;
  }
LABEL_90:
  unint64_t v233 = v318;
  uint64_t v234 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v298)(v233, a3);
  if (v234 < 0) {
    goto LABEL_110;
  }
LABEL_93:
  unsigned int v235 = 0;
LABEL_111:
  int *v297 = ((v316 & 0x7FFFFF | ((unsigned __int16)v299 << 23)) + 1065353216) | v235;
  uint64_t v262 = v328;
  char v263 = (uint64_t (*)(uint64_t *, char *))*((void *)v328 + 8);
  uint64_t v264 = (uint64_t)v330;
  if (v263(v330, v328))
  {
    if ((*((uint64_t (**)(uint64_t, char *))v262 + 16))(v264, v262) < 64) {
      goto LABEL_120;
    }
    uint64_t v336 = 0;
    uint64_t v271 = v320;
    uint64_t v272 = v264;
    (*((void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t))v328 + 12))(&v336, &type metadata for Int, v296, v264);
    unint64_t v273 = v325;
    char v274 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8))(v325, v271, v264);
    goto LABEL_123;
  }
  char v265 = v263((uint64_t *)v264, v262);
  uint64_t v266 = (*((uint64_t (**)(uint64_t, char *))v262 + 16))(v264, v262);
  if ((v265 & 1) == 0)
  {
    if (v266 < 64)
    {
LABEL_120:
      char v275 = v320;
      ((void (*)(char *, char *, uint64_t))v321)(v320, v325, v264);
      uint64_t v276 = ((uint64_t (*)(uint64_t, char *))v309)(v264, v328);
      ((void (*)(char *, uint64_t))v322)(v275, v264);
      char v88 = v276 == 0;
      return v88 & 1;
    }
    uint64_t v336 = 0;
    unint64_t v273 = v320;
    uint64_t v272 = v264;
    (*((void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t))v328 + 12))(&v336, &type metadata for Int, v296, v264);
    uint64_t v271 = v325;
    char v274 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8))(v325, v273, v264);
LABEL_123:
    char v88 = v274;
    uint64_t v281 = v271;
    v282 = v322;
    ((void (*)(char *, uint64_t))v322)(v281, v272);
    ((void (*)(char *, uint64_t))v282)(v273, v272);
    return v88 & 1;
  }
  if (v266 <= 64)
  {
    uint64_t v277 = v319;
    ((void (*)(uint64_t *, uint64_t))v308)(&qword_18162B0B8, 256);
    unint64_t v278 = v320;
    ((void (*)(char *, uint64_t, int **))v303)(v277, v264, v324);
    uint64_t v279 = v325;
    char v280 = (*(uint64_t (**)(char *, char *, uint64_t))(v329 + 32))(v325, v278, v264);
    ((void (*)(char *, uint64_t))v322)(v278, v264);
    ((void (*)(char *, char *, uint64_t))v321)(v306, v279, v264);
    char v88 = (v280 & 1) != 0 && ((uint64_t (*)(uint64_t, char *))v309)(v264, v328) == 0;
    ((void (*)(char *, uint64_t))v322)(v306, v264);
  }
  else
  {
    uint64_t v336 = 0;
    char v267 = v320;
    (*((void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t))v328 + 12))(&v336, &type metadata for Int, v296, v264);
    unint64_t v268 = v325;
    char v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8))(v325, v267, v264);
    uint64_t v269 = v267;
    uint64_t v270 = v322;
    ((void (*)(char *, uint64_t))v322)(v269, v264);
    ((void (*)(char *, uint64_t))v270)(v268, v264);
  }
  return v88 & 1;
}

uint64_t specialized static BinaryFloatingPoint<>._convert<A>(from:)(__int16 *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v330 = a1;
  uint64_t v7 = *(void *)(a4 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v318 = *(int ***)(AssociatedConformanceWitness + 16);
  unint64_t v311 = swift_getAssociatedTypeWitness(0, v318, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v311);
  uint64_t v316 = (char *)&v292 - v9;
  uint64_t v324 = v7;
  char v328 = *(int ***)(v7 + 16);
  uint64_t v326 = swift_getAssociatedTypeWitness(0, v328, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v326);
  uint64_t v327 = (char *)&v292 - v10;
  uint64_t v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v325 = *(v11 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  unint64_t v302 = (char *)&v292 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  v301 = (char *)&v292 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v310 = (char *)&v292 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  char v304 = (char *)&v292 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v331 = (char *)&v292 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v308 = (char *)&v292 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v309 = (char *)&v292 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  char v319 = (char *)&v292 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v305 = (char *)&v292 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  char v306 = (char *)&v292 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  char v323 = (char *)&v292 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v317 = (char *)&v292 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v322 = (uint64_t)&v292 - v37;
  uint64_t v38 = *(void *)(a3 - 8);
  uint64_t v39 = MEMORY[0x1F4188790](v36);
  uint64_t v41 = (char *)&v292 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  unint64_t v299 = (char *)&v292 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  unint64_t v298 = (char *)&v292 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  char v313 = (char *)&v292 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  char v297 = (char *)&v292 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  unint64_t v303 = (char *)&v292 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  char v314 = (char *)&v292 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  uint64_t v300 = (char *)&v292 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  uint64_t v315 = (char *)&v292 - v57;
  MEMORY[0x1F4188790](v56);
  uint64_t v59 = (char *)&v292 - v58;
  uint64_t v60 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  char v61 = v60(a3, v4);
  unint64_t v320 = v60;
  uint64_t v321 = v4 + 64;
  if (v61)
  {
    unint64_t v312 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v62 = v312(a3, v4);
    if (v62 < 64)
    {
      (*(void (**)(char *, char *, uint64_t))(v38 + 16))(v59, a2, a3);
      uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t v66 = *(void (**)(void))(v38 + 8);
      ((void (*)(char *, uint64_t))v66)(v59, a3);
      uint64_t v67 = v331;
      if (v65) {
        goto LABEL_23;
      }
LABEL_19:
      *uint64_t v330 = 0;
LABEL_20:
      char v92 = 1;
      return v92 & 1;
    }
    v332 = 0;
    uint64_t v77 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v78 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
    v77(&v332, &type metadata for Int, v78, a3, v4);
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 16) + 8) + 8))(a2, v59, a3);
    uint64_t v76 = v38;
    goto LABEL_9;
  }
  uint64_t v329 = v38;
  char v68 = v60(a3, v4);
  char v69 = a2;
  unint64_t v312 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
  uint64_t v70 = v312(a3, v4);
  if ((v68 & 1) == 0)
  {
    uint64_t v67 = v331;
    if (v70 < 64)
    {
      uint64_t v38 = v329;
      (*(void (**)(char *, char *, uint64_t))(v329 + 16))(v59, a2, a3);
      uint64_t v79 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t v66 = *(void (**)(void))(v38 + 8);
      ((void (*)(char *, uint64_t))v66)(v59, a3);
      if (!v79) {
        goto LABEL_19;
      }
    }
    else
    {
      v332 = 0;
      uint64_t v89 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v90 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      v89(&v332, &type metadata for Int, v90, a3, v4);
      char v91 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 16) + 8) + 8))(a2, v59, a3);
      uint64_t v38 = v329;
      uint64_t v66 = *(void (**)(void))(v329 + 8);
      ((void (*)(char *, uint64_t))v66)(v59, a3);
      if (v91) {
        goto LABEL_19;
      }
    }
    goto LABEL_23;
  }
  if (v70 > 64)
  {
    v332 = 0;
    uint64_t v73 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
    v73(&v332, &type metadata for Int, v74, a3, v4);
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 16) + 8) + 8))(a2, v59, a3);
    uint64_t v38 = v329;
    uint64_t v76 = v329;
LABEL_9:
    uint64_t v66 = *(void (**)(void))(v76 + 8);
    ((void (*)(char *, uint64_t))v66)(v59, a3);
    uint64_t v67 = v331;
    if (v75) {
      goto LABEL_19;
    }
    goto LABEL_23;
  }
  unint64_t v296 = v11;
  uint64_t v80 = v328;
  uint64_t v81 = v326;
  uint64_t v82 = swift_getAssociatedConformanceWitness((uint64_t)v328, a3, (uint64_t)v326, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v83 = v327;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v82 + 8))(&qword_18162B0B8, 256, v81, v82);
  ((void (*)(char *, uint64_t, int **))v80[3])(v83, a3, v80);
  LOBYTE(v81) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 32))(a2, v59, a3);
  uint64_t v84 = v329;
  uint64_t v85 = v59;
  unint64_t v86 = *(void (**)(void))(v329 + 8);
  char v87 = v85;
  v86();
  (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v41, v69, a3);
  if ((v81 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v86)(v41, a3);
    uint64_t v38 = v329;
    uint64_t v11 = v296;
    uint64_t v66 = v86;
    uint64_t v59 = v87;
    a2 = v69;
    uint64_t v67 = v331;
    goto LABEL_23;
  }
  uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  ((void (*)(char *, uint64_t))v86)(v41, a3);
  uint64_t v38 = v329;
  uint64_t v11 = v296;
  uint64_t v66 = v86;
  uint64_t v59 = v87;
  a2 = v69;
  uint64_t v67 = v331;
  if (!v88) {
    goto LABEL_19;
  }
LABEL_23:
  uint64_t v94 = v322;
  (*(void (**)(uint64_t))(v324 + 56))(a3);
  uint64_t v95 = swift_getAssociatedConformanceWitness(v4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v96 = *(uint64_t (**)(uint64_t *))(v95 + 136);
  uint64_t v295 = v95;
  uint64_t v97 = v96(v11);
  if (v97 > 15)
  {
    (*(void (**)(uint64_t, uint64_t *))(v325 + 8))(v94, v11);
    uint64_t v98 = v320;
    char v99 = v320(a3, v4);
    uint64_t v100 = a2;
    char v101 = v99;
    uint64_t v102 = v315;
    (*(void (**)(char *, char *, uint64_t))(v38 + 16))(v315, v100, a3);
    if (v101)
    {
      if (v98(a3, v4))
      {
        uint64_t v103 = v312(a3, v4);
        if (v103 < 64)
        {
          uint64_t v106 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
          uint64_t v107 = v102;
          goto LABEL_57;
        }
        v332 = 0;
        uint64_t v186 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v187 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
        v186(&v332, &type metadata for Int, v187, a3, v4);
        char v181 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v102, v59, a3);
        ((void (*)(char *, uint64_t))v66)(v59, a3);
        char v182 = v102;
        goto LABEL_53;
      }
      uint64_t v171 = v98;
      uint64_t v172 = v38;
      char v173 = v171(a3, v4);
      uint64_t v174 = v4;
      uint64_t v175 = v312(a3, v4);
      if (v173)
      {
        if (v175 <= 64)
        {
          unint64_t v222 = v328;
          uint64_t v223 = v326;
          uint64_t v224 = swift_getAssociatedConformanceWitness((uint64_t)v328, a3, (uint64_t)v326, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v225 = v327;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v224 + 8))(&qword_18162B0B8, 256, v223, v224);
          ((void (*)(char *, uint64_t, int **))v222[3])(v225, a3, v222);
          unint64_t v226 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16);
          char v227 = v315;
          LOBYTE(v222) = v226(v315, v59, a3);
          ((void (*)(char *, uint64_t))v66)(v59, a3);
          (*(void (**)(char *, char *, uint64_t))(v172 + 32))(v300, v227, a3);
          if ((v222 & 1) == 0)
          {
            uint64_t v237 = v300;
            uint64_t v238 = (*(uint64_t (**)(uint64_t, uint64_t))(v174 + 120))(a3, v174);
            ((void (*)(char *, uint64_t))v66)(v237, a3);
            if (v238 < 0) {
              goto LABEL_136;
            }
            goto LABEL_60;
          }
          ((void (*)(char *, uint64_t))v66)(v300, a3);
LABEL_136:
          char v92 = 0;
          __int16 v188 = -1024;
          goto LABEL_137;
        }
        v332 = 0;
        unint64_t v178 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v175, v176, v177);
        v178(&v332, &type metadata for Int, v179, a3, v4);
        char v180 = v315;
        char v181 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v174 + 32) + 8) + 16))(v315, v59, a3);
        ((void (*)(char *, uint64_t))v66)(v59, a3);
        char v182 = v180;
LABEL_53:
        ((void (*)(char *, uint64_t))v66)(v182, a3);
        if ((v181 & 1) == 0) {
          goto LABEL_60;
        }
        goto LABEL_136;
      }
      uint64_t v102 = v315;
      if (v175 < 64)
      {
        uint64_t v106 = (*(uint64_t (**)(uint64_t))(v4 + 120))(a3);
        uint64_t v107 = v102;
LABEL_57:
        ((void (*)(char *, uint64_t))v66)(v107, a3);
        if (v106 < 0) {
          goto LABEL_136;
        }
LABEL_60:
        char v92 = 0;
        __int16 v188 = 31744;
LABEL_137:
        *uint64_t v330 = v188;
        return v92 & 1;
      }
    }
    ((void (*)(char *, uint64_t))v66)(v102, a3);
    goto LABEL_60;
  }
  uint64_t v300 = a2;
  uint64_t v315 = (char *)v66;
  unint64_t v296 = v11;
  uint64_t v329 = v38;
  unint64_t v294 = v97;
  if (v97 <= 10)
  {
    uint64_t v141 = (uint64_t)v296;
    (*(void (**)(char *, uint64_t, uint64_t *))(v325 + 32))(v67, v94, v296);
    uint64_t v142 = v295;
    uint64_t v143 = *(char **)(v295 + 64);
    uint64_t v322 = v295 + 64;
    char v319 = v143;
    if (((uint64_t (*)(uint64_t, uint64_t))v143)(v141, v295))
    {
      uint64_t v144 = v304;
      (*(void (**)(void))(v325 + 16))();
      uint64_t v145 = v318;
      uint64_t v146 = v311;
      uint64_t v147 = swift_getAssociatedConformanceWitness((uint64_t)v318, v141, (uint64_t)v311, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v148 = v316;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v147 + 8))(&qword_18162B0B8, 256, v146, v147);
      char v149 = v323;
      ((void (*)(char *, uint64_t, int **))v145[3])(v148, v141, v145);
      uint64_t v150 = swift_getAssociatedConformanceWitness(v324, a3, v141, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v146) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v150 + 32))(v144, v149, v141, v150);
      char v151 = *(void (**)(char *, uint64_t))(v325 + 8);
      v151(v149, v141);
      if ((v146 & 1) == 0) {
        goto LABEL_138;
      }
      v151(v144, v141);
      uint64_t v38 = v329;
      uint64_t v67 = v331;
    }
    uint64_t v152 = *(uint64_t (**)(uint64_t, uint64_t))(v142 + 128);
    if (v152(v141, v142) < 16)
    {
LABEL_64:
      int v196 = (*(uint64_t (**)(uint64_t, uint64_t))(v142 + 120))(v141, v142);
      (*(void (**)(char *, uint64_t))(v325 + 8))(v67, v141);
      int v197 = v320;
      char v198 = v320(a3, v4);
      (*(void (**)(char *, char *, uint64_t))(v38 + 16))(v314, v300, a3);
      if (v198)
      {
        if (v197(a3, v4))
        {
          uint64_t v199 = v312(a3, v4);
          if (v199 < 64)
          {
LABEL_67:
            uint64_t v202 = v4;
            uint64_t v203 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 120);
            uint64_t v204 = v314;
            unint64_t v205 = v203(a3, v202);
            ((void (*)(char *, uint64_t))v315)(v204, a3);
            unint64_t v206 = v205 >> 63;
            goto LABEL_121;
          }
          goto LABEL_86;
        }
        char v207 = v197(a3, v4);
        uint64_t v208 = v4;
        uint64_t v199 = v312(a3, v4);
        if (v207)
        {
          if (v199 <= 64)
          {
            uint64_t v239 = v328;
            uint64_t v240 = v326;
            uint64_t v241 = swift_getAssociatedConformanceWitness((uint64_t)v328, a3, (uint64_t)v326, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v242 = v327;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v241 + 8))(&qword_18162B0B8, 256, v240, v241);
            ((void (*)(char *, uint64_t, int **))v239[3])(v242, a3, v239);
            unint64_t v243 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16);
            uint64_t v244 = v314;
            LOBYTE(v24_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = v243(v314, v59, a3);
            ((void (*)(char *, uint64_t))v315)(v59, a3);
            (*(void (**)(char *, char *, uint64_t))(v38 + 32))(v299, v244, a3);
            if (v240) {
              LOBYTE(v206) = 1;
            }
            else {
              unint64_t v206 = (unint64_t)(*(uint64_t (**)(uint64_t, uint64_t))(v208 + 120))(a3, v208) >> 63;
            }
            ((void (*)(char *, uint64_t))v315)(v299, a3);
LABEL_121:
            if ((v294 & 0x8000000000000000) == 0)
            {
              if (v206) {
                __int16 v276 = 0x8000;
              }
              else {
                __int16 v276 = 0;
              }
              *uint64_t v330 = (((_WORD)v294 << 10) + 15360) & 0x7C00 | (v196 << ((10 - v294) & 0xF)) & 0x3FF | v276;
              goto LABEL_20;
            }
LABEL_138:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
          }
LABEL_86:
          v332 = 0;
          unsigned int v231 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
          unint64_t v232 = lazy protocol witness table accessor for type Int and conformance Int(v199, v200, v201);
          v231(&v332, &type metadata for Int, v232, a3, v4);
          unint64_t v233 = v314;
          LOBYTE(v206) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                            + 16))(v314, v59, a3);
          uint64_t v234 = v315;
          ((void (*)(char *, uint64_t))v315)(v59, a3);
          ((void (*)(char *, uint64_t))v234)(v233, a3);
          goto LABEL_121;
        }
        if (v199 < 64) {
          goto LABEL_67;
        }
      }
      ((void (*)(char *, uint64_t))v315)(v314, a3);
      LOBYTE(v206) = 0;
      goto LABEL_121;
    }
    uint64_t v317 = (char *)v4;
    char v313 = v59;
    uint64_t v153 = *(void (**)(char *, char *, uint64_t))(v325 + 16);
    v153(v310, v67, v141);
    LOWORD(v332) = -1;
    char v154 = ((uint64_t (*)(uint64_t, uint64_t))v319)(v141, v142);
    uint64_t v155 = v152(v141, v142);
    if (v154)
    {
      if (v155 <= 16)
      {
        uint64_t v158 = v318;
        uint64_t v159 = (uint64_t)v296;
        uint64_t v160 = v311;
        uint64_t v161 = swift_getAssociatedConformanceWitness((uint64_t)v318, (uint64_t)v296, (uint64_t)v311, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v162 = v316;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v161 + 8))(&qword_18162B0B8, 256, v160, v161);
        uint64_t v163 = v323;
        ((void (*)(char *, uint64_t, int **))v158[3])(v162, v159, v158);
        uint64_t v164 = swift_getAssociatedConformanceWitness(v324, a3, v159, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        uint64_t v165 = v310;
        LOBYTE(v16_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v164 + 40))(v310, v163, v159, v164);
        unsigned int v166 = *(void (**)(char *, uint64_t))(v325 + 8);
        v166(v163, v159);
        unsigned int v167 = (unsigned __int16)v332;
        v153(v301, v165, v159);
        if (v160)
        {
          uint64_t v168 = v301;
          uint64_t v169 = (uint64_t)v296;
          unsigned __int16 v170 = (*(uint64_t (**)(uint64_t *))(v295 + 120))(v296);
          v166(v168, v169);
          if (v167 < v170) {
LABEL_85:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          v166(v301, (uint64_t)v296);
        }
        goto LABEL_63;
      }
    }
    else if (v155 <= 16)
    {
      uint64_t v228 = v323;
      uint64_t v229 = (uint64_t)v296;
      v153(v323, v310, (uint64_t)v296);
      unsigned __int16 v230 = (*(uint64_t (**)(uint64_t))(v295 + 120))(v229);
      unsigned int v166 = *(void (**)(char *, uint64_t))(v325 + 8);
      v166(v228, v229);
      if ((unsigned __int16)v332 < v230) {
        goto LABEL_85;
      }
      goto LABEL_63;
    }
    uint64_t v189 = v295;
    unint64_t v190 = *(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v295 + 96);
    unint64_t v191 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v155, v156, v157);
    uint64_t v192 = v323;
    uint64_t v193 = (uint64_t)v296;
    v190(&v332, &type metadata for UInt16, v191, v296, v189);
    uint64_t v194 = swift_getAssociatedConformanceWitness(v324, a3, v193, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v195 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v194 + 16))(v192, v310, v193, v194);
    unsigned int v166 = *(void (**)(char *, uint64_t))(v325 + 8);
    v166(v192, v193);
    if (v195) {
      goto LABEL_85;
    }
LABEL_63:
    uint64_t v141 = (uint64_t)v296;
    v166(v310, (uint64_t)v296);
    uint64_t v38 = v329;
    uint64_t v59 = v313;
    uint64_t v4 = (uint64_t)v317;
    uint64_t v142 = v295;
    uint64_t v67 = v331;
    goto LABEL_64;
  }
  uint64_t v108 = v97;
  uint64_t v109 = v318;
  uint64_t v110 = (uint64_t)v296;
  uint64_t v111 = v311;
  uint64_t v292 = (uint64_t (*)(void, void))(v97 - 10);
  char v314 = (char *)swift_getAssociatedConformanceWitness((uint64_t)v318, (uint64_t)v296, (uint64_t)v311, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v304 = (char *)*((void *)v314 + 1);
  uint64_t v310 = v314 + 8;
  uint64_t v112 = v316;
  ((void (*)(uint64_t *, uint64_t, const char *, char *))v304)(&qword_18162B0C0, 512, v111, v314);
  uint64_t v113 = v109[3];
  v301 = (char *)(v109 + 3);
  unint64_t v299 = (char *)v113;
  uint64_t v114 = v323;
  uint64_t v115 = ((uint64_t (*)(char *, uint64_t, int **))v113)(v112, v110, v109);
  uint64_t v116 = v295;
  uint64_t v331 = (char *)(v295 + 256);
  v332 = (uint64_t (*)(void, void))(v108 - 11);
  uint64_t v117 = *(void (**)(char *, uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v295 + 256);
  unint64_t v293 = lazy protocol witness table accessor for type Int and conformance Int(v115, v118, v119);
  v117(v114, &v332, &type metadata for Int, v293, v110, v116);
  uint64_t v120 = v325 + 8;
  uint64_t v331 = *(char **)(v325 + 8);
  ((void (*)(char *, uint64_t))v331)(v114, v110);
  uint64_t v121 = v316;
  ((void (*)(void *, uint64_t, const char *, char *))v304)(&unk_18162B0D0, 768, v111, v314);
  uint64_t v122 = v305;
  ((void (*)(char *, uint64_t, int **))v299)(v121, v110, v318);
  uint64_t v123 = AssociatedConformanceWitness;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(AssociatedConformanceWitness + 64))(v122, v317, v110, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t))v331)(v122, v110);
  ((void (*)(uint64_t *, uint64_t, const char *, char *))v304)(&qword_18162B0C0, 512, v111, v314);
  ((void (*)(char *, uint64_t, int **))v299)(v121, v110, v318);
  uint64_t v124 = v306;
  uint64_t v125 = v323;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v123 + 8) + 40))(v323, v122, v110);
  uint64_t v126 = (void (*)(char *, uint64_t))v331;
  ((void (*)(char *, uint64_t))v331)(v122, v110);
  v126(v125, v110);
  uint64_t v127 = v295;
  uint64_t v128 = v322;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v295 + 192))(v322, v124, v110, v295);
  v126(v124, v110);
  v332 = v292;
  uint64_t v129 = v323;
  (*(void (**)(uint64_t, uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v127 + 240))(v128, &v332, &type metadata for Int, v293, v110, v127);
  v126((char *)v128, v110);
  uint64_t v130 = *(uint64_t (**)(void, void))(v127 + 120);
  v305 = (char *)(v127 + 120);
  uint64_t v292 = v130;
  uint64_t v131 = v130(v110, v127);
  uint64_t v132 = v126;
  uint64_t AssociatedConformanceWitness = v120;
  v126(v129, v110);
  char v306 = (char *)v131;
  LODWORD(v322) = v131 & 0x3FF;
  uint64_t v133 = swift_getAssociatedConformanceWitness(v324, a3, v110, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  uint64_t v134 = *(uint64_t (**)(char *, char *, uint64_t))(v133 + 40);
  uint64_t v135 = v319;
  uint64_t v136 = v317;
  uint64_t v324 = v133;
  LOBYTE(v131) = v134(v319, v317, v110);
  uint64_t v137 = v325;
  uint64_t v138 = v309;
  (*(void (**)(char *, char *, uint64_t))(v325 + 16))(v309, v135, v110);
  uint64_t v139 = *(char **)(v137 + 32);
  uint64_t v140 = v308;
  uint64_t v325 = v137 + 32;
  uint64_t v317 = v139;
  ((void (*)(char *, char *, uint64_t))v139)(v308, v136, v110);
  if (v131)
  {
    v132(v140, v110);
    v132(v138, v110);
  }
  else
  {
    char v183 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v324 + 8) + 8))(v138, v140, v110);
    v132(v140, v110);
    v132(v138, v110);
    if ((v183 & 1) == 0 || (v306 & 1) == 0) {
      goto LABEL_74;
    }
  }
  if (v322 == 1023)
  {
    if (v294 >= 0xF)
    {
      ((void (*)(char *, uint64_t *))v331)(v319, v296);
      char v184 = v320(a3, v4);
      (*(void (**)(char *, char *, uint64_t))(v329 + 16))(v303, v300, a3);
      if (v184)
      {
        if (v320(a3, v4))
        {
          if (v312(a3, v4) < 64)
          {
LABEL_130:
            uint64_t v281 = v303;
            uint64_t v282 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
            ((void (*)(char *, uint64_t))v315)(v281, a3);
            if (v282 < 0) {
              goto LABEL_136;
            }
            goto LABEL_60;
          }
LABEL_127:
          v332 = 0;
          (*(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96))(&v332, &type metadata for Int, v293, a3, v4);
          unint64_t v278 = v303;
          char v279 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v303, v59, a3);
          char v280 = v315;
          ((void (*)(char *, uint64_t))v315)(v59, a3);
          ((void (*)(char *, uint64_t))v280)(v278, a3);
          if (v279) {
            goto LABEL_136;
          }
          goto LABEL_60;
        }
        char v273 = v320(a3, v4);
        uint64_t v274 = v4;
        uint64_t v275 = v312(a3, v4);
        if (v273)
        {
          if (v275 <= 64)
          {
            char v283 = v328;
            uint64_t v284 = v326;
            uint64_t v285 = swift_getAssociatedConformanceWitness((uint64_t)v328, a3, (uint64_t)v326, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v286 = v327;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v285 + 8))(&qword_18162B0B8, 256, v284, v285);
            ((void (*)(char *, uint64_t, int **))v283[3])(v286, a3, v283);
            uint64_t v287 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16);
            uint64_t v288 = v303;
            LOBYTE(v283) = v287(v303, v59, a3);
            uint64_t v289 = v329;
            ((void (*)(char *, uint64_t))v315)(v59, a3);
            (*(void (**)(char *, char *, uint64_t))(v289 + 32))(v297, v288, a3);
            if (v283)
            {
              ((void (*)(char *, uint64_t))v315)(v297, a3);
            }
            else
            {
              uint64_t v290 = v297;
              uint64_t v291 = (*(uint64_t (**)(uint64_t, uint64_t))(v274 + 120))(a3, v274);
              ((void (*)(char *, uint64_t))v315)(v290, a3);
              if ((v291 & 0x8000000000000000) == 0) {
                goto LABEL_60;
              }
            }
            goto LABEL_136;
          }
          goto LABEL_127;
        }
        if (v275 < 64) {
          goto LABEL_130;
        }
      }
      ((void (*)(char *, uint64_t))v315)(v303, a3);
      goto LABEL_60;
    }
    ++v294;
    int v185 = 1024;
  }
  else
  {
    int v185 = v322 + 1;
  }
  LODWORD(v322) = v185;
LABEL_74:
  unint64_t v209 = v320;
  char v210 = v320(a3, v4);
  (*(void (**)(char *, char *, uint64_t))(v329 + 16))(v313, v300, a3);
  if ((v210 & 1) == 0) {
    goto LABEL_94;
  }
  uint64_t v211 = v4;
  if (v209(a3, v4))
  {
    if (v312(a3, v4) < 64)
    {
      char v212 = v313;
      uint64_t v213 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t v214 = v212;
LABEL_91:
      ((void (*)(char *, uint64_t))v315)(v214, a3);
      goto LABEL_92;
    }
LABEL_80:
    v332 = 0;
    (*(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96))(&v332, &type metadata for Int, v293, a3, v4);
    uint64_t v217 = v313;
    char v218 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v313, v59, a3);
    int v219 = v315;
    ((void (*)(char *, uint64_t))v315)(v59, a3);
    ((void (*)(char *, uint64_t))v219)(v217, a3);
    __int16 v220 = v294;
    __int16 v221 = v322 & 0x3FF;
    if ((v218 & 1) == 0) {
      goto LABEL_93;
    }
LABEL_102:
    __int16 v236 = 0x8000;
    goto LABEL_103;
  }
  char v215 = v209(a3, v4);
  uint64_t v216 = v312(a3, v4);
  if ((v215 & 1) == 0)
  {
    if (v216 < 64)
    {
      unsigned int v235 = v313;
      uint64_t v213 = (*(uint64_t (**)(uint64_t, uint64_t))(v211 + 120))(a3, v211);
      uint64_t v214 = v235;
      goto LABEL_91;
    }
LABEL_94:
    ((void (*)(char *, uint64_t))v315)(v313, a3);
    __int16 v236 = 0;
    __int16 v220 = v294;
    __int16 v221 = v322 & 0x3FF;
    goto LABEL_103;
  }
  if (v216 > 64) {
    goto LABEL_80;
  }
  char v245 = v328;
  unint64_t v246 = v326;
  uint64_t v247 = swift_getAssociatedConformanceWitness((uint64_t)v328, a3, (uint64_t)v326, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v248 = v327;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v247 + 8))(&qword_18162B0B8, 256, v246, v247);
  ((void (*)(char *, uint64_t, int **))v245[3])(v248, a3, v245);
  unint64_t v249 = v313;
  LOBYTE(v246) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v211 + 32) + 8) + 16))(v313, v59, a3);
  uint64_t v250 = v329;
  ((void (*)(char *, uint64_t))v315)(v59, a3);
  (*(void (**)(char *, char *, uint64_t))(v250 + 32))(v298, v249, a3);
  if (v246)
  {
    ((void (*)(char *, uint64_t))v315)(v298, a3);
    __int16 v220 = v294;
    __int16 v221 = v322 & 0x3FF;
    goto LABEL_102;
  }
  uint64_t v277 = v298;
  uint64_t v213 = (*(uint64_t (**)(uint64_t, uint64_t))(v211 + 120))(a3, v211);
  ((void (*)(char *, uint64_t))v315)(v277, a3);
LABEL_92:
  __int16 v220 = v294;
  __int16 v221 = v322 & 0x3FF;
  if (v213 < 0) {
    goto LABEL_102;
  }
LABEL_93:
  __int16 v236 = 0;
LABEL_103:
  *uint64_t v330 = ((v221 | (v220 << 10)) + 15360) | v236;
  uint64_t v251 = v295;
  char v252 = *(uint64_t (**)(uint64_t *, uint64_t))(v295 + 64);
  uint64_t v253 = (uint64_t)v296;
  if (v252(v296, v295))
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v251 + 128))(v253, v251) < 64) {
      goto LABEL_111;
    }
    goto LABEL_108;
  }
  char v254 = v252((uint64_t *)v253, v251);
  uint64_t v255 = (*(uint64_t (**)(uint64_t, uint64_t))(v251 + 128))(v253, v251);
  if (v254)
  {
    if (v255 > 64)
    {
LABEL_108:
      v332 = 0;
      char v256 = v323;
      uint64_t v257 = (uint64_t)v296;
      (*(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t *))(v295 + 96))(&v332, &type metadata for Int, v293, v296);
      char v258 = v319;
      char v92 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v324 + 8) + 8))(v319, v256, v257);
      uint64_t v259 = v256;
      uint64_t v260 = (void (*)(char *, uint64_t))v331;
      ((void (*)(char *, uint64_t))v331)(v259, v257);
      v260(v258, v257);
      return v92 & 1;
    }
    uint64_t v264 = v316;
    ((void (*)(uint64_t *, uint64_t))v304)(&qword_18162B0B8, 256);
    char v265 = v323;
    uint64_t v266 = (uint64_t)v296;
    ((void (*)(char *, uint64_t *, int **))v299)(v264, v296, v318);
    char v267 = v319;
    LOBYTE(v264) = (*(uint64_t (**)(char *, char *, uint64_t))(v324 + 32))(v319, v265, v266);
    ((void (*)(char *, uint64_t))v331)(v265, v266);
    ((void (*)(char *, char *, uint64_t))v317)(v302, v267, v266);
    char v92 = (v264 & 1) != 0 && v292(v296, v295) == 0;
    ((void (*)(char *, uint64_t *))v331)(v302, v296);
  }
  else
  {
    if (v255 < 64)
    {
LABEL_111:
      uint64_t v261 = v323;
      uint64_t v262 = (uint64_t)v296;
      ((void (*)(char *, char *, uint64_t *))v317)(v323, v319, v296);
      uint64_t v263 = v292(v262, v295);
      ((void (*)(char *, uint64_t))v331)(v261, v262);
      char v92 = v263 == 0;
      return v92 & 1;
    }
    v332 = 0;
    unint64_t v268 = v323;
    uint64_t v269 = (uint64_t)v296;
    (*(void (**)(uint64_t (**)(void, void), ValueMetadata *, unint64_t, uint64_t *))(v295 + 96))(&v332, &type metadata for Int, v293, v296);
    uint64_t v270 = v319;
    char v92 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v324 + 8) + 8))(v319, v268, v269);
    uint64_t v271 = v270;
    uint64_t v272 = (void (*)(char *, uint64_t))v331;
    ((void (*)(char *, uint64_t))v331)(v271, v269);
    v272(v268, v269);
  }
  return v92 & 1;
}

uint64_t static BinaryFloatingPoint<>._convert<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v561 = a7;
  uint64_t v568 = a6;
  uint64_t v566 = (int **)a5;
  uint64_t v571 = a2;
  uint64_t v555 = a1;
  uint64_t v11 = *(void *)(a6 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v11, a4, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v11, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v522 = *(int ***)(AssociatedConformanceWitness + 16);
  v517 = swift_getAssociatedTypeWitness(0, v522, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v517);
  uint64_t v516 = (char *)&v479 - v13;
  uint64_t v14 = *(void *)(a5 + 16);
  uint64_t v15 = swift_getAssociatedTypeWitness(255, (int **)v14, a3, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v537 = *(void *)(swift_getAssociatedConformanceWitness(v14, a3, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  v495 = *(int ***)(*(void *)(v537 + 24) + 16);
  uint64_t v494 = swift_getAssociatedTypeWitness(0, v495, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v494);
  uint64_t v493 = (char *)&v479 - v16;
  uint64_t v532 = swift_checkMetadataState(0, (uint64_t)v15);
  uint64_t v525 = *(v532 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v532);
  unint64_t v484 = (char *)&v479 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v485 = (char *)&v479 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  unint64_t v508 = (char *)&v479 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v507 = (uint64_t (*)(void))((char *)&v479 - v24);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v492 = (char *)&v479 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v519 = (char *)&v479 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v534 = (char *)&v479 - v29;
  unint64_t v533 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v535 = *(v533 - 1);
  uint64_t v30 = MEMORY[0x1F4188790](v533);
  uint64_t v487 = (char *)&v479 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v504 = (char *)&v479 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  unint64_t v505 = (char *)&v479 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  v520 = (char *)&v479 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v502 = (char *)&v479 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  unint64_t v503 = (char *)&v479 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  uint64_t v521 = (char *)&v479 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  uint64_t v526 = (char *)&v479 - v45;
  MEMORY[0x1F4188790](v44);
  uint64_t v538 = (char *)&v479 - v46;
  uint64_t v531 = (void (**)(uint64_t))v11;
  uint64_t v542 = *(int ***)(v11 + 16);
  uint64_t v569 = a4;
  uint64_t v540 = swift_getAssociatedTypeWitness(0, v542, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v47 = MEMORY[0x1F4188790](v540);
  uint64_t v541 = (char *)&v479 - v48;
  uint64_t v570 = *(void *)(a4 - 8);
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  uint64_t v488 = (char *)&v479 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  uint64_t v518 = (char *)&v479 - v52;
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  uint64_t v483 = (char *)&v479 - v54;
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  uint64_t v512 = (char *)&v479 - v56;
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  uint64_t v481 = (char *)&v479 - v58;
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  char v496 = (char *)&v479 - v60;
  uint64_t v61 = MEMORY[0x1F4188790](v59);
  v486 = (char *)&v479 - v62;
  uint64_t v63 = MEMORY[0x1F4188790](v61);
  char v509 = (char *)&v479 - v64;
  uint64_t v65 = MEMORY[0x1F4188790](v63);
  uint64_t v539 = (char *)&v479 - v66;
  MEMORY[0x1F4188790](v65);
  uint64_t v558 = (char *)&v479 - v67;
  uint64_t v565 = *(void *)(a7 + 8);
  unint64_t v574 = *(int ***)(*(void *)(v565 + 24) + 16);
  char v68 = v574;
  char v69 = v566;
  uint64_t v70 = swift_getAssociatedTypeWitness(255, v566, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  unsigned __int16 v573 = swift_getAssociatedTypeWitness(0, v68, (uint64_t)v70, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v573);
  uint64_t v572 = (char *)&v479 - v71;
  unint64_t v567 = swift_checkMetadataState(0, (uint64_t)v70);
  uint64_t v559 = *(v567 - 1);
  uint64_t v72 = MEMORY[0x1F4188790](v567);
  uint64_t v497 = (char *)&v479 - ((v73 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v74 = MEMORY[0x1F4188790](v72);
  uint64_t v482 = (char *)&v479 - v75;
  uint64_t v76 = MEMORY[0x1F4188790](v74);
  v498 = (char *)&v479 - v77;
  uint64_t v78 = MEMORY[0x1F4188790](v76);
  char v523 = (char *)&v479 - v79;
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  uint64_t v515 = (char *)&v479 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  uint64_t v560 = (char *)&v479 - v83;
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  unint64_t v576 = (char *)&v479 - v85;
  uint64_t v86 = MEMORY[0x1F4188790](v84);
  unint64_t v575 = (char *)&v479 - v87;
  uint64_t v88 = *(void *)(a3 - 8);
  uint64_t v89 = MEMORY[0x1F4188790](v86);
  uint64_t v489 = (char *)&v479 - ((v90 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v91 = MEMORY[0x1F4188790](v89);
  uint64_t v524 = (char *)&v479 - v92;
  MEMORY[0x1F4188790](v91);
  uint64_t v94 = (char *)&v479 - v93;
  uint64_t v536 = v14;
  uint64_t v490 = *(void *)(v14 + 16);
  uint64_t v95 = *(void *)(*(void *)(v490 + 8) + 16);
  uint64_t v96 = swift_getAssociatedTypeWitness(0, (int **)v95, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v96);
  uint64_t v98 = (void (*)(char *, uint64_t))((char *)&v479 - v97);
  uint64_t v554 = swift_getAssociatedTypeWitness(0, v69, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v553 = *((void *)v554 - 1);
  uint64_t v99 = MEMORY[0x1F4188790](v554);
  uint64_t v510 = (char *)&v479 - ((v100 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v101 = MEMORY[0x1F4188790](v99);
  unint64_t v511 = (char *)&v479 - v102;
  MEMORY[0x1F4188790](v101);
  uint64_t v104 = (char *)&v479 - v103;
  uint64_t v105 = swift_getAssociatedConformanceWitness(v95, a3, (uint64_t)v96, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v106 = *(void (**)(uint64_t *, uint64_t))(v105 + 8);
  uint64_t v550 = (uint64_t)v96;
  uint64_t v548 = v105;
  v547 = (uint64_t (*)(void))(v105 + 8);
  uint64_t v546 = v106;
  ((void (*)(uint64_t *, uint64_t, const char *))v106)(&qword_18162B0C0, 512, v96);
  uint64_t v107 = *(void (**)(void, void))(v95 + 24);
  v549 = v98;
  uint64_t v551 = v95;
  uint64_t v545 = v95 + 24;
  v544 = v107;
  ((void (*)(void (*)(char *, uint64_t), uint64_t, uint64_t))v107)(v98, a3, v95);
  uint64_t v108 = v69[14];
  v552 = v104;
  uint64_t v109 = v69;
  ((void (*)(uint64_t, int **))v108)(a3, v69);
  uint64_t v110 = *(void (**)(char *, uint64_t))(v88 + 8);
  uint64_t v491 = v94;
  uint64_t v530 = v88 + 8;
  uint64_t v529 = v110;
  v110(v94, a3);
  uint64_t v111 = v567;
  uint64_t v113 = v573;
  uint64_t v112 = (uint64_t)v574;
  uint64_t v114 = swift_getAssociatedConformanceWitness((uint64_t)v574, (uint64_t)v567, (uint64_t)v573, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v556 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v114 + 8);
  uint64_t v115 = v572;
  v556(&qword_18162B0C0, 512, v113, v114);
  uint64_t v116 = v112;
  uint64_t v117 = v112 + 24;
  uint64_t v557 = *(void (**)(char *, uint64_t *, uint64_t))(v112 + 24);
  uint64_t v118 = v560;
  v557(v115, v111, v116);
  uint64_t v119 = v109[13];
  uint64_t v564 = a3;
  uint64_t v514 = (int *)(v109 + 13);
  uint64_t v513 = v119;
  uint64_t v577 = ((uint64_t (*)(uint64_t, int **))v119)(a3, v109);
  uint64_t v120 = *(void (**)(char *, uint64_t *, ValueMetadata *))(v565 + 256);
  unint64_t v543 = lazy protocol witness table accessor for type Int and conformance Int(v577, v121, v122);
  v120(v118, &v577, &type metadata for Int);
  uint64_t v123 = v569;
  uint64_t v124 = v559 + 8;
  uint64_t v125 = *(void (**)(char *, uint64_t *))(v559 + 8);
  v125(v118, v111);
  uint64_t v126 = v572;
  uint64_t v501 = v114;
  uint64_t v500 = v114 + 8;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18162B0C0, 512);
  uint64_t v127 = v126;
  uint64_t v128 = v123;
  uint64_t v129 = v568;
  uint64_t v499 = v117;
  v557(v127, v111, (uint64_t)v574);
  uint64_t v130 = v576;
  (*(void (**)(char *, char *, uint64_t *))(v561 + 88))(v575, v118, v111);
  v125(v118, v111);
  uint64_t v131 = v111;
  uint64_t v562 = v124;
  uint64_t v563 = v125;
  v125(v130, v111);
  uint64_t v132 = *(uint64_t (**)(uint64_t, uint64_t))(v129 + 64);
  char v133 = v132(v128, v129);
  uint64_t v528 = v129 + 64;
  uint64_t v527 = v132;
  if (v133)
  {
    uint64_t v134 = *(uint64_t (**)(uint64_t, uint64_t))(v129 + 128);
    uint64_t v135 = v571;
    if (v134(v128, v129) < 64)
    {
      uint64_t v136 = v570;
      uint64_t v137 = v558;
      (*(void (**)(char *, uint64_t, uint64_t))(v570 + 16))(v558, v135, v128);
      uint64_t v138 = (*(uint64_t (**)(uint64_t, uint64_t))(v129 + 120))(v128, v129);
      uint64_t v139 = v137;
      uint64_t v140 = *(void (**)(char *, uint64_t))(v136 + 8);
      v140(v139, v128);
      uint64_t v141 = v564;
      if (v138) {
        goto LABEL_8;
      }
      goto LABEL_19;
    }
LABEL_7:
    uint64_t v577 = 0;
    uint64_t v144 = v558;
    (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v129 + 96))(&v577, &type metadata for Int, v543, v128, v129);
    char v145 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v129 + 16) + 8) + 8))(v135, v144, v128);
    uint64_t v140 = *(void (**)(char *, uint64_t))(v570 + 8);
    v140(v144, v128);
    uint64_t v141 = v564;
    if ((v145 & 1) == 0)
    {
LABEL_8:
      uint64_t v146 = v129;
      goto LABEL_9;
    }
LABEL_19:
    v563(v575, v131);
    (*(void (**)(char *, const char *))(v553 + 8))(v552, v554);
    uint64_t v177 = v549;
    v546(&qword_18162B0B8, 256);
    ((void (*)(void (*)(char *, uint64_t), uint64_t, uint64_t))v544)(v177, v141, v551);
LABEL_20:
    char v178 = 1;
    return v178 & 1;
  }
  char v142 = v132(v128, v129);
  uint64_t v134 = *(uint64_t (**)(uint64_t, uint64_t))(v129 + 128);
  uint64_t v135 = v571;
  uint64_t v143 = v134(v128, v129);
  if (v142)
  {
    if (v143 > 64) {
      goto LABEL_7;
    }
    unsigned int v166 = v542;
    unsigned int v167 = v540;
    uint64_t v168 = swift_getAssociatedConformanceWitness((uint64_t)v542, v128, (uint64_t)v540, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v169 = v541;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v168 + 8))(&qword_18162B0B8, 256, v167, v168);
    unsigned __int16 v170 = v558;
    ((void (*)(char *, uint64_t, int **))v166[3])(v169, v128, v166);
    LOBYTE(v166) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v129 + 32) + 8) + 32))(v135, v170, v128);
    uint64_t v171 = v570;
    uint64_t v146 = v129;
    uint64_t v172 = *(void (**)(char *, uint64_t))(v570 + 8);
    v172(v170, v128);
    char v173 = *(void (**)(char *, uint64_t, uint64_t))(v171 + 16);
    uint64_t v174 = v539;
    v173(v539, v135, v128);
    if (v166)
    {
      uint64_t v175 = (*(uint64_t (**)(uint64_t, uint64_t))(v129 + 120))(v128, v129);
      v172(v174, v128);
      uint64_t v140 = v172;
      uint64_t v141 = v564;
      if (!v175) {
        goto LABEL_19;
      }
    }
    else
    {
      v172(v174, v128);
      uint64_t v140 = v172;
      uint64_t v141 = v564;
    }
  }
  else
  {
    uint64_t v163 = v570;
    uint64_t v146 = v129;
    uint64_t v141 = v564;
    uint64_t v164 = v558;
    if (v143 >= 64)
    {
      uint64_t v577 = 0;
      (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v146 + 96))(&v577, &type metadata for Int, v543, v128, v146);
      char v176 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v146 + 16) + 8) + 8))(v135, v164, v128);
      uint64_t v140 = *(void (**)(char *, uint64_t))(v163 + 8);
      v140(v164, v128);
      if (v176) {
        goto LABEL_19;
      }
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v570 + 16))(v558, v135, v128);
      uint64_t v165 = (*(uint64_t (**)(uint64_t, uint64_t))(v146 + 120))(v128, v146);
      uint64_t v140 = *(void (**)(char *, uint64_t))(v163 + 8);
      v140(v164, v128);
      if (!v165) {
        goto LABEL_19;
      }
    }
  }
LABEL_9:
  v549 = v140;
  v531[7](v128);
  uint64_t v147 = v533;
  uint64_t v148 = swift_getAssociatedConformanceWitness(v146, v128, (uint64_t)v533, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  char v149 = *(uint64_t (**)(uint64_t *))(v148 + 136);
  uint64_t v550 = v148;
  uint64_t v551 = v149(v147);
  uint64_t v150 = v536;
  char v151 = *(void (**)(void, void))(v536 + 120);
  uint64_t v152 = v524;
  uint64_t v545 = v536 + 120;
  v544 = v151;
  v151(v141, v536);
  uint64_t v153 = *(void (**)(uint64_t, uint64_t))(v150 + 176);
  char v154 = v534;
  uint64_t v539 = (char *)(v150 + 176);
  uint64_t v480 = v153;
  v153(v141, v150);
  v529(v152, v141);
  uint64_t v155 = v537;
  uint64_t v156 = v537 + 64;
  uint64_t v157 = *(uint64_t (**)(void))(v537 + 64);
  uint64_t v158 = v532;
  char v159 = ((uint64_t (*)(uint64_t *, uint64_t))v157)(v532, v537);
  uint64_t v548 = v156;
  v547 = v157;
  if (v159)
  {
    uint64_t v160 = *(uint64_t (**)(void))(v155 + 128);
    if (((uint64_t (*)(uint64_t *, uint64_t))v160)(v158, v155) >= 64)
    {
      uint64_t v577 = v551;
      uint64_t v189 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v155 + 96);
      uint64_t v546 = (void (*)(uint64_t *, uint64_t))v134;
      unint64_t v190 = v160;
      unint64_t v191 = v519;
      v189(&v577, &type metadata for Int, v543, v158, v155);
      char v192 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v155 + 32) + 8) + 16))(v154, v191, v158);
      uint64_t v193 = v191;
      uint64_t v160 = v190;
      uint64_t v134 = (uint64_t (*)(uint64_t, uint64_t))v546;
      char v162 = *(void (**)(char *, uint64_t *))(v525 + 8);
      v162(v193, v158);
      v162(v154, v158);
      if ((v192 & 1) == 0) {
        goto LABEL_58;
      }
      goto LABEL_40;
    }
    uint64_t v161 = (*(uint64_t (**)(uint64_t *, uint64_t))(v155 + 120))(v158, v155);
    char v162 = *(void (**)(char *, uint64_t *))(v525 + 8);
    v162(v154, v158);
LABEL_30:
    if (v161 >= v551) {
      goto LABEL_58;
    }
LABEL_40:
    (*(void (**)(char *, uint64_t *))(v535 + 8))(v538, v147);
    v563(v575, v131);
    (*(void (**)(char *, const char *))(v553 + 8))(v552, v554);
    uint64_t v210 = v568;
    uint64_t v209 = v569;
    uint64_t v211 = v527;
    char v212 = v527(v569, v568);
    uint64_t v213 = v518;
    (*(void (**)(char *, uint64_t, uint64_t))(v570 + 16))(v518, v571, v209);
    if (v212)
    {
      if (v211(v209, v210))
      {
        if (v134(v209, v210) < 64)
        {
          uint64_t v214 = (*(uint64_t (**)(uint64_t, uint64_t))(v210 + 120))(v209, v210);
LABEL_52:
          uint64_t v226 = v214;
          v549(v213, v209);
          goto LABEL_53;
        }
        uint64_t v577 = 0;
        uint64_t v224 = v558;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v210 + 96))(&v577, &type metadata for Int, v543, v209, v210);
        char v221 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v210 + 32) + 8) + 16))(v213, v224, v209);
        uint64_t v225 = v549;
        v549(v224, v209);
        v225(v213, v209);
        goto LABEL_48;
      }
      char v215 = v211(v209, v210);
      uint64_t v216 = v134(v209, v210);
      if (v215)
      {
        if (v216 <= 64)
        {
          char v319 = v542;
          uint64_t v320 = v569;
          uint64_t v321 = v540;
          uint64_t v322 = swift_getAssociatedConformanceWitness((uint64_t)v542, v569, (uint64_t)v540, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v323 = v541;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v322 + 8))(&qword_18162B0B8, 256, v321, v322);
          uint64_t v324 = v558;
          ((void (*)(char *, uint64_t, int **))v319[3])(v323, v320, v319);
          uint64_t v325 = v518;
          LOBYTE(v319) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v568 + 32) + 8)
                                                                            + 16))(v518, v324, v320);
          uint64_t v326 = v570;
          v549(v324, v320);
          (*(void (**)(char *, char *, uint64_t))(v326 + 32))(v488, v325, v320);
          if ((v319 & 1) == 0)
          {
            uint64_t v342 = v569;
            uint64_t v343 = v488;
            uint64_t v226 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
            v549(v343, v342);
            uint64_t v141 = v564;
LABEL_53:
            if (v226 < 0) {
              goto LABEL_88;
            }
LABEL_56:
            (*(void (**)(uint64_t))(v536 + 112))(v141);
LABEL_90:
            char v178 = 0;
            return v178 & 1;
          }
          v549(v488, v569);
          uint64_t v141 = v564;
LABEL_88:
          uint64_t v327 = v491;
          (*(void (**)(uint64_t))(v536 + 112))(v141);
          (*(void (**)(char *, uint64_t))(v490 + 16))(v327, v141);
          char v328 = v327;
          uint64_t v329 = v141;
LABEL_89:
          v529(v328, v329);
          goto LABEL_90;
        }
        uint64_t v577 = 0;
        uint64_t v217 = v568;
        uint64_t v218 = v569;
        int v219 = v558;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v568 + 96))(&v577, &type metadata for Int, v543, v569, v568);
        __int16 v220 = v518;
        char v221 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v217 + 32) + 8) + 16))(v518, v219, v218);
        unint64_t v222 = v219;
        uint64_t v223 = v549;
        v549(v222, v218);
        v223(v220, v218);
        uint64_t v141 = v564;
LABEL_48:
        if ((v221 & 1) == 0) {
          goto LABEL_56;
        }
        goto LABEL_88;
      }
      uint64_t v141 = v564;
      uint64_t v209 = v569;
      uint64_t v213 = v518;
      if (v216 < 64)
      {
        uint64_t v214 = (*(uint64_t (**)(uint64_t, uint64_t))(v568 + 120))(v569, v568);
        goto LABEL_52;
      }
    }
    v549(v213, v209);
    goto LABEL_56;
  }
  char v180 = ((uint64_t (*)(uint64_t *, uint64_t))v157)(v158, v155);
  uint64_t v181 = v155;
  char v182 = v180;
  uint64_t v160 = *(uint64_t (**)(void))(v181 + 128);
  uint64_t v183 = v160(v158);
  if (v182)
  {
    uint64_t v184 = v525;
    if (v183 <= 64)
    {
      v507 = v160;
      uint64_t v546 = (void (*)(uint64_t *, uint64_t))v134;
      int v196 = v495;
      int v197 = v494;
      uint64_t v198 = swift_getAssociatedConformanceWitness((uint64_t)v495, (uint64_t)v158, (uint64_t)v494, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v199 = v493;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v198 + 8))(&qword_18162B0B8, 256, v197, v198);
      uint64_t v200 = v519;
      ((void (*)(char *, uint64_t *, int **))v196[3])(v199, v158, v196);
      uint64_t v201 = v534;
      LOBYTE(v197) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v537 + 32) + 8)
                                                                          + 16))(v534, v200, v158);
      uint64_t v202 = *(void (**)(char *, uint64_t *))(v184 + 8);
      v202(v200, v158);
      uint64_t v203 = v492;
      (*(void (**)(char *, char *, uint64_t *))(v184 + 32))(v492, v201, v158);
      if (v197)
      {
        v202(v203, v158);
        uint64_t v134 = (uint64_t (*)(uint64_t, uint64_t))v546;
      }
      else
      {
        uint64_t v208 = (*(uint64_t (**)(uint64_t *))(v537 + 120))(v158);
        char v162 = v202;
        v202(v203, v158);
        uint64_t v134 = (uint64_t (*)(uint64_t, uint64_t))v546;
        uint64_t v160 = v507;
        if (v208 >= v551) {
          goto LABEL_58;
        }
      }
      goto LABEL_40;
    }
    uint64_t v577 = v551;
    uint64_t v185 = v537;
    uint64_t v186 = v519;
    (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v537 + 96))(&v577, &type metadata for Int, v543, v158, v537);
    unint64_t v187 = *(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v185 + 32) + 8) + 16);
    __int16 v188 = v534;
    LODWORD(v546) = v187(v534, v186, v158);
    char v162 = *(void (**)(char *, uint64_t *))(v184 + 8);
    v162(v186, v158);
  }
  else
  {
    uint64_t v194 = v525;
    if (v183 < 64)
    {
      char v195 = v534;
      uint64_t v161 = (*(uint64_t (**)(uint64_t *))(v537 + 120))(v158);
      char v162 = *(void (**)(char *, uint64_t *))(v194 + 8);
      v162(v195, v158);
      goto LABEL_30;
    }
    (*(void (**)(uint64_t (*)(void), char *, uint64_t *))(v525 + 32))(v507, v534, v158);
    if (v551 <= 0)
    {
      char v162 = *(void (**)(char *, uint64_t *))(v194 + 8);
      v162((char *)v507, v158);
      goto LABEL_58;
    }
    uint64_t v577 = v551;
    uint64_t v204 = v537;
    unint64_t v205 = v519;
    (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v537 + 96))(&v577, &type metadata for Int, v543, v158, v537);
    unint64_t v206 = *(uint64_t (**)(uint64_t (*)(void), char *, uint64_t *))(*(void *)(*(void *)(v204 + 32) + 8)
                                                                                       + 16);
    __int16 v188 = (char *)v507;
    LODWORD(v546) = v206(v507, v205, v158);
    char v207 = v205;
    char v162 = *(void (**)(char *, uint64_t *))(v194 + 8);
    v162(v207, v158);
  }
  v162(v188, v158);
  if (v546) {
    goto LABEL_40;
  }
LABEL_58:
  char v227 = v566;
  uint64_t v228 = v513;
  uint64_t v229 = ((uint64_t (*)(uint64_t, int **))v513)(v141, v566);
  if (v229 >= v551)
  {
    uint64_t v271 = v228;
    uint64_t v272 = v563;
    v563(v575, v131);
    uint64_t v273 = ((uint64_t (*)(uint64_t, int **))v271)(v141, v227);
    uint64_t v274 = v273 - v551;
    uint64_t v275 = v526;
    (*(void (**)(char *, char *, uint64_t *))(v535 + 32))(v526, v538, v147);
    uint64_t v276 = v565;
    uint64_t v277 = v576;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t *, uint64_t))(v565 + 88))(v275, v147, v550, v131, v565);
    uint64_t v577 = v274;
    unint64_t v278 = v560;
    (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v276 + 96))(&v577, &type metadata for Int, v543, v131, v276);
    (*(void (**)(char *, char *, uint64_t *))(v561 + 216))(v277, v278, v131);
    v272(v278, v131);
    v272(v277, v131);
    uint64_t v280 = v568;
    uint64_t v279 = v569;
    uint64_t v281 = v527;
    LOBYTE(v278) = v527(v569, v568);
    uint64_t v282 = v509;
    (*(void (**)(char *, uint64_t, uint64_t))(v570 + 16))(v509, v571, v279);
    if (v278)
    {
      uint64_t v283 = v551;
      if (v281(v279, v280))
      {
        if (v134(v279, v280) < 64)
        {
          uint64_t v279 = v569;
          uint64_t v284 = v509;
          uint64_t v285 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
          uint64_t v286 = v284;
          goto LABEL_93;
        }
        goto LABEL_79;
      }
      char v300 = v527(v279, v280);
      uint64_t v301 = v134(v279, v280);
      if (v300)
      {
        if (v301 <= 64)
        {
          char v344 = v542;
          uint64_t v345 = v569;
          v346 = v540;
          uint64_t v347 = swift_getAssociatedConformanceWitness((uint64_t)v542, v569, (uint64_t)v540, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v348 = v541;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v347 + 8))(&qword_18162B0B8, 256, v346, v347);
          unint64_t v349 = v558;
          ((void (*)(char *, uint64_t, int **))v344[3])(v348, v345, v344);
          v350 = v509;
          LOBYTE(v344) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v568 + 32) + 8)
                                                                            + 16))(v509, v349, v345);
          uint64_t v351 = v570;
          v549(v349, v345);
          (*(void (**)(char *, char *, uint64_t))(v351 + 32))(v486, v350, v345);
          if (v344)
          {
            v549(v486, v569);
          }
          else
          {
            uint64_t v383 = v569;
            uint64_t v384 = v486;
            uint64_t v385 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
            v549(v384, v383);
            if ((v385 & 0x8000000000000000) == 0) {
              goto LABEL_96;
            }
          }
          goto LABEL_127;
        }
LABEL_79:
        uint64_t v577 = 0;
        uint64_t v302 = v568;
        uint64_t v303 = v569;
        char v304 = v558;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v568 + 96))(&v577, &type metadata for Int, v543, v569, v568);
        v305 = v509;
        LOBYTE(v302) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v302 + 32) + 8)
                                                                          + 16))(v509, v304, v303);
        char v306 = v304;
        uint64_t v307 = v549;
        v549(v306, v303);
        v307(v305, v303);
        if ((v302 & 1) == 0) {
          goto LABEL_96;
        }
LABEL_127:
        LODWORD(v576) = 1;
        goto LABEL_128;
      }
      uint64_t v279 = v569;
      uint64_t v282 = v509;
      if (v301 < 64)
      {
        uint64_t v285 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
        uint64_t v286 = v282;
LABEL_93:
        v549(v286, v279);
        if (v285 < 0) {
          goto LABEL_127;
        }
LABEL_96:
        LODWORD(v576) = 0;
LABEL_128:
        uint64_t v386 = v554;
        uint64_t v387 = v553;
        unint64_t v388 = v552;
        unint64_t v389 = v511;
        uint64_t v390 = v510;
        uint64_t v577 = v283;
        char v391 = v566;
        uint64_t v392 = v564;
        uint64_t v393 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v566, v564, (uint64_t)v554, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)+ 8);
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v393 + 88))(&v577, &type metadata for Int, v543, v386, v393);
        (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(v393 + 24) + 8) + 24))(v388, v390, v386);
        unint64_t v394 = *(void (**)(char *, const char *))(v387 + 8);
        v394(v390, v386);
        v394(v388, v386);
        ((void (*)(void, char *, char *, uint64_t, int **))v391[7])(v576, v389, v515, v392, v391);
        goto LABEL_20;
      }
    }
    uint64_t v283 = v551;
    v549(v282, v279);
    goto LABEL_96;
  }
  v507 = v160;
  char v509 = (char *)v162;
  uint64_t v546 = (void (*)(uint64_t *, uint64_t))v134;
  uint64_t v230 = ((uint64_t (*)(uint64_t, int **))v228)(v141, v227);
  unsigned int v231 = (int *)(v551 - v230);
  unint64_t v232 = v522;
  unint64_t v233 = v517;
  uint64_t v234 = swift_getAssociatedConformanceWitness((uint64_t)v522, (uint64_t)v147, (uint64_t)v517, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unsigned int v235 = v516;
  uint64_t v518 = *(char **)(v234 + 8);
  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v518)(&qword_18162B0C0, 512, v233, v234);
  __int16 v236 = v232[3];
  uint64_t v237 = v526;
  uint64_t v515 = (char *)(v232 + 3);
  uint64_t v514 = v236;
  uint64_t result = ((uint64_t (*)(char *, uint64_t *, int **))v236)(v235, v147, v232);
  uint64_t v513 = v231;
  if (__OFSUB__(v231, 1))
  {
    __break(1u);
    goto LABEL_178;
  }
  uint64_t v577 = (uint64_t)v231 - 1;
  (*(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v550 + 256))(v237, &v577, &type metadata for Int, v543, v147, v550);
  uint64_t v238 = (char *)(v535 + 8);
  uint64_t v534 = *(char **)(v535 + 8);
  ((void (*)(char *, uint64_t *))v534)(v237, v147);
  uint64_t v524 = v238;
  uint64_t v239 = v233;
  uint64_t v240 = v518;
  ((void (*)(void *, uint64_t, const char *, uint64_t))v518)(&unk_18162B0D0, 768, v239, v234);
  uint64_t v241 = v502;
  uint64_t v242 = v235;
  unint64_t v243 = v514;
  ((void (*)(char *, uint64_t *, int **))v514)(v242, v147, v522);
  uint64_t v244 = (char *)(v234 + 8);
  char v245 = (char *)v234;
  uint64_t v246 = AssociatedConformanceWitness;
  (*(void (**)(char *, char *, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64))(v241, v521, v147, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t *))v534)(v241, v147);
  uint64_t v247 = v516;
  v492 = v245;
  uint64_t v488 = v244;
  ((void (*)(uint64_t *, uint64_t))v240)(&qword_18162B0C0, 512);
  ((void (*)(char *, uint64_t *, int **))v243)(v247, v147, v522);
  uint64_t v248 = v503;
  unint64_t v249 = v526;
  (*(void (**)(char *, char *, uint64_t *))(*(void *)(v246 + 8) + 40))(v526, v241, v147);
  uint64_t v250 = v534;
  ((void (*)(char *, uint64_t *))v534)(v241, v147);
  ((void (*)(char *, uint64_t *))v250)(v249, v147);
  uint64_t v251 = v550;
  char v252 = v520;
  uint64_t v253 = v538;
  (*(void (**)(char *, char *, uint64_t *, uint64_t))(v550 + 192))(v538, v248, v147, v550);
  ((void (*)(char *, uint64_t *))v250)(v248, v147);
  uint64_t v577 = (uint64_t)v513;
  (*(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v251 + 240))(v253, &v577, &type metadata for Int, v543, v147, v251);
  ((void (*)(char *, uint64_t *))v250)(v253, v147);
  uint64_t v254 = v565;
  uint64_t v255 = v576;
  char v256 = v567;
  uint64_t AssociatedConformanceWitness = *(void *)(v565 + 96);
  unint64_t v503 = (char *)(v565 + 96);
  ((void (*)(char *, uint64_t *, uint64_t, uint64_t *, uint64_t))AssociatedConformanceWitness)(v249, v147, v251, v567, v565);
  uint64_t v513 = *(int **)(v254 + 192);
  ((void (*)(char *, char *, uint64_t *, uint64_t))v513)(v255, v575, v256, v254);
  v563(v255, v256);
  uint64_t v257 = swift_getAssociatedConformanceWitness((uint64_t)v531, v569, (uint64_t)v147, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  char v258 = v521;
  LOBYTE(v255) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v257 + 40))(v252, v521, v147, v257);
  uint64_t v259 = v535;
  uint64_t v260 = v505;
  (*(void (**)(char *, char *, uint64_t *))(v535 + 16))(v505, v252, v147);
  uint64_t v261 = *(void (***)(uint64_t))(v259 + 32);
  uint64_t v262 = v504;
  uint64_t v535 = v259 + 32;
  uint64_t v531 = v261;
  ((void (*)(char *, char *, uint64_t *))v261)(v504, v258, v147);
  uint64_t v538 = (char *)v257;
  if (v255)
  {
    ((void (*)(char *, uint64_t *))v250)(v262, v147);
    ((void (*)(char *, uint64_t *))v250)(v260, v147);
    goto LABEL_62;
  }
  char v287 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v257 + 8) + 8))(v260, v262, v147);
  ((void (*)(char *, uint64_t *))v250)(v262, v147);
  ((void (*)(char *, uint64_t *))v250)(v260, v147);
  if ((v287 & 1) == 0) {
    goto LABEL_141;
  }
  uint64_t v288 = v572;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18162B0C0, 512);
  uint64_t v289 = v576;
  uint64_t v290 = v567;
  v557(v288, v567, (uint64_t)v574);
  uint64_t v291 = v565;
  ((void (*)(char *, char *, uint64_t *, uint64_t))v513)(v523, v289, v290, v565);
  v563(v289, v290);
  uint64_t v292 = *(uint64_t (**)(uint64_t *, uint64_t))(v291 + 64);
  if (v292(v290, v291))
  {
    if ((*(uint64_t (**)(uint64_t *))(v565 + 128))(v567) < 64)
    {
LABEL_111:
      char v352 = *(uint64_t (**)(uint64_t *))(v565 + 120);
      unint64_t v353 = (int **)&v530;
      goto LABEL_112;
    }
LABEL_99:
    uint64_t v577 = 1;
    char v334 = v576;
    uint64_t v335 = v567;
    uint64_t v336 = v565;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))AssociatedConformanceWitness)(&v577, &type metadata for Int, v543, v567, v565);
    uint64_t v337 = v498;
    LOBYTE(v336) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v336 + 16) + 8) + 8))(v498, v334, v335);
    uint64_t v338 = v563;
    v563(v334, v335);
    v338(v337, v335);
    if (v336) {
      goto LABEL_62;
    }
LABEL_141:
    v563(v575, v567);
    goto LABEL_142;
  }
  uint64_t v330 = v567;
  uint64_t v331 = v565;
  char v332 = v292(v567, v565);
  uint64_t v333 = (*(uint64_t (**)(uint64_t *, uint64_t))(v331 + 128))(v330, v331);
  if ((v332 & 1) == 0)
  {
    if (v333 >= 64)
    {
      uint64_t v577 = 1;
      uint64_t v399 = v576;
      uint64_t v400 = v567;
      uint64_t v401 = v565;
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))AssociatedConformanceWitness)(&v577, &type metadata for Int, v543, v567, v565);
      uint64_t v402 = v498;
      char v403 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v401 + 16) + 8) + 8))(v498, v399, v400);
      v404 = v563;
      v563(v402, v400);
      v404(v399, v400);
      if ((v403 & 1) == 0) {
        goto LABEL_141;
      }
      goto LABEL_62;
    }
    goto LABEL_111;
  }
  if (v333 > 64) {
    goto LABEL_99;
  }
  unint64_t v395 = v572;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18162B0B8, 256);
  uint64_t v396 = v576;
  char v397 = v567;
  v557(v395, v567, (uint64_t)v574);
  uint64_t v398 = v498;
  LOBYTE(v395) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v565 + 32) + 8) + 32))(v498, v396, v397);
  v563(v396, v397);
  (*(void (**)(char *, char *, uint64_t *))(v559 + 32))(v482, v398, v397);
  if ((v395 & 1) == 0)
  {
    v563(v482, v567);
    goto LABEL_141;
  }
  char v352 = *(uint64_t (**)(uint64_t *))(v565 + 120);
  unint64_t v353 = &v514;
LABEL_112:
  char v354 = (char *)*(v353 - 32);
  unint64_t v355 = v567;
  uint64_t v356 = v352(v567);
  v563(v354, v355);
  if (v356 != 1) {
    goto LABEL_141;
  }
LABEL_62:
  uint64_t v263 = v572;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18162B0C0, 512);
  uint64_t v264 = v560;
  char v265 = v567;
  v557(v263, v567, (uint64_t)v574);
  uint64_t v266 = v576;
  char v267 = v523;
  LOBYTE(v263) = (*(uint64_t (**)(char *, char *, uint64_t *))(v561 + 80))(v576, v264, v265);
  unint64_t v268 = v563;
  v563(v264, v265);
  v268(v267, v265);
  uint64_t v269 = *(void (**)(char *, char *, uint64_t *))(v559 + 32);
  v269(v267, v266, v265);
  uint64_t v270 = v497;
  v269(v497, v575, v265);
  if (v263)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t *))v268)(v270, v265);
  }
  else
  {
    char v293 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v565 + 32) + 8) + 40))(v523, v270, v265);
    uint64_t result = ((uint64_t (*)(char *, uint64_t *))v268)(v270, v265);
    uint64_t v294 = v568;
    uint64_t v295 = v527;
    if ((v293 & 1) == 0) {
      goto LABEL_143;
    }
  }
  if (!__OFADD__(v551++, 1))
  {
    char v297 = v489;
    uint64_t v298 = v564;
    uint64_t v299 = v536;
    v544(v564, v536);
    v480(v298, v299);
    v529(v297, v298);
    if (v547())
    {
      if (v507(v532) < 64) {
        goto LABEL_103;
      }
      goto LABEL_83;
    }
    uint64_t v308 = v532;
    uint64_t v309 = v537;
    char v310 = ((uint64_t (*)(uint64_t *, uint64_t))v547)(v532, v537);
    uint64_t v311 = ((uint64_t (*)(uint64_t *, uint64_t))v507)(v308, v309);
    if (v310)
    {
      if (v311 <= 64)
      {
        unint64_t v357 = v495;
        v358 = v532;
        char v359 = v494;
        uint64_t v360 = swift_getAssociatedConformanceWitness((uint64_t)v495, (uint64_t)v532, (uint64_t)v494, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v361 = v493;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v360 + 8))(&qword_18162B0B8, 256, v359, v360);
        uint64_t v362 = v519;
        ((void (*)(char *, uint64_t *, int **))v357[3])(v361, v358, v357);
        char v363 = v508;
        LOBYTE(v357) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v537 + 32) + 8)
                                                                            + 16))(v508, v362, v358);
        uint64_t v364 = v525;
        ((void (*)(char *, uint64_t *))v509)(v362, v358);
        (*(void (**)(char *, char *, uint64_t *))(v364 + 32))(v485, v363, v358);
        if (v357)
        {
          ((void (*)(char *, uint64_t *))v509)(v485, v532);
          uint64_t v318 = v567;
          uint64_t v294 = v568;
          uint64_t v295 = v527;
          goto LABEL_116;
        }
        uint64_t v408 = v485;
        unint64_t v409 = v532;
        uint64_t v341 = (*(uint64_t (**)(uint64_t *))(v537 + 120))(v532);
        ((void (*)(char *, uint64_t *))v509)(v408, v409);
        goto LABEL_104;
      }
LABEL_83:
      uint64_t v577 = v551;
      uint64_t v312 = v537;
      char v313 = v519;
      char v314 = v532;
      (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v537 + 96))(&v577, &type metadata for Int, v543, v532, v537);
      uint64_t v315 = v508;
      char v316 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v312 + 32) + 8) + 16))(v508, v313, v314);
      uint64_t v317 = v509;
      ((void (*)(char *, uint64_t *))v509)(v313, v314);
      ((void (*)(char *, uint64_t *))v317)(v315, v314);
      goto LABEL_84;
    }
    if (v311 < 64)
    {
LABEL_103:
      uint64_t v339 = v508;
      uint64_t v340 = v532;
      uint64_t v341 = (*(uint64_t (**)(uint64_t *))(v537 + 120))(v532);
      ((void (*)(char *, uint64_t *))v509)(v339, v340);
LABEL_104:
      uint64_t v318 = v567;
      uint64_t v294 = v568;
      uint64_t v295 = v527;
      if (v341 >= v551)
      {
LABEL_143:
        uint64_t v410 = v569;
        char v411 = v295(v569, v294);
        (*(void (**)(char *, uint64_t, uint64_t))(v570 + 16))(v512, v571, v410);
        if (v411)
        {
          if (v295(v410, v294))
          {
            if (((uint64_t (*)(uint64_t))v546)(v569) < 64)
            {
              uint64_t v412 = v568;
              uint64_t v410 = v569;
              goto LABEL_152;
            }
LABEL_149:
            uint64_t v577 = 0;
            uint64_t v417 = v568;
            uint64_t v418 = v569;
            v419 = v558;
            (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v568 + 96))(&v577, &type metadata for Int, v543, v569, v568);
            uint64_t v420 = v512;
            LOBYTE(v417) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v417 + 32) + 8)
                                                                              + 16))(v512, v419, v418);
            uint64_t v421 = v419;
            v422 = v549;
            v549(v421, v418);
            v422(v420, v418);
            if (v417) {
              goto LABEL_153;
            }
            goto LABEL_155;
          }
          uint64_t v414 = v568;
          uint64_t v413 = v569;
          char v415 = v527(v569, v568);
          uint64_t v416 = ((uint64_t (*)(uint64_t, uint64_t))v546)(v413, v414);
          if (v415)
          {
            if (v416 <= 64)
            {
              v455 = v542;
              uint64_t v456 = v569;
              uint64_t v457 = v540;
              uint64_t v458 = swift_getAssociatedConformanceWitness((uint64_t)v542, v569, (uint64_t)v540, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v459 = v541;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v458 + 8))(&qword_18162B0B8, 256, v457, v458);
              unsigned int v460 = v558;
              ((void (*)(char *, uint64_t, int **))v455[3])(v459, v456, v455);
              v461 = v512;
              LOBYTE(v455) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v568 + 32)
                                                                                            + 8)
                                                                                + 16))(v512, v460, v456);
              uint64_t v462 = v570;
              v549(v460, v456);
              (*(void (**)(char *, char *, uint64_t))(v462 + 32))(v483, v461, v456);
              if (v455)
              {
                v549(v483, v569);
                uint64_t v425 = 1;
                goto LABEL_156;
              }
              uint64_t v463 = v569;
              v464 = v483;
              uint64_t v465 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
              v549(v464, v463);
              if (v465 < 0) {
                goto LABEL_153;
              }
              goto LABEL_155;
            }
            goto LABEL_149;
          }
          uint64_t v412 = v568;
          uint64_t v410 = v569;
          if (v416 < 64)
          {
LABEL_152:
            uint64_t v423 = v512;
            uint64_t v424 = (*(uint64_t (**)(uint64_t))(v412 + 120))(v410);
            v549(v423, v410);
            if (v424 < 0)
            {
LABEL_153:
              uint64_t v425 = 1;
LABEL_156:
              uint64_t v577 = v551;
              char v426 = v566;
              uint64_t v427 = v564;
              uint64_t v428 = v554;
              uint64_t v429 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v566, v564, (uint64_t)v554, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)+ 8);
              uint64_t v430 = v510;
              (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v429 + 88))(&v577, &type metadata for Int, v543, v428, v429);
              uint64_t v431 = v511;
              v432 = v552;
              (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(v429 + 24) + 8) + 24))(v552, v430, v428);
              uint64_t v433 = *(void (**)(char *, const char *))(v553 + 8);
              v433(v430, v428);
              v433(v432, v428);
              uint64_t v434 = v576;
              (*(void (**)(char *, char *, uint64_t *))(v559 + 32))(v576, v523, v567);
              ((void (*)(uint64_t, char *, char *, uint64_t, int **))v426[7])(v425, v431, v434, v427, v426);
              uint64_t v435 = v550;
              unsigned int v436 = *(uint64_t (**)(uint64_t *, uint64_t))(v550 + 64);
              char v437 = v533;
              if (v436(v533, v550))
              {
                if ((*(uint64_t (**)(uint64_t *, uint64_t))(v435 + 128))(v437, v435) < 64) {
                  goto LABEL_164;
                }
                goto LABEL_161;
              }
              char v438 = v436(v437, v435);
              uint64_t v439 = (*(uint64_t (**)(uint64_t *, uint64_t))(v435 + 128))(v437, v435);
              if (v438)
              {
                if (v439 <= 64)
                {
                  uint64_t v447 = v516;
                  ((void (*)(uint64_t *, uint64_t))v518)(&qword_18162B0B8, 256);
                  uint64_t v448 = v526;
                  uint64_t v449 = v533;
                  ((void (*)(char *, uint64_t *, int **))v514)(v447, v533, v522);
                  unint64_t v450 = v520;
                  LOBYTE(v447) = (*((uint64_t (**)(char *, char *, uint64_t *))v538 + 4))(v520, v448, v449);
                  ((void (*)(char *, uint64_t *))v534)(v448, v449);
                  ((void (*)(char *, char *, uint64_t *))v531)(v487, v450, v449);
                  char v178 = (v447 & 1) != 0
                      && (*(uint64_t (**)(uint64_t *))(v550 + 120))(v533) == 0;
                  ((void (*)(char *, uint64_t *))v534)(v487, v533);
                  return v178 & 1;
                }
LABEL_161:
                uint64_t v577 = 0;
                uint64_t v440 = v526;
                uint64_t v441 = v533;
                (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *))(v550 + 96))(&v577, &type metadata for Int, v543, v533);
                uint64_t v442 = v520;
                char v178 = (*(uint64_t (**)(char *, char *, uint64_t *))(*((void *)v538 + 1) + 8))(v520, v440, v441);
                uint64_t v443 = v534;
                ((void (*)(char *, uint64_t *))v534)(v440, v441);
                ((void (*)(char *, uint64_t *))v443)(v442, v441);
                return v178 & 1;
              }
              if (v439 < 64)
              {
LABEL_164:
                uint64_t v444 = v526;
                uint64_t v445 = v533;
                ((void (*)(char *, char *, uint64_t *))v531)(v526, v520, v533);
                uint64_t v446 = (*(uint64_t (**)(uint64_t *))(v550 + 120))(v445);
                ((void (*)(char *, uint64_t *))v534)(v444, v445);
                char v178 = v446 == 0;
                return v178 & 1;
              }
              uint64_t v577 = 0;
              uint64_t v451 = v526;
              uint64_t v452 = v533;
              (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *))(v550 + 96))(&v577, &type metadata for Int, v543, v533);
              uint64_t v453 = v520;
              char v178 = (*(uint64_t (**)(char *, char *, uint64_t *))(*((void *)v538 + 1) + 8))(v520, v451, v452);
              uint64_t v454 = v534;
              ((void (*)(char *, uint64_t *))v534)(v453, v452);
              ((void (*)(char *, uint64_t *))v454)(v451, v452);
              return v178 & 1;
            }
LABEL_155:
            uint64_t v425 = 0;
            goto LABEL_156;
          }
        }
        v549(v512, v410);
        goto LABEL_155;
      }
LABEL_116:
      v563(v523, v318);
      ((void (*)(char *, uint64_t *))v534)(v520, v533);
      (*(void (**)(char *, const char *))(v553 + 8))(v552, v554);
      uint64_t v365 = v569;
      char v366 = v295(v569, v294);
      (*(void (**)(char *, uint64_t, uint64_t))(v570 + 16))(v496, v571, v365);
      if (v366)
      {
        if (((uint64_t (*)(void))v527)())
        {
          if (((uint64_t (*)(uint64_t))v546)(v569) < 64)
          {
LABEL_134:
            uint64_t v405 = v569;
            v406 = v496;
            uint64_t v407 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
            v549(v406, v405);
            if (v407 < 0) {
              goto LABEL_176;
            }
LABEL_137:
            (*(void (**)(uint64_t))(v536 + 112))(v564);
            goto LABEL_90;
          }
          goto LABEL_122;
        }
        uint64_t v368 = v568;
        uint64_t v367 = v569;
        char v369 = v527(v569, v568);
        uint64_t v370 = ((uint64_t (*)(uint64_t, uint64_t))v546)(v367, v368);
        if (v369)
        {
          if (v370 <= 64)
          {
            uint64_t v466 = v542;
            uint64_t v467 = v569;
            uint64_t v468 = v540;
            uint64_t v469 = swift_getAssociatedConformanceWitness((uint64_t)v542, v569, (uint64_t)v540, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v470 = v541;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v469 + 8))(&qword_18162B0B8, 256, v468, v469);
            unsigned __int16 v471 = v558;
            ((void (*)(char *, uint64_t, int **))v466[3])(v470, v467, v466);
            uint64_t v472 = v496;
            LOBYTE(v466) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v568 + 32) + 8)
                                                                              + 16))(v496, v471, v467);
            uint64_t v473 = v570;
            v549(v471, v467);
            (*(void (**)(char *, char *, uint64_t))(v473 + 32))(v481, v472, v467);
            if (v466)
            {
              v549(v481, v569);
            }
            else
            {
              uint64_t v474 = v569;
              int v475 = v481;
              uint64_t v476 = (*(uint64_t (**)(uint64_t))(v568 + 120))(v569);
              v549(v475, v474);
              if ((v476 & 0x8000000000000000) == 0) {
                goto LABEL_137;
              }
            }
            goto LABEL_176;
          }
LABEL_122:
          uint64_t v577 = 0;
          uint64_t v371 = v568;
          uint64_t v372 = v569;
          int64_t v373 = v558;
          (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v568 + 96))(&v577, &type metadata for Int, v543, v569, v568);
          uint64_t v374 = v496;
          LOBYTE(v371) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v371 + 32) + 8)
                                                                            + 16))(v496, v373, v372);
          unint64_t v375 = v373;
          v376 = v549;
          v549(v375, v372);
          v376(v374, v372);
          if ((v371 & 1) == 0) {
            goto LABEL_137;
          }
LABEL_176:
          uint64_t v477 = v491;
          uint64_t v478 = v564;
          (*(void (**)(uint64_t))(v536 + 112))(v564);
          (*(void (**)(char *, uint64_t))(v490 + 16))(v477, v478);
          char v328 = v477;
          uint64_t v329 = v478;
          goto LABEL_89;
        }
        if (v370 < 64) {
          goto LABEL_134;
        }
      }
      v549(v496, v569);
      goto LABEL_137;
    }
    (*(void (**)(char *, char *, uint64_t *))(v525 + 32))(v484, v508, v532);
    if (v551 > 0)
    {
      uint64_t v577 = v551;
      uint64_t v377 = v537;
      uint64_t v378 = v519;
      uint64_t v379 = v532;
      (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v537 + 96))(&v577, &type metadata for Int, v543, v532, v537);
      uint64_t v380 = v484;
      char v316 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v377 + 32) + 8) + 16))(v484, v378, v379);
      uint64_t v381 = v378;
      uint64_t v382 = v509;
      ((void (*)(char *, uint64_t *))v509)(v381, v379);
      ((void (*)(char *, uint64_t *))v382)(v380, v379);
LABEL_84:
      uint64_t v318 = v567;
      uint64_t v294 = v568;
      uint64_t v295 = v527;
      if ((v316 & 1) == 0) {
        goto LABEL_143;
      }
      goto LABEL_116;
    }
    ((void (*)(char *, uint64_t *))v509)(v484, v532);
LABEL_142:
    uint64_t v294 = v568;
    uint64_t v295 = v527;
    goto LABEL_143;
  }
LABEL_178:
  __break(1u);
  return result;
}

uint64_t BinaryFloatingPoint<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  static BinaryFloatingPoint<>._convert<A>(from:)(a7, a1, a2, a3, a4, a5, a6);
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8);

  return v9(a1, a3);
}

uint64_t BinaryFloatingPoint<>.init<A>(exactly:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v14 = static BinaryFloatingPoint<>._convert<A>(from:)((uint64_t)v10, a1, a2, a3, v11, v12, v13);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
  if (v14)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v8 + 32))(a4, v10, a2);
    uint64_t v15 = 0;
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v10, a2);
    uint64_t v15 = 1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))(a4, v15, 1, a2);
}

uint64_t _swift_stdlib_Hashable_isEqual_indirect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v16 - v11;
  uint64_t v13 = *(void (**)(char *))(v7 + 16);
  v13((char *)&v16 - v11);
  ((void (*)(char *, uint64_t, uint64_t))v13)(v10, a2, a3);
  LOBYTE(a4) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a4 + 8) + 8))(v12, v10, a3);
  char v14 = *(void (**)(char *, uint64_t))(v7 + 8);
  v14(v10, a3);
  v14(v12, a3);
  return a4 & 1;
}

uint64_t _swift_stdlib_Hashable_hashValue_indirect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _ConcreteHashableBox._unbox<A>()@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v10 = type metadata accessor for _ConcreteHashableBox(255, a2, a3, a4);
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)v10, v11, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v25[-1] - v15;
  v25[3] = a1;
  v25[4] = (unint64_t)&protocol witness table for _ConcreteHashableBox<A>;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v25);
  (*(void (**)(void *, uint64_t, unint64_t))(*(void *)(a1 - 8) + 16))(boxed_opaque_existential_0Tm, v6, a1);
  uint64_t v18 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  int v19 = swift_dynamicCast(v16, v25, v18, (const char *)v10, 6uLL);
  uint64_t v20 = (void (*)(char *, uint64_t, uint64_t, Class *))*((void *)*(v10 - 1) + 7);
  if (v19)
  {
    uint64_t v21 = (uint64_t)*(v10 - 1);
    v20(v16, 0, 1, v10);
    uint64_t v22 = *(void *)(a2 - 8);
    (*(void (**)(uint64_t, char *, uint64_t))(v22 + 16))(a5, v16, a2);
    (*(void (**)(char *, Class *))(v21 + 8))(v16, v10);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v22 + 56))(a5, 0, 1, a2);
  }
  else
  {
    v20(v16, 1, 1, v10);
    (*(void (**)(char *, Class *))(v14 + 8))(v16, v13);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56))(a5, 1, 1, a2);
  }
}

uint64_t _ConcreteHashableBox._isEqual(to:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = type metadata accessor for Optional(0, v6, a3, a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)v20 - v10;
  uint64_t v12 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = a1[3];
  uint64_t v16 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v15);
  uint64_t v17 = *(void *)(a2 + 24);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 56))(v6, v17, v15, v16);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v12 + 48))(v11, 1, v6) == 1)
  {
    (*(void (**)(char *, Class *))(v8 + 8))(v11, v7);
    return 2;
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v14, v11, v6);
    char v19 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(v17 + 8) + 8))(v20[1], v14, v6);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v6);
    return v19 & 1;
  }
}

uint64_t _ConcreteHashableBox._hashValue.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))(*(void *)(a1 + 16));
}

uint64_t _ConcreteHashableBox._hash(into:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 24))(a1, *(void *)(a2 + 16));
}

Swift::Int __swiftcall _ConcreteHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  return (*(uint64_t (**)(Swift::Int, void))(*(void *)(v1 + 24) + 32))(_seed, *(void *)(v1 + 16));
}

uint64_t protocol witness for _AnyHashableBox._base.getter in conformance _ConcreteHashableBox<A>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return _ConcreteHashableBox._base.getter(a1, a2);
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _ConcreteHashableBox<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return _ConcreteHashableBox._unbox<A>()(a3, a1, a2, a4, a5);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _ConcreteHashableBox<A>(char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return _ConcreteHashableBox._downCastConditional<A>(into:)(a1, a3, a2, a4) & 1;
}

double AnyHashable.init<A>(_:)@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(a2 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12 == &type metadata for String)
  {
    char v19 = *(swift **)a1;
    uint64_t v20 = *(void *)(a1 + 8);
    *(void *)(a4 + 24) = &unk_1ECA01A78;
    *(void *)(a4 + 32) = &protocol witness table for _ConcreteHashableBox<A>;
    *(void *)a4 = v19;
    *(void *)(a4 + 8) = v20;
    return result;
  }
  (*(void (**)(char *, uint64_t, uint64_t *))(v8 + 16))(v11, a1, a2);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation);
  if ((swift_dynamicCast(&v25, v11, a2, v13, 6) & 1) == 0)
  {
    uint64_t v27 = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v25, &demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation?);
    long long v22 = 0u;
    long long v23 = 0u;
    uint64_t v24 = 0;
    goto LABEL_7;
  }
  uint64_t v14 = *((void *)&v26 + 1);
  uint64_t v15 = v27;
  uint64_t v16 = __swift_project_boxed_opaque_existential_0Tm(&v25, *((uint64_t *)&v26 + 1));
  MEMORY[0x1F4188790](v16);
  (*(void (**)(char *))(v18 + 16))((char *)&v22 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0));
  ((void (*)(long long *__return_ptr, uint64_t, _UNKNOWN **))v15[1])(&v22, v14, v15);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v25);
  if (!*((void *)&v23 + 1))
  {
LABEL_7:
    outlined destroy of AnyHashable?((uint64_t *)&v22);
    *((void *)&v26 + 1) = &unk_1ECA01B10;
    uint64_t v27 = &protocol witness table for _ConcreteHashableBox<A>;
    LOBYTE(v25) = 0;
    _swift_makeAnyHashableUpcastingToHashableBaseType((swift **)a1, (objc_object *)&v25, a2, a3);
    (*(void (**)(uint64_t, uint64_t *))(v8 + 8))(a1, a2);
    goto LABEL_8;
  }
  (*(void (**)(uint64_t, uint64_t *))(v8 + 8))(a1, a2);
  long long v25 = v22;
  long long v26 = v23;
  uint64_t v27 = v24;
LABEL_8:
  double result = *(double *)&v25;
  long long v21 = v26;
  *(_OWORD *)a4 = v25;
  *(_OWORD *)(a4 + 16) = v21;
  *(void *)(a4 + 32) = v27;
  return result;
}

uint64_t AnyHashable.base.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 48))(v1, v2);
}

uint64_t AnyHashable.hashValue.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 8))(v7, v1, v2);
  uint64_t v3 = v8;
  uint64_t v4 = v9;
  __swift_project_boxed_opaque_existential_0Tm(v7, v8);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 24))(v3, v4);
  __swift_destroy_boxed_opaque_existential_1Tm(v7);
  return v5;
}

uint64_t AnyHashable.hash(into:)(uint64_t a1)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_project_boxed_opaque_existential_0Tm(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32))(a1, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

Swift::Int __swiftcall AnyHashable._rawHashValue(seed:)(Swift::Int seed)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v9, v3, v4);
  uint64_t v5 = v10;
  uint64_t v6 = v11;
  __swift_project_boxed_opaque_existential_0Tm(v9, v10);
  Swift::Int v7 = (*(uint64_t (**)(Swift::Int, uint64_t, uint64_t))(v6 + 40))(seed, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v9);
  return v7;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance AnyHashable()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 8))(v7, v1, v2);
  uint64_t v3 = v8;
  uint64_t v4 = v9;
  __swift_project_boxed_opaque_existential_0Tm(v7, v8);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 24))(v3, v4);
  __swift_destroy_boxed_opaque_existential_1Tm(v7);
  return v5;
}

uint64_t protocol witness for Hashable.hash(into:) in conformance AnyHashable(uint64_t a1)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_project_boxed_opaque_existential_0Tm(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32))(a1, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance AnyHashable(uint64_t a1)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v9, v3, v4);
  uint64_t v5 = v10;
  uint64_t v6 = v11;
  __swift_project_boxed_opaque_existential_0Tm(v9, v10);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 40))(a1, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v9);
  return v7;
}

uint64_t AnyHashable.description.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 48))(v5, v1, v2);
  v4[0] = 0;
  v4[1] = 0xE000000000000000;
  _print_unlocked<A, B>(_:_:)((uint64_t)v5, (uint64_t)v4, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v5);
  return v4[0];
}

uint64_t specialized String.init<A>(describing:)(uint64_t a1)
{
  uint64_t v214 = 0;
  unint64_t v215 = 0xE000000000000000;
  uint64_t v216 = a1;
  uint64_t v2 = (uint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any.Type);
  uint64_t v208 = v2;
  v207[0] = a1;
  uint64_t v3 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(v207, (uint64_t)v2);
  unint64_t DynamicType = (void *)swift_getDynamicType(v3, v2, 1);
  BOOL isOptionalType = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(v207);
  if (isOptionalType)
  {
    *(void *)&long long v210 = a1;
    uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)v207, (unint64_t *)&v210, (Class *)v2, v6, 7uLL);
    uint64_t v7 = (uint64_t)v208;
    uint64_t v8 = v209;
    __swift_project_boxed_opaque_existential_0Tm(v207, (uint64_t)v208);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
    uint64_t v11 = v9;
    unint64_t v12 = v10;
    uint64_t v13 = v214;
    unint64_t v14 = v215;
    unint64_t v15 = HIBYTE(v215) & 0xF;
    if ((v215 & 0x2000000000000000) != 0) {
      unint64_t v16 = HIBYTE(v215) & 0xF;
    }
    else {
      unint64_t v16 = v214 & 0xFFFFFFFFFFFFLL;
    }
    if (v16 || (v214 & ~v215 & 0x2000000000000000) != 0)
    {
      uint64_t v17 = v10 & 0x2000000000000000;
      uint64_t v18 = HIBYTE(v10) & 0xF;
      if ((v215 & 0x2000000000000000) == 0 || !v17) {
        goto LABEL_11;
      }
      unint64_t v19 = v15 + v18;
      if (v15 + v18 > 0xF)
      {
        uint64_t v17 = 1;
LABEL_11:
        if (v17) {
          uint64_t v20 = HIBYTE(v10) & 0xF;
        }
        else {
          uint64_t v20 = v9 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v10, 2);
        if ((v12 & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRetain_n(v12, 5);
          v173._Swift::UInt64 rawBits = 1;
          v174._Swift::UInt64 rawBits = (v20 << 16) | 1;
          v175._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v173, v174, v11, v12);
          if (v175._rawBits < 0x10000) {
            v175._rawBits |= 3;
          }
          Swift::Int v21 = specialized Collection.count.getter(v175, v176, v11, v12);
          swift_bridgeObjectRelease(v12);
          if ((v14 & 0x1000000000000000) == 0)
          {
LABEL_16:
            BOOL v22 = __OFADD__(v16, v21);
            Swift::Int v23 = v16 + v21;
            if (!v22)
            {
LABEL_17:
              if ((v13 & ~v14 & 0x2000000000000000) != 0
                && swift_isUniquelyReferenced_nonNull_native(v14 & 0xFFFFFFFFFFFFFFFLL))
              {
                uint64_t v24 = v214;
                uint64_t v13 = v215;
                int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(v214, v215);
                if (v26) {
                  goto LABEL_250;
                }
                if (v23 >= 16) {
                  goto LABEL_28;
                }
                if ((v13 & 0x2000000000000000) == 0)
                {
                  unint64_t v14 = v13;
                  if (v25 < v21) {
                    goto LABEL_74;
                  }
                  goto LABEL_28;
                }
                int v50 = 0;
                unint64_t v14 = v13;
              }
              else
              {
                if (v23 >= 16)
                {
                  uint64_t v24 = v214;
                  uint64_t v13 = v215;
LABEL_28:
                  int64_t v30 = _StringGuts.nativeUnusedCapacity.getter(v24, v13);
                  unint64_t v14 = (v31 & 1) == 0 && v30 >= v21;
                  if ((v24 & ~v13 & 0x2000000000000000) != 0
                    && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if (v14) {
                      goto LABEL_69;
                    }
                  }
                  else if (v14)
                  {
LABEL_68:
                    _StringGuts.grow(_:)(v23);
LABEL_69:
                    swift_bridgeObjectRelease_n(v12, 4);
                    if ((v12 & 0x1000000000000000) == 0)
                    {
                      if (v17)
                      {
                        swift_bridgeObjectRelease_n(v12, 2);
                        uint64_t v47 = (v12 >> 62) & 1;
                        *(void *)&long long v210 = v11;
                        *((void *)&v210 + 1) = v12 & 0xFFFFFFFFFFFFFFLL;
                        uint64_t v48 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v12) & 0xF, (uint64_t)&v210, HIBYTE(v12) & 0xF);
LABEL_124:
                        _StringGuts.appendInPlace(_:isASCII:)(v48, v49, v47);
                        swift_bridgeObjectRelease(v12);
                        goto LABEL_176;
                      }
                      if ((v11 & 0x1000000000000000) != 0)
                      {
                        swift_bridgeObjectRelease(v12);
                        id v83 = (id)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
                        uint64_t v84 = v11 & 0xFFFFFFFFFFFFLL;
                        uint64_t v85 = v11 & 0xFFFFFFFFFFFFLL;
LABEL_157:
                        uint64_t v127 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v84, (uint64_t)v83, v85);
                        _StringGuts.appendInPlace(_:isASCII:)(v127, v128, v11 < 0);
LABEL_160:
                        swift_bridgeObjectRelease_n(v12, 2);
                        goto LABEL_176;
                      }
                      id v83 = _StringObject.sharedUTF8.getter(v11, v12);
                      uint64_t v85 = v196;
                      swift_bridgeObjectRelease(v12);
                      if (v85 >= (v11 & 0xFFFFFFFFFFFFLL))
                      {
                        uint64_t v84 = v11 & 0xFFFFFFFFFFFFLL;
                        goto LABEL_157;
                      }
LABEL_248:
                      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
                    }
                    swift_bridgeObjectRelease(v12);
                    uint64_t v63 = v11;
                    unint64_t v64 = v12;
                    uint64_t v65 = v20;
LABEL_159:
                    _StringGuts._foreignAppendInPlace(_:)(v63, v64, 0, v65);
                    goto LABEL_160;
                  }
                  uint64_t v43 = _StringGuts.nativeCapacity.getter(v214, v215);
                  if (v44) {
                    uint64_t v45 = 0;
                  }
                  else {
                    uint64_t v45 = v43;
                  }
                  if (v45 + 0x4000000000000000 >= 0)
                  {
                    uint64_t v46 = 2 * v45;
                    if (v46 > v23) {
                      Swift::Int v23 = v46;
                    }
                    goto LABEL_68;
                  }
                  __break(1u);
                  goto LABEL_225;
                }
                unint64_t v14 = v215;
                if ((v215 & 0x2000000000000000) == 0)
                {
                  uint64_t v13 = v215;
LABEL_74:
                  int v50 = 1;
                  goto LABEL_129;
                }
                int v50 = 0;
                uint64_t v13 = v215;
              }
LABEL_129:
              swift_bridgeObjectRelease_n(v12, 5);
              uint64_t v18 = v214;
              if (!v50) {
                goto LABEL_130;
              }
              goto LABEL_216;
            }
LABEL_215:
            __break(1u);
LABEL_216:
            if ((v14 & 0x1000000000000000) != 0)
            {
              uint64_t v18 = _StringGuts._foreignConvertedToSmall()(v18, v13);
              unint64_t v14 = v199;
            }
            else
            {
              if ((v18 & 0x1000000000000000) != 0)
              {
                char v178 = (unsigned __int8 *)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v179 = v18 & 0xFFFFFFFFFFFFLL;
              }
              else
              {
                char v178 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v13);
                uint64_t v179 = v202;
              }
              swift_bridgeObjectRetain(v13);
              closure #1 in _StringGuts._convertedToSmall()(v178, v179, &v210);
              swift_bridgeObjectRelease(v13);
              unint64_t v14 = *((void *)&v210 + 1);
              uint64_t v18 = v210;
            }
LABEL_130:
            v87._Swift::UInt64 rawBits = (v20 << 16) | 1;
            v88._Swift::UInt64 rawBits = 1;
            v89._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v88, v87, v11, v12);
            if (v89._rawBits < 0x10000) {
              v89._rawBits |= 3;
            }
            unint64_t v91 = specialized String.init(_:)(v89, v90, v11, v12);
            unint64_t v93 = v92;
            swift_bridgeObjectRelease(v12);
            if ((v93 & 0x2000000000000000) != 0)
            {
              swift_bridgeObjectRelease(v93);
            }
            else if ((v93 & 0x1000000000000000) != 0)
            {
              unint64_t v91 = _StringGuts._foreignConvertedToSmall()(v91, v93);
              unint64_t v201 = v200;
              swift_bridgeObjectRelease(v93);
              unint64_t v93 = v201;
            }
            else
            {
              if ((v91 & 0x1000000000000000) != 0)
              {
                char v180 = (unsigned __int8 *)((v93 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v181 = v91 & 0xFFFFFFFFFFFFLL;
              }
              else
              {
                char v180 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v91, v93);
              }
              closure #1 in _StringGuts._convertedToSmall()(v180, v181, &v210);
              swift_bridgeObjectRelease(v93);
              unint64_t v93 = *((void *)&v210 + 1);
              unint64_t v91 = v210;
            }
            uint64_t v94 = HIBYTE(v14) & 0xF;
            uint64_t v95 = HIBYTE(v93) & 0xF;
            uint64_t v96 = v95 + v94;
            if ((unint64_t)(v95 + v94) <= 0xF)
            {
              if (v95)
              {
                uint64_t v97 = 0;
                unint64_t v98 = 0;
                uint64_t v99 = 8 * v95;
                do
                {
                  unint64_t v100 = v94 + v98;
                  BOOL v76 = v98++ >= 8;
                  if (v76) {
                    unint64_t v101 = v93;
                  }
                  else {
                    unint64_t v101 = v91;
                  }
                  char v102 = (8 * v94 + v97) & 0x38;
                  uint64_t v103 = (-255 << v102) - 1;
                  unint64_t v104 = (unint64_t)(v101 >> (v97 & 0x38)) << v102;
                  unint64_t v105 = v104 | v103 & v14;
                  unint64_t v106 = v104 | v103 & v18;
                  if (v100 < 8) {
                    uint64_t v18 = v106;
                  }
                  else {
                    unint64_t v14 = v105;
                  }
                  v97 += 8;
                }
                while (v99 != v97);
              }
LABEL_144:
              swift_bridgeObjectRelease(v13);
              swift_bridgeObjectRelease(v12);
              unint64_t v107 = 0xA000000000000000;
              if (!(v18 & 0x8080808080808080 | v14 & 0x80808080808080)) {
                unint64_t v107 = 0xE000000000000000;
              }
              uint64_t v214 = v18;
              unint64_t v215 = v107 & 0xFF00000000000000 | (v96 << 56) | v14 & 0xFFFFFFFFFFFFFFLL;
              goto LABEL_176;
            }
            goto LABEL_249;
          }
        }
        else
        {
          swift_bridgeObjectRetain_n(v12, 4);
          Swift::Int v21 = v20;
          if ((v14 & 0x1000000000000000) == 0) {
            goto LABEL_16;
          }
        }
        Swift::Int v177 = String.UTF8View._foreignCount()();
        Swift::Int v23 = v177 + v21;
        if (!__OFADD__(v177, v21)) {
          goto LABEL_17;
        }
        goto LABEL_215;
      }
      if (v18)
      {
        uint64_t v71 = 0;
        unint64_t v72 = 0;
        uint64_t v73 = 8 * v18;
        unint64_t v74 = v215;
        do
        {
          unint64_t v75 = v15 + v72;
          BOOL v76 = v72++ >= 8;
          if (v76) {
            unint64_t v77 = v10;
          }
          else {
            unint64_t v77 = v9;
          }
          char v78 = (8 * v15 + v71) & 0x38;
          uint64_t v79 = (-255 << v78) - 1;
          unint64_t v80 = (unint64_t)(v77 >> (v71 & 0x38)) << v78;
          unint64_t v81 = v80 | v79 & v74;
          unint64_t v82 = v80 | v79 & v13;
          if (v75 < 8) {
            uint64_t v13 = v82;
          }
          else {
            unint64_t v74 = v81;
          }
          v71 += 8;
        }
        while (v73 != v71);
        goto LABEL_172;
      }
LABEL_171:
      unint64_t v74 = v14;
LABEL_172:
      swift_bridgeObjectRelease(v14);
      swift_bridgeObjectRelease(v12);
      unint64_t v139 = 0xA000000000000000;
      if (!(v13 & 0x8080808080808080 | v74 & 0x80808080808080)) {
        unint64_t v139 = 0xE000000000000000;
      }
      unint64_t v140 = v139 & 0xFF00000000000000 | (v19 << 56) | v74 & 0xFFFFFFFFFFFFFFLL;
LABEL_175:
      uint64_t v214 = v13;
      unint64_t v215 = v140;
      goto LABEL_176;
    }
LABEL_99:
    uint64_t v66 = v14;
    goto LABEL_100;
  }
  uint64_t v213 = a1;
  uint64_t v27 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v210, (unint64_t *)&v213, (Class *)v2, v27, 6uLL))
  {
    outlined init with take of MirrorPath(&v210, (uint64_t)v207);
    uint64_t v28 = (uint64_t)v208;
    uint64_t v29 = v209;
    __swift_project_boxed_opaque_existential_0Tm(v207, (uint64_t)v208);
    (*(void (**)(uint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v29 + 8))(&v214, &type metadata for String, &protocol witness table for String, v28, v29);
    goto LABEL_176;
  }
  uint64_t v212 = 0;
  long long v210 = 0u;
  long long v211 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v210, &demangling cache variable for type metadata for TextOutputStreamable?);
  uint64_t v213 = a1;
  uint64_t v33 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v210, (unint64_t *)&v213, (Class *)v2, v33, 6uLL))
  {
    outlined init with take of MirrorPath(&v210, (uint64_t)v207);
    uint64_t v34 = (uint64_t)v208;
    uint64_t v35 = v209;
    __swift_project_boxed_opaque_existential_0Tm(v207, (uint64_t)v208);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(v35 + 8))(v34, v35);
    uint64_t v11 = v36;
    unint64_t v12 = v37;
    uint64_t v13 = v214;
    unint64_t v14 = v215;
    unint64_t v38 = HIBYTE(v215) & 0xF;
    if ((v215 & 0x2000000000000000) != 0) {
      Swift::Int v23 = HIBYTE(v215) & 0xF;
    }
    else {
      Swift::Int v23 = v214 & 0xFFFFFFFFFFFFLL;
    }
    if (v23 || (v214 & ~v215 & 0x2000000000000000) != 0)
    {
      uint64_t v24 = v37 & 0x2000000000000000;
      uint64_t v18 = HIBYTE(v37) & 0xF;
      if ((v215 & 0x2000000000000000) != 0 && v24)
      {
        unint64_t v19 = v38 + v18;
        if (v38 + v18 <= 0xF)
        {
          if (v18)
          {
            uint64_t v129 = 0;
            unint64_t v130 = 0;
            uint64_t v131 = 8 * v18;
            unint64_t v74 = v215;
            do
            {
              unint64_t v132 = v38 + v130;
              BOOL v76 = v130++ >= 8;
              if (v76) {
                unint64_t v133 = v37;
              }
              else {
                unint64_t v133 = v36;
              }
              char v134 = (8 * v38 + v129) & 0x38;
              uint64_t v135 = (-255 << v134) - 1;
              unint64_t v136 = (unint64_t)(v133 >> (v129 & 0x38)) << v134;
              unint64_t v137 = v136 | v135 & v74;
              unint64_t v138 = v136 | v135 & v13;
              if (v132 < 8) {
                uint64_t v13 = v138;
              }
              else {
                unint64_t v74 = v137;
              }
              v129 += 8;
            }
            while (v131 != v129);
            goto LABEL_172;
          }
          goto LABEL_171;
        }
        uint64_t v24 = 1;
      }
      uint64_t v20 = v36 & 0xFFFFFFFFFFFFLL;
      if (v24) {
        uint64_t v17 = HIBYTE(v37) & 0xF;
      }
      else {
        uint64_t v17 = v36 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v37, 2);
      if ((v12 & 0x1000000000000000) == 0)
      {
        swift_bridgeObjectRetain_n(v12, 4);
        Swift::Int v39 = v17;
        if ((v14 & 0x1000000000000000) != 0) {
          goto LABEL_228;
        }
        goto LABEL_53;
      }
LABEL_225:
      swift_bridgeObjectRetain_n(v12, 5);
      v182._Swift::UInt64 rawBits = 1;
      v183._Swift::UInt64 rawBits = (v17 << 16) | 1;
      v184._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v182, v183, v11, v12);
      if (v184._rawBits < 0x10000) {
        v184._rawBits |= 3;
      }
      Swift::Int v39 = specialized Collection.count.getter(v184, v185, v11, v12);
      swift_bridgeObjectRelease(v12);
      if ((v14 & 0x1000000000000000) != 0)
      {
LABEL_228:
        Swift::Int v186 = String.UTF8View._foreignCount()();
        int64_t v40 = v186 + v39;
        if (!__OFADD__(v186, v39))
        {
LABEL_54:
          if ((v13 & ~v14 & 0x2000000000000000) == 0
            || !swift_isUniquelyReferenced_nonNull_native(v14 & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v40 > 15) {
              goto LABEL_102;
            }
            unint64_t v14 = v215;
            if ((v215 & 0x2000000000000000) == 0)
            {
              uint64_t v13 = v215;
LABEL_127:
              int v86 = 1;
              goto LABEL_180;
            }
            int v86 = 0;
            uint64_t v13 = v215;
            goto LABEL_180;
          }
          uint64_t v13 = v215;
          int64_t v41 = _StringGuts.nativeUnusedCapacity.getter(v214, v215);
          if ((v42 & 1) == 0)
          {
            if (v40 >= 16) {
              goto LABEL_102;
            }
            if ((v13 & 0x2000000000000000) == 0)
            {
              unint64_t v14 = v13;
              if (v41 < v39) {
                goto LABEL_127;
              }
LABEL_102:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v40, v39);
              swift_bridgeObjectRelease_n(v12, 4);
              if ((v12 & 0x1000000000000000) != 0)
              {
                swift_bridgeObjectRelease(v12);
                uint64_t v63 = v11;
                unint64_t v64 = v12;
                uint64_t v65 = v17;
                goto LABEL_159;
              }
              if (v24)
              {
                swift_bridgeObjectRelease_n(v12, 2);
                uint64_t v47 = (v12 >> 62) & 1;
                *(void *)&long long v210 = v11;
                *((void *)&v210 + 1) = v12 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v67 = v18;
                uint64_t v68 = v18;
LABEL_123:
                uint64_t v48 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v67, (uint64_t)&v210, v68);
                goto LABEL_124;
              }
              goto LABEL_154;
            }
            int v86 = 0;
            unint64_t v14 = v13;
LABEL_180:
            swift_bridgeObjectRelease_n(v12, 5);
            uint64_t v18 = v214;
            if (!v86) {
              goto LABEL_181;
            }
            goto LABEL_237;
          }
LABEL_250:
          unint64_t v198 = 258;
LABEL_251:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v198, 0);
        }
        goto LABEL_230;
      }
LABEL_53:
      BOOL v22 = __OFADD__(v23, v39);
      int64_t v40 = v23 + v39;
      if (!v22) {
        goto LABEL_54;
      }
LABEL_230:
      __break(1u);
      goto LABEL_231;
    }
    goto LABEL_99;
  }
  uint64_t v212 = 0;
  long long v210 = 0u;
  long long v211 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v210, &demangling cache variable for type metadata for CustomStringConvertible?);
  uint64_t v213 = a1;
  uint64_t v51 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v210, (unint64_t *)&v213, (Class *)v2, v51, 6uLL))
  {
    outlined init with take of MirrorPath(&v210, (uint64_t)v207);
    uint64_t v52 = (uint64_t)v208;
    uint64_t v53 = v209;
    __swift_project_boxed_opaque_existential_0Tm(v207, (uint64_t)v208);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(v53 + 8))(v52, v53);
    uint64_t v11 = v54;
    unint64_t v12 = v55;
    uint64_t v13 = v214;
    uint64_t v17 = v215;
    unint64_t v56 = HIBYTE(v215) & 0xF;
    if ((v215 & 0x2000000000000000) != 0) {
      int64_t v40 = HIBYTE(v215) & 0xF;
    }
    else {
      int64_t v40 = v214 & 0xFFFFFFFFFFFFLL;
    }
    if (v40 || (v214 & ~v215 & 0x2000000000000000) != 0)
    {
      uint64_t v24 = v55 & 0x2000000000000000;
      unint64_t v14 = HIBYTE(v55) & 0xF;
      if ((v215 & 0x2000000000000000) != 0 && v24)
      {
        unint64_t v57 = v56 + v14;
        if (v56 + v14 <= 0xF)
        {
          if (v14)
          {
            uint64_t v161 = 0;
            unint64_t v162 = 0;
            uint64_t v163 = 8 * v14;
            unint64_t v164 = v215;
            do
            {
              unint64_t v165 = v56 + v162;
              BOOL v76 = v162++ >= 8;
              if (v76) {
                unint64_t v166 = v55;
              }
              else {
                unint64_t v166 = v54;
              }
              char v167 = (8 * v56 + v161) & 0x38;
              uint64_t v168 = (-255 << v167) - 1;
              unint64_t v169 = (unint64_t)(v166 >> (v161 & 0x38)) << v167;
              unint64_t v170 = v169 | v168 & v164;
              unint64_t v171 = v169 | v168 & v13;
              if (v165 < 8) {
                uint64_t v13 = v171;
              }
              else {
                unint64_t v164 = v170;
              }
              v161 += 8;
            }
            while (v163 != v161);
          }
          else
          {
            unint64_t v164 = v215;
          }
          swift_bridgeObjectRelease(v215);
          swift_bridgeObjectRelease(v12);
          unint64_t v172 = 0xA000000000000000;
          if (!(v13 & 0x8080808080808080 | v164 & 0x80808080808080)) {
            unint64_t v172 = 0xE000000000000000;
          }
          unint64_t v140 = v172 & 0xFF00000000000000 | (v57 << 56) | v164 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_175;
        }
        uint64_t v24 = 1;
      }
      uint64_t v20 = v54 & 0xFFFFFFFFFFFFLL;
      if (v24) {
        uint64_t v18 = HIBYTE(v55) & 0xF;
      }
      else {
        uint64_t v18 = v54 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v55, 2);
      if ((v12 & 0x1000000000000000) == 0)
      {
        swift_bridgeObjectRetain_n(v12, 4);
        Swift::Int v58 = v18;
        if ((v17 & 0x1000000000000000) != 0) {
          goto LABEL_234;
        }
        goto LABEL_90;
      }
LABEL_231:
      swift_bridgeObjectRetain_n(v12, 5);
      v187._Swift::UInt64 rawBits = 1;
      v188._Swift::UInt64 rawBits = (v18 << 16) | 1;
      v189._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v187, v188, v11, v12);
      if (v189._rawBits < 0x10000) {
        v189._rawBits |= 3;
      }
      Swift::Int v58 = specialized Collection.count.getter(v189, v190, v11, v12);
      swift_bridgeObjectRelease(v12);
      if ((v17 & 0x1000000000000000) != 0)
      {
LABEL_234:
        Swift::Int v191 = String.UTF8View._foreignCount()();
        int64_t v59 = v191 + v58;
        if (!__OFADD__(v191, v58)) {
          goto LABEL_91;
        }
        goto LABEL_236;
      }
LABEL_90:
      BOOL v22 = __OFADD__(v40, v58);
      int64_t v59 = v40 + v58;
      if (!v22)
      {
LABEL_91:
        if ((v13 & ~v17 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
        {
          uint64_t v60 = v215;
          int64_t v61 = _StringGuts.nativeUnusedCapacity.getter(v214, v215);
          if (v62) {
            goto LABEL_250;
          }
          if (v59 < 16 && ((v60 & 0x2000000000000000) != 0 || v61 < v58)) {
            goto LABEL_149;
          }
        }
        else if (v59 <= 15)
        {
          uint64_t v60 = v215;
LABEL_149:
          swift_bridgeObjectRelease_n(v12, 5);
          unint64_t v108 = v214;
          swift_bridgeObjectRetain(v60);
          unint64_t v109 = _StringGuts._convertedToSmall()(v108, v60);
          unint64_t v111 = v110;
          swift_bridgeObjectRelease(v60);
          v112._Swift::UInt64 rawBits = (v18 << 16) | 1;
          v113._Swift::UInt64 rawBits = 1;
          v114._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v113, v112, v11, v12);
          if (v114._rawBits < 0x10000) {
            v114._rawBits |= 3;
          }
          unint64_t v116 = specialized String.init(_:)(v114, v115, v11, v12);
          unint64_t v118 = v117;
          swift_bridgeObjectRelease(v12);
          unint64_t v119 = _StringGuts._convertedToSmall()(v116, v118);
          unint64_t v121 = v120;
          swift_bridgeObjectRelease(v118);
          unint64_t v122 = specialized _SmallString.init(_:appending:)(v109, v111, v119, v121);
          if (v124)
          {
LABEL_249:
            unint64_t v198 = 266;
            goto LABEL_251;
          }
          uint64_t v125 = v122;
          unint64_t v126 = v123;
          swift_bridgeObjectRelease(v60);
          swift_bridgeObjectRelease(v12);
          uint64_t v214 = v125;
          unint64_t v215 = v126;
LABEL_176:
          __swift_destroy_boxed_opaque_existential_1Tm(v207);
          return v214;
        }
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v59, v58);
        swift_bridgeObjectRelease_n(v12, 4);
        if ((v12 & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v12);
          uint64_t v63 = v11;
          unint64_t v64 = v12;
          uint64_t v65 = v18;
          goto LABEL_159;
        }
        if (v24)
        {
          swift_bridgeObjectRelease_n(v12, 2);
          uint64_t v47 = (v12 >> 62) & 1;
          *(void *)&long long v210 = v11;
          *((void *)&v210 + 1) = v12 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v67 = v14;
          uint64_t v68 = v14;
          goto LABEL_123;
        }
LABEL_154:
        if ((v11 & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v12);
          id v83 = (id)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v85 = v20;
        }
        else
        {
          id v83 = _StringObject.sharedUTF8.getter(v11, v12);
          uint64_t v85 = v197;
          swift_bridgeObjectRelease(v12);
          if (v85 < v20) {
            goto LABEL_248;
          }
        }
        uint64_t v84 = v20;
        goto LABEL_157;
      }
LABEL_236:
      __break(1u);
LABEL_237:
      if ((v14 & 0x1000000000000000) != 0)
      {
        uint64_t v18 = _StringGuts._foreignConvertedToSmall()(v18, v13);
        unint64_t v14 = v203;
      }
      else
      {
        if ((v18 & 0x1000000000000000) != 0)
        {
          char v192 = (unsigned __int8 *)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v193 = v18 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          char v192 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v13);
          uint64_t v193 = v206;
        }
        swift_bridgeObjectRetain(v13);
        closure #1 in _StringGuts._convertedToSmall()(v192, v193, &v210);
        swift_bridgeObjectRelease(v13);
        unint64_t v14 = *((void *)&v210 + 1);
        uint64_t v18 = v210;
      }
LABEL_181:
      v142._Swift::UInt64 rawBits = (v17 << 16) | 1;
      v143._Swift::UInt64 rawBits = 1;
      v144._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v143, v142, v11, v12);
      if (v144._rawBits < 0x10000) {
        v144._rawBits |= 3;
      }
      unint64_t v146 = specialized String.init(_:)(v144, v145, v11, v12);
      unint64_t v148 = v147;
      swift_bridgeObjectRelease(v12);
      if ((v148 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v148);
      }
      else if ((v148 & 0x1000000000000000) != 0)
      {
        unint64_t v146 = _StringGuts._foreignConvertedToSmall()(v146, v148);
        unint64_t v205 = v204;
        swift_bridgeObjectRelease(v148);
        unint64_t v148 = v205;
      }
      else
      {
        if ((v146 & 0x1000000000000000) != 0)
        {
          uint64_t v194 = (unsigned __int8 *)((v148 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v195 = v146 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v194 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v146, v148);
        }
        closure #1 in _StringGuts._convertedToSmall()(v194, v195, &v210);
        swift_bridgeObjectRelease(v148);
        unint64_t v148 = *((void *)&v210 + 1);
        unint64_t v146 = v210;
      }
      uint64_t v149 = HIBYTE(v14) & 0xF;
      uint64_t v150 = HIBYTE(v148) & 0xF;
      uint64_t v96 = v150 + v149;
      if ((unint64_t)(v150 + v149) <= 0xF)
      {
        if (v150)
        {
          uint64_t v151 = 0;
          unint64_t v152 = 0;
          uint64_t v153 = 8 * v150;
          do
          {
            unint64_t v154 = v149 + v152;
            BOOL v76 = v152++ >= 8;
            if (v76) {
              unint64_t v155 = v148;
            }
            else {
              unint64_t v155 = v146;
            }
            char v156 = (8 * v149 + v151) & 0x38;
            uint64_t v157 = (-255 << v156) - 1;
            unint64_t v158 = (unint64_t)(v155 >> (v151 & 0x38)) << v156;
            unint64_t v159 = v158 | v157 & v14;
            unint64_t v160 = v158 | v157 & v18;
            if (v154 < 8) {
              uint64_t v18 = v160;
            }
            else {
              unint64_t v14 = v159;
            }
            v151 += 8;
          }
          while (v153 != v151);
        }
        goto LABEL_144;
      }
      goto LABEL_249;
    }
    uint64_t v66 = v215;
LABEL_100:
    swift_bridgeObjectRelease(v66);
    uint64_t v214 = v11;
    unint64_t v215 = v12;
    goto LABEL_176;
  }
  uint64_t v212 = 0;
  long long v210 = 0u;
  long long v211 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v210, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v211 + 1) = v2;
  *(void *)&long long v210 = a1;
  Mirror.init(reflecting:)((uint64_t *)&v210, (uint64_t)v207);
  uint64_t v69 = v207[1];
  uint64_t v70 = v209;
  ((void (*)(uint64_t *, uint64_t *, uint64_t *, void, uint64_t *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(&v216, v207, &v214, 0, v2, &type metadata for String, &protocol witness table for String);
  swift_release(v70);
  swift_release(v69);
  return v214;
}

unint64_t specialized String.init<A>(describing:)(Swift::UInt64 a1)
{
  v22[0] = 0;
  v22[1] = 0xE000000000000000;
  uint64_t v20 = &type metadata for UnsafeMutableRawPointer;
  v19[0] = a1;
  uint64_t v2 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)&type metadata for UnsafeMutableRawPointer);
  unint64_t DynamicType = (void *)swift_getDynamicType(v2, &type metadata for UnsafeMutableRawPointer.Kind, 1);
  BOOL isOptionalType = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(v19);
  if (isOptionalType)
  {
    unint64_t v5 = specialized _Pointer.debugDescription.getter(a1);
    swift_bridgeObjectRelease(0xE000000000000000);
  }
  else
  {
    Swift::UInt64 v18 = a1;
    uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v15, &v18, (Class *)&type metadata for UnsafeMutableRawPointer, v6, 6uLL))
    {
      outlined init with take of MirrorPath(&v15, (uint64_t)v19);
      uint64_t v7 = v20;
      uint64_t v8 = v21;
      __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
      ((void (*)(void *, ValueMetadata *, _UNKNOWN **, ValueMetadata *, _UNKNOWN **))v8[1])(v22, &type metadata for String, &protocol witness table for String, v7, v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
      return v22[0];
    }
    else
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v15, &demangling cache variable for type metadata for TextOutputStreamable?);
      Swift::UInt64 v18 = a1;
      uint64_t v9 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast((char *)&v15, &v18, (Class *)&type metadata for UnsafeMutableRawPointer, v9, 6uLL))
      {
        outlined init with take of MirrorPath(&v15, (uint64_t)v19);
        unint64_t v10 = v20;
        uint64_t v11 = v21;
        __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
        unint64_t v12 = ((uint64_t (*)(ValueMetadata *, _UNKNOWN **))v11[1])(v10, v11);
      }
      else
      {
        uint64_t v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v15, &demangling cache variable for type metadata for CustomStringConvertible?);
        uint64_t v20 = &type metadata for UnsafeMutableRawPointer;
        Swift::Int v21 = &protocol witness table for UnsafeMutableRawPointer;
        v19[0] = a1;
        uint64_t v13 = __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)&type metadata for UnsafeMutableRawPointer);
        unint64_t v12 = specialized _Pointer.debugDescription.getter(*v13);
      }
      unint64_t v5 = v12;
      swift_bridgeObjectRelease(0xE000000000000000);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
    }
  }
  return v5;
}

uint64_t specialized String.init<A>(describing:)(void *a1)
{
  v22[0] = 0;
  v22[1] = 0xE000000000000000;
  uint64_t v20 = &type metadata for UnsafeRawPointer;
  v19[0] = (uint64_t)a1;
  uint64_t v2 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)&type metadata for UnsafeRawPointer);
  unint64_t DynamicType = (void *)swift_getDynamicType(v2, &type metadata for UnsafeRawPointer.Kind, 1);
  BOOL isOptionalType = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(v19);
  if (isOptionalType)
  {
    uint64_t countAndFlagsBits = _rawPointerToString(_:)(a1)._countAndFlagsBits;
    swift_bridgeObjectRelease(0xE000000000000000);
  }
  else
  {
    Swift::UInt64 v18 = a1;
    uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v15, (unint64_t *)&v18, (Class *)&type metadata for UnsafeRawPointer, v6, 6uLL))
    {
      outlined init with take of MirrorPath(&v15, (uint64_t)v19);
      uint64_t v7 = v20;
      uint64_t v8 = v21;
      __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
      ((void (*)(void *, ValueMetadata *, _UNKNOWN **, ValueMetadata *, _UNKNOWN **))v8[1])(v22, &type metadata for String, &protocol witness table for String, v7, v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
      return v22[0];
    }
    else
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v15, &demangling cache variable for type metadata for TextOutputStreamable?);
      Swift::UInt64 v18 = a1;
      uint64_t v9 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast((char *)&v15, (unint64_t *)&v18, (Class *)&type metadata for UnsafeRawPointer, v9, 6uLL))
      {
        outlined init with take of MirrorPath(&v15, (uint64_t)v19);
        unint64_t v10 = v20;
        uint64_t v11 = v21;
        __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
        uint64_t v12 = ((uint64_t (*)(ValueMetadata *, _UNKNOWN **))v11[1])(v10, v11);
      }
      else
      {
        uint64_t v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v15, &demangling cache variable for type metadata for CustomStringConvertible?);
        uint64_t v20 = &type metadata for UnsafeRawPointer;
        Swift::Int v21 = &protocol witness table for UnsafeRawPointer;
        v19[0] = (uint64_t)a1;
        uint64_t v13 = (Builtin::RawPointer *)__swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)&type metadata for UnsafeRawPointer);
        uint64_t v12 = _rawPointerToString(_:)(*v13)._countAndFlagsBits;
      }
      uint64_t countAndFlagsBits = v12;
      swift_bridgeObjectRelease(0xE000000000000000);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
    }
  }
  return countAndFlagsBits;
}

uint64_t String.init<A>(describing:)(uint64_t a1, Class *a2)
{
  uint64_t v4 = (uint64_t)*(a2 - 1);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  uint64_t v240 = (unint64_t *)((char *)&v239 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v9 = (unint64_t *)((char *)&v239 - v8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (unint64_t *)((char *)&v239 - v11);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  long long v15 = (unint64_t *)((char *)&v239 - v14);
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (unint64_t *)((char *)&v239 - v16);
  unint64_t v248 = 0;
  unint64_t v249 = 0xE000000000000000;
  unint64_t v243 = (uint64_t *)v18;
  unint64_t v19 = __swift_allocate_boxed_opaque_existential_0Tm(&v241);
  uint64_t v20 = *(void (**)(unint64_t *, uint64_t, Class *))(v4 + 16);
  v20(v19, a1, a2);
  Swift::Int v21 = v243;
  BOOL v22 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v241, (uint64_t)v243);
  unint64_t DynamicType = (void *)swift_getDynamicType(v22, v21, 1);
  LODWORD(v21) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v241);
  if (v21)
  {
    (*(void (**)(unint64_t *, uint64_t, Class *))(v4 + 32))(v17, a1, a2);
    uint64_t v24 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v241, v17, a2, v24, 7uLL);
    uint64_t v25 = (uint64_t)v243;
    uint64_t v26 = v244;
    __swift_project_boxed_opaque_existential_0Tm(&v241, (uint64_t)v243);
    uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 8))(v25, v26);
    uint64_t v29 = v27;
    unint64_t v30 = v28;
    uint64_t v31 = v248;
    unint64_t v32 = v249;
    unint64_t v33 = HIBYTE(v249) & 0xF;
    if ((v249 & 0x2000000000000000) != 0) {
      unint64_t v34 = HIBYTE(v249) & 0xF;
    }
    else {
      unint64_t v34 = v248 & 0xFFFFFFFFFFFFLL;
    }
    if (v34 || (v248 & ~v249 & 0x2000000000000000) != 0)
    {
      uint64_t v35 = v28 & 0x2000000000000000;
      unint64_t v36 = HIBYTE(v28) & 0xF;
      if ((v249 & 0x2000000000000000) == 0 || !v35) {
        goto LABEL_11;
      }
      unint64_t v37 = v33 + v36;
      if (v33 + v36 > 0xF)
      {
        uint64_t v35 = 1;
LABEL_11:
        uint64_t v240 = (unint64_t *)(v27 & 0xFFFFFFFFFFFFLL);
        if (v35) {
          uint64_t v38 = HIBYTE(v28) & 0xF;
        }
        else {
          uint64_t v38 = v27 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v28, 2);
        if ((v30 & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRetain_n(v30, 5);
          v205._Swift::UInt64 rawBits = 1;
          v206._Swift::UInt64 rawBits = (v38 << 16) | 1;
          v207._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v205, v206, v29, v30);
          if (v207._rawBits < 0x10000) {
            v207._rawBits |= 3;
          }
          Swift::Int v39 = specialized Collection.count.getter(v207, v208, v29, v30);
          swift_bridgeObjectRelease(v30);
          if ((v32 & 0x1000000000000000) == 0)
          {
LABEL_16:
            BOOL v40 = __OFADD__(v34, v39);
            Swift::Int v41 = v34 + v39;
            if (!v40)
            {
LABEL_17:
              if ((v31 & ~v32 & 0x2000000000000000) != 0
                && swift_isUniquelyReferenced_nonNull_native(v32 & 0xFFFFFFFFFFFFFFFLL))
              {
                uint64_t v42 = v248;
                uint64_t v31 = v249;
                int64_t v43 = _StringGuts.nativeUnusedCapacity.getter(v248, v249);
                if (v44) {
                  goto LABEL_261;
                }
                if (v41 > 15) {
                  goto LABEL_32;
                }
                if ((v31 & 0x2000000000000000) == 0)
                {
                  unint64_t v32 = v31;
                  if (v43 < v39) {
                    goto LABEL_59;
                  }
                  goto LABEL_32;
                }
                int v63 = 0;
                unint64_t v32 = v31;
              }
              else
              {
                if (v41 >= 16)
                {
                  uint64_t v42 = v248;
                  uint64_t v31 = v249;
LABEL_32:
                  int64_t v48 = _StringGuts.nativeUnusedCapacity.getter(v42, v31);
                  uint64_t v51 = (v49 & 1) == 0 && v48 >= v39;
                  if ((v42 & ~v31 & 0x2000000000000000) != 0
                    && swift_isUniquelyReferenced_nonNull_native(v31 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if (v51) {
                      goto LABEL_52;
                    }
                  }
                  else if (v51)
                  {
LABEL_51:
                    _StringGuts.grow(_:)(v41);
LABEL_52:
                    swift_bridgeObjectRelease_n(v30, 4);
                    if ((v30 & 0x1000000000000000) == 0)
                    {
                      if (v35)
                      {
                        swift_bridgeObjectRelease_n(v30, 2);
                        uint64_t v59 = (v30 >> 62) & 1;
                        *(void *)&long long v245 = v29;
                        *((void *)&v245 + 1) = v30 & 0xFFFFFFFFFFFFFFLL;
                        uint64_t v60 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v30) & 0xF, (uint64_t)&v245, HIBYTE(v30) & 0xF);
LABEL_55:
                        LOBYTE(v62) = v59;
LABEL_56:
                        _StringGuts.appendInPlace(_:isASCII:)(v60, v61, v62);
                        swift_bridgeObjectRelease(v30);
                        goto LABEL_204;
                      }
                      if ((v29 & 0x1000000000000000) != 0)
                      {
                        swift_bridgeObjectRelease(v30);
                        id v106 = (id)((v30 & 0xFFFFFFFFFFFFFFFLL) + 32);
                        uint64_t v107 = (uint64_t)v240;
                        uint64_t v108 = (uint64_t)v240;
LABEL_123:
                        unint64_t v109 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v107, (uint64_t)v106, v108);
                        _StringGuts.appendInPlace(_:isASCII:)(v109, v110, v29 < 0);
                        goto LABEL_124;
                      }
                      goto LABEL_242;
                    }
                    swift_bridgeObjectRelease(v30);
                    uint64_t v74 = v29;
                    unint64_t v75 = v30;
                    uint64_t v76 = v38;
LABEL_84:
                    _StringGuts._foreignAppendInPlace(_:)(v74, v75, 0, v76);
LABEL_124:
                    swift_bridgeObjectRelease_n(v30, 2);
                    goto LABEL_204;
                  }
                  uint64_t v55 = _StringGuts.nativeCapacity.getter(v248, v249);
                  if (v56) {
                    uint64_t v57 = 0;
                  }
                  else {
                    uint64_t v57 = v55;
                  }
                  if (v57 + 0x4000000000000000 >= 0)
                  {
                    uint64_t v58 = 2 * v57;
                    if (v58 > v41) {
                      Swift::Int v41 = v58;
                    }
                    goto LABEL_51;
                  }
                  __break(1u);
                  goto LABEL_236;
                }
                unint64_t v32 = v249;
                if ((v249 & 0x2000000000000000) == 0)
                {
                  uint64_t v31 = v249;
LABEL_59:
                  int v63 = 1;
                  goto LABEL_132;
                }
                int v63 = 0;
                uint64_t v31 = v249;
              }
LABEL_132:
              swift_bridgeObjectRelease_n(v30, 5);
              unint64_t v36 = v248;
              if (!v63) {
                goto LABEL_133;
              }
              goto LABEL_227;
            }
LABEL_226:
            __break(1u);
LABEL_227:
            if ((v32 & 0x1000000000000000) != 0)
            {
              unint64_t v36 = _StringGuts._foreignConvertedToSmall()(v36, v31);
              unint64_t v32 = v231;
            }
            else
            {
              if ((v36 & 0x1000000000000000) != 0)
              {
                long long v210 = (unsigned __int8 *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v211 = v36 & 0xFFFFFFFFFFFFLL;
              }
              else
              {
                long long v210 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v36, v31);
                uint64_t v211 = v234;
              }
              swift_bridgeObjectRetain(v31);
              closure #1 in _StringGuts._convertedToSmall()(v210, v211, &v245);
              swift_bridgeObjectRelease(v31);
              unint64_t v32 = *((void *)&v245 + 1);
              unint64_t v36 = v245;
            }
LABEL_133:
            v114._Swift::UInt64 rawBits = (v38 << 16) | 1;
            v115._Swift::UInt64 rawBits = 1;
            v116._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v115, v114, v29, v30);
            if (v116._rawBits < 0x10000) {
              v116._rawBits |= 3;
            }
            unint64_t v118 = specialized String.init(_:)(v116, v117, v29, v30);
            unint64_t v120 = v119;
            swift_bridgeObjectRelease(v30);
            if ((v120 & 0x2000000000000000) != 0)
            {
              swift_bridgeObjectRelease(v120);
            }
            else if ((v120 & 0x1000000000000000) != 0)
            {
              unint64_t v118 = _StringGuts._foreignConvertedToSmall()(v118, v120);
              unint64_t v233 = v232;
              swift_bridgeObjectRelease(v120);
              unint64_t v120 = v233;
            }
            else
            {
              if ((v118 & 0x1000000000000000) != 0)
              {
                uint64_t v212 = (unsigned __int8 *)((v120 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v213 = v118 & 0xFFFFFFFFFFFFLL;
              }
              else
              {
                uint64_t v212 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v118, v120);
              }
              closure #1 in _StringGuts._convertedToSmall()(v212, v213, &v245);
              swift_bridgeObjectRelease(v120);
              unint64_t v120 = *((void *)&v245 + 1);
              unint64_t v118 = v245;
            }
            uint64_t v121 = HIBYTE(v32) & 0xF;
            uint64_t v122 = HIBYTE(v120) & 0xF;
            uint64_t v123 = v122 + v121;
            if ((unint64_t)(v122 + v121) <= 0xF)
            {
              if (v122)
              {
                char v124 = 0;
                unint64_t v125 = 0;
                do
                {
                  unint64_t v126 = v121 + v125;
                  unint64_t v127 = v125 + 1;
                  if (v125 >= 8) {
                    unint64_t v128 = v120;
                  }
                  else {
                    unint64_t v128 = v118;
                  }
                  unint64_t v129 = v128 >> (v124 & 0x38);
                  char v130 = (8 * v121 + v124) & 0x38;
                  uint64_t v131 = (-255 << v130) - 1;
                  unint64_t v132 = (unint64_t)v129 << v130;
                  unint64_t v133 = v132 | v131 & v32;
                  unint64_t v134 = v132 | v131 & v36;
                  if (v126 < 8) {
                    unint64_t v36 = v134;
                  }
                  else {
                    unint64_t v32 = v133;
                  }
                  v124 += 8;
                  unint64_t v125 = v127;
                }
                while (v122 != v127);
              }
              swift_bridgeObjectRelease(v31);
              swift_bridgeObjectRelease(v30);
              unint64_t v135 = 0xA000000000000000;
              if (!(v36 & 0x8080808080808080 | v32 & 0x80808080808080)) {
                unint64_t v135 = 0xE000000000000000;
              }
              unint64_t v248 = v36;
              unint64_t v249 = v135 & 0xFF00000000000000 | (v123 << 56) | v32 & 0xFFFFFFFFFFFFFFLL;
              goto LABEL_204;
            }
            goto LABEL_260;
          }
        }
        else
        {
          swift_bridgeObjectRetain_n(v30, 4);
          Swift::Int v39 = v38;
          if ((v32 & 0x1000000000000000) == 0) {
            goto LABEL_16;
          }
        }
        Swift::Int v209 = String.UTF8View._foreignCount()();
        Swift::Int v41 = v209 + v39;
        if (!__OFADD__(v209, v39)) {
          goto LABEL_17;
        }
        goto LABEL_226;
      }
      if (v36)
      {
        char v94 = 0;
        unint64_t v95 = 0;
        unint64_t v96 = v249;
        do
        {
          unint64_t v97 = v33 + v95;
          unint64_t v98 = v95 + 1;
          if (v95 >= 8) {
            unint64_t v99 = v28;
          }
          else {
            unint64_t v99 = v27;
          }
          unint64_t v100 = v99 >> (v94 & 0x38);
          char v101 = (8 * v33 + v94) & 0x38;
          uint64_t v102 = (-255 << v101) - 1;
          unint64_t v103 = (unint64_t)v100 << v101;
          unint64_t v104 = v103 | v102 & v96;
          unint64_t v105 = v103 | v102 & v31;
          if (v97 < 8) {
            uint64_t v31 = v105;
          }
          else {
            unint64_t v96 = v104;
          }
          v94 += 8;
          unint64_t v95 = v98;
        }
        while (v36 != v98);
      }
      else
      {
        unint64_t v96 = v249;
      }
      uint64_t v136 = v249;
      goto LABEL_152;
    }
    uint64_t v77 = v249;
LABEL_86:
    swift_bridgeObjectRelease(v77);
    unint64_t v248 = v29;
    unint64_t v249 = v30;
    goto LABEL_204;
  }
  v20(v15, a1, a2);
  if ((swift_dynamicCast((char *)&v241, v15, a2, (const char *)&type metadata for String, 6uLL) & 1) == 0)
  {
    v20(v12, a1, a2);
    uint64_t v52 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v245, v12, a2, v52, 6uLL))
    {
      (*(void (**)(uint64_t, Class *))(v4 + 8))(a1, a2);
      outlined init with take of MirrorPath(&v245, (uint64_t)&v241);
      uint64_t v53 = (uint64_t)v243;
      uint64_t v54 = v244;
      __swift_project_boxed_opaque_existential_0Tm(&v241, (uint64_t)v243);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v54 + 8))(&v248, &type metadata for String, &protocol witness table for String, v53, v54);
LABEL_204:
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v241);
      return v248;
    }
    uint64_t v247 = 0;
    long long v245 = 0u;
    long long v246 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v245, &demangling cache variable for type metadata for TextOutputStreamable?);
    v20(v9, a1, a2);
    unint64_t v64 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v245, v9, a2, v64, 6uLL))
    {
      (*(void (**)(uint64_t, Class *))(v4 + 8))(a1, a2);
      outlined init with take of MirrorPath(&v245, (uint64_t)&v241);
      uint64_t v65 = (uint64_t)v243;
      uint64_t v66 = v244;
      __swift_project_boxed_opaque_existential_0Tm(&v241, (uint64_t)v243);
      uint64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t))(v66 + 8))(v65, v66);
      uint64_t v29 = v67;
      unint64_t v30 = v68;
      uint64_t v31 = v248;
      unint64_t v36 = v249;
      unint64_t v69 = HIBYTE(v249) & 0xF;
      if ((v249 & 0x2000000000000000) != 0) {
        Swift::Int v41 = HIBYTE(v249) & 0xF;
      }
      else {
        Swift::Int v41 = v248 & 0xFFFFFFFFFFFFLL;
      }
      if (v41 || (v248 & ~v249 & 0x2000000000000000) != 0)
      {
        uint64_t v42 = v68 & 0x2000000000000000;
        uint64_t v51 = HIBYTE(v68) & 0xF;
        if ((v249 & 0x2000000000000000) != 0 && v42)
        {
          unint64_t v37 = v69 + v51;
          if (v69 + v51 <= 0xF)
          {
            if (v51)
            {
              char v159 = 0;
              unint64_t v160 = 0;
              unint64_t v96 = v249;
              do
              {
                unint64_t v161 = v69 + v160;
                unint64_t v162 = v160 + 1;
                if (v160 >= 8) {
                  unint64_t v163 = v68;
                }
                else {
                  unint64_t v163 = v67;
                }
                unint64_t v164 = v163 >> (v159 & 0x38);
                char v165 = (8 * v69 + v159) & 0x38;
                uint64_t v166 = (-255 << v165) - 1;
                unint64_t v167 = (unint64_t)v164 << v165;
                unint64_t v168 = v167 | v166 & v96;
                unint64_t v169 = v167 | v166 & v31;
                if (v161 < 8) {
                  uint64_t v31 = v169;
                }
                else {
                  unint64_t v96 = v168;
                }
                v159 += 8;
                unint64_t v160 = v162;
              }
              while (v51 != v162);
              uint64_t v136 = v249;
            }
            else
            {
              unint64_t v96 = v249;
              uint64_t v136 = v249;
            }
LABEL_152:
            swift_bridgeObjectRelease(v136);
            swift_bridgeObjectRelease(v30);
            unint64_t v137 = 0xA000000000000000;
            if (!(v31 & 0x8080808080808080 | v96 & 0x80808080808080)) {
              unint64_t v137 = 0xE000000000000000;
            }
            unint64_t v138 = v137 | (v37 << 56);
LABEL_155:
            unint64_t v248 = v31;
            unint64_t v249 = v138 & 0xFF00000000000000 | v96 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_204;
          }
          uint64_t v42 = 1;
        }
        uint64_t v38 = v67 & 0xFFFFFFFFFFFFLL;
        if (v42) {
          uint64_t v35 = HIBYTE(v68) & 0xF;
        }
        else {
          uint64_t v35 = v67 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v68, 2);
        if ((v30 & 0x1000000000000000) == 0)
        {
          swift_bridgeObjectRetain_n(v30, 4);
          Swift::Int v70 = v35;
          if ((v36 & 0x1000000000000000) != 0) {
            goto LABEL_239;
          }
          goto LABEL_75;
        }
LABEL_236:
        swift_bridgeObjectRetain_n(v30, 5);
        v214._Swift::UInt64 rawBits = 1;
        v215._Swift::UInt64 rawBits = (v35 << 16) | 1;
        v216._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v214, v215, v29, v30);
        if (v216._rawBits < 0x10000) {
          v216._rawBits |= 3;
        }
        Swift::Int v70 = specialized Collection.count.getter(v216, v217, v29, v30);
        swift_bridgeObjectRelease(v30);
        if ((v36 & 0x1000000000000000) != 0)
        {
LABEL_239:
          Swift::Int v218 = String.UTF8View._foreignCount()();
          int64_t v71 = v218 + v70;
          if (!__OFADD__(v218, v70))
          {
LABEL_76:
            if ((v31 & ~v36 & 0x2000000000000000) == 0
              || !swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
            {
              if (v71 <= 15)
              {
                unint64_t v36 = v249;
                if ((v249 & 0x2000000000000000) == 0)
                {
                  uint64_t v31 = v249;
LABEL_162:
                  int v139 = 1;
                  goto LABEL_186;
                }
                int v139 = 0;
                uint64_t v31 = v249;
                goto LABEL_186;
              }
LABEL_127:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v71, v70);
              swift_bridgeObjectRelease_n(v30, 4);
              if ((v30 & 0x1000000000000000) != 0)
              {
                swift_bridgeObjectRelease(v30);
                uint64_t v74 = v29;
                unint64_t v75 = v30;
                uint64_t v76 = v35;
                goto LABEL_84;
              }
              if (v42)
              {
                swift_bridgeObjectRelease_n(v30, 2);
                uint64_t v59 = (v30 >> 62) & 1;
                *(void *)&long long v245 = v29;
                *((void *)&v245 + 1) = v30 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v60 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v51, (uint64_t)&v245, v51);
                goto LABEL_55;
              }
LABEL_171:
              if ((v29 & 0x1000000000000000) != 0)
              {
                swift_bridgeObjectRelease(v30);
                id v106 = (id)((v30 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v108 = v38;
              }
              else
              {
                id v106 = _StringObject.sharedUTF8.getter(v29, v30);
                uint64_t v108 = v229;
                swift_bridgeObjectRelease(v30);
                if (v108 < v38) {
                  goto LABEL_243;
                }
              }
              uint64_t v107 = v38;
              goto LABEL_123;
            }
            uint64_t v31 = v249;
            int64_t v72 = _StringGuts.nativeUnusedCapacity.getter(v248, v249);
            if ((v73 & 1) == 0)
            {
              if (v71 <= 15)
              {
                if ((v31 & 0x2000000000000000) == 0)
                {
                  unint64_t v36 = v31;
                  if (v72 < v70) {
                    goto LABEL_162;
                  }
                  goto LABEL_127;
                }
                int v139 = 0;
                unint64_t v36 = v31;
LABEL_186:
                swift_bridgeObjectRelease_n(v30, 5);
                uint64_t v88 = v248;
                if (!v139) {
                  goto LABEL_187;
                }
                goto LABEL_250;
              }
              goto LABEL_127;
            }
LABEL_261:
            unint64_t v230 = 258;
LABEL_262:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v230, 0);
          }
LABEL_241:
          __break(1u);
LABEL_242:
          id v106 = _StringObject.sharedUTF8.getter(v29, v30);
          uint64_t v108 = v219;
          swift_bridgeObjectRelease(v30);
          if (v108 >= (uint64_t)v240)
          {
            uint64_t v107 = (uint64_t)v240;
            goto LABEL_123;
          }
LABEL_243:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
        }
LABEL_75:
        BOOL v40 = __OFADD__(v41, v70);
        int64_t v71 = v41 + v70;
        if (!v40) {
          goto LABEL_76;
        }
        goto LABEL_241;
      }
      goto LABEL_163;
    }
    uint64_t v247 = 0;
    long long v245 = 0u;
    long long v246 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v245, &demangling cache variable for type metadata for CustomStringConvertible?);
    char v78 = v240;
    v20(v240, a1, a2);
    uint64_t v79 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (!swift_dynamicCast((char *)&v245, v78, a2, v79, 6uLL))
    {
      uint64_t v247 = 0;
      long long v245 = 0u;
      long long v246 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v245, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
      *((void *)&v246 + 1) = a2;
      unint64_t v111 = __swift_allocate_boxed_opaque_existential_0Tm(&v245);
      v20(v111, a1, a2);
      Mirror.init(reflecting:)((uint64_t *)&v245, (uint64_t)&v241);
      uint64_t v112 = v242;
      uint64_t v113 = v244;
      ((void (*)(uint64_t, unint64_t *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(a1, &v241, &v248, 0, a2, &type metadata for String, &protocol witness table for String);
      (*(void (**)(uint64_t, Class *))(v4 + 8))(a1, a2);
      swift_release(v113);
      swift_release(v112);
      return v248;
    }
    (*(void (**)(uint64_t, Class *))(v4 + 8))(a1, a2);
    outlined init with take of MirrorPath(&v245, (uint64_t)&v241);
    uint64_t v80 = (uint64_t)v243;
    uint64_t v81 = v244;
    __swift_project_boxed_opaque_existential_0Tm(&v241, (uint64_t)v243);
    uint64_t v82 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 8))(v80, v81);
    uint64_t v29 = v82;
    unint64_t v30 = v83;
    uint64_t v31 = v248;
    unint64_t v36 = v249;
    unint64_t v84 = HIBYTE(v249) & 0xF;
    if ((v249 & 0x2000000000000000) != 0) {
      unint64_t v85 = HIBYTE(v249) & 0xF;
    }
    else {
      unint64_t v85 = v248 & 0xFFFFFFFFFFFFLL;
    }
    if (!v85 && (v248 & ~v249 & 0x2000000000000000) == 0)
    {
LABEL_163:
      uint64_t v77 = v36;
      goto LABEL_86;
    }
    uint64_t v86 = v83 & 0x2000000000000000;
    uint64_t v35 = HIBYTE(v83) & 0xF;
    if ((v249 & 0x2000000000000000) != 0 && v86)
    {
      unint64_t v87 = v84 + v35;
      if (v84 + v35 <= 0xF)
      {
        if (v35)
        {
          char v193 = 0;
          unint64_t v194 = 0;
          unint64_t v96 = v249;
          do
          {
            unint64_t v195 = v84 + v194;
            unint64_t v196 = v194 + 1;
            if (v194 >= 8) {
              unint64_t v197 = v83;
            }
            else {
              unint64_t v197 = v82;
            }
            unint64_t v198 = v197 >> (v193 & 0x38);
            char v199 = (8 * v84 + v193) & 0x38;
            uint64_t v200 = (-255 << v199) - 1;
            unint64_t v201 = (unint64_t)v198 << v199;
            unint64_t v202 = v201 | v200 & v96;
            unint64_t v203 = v201 | v200 & v31;
            if (v195 < 8) {
              uint64_t v31 = v203;
            }
            else {
              unint64_t v96 = v202;
            }
            v193 += 8;
            unint64_t v194 = v196;
          }
          while (v35 != v196);
        }
        else
        {
          unint64_t v96 = v249;
        }
        swift_bridgeObjectRelease(v249);
        swift_bridgeObjectRelease(v30);
        unint64_t v204 = 0xA000000000000000;
        if (!(v31 & 0x8080808080808080 | v96 & 0x80808080808080)) {
          unint64_t v204 = 0xE000000000000000;
        }
        unint64_t v138 = v204 | (v87 << 56);
        goto LABEL_155;
      }
      uint64_t v86 = 1;
    }
    uint64_t v38 = v82 & 0xFFFFFFFFFFFFLL;
    if (v86) {
      uint64_t v88 = HIBYTE(v83) & 0xF;
    }
    else {
      uint64_t v88 = v82 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v83, 2);
    if ((v30 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v30, 5);
      v220._Swift::UInt64 rawBits = 1;
      v221._Swift::UInt64 rawBits = (v88 << 16) | 1;
      v222._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v220, v221, v29, v30);
      if (v222._rawBits < 0x10000) {
        v222._rawBits |= 3;
      }
      Swift::Int v89 = specialized Collection.count.getter(v222, v223, v29, v30);
      swift_bridgeObjectRelease(v30);
      if ((v36 & 0x1000000000000000) == 0)
      {
LABEL_103:
        BOOL v40 = __OFADD__(v85, v89);
        int64_t v90 = v85 + v89;
        if (!v40)
        {
LABEL_104:
          if ((v31 & ~v36 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
          {
            uint64_t v91 = v249;
            int64_t v92 = _StringGuts.nativeUnusedCapacity.getter(v248, v249);
            if (v93) {
              goto LABEL_261;
            }
            if (v90 <= 15 && ((v91 & 0x2000000000000000) != 0 || v92 < v89))
            {
LABEL_166:
              swift_bridgeObjectRelease_n(v30, 5);
              unint64_t v140 = v248;
              swift_bridgeObjectRetain(v91);
              unint64_t v141 = _StringGuts._convertedToSmall()(v140, v91);
              unint64_t v143 = v142;
              swift_bridgeObjectRelease(v91);
              v144._Swift::UInt64 rawBits = (v88 << 16) | 1;
              v145._Swift::UInt64 rawBits = 1;
              v146._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v145, v144, v29, v30);
              if (v146._rawBits < 0x10000) {
                v146._rawBits |= 3;
              }
              unint64_t v148 = specialized String.init(_:)(v146, v147, v29, v30);
              unint64_t v150 = v149;
              swift_bridgeObjectRelease(v30);
              unint64_t v151 = _StringGuts._convertedToSmall()(v148, v150);
              unint64_t v153 = v152;
              swift_bridgeObjectRelease(v150);
              unint64_t v154 = specialized _SmallString.init(_:appending:)(v141, v143, v151, v153);
              if ((v156 & 1) == 0)
              {
                uint64_t v157 = v154;
                unint64_t v158 = v155;
                swift_bridgeObjectRelease(v91);
                swift_bridgeObjectRelease(v30);
                unint64_t v248 = v157;
                unint64_t v249 = v158;
                goto LABEL_204;
              }
LABEL_260:
              unint64_t v230 = 266;
              goto LABEL_262;
            }
          }
          else if (v90 <= 15)
          {
            uint64_t v91 = v249;
            goto LABEL_166;
          }
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v90, v89);
          swift_bridgeObjectRelease_n(v30, 4);
          if ((v30 & 0x1000000000000000) != 0)
          {
            swift_bridgeObjectRelease(v30);
            uint64_t v74 = v29;
            unint64_t v75 = v30;
            uint64_t v76 = v88;
            goto LABEL_84;
          }
          if (v86)
          {
            swift_bridgeObjectRelease_n(v30, 2);
            *(void *)&long long v245 = v29;
            *((void *)&v245 + 1) = v30 & 0xFFFFFFFFFFFFFFLL;
            uint64_t v60 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v30) & 0xF, (uint64_t)&v245, HIBYTE(v30) & 0xF);
            uint64_t v62 = (v30 >> 62) & 1;
            goto LABEL_56;
          }
          goto LABEL_171;
        }
LABEL_249:
        __break(1u);
LABEL_250:
        if ((v36 & 0x1000000000000000) != 0)
        {
          uint64_t v88 = _StringGuts._foreignConvertedToSmall()(v88, v31);
          unint64_t v36 = v235;
        }
        else
        {
          if ((v88 & 0x1000000000000000) != 0)
          {
            uint64_t v225 = (unsigned __int8 *)((v36 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v226 = v88 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v225 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v88, v31);
            uint64_t v226 = v238;
          }
          swift_bridgeObjectRetain(v31);
          closure #1 in _StringGuts._convertedToSmall()(v225, v226, &v245);
          swift_bridgeObjectRelease(v31);
          unint64_t v36 = *((void *)&v245 + 1);
          uint64_t v88 = v245;
        }
LABEL_187:
        v170._Swift::UInt64 rawBits = (v35 << 16) | 1;
        v171._Swift::UInt64 rawBits = 1;
        v172._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v171, v170, v29, v30);
        if (v172._rawBits < 0x10000) {
          v172._rawBits |= 3;
        }
        unint64_t v174 = specialized String.init(_:)(v172, v173, v29, v30);
        unint64_t v176 = v175;
        swift_bridgeObjectRelease(v30);
        if ((v176 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v176);
        }
        else if ((v176 & 0x1000000000000000) != 0)
        {
          unint64_t v174 = _StringGuts._foreignConvertedToSmall()(v174, v176);
          unint64_t v237 = v236;
          swift_bridgeObjectRelease(v176);
          unint64_t v176 = v237;
        }
        else
        {
          if ((v174 & 0x1000000000000000) != 0)
          {
            char v227 = (unsigned __int8 *)((v176 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v228 = v174 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            char v227 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v174, v176);
          }
          closure #1 in _StringGuts._convertedToSmall()(v227, v228, &v245);
          swift_bridgeObjectRelease(v176);
          unint64_t v176 = *((void *)&v245 + 1);
          unint64_t v174 = v245;
        }
        uint64_t v177 = HIBYTE(v36) & 0xF;
        uint64_t v178 = HIBYTE(v176) & 0xF;
        uint64_t v179 = v178 + v177;
        if ((unint64_t)(v178 + v177) <= 0xF)
        {
          if (v178)
          {
            char v180 = 0;
            unint64_t v181 = 0;
            do
            {
              unint64_t v182 = v177 + v181;
              unint64_t v183 = v181 + 1;
              if (v181 >= 8) {
                unint64_t v184 = v176;
              }
              else {
                unint64_t v184 = v174;
              }
              unint64_t v185 = v184 >> (v180 & 0x38);
              char v186 = (8 * v177 + v180) & 0x38;
              uint64_t v187 = (-255 << v186) - 1;
              unint64_t v188 = (unint64_t)v185 << v186;
              unint64_t v189 = v188 | v187 & v36;
              unint64_t v190 = v188 | v187 & v88;
              if (v182 < 8) {
                uint64_t v88 = v190;
              }
              else {
                unint64_t v36 = v189;
              }
              v180 += 8;
              unint64_t v181 = v183;
            }
            while (v178 != v183);
          }
          swift_bridgeObjectRelease(v31);
          swift_bridgeObjectRelease(v30);
          unint64_t v191 = 0xA000000000000000;
          if (!(v88 & 0x8080808080808080 | v36 & 0x80808080808080)) {
            unint64_t v191 = 0xE000000000000000;
          }
          unint64_t v248 = v88;
          unint64_t v249 = v191 & 0xFF00000000000000 | (v179 << 56) | v36 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_204;
        }
        goto LABEL_260;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v30, 4);
      Swift::Int v89 = v88;
      if ((v36 & 0x1000000000000000) == 0) {
        goto LABEL_103;
      }
    }
    Swift::Int v224 = String.UTF8View._foreignCount()();
    int64_t v90 = v224 + v89;
    if (!__OFADD__(v224, v89)) {
      goto LABEL_104;
    }
    goto LABEL_249;
  }
  (*(void (**)(uint64_t, Class *))(v4 + 8))(a1, a2);
  uint64_t v46 = v241;
  uint64_t v45 = v242;
  unint64_t v47 = HIBYTE(v249) & 0xF;
  if ((v249 & 0x2000000000000000) == 0) {
    unint64_t v47 = v248 & 0xFFFFFFFFFFFFLL;
  }
  if (v47 || (v248 & ~v249 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(v241, v242);
    swift_bridgeObjectRelease(v45);
  }
  else
  {
    swift_bridgeObjectRelease(v249);
    unint64_t v248 = v46;
    unint64_t v249 = v45;
  }
  return v248;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AnyHashable()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 48))(v5, v1, v2);
  v4[0] = 0;
  v4[1] = 0xE000000000000000;
  _print_unlocked<A, B>(_:_:)((uint64_t)v5, (uint64_t)v4, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v5);
  return v4[0];
}

unint64_t AnyHashable.debugDescription.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 48))(v11, v1, v2);
  unint64_t v9 = 0;
  unint64_t v10 = 0xE000000000000000;
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)v11, (uint64_t)&v9, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t v3 = v10;
  unint64_t v4 = specialized static String.+ infix(_:_:)(0x6168736148796E41uLL, 0xEC00000028656C62, v9, v10);
  unint64_t v6 = v5;
  swift_bridgeObjectRelease(v3);
  unint64_t v7 = specialized static String.+ infix(_:_:)(v4, v6, 0x29uLL, 0xE100000000000000);
  swift_bridgeObjectRelease(v6);
  return v7;
}

uint64_t AnyHashable.customMirror.getter@<X0>(uint64_t a1@<X8>)
{
  outlined init with copy of AnyHashable((uint64_t)v1, (uint64_t)v8);
  uint64_t v3 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  unint64_t v4 = swift_allocObject(v3, 0x50uLL, 7uLL);
  *((_OWORD *)v4 + 1) = xmmword_18162AC80;
  v4[4] = 0x65756C6176;
  v4[5] = 0xE500000000000000;
  uint64_t v5 = v1[3];
  uint64_t v6 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(v5, v6);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)((uint64_t)v8, (uint64_t)v4, 8, 0, 0, a1);
}

__n128 protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance AnyHashable@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = *(void *)(v1 + 32);
  return result;
}

uint64_t _swift_makeAnyHashableUsingDefaultRepresentation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v10 = type metadata accessor for _ConcreteHashableBox(0, a3, a4, a4);
  uint64_t v11 = &protocol witness table for _ConcreteHashableBox<A>;
  unint64_t v7 = __swift_allocate_boxed_opaque_existential_0Tm(&v9);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(v7, a1, a3);
  return outlined assign with take of AnyHashable(&v9, a2);
}

double _swift_convertToAnyHashableIndirect(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v9 + 16))(v8);
  AnyHashable.init<A>(_:)((uint64_t)v8, a3, a4, (uint64_t)v13);
  double result = *(double *)v13;
  long long v11 = v13[1];
  *(_OWORD *)a2 = v13[0];
  *(_OWORD *)(a2 + 16) = v11;
  *(void *)(a2 + 32) = v14;
  return result;
}

uint64_t _swift_anyHashableDownCastConditionalIndirect(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for Optional(0, a3, a3, a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  long long v11 = (char *)&v25[-1] - v10;
  uint64_t v12 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v25[-1] - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  outlined init with copy of AnyHashable(a1, (uint64_t)v26);
  uint64_t v15 = v27;
  uint64_t v16 = v28;
  __swift_project_boxed_opaque_existential_0Tm(v26, v27);
  if ((*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v16 + 64))(a2, a3, v15, v16))
  {
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v18 = v27;
    uint64_t v19 = v28;
    __swift_project_boxed_opaque_existential_0Tm(v26, v27);
    (*(void (**)(id *__return_ptr, uint64_t, uint64_t))(v19 + 48))(v25, v18, v19);
    v25[0] = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v25, (uint64_t *)&unk_1ECA06310);
    char v20 = swift_dynamicCast(v11, v25, &unk_1ECA06328, a3, 6);
    Swift::Int v21 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 56);
    if (v20)
    {
      uint64_t v17 = 1;
      v21(v11, 0, 1, a3);
      BOOL v22 = *(void (**)(char *, char *, uint64_t))(v12 + 32);
      v22(v14, v11, a3);
      v22(a2, v14, a3);
    }
    else
    {
      v21(v11, 1, 1, a3);
      (*(void (**)(char *, Class *))(v8 + 8))(v11, v7);
      uint64_t v17 = 0;
    }
  }
  outlined destroy of AnyHashable(v26);
  return v17;
}

uint64_t UnsafeRawPointer.load<A>(fromByteOffset:as:)@<X0>(char a1@<W0>, char a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeRawPointer.load<A>(fromByteOffset:as:)(a1, a2, a3, 0x1B8uLL, a4);
}

uint64_t static UInt64.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

BOOL static UInt64.>= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >= a2;
}

BOOL static UInt64.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 < a2;
}

BOOL static UInt64.> infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 < a1;
}

unint64_t static UInt.- infix(_:_:)(unint64_t a1, unint64_t a2)
{
  BOOL v2 = a1 >= a2;
  unint64_t result = a1 - a2;
  if (!v2) {
    __break(1u);
  }
  return result;
}

uint64_t static Int.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

uint64_t FixedWidthInteger.init(littleEndian:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a3, a1, a2);
}

{
  return FixedWidthInteger.init(littleEndian:)(a1, a2, a3);
}

double Hasher.init(_rawSeed:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = a1 ^ 0x736F6D6570736575;
  *(void *)(a3 + 16) = a2 ^ 0x646F72616E646F6DLL;
  *(void *)(a3 + 24) = a1 ^ 0x6C7967656E657261;
  *(void *)(a3 + 32) = a2 ^ 0x7465646279746573;
  double result = 0.0;
  *(_OWORD *)(a3 + 4_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "EmptyCollection can't advance indices", 37, 2, "Swift/EmptyCollection.swift", 27, 2, 0x55uLL, 0) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  return result;
}

uint64_t static Hasher._isDeterministic.getter()
{
  return qword_1EB208F08;
}

uint64_t static Hasher._executionSeed.getter()
{
  return _swift_stdlib_Hashing_parameters;
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt a1)
{
  uint64_t v2 = HIBYTE(*v1) & 7;
  Swift::UInt v3 = *v1 + 0x800000000000000;
  if (v2)
  {
    Swift::UInt v3 = (a1 >> ((-8 * v2) & 0x38)) | ((*v1 & 0xFF00000000000000) + 0x800000000000000);
    Swift::UInt v4 = (a1 << (8 * v2)) | *v1 & 0xFFFFFFFFFFFFFFLL;
  }
  else
  {
    Swift::UInt v4 = a1;
  }
  Swift::UInt v5 = v1[4] ^ v4;
  Swift::UInt v6 = v1[2];
  Swift::UInt v7 = v6 + v1[1];
  Swift::UInt v8 = v7 ^ __ROR8__(v6, 51);
  Swift::UInt v9 = v1[3] + v5;
  uint64_t v10 = __ROR8__(v5, 48);
  Swift::UInt v11 = (v9 ^ v10) + __ROR8__(v7, 32);
  v1[4] = v11 ^ __ROR8__(v9 ^ v10, 43);
  v1[2] = (v9 + v8) ^ __ROR8__(v8, 47);
  v1[3] = __ROR8__(v9 + v8, 32);
  *uint64_t v1 = v3;
  v1[1] = v11 ^ v4;
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt64 a1)
{
  uint64_t v2 = HIBYTE(*v1) & 7;
  Swift::UInt64 v3 = *v1 + 0x800000000000000;
  if (v2)
  {
    Swift::UInt64 v3 = (a1 >> ((-8 * v2) & 0x38)) | ((*v1 & 0xFF00000000000000) + 0x800000000000000);
    Swift::UInt64 v4 = (a1 << (8 * v2)) | *v1 & 0xFFFFFFFFFFFFFFLL;
  }
  else
  {
    Swift::UInt64 v4 = a1;
  }
  Swift::UInt64 v5 = v1[4] ^ v4;
  Swift::UInt64 v6 = v1[2];
  Swift::UInt64 v7 = v6 + v1[1];
  Swift::UInt64 v8 = v7 ^ __ROR8__(v6, 51);
  Swift::UInt64 v9 = v1[3] + v5;
  uint64_t v10 = __ROR8__(v5, 48);
  Swift::UInt64 v11 = (v9 ^ v10) + __ROR8__(v7, 32);
  v1[4] = v11 ^ __ROR8__(v9 ^ v10, 43);
  v1[2] = (v9 + v8) ^ __ROR8__(v8, 47);
  v1[3] = __ROR8__(v9 + v8, 32);
  *uint64_t v1 = v3;
  v1[1] = v11 ^ v4;
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt32 a1)
{
  uint64_t v2 = *v1;
  unint64_t v3 = HIBYTE(*v1) & 7;
  char v4 = 8 * v3;
  if (v3 > 3)
  {
    unint64_t v5 = ((unint64_t)a1 << v4) | v2 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v6 = v2 & 0xFF00000000000000;
    unint64_t v7 = a1 >> ((-8 * v3) & 0x38);
    if (v3 == 4) {
      unint64_t v7 = 0;
    }
    uint64_t v8 = (v6 | v7) + 0x400000000000000;
    unint64_t v9 = v1[4] ^ v5;
    uint64_t v10 = v1[2];
    uint64_t v11 = v10 + v1[1];
    uint64_t v12 = v11 ^ __ROR8__(v10, 51);
    unint64_t v13 = v1[3] + v9;
    unint64_t v14 = v13 ^ __ROR8__(v9, 48);
    unint64_t v15 = v14 + __ROR8__(v11, 32);
    unint64_t v16 = v13 + v12;
    v1[3] = __ROR8__(v16, 32);
    v1[4] = v15 ^ __ROR8__(v14, 43);
    v1[1] = v15 ^ v5;
    v1[2] = v16 ^ __ROR8__(v12, 47);
    *uint64_t v1 = v8;
  }
  else
  {
    *uint64_t v1 = (((unint64_t)a1 << v4) | v2) + 0x400000000000000;
  }
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt16 a1)
{
  uint64_t v2 = *v1;
  unint64_t v3 = HIBYTE(*v1) & 7;
  char v4 = 8 * v3;
  if (v3 > 5)
  {
    unint64_t v5 = ((unint64_t)a1 << v4) | v2 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v6 = v2 & 0xFF00000000000000;
    unint64_t v7 = a1 >> ((-8 * v3) & 0x38);
    if (v3 == 6) {
      unint64_t v7 = 0;
    }
    uint64_t v8 = (v6 | v7) + 0x200000000000000;
    unint64_t v9 = v1[4] ^ v5;
    uint64_t v10 = v1[2];
    uint64_t v11 = v10 + v1[1];
    uint64_t v12 = v11 ^ __ROR8__(v10, 51);
    unint64_t v13 = v1[3] + v9;
    unint64_t v14 = v13 ^ __ROR8__(v9, 48);
    unint64_t v15 = v14 + __ROR8__(v11, 32);
    unint64_t v16 = v13 + v12;
    v1[3] = __ROR8__(v16, 32);
    v1[4] = v15 ^ __ROR8__(v14, 43);
    v1[1] = v15 ^ v5;
    v1[2] = v16 ^ __ROR8__(v12, 47);
    *uint64_t v1 = v8;
  }
  else
  {
    *uint64_t v1 = (((unint64_t)a1 << v4) | v2) + 0x200000000000000;
  }
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt8 a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = HIBYTE(*v1) & 7;
  char v4 = 8 * v3;
  if (v3 == 7)
  {
    unint64_t v5 = v2 & 0xFF00000000000000;
    unint64_t v6 = ((unint64_t)a1 << v4) | v2 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v7 = v1[4] ^ v6;
    uint64_t v8 = v1[2];
    uint64_t v9 = v8 + v1[1];
    uint64_t v10 = v9 ^ __ROR8__(v8, 51);
    unint64_t v11 = v1[3] + v7;
    unint64_t v12 = v11 ^ __ROR8__(v7, 48);
    unint64_t v13 = v12 + __ROR8__(v9, 32);
    unint64_t v14 = v11 + v10;
    v1[3] = __ROR8__(v14, 32);
    v1[4] = v13 ^ __ROR8__(v12, 43);
    v1[1] = v13 ^ v6;
    v1[2] = v14 ^ __ROR8__(v10, 47);
  }
  else
  {
    unint64_t v5 = ((unint64_t)a1 << v4) | v2;
  }
  *uint64_t v1 = v5 + 0x100000000000000;
}

Swift::Void __swiftcall Hasher._combine(bytes:count:)(Swift::UInt64 bytes, Swift::Int count)
{
  unint64_t v3 = *v2;
  uint64_t v4 = HIBYTE(*v2) & 7;
  unint64_t v5 = v4 + count;
  if (__CFADD__(v4, count))
  {
    __break(1u);
    JUMPOUT(0x1812C9834);
  }
  char v6 = 8 * v4;
  if (v5 > 7)
  {
    unint64_t v7 = HIBYTE(v3);
    Swift::UInt64 v8 = (bytes << v6) | v3 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v9 = (v7 + count);
    Swift::UInt64 v10 = bytes >> (-v6 & 0x38);
    if (v5 == 8) {
      Swift::UInt64 v11 = 0;
    }
    else {
      Swift::UInt64 v11 = v10;
    }
    Swift::UInt64 v12 = v11 | (v9 << 56);
    Swift::UInt64 v13 = v2[4] ^ v8;
    Swift::UInt64 v14 = v2[2];
    Swift::UInt64 v15 = v14 + v2[1];
    uint64_t v16 = v15 ^ __ROR8__(v14, 51);
    Swift::UInt64 v17 = v2[3] + v13;
    uint64_t v18 = __ROR8__(v13, 48);
    Swift::UInt64 v19 = (v17 ^ v18) + __ROR8__(v15, 32);
    uint64_t v20 = v19 ^ __ROR8__(v17 ^ v18, 43);
    Swift::UInt64 v21 = v17 + v16;
    unint64_t v2[3] = __ROR8__(v21, 32);
    v2[4] = v20;
    v2[1] = v19 ^ v8;
    v2[2] = v21 ^ __ROR8__(v16, 47);
    *uint64_t v2 = v12;
  }
  else
  {
    *uint64_t v2 = ((bytes << v6) | v3) + (count << 56);
  }
}

uint64_t static Hasher._hash(seed:_:)(uint64_t a1, uint64_t a2)
{
  return specialized static Hasher._hash(seed:_:)(a1, a2);
}

{
  return specialized static Hasher._hash(seed:_:)(a1, a2);
}

uint64_t static UInt64.bitWidth.getter()
{
  return 64;
}

double _hashContainerDefaultMaxLoadFactorInverse.getter()
{
  return 1.33333333;
}

double static Double./ infix(_:_:)(double a1, double a2)
{
  return a1 / a2;
}

uint64_t UnsafeMutableRawPointer.load<A>(fromByteOffset:as:)@<X0>(char a1@<W0>, char a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeRawPointer.load<A>(fromByteOffset:as:)(a1, a2, a3, 0x4F9uLL, a4);
}

uint64_t UnsafeRawPointer.load<A>(fromByteOffset:as:)@<X0>(char a1@<W0>, char a2@<W2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v5 = *(void *)(a3 - 8);
  if ((*(unsigned char *)(v5 + 80) & (a2 + a1)) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, a4, 0);
  }
  char v6 = *(uint64_t (**)(uint64_t))(v5 + 16);

  return v6(a5);
}

uint64_t _HashTable.bucketCount.getter(uint64_t a1, uint64_t a2)
{
  return a2 + 1;
}

char *static ManagedBuffer.create(minimumCapacity:makingHeaderWith:)(uint64_t a1, void (*a2)(void))
{
  uint64_t v5 = *(void *)(v2 + 80);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v12 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  Swift::UInt64 v10 = (char *)swift_allocObject((unint64_t *)v2, ((*(unsigned __int8 *)(*(void *)(*(void *)(v2 + 88) - 8) + 80)+ (unint64_t)*(unsigned int *)(v2 + 48)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(v2 + 88) - 8) + 80))+ *(void *)(*(void *)(*(void *)(v2 + 88) - 8) + 72) * v7, *(unsigned __int8 *)(*(void *)(*(void *)(v2 + 88) - 8) + 80) | (unint64_t)*(unsigned __int16 *)(v2 + 52));
  a2();
  if (v3) {
    swift_release((uint64_t)v10);
  }
  else {
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(&v10[*(void *)(*(void *)v10 + 96)], v9, v5);
  }
  return v10;
}

void __BridgingHashBuffer.deinit()
{
  int64_t v1 = 0;
  uint64_t v3 = *(void **)(v0 + 24);
  uint64_t v2 = *(void *)(v0 + 32);
  if (v2 + 1 < 64) {
    uint64_t v4 = ~(-1 << (v2 + 1));
  }
  else {
    uint64_t v4 = -1;
  }
  unint64_t v5 = v4 & *v3;
  int64_t v6 = (unint64_t)(v2 + 64) >> 6;
  while (1)
  {
    if (v5)
    {
      unint64_t v7 = __clz(__rbit64(v5));
      v5 &= v5 - 1;
      unint64_t v8 = v7 | (v1 << 6);
      goto LABEL_6;
    }
    if (__OFADD__(v1++, 1)) {
      goto LABEL_20;
    }
    if (v1 >= v6)
    {
LABEL_18:
      swift_unknownObjectRelease(*(id *)(v0 + 16));
      return;
    }
    unint64_t v10 = v3[v1];
    if (!v10) {
      break;
    }
LABEL_17:
    unint64_t v5 = (v10 - 1) & v10;
    unint64_t v8 = __clz(__rbit64(v10)) + (v1 << 6);
LABEL_6:
    swift_arrayDestroy(v0 + 40 + 8 * v8, 1, (unint64_t *)qword_1ECA06328);
  }
  int64_t v11 = v1 + 1;
  if (v1 + 1 >= v6) {
    goto LABEL_18;
  }
  unint64_t v10 = v3[v11];
  if (v10)
  {
    ++v1;
    goto LABEL_17;
  }
  while (1)
  {
    int64_t v1 = v11 + 1;
    if (__OFADD__(v11, 1)) {
      break;
    }
    if (v1 >= v6) {
      goto LABEL_18;
    }
    unint64_t v10 = v3[v1];
    ++v11;
    if (v10) {
      goto LABEL_17;
    }
  }
  __break(1u);
LABEL_20:
  __break(1u);
}

uint64_t ManagedBuffer.firstElementAddress.getter()
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)v0 + 88) - 8);
  return v0
       + ((*(unsigned __int8 *)(v1 + 80) + (unint64_t)*(unsigned int *)(*(void *)v0 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v1 + 80));
}

void __BridgingHashBuffer.__deallocating_deinit()
{
  __BridgingHashBuffer.deinit();

  swift_deallocClassInstance(v0);
}

void __BridgingHashBuffer.__allocating_init(_doNotCallMe:)()
{
  uint64_t inited = swift_initStackObject(v0, v2);
  swift_release((uint64_t)inited);
  __break(1u);
}

uint64_t _HashTable.words.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_HashTable.words.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _HashTable.bucketMask.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t _HashTable.wordCount.getter(uint64_t a1, uint64_t a2)
{
  return (unint64_t)(a2 + 64) >> 6;
}

Swift::Double __swiftcall Double.init(_:)(Swift::Int a1)
{
  return (double)a1;
}

double static Double.* infix(_:_:)(double a1, double a2)
{
  return a1 * a2;
}

Swift::Int __swiftcall Int.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (a1 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (a1 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  return (uint64_t)a1;
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(unsigned __int16 a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return 16 - (unsigned __int16)(__clz(a1) - 15);
}

{
  if ((__int16)a1 <= 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return 16 - (unsigned __int16)(__clz(a1) - 15);
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(unsigned int a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return 32 - (__clz(a1) + 1);
}

unint64_t specialized FixedWidthInteger._binaryLogarithm()(unint64_t a1, unint64_t a2)
{
  if (!(a2 | a1)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v2 = v3;
  }
  return 127 - v2;
}

{
  unint64_t v2;
  unint64_t v3;

  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v2 = v3;
  }
  return 127 - v2;
}

{
  unint64_t v2;
  unint64_t v3;

  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v2 = v3;
  }
  return 127 - v2;
}

unint64_t specialized FixedWidthInteger._binaryLogarithm()(unint64_t a1, int64_t a2)
{
  BOOL v2 = a1 != 0;
  if (a2) {
    BOOL v2 = a2 > 0;
  }
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  unint64_t v3 = __clz(a2);
  unint64_t v4 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v3 = v4;
  }
  return 127 - v3;
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(unsigned __int8 a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return 8 - (__clz(a1) - 23);
}

{
  if ((char)a1 <= 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return 8 - (__clz(a1) - 23);
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(signed int a1)
{
  if (a1 <= 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return 32 - (__clz(a1) + 1);
}

Swift::Int __swiftcall FixedWidthInteger._binaryLogarithm()()
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v23 = *(void *)(v1 + 8);
  uint64_t v6 = *(void *)(*(void *)(v23 + 24) + 16);
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(0, (int **)v6, v0, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v22 - v9;
  uint64_t v11 = *(void *)(v5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  Swift::UInt64 v14 = (char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v22 - v15;
  Swift::UInt64 v17 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v22 = v3;
  v17((char *)&v22 - v15, v3, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v10, v5, v6);
  LOBYTE(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v23 + 32)
                                                                                                 + 8)
                                                                                     + 40))(v16, v14, v5);
  Swift::UInt64 v19 = *(void (**)(char *, uint64_t))(v11 + 8);
  v19(v14, v5);
  if ((AssociatedTypeWitness & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  v19(v16, v5);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 56))(v5, v4);
  return v20 + ~(*(uint64_t (**)(uint64_t, uint64_t))(v4 + 152))(v5, v4);
}

uint64_t _HashTable.Bucket.offset.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_HashTable.Bucket.offset.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.Bucket.init(word:bit:)(Swift::Int word, Swift::Int bit)
{
  return (Swift::_HashTable::Bucket)(bit + (word << 6));
}

unint64_t _HashTable.Bucket.word.getter(unint64_t a1)
{
  return a1 >> 6;
}

uint64_t _HashTable.Bucket.bit.getter(char a1)
{
  return a1 & 0x3F;
}

BOOL static _HashTable.Bucket.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _HashTable.Bucket(void *a1, void *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _HashTable.Bucket(void *a1, void *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _HashTable.Bucket(void *a1, void *a2)
{
  return *a2 < *a1;
}

uint64_t _HashTable.Index.age.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _HashTable.Index(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xD5uLL, 0);
  }
  return *(void *)a1 == *(void *)a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _HashTable.Index(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xE2uLL, 0);
  }
  return *(void *)a1 < *(void *)a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _HashTable.Index(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a1 + 8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xE2uLL, 0);
  }
  return *(void *)a2 >= *(void *)a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _HashTable.Index(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xE2uLL, 0);
  }
  return *(void *)a1 >= *(void *)a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _HashTable.Index(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a1 + 8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't compare indices belonging to different collections", 56, 2, "Swift/HashTable.swift", 21, 2, 0xE2uLL, 0);
  }
  return *(void *)a2 < *(void *)a1;
}

uint64_t _HashTable.Iterator.wordIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t (*_HashTable.Iterator.wordIndex.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _HashTable.Iterator.word.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t (*_HashTable.Iterator.word.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for IteratorProtocol.next() in conformance _HashTable.Iterator(uint64_t a1@<X8>)
{
  unint64_t v2 = v1[3];
  if (v2)
  {
    char v3 = 0;
    v1[3] = (v2 - 1) & v2;
    unint64_t v4 = __clz(__rbit64(v2)) | (v1[2] << 6);
LABEL_14:
    *(void *)a1 = v4;
    *(unsigned char *)(a1 + 8) = v3;
    return;
  }
  uint64_t v5 = v1[2];
  int64_t v6 = v5 + 1;
  if (!__OFADD__(v5, 1))
  {
    int64_t v7 = (unint64_t)(v1[1] + 64) >> 6;
    if (v6 < v7)
    {
      v1[2] = v6;
      uint64_t v8 = *v1;
      unint64_t v9 = *(void *)(*v1 + 8 * v6);
      v1[3] = v9;
      if (v9)
      {
LABEL_6:
        char v3 = 0;
        v1[3] = (v9 - 1) & v9;
        unint64_t v4 = __clz(__rbit64(v9)) + (v6 << 6);
        goto LABEL_14;
      }
      int64_t v6 = v5 + 2;
      if (v5 + 2 < v7)
      {
        v1[2] = v6;
        unint64_t v9 = *(void *)(v8 + 8 * v6);
        v1[3] = v9;
        if (v9) {
          goto LABEL_6;
        }
        uint64_t v10 = v5 + 3;
        while (v7 != v10)
        {
          v1[2] = v10;
          unint64_t v9 = *(void *)(v8 + 8 * v10);
          v1[3] = v9;
          ++v10;
          if (v9)
          {
            int64_t v6 = v10 - 1;
            goto LABEL_6;
          }
        }
      }
    }
    unint64_t v4 = 0;
    char v3 = 1;
    goto LABEL_14;
  }
  __break(1u);
}

void protocol witness for Sequence.makeIterator() in conformance _HashTable(void *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2 + 1 < 64) {
    uint64_t v3 = ~(-1 << (v2 + 1));
  }
  else {
    uint64_t v3 = -1;
  }
  uint64_t v4 = v3 & **(void **)v1;
  *a1 = *(void *)v1;
  a1[1] = v2;
  a1[2] = 0;
  a1[3] = v4;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance _HashTable()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*(void **)v0, *(void *)(v0 + 8));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _HashTable(void *a1, unint64_t *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *(void **)v3, *(void *)(v3 + 8));
}

Swift::Bool __swiftcall _HashTable.isValid(_:)(Swift::_HashTable::Bucket a1)
{
  return a1.offset >= 0 && v1 + 1 > a1.offset;
}

Swift::Void __swiftcall _HashTable.checkOccupied(_:)(Swift::_HashTable::Bucket a1)
{
  if (a1.offset < 0
    || v2 + 1 <= a1.offset
    || ((*(void *)(v1 + (((unint64_t)a1.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) >> SLOBYTE(a1.offset)) & 1) == 0)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Collection elements using an invalid Index", 63, 2, "Swift/HashTable.swift", 21, 2, 0x130uLL, 0);
  }
}

Swift::_HashTable::Bucket __swiftcall _HashTable._firstOccupiedBucket(fromWord:)(Swift::Int fromWord)
{
  result.Swift::Int offset = v2 + 1;
  Swift::Int v5 = (unint64_t)(v2 + 64) >> 6;
  if (v5 > fromWord)
  {
    unint64_t v6 = *(void *)(v1 + 8 * fromWord);
    if (v6)
    {
      Swift::Int v7 = fromWord;
      return (Swift::_HashTable::Bucket)(__clz(__rbit64(v6)) + (v7 << 6));
    }
    else
    {
      Swift::Int v8 = v5 - 1;
      while (v8 != fromWord)
      {
        Swift::Int v7 = fromWord + 1;
        unint64_t v6 = *(void *)(v1 + 8 + 8 * fromWord++);
        if (v6) {
          return (Swift::_HashTable::Bucket)(__clz(__rbit64(v6)) + (v7 << 6));
        }
      }
    }
  }
  return result;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.previousHole(before:)(Swift::_HashTable::Bucket before)
{
  int64_t v3 = (unint64_t)before.offset >> 6;
  uint64_t v4 = *(void *)(v1 + 8 * ((unint64_t)before.offset >> 6)) | (-1 << SLOBYTE(before.offset));
  if (v4 == -1)
  {
    char v6 = 0;
    do
    {
      if (--v3 < 0 && (v6 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Hash table has no holes", 23, 2, "Swift/HashTable.swift", 21, 2, 0x17DuLL, 0);
      }
      v6 |= v3 < 0;
      if (v3 < 0) {
        int64_t v3 = ((unint64_t)(v2 + 64) >> 6) - 1;
      }
      uint64_t v7 = *(void *)(v1 + 8 * v3);
    }
    while (v7 == -1);
    unint64_t v5 = (v3 << 6) - __clz(~v7);
  }
  else
  {
    unint64_t v5 = (before.offset & 0xFFFFFFFFFFFFFFC0) - __clz(~v4);
  }
  return (Swift::_HashTable::Bucket)(v5 + 63);
}

Swift::_HashTable::Bucket __swiftcall _HashTable.nextHole(atOrAfter:)(Swift::_HashTable::Bucket atOrAfter)
{
  unint64_t v3 = (unint64_t)atOrAfter.offset >> 6;
  unint64_t v4 = (-1 << SLOBYTE(atOrAfter.offset)) & ~*(void *)(v1 + 8 * ((unint64_t)atOrAfter.offset >> 6));
  if (v4) {
    return (Swift::_HashTable::Bucket)(__clz(__rbit64(v4)) | atOrAfter.offset & 0xFFFFFFFFFFFFFFC0);
  }
  unint64_t v6 = (unint64_t)(v2 + 64) >> 6;
  do
  {
    if (++v3 == v6 && (v4 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Hash table has no holes", 23, 2, "Swift/HashTable.swift", 21, 2, 0x198uLL, 0);
    }
    BOOL v7 = v3 == v6;
    if (v3 == v6) {
      unint64_t v3 = 0;
    }
    LOBYTE(v4) = v7 | v4;
    uint64_t v8 = *(void *)(v1 + 8 * v3);
  }
  while (v8 == -1);
  return (Swift::_HashTable::Bucket)(__clz(__rbit64(~v8)) + (v3 << 6));
}

uint64_t static FixedWidthInteger.&+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  BOOL v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v8 + 80))(v7);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v7, a3);
}

char *_HashTable.copyContents(of:)(char *__src, int a2, char *__dst, uint64_t a4)
{
  unint64_t v4 = (unint64_t)(a4 + 64) >> 6;
  if (__dst != __src || &__src[8 * v4] <= __dst) {
    return (char *)memmove(__dst, __src, 8 * v4);
  }
  return __src;
}

char *specialized UnsafeMutablePointer.moveInitialize(from:count:)(char *__src, size_t __len, char *__dst, const char *a4, uint64_t a5, unint64_t a6)
{
  if ((__len & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a4, a5, 2, "Swift/UnsafePointer.swift", 25, 2, a6, 0);
  }
  if (__dst != __src || &__src[__len] <= __dst)
  {
    return (char *)memmove(__dst, __src, __len);
  }
  return __src;
}

char *UnsafeMutablePointer.assign(from:count:)(char *__src, uint64_t a2, char *__dst, unint64_t *a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.update with negative count", 47, 2, "Swift/UnsafePointer.swift", 25, 2, 0x3DEuLL, 0);
  }
  if (__dst < __src || &__src[*(void *)(*(a4 - 1) + 72) * a2] <= __dst)
  {
    return swift_arrayAssignWithCopyFrontToBack(__dst, __src, a2, a4);
  }
  else if (__dst != __src)
  {
    return swift_arrayAssignWithCopyBackToFront(__dst, __src, a2, (uint64_t)a4);
  }
  return __src;
}

Swift::Int _HashTable.delete<A>(at:with:)(Swift::_HashTable::Bucket before, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  Swift::Int offset = before.offset;
  unint64_t v8 = (before.offset + 1) & a4;
  if ((*(void *)(a3 + 8 * (v8 >> 6)) & (1 << v8)) != 0)
  {
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(a3 + 8 * (v8 >> 6)) & (1 << v8)) != 0)
    {
      Swift::Int v12 = (before.offset + 1) & a4;
      uint64_t v13 = *(uint64_t (**)(unint64_t, uint64_t, uint64_t))(a6 + 8);
      for (before.Swift::Int offset = v13(v8, a5, a6); ; before.Swift::Int offset = v13(v8, a5, a6))
      {
        Swift::Int v14 = before.offset & a4;
        if (offset >= v12)
        {
          if (v14 >= v12 && offset >= v14)
          {
LABEL_4:
            before.Swift::Int offset = (*(uint64_t (**)(unint64_t, Swift::Int, uint64_t, uint64_t))(a6 + 16))(v8, offset, a5, a6);
            Swift::Int offset = v8;
          }
        }
        else if (v14 >= v12 || offset >= v14)
        {
          goto LABEL_4;
        }
        unint64_t v8 = (v8 + 1) & a4;
        if (((*(void *)(a3 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v8) & 1) == 0) {
          break;
        }
      }
    }
    Swift::UInt64 v17 = (uint64_t *)(a3 + 8 * ((unint64_t)offset >> 6));
    uint64_t v18 = *v17;
    uint64_t v19 = (-1 << offset) - 1;
  }
  else
  {
    Swift::UInt64 v17 = (uint64_t *)(a3 + 8 * ((unint64_t)before.offset >> 6));
    uint64_t v19 = *v17;
    uint64_t v18 = (-1 << SLOBYTE(before.offset)) - 1;
  }
  *Swift::UInt64 v17 = v19 & v18;
  return before.offset;
}

uint64_t Identifiable<>.id.getter()
{
  return v0;
}

uint64_t (*DefaultIndices._elements.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultIndices._startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter(a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index, a2);
}

uint64_t DefaultIndices._startIndex.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
}

uint64_t (*DefaultIndices._startIndex.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultIndices._endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return DefaultIndices._endIndex.getter(a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index, a2);
}

uint64_t DefaultIndices._endIndex.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 40);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40);

  return v6(v4, a1, AssociatedTypeWitness);
}

uint64_t (*DefaultIndices._endIndex.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultIndices.init(_elements:startIndex:endIndex:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, uint64_t a6@<X8>)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(a6, a1, a4);
  Swift::Int v12 = type metadata accessor for DefaultIndices(0, a4, (uint64_t)a5, v11);
  uint64_t v13 = a6 + *((int *)v12 + 9);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  Swift::UInt64 v17 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32);
  ((void (*)(void *__return_ptr, uint64_t, uint64_t, const char *))v17)((void *)AssociatedTypeWitness - 1, v13, a2, AssociatedTypeWitness);
  uint64_t v15 = a6 + *((int *)v12 + 10);

  return v17(v15, a3, AssociatedTypeWitness);
}

uint64_t DiscontiguousSlice.Index.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v6(a2, v4, AssociatedTypeWitness);
}

uint64_t DefaultIndices.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 40);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v6(a2, v4, AssociatedTypeWitness);
}

uint64_t DefaultIndices.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v6(a3, a1, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  int **v10;
  const char *AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v17)(uint64_t, uint64_t, const char *);
  uint64_t vars8;

  uint64_t v4 = v3;
  unint64_t v8 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(a3, v4, v8);
  unint64_t v9 = a3 + *(int *)(a2 + 36);
  uint64_t v10 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  Swift::UInt64 v17 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);
  ((void (*)(void *__return_ptr, uint64_t, uint64_t, const char *))v17)((void *)AssociatedTypeWitness - 1, v9, a1, AssociatedTypeWitness);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  Swift::Int v14 = a1
      + *((int *)type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13)
        + 9);
  uint64_t v15 = a3 + *(int *)(a2 + 40);

  return v17(v15, v14, AssociatedTypeWitness);
}

uint64_t DefaultIndices.index(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 184))(a1, *(void *)(a2 + 16));
}

uint64_t DefaultIndices.formIndex(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 192))(a1, *(void *)(a2 + 16));
}

uint64_t DefaultIndices.indices.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a2, v2, a1);
}

uint64_t DefaultIndices.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 136))(a1, a2, *(void *)(a3 + 16));
}

uint64_t DefaultIndices.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a4 + 24) + 144))(a1, a2, a3, *(void *)(a4 + 16));
}

uint64_t DefaultIndices.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 152))(a1, a2, *(void *)(a3 + 16));
}

uint64_t (*protocol witness for Collection.subscript.read in conformance DefaultIndices<A>(const char ***a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = (const char **)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (const char *)DefaultIndices.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*DefaultIndices.subscript.read(const char **a1, uint64_t a2, uint64_t a3))()
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  *a1 = AssociatedTypeWitness;
  uint64_t v5 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v6 = v5;
  a1[1] = (const char *)v5;
  a1[2] = (const char *)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v6 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance DefaultIndices<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance DefaultIndices<A>(a1, (void (*)(uint64_t))DefaultIndices.startIndex.getter, protocol conformance descriptor for DefaultIndices<A>, a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance DefaultIndices<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DefaultIndices<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance DefaultIndices<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for DefaultIndices<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> DefaultIndices<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DefaultIndices<>.index(before:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> DefaultIndices<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DefaultIndices<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8));
}

Swift::String_optional __swiftcall readLine(strippingNewline:)(Swift::Bool strippingNewline)
{
  __linep[1] = *(char **)MEMORY[0x1E4F143B8];
  __linep[0] = 0;
  uint64_t Line_stdin = swift_stdlib_readLine_stdin(__linep);
  unint64_t v3 = (uint8x16_t *)__linep[0];
  if (Line_stdin >= 1)
  {
    if (!__linep[0]) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer has a nil start and nonzero count", 53, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x541uLL, 0);
    }
    int64_t v4 = Line_stdin;
    int64_t v5 = validateUTF8(_:)((uint64_t *)__linep[0], Line_stdin);
    if (v7) {
      uint64_t v8 = repairUTF8(_:firstKnownBrokenRange:)(v3->i8, v4, v5, v6);
    }
    else {
      uint64_t v8 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, v4, v5 & 1);
    }
    uint64_t v12 = v8;
    unint64_t v13 = v9;
    uint64_t v27 = v8;
    unint64_t v28 = v9;
    if (!strippingNewline) {
      goto LABEL_26;
    }
    swift_bridgeObjectRetain(v9);
    uint64_t v14 = specialized BidirectionalCollection.last.getter(v12, v13);
    if (v15)
    {
      uint64_t v16 = v15;
      if (v14 == 10 && v15 == 0xE100000000000000)
      {
        swift_bridgeObjectRelease(v13);
        swift_bridgeObjectRelease(0xE100000000000000);
LABEL_24:
        specialized RangeReplaceableCollection<>.removeLast()();
        uint64_t v21 = v23;
        goto LABEL_25;
      }
      if ((~v15 & 0x6000000000000000) != 0)
      {
        char v17 = _stringCompareInternal(_:_:expecting:)(v14, v15, 10, 0xE100000000000000, 0);
        swift_bridgeObjectRelease(v16);
        if (v17)
        {
          swift_bridgeObjectRelease(v13);
          goto LABEL_24;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v15);
      }
    }
    uint64_t v18 = specialized BidirectionalCollection.last.getter(v12, v13);
    unint64_t v20 = v19;
    swift_bridgeObjectRelease(v13);
    if (v20)
    {
      if (v18 == 2573 && v20 == 0xE200000000000000)
      {
        swift_bridgeObjectRelease(0xE200000000000000);
        swift_bridgeObjectRelease(0xE200000000000000);
        goto LABEL_24;
      }
      if ((~v20 & 0x6000000000000000) != 0)
      {
        char v22 = _stringCompareInternal(_:_:expecting:)(v18, v20, 2573, 0xE200000000000000, 0);
        swift_bridgeObjectRelease(v20);
        swift_bridgeObjectRelease(0xE200000000000000);
        if ((v22 & 1) == 0)
        {
LABEL_26:
          uint64_t v10 = v27;
          uint64_t v11 = (void *)v28;
          _swift_stdlib_free(v3);
          goto LABEL_27;
        }
        goto LABEL_24;
      }
      swift_bridgeObjectRelease(v20);
    }
    uint64_t v21 = 0xE200000000000000;
LABEL_25:
    swift_bridgeObjectRelease(v21);
    goto LABEL_26;
  }
  _swift_stdlib_free(__linep[0]);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
LABEL_27:
  uint64_t v24 = v10;
  uint64_t v25 = v11;
  result.value._unint64_t object = v25;
  result.value._uint64_t countAndFlagsBits = v24;
  return result;
}