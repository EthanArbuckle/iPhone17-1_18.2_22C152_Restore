uint64_t specialized RangeReplaceableCollection<>.removeLast()()
{
  uint64_t *v0;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  Swift::String::Index v5;
  Swift::UInt64 rawBits;
  char *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  int v14;
  Swift::UInt64 v15;
  void v17[2];
  uint64_t vars8;

  v2 = *v0;
  v1 = v0[1];
  v3 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000) == 0) {
    v3 = *v0 & 0xFFFFFFFFFFFFLL;
  }
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove last element from an empty collection", 50, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x363uLL, 0);
  }
  v4 = 7;
  if (((v1 >> 60) & ((v2 & 0x800000000000000) == 0)) != 0) {
    v4 = 11;
  }
  v5._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(v4 | (v3 << 16)))._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  rawBits = v5._rawBits;
  if ((v1 & 0x1000000000000000) != 0)
  {
    v15 = String.UnicodeScalarView._foreignIndex(before:)(v5)._rawBits;
  }
  else
  {
    if ((v1 & 0x2000000000000000) != 0)
    {
      v17[0] = v2;
      v17[1] = v1 & 0xFFFFFFFFFFFFFFLL;
      v11 = (char *)v17 + (v5._rawBits >> 16);
      if ((*(v11 - 1) & 0xC0) == 0x80)
      {
        v12 = 0;
        v13 = v11 - 2;
        do
          v14 = v13[v12--] & 0xC0;
        while (v14 == 128);
        v10 = 1 - v12;
      }
      else
      {
        v10 = 1;
      }
    }
    else
    {
      if ((v2 & 0x1000000000000000) != 0) {
        v7 = (char *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        v7 = (char *)_StringObject.sharedUTF8.getter(v2, v1);
      }
      v8 = 0;
      do
        v9 = v7[(rawBits >> 16) - 1 + v8--] & 0xC0;
      while (v9 == 128);
      v10 = -v8;
    }
    v15 = (rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
  }

  return specialized RangeReplaceableCollection.remove(at:)(v15);
}

{
  uint64_t v0;
  unint64_t v1;

  if (!*(void *)(*(void *)v0 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove last element from an empty collection", 50, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x363uLL, 0);
  }
  v1 = specialized Array._customRemoveLast()();
  if ((v1 & 0x1000000000000) != 0) {
    v1 = specialized Array.remove(at:)(*(void *)(*(void *)v0 + 16) - 1);
  }
  return v1 & 0xFFFFFFFFFFFFLL;
}

{
  void *v0;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  Swift::String::Index v4;
  uint64_t vars8;

  v1 = v0[1];
  v2 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000) == 0) {
    v2 = *v0 & 0xFFFFFFFFFFFFLL;
  }
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove last element from an empty collection", 50, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x363uLL, 0);
  }
  v3 = 7;
  if (((v1 >> 60) & ((*v0 & 0x800000000000000) == 0)) != 0) {
    v3 = 11;
  }
  v4._rawBits = String.index(before:)((Swift::String::Index)(v3 | (v2 << 16)))._rawBits;

  return String.remove(at:)(v4)._countAndFlagsBits;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  void *v6;
  void *v7;
  id v8;
  uint64_t vars8;

  v1 = *v0;
  if (!((unint64_t)*v0 >> 62))
  {
    if (*(void *)((v1 & 0xFFFFFFFFFFFFFF8) + 0x10)) {
      goto LABEL_3;
    }
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove last element from an empty collection", 50, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x363uLL, 0);
  }
  if (v1 < 0) {
    v6 = (void *)*v0;
  }
  else {
    v6 = (void *)(v1 & 0xFFFFFFFFFFFFFF8);
  }
  if (!objc_msgSend(v6, sel_count)) {
    goto LABEL_13;
  }
LABEL_3:
  result = specialized Array._customRemoveLast()();
  if (result) {
    return result;
  }
  v3 = *v0;
  if ((unint64_t)*v0 >> 62)
  {
    if (v3 < 0) {
      v7 = (void *)*v0;
    }
    else {
      v7 = (void *)(v3 & 0xFFFFFFFFFFFFFF8);
    }
    v8 = [v7 count];
    v5 = __OFSUB__(v8, 1);
    result = (uint64_t)v8 - 1;
    if (!v5) {
      goto LABEL_6;
    }
LABEL_19:
    __break(1u);
    return result;
  }
  v4 = *(void *)((v3 & 0xFFFFFFFFFFFFFF8) + 0x10);
  v5 = __OFSUB__(v4, 1);
  result = v4 - 1;
  if (v5) {
    goto LABEL_19;
  }
LABEL_6:

  return specialized Array.remove(at:)(result);
}

uint64_t RangeReplaceableCollection<>.removeLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return RangeReplaceableCollection<>.removeLast()(a1, a2, a3, 0x363uLL, a4);
}

{
  return RangeReplaceableCollection<>.removeLast()(a1, a2, a3, 0x3AEuLL, a4);
}

uint64_t _parseIntegerDigits<A>(ascii:radix:isNegative:)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int v78 = a4;
  uint64_t v84 = a7;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, (uint64_t)&type metadata for Bool, 0, 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  v77 = (char *)v68 - v13;
  v81 = (uint64_t (**)(void, void, void, void))a6;
  uint64_t v14 = *(void *)(a6 + 8);
  uint64_t v15 = *(void *)(*(void *)(v14 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v15, a5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v17 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v19 = (char *)v68 - v18;
  uint64_t v86 = *(void *)(a5 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  v76 = (char *)v68 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v82 = (char *)v68 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v25 = MEMORY[0x1F4188790](v24);
  v30 = (char *)v68 - v29;
  if (!a2)
  {
    v66 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v86 + 56);
    uint64_t v67 = v84;
    return v66(v67, 1, 1, a5);
  }
  int v31 = a3 + 48;
  int v32 = a3 + 55;
  int v33 = a3 + 87;
  if (a3 <= 10) {
    int v33 = 97;
  }
  int v69 = v33;
  if (a3 <= 10) {
    int v32 = 65;
  }
  int v70 = v32;
  uint64_t v90 = a3;
  if (a3 > 10) {
    int v31 = 58;
  }
  int v72 = v31;
  v85 = a1;
  v34 = *(void (**)(char *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v14 + 96);
  uint64_t v35 = v25;
  uint64_t v79 = v28;
  unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
  v83 = v30;
  uint64_t v80 = v14;
  v74 = v34;
  uint64_t v75 = v14 + 96;
  v34((char *)&v90, &type metadata for Int, v36, a5, v14);
  uint64_t v37 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v15, a5, v35, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v35, AssociatedConformanceWitness);
  uint64_t v39 = v79;
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 24))(v19, a5, v15);
  uint64_t v43 = v84;
  v42 = v85;
  v44 = v81;
  uint64_t v45 = v39;
  if (!v85)
  {
LABEL_25:
    (*(void (**)(char *, uint64_t))(v86 + 8))(v83, a5);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v86 + 32))(v43, v45, a5);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v86 + 56))(v43, 0, 1, a5);
  }
  uint64_t v46 = v86;
  v47 = (void (**)(uint64_t, uint64_t))(v86 + 8);
  v48 = (void (**)(uint64_t, char *, uint64_t))(v86 + 32);
  v68[1] = v81 + 11;
  v68[2] = v81 + 10;
  v68[0] = v81 + 12;
  while (1)
  {
    unsigned int v49 = *v42;
    if (v49 >= 0x30 && v49 < v72)
    {
      v85 = v42;
      uint64_t v71 = v37;
      char v87 = v49 - 48;
      unint64_t v50 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v46, v40, v41);
      v51 = &v87;
      uint64_t v52 = a5;
      uint64_t v53 = v80;
      goto LABEL_20;
    }
    uint64_t v54 = v80;
    if (v49 < 0x41 || v49 >= v70) {
      break;
    }
    v85 = v42;
    uint64_t v71 = v37;
    char v88 = v49 - 55;
    unint64_t v50 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v46, v40, v41);
    v51 = &v88;
LABEL_19:
    uint64_t v52 = a5;
    uint64_t v53 = v54;
LABEL_20:
    v74(v51, &type metadata for UInt8, v50, v52, v53);
    v55 = v76;
    int v73 = ((uint64_t (**)(char *, char *, uint64_t, void))v44)[12](v76, v83, a5, v44);
    v56 = *v47;
    (*v47)(v45, a5);
    v57 = *v48;
    (*v48)(v45, v55, a5);
    v58 = v82;
    if (v78) {
      int v59 = ((uint64_t (**)(char *, char *, uint64_t, void))v44)[11](v55, v82, a5, v44);
    }
    else {
      int v59 = ((uint64_t (**)(char *, char *, uint64_t, void))v44)[10](v55, v82, a5, v44);
    }
    int v60 = v59;
    v56((uint64_t)v58, a5);
    v56(v45, a5);
    v61 = v77;
    v57((uint64_t)v77, v55, a5);
    uint64_t v46 = ((uint64_t (*)(uint64_t, char *, uint64_t))v57)(v45, v61, a5);
    if ((v73 | v60))
    {
      v56(v45, a5);
      v56((uint64_t)v83, a5);
      v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v86 + 56);
      uint64_t v64 = v84;
      return v63(v64, 1, 1, a5);
    }
    uint64_t v43 = v84;
    v42 = v85 + 1;
    uint64_t v37 = v71 - 1;
    v44 = v81;
    if (v71 == 1) {
      goto LABEL_25;
    }
  }
  if (v49 >= 0x61 && v49 < v69)
  {
    v85 = v42;
    uint64_t v71 = v37;
    char v89 = v49 - 87;
    unint64_t v50 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v46, v40, v41);
    v51 = &v89;
    goto LABEL_19;
  }
  v65 = *(void (**)(uint64_t, uint64_t))(v86 + 8);
  v65(v45, a5);
  v65((uint64_t)v83, a5);
  v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v86 + 56);
  uint64_t v64 = v43;
  return v63(v64, 1, 1, a5);
}

uint64_t UnsafeBufferPointer.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 16) - 8);
    if (v4 == v2[1])
    {
      v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 + 56);
      uint64_t v7 = a2;
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t *v2 = v4 + *(void *)(v5 + 72);
      uint64_t v10 = v5;
      (*(void (**)(uint64_t))(v5 + 16))(a2);
      v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
      uint64_t v7 = a2;
      uint64_t v8 = 0;
    }
  }
  else
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 56);
    uint64_t v7 = a2;
    uint64_t v8 = 1;
  }

  return v6(v7, v8, 1);
}

BOOL static UInt8.>= infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 >= a2;
}

uint64_t specialized UnsafeBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0 || a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid slice", 13, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x76EuLL, 0);
  }
  uint64_t v4 = a3 + a1;
  if (!a3) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = a2 - a1;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  if (v5 && !v4) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer has a nil start and nonzero count", 53, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x541uLL, 0);
  }
  return v4;
}

uint64_t UnsafeBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  v9 = (unint64_t *)type metadata accessor for UnsafeBufferPointer(255, a5, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, v9, v10);
  uint64_t v13 = type metadata accessor for Slice(0, (uint64_t)v9, WitnessTable, v12);
  uint64_t v14 = (uint64_t)v13[2];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v13[3], v14, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v16 = *(void (**)(uint64_t *, uint64_t *, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);
  v16(v21, &v23, AssociatedTypeWitness);
  if ((v21[0] & 0x8000000000000000) != 0) {
    goto LABEL_10;
  }
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  v16(&v22, (uint64_t *)((char *)&v23 + *((int *)v13 + 9)), AssociatedTypeWitness);
  uint64_t v17 = v22;
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  (*(void (**)(void *, char *, uint64_t))(*(void *)(v14 - 8) + 16))(v21, (char *)&v23 + *((int *)v13 + 10), v14);
  if (v21[1] < v17) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid slice", 13, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x76EuLL, 0);
  if (a3)
  {
    uint64_t result = a3 + *(void *)(*(void *)(a5 - 8) + 72) * a1;
    BOOL v19 = a2 == a1;
    if (a2 - a1 >= 0) {
      goto LABEL_5;
    }
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t result = 0;
  BOOL v19 = a2 == a1;
  if (a2 - a1 < 0) {
    goto LABEL_9;
  }
LABEL_5:
  if (!v19 && !result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer has a nil start and nonzero count", 53, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x541uLL, 0);
  }
  return result;
}

{
  uint64_t result;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;

  if (a3)
  {
    uint64_t result = a3 + *(void *)(*(void *)(a5 - 8) + 72) * a1;
    uint64_t v8 = a2 - a1;
    uint64_t v7 = v8 == 0;
    if (v8 >= 0) {
      goto LABEL_3;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t result = 0;
  v9 = a2 - a1;
  uint64_t v7 = v9 == 0;
  if (v9 < 0) {
    goto LABEL_7;
  }
LABEL_3:
  if (!v7 && !result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer has a nil start and nonzero count", 53, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x541uLL, 0);
  }
  return result;
}

uint64_t specialized _parseInteger<A, B>(ascii:radix:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t (*a4)(void *, uint64_t, uint64_t))
{
  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2);
  if ((v6 & 0x1000000000000000) == 0)
  {
    if ((v6 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }
  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }
LABEL_7:
  __int16 v12 = a4(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12 & 0x1FF;
}

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  void v14[2];

  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2);
  if ((v6 & 0x1000000000000000) == 0)
  {
    if ((v6 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }
  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }
LABEL_7:
  __int16 v12 = a4(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12 & 0x1FFFF;
}

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  void v14[2];

  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2);
  if ((v6 & 0x1000000000000000) == 0)
  {
    if ((v6 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }
  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }
LABEL_7:
  __int16 v12 = a4(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12 | ((HIDWORD(v12) & 1) << 32);
}

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void v14[2];

  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2);
  if ((v6 & 0x1000000000000000) == 0)
  {
    if ((v6 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }
  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }
LABEL_7:
  __int16 v12 = a4(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12;
}

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void v14[2];

  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2);
  if ((v6 & 0x1000000000000000) == 0)
  {
    if ((v6 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }
  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }
LABEL_7:
  __int16 v12 = a4(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12;
}

void specialized _parseInteger<A, B>(ascii:radix:)(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  unint64_t v9 = a2;
  swift_bridgeObjectRetain(a2);
  if ((v9 & 0x1000000000000000) != 0)
  {
    a1 = specialized static String._copying(_:)(a1, v9);
    unint64_t v15 = v14;
    swift_bridgeObjectRelease(v9);
    unint64_t v9 = v15;
    if ((v15 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    v16[0] = a1;
    v16[1] = v9 & 0xFFFFFFFFFFFFFFLL;
    specialized closure #1 in _parseInteger<A, B>(ascii:radix:)((unsigned __int8 *)v16, HIBYTE(v9) & 0xF, a3, a4, a5, a6);
    swift_bridgeObjectRelease(v9);
    return;
  }
  if ((v9 & 0x2000000000000000) != 0) {
    goto LABEL_9;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000) != 0)
  {
    __int16 v12 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = a1 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    __int16 v12 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, v9);
  }
  specialized closure #1 in _parseInteger<A, B>(ascii:radix:)(v12, v13, a3, a4, a5, a6);

  swift_bridgeObjectRelease(v9);
}

void _parseInteger<A, B>(ascii:radix:)(uint64_t a1@<X0>, uint64_t a2@<X1>, Class *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  MEMORY[0x1F4188790](a1);
  unint64_t v14 = (void *)((char *)v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(Swift::UInt64 *))(v15 + 16))(v14);
  Swift::UInt64 v16 = String.init<A>(_:)(v14, a3, *(void *)(a5 + 40));
  uint64_t v18 = v16;
  unint64_t v19 = v17;
  if ((v17 & 0x1000000000000000) != 0)
  {
    uint64_t v18 = specialized static String._copying(_:)(v16, v17);
    unint64_t v23 = v22;
    swift_bridgeObjectRelease(v19);
    unint64_t v19 = v23;
    if ((v23 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v24 = HIBYTE(v19) & 0xF;
    v39[0] = v18;
    v39[1] = v19 & 0xFFFFFFFFFFFFFFLL;
    if (!v24) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
    }
    if (v18 == 43)
    {
      uint64_t v34 = specialized Collection.subscript.getter(1, (uint64_t)v39, v24);
      uint64_t v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v34, v35, v36, v37);
      uint64_t v31 = a7;
    }
    else
    {
      if (v18 == 45)
      {
        uint64_t v25 = specialized Collection.subscript.getter(1, (uint64_t)v39, v24);
        uint64_t v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
        uint64_t v31 = a7;
        uint64_t v32 = a2;
        int v33 = 1;
LABEL_14:
        _parseIntegerDigits<A>(ascii:radix:isNegative:)(v29, v30, v32, v33, a4, a6, v31);
        goto LABEL_15;
      }
      uint64_t v29 = (unsigned __int8 *)v39;
      uint64_t v31 = a7;
      uint64_t v30 = HIBYTE(v19) & 0xF;
    }
    uint64_t v32 = a2;
    int v33 = 0;
    goto LABEL_14;
  }
  if ((v17 & 0x2000000000000000) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v18 & 0x1000000000000000) != 0)
  {
    uint64_t v20 = (unsigned __int8 *)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v21 = v18 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v20 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v19);
  }
  closure #1 in _parseInteger<A, B>(ascii:radix:)(v20, v21, a2, a4, a6, a7);
LABEL_15:
  swift_bridgeObjectRelease(v19);
}

uint64_t specialized String.init<A>(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000) == 0) {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v6)
  {
    uint64_t v5 = specialized static String._copying(_:)(a1, a2, a3, a4);
    swift_bridgeObjectRelease(a4);
  }
  return v5;
}

Swift::UInt64 String.init<A>(_:)(Swift::UInt64 *a1, Class *a2, uint64_t a3)
{
  uint64_t v6 = (uint64_t)*(a2 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (unint64_t *)((char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v9 == &type metadata for String) {
    return *a1;
  }
  if (a2 == (Class *)&type metadata for Substring)
  {
    v11._rawBits = *a1;
    v12._rawBits = a1[1];
    unint64_t v13 = a1[3];
    uint64_t v10 = specialized String.init(_:)(v11, v12, a1[2], v13);
    swift_bridgeObjectRelease(v13);
  }
  else
  {
    (*(void (**)(unint64_t *, Swift::UInt64 *, Class *))(v6 + 16))(v8, a1, a2);
    if (swift_dynamicCast((char *)&v15, v8, a2, (const char *)&type metadata for String, 6uLL))
    {
      (*(void (**)(Swift::UInt64 *, Class *))(v6 + 8))(a1, a2);
      return v15;
    }
    else
    {
      uint64_t v10 = (*(uint64_t (**)(Class *))(*(void *)(a3 + 8) + 8))(a2);
      (*(void (**)(Swift::UInt64 *, Class *))(v6 + 8))(a1, a2);
    }
  }
  return v10;
}

unint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v6 = a1;
  int v7 = *a1;
  if (v7 == 43)
  {
    uint64_t v37 = specialized Collection.subscript.getter(1, (uint64_t)a1, v5);
    uint64_t v41 = specialized UnsafeBufferPointer.init(rebasing:)(v37, v38, v39, v40);
    if (!v42) {
      return 0;
    }
    v44 = (unsigned __int8 *)v41;
    unsigned __int8 v45 = a3 + 48;
    unsigned __int8 v46 = a3 + 55;
    unsigned __int8 v47 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }
    else
    {
      unsigned __int8 v47 = 97;
      unsigned __int8 v46 = 65;
    }
    if (v41)
    {
      unint64_t v19 = 0;
      uint64_t v48 = 0;
      unint64_t v49 = abs64(a3);
      unint64_t v50 = -(v43 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
      while (1)
      {
        unsigned int v51 = *v44;
        if (v51 < 0x30 || v51 >= v45)
        {
          if (v51 < 0x41 || v51 >= v46)
          {
            unint64_t result = 0;
            if (v51 < 0x61 || v51 >= v47) {
              return result;
            }
            char v52 = -87;
          }
          else
          {
            char v52 = -55;
          }
        }
        else
        {
          char v52 = -48;
        }
        unsigned long long v53 = __PAIR128__(v48 ^ (unint64_t)(v48 >> 63), v19 ^ (v48 >> 63)) - __PAIR128__(v48 >> 63, v48 >> 63);
        if ((__PAIR128__(v48 ^ (unint64_t)(v48 >> 63), v19 ^ (v48 >> 63)) - __PAIR128__(v48 >> 63, v48 >> 63)) >> 64) {
          BOOL v54 = v50 == 0;
        }
        else {
          BOOL v54 = 1;
        }
        char v57 = !v54
           || (*((unint64_t *)&v53 + 1) * (unsigned __int128)v49) >> 64 != 0
           || (v50 * (unsigned __int128)(unint64_t)v53) >> 64 != 0;
        unint64_t v58 = (__PAIR128__(v50, v49) * v53) >> 64;
        if (__CFADD__(((unint64_t)v53 * (unsigned __int128)v49) >> 64, v50 * v53 + *((void *)&v53 + 1) * v49)) {
          char v59 = 1;
        }
        else {
          char v59 = v57;
        }
        unint64_t v60 = v53 * v49;
        if ((v48 ^ (a3 >> 63)) < 0)
        {
          if (v59) {
            return 0;
          }
          BOOL v35 = v60 == 0;
          unint64_t v60 = -(uint64_t)v60;
          unint64_t v58 = -(uint64_t)(v58 + !v35);
          LOBYTE(v61) = v60 != 0;
        }
        else
        {
          if (v59) {
            return 0;
          }
          unint64_t v61 = v58 >> 63;
        }
        unint64_t result = 0;
        BOOL v35 = __CFADD__(v60, (v51 + v52));
        uint64_t v48 = (__PAIR128__(v58, v60) + (v51 + v52)) >> 64;
        unint64_t v19 = v60 + (v51 + v52);
        BOOL v62 = __OFADD__(v35, v58);
        if ((v61 & 1) != 0 || v62) {
          return result;
        }
        ++v44;
        if (!--v42) {
          return v19;
        }
      }
    }
    return 0;
  }
  if (v7 == 45)
  {
    uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v5);
    uint64_t v12 = specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13) {
      return 0;
    }
    uint64_t v15 = (unsigned __int8 *)v12;
    unsigned __int8 v16 = a3 + 48;
    unsigned __int8 v17 = a3 + 55;
    unsigned __int8 v18 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }
    else
    {
      unsigned __int8 v18 = 97;
      unsigned __int8 v17 = 65;
    }
    if (v12)
    {
      unint64_t v19 = 0;
      uint64_t v20 = 0;
      unint64_t v21 = abs64(a3);
      unint64_t v22 = -(v14 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
      while (1)
      {
        unsigned int v23 = *v15;
        if (v23 < 0x30 || v23 >= v16)
        {
          if (v23 < 0x41 || v23 >= v17)
          {
            unint64_t result = 0;
            if (v23 < 0x61 || v23 >= v18) {
              return result;
            }
            char v24 = -87;
          }
          else
          {
            char v24 = -55;
          }
        }
        else
        {
          char v24 = -48;
        }
        unsigned long long v26 = __PAIR128__(v20 ^ (unint64_t)(v20 >> 63), v19 ^ (v20 >> 63)) - __PAIR128__(v20 >> 63, v20 >> 63);
        BOOL v27 = !((__PAIR128__(v20 ^ (unint64_t)(v20 >> 63), v19 ^ (v20 >> 63)) - __PAIR128__(v20 >> 63, v20 >> 63)) >> 64)
           || v22 == 0;
        BOOL v28 = v27 && (*((unint64_t *)&v26 + 1) * (unsigned __int128)v21) >> 64 == 0;
        BOOL v29 = v28 && (v22 * (unsigned __int128)(unint64_t)v26) >> 64 == 0;
        BOOL v30 = !v29;
        unint64_t v31 = (__PAIR128__(v22, v21) * v26) >> 64;
        char v32 = __CFADD__(((unint64_t)v26 * (unsigned __int128)v21) >> 64, v22 * v26 + *((void *)&v26 + 1) * v21)
           || v30;
        unint64_t v33 = v26 * v21;
        if ((v20 ^ (a3 >> 63)) < 0)
        {
          if (v32) {
            return 0;
          }
          BOOL v35 = v33 == 0;
          unint64_t v33 = -(uint64_t)v33;
          unint64_t v31 = -(uint64_t)(v31 + !v35);
          LOBYTE(v34) = v33 != 0;
        }
        else
        {
          if (v32) {
            return 0;
          }
          unint64_t v34 = v31 >> 63;
        }
        unint64_t result = 0;
        BOOL v35 = v33 >= (v23 + v24);
        uint64_t v20 = (__PAIR128__(v31, v33) - (v23 + v24)) >> 64;
        unint64_t v19 = v33 - (v23 + v24);
        BOOL v36 = __OFSUB__(v31, !v35);
        if ((v34 & 1) != 0 || v36) {
          break;
        }
        ++v15;
        if (!--v13) {
          return v19;
        }
      }
      return result;
    }
    return 0;
  }
  unint64_t v63 = 0;
  uint64_t v64 = 0;
  unsigned __int8 v65 = a3 + 48;
  unsigned __int8 v66 = a3 + 55;
  unsigned __int8 v67 = a3 + 87;
  if (a3 > 10)
  {
    unsigned __int8 v65 = 58;
  }
  else
  {
    unsigned __int8 v67 = 97;
    unsigned __int8 v66 = 65;
  }
  unint64_t v68 = abs64(a3);
  unint64_t v69 = -(v3 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
  while (1)
  {
    unsigned int v70 = *v6;
    if (v70 < 0x30 || v70 >= v65)
    {
      if (v70 < 0x41 || v70 >= v66)
      {
        unint64_t result = 0;
        if (v70 < 0x61 || v70 >= v67) {
          return result;
        }
        char v71 = -87;
      }
      else
      {
        char v71 = -55;
      }
    }
    else
    {
      char v71 = -48;
    }
    unsigned long long v72 = __PAIR128__(v64 ^ (unint64_t)(v64 >> 63), v63 ^ (v64 >> 63)) - __PAIR128__(v64 >> 63, v64 >> 63);
    if ((__PAIR128__(v64 ^ (unint64_t)(v64 >> 63), v63 ^ (v64 >> 63)) - __PAIR128__(v64 >> 63, v64 >> 63)) >> 64) {
      BOOL v73 = v69 == 0;
    }
    else {
      BOOL v73 = 1;
    }
    char v76 = !v73
       || (*((unint64_t *)&v72 + 1) * (unsigned __int128)v68) >> 64 != 0
       || (v69 * (unsigned __int128)(unint64_t)v72) >> 64 != 0;
    unint64_t v77 = (__PAIR128__(v69, v68) * v72) >> 64;
    if (__CFADD__(((unint64_t)v72 * (unsigned __int128)v68) >> 64, v69 * v72 + *((void *)&v72 + 1) * v68)) {
      char v76 = 1;
    }
    unint64_t v78 = v72 * v68;
    if ((v64 ^ (a3 >> 63)) < 0)
    {
      if (v76) {
        return 0;
      }
      BOOL v35 = v78 == 0;
      unint64_t v78 = -(uint64_t)v78;
      unint64_t v77 = -(uint64_t)(v77 + !v35);
      LOBYTE(v79) = v78 != 0;
    }
    else
    {
      if (v76) {
        return 0;
      }
      unint64_t v79 = v77 >> 63;
    }
    unint64_t result = 0;
    BOOL v35 = __CFADD__(v78, (v70 + v71));
    uint64_t v64 = (__PAIR128__(v77, v78) + (v70 + v71)) >> 64;
    unint64_t v63 = v78 + (v70 + v71);
    BOOL v80 = __OFADD__(v35, v77);
    if ((v79 & 1) != 0 || v80) {
      break;
    }
    ++v6;
    if (!--v5) {
      return v63;
    }
  }
  return result;
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  char v21;
  unint64_t result;
  unsigned __int8 v23;
  BOOL v24;
  char v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  unint64_t v31;
  unint64_t v32;
  BOOL v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unint64_t v45;
  uint64_t v46;
  unsigned int v47;
  char v48;
  unsigned __int8 v49;
  BOOL v50;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  BOOL v59;
  uint64_t v60;
  unint64_t v61;
  unsigned __int8 v62;
  unsigned __int8 v63;
  unsigned __int8 v64;
  uint64_t v65;
  unsigned int v66;
  char v67;
  unsigned __int8 v68;
  BOOL v69;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  BOOL v77;
  BOOL v78;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a1;
  if (v6 == 43)
  {
    BOOL v35 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v39 = specialized UnsafeBufferPointer.init(rebasing:)(v35, v36, v37, v38);
    if (!v40) {
      return 0;
    }
    uint64_t v41 = (unsigned __int8 *)v39;
    uint64_t v42 = a3 + 55;
    uint64_t v43 = a3 + 87;
    if (a3 > 10)
    {
      v44 = 58;
    }
    else
    {
      uint64_t v43 = 97;
      uint64_t v42 = 65;
      v44 = a3 + 48;
    }
    if (!v39) {
      return 0;
    }
    unsigned __int8 v17 = 0;
    unsigned __int8 v45 = 0;
    unsigned __int8 v46 = a3 >> 63;
    while (1)
    {
      unsigned __int8 v47 = *v41;
      if (v47 < 0x30 || v47 >= v44)
      {
        if (v47 < 0x41 || v47 >= v42)
        {
          unint64_t result = 0;
          if (v47 < 0x61 || v47 >= v43) {
            return result;
          }
          uint64_t v48 = -87;
        }
        else
        {
          uint64_t v48 = -55;
        }
      }
      else
      {
        uint64_t v48 = -48;
      }
      unint64_t result = 0;
      unint64_t v49 = v47 + v48;
      if (v45) {
        unint64_t v50 = a3 >= 0;
      }
      else {
        unint64_t v50 = 1;
      }
      unsigned long long v53 = !v50
         || (v45 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
         || ((unint64_t)v46 * (unsigned __int128)v17) >> 64 != 0;
      BOOL v54 = v46 * v17 + v45 * a3;
      v55 = (v17 * (unsigned __int128)(unint64_t)a3) >> 64;
      BOOL v30 = __CFADD__(v55, v54);
      v56 = v55 + v54;
      if (v30) {
        unsigned long long v53 = 1;
      }
      char v57 = v17 * a3;
      BOOL v30 = __CFADD__(v57, v49);
      unsigned __int8 v17 = v57 + v49;
      unint64_t v58 = v30;
      BOOL v30 = __CFADD__(v30, v56);
      unsigned __int8 v45 = v58 + v56;
      char v59 = v30;
      if ((v53 & 1) != 0 || v59) {
        break;
      }
      ++v41;
      if (!--v40) {
        return v17;
      }
    }
  }
  else
  {
    if (v6 == 45)
    {
      int v7 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
      uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
      if (!v12) {
        return 0;
      }
      uint64_t v13 = (unsigned __int8 *)v11;
      uint64_t v14 = a3 + 55;
      uint64_t v15 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v16 = 58;
      }
      else
      {
        uint64_t v15 = 97;
        uint64_t v14 = 65;
        unsigned __int8 v16 = a3 + 48;
      }
      if (v11)
      {
        unsigned __int8 v17 = 0;
        unsigned __int8 v18 = 0;
        unint64_t v19 = a3 >> 63;
        while (1)
        {
          uint64_t v20 = *v13;
          if (v20 < 0x30 || v20 >= v16)
          {
            if (v20 < 0x41 || v20 >= v14)
            {
              unint64_t result = 0;
              if (v20 < 0x61 || v20 >= v15) {
                return result;
              }
              unint64_t v21 = -87;
            }
            else
            {
              unint64_t v21 = -55;
            }
          }
          else
          {
            unint64_t v21 = -48;
          }
          unint64_t result = 0;
          unsigned int v23 = v20 + v21;
          if (v18) {
            char v24 = a3 >= 0;
          }
          else {
            char v24 = 1;
          }
          BOOL v27 = !v24
             || (v18 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
             || ((unint64_t)v19 * (unsigned __int128)v17) >> 64 != 0;
          BOOL v28 = v19 * v17 + v18 * a3;
          BOOL v29 = (v17 * (unsigned __int128)(unint64_t)a3) >> 64;
          BOOL v30 = __CFADD__(v29, v28);
          unint64_t v31 = v29 + v28;
          if (v30) {
            BOOL v27 = 1;
          }
          char v32 = v17 * a3;
          BOOL v30 = v32 >= v23;
          unsigned __int8 v17 = v32 - v23;
          unint64_t v33 = v30;
          BOOL v30 = v31 >= !v30;
          unsigned __int8 v18 = v31 - !v33;
          unint64_t v34 = !v30;
          if ((v27 & 1) != 0 || v34) {
            break;
          }
          ++v13;
          if (!--v12) {
            return v17;
          }
        }
        return result;
      }
      return 0;
    }
    unint64_t v60 = 0;
    unint64_t v61 = 0;
    BOOL v62 = a3 + 48;
    unint64_t v63 = a3 + 55;
    uint64_t v64 = a3 + 87;
    if (a3 > 10)
    {
      BOOL v62 = 58;
    }
    else
    {
      uint64_t v64 = 97;
      unint64_t v63 = 65;
    }
    unsigned __int8 v65 = a3 >> 63;
    while (1)
    {
      unsigned __int8 v66 = *v5;
      if (v66 < 0x30 || v66 >= v62)
      {
        if (v66 < 0x41 || v66 >= v63)
        {
          unint64_t result = 0;
          if (v66 < 0x61 || v66 >= v64) {
            return result;
          }
          unsigned __int8 v67 = -87;
        }
        else
        {
          unsigned __int8 v67 = -55;
        }
      }
      else
      {
        unsigned __int8 v67 = -48;
      }
      unint64_t result = 0;
      unint64_t v68 = v66 + v67;
      if (v61) {
        unint64_t v69 = a3 >= 0;
      }
      else {
        unint64_t v69 = 1;
      }
      unsigned long long v72 = !v69
         || (v61 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
         || ((unint64_t)v65 * (unsigned __int128)(unint64_t)v60) >> 64 != 0;
      BOOL v73 = v65 * v60 + v61 * a3;
      v74 = ((unint64_t)v60 * (unsigned __int128)(unint64_t)a3) >> 64;
      BOOL v30 = __CFADD__(v74, v73);
      uint64_t v75 = v74 + v73;
      if (v30) {
        unsigned long long v72 = 1;
      }
      char v76 = v60 * a3;
      BOOL v30 = __CFADD__(v76, v68);
      unint64_t v60 = v76 + v68;
      unint64_t v77 = v30;
      BOOL v30 = __CFADD__(v30, v75);
      unint64_t v61 = v77 + v75;
      unint64_t v78 = v30;
      if ((v72 & 1) != 0 || v78) {
        break;
      }
      ++v5;
      if (!--v4) {
        return v60;
      }
    }
  }
  return result;
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned int v17;
  unsigned int v18;
  char v19;
  unsigned int v20;
  unsigned __int8 v21;
  unint64_t v22;
  BOOL v23;
  BOOL v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned int v35;
  unsigned int v36;
  char v37;
  unsigned __int8 v38;
  unint64_t v39;
  BOOL v40;
  char v41;
  unsigned int v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  unsigned __int8 v48;
  unint64_t v49;
  BOOL v50;
  char v51;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    unsigned long long v26 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    BOOL v30 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
    if (!v31)
    {
      uint64_t v20 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }
    char v32 = a3 + 55;
    unint64_t v33 = a3 + 87;
    if (a3 > 10)
    {
      unint64_t v34 = 58;
    }
    else
    {
      unint64_t v33 = 97;
      char v32 = 65;
      unint64_t v34 = a3 + 48;
    }
    if (!v30) {
      goto LABEL_67;
    }
    BOOL v35 = 0;
    do
    {
      BOOL v36 = *v30;
      if (v36 < 0x30 || v36 >= v34)
      {
        if (v36 < 0x41 || v36 >= v32)
        {
          uint64_t v20 = 0;
          int v7 = 1;
          if (v36 < 0x61 || v36 >= v33) {
            return v20 | ((unint64_t)v7 << 32);
          }
          uint64_t v37 = -87;
        }
        else
        {
          uint64_t v37 = -55;
        }
      }
      else
      {
        uint64_t v37 = -48;
      }
      uint64_t v20 = 0;
      uint64_t v38 = v36 + v37;
      uint64_t v39 = v35 * (unint64_t)a3;
      uint64_t v40 = (v39 & 0xFFFFFFFF00000000) != 0;
      char v24 = __CFADD__(v39, v38);
      BOOL v35 = v39 + v38;
      uint64_t v41 = v24;
      int v7 = 1;
      if (v40) {
        break;
      }
      if (v41) {
        break;
      }
      int v7 = 0;
      ++v30;
      uint64_t v20 = v35;
      --v31;
    }
    while (v31);
  }
  else
  {
    if (v6 == 45)
    {
      int v7 = 1;
      uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
      uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
      if (!v13)
      {
        uint64_t v20 = 0;
        return v20 | ((unint64_t)v7 << 32);
      }
      uint64_t v14 = a3 + 55;
      uint64_t v15 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v16 = 58;
      }
      else
      {
        uint64_t v15 = 97;
        uint64_t v14 = 65;
        unsigned __int8 v16 = a3 + 48;
      }
      if (v12)
      {
        unsigned __int8 v17 = 0;
        do
        {
          unsigned __int8 v18 = *v12;
          if (v18 < 0x30 || v18 >= v16)
          {
            if (v18 < 0x41 || v18 >= v14)
            {
              uint64_t v20 = 0;
              int v7 = 1;
              if (v18 < 0x61 || v18 >= v15) {
                return v20 | ((unint64_t)v7 << 32);
              }
              unint64_t v19 = -87;
            }
            else
            {
              unint64_t v19 = -55;
            }
          }
          else
          {
            unint64_t v19 = -48;
          }
          uint64_t v20 = 0;
          unint64_t v21 = v18 + v19;
          unint64_t v22 = v17 * (unint64_t)a3;
          unsigned int v23 = (v22 & 0xFFFFFFFF00000000) != 0;
          char v24 = v22 >= v21;
          unsigned __int8 v17 = v22 - v21;
          uint64_t v25 = !v24;
          int v7 = 1;
          if (v23) {
            break;
          }
          if (v25) {
            break;
          }
          int v7 = 0;
          ++v12;
          uint64_t v20 = v17;
          --v13;
        }
        while (v13);
        return v20 | ((unint64_t)v7 << 32);
      }
LABEL_67:
      uint64_t v20 = 0;
      int v7 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }
    uint64_t v42 = 0;
    uint64_t v43 = a3 + 55;
    v44 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }
    else
    {
      v44 = 97;
      uint64_t v43 = 65;
      unsigned __int8 v45 = a3 + 48;
    }
    do
    {
      unsigned __int8 v46 = *v5;
      if (v46 < 0x30 || v46 >= v45)
      {
        if (v46 < 0x41 || v46 >= v43)
        {
          uint64_t v20 = 0;
          int v7 = 1;
          if (v46 < 0x61 || v46 >= v44) {
            return v20 | ((unint64_t)v7 << 32);
          }
          unsigned __int8 v47 = -87;
        }
        else
        {
          unsigned __int8 v47 = -55;
        }
      }
      else
      {
        unsigned __int8 v47 = -48;
      }
      uint64_t v20 = 0;
      uint64_t v48 = v46 + v47;
      unint64_t v49 = v42 * (unint64_t)a3;
      unint64_t v50 = (v49 & 0xFFFFFFFF00000000) != 0;
      char v24 = __CFADD__(v49, v48);
      uint64_t v42 = v49 + v48;
      unsigned int v51 = v24;
      int v7 = 1;
      if (v50) {
        break;
      }
      if (v51) {
        break;
      }
      int v7 = 0;
      ++v5;
      uint64_t v20 = v42;
      --v4;
    }
    while (v4);
  }
  return v20 | ((unint64_t)v7 << 32);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned int v17;
  unsigned int v18;
  char v19;
  unsigned int v20;
  unsigned __int8 v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned int v35;
  unsigned int v36;
  char v37;
  unsigned __int8 v38;
  uint64_t v39;
  BOOL v40;
  char v41;
  unsigned int v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  unsigned __int8 v48;
  uint64_t v49;
  BOOL v50;
  char v51;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    unsigned long long v26 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    BOOL v30 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
    if (!v31)
    {
      uint64_t v20 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }
    char v32 = a3 + 55;
    unint64_t v33 = a3 + 87;
    if (a3 > 10)
    {
      unint64_t v34 = 58;
    }
    else
    {
      unint64_t v33 = 97;
      char v32 = 65;
      unint64_t v34 = a3 + 48;
    }
    if (!v30) {
      goto LABEL_67;
    }
    BOOL v35 = 0;
    do
    {
      BOOL v36 = *v30;
      if (v36 < 0x30 || v36 >= v34)
      {
        if (v36 < 0x41 || v36 >= v32)
        {
          uint64_t v20 = 0;
          int v7 = 1;
          if (v36 < 0x61 || v36 >= v33) {
            return v20 | ((unint64_t)v7 << 32);
          }
          uint64_t v37 = -87;
        }
        else
        {
          uint64_t v37 = -55;
        }
      }
      else
      {
        uint64_t v37 = -48;
      }
      uint64_t v20 = 0;
      uint64_t v38 = v36 + v37;
      uint64_t v39 = (int)v35 * (uint64_t)(int)a3;
      uint64_t v40 = v39 != (int)v39;
      char v24 = __OFADD__(v39, v38);
      BOOL v35 = v39 + v38;
      uint64_t v41 = v24;
      int v7 = 1;
      if (v40) {
        break;
      }
      if (v41) {
        break;
      }
      int v7 = 0;
      ++v30;
      uint64_t v20 = v35;
      --v31;
    }
    while (v31);
  }
  else
  {
    if (v6 == 45)
    {
      int v7 = 1;
      uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
      uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
      if (!v13)
      {
        uint64_t v20 = 0;
        return v20 | ((unint64_t)v7 << 32);
      }
      uint64_t v14 = a3 + 55;
      uint64_t v15 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v16 = 58;
      }
      else
      {
        uint64_t v15 = 97;
        uint64_t v14 = 65;
        unsigned __int8 v16 = a3 + 48;
      }
      if (v12)
      {
        unsigned __int8 v17 = 0;
        do
        {
          unsigned __int8 v18 = *v12;
          if (v18 < 0x30 || v18 >= v16)
          {
            if (v18 < 0x41 || v18 >= v14)
            {
              uint64_t v20 = 0;
              int v7 = 1;
              if (v18 < 0x61 || v18 >= v15) {
                return v20 | ((unint64_t)v7 << 32);
              }
              unint64_t v19 = -87;
            }
            else
            {
              unint64_t v19 = -55;
            }
          }
          else
          {
            unint64_t v19 = -48;
          }
          uint64_t v20 = 0;
          unint64_t v21 = v18 + v19;
          unint64_t v22 = (int)v17 * (uint64_t)(int)a3;
          unsigned int v23 = v22 != (int)v22;
          char v24 = __OFSUB__(v22, v21);
          unsigned __int8 v17 = v22 - v21;
          uint64_t v25 = v24;
          int v7 = 1;
          if (v23) {
            break;
          }
          if (v25) {
            break;
          }
          int v7 = 0;
          ++v12;
          uint64_t v20 = v17;
          --v13;
        }
        while (v13);
        return v20 | ((unint64_t)v7 << 32);
      }
LABEL_67:
      uint64_t v20 = 0;
      int v7 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }
    uint64_t v42 = 0;
    uint64_t v43 = a3 + 55;
    v44 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }
    else
    {
      v44 = 97;
      uint64_t v43 = 65;
      unsigned __int8 v45 = a3 + 48;
    }
    do
    {
      unsigned __int8 v46 = *v5;
      if (v46 < 0x30 || v46 >= v45)
      {
        if (v46 < 0x41 || v46 >= v43)
        {
          uint64_t v20 = 0;
          int v7 = 1;
          if (v46 < 0x61 || v46 >= v44) {
            return v20 | ((unint64_t)v7 << 32);
          }
          unsigned __int8 v47 = -87;
        }
        else
        {
          unsigned __int8 v47 = -55;
        }
      }
      else
      {
        unsigned __int8 v47 = -48;
      }
      uint64_t v20 = 0;
      uint64_t v48 = v46 + v47;
      unint64_t v49 = (int)v42 * (uint64_t)(int)a3;
      unint64_t v50 = v49 != (int)v49;
      char v24 = __OFADD__(v49, v48);
      uint64_t v42 = v49 + v48;
      unsigned int v51 = v24;
      int v7 = 1;
      if (v50) {
        break;
      }
      if (v51) {
        break;
      }
      int v7 = 0;
      ++v5;
      uint64_t v20 = v42;
      --v4;
    }
    while (v4);
  }
  return v20 | ((unint64_t)v7 << 32);
}

uint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v23 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    BOOL v27 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v23, v24, v25, v26);
    if (!v28)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }
    unsigned __int8 v29 = a3 + 55;
    unsigned __int8 v30 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v31 = 58;
    }
    else
    {
      unsigned __int8 v30 = 97;
      unsigned __int8 v29 = 65;
      unsigned __int8 v31 = a3 + 48;
    }
    if (v27)
    {
      LOBYTE(v32) = 0;
      while (1)
      {
        unsigned int v33 = *v27;
        if (v33 < 0x30 || v33 >= v31)
        {
          if (v33 < 0x41 || v33 >= v29)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v33 < 0x61 || v33 >= v30) {
              return v20 | (v7 << 8);
            }
            char v34 = -87;
          }
          else
          {
            char v34 = -55;
          }
        }
        else
        {
          char v34 = -48;
        }
        unsigned __int8 v20 = 0;
        __int16 v35 = v32 * a3;
        int v7 = 1;
        if ((v35 & 0xFF00) == 0)
        {
          unsigned int v32 = v35 + (v33 + v34);
          if (((v32 >> 8) & 1) == 0)
          {
            int v7 = 0;
            ++v27;
            unsigned __int8 v20 = v32;
            if (--v28) {
              continue;
            }
          }
        }
        return v20 | (v7 << 8);
      }
    }
  }
  else
  {
    if (v6 != 45)
    {
      LOBYTE(v36) = 0;
      unsigned __int8 v37 = a3 + 55;
      unsigned __int8 v38 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v39 = 58;
      }
      else
      {
        unsigned __int8 v38 = 97;
        unsigned __int8 v37 = 65;
        unsigned __int8 v39 = a3 + 48;
      }
      while (1)
      {
        unsigned int v40 = *v5;
        if (v40 < 0x30 || v40 >= v39)
        {
          if (v40 < 0x41 || v40 >= v37)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v40 < 0x61 || v40 >= v38) {
              return v20 | (v7 << 8);
            }
            char v41 = -87;
          }
          else
          {
            char v41 = -55;
          }
        }
        else
        {
          char v41 = -48;
        }
        unsigned __int8 v20 = 0;
        __int16 v42 = v36 * a3;
        int v7 = 1;
        if ((v42 & 0xFF00) == 0)
        {
          unsigned int v36 = v42 + (v40 + v41);
          if (((v36 >> 8) & 1) == 0)
          {
            int v7 = 0;
            ++v5;
            unsigned __int8 v20 = v36;
            if (--v4) {
              continue;
            }
          }
        }
        return v20 | (v7 << 8);
      }
    }
    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }
    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }
    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }
    if (v12)
    {
      LOBYTE(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 8);
            }
            char v19 = -87;
          }
          else
          {
            char v19 = -55;
          }
        }
        else
        {
          char v19 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = v17 * a3;
        int v17 = (v17 * a3) - v21;
        int v7 = 1;
        if ((v22 & 0xFF00) == 0 && (v17 & 0xFFFFFF00) == 0)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }
        return v20 | (v7 << 8);
      }
    }
  }
  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 8);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  char v19;
  unsigned __int8 v20;
  char v21;
  int v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  int v34;
  unsigned int v35;
  char v36;
  char v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned int v45;
  char v46;
  char v47;
  int v48;
  int v49;
  BOOL v50;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v25 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    unsigned __int8 v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
    if (!v30)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }
    unsigned __int8 v31 = a3 + 55;
    unsigned int v32 = a3 + 87;
    if (a3 > 10)
    {
      unsigned int v33 = 58;
    }
    else
    {
      unsigned int v32 = 97;
      unsigned __int8 v31 = 65;
      unsigned int v33 = a3 + 48;
    }
    if (v29)
    {
      LOBYTE(v34) = 0;
      while (1)
      {
        __int16 v35 = *v29;
        if (v35 < 0x30 || v35 >= v33)
        {
          if (v35 < 0x41 || v35 >= v31)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v35 < 0x61 || v35 >= v32) {
              return v20 | (v7 << 8);
            }
            unsigned int v36 = -87;
          }
          else
          {
            unsigned int v36 = -55;
          }
        }
        else
        {
          unsigned int v36 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v37 = v35 + v36;
        unsigned __int8 v38 = (char)v34 * (char)a3;
        unsigned __int8 v39 = (char)(v34 * a3);
        char v34 = v39 + v37;
        unsigned int v40 = v34 != (char)(v39 + v37);
        int v7 = 1;
        if (v39 == v38 && !v40)
        {
          int v7 = 0;
          ++v29;
          unsigned __int8 v20 = v34;
          if (--v30) {
            continue;
          }
        }
        return v20 | (v7 << 8);
      }
    }
  }
  else
  {
    if (v6 != 45)
    {
      LOBYTE(v41) = 0;
      __int16 v42 = a3 + 55;
      uint64_t v43 = a3 + 87;
      if (a3 > 10)
      {
        v44 = 58;
      }
      else
      {
        uint64_t v43 = 97;
        __int16 v42 = 65;
        v44 = a3 + 48;
      }
      while (1)
      {
        unsigned __int8 v45 = *v5;
        if (v45 < 0x30 || v45 >= v44)
        {
          if (v45 < 0x41 || v45 >= v42)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v45 < 0x61 || v45 >= v43) {
              return v20 | (v7 << 8);
            }
            unsigned __int8 v46 = -87;
          }
          else
          {
            unsigned __int8 v46 = -55;
          }
        }
        else
        {
          unsigned __int8 v46 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v47 = v45 + v46;
        uint64_t v48 = (char)v41 * (char)a3;
        unint64_t v49 = (char)(v41 * a3);
        char v41 = v49 + v47;
        unint64_t v50 = v41 != (char)(v49 + v47);
        int v7 = 1;
        if (v49 == v48 && !v50)
        {
          int v7 = 0;
          ++v5;
          unsigned __int8 v20 = v41;
          if (--v4) {
            continue;
          }
        }
        return v20 | (v7 << 8);
      }
    }
    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }
    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }
    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }
    if (v12)
    {
      LOBYTE(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 8);
            }
            char v19 = -87;
          }
          else
          {
            char v19 = -55;
          }
        }
        else
        {
          char v19 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = (char)v17 * (char)a3;
        uint64_t v23 = (char)(v17 * a3);
        int v17 = v23 - v21;
        uint64_t v24 = v17 != (char)(v23 - v21);
        int v7 = 1;
        if (v23 == v22 && !v24)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }
        return v20 | (v7 << 8);
      }
    }
  }
  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 8);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  char v19;
  unsigned __int16 v20;
  unsigned __int8 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  uint64_t v28;
  unsigned __int8 v29;
  unsigned __int8 v30;
  unsigned __int8 v31;
  int v32;
  unsigned int v33;
  char v34;
  int v35;
  int v36;
  unsigned __int8 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  unsigned int v40;
  char v41;
  int v42;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v23 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    BOOL v27 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v23, v24, v25, v26);
    if (!v28)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }
    unsigned __int8 v29 = a3 + 55;
    unsigned __int8 v30 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v31 = 58;
    }
    else
    {
      unsigned __int8 v30 = 97;
      unsigned __int8 v29 = 65;
      unsigned __int8 v31 = a3 + 48;
    }
    if (v27)
    {
      LOWORD(v32) = 0;
      while (1)
      {
        unsigned int v33 = *v27;
        if (v33 < 0x30 || v33 >= v31)
        {
          if (v33 < 0x41 || v33 >= v29)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v33 < 0x61 || v33 >= v30) {
              return v20 | (v7 << 16);
            }
            char v34 = -87;
          }
          else
          {
            char v34 = -55;
          }
        }
        else
        {
          char v34 = -48;
        }
        unsigned __int8 v20 = 0;
        __int16 v35 = (unsigned __int16)v32 * (unsigned __int16)a3;
        int v7 = 1;
        if ((v35 & 0xFFFF0000) == 0)
        {
          unsigned int v32 = (unsigned __int16)v35 + (v33 + v34);
          if ((v32 & 0x10000) == 0)
          {
            int v7 = 0;
            ++v27;
            unsigned __int8 v20 = v32;
            if (--v28) {
              continue;
            }
          }
        }
        return v20 | (v7 << 16);
      }
    }
  }
  else
  {
    if (v6 != 45)
    {
      LOWORD(v36) = 0;
      unsigned __int8 v37 = a3 + 55;
      unsigned __int8 v38 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v39 = 58;
      }
      else
      {
        unsigned __int8 v38 = 97;
        unsigned __int8 v37 = 65;
        unsigned __int8 v39 = a3 + 48;
      }
      while (1)
      {
        unsigned int v40 = *v5;
        if (v40 < 0x30 || v40 >= v39)
        {
          if (v40 < 0x41 || v40 >= v37)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v40 < 0x61 || v40 >= v38) {
              return v20 | (v7 << 16);
            }
            char v41 = -87;
          }
          else
          {
            char v41 = -55;
          }
        }
        else
        {
          char v41 = -48;
        }
        unsigned __int8 v20 = 0;
        __int16 v42 = (unsigned __int16)v36 * (unsigned __int16)a3;
        int v7 = 1;
        if ((v42 & 0xFFFF0000) == 0)
        {
          unsigned int v36 = (unsigned __int16)v42 + (v40 + v41);
          if ((v36 & 0x10000) == 0)
          {
            int v7 = 0;
            ++v5;
            unsigned __int8 v20 = v36;
            if (--v4) {
              continue;
            }
          }
        }
        return v20 | (v7 << 16);
      }
    }
    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }
    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }
    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }
    if (v12)
    {
      LOWORD(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 16);
            }
            char v19 = -87;
          }
          else
          {
            char v19 = -55;
          }
        }
        else
        {
          char v19 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = (unsigned __int16)v17 * (unsigned __int16)a3;
        int v17 = (unsigned __int16)(v17 * a3) - v21;
        int v7 = 1;
        if ((v22 & 0xFFFF0000) == 0 && (v17 & 0xFFFF0000) == 0)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }
        return v20 | (v7 << 16);
      }
    }
  }
  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 16);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  char v19;
  unsigned __int16 v20;
  unsigned __int8 v21;
  int v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  int v34;
  unsigned int v35;
  char v36;
  unsigned __int8 v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned int v45;
  char v46;
  unsigned __int8 v47;
  int v48;
  int v49;
  BOOL v50;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v25 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    unsigned __int8 v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
    if (!v30)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }
    unsigned __int8 v31 = a3 + 55;
    unsigned int v32 = a3 + 87;
    if (a3 > 10)
    {
      unsigned int v33 = 58;
    }
    else
    {
      unsigned int v32 = 97;
      unsigned __int8 v31 = 65;
      unsigned int v33 = a3 + 48;
    }
    if (v29)
    {
      LOWORD(v34) = 0;
      while (1)
      {
        __int16 v35 = *v29;
        if (v35 < 0x30 || v35 >= v33)
        {
          if (v35 < 0x41 || v35 >= v31)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v35 < 0x61 || v35 >= v32) {
              return v20 | (v7 << 16);
            }
            unsigned int v36 = -87;
          }
          else
          {
            unsigned int v36 = -55;
          }
        }
        else
        {
          unsigned int v36 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v37 = v35 + v36;
        unsigned __int8 v38 = (__int16)v34 * (__int16)a3;
        unsigned __int8 v39 = (__int16)(v34 * a3);
        char v34 = v39 + v37;
        unsigned int v40 = v34 != (__int16)(v39 + v37);
        int v7 = 1;
        if (v39 == v38 && !v40)
        {
          int v7 = 0;
          ++v29;
          unsigned __int8 v20 = v34;
          if (--v30) {
            continue;
          }
        }
        return v20 | (v7 << 16);
      }
    }
  }
  else
  {
    if (v6 != 45)
    {
      LOWORD(v41) = 0;
      __int16 v42 = a3 + 55;
      uint64_t v43 = a3 + 87;
      if (a3 > 10)
      {
        v44 = 58;
      }
      else
      {
        uint64_t v43 = 97;
        __int16 v42 = 65;
        v44 = a3 + 48;
      }
      while (1)
      {
        unsigned __int8 v45 = *v5;
        if (v45 < 0x30 || v45 >= v44)
        {
          if (v45 < 0x41 || v45 >= v42)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v45 < 0x61 || v45 >= v43) {
              return v20 | (v7 << 16);
            }
            unsigned __int8 v46 = -87;
          }
          else
          {
            unsigned __int8 v46 = -55;
          }
        }
        else
        {
          unsigned __int8 v46 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v47 = v45 + v46;
        uint64_t v48 = (__int16)v41 * (__int16)a3;
        unint64_t v49 = (__int16)(v41 * a3);
        char v41 = v49 + v47;
        unint64_t v50 = v41 != (__int16)(v49 + v47);
        int v7 = 1;
        if (v49 == v48 && !v50)
        {
          int v7 = 0;
          ++v5;
          unsigned __int8 v20 = v41;
          if (--v4) {
            continue;
          }
        }
        return v20 | (v7 << 16);
      }
    }
    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }
    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }
    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }
    if (v12)
    {
      LOWORD(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 16);
            }
            char v19 = -87;
          }
          else
          {
            char v19 = -55;
          }
        }
        else
        {
          char v19 = -48;
        }
        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = (__int16)v17 * (__int16)a3;
        uint64_t v23 = (__int16)(v17 * a3);
        int v17 = v23 - v21;
        uint64_t v24 = v17 != (__int16)(v23 - v21);
        int v7 = 1;
        if (v23 == v22 && !v24)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }
        return v20 | (v7 << 16);
      }
    }
  }
  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 16);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  uint64_t v17;
  unsigned int v18;
  char v19;
  uint64_t result;
  unsigned __int8 v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  uint64_t v35;
  unsigned int v36;
  char v37;
  unsigned __int8 v38;
  uint64_t v39;
  BOOL v40;
  BOOL v41;
  uint64_t v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  unsigned __int8 v48;
  uint64_t v49;
  BOOL v50;
  BOOL v51;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    uint64_t v25 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    unsigned __int8 v29 = specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
    if (!v30) {
      return 0;
    }
    unsigned __int8 v31 = (unsigned __int8 *)v29;
    unsigned int v32 = a3 + 48;
    unsigned int v33 = a3 + 55;
    char v34 = a3 + 87;
    if (a3 > 10)
    {
      unsigned int v32 = 58;
    }
    else
    {
      char v34 = 97;
      unsigned int v33 = 65;
    }
    if (!v29) {
      return 0;
    }
    __int16 v35 = 0;
    do
    {
      unsigned int v36 = *v31;
      if (v36 < 0x30 || v36 >= v32)
      {
        if (v36 < 0x41 || v36 >= v33)
        {
          unint64_t result = 0;
          if (v36 < 0x61 || v36 >= v34) {
            return result;
          }
          unsigned __int8 v37 = -87;
        }
        else
        {
          unsigned __int8 v37 = -55;
        }
      }
      else
      {
        unsigned __int8 v37 = -48;
      }
      unint64_t result = 0;
      unsigned __int8 v38 = v36 + v37;
      unsigned __int8 v39 = v35 * a3;
      unsigned int v40 = (unsigned __int128)(v35 * (__int128)a3) >> 64 != (v35 * a3) >> 63;
      __int16 v35 = v35 * a3 + v38;
      char v41 = __OFADD__(v39, v38);
      if (v40) {
        break;
      }
      if (v41) {
        break;
      }
      ++v31;
      unint64_t result = v35;
      --v30;
    }
    while (v30);
  }
  else
  {
    if (v6 == 45)
    {
      int v7 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
      uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
      if (!v12) {
        return 0;
      }
      uint64_t v13 = (unsigned __int8 *)v11;
      unsigned __int8 v14 = a3 + 48;
      unsigned __int8 v15 = a3 + 55;
      unsigned __int8 v16 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v14 = 58;
      }
      else
      {
        unsigned __int8 v16 = 97;
        unsigned __int8 v15 = 65;
      }
      if (v11)
      {
        int v17 = 0;
        do
        {
          unsigned int v18 = *v13;
          if (v18 < 0x30 || v18 >= v14)
          {
            if (v18 < 0x41 || v18 >= v15)
            {
              unint64_t result = 0;
              if (v18 < 0x61 || v18 >= v16) {
                return result;
              }
              char v19 = -87;
            }
            else
            {
              char v19 = -55;
            }
          }
          else
          {
            char v19 = -48;
          }
          unint64_t result = 0;
          unsigned __int8 v21 = v18 + v19;
          __int16 v22 = v17 * a3;
          uint64_t v23 = (unsigned __int128)(v17 * (__int128)a3) >> 64 != (v17 * a3) >> 63;
          int v17 = v17 * a3 - v21;
          uint64_t v24 = __OFSUB__(v22, v21);
          if (v23) {
            break;
          }
          if (v24) {
            break;
          }
          ++v13;
          unint64_t result = v17;
          --v12;
        }
        while (v12);
        return result;
      }
      return 0;
    }
    __int16 v42 = 0;
    uint64_t v43 = a3 + 48;
    v44 = a3 + 55;
    unsigned __int8 v45 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v43 = 58;
    }
    else
    {
      unsigned __int8 v45 = 97;
      v44 = 65;
    }
    do
    {
      unsigned __int8 v46 = *v5;
      if (v46 < 0x30 || v46 >= v43)
      {
        if (v46 < 0x41 || v46 >= v44)
        {
          unint64_t result = 0;
          if (v46 < 0x61 || v46 >= v45) {
            return result;
          }
          unsigned __int8 v47 = -87;
        }
        else
        {
          unsigned __int8 v47 = -55;
        }
      }
      else
      {
        unsigned __int8 v47 = -48;
      }
      unint64_t result = 0;
      uint64_t v48 = v46 + v47;
      unint64_t v49 = v42 * a3;
      unint64_t v50 = (unsigned __int128)(v42 * (__int128)a3) >> 64 != (v42 * a3) >> 63;
      __int16 v42 = v42 * a3 + v48;
      unsigned int v51 = __OFADD__(v49, v48);
      if (v50) {
        break;
      }
      if (v51) {
        break;
      }
      ++v5;
      unint64_t result = v42;
      --v4;
    }
    while (v4);
  }
  return result;
}

unint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)(unsigned __int8 *a1, uint64_t a2, int64_t a3)
{
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    uint64_t v26 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v30 = specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
    if (!v31) {
      return 0;
    }
    unsigned int v32 = (unsigned __int8 *)v30;
    unsigned __int8 v33 = a3 + 48;
    unsigned __int8 v34 = a3 + 55;
    unsigned __int8 v35 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v33 = 58;
    }
    else
    {
      unsigned __int8 v35 = 97;
      unsigned __int8 v34 = 65;
    }
    if (!v30) {
      return 0;
    }
    unint64_t v36 = 0;
    do
    {
      unsigned int v37 = *v32;
      if (v37 < 0x30 || v37 >= v33)
      {
        if (v37 < 0x41 || v37 >= v34)
        {
          unint64_t result = 0;
          if (v37 < 0x61 || v37 >= v35) {
            return result;
          }
          char v38 = -87;
        }
        else
        {
          char v38 = -55;
        }
      }
      else
      {
        char v38 = -48;
      }
      unint64_t result = 0;
      unsigned __int8 v39 = v37 + v38;
      BOOL v40 = !is_mul_ok(v36, a3);
      unint64_t v41 = v36 * a3;
      BOOL v24 = __CFADD__(v41, v39);
      unint64_t v36 = v41 + v39;
      char v42 = v24;
      if (v40) {
        break;
      }
      if (v42) {
        break;
      }
      ++v32;
      unint64_t result = v36;
      --v31;
    }
    while (v31);
  }
  else
  {
    if (v6 == 45)
    {
      uint64_t v7 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
      uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
      if (!v12) {
        return 0;
      }
      uint64_t v13 = (unsigned __int8 *)v11;
      unsigned __int8 v14 = a3 + 48;
      unsigned __int8 v15 = a3 + 55;
      unsigned __int8 v16 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v14 = 58;
      }
      else
      {
        unsigned __int8 v16 = 97;
        unsigned __int8 v15 = 65;
      }
      if (v11)
      {
        unint64_t v17 = 0;
        do
        {
          unsigned int v18 = *v13;
          if (v18 < 0x30 || v18 >= v14)
          {
            if (v18 < 0x41 || v18 >= v15)
            {
              unint64_t result = 0;
              if (v18 < 0x61 || v18 >= v16) {
                return result;
              }
              char v19 = -87;
            }
            else
            {
              char v19 = -55;
            }
          }
          else
          {
            char v19 = -48;
          }
          unint64_t result = 0;
          unsigned __int8 v21 = v18 + v19;
          BOOL v22 = !is_mul_ok(v17, a3);
          unint64_t v23 = v17 * a3;
          BOOL v24 = v23 >= v21;
          unint64_t v17 = v23 - v21;
          char v25 = !v24;
          if (v22) {
            break;
          }
          if (v25) {
            break;
          }
          ++v13;
          unint64_t result = v17;
          --v12;
        }
        while (v12);
        return result;
      }
      return 0;
    }
    unint64_t v43 = 0;
    unsigned __int8 v44 = a3 + 48;
    unsigned __int8 v45 = a3 + 55;
    unsigned __int8 v46 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v44 = 58;
    }
    else
    {
      unsigned __int8 v46 = 97;
      unsigned __int8 v45 = 65;
    }
    do
    {
      unsigned int v47 = *v5;
      if (v47 < 0x30 || v47 >= v44)
      {
        if (v47 < 0x41 || v47 >= v45)
        {
          unint64_t result = 0;
          if (v47 < 0x61 || v47 >= v46) {
            return result;
          }
          char v48 = -87;
        }
        else
        {
          char v48 = -55;
        }
      }
      else
      {
        char v48 = -48;
      }
      unint64_t result = 0;
      unsigned __int8 v49 = v47 + v48;
      BOOL v50 = !is_mul_ok(v43, a3);
      unint64_t v51 = v43 * a3;
      BOOL v24 = __CFADD__(v51, v49);
      unint64_t v43 = v51 + v49;
      char v52 = v24;
      if (v50) {
        break;
      }
      if (v52) {
        break;
      }
      ++v5;
      unint64_t result = v43;
      --v4;
    }
    while (v4);
  }
  return result;
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int v20;
  char v21;
  unint64_t result;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  unint64_t v26;
  BOOL v27;
  BOOL v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unsigned __int8 v45;
  unsigned __int8 v46;
  unsigned __int8 v47;
  unint64_t v48;
  unsigned int v49;
  char v50;
  BOOL v51;
  BOOL v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  BOOL v56;
  unint64_t v57;
  BOOL v58;
  int v59;
  unsigned int v60;
  char v61;
  BOOL v62;
  BOOL v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  BOOL v67;
  unint64_t v68;
  int v69;

  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    uint64_t v30 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    unsigned __int8 v34 = specialized UnsafeBufferPointer.init(rebasing:)(v30, v31, v32, v33);
    if (v35)
    {
      unint64_t v36 = (unsigned __int8 *)v34;
      unsigned int v37 = a3 + 48;
      char v38 = a3 + 55;
      unsigned __int8 v39 = a3 + 87;
      if (a3 > 10)
      {
        unsigned int v37 = 58;
      }
      else
      {
        unsigned __int8 v39 = 97;
        char v38 = 65;
      }
      if (!v34) {
        return 0;
      }
      BOOL v40 = 0;
      unint64_t v41 = 0;
      char v42 = a3 >> 63;
      while (1)
      {
        unint64_t v60 = *v36;
        if (v60 < 0x30 || v60 >= v37)
        {
          if (v60 < 0x41 || v60 >= v38)
          {
            unint64_t result = 0;
            if (v60 < 0x61 || v60 >= v39) {
              return result;
            }
            unint64_t v61 = -87;
          }
          else
          {
            unint64_t v61 = -55;
          }
        }
        else
        {
          unint64_t v61 = -48;
        }
        unint64_t result = 0;
        BOOL v62 = !is_mul_ok(v41, a3);
        unint64_t v63 = !is_mul_ok(v40, v42);
        uint64_t v64 = __CFADD__(v41 * a3, v40 * v42);
        unsigned __int8 v65 = (a3 * __PAIR128__(v41, v40)) >> 64;
        unsigned __int8 v66 = __CFADD__(v41 * a3 + v40 * v42, (v40 * (unsigned __int128)(unint64_t)a3) >> 64);
        unsigned __int8 v67 = a3 >= 0 || v41 == 0;
        if (!v67 || v62 || v63 || v64) {
          break;
        }
        unint64_t v68 = v40 * a3;
        unint64_t v58 = __CFADD__(v68, (v60 + v61));
        BOOL v40 = v68 + (v60 + v61);
        unint64_t v69 = v58;
        if (v65 == -1)
        {
          if ((v69 | v66)) {
            return 0;
          }
          unint64_t v41 = -1;
        }
        else if (v69)
        {
          if (v66) {
            return 0;
          }
          unint64_t v41 = v65 + 1;
        }
        else
        {
          unint64_t v41 = v65;
          if (v66) {
            return 0;
          }
        }
        ++v36;
        if (!--v35) {
          return v40;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else if (v6 == 45)
  {
    uint64_t v7 = specialized Collection.subscript.getter(1, (uint64_t)a1, v4);
    uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
    if (v12)
    {
      uint64_t v13 = (unsigned __int8 *)v11;
      unsigned __int8 v14 = a3 + 48;
      unsigned __int8 v15 = a3 + 55;
      unsigned __int8 v16 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v14 = 58;
      }
      else
      {
        unsigned __int8 v16 = 97;
        unsigned __int8 v15 = 65;
      }
      if (v11)
      {
        unint64_t v17 = 0;
        unsigned int v18 = 0;
        char v19 = a3 >> 63;
        while (1)
        {
          unsigned __int8 v20 = *v13;
          if (v20 < 0x30 || v20 >= v14)
          {
            if (v20 < 0x41 || v20 >= v15)
            {
              unint64_t result = 0;
              if (v20 < 0x61 || v20 >= v16) {
                return result;
              }
              unsigned __int8 v21 = -87;
            }
            else
            {
              unsigned __int8 v21 = -55;
            }
          }
          else
          {
            unsigned __int8 v21 = -48;
          }
          unint64_t result = 0;
          unint64_t v23 = !is_mul_ok(v18, a3);
          BOOL v24 = !is_mul_ok(v17, v19);
          char v25 = __CFADD__(v18 * a3, v17 * v19);
          uint64_t v26 = (a3 * __PAIR128__(v18, v17)) >> 64;
          uint64_t v27 = __CFADD__(v18 * a3 + v17 * v19, (v17 * (unsigned __int128)(unint64_t)a3) >> 64);
          uint64_t v28 = a3 >= 0 || v18 == 0;
          if (!v28 || v23 || v24 || v25) {
            return result;
          }
          uint64_t v29 = v17 * a3;
          unint64_t result = v29 - (v20 + v21);
          if (v29 < (v20 + v21)) {
            break;
          }
          if (v26) {
            goto LABEL_37;
          }
          if (v27) {
            return 0;
          }
LABEL_38:
          ++v13;
          unint64_t v17 = v29 - (v20 + v21);
          unsigned int v18 = v26;
          if (!--v12) {
            return result;
          }
        }
        if (!v26) {
          return 0;
        }
        --v26;
LABEL_37:
        if (v27) {
          return 0;
        }
        goto LABEL_38;
      }
      return 0;
    }
    return 0;
  }
  else
  {
    unint64_t v43 = 0;
    unsigned __int8 v44 = 0;
    unsigned __int8 v45 = a3 + 48;
    unsigned __int8 v46 = a3 + 55;
    unsigned int v47 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }
    else
    {
      unsigned int v47 = 97;
      unsigned __int8 v46 = 65;
    }
    char v48 = a3 >> 63;
    while (1)
    {
      unsigned __int8 v49 = *v5;
      if (v49 < 0x30 || v49 >= v45)
      {
        if (v49 < 0x41 || v49 >= v46)
        {
          unint64_t result = 0;
          if (v49 < 0x61 || v49 >= v47) {
            return result;
          }
          BOOL v50 = -87;
        }
        else
        {
          BOOL v50 = -55;
        }
      }
      else
      {
        BOOL v50 = -48;
      }
      unint64_t result = 0;
      unint64_t v51 = !is_mul_ok(v44, a3);
      char v52 = !is_mul_ok(v43, v48);
      unsigned long long v53 = __CFADD__(v44 * a3, v43 * v48);
      BOOL v54 = (a3 * __PAIR128__(v44, v43)) >> 64;
      v55 = __CFADD__(v44 * a3 + v43 * v48, (v43 * (unsigned __int128)(unint64_t)a3) >> 64);
      v56 = a3 >= 0 || v44 == 0;
      if (!v56 || v51 || v52 || v53) {
        break;
      }
      char v57 = v43 * a3;
      unint64_t v58 = __CFADD__(v57, (v49 + v50));
      unint64_t v43 = v57 + (v49 + v50);
      char v59 = v58;
      if (v54 == -1)
      {
        if ((v59 | v55)) {
          return 0;
        }
        unsigned __int8 v44 = -1;
      }
      else if (v59)
      {
        if (v55) {
          return 0;
        }
        unsigned __int8 v44 = v54 + 1;
      }
      else
      {
        unsigned __int8 v44 = v54;
        if (v55) {
          return 0;
        }
      }
      ++v5;
      if (!--v4) {
        return v43;
      }
    }
  }
  return result;
}

Swift::UInt64 specialized closure #1 in _parseInteger<A, B>(ascii:radix:)(unsigned __int8 *a1, uint64_t a2, Swift::_Int128 by)
{
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  uint64_t low = by.low;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 != 43)
  {
    if (v6 != 45)
    {
      if ((uint64_t)by.low <= 10) {
        unsigned __int8 v37 = 97;
      }
      else {
        unsigned __int8 v37 = LOBYTE(by.low) + 87;
      }
      if ((uint64_t)by.low <= 10) {
        unsigned __int8 v38 = 65;
      }
      else {
        unsigned __int8 v38 = LOBYTE(by.low) + 55;
      }
      if ((uint64_t)by.low <= 10) {
        unsigned __int8 v39 = LOBYTE(by.low) + 48;
      }
      else {
        unsigned __int8 v39 = 58;
      }
      while (1)
      {
        unsigned int v40 = *v5;
        if (v40 < 0x30 || v40 >= v39)
        {
          if (v40 < 0x41 || v40 >= v38)
          {
            v20.partialValue.uint64_t low = 0;
            if (v40 < 0x61 || v40 >= v37) {
              return v20.partialValue.low;
            }
            char v41 = -87;
          }
          else
          {
            char v41 = -55;
          }
        }
        else
        {
          char v41 = -48;
        }
        unsigned __int8 v42 = v40 + v41;
        v43.uint64_t low = low;
        v43.high = low >> 63;
        Swift::tuple_partialValue__Int128_overflow_Bool v20 = _Int128.multipliedReportingOverflow(by:)(v43);
        int v44 = *(_DWORD *)&v20.overflow;
        *(void *)&v20.overfuint64_t low = v20.partialValue.low + v42;
        BOOL v46 = __CFADD__(v20.partialValue.low, v42);
        if (v20.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
        {
          if ((v46 | v44)) {
            goto LABEL_97;
          }
        }
        else if (v46)
        {
          if (v44) {
            goto LABEL_97;
          }
        }
        else if (v44)
        {
          goto LABEL_97;
        }
        ++v5;
        if (!--v4) {
          goto LABEL_98;
        }
      }
    }
    uint64_t v7 = specialized Collection.subscript.getter(1, (uint64_t)a1, a2);
    uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
    if (!v12)
    {
      v20.partialValue.uint64_t low = 0;
      return v20.partialValue.low;
    }
    uint64_t v13 = (unsigned __int8 *)v11;
    if (low <= 10) {
      unsigned __int8 v14 = 97;
    }
    else {
      unsigned __int8 v14 = low + 87;
    }
    if (low <= 10) {
      unsigned __int8 v15 = 65;
    }
    else {
      unsigned __int8 v15 = low + 55;
    }
    if (low <= 10) {
      unsigned __int8 v16 = low + 48;
    }
    else {
      unsigned __int8 v16 = 58;
    }
    if (v11)
    {
      uint64_t v17 = v12;
      do
      {
        unsigned int v18 = *v13;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v15)
          {
            v20.partialValue.uint64_t low = 0;
            if (v18 < 0x61 || v18 >= v14) {
              return v20.partialValue.low;
            }
            char v19 = -87;
          }
          else
          {
            char v19 = -55;
          }
        }
        else
        {
          char v19 = -48;
        }
        unsigned __int8 v21 = v18 + v19;
        v22.uint64_t low = low;
        v22.high = low >> 63;
        Swift::tuple_partialValue__Int128_overflow_Bool v20 = _Int128.multipliedReportingOverflow(by:)(v22);
        BOOL v24 = v20.partialValue.low >= v21;
        v20.partialValue.low -= v21;
        int v25 = !v24;
        if (v20.partialValue.high == 0x8000000000000000)
        {
          if ((*(_DWORD *)&v20.overflow | v25)) {
            goto LABEL_97;
          }
        }
        else if (v20.overflow)
        {
          goto LABEL_97;
        }
        ++v13;
        --v17;
      }
      while (v17);
      return v20.partialValue.low;
    }
LABEL_95:
    v20.partialValue.uint64_t low = 0;
    return v20.partialValue.low;
  }
  uint64_t v26 = specialized Collection.subscript.getter(1, (uint64_t)a1, a2);
  uint64_t v30 = specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
  if (!v31)
  {
    v20.partialValue.uint64_t low = 0;
    return v20.partialValue.low;
  }
  unsigned int v32 = (unsigned __int8 *)v30;
  if (low <= 10) {
    unsigned __int8 v33 = 97;
  }
  else {
    unsigned __int8 v33 = low + 87;
  }
  if (low <= 10) {
    unsigned __int8 v34 = 65;
  }
  else {
    unsigned __int8 v34 = low + 55;
  }
  if (low <= 10) {
    unsigned __int8 v35 = low + 48;
  }
  else {
    unsigned __int8 v35 = 58;
  }
  if (!v30) {
    goto LABEL_95;
  }
  uint64_t v36 = v31;
  do
  {
    unsigned int v47 = *v32;
    if (v47 < 0x30 || v47 >= v35)
    {
      if (v47 < 0x41 || v47 >= v34)
      {
        v20.partialValue.uint64_t low = 0;
        if (v47 < 0x61 || v47 >= v33) {
          return v20.partialValue.low;
        }
        char v48 = -87;
      }
      else
      {
        char v48 = -55;
      }
    }
    else
    {
      char v48 = -48;
    }
    unsigned __int8 v49 = v47 + v48;
    v50.uint64_t low = low;
    v50.high = low >> 63;
    Swift::tuple_partialValue__Int128_overflow_Bool v20 = _Int128.multipliedReportingOverflow(by:)(v50);
    int v51 = *(_DWORD *)&v20.overflow;
    *(void *)&v20.overfuint64_t low = v20.partialValue.low + v49;
    BOOL v52 = __CFADD__(v20.partialValue.low, v49);
    if (v20.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
    {
      if ((v52 | v51)) {
        goto LABEL_97;
      }
    }
    else if (v52)
    {
      if (v51)
      {
LABEL_97:
        v20.partialValue.uint64_t low = 0;
        return v20.partialValue.low;
      }
    }
    else if (v51)
    {
      goto LABEL_97;
    }
    ++v32;
    --v36;
  }
  while (v36);
LABEL_98:
  v20.partialValue.uint64_t low = *(void *)&v20.overflow;
  return v20.partialValue.low;
}

uint64_t closure #1 in _parseInteger<A, B>(ascii:radix:)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X8>)
{
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  int v10 = *a1;
  if (v10 == 43)
  {
    uint64_t v18 = specialized Collection.subscript.getter(1, (uint64_t)a1, a2);
    a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v18, v19, v20, v21);
    uint64_t v15 = a6;
LABEL_7:
    uint64_t v16 = a3;
    int v17 = 0;
    return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
  }
  if (v10 != 45)
  {
    uint64_t v15 = a6;
    goto LABEL_7;
  }
  uint64_t v11 = specialized Collection.subscript.getter(1, (uint64_t)a1, a2);
  a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v11, v12, v13, v14);
  uint64_t v15 = a6;
  uint64_t v16 = a3;
  int v17 = 1;
  return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
}

uint64_t FixedWidthInteger.init<A>(_:radix:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, Class *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v67 = a5;
  uint64_t v68 = a1;
  uint64_t v65 = a7;
  uint64_t v64 = (uint64_t)*(a4 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v56 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v13, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UTF8View);
  uint64_t v63 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v56 - v15;
  uint64_t v19 = type metadata accessor for Optional(255, a3, v17, v18);
  Swift::_Int128 v22 = type metadata accessor for Optional(0, (uint64_t)v19, v20, v21);
  uint64_t v23 = MEMORY[0x1F4188790](v22);
  int v25 = (char *)&v56 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v28 = (char *)&v56 - v27;
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  uint64_t v30 = MEMORY[0x1F4188790](v29);
  if ((unint64_t)(a2 - 37) <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Radix not in range 2...36", 25, 2, "Swift/IntegerParsing.swift", 26, 2, 0x80uLL, 0);
  }
  uint64_t v56 = (uint64_t)&v56 - v31;
  uint64_t v57 = v34;
  uint64_t v58 = v30;
  char v59 = v12;
  uint64_t v60 = v33;
  uint64_t v61 = v32;
  uint64_t v62 = a2;
  uint64_t v36 = v67;
  uint64_t v35 = v68;
  uint64_t v66 = a3;
  if ((*(uint64_t (**)(Class *))(*(void *)(*(void *)(a6 + 8) + 8) + 104))(a4))
  {
    (*(void (**)(uint64_t, Class *))(v64 + 8))(v35, a4);
    uint64_t v46 = v66;
    uint64_t v48 = *(void *)(v66 - 8);
  }
  else
  {
    uint64_t v37 = (*(uint64_t (**)(Class *, uint64_t))(a6 + 120))(a4, a6);
    MEMORY[0x1F4188790](v37);
    *(&v56 - 6) = v66;
    *(&v56 - 5) = (uint64_t)a4;
    uint64_t v53 = v36;
    uint64_t v54 = a6;
    uint64_t v55 = v62;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, (uint64_t)a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated conformance descriptor for StringProtocol.StringProtocol.UTF8View: Collection);
    (*(void (**)(uint64_t (*)@<X0>(unsigned __int8 *@<X0>, uint64_t@<X1>, uint64_t@<X8>), uint64_t *, Class *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 72))(partial apply for closure #1 in FixedWidthInteger.init<A>(_:radix:), &v56 - 8, v19, AssociatedTypeWitness);
    (*(void (**)(char *, const char *))(v63 + 8))(v16, AssociatedTypeWitness);
    uint64_t v39 = v64;
    uint64_t v40 = (uint64_t)v59;
    (*(void (**)(char *, uint64_t, Class *))(v64 + 32))(v59, v68, a4);
    uint64_t v42 = v57;
    uint64_t v41 = v58;
    (*(void (**)(char *, char *, uint64_t))(v57 + 32))(v25, v28, v58);
    uint64_t v43 = v61;
    if ((*(unsigned int (**)(char *, uint64_t, Class *))(v61 + 48))(v25, 1, v19) == 1)
    {
      uint64_t v44 = v56;
      _parseInteger<A, B>(ascii:radix:)(v40, v62, a4, v66, a6, v67, v56);
      (*(void (**)(uint64_t, Class *))(v39 + 8))(v40, a4);
      (*(void (**)(char *, uint64_t))(v42 + 8))(v25, v41);
      unsigned __int8 v45 = *(void (**)(uint64_t, char *, Class *))(v43 + 32);
    }
    else
    {
      (*(void (**)(uint64_t, Class *))(v39 + 8))(v40, a4);
      unsigned __int8 v45 = *(void (**)(uint64_t, char *, Class *))(v43 + 32);
      uint64_t v44 = v56;
      v45(v56, v25, v19);
    }
    uint64_t v46 = v66;
    uint64_t v47 = v60;
    v45(v60, (char *)v44, v19);
    uint64_t v48 = *(void *)(v46 - 8);
    uint64_t v49 = v48;
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v48 + 48))(v47, 1, v46) != 1)
    {
      uint64_t v51 = v65;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v49 + 32))(v65, v47, v46);
      uint64_t v50 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v49 + 56))(v51, v50, 1, v46);
    }
    (*(void (**)(uint64_t, Class *))(v43 + 8))(v47, v19);
  }
  uint64_t v49 = v48;
  uint64_t v50 = 1;
  uint64_t v51 = v65;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v49 + 56))(v51, v50, 1, v46);
}

uint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  v173 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a4, (uint64_t)&type metadata for Bool, 0, 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  v175 = (char *)&v158 - v12;
  uint64_t v178 = *(void *)(a5 + 8);
  uint64_t v179 = a5;
  v172 = *(int ***)(*(void *)(v178 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v172, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v14 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v180 = a4;
  uint64_t v177 = *(void *)(a4 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v14);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v158 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  MEMORY[0x1F4188790](v19);
  uint64_t v21 = MEMORY[0x1F4188790]((char *)&v158 - v20);
  uint64_t v23 = (char *)&v158 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  v176 = (char *)&v158 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v174 = (char *)&v158 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v30 = (void (**)(char *, char *, uint64_t))((char *)&v158 - v29);
  uint64_t v31 = MEMORY[0x1F4188790](v28);
  uint64_t v33 = (char *)&v158 - v32;
  uint64_t v34 = MEMORY[0x1F4188790](v31);
  uint64_t v38 = a2;
  uint64_t v40 = (char *)&v158 - v39;
  if (v38 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  int v41 = *a1;
  uint64_t v42 = (uint64_t)a1;
  v171 = v37;
  if (v41 == 43)
  {
    v169 = v36;
    v176 = v35;
    uint64_t v83 = specialized Collection.subscript.getter(1, (uint64_t)a1, v38);
    uint64_t v87 = specialized UnsafeBufferPointer.init(rebasing:)(v83, v84, v85, v86);
    if (v88)
    {
      uint64_t v90 = (char *)v87;
      uint64_t v91 = v88;
      int v92 = a3 + 48;
      int v93 = a3 + 55;
      int v94 = a3 + 87;
      if (a3 <= 10) {
        int v94 = 97;
      }
      int v159 = v94;
      if (a3 <= 10) {
        int v93 = 65;
      }
      int v160 = v93;
      uint64_t v181 = a3;
      if (a3 > 10) {
        int v92 = 58;
      }
      LODWORD(v165) = v92;
      uint64_t v95 = v178;
      uint64_t v96 = v178 + 96;
      v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v178 + 96);
      unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v87, v88, v89);
      uint64_t v99 = v180;
      v167 = v97;
      uint64_t v168 = v96;
      v97(&v181, &type metadata for Int, v98, v180, v95);
      v100 = v172;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v172, v99, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v102 = v171;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v103 = v100[3];
      v170 = (unsigned __int8 *)v18;
      uint64_t v104 = ((uint64_t (*)(void, uint64_t, int **))v103)(v102, v99, v100);
      if (v90)
      {
        v172 = (int **)(v177 + 8);
        uint64_t v163 = v179 + 80;
        v164 = (char **)(v177 + 32);
        uint64_t v158 = v179 + 96;
        v107 = v170;
        v108 = (void (**)(unsigned __int8 *, uint64_t))(v177 + 8);
        do
        {
          unsigned int v109 = *v90;
          if (v109 < 0x30 || v109 >= v165)
          {
            if (v109 < 0x41 || v109 >= v160)
            {
              if (v109 < 0x61 || v109 >= v159)
              {
                uint64_t v153 = v177;
                v154 = *(void (**)(unsigned __int8 *, uint64_t))(v177 + 8);
                v155 = (char *)v170;
                goto LABEL_80;
              }
              v161 = (unsigned __int8 *)v91;
              v162 = v90;
              char v110 = v109 - 87;
            }
            else
            {
              v161 = (unsigned __int8 *)v91;
              v162 = v90;
              char v110 = v109 - 55;
            }
            LOBYTE(v181) = v110;
          }
          else
          {
            v161 = (unsigned __int8 *)v91;
            v162 = v90;
            LOBYTE(v181) = v109 - 48;
          }
          unint64_t v111 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v104, v105, v106);
          uint64_t v112 = v180;
          v113 = v169;
          v167(&v181, &type metadata for UInt8, v111, v180, v178);
          uint64_t v114 = v179;
          v115 = v174;
          LODWORD(v171) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v179 + 96))(v174, v176, v112, v179);
          v116 = *v108;
          (*v108)(v107, v112);
          v166 = (void (*)(unsigned __int8 *, char *, uint64_t))*v164;
          v166(v107, v115, v112);
          char v117 = (*(uint64_t (**)(char *, void (**)(char *, char *, uint64_t), uint64_t, uint64_t))(v114 + 80))(v115, v113, v112, v114);
          v116((unsigned __int8 *)v113, v112);
          v116(v107, v112);
          v118 = v175;
          v119 = v115;
          v120 = (uint64_t (*)(unsigned __int8 *, char *, uint64_t))v166;
          v166((unsigned __int8 *)v175, v119, v112);
          uint64_t v104 = v120(v107, v118, v112);
          if (v171 & 1) != 0 || (v117)
          {
            uint64_t v150 = v180;
            v116(v107, v180);
            v116((unsigned __int8 *)v176, v150);
            return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v177 + 56))(v173, 1, 1, v150);
          }
          uint64_t v90 = v162 + 1;
          uint64_t v91 = (uint64_t)(v161 - 1);
        }
        while (v161 != (unsigned __int8 *)1);
      }
      uint64_t v80 = v177;
      uint64_t v81 = v180;
      (*(void (**)(char *, uint64_t))(v177 + 8))(v176, v180);
      v82 = v173;
      (*(void (**)(char *, unsigned __int8 *, uint64_t))(v80 + 32))(v173, v170, v81);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v80 + 56))(v82, 0, 1, v81);
    }
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v177 + 56))(v173, 1, 1, v180);
  }
  if (v41 == 45)
  {
    v169 = v30;
    uint64_t v43 = specialized Collection.subscript.getter(1, (uint64_t)a1, v38);
    uint64_t v47 = specialized UnsafeBufferPointer.init(rebasing:)(v43, v44, v45, v46);
    if (v48)
    {
      uint64_t v50 = (unsigned __int8 *)v47;
      v166 = (void (*)(unsigned __int8 *, char *, uint64_t))v48;
      int v51 = a3 + 48;
      int v52 = a3 + 55;
      int v53 = a3 + 87;
      if (a3 <= 10) {
        int v53 = 97;
      }
      int v159 = v53;
      if (a3 <= 10) {
        int v52 = 65;
      }
      int v160 = v52;
      uint64_t v181 = a3;
      if (a3 > 10) {
        int v51 = 58;
      }
      LODWORD(v165) = v51;
      uint64_t v54 = v178;
      v170 = (unsigned __int8 *)v33;
      uint64_t v55 = v172;
      uint64_t v56 = v178 + 96;
      uint64_t v57 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v178 + 96);
      unint64_t v58 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
      uint64_t v59 = v180;
      v167 = v57;
      uint64_t v168 = v56;
      v57(&v181, &type metadata for Int, v58, v180, v54);
      uint64_t v60 = swift_getAssociatedConformanceWitness((uint64_t)v55, v59, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v61 = v171;
      (*(void (**)(void *, uint64_t, const char *, uint64_t))(v60 + 8))(&unk_18162B0B8, 256, AssociatedTypeWitness, v60);
      uint64_t v62 = v170;
      uint64_t v63 = ((uint64_t (*)(void, uint64_t, int **))v55[3])(v61, v59, v55);
      if (v50)
      {
        v176 = (char *)(v177 + 8);
        v164 = (char **)(v177 + 32);
        v162 = v40;
        uint64_t v158 = v179 + 96;
        uint64_t v163 = v179 + 88;
        uint64_t v66 = (void (**)(void, void, void))(v177 + 32);
        do
        {
          unsigned int v67 = *v50;
          if (v67 < 0x30 || v67 >= v165)
          {
            if (v67 < 0x41 || v67 >= v160)
            {
              if (v67 < 0x61 || v67 >= v159)
              {
                uint64_t v153 = v177;
                v154 = *(void (**)(unsigned __int8 *, uint64_t))(v177 + 8);
                uint64_t v156 = v180;
                v154(v62, v180);
                v157 = v40;
                goto LABEL_81;
              }
              v161 = v50;
              char v68 = v67 - 87;
            }
            else
            {
              v161 = v50;
              char v68 = v67 - 55;
            }
            LOBYTE(v181) = v68;
          }
          else
          {
            v161 = v50;
            LOBYTE(v181) = v67 - 48;
          }
          unint64_t v69 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v63, v64, v65);
          unsigned int v70 = v169;
          ((void (*)(uint64_t *, ValueMetadata *, unint64_t))v167)(&v181, &type metadata for UInt8, v69);
          uint64_t v71 = v179;
          uint64_t v72 = v180;
          BOOL v73 = v174;
          v74 = v170;
          LODWORD(v172) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v179 + 96))(v174, v40, v180, v179);
          uint64_t v75 = *(void (**)(void (**)(char *, char *, uint64_t), uint64_t))v176;
          (*(void (**)(unsigned __int8 *, uint64_t))v176)(v74, v72);
          v171 = *v66;
          v171(v74, v73, v72);
          char v76 = (*(uint64_t (**)(char *, void (**)(char *, char *, uint64_t), uint64_t, uint64_t))(v71 + 88))(v73, v70, v72, v71);
          v75(v70, v72);
          v75((void (**)(char *, char *, uint64_t))v74, v72);
          unint64_t v77 = v175;
          unint64_t v78 = v73;
          uint64_t v62 = v74;
          unint64_t v79 = (uint64_t (*)(unsigned __int8 *, char *, uint64_t))v171;
          v171(v175, v78, v72);
          uint64_t v63 = v79(v62, v77, v72);
          if (v172 & 1) != 0 || (v76)
          {
            uint64_t v150 = v180;
            v75((void (**)(char *, char *, uint64_t))v62, v180);
            v75((void (**)(char *, char *, uint64_t))v162, v150);
            return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v177 + 56))(v173, 1, 1, v150);
          }
          uint64_t v40 = v162;
          uint64_t v50 = v161 + 1;
          v166 = (void (*)(unsigned __int8 *, char *, uint64_t))((char *)v166 - 1);
        }
        while (v166);
      }
      uint64_t v80 = v177;
      uint64_t v81 = v180;
      (*(void (**)(char *, uint64_t))(v177 + 8))(v40, v180);
      v82 = v173;
      (*(void (**)(char *, unsigned __int8 *, uint64_t))(v80 + 32))(v173, v62, v81);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v80 + 56))(v82, 0, 1, v81);
    }
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v177 + 56))(v173, 1, 1, v180);
  }
  v166 = (void (*)(unsigned __int8 *, char *, uint64_t))v34;
  uint64_t v163 = v38;
  int v122 = a3 + 55;
  int v123 = a3 + 87;
  if (a3 <= 10) {
    int v123 = 97;
  }
  int v160 = v123;
  if (a3 <= 10) {
    int v122 = 65;
  }
  LODWORD(v161) = v122;
  uint64_t v181 = a3;
  if (a3 <= 10) {
    int v124 = a3 + 48;
  }
  else {
    int v124 = 58;
  }
  uint64_t v125 = v178;
  uint64_t v127 = v178 + 96;
  v126 = *(char ***)(v178 + 96);
  v170 = (unsigned __int8 *)v42;
  unint64_t v128 = lazy protocol witness table accessor for type Int and conformance Int(v34, v42, v38);
  uint64_t v129 = v180;
  v164 = v126;
  uint64_t v165 = v127;
  ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v126)(&v181, &type metadata for Int, v128, v180, v125);
  v130 = v172;
  uint64_t v131 = swift_getAssociatedConformanceWitness((uint64_t)v172, v129, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v132 = v171;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v131 + 8))(&unk_18162B0B8, 256, AssociatedTypeWitness, v131);
  uint64_t v133 = ((uint64_t (*)(void, uint64_t, int **))v130[3])(v132, v129, v130);
  v136 = v170;
  uint64_t v137 = v180;
  uint64_t v168 = v179 + 96;
  v172 = (int **)(v177 + 8);
  v169 = (void (**)(char *, char *, uint64_t))(v177 + 32);
  v167 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v179 + 80);
  LODWORD(v162) = v124;
  while (1)
  {
    unsigned int v138 = *v136;
    if (v138 < 0x30 || v138 >= v124) {
      break;
    }
    v170 = v136;
    LOBYTE(v181) = v138 - 48;
LABEL_69:
    unint64_t v140 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v133, v134, v135);
    v141 = (char *)v166;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t))v164)(&v181, &type metadata for UInt8, v140);
    uint64_t v142 = v179;
    v143 = v174;
    LODWORD(v171) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v179 + 96))(v174, v176, v137, v179);
    v144 = *v172;
    ((void (*)(char *, uint64_t))*v172)(v23, v137);
    v145 = *v169;
    (*v169)(v23, v143, v137);
    char v146 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v142 + 80))(v143, v141, v137, v142);
    v147 = v141;
    char v148 = v146;
    ((void (*)(char *, uint64_t))v144)(v147, v137);
    ((void (*)(char *, uint64_t))v144)(v23, v137);
    v149 = v175;
    v145(v175, v143, v137);
    uint64_t v150 = v137;
    uint64_t v133 = ((uint64_t (*)(char *, char *, uint64_t))v145)(v23, v149, v137);
    if (v171 & 1) != 0 || (v148)
    {
      ((void (*)(char *, uint64_t))v144)(v23, v137);
      ((void (*)(char *, uint64_t))v144)(v176, v137);
      return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v177 + 56))(v173, 1, 1, v150);
    }
    v136 = v170 + 1;
    --v163;
    LOBYTE(v124) = (_BYTE)v162;
    if (!v163)
    {
      uint64_t v151 = v180;
      ((void (*)(char *, uint64_t))v144)(v176, v180);
      v152 = v173;
      v145(v173, v23, v151);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v177 + 56))(v152, 0, 1, v151);
    }
  }
  if (v138 >= 0x41 && v138 < v161)
  {
    v170 = v136;
    char v139 = v138 - 55;
LABEL_68:
    LOBYTE(v181) = v139;
    goto LABEL_69;
  }
  if (v138 >= 0x61 && v138 < v160)
  {
    v170 = v136;
    char v139 = v138 - 87;
    goto LABEL_68;
  }
  uint64_t v153 = v177;
  v154 = *(void (**)(unsigned __int8 *, uint64_t))(v177 + 8);
  v155 = v23;
LABEL_80:
  uint64_t v156 = v180;
  v154((unsigned __int8 *)v155, v180);
  v157 = v176;
LABEL_81:
  v154((unsigned __int8 *)v157, v156);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v153 + 56))(v173, 1, 1, v156);
}

uint64_t closure #1 in FixedWidthInteger.init<A>(_:radix:)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  int v10 = *a1;
  if (v10 == 43)
  {
    uint64_t v18 = specialized Collection.subscript.getter(1, (uint64_t)a1, a2);
    a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v18, v19, v20, v21);
    uint64_t v15 = a6;
LABEL_7:
    uint64_t v16 = a3;
    int v17 = 0;
    return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
  }
  if (v10 != 45)
  {
    uint64_t v15 = a6;
    goto LABEL_7;
  }
  uint64_t v11 = specialized Collection.subscript.getter(1, (uint64_t)a1, a2);
  a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v11, v12, v13, v14);
  uint64_t v15 = a6;
  uint64_t v16 = a3;
  int v17 = 1;
  return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
}

Swift::UInt16 __swiftcall _ascii16(_:)(Swift::Unicode::Scalar a1)
{
  if (a1._value >= 0x10000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
  return a1._value;
}

BOOL static UInt32.>= infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a1 >= a2;
}

BOOL static UInt32.<= infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 >= a1;
}

uint64_t _asciiDigit<A, B>(codeUnit:radix:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v55 = a2;
  int v53 = *(int ***)(*(void *)(a6 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v53, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int v51 = (char *)&v51 - v14;
  uint64_t v15 = *(void *)(a4 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v54 = (char *)&v51 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v51 - v19;
  uint64_t v21 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v51 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v23, a1, a3);
  __int16 v24 = (*(uint64_t (**)(uint64_t))(*(void *)(a5 + 8) + 120))(a3);
  (*(void (**)(char *, uint64_t))(v21 + 8))(v23, a3);
  if ((unsigned __int16)(v24 - 58) > 0xFFF5u)
  {
    __int16 v26 = -48;
LABEL_7:
    uint64_t v25 = a7;
    goto LABEL_8;
  }
  if ((unsigned __int16)(v24 - 91) > 0xFFE5u)
  {
    __int16 v26 = -55;
    goto LABEL_7;
  }
  uint64_t v25 = a7;
  if ((unsigned __int16)(v24 - 123) < 0xFFE6u) {
    goto LABEL_21;
  }
  __int16 v26 = -87;
LABEL_8:
  unsigned __int16 v27 = v26 + v24;
  char v28 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6);
  uint64_t v29 = v55;
  uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
  if (v28)
  {
    if (v30 >= 17)
    {
      unsigned __int16 v56 = v27;
      uint64_t v33 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      unint64_t v34 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v30, v31, v32);
      uint64_t v35 = (__int16 *)&v56;
      goto LABEL_13;
    }
    uint64_t v40 = AssociatedTypeWitness;
    int v41 = v53;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v53, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v43 = v51;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v40, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v41[3])(v43, a4, v41);
    LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 40))(v29, v20, a4);
    uint64_t v44 = *(void (**)(char *, uint64_t))(v15 + 8);
    v44(v20, a4);
    uint64_t v45 = v54;
    (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v54, v29, a4);
    if ((v40 & 1) == 0)
    {
      v44(v45, a4);
      goto LABEL_21;
    }
    unsigned __int16 v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    uint64_t v37 = ((uint64_t (*)(char *, uint64_t))v44)(v45, a4);
    goto LABEL_18;
  }
  if (v30 <= 16)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v20, v29, a4);
    unsigned __int16 v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    uint64_t v37 = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v20, a4);
LABEL_18:
    if (v27 < v46) {
      goto LABEL_19;
    }
LABEL_21:
    uint64_t v49 = 1;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 56))(v25, v49, 1, a4);
  }
  unsigned __int16 v57 = v27;
  uint64_t v33 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  unint64_t v34 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v30, v31, v32);
  uint64_t v35 = (__int16 *)&v57;
LABEL_13:
  v33(v35, &type metadata for UInt16, v34, a4, a6);
  char v36 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v20, v29, a4);
  uint64_t v37 = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v20, a4);
  if ((v36 & 1) == 0) {
    goto LABEL_21;
  }
LABEL_19:
  unsigned __int16 v58 = v27;
  uint64_t v47 = *(void (**)(unsigned __int16 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  unint64_t v48 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v37, v38, v39);
  v47(&v58, &type metadata for UInt16, v48, a4, a6);
  uint64_t v49 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 56))(v25, v49, 1, a4);
}

uint64_t UInt16.init(_builtinIntegerLiteral:)(unsigned __int16 *a1, unint64_t a2)
{
  if (a2 >> 9 <= 8 && (a2 & 1) == 0) {
    return *a1;
  }
  else {
    return 0;
  }
}

uint64_t _parseUnsignedASCII<A, B>(first:rest:radix:positive:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X7>, char *a9@<X8>, uint64_t a10)
{
  int v137 = a4;
  uint64_t v139 = a2;
  v141 = a9;
  uint64_t v142 = a1;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a6, (uint64_t)&type metadata for Bool, 0, 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  int v123 = (char *)&v98 - v16;
  uint64_t v131 = a5;
  v132 = a7;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a7, a5, (uint64_t)&protocol requirements base descriptor for IteratorProtocol, associated type descriptor for IteratorProtocol.Element);
  v119 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v18, v19);
  uint64_t v118 = (uint64_t)*(v119 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v119);
  v130 = (char *)&v98 - v21;
  uint64_t v138 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v20);
  v126 = (char *)&v98 - v22;
  uint64_t v135 = a8;
  uint64_t v23 = *(void *)(a8 + 8);
  char v117 = *(int ***)(*(void *)(v23 + 24) + 16);
  v116 = swift_getAssociatedTypeWitness(0, v117, a6, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v24 = MEMORY[0x1F4188790](v116);
  v115 = (char *)&v98 - v25;
  uint64_t v26 = *(void *)(a6 - 8);
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  v120 = (char *)&v98 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  int v122 = (char *)&v98 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v121 = (char *)&v98 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v136 = (char *)&v98 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  unint64_t v128 = (Class *)((char *)&v98 - v36);
  MEMORY[0x1F4188790](v35);
  unint64_t v140 = (char *)&v98 - v37;
  uint64_t v40 = type metadata accessor for Optional(0, a6, v38, v39);
  uint64_t v41 = (uint64_t)*(v40 - 1);
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  int v124 = (char *)&v98 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  uint64_t v133 = (uint64_t)&v98 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  unint64_t v48 = (char *)&v98 - v47;
  MEMORY[0x1F4188790](v46);
  uint64_t v50 = (char *)&v98 - v49;
  uint64_t v134 = a3;
  uint64_t v129 = AssociatedTypeWitness;
  uint64_t v127 = a10;
  uint64_t v125 = v23;
  _asciiDigit<A, B>(codeUnit:radix:)(v142, a3, (uint64_t)AssociatedTypeWitness, a6, a10, v23, (uint64_t)&v98 - v49);
  uint64_t v142 = v26;
  int v51 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v26 + 48);
  if (v51(v50, 1, a6) == 1) {
    goto LABEL_2;
  }
  int v52 = *(void (**)(char *, char *, Class *))(v41 + 16);
  v52(v48, v50, v40);
  if (v51(v48, 1, a6) == 1)
  {
    int v53 = *(void (**)(char *, Class *))(v41 + 8);
    v53(v50, v40);
    v53(v48, v40);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v142 + 56))(v141, 1, 1, a6);
  }
  char v110 = (void (*)(char *, uint64_t, Class *))v52;
  uint64_t v111 = v41 + 16;
  uint64_t v112 = v51;
  v113 = *(void (**)(char *, char *, uint64_t))(v142 + 32);
  uint64_t v54 = v140;
  uint64_t v114 = v142 + 32;
  v113(v140, v48, a6);
  uint64_t v55 = v136;
  if ((v137 & 1) == 0)
  {
    unsigned __int16 v56 = v117;
    unsigned __int16 v57 = v116;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v117, a6, (uint64_t)v116, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v59 = v115;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v57, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v56[3])(v59, a6, v56);
    LOBYTE(v57) = (*(uint64_t (**)(Class *, char *, uint64_t))(v135 + 88))(v128, v54, a6);
    uint64_t v60 = *(void (**)(char *, uint64_t))(v142 + 8);
    v60(v55, a6);
    v60(v54, a6);
    if (v57)
    {
      v60((char *)v128, a6);
LABEL_2:
      (*(void (**)(char *, Class *))(v41 + 8))(v50, v40);
      return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v142 + 56))(v141, 1, 1, a6);
    }
    v113(v54, (char *)v128, a6);
  }
  uint64_t v61 = v132 + 2;
  uint64_t v62 = v130;
  unsigned int v109 = v132[2];
  ((void (*)(uint64_t))v109)(v131);
  uint64_t v63 = v138;
  uint64_t v64 = *(uint64_t (**)(char *, uint64_t, const char *))(v138 + 48);
  uint64_t v65 = (uint64_t)v129;
  uint64_t v108 = v138 + 48;
  v107 = v64;
  if (v64(v62, 1, v129) != 1)
  {
    v101 = v61;
    unint64_t v128 = v40;
    uint64_t v71 = *(void (**)(char *, char *, uint64_t))(v63 + 32);
    uint64_t v70 = v63 + 32;
    unint64_t v69 = v71;
    uint64_t v72 = (void (**)(uint64_t, uint64_t))(v70 - 24);
    uint64_t v105 = v135 + 96;
    char v117 = (int **)(v142 + 8);
    uint64_t v103 = v135 + 88;
    uint64_t v102 = v135 + 80;
    BOOL v73 = (void (**)(uint64_t, char *))(v41 + 8);
    uint64_t v138 = v70;
    uint64_t v106 = (void (**)(uint64_t, char *))(v41 + 8);
    uint64_t v100 = (v41 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    uint64_t v99 = v71;
    unint64_t v98 = (void (**)(uint64_t, uint64_t))(v70 - 24);
    uint64_t v104 = v50;
    while (1)
    {
      uint64_t v74 = (uint64_t)v126;
      v69(v126, v62, v65);
      uint64_t v75 = v133;
      _asciiDigit<A, B>(codeUnit:radix:)(v74, v134, v65, a6, v127, v125, v133);
      (*v72)(v74, v65);
      char v76 = v112;
      if (v112((char *)v75, 1, a6) == 1)
      {
        ((void (*)(char *, uint64_t))*v117)(v140, a6);
        int v94 = *v73;
        uint64_t v95 = v128;
        (*v73)(v75, (char *)v128);
        v94((uint64_t)v50, (char *)v95);
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v142 + 56))(v141, 1, 1, a6);
      }
      unint64_t v77 = v124;
      v110(v124, v75, v128);
      if (v76(v77, 1, a6) == 1) {
        break;
      }
      unint64_t v78 = v121;
      v113(v121, v77, a6);
      uint64_t v79 = v135;
      uint64_t v80 = v122;
      uint64_t v81 = v140;
      int v82 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v135 + 96))(v122, v134, a6, v135);
      uint64_t v83 = *v117;
      ((void (*)(char *, uint64_t))*v117)(v81, a6);
      LODWORD(v116) = v82;
      uint64_t v84 = v136;
      if (v137) {
        int v85 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v79 + 80))(v136, v78, a6, v79);
      }
      else {
        int v85 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v79 + 88))(v136, v78, a6, v79);
      }
      LODWORD(v115) = v85;
      uint64_t v86 = v80;
      uint64_t v87 = v120;
      ((void (*)(char *, uint64_t))v83)(v86, a6);
      ((void (*)(char *, uint64_t))v83)(v78, a6);
      uint64_t v88 = v123;
      uint64_t v89 = v113;
      v113(v123, v84, a6);
      v89(v87, v88, a6);
      uint64_t v90 = v106;
      uint64_t v66 = *v106;
      uint64_t v91 = v87;
      int v92 = v128;
      (*v106)(v133, (char *)v128);
      if ((v116 | v115))
      {
        ((void (*)(char *, uint64_t))v83)(v91, a6);
        v66((uint64_t)v104, (char *)v92);
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v142 + 56))(v141, 1, 1, a6);
      }
      v89(v140, v91, a6);
      uint64_t v62 = v130;
      ((void (*)(uint64_t, int **))v109)(v131, v132);
      uint64_t v65 = (uint64_t)v129;
      int v93 = v107(v62, 1, v129);
      BOOL v73 = v90;
      unint64_t v69 = v99;
      uint64_t v72 = v98;
      uint64_t v50 = v104;
      if (v93 == 1)
      {
        uint64_t v40 = v128;
        goto LABEL_10;
      }
    }
    ((void (*)(char *, uint64_t))*v117)(v140, a6);
    uint64_t v96 = *v106;
    v97 = v128;
    (*v106)(v75, (char *)v128);
    v96((uint64_t)v50, (char *)v97);
    v96((uint64_t)v77, (char *)v97);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v142 + 56))(v141, 1, 1, a6);
  }
  uint64_t v66 = *(void (**)(uint64_t, char *))(v41 + 8);
LABEL_10:
  v66((uint64_t)v50, (char *)v40);
  (*(void (**)(char *, Class *))(v118 + 8))(v62, v119);
  unsigned int v67 = v141;
  v113(v141, v140, a6);
  return (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v142 + 56))(v67, 0, 1, a6);
}

uint64_t _parseASCII<A, B>(codeUnits:radix:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, char *a8@<X8>)
{
  uint64_t v183 = a2;
  uint64_t v184 = a6;
  v193 = a8;
  uint64_t v194 = a4;
  uint64_t v182 = a7;
  uint64_t v189 = *(void *)(a7 + 8);
  uint64_t v11 = *(int ***)(*(void *)(v189 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for IteratorProtocol, associated type descriptor for IteratorProtocol.Element);
  v176 = v11;
  v175 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v175);
  v174 = (char *)&v159 - v13;
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v15 = *(v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  v172 = (char *)&v159 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v177 = (char *)&v159 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v173 = (char *)&v159 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v159 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  v190 = (char *)&v159 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v186 = (char *)&v159 - v28;
  MEMORY[0x1F4188790](v27);
  v191 = (char *)&v159 - v29;
  uint64_t v32 = type metadata accessor for Optional(0, (uint64_t)v14, v30, v31);
  uint64_t v33 = (uint64_t)*(v32 - 1);
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v178 = (char *)&v159 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v181 = (char *)&v159 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v40 = (char *)&v159 - v39;
  MEMORY[0x1F4188790](v38);
  uint64_t v42 = (char *)&v159 - v41;
  uint64_t v43 = *(void (**)(uint64_t, int **))(a5 + 16);
  uint64_t v187 = a1;
  uint64_t v188 = a3;
  v185 = (int **)a5;
  uint64_t v179 = v43;
  uint64_t v180 = a5 + 16;
  v43(a3, (int **)a5);
  uint64_t v192 = v15;
  uint64_t v44 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v15 + 48);
  if (v44(v42, 1, v14) == 1)
  {
    (*(void (**)(char *, Class *))(v33 + 8))(v42, v32);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v194 - 8) + 56))(v193, 1, 1);
  }
  uint64_t v45 = *(void (**)(char *, char *, Class *))(v33 + 16);
  v45(v40, v42, v32);
  if (v44(v40, 1, v14) == 1)
  {
    uint64_t v46 = *(void (**)(char *, Class *))(v33 + 8);
    v46(v42, v32);
    v46(v40, v32);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v194 - 8) + 56))(v193, 1, 1);
  }
  v171 = v32;
  v161 = v45;
  uint64_t v162 = v33 + 16;
  v166 = v44;
  uint64_t v170 = v33;
  uint64_t v48 = (uint64_t)v191;
  uint64_t v49 = *(void (**)(char *, char *, uint64_t *))(v192 + 32);
  uint64_t v164 = v192 + 32;
  uint64_t v165 = v49;
  v49(v191, v40, v14);
  uint64_t v50 = v189;
  uint64_t v51 = v189 + 64;
  int v52 = *(uint64_t (**)(uint64_t *, uint64_t))(v189 + 64);
  char v53 = v52(v14, v189);
  uint64_t v169 = v51;
  uint64_t v168 = v52;
  if ((v53 & 1) == 0)
  {
    v167 = *(uint64_t (**)(uint64_t *, uint64_t))(v50 + 128);
    uint64_t v69 = v167(v14, v50);
    unsigned __int16 v58 = v186;
    if (v69 >= 16)
    {
      __int16 v195 = 43;
      BOOL v73 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v50 + 96);
      unint64_t v74 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v69, v70, v71);
      v73(&v195, &type metadata for UInt16, v74, v14, v50);
      uint64_t v68 = (uint64_t)v191;
      char v67 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v50 + 16) + 8) + 8))(v191, v58, v14);
      uint64_t v59 = v192;
LABEL_18:
      uint64_t v66 = *(void (**)(char *, uint64_t *))(v59 + 8);
      v66(v58, v14);
      goto LABEL_19;
    }
    uint64_t v68 = v48;
    uint64_t v59 = v192;
    (*(void (**)(char *, uint64_t, uint64_t *))(v192 + 16))(v186, v48, v14);
    goto LABEL_15;
  }
  char v54 = v52(v14, v50);
  v167 = *(uint64_t (**)(uint64_t *, uint64_t))(v50 + 128);
  uint64_t v55 = v167(v14, v50);
  unsigned __int16 v58 = v186;
  if ((v54 & 1) == 0)
  {
    uint64_t v59 = v192;
    if (v55 >= 16) {
      goto LABEL_17;
    }
    uint64_t v68 = (uint64_t)v191;
    (*(void (**)(char *, char *, uint64_t *))(v192 + 16))(v186, v191, v14);
LABEL_15:
    __int16 v72 = (*(uint64_t (**)(uint64_t *, uint64_t))(v50 + 120))(v14, v50);
    uint64_t v66 = *(void (**)(char *, uint64_t *))(v59 + 8);
    v66(v58, v14);
    char v67 = v72 == 43;
    goto LABEL_19;
  }
  uint64_t v59 = v192;
  if (v55 > 16)
  {
LABEL_17:
    __int16 v195 = 43;
    uint64_t v75 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v50 + 96);
    unint64_t v76 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v55, v56, v57);
    v75(&v195, &type metadata for UInt16, v76, v14, v50);
    uint64_t v68 = (uint64_t)v191;
    char v67 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v50 + 16) + 8) + 8))(v191, v58, v14);
    goto LABEL_18;
  }
  uint64_t v60 = v175;
  uint64_t v61 = (uint64_t)v176;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v176, (uint64_t)v14, (uint64_t)v175, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v63 = v174;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v60, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t *, uint64_t))(v61 + 24))(v63, v14, v61);
  uint64_t v64 = (uint64_t)v191;
  int v160 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v50 + 32) + 8) + 32))(v191, v58, v14);
  uint64_t v163 = *(void (**)(char *, uint64_t *))(v59 + 8);
  v163(v58, v14);
  int v159 = *(void (**)(char *, uint64_t, uint64_t *))(v59 + 16);
  v159(v24, v64, v14);
  if ((v160 & 1) == 0)
  {
    uint64_t v66 = v163;
    v163(v24, v14);
    v159(v190, (uint64_t)v191, v14);
    goto LABEL_31;
  }
  __int16 v65 = (*(uint64_t (**)(uint64_t *, uint64_t))(v50 + 120))(v14, v50);
  uint64_t v66 = v163;
  v163(v24, v14);
  char v67 = v65 == 43;
  uint64_t v68 = (uint64_t)v191;
LABEL_19:
  unint64_t v77 = v190;
  (*(void (**)(char *, uint64_t, uint64_t *))(v59 + 16))(v190, v68, v14);
  if (v67)
  {
    unint64_t v78 = v171;
    uint64_t v163 = v66;
    v66(v77, v14);
    goto LABEL_21;
  }
LABEL_31:
  uint64_t v106 = v168;
  if ((v168(v14, v50) & 1) == 0)
  {
    int v122 = v190;
    uint64_t v123 = v167(v14, v50);
    if (v123 >= 16)
    {
      __int16 v195 = 45;
      uint64_t v127 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v50 + 96);
      unint64_t v128 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v123, v124, v125);
      v127(&v195, &type metadata for UInt16, v128, v14, v50);
      char v129 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v50 + 16) + 8) + 8))(v122, v58, v14);
      v66(v58, v14);
      v130 = v122;
      goto LABEL_47;
    }
    v165(v58, v122, v14);
    __int16 v126 = (*(uint64_t (**)(uint64_t *, uint64_t))(v50 + 120))(v14, v50);
    goto LABEL_42;
  }
  char v107 = v106(v14, v50);
  uint64_t v108 = v167(v14, v50);
  if ((v107 & 1) == 0)
  {
    if (v108 >= 16) {
      goto LABEL_46;
    }
    v165(v58, v190, v14);
    __int16 v126 = (*(uint64_t (**)(uint64_t *, uint64_t))(v50 + 120))(v14, v50);
LABEL_42:
    v66(v58, v14);
    if (v126 != 45)
    {
LABEL_48:
      v120 = v185;
      uint64_t v121 = v170;
LABEL_49:
      uint64_t v135 = (uint64_t)v191;
      _parseUnsignedASCII<A, B>(first:rest:radix:positive:)((uint64_t)v191, v187, v183, 1, v188, v194, v120, v184, v193, v182);
      v66((char *)v135, v14);
      return (*(uint64_t (**)(char *, Class *))(v121 + 8))(v42, v171);
    }
LABEL_43:
    uint64_t v163 = v66;
    goto LABEL_44;
  }
  if (v108 > 16)
  {
LABEL_46:
    __int16 v195 = 45;
    uint64_t v131 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v50 + 96);
    unint64_t v132 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v108, v109, v110);
    v131(&v195, &type metadata for UInt16, v132, v14, v50);
    uint64_t v133 = *(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v50 + 16) + 8) + 8);
    uint64_t v134 = v190;
    char v129 = v133(v190, v58, v14);
    v66(v58, v14);
    v130 = v134;
LABEL_47:
    v66(v130, v14);
    if ((v129 & 1) == 0) {
      goto LABEL_48;
    }
    goto LABEL_43;
  }
  uint64_t v112 = v175;
  uint64_t v111 = (uint64_t)v176;
  uint64_t v113 = swift_getAssociatedConformanceWitness((uint64_t)v176, (uint64_t)v14, (uint64_t)v175, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v114 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v113 + 8);
  uint64_t v163 = v66;
  v115 = v174;
  v114(&qword_18162B0B8, 256, v112, v113);
  v116 = v115;
  uint64_t v66 = v163;
  (*(void (**)(char *, uint64_t *, uint64_t))(v111 + 24))(v116, v14, v111);
  char v117 = v190;
  LOBYTE(v112) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v50 + 32) + 8) + 32))(v190, v58, v14);
  v66(v58, v14);
  uint64_t v118 = v173;
  v165(v173, v117, v14);
  if ((v112 & 1) == 0)
  {
    v66(v118, v14);
    goto LABEL_48;
  }
  __int16 v119 = (*(uint64_t (**)(uint64_t *, uint64_t))(v50 + 120))(v14, v50);
  v66(v118, v14);
  BOOL v105 = v119 == 45;
  v120 = v185;
  uint64_t v121 = v170;
  if (!v105) {
    goto LABEL_49;
  }
LABEL_44:
  unint64_t v78 = v171;
  uint64_t v68 = (uint64_t)v191;
LABEL_21:
  uint64_t v79 = v181;
  uint64_t v80 = v185;
  v179(v188, v185);
  uint64_t v81 = v166;
  if (v166(v79, 1, v14) == 1)
  {
    v163((char *)v68, v14);
    int v82 = *(void (**)(char *, Class *))(v170 + 8);
    v82(v79, v78);
    v82(v42, v78);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v194 - 8) + 56))(v193, 1, 1);
  }
  uint64_t v83 = v178;
  v161(v178, v79, v78);
  if (v81(v83, 1, v14) == 1)
  {
    v163((char *)v68, v14);
    uint64_t v84 = v83;
    int v85 = *(void (**)(char *, Class *))(v170 + 8);
    v85(v79, v78);
    v85(v42, v78);
    v85(v84, v78);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v194 - 8) + 56))(v193, 1, 1);
  }
  uint64_t v86 = (void (*)(char *, uint64_t, uint64_t *))v165;
  v165(v177, v83, v14);
  uint64_t v87 = v189;
  uint64_t v88 = v168;
  if (v168(v14, v189))
  {
    char v89 = v88(v14, v87);
    uint64_t v90 = v167(v14, v87);
    if (v89)
    {
      if (v90 <= 16)
      {
        int v93 = v175;
        uint64_t v94 = (uint64_t)v176;
        uint64_t v95 = swift_getAssociatedConformanceWitness((uint64_t)v176, (uint64_t)v14, (uint64_t)v175, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v96 = v174;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v95 + 8))(&qword_18162B0B8, 256, v93, v95);
        v97 = v186;
        (*(void (**)(char *, uint64_t *, uint64_t))(v94 + 24))(v96, v14, v94);
        uint64_t v98 = v189;
        uint64_t v99 = (uint64_t)v191;
        LOBYTE(v93) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v189 + 32) + 8)
                                                                           + 32))(v191, v97, v14);
        uint64_t v100 = v163;
        v163(v97, v14);
        v101 = v172;
        v165(v172, (char *)v99, v14);
        if (v93)
        {
          __int16 v102 = (*(uint64_t (**)(uint64_t *, uint64_t))(v98 + 120))(v14, v98);
          uint64_t v103 = v101;
          __int16 v104 = v102;
          v100(v103, v14);
          BOOL v105 = v104 == 45;
          uint64_t v80 = v185;
          goto LABEL_56;
        }
        v100(v101, v14);
        uint64_t v80 = v185;
        uint64_t v143 = v170;
LABEL_64:
        uint64_t v156 = (uint64_t)v177;
        _parseUnsignedASCII<A, B>(first:rest:radix:positive:)((uint64_t)v177, v187, v183, 1, v188, v194, v80, v184, v193, v182);
        goto LABEL_62;
      }
      goto LABEL_59;
    }
    if (v90 >= 16)
    {
LABEL_59:
      __int16 v195 = 45;
      uint64_t v150 = v189;
      uint64_t v151 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v189 + 96);
      unint64_t v152 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v90, v91, v92);
      uint64_t v153 = v186;
      v151(&v195, &type metadata for UInt16, v152, v14, v150);
      v154 = *(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)(*(void *)(v150 + 16) + 8) + 8);
      uint64_t v155 = (uint64_t)v191;
      char v147 = v154((uint64_t)v191, v153, v14);
      uint64_t v100 = v163;
      v163(v153, v14);
      uint64_t v149 = v155;
LABEL_60:
      v100((char *)v149, v14);
      uint64_t v143 = v170;
      if (v147) {
        goto LABEL_61;
      }
      goto LABEL_64;
    }
    unint64_t v140 = v186;
    v165(v186, v191, v14);
    __int16 v141 = (*(uint64_t (**)(uint64_t *, uint64_t))(v189 + 120))(v14, v189);
  }
  else
  {
    uint64_t v136 = (uint64_t)v191;
    uint64_t v137 = v167(v14, v87);
    if (v137 >= 16)
    {
      __int16 v195 = 45;
      v144 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v87 + 96);
      unint64_t v145 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v137, v138, v139);
      char v146 = v186;
      v144(&v195, &type metadata for UInt16, v145, v14, v87);
      char v147 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)(*(void *)(v87 + 16) + 8) + 8))(v136, v146, v14);
      char v148 = v146;
      uint64_t v100 = v163;
      v163(v148, v14);
      uint64_t v149 = v136;
      goto LABEL_60;
    }
    unint64_t v140 = v186;
    v86(v186, v136, v14);
    __int16 v141 = (*(uint64_t (**)(uint64_t *, uint64_t))(v87 + 120))(v14, v87);
  }
  __int16 v142 = v141;
  uint64_t v100 = v163;
  v163(v140, v14);
  BOOL v105 = v142 == 45;
LABEL_56:
  uint64_t v143 = v170;
  if (!v105) {
    goto LABEL_64;
  }
LABEL_61:
  uint64_t v156 = (uint64_t)v177;
  _parseUnsignedASCII<A, B>(first:rest:radix:positive:)((uint64_t)v177, v187, v183, 0, v188, v194, v80, v184, v193, v182);
LABEL_62:
  v100((char *)v156, v14);
  v157 = *(void (**)(char *, Class *))(v143 + 8);
  uint64_t v158 = v171;
  v157(v79, v171);
  return ((uint64_t (*)(char *, Class *))v157)(v42, v158);
}

uint64_t static FixedWidthInteger._parseASCIISlowPath<A, B>(codeUnits:radix:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X7>, char *a7@<X8>, uint64_t a8)
{
  return _parseASCII<A, B>(codeUnits:radix:)(a1, a2, a3, a4, a5, a6, a8, a7);
}

uint64_t ExpressibleByIntegerLiteral<>.init(integerLiteral:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a3, a1, a2);
}

uint64_t static AdditiveArithmetic.+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v9 + 24))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

uint64_t static AdditiveArithmetic.-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v9 + 40))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

uint64_t static AdditiveArithmetic<>.zero.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v7 = (char *)&v10 - v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 24))(v7, a1, a3);
}

Swift::Void __swiftcall SignedNumeric.negate()()
{
  uint64_t v3 = v0;
  uint64_t v4 = *(void *)(v1 + 8);
  uint64_t v5 = *(void *)(v4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v0, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v18 - v8;
  uint64_t v10 = *(void *)(v3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v7);
  uint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v18 - v14;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 24))(v9, v3, v5);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v4 + 8) + 40))(v13, v2, v3);
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v10 + 8);
  v17(v2, v3);
  v17((uint64_t)v13, v3);
  (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))(v2, v15, v3);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t, uint64_t);
  uint64_t v18;

  uint64_t v3 = v0;
  uint64_t v4 = *(void *)(v1 + 8);
  uint64_t v5 = *(void *)(v4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v0, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v18 - v8;
  uint64_t v10 = *(void *)(v3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v7);
  uint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v18 - v14;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 24))(v9, v3, v5);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v4 + 8) + 40))(v13, v2, v3);
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v10 + 8);
  v17(v2, v3);
  v17((uint64_t)v13, v3);
  (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))(v2, v15, v3);
}

uint64_t static AdditiveArithmetic.+ prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a3, a1, a2);
}

uint64_t BinaryInteger._lowWord.getter(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a2, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)+ 8)+ 8)+ 8);
  uint64_t v6 = swift_getAssociatedTypeWitness(0, (int **)v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)v6 - 1);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)&v12 - v8;
  (*(void (**)(uint64_t, uint64_t))(a2 + 112))(a1, a2);
  (*(void (**)(const char *, uint64_t))(v5 + 32))(AssociatedTypeWitness, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, (uint64_t)AssociatedTypeWitness, (uint64_t)v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16))(&v12, v6, AssociatedConformanceWitness);
  (*(void (**)(char *, const char *))(v7 + 8))(v9, v6);
  if (v13) {
    return 0;
  }
  else {
    return v12;
  }
}

{
  const char *AssociatedTypeWitness;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t AssociatedConformanceWitness;
  uint64_t v12;
  char v13;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a2, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)+ 8)+ 8)+ 8);
  uint64_t v6 = swift_getAssociatedTypeWitness(0, (int **)v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)v6 - 1);
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (char *)&v12 - v8;
  (*(void (**)(uint64_t, uint64_t))(a2 + 112))(a1, a2);
  (*(void (**)(const char *, uint64_t))(v5 + 32))(AssociatedTypeWitness, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, (uint64_t)AssociatedTypeWitness, (uint64_t)v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16))(&v12, v6, AssociatedConformanceWitness);
  (*(void (**)(char *, const char *))(v7 + 8))(v9, v6);
  if (v13) {
    return 0;
  }
  else {
    return v12;
  }
}

Swift::Int __swiftcall BinaryInteger._binaryLogarithm()()
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v6 = *(void *)(v1[3] + 16);
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(0, (int **)v6, v0, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v32 - v9;
  uint64_t v11 = *(void *)(v5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v32 - v15;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))((char *)&v32 - v15, v3, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v10, v5, v6);
  LOBYTE(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v4[4] + 8) + 40))(v16, v14, v5);
  uint64_t v18 = *(void (**)(char *, uint64_t))(v11 + 8);
  v18(v14, v5);
  if ((AssociatedTypeWitness & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x4F7uLL, 0);
  }
  v18(v16, v5);
  uint64_t v40 = v18;
  uint64_t v19 = (uint64_t (*)(uint64_t, void *))v4[16];
  uint64_t v20 = v19(v5, v4);
  uint64_t v21 = v20 + 62;
  if (v20 - 1 >= 0) {
    uint64_t v21 = v20 - 1;
  }
  uint64_t v22 = v21 >> 6;
  unint64_t v33 = v21 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v34 = v20 - 1;
  unint64_t v23 = v20 - 1 - (v21 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v35 = v19;
  uint64_t v36 = v4 + 16;
  uint64_t v24 = v19(v5, v4);
  uint64_t v41 = ~v23 + v24;
  uint64_t v25 = v3;
  uint64_t v26 = (void (*)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, void *))v4[30];
  unint64_t v38 = lazy protocol witness table accessor for type Int and conformance Int(v24, v27, v28);
  uint64_t v39 = v26;
  ((void (*)(uint64_t, uint64_t *, ValueMetadata *))v26)(v25, &v41, &type metadata for Int);
  uint64_t v37 = (uint64_t (*)(uint64_t, void *))v4[15];
  unint64_t v29 = v37(v5, v4);
  v40(v14, v5);
  if (!v29)
  {
    uint64_t v30 = v33 - v34 - 65;
    do
    {
      --v22;
      uint64_t v41 = v35(v5, v4) + v30;
      v39(v25, &v41, &type metadata for Int, v38, v5, v4);
      unint64_t v29 = v37(v5, v4);
      v40(v14, v5);
      v30 -= 64;
    }
    while (!v29);
  }
  return ((v22 << 6) | 0x3F) - __clz(v29);
}

uint64_t static BinaryInteger.& infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 200))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 200))(a5, a2, a3, a4);
}

uint64_t static BinaryInteger.| infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 216))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 216))(a5, a2, a3, a4);
}

uint64_t static BinaryInteger.^ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 232))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 232))(a5, a2, a3, a4);
}

uint64_t static BinaryInteger.>> infix<A>(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 248))(a7, a2, a3, a4, a5, a6);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a7, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 248))(a7, a2, a4, a6, a3, a5);
}

uint64_t static BinaryInteger.<< infix<A>(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 264))(a7, a2, a3, a4, a5, a6);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a7, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 264))(a7, a2, a4, a6, a3, a5);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(_OWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  uint64_t result = __udivti3();
  *a1 = __PAIR128__(a5, a4) - __PAIR128__(v11, result) * __PAIR128__(a3, a2);
  return result;
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(int *a1, int a2, int a3)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  }
  if (a2 == -1 && a3 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  }
  *a1 = a3 % a2;
  return (a3 / a2);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(_WORD *a1, __int16 a2, __int16 a3)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  }
  if (a2 == -1 && (unsigned __int16)a3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  }
  *a1 = a3 % a2;
  return (a3 / a2);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || (unint64_t v10 = a4 | a5 ^ 0x8000000000000000) != 0)
  {
    uint64_t result = __divti3();
    unint64_t v12 = (__PAIR128__(a5, a4) - __PAIR128__(v13, result) * __PAIR128__(a3, a2)) >> 64;
    unint64_t v10 = a4 - result * a2;
  }
  else
  {
    uint64_t result = 0;
    unint64_t v12 = 0;
  }
  *a1 = v10;
  a1[1] = v12;
  return result;
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(unsigned char *a1, char a2, char a3)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  }
  if (a2 == -1 && a3 == 128) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  }
  *a1 = a3 % a2;
  return (a3 / a2);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  if (a2 == -1 && a3 == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  }
  *a1 = a3 % a2;
  return a3 / a2;
}

uint64_t BinaryInteger.quotientAndRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 152))(v6, a3, a4, a5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 168))(v6, a3, a4, a5);
}

BOOL specialized BinaryInteger.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 | a2)
  {
    a3 = __umodti3();
    a4 = v4;
  }
  return (a3 | a4) == 0;
}

BOOL specialized BinaryInteger.isMultiple(of:)(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned int v2 = a2;
  if (a1) {
    unsigned int v2 = a2 % a1;
  }
  return v2 == 0;
}

BOOL specialized BinaryInteger.isMultiple(of:)(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned int v2 = a2;
  if (a1) {
    unsigned int v2 = a2 % a1;
  }
  return v2 == 0;
}

BOOL specialized BinaryInteger.isMultiple(of:)(unsigned int a1, unsigned int a2)
{
  if (a1) {
    a2 %= a1;
  }
  return a2 == 0;
}

uint64_t BinaryInteger.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t v113 = *(int ***)(swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  uint64_t v112 = swift_getAssociatedTypeWitness(0, v113, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v112);
  uint64_t v111 = (char *)&v108 - v8;
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v121 = *(v9 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  unint64_t v12 = (char *)&v108 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  v120 = (char *)&v108 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v125 = (char *)&v108 - v16;
  MEMORY[0x1F4188790](v15);
  int v122 = (char *)&v108 - v17;
  uint64_t v124 = v6;
  char v117 = *(int ***)(v6 + 16);
  v116 = swift_getAssociatedTypeWitness(0, v117, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v18 = MEMORY[0x1F4188790](v116);
  v115 = (char *)&v108 - v19;
  uint64_t v127 = *(void (**)(char *, uint64_t *))(a2 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v110 = (char *)&v108 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v108 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v108 - v25;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v28 = v27(a2, a3);
  uint64_t v114 = v12;
  __int16 v119 = v27;
  if ((v28 & 1) == 0)
  {
    char v39 = v27(a2, a3);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v123 = a1;
    uint64_t v118 = v40;
    uint64_t v41 = v40(a2, a3);
    if (v39)
    {
      if (v41 <= 64)
      {
        uint64_t v44 = v116;
        uint64_t v45 = v117;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v117, a2, (uint64_t)v116, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v47 = v115;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v44, AssociatedConformanceWitness);
        uint64_t v35 = v26;
        ((void (*)(char *, uint64_t, int **))v45[3])(v47, a2, v45);
        uint64_t v48 = v123;
        LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8)
                                                                          + 32))(v123, v35, a2);
        uint64_t v49 = v127;
        uint64_t v109 = (uint64_t *)*((void *)v127 + 1);
        ((void (*)(char *, uint64_t))v109)(v35, a2);
        (*((void (**)(char *, uint64_t, uint64_t))v49 + 2))(v24, v48, a2);
        if ((v44 & 1) == 0)
        {
          ((void (*)(char *, uint64_t))v109)(v24, a2);
          goto LABEL_27;
        }
        uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        uint64_t v37 = v109;
        ((void (*)(char *, uint64_t))v109)(v24, a2);
        uint64_t v38 = v126;
        if (v50) {
          goto LABEL_27;
        }
LABEL_16:
        uint64_t v59 = v119;
        if (v119(a2, a3))
        {
          uint64_t v60 = v118(a2, a3);
          if (v60 >= 64) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
        char v63 = v59(a2, a3);
        uint64_t v60 = v118(a2, a3);
        if (v63)
        {
          if (v60 <= 64)
          {
            uint64_t v64 = v116;
            __int16 v65 = v117;
            uint64_t v66 = swift_getAssociatedConformanceWitness((uint64_t)v117, a2, (uint64_t)v116, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            char v67 = v115;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v66 + 8))(&qword_18162B0B8, 256, v64, v66);
            ((void (*)(char *, uint64_t, int **))v65[3])(v67, a2, v65);
            LOBYTE(v64) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8)
                                                                              + 32))(v38, v35, a2);
            uint64_t v68 = v127;
            ((void (*)(char *, uint64_t))v37)(v35, a2);
            uint64_t v69 = v110;
            (*((void (**)(char *, uint64_t, uint64_t))v68 + 2))(v110, v38, a2);
            char v70 = (v64 & 1) != 0
               && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3) == 0;
            ((void (*)(char *, uint64_t))v37)(v69, a2);
            return v70 & 1;
          }
        }
        else if (v60 < 64)
        {
LABEL_24:
          (*((void (**)(char *, uint64_t, uint64_t))v127 + 2))(v35, v38, a2);
          uint64_t v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          ((void (*)(char *, uint64_t))v37)(v35, a2);
          char v70 = v71 == 0;
          return v70 & 1;
        }
LABEL_25:
        v128[0] = 0;
        __int16 v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v60, v61, v62);
        v72(v128, &type metadata for Int, v73, a2, a3);
        char v70 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 16) + 8) + 8))(v38, v35, a2);
        ((void (*)(char *, uint64_t))v37)(v35, a2);
        return v70 & 1;
      }
    }
    else if (v41 < 64)
    {
      char v54 = v127;
      uint64_t v35 = v26;
      (*((void (**)(char *, uint64_t, uint64_t))v127 + 2))(v26, v123, a2);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v37 = (uint64_t *)*((void *)v54 + 1);
      ((void (*)(char *, uint64_t))v37)(v26, a2);
      uint64_t v38 = v126;
      if (v55) {
        goto LABEL_27;
      }
      goto LABEL_16;
    }
    v128[0] = 0;
    uint64_t v56 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v57 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
    uint64_t v35 = v26;
    v56(v128, &type metadata for Int, v57, a2, a3);
    char v58 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 16) + 8) + 8))(v123, v26, a2);
    uint64_t v37 = (uint64_t *)*((void *)v127 + 1);
    ((void (*)(char *, uint64_t))v37)(v26, a2);
    uint64_t v38 = v126;
    if (v58) {
      goto LABEL_16;
    }
    goto LABEL_27;
  }
  uint64_t v109 = v9;
  uint64_t v29 = v126;
  uint64_t v118 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v30 = v118(a2, a3);
  uint64_t v33 = a1;
  if (v30 >= 64)
  {
    v128[0] = 0;
    uint64_t v123 = a1;
    uint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v51(v128, &type metadata for Int, v52, a2, a3);
    uint64_t v38 = v29;
    uint64_t v35 = v26;
    char v53 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 16) + 8) + 8))(v123, v26, a2);
    uint64_t v37 = (uint64_t *)*((void *)v127 + 1);
    ((void (*)(char *, uint64_t))v37)(v26, a2);
    uint64_t v9 = v109;
    if (v53) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v34 = v127;
    uint64_t v35 = v26;
    (*((void (**)(char *, uint64_t, uint64_t))v127 + 2))(v26, v33, a2);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v37 = (uint64_t *)*((void *)v34 + 1);
    ((void (*)(char *, uint64_t))v37)(v26, a2);
    uint64_t v38 = v29;
    uint64_t v9 = v109;
    if (!v36) {
      goto LABEL_16;
    }
  }
LABEL_27:
  uint64_t v75 = v124;
  unint64_t v74 = v125;
  unint64_t v76 = *(void (**)(uint64_t, uint64_t))(v124 + 56);
  v76(a2, v124);
  unint64_t v77 = v120;
  v76(a2, v75);
  uint64_t v78 = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v79 = v122;
  (*(void (**)(char *, char *, uint64_t *, uint64_t))(v78 + 168))(v74, v77, v9, v78);
  uint64_t v80 = v121;
  uint64_t v81 = *(void (**)(char *, uint64_t *))(v121 + 8);
  v81(v77, v9);
  uint64_t v127 = v81;
  v81(v74, v9);
  int v82 = *(uint64_t (**)(uint64_t *, uint64_t))(v78 + 64);
  if (v82(v9, v78))
  {
    uint64_t v83 = (*(uint64_t (**)(uint64_t *, uint64_t))(v78 + 128))(v9, v78);
    if (v83 < 64) {
      goto LABEL_35;
    }
    goto LABEL_32;
  }
  char v86 = v82(v9, v78);
  uint64_t v83 = (*(uint64_t (**)(uint64_t *, uint64_t))(v78 + 128))(v9, v78);
  if ((v86 & 1) == 0)
  {
    if (v83 >= 64)
    {
      v128[0] = 0;
      __int16 v102 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v78 + 96);
      unint64_t v103 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      __int16 v104 = v125;
      v102(v128, &type metadata for Int, v103, v9, v78);
      uint64_t v105 = swift_getAssociatedConformanceWitness(v124, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v70 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v105 + 8) + 8))(v79, v104, v9);
      uint64_t v106 = v127;
      v127(v79, v9);
      v106(v104, v9);
      return v70 & 1;
    }
LABEL_35:
    uint64_t v92 = (*(uint64_t (**)(uint64_t *, uint64_t))(v78 + 120))(v9, v78);
    v127(v79, v9);
    char v70 = v92 == 0;
    return v70 & 1;
  }
  if (v83 > 64)
  {
LABEL_32:
    v128[0] = 0;
    uint64_t v87 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v78 + 96);
    unint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
    char v89 = v125;
    v87(v128, &type metadata for Int, v88, v9, v78);
    uint64_t v90 = swift_getAssociatedConformanceWitness(v124, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v70 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v90 + 8) + 8))(v79, v89, v9);
    uint64_t v91 = v127;
    v127(v89, v9);
    v91(v79, v9);
    return v70 & 1;
  }
  int v93 = v112;
  uint64_t v94 = v113;
  uint64_t v95 = swift_getAssociatedConformanceWitness((uint64_t)v113, (uint64_t)v9, (uint64_t)v112, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v96 = v111;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v95 + 8))(&qword_18162B0B8, 256, v93, v95);
  v97 = v125;
  ((void (*)(char *, uint64_t *, int **))v94[3])(v96, v9, v94);
  uint64_t v98 = swift_getAssociatedConformanceWitness(v124, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  char v99 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v98 + 32))(v79, v97, v9, v98);
  uint64_t v100 = v127;
  v127(v97, v9);
  v101 = v114;
  (*(void (**)(char *, char *, uint64_t *))(v80 + 32))(v114, v79, v9);
  char v70 = (v99 & 1) != 0 && (*(uint64_t (**)(uint64_t *, uint64_t))(v78 + 120))(v9, v78) == 0;
  v100(v101, v9);
  return v70 & 1;
}

BOOL specialized BinaryInteger.signum()(uint64_t a1, unint64_t a2)
{
  if (a2) {
    BOOL v2 = (uint64_t)a2 > 0;
  }
  else {
    BOOL v2 = a1 != 0;
  }
  return v2 - (a2 >> 63);
}

uint64_t BinaryInteger.signum()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v39 = a3;
  uint64_t v38 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(v38 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v33 - v8;
  uint64_t v10 = *(void *)(a1 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v7);
  uint64_t v35 = (char *)&v33 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v33 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v42 = (char *)&v33 - v16;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v43 = *(void (**)(uint64_t *, uint64_t, const char *))(AssociatedConformanceWitness + 8);
  uint64_t v44 = AssociatedConformanceWitness;
  v43(&qword_18162B0B8, 256, AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 24);
  uint64_t v36 = v5;
  uint64_t v40 = v18;
  v18(v9, a1, v5);
  uint64_t v19 = *(void *)(*(void *)(a2 + 32) + 8);
  char v20 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v19 + 40))(v41, v15, a1, v19);
  uint64_t v21 = *(void (**)(char *, uint64_t))(v10 + 8);
  uint64_t v37 = v10 + 8;
  uint64_t v34 = v21;
  v21(v15, a1);
  if (v20)
  {
    uint64_t v22 = &qword_18162B0C0;
    uint64_t v23 = 512;
  }
  else
  {
    uint64_t v22 = &qword_18162B0B8;
    uint64_t v23 = 256;
  }
  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v43)(v22, v23, AssociatedTypeWitness, v44);
  uint64_t v24 = v36;
  uint64_t v25 = v40;
  v40(v9, a1, v36);
  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v43)(&qword_18162B0B8, 256, AssociatedTypeWitness, v44);
  v25(v9, a1, v24);
  char v26 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v19 + 16))(v41, v15, a1, v19);
  uint64_t v27 = v34;
  v34(v15, a1);
  if (v26)
  {
    char v28 = &qword_18162B0C0;
    uint64_t v29 = 512;
  }
  else
  {
    char v28 = &qword_18162B0B8;
    uint64_t v29 = 256;
  }
  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v43)(v28, v29, AssociatedTypeWitness, v44);
  uint64_t v30 = v35;
  v40(v9, a1, v24);
  uint64_t v31 = v42;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v38 + 8) + 40))(v42, v30, a1);
  v27(v30, a1);
  return ((uint64_t (*)(char *, uint64_t))v27)(v31, a1);
}

uint64_t BinaryInteger.init()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v3, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v6 = (char *)&v9 - v5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v3, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v3 + 24))(v6, a1, v3);
}

uint64_t specialized BinaryInteger._description(radix:uppercase:)(unint64_t a1, char a2, Swift::UInt64 a3, Swift::UInt64 a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Radix must be between 2 and 36", 30, 2, "Swift/Integers.swift", 20, 2, 0x5E1uLL, 0);
  }
  Swift::UInt64 v4 = a4;
  Swift::UInt64 v5 = a3;
  if (!(a4 | a3)) {
    return 48;
  }
  uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v15.i16[0] = vaddlv_u8(v15);
  uint64_t v16 = v15.u32[0];
  unint64_t v17 = __clz(__rbit64(a1));
  char v32 = a1 - 1;
  uint64_t v18 = &_swiftEmptyArrayStorage;
  do
  {
    if (v16 == 1)
    {
      if (v17 >= 0x40)
      {
        Swift::UInt64 v19 = v4 >> (v17 & 0x3F);
        Swift::UInt64 v4 = 0;
      }
      else if (v17)
      {
        Swift::UInt64 v19 = (v4 << (-(char)v17 & 0x3F)) | (v5 >> v17);
        v4 >>= v17;
      }
      else
      {
        Swift::UInt64 v19 = v5;
      }
      unsigned __int8 v20 = v5 & v32;
      Swift::UInt64 v5 = v19;
      if (a1 < 0xB)
      {
LABEL_24:
        char v22 = v20 + 48;
        if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v18)) {
          goto LABEL_25;
        }
        goto LABEL_30;
      }
    }
    else
    {
      v36.high = (Swift::UInt64)&v33;
      v36.uint64_t low = v4;
      Swift::UInt64 v4 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v35, &v34, v36, v5, 0, a1);
      Swift::UInt64 v5 = (Swift::UInt64)v35;
      unsigned __int8 v20 = v33;
      if (a1 < 0xB) {
        goto LABEL_24;
      }
    }
    if (v20 < 0xAu) {
      goto LABEL_24;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v18);
    if (a2)
    {
      char v22 = v20 + 55;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_25;
      }
    }
    else
    {
      char v22 = v20 + 87;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_25;
      }
    }
LABEL_30:
    uint64_t v18 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v18[2]->isa + 1, 1, (uint64_t)v18);
LABEL_25:
    uint64_t v24 = v18[2];
    unint64_t v23 = (unint64_t)v18[3];
    if ((unint64_t)v24 >= v23 >> 1) {
      uint64_t v18 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v23 > 1), (int64_t)&v24->isa + 1, 1, (uint64_t)v18);
    }
    v18[2] = (__objc2_class *)((char *)&v24->isa + 1);
    *((unsigned char *)&v24->info + (void)v18) = v22;
  }
  while (v4 | v5);
  uint64_t v35 = v18;
  specialized MutableCollection<>.reverse()();
  Swift::UInt64 v7 = (Swift::UInt64)v35;
  size_t v8 = (size_t)v35[2];
  if (!v8)
  {
    uint64_t v6 = 0;
LABEL_46:
    swift_bridgeObjectRetain((unint64_t)v35);
    goto LABEL_47;
  }
  if (v8 <= 0xF)
  {
    uint64_t v25 = 8;
    if (v8 < 8) {
      uint64_t v25 = (uint64_t)v35[2];
    }
    uint64_t v6 = *((unsigned __int8 *)v35 + 32);
    if (v25 != 1)
    {
      v6 |= (unint64_t)*((unsigned __int8 *)v35 + 33) << 8;
      if (v25 != 2)
      {
        v6 |= (unint64_t)*((unsigned __int8 *)v35 + 34) << 16;
        if (v25 != 3)
        {
          v6 |= (unint64_t)*((unsigned __int8 *)v35 + 35) << 24;
          if (v25 != 4)
          {
            v6 |= (unint64_t)*((unsigned __int8 *)v35 + 36) << 32;
            if (v25 != 5)
            {
              v6 |= (unint64_t)*((unsigned __int8 *)v35 + 37) << 40;
              if (v25 != 6)
              {
                v6 |= (unint64_t)*((unsigned __int8 *)v35 + 38) << 48;
                if (v25 != 7) {
                  v6 |= (unint64_t)*((unsigned __int8 *)v35 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v26 = 0;
    if (v8 >= 9)
    {
      uint64_t v27 = 0;
      char v28 = (unsigned __int8 *)(v35 + 5);
      size_t v29 = v8 - 8;
      do
      {
        if (v8 - 8 <= v8 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v30 = *v28++;
        v26 |= (unint64_t)v30 << v27;
        v27 += 8;
        --v29;
      }
      while (v29);
    }
    goto LABEL_46;
  }
  unint64_t v9 = v8 | 0xF000000000000000;
  int64_t v10 = _allocateStringStorage(codeUnitCapacity:)((int64_t)v35[2]);
  uint64_t v12 = v11;
  *(void *)(v10 + 16) = v11;
  *(void *)(v10 + 24) = v8 | 0xF000000000000000;
  swift_bridgeObjectRetain(v7);
  if (v12 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    unint64_t v9 = *(void *)(v10 + 24);
  }
  *(unsigned char *)(v10 + 32 + (v9 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v7 + 32), v8, (char *)(v10 + 32));
  uint64_t v6 = *(void *)(v10 + 24);
LABEL_47:
  swift_bridgeObjectRelease_n(v7, 2);
  return v6;
}

uint64_t specialized BinaryInteger._description(radix:uppercase:)(unint64_t a1, char a2, Swift::UInt64 a3, uint64_t a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Radix must be between 2 and 36", 30, 2, "Swift/Integers.swift", 20, 2, 0x5E1uLL, 0);
  }
  if (a4 | a3)
  {
    Swift::UInt64 v6 = (unsigned __int128)-(__int128)__PAIR128__(v4, a3) >> 64;
    if (a4 >= 0) {
      Swift::UInt64 v7 = a3;
    }
    else {
      Swift::UInt64 v7 = -(uint64_t)a3;
    }
    if (a4 >= 0) {
      Swift::UInt64 v8 = a4;
    }
    else {
      Swift::UInt64 v8 = v6;
    }
    if (!(v8 | v7))
    {
      unint64_t v9 = &_swiftEmptyArrayStorage;
LABEL_13:
      uint64_t v40 = v9;
      if (a4 < 0)
      {
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v9)) {
          unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v9[2]->isa + 1, 1, (uint64_t)v9);
        }
        uint64_t v11 = v9[2];
        unint64_t v10 = (unint64_t)v9[3];
        if ((unint64_t)v11 >= v10 >> 1) {
          unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v10 > 1), (int64_t)&v11->isa + 1, 1, (uint64_t)v9);
        }
        v9[2] = (__objc2_class *)((char *)&v11->isa + 1);
        *((unsigned char *)&v11->info + (void)v9) = 45;
        uint64_t v40 = v9;
      }
      specialized MutableCollection<>.reverse()();
      Swift::UInt64 v12 = (Swift::UInt64)v40;
      size_t v13 = (size_t)v40[2];
      if (v13)
      {
        if (v13 > 0xF)
        {
          unint64_t v14 = v13 | 0xF000000000000000;
          int64_t v15 = _allocateStringStorage(codeUnitCapacity:)((int64_t)v40[2]);
          uint64_t v17 = v16;
          *(void *)(v15 + 16) = v16;
          *(void *)(v15 + 24) = v13 | 0xF000000000000000;
          swift_bridgeObjectRetain(v12);
          if (v17 < 0)
          {
            *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
            unint64_t v14 = *(void *)(v15 + 24);
          }
          *(unsigned char *)(v15 + 32 + (v14 & 0xFFFFFFFFFFFFLL)) = 0;
          specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v12 + 32), v13, (char *)(v15 + 32));
          uint64_t v5 = *(void *)(v15 + 24);
          goto LABEL_61;
        }
        uint64_t v29 = 8;
        if (v13 < 8) {
          uint64_t v29 = (uint64_t)v40[2];
        }
        uint64_t v5 = *((unsigned __int8 *)v40 + 32);
        if (v29 != 1)
        {
          v5 |= (unint64_t)*((unsigned __int8 *)v40 + 33) << 8;
          if (v29 != 2)
          {
            v5 |= (unint64_t)*((unsigned __int8 *)v40 + 34) << 16;
            if (v29 != 3)
            {
              v5 |= (unint64_t)*((unsigned __int8 *)v40 + 35) << 24;
              if (v29 != 4)
              {
                v5 |= (unint64_t)*((unsigned __int8 *)v40 + 36) << 32;
                if (v29 != 5)
                {
                  v5 |= (unint64_t)*((unsigned __int8 *)v40 + 37) << 40;
                  if (v29 != 6)
                  {
                    v5 |= (unint64_t)*((unsigned __int8 *)v40 + 38) << 48;
                    if (v29 != 7) {
                      v5 |= (unint64_t)*((unsigned __int8 *)v40 + 39) << 56;
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v30 = 0;
        if (v13 >= 9)
        {
          uint64_t v31 = 0;
          char v32 = (unsigned __int8 *)(v40 + 5);
          size_t v33 = v13 - 8;
          do
          {
            if (v13 - 8 <= v13 - 9) {
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
            }
            unsigned int v34 = *v32++;
            v30 |= (unint64_t)v34 << v31;
            v31 += 8;
            --v33;
          }
          while (v33);
        }
      }
      else
      {
        uint64_t v5 = 0;
      }
      swift_bridgeObjectRetain((unint64_t)v40);
LABEL_61:
      swift_bridgeObjectRelease_n(v12, 2);
      return v5;
    }
    uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
    v20.i16[0] = vaddlv_u8(v20);
    uint64_t v21 = v20.u32[0];
    unint64_t v22 = __clz(__rbit64(a1));
    char v37 = a1 - 1;
    unint64_t v9 = &_swiftEmptyArrayStorage;
    while (1)
    {
      if (v21 == 1)
      {
        if (v22 >= 0x40)
        {
          Swift::UInt64 v23 = v8 >> (v22 & 0x3F);
          Swift::UInt64 v8 = 0;
        }
        else if (v22)
        {
          Swift::UInt64 v23 = (v8 << (-(char)v22 & 0x3F)) | (v7 >> v22);
          v8 >>= v22;
        }
        else
        {
          Swift::UInt64 v23 = v7;
        }
        unsigned __int8 v24 = v7 & v37;
        Swift::UInt64 v7 = v23;
        if (a1 < 0xB)
        {
LABEL_38:
          char v26 = v24 + 48;
          if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v9)) {
            goto LABEL_44;
          }
          goto LABEL_39;
        }
      }
      else
      {
        v41.high = (Swift::UInt64)&v38;
        v41.uint64_t low = v8;
        Swift::UInt64 v8 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v40, &v39, v41, v7, 0, a1);
        Swift::UInt64 v7 = (Swift::UInt64)v40;
        unsigned __int8 v24 = v38;
        if (a1 < 0xB) {
          goto LABEL_38;
        }
      }
      if (v24 < 0xAu) {
        goto LABEL_38;
      }
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v9);
      if (a2)
      {
        char v26 = v24 + 55;
        if (!isUniquelyReferenced_nonNull_native) {
          goto LABEL_44;
        }
      }
      else
      {
        char v26 = v24 + 87;
        if (!isUniquelyReferenced_nonNull_native) {
LABEL_44:
        }
          unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v9[2]->isa + 1, 1, (uint64_t)v9);
      }
LABEL_39:
      char v28 = v9[2];
      unint64_t v27 = (unint64_t)v9[3];
      if ((unint64_t)v28 >= v27 >> 1) {
        unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v27 > 1), (int64_t)&v28->isa + 1, 1, (uint64_t)v9);
      }
      v9[2] = (__objc2_class *)((char *)&v28->isa + 1);
      *((unsigned char *)&v28->info + (void)v9) = v26;
      if (!(v8 | v7)) {
        goto LABEL_13;
      }
    }
  }
  return 48;
}

uint64_t specialized BinaryInteger._description(radix:uppercase:)(unint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Radix must be between 2 and 36", 30, 2, "Swift/Integers.swift", 20, 2, 0x5E1uLL, 0);
  }
  if (!(a3 | a4)) {
    return 48;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v5.i16[0] = vaddlv_u8(v5);
  uint64_t v6 = v5.u32[0];
  unint64_t v8 = (__PAIR128__(a4 ^ (unint64_t)(a4 >> 63), a3 ^ (unint64_t)(a4 >> 63))
      - __PAIR128__(a4 >> 63, a4 >> 63)) >> 64;
  unint64_t v7 = (a3 ^ (a4 >> 63)) - (a4 >> 63);
  char v9 = __clz(__rbit64(a1));
  char v10 = a1 - 1;
  uint64_t v11 = &_swiftEmptyArrayStorage;
  do
  {
    if (v6 == 1)
    {
      unsigned __int8 v12 = v7 & v10;
      if ((v9 & 0x40) != 0) {
        unint64_t v7 = v8 >> v9;
      }
      else {
        unint64_t v7 = ((2 * v8) << ~v9) | (v7 >> v9);
      }
      if ((v9 & 0x40) != 0) {
        unint64_t v8 = 0;
      }
      else {
        v8 >>= v9;
      }
      if (a1 < 0xB)
      {
LABEL_19:
        char v16 = v12 + 48;
        if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v11)) {
          goto LABEL_20;
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v13 = __udivti3();
      unint64_t v8 = v14;
      unsigned __int8 v12 = v7 - v13 * a1;
      unint64_t v7 = v13;
      if (a1 < 0xB) {
        goto LABEL_19;
      }
    }
    if (v12 < 0xAu) {
      goto LABEL_19;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v11);
    if (a2)
    {
      char v16 = v12 + 55;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }
    else
    {
      char v16 = v12 + 87;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }
LABEL_25:
    uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v11[2]->isa + 1, 1, (uint64_t)v11);
LABEL_20:
    uint64_t v18 = v11[2];
    unint64_t v17 = (unint64_t)v11[3];
    if ((unint64_t)v18 >= v17 >> 1) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v17 > 1), (int64_t)&v18->isa + 1, 1, (uint64_t)v11);
    }
    v11[2] = (__objc2_class *)((char *)&v18->isa + 1);
    *((unsigned char *)&v18->info + (void)v11) = v16;
  }
  while (v7 | v8);
  unint64_t v36 = (unint64_t)v11;
  if (a4 < 0)
  {
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v11)) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v11[2]->isa + 1, 1, (uint64_t)v11);
    }
    uint8x8_t v20 = v11[2];
    unint64_t v19 = (unint64_t)v11[3];
    if ((unint64_t)v20 >= v19 >> 1) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v19 > 1), (int64_t)&v20->isa + 1, 1, (uint64_t)v11);
    }
    v11[2] = (__objc2_class *)((char *)&v20->isa + 1);
    *((unsigned char *)&v20->info + (void)v11) = 45;
    unint64_t v36 = (unint64_t)v11;
  }
  specialized MutableCollection<>.reverse()();
  size_t v21 = *(void *)(v36 + 16);
  if (!v21)
  {
    uint64_t v26 = 0;
LABEL_53:
    swift_bridgeObjectRetain(v36);
    goto LABEL_54;
  }
  if (v21 <= 0xF)
  {
    uint64_t v27 = 8;
    if (v21 < 8) {
      uint64_t v27 = *(void *)(v36 + 16);
    }
    uint64_t v26 = *(unsigned __int8 *)(v36 + 32);
    if (v27 != 1)
    {
      v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 33) << 8;
      if (v27 != 2)
      {
        v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 34) << 16;
        if (v27 != 3)
        {
          v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 35) << 24;
          if (v27 != 4)
          {
            v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 36) << 32;
            if (v27 != 5)
            {
              v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 37) << 40;
              if (v27 != 6)
              {
                v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 38) << 48;
                if (v27 != 7) {
                  v26 |= (unint64_t)*(unsigned __int8 *)(v36 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v28 = 0;
    if (v21 >= 9)
    {
      uint64_t v29 = 0;
      uint64_t v30 = (unsigned __int8 *)(v36 + 40);
      size_t v31 = v21 - 8;
      do
      {
        if (v21 - 8 <= v21 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v32 = *v30++;
        v28 |= (unint64_t)v32 << v29;
        v29 += 8;
        --v31;
      }
      while (v31);
    }
    goto LABEL_53;
  }
  unint64_t v22 = v21 | 0xF000000000000000;
  int64_t v23 = _allocateStringStorage(codeUnitCapacity:)(*(void *)(v36 + 16));
  uint64_t v25 = v24;
  *(void *)(v23 + 16) = v24;
  *(void *)(v23 + 24) = v21 | 0xF000000000000000;
  swift_bridgeObjectRetain(v36);
  if (v25 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    unint64_t v22 = *(void *)(v23 + 24);
  }
  *(unsigned char *)(v23 + 32 + (v22 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v36 + 32), v21, (char *)(v23 + 32));
  uint64_t v26 = *(void *)(v23 + 24);
LABEL_54:
  swift_bridgeObjectRelease_n(v36, 2);
  return v26;
}

uint64_t specialized BinaryInteger._description(radix:uppercase:)(unint64_t a1, char a2, unint64_t a3, unint64_t a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Radix must be between 2 and 36", 30, 2, "Swift/Integers.swift", 20, 2, 0x5E1uLL, 0);
  }
  unint64_t v4 = a4;
  unint64_t v5 = a3;
  if (!(a3 | a4)) {
    return 48;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v8.i16[0] = vaddlv_u8(v8);
  uint64_t v9 = v8.u32[0];
  char v10 = __clz(__rbit64(a1));
  char v33 = a1 - 1;
  uint64_t v11 = &_swiftEmptyArrayStorage;
  do
  {
    if (v9 == 1)
    {
      unsigned __int8 v12 = v5 & v33;
      if ((v10 & 0x40) != 0) {
        unint64_t v5 = v4 >> v10;
      }
      else {
        unint64_t v5 = ((2 * v4) << ~v10) | (v5 >> v10);
      }
      if ((v10 & 0x40) != 0) {
        unint64_t v4 = 0;
      }
      else {
        v4 >>= v10;
      }
      if (a1 < 0xB)
      {
LABEL_19:
        char v16 = v12 + 48;
        if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v11)) {
          goto LABEL_20;
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v13 = __udivti3();
      unint64_t v4 = v14;
      unsigned __int8 v12 = v5 - v13 * a1;
      unint64_t v5 = v13;
      if (a1 < 0xB) {
        goto LABEL_19;
      }
    }
    if (v12 < 0xAu) {
      goto LABEL_19;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v11);
    if (a2)
    {
      char v16 = v12 + 55;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }
    else
    {
      char v16 = v12 + 87;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }
LABEL_25:
    uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v11[2]->isa + 1, 1, (uint64_t)v11);
LABEL_20:
    uint64_t v18 = v11[2];
    unint64_t v17 = (unint64_t)v11[3];
    if ((unint64_t)v18 >= v17 >> 1) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v17 > 1), (int64_t)&v18->isa + 1, 1, (uint64_t)v11);
    }
    v11[2] = (__objc2_class *)((char *)&v18->isa + 1);
    *((unsigned char *)&v18->info + (void)v11) = v16;
  }
  while (v5 | v4);
  unint64_t v34 = (unint64_t)v11;
  specialized MutableCollection<>.reverse()();
  size_t v19 = (size_t)v11[2];
  if (!v19)
  {
    uint64_t v25 = 0;
LABEL_47:
    swift_bridgeObjectRetain(v34);
    goto LABEL_48;
  }
  uint8x8_t v20 = (unsigned __int8 *)(v11 + 4);
  if (v19 <= 0xF)
  {
    uint64_t v26 = 8;
    if (v19 < 8) {
      uint64_t v26 = *(void *)(v34 + 16);
    }
    uint64_t v25 = *v20;
    if (v26 != 1)
    {
      v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 33) << 8;
      if (v26 != 2)
      {
        v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 34) << 16;
        if (v26 != 3)
        {
          v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 35) << 24;
          if (v26 != 4)
          {
            v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 36) << 32;
            if (v26 != 5)
            {
              v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 37) << 40;
              if (v26 != 6)
              {
                v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 38) << 48;
                if (v26 != 7) {
                  v25 |= (unint64_t)*(unsigned __int8 *)(v34 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v27 = 0;
    if (v19 >= 9)
    {
      uint64_t v28 = 0;
      uint64_t v29 = (unsigned __int8 *)(v34 + 40);
      size_t v30 = v19 - 8;
      do
      {
        if (v19 - 8 <= v19 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v31 = *v29++;
        v27 |= (unint64_t)v31 << v28;
        v28 += 8;
        --v30;
      }
      while (v30);
    }
    goto LABEL_47;
  }
  unint64_t v21 = v19 | 0xF000000000000000;
  int64_t v22 = _allocateStringStorage(codeUnitCapacity:)(*(void *)(v34 + 16));
  uint64_t v24 = v23;
  *(void *)(v22 + 16) = v23;
  *(void *)(v22 + 24) = v19 | 0xF000000000000000;
  swift_bridgeObjectRetain(v34);
  if (v24 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    unint64_t v21 = *(void *)(v22 + 24);
  }
  *(unsigned char *)(v22 + 32 + (v21 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v34 + 32), v19, (char *)(v22 + 32));
  uint64_t v25 = *(void *)(v22 + 24);
LABEL_48:
  swift_bridgeObjectRelease_n(v34, 2);
  return v25;
}

Swift::String __swiftcall BinaryInteger._description(radix:uppercase:)(Swift::Int radix, Swift::Bool uppercase)
{
  uint64_t v188 = (__objc2_class **)radix;
  uint64_t v4 = v2;
  LODWORD(v181) = uppercase;
  v193 = (void (*)(unsigned char *, uint64_t))v3;
  uint64_t v5 = *(void *)(v3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v5, v2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, 0, 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v184 = &v156[-v7];
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  v171 = *(int ***)(AssociatedConformanceWitness + 16);
  uint64_t v170 = swift_getAssociatedTypeWitness(0, v171, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](v170);
  uint64_t v192 = &v156[-v9];
  uint64_t v185 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v168 = &v156[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v183 = &v156[-v13];
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  char v16 = &v156[-v15];
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  size_t v19 = &v156[-v18];
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  int64_t v22 = &v156[-v21];
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = &v156[-v24];
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v28 = &v156[-v27];
  MEMORY[0x1F4188790](v26);
  size_t v30 = &v156[-v29];
  unsigned int v31 = *(int ***)(v5 + 16);
  unsigned int v32 = swift_getAssociatedTypeWitness(0, v31, v4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v33 = MEMORY[0x1F4188790](v32);
  uint64_t v34 = MEMORY[0x1F4188790](v33);
  uint64_t v35 = (void (*)(void, void, void))MEMORY[0x1F4188790](v34);
  if ((unint64_t)v188 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Radix must be between 2 and 36", 30, 2, "Swift/Integers.swift", 20, 2, 0x5E1uLL, 0);
  }
  uint64_t v178 = v39;
  uint64_t v179 = v35;
  uint64_t v180 = v38;
  v186 = &v156[-v36];
  v175 = v37;
  v172 = AssociatedTypeWitness;
  uint64_t v189 = v22;
  v190 = v25;
  uint64_t v158 = v19;
  uint64_t v194 = v16;
  __int16 v195 = v28;
  uint64_t v182 = v30;
  uint64_t v40 = (uint64_t)v193;
  Swift::tuple_high_UInt64_low_UInt64 v41 = v187;
  if ((*((uint64_t (**)(uint64_t, void))v193 + 16))(v4, v193) <= 64)
  {
    char v51 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 64))(v4, v40);
    uint64_t v52 = v180;
    char v53 = v186;
    (*(void (**)(unsigned char *, void (**)(void, uint64_t), uint64_t))(v180 + 16))(v186, v41, v4);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 120))(v4, v40);
    (*(void (**)(unsigned char *, uint64_t))(v52 + 8))(v53, v4);
    char v55 = v181 & 1;
    if (v51)
    {
      unint64_t countAndFlagsBits = _int64ToString(_:radix:uppercase:)(v54, (uint64_t)v188, v55, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    }
    else
    {
      Swift::String v72 = _uint64ToString(_:radix:uppercase:)(v54, (Swift::Int64)v188, v55);
      object = v72._object;
      unint64_t countAndFlagsBits = v72._countAndFlagsBits;
    }
    uint64_t v50 = countAndFlagsBits;
    int64_t v49 = (int64_t)object;
    goto LABEL_80;
  }
  uint64_t v167 = v5;
  uint64_t v42 = v31;
  uint64_t v43 = v179;
  uint64_t v44 = swift_getAssociatedConformanceWitness((uint64_t)v31, v4, (uint64_t)v179, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v45 = v178;
  uint64_t v165 = *(void (**)(void, void))(v44 + 8);
  ((void (*)(void *, uint64_t, void (*)(void, void, void), uint64_t))v165)(&unk_18162B0B8, 256, v43, v44);
  uint64_t v46 = v186;
  uint64_t v164 = v42[3];
  ((void (*)(uint64_t, uint64_t, int **))v164)(v45, v4, v42);
  LOBYTE(v43) = (*(uint64_t (**)(void (**)(void, uint64_t), unsigned char *, uint64_t))(*(void *)(*(void *)(v40 + 16) + 8) + 8))(v41, v46, v4);
  uint64_t v47 = v180;
  uint64_t v48 = *(void (**)(void, void))(v180 + 8);
  uint64_t v174 = v180 + 8;
  v166 = v48;
  v48(v46, v4);
  if (v43)
  {
    int64_t v49 = 0xE100000000000000;
    uint64_t v50 = 48;
    goto LABEL_80;
  }
  uint64_t v162 = v44 + 8;
  uint64_t v163 = v44;
  uint8x8_t v58 = (uint8x8_t)vcnt_s8((int8x8_t)v188);
  v58.i16[0] = vaddlv_u8(v58);
  uint64_t v176 = v58.u32[0];
  v197 = v188;
  uint64_t v59 = (void (*)(void, void))v4;
  uint64_t v60 = swift_getAssociatedConformanceWitness(v40, v4, (uint64_t)v172, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v61 = *(void (**)(__objc2_class ***, ValueMetadata *))(v60 + 88);
  unint64_t v177 = lazy protocol witness table accessor for type Int and conformance Int(v60, v62, v63);
  v61(&v197, &type metadata for Int);
  char v64 = (*(uint64_t (**)(void, uint64_t))(v40 + 64))(v59, v40);
  __int16 v65 = v175;
  (*(void (**)(uint64_t (*)(void, void), void (**)(void, uint64_t), void (*)(void, void)))(v47 + 16))(v175, v41, v59);
  if (v64)
  {
    uint64_t v66 = v178;
    v165(&unk_18162B0B8, 256);
    char v67 = v186;
    ((void (*)(uint64_t, void (*)(void, void), int **))v164)(v66, v59, v42);
    int v157 = (*(uint64_t (**)(uint64_t (*)(void, void), unsigned char *, void (*)(void, void)))(*(void *)(*(void *)(v40 + 32) + 8) + 16))(v65, v67, v59);
    uint64_t v68 = v166;
    v166(v67, v59);
    uint64_t v69 = v171;
    char v70 = v192;
    uint64_t v71 = v185;
  }
  else
  {
    int v157 = 0;
    uint64_t v69 = v171;
    char v70 = v192;
    uint64_t v71 = v185;
    uint64_t v68 = v166;
  }
  v68(v65, v59);
  unint64_t v73 = *(void (**)(void))(v167 + 56);
  unint64_t v74 = v195;
  v166 = v59;
  v73(v59);
  uint64_t v75 = *(uint64_t (**)(void, void))(v60 + 64);
  v186 = (unsigned char *)(v60 + 120);
  unint64_t v77 = *(void (**)(void, void, void))(v71 + 16);
  uint64_t v76 = v71 + 16;
  uint64_t v178 = v60 + 128;
  uint64_t v179 = v77;
  uint64_t v163 = v60 + 96;
  v197 = &_swiftEmptyArrayStorage;
  uint64_t v165 = (void (*)(void, void))(v69 + 3);
  uint64_t v78 = v74;
  uint64_t v79 = (int *)(v76 + 16);
  uint64_t v162 = v60 + 272;
  unint64_t v161 = __clz(__rbit64((unint64_t)v188));
  uint64_t v160 = v60 + 240;
  uint64_t v180 = v60 + 64;
  uint64_t v159 = v60 + 192;
  if (v181) {
    int v80 = 55;
  }
  else {
    int v80 = 87;
  }
  LODWORD(v174) = v80;
  uint64_t v187 = (void (**)(void, uint64_t))(v76 - 8);
  uint64_t v181 = (v76 - 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  uint64_t v185 = v76;
  v175 = v75;
  uint64_t v164 = (int *)(v76 + 16);
  uint64_t v81 = (uint64_t)v172;
  for (i = v60; ; uint64_t v60 = i)
  {
    int v82 = v190;
    v179(v190, v78, v81);
    char v83 = v75(v81, v60);
    uint64_t v84 = v184;
    if (v83)
    {
      uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 128))(v81, v60);
      char v86 = v189;
      uint64_t v87 = v81;
      if (v85 >= 64)
      {
        unint64_t v196 = 0;
        (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v60 + 96))(&v196, &type metadata for Int, v177, v81, v60);
        uint64_t v103 = swift_getAssociatedConformanceWitness(v167, (uint64_t)v166, v81, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        __int16 v104 = v82;
        char v105 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v103 + 8) + 8))(v82, v86, v81);
        uint64_t v91 = *v187;
        (*v187)(v86, v87);
        v91(v104, v87);
        if (v105) {
          goto LABEL_49;
        }
        goto LABEL_34;
      }
      uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 120))(v81, v60);
      char v89 = v82;
      uint64_t v90 = v88;
      uint64_t v91 = *v187;
      (*v187)(v89, v87);
      uint64_t v92 = TupleTypeMetadata2;
      if (!v90) {
        goto LABEL_49;
      }
      goto LABEL_35;
    }
    char v93 = v75(v81, v60);
    uint64_t v87 = v81;
    uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 128))(v81, v60);
    uint64_t v95 = v189;
    if ((v93 & 1) == 0) {
      break;
    }
    if (v94 > 64) {
      goto LABEL_31;
    }
    uint64_t v96 = v171;
    v97 = v170;
    uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v171, v81, (uint64_t)v170, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, const char *, uint64_t))(v98 + 8))(&unk_18162B0B8, 256, v97, v98);
    ((void (*)(unsigned char *, uint64_t, int **))v96[3])(v70, v81, v96);
    uint64_t v99 = swift_getAssociatedConformanceWitness(v167, (uint64_t)v166, v81, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    uint64_t v100 = v190;
    LOBYTE(v96) = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t, uint64_t))(v99 + 32))(v190, v95, v81, v99);
    uint64_t v91 = *v187;
    (*v187)(v95, v87);
    v101 = v158;
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))v79)(v158, v100, v87);
    if ((v96 & 1) == 0)
    {
      v91(v101, v87);
      uint64_t v79 = v164;
      goto LABEL_34;
    }
    uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 120))(v87, v60);
    v91(v158, v87);
    uint64_t v92 = TupleTypeMetadata2;
    if (!v102) {
      goto LABEL_49;
    }
    uint64_t v79 = v164;
LABEL_35:
    v193 = (void (*)(unsigned char *, uint64_t))v91;
    if (v176 == 1)
    {
      v172 = &v84[*((int *)v92 + 12)];
      unint64_t v196 = v161;
      uint64_t v111 = v195;
      (*(void (**)(unsigned char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v60 + 240))(v195, &v196, &type metadata for Int, v177, v87, v60);
      uint64_t v112 = v170;
      uint64_t v113 = v171;
      uint64_t v114 = swift_getAssociatedConformanceWitness((uint64_t)v171, v87, (uint64_t)v170, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v115 = v192;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v114 + 8))(&qword_18162B0C0, 512, v112, v114);
      v116 = v168;
      uint64_t v117 = v87;
      ((void (*)(unsigned char *, uint64_t, int **))v113[3])(v115, v87, v113);
      uint64_t v118 = v189;
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 40))(v182, v116, v87);
      __int16 v119 = v116;
      uint64_t v120 = v60;
      uint64_t v121 = v164;
      int v122 = v183;
      uint64_t v123 = v87;
      uint64_t v124 = v193;
      v193(v119, v123);
      uint64_t v125 = *(void (**)(unsigned char *, unsigned char *, uint64_t, uint64_t))(v60 + 192);
      uint64_t v126 = v194;
      v125(v111, v118, v117, v120);
      v124(v118, v117);
      uint64_t v92 = TupleTypeMetadata2;
    }
    else
    {
      uint64_t v111 = v195;
      (*(void (**)(unsigned char *, unsigned char *, unsigned char *, uint64_t, uint64_t))(v60 + 272))(v84, &v84[*((int *)v92 + 12)], v182, v87, v60);
      uint64_t v117 = v87;
      uint64_t v120 = v60;
      uint64_t v121 = v79;
      int v122 = v183;
      uint64_t v124 = v193;
      uint64_t v126 = v194;
    }
    v124(v111, v117);
    uint64_t v127 = &v84[*((int *)v92 + 12)];
    unint64_t v128 = *(void (**)(unsigned char *, unsigned char *, uint64_t))v121;
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))v121)(v126, v84, v117);
    char v129 = v121;
    v128(v122, v127, v117);
    unsigned __int8 v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v120 + 120))(v117, v120);
    uint64_t v81 = v117;
    v124(v122, v117);
    if (v130 >= 0xAu && (unint64_t)v188 >= 0xB) {
      char v132 = v174;
    }
    else {
      char v132 = 48;
    }
    uint64_t v133 = v197;
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v197)) {
      uint64_t v133 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v133[2]->isa + 1, 1, (uint64_t)v133);
    }
    uint64_t v135 = v133[2];
    unint64_t v134 = (unint64_t)v133[3];
    uint64_t v79 = v129;
    if ((unint64_t)v135 >= v134 >> 1) {
      uint64_t v133 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v134 > 1), (int64_t)&v135->isa + 1, 1, (uint64_t)v133);
    }
    v133[2] = (__objc2_class *)((char *)&v135->isa + 1);
    *((unsigned char *)&v135->info + (void)v133) = v132 + v130;
    v197 = v133;
    uint64_t v78 = v195;
    v128(v195, v194, v81);
    char v70 = v192;
    uint64_t v75 = v175;
  }
  if (v94 < 64)
  {
    uint64_t v106 = v190;
    uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 120))(v81, v60);
    uint64_t v91 = *v187;
    (*v187)(v106, v87);
    uint64_t v92 = TupleTypeMetadata2;
    if (!v107) {
      goto LABEL_49;
    }
    goto LABEL_35;
  }
LABEL_31:
  unint64_t v196 = 0;
  (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v60 + 96))(&v196, &type metadata for Int, v177, v81, v60);
  uint64_t v108 = swift_getAssociatedConformanceWitness(v167, (uint64_t)v166, v81, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  uint64_t v109 = v190;
  char v110 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v108 + 8) + 8))(v190, v95, v81);
  uint64_t v91 = *v187;
  (*v187)(v95, v87);
  v91(v109, v87);
  if ((v110 & 1) == 0)
  {
LABEL_34:
    uint64_t v92 = TupleTypeMetadata2;
    goto LABEL_35;
  }
LABEL_49:
  uint64_t v136 = v182;
  char v137 = v157;
  v91(v195, v87);
  v91(v136, v87);
  if (v137)
  {
    uint64_t v138 = v197;
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v197)) {
      uint64_t v138 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v138[2]->isa + 1, 1, (uint64_t)v138);
    }
    unint64_t v140 = v138[2];
    unint64_t v139 = (unint64_t)v138[3];
    if ((unint64_t)v140 >= v139 >> 1) {
      uint64_t v138 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v139 > 1), (int64_t)&v140->isa + 1, 1, (uint64_t)v138);
    }
    v138[2] = (__objc2_class *)((char *)&v140->isa + 1);
    *((unsigned char *)&v140->info + (void)v138) = 45;
    v197 = v138;
  }
  specialized MutableCollection<>.reverse()();
  __int16 v141 = v197;
  size_t v142 = (size_t)v197[2];
  if (!v142)
  {
    uint64_t v50 = 0;
    int64_t v49 = 0xE000000000000000;
LABEL_78:
    swift_bridgeObjectRetain((unint64_t)v197);
    goto LABEL_79;
  }
  if (v142 <= 0xF)
  {
    uint64_t v146 = 8;
    if (v142 < 8) {
      uint64_t v146 = (uint64_t)v197[2];
    }
    uint64_t v50 = *((unsigned __int8 *)v197 + 32);
    if (v146 != 1)
    {
      v50 |= (unint64_t)*((unsigned __int8 *)v197 + 33) << 8;
      if (v146 != 2)
      {
        v50 |= (unint64_t)*((unsigned __int8 *)v197 + 34) << 16;
        if (v146 != 3)
        {
          v50 |= (unint64_t)*((unsigned __int8 *)v197 + 35) << 24;
          if (v146 != 4)
          {
            v50 |= (unint64_t)*((unsigned __int8 *)v197 + 36) << 32;
            if (v146 != 5)
            {
              v50 |= (unint64_t)*((unsigned __int8 *)v197 + 37) << 40;
              if (v146 != 6)
              {
                v50 |= (unint64_t)*((unsigned __int8 *)v197 + 38) << 48;
                if (v146 != 7) {
                  v50 |= (unint64_t)*((unsigned __int8 *)v197 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v147 = 0;
    if (v142 >= 9)
    {
      uint64_t v148 = 0;
      uint64_t v149 = (unsigned __int8 *)(v197 + 5);
      size_t v150 = v142 - 8;
      do
      {
        if (v142 - 8 <= v142 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v151 = *v149++;
        v147 |= (unint64_t)v151 << v148;
        v148 += 8;
        --v150;
      }
      while (v150);
    }
    unint64_t v152 = 0xA000000000000000;
    if (((v147 | v50) & 0x8080808080808080) == 0) {
      unint64_t v152 = 0xE000000000000000;
    }
    int64_t v49 = v152 | (v142 << 56) | v147;
    goto LABEL_78;
  }
  unint64_t v143 = v142 | 0xF000000000000000;
  int64_t v49 = _allocateStringStorage(codeUnitCapacity:)((int64_t)v197[2]);
  uint64_t v145 = v144;
  *(void *)(v49 + 16) = v144;
  *(void *)(v49 + 24) = v142 | 0xF000000000000000;
  swift_bridgeObjectRetain((unint64_t)v141);
  if (v145 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    unint64_t v143 = *(void *)(v49 + 24);
  }
  *(unsigned char *)(v49 + 32 + (v143 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)v141 + 32, v142, (char *)(v49 + 32));
  uint64_t v50 = *(void *)(v49 + 24);
LABEL_79:
  swift_bridgeObjectRelease_n((uint64_t)v141, 2);
LABEL_80:
  uint64_t v153 = v50;
  v154 = (void *)v49;
  result._object = v154;
  result._unint64_t countAndFlagsBits = v153;
  return result;
}

Swift::String __swiftcall _uint64ToString(_:radix:uppercase:)(Swift::UInt64 _, Swift::Int64 radix, Swift::Bool uppercase)
{
  unint64_t v3 = _int64ToString(_:radix:uppercase:)(_, radix, uppercase, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_uint64ToString);
  result._object = v4;
  result._unint64_t countAndFlagsBits = v3;
  return result;
}

unint64_t _int64ToString(_:radix:uppercase:)(uint64_t a1, uint64_t a2, char a3, uint64_t (*a4)(long long *, uint64_t, uint64_t, uint64_t, void))
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a2 < 10)
  {
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long __src = 0u;
    long long v26 = 0u;
    uint64_t v4 = a4(&__src, 72, a1, a2, a3 & 1);
    if ((v4 & 0x8000000000000000) == 0)
    {
      size_t v5 = v4;
      if (v4)
      {
        if ((unint64_t)v4 <= 0xF)
        {
          uint64_t v6 = v4 - 8;
          uint64_t v7 = 8;
          if (v4 < 8) {
            uint64_t v7 = v4;
          }
          unint64_t result = __src;
          if (v7 != 1)
          {
            unint64_t result = __src | ((unint64_t)BYTE1(__src) << 8);
            if (v7 != 2)
            {
              result |= (unint64_t)BYTE2(__src) << 16;
              if (v7 != 3)
              {
                result |= (unint64_t)BYTE3(__src) << 24;
                if (v7 != 4)
                {
                  result |= (unint64_t)BYTE4(__src) << 32;
                  if (v7 != 5)
                  {
                    result |= (unint64_t)BYTE5(__src) << 40;
                    if (v7 != 6)
                    {
                      result |= (unint64_t)BYTE6(__src) << 48;
                      if (v7 != 7) {
                        result |= (unint64_t)BYTE7(__src) << 56;
                      }
                    }
                  }
                }
              }
            }
          }
          uint64_t v9 = 0;
          if (v5 >= 9)
          {
            uint64_t v10 = 0;
            uint64_t v11 = (unsigned __int8 *)&__src + 8;
            unint64_t v12 = v6 & ~(v6 >> 63);
            while (v12 > v5 - 9)
            {
              unsigned int v13 = *v11++;
              v9 |= (unint64_t)v13 << v10;
              v10 += 8;
              if (!--v6) {
                return result;
              }
            }
            goto LABEL_42;
          }
          return result;
        }
LABEL_23:
        unint64_t v15 = v5 | 0xF000000000000000;
        int64_t v16 = _allocateStringStorage(codeUnitCapacity:)(v5);
        *(void *)(v16 + 16) = v17;
        *(void *)(v16 + 24) = v5 | 0xF000000000000000;
        if (v17 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
          unint64_t v15 = *(void *)(v16 + 24);
        }
        *(unsigned char *)(v16 + 32 + (v15 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v5, (char *)(v16 + 32));
        return *(void *)(v16 + 24);
      }
      return 0;
    }
LABEL_43:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  long long __src = 0u;
  long long v26 = 0u;
  uint64_t v14 = a4(&__src, 32, a1, a2, a3 & 1);
  if (v14 < 0) {
    goto LABEL_43;
  }
  size_t v5 = v14;
  if (!v14) {
    return 0;
  }
  if ((unint64_t)v14 > 0xF) {
    goto LABEL_23;
  }
  uint64_t v18 = v14 - 8;
  uint64_t v19 = 8;
  if (v14 < 8) {
    uint64_t v19 = v14;
  }
  unint64_t result = __src;
  if (v19 != 1)
  {
    unint64_t result = __src | ((unint64_t)BYTE1(__src) << 8);
    if (v19 != 2)
    {
      result |= (unint64_t)BYTE2(__src) << 16;
      if (v19 != 3)
      {
        result |= (unint64_t)BYTE3(__src) << 24;
        if (v19 != 4)
        {
          result |= (unint64_t)BYTE4(__src) << 32;
          if (v19 != 5)
          {
            result |= (unint64_t)BYTE5(__src) << 40;
            if (v19 != 6)
            {
              result |= (unint64_t)BYTE6(__src) << 48;
              if (v19 != 7) {
                result |= (unint64_t)BYTE7(__src) << 56;
              }
            }
          }
        }
      }
    }
  }
  uint64_t v20 = 0;
  if (v5 >= 9)
  {
    uint64_t v21 = 0;
    int64_t v22 = (unsigned __int8 *)&__src + 8;
    unint64_t v23 = v18 & ~(v18 >> 63);
    while (v23 > v5 - 9)
    {
      unsigned int v24 = *v22++;
      v20 |= (unint64_t)v24 << v21;
      v21 += 8;
      if (!--v18) {
        return result;
      }
    }
LABEL_42:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
  }
  return result;
}

uint64_t Int.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t Int.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

void specialized MutableCollection<>.reverse()()
{
  uint8x8_t v1 = (__objc2_class **)*v0;
  uint64_t v2 = *(void *)(*v0 + 16);
  if (v2) {
    BOOL v3 = v2 == 1;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
    *uint64_t v0 = (uint64_t)v1;
    if (!isUniquelyReferenced_nonNull_native) {
      uint8x8_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v1);
    }
    unint64_t v5 = 0;
    *uint64_t v0 = (uint64_t)v1;
    uint64_t v6 = v2 + 31;
    do
    {
      if (v5 != v6 - 32)
      {
        unint64_t v8 = (unint64_t)v1[2];
        if (v5 >= v8 || v6 - 32 >= v8) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
        char v9 = *((unsigned char *)v1 + v5 + 32);
        *((unsigned char *)v1 + v5 + 32) = *((unsigned char *)v1 + v6);
        *((unsigned char *)v1 + v6) = v9;
      }
      ++v5;
      int64_t v7 = v6 - 33;
      --v6;
    }
    while ((uint64_t)v5 < v7);
    *uint64_t v0 = (uint64_t)v1;
  }
}

{
  uint64_t *v0;
  __objc2_class **v1;
  uint64_t v2;
  unint64_t v3;
  BOOL isUniquelyReferenced_nonNull_native;
  _WORD *v5;
  _WORD *v6;
  uint64_t v7;
  unint64_t v9;
  __int16 v10;
  int v11;
  __int16 v12;

  uint8x8_t v1 = (__objc2_class **)*v0;
  uint64_t v2 = *(void *)(*v0 + 16);
  if (v2)
  {
    BOOL v3 = v2 - 1;
    if (v2 != 1)
    {
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
      *uint64_t v0 = (uint64_t)v1;
      if (!isUniquelyReferenced_nonNull_native) {
        uint8x8_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v1);
      }
      *uint64_t v0 = (uint64_t)v1;
      unint64_t v5 = (_WORD *)&v1[v2 + 3] + 2;
      uint64_t v6 = (_WORD *)v1 + 18;
      int64_t v7 = 1;
      do
      {
        if (v7 - 1 != v3)
        {
          char v9 = (unint64_t)v1[2];
          if (v7 - 1 >= v9 || v3 >= v9) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
          }
          uint64_t v10 = *v6;
          uint64_t v11 = *((_DWORD *)v6 - 1);
          unint64_t v12 = *v5;
          *((_DWORD *)v6 - 1) = *((_DWORD *)v5 - 1);
          *uint64_t v6 = v12;
          *((_DWORD *)v5 - 1) = v11;
          *unint64_t v5 = v10;
        }
        --v3;
        v5 -= 4;
        v6 += 4;
      }
      while (v7++ < (uint64_t)v3);
      *uint64_t v0 = (uint64_t)v1;
    }
  }
}

uint64_t MutableCollection<>.reverse()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)v27 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  unsigned int v13 = (char *)v27 - v12;
  MEMORY[0x1F4188790](v11);
  unint64_t v15 = (char *)v27 - v14;
  int64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 104);
  uint64_t v34 = v5;
  uint64_t result = v16(a1, v5);
  if ((result & 1) == 0)
  {
    uint64_t v18 = v34;
    (*(void (**)(uint64_t, uint64_t))(v34 + 64))(a1, v34);
    (*(void (**)(uint64_t, uint64_t))(v18 + 72))(a1, v18);
    (*(void (**)(char *, uint64_t))(v35 + 32))(v10, a1);
    v27[0] = *(void *)(v7 + 8);
    v27[1] = v7 + 8;
    ((void (*)(char *, const char *))v27[0])(v10, AssociatedTypeWitness);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v18, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
    uint64_t v20 = *(uint64_t (**)(char *, char *, const char *))(AssociatedConformanceWitness + 16);
    uint64_t v32 = AssociatedConformanceWitness;
    char v21 = v20(v15, v13, AssociatedTypeWitness);
    uint64_t v33 = a3;
    if (v21)
    {
      int64_t v22 = (uint64_t (*)(char *, char *, const char *, uint64_t))v20;
      uint64_t v30 = *(void (**)(char *, char *, uint64_t, uint64_t))(v33 + 64);
      uint64_t v31 = v33 + 64;
      long long v28 = *(void (**)(char *, uint64_t, uint64_t))(v34 + 192);
      uint64_t v29 = v34 + 192;
      unint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v35 + 40);
      do
      {
        unsigned int v24 = v22;
        v30(v15, v13, a1, v33);
        v28(v15, a1, v34);
        v23(v13, a1, v35);
        char v25 = v24(v15, v13, AssociatedTypeWitness, v32);
        int64_t v22 = v24;
      }
      while ((v25 & 1) != 0);
    }
    long long v26 = (uint64_t (*)(char *, const char *))v27[0];
    ((void (*)(char *, const char *))v27[0])(v13, AssociatedTypeWitness);
    return v26(v15, AssociatedTypeWitness);
  }
  return result;
}

uint64_t BinaryInteger.distance(to:)(void (*a1)(void, void, void), uint64_t a2, uint64_t a3)
{
  v438 = a1;
  uint64_t v5 = *(void *)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v5, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  v402 = *(int ***)(AssociatedConformanceWitness + 16);
  v401 = swift_getAssociatedTypeWitness(0, v402, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v401);
  v400 = (char *)&v399 - v7;
  v419 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v425 = (void *)*(v419 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v419);
  v403 = (char *)&v399 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  v418 = (char *)&v399 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  v423 = (char *)&v399 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  v416 = (char *)&v399 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  v411 = (char *)&v399 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v422 = (char *)&v399 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v426 = (char *)&v399 - v21;
  MEMORY[0x1F4188790](v20);
  v431 = (uint64_t (**)(char *, char *, uint64_t))((char *)&v399 - v22);
  unint64_t v23 = *(int ***)(v5 + 16);
  unsigned int v24 = swift_getAssociatedTypeWitness(0, v23, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v25 = MEMORY[0x1F4188790](v24);
  long long v27 = (char *)&v399 - v26;
  uint64_t v436 = *(void *)(a2 - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  v399 = (char *)&v399 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v417 = (char *)&v399 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v415 = (char *)&v399 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  v412 = (char *)&v399 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v409 = (uint64_t)&v399 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v428 = (char *)&v399 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  v405 = (char *)&v399 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  uint64_t v44 = (char *)&v399 - v43;
  uint64_t v45 = MEMORY[0x1F4188790](v42);
  v413 = (char *)&v399 - v46;
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  v424 = (char *)&v399 - v48;
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  v439 = (char *)&v399 - v50;
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  v429 = (char *)&v399 - v52;
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  v404 = (char *)&v399 - v54;
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  v408 = (char *)&v399 - v56;
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  v414 = (char *)&v399 - v58;
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  v420 = (int *)((char *)&v399 - v60);
  uint64_t v61 = MEMORY[0x1F4188790](v59);
  uint64_t v63 = (char *)&v399 - v62;
  uint64_t v64 = MEMORY[0x1F4188790](v61);
  v421 = (char *)&v399 - v65;
  uint64_t v66 = MEMORY[0x1F4188790](v64);
  uint64_t v68 = (char *)&v399 - v67;
  MEMORY[0x1F4188790](v66);
  v432 = (char *)&v399 - v69;
  char v70 = *(uint64_t (**)(void, void))(a3 + 64);
  v433 = (void (*)(void))(a3 + 64);
  uint64_t v434 = a3;
  v435 = v70;
  char v71 = v70(a2, a3);
  v430 = v63;
  v427 = v23;
  v406 = v24;
  if ((v71 & 1) == 0)
  {
    v426 = v27;
    uint64_t v106 = v434;
    uint64_t v107 = *(uint64_t (**)(void, void, void))(*(void *)(*(void *)(v434 + 32) + 8) + 40);
    v431 = *(uint64_t (***)(char *, char *, uint64_t))(*(void *)(v434 + 32) + 8);
    char v108 = v107(v437, v438, a2);
    uint64_t v109 = *(void (**)(void, void, void))(*(void *)(v5 + 8) + 40);
    char v110 = (void *)(v436 + 16);
    uint64_t v111 = a2;
    if (v108)
    {
      uint64_t v112 = v432;
      v109(v437, v438, a2);
      char v113 = v435(a2, v106);
      uint64_t v114 = (void (*)(char *, void, uint64_t))*v110;
      ((void (*)(char *, char *, uint64_t))*v110)(v68, v112, a2);
      v437 = (void (*)(void, void, void))v114;
      BOOL v115 = (v113 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 128))(a2, v106) > 64;
      unint64_t v152 = v421;
      v154 = (void (*)(void, void, void))(v436 + 8);
      uint64_t v153 = *(char **)(v436 + 8);
      uint64_t AssociatedConformanceWitness = (v436 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      ((void (*)(char *, uint64_t))v153)(v68, a2);
      v437(v152, v432, a2);
      v438 = v154;
      v439 = v153;
      if (!v115)
      {
        ((void (*)(char *, uint64_t))v153)(v152, a2);
        uint64_t v156 = *(char **)(v106 + 128);
        uint64_t v163 = (uint64_t)v432;
        uint64_t v161 = a2;
        uint64_t v164 = (char *)v420;
        goto LABEL_45;
      }
      int64_t v441 = 0x8000000000000000;
      uint64_t v155 = v435;
      if (v435(a2, v106))
      {
        uint64_t v156 = *(char **)(v106 + 128);
        uint64_t v157 = ((uint64_t (*)(uint64_t, uint64_t))v156)(a2, v106);
        uint64_t v160 = v152;
        uint64_t v161 = a2;
        if (v157 >= 64)
        {
          v429 = *(char **)(v106 + 96);
          unint64_t v330 = lazy protocol witness table accessor for type Int and conformance Int(v157, v158, v159);
          v331 = v430;
          ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v429)(&v441, &type metadata for Int, v330, a2, v106);
          char v332 = v431[2](v160, v331, a2);
          ((void (*)(char *, uint64_t))v153)(v331, a2);
          ((void (*)(char *, uint64_t))v153)(v160, a2);
          uint64_t v163 = (uint64_t)v432;
          uint64_t v164 = (char *)v420;
          if (v332) {
            goto LABEL_120;
          }
        }
        else
        {
          uint64_t v162 = (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 120))(a2, v106);
          ((void (*)(char *, uint64_t))v153)(v160, a2);
          uint64_t v163 = (uint64_t)v432;
          uint64_t v164 = (char *)v420;
          if (v162 < v441) {
            goto LABEL_120;
          }
        }
      }
      else
      {
        char v252 = v155(a2, v106);
        uint64_t v156 = *(char **)(v106 + 128);
        v429 = (char *)((v106 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000);
        uint64_t v409 = v111;
        uint64_t v253 = ((uint64_t (*)(uint64_t, uint64_t))v156)(v111, v106);
        uint64_t v164 = (char *)v420;
        if (v252)
        {
          if (v253 > 64)
          {
            v256 = *(void (**)(void, void, void, void, void))(v106 + 96);
            unint64_t v257 = lazy protocol witness table accessor for type Int and conformance Int(v253, v254, v255);
            v258 = v430;
            uint64_t v161 = v409;
            v256(&v441, &type metadata for Int, v257, v409, v106);
            v259 = v164;
            v260 = v421;
            char v261 = v431[2](v421, v258, v161);
            ((void (*)(char *, uint64_t))v153)(v258, v161);
            v262 = v260;
            uint64_t v164 = v259;
            ((void (*)(char *, uint64_t))v153)(v262, v161);
            uint64_t v163 = (uint64_t)v432;
            if (v261) {
              goto LABEL_165;
            }
            goto LABEL_45;
          }
          v425 = v110;
          uint64_t v356 = (uint64_t)v427;
          uint64_t v357 = v409;
          uint64_t v358 = (uint64_t)v406;
          uint64_t v359 = swift_getAssociatedConformanceWitness((uint64_t)v427, v409, (uint64_t)v406, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v360 = v426;
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v359 + 8))(&qword_18162B0B8, 256, v358, v359);
          v361 = v430;
          v362 = v360;
          uint64_t v161 = v357;
          (*(void (**)(char *, uint64_t, uint64_t))(v356 + 24))(v362, v357, v356);
          v363 = v421;
          LOBYTE(v358) = v431[2](v421, v361, v357);
          ((void (*)(char *, uint64_t))v153)(v361, v357);
          v364 = v404;
          (*(void (**)(char *, char *, uint64_t))(v436 + 32))(v404, v363, v161);
          if (v358)
          {
            ((void (*)(char *, uint64_t))v153)(v364, v161);
            goto LABEL_165;
          }
          int64_t v365 = v441;
          uint64_t v366 = (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 120))(v161, v106);
          ((void (*)(char *, uint64_t))v153)(v364, v161);
          BOOL v340 = v366 < v365;
          uint64_t v163 = (uint64_t)v432;
          uint64_t v164 = (char *)v420;
        }
        else
        {
          if (v253 >= 64)
          {
            v379 = v152;
            uint64_t v161 = v409;
            ((void (*)(char *, uint64_t))v153)(v379, v409);
            uint64_t v163 = (uint64_t)v432;
            goto LABEL_45;
          }
          v338 = v152;
          uint64_t v161 = v409;
          uint64_t v339 = (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 120))(v409, v106);
          ((void (*)(char *, uint64_t))v153)(v338, v161);
          BOOL v340 = v339 < v441;
          uint64_t v163 = (uint64_t)v432;
        }
        if (v340) {
          goto LABEL_165;
        }
      }
LABEL_45:
      uint64_t v197 = ((uint64_t (*)(uint64_t, uint64_t))v156)(v161, v106);
      v198 = v156;
      v199 = v437;
      v437(v164, v163, v161);
      v200 = v435;
      v429 = v198;
      if (v197 >= 65)
      {
        ((void (*)(char *, uint64_t))v439)(v164, v161);
        v201 = v414;
        v199(v414, v163, v161);
        uint64_t v111 = (uint64_t)v201;
LABEL_60:
        int64_t v441 = 0x7FFFFFFFFFFFFFFFLL;
        char v224 = v200(v161, v106);
        uint64_t v225 = ((uint64_t (*)(uint64_t, uint64_t))v429)(v161, v106);
        if (v224)
        {
          v228 = v430;
          if (v225 > 64)
          {
            v229 = *(void (**)(void, void, void, void, void))(v106 + 96);
            unint64_t v230 = lazy protocol witness table accessor for type Int and conformance Int(v225, v226, v227);
            v229(&v441, &type metadata for Int, v230, v161, v106);
            uint64_t v163 = (uint64_t)v432;
            char v231 = v431[2](v228, (char *)v111, v161);
            v232 = v439;
            ((void (*)(char *, uint64_t))v439)(v228, v161);
            uint64_t v233 = v111;
            goto LABEL_104;
          }
        }
        else
        {
          v228 = v430;
          if (v225 > 63)
          {
            uint64_t v440 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v292 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v436 + 32))(v430, v111, v161);
            v293 = *(void (**)(void, void, void, void, void))(v106 + 96);
            unint64_t v296 = lazy protocol witness table accessor for type Int and conformance Int(v292, v294, v295);
            v297 = v408;
            v293(&v440, &type metadata for Int, v296, v161, v106);
            uint64_t v163 = (uint64_t)v432;
            char v231 = v431[2](v297, v228, v161);
            v232 = v439;
            ((void (*)(char *, uint64_t))v439)(v297, v161);
            uint64_t v233 = (uint64_t)v228;
LABEL_104:
            ((void (*)(uint64_t, uint64_t))v232)(v233, v161);
            if ((v231 & 1) == 0) {
              goto LABEL_105;
            }
LABEL_120:
            uint64_t v409 = v161;
            goto LABEL_165;
          }
        }
        (*(void (**)(char *, uint64_t, uint64_t))(v436 + 32))(v228, v111, v161);
        (*(void (**)(uint64_t, uint64_t))(v106 + 120))(v161, v106);
        v232 = v439;
        ((void (*)(char *, uint64_t))v439)(v228, v161);
LABEL_105:
        uint64_t v298 = (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 120))(v161, v106);
        ((void (*)(uint64_t, uint64_t))v232)(v163, v161);
        BOOL v283 = __OFSUB__(0, v298);
        uint64_t v282 = -v298;
        if (!v283) {
          return v282;
        }
        __break(1u);
LABEL_108:
        uint64_t v440 = 0x7FFFFFFFFFFFFFFFLL;
        v299 = v430;
        uint64_t v300 = (*(uint64_t (**)(char *, char *, uint64_t))(v436 + 32))(v430, v432, v111);
        v301 = (void (*)(void, void))v106;
        uint64_t v302 = v163;
        v303 = *(void (**)(void, void, void, void, void))(v163 + 96);
        unint64_t v306 = lazy protocol witness table accessor for type Int and conformance Int(v300, v304, v305);
        v307 = v408;
        v303(&v440, &type metadata for Int, v306, v111, v302);
        uint64_t v163 = v302;
        uint64_t v106 = (uint64_t)v301;
        char v308 = v431[2](v307, v299, v111);
        v301(v307, v111);
        v309 = v299;
        v207 = v429;
        v301(v309, v111);
        if ((v308 & 1) == 0) {
          goto LABEL_109;
        }
LABEL_159:
        uint64_t v409 = v111;
        v432 = v207;
        goto LABEL_165;
      }
      uint64_t v222 = ((uint64_t (*)(uint64_t, uint64_t))v198)(v161, v106);
      ((void (*)(char *, uint64_t))v439)(v164, v161);
      if (v222 == 64)
      {
        char v223 = v200(v161, v106);
        uint64_t v111 = (uint64_t)v414;
        v199(v414, v163, v161);
        if ((v223 & 1) == 0) {
          goto LABEL_60;
        }
      }
      else
      {
        uint64_t v111 = (uint64_t)v414;
        v199(v414, v163, v161);
      }
      v232 = v439;
      ((void (*)(uint64_t, uint64_t))v439)(v111, v161);
      goto LABEL_105;
    }
    uint64_t v137 = v436;
    v432 = v44;
    uint64_t v138 = v429;
    v109(v438, v437, a2);
    unint64_t v139 = v435;
    char v140 = v435(a2, v106);
    __int16 v141 = (void (*)(void, void, void))*v110;
    size_t v142 = v439;
    unint64_t v143 = v110;
    ((void (*)(char *, char *, uint64_t))*v110)(v439, v138, v111);
    v438 = v141;
    uint64_t v144 = v106;
    BOOL v145 = (v140 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 128))(v111, v106) > 64;
    uint64_t v179 = v142;
    uint64_t v180 = (void (*)(void, void, void))(v137 + 8);
    uint64_t v181 = *(char **)(v137 + 8);
    uint64_t v182 = (v137 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    ((void (*)(char *, uint64_t))v181)(v179, v111);
    uint64_t v183 = v424;
    uint64_t v184 = v429;
    v438(v424, v429, v111);
    v439 = v181;
    uint64_t AssociatedConformanceWitness = v182;
    v437 = v180;
    if (!v145)
    {
      ((void (*)(char *, uint64_t))v181)(v183, v111);
      uint64_t v163 = v144;
      uint64_t v194 = *(uint64_t (**)(void, void))(v144 + 128);
      uint64_t v195 = (v144 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
      unint64_t v196 = v143;
      uint64_t v192 = v432;
      v193 = v413;
      goto LABEL_48;
    }
    int64_t v441 = 0x8000000000000000;
    uint64_t v185 = v144;
    if (v139(v111, v144))
    {
      v186 = *(void **)(v144 + 128);
      v428 = (char *)((v144 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000);
      uint64_t v187 = v424;
      v425 = v186;
      uint64_t v188 = ((uint64_t (*)(uint64_t, uint64_t))v186)(v111, v185);
      if (v188 >= 64)
      {
        v333 = *(void (**)(void, void, void, void, void))(v185 + 96);
        unint64_t v334 = lazy protocol witness table accessor for type Int and conformance Int(v188, v189, v190);
        v335 = v430;
        v333(&v441, &type metadata for Int, v334, v111, v185);
        v336 = v439;
        char v337 = v431[2](v187, v335, v111);
        uint64_t v184 = v429;
        ((void (*)(char *, uint64_t))v336)(v335, v111);
        ((void (*)(char *, uint64_t))v336)(v187, v111);
        uint64_t v163 = v185;
        uint64_t v192 = v432;
        v193 = v413;
        uint64_t v194 = (uint64_t (*)(void, void))v425;
        uint64_t v195 = (uint64_t)v428;
        unint64_t v196 = v143;
        if (v337)
        {
LABEL_122:
          uint64_t v409 = v111;
LABEL_162:
          v432 = v184;
          goto LABEL_165;
        }
      }
      else
      {
        uint64_t v191 = (*(uint64_t (**)(uint64_t, uint64_t))(v185 + 120))(v111, v185);
        ((void (*)(char *, uint64_t))v439)(v187, v111);
        uint64_t v163 = v185;
        uint64_t v192 = v432;
        v193 = v413;
        uint64_t v194 = (uint64_t (*)(void, void))v425;
        uint64_t v195 = (uint64_t)v428;
        unint64_t v196 = v143;
        if (v191 < v441) {
          goto LABEL_122;
        }
      }
LABEL_48:
      v202 = (char *)v195;
      uint64_t v203 = v194(v111, v163);
      v204 = v184;
      v205 = v184;
      v206 = v438;
      v438(v193, v204, v111);
      v428 = v202;
      if (v203 >= 65)
      {
        ((void (*)(char *, uint64_t))v439)(v193, v111);
        v207 = v205;
        v206(v192, v205, v111);
        goto LABEL_65;
      }
      v425 = v196;
      v207 = v205;
      uint64_t v234 = v194(v111, v163);
      ((void (*)(char *, uint64_t))v439)(v193, v111);
      if (v234 == 64)
      {
        char v235 = v435(v111, v163);
        v206(v192, v205, v111);
        if ((v235 & 1) == 0)
        {
LABEL_65:
          int64_t v441 = 0x7FFFFFFFFFFFFFFFLL;
          char v236 = v435(v111, v163);
          uint64_t v237 = v194(v111, v163);
          if (v236)
          {
            uint64_t v106 = (uint64_t)v439;
            if (v237 > 64)
            {
              v240 = v439;
              uint64_t v241 = v163;
              v242 = *(void (**)(void, void, void, void, void))(v163 + 96);
              unint64_t v243 = lazy protocol witness table accessor for type Int and conformance Int(v237, v238, v239);
              v244 = v430;
              v242(&v441, &type metadata for Int, v243, v111, v241);
              uint64_t v163 = v241;
              uint64_t v106 = (uint64_t)v240;
              v245 = v432;
              char v246 = v431[2](v244, v432, v111);
              v247 = v244;
              v207 = v429;
              ((void (*)(char *, uint64_t))v106)(v247, v111);
              ((void (*)(char *, uint64_t))v106)(v245, v111);
              if (v246) {
                goto LABEL_159;
              }
LABEL_109:
              uint64_t v282 = (*(uint64_t (**)(uint64_t, uint64_t))(v163 + 120))(v111, v163);
              ((void (*)(char *, uint64_t))v106)(v207, v111);
              return v282;
            }
          }
          else
          {
            uint64_t v106 = (uint64_t)v439;
            if (v237 > 63) {
              goto LABEL_108;
            }
          }
          v251 = v430;
          (*(void (**)(char *, char *, uint64_t))(v436 + 32))(v430, v432, v111);
          (*(void (**)(uint64_t, uint64_t))(v163 + 120))(v111, v163);
          ((void (*)(char *, uint64_t))v106)(v251, v111);
          goto LABEL_109;
        }
      }
      else
      {
        v206(v192, v205, v111);
      }
      uint64_t v106 = (uint64_t)v439;
      ((void (*)(char *, uint64_t))v439)(v192, v111);
      goto LABEL_109;
    }
    char v263 = v139(v111, v144);
    v264 = *(void **)(v144 + 128);
    v428 = (char *)((v144 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000);
    v265 = v424;
    uint64_t v409 = v111;
    v425 = v264;
    uint64_t v266 = ((uint64_t (*)(uint64_t, uint64_t))v264)(v111, v185);
    if (v263)
    {
      if (v266 > 64)
      {
        uint64_t v269 = v434;
        v270 = *(void (**)(void, void, void, void, void))(v434 + 96);
        unint64_t v271 = lazy protocol witness table accessor for type Int and conformance Int(v266, v267, v268);
        v272 = v430;
        uint64_t v111 = v409;
        v270(&v441, &type metadata for Int, v271, v409, v269);
        v273 = v439;
        char v274 = v431[2](v265, v272, v111);
        uint64_t v184 = v429;
        ((void (*)(char *, uint64_t))v273)(v272, v111);
        uint64_t v163 = v269;
        ((void (*)(char *, uint64_t))v273)(v265, v111);
        uint64_t v192 = v432;
        v193 = v413;
        uint64_t v194 = (uint64_t (*)(void, void))v425;
        uint64_t v195 = (uint64_t)v428;
        unint64_t v196 = v143;
        if (v274) {
          goto LABEL_162;
        }
        goto LABEL_48;
      }
      uint64_t v367 = (uint64_t)v427;
      uint64_t v111 = v409;
      uint64_t v368 = (uint64_t)v406;
      uint64_t v369 = swift_getAssociatedConformanceWitness((uint64_t)v427, v409, (uint64_t)v406, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v370 = v426;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v369 + 8))(&qword_18162B0B8, 256, v368, v369);
      v371 = v430;
      (*(void (**)(char *, uint64_t, uint64_t))(v367 + 24))(v370, v111, v367);
      LOBYTE(v368) = v431[2](v265, v371, v111);
      v372 = v439;
      ((void (*)(char *, uint64_t))v439)(v371, v111);
      v373 = v405;
      (*(void (**)(char *, char *, uint64_t))(v436 + 32))(v405, v265, v111);
      if (v368)
      {
        ((void (*)(char *, uint64_t))v372)(v373, v111);
        goto LABEL_162;
      }
      int64_t v374 = v441;
      uint64_t v163 = v434;
      uint64_t v375 = (*(uint64_t (**)(uint64_t, uint64_t))(v434 + 120))(v111, v434);
      ((void (*)(char *, uint64_t))v372)(v373, v111);
      BOOL v343 = v375 < v374;
    }
    else
    {
      v341 = v439;
      if (v266 >= 64)
      {
        uint64_t v111 = v409;
        ((void (*)(char *, uint64_t))v439)(v265, v409);
        uint64_t v163 = v434;
        uint64_t v192 = v432;
        v193 = v413;
        uint64_t v194 = (uint64_t (*)(void, void))v425;
        uint64_t v195 = (uint64_t)v428;
        unint64_t v196 = v143;
        goto LABEL_48;
      }
      uint64_t v163 = v434;
      uint64_t v111 = v409;
      uint64_t v342 = (*(uint64_t (**)(uint64_t, uint64_t))(v434 + 120))(v409, v434);
      ((void (*)(char *, uint64_t))v341)(v265, v111);
      BOOL v343 = v342 < v441;
    }
    uint64_t v192 = v432;
    v193 = v413;
    uint64_t v194 = (uint64_t (*)(void, void))v425;
    uint64_t v195 = (uint64_t)v428;
    unint64_t v196 = v143;
    if (v343) {
      goto LABEL_162;
    }
    goto LABEL_48;
  }
  uint64_t v407 = v5;
  Swift::String v72 = v23;
  uint64_t v73 = (uint64_t)v23;
  unint64_t v74 = v24;
  v424 = (char *)swift_getAssociatedConformanceWitness(v73, a2, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v75 = v424 + 8;
  v421 = (char *)*((void *)v424 + 1);
  uint64_t v76 = v27;
  ((void (*)(uint64_t *, uint64_t, const char *, char *))v421)(&qword_18162B0B8, 256, v24, v424);
  uint64_t v77 = a2;
  uint64_t v78 = (char *)(v72 + 3);
  v420 = v72[3];
  ((void (*)(char *, uint64_t, int **))v420)(v27, v77, v72);
  uint64_t v79 = *(char **)(*(void *)(v434 + 32) + 8);
  v429 = (char *)*((void *)v79 + 2);
  LODWORD(v432) = ((uint64_t (*)(void (*)(char *, char *, uint64_t), char *, uint64_t, char *))v429)((void (*)(char *, char *, uint64_t))v437, v63, v77, v79);
  unint64_t v80 = v436 + 8;
  v439 = *(char **)(v436 + 8);
  ((void (*)(char *, uint64_t))v439)(v63, v77);
  v405 = v75;
  ((void (*)(uint64_t *, uint64_t, const char *, char *))v421)(&qword_18162B0B8, 256, v74, v424);
  v404 = v78;
  ((void (*)(char *, uint64_t, int **))v420)(v76, v77, v427);
  v413 = v79;
  v414 = v79 + 16;
  int v81 = ((uint64_t (*)(void (*)(char *, char *, uint64_t), char *, uint64_t, char *))v429)((void (*)(char *, char *, uint64_t))v438, v63, v77, v79);
  ((void (*)(char *, uint64_t))v439)(v63, v77);
  if (((v432 ^ v81) & 1) == 0)
  {
    v116 = v76;
    uint64_t AssociatedConformanceWitness = v80 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    uint64_t v117 = v428;
    (*(void (**)(void, void, uint64_t))(*(void *)(v407 + 8) + 40))(v438, v437, v77);
    uint64_t v118 = v434;
    char v119 = v435(v77, v434);
    uint64_t v121 = (void (*)(void, void, void))(v436 + 16);
    uint64_t v120 = *(void (**)(void, void, void))(v436 + 16);
    uint64_t v122 = v409;
    v120(v409, v117, v77);
    v437 = v120;
    v438 = v121;
    if (v119)
    {
      v426 = v116;
      v432 = *(char **)(v118 + 128);
      uint64_t v123 = ((uint64_t (*)(uint64_t, uint64_t))v432)(v77, v118);
      uint64_t v124 = v122;
      uint64_t v125 = v439;
      ((void (*)(uint64_t, uint64_t))v439)(v124, v77);
      uint64_t v126 = v412;
      v120(v412, v117, v77);
      if (v123 >= 65)
      {
        uint64_t v127 = (v118 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
        int64_t v441 = 0x8000000000000000;
        unint64_t v128 = v435;
        if (v435(v77, v118))
        {
          char v129 = v432;
          uint64_t v130 = ((uint64_t (*)(uint64_t, uint64_t))v432)(v77, v118);
          if (v130 >= 64)
          {
            v431 = (uint64_t (**)(char *, char *, uint64_t))v80;
            v350 = *(void (**)(void, void, void, void, void))(v118 + 96);
            unint64_t v351 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
            v352 = v430;
            v350(&v441, &type metadata for Int, v351, v77, v118);
            unint64_t v80 = (unint64_t)v431;
            char v353 = ((uint64_t (*)(char *, char *, uint64_t, char *))v429)(v126, v352, v77, v413);
            v354 = v352;
            char v129 = v432;
            v355 = v439;
            ((void (*)(char *, uint64_t))v439)(v354, v77);
            ((void (*)(char *, uint64_t))v355)(v126, v77);
            uint64_t v134 = v118;
            uint64_t v135 = v428;
            uint64_t v136 = v415;
            if (v353) {
              goto LABEL_132;
            }
          }
          else
          {
            uint64_t v133 = (*(uint64_t (**)(uint64_t, uint64_t))(v118 + 120))(v77, v118);
            ((void (*)(char *, uint64_t))v439)(v126, v77);
            uint64_t v134 = v118;
            uint64_t v135 = v428;
            uint64_t v136 = v415;
            if (v133 < v441) {
              goto LABEL_132;
            }
          }
          goto LABEL_33;
        }
        char v320 = v128(v77, v118);
        uint64_t v409 = v77;
        char v129 = v432;
        uint64_t v321 = ((uint64_t (*)(uint64_t, uint64_t))v432)(v77, v118);
        v324 = v430;
        if ((v320 & 1) == 0)
        {
          uint64_t v135 = v428;
          uint64_t v136 = v415;
          if (v321 >= 64)
          {
            uint64_t v77 = v409;
            ((void (*)(char *, uint64_t))v439)(v126, v409);
            uint64_t v134 = v434;
            goto LABEL_33;
          }
          uint64_t v134 = v434;
          uint64_t v77 = v409;
          uint64_t v378 = (*(uint64_t (**)(uint64_t, uint64_t))(v434 + 120))(v409, v434);
          ((void (*)(char *, uint64_t))v439)(v126, v77);
          if (v378 >= v441)
          {
LABEL_33:
            uint64_t v166 = ((uint64_t (*)(uint64_t, uint64_t))v129)(v77, v134);
            uint64_t v167 = v437;
            v437(v136, v135, v77);
            v432 = (char *)v127;
            if (v166 >= 65)
            {
              uint64_t v168 = v129;
              uint64_t v149 = v439;
              ((void (*)(char *, uint64_t))v439)(v136, v77);
              unsigned int v151 = v417;
              v167(v417, v135, v77);
LABEL_35:
              v431 = (uint64_t (**)(char *, char *, uint64_t))v80;
              int64_t v441 = 0x7FFFFFFFFFFFFFFFLL;
              char v169 = v435(v77, v134);
              uint64_t v170 = ((uint64_t (*)(uint64_t, uint64_t))v168)(v77, v134);
              if (v169)
              {
                if (v170 > 64)
                {
                  uint64_t v173 = v134;
                  uint64_t v174 = *(void (**)(void, void, void, void, void))(v134 + 96);
                  unint64_t v175 = lazy protocol witness table accessor for type Int and conformance Int(v170, v171, v172);
                  uint64_t v176 = v430;
                  v174(&v441, &type metadata for Int, v175, v77, v173);
                  uint64_t v134 = v173;
                  uint64_t v135 = v428;
                  char v177 = ((uint64_t (*)(char *, char *, uint64_t, char *))v429)(v176, v151, v77, v413);
                  ((void (*)(char *, uint64_t))v149)(v176, v77);
                  uint64_t v178 = v151;
                  goto LABEL_101;
                }
              }
              else if (v170 > 63)
              {
LABEL_100:
                uint64_t v440 = 0x7FFFFFFFFFFFFFFFLL;
                v284 = v430;
                uint64_t v285 = (*(uint64_t (**)(char *, char *, uint64_t))(v436 + 32))(v430, v151, v77);
                uint64_t v286 = v134;
                v287 = *(void (**)(void, void, void, void, void))(v134 + 96);
                unint64_t v290 = lazy protocol witness table accessor for type Int and conformance Int(v285, v288, v289);
                v291 = v408;
                v287(&v440, &type metadata for Int, v290, v77, v286);
                uint64_t v134 = v286;
                uint64_t v135 = v428;
                char v177 = ((uint64_t (*)(char *, char *, uint64_t, char *))v429)(v291, v284, v77, v413);
                ((void (*)(char *, uint64_t))v149)(v291, v77);
                uint64_t v178 = v284;
LABEL_101:
                ((void (*)(char *, uint64_t))v149)(v178, v77);
                if ((v177 & 1) == 0) {
                  goto LABEL_102;
                }
LABEL_132:
                uint64_t v409 = v77;
                v432 = v135;
                goto LABEL_165;
              }
              v250 = v430;
              (*(void (**)(char *, char *, uint64_t))(v436 + 32))(v430, v151, v77);
              (*(void (**)(uint64_t, uint64_t))(v134 + 120))(v77, v134);
              ((void (*)(char *, uint64_t))v149)(v250, v77);
LABEL_102:
              uint64_t v282 = (*(uint64_t (**)(uint64_t, uint64_t))(v134 + 120))(v77, v134);
              ((void (*)(char *, uint64_t))v149)(v135, v77);
              return v282;
            }
            uint64_t v168 = v129;
            uint64_t v220 = ((uint64_t (*)(uint64_t, uint64_t))v129)(v77, v134);
            uint64_t v149 = v439;
            ((void (*)(char *, uint64_t))v439)(v136, v77);
            if (v220 == 64)
            {
              char v221 = v435(v77, v134);
              unsigned int v151 = v417;
              v167(v417, v135, v77);
              if ((v221 & 1) == 0) {
                goto LABEL_35;
              }
            }
            else
            {
              unsigned int v151 = v417;
              v167(v417, v135, v77);
            }
            ((void (*)(char *, uint64_t))v149)(v151, v77);
            goto LABEL_102;
          }
LABEL_158:
          v432 = v135;
          goto LABEL_165;
        }
        if (v321 > 64)
        {
          uint64_t v325 = v434;
          v326 = *(void (**)(void, void, void, void, void))(v434 + 96);
          unint64_t v327 = lazy protocol witness table accessor for type Int and conformance Int(v321, v322, v323);
          uint64_t v77 = v409;
          v326(&v441, &type metadata for Int, v327, v409, v325);
          uint64_t v134 = v325;
          char v328 = ((uint64_t (*)(char *, char *, uint64_t, char *))v429)(v126, v324, v77, v413);
          v329 = v439;
          ((void (*)(char *, uint64_t))v439)(v324, v77);
          ((void (*)(char *, uint64_t))v329)(v126, v77);
          uint64_t v135 = v428;
          uint64_t v136 = v415;
          char v129 = v432;
          if ((v328 & 1) == 0) {
            goto LABEL_33;
          }
          goto LABEL_158;
        }
        v392 = v426;
        ((void (*)(uint64_t *, uint64_t))v421)(&qword_18162B0B8, 256);
        uint64_t v77 = v409;
        ((void (*)(char *, uint64_t, int **))v420)(v392, v409, v427);
        char v393 = ((uint64_t (*)(char *, char *, uint64_t, char *))v429)(v126, v324, v77, v413);
        v394 = v439;
        ((void (*)(char *, uint64_t))v439)(v324, v77);
        v395 = v399;
        (*(void (**)(char *, char *, uint64_t))(v436 + 32))(v399, v126, v77);
        uint64_t v134 = v434;
        uint64_t v135 = v428;
        v396 = (char *)v80;
        if ((v393 & 1) == 0)
        {
          int64_t v397 = v441;
          uint64_t v398 = (*(uint64_t (**)(uint64_t, uint64_t))(v434 + 120))(v77, v434);
          ((void (*)(char *, uint64_t))v394)(v395, v77);
          BOOL v340 = v398 < v397;
          unint64_t v80 = (unint64_t)v396;
          uint64_t v136 = v415;
          char v129 = v432;
          if (!v340) {
            goto LABEL_33;
          }
          goto LABEL_158;
        }
        ((void (*)(char *, uint64_t))v394)(v395, v77);
        v432 = v135;
LABEL_165:
        ((void (*)(char *, uint64_t))v439)(v432, v409);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
      }
    }
    else
    {
      uint64_t v165 = v122;
      uint64_t v125 = v439;
      ((void (*)(uint64_t, uint64_t))v439)(v165, v77);
      uint64_t v126 = v412;
      v120(v412, v117, v77);
    }
    ((void (*)(char *, uint64_t))v125)(v126, v77);
    char v129 = *(char **)(v118 + 128);
    uint64_t v127 = (v118 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v134 = v118;
    uint64_t v135 = v428;
    uint64_t v136 = v415;
    goto LABEL_33;
  }
  uint64_t v82 = v407;
  char v83 = *(void (**)(void, void))(v407 + 56);
  uint64_t v84 = v426;
  v83(v77, v407);
  uint64_t v85 = v422;
  v83(v77, v82);
  char v86 = v431;
  uint64_t v87 = (uint64_t)v419;
  (*(void (**)(char *, char *, uint64_t *))(*(void *)(AssociatedConformanceWitness + 8) + 24))(v84, v85, v419);
  uint64_t v88 = v425;
  char v89 = (uint64_t (*)(void, void))(v425 + 1);
  uint64_t v90 = (char *)v425[1];
  uint64_t AssociatedConformanceWitness = (unint64_t)(v425 + 1) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  ((void (*)(char *, uint64_t))v90)(v85, v87);
  ((void (*)(char *, uint64_t))v90)(v84, v87);
  uint64_t v91 = swift_getAssociatedConformanceWitness(v434, v77, v87, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v436 = *(void *)(v91 + 64);
  v437 = (void (*)(void, void, void))(v91 + 64);
  char v92 = ((uint64_t (*)(uint64_t, uint64_t))v436)(v87, v91);
  char v93 = (void (*)(void))v88[2];
  uint64_t v94 = v411;
  ((void (*)(char *, uint64_t (**)(char *, char *, uint64_t), uint64_t))v93)(v411, v86, v87);
  uint64_t v409 = v77;
  v438 = (void (*)(void, void, void))(v88 + 2);
  v439 = v90;
  v435 = v89;
  if ((v92 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v90)(v94, v87);
    uint64_t v96 = v416;
    ((void (*)(char *, uint64_t (**)(char *, char *, uint64_t), uint64_t))v93)(v416, v86, v87);
    v97 = v423;
    goto LABEL_21;
  }
  uint64_t v434 = *(void *)(v91 + 128);
  uint64_t v95 = ((uint64_t (*)(uint64_t, uint64_t))v434)(v87, v91);
  ((void (*)(char *, uint64_t))v90)(v94, v87);
  uint64_t v96 = v416;
  v93();
  v97 = v423;
  if (v95 < 65)
  {
LABEL_21:
    ((void (*)(char *, uint64_t))v90)(v96, v87);
    char v105 = *(uint64_t (**)(void, void))(v91 + 128);
    uint64_t v98 = (v91 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    __int16 v104 = (char *)v431;
LABEL_22:
    uint64_t v146 = v105(v87, v91);
    goto LABEL_23;
  }
  v433 = v93;
  uint64_t v98 = (v91 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
  int64_t v441 = 0x8000000000000000;
  uint64_t v99 = (uint64_t (*)(void, void))v436;
  if (((uint64_t (*)(uint64_t, uint64_t))v436)(v87, v91))
  {
    uint64_t v100 = ((uint64_t (*)(uint64_t, uint64_t))v434)(v87, v91);
    if (v100 >= 64)
    {
      v344 = *(void (**)(void, void, void, void, void))(v91 + 96);
      unint64_t v345 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
      v346 = v426;
      v344(&v441, &type metadata for Int, v345, v87, v91);
      uint64_t v347 = swift_getAssociatedConformanceWitness(v407, v409, v87, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v348 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v347 + 16))(v96, v346, v87, v347);
      v349 = v439;
      ((void (*)(char *, uint64_t))v439)(v346, v87);
      ((void (*)(char *, uint64_t))v349)(v96, v87);
      __int16 v104 = (char *)v431;
      char v93 = v433;
      char v105 = (uint64_t (*)(void, void))v434;
      v97 = v423;
      if (v348) {
        goto LABEL_154;
      }
    }
    else
    {
      uint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(v91 + 120))(v87, v91);
      ((void (*)(char *, uint64_t))v439)(v96, v87);
      __int16 v104 = (char *)v431;
      char v93 = v433;
      char v105 = (uint64_t (*)(void, void))v434;
      v97 = v423;
      if (v103 < v441) {
        goto LABEL_154;
      }
    }
    goto LABEL_22;
  }
  char v311 = v99(v87, v91);
  uint64_t v312 = ((uint64_t (*)(uint64_t, uint64_t))v434)(v87, v91);
  if (v311)
  {
    char v93 = v433;
    v97 = v423;
    if (v312 > 64)
    {
      v430 = *(char **)(v91 + 96);
      unint64_t v315 = lazy protocol witness table accessor for type Int and conformance Int(v312, v313, v314);
      v316 = v426;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v430)(&v441, &type metadata for Int, v315, v87, v91);
      uint64_t v317 = swift_getAssociatedConformanceWitness(v407, v409, v87, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v318 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v317 + 16))(v96, v316, v87, v317);
      v319 = v439;
      ((void (*)(char *, uint64_t))v439)(v316, v87);
      ((void (*)(char *, uint64_t))v319)(v96, v87);
      __int16 v104 = (char *)v431;
      char v105 = (uint64_t (*)(void, void))v434;
      if (v318) {
        goto LABEL_154;
      }
      goto LABEL_22;
    }
    v380 = v402;
    v381 = v401;
    uint64_t v382 = swift_getAssociatedConformanceWitness((uint64_t)v402, v87, (uint64_t)v401, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v383 = v400;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v382 + 8))(&qword_18162B0B8, 256, v381, v382);
    v384 = v380;
    v385 = v380[3];
    v386 = v426;
    ((void (*)(char *, uint64_t, int **))v385)(v383, v87, v384);
    uint64_t v387 = swift_getAssociatedConformanceWitness(v407, v409, v87, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    LODWORD(v430) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v387 + 16))(v96, v386, v87, v387);
    v388 = v439;
    ((void (*)(char *, uint64_t))v439)(v386, v87);
    v389 = v403;
    ((void (*)(char *, char *, uint64_t))v425[4])(v403, v96, v87);
    if (v430)
    {
      ((void (*)(char *, uint64_t))v388)(v389, v87);
      goto LABEL_164;
    }
    int64_t v390 = v441;
    uint64_t v391 = (*(uint64_t (**)(uint64_t, uint64_t))(v91 + 120))(v87, v91);
    ((void (*)(char *, uint64_t))v388)(v389, v87);
    BOOL v377 = v391 < v390;
LABEL_152:
    __int16 v104 = (char *)v431;
    char v105 = (uint64_t (*)(void, void))v434;
    if (v377)
    {
LABEL_154:
      uint64_t v409 = v87;
      v432 = v104;
      goto LABEL_165;
    }
    goto LABEL_22;
  }
  char v93 = v433;
  v97 = v423;
  if (v312 < 64)
  {
    uint64_t v376 = (*(uint64_t (**)(uint64_t, uint64_t))(v91 + 120))(v87, v91);
    ((void (*)(char *, uint64_t))v439)(v96, v87);
    BOOL v377 = v376 < v441;
    goto LABEL_152;
  }
  ((void (*)(char *, uint64_t))v439)(v96, v87);
  __int16 v104 = (char *)v431;
  char v105 = (uint64_t (*)(void, void))v434;
  uint64_t v146 = ((uint64_t (*)(uint64_t, uint64_t))v434)(v87, v91);
LABEL_23:
  uint64_t v147 = v146;
  uint64_t v134 = (uint64_t)v97;
  ((void (*)(char *, char *, uint64_t))v93)(v97, v104, v87);
  uint64_t v77 = (uint64_t)v437;
  uint64_t v434 = v98;
  if (v147 >= 65)
  {
    uint64_t v148 = v105;
    uint64_t v149 = (char *)v435;
    ((void (*)(char *, uint64_t))v439)(v97, v87);
    size_t v150 = v93;
    unsigned int v151 = v418;
    ((void (*)(char *, char *, uint64_t))v150)(v418, v104, v87);
    goto LABEL_52;
  }
  v208 = v93;
  uint64_t v148 = v105;
  uint64_t v209 = v105(v87, v91);
  uint64_t v149 = (char *)v435;
  ((void (*)(uint64_t, uint64_t))v439)(v134, v87);
  if (v209 != 64)
  {
    unsigned int v151 = v418;
    ((void (*)(char *, char *, uint64_t))v208)(v418, v104, v87);
    goto LABEL_87;
  }
  char v210 = ((uint64_t (*)(uint64_t, uint64_t))v436)(v87, v91);
  unsigned int v151 = v418;
  ((void (*)(char *, char *, uint64_t))v208)(v418, v104, v87);
  if (v210)
  {
LABEL_87:
    v218 = v439;
    ((void (*)(char *, uint64_t))v439)(v151, v87);
    goto LABEL_96;
  }
LABEL_52:
  int64_t v441 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v134 = ((uint64_t (*)(uint64_t, uint64_t))v436)(v87, v91);
  uint64_t v211 = v148(v87, v91);
  if (v134)
  {
    if (v211 > 64)
    {
      uint64_t v134 = *(void *)(v91 + 96);
      unint64_t v214 = lazy protocol witness table accessor for type Int and conformance Int(v211, v212, v213);
      v215 = v426;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v134)(&v441, &type metadata for Int, v214, v87, v91);
      uint64_t v216 = swift_getAssociatedConformanceWitness(v407, v409, v87, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v217 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v216 + 16))(v215, v151, v87, v216);
      v218 = v439;
      ((void (*)(char *, uint64_t))v439)(v215, v87);
      v219 = v151;
      goto LABEL_95;
    }
  }
  else if (v211 > 63)
  {
    uint64_t v440 = 0x7FFFFFFFFFFFFFFFLL;
    v275 = v426;
    uint64_t v276 = ((uint64_t (*)(char *, char *, uint64_t))v425[4])(v426, v151, v87);
    uint64_t v134 = *(void *)(v91 + 96);
    unint64_t v279 = lazy protocol witness table accessor for type Int and conformance Int(v276, v277, v278);
    unsigned int v151 = v422;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v134)(&v440, &type metadata for Int, v279, v87, v91);
    uint64_t v280 = swift_getAssociatedConformanceWitness(v407, v409, v87, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v217 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v280 + 16))(v151, v275, v87, v280);
    v218 = v439;
    ((void (*)(char *, uint64_t))v439)(v151, v87);
    v219 = v275;
LABEL_95:
    ((void (*)(char *, uint64_t))v218)(v219, v87);
    if ((v217 & 1) == 0) {
      goto LABEL_96;
    }
    goto LABEL_164;
  }
  v248 = v426;
  ((void (*)(char *, char *, uint64_t))v425[4])(v426, v151, v87);
  uint64_t v249 = (*(uint64_t (**)(uint64_t, uint64_t))(v91 + 120))(v87, v91);
  v218 = v439;
  ((void (*)(char *, uint64_t))v439)(v248, v87);
  if (v441 < v249)
  {
LABEL_164:
    uint64_t v409 = v87;
    v432 = (char *)v431;
    goto LABEL_165;
  }
LABEL_96:
  v281 = v431;
  uint64_t v282 = (*(uint64_t (**)(uint64_t, uint64_t))(v91 + 120))(v87, v91);
  ((void (*)(uint64_t (**)(char *, char *, uint64_t), uint64_t))v218)(v281, v87);
  if ((v432 & 1) == 0)
  {
    BOOL v283 = __OFSUB__(0, v282);
    uint64_t v282 = -v282;
    if (v283)
    {
      __break(1u);
      goto LABEL_100;
    }
  }
  return v282;
}

uint64_t SignedInteger<>.init<A>(exactly:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v211 = a4;
  uint64_t v203 = a6;
  uint64_t v206 = *(void *)(a4 + 8);
  uint64_t v194 = *(int ***)(*(void *)(v206 + 24) + 16);
  uint64_t v212 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v194, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v192 = (char *)&v180 - v10;
  uint64_t v191 = *(int ***)(*(void *)(a5 + 24) + 16);
  uint64_t v190 = swift_getAssociatedTypeWitness(0, v191, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](v190);
  uint64_t v189 = (char *)&v180 - v12;
  uint64_t v205 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v188 = (char *)&v180 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v187 = (char *)&v180 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v197 = (char *)&v180 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v184 = (char *)&v180 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v195 = (char *)&v180 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v196 = (char *)&v180 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v199 = (char *)&v180 - v26;
  uint64_t v27 = *(void *)(a3 - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v185 = (char *)&v180 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v186 = (char *)&v180 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  char v210 = (char *)&v180 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v36 = (char *)&v180 - v35;
  uint64_t v37 = MEMORY[0x1F4188790](v34);
  uint64_t v183 = (char *)&v180 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v182 = (char *)&v180 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v198 = (char *)&v180 - v42;
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  uint64_t v45 = (char *)&v180 - v44;
  MEMORY[0x1F4188790](v43);
  uint64_t v47 = (char *)&v180 - v46;
  uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  uint64_t v215 = a5;
  uint64_t v202 = a5 + 64;
  v204 = v48;
  char v49 = v48(a3, a5);
  uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v27 + 16);
  v50(v47, (uint64_t)a1, a3);
  uint64_t v213 = a1;
  uint64_t v209 = v27;
  uint64_t v200 = v27 + 16;
  v201 = v36;
  v207 = v50;
  if ((v49 & 1) == 0)
  {
    uint64_t v76 = *(void (**)(char *, uint64_t))(v27 + 8);
    v76(v47, a3);
    v50(v45, (uint64_t)a1, a3);
    uint64_t v70 = v215;
LABEL_10:
    unint64_t v214 = v76;
    v76(v45, a3);
    uint64_t v68 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 128);
    uint64_t v56 = (v70 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
LABEL_11:
    uint64_t v77 = v213;
    goto LABEL_12;
  }
  uint64_t v51 = v215 + 128;
  uint64_t v52 = *(uint64_t (**)(uint64_t))(v215 + 128);
  uint64_t v181 = v52(a3);
  unint64_t v214 = *(void (**)(char *, uint64_t))(v27 + 8);
  v214(v47, a3);
  uint64_t v53 = v211;
  uint64_t v54 = (*(uint64_t (**)(void))(v211 + 56))();
  v50(v45, (uint64_t)a1, a3);
  if (v54 >= v181)
  {
    uint64_t v76 = v214;
    uint64_t v70 = v215;
    goto LABEL_10;
  }
  uint64_t v55 = v53;
  uint64_t v181 = (uint64_t)v45;
  uint64_t v180 = v27 + 8;
  v208 = (uint64_t (*)(uint64_t, uint64_t))v52;
  uint64_t v56 = v51 & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
  uint64_t v57 = *(void (**)(uint64_t, uint64_t))(v53 + 72);
  uint64_t v58 = v199;
  uint64_t v59 = v212;
  v57(v212, v55);
  uint64_t v60 = v204;
  int v61 = v204(a3, v215);
  uint64_t v62 = v206;
  if (((v61 ^ (*(unsigned int (**)(uint64_t, uint64_t))(v206 + 64))(v59, v206)) & 1) == 0)
  {
    uint64_t v110 = v181;
    uint64_t v111 = v208(a3, v215);
    if (v111 >= (*(uint64_t (**)(uint64_t, uint64_t))(v62 + 128))(v59, v62))
    {
      uint64_t v113 = v215;
      unint64_t v143 = v198;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v215 + 96))(v58, v59, v62, a3, v215);
      char v144 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v113 + 32) + 8) + 16))(v110, v143, a3);
      BOOL v145 = v143;
      uint64_t v146 = (void (*)(uint64_t, uint64_t))v214;
      v214(v145, a3);
      v146(v110, a3);
      uint64_t v75 = v205;
      unint64_t v74 = v146;
      if (v144)
      {
LABEL_56:
        v74((uint64_t)v213, a3);
        uint64_t v109 = 1;
        uint64_t v101 = v203;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v75 + 56))(v101, v109, 1, v59);
      }
    }
    else
    {
      uint64_t v112 = v196;
      uint64_t v113 = v215;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v62 + 96))(v110, a3, v215, v59, v62);
      char v114 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v62 + 32) + 8) + 16))(v112, v58, v59);
      uint64_t v75 = v205;
      BOOL v115 = *(void (**)(char *, uint64_t))(v205 + 8);
      v115(v112, v59);
      v115(v58, v59);
      unint64_t v74 = (void (*)(uint64_t, uint64_t))v214;
      if (v114) {
        goto LABEL_56;
      }
    }
    uint64_t v70 = v113;
    goto LABEL_46;
  }
  uint64_t v63 = v215;
  char v64 = v60(a3, v215);
  uint64_t v65 = v208;
  uint64_t v66 = v208(a3, v63);
  uint64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t))(v62 + 128))(v59, v62);
  if (v64)
  {
    if (v67 < v66)
    {
      uint64_t v68 = v65;
      uint64_t v69 = v62;
      uint64_t v70 = v215;
      char v71 = v198;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v215 + 96))(v58, v59, v69, a3, v215);
      uint64_t v72 = v181;
      char v73 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v70 + 32) + 8) + 16))(v181, v71, a3);
      unint64_t v74 = (void (*)(uint64_t, uint64_t))v214;
      v214(v71, a3);
      v74(v72, a3);
      uint64_t v75 = v205;
      if (v73) {
        goto LABEL_56;
      }
      goto LABEL_11;
    }
    size_t v150 = v58;
    unsigned int v151 = v191;
    unint64_t v152 = v190;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v191, a3, (uint64_t)v190, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v154 = v189;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v152, AssociatedConformanceWitness);
    uint64_t v155 = v198;
    ((void (*)(char *, uint64_t, int **))v151[3])(v154, a3, v151);
    uint64_t v156 = v215;
    uint64_t v157 = v181;
    LOBYTE(v152) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v215 + 32) + 8) + 16))(v181, v155, a3);
    v214(v155, a3);
    uint64_t v158 = v182;
    (*(void (**)(char *, uint64_t, uint64_t))(v209 + 32))(v182, v157, a3);
    uint64_t v75 = v205;
    uint64_t v159 = v195;
    (*(void (**)(char *, char *, uint64_t))(v205 + 32))(v195, v150, v59);
    if (v152)
    {
      (*(void (**)(char *, uint64_t))(v75 + 8))(v159, v59);
      uint64_t v160 = v158;
      unint64_t v74 = (void (*)(uint64_t, uint64_t))v214;
      v214(v160, a3);
      goto LABEL_56;
    }
    uint64_t v173 = v206;
    uint64_t v174 = v196;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v206 + 96))(v158, a3, v156, v59, v206);
    unint64_t v175 = v195;
    char v176 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v173 + 32) + 8) + 16))(v174, v195, v59);
    uint64_t v177 = v56;
    uint64_t v178 = *(void (**)(char *, uint64_t))(v75 + 8);
    v178(v174, v59);
    v178(v175, v59);
    uint64_t v56 = v177;
    unint64_t v74 = (void (*)(uint64_t, uint64_t))v214;
    uint64_t v70 = v215;
    if (v176) {
      goto LABEL_56;
    }
    goto LABEL_46;
  }
  if (v66 < v67)
  {
    uint64_t v137 = v196;
    uint64_t v138 = v58;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v62 + 96))(v181, a3, v215, v59, v62);
    char v139 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v62 + 32) + 8) + 16))(v137, v58, v59);
    uint64_t v140 = v205;
    uint64_t v141 = v56;
    size_t v142 = *(void (**)(char *, uint64_t))(v205 + 8);
    v142(v137, v59);
    v142(v138, v59);
    uint64_t v56 = v141;
    uint64_t v75 = v140;
    unint64_t v74 = (void (*)(uint64_t, uint64_t))v214;
    uint64_t v70 = v215;
    if (v139) {
      goto LABEL_56;
    }
    goto LABEL_46;
  }
  uint64_t v161 = v194;
  uint64_t v162 = AssociatedTypeWitness;
  uint64_t v163 = swift_getAssociatedConformanceWitness((uint64_t)v194, v59, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v164 = v192;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v163 + 8))(&qword_18162B0B8, 256, v162, v163);
  uint64_t v165 = v196;
  ((void (*)(char *, uint64_t, int **))v161[3])(v164, v59, v161);
  uint64_t v166 = v58;
  LOBYTE(v162) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v62 + 32) + 8) + 40))(v58, v165, v59);
  uint64_t v167 = v205;
  uint64_t v168 = *(void (**)(char *, uint64_t))(v205 + 8);
  v168(v165, v59);
  char v169 = v183;
  (*(void (**)(char *, uint64_t, uint64_t))(v209 + 32))(v183, v181, a3);
  uint64_t v170 = v184;
  (*(void (**)(char *, char *, uint64_t))(v167 + 32))(v184, v166, v59);
  if (v162)
  {
    uint64_t v70 = v215;
    uint64_t v171 = v198;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v215 + 96))(v170, v59, v206, a3, v215);
    char v172 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v70 + 32) + 8) + 16))(v169, v171, a3);
    unint64_t v74 = (void (*)(uint64_t, uint64_t))v214;
    v214(v171, a3);
    v74((uint64_t)v169, a3);
    uint64_t v75 = v205;
    if (v172) {
      goto LABEL_56;
    }
LABEL_46:
    uint64_t v77 = v213;
    uint64_t v68 = v208;
    goto LABEL_12;
  }
  v168(v170, v59);
  v214(v169, a3);
  uint64_t v77 = v213;
  uint64_t v70 = v215;
  uint64_t v68 = v208;
LABEL_12:
  v208 = v68;
  v199 = (char *)v56;
  uint64_t v78 = v68(a3, v70);
  uint64_t v79 = a3;
  uint64_t v80 = v211;
  uint64_t v59 = v212;
  uint64_t v195 = *(char **)(v211 + 56);
  uint64_t v81 = ((uint64_t (*)(uint64_t, uint64_t))v195)(v212, v211);
  uint64_t v82 = v201;
  char v83 = v207;
  v207(v201, (uint64_t)v77, a3);
  if (v81 < v78)
  {
    v214(v82, a3);
    v83(v210, (uint64_t)v77, a3);
    uint64_t v84 = v215;
    uint64_t v85 = v206;
    goto LABEL_14;
  }
  uint64_t v84 = v215;
  uint64_t v94 = v208(a3, v215);
  v214(v82, a3);
  if (v94 != ((uint64_t (*)(uint64_t, uint64_t))v195)(v59, v80))
  {
    uint64_t v96 = v210;
    v207(v210, (uint64_t)v213, a3);
    uint64_t v85 = v206;
    uint64_t v59 = v212;
LABEL_24:
    v214(v96, a3);
    uint64_t v101 = v203;
    uint64_t v102 = v84;
    uint64_t v75 = v205;
LABEL_25:
    uint64_t v103 = v213;
    goto LABEL_32;
  }
  char v95 = v204(a3, v84);
  uint64_t v96 = v210;
  v207(v210, (uint64_t)v213, a3);
  uint64_t v85 = v206;
  uint64_t v59 = v212;
  if (v95) {
    goto LABEL_24;
  }
LABEL_14:
  char v86 = v197;
  (*(void (**)(uint64_t))(v211 + 64))(v59);
  uint64_t v87 = *(uint64_t (**)(uint64_t, uint64_t))(v85 + 64);
  int v88 = v87(v59, v85);
  if (((v88 ^ v204(v79, v84)) & 1) == 0)
  {
    uint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(v85 + 128))(v59, v85);
    uint64_t v98 = v210;
    char v92 = v86;
    if (v97 >= v208(v79, v84))
    {
      char v93 = v198;
      (*(void (**)(char *, char *, uint64_t))(v209 + 32))(v198, v98, v79);
      goto LABEL_31;
    }
    uint64_t v99 = v198;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v84 + 96))(v92, v59, v85, v79, v84);
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 32) + 8) + 16))(v99, v98, v79);
    goto LABEL_28;
  }
  char v89 = v87(v59, v85);
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(v85 + 128))(v59, v85);
  uint64_t v91 = v208(v79, v84);
  char v92 = v86;
  if (v89)
  {
    if (v91 >= v90)
    {
      v116 = v194;
      uint64_t v117 = AssociatedTypeWitness;
      uint64_t v118 = swift_getAssociatedConformanceWitness((uint64_t)v194, v59, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v119 = v192;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v118 + 8))(&qword_18162B0B8, 256, v117, v118);
      uint64_t v120 = v196;
      ((void (*)(char *, uint64_t, int **))v116[3])(v119, v59, v116);
      LOBYTE(v117) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v85 + 32) + 8) + 16))(v92, v120, v59);
      uint64_t v75 = v205;
      uint64_t v121 = v120;
      uint64_t v122 = *(void (**)(char *, uint64_t))(v205 + 8);
      v122(v121, v59);
      uint64_t v123 = v187;
      (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v187, v92, v59);
      uint64_t v124 = v186;
      (*(void (**)(char *, char *, uint64_t))(v209 + 32))(v186, v210, v79);
      if (v117)
      {
        uint64_t v125 = v124;
        char v105 = v214;
        v214(v125, v79);
        v122(v123, v59);
        uint64_t v101 = v203;
        uint64_t v103 = v213;
      }
      else
      {
        uint64_t v102 = v215;
        uint64_t v147 = v198;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v215 + 96))(v123, v59, v85, v79, v215);
        char v148 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v147, v124, v79);
        uint64_t v149 = v124;
        char v105 = v214;
        v214(v147, v79);
        v105(v149, v79);
        uint64_t v101 = v203;
        uint64_t v103 = v213;
        if ((v148 & 1) == 0) {
          goto LABEL_32;
        }
      }
      goto LABEL_48;
    }
    char v93 = v198;
    (*(void (**)(char *, char *, uint64_t))(v209 + 32))(v198, v210, v79);
LABEL_31:
    uint64_t v106 = v196;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v85 + 96))(v93, v79, v84, v59, v85);
    char v107 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v85 + 32) + 8) + 16))(v92, v106, v59);
    uint64_t v102 = v84;
    uint64_t v75 = v205;
    char v108 = *(void (**)(char *, uint64_t))(v205 + 8);
    v108(v106, v59);
    v108(v92, v59);
    uint64_t v101 = v203;
    char v105 = v214;
    uint64_t v103 = v213;
    if ((v107 & 1) == 0) {
      goto LABEL_32;
    }
LABEL_48:
    v105(v103, v79);
    uint64_t v109 = 1;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v75 + 56))(v101, v109, 1, v59);
  }
  if (v90 >= v91)
  {
    uint64_t v126 = v191;
    uint64_t v127 = v190;
    uint64_t v128 = swift_getAssociatedConformanceWitness((uint64_t)v191, v79, (uint64_t)v190, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    char v129 = v189;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v128 + 8))(&qword_18162B0B8, 256, v127, v128);
    uint64_t v130 = v198;
    ((void (*)(char *, uint64_t, int **))v126[3])(v129, v79, v126);
    uint64_t v131 = v210;
    LODWORD(v211) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 32) + 8) + 40))(v210, v130, v79);
    uint64_t v132 = v209;
    v214(v130, v79);
    uint64_t v102 = v84;
    uint64_t v75 = v205;
    uint64_t v133 = v188;
    (*(void (**)(char *, char *, uint64_t))(v205 + 32))(v188, v92, v59);
    uint64_t v134 = v185;
    (*(void (**)(char *, char *, uint64_t))(v132 + 32))(v185, v131, v79);
    if (v211)
    {
      uint64_t v135 = v196;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v85 + 96))(v134, v79, v102, v59, v85);
      LODWORD(v211) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v85 + 32) + 8)
                                                                         + 16))(v133, v135, v59);
      uint64_t v136 = *(void (**)(char *, uint64_t))(v75 + 8);
      v136(v135, v59);
      v136(v133, v59);
      uint64_t v101 = v203;
      uint64_t v103 = v213;
      char v105 = v214;
      if ((v211 & 1) == 0) {
        goto LABEL_32;
      }
      goto LABEL_48;
    }
    v214(v134, v79);
    (*(void (**)(char *, uint64_t))(v75 + 8))(v133, v59);
    uint64_t v101 = v203;
    goto LABEL_25;
  }
  uint64_t v99 = v198;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v84 + 96))(v92, v59, v85, v79, v84);
  uint64_t v98 = v210;
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 32) + 8) + 16))(v99, v210, v79);
LABEL_28:
  char v104 = v100;
  char v105 = v214;
  v214(v99, v79);
  v105(v98, v79);
  uint64_t v101 = v203;
  uint64_t v102 = v84;
  uint64_t v75 = v205;
  uint64_t v103 = v213;
  if (v104) {
    goto LABEL_48;
  }
LABEL_32:
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v85 + 96))(v103, v79, v102, v59, v85);
  uint64_t v109 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v75 + 56))(v101, v109, 1, v59);
}

uint64_t BinaryInteger.advanced(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v30 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 64))(v11, v10);
  if ((v12 & 1) == 0)
  {
    if (a1 < 0)
    {
      uint64_t v31 = -a1;
      uint64_t v28 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 88);
      unint64_t v29 = lazy protocol witness table accessor for type UInt and conformance UInt(v12, v13, v14);
      v28(&v31, &type metadata for UInt, v29, a2, a3);
      (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 24) + 8) + 40))(v3, v9, a2);
      return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, a2);
    }
    uint64_t v31 = a1;
    uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 88);
    unint64_t v25 = lazy protocol witness table accessor for type UInt and conformance UInt(v12, v13, v14);
    v24(&v31, &type metadata for UInt, v25, a2, a3);
LABEL_8:
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 24) + 8) + 24))(v3, v9, a2);
    return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, a2);
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3);
  if (v15 > 63)
  {
    uint64_t v31 = a1;
    uint64_t v26 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v27 = lazy protocol witness table accessor for type Int and conformance Int(v15, v16, v17);
    v26(&v31, &type metadata for Int, v27, a2, a3);
    goto LABEL_8;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, v3, a2);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, a2);
  if (__OFADD__(v18, a1))
  {
    __break(1u);
  }
  else
  {
    uint64_t v31 = v18 + a1;
    uint64_t v22 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 88);
    unint64_t v23 = lazy protocol witness table accessor for type Int and conformance Int(result, v20, v21);
    return v22(&v31, &type metadata for Int, v23, a2, a3);
  }
  return result;
}

uint64_t FixedWidthInteger.bitWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

BOOL static BinaryInteger.!= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(void))(*(void *)(*(void *)(a4 + 16) + 8) + 8))() & 1) == 0;
}

BOOL static BinaryInteger.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, a1) & 1) == 0;
}

BOOL static BinaryInteger.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(void))(*(void *)(*(void *)(a4 + 32) + 8) + 16))() & 1) == 0;
}

uint64_t static BinaryInteger.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, a1) & 1;
}

uint64_t specialized FixedWidthInteger.multipliedFullWidth(by:)(_OWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5 = (a5 * (unsigned __int128)a2) >> 64;
  if (__CFADD__((a4 * (unsigned __int128)a2) >> 64, a5 * a2)) {
    ++v5;
  }
  if (__CFADD__((__PAIR128__(a5, a4) * a2) >> 64, a4 * a3)) {
    uint64_t v6 = ((a4 * (unsigned __int128)a3) >> 64) + 1;
  }
  else {
    uint64_t v6 = (a4 * (unsigned __int128)a3) >> 64;
  }
  *a1 = __PAIR128__(a3, a2) * __PAIR128__(a5, a4);
  return v5 + a5 * a3 + v6;
}

uint64_t specialized FixedWidthInteger.multipliedFullWidth(by:)(_OWORD *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  *a1 = __PAIR128__(a3, a2) * __PAIR128__(a5, a4);
  return (a5 >> 63) * a2
       + __CFADD__((a4 * (unsigned __int128)a2) >> 64, a5 * a2)
       + (((unint64_t)a5 * (unsigned __int128)a2) >> 64)
       + a5 * a3
       + a4 * (a3 >> 63)
       + __CFADD__((__PAIR128__(a5, a4) * a2) >> 64, a4 * a3)
       + ((a4 * (unsigned __int128)(unint64_t)a3) >> 64);
}

uint64_t FixedWidthInteger.multipliedFullWidth(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  uint64_t v120 = a3;
  uint64_t v101 = a2;
  uint64_t v99 = a1;
  uint64_t v121 = *(void *)(a5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v121 + 24), a4, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t v124 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v100 = (uint64_t)v95 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v119 = (uint64_t)v95 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)v95 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v111 = (uint64_t)v95 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)v95 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)v95 - v23;
  uint64_t v112 = (char *)v95 - v23;
  uint64_t v109 = *(void *)(a4 - 8);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v97 = (uint64_t)v95 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v110 = (uint64_t)v95 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v118 = (char *)v95 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  BOOL v115 = (char *)v95 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  uint64_t v125 = (uint64_t)v95 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v122 = (char *)v95 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v39 = (char *)v95 - v38;
  char v108 = (char *)v95 - v38;
  MEMORY[0x1F4188790](v37);
  uint64_t v117 = (char *)v95 - v40;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)((uint64_t)v95 - v40, (uint64_t)v24, v6, a4, a4, a5, a5);
  uint64_t v41 = a5;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)((uint64_t)v39, (uint64_t)v21, v120, a4, a4, a5, a5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for FixedWidthInteger, associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  uint64_t v42 = *(void (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 232);
  uint64_t v98 = v21;
  uint64_t v43 = (uint64_t)AssociatedTypeWitness;
  v42(v24, v21, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v44 = *(void (**)(uint64_t, char *, uint64_t))(v124 + 16);
  v95[2] = v124 + 16;
  uint64_t v96 = v44;
  uint64_t v45 = (uint64_t)v16;
  v44((uint64_t)v16, v21, v43);
  uint64_t v46 = v121;
  uint64_t v47 = v121 + 88;
  char v104 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v121 + 88);
  uint64_t v48 = v104;
  uint64_t v120 = swift_getAssociatedConformanceWitness(v121, a4, v43, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  char v49 = v115;
  v48(v45, v43, v120, a4, v46);
  v95[1] = v47;
  uint64_t v50 = *(void (**)(char *, char *, uint64_t, uint64_t))(v41 + 232);
  uint64_t v106 = v41 + 232;
  char v107 = v50;
  v50(v117, v49, a4, v41);
  uint64_t v51 = *(void (**)(char *, uint64_t))(v109 + 8);
  v51(v49, a4);
  uint64_t v123 = v45;
  uint64_t v52 = v119;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(v45, v119, v111, a4, v43, v41, AssociatedConformanceWitness);
  uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v124 + 8);
  v124 += 8;
  char v105 = v53;
  v53(v52, v43);
  uint64_t v54 = v49;
  uint64_t v55 = v45;
  uint64_t v57 = v120;
  uint64_t v56 = v121;
  v104(v55, v43, v120, a4, v121);
  uint64_t v114 = v41;
  uint64_t v102 = *(void (**)(uint64_t, char *, uint64_t, uint64_t))(v41 + 80);
  uint64_t v103 = v41 + 80;
  uint64_t v58 = v125;
  v102((uint64_t)v122, v54, a4, v41);
  v51(v54, a4);
  v51((char *)v58, a4);
  uint64_t v59 = v123;
  uint64_t v116 = v43;
  v96(v123, v112, v43);
  uint64_t v60 = v118;
  uint64_t v61 = v43;
  uint64_t v62 = v104;
  v104(v59, v61, v57, a4, v56);
  uint64_t v63 = v108;
  uint64_t v64 = v114;
  v107(v60, v108, a4, v114);
  v51(v60, a4);
  uint64_t v65 = v110;
  uint64_t v66 = v123;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(v110, v123, (uint64_t)v122, a4, a4, v64, v64);
  v51((char *)v65, a4);
  uint64_t v67 = v116;
  v62(v66, v116, v120, a4, v121);
  uint64_t v68 = v115;
  uint64_t v69 = (void (*)(char *, uint64_t, uint64_t, uint64_t))v102;
  v102(v125, v60, a4, v64);
  v51(v60, a4);
  v51(v68, a4);
  uint64_t v70 = v110;
  v107(v117, v63, a4, v64);
  uint64_t v71 = v97;
  uint64_t v72 = v123;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(v97, v123, (uint64_t)v122, a4, a4, v64, v64);
  uint64_t v73 = v67;
  unint64_t v74 = v105;
  v105(v72, v73);
  v69(v118, v71, a4, v64);
  v51((char *)v71, a4);
  v51((char *)v70, a4);
  uint64_t v75 = v123;
  uint64_t v76 = v114;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(v70, v123, v125, a4, a4, v114, v114);
  v74(v75, v116);
  uint64_t v77 = v115;
  uint64_t v78 = (uint64_t)v118;
  v102((uint64_t)v115, (char *)v70, a4, v76);
  v51((char *)v70, a4);
  v51((char *)v78, a4);
  (*(void (**)(uint64_t, char *, uint64_t))(v109 + 16))(v99, v77, a4);
  uint64_t v79 = v125;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(v78, v119, v125, a4, a4, v76, v76);
  v51((char *)v78, a4);
  uint64_t v80 = (*(uint64_t (**)(uint64_t))(v121 + 128))(a4);
  v51(v77, a4);
  v51((char *)v79, a4);
  v51(v122, a4);
  uint64_t v81 = v116;
  uint64_t v82 = (void (*)(char *, uint64_t))v105;
  v105((uint64_t)v98, v116);
  v51(v108, a4);
  v82(v112, v81);
  uint64_t v83 = ((uint64_t (*)(char *, uint64_t))v51)(v117, a4);
  if (v80 >= 0) {
    uint64_t v86 = v80;
  }
  else {
    uint64_t v86 = v80 + 1;
  }
  uint64_t v126 = v86 >> 1;
  uint64_t v87 = v120;
  int v88 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v120 + 256);
  unint64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
  uint64_t v90 = v123;
  uint64_t v91 = v119;
  v88(v119, &v126, &type metadata for Int, v89, v81, v87);
  v82((char *)v91, v81);
  uint64_t v92 = v100;
  uint64_t v93 = v111;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(v91, v100, v111, a4, v81, v114, AssociatedConformanceWitness);
  v82((char *)v91, v81);
  v82((char *)v93, v81);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v87 + 208))(v90, v92, v81, v87);
  v82((char *)v92, v81);
  return ((uint64_t (*)(uint64_t, uint64_t))v82)(v90, v81);
}

uint64_t FixedWidthInteger.init(bigEndian:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return FixedWidthInteger.init(bigEndian:)(a1, a2, a3);
}

{
  uint64_t (*v5)(uint64_t, uint64_t);
  uint64_t vars8;

  (*(void (**)(uint64_t, uint64_t))(a3 + 192))(a2, a3);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8);

  return v5(a1, a2);
}

uint64_t FixedWidthInteger.bigEndian.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

uint64_t static FixedWidthInteger.&>> infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 208))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 208))(a5, a2, a3, a4);
}

uint64_t static FixedWidthInteger.&>>= infix(_:_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v18 - v12;
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v18 - v14;
  (*(void (**)(char *))(v7 + 16))(v10);
  (*(void (**)(char *, uint64_t, void, uint64_t, void))(*(void *)(a4 + 8) + 96))(v10, a3, *(void *)(a4 + 8), a3, *(void *)(a4 + 8));
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a4 + 200))(a1, v13, a3, a4);
  uint64_t v16 = *(void (**)(char *, uint64_t))(v7 + 8);
  v16(a1, a3);
  v16(v13, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v7 + 32))(a1, v15, a3);
}

uint64_t static FixedWidthInteger.&>>= infix<A>(_:_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v24 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v11);
  uint64_t v18 = (char *)&v24 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v24 - v19;
  (*(void (**)(char *))(v21 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96))(v13, a4, a6, a3);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 200))(a1, v18, a3, a5);
  uint64_t v22 = *(void (**)(char *, uint64_t))(v15 + 8);
  v22(a1, a3);
  v22(v18, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v15 + 32))(a1, v20, a3);
}

uint64_t static FixedWidthInteger.&<< infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 224))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 224))(a5, a2, a3, a4);
}

uint64_t static FixedWidthInteger.&<<= infix(_:_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v18 - v12;
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v18 - v14;
  (*(void (**)(char *))(v7 + 16))(v10);
  (*(void (**)(char *, uint64_t, void, uint64_t, void))(*(void *)(a4 + 8) + 96))(v10, a3, *(void *)(a4 + 8), a3, *(void *)(a4 + 8));
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a4 + 216))(a1, v13, a3, a4);
  uint64_t v16 = *(void (**)(char *, uint64_t))(v7 + 8);
  v16(a1, a3);
  v16(v13, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v7 + 32))(a1, v15, a3);
}

uint64_t static FixedWidthInteger.&<<= infix<A>(_:_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v24 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v11);
  uint64_t v18 = (char *)&v24 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v24 - v19;
  (*(void (**)(char *))(v21 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96))(v13, a4, a6, a3);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 216))(a1, v18, a3, a5);
  uint64_t v22 = *(void (**)(char *, uint64_t))(v15 + 8);
  v22(a1, a3);
  v22(v18, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v15 + 32))(a1, v20, a3);
}

uint64_t split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v60 = a2;
  uint64_t AssociatedConformanceWitness = a1;
  uint64_t v10 = *(void *)(a7 + 8);
  uint64_t v11 = *(int ***)(v10 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a5, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t v64 = *(int ***)(swift_getAssociatedConformanceWitness((uint64_t)v11, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  uint64_t v62 = swift_getAssociatedTypeWitness(0, v64, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1F4188790](v62);
  uint64_t v63 = (char *)&v47 - v14;
  uint64_t v15 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v47 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v59 = *(v18 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v18);
  uint64_t v56 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v54 = (char *)&v47 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v57 = (char *)&v47 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v58 = (char *)&v47 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v55 = (char *)&v47 - v27;
  uint64_t v53 = a7;
  uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 56))(a5, a7);
  if (v28 >= 0) {
    uint64_t v31 = v28;
  }
  else {
    uint64_t v31 = v28 + 1;
  }
  uint64_t v52 = v31 >> 1;
  *(void *)uint64_t v65 = v31 >> 1;
  uint64_t v32 = *(void (**)(uint64_t, char *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v10 + 240);
  unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
  v32(a3, v65, &type metadata for Int, v51, a5, v10);
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v17, a3, a5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v10, a5, (uint64_t)v18, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v47 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 96);
  v47(v17, a5, v10, v18, AssociatedConformanceWitness);
  uint64_t v33 = v64;
  uint64_t v34 = v62;
  uint64_t v35 = swift_getAssociatedConformanceWitness((uint64_t)v64, (uint64_t)v18, (uint64_t)v62, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v36 = *(void (**)(uint64_t *, uint64_t))(v35 + 8);
  uint64_t v49 = v35;
  uint64_t v50 = v36;
  uint64_t v37 = v63;
  ((void (*)(uint64_t *, uint64_t, const char *, uint64_t))v36)(&qword_18162B0C0, 512, v34, v35);
  uint64_t v48 = v33[3];
  uint64_t v38 = v54;
  ((void (*)(char *, uint64_t *, int **))v48)(v37, v18, v33);
  *(void *)uint64_t v65 = v52;
  uint64_t v39 = v56;
  v47(v65, (uint64_t)&type metadata for Int, v51, v18, AssociatedConformanceWitness);
  uint64_t v40 = swift_getAssociatedConformanceWitness(v53, a5, (uint64_t)v18, (uint64_t)&protocol requirements base descriptor for FixedWidthInteger, associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  uint64_t v41 = v57;
  (*(void (**)(char *, char *, uint64_t *, uint64_t))(v40 + 216))(v38, v39, v18, v40);
  uint64_t v42 = *(void (**)(char *, uint64_t *))(v59 + 8);
  v42(v39, v18);
  v42(v38, v18);
  uint64_t v43 = v63;
  v50(&qword_18162B0C0, 512);
  ((void (*)(char *, uint64_t *, int **))v48)(v43, v18, v64);
  uint64_t v44 = v58;
  (*(void (**)(char *, char *, uint64_t *, uint64_t))(v40 + 88))(v58, v38, v18, v40);
  v42(v38, v18);
  v42(v41, v18);
  uint64_t v45 = v55;
  (*(void (**)(char *, char *, uint64_t *))(AssociatedConformanceWitness + 192))(v55, v44, v18);
  v42(v44, v18);
  return ((uint64_t (*)(char *, uint64_t *))v42)(v45, v18);
}

uint64_t static FixedWidthInteger.&>> infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void *)(v14 - 8);
  MEMORY[0x1F4188790](v11);
  uint64_t v17 = (char *)&v20 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v18 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96))(v13, a4, a6, a3);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 200))(a1, v17, a3, a5);
  return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v17, a3);
}

uint64_t specialized RandomNumberGenerator.next<A>(upperBound:)(unint64_t a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "upperBound cannot be zero.", 26, 2, "Swift/Random.swift", 18, 2, 0x6AuLL, 0);
  }
  unint64_t __buf = 0;
  swift_stdlib_random(&__buf, 8uLL);
  uint64_t result = (__buf * (unsigned __int128)a1) >> 64;
  if (__buf * a1 < a1)
  {
    unint64_t v3 = -(uint64_t)a1 % a1;
    if (v3 > __buf * a1)
    {
      do
      {
        unint64_t __buf = 0;
        swift_stdlib_random(&__buf, 8uLL);
      }
      while (v3 > __buf * a1);
      return (__buf * (unsigned __int128)a1) >> 64;
    }
  }
  return result;
}

uint64_t specialized RandomNumberGenerator.next<A>(upperBound:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "upperBound cannot be zero.", 26, 2, "Swift/Random.swift", 18, 2, 0x6AuLL, 0);
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 8);
  uint64_t v7 = v6(a2, a3);
  unint64_t v8 = v7 * a1;
  uint64_t result = ((unint64_t)v7 * (unsigned __int128)a1) >> 64;
  if (v8 < a1)
  {
    unint64_t v10 = -(uint64_t)a1 % a1;
    if (v10 > v8)
    {
      do
        uint64_t v11 = v6(a2, a3);
      while (v10 > v11 * a1);
      return ((unint64_t)v11 * (unsigned __int128)a1) >> 64;
    }
  }
  return result;
}

uint64_t specialized RandomNumberGenerator.next<A>(upperBound:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v257 = a3;
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t v227 = *(int ***)(swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  uint64_t v225 = swift_getAssociatedTypeWitness(0, v227, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v225);
  char v224 = (char *)&v210 - v10;
  uint64_t v235 = v8;
  unint64_t v230 = *(int ***)(v8 + 16);
  v229 = swift_getAssociatedTypeWitness(0, v230, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v229);
  v228 = (char *)&v210 - v11;
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v240 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v233 = (char *)&v210 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v232 = (char *)&v210 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v210 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v222 = (char *)&v210 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v263 = (char *)&v210 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v260 = (char *)&v210 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v241 = (void (**)(char *, char *, uint64_t))((char *)&v210 - v26);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a2, (uint64_t)v12, "high low ", 0);
  uint64_t v212 = *(TupleTypeMetadata2 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  v258 = (char *)&v210 - v28;
  uint64_t v29 = *(void *)(a2 - 8);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  char v261 = (char *)&v210 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v218 = (char *)&v210 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  char v231 = (void (**)(char *, char *, uint64_t *))((char *)&v210 - v35);
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  char v221 = (char *)&v210 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v220 = (char *)&v210 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  uint64_t v234 = (char *)&v210 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  char v236 = (char *)&v210 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  uint64_t v253 = (uint64_t)&v210 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v262 = (char *)&v210 - v47;
  MEMORY[0x1F4188790](v46);
  uint64_t v49 = (char *)&v210 - v48;
  uint64_t v211 = v50;
  unint64_t v51 = *(void (**)(char *, char *, uint64_t))(v50 + 16);
  v259 = a1;
  uint64_t v238 = v50 + 16;
  uint64_t v237 = v51;
  v51((char *)&v210 - v48, a1, a2);
  uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  uint64_t v264 = v7;
  char v53 = v52(a2, v7);
  uint64_t v255 = v52;
  uint64_t v256 = v7 + 64;
  v219 = a4;
  char v223 = v19;
  if (v53)
  {
    uint64_t v254 = *(uint64_t (**)(uint64_t))(v264 + 128);
    uint64_t v54 = v254(a2);
    if (v54 < 64) {
      goto LABEL_3;
    }
LABEL_9:
    uint64_t v265 = 0;
    uint64_t v72 = v264;
    uint64_t v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v264 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    uint64_t v75 = v262;
    v73(&v265, &type metadata for Int, v74, a2, v72);
    uint64_t v63 = TupleTypeMetadata2;
    char v70 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v72 + 16) + 8) + 8))(v49, v75, a2);
    uint64_t v76 = *(char **)(v29 + 8);
    uint64_t v59 = v29 + 8;
    uint64_t v60 = v76;
    ((void (*)(char *, uint64_t))v76)(v75, a2);
LABEL_10:
    uint64_t v62 = v236;
    if (v70) {
      goto LABEL_28;
    }
LABEL_11:
    uint64_t v77 = v59 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    goto LABEL_12;
  }
  uint64_t v64 = v264;
  char v65 = v52(a2, v264);
  uint64_t v254 = *(uint64_t (**)(uint64_t))(v64 + 128);
  uint64_t v54 = ((uint64_t (*)(uint64_t, uint64_t))v254)(a2, v64);
  if ((v65 & 1) == 0)
  {
    if (v54 < 64)
    {
LABEL_3:
      uint64_t v57 = v262;
      v237(v262, v49, a2);
      uint64_t v58 = (*(uint64_t (**)(uint64_t))(v264 + 120))(a2);
      uint64_t v61 = *(char **)(v29 + 8);
      uint64_t v59 = v29 + 8;
      uint64_t v60 = v61;
      ((void (*)(char *, uint64_t))v61)(v57, a2);
      uint64_t v62 = v236;
      uint64_t v63 = TupleTypeMetadata2;
      if (!v58) {
LABEL_28:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "upperBound cannot be zero.", 26, 2, "Swift/Random.swift", 18, 2, 0x6AuLL, 0);
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if (v54 > 64)
  {
    uint64_t v265 = 0;
    uint64_t v66 = v264;
    uint64_t v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v264 + 96);
    unint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    uint64_t v69 = v262;
    v67(&v265, &type metadata for Int, v68, a2, v66);
    char v70 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v66 + 16) + 8) + 8))(v49, v69, a2);
    uint64_t v71 = *(char **)(v29 + 8);
    uint64_t v59 = v29 + 8;
    uint64_t v60 = v71;
    ((void (*)(char *, uint64_t))v71)(v69, a2);
    uint64_t v63 = TupleTypeMetadata2;
    goto LABEL_10;
  }
  BOOL v115 = v230;
  uint64_t v116 = v229;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v230, a2, (uint64_t)v229, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v118 = v228;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v116, AssociatedConformanceWitness);
  uint64_t v119 = v262;
  ((void (*)(char *, uint64_t, int **))v115[3])(v118, a2, v115);
  LOBYTE(v116) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v264 + 32) + 8) + 32))(v49, v119, a2);
  uint64_t v121 = *(char **)(v29 + 8);
  uint64_t v120 = v29 + 8;
  uint64_t v60 = v121;
  ((void (*)(char *, uint64_t))v121)(v119, a2);
  uint64_t v122 = v261;
  v237(v261, v49, a2);
  if (v116)
  {
    uint64_t v123 = (*(uint64_t (**)(uint64_t))(v264 + 120))(a2);
    ((void (*)(char *, uint64_t))v60)(v122, a2);
    uint64_t v63 = TupleTypeMetadata2;
    uint64_t v62 = v236;
    uint64_t v77 = v120 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    if (!v123) {
      goto LABEL_28;
    }
  }
  else
  {
    ((void (*)(char *, uint64_t))v60)(v122, a2);
    uint64_t v63 = TupleTypeMetadata2;
    uint64_t v62 = v236;
    uint64_t v77 = v120 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  }
LABEL_12:
  ((void (*)(char *, uint64_t))v60)(v49, a2);
  uint64_t v78 = v253;
  uint64_t v79 = v257;
  specialized static FixedWidthInteger._random<A>(using:)(a2, v257, v253);
  uint64_t v80 = &v258[*((int *)v63 + 12)];
  uint64_t v81 = *(void (**)(void))(v79 + 120);
  uint64_t v243 = v79 + 120;
  v242 = v81;
  v81();
  uint64_t v239 = v77;
  char v261 = v60;
  ((void (*)(uint64_t, uint64_t))v60)(v78, a2);
  uint64_t v82 = *(void (**)(char *, char *, uint64_t *))(v240 + 16);
  uint64_t v83 = (char *)v241;
  uint64_t v250 = v240 + 16;
  v251 = v80;
  uint64_t v249 = v82;
  v82((char *)v241, v80, v12);
  uint64_t v84 = v264;
  uint64_t v85 = swift_getAssociatedConformanceWitness(v264, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v86 = *(uint64_t (**)(uint64_t *, uint64_t))(v85 + 64);
  LODWORD(v80) = v86(v12, v85);
  int v87 = v255(a2, v84);
  v247 = v86;
  uint64_t v248 = v85 + 64;
  uint64_t v252 = v85;
  if (((v80 ^ v87) & 1) == 0)
  {
    uint64_t v100 = *(uint64_t (**)(uint64_t *, uint64_t))(v85 + 128);
    uint64_t v246 = v85 + 128;
    v245 = v100;
    uint64_t v101 = v100(v12, v85);
    uint64_t v102 = v259;
    uint64_t v244 = v264 + 128;
    if (v101 < v254(a2))
    {
      uint64_t v103 = v264;
      char v104 = v262;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v264 + 96))(v83, v12, v85, a2, v264);
      char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v103 + 32) + 8) + 16))(v104, v102, a2);
LABEL_20:
      char v108 = v105;
      uint64_t v109 = (void (*)(char *, uint64_t))v261;
      ((void (*)(char *, uint64_t))v261)(v104, a2);
      goto LABEL_21;
    }
    uint64_t v112 = v262;
    v237(v262, v102, a2);
    uint64_t v113 = v260;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v85 + 96))(v112, a2, v264, v12, v85);
    uint64_t v114 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v97 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v114 + 16))(v83, v113, v12, v114);
    uint64_t v98 = *(void (**)(char *, uint64_t *))(v240 + 8);
    v98(v113, v12);
    uint64_t v99 = v83;
LABEL_24:
    v98(v99, v12);
    uint64_t v110 = v219;
    uint64_t v111 = TupleTypeMetadata2;
    uint64_t v109 = (void (*)(char *, uint64_t))v261;
    if ((v97 & 1) == 0) {
      goto LABEL_59;
    }
    goto LABEL_31;
  }
  char v88 = v86(v12, v85);
  unint64_t v89 = *(uint64_t (**)(uint64_t *, uint64_t))(v85 + 128);
  uint64_t v246 = v85 + 128;
  v245 = v89;
  uint64_t v90 = v89(v12, v85);
  uint64_t v91 = v259;
  uint64_t v244 = v264 + 128;
  uint64_t v92 = v254(a2);
  uint64_t v93 = v83;
  if ((v88 & 1) == 0)
  {
    uint64_t v106 = v260;
    if (v90 < v92)
    {
      uint64_t v107 = v264;
      char v104 = v262;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v264 + 96))(v83, v12, v252, a2, v264);
      char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v107 + 32) + 8) + 16))(v104, v91, a2);
      goto LABEL_20;
    }
    v193 = v230;
    uint64_t v194 = v229;
    uint64_t v195 = swift_getAssociatedConformanceWitness((uint64_t)v230, a2, (uint64_t)v229, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    unint64_t v196 = v228;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v195 + 8))(&qword_18162B0B8, 256, v194, v195);
    uint64_t v197 = v262;
    v198 = v196;
    v199 = v259;
    ((void (*)(char *, uint64_t, int **))v193[3])(v198, a2, v193);
    LOBYTE(v194) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v264 + 32) + 8) + 40))(v199, v197, a2);
    ((void (*)(char *, uint64_t))v261)(v197, a2);
    uint64_t v200 = v240;
    v201 = v233;
    (*(void (**)(char *, char *, uint64_t *))(v240 + 32))(v233, v83, v12);
    uint64_t v202 = v218;
    v237(v218, v199, a2);
    if ((v194 & 1) == 0)
    {
      ((void (*)(char *, uint64_t))v261)(v202, a2);
      (*(void (**)(char *, uint64_t *))(v200 + 8))(v201, v12);
      goto LABEL_58;
    }
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v252 + 96))(v202, a2, v264, v12);
    uint64_t v203 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v97 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v203 + 16))(v201, v106, v12, v203);
    uint64_t v98 = *(void (**)(char *, uint64_t *))(v200 + 8);
    v98(v106, v12);
    uint64_t v99 = v201;
    goto LABEL_24;
  }
  uint64_t v94 = v260;
  if (v92 < v90)
  {
    char v95 = v262;
    v237(v262, v91, a2);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v252 + 96))(v95, a2, v264, v12);
    uint64_t v96 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v97 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v96 + 16))(v83, v94, v12, v96);
    uint64_t v98 = *(void (**)(char *, uint64_t *))(v240 + 8);
    v98(v94, v12);
    uint64_t v99 = v83;
    goto LABEL_24;
  }
  uint64_t v124 = v227;
  uint64_t v125 = v225;
  uint64_t v126 = swift_getAssociatedConformanceWitness((uint64_t)v227, (uint64_t)v12, (uint64_t)v225, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v127 = v91;
  uint64_t v128 = v93;
  char v129 = v224;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v126 + 8))(&qword_18162B0B8, 256, v125, v126);
  ((void (*)(char *, uint64_t *, int **))v124[3])(v129, v12, v124);
  uint64_t v130 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LOBYTE(v125) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v130 + 16))(v128, v94, v12, v130);
  uint64_t v131 = v240;
  uint64_t v132 = *(void (**)(char *, uint64_t *))(v240 + 8);
  v132(v94, v12);
  uint64_t v133 = *(void (**)(char *, char *, uint64_t *))(v131 + 32);
  uint64_t v134 = v232;
  v133(v232, v128, v12);
  uint64_t v135 = (char *)v231;
  v237((char *)v231, v127, a2);
  if ((v125 & 1) == 0)
  {
    uint64_t v204 = v264;
    uint64_t v205 = v134;
    uint64_t v206 = v262;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v264 + 96))(v205, v12, v252, a2, v264);
    char v108 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v204 + 32) + 8) + 16))(v206, v135, a2);
    v207 = v135;
    uint64_t v109 = (void (*)(char *, uint64_t))v261;
    ((void (*)(char *, uint64_t))v261)(v206, a2);
    v109(v207, a2);
LABEL_21:
    uint64_t v110 = v219;
    uint64_t v111 = TupleTypeMetadata2;
    if ((v108 & 1) == 0) {
      goto LABEL_59;
    }
    goto LABEL_31;
  }
  uint64_t v136 = v135;
  uint64_t v109 = (void (*)(char *, uint64_t))v261;
  ((void (*)(char *, uint64_t))v261)(v136, a2);
  v132(v134, v12);
LABEL_31:
  uint64_t v137 = v262;
  uint64_t v138 = v234;
  char v139 = v230;
  uint64_t v140 = v229;
  uint64_t v141 = swift_getAssociatedConformanceWitness((uint64_t)v230, a2, (uint64_t)v229, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  size_t v142 = *(void (**)(uint64_t *, uint64_t))(v141 + 8);
  unint64_t v143 = v228;
  v218 = (char *)v141;
  uint64_t v217 = v141 + 8;
  uint64_t v216 = v142;
  ((void (*)(uint64_t *, uint64_t, const char *))v142)(&qword_18162B0B8, 256, v140);
  char v144 = v139[3];
  uint64_t v215 = v139 + 3;
  unint64_t v214 = v144;
  ((void (*)(char *, uint64_t, int **))v144)(v143, a2, v139);
  BOOL v145 = v259;
  (*(void (**)(char *, char *, uint64_t))(v257 + 88))(v137, v259, a2);
  v109(v138, a2);
  uint64_t v146 = v264;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v264 + 168))(v137, v145, a2, v264);
  v109(v137, a2);
  uint64_t v147 = v252;
  uint64_t v233 = (char *)(v252 + 96);
  uint64_t v234 = (char *)(v240 + 8);
  v232 = (char *)(v146 + 96);
  char v231 = (void (**)(char *, char *, uint64_t *))(v240 + 32);
  uint64_t v213 = v227 + 3;
  uint64_t v241 = (void (**)(char *, char *, uint64_t))(v211 + 40);
  v240 += 40;
  char v148 = v251;
  while (1)
  {
    uint64_t v159 = v263;
    v249(v263, v148, v12);
    uint64_t v160 = v247;
    int v161 = v247(v12, v147);
    if (((v161 ^ v255(a2, v264)) & 1) == 0)
    {
      uint64_t v175 = v245(v12, v147);
      if (v175 < ((uint64_t (*)(uint64_t, uint64_t))v254)(a2, v264)) {
        goto LABEL_42;
      }
      uint64_t v149 = v262;
      v237(v262, v62, a2);
      uint64_t v179 = v260;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v147 + 96))(v149, a2, v264, v12, v147);
      uint64_t v180 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v181 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v180 + 16))(v159, v179, v12, v180);
      uint64_t v182 = *(void (**)(char *, uint64_t *))v234;
      (*(void (**)(char *, uint64_t *))v234)(v179, v12);
      uint64_t v183 = v159;
      uint64_t v155 = v179;
      uint64_t v62 = v236;
      v182(v183, v12);
      goto LABEL_47;
    }
    if ((v160(v12, v147) & 1) == 0) {
      break;
    }
    uint64_t v162 = v263;
    uint64_t v163 = v245(v12, v147);
    if (((uint64_t (*)(uint64_t, uint64_t))v254)(a2, v264) < v163)
    {
      uint64_t v149 = v262;
      v237(v262, v62, a2);
      size_t v150 = v260;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v147 + 96))(v149, a2, v264, v12, v147);
      uint64_t v151 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v152 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v151 + 16))(v162, v150, v12, v151);
      uint64_t v153 = *(void (**)(char *, uint64_t *))v234;
      (*(void (**)(char *, uint64_t *))v234)(v150, v12);
      v154 = v162;
      uint64_t v155 = v150;
      uint64_t v62 = v236;
      v153(v154, v12);
      uint64_t v156 = (void (*)(char *, uint64_t))v261;
      if ((v152 & 1) == 0) {
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v164 = v227;
      uint64_t v165 = v225;
      uint64_t v166 = swift_getAssociatedConformanceWitness((uint64_t)v227, (uint64_t)v12, (uint64_t)v225, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v167 = v62;
      uint64_t v168 = v224;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v166 + 8))(&qword_18162B0B8, 256, v165, v166);
      char v169 = v260;
      uint64_t v170 = v168;
      uint64_t v171 = v222;
      ((void (*)(char *, uint64_t *, int **))v164[3])(v170, v12, v164);
      uint64_t v172 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v165) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v172 + 16))(v162, v169, v12, v172);
      uint64_t v173 = *(void (**)(char *, uint64_t *))v234;
      (*(void (**)(char *, uint64_t *))v234)(v169, v12);
      (*v231)(v171, v162, v12);
      uint64_t v174 = v220;
      v237(v220, v167, a2);
      if (v165)
      {
        uint64_t v156 = (void (*)(char *, uint64_t))v261;
        ((void (*)(char *, uint64_t))v261)(v174, a2);
        v173(v171, v12);
        uint64_t v155 = v260;
        uint64_t v62 = v236;
        uint64_t v149 = v262;
      }
      else
      {
        uint64_t v191 = v264;
        uint64_t v149 = v262;
        (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v264 + 96))(v171, v12, v147, a2, v264);
        char v192 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v191 + 32) + 8) + 16))(v149, v174, a2);
        uint64_t v156 = (void (*)(char *, uint64_t))v261;
        ((void (*)(char *, uint64_t))v261)(v149, a2);
        v156(v174, a2);
        uint64_t v155 = v260;
        uint64_t v62 = v236;
        if ((v192 & 1) == 0) {
          goto LABEL_57;
        }
      }
    }
LABEL_33:
    uint64_t v157 = v253;
    uint64_t v158 = v257;
    specialized static FixedWidthInteger._random<A>(using:)(a2, v257, v253);
    ((void (*)(char *, char *, char *, uint64_t, uint64_t))v242)(v149, v155, v259, a2, v158);
    v156((char *)v157, a2);
    (*v241)(v258, v149, a2);
    char v148 = v251;
    (*(void (**)(char *, char *, uint64_t *))v240)(v251, v155, v12);
    uint64_t v147 = v252;
  }
  uint64_t v159 = v263;
  uint64_t v176 = v245(v12, v147);
  if (v176 < ((uint64_t (*)(uint64_t, uint64_t))v254)(a2, v264))
  {
LABEL_42:
    uint64_t v177 = v264;
    uint64_t v149 = v262;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v264 + 96))(v159, v12, v147, a2, v264);
    char v178 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v177 + 32) + 8) + 16))(v149, v62, a2);
    uint64_t v156 = (void (*)(char *, uint64_t))v261;
    ((void (*)(char *, uint64_t))v261)(v149, a2);
    uint64_t v155 = v260;
    if ((v178 & 1) == 0) {
      goto LABEL_57;
    }
    goto LABEL_33;
  }
  uint64_t v184 = v228;
  v216(&qword_18162B0B8, 256);
  uint64_t v185 = v262;
  ((void (*)(char *, uint64_t, int **))v214)(v184, a2, v230);
  char v186 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v264 + 32) + 8) + 40))(v62, v185, a2);
  ((void (*)(char *, uint64_t))v261)(v185, a2);
  uint64_t v187 = v223;
  (*v231)(v223, v159, v12);
  uint64_t v188 = v221;
  v237(v221, v62, a2);
  if (v186)
  {
    uint64_t v155 = v260;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v147 + 96))(v188, a2, v264, v12, v147);
    uint64_t v189 = swift_getAssociatedConformanceWitness(v235, a2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v181 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v189 + 16))(v187, v155, v12, v189);
    uint64_t v190 = *(void (**)(char *, uint64_t *))v234;
    (*(void (**)(char *, uint64_t *))v234)(v155, v12);
    v190(v187, v12);
    uint64_t v62 = v236;
    uint64_t v149 = v262;
LABEL_47:
    uint64_t v156 = (void (*)(char *, uint64_t))v261;
    if ((v181 & 1) == 0) {
      goto LABEL_57;
    }
    goto LABEL_33;
  }
  uint64_t v156 = (void (*)(char *, uint64_t))v261;
  ((void (*)(char *, uint64_t))v261)(v188, a2);
  (*(void (**)(char *, uint64_t *))v234)(v187, v12);
LABEL_57:
  v156(v62, a2);
LABEL_58:
  uint64_t v110 = v219;
  uint64_t v111 = TupleTypeMetadata2;
LABEL_59:
  v208 = v258;
  v237(v110, v258, a2);
  return (*(uint64_t (**)(char *, uint64_t *))(v212 + 8))(v208, v111);
}

uint64_t RandomNumberGenerator.next<A>(upperBound:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  uint64_t v250 = a4;
  uint64_t v249 = a2;
  uint64_t v215 = a6;
  uint64_t v257 = a5;
  uint64_t v8 = *(void *)(a5 + 8);
  uint64_t v9 = *(void *)(v8 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  char v223 = *(int ***)(swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  uint64_t v222 = swift_getAssociatedTypeWitness(0, v223, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v222);
  char v221 = (char *)v209 - v11;
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v236 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  v219 = (char *)v209 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v218 = (char *)v209 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)v209 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v230 = (uint64_t)v209 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v229 = (char *)v209 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  char v261 = (char *)v209 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v252 = (char *)v209 - v26;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a3, (uint64_t)v12, "high low ", 0);
  v209[0] = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  v259 = (char *)v209 - v28;
  uint64_t v232 = v9;
  uint64_t v226 = *(int ***)(v9 + 16);
  uint64_t v225 = swift_getAssociatedTypeWitness(0, v226, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v29 = MEMORY[0x1F4188790](v225);
  char v224 = (char *)v209 - v30;
  uint64_t v31 = *(void *)(a3 - 8);
  uint64_t v32 = MEMORY[0x1F4188790](v29);
  uint64_t v217 = (char *)v209 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v216 = (char *)v209 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  char v231 = (char *)v209 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v256 = (char *)v209 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  unint64_t v214 = (char *)v209 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  uint64_t v227 = (char *)v209 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  uint64_t v248 = (uint64_t)v209 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v260 = (char *)v209 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  v262 = (char *)v209 - v49;
  MEMORY[0x1F4188790](v48);
  unint64_t v51 = (char *)v209 - v50;
  uint64_t v237 = v52;
  char v53 = v52[2];
  v258 = a1;
  uint64_t v235 = v52 + 2;
  uint64_t v234 = v53;
  v53((char *)v209 - v50, a1, a3);
  uint64_t v54 = *(unsigned int (**)(uint64_t, uint64_t))(v8 + 64);
  uint64_t v263 = v8;
  char v55 = v54(a3, v8);
  v228 = v19;
  uint64_t v255 = v8 + 64;
  uint64_t v253 = v54;
  uint64_t v220 = TupleTypeMetadata2;
  if (v55)
  {
    uint64_t v254 = *(uint64_t (**)(uint64_t))(v263 + 128);
    uint64_t v56 = v254(a3);
    if (v56 < 64)
    {
      uint64_t v59 = v262;
      v234(v262, v51, a3);
      uint64_t v60 = (*(uint64_t (**)(uint64_t))(v263 + 120))(a3);
      uint64_t v62 = *(void (**)(uint64_t, uint64_t))(v31 + 8);
      uint64_t v61 = v31 + 8;
      uint64_t v233 = v62;
      v62((uint64_t)v59, a3);
      uint64_t v63 = TupleTypeMetadata2;
      uint64_t v64 = v252;
      if (!v60) {
        goto LABEL_12;
      }
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  uint64_t v65 = v263;
  char v66 = v54(a3, v263);
  uint64_t v254 = *(uint64_t (**)(uint64_t))(v65 + 128);
  uint64_t v56 = ((uint64_t (*)(uint64_t, uint64_t))v254)(a3, v65);
  if ((v66 & 1) == 0)
  {
    if (v56 < 64)
    {
      uint64_t v63 = TupleTypeMetadata2;
      uint64_t v76 = v262;
      v234(v262, v51, a3);
      uint64_t v77 = (*(uint64_t (**)(uint64_t))(v263 + 120))(a3);
      uint64_t v78 = *(void (**)(uint64_t, uint64_t))(v31 + 8);
      uint64_t v61 = v31 + 8;
      uint64_t v233 = v78;
      v78((uint64_t)v76, a3);
      uint64_t v64 = v252;
      if (!v77) {
        goto LABEL_12;
      }
LABEL_14:
      uint64_t v73 = v61 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      goto LABEL_15;
    }
LABEL_13:
    uint64_t v264 = 0;
    uint64_t v79 = v263;
    uint64_t v80 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v263 + 96);
    unint64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
    uint64_t v82 = v262;
    v80(&v264, &type metadata for Int, v81, a3, v79);
    uint64_t v63 = v220;
    char v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 16) + 8) + 8))(v51, v82, a3);
    uint64_t v84 = *(void (**)(uint64_t, uint64_t))(v31 + 8);
    uint64_t v61 = v31 + 8;
    uint64_t v233 = v84;
    v84((uint64_t)v82, a3);
    uint64_t v64 = v252;
    if (v83) {
      goto LABEL_12;
    }
    goto LABEL_14;
  }
  if (v56 > 64) {
    goto LABEL_13;
  }
  uint64_t v63 = TupleTypeMetadata2;
  uint64_t v67 = v226;
  unint64_t v68 = v225;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v226, a3, (uint64_t)v225, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v70 = v224;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v68, AssociatedConformanceWitness);
  uint64_t v71 = v262;
  ((void (*)(char *, uint64_t, int **))v67[3])(v70, a3, v67);
  LOBYTE(v68) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v263 + 32) + 8) + 32))(v51, v71, a3);
  uint64_t v72 = *(void (**)(char *, uint64_t))(v31 + 8);
  uint64_t v73 = (v31 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  v72(v71, a3);
  unint64_t v74 = v260;
  v234(v260, v51, a3);
  uint64_t v233 = (void (*)(uint64_t, uint64_t))v72;
  if (v68)
  {
    uint64_t v75 = (*(uint64_t (**)(uint64_t))(v263 + 120))(a3);
    v72(v74, a3);
    uint64_t v64 = v252;
    if (!v75) {
LABEL_12:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "upperBound cannot be zero.", 26, 2, "Swift/Random.swift", 18, 2, 0x6AuLL, 0);
  }
  else
  {
    v72(v74, a3);
    uint64_t v64 = v252;
  }
LABEL_15:
  uint64_t v85 = v233;
  v233((uint64_t)v51, a3);
  uint64_t v86 = v248;
  uint64_t v87 = v257;
  static FixedWidthInteger._random<A>(using:)(v251, a3, v249, v257, v250, v248);
  uint64_t v88 = *((int *)v63 + 12);
  unint64_t v89 = v258;
  uint64_t v90 = (char *)v73;
  uint64_t v91 = &v259[v88];
  uint64_t v92 = *(void (**)(void))(v87 + 120);
  uint64_t v239 = v87 + 120;
  uint64_t v238 = v92;
  v92();
  v85(v86, a3);
  uint64_t v93 = *(void (**)(char *, char *, uint64_t *))(v236 + 16);
  uint64_t v246 = v236 + 16;
  v247 = v91;
  v245 = v93;
  v93(v64, v91, v12);
  uint64_t v94 = v263;
  uint64_t v95 = swift_getAssociatedConformanceWitness(v263, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v96 = *(uint64_t (**)(uint64_t *, uint64_t))(v95 + 64);
  LODWORD(v87) = v96(v12, v95);
  unsigned int v97 = v253(a3, v94);
  v260 = v90;
  uint64_t v244 = v95 + 64;
  uint64_t v243 = v96;
  if (((v87 ^ v97) & 1) == 0)
  {
    uint64_t v111 = *(uint64_t (**)(uint64_t *, uint64_t))(v95 + 128);
    uint64_t v112 = v252;
    uint64_t v242 = v95 + 128;
    uint64_t v241 = v111;
    uint64_t v113 = v111(v12, v95);
    uint64_t v240 = v263 + 128;
    uint64_t v114 = v254(a3);
    uint64_t v103 = v262;
    if (v113 >= v114)
    {
      v234(v262, v89, a3);
      uint64_t v118 = v261;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v95 + 96))(v103, a3, v263, v12, v95);
      uint64_t v119 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v116 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v119 + 16))(v112, v118, v12, v119);
      uint64_t v120 = *(void (**)(char *, uint64_t *))(v236 + 8);
      v120(v118, v12);
      v120(v112, v12);
      uint64_t v103 = v262;
    }
    else
    {
      uint64_t v115 = v263;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v263 + 96))(v112, v12, v95, a3, v263);
      char v116 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v115 + 32) + 8) + 16))(v103, v89, a3);
      v233((uint64_t)v103, a3);
    }
    uint64_t v121 = v215;
    char v105 = v220;
LABEL_32:
    uint64_t v106 = v228;
    if ((v116 & 1) == 0) {
      goto LABEL_61;
    }
    goto LABEL_37;
  }
  char v98 = v96(v12, v95);
  uint64_t v99 = *(uint64_t (**)(uint64_t *, uint64_t))(v95 + 128);
  uint64_t v242 = v95 + 128;
  uint64_t v241 = v99;
  uint64_t v100 = v99(v12, v95);
  uint64_t v240 = v263 + 128;
  uint64_t v101 = v254(a3);
  uint64_t v102 = v261;
  uint64_t v103 = v262;
  if ((v98 & 1) == 0)
  {
    BOOL v104 = v100 < v101;
    char v105 = v220;
    if (v104)
    {
      uint64_t v117 = v263;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v263 + 96))(v252, v12, v95, a3, v263);
      char v116 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v117 + 32) + 8) + 16))(v103, v89, a3);
      v233((uint64_t)v103, a3);
    }
    else
    {
      uint64_t v131 = v226;
      uint64_t v132 = v225;
      uint64_t v133 = swift_getAssociatedConformanceWitness((uint64_t)v226, a3, (uint64_t)v225, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v134 = v224;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v133 + 8))(&qword_18162B0B8, 256, v132, v133);
      uint64_t v135 = v134;
      uint64_t v136 = v262;
      ((void (*)(char *, uint64_t, int **))v131[3])(v135, a3, v131);
      char v137 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v263 + 32) + 8) + 40))(v89, v136, a3);
      uint64_t v138 = (void (*)(char *, uint64_t))v233;
      v233((uint64_t)v136, a3);
      uint64_t v139 = v236;
      (*(void (**)(uint64_t, char *, uint64_t *))(v236 + 32))(v230, v252, v12);
      uint64_t v140 = v89;
      uint64_t v141 = v214;
      v234(v214, v140, a3);
      if ((v137 & 1) == 0)
      {
        v138(v141, a3);
        (*(void (**)(uint64_t, uint64_t *))(v139 + 8))(v230, v12);
        uint64_t v121 = v215;
        goto LABEL_61;
      }
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v95 + 96))(v141, a3, v263, v12, v95);
      uint64_t v142 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      uint64_t v143 = v230;
      char v116 = (*(uint64_t (**)(uint64_t, char *, uint64_t *, uint64_t))(v142 + 16))(v230, v102, v12, v142);
      char v144 = *(void (**)(char *, uint64_t *))(v139 + 8);
      v144(v102, v12);
      v144((char *)v143, v12);
      uint64_t v103 = v262;
    }
    uint64_t v121 = v215;
    goto LABEL_32;
  }
  BOOL v104 = v101 < v100;
  char v105 = v220;
  uint64_t v106 = v228;
  if (v104)
  {
    v234(v262, v89, a3);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v95 + 96))(v103, a3, v263, v12, v95);
    uint64_t v107 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v108 = v252;
    char v109 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v107 + 16))(v252, v102, v12, v107);
    uint64_t v110 = *(void (**)(char *, uint64_t *))(v236 + 8);
    v110(v102, v12);
    v110(v108, v12);
    uint64_t v103 = v262;
    goto LABEL_36;
  }
  uint64_t v122 = v223;
  uint64_t v123 = v222;
  uint64_t v124 = swift_getAssociatedConformanceWitness((uint64_t)v223, (uint64_t)v12, (uint64_t)v222, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v125 = v221;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v124 + 8))(&qword_18162B0B8, 256, v123, v124);
  ((void (*)(char *, uint64_t *, int **))v122[3])(v125, v12, v122);
  uint64_t v126 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  uint64_t v127 = v252;
  LODWORD(v230) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v126 + 16))(v252, v102, v12, v126);
  uint64_t v128 = v236;
  unint64_t v214 = *(char **)(v236 + 8);
  ((void (*)(char *, uint64_t *))v214)(v102, v12);
  char v129 = v229;
  (*(void (**)(char *, char *, uint64_t *))(v128 + 32))(v229, v127, v12);
  uint64_t v130 = v227;
  v234(v227, v258, a3);
  if ((v230 & 1) == 0)
  {
    uint64_t v103 = v262;
    uint64_t v145 = v263;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v263 + 96))(v129, v12, v95, a3, v263);
    char v109 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v145 + 32) + 8) + 16))(v103, v130, a3);
    uint64_t v146 = (void (*)(char *, uint64_t))v233;
    v233((uint64_t)v103, a3);
    v146(v130, a3);
LABEL_36:
    uint64_t v121 = v215;
    if ((v109 & 1) == 0) {
      goto LABEL_61;
    }
    goto LABEL_37;
  }
  v233((uint64_t)v130, a3);
  ((void (*)(char *, uint64_t *))v214)(v129, v12);
  uint64_t v103 = v262;
LABEL_37:
  uint64_t v147 = v253;
  char v148 = v226;
  uint64_t v149 = v225;
  uint64_t v150 = swift_getAssociatedConformanceWitness((uint64_t)v226, a3, (uint64_t)v225, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v151 = *(void (**)(uint64_t *, uint64_t))(v150 + 8);
  char v152 = v224;
  unint64_t v214 = (char *)v150;
  uint64_t v213 = v150 + 8;
  uint64_t v212 = v151;
  ((void (*)(uint64_t *, uint64_t, const char *))v151)(&qword_18162B0B8, 256, v149);
  uint64_t v153 = v148[3];
  v154 = v231;
  uint64_t v211 = v148 + 3;
  uint64_t v210 = v153;
  ((void (*)(char *, uint64_t, int **))v153)(v152, a3, v148);
  uint64_t v155 = v103;
  uint64_t v156 = v103;
  uint64_t v157 = v258;
  (*(void (**)(char *, char *, uint64_t))(v257 + 88))(v155, v258, a3);
  uint64_t v158 = (void (*)(char *, uint64_t))v233;
  v233((uint64_t)v154, a3);
  uint64_t v159 = v263;
  uint64_t v160 = v158;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v263 + 168))(v156, v157, a3, v263);
  v158(v156, a3);
  uint64_t v230 = v95 + 96;
  char v231 = (char *)(v236 + 8);
  v229 = (char *)(v159 + 96);
  uint64_t v227 = (char *)(v236 + 32);
  v209[1] = v223 + 3;
  v237 += 5;
  v236 += 40;
  int v161 = v247;
  uint64_t v252 = (char *)v95;
  while (1)
  {
    v245(v106, v161, v12);
    char v169 = v243;
    int v170 = v243(v12, v95);
    if (((v170 ^ v147(a3, v263)) & 1) == 0)
    {
      uint64_t v177 = v241(v12, v95);
      char v178 = v256;
      if (v177 < ((uint64_t (*)(uint64_t, uint64_t))v254)(a3, v263))
      {
        uint64_t v163 = v262;
        uint64_t v162 = v263;
        (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v263 + 96))(v106, v12, v95, a3, v263);
        char v164 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v162 + 32) + 8) + 16))(v163, v178, a3);
        v160(v163, a3);
        uint64_t v165 = v261;
        uint64_t v166 = v160;
        if ((v164 & 1) == 0) {
          goto LABEL_60;
        }
        goto LABEL_39;
      }
      uint64_t v163 = v262;
      v234(v262, v178, a3);
      uint64_t v165 = v261;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v95 + 96))(v163, a3, v263, v12, v95);
      uint64_t v179 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v175 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v179 + 16))(v106, v165, v12, v179);
      uint64_t v180 = *(void (**)(char *, uint64_t *))v231;
      (*(void (**)(char *, uint64_t *))v231)(v165, v12);
      v180(v106, v12);
      uint64_t v166 = v160;
      goto LABEL_46;
    }
    char v171 = v169(v12, v95);
    uint64_t v172 = v256;
    if (v171)
    {
      uint64_t v173 = v241(v12, v95);
      if (((uint64_t (*)(uint64_t, uint64_t))v254)(a3, v263) < v173)
      {
        uint64_t v163 = v262;
        v234(v262, v172, a3);
        uint64_t v165 = v261;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v95 + 96))(v163, a3, v263, v12, v95);
        uint64_t v174 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        char v175 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v174 + 16))(v106, v165, v12, v174);
        uint64_t v176 = *(void (**)(char *, uint64_t *))v231;
        (*(void (**)(char *, uint64_t *))v231)(v165, v12);
        v176(v106, v12);
        uint64_t v166 = (void (*)(char *, uint64_t))v233;
LABEL_46:
        if ((v175 & 1) == 0) {
          goto LABEL_60;
        }
        goto LABEL_39;
      }
      uint64_t v184 = v223;
      uint64_t v185 = v222;
      uint64_t v186 = swift_getAssociatedConformanceWitness((uint64_t)v223, (uint64_t)v12, (uint64_t)v222, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v187 = v106;
      uint64_t v188 = v221;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v186 + 8))(&qword_18162B0B8, 256, v185, v186);
      uint64_t v189 = v172;
      uint64_t v190 = v261;
      ((void (*)(char *, uint64_t *, int **))v184[3])(v188, v12, v184);
      uint64_t v191 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v185) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v191 + 16))(v187, v190, v12, v191);
      char v192 = *(void (**)(char *, uint64_t *))v231;
      (*(void (**)(char *, uint64_t *))v231)(v190, v12);
      v193 = v218;
      (*(void (**)(char *, char *, uint64_t *))v227)(v218, v187, v12);
      uint64_t v194 = v216;
      v234(v216, v189, a3);
      if (v185)
      {
        uint64_t v166 = (void (*)(char *, uint64_t))v233;
        v233((uint64_t)v194, a3);
        v192(v193, v12);
        uint64_t v106 = v228;
        uint64_t v165 = v261;
        uint64_t v163 = v262;
        goto LABEL_39;
      }
      uint64_t v163 = v262;
      uint64_t v206 = v263;
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v263 + 96))(v193, v12, v95, a3, v263);
      char v183 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v206 + 32) + 8) + 16))(v163, v194, a3);
      uint64_t v166 = (void (*)(char *, uint64_t))v233;
      v233((uint64_t)v163, a3);
      v166(v194, a3);
      uint64_t v106 = v228;
      goto LABEL_56;
    }
    uint64_t v181 = v241(v12, v95);
    if (v181 >= ((uint64_t (*)(uint64_t, uint64_t))v254)(a3, v263)) {
      break;
    }
    uint64_t v163 = v262;
    uint64_t v182 = v263;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v263 + 96))(v106, v12, v95, a3, v263);
    char v183 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v182 + 32) + 8) + 16))(v163, v172, a3);
    uint64_t v166 = (void (*)(char *, uint64_t))v233;
    v233((uint64_t)v163, a3);
LABEL_56:
    uint64_t v165 = v261;
    if ((v183 & 1) == 0) {
      goto LABEL_60;
    }
LABEL_39:
    uint64_t v167 = v248;
    uint64_t v168 = v257;
    static FixedWidthInteger._random<A>(using:)(v251, a3, v249, v257, v250, v248);
    ((void (*)(char *, char *, char *, uint64_t, uint64_t))v238)(v163, v165, v258, a3, v168);
    v166((char *)v167, a3);
    (*v237)(v259, v163, a3);
    int v161 = v247;
    (*(void (**)(char *, char *, uint64_t *))v236)(v247, v165, v12);
    uint64_t v95 = (uint64_t)v252;
    uint64_t v147 = v253;
    uint64_t v160 = v166;
  }
  uint64_t v195 = v224;
  v212(&qword_18162B0B8, 256);
  unint64_t v196 = v262;
  ((void (*)(char *, uint64_t, int **))v210)(v195, a3, v226);
  char v197 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v263 + 32) + 8) + 40))(v172, v196, a3);
  v233((uint64_t)v196, a3);
  v198 = v219;
  (*(void (**)(char *, char *, uint64_t *))v227)(v219, v106, v12);
  v199 = v172;
  uint64_t v200 = v217;
  v234(v217, v199, a3);
  if (v197)
  {
    uint64_t v165 = v261;
    (*((void (**)(char *, uint64_t, uint64_t, uint64_t *))v252 + 12))(v200, a3, v263, v12);
    uint64_t v201 = swift_getAssociatedConformanceWitness(v232, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v202 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v201 + 16))(v198, v165, v12, v201);
    uint64_t v203 = v198;
    uint64_t v204 = *(void (**)(char *, uint64_t *))v231;
    (*(void (**)(char *, uint64_t *))v231)(v165, v12);
    uint64_t v205 = v203;
    uint64_t v106 = v228;
    v204(v205, v12);
    uint64_t v163 = v262;
    uint64_t v166 = (void (*)(char *, uint64_t))v233;
    if ((v202 & 1) == 0) {
      goto LABEL_60;
    }
    goto LABEL_39;
  }
  uint64_t v166 = (void (*)(char *, uint64_t))v233;
  v233((uint64_t)v200, a3);
  (*(void (**)(char *, uint64_t *))v231)(v198, v12);
LABEL_60:
  v166(v256, a3);
  uint64_t v121 = v215;
  char v105 = v220;
LABEL_61:
  v207 = v259;
  v234(v121, v259, a3);
  return (*(uint64_t (**)(char *, uint64_t *))(v209[0] + 8))(v207, v105);
}

uint64_t static FixedWidthInteger.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized static FixedWidthInteger.random<A>(in:using:)(a1, a2, a2, a3);
}

uint64_t specialized static FixedWidthInteger.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v56 = a2;
  uint64_t v57 = a5;
  uint64_t v8 = *(void *)(a4 + 8);
  char v55 = *(int ***)(v8 + 24);
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(255, v55, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v55, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v48 = *(int ***)(AssociatedConformanceWitness + 16);
  uint64_t v45 = swift_getAssociatedTypeWitness(0, v48, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](v45);
  uint64_t v44 = (char *)&v43 - v11;
  uint64_t v49 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v43 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  uint64_t v15 = *(v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v52 = (char *)&v43 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v50 = (char *)&v43 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v43 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v43 - v23;
  type metadata accessor for ClosedRange(0, a3, *(void *)(*(void *)(v8 + 32) + 8), v25);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a4 + 88);
  uint64_t v53 = a1;
  v26(v13, a1, a3, a4);
  uint64_t v27 = swift_getAssociatedConformanceWitness(v8, a3, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v27 + 96);
  uint64_t v47 = v13;
  uint64_t v29 = v13;
  uint64_t v30 = v27;
  uint64_t v58 = v8;
  uint64_t v43 = v28;
  v28(v29, a3, v8, v14, v27);
  uint64_t v54 = a4;
  uint64_t v31 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for FixedWidthInteger, associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  (*(void (**)(uint64_t *, uint64_t))(v31 + 64))(v14, v31);
  uint64_t v32 = swift_getAssociatedConformanceWitness((uint64_t)v55, a3, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LOBYTE(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v32 + 8) + 8))(v24, v22, v14);
  uint64_t v33 = *(void (**)(char *, uint64_t *))(v15 + 8);
  char v55 = (int **)(v15 + 8);
  v33(v22, v14);
  if (AssociatedTypeWitness)
  {
    v33(v24, v14);
    specialized static FixedWidthInteger._random<A>(using:)((uint64_t)v14, v31, (uint64_t)v22);
  }
  else
  {
    uint64_t v46 = v30;
    uint64_t v34 = v48;
    uint64_t v35 = v45;
    uint64_t v36 = swift_getAssociatedConformanceWitness((uint64_t)v48, (uint64_t)v14, (uint64_t)v45, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v37 = v44;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v36 + 8))(&qword_18162B0C0, 512, v35, v36);
    ((void (*)(char *, uint64_t *, int **))v34[3])(v37, v14, v34);
    (*(void (**)(char *, char *, uint64_t *))(*(void *)(AssociatedConformanceWitness + 8) + 32))(v24, v22, v14);
    v33(v22, v14);
    uint64_t v38 = v47;
    (*(void (**)(char *, uint64_t, uint64_t))(v49 + 16))(v47, v53, a3);
    uint64_t v39 = v50;
    v43(v38, a3, v58, v14, v46);
    swift_getAssociatedConformanceWitness(v54, a3, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for FixedWidthInteger, associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: UnsignedInteger);
    uint64_t v40 = v52;
    specialized RandomNumberGenerator.next<A>(upperBound:)(v24, (uint64_t)v14, v31, v52);
    v33(v24, v14);
    (*(void (**)(char *, char *, uint64_t *, uint64_t))(v31 + 80))(v22, v40, v14, v31);
    v33(v40, v14);
    uint64_t v41 = v39;
    uint64_t v30 = v46;
    v33(v41, v14);
  }
  return (*(uint64_t (**)(char *, uint64_t *, uint64_t, uint64_t))(v58 + 96))(v22, v14, v30, a3);
}

uint64_t static FixedWidthInteger.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v59 = a2;
  uint64_t v60 = a6;
  uint64_t v61 = a7;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v57 = *(int ***)(v10 + 24);
  uint64_t v58 = a4;
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(255, v57, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v57, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  unint64_t v51 = *(int ***)(AssociatedConformanceWitness + 16);
  uint64_t v48 = swift_getAssociatedTypeWitness(0, v51, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1F4188790](v48);
  uint64_t v47 = (char *)&v45 - v13;
  uint64_t v52 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v45 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = swift_checkMetadataState(0, AssociatedTypeWitness);
  uint64_t v17 = *(v16 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v54 = (char *)&v45 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v53 = (char *)&v45 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v45 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v45 - v25;
  type metadata accessor for ClosedRange(0, a3, *(void *)(*(void *)(v10 + 32) + 8), v27);
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a5 + 88);
  uint64_t v56 = a1;
  v28(v15, a1, a3, a5);
  uint64_t v29 = swift_getAssociatedConformanceWitness(v10, a3, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v29 + 96);
  uint64_t v50 = v15;
  uint64_t v31 = v15;
  uint64_t v32 = v29;
  uint64_t v62 = v10;
  uint64_t v46 = v30;
  v30(v31, a3, v10, v16, v29);
  uint64_t v33 = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for FixedWidthInteger, associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  (*(void (**)(uint64_t *, uint64_t))(v33 + 64))(v16, v33);
  uint64_t v34 = swift_getAssociatedConformanceWitness((uint64_t)v57, a3, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LOBYTE(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v34 + 8) + 8))(v26, v24, v16);
  uint64_t v35 = *(void (**)(char *, uint64_t *))(v17 + 8);
  uint64_t v57 = (int **)(v17 + 8);
  v35(v24, v16);
  if (AssociatedTypeWitness)
  {
    v35(v26, v16);
    static FixedWidthInteger._random<A>(using:)(v59, (uint64_t)v16, v58, v33, v60, (uint64_t)v24);
  }
  else
  {
    uint64_t v49 = v32;
    uint64_t v36 = v51;
    uint64_t v37 = v48;
    uint64_t v38 = swift_getAssociatedConformanceWitness((uint64_t)v51, (uint64_t)v16, (uint64_t)v48, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v39 = v47;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v38 + 8))(&qword_18162B0C0, 512, v37, v38);
    ((void (*)(char *, uint64_t *, int **))v36[3])(v39, v16, v36);
    (*(void (**)(char *, char *, uint64_t *))(*(void *)(AssociatedConformanceWitness + 8) + 32))(v26, v24, v16);
    v35(v24, v16);
    uint64_t v40 = v50;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v50, v56, a3);
    uint64_t v41 = v53;
    v46(v40, a3, v62, v16, v49);
    uint64_t v42 = v54;
    RandomNumberGenerator.next<A>(upperBound:)(v26, v58, (uint64_t)v16, v60, v33, v54);
    v35(v26, v16);
    (*(void (**)(char *, char *, uint64_t *, uint64_t))(v33 + 80))(v24, v42, v16, v33);
    v35(v42, v16);
    uint64_t v43 = v41;
    uint64_t v32 = v49;
    v35(v43, v16);
  }
  return (*(uint64_t (**)(char *, uint64_t *, uint64_t, uint64_t))(v62 + 96))(v24, v16, v32, a3);
}

uint64_t RandomNumberGenerator.next<A>()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FixedWidthInteger._random<A>(using:)(v5, a2, a1, a4, a3, a5);
}

uint64_t static FixedWidthInteger.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return specialized static FixedWidthInteger.random<A>(in:using:)(a1, a2, a2, a3, a4);
}

uint64_t static FixedWidthInteger._nonMaskingRightShiftGeneric<A>(_:_:)(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, char *a6)
{
  uint64_t v239 = a1;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v241 = a2;
  uint64_t v242 = v10;
  char v231 = *(int ***)(*(void *)(v10 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v231, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v230 = (char *)&v212 - v12;
  uint64_t v233 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v235 = (char *)&v212 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v234 = (char *)&v212 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v238 = (char *)&v212 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v243 = (char *)&v212 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v22 = (uint64_t)&v212 - v21;
  uint64_t v220 = *(int ***)(*((void *)a6 + 3) + 16);
  v219 = swift_getAssociatedTypeWitness(0, v220, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v23 = MEMORY[0x1F4188790](v219);
  v218 = (char *)&v212 - v24;
  uint64_t v237 = (char *)*(a4 - 1);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  unint64_t v214 = (char *)&v212 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v222 = (char *)&v212 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  char v223 = (char *)&v212 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v216 = (char *)&v212 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  char v224 = (char *)&v212 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v225 = (char *)&v212 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v217 = (char *)&v212 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v41 = (char *)&v212 - v40;
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  uint64_t v44 = (char *)&v212 - v43;
  MEMORY[0x1F4188790](v42);
  uint64_t v46 = (char *)&v212 - v45;
  v245 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 56);
  uint64_t v246 = a5 + 56;
  uint64_t v47 = v245(a3, a5);
  uint64_t v48 = -v47;
  if (__OFSUB__(0, v47))
  {
    __break(1u);
    goto LABEL_87;
  }
  uint64_t v244 = a5;
  uint64_t v236 = v46;
  uint64_t v49 = (uint64_t (*)(void *, char *))*((void *)a6 + 8);
  char v50 = v49(a4, a6);
  v228 = a6 + 64;
  uint64_t v227 = v49;
  uint64_t v229 = v22;
  if (v50)
  {
    unint64_t v51 = v241;
    uint64_t v226 = (uint64_t (*)(void *, char *))*((void *)a6 + 16);
    uint64_t v52 = v226(a4, a6);
    if (v52 < 64)
    {
      uint64_t v41 = v236;
      char v55 = v237;
      (*((void (**)(char *, void *, void *))v237 + 2))(v236, v51, a4);
      uint64_t v56 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
      uint64_t v232 = (void (*)(char *, void *))*((void *)v55 + 1);
      v232(v41, a4);
      BOOL v57 = v56 < v48;
      uint64_t v58 = v233;
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      uint64_t v60 = v244;
      if (!v57) {
        goto LABEL_27;
      }
      goto LABEL_23;
    }
    int64_t v248 = v48;
    uint64_t v41 = (char *)*((void *)a6 + 12);
    unint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    char v66 = v236;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))v41)(&v248, &type metadata for Int, v68, a4, a6);
    char v67 = (*(uint64_t (**)(void *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v51, v66, a4);
    goto LABEL_10;
  }
  char v61 = v49(a4, a6);
  uint64_t v226 = (uint64_t (*)(void *, char *))*((void *)a6 + 16);
  uint64_t v62 = v226(a4, a6);
  if ((v61 & 1) == 0)
  {
    uint64_t v59 = (uint64_t)AssociatedTypeWitness;
    uint64_t v60 = v244;
    if (v62 < 64)
    {
      uint64_t v41 = v236;
      char v70 = v237;
      unint64_t v51 = v241;
      (*((void (**)(char *, void *, void *))v237 + 2))(v236, v241, a4);
      uint64_t v71 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
      uint64_t v232 = (void (*)(char *, void *))*((void *)v70 + 1);
      v232(v41, a4);
      BOOL v57 = v71 < v48;
      uint64_t v58 = v233;
      if (v57) {
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v51 = v237;
      uint64_t v79 = (*((uint64_t (**)(char *, void *, void *))v237 + 2))(v41, v241, a4);
      if (v48 <= 0) {
        goto LABEL_26;
      }
      int64_t v248 = v48;
      uint64_t v82 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
      unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
      uint64_t v84 = v236;
      v82(&v248, &type metadata for Int, v83, a4, a6);
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      char v85 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v41, v84, a4);
      uint64_t v86 = (void (*)(char *, void *))v51[1];
      v86(v84, a4);
      uint64_t v232 = v86;
      v86(v41, a4);
      uint64_t v58 = v233;
      unint64_t v51 = v241;
      if (v85) {
        goto LABEL_23;
      }
    }
    goto LABEL_27;
  }
  if (v62 > 64)
  {
    int64_t v248 = v48;
    uint64_t v41 = (char *)*((void *)a6 + 12);
    unint64_t v65 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
    char v66 = v236;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))v41)(&v248, &type metadata for Int, v65, a4, a6);
    unint64_t v51 = v241;
    char v67 = (*(uint64_t (**)(void *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v241, v66, a4);
LABEL_10:
    char v69 = v67;
    uint64_t v232 = (void (*)(char *, void *))*((void *)v237 + 1);
    v232(v66, a4);
    uint64_t v58 = v233;
    uint64_t v59 = (uint64_t)AssociatedTypeWitness;
    uint64_t v60 = v244;
    if (v69) {
      goto LABEL_23;
    }
    goto LABEL_27;
  }
  uint64_t v72 = v220;
  uint64_t v73 = v219;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v220, (uint64_t)a4, (uint64_t)v219, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v75 = v218;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v73, AssociatedConformanceWitness);
  uint64_t v76 = v236;
  ((void (*)(char *, void *, int **))v72[3])(v75, a4, v72);
  uint64_t v77 = (void (*)(void, void, void))v241;
  LOBYTE(v73) = (*(uint64_t (**)(void *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v241, v76, a4);
  uint64_t v41 = v237;
  uint64_t v78 = v76;
  unint64_t v51 = (void *)*((void *)v237 + 1);
  ((void (*)(char *, void *))v51)(v78, a4);
  (*((void (**)(char *, void, void *))v41 + 2))(v44, v77, a4);
  if (v73)
  {
    ((void (*)(char *, void *))v51)(v44, a4);
    uint64_t v58 = v233;
    uint64_t v59 = (uint64_t)AssociatedTypeWitness;
    uint64_t v60 = v244;
    goto LABEL_23;
  }
  uint64_t v87 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
  uint64_t v232 = (void (*)(char *, void *))v51;
  ((void (*)(char *, void *))v51)(v44, a4);
  BOOL v57 = v87 < v48;
  uint64_t v58 = v233;
  uint64_t v59 = (uint64_t)AssociatedTypeWitness;
  unint64_t v51 = v241;
  uint64_t v60 = v244;
  if (!v57)
  {
LABEL_27:
    uint64_t v89 = v245(a3, v60);
    char v90 = v227(a4, a6);
    uint64_t v215 = a6 + 128;
    uint64_t v91 = v226(a4, a6);
    if (v90)
    {
      uint64_t v94 = v232;
      if (v91 > 64)
      {
        int64_t v248 = v89;
        uint64_t v95 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
        unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        unsigned int v97 = v236;
        v95(&v248, &type metadata for Int, v96, a4, a6);
        char v98 = (*(uint64_t (**)(char *, void *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v97, v241, a4);
        uint64_t v99 = v237;
        v94(v97, a4);
        if ((v98 & 1) == 0)
        {
          uint64_t v100 = v99 + 16;
          char v221 = (void (*)(char *, char *, void *))*((void *)v99 + 2);
LABEL_38:
          unint64_t v107 = (unint64_t)v100 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
LABEL_39:
          uint64_t v118 = v225;
          uint64_t v119 = v221;
          v221(v225, (char *)v241, a4);
          char v120 = v227(a4, a6);
          uint64_t v121 = v224;
          uint64_t v241 = (void *)v107;
          v119(v224, v118, a4);
          uint64_t v122 = v226;
          if ((v120 & 1) == 0)
          {
            v232(v121, a4);
            uint64_t v58 = v233;
            goto LABEL_63;
          }
          uint64_t v123 = v226(a4, a6);
          uint64_t v124 = v232;
          char v224 = v99 + 8;
          v232(v121, a4);
          uint64_t v58 = v233;
          if (v123 <= 64) {
            goto LABEL_63;
          }
          uint64_t v125 = v216;
          v221(v216, v118, a4);
          int64_t v248 = 0x8000000000000000;
          uint64_t v126 = v227;
          if (v227(a4, a6))
          {
            uint64_t v127 = v226(a4, a6);
            uint64_t v130 = v125;
            if (v127 < 64)
            {
              uint64_t v131 = v236;
              v221(v236, v130, a4);
              uint64_t v132 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
              v124(v131, a4);
              uint64_t v133 = v130;
              if (v132 < v248) {
                goto LABEL_95;
              }
              goto LABEL_62;
            }
            uint64_t v142 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
            unint64_t v143 = lazy protocol witness table accessor for type Int and conformance Int(v127, v128, v129);
            char v144 = v236;
            v142(&v248, &type metadata for Int, v143, a4, a6);
            uint64_t v118 = v225;
            uint64_t v58 = v233;
            char v141 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v130, v144, a4);
            v124(v144, a4);
            uint64_t v133 = v130;
LABEL_52:
            if (v141) {
              goto LABEL_95;
            }
LABEL_62:
            v124(v133, a4);
            uint64_t v122 = v226;
LABEL_63:
            uint64_t v155 = v122(a4, a6);
            uint64_t v156 = v122;
            uint64_t v157 = v223;
            v221(v223, v118, a4);
            if (v155 < 65)
            {
              uint64_t v159 = v156(a4, a6);
              uint64_t v158 = v232;
              v232(v157, a4);
              if (v159 != 64 || (v227(a4, a6) & 1) != 0) {
                goto LABEL_76;
              }
            }
            else
            {
              uint64_t v158 = v232;
              v232(v157, a4);
            }
            uint64_t v160 = v222;
            v221(v222, v118, a4);
            int64_t v248 = 0x7FFFFFFFFFFFFFFFLL;
            char v161 = v227(a4, a6);
            uint64_t v162 = v226(a4, a6);
            if (v161)
            {
              if (v162 > 64)
              {
                uint64_t v165 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
                unint64_t v166 = lazy protocol witness table accessor for type Int and conformance Int(v162, v163, v164);
                uint64_t v167 = &v248;
LABEL_73:
                char v169 = v160;
                int v170 = v236;
                v165(v167, &type metadata for Int, v166, a4, a6);
                char v171 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8)
                                                                           + 16))(v170, v169, a4);
                v158(v170, a4);
                if (v171) {
                  goto LABEL_93;
                }
                uint64_t v118 = v225;
                uint64_t v160 = v222;
                goto LABEL_75;
              }
            }
            else if (v162 > 63)
            {
              uint64_t v247 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v165 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
              unint64_t v166 = lazy protocol witness table accessor for type Int and conformance Int(v162, v163, v164);
              uint64_t v167 = &v247;
              goto LABEL_73;
            }
            uint64_t v168 = v236;
            v221(v236, v160, a4);
            (*((void (**)(void *, char *))a6 + 15))(a4, a6);
            v158(v168, a4);
            uint64_t v118 = v225;
LABEL_75:
            v158(v160, a4);
LABEL_76:
            uint64_t v172 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
            uint64_t v173 = v118;
            uint64_t v22 = v172;
            v158(v173, a4);
            uint64_t v59 = (uint64_t)AssociatedTypeWitness;
            goto LABEL_77;
          }
          char v134 = v126(a4, a6);
          uint64_t v135 = v226(a4, a6);
          if (v134)
          {
            if (v135 > 64)
            {
              uint64_t v138 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
              unint64_t v139 = lazy protocol witness table accessor for type Int and conformance Int(v135, v136, v137);
              uint64_t v140 = v236;
              v138(&v248, &type metadata for Int, v139, a4, a6);
              uint64_t v58 = v233;
              uint64_t v133 = v216;
              char v141 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v216, v140, a4);
              v124(v140, a4);
              uint64_t v118 = v225;
              goto LABEL_52;
            }
            uint64_t v147 = v220;
            char v148 = v219;
            uint64_t v149 = swift_getAssociatedConformanceWitness((uint64_t)v220, (uint64_t)a4, (uint64_t)v219, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v150 = v218;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v149 + 8))(&qword_18162B0B8, 256, v148, v149);
            uint64_t v151 = v236;
            ((void (*)(char *, void *, int **))v147[3])(v150, a4, v147);
            char v152 = v216;
            LOBYTE(v148) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8)
                                                                               + 16))(v216, v151, a4);
            v124(v151, a4);
            uint64_t v153 = v214;
            v221(v214, v152, a4);
            if (v148)
            {
              v124(v153, a4);
              goto LABEL_95;
            }
            uint64_t v220 = (int **)v248;
            uint64_t v154 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
            v124(v153, a4);
            BOOL v57 = v154 < (uint64_t)v220;
            uint64_t v118 = v225;
            uint64_t v133 = v216;
            if (!v57) {
              goto LABEL_62;
            }
          }
          else
          {
            if (v135 >= 64)
            {
              uint64_t v118 = v225;
              uint64_t v133 = v216;
              goto LABEL_62;
            }
            uint64_t v145 = v236;
            uint64_t v133 = v216;
            v221(v236, v216, a4);
            uint64_t v146 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
            v124(v145, a4);
            uint64_t v118 = v225;
            if (v146 >= v248) {
              goto LABEL_62;
            }
          }
LABEL_95:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        }
LABEL_47:
        uint64_t v22 = v245(a3, v60);
        uint64_t v59 = (uint64_t)AssociatedTypeWitness;
        uint64_t v58 = v233;
        goto LABEL_77;
      }
      uint64_t v106 = v236;
      uint64_t v99 = v237;
      uint64_t v102 = v237 + 16;
      char v221 = (void (*)(char *, char *, void *))*((void *)v237 + 2);
      v221(v236, (char *)v241, a4);
      uint64_t v103 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
      BOOL v104 = v106;
      char v105 = a4;
    }
    else
    {
      uint64_t v94 = v232;
      if (v91 > 63)
      {
        uint64_t v99 = v237;
        char v108 = v237 + 16;
        char v109 = v217;
        char v221 = (void (*)(char *, char *, void *))*((void *)v237 + 2);
        uint64_t v110 = ((uint64_t (*)(char *, void *, void *))v221)(v217, v241, a4);
        if (v89 < 0)
        {
          v94(v109, a4);
          uint64_t v60 = v244;
        }
        else
        {
          int64_t v248 = v89;
          uint64_t v213 = (void (*)(int64_t *, ValueMetadata *, unint64_t, void *, char *))*((void *)a6 + 12);
          unint64_t v113 = lazy protocol witness table accessor for type Int and conformance Int(v110, v111, v112);
          uint64_t v114 = v109;
          uint64_t v115 = v94;
          uint64_t v100 = v108;
          char v116 = v236;
          v213(&v248, &type metadata for Int, v113, a4, a6);
          char v117 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*((void *)a6 + 4) + 8) + 16))(v116, v114, a4);
          v115(v116, a4);
          uint64_t v232 = v115;
          v115(v114, a4);
          uint64_t v60 = v244;
          if ((v117 & 1) == 0) {
            goto LABEL_38;
          }
        }
        goto LABEL_47;
      }
      uint64_t v101 = v236;
      uint64_t v99 = v237;
      uint64_t v102 = v237 + 16;
      char v221 = (void (*)(char *, char *, void *))*((void *)v237 + 2);
      v221(v236, (char *)v241, a4);
      uint64_t v103 = (*((uint64_t (**)(void *, char *))a6 + 15))(a4, a6);
      BOOL v104 = v101;
      char v105 = a4;
      uint64_t v232 = v94;
    }
    v94(v104, v105);
    if (v89 >= v103)
    {
      unint64_t v107 = (unint64_t)v102 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
      goto LABEL_39;
    }
    goto LABEL_47;
  }
LABEL_23:
  uint64_t v88 = v245(a3, v60);
  uint64_t v22 = -v88;
  if (__OFSUB__(0, v88))
  {
    __break(1u);
LABEL_26:
    uint64_t v232 = (void (*)(char *, void *))v51[1];
    v232(v41, a4);
    goto LABEL_27;
  }
LABEL_77:
  uint64_t v174 = *(void (**)(char *, uint64_t, uint64_t))(v58 + 32);
  v174(v243, v239, a3);
  char v175 = (*(uint64_t (**)(uint64_t))(v242 + 64))(a3);
  a6 = v235;
  uint64_t v241 = v174;
  if (v175)
  {
    uint64_t v176 = v244;
    uint64_t v177 = v245(a3, v244);
    if (!__OFSUB__(v177, 1))
    {
      int64_t v248 = v177 - 1;
      uint64_t v180 = v58;
      uint64_t v181 = v242;
      uint64_t v182 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v242 + 96);
      unint64_t v183 = lazy protocol witness table accessor for type Int and conformance Int(v177, v178, v179);
      uint64_t v184 = v234;
      uint64_t v185 = v181;
      uint64_t v186 = v231;
      v182(&v248, &type metadata for Int, v183, a3, v185);
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v176 + 200))(v243, v184, a3, v176);
      uint64_t v187 = v184;
      a6 = v235;
      (*(void (**)(char *, uint64_t))(v58 + 8))(v187, a3);
      uint64_t v188 = swift_getAssociatedConformanceWitness((uint64_t)v186, a3, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v189 = v230;
      goto LABEL_81;
    }
    __break(1u);
LABEL_93:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  uint64_t v186 = v231;
  uint64_t v188 = swift_getAssociatedConformanceWitness((uint64_t)v231, a3, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v180 = v58;
  uint64_t v189 = v230;
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v188 + 8))(&qword_18162B0B8, 256, v59, v188);
  ((void (*)(char *, uint64_t, int **))v186[3])(v189, a3, v186);
LABEL_81:
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v188 + 8))(&qword_18162B0B8, 256, v59, v188);
  ((void (*)(char *, uint64_t, int **))v186[3])(v189, a3, v186);
  a4 = *(void **)(v180 + 8);
  if (v22 < 0)
  {
LABEL_87:
    ((void (*)(char *, uint64_t))a4)(v238, a3);
    uint64_t v202 = v244;
    uint64_t v203 = v245(a3, v244);
    if (__OFSUB__(0, v203))
    {
      __break(1u);
    }
    else if (-v203 < v22)
    {
      uint64_t v204 = ((uint64_t (*)(char *, uint64_t))a4)(a6, a3);
      int64_t v248 = -v22;
      uint64_t v205 = v242;
      uint64_t v206 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v242 + 96);
      unint64_t v209 = lazy protocol witness table accessor for type Int and conformance Int(v204, v207, v208);
      char v197 = v234;
      v206(&v248, &type metadata for Int, v209, a3, v205);
      uint64_t v198 = v229;
      v199 = v243;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v202 + 216))(v243, v197, a3, v202);
      goto LABEL_84;
    }
    ((void (*)(char *, uint64_t))a4)(v243, a3);
    uint64_t v198 = v229;
    uint64_t v210 = v229;
    uint64_t v211 = a6;
LABEL_91:
    uint64_t v200 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v241;
    ((void (*)(uint64_t, char *, uint64_t))v241)(v210, v211, a3);
    return v200(v239, v198, a3);
  }
  ((void (*)(char *, uint64_t))a4)(a6, a3);
  uint64_t v190 = v244;
  if (v22 >= v245(a3, v244))
  {
    ((void (*)(char *, uint64_t))a4)(v243, a3);
    uint64_t v198 = v229;
    uint64_t v210 = v229;
    uint64_t v211 = v238;
    goto LABEL_91;
  }
  uint64_t v191 = ((uint64_t (*)(char *, uint64_t))a4)(v238, a3);
  int64_t v248 = v22;
  uint64_t v192 = v242;
  v193 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v242 + 96);
  unint64_t v196 = lazy protocol witness table accessor for type Int and conformance Int(v191, v194, v195);
  char v197 = v234;
  v193(&v248, &type metadata for Int, v196, a3, v192);
  uint64_t v198 = v229;
  v199 = v243;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v190 + 200))(v243, v197, a3, v190);
LABEL_84:
  ((void (*)(char *, uint64_t))a4)(v197, a3);
  ((void (*)(char *, uint64_t))a4)(v199, a3);
  uint64_t v200 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v241;
  return v200(v239, v198, a3);
}

uint64_t static FixedWidthInteger.>>= infix<A>(_:_:)(uint64_t a1, void (*a2)(char *, uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (void *)a4;
  v245 = a2;
  uint64_t v239 = a1;
  v219 = *(int ***)(*(void *)(a6 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v219, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v217 = (char *)v214 - v10;
  uint64_t v241 = *(void *)(a5 + 8);
  uint64_t v234 = *(int ***)(*(void *)(v241 + 24) + 16);
  uint64_t v233 = swift_getAssociatedTypeWitness(0, v234, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](v233);
  uint64_t v13 = (char *)v214 - v12;
  uint64_t v230 = *(void *)(a3 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v235 = (char *)v214 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v232 = (char *)v214 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v238 = (char *)v214 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v242 = (char *)v214 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v229 = (char *)v214 - v23;
  uint64_t v237 = (char *)*(v8 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v26 = (uint64_t)v214 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  uint64_t v29 = (char *)v214 - v28;
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v216 = (char *)v214 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v215 = (char *)v214 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  char v221 = (char *)v214 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v223 = (uint64_t)v214 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v220 = (char *)v214 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  uint64_t v222 = (char *)v214 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  char v224 = (char *)v214 - v43;
  MEMORY[0x1F4188790](v42);
  uint64_t v45 = (char *)v214 - v44;
  uint64_t v46 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 56);
  uint64_t v240 = a5;
  uint64_t v243 = v46;
  uint64_t v244 = a5 + 56;
  uint64_t v47 = v46(a3, a5);
  uint64_t v48 = -v47;
  if (__OFSUB__(0, v47))
  {
    __break(1u);
    goto LABEL_83;
  }
  uint64_t v236 = v45;
  uint64_t v49 = *(uint64_t (**)(void *, uint64_t))(a6 + 64);
  char v50 = v49(v8, a6);
  v228 = v13;
  uint64_t v225 = a6 + 64;
  uint64_t v227 = v49;
  if ((v50 & 1) == 0)
  {
    char v58 = v49(v8, a6);
    uint64_t v226 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
    uint64_t v59 = v226(v8, a6);
    if (v58)
    {
      uint64_t v57 = v240;
      if (v59 <= 64)
      {
        uint64_t v72 = v219;
        uint64_t v73 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v219, (uint64_t)v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v75 = v217;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v73, AssociatedConformanceWitness);
        uint64_t v76 = v236;
        ((void (*)(char *, void *, int **))v72[3])(v75, v8, v72);
        LOBYTE(v73) = (*(uint64_t (**)(void, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                          + 16))(v245, v76, v8);
        uint64_t v77 = v237;
        uint64_t v78 = v76;
        uint64_t v79 = (void (*)(char *, void *))*((void *)v237 + 1);
        v79(v78, v8);
        (*((void (**)(char *, void, void *))v77 + 2))(v29, v245, v8);
        if (v73)
        {
          v79(v29, v8);
        }
        else
        {
          uint64_t v88 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          char v231 = v79;
          v79(v29, v8);
          uint64_t v29 = v237;
          if (v88 >= v48) {
            goto LABEL_26;
          }
        }
        goto LABEL_22;
      }
      int64_t v247 = v48;
      uint64_t v62 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
      unint64_t v63 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
      uint64_t v64 = v236;
      v62(&v247, &type metadata for Int, v63, v8, a6);
      char v65 = (*(uint64_t (**)(void, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v245, v64, v8);
      uint64_t v29 = v237;
      char v231 = (void (*)(char *, void *))*((void *)v237 + 1);
      v231(v64, v8);
      if (v65) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v57 = v240;
      if (v59 < 64)
      {
        char v70 = v236;
        uint64_t v29 = v237;
        (*((void (**)(char *, void, void *))v237 + 2))(v236, v245, v8);
        uint64_t v71 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
        char v231 = (void (*)(char *, void *))*((void *)v29 + 1);
        v231(v70, v8);
        if (v71 < v48) {
          goto LABEL_22;
        }
      }
      else
      {
        uint64_t v29 = v237;
        uint64_t v80 = (*((uint64_t (**)(uint64_t, void, void *))v237 + 2))(v26, v245, v8);
        if (v48 <= 0) {
          goto LABEL_25;
        }
        int64_t v247 = v48;
        unint64_t v83 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
        char v85 = v236;
        v83(&v247, &type metadata for Int, v84, v8, a6);
        uint64_t v29 = v237;
        char v86 = (*(uint64_t (**)(uint64_t, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v26, v85, v8);
        uint64_t v87 = (void (*)(char *, void *))*((void *)v29 + 1);
        v87(v85, v8);
        char v231 = v87;
        v87((char *)v26, v8);
        if (v86) {
          goto LABEL_22;
        }
      }
    }
LABEL_26:
    uint64_t v91 = v243(a3, v57);
    char v92 = v227(v8, a6);
    uint64_t v93 = v226(v8, a6);
    uint64_t v90 = v230;
    v214[1] = a6 + 128;
    if (v92)
    {
      if (v93 > 64)
      {
        int64_t v247 = v91;
        unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
        char v98 = v236;
        v96(&v247, &type metadata for Int, v97, v8, a6);
        char v99 = (*(uint64_t (**)(char *, void, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v98, v245, v8);
        v231(v98, v8);
        if ((v99 & 1) == 0)
        {
          uint64_t v100 = (void (*)(char *, char *, void *))*((void *)v29 + 2);
          goto LABEL_35;
        }
        goto LABEL_42;
      }
    }
    else if (v93 > 63)
    {
      uint64_t v103 = (uint64_t (*)(char *, void, void *))*((void *)v29 + 2);
      BOOL v104 = v216;
      uint64_t v105 = v103(v216, v245, v8);
      if (v91 < 0)
      {
        v231(v104, v8);
        goto LABEL_42;
      }
      int64_t v247 = v91;
      char v108 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
      unint64_t v109 = lazy protocol witness table accessor for type Int and conformance Int(v105, v106, v107);
      uint64_t v110 = v236;
      v214[0] = v103;
      uint64_t v111 = v104;
      v108(&v247, &type metadata for Int, v109, v8, a6);
      uint64_t v90 = v230;
      char v112 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v110, v104, v8);
      unint64_t v113 = v110;
      uint64_t v114 = v231;
      v231(v113, v8);
      uint64_t v115 = v111;
      uint64_t v100 = (void (*)(char *, char *, void *))v214[0];
      v114(v115, v8);
      if (v112)
      {
LABEL_42:
        uint64_t v57 = v240;
        uint64_t v26 = v243(a3, v240);
        goto LABEL_73;
      }
LABEL_35:
      uint64_t v116 = v223;
      char v117 = v224;
      v100(v224, (char *)v245, v8);
      char v118 = v227(v8, a6);
      uint64_t v119 = v222;
      v100(v222, v117, v8);
      char v120 = v226;
      if ((v118 & 1) == 0)
      {
        v231(v119, v8);
        goto LABEL_59;
      }
      uint64_t v121 = v226(v8, a6);
      uint64_t v122 = v119;
      uint64_t v123 = (void (*)(char *, uint64_t, uint64_t))(v237 + 8);
      v231(v122, v8);
      if (v121 <= 64) {
        goto LABEL_59;
      }
      v245 = v123;
      v100(v220, v117, v8);
      int64_t v247 = 0x8000000000000000;
      uint64_t v124 = v227;
      if (v227(v8, a6))
      {
        char v120 = v226;
        uint64_t v125 = v226(v8, a6);
        if (v125 < 64)
        {
          uint64_t v128 = v236;
          v100(v236, v220, v8);
          uint64_t v223 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v129 = v231;
          v231(v128, v8);
          BOOL v130 = v223 < v247;
LABEL_55:
          unint64_t v139 = v220;
          if (!v130) {
            goto LABEL_58;
          }
LABEL_91:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        }
        uint64_t v140 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v141 = lazy protocol witness table accessor for type Int and conformance Int(v125, v126, v127);
        uint64_t v142 = v236;
        v140(&v247, &type metadata for Int, v141, v8, a6);
        char v120 = v226;
        char v117 = v224;
        LODWORD(v223) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                            + 16))(v220, v142, v8);
        uint64_t v129 = v231;
        v231(v142, v8);
        unint64_t v139 = v220;
      }
      else
      {
        char v131 = v124(v8, a6);
        char v120 = v226;
        uint64_t v132 = v226(v8, a6);
        if ((v131 & 1) == 0)
        {
          if (v132 >= 64)
          {
            char v117 = v224;
            v231(v220, v8);
            goto LABEL_59;
          }
          unint64_t v143 = v236;
          char v144 = v220;
          v100(v236, v220, v8);
          uint64_t v223 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v129 = v231;
          v231(v143, v8);
          unint64_t v139 = v144;
          char v117 = v224;
          if (v223 < v247) {
            goto LABEL_91;
          }
LABEL_58:
          v129(v139, v8);
LABEL_59:
          uint64_t v156 = v120(v8, a6);
          v100((char *)v116, v117, v8);
          if (v156 < 65)
          {
            uint64_t v158 = v120(v8, a6);
            v231((char *)v116, v8);
            if (v158 != 64) {
              goto LABEL_72;
            }
            uint64_t v157 = v227;
            if (v227(v8, a6)) {
              goto LABEL_72;
            }
          }
          else
          {
            v231((char *)v116, v8);
            uint64_t v157 = v227;
          }
          uint64_t v159 = v221;
          v100(v221, v117, v8);
          int64_t v247 = 0x7FFFFFFFFFFFFFFFLL;
          char v160 = v157(v8, a6);
          uint64_t v161 = v226(v8, a6);
          if (v160)
          {
            if (v161 > 64)
            {
              uint64_t v164 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
              unint64_t v165 = lazy protocol witness table accessor for type Int and conformance Int(v161, v162, v163);
              unint64_t v166 = &v247;
LABEL_69:
              int v170 = v236;
              v164(v166, &type metadata for Int, v165, v8, a6);
              char v171 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v170, v159, v8);
              uint64_t v172 = v170;
              char v169 = v231;
              v231(v172, v8);
              if (v171) {
                goto LABEL_89;
              }
              uint64_t v168 = v221;
              goto LABEL_71;
            }
          }
          else if (v161 > 63)
          {
            uint64_t v246 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v164 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
            unint64_t v165 = lazy protocol witness table accessor for type Int and conformance Int(v161, v162, v163);
            unint64_t v166 = &v246;
            goto LABEL_69;
          }
          uint64_t v167 = v236;
          v100(v236, v159, v8);
          (*(void (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v168 = v159;
          char v169 = v231;
          v231(v167, v8);
LABEL_71:
          char v117 = v224;
          v169(v168, v8);
LABEL_72:
          uint64_t v173 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v174 = v117;
          uint64_t v26 = v173;
          v231(v174, v8);
          uint64_t v90 = v230;
          uint64_t v57 = v240;
          goto LABEL_73;
        }
        if (v132 <= 64)
        {
          uint64_t v145 = v219;
          uint64_t v146 = AssociatedTypeWitness;
          uint64_t v147 = swift_getAssociatedConformanceWitness((uint64_t)v219, (uint64_t)v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v148 = v217;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v147 + 8))(&qword_18162B0B8, 256, v146, v147);
          uint64_t v149 = v145;
          uint64_t v150 = v145[3];
          uint64_t v151 = v236;
          ((void (*)(char *, void *, int **))v150)(v148, v8, v149);
          char v152 = v220;
          LODWORD(v223) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                              + 16))(v220, v151, v8);
          v231(v151, v8);
          uint64_t v153 = v215;
          v100(v215, v152, v8);
          if (v223)
          {
            v231(v153, v8);
            goto LABEL_91;
          }
          uint64_t v223 = v247;
          uint64_t v154 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v155 = v153;
          uint64_t v129 = v231;
          v231(v155, v8);
          BOOL v130 = v154 < v223;
          char v117 = v224;
          goto LABEL_55;
        }
        uint64_t v135 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v136 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        uint64_t v137 = v236;
        v135(&v247, &type metadata for Int, v136, v8, a6);
        char v120 = v226;
        uint64_t v138 = v220;
        LODWORD(v223) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                            + 16))(v220, v137, v8);
        uint64_t v129 = v231;
        v231(v137, v8);
        unint64_t v139 = v138;
        char v117 = v224;
      }
      if (v223) {
        goto LABEL_91;
      }
      goto LABEL_58;
    }
    uint64_t v100 = (void (*)(char *, char *, void *))*((void *)v29 + 2);
    uint64_t v101 = v236;
    v100(v236, (char *)v245, v8);
    uint64_t v102 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
    v231(v101, v8);
    if (v91 < v102) {
      goto LABEL_42;
    }
    goto LABEL_35;
  }
  unint64_t v51 = v245;
  uint64_t v226 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
  uint64_t v52 = v226(v8, a6);
  if (v52 >= 64)
  {
    int64_t v247 = v48;
    char v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
    unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    unint64_t v68 = v236;
    v66(&v247, &type metadata for Int, v67, v8, a6);
    char v69 = (*(uint64_t (**)(void, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v245, v68, v8);
    uint64_t v29 = v237;
    char v231 = (void (*)(char *, void *))*((void *)v237 + 1);
    v231(v68, v8);
    uint64_t v57 = v240;
    if (v69) {
      goto LABEL_22;
    }
    goto LABEL_26;
  }
  char v55 = v236;
  uint64_t v29 = v237;
  (*((void (**)(char *, void, void *))v237 + 2))(v236, v51, v8);
  uint64_t v56 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
  char v231 = (void (*)(char *, void *))*((void *)v29 + 1);
  v231(v55, v8);
  uint64_t v57 = v240;
  if (v56 >= v48) {
    goto LABEL_26;
  }
LABEL_22:
  uint64_t v89 = v243(a3, v57);
  uint64_t v26 = -v89;
  uint64_t v90 = v230;
  if (__OFSUB__(0, v89))
  {
    __break(1u);
LABEL_25:
    char v231 = (void (*)(char *, void *))*((void *)v29 + 1);
    v231((char *)v26, v8);
    goto LABEL_26;
  }
LABEL_73:
  char v175 = *(void (**)(char *, uint64_t, uint64_t))(v90 + 32);
  v175(v242, v239, a3);
  char v176 = (*(uint64_t (**)(uint64_t))(v241 + 64))(a3);
  uint64_t v177 = v234;
  uint64_t v29 = v235;
  uint64_t v178 = v233;
  v245 = v175;
  if (v176)
  {
    uint64_t v179 = v243(a3, v57);
    if (!__OFSUB__(v179, 1))
    {
      int64_t v247 = v179 - 1;
      uint64_t v182 = v57;
      uint64_t v183 = v241;
      uint64_t v184 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v241 + 96);
      unint64_t v185 = lazy protocol witness table accessor for type Int and conformance Int(v179, v180, v181);
      uint64_t v186 = v232;
      uint64_t v187 = v183;
      uint64_t v188 = v182;
      uint64_t v177 = v234;
      v184(&v247, &type metadata for Int, v185, a3, v187);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v188 + 200))(v242, v186, a3, v188);
      uint64_t v189 = v186;
      uint64_t v178 = v233;
      uint64_t v29 = v235;
      (*(void (**)(char *, uint64_t))(v90 + 8))(v189, a3);
      uint64_t v190 = swift_getAssociatedConformanceWitness((uint64_t)v177, a3, (uint64_t)v178, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v191 = v228;
      goto LABEL_77;
    }
    __break(1u);
LABEL_89:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  uint64_t v190 = swift_getAssociatedConformanceWitness((uint64_t)v234, a3, (uint64_t)v233, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v191 = v228;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v190 + 8))(&qword_18162B0B8, 256, v178, v190);
  ((void (*)(char *, uint64_t, int **))v177[3])(v191, a3, v177);
LABEL_77:
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v190 + 8))(&qword_18162B0B8, 256, v178, v190);
  ((void (*)(char *, uint64_t, int **))v177[3])(v191, a3, v177);
  uint64_t v8 = *(void **)(v90 + 8);
  if (v26 < 0)
  {
LABEL_83:
    ((void (*)(char *, uint64_t))v8)(v238, a3);
    uint64_t v204 = v240;
    uint64_t v205 = v243(a3, v240);
    if (__OFSUB__(0, v205))
    {
      __break(1u);
    }
    else if (-v205 < v26)
    {
      uint64_t v206 = ((uint64_t (*)(char *, uint64_t))v8)(v29, a3);
      int64_t v247 = -v26;
      uint64_t v207 = v241;
      uint64_t v208 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v241 + 96);
      unint64_t v211 = lazy protocol witness table accessor for type Int and conformance Int(v206, v209, v210);
      v199 = v232;
      v208(&v247, &type metadata for Int, v211, a3, v207);
      uint64_t v200 = v229;
      uint64_t v201 = v242;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v204 + 216))(v242, v199, a3, v204);
      goto LABEL_80;
    }
    ((void (*)(char *, uint64_t))v8)(v242, a3);
    uint64_t v200 = v229;
    uint64_t v212 = v229;
    uint64_t v213 = v29;
LABEL_87:
    uint64_t v202 = (uint64_t (*)(uint64_t, char *, uint64_t))v245;
    v245(v212, (uint64_t)v213, a3);
    return v202(v239, v200, a3);
  }
  ((void (*)(char *, uint64_t))v8)(v29, a3);
  uint64_t v192 = v240;
  if (v26 >= v243(a3, v240))
  {
    ((void (*)(char *, uint64_t))v8)(v242, a3);
    uint64_t v200 = v229;
    uint64_t v212 = v229;
    uint64_t v213 = v238;
    goto LABEL_87;
  }
  uint64_t v193 = ((uint64_t (*)(char *, uint64_t))v8)(v238, a3);
  int64_t v247 = v26;
  uint64_t v194 = v241;
  uint64_t v195 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v241 + 96);
  unint64_t v198 = lazy protocol witness table accessor for type Int and conformance Int(v193, v196, v197);
  v199 = v232;
  v195(&v247, &type metadata for Int, v198, a3, v194);
  uint64_t v200 = v229;
  uint64_t v201 = v242;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v192 + 200))(v242, v199, a3, v192);
LABEL_80:
  ((void (*)(char *, uint64_t))v8)(v199, a3);
  ((void (*)(char *, uint64_t))v8)(v201, a3);
  uint64_t v202 = (uint64_t (*)(uint64_t, char *, uint64_t))v245;
  return v202(v239, v200, a3);
}

uint64_t static FixedWidthInteger._nonMaskingRightShift(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v50 = a2;
  uint64_t v53 = a1;
  uint64_t v48 = a5;
  uint64_t v7 = *(void *)(a4 + 8);
  uint64_t v8 = *(void *)(*(void *)(v7 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v48 - v11;
  uint64_t v51 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v48 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v52 = (char *)&v48 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v19 = (char *)&v48 - v18;
  char v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 64))(a3, v7);
  uint64_t v49 = v15;
  uint64_t v54 = v19;
  if (v20)
  {
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    if (__OFSUB__(v21, 1))
    {
      __break(1u);
      goto LABEL_16;
    }
    uint64_t v55 = v21 - 1;
    uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v25 = lazy protocol witness table accessor for type Int and conformance Int(v21, v22, v23);
    uint64_t v26 = v7;
    uint64_t v27 = v52;
    v24(&v55, &type metadata for Int, v25, a3, v26);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v53, v27, a3, a4);
    uint64_t v28 = v51;
    uint64_t v29 = v27;
    uint64_t v7 = v26;
    (*(void (**)(char *, uint64_t))(v51 + 8))(v29, a3);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  }
  else
  {
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a3, v8);
    uint64_t v28 = v51;
  }
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v15 = v49;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a3, v8);
  uint64_t v31 = *(void (**)(char *, uint64_t))(v28 + 8);
  uint64_t v32 = v50;
  if (v50 < 0)
  {
    v31(v54, a3);
    uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    uint64_t v12 = v48;
    if (!__OFSUB__(0, v41))
    {
      if (-v41 < v32)
      {
        uint64_t v42 = ((uint64_t (*)(char *, uint64_t))v31)(v15, a3);
        uint64_t v55 = -v32;
        uint64_t v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v44, v45);
        uint64_t v47 = v7;
        uint64_t v39 = v52;
        v43(&v55, &type metadata for Int, v46, a3, v47);
        (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 216))(v53, v39, a3, a4);
        return ((uint64_t (*)(char *, uint64_t))v31)(v39, a3);
      }
      return (*(uint64_t (**)(char *, char *, uint64_t))(v51 + 32))(v12, v15, a3);
    }
LABEL_16:
    __break(1u);
    return (*(uint64_t (**)(char *, char *, uint64_t))(v51 + 32))(v12, v15, a3);
  }
  v31(v15, a3);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4) > v32)
  {
    uint64_t v33 = ((uint64_t (*)(char *, uint64_t))v31)(v54, a3);
    uint64_t v55 = v32;
    uint64_t v34 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v33, v35, v36);
    uint64_t v38 = v7;
    uint64_t v39 = v52;
    v34(&v55, &type metadata for Int, v37, a3, v38);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v53, v39, a3, a4);
    return ((uint64_t (*)(char *, uint64_t))v31)(v39, a3);
  }
  return (*(uint64_t (**)(char *, char *, uint64_t))(v51 + 32))(v48, v54, a3);
}

uint64_t static FixedWidthInteger._nonMaskingLeftShiftGeneric<A>(_:_:)(uint64_t a1, void (*a2)(char *, uint64_t, uint64_t), uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v226 = a1;
  uint64_t v10 = *(void *)(a5 + 8);
  v228 = a2;
  uint64_t v229 = v10;
  char v221 = *(int ***)(*(void *)(v10 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v221, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v227 = (char *)&v199 - v12;
  uint64_t v216 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v225 = (char *)&v199 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v220 = (char *)&v199 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  char v224 = (char *)&v199 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v230 = (char *)&v199 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v22 = (uint64_t)&v199 - v21;
  uint64_t v207 = *(int ***)(*(void *)(a6 + 24) + 16);
  uint64_t v206 = swift_getAssociatedTypeWitness(0, v207, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v23 = MEMORY[0x1F4188790](v206);
  uint64_t v205 = (char *)&v199 - v24;
  uint64_t v223 = (char *)*(a4 - 1);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v202 = (char *)&v199 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v209 = (char *)&v199 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v210 = (char *)&v199 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v203 = (char *)&v199 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  unint64_t v211 = (char *)&v199 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v212 = (char *)&v199 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v204 = (char *)&v199 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v41 = (char *)&v199 - v40;
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  uint64_t v44 = (char *)&v199 - v43;
  MEMORY[0x1F4188790](v42);
  unint64_t v46 = (char *)&v199 - v45;
  char v231 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 56);
  uint64_t v232 = a5 + 56;
  uint64_t v47 = v231(a3, a5);
  uint64_t v48 = -v47;
  if (__OFSUB__(0, v47))
  {
    __break(1u);
    goto LABEL_88;
  }
  uint64_t v233 = a5;
  v218 = v46;
  uint64_t v49 = *(uint64_t (**)(void *, uint64_t))(a6 + 64);
  char v50 = v49(a4, a6);
  uint64_t v214 = a6 + 64;
  uint64_t v213 = v49;
  uint64_t v215 = v22;
  if (v50)
  {
    uint64_t v51 = v228;
    uint64_t v217 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
    uint64_t v52 = v217(a4, a6);
    if (v52 < 64)
    {
      uint64_t v55 = v223;
      uint64_t v56 = v218;
      (*((void (**)(char *, void *, void *))v223 + 2))(v218, v51, a4);
      uint64_t v57 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
      v219 = (char *)*((void *)v55 + 1);
      ((void (*)(char *, void *))v219)(v56, a4);
      BOOL v58 = v57 < v48;
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      uint64_t v60 = v227;
      if (!v58) {
        goto LABEL_27;
      }
      goto LABEL_23;
    }
    int64_t v235 = v48;
    uint64_t v41 = *(char **)(a6 + 96);
    unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    uint64_t v56 = v218;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))v41)(&v235, &type metadata for Int, v67, a4, a6);
    char v66 = (*(uint64_t (**)(void *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v51, v56, a4);
    goto LABEL_10;
  }
  char v61 = v49(a4, a6);
  uint64_t v217 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
  uint64_t v62 = v217(a4, a6);
  if ((v61 & 1) == 0)
  {
    uint64_t v60 = v227;
    uint64_t v56 = v218;
    if (v62 < 64)
    {
      char v69 = v223;
      uint64_t v51 = v228;
      (*((void (**)(char *, void *, void *))v223 + 2))(v218, v228, a4);
      uint64_t v70 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
      v219 = (char *)*((void *)v69 + 1);
      ((void (*)(char *, void *))v219)(v56, a4);
      BOOL v58 = v70 < v48;
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      if (v58) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v223;
      uint64_t v76 = (*((uint64_t (**)(char *, void *, void *))v223 + 2))(v41, v228, a4);
      if (v48 <= 0) {
        goto LABEL_26;
      }
      int64_t v235 = v48;
      uint64_t v79 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
      unint64_t v80 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
      v79(&v235, &type metadata for Int, v80, a4, a6);
      uint64_t v60 = v227;
      char v81 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v41, v56, a4);
      uint64_t v82 = (char *)*((void *)v51 + 1);
      ((void (*)(char *, void *))v82)(v56, a4);
      v219 = v82;
      ((void (*)(char *, void *))v82)(v41, a4);
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      uint64_t v51 = v228;
      if (v81) {
        goto LABEL_23;
      }
    }
    goto LABEL_27;
  }
  uint64_t v56 = v218;
  if (v62 > 64)
  {
    int64_t v235 = v48;
    uint64_t v41 = *(char **)(a6 + 96);
    unint64_t v65 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))v41)(&v235, &type metadata for Int, v65, a4, a6);
    uint64_t v51 = v228;
    char v66 = (*(uint64_t (**)(void *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v228, v56, a4);
LABEL_10:
    char v68 = v66;
    v219 = (char *)*((void *)v223 + 1);
    ((void (*)(char *, void *))v219)(v56, a4);
    uint64_t v59 = (uint64_t)AssociatedTypeWitness;
    uint64_t v60 = v227;
    if (v68) {
      goto LABEL_23;
    }
    goto LABEL_27;
  }
  uint64_t v71 = v207;
  uint64_t v72 = v206;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v207, (uint64_t)a4, (uint64_t)v206, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v74 = v205;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v72, AssociatedConformanceWitness);
  ((void (*)(char *, void *, int **))v71[3])(v74, a4, v71);
  uint64_t v51 = v228;
  LOBYTE(v72) = (*(uint64_t (**)(void *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v228, v56, a4);
  uint64_t v41 = v223;
  uint64_t v75 = v56;
  uint64_t v56 = (char *)*((void *)v223 + 1);
  ((void (*)(char *, void *))v56)(v75, a4);
  (*((void (**)(char *, void *, void *))v41 + 2))(v44, v51, a4);
  if (v72)
  {
    ((void (*)(char *, void *))v56)(v44, a4);
    uint64_t v59 = (uint64_t)AssociatedTypeWitness;
    uint64_t v60 = v227;
    goto LABEL_23;
  }
  uint64_t v83 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
  v219 = v56;
  ((void (*)(char *, void *))v56)(v44, a4);
  BOOL v58 = v83 < v48;
  uint64_t v59 = (uint64_t)AssociatedTypeWitness;
  uint64_t v60 = v227;
  uint64_t v51 = v228;
  uint64_t v56 = v218;
  if (!v58)
  {
LABEL_27:
    uint64_t v85 = v231(a3, v233);
    char v86 = v213(a4, a6);
    uint64_t v201 = a6 + 128;
    uint64_t v87 = v217(a4, a6);
    if (v86)
    {
      uint64_t v90 = v219;
      if (v87 > 64)
      {
        int64_t v235 = v85;
        uint64_t v91 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v87, v88, v89);
        v91(&v235, &type metadata for Int, v92, a4, a6);
        char v93 = (*(uint64_t (**)(char *, void *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v56, v228, a4);
        uint64_t v94 = v223;
        ((void (*)(char *, void *))v90)(v56, a4);
        if ((v93 & 1) == 0)
        {
          v219 = v90;
          unint64_t v95 = (unint64_t)(v94 + 16);
          uint64_t v208 = (void (*)(char *, char *, void *))*((void *)v94 + 2);
LABEL_37:
          unint64_t v99 = v95 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
LABEL_38:
          unint64_t v109 = v212;
          uint64_t v110 = v208;
          v208(v212, (char *)v228, a4);
          char v111 = v213(a4, a6);
          char v112 = v211;
          unint64_t v200 = v99;
          v110(v211, v109, a4);
          if ((v111 & 1) == 0)
          {
            ((void (*)(char *, void *))v219)(v112, a4);
            uint64_t v59 = (uint64_t)AssociatedTypeWitness;
            goto LABEL_63;
          }
          uint64_t v113 = v217(a4, a6);
          uint64_t v114 = (void (*)(char *, uint64_t, uint64_t))(v94 + 8);
          ((void (*)(char *, void *))v219)(v112, a4);
          uint64_t v59 = (uint64_t)AssociatedTypeWitness;
          if (v113 <= 64) {
            goto LABEL_63;
          }
          uint64_t v115 = v203;
          v208(v203, v109, a4);
          int64_t v235 = 0x8000000000000000;
          uint64_t v116 = v213;
          if (v213(a4, a6))
          {
            v228 = v114;
            uint64_t v117 = v217(a4, a6);
            char v120 = v115;
            if (v117 < 64)
            {
              uint64_t v56 = v218;
              v208(v218, v115, a4);
              uint64_t v121 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
              uint64_t v122 = v219;
              ((void (*)(char *, void *))v219)(v56, a4);
              BOOL v58 = v121 < v235;
              uint64_t v115 = v120;
              uint64_t v123 = v122;
              if (!v58) {
                goto LABEL_62;
              }
LABEL_96:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
            }
            char v131 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
            unint64_t v132 = lazy protocol witness table accessor for type Int and conformance Int(v117, v118, v119);
            uint64_t v56 = v218;
            v131(&v235, &type metadata for Int, v132, a4, a6);
            unint64_t v109 = v212;
            uint64_t v59 = (uint64_t)AssociatedTypeWitness;
            LODWORD(v211) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                                + 16))(v115, v56, a4);
            uint64_t v133 = v219;
            ((void (*)(char *, void *))v219)(v56, a4);
            uint64_t v123 = v133;
            if (v211) {
              goto LABEL_96;
            }
          }
          else
          {
            char v124 = v116(a4, a6);
            uint64_t v125 = v217(a4, a6);
            if (v124)
            {
              uint64_t v56 = v218;
              uint64_t v123 = v219;
              if (v125 <= 64)
              {
                uint64_t v135 = v207;
                unint64_t v136 = v206;
                uint64_t v137 = swift_getAssociatedConformanceWitness((uint64_t)v207, (uint64_t)a4, (uint64_t)v206, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                uint64_t v138 = v205;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v137 + 8))(&qword_18162B0B8, 256, v136, v137);
                ((void (*)(char *, void *, int **))v135[3])(v138, a4, v135);
                unint64_t v139 = v203;
                LOBYTE(v136) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32)
                                                                                               + 8)
                                                                                   + 16))(v203, v56, a4);
                ((void (*)(char *, void *))v123)(v56, a4);
                uint64_t v140 = v202;
                v208(v202, v139, a4);
                if (v136)
                {
                  ((void (*)(char *, void *))v123)(v140, a4);
                }
                else
                {
                  int64_t v141 = v235;
                  uint64_t v142 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                  ((void (*)(char *, void *))v123)(v140, a4);
                  BOOL v58 = v142 < v141;
                  unint64_t v109 = v212;
                  uint64_t v115 = v203;
                  if (!v58) {
                    goto LABEL_62;
                  }
                }
                goto LABEL_96;
              }
              uint64_t v128 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
              unint64_t v129 = lazy protocol witness table accessor for type Int and conformance Int(v125, v126, v127);
              v128(&v235, &type metadata for Int, v129, a4, a6);
              uint64_t v59 = (uint64_t)AssociatedTypeWitness;
              uint64_t v115 = v203;
              char v130 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v203, v56, a4);
              ((void (*)(char *, void *))v123)(v56, a4);
              unint64_t v109 = v212;
              if (v130) {
                goto LABEL_96;
              }
            }
            else
            {
              uint64_t v56 = v218;
              uint64_t v123 = v219;
              if (v125 < 64)
              {
                uint64_t v115 = v203;
                v208(v218, v203, a4);
                uint64_t v134 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                ((void (*)(char *, void *))v123)(v56, a4);
                unint64_t v109 = v212;
                if (v134 < v235) {
                  goto LABEL_96;
                }
              }
              else
              {
                unint64_t v109 = v212;
                uint64_t v115 = v203;
              }
            }
          }
LABEL_62:
          ((void (*)(char *, void *))v123)(v115, a4);
LABEL_63:
          unint64_t v143 = v217;
          uint64_t v144 = v217(a4, a6);
          uint64_t v145 = v210;
          v208(v210, v109, a4);
          if (v144 < 65)
          {
            uint64_t v147 = v143(a4, a6);
            uint64_t v146 = v219;
            ((void (*)(char *, void *))v219)(v145, a4);
            if (v147 != 64 || (v213(a4, a6) & 1) != 0) {
              goto LABEL_76;
            }
          }
          else
          {
            uint64_t v146 = v219;
            ((void (*)(char *, void *))v219)(v145, a4);
          }
          char v148 = v209;
          v208(v209, v109, a4);
          int64_t v235 = 0x7FFFFFFFFFFFFFFFLL;
          char v149 = v213(a4, a6);
          uint64_t v150 = v217(a4, a6);
          if (v149)
          {
            if (v150 > 64)
            {
              uint64_t v153 = v148;
              uint64_t v154 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
              unint64_t v155 = lazy protocol witness table accessor for type Int and conformance Int(v150, v151, v152);
              uint64_t v156 = &v235;
LABEL_73:
              v154(v156, &type metadata for Int, v155, a4, a6);
              uint64_t v158 = v153;
              uint64_t v146 = v219;
              char v159 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v56, v158, a4);
              ((void (*)(char *, void *))v146)(v56, a4);
              if (v159) {
                goto LABEL_94;
              }
              uint64_t v157 = v209;
              goto LABEL_75;
            }
          }
          else if (v150 > 63)
          {
            uint64_t v234 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v153 = v148;
            uint64_t v154 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
            unint64_t v155 = lazy protocol witness table accessor for type Int and conformance Int(v150, v151, v152);
            uint64_t v156 = &v234;
            goto LABEL_73;
          }
          v208(v56, v148, a4);
          (*(void (**)(void *, uint64_t))(a6 + 120))(a4, a6);
          uint64_t v157 = v148;
          ((void (*)(char *, void *))v146)(v56, a4);
LABEL_75:
          unint64_t v109 = v212;
          ((void (*)(char *, void *))v146)(v157, a4);
LABEL_76:
          uint64_t v160 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
          uint64_t v161 = v109;
          uint64_t v22 = v160;
          ((void (*)(char *, void *))v146)(v161, a4);
          goto LABEL_77;
        }
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v90 = v219;
      if (v87 > 63)
      {
        uint64_t v100 = v223 + 16;
        uint64_t v101 = v204;
        uint64_t v208 = (void (*)(char *, char *, void *))*((void *)v223 + 2);
        uint64_t v102 = ((uint64_t (*)(char *, void, void *))v208)(v204, v228, a4);
        if (v85 < 0)
        {
          ((void (*)(char *, void *))v90)(v101, a4);
        }
        else
        {
          int64_t v235 = v85;
          uint64_t v105 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
          unint64_t v106 = lazy protocol witness table accessor for type Int and conformance Int(v102, v103, v104);
          unint64_t v200 = (unint64_t)v100;
          uint64_t v107 = v101;
          v105(&v235, &type metadata for Int, v106, a4, a6);
          char v108 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v56, v101, a4);
          uint64_t v94 = v223;
          ((void (*)(char *, void *))v90)(v56, a4);
          ((void (*)(char *, void *))v90)(v107, a4);
          if ((v108 & 1) == 0)
          {
            v219 = v90;
            unint64_t v95 = v200;
            goto LABEL_37;
          }
        }
LABEL_47:
        uint64_t v22 = v231(a3, v233);
LABEL_77:
        uint64_t v60 = v227;
        goto LABEL_78;
      }
    }
    unint64_t v96 = v223;
    unint64_t v97 = v223 + 16;
    uint64_t v208 = (void (*)(char *, char *, void *))*((void *)v223 + 2);
    v208(v56, (char *)v228, a4);
    uint64_t v98 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
    ((void (*)(char *, void *))v90)(v56, a4);
    if (v85 >= v98)
    {
      uint64_t v94 = v96;
      v219 = v90;
      unint64_t v99 = (unint64_t)v97 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
      goto LABEL_38;
    }
    goto LABEL_47;
  }
LABEL_23:
  uint64_t v84 = v231(a3, v233);
  uint64_t v22 = -v84;
  if (__OFSUB__(0, v84))
  {
    __break(1u);
LABEL_26:
    v219 = (char *)*((void *)v51 + 1);
    ((void (*)(char *, void *))v219)(v41, a4);
    uint64_t v59 = (uint64_t)AssociatedTypeWitness;
    goto LABEL_27;
  }
LABEL_78:
  uint64_t v162 = v216;
  uint64_t v163 = *(void (**)(char *, uint64_t, uint64_t))(v216 + 32);
  v163(v230, v226, a3);
  char v164 = (*(uint64_t (**)(uint64_t))(v229 + 64))(a3);
  unint64_t v165 = v221;
  v228 = v163;
  if (v164)
  {
    uint64_t v166 = v231(a3, v233);
    if (!__OFSUB__(v166, 1))
    {
      int64_t v235 = v166 - 1;
      uint64_t v169 = v229;
      int v170 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v229 + 96);
      unint64_t v171 = lazy protocol witness table accessor for type Int and conformance Int(v166, v167, v168);
      uint64_t v172 = v220;
      unint64_t v165 = v221;
      uint64_t v173 = v169;
      uint64_t v174 = v233;
      v170(&v235, &type metadata for Int, v171, a3, v173);
      uint64_t v60 = v227;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v174 + 200))(v230, v172, a3, v174);
      char v175 = v172;
      uint64_t v59 = (uint64_t)AssociatedTypeWitness;
      (*(void (**)(char *, uint64_t))(v162 + 8))(v175, a3);
      uint64_t v176 = swift_getAssociatedConformanceWitness((uint64_t)v165, a3, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      goto LABEL_82;
    }
    __break(1u);
LABEL_94:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  uint64_t v176 = swift_getAssociatedConformanceWitness((uint64_t)v221, a3, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v176 + 8))(&qword_18162B0B8, 256, v59, v176);
  ((void (*)(char *, uint64_t, int **))v165[3])(v60, a3, v165);
LABEL_82:
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v176 + 8))(&qword_18162B0B8, 256, v59, v176);
  ((void (*)(char *, uint64_t, int **))v165[3])(v60, a3, v165);
  a4 = *(void **)(v162 + 8);
  if (v22 < 0)
  {
LABEL_88:
    ((void (*)(char *, uint64_t))a4)(v225, a3);
    uint64_t v189 = v231(a3, v233);
    if (__OFSUB__(0, v189))
    {
      __break(1u);
    }
    else
    {
      uint64_t v190 = v233;
      if (-v189 < v22)
      {
        uint64_t v191 = ((uint64_t (*)(char *, uint64_t))a4)(v224, a3);
        int64_t v235 = -v22;
        uint64_t v192 = v229;
        uint64_t v193 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v229 + 96);
        unint64_t v196 = lazy protocol witness table accessor for type Int and conformance Int(v191, v194, v195);
        uint64_t v184 = v220;
        v193(&v235, &type metadata for Int, v196, a3, v192);
        uint64_t v185 = v215;
        uint64_t v186 = v230;
        (*(void (**)(char *, char *, uint64_t, uint64_t))(v190 + 200))(v230, v184, a3, v190);
        goto LABEL_85;
      }
    }
    ((void (*)(char *, uint64_t))a4)(v230, a3);
    uint64_t v185 = v215;
    uint64_t v197 = v215;
    unint64_t v198 = v224;
LABEL_92:
    uint64_t v187 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v228;
    v228((char *)v197, (uint64_t)v198, a3);
    return v187(v226, v185, a3);
  }
  ((void (*)(char *, uint64_t))a4)(v224, a3);
  if (v22 >= v231(a3, v233))
  {
    ((void (*)(char *, uint64_t))a4)(v230, a3);
    uint64_t v185 = v215;
    uint64_t v197 = v215;
    unint64_t v198 = v225;
    goto LABEL_92;
  }
  uint64_t v177 = ((uint64_t (*)(char *, uint64_t))a4)(v225, a3);
  int64_t v235 = v22;
  uint64_t v178 = v233;
  uint64_t v179 = v229;
  uint64_t v180 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v229 + 96);
  unint64_t v183 = lazy protocol witness table accessor for type Int and conformance Int(v177, v181, v182);
  uint64_t v184 = v220;
  v180(&v235, &type metadata for Int, v183, a3, v179);
  uint64_t v185 = v215;
  uint64_t v186 = v230;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v178 + 216))(v230, v184, a3, v178);
LABEL_85:
  ((void (*)(char *, uint64_t))a4)(v184, a3);
  ((void (*)(char *, uint64_t))a4)(v186, a3);
  uint64_t v187 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v228;
  return v187(v226, v185, a3);
}

uint64_t static FixedWidthInteger.<<= infix<A>(_:_:)(uint64_t a1, void (*a2)(char *, uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (void *)a4;
  uint64_t v246 = a2;
  uint64_t v240 = a1;
  uint64_t v220 = *(int ***)(*(void *)(a6 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v220, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  v218 = (char *)v215 - v10;
  uint64_t v242 = *(void *)(a5 + 8);
  int64_t v235 = *(int ***)(*(void *)(v242 + 24) + 16);
  uint64_t v234 = swift_getAssociatedTypeWitness(0, v235, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](v234);
  uint64_t v13 = (char *)v215 - v12;
  uint64_t v231 = *(void *)(a3 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v236 = (char *)v215 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v233 = (char *)v215 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v239 = (char *)v215 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v243 = (char *)v215 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v230 = (char *)v215 - v23;
  uint64_t v238 = (char *)*(v8 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v26 = (uint64_t)v215 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  uint64_t v29 = (char *)v215 - v28;
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v217 = (char *)v215 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v216 = (char *)v215 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v222 = (char *)v215 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v224 = (uint64_t)v215 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  char v221 = (char *)v215 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  uint64_t v223 = (char *)v215 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  uint64_t v225 = (char *)v215 - v43;
  MEMORY[0x1F4188790](v42);
  uint64_t v45 = (char *)v215 - v44;
  unint64_t v46 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 56);
  uint64_t v241 = a5;
  uint64_t v244 = v46;
  uint64_t v245 = a5 + 56;
  uint64_t v47 = v46(a3, a5);
  uint64_t v48 = -v47;
  if (__OFSUB__(0, v47))
  {
    __break(1u);
    goto LABEL_83;
  }
  uint64_t v237 = v45;
  uint64_t v49 = *(uint64_t (**)(void *, uint64_t))(a6 + 64);
  char v50 = v49(v8, a6);
  uint64_t v229 = v13;
  uint64_t v226 = a6 + 64;
  v228 = v49;
  if ((v50 & 1) == 0)
  {
    char v58 = v49(v8, a6);
    uint64_t v227 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
    uint64_t v59 = v227(v8, a6);
    if (v58)
    {
      uint64_t v57 = v241;
      if (v59 <= 64)
      {
        uint64_t v72 = v220;
        uint64_t v73 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v220, (uint64_t)v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v75 = v218;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v73, AssociatedConformanceWitness);
        uint64_t v76 = v237;
        ((void (*)(char *, void *, int **))v72[3])(v75, v8, v72);
        LOBYTE(v73) = (*(uint64_t (**)(void, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                          + 16))(v246, v76, v8);
        uint64_t v77 = v238;
        uint64_t v78 = v76;
        uint64_t v79 = (void (*)(char *, void *))*((void *)v238 + 1);
        v79(v78, v8);
        (*((void (**)(char *, void, void *))v77 + 2))(v29, v246, v8);
        if (v73)
        {
          v79(v29, v8);
        }
        else
        {
          uint64_t v88 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v232 = v79;
          v79(v29, v8);
          uint64_t v29 = v238;
          if (v88 >= v48) {
            goto LABEL_26;
          }
        }
        goto LABEL_22;
      }
      int64_t v248 = v48;
      uint64_t v62 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
      unint64_t v63 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
      uint64_t v64 = v237;
      v62(&v248, &type metadata for Int, v63, v8, a6);
      char v65 = (*(uint64_t (**)(void, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v246, v64, v8);
      uint64_t v29 = v238;
      uint64_t v232 = (void (*)(char *, void *))*((void *)v238 + 1);
      v232(v64, v8);
      if (v65) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v57 = v241;
      if (v59 < 64)
      {
        uint64_t v70 = v237;
        uint64_t v29 = v238;
        (*((void (**)(char *, void, void *))v238 + 2))(v237, v246, v8);
        uint64_t v71 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
        uint64_t v232 = (void (*)(char *, void *))*((void *)v29 + 1);
        v232(v70, v8);
        if (v71 < v48) {
          goto LABEL_22;
        }
      }
      else
      {
        uint64_t v29 = v238;
        uint64_t v80 = (*((uint64_t (**)(uint64_t, void, void *))v238 + 2))(v26, v246, v8);
        if (v48 <= 0) {
          goto LABEL_25;
        }
        int64_t v248 = v48;
        uint64_t v83 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
        uint64_t v85 = v237;
        v83(&v248, &type metadata for Int, v84, v8, a6);
        uint64_t v29 = v238;
        char v86 = (*(uint64_t (**)(uint64_t, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v26, v85, v8);
        uint64_t v87 = (void (*)(char *, void *))*((void *)v29 + 1);
        v87(v85, v8);
        uint64_t v232 = v87;
        v87((char *)v26, v8);
        if (v86) {
          goto LABEL_22;
        }
      }
    }
LABEL_26:
    uint64_t v91 = v244(a3, v57);
    char v92 = v228(v8, a6);
    uint64_t v93 = v227(v8, a6);
    uint64_t v90 = v231;
    v215[1] = a6 + 128;
    if (v92)
    {
      if (v93 > 64)
      {
        int64_t v248 = v91;
        unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
        uint64_t v98 = v237;
        v96(&v248, &type metadata for Int, v97, v8, a6);
        char v99 = (*(uint64_t (**)(char *, void, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v98, v246, v8);
        v232(v98, v8);
        if ((v99 & 1) == 0)
        {
          uint64_t v100 = (void (*)(char *, char *, void *))*((void *)v29 + 2);
          goto LABEL_35;
        }
        goto LABEL_42;
      }
    }
    else if (v93 > 63)
    {
      uint64_t v103 = (uint64_t (*)(char *, void, void *))*((void *)v29 + 2);
      uint64_t v104 = v217;
      uint64_t v105 = v103(v217, v246, v8);
      if (v91 < 0)
      {
        v232(v104, v8);
        goto LABEL_42;
      }
      int64_t v248 = v91;
      char v108 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
      unint64_t v109 = lazy protocol witness table accessor for type Int and conformance Int(v105, v106, v107);
      uint64_t v110 = v237;
      v215[0] = v103;
      char v111 = v104;
      v108(&v248, &type metadata for Int, v109, v8, a6);
      uint64_t v90 = v231;
      char v112 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v110, v104, v8);
      uint64_t v113 = v110;
      uint64_t v114 = v232;
      v232(v113, v8);
      uint64_t v115 = v111;
      uint64_t v100 = (void (*)(char *, char *, void *))v215[0];
      v114(v115, v8);
      if (v112)
      {
LABEL_42:
        uint64_t v57 = v241;
        uint64_t v26 = v244(a3, v241);
        goto LABEL_73;
      }
LABEL_35:
      uint64_t v116 = v224;
      uint64_t v117 = v225;
      v100(v225, (char *)v246, v8);
      char v118 = v228(v8, a6);
      uint64_t v119 = v223;
      v100(v223, v117, v8);
      char v120 = v227;
      if ((v118 & 1) == 0)
      {
        v232(v119, v8);
        goto LABEL_59;
      }
      uint64_t v121 = v227(v8, a6);
      uint64_t v122 = v119;
      uint64_t v123 = (void (*)(char *, uint64_t, uint64_t))(v238 + 8);
      v232(v122, v8);
      if (v121 <= 64) {
        goto LABEL_59;
      }
      uint64_t v246 = v123;
      v100(v221, v117, v8);
      int64_t v248 = 0x8000000000000000;
      char v124 = v228;
      if (v228(v8, a6))
      {
        char v120 = v227;
        uint64_t v125 = v227(v8, a6);
        if (v125 < 64)
        {
          uint64_t v128 = v237;
          v100(v237, v221, v8);
          uint64_t v224 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          unint64_t v129 = v232;
          v232(v128, v8);
          BOOL v130 = v224 < v248;
LABEL_55:
          unint64_t v139 = v221;
          if (!v130) {
            goto LABEL_58;
          }
LABEL_91:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        }
        uint64_t v140 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v141 = lazy protocol witness table accessor for type Int and conformance Int(v125, v126, v127);
        uint64_t v142 = v237;
        v140(&v248, &type metadata for Int, v141, v8, a6);
        char v120 = v227;
        uint64_t v117 = v225;
        LODWORD(v224) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                            + 16))(v221, v142, v8);
        unint64_t v129 = v232;
        v232(v142, v8);
        unint64_t v139 = v221;
      }
      else
      {
        char v131 = v124(v8, a6);
        char v120 = v227;
        uint64_t v132 = v227(v8, a6);
        if ((v131 & 1) == 0)
        {
          if (v132 >= 64)
          {
            uint64_t v117 = v225;
            v232(v221, v8);
            goto LABEL_59;
          }
          unint64_t v143 = v237;
          uint64_t v144 = v221;
          v100(v237, v221, v8);
          uint64_t v224 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          unint64_t v129 = v232;
          v232(v143, v8);
          unint64_t v139 = v144;
          uint64_t v117 = v225;
          if (v224 < v248) {
            goto LABEL_91;
          }
LABEL_58:
          v129(v139, v8);
LABEL_59:
          uint64_t v156 = v120(v8, a6);
          v100((char *)v116, v117, v8);
          if (v156 < 65)
          {
            uint64_t v158 = v120(v8, a6);
            v232((char *)v116, v8);
            if (v158 != 64) {
              goto LABEL_72;
            }
            uint64_t v157 = v228;
            if (v228(v8, a6)) {
              goto LABEL_72;
            }
          }
          else
          {
            v232((char *)v116, v8);
            uint64_t v157 = v228;
          }
          char v159 = v222;
          v100(v222, v117, v8);
          int64_t v248 = 0x7FFFFFFFFFFFFFFFLL;
          char v160 = v157(v8, a6);
          uint64_t v161 = v227(v8, a6);
          if (v160)
          {
            if (v161 > 64)
            {
              char v164 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
              unint64_t v165 = lazy protocol witness table accessor for type Int and conformance Int(v161, v162, v163);
              uint64_t v166 = &v248;
LABEL_69:
              int v170 = v237;
              v164(v166, &type metadata for Int, v165, v8, a6);
              char v171 = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v170, v159, v8);
              uint64_t v172 = v170;
              uint64_t v169 = v232;
              v232(v172, v8);
              if (v171) {
                goto LABEL_89;
              }
              uint64_t v168 = v222;
              goto LABEL_71;
            }
          }
          else if (v161 > 63)
          {
            uint64_t v247 = 0x7FFFFFFFFFFFFFFFLL;
            char v164 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
            unint64_t v165 = lazy protocol witness table accessor for type Int and conformance Int(v161, v162, v163);
            uint64_t v166 = &v247;
            goto LABEL_69;
          }
          uint64_t v167 = v237;
          v100(v237, v159, v8);
          (*(void (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v168 = v159;
          uint64_t v169 = v232;
          v232(v167, v8);
LABEL_71:
          uint64_t v117 = v225;
          v169(v168, v8);
LABEL_72:
          uint64_t v173 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          uint64_t v174 = v117;
          uint64_t v26 = v173;
          v232(v174, v8);
          uint64_t v90 = v231;
          uint64_t v57 = v241;
          goto LABEL_73;
        }
        if (v132 <= 64)
        {
          uint64_t v145 = v220;
          uint64_t v146 = AssociatedTypeWitness;
          uint64_t v147 = swift_getAssociatedConformanceWitness((uint64_t)v220, (uint64_t)v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v148 = v218;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v147 + 8))(&qword_18162B0B8, 256, v146, v147);
          char v149 = v145;
          uint64_t v150 = v145[3];
          uint64_t v151 = v237;
          ((void (*)(char *, void *, int **))v150)(v148, v8, v149);
          uint64_t v152 = v221;
          LODWORD(v224) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                              + 16))(v221, v151, v8);
          v232(v151, v8);
          uint64_t v153 = v216;
          v100(v216, v152, v8);
          if (v224)
          {
            v232(v153, v8);
            goto LABEL_91;
          }
          uint64_t v224 = v248;
          uint64_t v154 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
          unint64_t v155 = v153;
          unint64_t v129 = v232;
          v232(v155, v8);
          BOOL v130 = v154 < v224;
          uint64_t v117 = v225;
          goto LABEL_55;
        }
        uint64_t v135 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
        unint64_t v136 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        uint64_t v137 = v237;
        v135(&v248, &type metadata for Int, v136, v8, a6);
        char v120 = v227;
        uint64_t v138 = v221;
        LODWORD(v224) = (*(uint64_t (**)(char *, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                            + 16))(v221, v137, v8);
        unint64_t v129 = v232;
        v232(v137, v8);
        unint64_t v139 = v138;
        uint64_t v117 = v225;
      }
      if (v224) {
        goto LABEL_91;
      }
      goto LABEL_58;
    }
    uint64_t v100 = (void (*)(char *, char *, void *))*((void *)v29 + 2);
    uint64_t v101 = v237;
    v100(v237, (char *)v246, v8);
    uint64_t v102 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
    v232(v101, v8);
    if (v91 < v102) {
      goto LABEL_42;
    }
    goto LABEL_35;
  }
  uint64_t v51 = v246;
  uint64_t v227 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
  uint64_t v52 = v227(v8, a6);
  if (v52 >= 64)
  {
    int64_t v248 = v48;
    char v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, void *, uint64_t))(a6 + 96);
    unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    char v68 = v237;
    v66(&v248, &type metadata for Int, v67, v8, a6);
    char v69 = (*(uint64_t (**)(void, char *, void *))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v246, v68, v8);
    uint64_t v29 = v238;
    uint64_t v232 = (void (*)(char *, void *))*((void *)v238 + 1);
    v232(v68, v8);
    uint64_t v57 = v241;
    if (v69) {
      goto LABEL_22;
    }
    goto LABEL_26;
  }
  uint64_t v55 = v237;
  uint64_t v29 = v238;
  (*((void (**)(char *, void, void *))v238 + 2))(v237, v51, v8);
  uint64_t v56 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(v8, a6);
  uint64_t v232 = (void (*)(char *, void *))*((void *)v29 + 1);
  v232(v55, v8);
  uint64_t v57 = v241;
  if (v56 >= v48) {
    goto LABEL_26;
  }
LABEL_22:
  uint64_t v89 = v244(a3, v57);
  uint64_t v26 = -v89;
  uint64_t v90 = v231;
  if (__OFSUB__(0, v89))
  {
    __break(1u);
LABEL_25:
    uint64_t v232 = (void (*)(char *, void *))*((void *)v29 + 1);
    v232((char *)v26, v8);
    goto LABEL_26;
  }
LABEL_73:
  char v175 = *(void (**)(char *, uint64_t, uint64_t))(v90 + 32);
  v175(v243, v240, a3);
  char v176 = (*(uint64_t (**)(uint64_t))(v242 + 64))(a3);
  uint64_t v177 = v235;
  uint64_t v45 = v236;
  uint64_t v178 = v234;
  uint64_t v246 = v175;
  if (v176)
  {
    uint64_t v179 = v244(a3, v57);
    if (!__OFSUB__(v179, 1))
    {
      int64_t v248 = v179 - 1;
      uint64_t v182 = v57;
      uint64_t v183 = v242;
      uint64_t v184 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v242 + 96);
      unint64_t v185 = lazy protocol witness table accessor for type Int and conformance Int(v179, v180, v181);
      uint64_t v186 = v233;
      uint64_t v187 = v183;
      uint64_t v188 = v182;
      uint64_t v45 = v236;
      v184(&v248, &type metadata for Int, v185, a3, v187);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v188 + 200))(v243, v186, a3, v188);
      uint64_t v189 = v186;
      uint64_t v178 = v234;
      uint64_t v177 = v235;
      (*(void (**)(char *, uint64_t))(v90 + 8))(v189, a3);
      uint64_t v190 = swift_getAssociatedConformanceWitness((uint64_t)v177, a3, (uint64_t)v178, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v191 = v229;
      goto LABEL_77;
    }
    __break(1u);
LABEL_89:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  uint64_t v190 = swift_getAssociatedConformanceWitness((uint64_t)v235, a3, (uint64_t)v234, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v191 = v229;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v190 + 8))(&qword_18162B0B8, 256, v178, v190);
  ((void (*)(char *, uint64_t, int **))v177[3])(v191, a3, v177);
LABEL_77:
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v190 + 8))(&qword_18162B0B8, 256, v178, v190);
  ((void (*)(char *, uint64_t, int **))v177[3])(v191, a3, v177);
  uint64_t v8 = *(void **)(v90 + 8);
  if (v26 < 0)
  {
LABEL_83:
    ((void (*)(char *, uint64_t))v8)(v45, a3);
    uint64_t v205 = v241;
    uint64_t v206 = v244(a3, v241);
    if (__OFSUB__(0, v206))
    {
      __break(1u);
    }
    else if (-v206 < v26)
    {
      uint64_t v207 = ((uint64_t (*)(char *, uint64_t))v8)(v239, a3);
      int64_t v248 = -v26;
      uint64_t v208 = v242;
      uint64_t v209 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v242 + 96);
      unint64_t v212 = lazy protocol witness table accessor for type Int and conformance Int(v207, v210, v211);
      unint64_t v200 = v233;
      v209(&v248, &type metadata for Int, v212, a3, v208);
      uint64_t v201 = v230;
      uint64_t v202 = v243;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v205 + 200))(v243, v200, a3, v205);
      goto LABEL_80;
    }
    ((void (*)(char *, uint64_t))v8)(v243, a3);
    uint64_t v201 = v230;
    uint64_t v213 = v230;
    uint64_t v214 = v239;
LABEL_87:
    uint64_t v203 = (uint64_t (*)(uint64_t, char *, uint64_t))v246;
    v246(v213, (uint64_t)v214, a3);
    return v203(v240, v201, a3);
  }
  ((void (*)(char *, uint64_t))v8)(v239, a3);
  uint64_t v192 = v241;
  if (v26 >= v244(a3, v241))
  {
    ((void (*)(char *, uint64_t))v8)(v243, a3);
    uint64_t v201 = v230;
    uint64_t v213 = v230;
    uint64_t v214 = v45;
    goto LABEL_87;
  }
  uint64_t v193 = ((uint64_t (*)(char *, uint64_t))v8)(v45, a3);
  int64_t v248 = v26;
  uint64_t v194 = v192;
  uint64_t v195 = v242;
  unint64_t v196 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v242 + 96);
  unint64_t v199 = lazy protocol witness table accessor for type Int and conformance Int(v193, v197, v198);
  unint64_t v200 = v233;
  v196(&v248, &type metadata for Int, v199, a3, v195);
  uint64_t v201 = v230;
  uint64_t v202 = v243;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v194 + 216))(v243, v200, a3, v194);
LABEL_80:
  ((void (*)(char *, uint64_t))v8)(v200, a3);
  ((void (*)(char *, uint64_t))v8)(v202, a3);
  uint64_t v203 = (uint64_t (*)(uint64_t, char *, uint64_t))v246;
  return v203(v240, v201, a3);
}

uint64_t static FixedWidthInteger._nonMaskingLeftShift(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v53 = a2;
  uint64_t v56 = a1;
  uint64_t v8 = *(void *)(a4 + 8);
  uint64_t v9 = *(void *)(*(void *)(v8 + 24) + 16);
  uint64_t v10 = &protocol requirements base descriptor for ExpressibleByIntegerLiteral;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v49 - v13;
  uint64_t v54 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v57 = (char *)&v49 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v55 = (char *)&v49 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v20 = (char *)&v49 - v19;
  char v21 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 64))(a3, v8);
  uint64_t v51 = v20;
  uint64_t v52 = a5;
  if (v21)
  {
    uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    if (__OFSUB__(v22, 1))
    {
      __break(1u);
      goto LABEL_16;
    }
    uint64_t v58 = v22 - 1;
    uint64_t v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v8 + 96);
    unint64_t v26 = lazy protocol witness table accessor for type Int and conformance Int(v22, v23, v24);
    char v50 = v14;
    uint64_t v27 = v8;
    uint64_t v28 = v55;
    v25(&v58, &type metadata for Int, v26, a3, v27);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v56, v28, a3, a4);
    uint64_t v29 = v54;
    uint64_t v30 = v28;
    uint64_t v8 = v27;
    uint64_t v14 = v50;
    (*(void (**)(char *, uint64_t))(v54 + 8))(v30, a3);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  }
  else
  {
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v14, a3, v9);
    uint64_t v29 = v54;
  }
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v14, a3, v9);
  uint64_t v32 = *(void (**)(char *, uint64_t))(v29 + 8);
  uint64_t v33 = v53;
  if (v53 < 0)
  {
    v32(v57, a3);
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    uint64_t v10 = v52;
    if (!__OFSUB__(0, v42))
    {
      if (-v42 < v33)
      {
        uint64_t v43 = ((uint64_t (*)(char *, uint64_t))v32)(v51, a3);
        uint64_t v58 = -v33;
        uint64_t v44 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v8 + 96);
        unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v43, v45, v46);
        uint64_t v48 = v8;
        uint64_t v40 = v55;
        v44(&v58, &type metadata for Int, v47, a3, v48);
        (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v56, v40, a3, a4);
        return ((uint64_t (*)(char *, uint64_t))v32)(v40, a3);
      }
      return (*(uint64_t (**)(void *, char *, uint64_t))(v54 + 32))(v10, v51, a3);
    }
LABEL_16:
    __break(1u);
    return (*(uint64_t (**)(void *, char *, uint64_t))(v54 + 32))(v10, v51, a3);
  }
  v32(v51, a3);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4) > v33)
  {
    uint64_t v34 = ((uint64_t (*)(char *, uint64_t))v32)(v57, a3);
    uint64_t v58 = v33;
    uint64_t v35 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v8 + 96);
    unint64_t v38 = lazy protocol witness table accessor for type Int and conformance Int(v34, v36, v37);
    uint64_t v39 = v8;
    uint64_t v40 = v55;
    v35(&v58, &type metadata for Int, v38, a3, v39);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 216))(v56, v40, a3, a4);
    return ((uint64_t (*)(char *, uint64_t))v32)(v40, a3);
  }
  return (*(uint64_t (**)(void *, char *, uint64_t))(v54 + 32))(v52, v57, a3);
}

BOOL specialized static FixedWidthInteger._convert<A>(from:)(uint64_t a1, double a2)
{
  uint64_t v4 = (*(void *)&a2 >> 52) & 0x7FFLL;
  unint64_t v5 = *(void *)&a2 & 0xFFFFFFFFFFFFFLL;
  if (!(v4 | *(void *)&a2 & 0xFFFFFFFFFFFFFLL))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    BOOL result = 1;
    goto LABEL_50;
  }
  if (v4 == 2047 || (int64_t v6 = Double.exponent.getter(a2), v6 >= 128))
  {
    BOOL result = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 1;
    return result;
  }
  uint64_t v7 = v6;
  uint64_t v8 = Double.significandWidth.getter(a2);
  BOOL result = v7 >= v8;
  uint64_t v10 = v8 + __clz(__rbit64(v5));
  unint64_t v11 = v7 - v10;
  if (__OFSUB__(v7, v10))
  {
    __break(1u);
    goto LABEL_35;
  }
  if (v10 > 127)
  {
    unint64_t v12 = v5 >> (v10 - v7);
    if (v11 <= 0xFFFFFFFFFFFFFFC0) {
      unint64_t v12 = 0;
    }
    unint64_t v13 = v5 << v11;
    if (v11 >= 0x40) {
      unint64_t v13 = 0;
    }
    if ((v11 & 0x8000000000000000) == 0) {
      unint64_t v12 = v13;
    }
    uint64_t v10 = 0;
    if (v11 - 65 >= 0xFFFFFFFFFFFFFF7FLL) {
      unint64_t v5 = v12;
    }
    else {
      unint64_t v5 = 0;
    }
  }
  else
  {
    if (v11 - 129 < 0xFFFFFFFFFFFFFEFFLL)
    {
LABEL_7:
      uint64_t v10 = 0;
      unint64_t v5 = 0;
      goto LABEL_17;
    }
    if ((v11 & 0x8000000000000000) != 0)
    {
      unint64_t v23 = v5 >> (v10 - v7);
      if ((unint64_t)(v10 - v7) >= 0x40) {
        unint64_t v23 = 0;
      }
      uint64_t v10 = 0;
      if (v11 <= 0xFFFFFFFFFFFFFF80) {
        unint64_t v5 = 0;
      }
      else {
        unint64_t v5 = v23;
      }
    }
    else
    {
      if (v11 >= 0x80) {
        goto LABEL_7;
      }
      if (v11 > 0x3F)
      {
        uint64_t v10 = v5 << v11;
        unint64_t v5 = 0;
      }
      else if (v11)
      {
        uint64_t v10 = v5 >> (v10 - v7);
        v5 <<= v11;
      }
      else
      {
        uint64_t v10 = 0;
      }
    }
  }
LABEL_17:
  if (v7 != 127)
  {
    if (v7 <= -128) {
      unint64_t v14 = -128;
    }
    else {
      unint64_t v14 = v7;
    }
    if ((v14 & 0x8000000000000000) != 0)
    {
      if (v7 < -127)
      {
        unint64_t v15 = 0;
        unint64_t v16 = 0;
LABEL_43:
        unint64_t v20 = v16 | v5;
        unint64_t v21 = v15 | v10;
        if (a2 >= 0.0)
        {
          if ((v21 & 0x8000000000000000) == 0)
          {
LABEL_49:
            *(void *)a1 = v20;
            *(void *)(a1 + 8) = v21;
LABEL_50:
            *(unsigned char *)(a1 + 16) = 0;
            return result;
          }
        }
        else if ((v21 & 0x8000000000000000) == 0)
        {
          BOOL v22 = v20 == 0;
          unint64_t v20 = -(uint64_t)v20;
          if (v22) {
            unint64_t v21 = -(uint64_t)v21;
          }
          else {
            unint64_t v21 = ~v21;
          }
          goto LABEL_49;
        }
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000028, 0x80000001816DFAC0 | 0x8000000000000000, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
      }
      unint64_t v15 = 0;
      unint64_t v16 = 0;
      uint64_t v19 = -(uint64_t)v14;
      if ((v19 & 0x7Fu) > 0x3FuLL) {
        goto LABEL_43;
      }
      if ((v19 & 0x7F) != 0)
      {
        unint64_t v15 = 0;
        unint64_t v16 = 1uLL >> v19;
        goto LABEL_43;
      }
    }
    else
    {
      if (v14 > 0x3F)
      {
        unint64_t v16 = 0;
        unint64_t v15 = 1 << v14;
        goto LABEL_43;
      }
      if (v14)
      {
        unint64_t v15 = 1uLL >> -(char)v14;
        unint64_t v16 = 1 << v14;
        goto LABEL_43;
      }
    }
    unint64_t v15 = 0;
    unint64_t v16 = 1;
    goto LABEL_43;
  }
LABEL_35:
  if (a2 >= 0.0 || (unint64_t v17 = v10 | v5) != 0)
  {
    BOOL result = 0;
    unint64_t v18 = 0;
    LOBYTE(v17) = 1;
  }
  else
  {
    unint64_t v18 = 0x8000000000000000;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 16) = v17;
  return result;
}

uint64_t static FixedWidthInteger._convert<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v335 = a1;
  uint64_t v336 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  v307 = (char *)&v295 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v306 = (char *)&v295 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v305 = (char *)&v295 - v14;
  uint64_t v350 = v15;
  uint64_t v358 = *(void *)(v15 + 8);
  uint64_t v16 = *(void *)(v358 + 24);
  v310 = *(int ***)(v16 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v310, v17, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  v309 = (char *)&v295 - v18;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, (int **)v16, a3, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  uint64_t v297 = v16;
  uint64_t v323 = *(int ***)(swift_getAssociatedConformanceWitness(v16, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  uint64_t v321 = swift_getAssociatedTypeWitness(0, v323, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v321);
  uint64_t v322 = (char *)&v295 - v20;
  uint64_t v353 = a3;
  unint64_t v23 = type metadata accessor for Optional(255, a3, v21, v22);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v23, (uint64_t)&type metadata for Bool, 0, 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  uint64_t v298 = (char *)&v295 - v25;
  v354 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v338 = *(v354 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v354);
  v319 = (char *)&v295 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  char v320 = (char *)&v295 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  unint64_t v296 = (char *)&v295 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v299 = (char *)&v295 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  char v337 = (char *)&v295 - v35;
  MEMORY[0x1F4188790](v34);
  unint64_t v345 = (char *)&v295 - v36;
  v324 = swift_getAssociatedTypeWitness(0, (int **)a6, a4, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v325 = *((void *)v324 - 1);
  uint64_t v37 = MEMORY[0x1F4188790](v324);
  v326 = (char *)&v295 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  v344 = (char *)&v295 - v39;
  unint64_t v346 = a6;
  uint64_t v40 = *(void *)(a6 + 16);
  uint64_t v41 = swift_getAssociatedTypeWitness(255, (int **)v40, a4, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated type descriptor for FloatingPoint.Exponent);
  uint64_t v42 = *(void *)(swift_getAssociatedConformanceWitness(v40, a4, (uint64_t)v41, (uint64_t)&protocol requirements base descriptor for FloatingPoint, associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)+ 8);
  uint64_t v328 = *(void *)(v42 + 24);
  v349 = *(int ***)(v328 + 16);
  uint64_t v312 = swift_getAssociatedTypeWitness(0, v349, (uint64_t)v41, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v312);
  char v311 = (char *)&v295 - v43;
  uint64_t v44 = swift_checkMetadataState(0, (uint64_t)v41);
  uint64_t v45 = *(v44 - 1);
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  v303 = (char *)&v295 - ((v47 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  unint64_t v327 = (char *)&v295 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  v301 = (char *)&v295 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  uint64_t v302 = (char *)&v295 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  v329 = (char *)&v295 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  uint64_t v314 = (uint64_t)&v295 - v57;
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  uint64_t v356 = (char *)&v295 - v59;
  uint64_t v60 = MEMORY[0x1F4188790](v58);
  v352 = (_DWORD *)((char *)&v295 - v61);
  MEMORY[0x1F4188790](v60);
  uint64_t v357 = (char *)&v295 - v62;
  unint64_t v334 = *(int ***)(*(void *)(*(void *)(v40 + 16) + 8) + 16);
  char v332 = swift_getAssociatedTypeWitness(0, v334, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v63 = MEMORY[0x1F4188790](v332);
  char v65 = (char *)&v295 - v64;
  uint64_t v348 = *(void *)(a4 - 8);
  uint64_t v66 = MEMORY[0x1F4188790](v63);
  char v318 = (char *)&v295 - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v68 = MEMORY[0x1F4188790](v66);
  v333 = (char *)&v295 - v69;
  MEMORY[0x1F4188790](v68);
  uint64_t v71 = (char *)&v295 - v70;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v40 + 384))(a4, v40))
  {
    v258 = v310;
    uint64_t v259 = v353;
    v260 = AssociatedTypeWitness;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v310, v353, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v262 = v309;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v260, AssociatedConformanceWitness);
    uint64_t v263 = v335;
    ((void (*)(char *, uint64_t, int **))v258[3])(v262, v259, v258);
    char v107 = 1;
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v336 + 56))(v263, 0, 1, v259);
    return v107 & 1;
  }
  uint64_t v72 = *(uint64_t (**)(uint64_t, uint64_t))(v40 + 376);
  uint64_t v341 = v40;
  if (v72(a4, v40))
  {
    uint64_t v351 = v45;
    uint64_t v342 = *(uint64_t (**)(void))(v358 + 64);
    uint64_t v343 = v358 + 64;
    char v73 = v342();
    uint64_t v74 = v348;
    uint64_t v76 = v348 + 16;
    uint64_t v75 = *(void (**)(char *, uint64_t, uint64_t))(v348 + 16);
    uint64_t v355 = a2;
    unint64_t v315 = v75;
    v75(v71, a2, a4);
    uint64_t v295 = v23;
    uint64_t v313 = v65;
    uint64_t v316 = v76;
    if (v73)
    {
      uint64_t v317 = *(void (**)(char *, uint64_t))(v74 + 8);
      v317(v71, a4);
      uint64_t v77 = v341;
      goto LABEL_6;
    }
    uint64_t v78 = v334;
    uint64_t v79 = v332;
    uint64_t v80 = swift_getAssociatedConformanceWitness((uint64_t)v334, a4, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, const char *, uint64_t))(v80 + 8))(&unk_18162B0C8, 257, v79, v80);
    uint64_t v81 = v65;
    uint64_t v82 = v333;
    ((void (*)(char *, uint64_t, int **))v78[3])(v81, a4, v78);
    uint64_t v83 = v74;
    uint64_t v77 = v341;
    LOBYTE(v79) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v341 + 24) + 8) + 40))(v71, v82, a4);
    unint64_t v84 = *(void (**)(char *, uint64_t))(v83 + 8);
    v84(v82, a4);
    uint64_t v317 = v84;
    v84(v71, a4);
    if (v79)
    {
LABEL_6:
      uint64_t v85 = v357;
      (*(void (**)(uint64_t, uint64_t))(v77 + 176))(a4, v77);
      uint64_t v86 = v350 + 56;
      uint64_t v87 = *(uint64_t (**)(void))(v350 + 56);
      uint64_t v88 = v87();
      uint64_t v89 = *(uint64_t (**)(uint64_t *, uint64_t))(v42 + 64);
      char v90 = v89(v44, v42);
      uint64_t v331 = v42 + 64;
      BOOL v340 = v89;
      uint64_t v304 = v87;
      if (v90)
      {
        unint64_t v330 = *(uint64_t (**)(uint64_t *, uint64_t))(v42 + 128);
        uint64_t v91 = v330(v44, v42);
        if (v91 < 64)
        {
          uint64_t v95 = v351;
          uint64_t v94 = v352;
          (*(void (**)(_DWORD *, char *, uint64_t *))(v351 + 16))(v352, v85, v44);
          uint64_t v96 = (*(uint64_t (**)(uint64_t *, uint64_t))(v42 + 120))(v44, v42);
          unint64_t v97 = v94;
          uint64_t v98 = *(char **)(v95 + 8);
          ((void (*)(_DWORD *, uint64_t *))v98)(v97, v44);
          goto LABEL_19;
        }
        uint64_t v359 = v88;
        uint64_t v105 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v42 + 96);
        unint64_t v106 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        uint64_t v104 = v352;
LABEL_14:
        v105(&v359, &type metadata for Int, v106, v44, v42);
        char v108 = (*(uint64_t (**)(char *, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(v85, v104, v44);
        uint64_t v95 = v351;
        unint64_t v109 = v104;
        uint64_t v98 = *(char **)(v351 + 8);
        ((void (*)(_DWORD *, uint64_t *))v98)(v109, v44);
        if (v108) {
          goto LABEL_20;
        }
        goto LABEL_72;
      }
      char v99 = v89(v44, v42);
      unint64_t v330 = *(uint64_t (**)(uint64_t *, uint64_t))(v42 + 128);
      uint64_t v100 = v330(v44, v42);
      uint64_t v103 = v352;
      if (v99)
      {
        if (v100 > 64)
        {
          uint64_t v359 = v88;
          uint64_t v104 = v352;
          uint64_t v105 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v42 + 96);
          unint64_t v106 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
          goto LABEL_14;
        }
        uint64_t v132 = v349;
        uint64_t v133 = v312;
        uint64_t v134 = swift_getAssociatedConformanceWitness((uint64_t)v349, (uint64_t)v44, (uint64_t)v312, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v135 = v311;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v134 + 8))(&qword_18162B0B8, 256, v133, v134);
        ((void (*)(char *, uint64_t *, int **))v132[3])(v135, v44, v132);
        LODWORD(v314) = (*(uint64_t (**)(char *, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8)
                                                                               + 16))(v85, v103, v44);
        uint64_t v95 = v351;
        uint64_t v98 = *(char **)(v351 + 8);
        ((void (*)(_DWORD *, uint64_t *))v98)(v103, v44);
        unint64_t v136 = v356;
        (*(void (**)(char *, char *, uint64_t *))(v95 + 16))(v356, v85, v44);
        if (v314)
        {
          ((void (*)(char *, uint64_t *))v98)(v136, v44);
        }
        else
        {
          uint64_t v314 = (*(uint64_t (**)(uint64_t *, uint64_t))(v42 + 120))(v44, v42);
          ((void (*)(char *, uint64_t *))v98)(v136, v44);
          if (v314 >= v88) {
            goto LABEL_72;
          }
        }
      }
      else
      {
        if (v100 < 64)
        {
          uint64_t v95 = v351;
          (*(void (**)(_DWORD *, char *, uint64_t *))(v351 + 16))(v352, v85, v44);
          uint64_t v96 = (*(uint64_t (**)(uint64_t *, uint64_t))(v42 + 120))(v44, v42);
          uint64_t v98 = *(char **)(v95 + 8);
          ((void (*)(_DWORD *, uint64_t *))v98)(v103, v44);
LABEL_19:
          if (v96 < v88) {
            goto LABEL_20;
          }
LABEL_72:
          uint64_t v256 = v336;
          uint64_t v257 = v335;
          ((void (*)(char *, uint64_t *))v98)(v357, v44);
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v256 + 56))(v257, 1, 1, v353);
          char v107 = 0;
          return v107 & 1;
        }
        uint64_t v95 = v351;
        uint64_t v137 = v314;
        uint64_t v138 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(v351 + 16))(v314, v85, v44);
        if (v88 <= 0)
        {
          uint64_t v98 = *(char **)(v95 + 8);
          ((void (*)(uint64_t, uint64_t *))v98)(v137, v44);
          goto LABEL_72;
        }
        uint64_t v359 = v88;
        uint64_t v356 = *(char **)(v42 + 96);
        unint64_t v141 = lazy protocol witness table accessor for type Int and conformance Int(v138, v139, v140);
        uint64_t v142 = v137;
        ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))v356)(&v359, &type metadata for Int, v141, v44, v42);
        char v143 = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(v137, v103, v44);
        uint64_t v98 = *(char **)(v95 + 8);
        ((void (*)(_DWORD *, uint64_t *))v98)(v103, v44);
        ((void (*)(uint64_t, uint64_t *))v98)(v142, v44);
        if ((v143 & 1) == 0) {
          goto LABEL_72;
        }
      }
LABEL_20:
      uint64_t v314 = (*(uint64_t (**)(uint64_t))(v346 + 136))(a4);
      uint64_t v110 = v340;
      char v111 = v340(v44, v42);
      uint64_t v356 = v98;
      uint64_t v339 = a4;
      uint64_t v300 = v86;
      uint64_t v347 = v42;
      if (v111)
      {
        uint64_t v112 = v330(v44, v42);
        if (v112 >= 64)
        {
          uint64_t v117 = v314;
          uint64_t v359 = v314;
          uint64_t v126 = v95;
          uint64_t v127 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v42 + 96);
          unint64_t v128 = lazy protocol witness table accessor for type Int and conformance Int(v112, v113, v114);
          uint64_t v115 = v352;
          v127(&v359, &type metadata for Int, v128, v44, v42);
          int v125 = (*(uint64_t (**)(char *, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(v85, v115, v44);
          v349 = (int **)((v126 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
          ((void (*)(_DWORD *, uint64_t *))v356)(v115, v44);
LABEL_31:
          uint64_t v131 = (uint64_t)v324;
          goto LABEL_46;
        }
        uint64_t v115 = v352;
        (*(void (**)(_DWORD *, char *, uint64_t *))(v95 + 16))(v352, v85, v44);
        uint64_t v116 = (*(uint64_t (**)(uint64_t *, uint64_t))(v42 + 120))(v44, v42);
        v349 = (int **)((v95 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
        ((void (*)(_DWORD *, uint64_t *))v356)(v115, v44);
        uint64_t v117 = v314;
LABEL_30:
        int v125 = v116 < v117;
        goto LABEL_31;
      }
      char v118 = v110(v44, v42);
      uint64_t v119 = v330(v44, v42);
      if (v118)
      {
        if (v119 <= 64)
        {
          uint64_t v144 = v349;
          uint64_t v145 = v312;
          uint64_t v146 = swift_getAssociatedConformanceWitness((uint64_t)v349, (uint64_t)v44, (uint64_t)v312, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v147 = v311;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v146 + 8))(&qword_18162B0B8, 256, v145, v146);
          char v148 = v352;
          ((void (*)(char *, uint64_t *, int **))v144[3])(v147, v44, v144);
          LOBYTE(v145) = (*(uint64_t (**)(char *, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8)
                                                                                + 16))(v85, v148, v44);
          uint64_t v149 = v351;
          v349 = (int **)((v351 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
          ((void (*)(_DWORD *, uint64_t *))v356)(v148, v44);
          uint64_t v150 = v302;
          (*(void (**)(char *, char *, uint64_t *))(v149 + 16))(v302, v85, v44);
          if (v145)
          {
            int v125 = 1;
            uint64_t v117 = v314;
          }
          else
          {
            uint64_t v159 = (*(uint64_t (**)(uint64_t *, uint64_t))(v42 + 120))(v44, v42);
            uint64_t v117 = v314;
            int v125 = v159 < v314;
          }
          ((void (*)(char *, uint64_t *))v356)(v150, v44);
          uint64_t v131 = (uint64_t)v324;
          uint64_t v115 = v352;
LABEL_46:
          LODWORD(v324) = v125 ^ 1;
          uint64_t v160 = v346;
          uint64_t v161 = v339;
          (*(void (**)(uint64_t, unint64_t))(v346 + 120))(v339, v346);
          uint64_t v162 = *(void *)(swift_getAssociatedConformanceWitness(v160, v161, v131, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)+ 8);
          uint64_t v163 = (*(uint64_t (**)(uint64_t, uint64_t))(v162 + 144))(v131, v162);
          uint64_t v164 = v163 + v117;
          uint64_t v359 = v164;
          unint64_t v165 = *(void (**)(uint64_t *, ValueMetadata *))(v347 + 88);
          unint64_t v346 = lazy protocol witness table accessor for type Int and conformance Int(v163, v166, v167);
          v165(&v359, &type metadata for Int);
          uint64_t v168 = v329;
          (*(void (**)(char *, _DWORD *, uint64_t *))(*(void *)(v328 + 8) + 40))(v357, v115, v44);
          uint64_t v169 = v115;
          int v170 = v356;
          ((void (*)(_DWORD *, uint64_t *))v356)(v169, v44);
          char v171 = v44;
          uint64_t v173 = v353;
          uint64_t v172 = v354;
          uint64_t v174 = swift_getAssociatedConformanceWitness(v350, v353, (uint64_t)v354, (uint64_t)&protocol requirements base descriptor for FixedWidthInteger, associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
          if (v164 >= (*(uint64_t (**)(uint64_t *, uint64_t))(v174 + 56))(v172, v174))
          {
            unint64_t v185 = v326;
            uint64_t v186 = v344;
            (*(void (**)(char *, char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v162 + 256))(v344, v168, v171, v347, v131, v162);
            ((void (*)(char *, uint64_t *))v170)(v168, v171);
            (*(void (**)(char *, uint64_t))(v325 + 8))(v186, v131);
            uint64_t v176 = v358;
            uint64_t v187 = v354;
            uint64_t v188 = swift_getAssociatedConformanceWitness(v358, v173, (uint64_t)v354, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
            (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v188 + 96))(v185, v131, v162, v187, v188);
            uint64_t v183 = v327;
            uint64_t v184 = v347;
            uint64_t v182 = v352;
          }
          else
          {
            char v175 = v326;
            (*(void (**)(char *, char *, uint64_t))(v325 + 32))(v326, v344, v131);
            uint64_t v176 = v358;
            uint64_t v177 = v354;
            uint64_t v178 = swift_getAssociatedConformanceWitness(v358, v173, (uint64_t)v354, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
            uint64_t v179 = v337;
            (*(void (**)(char *, uint64_t, uint64_t, uint64_t *, uint64_t))(v178 + 96))(v175, v131, v162, v177, v178);
            uint64_t v180 = v347;
            (*(void (**)(char *, char *, uint64_t *, uint64_t, uint64_t *, uint64_t))(v178 + 256))(v179, v168, v171, v347, v177, v178);
            uint64_t v181 = v179;
            uint64_t v182 = v352;
            (*(void (**)(char *, uint64_t *))(v338 + 8))(v181, v177);
            ((void (*)(char *, uint64_t *))v356)(v168, v171);
            uint64_t v183 = v327;
            uint64_t v184 = v180;
          }
          char v189 = ((uint64_t (*)(uint64_t, uint64_t))v342)(v173, v176);
          (*(void (**)(char *, char *, uint64_t *))(v351 + 16))(v183, v357, v171);
          uint64_t v190 = v340;
          if (v189)
          {
            uint64_t v191 = ((uint64_t (*)(uint64_t, uint64_t))v304)(v173, v350) - 1;
            char v192 = v190(v171, v184);
            uint64_t v193 = v184;
            char v194 = v192;
            uint64_t v195 = v171;
            uint64_t v196 = v193;
            uint64_t v197 = ((uint64_t (*)(uint64_t *))v330)(v171);
            if (v194)
            {
              if (v197 > 64)
              {
                uint64_t v359 = v191;
                (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v196 + 96))(&v359, &type metadata for Int, v346, v171, v196);
                char v198 = (*(uint64_t (**)(_DWORD *, char *, uint64_t *))(*(void *)(*(void *)(v196 + 16) + 8)
                                                                              + 8))(v182, v183, v171);
                unint64_t v199 = v182;
                unint64_t v200 = v356;
                ((void (*)(_DWORD *, uint64_t *))v356)(v199, v171);
                uint64_t v201 = v183;
                uint64_t v202 = v171;
                goto LABEL_66;
              }
LABEL_56:
              (*(void (**)(_DWORD *, char *, uint64_t *))(v351 + 32))(v182, v183, v171);
              uint64_t v203 = (*(uint64_t (**)(uint64_t *, uint64_t))(v196 + 120))(v171, v196);
              uint64_t v204 = v182;
              unint64_t v200 = v356;
              ((void (*)(_DWORD *, uint64_t *))v356)(v204, v171);
              if (v191 == v203) {
                goto LABEL_67;
              }
              goto LABEL_57;
            }
            if (v197 <= 63) {
              goto LABEL_56;
            }
            uint64_t v242 = v303;
            (*(void (**)(char *, char *, uint64_t *))(v351 + 32))(v303, v183, v171);
            if ((v191 & 0x8000000000000000) == 0)
            {
              uint64_t v359 = v191;
              (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v196 + 96))(&v359, &type metadata for Int, v346, v171, v196);
              char v198 = (*(uint64_t (**)(_DWORD *, char *, uint64_t *))(*(void *)(*(void *)(v196 + 16) + 8)
                                                                            + 8))(v182, v242, v171);
              uint64_t v243 = v182;
              unint64_t v200 = v356;
              ((void (*)(_DWORD *, uint64_t *))v356)(v243, v171);
              uint64_t v201 = v242;
              uint64_t v202 = v171;
LABEL_66:
              ((void (*)(char *, uint64_t *))v200)(v201, v202);
              if (v198)
              {
LABEL_67:
                ((void (*)(char *, uint64_t *))v200)(v357, v171);
                uint64_t v244 = v334;
                uint64_t v245 = v339;
                uint64_t v246 = v332;
                uint64_t v247 = swift_getAssociatedConformanceWitness((uint64_t)v334, v339, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                int64_t v248 = v313;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v247 + 8))(&qword_18162B0B8, 256, v246, v247);
                uint64_t v249 = v333;
                ((void (*)(char *, uint64_t, int **))v244[3])(v248, v245, v244);
                LOBYTE(v246) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v341 + 24)
                                                                                               + 8)
                                                                                   + 16))(v355, v249, v245);
                v317(v249, v245);
                uint64_t v250 = *(void (**)(char *, char *, uint64_t *))(v338 + 32);
                uint64_t v251 = v299;
                v250(v299, v345, v354);
                if ((v246 & 1) == 0)
                {
                  (*(void (**)(char *, uint64_t *))(v338 + 8))(v251, v354);
                  char v107 = 0;
                  uint64_t v264 = 1;
LABEL_91:
                  uint64_t v293 = v336;
                  uint64_t v294 = v335;
                  uint64_t v292 = v298;
                  goto LABEL_92;
                }
                uint64_t v252 = v173;
                uint64_t v253 = v354;
                uint64_t v254 = swift_getAssociatedConformanceWitness(v358, v173, (uint64_t)v354, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
                uint64_t v255 = *(uint64_t (**)(uint64_t *, uint64_t))(v254 + 64);
                if (v255(v253, v254))
                {
                  if ((*(uint64_t (**)(uint64_t *, uint64_t))(v254 + 128))(v253, v254) < 64)
                  {
LABEL_82:
                    char v274 = v299;
                    v275 = v354;
                    uint64_t v276 = (*(uint64_t (**)(uint64_t *, uint64_t))(v254 + 120))(v354, v254);
                    (*(void (**)(char *, uint64_t *))(v338 + 8))(v274, v275);
                    if (!v276) {
                      goto LABEL_88;
                    }
                    goto LABEL_90;
                  }
                }
                else
                {
                  char v265 = v255(v253, v254);
                  uint64_t v266 = (*(uint64_t (**)(uint64_t *, uint64_t))(v254 + 128))(v253, v254);
                  if ((v265 & 1) == 0)
                  {
                    if (v266 < 64) {
                      goto LABEL_82;
                    }
                    uint64_t v359 = 0;
                    uint64_t v289 = v337;
                    uint64_t v268 = v354;
                    (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v254 + 96))(&v359, &type metadata for Int, v346, v354, v254);
                    uint64_t v290 = swift_getAssociatedConformanceWitness(v297, v252, (uint64_t)v268, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
                    v291 = v299;
                    char v271 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v290 + 8) + 8))(v299, v289, v268);
                    v272 = *(void (**)(char *, uint64_t *))(v338 + 8);
                    v272(v291, v268);
                    v273 = v289;
LABEL_87:
                    v272(v273, v268);
                    if (v271)
                    {
LABEL_88:
                      uint64_t v292 = v298;
                      uint64_t v173 = v252;
                      (*(void (**)(uint64_t))(v350 + 72))(v252);
                      uint64_t v264 = 0;
                      uint64_t v293 = v336;
                      uint64_t v294 = v335;
                      char v107 = (char)v324;
LABEL_92:
                      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v293 + 56))(v292, v264, 1, v173);
                      (*((void (**)(uint64_t, char *))*(v295 - 1) + 4))(v294, v292);
                      return v107 & 1;
                    }
                    goto LABEL_90;
                  }
                  if (v266 <= 64)
                  {
                    uint64_t v277 = v323;
                    uint64_t v278 = v354;
                    unint64_t v279 = v321;
                    uint64_t v280 = swift_getAssociatedConformanceWitness((uint64_t)v323, (uint64_t)v354, (uint64_t)v321, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    v281 = v322;
                    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v280 + 8))(&qword_18162B0B8, 256, v279, v280);
                    uint64_t v282 = v337;
                    ((void (*)(char *, uint64_t *, int **))v277[3])(v281, v278, v277);
                    uint64_t v283 = swift_getAssociatedConformanceWitness(v297, v252, (uint64_t)v278, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
                    v284 = v299;
                    LOBYTE(v279) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v283 + 32))(v299, v282, v278, v283);
                    uint64_t v285 = *(void (**)(char *, uint64_t *))(v338 + 8);
                    v285(v282, v278);
                    v250(v296, v284, v278);
                    if (v279)
                    {
                      uint64_t v286 = v296;
                      v287 = v354;
                      uint64_t v288 = (*(uint64_t (**)(uint64_t *, uint64_t))(v254 + 120))(v354, v254);
                      v285(v286, v287);
                      if (!v288) {
                        goto LABEL_88;
                      }
                    }
                    else
                    {
                      v285(v296, v354);
                    }
LABEL_90:
                    char v107 = 0;
                    uint64_t v264 = 1;
                    uint64_t v173 = v252;
                    goto LABEL_91;
                  }
                }
                uint64_t v359 = 0;
                uint64_t v267 = v337;
                uint64_t v268 = v354;
                (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v254 + 96))(&v359, &type metadata for Int, v346, v354, v254);
                uint64_t v269 = swift_getAssociatedConformanceWitness(v297, v252, (uint64_t)v268, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
                v270 = v299;
                char v271 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v269 + 8) + 8))(v299, v267, v268);
                v272 = *(void (**)(char *, uint64_t *))(v338 + 8);
                v272(v267, v268);
                v273 = v270;
                goto LABEL_87;
              }
LABEL_57:
              uint64_t v205 = v323;
              uint64_t v206 = v354;
              uint64_t v207 = v321;
              v352 = associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral;
              uint64_t v208 = swift_getAssociatedConformanceWitness((uint64_t)v323, (uint64_t)v354, (uint64_t)v321, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v209 = v196;
              uint64_t v210 = (uint64_t)v206;
              uint64_t v211 = v322;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v208 + 8))(&qword_18162B0C0, 512, v207, v208);
              unint64_t v212 = v319;
              uint64_t v213 = v210;
              ((void (*)(char *, uint64_t, int **))v205[3])(v211, v210, v205);
              uint64_t v214 = swift_getAssociatedConformanceWitness(v358, v173, v210, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
              uint64_t v215 = v337;
              uint64_t v216 = v357;
              (*(void (**)(char *, char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v214 + 256))(v212, v357, v171, v209, v213, v214);
              uint64_t v217 = *(void (**)(char *, uint64_t))(v338 + 8);
              v217(v212, v213);
              ((void (*)(char *, uint64_t *))v356)(v216, v171);
              uint64_t v218 = v173;
              v219 = v320;
              uint64_t v220 = v345;
              (*(void (**)(char *, char *, uint64_t, uint64_t))(v214 + 208))(v215, v345, v213, v214);
              v217(v215, v213);
              v217(v220, v213);
              LOBYTE(v213) = ((uint64_t (*)(uint64_t, uint64_t))v342)(v218, v358);
              char v221 = v318;
              uint64_t v222 = v339;
              v315(v318, v355, v339);
              if (v213)
              {
                uint64_t v223 = v334;
                uint64_t v224 = v332;
                uint64_t v225 = swift_getAssociatedConformanceWitness((uint64_t)v334, v222, (uint64_t)v332, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, v352);
                uint64_t v226 = v313;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v225 + 8))(&qword_18162B0B8, 256, v224, v225);
                uint64_t v227 = v333;
                ((void (*)(char *, uint64_t, int **))v223[3])(v226, v222, v223);
                LOBYTE(v224) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v341 + 24)
                                                                                              + 8)
                                                                                  + 16))(v221, v227, v222);
                v228 = v227;
                uint64_t v229 = v317;
                v317(v228, v222);
                v229(v221, v222);
                if (v224)
                {
                  uint64_t v230 = v310;
                  uint64_t v231 = AssociatedTypeWitness;
                  uint64_t v232 = swift_getAssociatedConformanceWitness((uint64_t)v310, v218, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  uint64_t v233 = v219;
                  uint64_t v234 = v309;
                  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v232 + 8))(&qword_18162B0B8, 256, v231, v232);
                  int64_t v235 = v305;
                  ((void (*)(char *, uint64_t, int **))v230[3])(v234, v218, v230);
                  uint64_t v236 = v306;
                  (*(void (**)(char *, uint64_t *, uint64_t, uint64_t))(v358 + 88))(v233, v354, v214, v218);
                  uint64_t v237 = v307;
                  (*(void (**)(char *, char *, uint64_t))(v350 + 88))(v307, v236, v218);
                  uint64_t v238 = v336;
                  uint64_t v239 = *(void (**)(char *, uint64_t))(v336 + 8);
                  v239(v236, v218);
                  v239(v235, v218);
                  uint64_t v240 = v335;
                  (*(void (**)(uint64_t, char *, uint64_t))(v238 + 32))(v335, v237, v218);
LABEL_62:
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v238 + 56))(v240, 0, 1, v218);
                  char v107 = (char)v324;
                  return v107 & 1;
                }
              }
              else
              {
                v317(v221, v222);
              }
              uint64_t v240 = v335;
              (*(void (**)(char *, uint64_t *, uint64_t, uint64_t))(v358 + 88))(v219, v354, v214, v218);
              uint64_t v238 = v336;
              goto LABEL_62;
            }
            uint64_t v183 = v242;
          }
          else
          {
            uint64_t v196 = v184;
            uint64_t v195 = v171;
          }
          char v171 = v195;
          ((void (*)(char *, uint64_t *))v356)(v183, v195);
          goto LABEL_57;
        }
        uint64_t v117 = v314;
        uint64_t v359 = v314;
        uint64_t v122 = v85;
        uint64_t v123 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v42 + 96);
        unint64_t v124 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
        uint64_t v115 = v352;
        v123(&v359, &type metadata for Int, v124, v44, v42);
        int v125 = (*(uint64_t (**)(char *, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(v122, v115, v44);
        v349 = (int **)((v351 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
        ((void (*)(_DWORD *, uint64_t *))v356)(v115, v44);
      }
      else
      {
        uint64_t v117 = v314;
        if (v119 < 64)
        {
          uint64_t v129 = v351 + 16;
          BOOL v130 = (void (*)(_DWORD *, uint64_t *))v98;
          uint64_t v115 = v352;
          (*(void (**)(_DWORD *, char *, uint64_t *))(v351 + 16))(v352, v85, v44);
          uint64_t v116 = (*(uint64_t (**)(uint64_t *, uint64_t))(v42 + 120))(v44, v42);
          v349 = (int **)((v129 - 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
          v130(v115, v44);
          goto LABEL_30;
        }
        uint64_t v151 = v351;
        uint64_t v152 = v301;
        uint64_t v153 = (*(uint64_t (**)(char *, char *, uint64_t *))(v351 + 16))(v301, v85, v44);
        if (v117 < 1)
        {
          v349 = (int **)((v151 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
          ((void (*)(char *, uint64_t *))v98)(v152, v44);
          int v125 = 0;
          uint64_t v115 = v352;
          goto LABEL_31;
        }
        uint64_t v359 = v117;
        uint64_t v156 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v42 + 96);
        unint64_t v157 = lazy protocol witness table accessor for type Int and conformance Int(v153, v154, v155);
        uint64_t v115 = v352;
        v156(&v359, &type metadata for Int, v157, v44, v42);
        int v125 = (*(uint64_t (**)(char *, _DWORD *, uint64_t *))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(v152, v115, v44);
        v349 = (int **)((v151 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000);
        uint64_t v158 = v356;
        ((void (*)(_DWORD *, uint64_t *))v356)(v115, v44);
        ((void (*)(char *, uint64_t *))v158)(v152, v44);
      }
      uint64_t v131 = (uint64_t)v324;
      goto LABEL_46;
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v336 + 56))(v335, 1, 1, v353);
  char v107 = 0;
  return v107 & 1;
}

unint64_t specialized FixedWidthInteger.init<A>(_:)(double a1)
{
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v56, a1);
  if (v58)
  {
    unint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v4 = v3;
    unint64_t v56 = v2;
    unint64_t v57 = v3;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v6 < 0) {
      goto LABEL_66;
    }
    uint64_t v7 = (uint8x16_t *)TypeName;
    int64_t v8 = v6;
    int64_t v9 = validateUTF8(_:)(TypeName, v6);
    if (v11) {
      unint64_t v12 = repairUTF8(_:firstKnownBrokenRange:)(v7->i8, v8, v9, v10);
    }
    else {
      unint64_t v12 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v7, v8, v9 & 1);
    }
    unint64_t v14 = v12;
    unint64_t v15 = v13;
    uint64_t v16 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000) == 0) {
      uint64_t v16 = v2 & 0xFFFFFFFFFFFFLL;
    }
    if (!v16 && (v2 & ~v4 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v4);
      unint64_t v56 = v14;
      unint64_t v57 = v15;
      goto LABEL_21;
    }
    if ((v4 & 0x2000000000000000) != 0)
    {
      if ((v13 & 0x2000000000000000) != 0)
      {
        unint64_t v18 = specialized _SmallString.init(_:appending:)(v2, v4, v12, v13);
        if ((v20 & 1) == 0)
        {
          unint64_t v21 = v18;
          unint64_t v22 = v19;
          swift_bridgeObjectRelease(v4);
          swift_bridgeObjectRelease(v15);
          unint64_t v56 = v21;
          unint64_t v57 = v22;
          unint64_t v15 = v22;
          unint64_t v14 = v21;
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else if ((v13 & 0x2000000000000000) != 0)
    {
LABEL_19:
      uint64_t v17 = HIBYTE(v15) & 0xF;
      goto LABEL_20;
    }
    uint64_t v17 = v12 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v14, v15, 0, v17);
    swift_bridgeObjectRelease(v15);
    unint64_t v14 = v56;
    unint64_t v15 = v57;
LABEL_21:
    uint64_t v23 = HIBYTE(v15) & 0xF;
    if ((v15 & 0x2000000000000000) == 0) {
      uint64_t v23 = v14 & 0xFFFFFFFFFFFFLL;
    }
    if (v23 || (v14 & ~v15 & 0x2000000000000000) != 0)
    {
      if ((v15 & 0x2000000000000000) != 0
        && (0x80000001816DE7E0 & 0x2000000000000000) != 0
        && (unint64_t v24 = specialized _SmallString.init(_:appending:)(v14, v15, 0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000), (v26 & 1) == 0))
      {
        unint64_t v27 = v24;
        unint64_t v28 = v25;
        swift_bridgeObjectRelease(v15);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
        unint64_t v56 = v27;
        unint64_t v57 = v28;
      }
      else
      {
        if ((0x80000001816DE7E0 & 0x2000000000000000) != 0) {
          unint64_t v29 = (0x80000001816DE7E0 >> 56) & 0xF;
        }
        else {
          unint64_t v29 = 30;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000, 0, v29);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v15);
      unint64_t v56 = 0xD00000000000001ELL;
      unint64_t v57 = 0x80000001816DE7E0 | 0x8000000000000000;
    }
    uint64_t v30 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v31 & 0x8000000000000000) == 0)
    {
      uint64_t v32 = (uint8x16_t *)v30;
      int64_t v33 = v31;
      int64_t v34 = validateUTF8(_:)(v30, v31);
      if (v36) {
        unint64_t v37 = repairUTF8(_:firstKnownBrokenRange:)(v32->i8, v33, v34, v35);
      }
      else {
        unint64_t v37 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v32, v33, v34 & 1);
      }
      unint64_t v39 = v37;
      unint64_t v40 = v38;
      uint64_t v41 = v57;
      unint64_t v42 = HIBYTE(v57) & 0xF;
      if ((v57 & 0x2000000000000000) == 0) {
        unint64_t v42 = v56 & 0xFFFFFFFFFFFFLL;
      }
      if (!v42 && (v56 & ~v57 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v57);
        unint64_t v56 = v39;
        unint64_t v57 = v40;
        goto LABEL_52;
      }
      if ((v57 & 0x2000000000000000) != 0)
      {
        if ((v38 & 0x2000000000000000) != 0)
        {
          unint64_t v44 = specialized _SmallString.init(_:appending:)(v56, v57, v37, v38);
          if ((v46 & 1) == 0)
          {
            unint64_t v47 = v44;
            unint64_t v48 = v45;
            swift_bridgeObjectRelease(v41);
            swift_bridgeObjectRelease(v40);
            unint64_t v56 = v47;
            unint64_t v57 = v48;
            unint64_t v40 = v48;
            unint64_t v39 = v47;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
      }
      else if ((v38 & 0x2000000000000000) != 0)
      {
LABEL_50:
        uint64_t v43 = HIBYTE(v40) & 0xF;
        goto LABEL_51;
      }
      uint64_t v43 = v37 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v39, v40, 0, v43);
      swift_bridgeObjectRelease(v40);
      unint64_t v39 = v56;
      unint64_t v40 = v57;
LABEL_52:
      uint64_t v49 = HIBYTE(v40) & 0xF;
      if ((v40 & 0x2000000000000000) == 0) {
        uint64_t v49 = v39 & 0xFFFFFFFFFFFFLL;
      }
      if (v49 || (v39 & ~v40 & 0x2000000000000000) != 0)
      {
        if ((v40 & 0x2000000000000000) != 0
          && (0x80000001816DE800 & 0x2000000000000000) != 0
          && (unint64_t v52 = specialized _SmallString.init(_:appending:)(v39, v40, 0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000), (v54 & 1) == 0))
        {
          uint64_t v51 = v52;
          unint64_t v50 = v53;
          swift_bridgeObjectRelease(v40);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
        }
        else
        {
          if ((0x80000001816DE800 & 0x2000000000000000) != 0) {
            unint64_t v55 = (0x80000001816DE800 >> 56) & 0xF;
          }
          else {
            unint64_t v55 = 46;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000, 0, v55);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
          uint64_t v51 = v56;
          unint64_t v50 = v57;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v40);
        unint64_t v50 = 0x80000001816DE800 | 0x8000000000000000;
        uint64_t v51 = 0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v51, v50, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_66:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return v56;
}

uint64_t FixedWidthInteger.init<A>(_:)@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, Class *a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v12 = type metadata accessor for Optional(0, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  unint64_t v15 = (char *)&v72 - v14;
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v72 - v14, a1, (uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v16 = (uint64_t)*(a2 - 1);
  if ((*(unsigned int (**)(char *, uint64_t, Class *))(v16 + 48))(v15, 1, a2) == 1)
  {
    (*(void (**)(char *, Class *))(v13 + 8))(v15, v12);
    unint64_t v18 = specialized static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v20 = v19;
    unint64_t v72 = v18;
    unint64_t v73 = v19;
    TypeName = (uint64_t *)swift_getTypeName(a3, 0);
    if (v22 < 0) {
      goto LABEL_66;
    }
    uint64_t v23 = (uint8x16_t *)TypeName;
    int64_t v24 = v22;
    int64_t v25 = validateUTF8(_:)(TypeName, v22);
    if (v27) {
      unint64_t v28 = repairUTF8(_:firstKnownBrokenRange:)(v23->i8, v24, v25, v26);
    }
    else {
      unint64_t v28 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v23, v24, v25 & 1);
    }
    unint64_t v30 = v28;
    unint64_t v31 = v29;
    uint64_t v32 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000) == 0) {
      uint64_t v32 = v18 & 0xFFFFFFFFFFFFLL;
    }
    if (!v32 && (v18 & ~v20 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v20);
      unint64_t v72 = v30;
      unint64_t v73 = v31;
      goto LABEL_21;
    }
    if ((v20 & 0x2000000000000000) != 0)
    {
      if ((v29 & 0x2000000000000000) != 0)
      {
        unint64_t v34 = specialized _SmallString.init(_:appending:)(v18, v20, v28, v29);
        if ((v36 & 1) == 0)
        {
          unint64_t v37 = v34;
          unint64_t v38 = v35;
          swift_bridgeObjectRelease(v31);
          swift_bridgeObjectRelease(v20);
          unint64_t v72 = v37;
          unint64_t v73 = v38;
          unint64_t v31 = v38;
          unint64_t v30 = v37;
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else if ((v29 & 0x2000000000000000) != 0)
    {
LABEL_19:
      uint64_t v33 = HIBYTE(v31) & 0xF;
      goto LABEL_20;
    }
    uint64_t v33 = v28 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v30, v31, 0, v33);
    swift_bridgeObjectRelease(v31);
    unint64_t v30 = v72;
    unint64_t v31 = v73;
LABEL_21:
    uint64_t v39 = HIBYTE(v31) & 0xF;
    if ((v31 & 0x2000000000000000) == 0) {
      uint64_t v39 = v30 & 0xFFFFFFFFFFFFLL;
    }
    if (v39 || (v30 & ~v31 & 0x2000000000000000) != 0)
    {
      if ((v31 & 0x2000000000000000) != 0
        && ((unint64_t)"Swift/Random.swift" & 0x2000000000000000) != 0
        && (unint64_t v40 = specialized _SmallString.init(_:appending:)(v30, v31, 0xD00000000000001ELL, 0x80000001816DE7E0),
            (v42 & 1) == 0))
      {
        unint64_t v43 = v40;
        unint64_t v44 = v41;
        swift_bridgeObjectRelease(v31);
        unint64_t v72 = v43;
        unint64_t v73 = v44;
      }
      else
      {
        if (((unint64_t)"Swift/Random.swift" & 0x2000000000000000) != 0) {
          unint64_t v45 = (0x80000001816DE7E0 >> 56) & 0xF;
        }
        else {
          unint64_t v45 = 30;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001816DE7E0, 0, v45);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v31);
      unint64_t v72 = 0xD00000000000001ELL;
      unint64_t v73 = 0x80000001816DE7E0;
    }
    char v46 = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v47 & 0x8000000000000000) == 0)
    {
      unint64_t v48 = (uint8x16_t *)v46;
      int64_t v49 = v47;
      int64_t v50 = validateUTF8(_:)(v46, v47);
      if (v52) {
        unint64_t v53 = repairUTF8(_:firstKnownBrokenRange:)(v48->i8, v49, v50, v51);
      }
      else {
        unint64_t v53 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v48, v49, v50 & 1);
      }
      unint64_t v55 = v53;
      unint64_t v56 = v54;
      uint64_t v57 = v73;
      unint64_t v58 = HIBYTE(v73) & 0xF;
      if ((v73 & 0x2000000000000000) == 0) {
        unint64_t v58 = v72 & 0xFFFFFFFFFFFFLL;
      }
      if (!v58 && (v72 & ~v73 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v73);
        unint64_t v72 = v55;
        unint64_t v73 = v56;
        goto LABEL_52;
      }
      if ((v73 & 0x2000000000000000) != 0)
      {
        if ((v54 & 0x2000000000000000) != 0)
        {
          unint64_t v60 = specialized _SmallString.init(_:appending:)(v72, v73, v53, v54);
          if ((v62 & 1) == 0)
          {
            unint64_t v63 = v60;
            unint64_t v64 = v61;
            swift_bridgeObjectRelease(v56);
            swift_bridgeObjectRelease(v57);
            unint64_t v72 = v63;
            unint64_t v73 = v64;
            unint64_t v56 = v64;
            unint64_t v55 = v63;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
      }
      else if ((v54 & 0x2000000000000000) != 0)
      {
LABEL_50:
        uint64_t v59 = HIBYTE(v56) & 0xF;
        goto LABEL_51;
      }
      uint64_t v59 = v53 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v55, v56, 0, v59);
      swift_bridgeObjectRelease(v56);
      unint64_t v55 = v72;
      unint64_t v56 = v73;
LABEL_52:
      uint64_t v65 = HIBYTE(v56) & 0xF;
      if ((v56 & 0x2000000000000000) == 0) {
        uint64_t v65 = v55 & 0xFFFFFFFFFFFFLL;
      }
      if (v65 || (v55 & ~v56 & 0x2000000000000000) != 0)
      {
        if ((v56 & 0x2000000000000000) != 0
          && (0x80000001816DE800 & 0x2000000000000000) != 0
          && (unint64_t v68 = specialized _SmallString.init(_:appending:)(v55, v56, 0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000), (v70 & 1) == 0))
        {
          uint64_t v67 = v68;
          unint64_t v66 = v69;
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
          swift_bridgeObjectRelease(v56);
        }
        else
        {
          if ((0x80000001816DE800 & 0x2000000000000000) != 0) {
            unint64_t v71 = (0x80000001816DE800 >> 56) & 0xF;
          }
          else {
            unint64_t v71 = 46;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000, 0, v71);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
          uint64_t v67 = v72;
          unint64_t v66 = v73;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v56);
        unint64_t v66 = 0x80000001816DE800 | 0x8000000000000000;
        uint64_t v67 = 0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v67, v66, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_66:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  (*((void (**)(uint64_t, Class *))*(a3 - 1) + 1))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v16 + 32))(a6, v15, a2);
}

uint64_t FixedWidthInteger.init<A>(exactly:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v12 = type metadata accessor for Optional(0, a2, a3, a4);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v23 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  unint64_t v18 = (char *)&v23 - v17;
  LOBYTE(a5) = static FixedWidthInteger._convert<A>(from:)((uint64_t)&v23 - v17, a1, a2, a3, a4, a5);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
  if (a5)
  {
    (*(void (**)(char *, char *, Class *))(v13 + 32))(v16, v18, v12);
    uint64_t v19 = *(void *)(a2 - 8);
    uint64_t v20 = v19;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v16, 1, a2) != 1)
    {
      (*(void (**)(uint64_t, char *, uint64_t))(v19 + 32))(a6, v16, a2);
      uint64_t v21 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 56))(a6, v21, 1, a2);
    }
    (*(void (**)(char *, Class *))(v13 + 8))(v16, v12);
  }
  else
  {
    (*(void (**)(char *, Class *))(v13 + 8))(v18, v12);
    uint64_t v19 = *(void *)(a2 - 8);
  }
  uint64_t v20 = v19;
  uint64_t v21 = 1;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 56))(a6, v21, 1, a2);
}

uint64_t FixedWidthInteger.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7 = a4;
  uint64_t v9 = a2;
  uint64_t v176 = a1;
  uint64_t v167 = a6;
  uint64_t v173 = *(void *)(a4 + 8);
  uint64_t v160 = *(int ***)(*(void *)(v173 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v160, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v158 = (char *)&v144 - v10;
  unint64_t v157 = *(int ***)(*(void *)(a5 + 24) + 16);
  uint64_t v156 = swift_getAssociatedTypeWitness(0, v157, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](v156);
  uint64_t v155 = (char *)&v144 - v12;
  uint64_t v175 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v149 = (char *)&v144 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v150 = (char *)&v144 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v154 = (char *)&v144 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v153 = (char *)&v144 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v174 = (char *)&v144 - v22;
  uint64_t v171 = *(void *)(v9 - 8);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  char v148 = (char *)&v144 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v147 = (char *)&v144 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v172 = (char *)&v144 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v151 = (char *)&v144 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v152 = (char *)&v144 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  int v170 = (char *)&v144 - v34;
  MEMORY[0x1F4188790](v33);
  char v36 = (char *)&v144 - v35;
  unint64_t v37 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 72);
  uint64_t v38 = v7;
  uint64_t v146 = v7 + 72;
  uint64_t v145 = v37;
  v37(v9, v7);
  uint64_t v39 = *(uint64_t (**)(uint64_t))(a5 + 64);
  uint64_t v40 = a3;
  LODWORD(v7) = v39(a3);
  uint64_t v41 = v173;
  uint64_t v163 = *(uint64_t (**)(uint64_t))(v173 + 64);
  uint64_t v164 = v173 + 64;
  int v42 = v163(v9);
  uint64_t v168 = a5;
  uint64_t v169 = v38;
  unint64_t v165 = (unsigned int (*)(uint64_t, uint64_t))v39;
  uint64_t v166 = a5 + 64;
  if ((v7 ^ v42))
  {
    char v43 = ((uint64_t (*)(uint64_t, uint64_t))v39)(v40, a5);
    unint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v144 = v40;
    uint64_t v162 = v44;
    uint64_t v45 = v44(v40, a5);
    char v46 = *(uint64_t (**)(uint64_t, uint64_t))(v41 + 128);
    uint64_t v47 = v46(v9, v41);
    if (v43)
    {
      uint64_t v48 = v175;
      if (v47 < v45)
      {
        uint64_t v161 = v46;
        uint64_t v49 = v168;
        uint64_t v51 = v173;
        int64_t v50 = v174;
        uint64_t v52 = v144;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v168 + 96))(v36, v9, v173, v144, v168);
        uint64_t v53 = v176;
        char v54 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v176, v50, v52);
        (*(void (**)(char *, uint64_t))(v48 + 8))(v50, v52);
LABEL_10:
        uint64_t v61 = v169;
        unint64_t v60 = v172;
        goto LABEL_12;
      }
      unint64_t v68 = v156;
      unint64_t v69 = v157;
      uint64_t v52 = v144;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v157, v144, (uint64_t)v156, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v71 = v155;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v68, AssociatedConformanceWitness);
      unint64_t v72 = v174;
      ((void (*)(char *, uint64_t, int **))v69[3])(v71, v52, v69);
      uint64_t v73 = v176;
      LOBYTE(v68) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v168 + 32) + 8)
                                                                        + 16))(v176, v72, v52);
      uint64_t v74 = v9;
      uint64_t v75 = v36;
      uint64_t v154 = *(char **)(v48 + 8);
      ((void (*)(char *, uint64_t))v154)(v72, v52);
      uint64_t v76 = v153;
      (*(void (**)(char *, uint64_t, uint64_t))(v48 + 16))(v153, v73, v52);
      uint64_t v77 = v171;
      uint64_t v78 = v152;
      uint64_t v79 = v75;
      uint64_t v9 = v74;
      (*(void (**)(char *, char *, uint64_t))(v171 + 32))(v152, v79, v74);
      if (v68)
      {
        (*(void (**)(char *, uint64_t))(v77 + 8))(v78, v74);
        ((void (*)(char *, uint64_t))v154)(v76, v52);
        uint64_t v53 = v176;
        uint64_t v61 = v169;
        goto LABEL_16;
      }
      uint64_t v161 = v46;
      uint64_t v51 = v173;
      unint64_t v97 = v170;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v173 + 96))(v76, v52, v168, v9, v173);
      char v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v51 + 32) + 8) + 16))(v97, v78, v9);
      uint64_t v98 = *(void (**)(char *, uint64_t))(v77 + 8);
      v98(v97, v9);
      v98(v78, v9);
      uint64_t v53 = v176;
      uint64_t v49 = v168;
    }
    else
    {
      uint64_t v161 = v46;
      if (v45 < v47)
      {
        unint64_t v63 = v174;
        uint64_t v52 = v144;
        (*(void (**)(char *, uint64_t, uint64_t))(v175 + 16))(v174, v176, v144);
        uint64_t v51 = v173;
        unint64_t v64 = v170;
        uint64_t v49 = v168;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v173 + 96))(v63, v52, v168, v9, v173);
        char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v51 + 32) + 8) + 16))(v64, v36, v9);
        uint64_t v65 = *(void (**)(char *, uint64_t))(v171 + 8);
        v65(v64, v9);
        v65(v36, v9);
        uint64_t v53 = v176;
        goto LABEL_10;
      }
      uint64_t v81 = AssociatedTypeWitness;
      uint64_t v82 = v160;
      uint64_t v83 = swift_getAssociatedConformanceWitness((uint64_t)v160, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v84 = v9;
      uint64_t v85 = v36;
      uint64_t v86 = v158;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v83 + 8))(&qword_18162B0B8, 256, v81, v83);
      uint64_t v87 = v170;
      ((void (*)(char *, uint64_t, int **))v82[3])(v86, v84, v82);
      uint64_t v51 = v173;
      LOBYTE(v81) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v173 + 32) + 8) + 40))(v85, v87, v84);
      uint64_t v88 = v171;
      uint64_t v89 = *(void (**)(char *, uint64_t))(v171 + 8);
      v89(v87, v84);
      char v90 = v154;
      uint64_t v52 = v144;
      (*(void (**)(char *, uint64_t, uint64_t))(v175 + 16))(v154, v176, v144);
      uint64_t v91 = *(void (**)(char *, char *, uint64_t))(v88 + 32);
      uint64_t v92 = v151;
      uint64_t v93 = v85;
      uint64_t v9 = v84;
      v91(v151, v93, v84);
      if ((v81 & 1) == 0)
      {
        v89(v92, v84);
        (*(void (**)(char *, uint64_t))(v175 + 8))(v90, v52);
        uint64_t v49 = v168;
        uint64_t v61 = v169;
        unint64_t v60 = v172;
        char v62 = (uint64_t (*)(uint64_t, uint64_t))v163;
        goto LABEL_23;
      }
      uint64_t v49 = v168;
      uint64_t v94 = v174;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v168 + 96))(v92, v84, v51, v52, v168);
      char v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v90, v94, v52);
      uint64_t v96 = *(void (**)(char *, uint64_t))(v175 + 8);
      v96(v94, v52);
      v96(v90, v52);
      uint64_t v53 = v176;
    }
    unint64_t v60 = v172;
    char v62 = (uint64_t (*)(uint64_t, uint64_t))v163;
    uint64_t v61 = v169;
    if (v95) {
      goto LABEL_16;
    }
    goto LABEL_23;
  }
  uint64_t v53 = v176;
  uint64_t v162 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
  uint64_t v55 = v162(v40, a5);
  uint64_t v51 = v41;
  uint64_t v161 = *(uint64_t (**)(uint64_t, uint64_t))(v41 + 128);
  if (v55 < v161(v9, v41))
  {
    unint64_t v56 = v174;
    uint64_t v52 = v40;
    (*(void (**)(char *, uint64_t, uint64_t))(v175 + 16))(v174, v53, v40);
    uint64_t v57 = v170;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v51 + 96))(v56, v40, a5, v9, v51);
    LODWORD(v154) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v51 + 32) + 8) + 16))(v57, v36, v9);
    uint64_t v58 = v53;
    uint64_t v59 = *(void (**)(char *, uint64_t))(v171 + 8);
    v59(v57, v9);
    v59(v36, v9);
    uint64_t v53 = v58;
    uint64_t v49 = a5;
    unint64_t v60 = v172;
    uint64_t v61 = v169;
    char v62 = (uint64_t (*)(uint64_t, uint64_t))v163;
    if ((v154 & 1) == 0) {
      goto LABEL_23;
    }
LABEL_16:
    (*(void (**)(uint64_t, uint64_t))(v175 + 8))(v53, v52);
    return v145(v9, v61);
  }
  unint64_t v66 = v174;
  uint64_t v67 = v41;
  uint64_t v52 = v40;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v36, v9, v67, v40, a5);
  char v54 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8) + 16))(v53, v66, v40);
  (*(void (**)(char *, uint64_t))(v175 + 8))(v66, v40);
  uint64_t v49 = a5;
  unint64_t v60 = v172;
  uint64_t v61 = v169;
LABEL_12:
  char v62 = (uint64_t (*)(uint64_t, uint64_t))v163;
  if (v54) {
    goto LABEL_16;
  }
LABEL_23:
  uint64_t v163 = *(uint64_t (**)(uint64_t))(v61 + 64);
  uint64_t v164 = v61 + 64;
  ((void (*)(uint64_t, uint64_t))v163)(v9, v61);
  int v99 = v62(v9, v51);
  if (((v99 ^ v165(v52, v49)) & 1) == 0)
  {
    uint64_t v108 = v161(v9, v51);
    uint64_t v105 = v176;
    uint64_t v107 = v49;
    uint64_t v103 = v51;
    if (v108 >= v162(v52, v49))
    {
      uint64_t v113 = v174;
      (*(void (**)(char *, uint64_t, uint64_t))(v175 + 16))(v174, v105, v52);
      unint64_t v106 = v170;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v51 + 96))(v113, v52, v107, v9, v51);
      goto LABEL_33;
    }
    unint64_t v109 = v174;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v49 + 96))(v60, v9, v51, v52, v49);
    char v110 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v109, v105, v52);
    goto LABEL_31;
  }
  char v100 = v62(v9, v51);
  uint64_t v101 = v161(v9, v51);
  uint64_t v102 = v162(v52, v49);
  uint64_t v103 = v51;
  if ((v100 & 1) == 0)
  {
    if (v101 >= v102)
    {
      uint64_t v126 = v156;
      uint64_t v127 = v157;
      uint64_t v128 = swift_getAssociatedConformanceWitness((uint64_t)v157, v52, (uint64_t)v156, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v129 = v155;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v128 + 8))(&qword_18162B0B8, 256, v126, v128);
      BOOL v130 = v174;
      ((void (*)(char *, uint64_t, int **))v127[3])(v129, v52, v127);
      uint64_t v107 = v168;
      uint64_t v131 = v176;
      LODWORD(v166) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v168 + 32) + 8)
                                                                          + 40))(v176, v130, v52);
      uint64_t v132 = v175;
      uint64_t v133 = *(void (**)(char *, uint64_t))(v175 + 8);
      v133(v130, v52);
      uint64_t v134 = v171;
      uint64_t v135 = v148;
      (*(void (**)(char *, char *, uint64_t))(v171 + 32))(v148, v172, v9);
      unint64_t v136 = *(void (**)(char *, uint64_t, uint64_t))(v132 + 16);
      uint64_t v137 = v149;
      uint64_t v138 = v134;
      v136(v149, v131, v52);
      if ((v166 & 1) == 0)
      {
        v133(v137, v52);
        (*(void (**)(char *, uint64_t))(v134 + 8))(v135, v9);
        uint64_t v105 = v176;
        uint64_t v103 = v173;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v103 + 96))(v105, v52, v107, v9, v103);
      }
      uint64_t v139 = v170;
      uint64_t v140 = v137;
      uint64_t v103 = v173;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v173 + 96))(v140, v52, v107, v9, v173);
      char v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v103 + 32) + 8) + 16))(v135, v139, v9);
      unint64_t v141 = *(void (**)(char *, uint64_t))(v138 + 8);
      v141(v139, v9);
      v141(v135, v9);
      uint64_t v112 = v175;
      uint64_t v105 = v176;
      goto LABEL_34;
    }
    uint64_t v107 = v168;
    unint64_t v109 = v174;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v168 + 96))(v172, v9, v51, v52, v168);
    uint64_t v105 = v176;
    char v110 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v107 + 32) + 8) + 16))(v109, v176, v52);
LABEL_31:
    char v111 = v110;
    uint64_t v112 = v175;
    (*(void (**)(char *, uint64_t))(v175 + 8))(v109, v52);
    goto LABEL_34;
  }
  if (v102 < v101)
  {
    unint64_t v60 = v172;
    uint64_t v104 = v174;
    uint64_t v105 = v176;
    (*(void (**)(char *, uint64_t, uint64_t))(v175 + 16))(v174, v176, v52);
    unint64_t v106 = v170;
    uint64_t v107 = v168;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v51 + 96))(v104, v52, v168, v9, v51);
LABEL_33:
    char v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v103 + 32) + 8) + 16))(v60, v106, v9);
    uint64_t v114 = *(void (**)(char *, uint64_t))(v171 + 8);
    v114(v106, v9);
    uint64_t v115 = v60;
    uint64_t v112 = v175;
    v114(v115, v9);
    goto LABEL_34;
  }
  uint64_t v116 = AssociatedTypeWitness;
  uint64_t v117 = v160;
  uint64_t v118 = swift_getAssociatedConformanceWitness((uint64_t)v160, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v119 = v158;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v118 + 8))(&qword_18162B0B8, 256, v116, v118);
  uint64_t v120 = v170;
  ((void (*)(char *, uint64_t, int **))v117[3])(v119, v9, v117);
  uint64_t v121 = v172;
  LOBYTE(v116) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v51 + 32) + 8) + 16))(v172, v120, v9);
  uint64_t v122 = v171;
  uint64_t v123 = *(void (**)(char *, uint64_t))(v171 + 8);
  v123(v120, v9);
  unint64_t v124 = v147;
  (*(void (**)(char *, char *, uint64_t))(v122 + 32))(v147, v121, v9);
  uint64_t v112 = v175;
  int v125 = v150;
  (*(void (**)(char *, uint64_t, uint64_t))(v175 + 16))(v150, v176, v52);
  if (v116)
  {
    (*(void (**)(char *, uint64_t))(v112 + 8))(v125, v52);
    v123(v124, v9);
    uint64_t v105 = v176;
    goto LABEL_39;
  }
  uint64_t v107 = v168;
  uint64_t v142 = v174;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v168 + 96))(v124, v9, v103, v52, v168);
  char v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v107 + 32) + 8) + 16))(v142, v125, v52);
  char v143 = *(void (**)(char *, uint64_t))(v112 + 8);
  v143(v142, v52);
  v143(v125, v52);
  uint64_t v105 = v176;
LABEL_34:
  if (v111)
  {
LABEL_39:
    (*(void (**)(uint64_t, uint64_t))(v112 + 8))(v105, v52);
    return ((uint64_t (*)(uint64_t, uint64_t))v163)(v9, v169);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v103 + 96))(v105, v52, v107, v9, v103);
}

uint64_t specialized static FixedWidthInteger._truncatingInit<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v23)(uint64_t *__return_ptr, uint64_t, uint64_t);
  uint64_t v24;
  void v26[2];
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;

  uint64_t v27 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  v26[1] = (char *)v26 - v6;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)+ 8)+ 8)+ 8);
  v26[0] = swift_getAssociatedTypeWitness(0, (int **)v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v28 = *(void *)(v26[0] - 8);
  uint64_t v8 = MEMORY[0x1F4188790](v26[0]);
  uint64_t v10 = (char *)v26 - v9;
  uint64_t v11 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)v26 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = *(void *)(*(void *)(a3 + 24) + 16);
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v14, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v15);
  uint64_t v17 = (char *)v26 - v16;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v14, a2, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v15, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 24))(v17, a2, v14);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v27, v13, a2);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, a2);
  uint64_t v20 = a2;
  uint64_t v21 = v26[0];
  (*(void (**)(uint64_t, uint64_t))(a3 + 112))(v20, a3);
  (*(void (**)(const char *, uint64_t))(v7 + 32))(AssociatedTypeWitness, v7);
  uint64_t v22 = swift_getAssociatedConformanceWitness(v7, (uint64_t)AssociatedTypeWitness, v21, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v23 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v22 + 16);
  v23(&v29, v21, v22);
  if (v30)
  {
    uint64_t v24 = v19 << 63 >> 63;
  }
  else
  {
    uint64_t v24 = v29;
    v23(&v29, v21, v22);
    if ((v30 & 1) == 0) {
      v23(&v29, v21, v22);
    }
  }
  (*(void (**)(char *, uint64_t))(v28 + 8))(v10, v21);
  return v24;
}

uint64_t specialized static FixedWidthInteger._truncatingInit<A>(_:)(char *a1, uint64_t a2, uint64_t a3)
{
  void (*v28)(uint64_t *__return_ptr, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  BOOL v36;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  int **v41;
  char *v42;
  char *v43;
  uint64_t v44;
  char v45;

  char v43 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  int v42 = (char *)&v38 - v6;
  uint64_t v41 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)+ 8)+ 8)+ 8);
  uint64_t v7 = swift_getAssociatedTypeWitness(0, v41, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v39 = *((void *)v7 - 1);
  uint64_t v40 = v7;
  uint64_t v8 = MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v38 - v9;
  uint64_t v11 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v38 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = *(void *)(*(void *)(a3 + 24) + 16);
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v14, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v15);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v14, a2, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v15, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 24))(v17, a2, v14);
  uint64_t v19 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v43, v13, a2);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, a2);
  uint64_t v20 = v19 << 63 >> 63;
  (*(void (**)(uint64_t, uint64_t))(a3 + 112))(a2, a3);
  uint64_t v21 = v41[4];
  char v43 = v10;
  uint64_t v22 = v41;
  ((void (*)(const char *))v21)(AssociatedTypeWitness);
  uint64_t v23 = (uint64_t)v22;
  uint64_t v24 = (uint64_t)v40;
  uint64_t v25 = swift_getAssociatedConformanceWitness(v23, (uint64_t)AssociatedTypeWitness, (uint64_t)v40, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v25 + 16);
  uint64_t v29 = v20;
  uint64_t v30 = v20;
  while (1)
  {
    v28(&v44, v24, v25);
    if (v45) {
      break;
    }
    uint64_t v31 = v26 < 0x80;
    if (v27) {
      uint64_t v31 = v27 < 0;
    }
    if (!v31) {
      break;
    }
    uint64_t v32 = v44 ^ v30;
    if ((v26 & 0x7F) != 0) {
      uint64_t v33 = v44 ^ v30;
    }
    else {
      uint64_t v33 = 0;
    }
    if ((v26 & 0x7F) >= 0x40) {
      uint64_t v32 = 0;
    }
    v20 ^= v32;
    v29 ^= v33;
    uint64_t v34 = v26 >= 0xFFFFFFFFFFFFFFC0;
    if (v26 < 0xFFFFFFFFFFFFFFC0) {
      uint64_t v35 = v27;
    }
    else {
      uint64_t v35 = v27 + 1;
    }
    v26 += 64;
    char v36 = v27 == 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v27 = v35;
    if (v36)
    {
      uint64_t v27 = v35;
      if (v34) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x264uLL, 0);
      }
    }
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v43, v24);
  return v20;
}

uint64_t static FixedWidthInteger._truncatingInit<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v79 = a1;
  uint64_t v84 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v75 = (uint64_t (*)(char *, char *, uint64_t, uint64_t))((char *)&v66 - v11);
  uint64_t v74 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)+ 8)+ 8)+ 8);
  uint64_t v78 = AssociatedTypeWitness;
  uint64_t v88 = swift_getAssociatedTypeWitness(0, (int **)v74, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v70 = *((void *)v88 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v88);
  uint64_t v87 = (char *)&v66 - v13;
  uint64_t v71 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v83 = (char *)&v66 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v82 = (char *)&v66 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v89 = (char *)&v66 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v90 = (char *)&v66 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v23 = (char *)&v66 - v22;
  uint64_t v85 = *(void *)(a4 + 8);
  uint64_t v86 = a4;
  uint64_t v80 = *(void *)(v85 + 24);
  uint64_t v73 = *(int ***)(v80 + 16);
  unint64_t v69 = swift_getAssociatedTypeWitness(0, v73, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v24 = MEMORY[0x1F4188790](v69);
  unint64_t v72 = (char *)&v66 - v25;
  uint64_t v26 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v66 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = *(void *)(*(void *)(a5 + 24) + 16);
  uint64_t v30 = swift_getAssociatedTypeWitness(0, (int **)v29, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v30);
  uint64_t v32 = (char *)&v66 - v31;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v29, a3, (uint64_t)v30, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0B8, 256, v30, AssociatedConformanceWitness);
  uint64_t v34 = v23;
  (*(void (**)(char *, uint64_t, uint64_t))(v29 + 24))(v32, a3, v29);
  uint64_t v77 = a5;
  uint64_t v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8) + 16))(v79, v28, a3);
  char v36 = *(void (**)(char *, uint64_t))(v26 + 8);
  uint64_t v76 = a3;
  uint64_t v37 = a3;
  uint64_t v38 = (uint64_t)v69;
  uint64_t v39 = v73;
  v36(v28, v37);
  uint64_t v40 = swift_getAssociatedConformanceWitness((uint64_t)v39, a2, v38, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v41 = v72;
  unint64_t v68 = *(void (**)(void *, uint64_t, uint64_t, uint64_t))(v40 + 8);
  v68(&unk_18162B0B8, 256, v38, v40);
  int v42 = v39[3];
  char v43 = v34;
  uint64_t v81 = v34;
  uint64_t v44 = v85;
  uint64_t v66 = v35;
  uint64_t v67 = v42;
  if (v35)
  {
    uint64_t v45 = v43;
    ((void (*)(char *, uint64_t, int **))v42)(v41, a2, v39);
    (*(void (**)(char *, uint64_t, uint64_t))(v44 + 184))(v45, a2, v44);
    (*(void (**)(char *, uint64_t))(v71 + 8))(v45, a2);
  }
  else
  {
    ((void (*)(char *, uint64_t, int **))v42)(v41, a2, v39);
  }
  char v46 = v41;
  v68(&unk_18162B0B8, 256, v38, v40);
  uint64_t v47 = v90;
  ((void (*)(char *, uint64_t, int **))v67)(v46, a2, v39);
  uint64_t v48 = v86;
  uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(v86 + 56))(a2, v86);
  int64_t v50 = *(void (**)(uint64_t, uint64_t, uint64_t))(v48 + 136);
  v50(v49, a2, v48);
  (*(void (**)(uint64_t))(v77 + 112))(v76);
  uint64_t v51 = v74;
  uint64_t v52 = (uint64_t)v78;
  (*(void (**)(const char *, uint64_t))(v74 + 32))(v78, v74);
  uint64_t v53 = v51;
  char v54 = v88;
  uint64_t v55 = swift_getAssociatedConformanceWitness(v53, v52, (uint64_t)v88, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v78 = *(const char **)(v55 + 16);
  uint64_t v79 = v55;
  ((void (*)(uint64_t *__return_ptr, const char *))v78)(&v91, v54);
  if ((v92 & 1) == 0)
  {
    uint64_t v56 = v86;
    uint64_t v77 = *(void *)(*(void *)(v85 + 32) + 8);
    uint64_t v75 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v77 + 16);
    uint64_t v76 = v77 + 16;
    uint64_t v57 = v91;
    uint64_t v73 = (int **)(v86 + 216);
    uint64_t v74 = v66 << 63 >> 63;
    uint64_t v58 = (void (**)(char *, uint64_t))(v71 + 8);
    unint64_t v72 = (char *)(v85 + 232);
    do
    {
      if ((v75(v47, v89, a2, v77) & 1) == 0) {
        break;
      }
      uint64_t v59 = v83;
      v50(v57 ^ v74, a2, v56);
      unint64_t v60 = v82;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v56 + 216))(v59, v90, a2, v56);
      uint64_t v61 = *v58;
      char v62 = v59;
      uint64_t v47 = v90;
      (*v58)(v62, a2);
      (*(void (**)(uint64_t, char *, uint64_t))(v85 + 232))(v84, v60, a2);
      v61(v60, a2);
      unint64_t v63 = v81;
      v50(64, a2, v56);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v80 + 8) + 32))(v47, v63, a2);
      v61(v63, a2);
      ((void (*)(uint64_t *__return_ptr, const char *, uint64_t))v78)(&v91, v88, v79);
      uint64_t v57 = v91;
    }
    while (v92 != 1);
  }
  (*(void (**)(char *, const char *))(v70 + 8))(v87, v88);
  unint64_t v64 = *(void (**)(char *, uint64_t))(v71 + 8);
  v64(v89, a2);
  return ((uint64_t (*)(char *, uint64_t))v64)(v47, a2);
}

uint64_t static FixedWidthInteger._highBitIndex.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(a2 + 56))();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 136))(v4 - 1, a1, a2);
}

uint64_t static FixedWidthInteger.&-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v8 + 88))(v7);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v7, a3);
}

uint64_t static FixedWidthInteger.&*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v8 + 96))(v7, a1);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v7, a3);
}

uint64_t specialized static FixedWidthInteger._random<A>(using:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v63 = *(void *)(v6 + 24);
  uint64_t v59 = *(int ***)(v63 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v59, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v58 = (char *)&v53 - v9;
  uint64_t v55 = *(void *)(a1 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  char v62 = (char *)&v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v53 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v61 = (char *)&v53 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v53 - v17;
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 56);
  if (v19(a1, a2) < 65)
  {
    uint64_t __buf = 0;
    swift_stdlib_random(&__buf, 8uLL);
    uint64_t v48 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
    unint64_t v52 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v49, v50, v51);
    return v48(&__buf, &type metadata for UInt64, v52, a1, v6);
  }
  else
  {
    uint64_t v53 = a3;
    uint64_t v54 = v6;
    uint64_t v20 = v19(a1, a2);
    if (v20 >= 0) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 + 63;
    }
    uint64_t v22 = v20 - (v21 & 0xFFFFFFFFFFFFFFC0);
    uint64_t v23 = v59;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v59, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v25 = v58;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    uint64_t v26 = v23[3];
    unint64_t v60 = v18;
    ((void (*)(char *, uint64_t, int **))v26)(v25, a1, v23);
    int64_t v27 = ((v22 > 0) | (unint64_t)(v22 >> 63)) + (v21 >> 6);
    if (v27 < 0) {
      goto LABEL_13;
    }
    uint64_t v59 = (int **)a2;
    uint64_t v28 = v54;
    if (v27)
    {
      uint64_t v29 = 0;
      uint64_t v56 = (void (**)(char *, uint64_t))(v55 + 8);
      uint64_t v57 = v59 + 27;
      uint64_t v30 = 0x200000000000000;
      uint64_t v58 = (char *)(v54 + 96);
      while (1)
      {
        uint64_t __buf = 0;
        swift_stdlib_random(&__buf, 8uLL);
        uint64_t v31 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v28 + 96);
        unint64_t v35 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v32, v33, v34);
        uint64_t v36 = v31(&__buf, &type metadata for UInt64, v35, a1, v28);
        if (!v30) {
          break;
        }
        uint64_t __buf = v29;
        unint64_t v39 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        uint64_t v40 = v14;
        uint64_t v41 = v62;
        v31(&__buf, &type metadata for Int, v39, a1, v28);
        uint64_t v42 = v28;
        char v43 = v61;
        ((void (*)(char *, char *, uint64_t))v59[27])(v40, v41, a1);
        uint64_t v44 = *v56;
        uint64_t v45 = v41;
        uint64_t v14 = v40;
        (*v56)(v45, a1);
        v44(v40, a1);
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v63 + 8) + 32))(v60, v43, a1);
        char v46 = v43;
        uint64_t v28 = v42;
        v44(v46, a1);
        --v30;
        v29 += 64;
        if (!--v27) {
          return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v55 + 32))(v53, v60, a1);
        }
      }
      __break(1u);
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v55 + 32))(v53, v60, a1);
  }
}

uint64_t static FixedWidthInteger._random<A>(using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v56 = a6;
  uint64_t v10 = *(void *)(a4 + 8);
  uint64_t v67 = *(void *)(v10 + 24);
  uint64_t v68 = a1;
  unint64_t v69 = *(int ***)(v67 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v69, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v54 - v12;
  uint64_t v55 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v66 = (char *)&v54 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v70 = (char *)&v54 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v65 = (char *)&v54 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v54 - v20;
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 56);
  if (v22(a2, a4) <= 64)
  {
    uint64_t v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 8))(a3, a5);
    uint64_t v50 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v10 + 96);
    unint64_t v53 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v71, v51, v52);
    return v50(&v71, &type metadata for UInt64, v53, a2, v10);
  }
  else
  {
    uint64_t v63 = a4;
    uint64_t v23 = v22(a2, a4);
    if (v23 >= 0) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = v23 + 63;
    }
    uint64_t v25 = v23 - (v24 & 0xFFFFFFFFFFFFFFC0);
    uint64_t v26 = v69;
    int64_t v27 = AssociatedTypeWitness;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v69, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v27, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v26[3])(v13, a2, v26);
    int64_t v29 = ((v25 > 0) | (unint64_t)(v25 >> 63)) + (v24 >> 6);
    if (v29 < 0) {
      goto LABEL_13;
    }
    uint64_t AssociatedTypeWitness = v21;
    if (v29)
    {
      uint64_t v30 = 0;
      uint64_t v61 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 8);
      uint64_t v62 = a5 + 8;
      unint64_t v69 = (int **)(v10 + 96);
      uint64_t v58 = v55 + 8;
      uint64_t v59 = v63 + 216;
      uint64_t v31 = 0x200000000000000;
      uint64_t v60 = v10;
      uint64_t v57 = a3;
      uint64_t v32 = (void (**)(char *, uint64_t))(v55 + 8);
      while (1)
      {
        uint64_t v33 = a3;
        uint64_t v34 = a5;
        uint64_t v71 = v61(v33, a5);
        unint64_t v35 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v10 + 96);
        unint64_t v38 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v71, v36, v37);
        uint64_t v39 = v35(&v71, &type metadata for UInt64, v38, a2, v10);
        if (!v31) {
          break;
        }
        uint64_t v71 = v30;
        unint64_t v42 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        char v43 = v66;
        v35(&v71, &type metadata for Int, v42, a2, v10);
        uint64_t v44 = v65;
        (*(void (**)(char *, char *, uint64_t))(v63 + 216))(v70, v43, a2);
        uint64_t v45 = *v32;
        char v46 = v43;
        uint64_t v47 = v70;
        (*v32)(v46, a2);
        v45(v47, a2);
        (*(void (**)(const char *, char *, uint64_t))(*(void *)(v67 + 8) + 32))(AssociatedTypeWitness, v44, a2);
        uint64_t v48 = v44;
        uint64_t v10 = v60;
        v45(v48, a2);
        --v31;
        v30 += 64;
        --v29;
        a5 = v34;
        a3 = v57;
        if (!v29) {
          return (*(uint64_t (**)(uint64_t, const char *, uint64_t))(v55 + 32))(v56, AssociatedTypeWitness, a2);
        }
      }
      __break(1u);
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    return (*(uint64_t (**)(uint64_t, const char *, uint64_t))(v55 + 32))(v56, AssociatedTypeWitness, a2);
  }
}

uint64_t static UnsignedInteger.isSigned.getter()
{
  return 0;
}

uint64_t UnsignedInteger<>.init<A>(exactly:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v138 = a1;
  uint64_t v135 = a6;
  uint64_t v131 = a4;
  uint64_t v133 = a4[1];
  uint64_t v120 = *(int ***)(*(void *)(v133 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v113 - v10;
  uint64_t v136 = a2;
  uint64_t v134 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v122 = (char *)&v113 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v121 = (char *)&v113 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v123 = (char *)&v113 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v129 = (char *)&v113 - v17;
  uint64_t v18 = *(void *)(a5[3] + 16);
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)v18, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v20 = MEMORY[0x1F4188790](v19);
  uint64_t v22 = (char *)&v113 - v21;
  uint64_t v23 = *(void *)(a3 - 8);
  uint64_t v24 = MEMORY[0x1F4188790](v20);
  uint64_t v116 = (char *)&v113 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v117 = (char *)&v113 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v137 = (char *)&v113 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v32 = (char *)&v113 - v31;
  MEMORY[0x1F4188790](v30);
  uint64_t v34 = (char *)&v113 - v33;
  int v125 = (uint64_t (*)(uint64_t, void *))a5[8];
  uint64_t v126 = a5 + 8;
  char v35 = v125(a3, a5);
  BOOL v130 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  v130(v34, (uint64_t)v138, a3);
  uint64_t v132 = v23;
  unint64_t v124 = v32;
  uint64_t v115 = v19;
  if ((v35 & 1) == 0)
  {
    uint64_t v128 = (void *)(v23 + 16);
    uint64_t v113 = v22;
    uint64_t v114 = v18;
    uint64_t v37 = a5;
    uint64_t v127 = *(void (**)(char *, uint64_t))(v23 + 8);
    v127(v34, a3);
    goto LABEL_6;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v18, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v19, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v18 + 24))(v22, a3, v18);
  uint64_t v37 = a5;
  char v38 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a5[4] + 8) + 16))(v34, v32, a3);
  uint64_t v39 = *(void (**)(char *, uint64_t))(v23 + 8);
  v39(v32, a3);
  v39(v34, a3);
  if ((v38 & 1) == 0)
  {
    uint64_t v128 = (void *)(v23 + 16);
    uint64_t v113 = v22;
    uint64_t v114 = v18;
    uint64_t v127 = v39;
LABEL_6:
    uint64_t v44 = v37;
    char v46 = v37 + 16;
    uint64_t v45 = (void (*)(char *, uint64_t, uint64_t))v37[16];
    uint64_t v47 = v138;
    uint64_t v48 = a3;
    uint64_t v49 = ((uint64_t (*)(uint64_t, void *))v45)(a3, v37);
    uint64_t v50 = v131;
    uint64_t v51 = v47;
    uint64_t v41 = v136;
    uint64_t v52 = ((uint64_t (*)(uint64_t, void *))v131[7])(v136, v131);
    unint64_t v53 = v137;
    v130(v137, (uint64_t)v51, v48);
    if (v49 < v52)
    {
      v127(v53, v48);
      uint64_t v43 = v134;
      uint64_t v42 = v135;
      uint64_t v54 = v44;
      uint64_t v55 = v48;
      uint64_t v56 = v133;
      goto LABEL_8;
    }
    uint64_t v128 = v46;
    BOOL v130 = v45;
    uint64_t v57 = v129;
    ((void (*)(uint64_t, void *))v50[8])(v41, v50);
    uint64_t v58 = v133;
    uint64_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v133 + 64);
    int v60 = v59(v41, v133);
    int v61 = v60 ^ v125(v48, v44);
    uint64_t v54 = v44;
    uint64_t v55 = v48;
    if (v61)
    {
      char v62 = v59(v41, v58);
      uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v58 + 128))(v41, v58);
      uint64_t v131 = v44;
      uint64_t v64 = ((uint64_t (*)(uint64_t, void *))v130)(v48, v44);
      if (v62)
      {
        if (v64 >= v63)
        {
          uint64_t v83 = AssociatedTypeWitness;
          uint64_t v82 = v120;
          uint64_t v41 = v136;
          uint64_t v84 = swift_getAssociatedConformanceWitness((uint64_t)v120, v136, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v85 = v118;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v84 + 8))(&qword_18162B0B8, 256, v83, v84);
          uint64_t v86 = v123;
          ((void (*)(char *, uint64_t, int **))v82[3])(v85, v41, v82);
          uint64_t v87 = v129;
          LOBYTE(v83) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v133 + 32) + 8)
                                                                           + 16))(v129, v86, v41);
          uint64_t v43 = v134;
          uint64_t v88 = *(void (**)(char *, uint64_t))(v134 + 8);
          v88(v86, v41);
          uint64_t v89 = v121;
          (*(void (**)(char *, char *, uint64_t))(v43 + 32))(v121, v87, v41);
          char v90 = v117;
          uint64_t v55 = v48;
          (*(void (**)(char *, char *, uint64_t))(v132 + 32))(v117, v137, v48);
          uint64_t v42 = v135;
          if (v83)
          {
            uint64_t v91 = v90;
            uint64_t v75 = v127;
            v127(v91, v48);
            v88(v89, v41);
          }
          else
          {
            uint64_t v107 = v89;
            uint64_t v54 = v131;
            uint64_t v108 = v124;
            ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v131[12])(v107, v41, v133, v48, v131);
            char v109 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v54[4] + 8) + 16))(v108, v90, v48);
            char v110 = v108;
            char v111 = v90;
            uint64_t v75 = v127;
            v127(v110, v48);
            v75(v111, v48);
            uint64_t v56 = v133;
            if ((v109 & 1) == 0) {
              goto LABEL_8;
            }
          }
          goto LABEL_28;
        }
        uint64_t v65 = v124;
        (*(void (**)(char *, char *, uint64_t))(v132 + 32))(v124, v137, v48);
        uint64_t v56 = v133;
        uint64_t v66 = v123;
        uint64_t v54 = v131;
        uint64_t v41 = v136;
        (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v133 + 96))(v65, v55, v131, v136, v133);
        uint64_t v67 = v129;
        char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v56 + 32) + 8) + 16))(v129, v66, v41);
        uint64_t v43 = v134;
        uint64_t v69 = v134;
        goto LABEL_20;
      }
      if (v63 >= v64)
      {
        uint64_t v92 = v114;
        uint64_t v93 = (uint64_t)v115;
        uint64_t v94 = swift_getAssociatedConformanceWitness(v114, v48, (uint64_t)v115, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v95 = v113;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v94 + 8))(&qword_18162B0B8, 256, v93, v94);
        uint64_t v96 = v124;
        (*(void (**)(char *, uint64_t, uint64_t))(v92 + 24))(v95, v48, v92);
        uint64_t v54 = v131;
        unint64_t v97 = v137;
        LODWORD(v130) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v131[4] + 8) + 40))(v137, v96, v55);
        uint64_t v98 = v132;
        int v99 = v96;
        char v100 = v127;
        v127(v99, v55);
        uint64_t v43 = v134;
        uint64_t v101 = v122;
        uint64_t v41 = v136;
        (*(void (**)(char *, char *, uint64_t))(v134 + 32))(v122, v129, v136);
        uint64_t v102 = *(void (**)(char *, char *, uint64_t))(v98 + 32);
        uint64_t v103 = v116;
        v102(v116, v97, v55);
        uint64_t v42 = v135;
        uint64_t v56 = v133;
        if ((v130 & 1) == 0)
        {
          v100(v103, v55);
          (*(void (**)(char *, uint64_t))(v43 + 8))(v101, v41);
          goto LABEL_8;
        }
        uint64_t v104 = v123;
        (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v133 + 96))(v103, v55, v54, v41, v133);
        LODWORD(v137) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v56 + 32) + 8)
                                                                           + 16))(v101, v104, v41);
        uint64_t v105 = *(void (**)(char *, uint64_t))(v43 + 8);
        unint64_t v106 = v104;
        uint64_t v42 = v135;
        v105(v106, v41);
        v105(v101, v41);
        uint64_t v75 = v100;
        if ((v137 & 1) == 0)
        {
LABEL_8:
          (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v56 + 96))(v138, v55, v54, v41, v56);
          uint64_t v40 = 0;
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v43 + 56))(v42, v40, 1, v41);
        }
LABEL_28:
        v75(v138, v55);
        uint64_t v40 = 1;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v43 + 56))(v42, v40, 1, v41);
      }
      uint64_t v54 = v131;
      uint64_t v77 = v124;
      uint64_t v41 = v136;
      uint64_t v56 = v133;
      ((void (*)(char *, uint64_t))v131[12])(v129, v136);
      uint64_t v78 = v137;
      char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v54[4] + 8) + 16))(v77, v137, v55);
      uint64_t v75 = v127;
      v127(v77, v55);
      uint64_t v76 = v78;
    }
    else
    {
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(v58 + 128))(v41, v58);
      uint64_t v71 = v137;
      uint64_t v72 = ((uint64_t (*)(uint64_t, void *))v130)(v48, v54);
      uint64_t v56 = v58;
      if (v70 >= v72)
      {
        uint64_t v79 = v124;
        (*(void (**)(char *, char *, uint64_t))(v132 + 32))(v124, v71, v55);
        uint64_t v80 = *(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v58 + 96);
        uint64_t v66 = v123;
        v80(v79, v55, v54, v41, v56);
        char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v56 + 32) + 8) + 16))(v57, v66, v41);
        uint64_t v43 = v134;
        uint64_t v69 = v134;
        uint64_t v67 = v57;
LABEL_20:
        uint64_t v81 = *(void (**)(char *, uint64_t))(v69 + 8);
        v81(v66, v41);
        v81(v67, v41);
        uint64_t v42 = v135;
        uint64_t v75 = v127;
        if ((v68 & 1) == 0) {
          goto LABEL_8;
        }
        goto LABEL_28;
      }
      uint64_t v73 = v124;
      ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v54[12])(v57, v41, v58, v55, v54);
      char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v54[4] + 8) + 16))(v73, v71, v55);
      uint64_t v75 = v127;
      v127(v73, v55);
      uint64_t v76 = v71;
    }
    v75(v76, v55);
    uint64_t v43 = v134;
    uint64_t v42 = v135;
    if ((v74 & 1) == 0) {
      goto LABEL_8;
    }
    goto LABEL_28;
  }
  v39(v138, a3);
  uint64_t v40 = 1;
  uint64_t v42 = v135;
  uint64_t v41 = v136;
  uint64_t v43 = v134;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v43 + 56))(v42, v40, 1, v41);
}

uint64_t static UnsignedInteger<>.min.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a2 + 8) + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v3, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v6 = (char *)&v9 - v5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v3, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v3 + 24))(v6, a1, v3);
}

uint64_t specialized UnsignedInteger<>.dividingFullWidth(_:)(uint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7)
{
  if (!(a6 | a7)) {
    _assertionFailure(_:_:file:line:flags:)("Precondition failed", 19, 2, 0xD000000000000010, 0x80000001816DC400, "Swift/Integers.swift", 20, 2, 0xDB6uLL, 0);
  }
  if (__PAIR128__(a3, a2) >= __PAIR128__(a7, a6)) {
    _assertionFailure(_:_:file:line:flags:)("Precondition failed", 19, 2, 0xD00000000000002ALL, 0x80000001816E29F0, "Swift/Integers.swift", 20, 2, 0xDB7uLL, 0);
  }
  unint64_t v8 = __clz(a7);
  unint64_t v9 = __clz(a6) + 64;
  if (!a7) {
    unint64_t v8 = v9;
  }
  if (a6 & (a6 - 1) | a7 & ((a6 != 0) + a7 - 1))
  {
    char v20 = v8 & 0x7F;
    char v21 = ~(_BYTE)v8;
    if ((-(int)v8 & 0x40) != 0) {
      unint64_t v22 = 0;
    }
    else {
      unint64_t v22 = a5 >> -(char)v8;
    }
    uint64_t v23 = ((2 * a5) << (v8 - 1)) | (a4 >> -(char)v8);
    if ((-(int)v8 & 0x40) != 0) {
      uint64_t v23 = a5 >> -(char)v8;
    }
    if (!v8)
    {
      uint64_t v23 = 0;
      unint64_t v22 = 0;
    }
    if ((v8 & 0x40) != 0) {
      unint64_t v24 = a6 << v8;
    }
    else {
      unint64_t v24 = (a7 << v8) | (a6 >> 1 >> ~(_BYTE)v8);
    }
    if ((v8 & 0x40) != 0) {
      unint64_t v25 = 0;
    }
    else {
      unint64_t v25 = a6 << v8;
    }
    unint64_t v26 = (a3 << v8) | (a2 >> 1 >> v21);
    uint64_t v27 = a2 << v8;
    if ((v8 & 0x40) != 0)
    {
      unint64_t v26 = a2 << v8;
      uint64_t v27 = 0;
    }
    unint64_t v28 = v22 | v26;
    uint64_t v29 = v23 | v27;
    unint64_t v30 = (a5 << v8) | (a4 >> 1 >> v21);
    unint64_t v31 = a4 << v8;
    if ((v20 & 0x40) != 0) {
      unint64_t v32 = v31;
    }
    else {
      unint64_t v32 = v30;
    }
    if ((v20 & 0x40) != 0) {
      unint64_t v33 = 0;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v25)
    {
      uint64_t v34 = specialized generateHalfDigit #1 <A>(high:low:) in UnsignedInteger<>.dividingFullWidth(_:)(v23 | v27, v28, v32, 0, v24, 0, 0xFFFFFFFFFFFFFFFFLL, 0, v25, 64);
      unsigned long long v36 = __PAIR128__(v29, v32) - __PAIR128__(v35, v34) * __PAIR128__(v24, v25);
      uint64_t result = specialized generateHalfDigit #1 <A>(high:low:) in UnsignedInteger<>.dividingFullWidth(_:)(v36, *((unint64_t *)&v36 + 1), v33, 0, v24, 0, 0xFFFFFFFFFFFFFFFFLL, 0, v25, 64);
      unint64_t v38 = ((v33 - __PAIR128__(v37, result) * __PAIR128__(v24, v25)) >> 64) + v36;
      uint64_t v39 = v38 >> v20;
      uint64_t v19 = ((2 * v38) << ~v20) | ((v33 - result * v25) >> v20);
      if ((v20 & 0x40) != 0)
      {
        uint64_t v19 = v39;
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v18 = v39;
      }
    }
    else
    {
      if (!v24) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
      }
      __udivti3();
      uint64_t result = __udivti3();
      unint64_t v40 = v32 - result * v24;
      uint64_t v18 = v40 >> v20;
      uint64_t v19 = ((2 * v40) << ~v20) | (v33 >> v20);
      if ((v20 & 0x40) != 0)
      {
        uint64_t v19 = v18;
        uint64_t v18 = 0;
      }
    }
  }
  else
  {
    char v10 = v8 + 1;
    char v11 = 127 - v8;
    char v12 = v11 & 0x7F;
    uint64_t v13 = ((2 * a5) << ~v11) | (a4 >> v11);
    uint64_t v14 = a5 >> v11;
    if ((v12 & 0x40) != 0) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v13;
    }
    if ((v10 & 0x40) != 0) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = a2 << v10;
    }
    uint64_t result = v15 | v16;
    uint64_t v18 = ((a6 != 0) + a7 - 1) & a5;
    uint64_t v19 = (a6 - 1) & a4;
  }
  *a1 = v19;
  a1[1] = v18;
  return result;
}

uint64_t specialized generateHalfDigit #1 <A>(high:low:) in UnsignedInteger<>.dividingFullWidth(_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, long long a9, char a10)
{
  if (!(a5 | a6)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  uint64_t result = __udivti3();
  unint64_t v21 = (__PAIR128__(a2, a1) - __PAIR128__(v19, result) * __PAIR128__(a6, a5)) >> 64;
  unint64_t v20 = a1 - result * a5;
  char v22 = a10 & 0x7F;
  do
  {
    if (__PAIR128__(a8, a7) >= __PAIR128__(v19, result))
    {
      unint64_t v24 = (v21 << v22) | (v20 >> 1 >> ~v22);
      uint64_t v25 = v20 << v22;
      if ((a10 & 0x40) != 0)
      {
        unint64_t v24 = v20 << v22;
        uint64_t v25 = 0;
      }
      if (__PAIR128__(v24 | a4, v25 | a3) >= __PAIR128__(v19, result) * a9) {
        break;
      }
    }
    BOOL v23 = result-- != 0;
    uint64_t v19 = v23 + v19 - 1;
    unint64_t v21 = (__PAIR128__(v21, v20) + __PAIR128__(a6, a5)) >> 64;
    v20 += a5;
  }
  while (__PAIR128__(a8, a7) >= __PAIR128__(v21, v20));
  return result;
}

void static SignedInteger._maskingAdd(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD00000000000002CLL, 0x80000001816DE830, "Swift/Integers.swift", 20, 2, 0xEDDuLL, 0);
}

void static SignedInteger._maskingSubtract(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD00000000000002CLL, 0x80000001816DE830, "Swift/Integers.swift", 20, 2, 0xEE2uLL, 0);
}

uint64_t static SignedInteger.isSigned.getter()
{
  return 1;
}

uint64_t static SignedInteger<>.min.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 - 8);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v5);
  unint64_t v9 = (char *)&v19 - v8;
  uint64_t v11 = *(void *)(*(void *)(*(void *)(v10 + 8) + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, a1, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v19 - v13;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v11, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0C8, 257, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 24))(v14, a1, v11);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 136))(v16 - 1, a1, a2);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a2 + 216))(v9, v7, a1, a2);
  uint64_t v17 = *(void (**)(char *, uint64_t))(v4 + 8);
  v17(v7, a1);
  return ((uint64_t (*)(char *, uint64_t))v17)(v9, a1);
}

uint64_t specialized SignedInteger<>.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL) {
    return 1;
  }
  if (!(a1 | a2)) {
    return (a3 | a4) == 0;
  }
  uint64_t v5 = __modti3();
  return (v5 | v6) == 0;
}

BOOL specialized SignedInteger<>.isMultiple(of:)(char a1, char a2)
{
  if (a1 == -1) {
    return 1;
  }
  if (a1) {
    return a2 % a1 == 0;
  }
  else {
    return a2 == 0;
  }
}

BOOL specialized SignedInteger<>.isMultiple(of:)(__int16 a1, __int16 a2)
{
  if (a1 == -1) {
    return 1;
  }
  if (a1) {
    return a2 % a1 == 0;
  }
  else {
    return a2 == 0;
  }
}

BOOL specialized SignedInteger<>.isMultiple(of:)(int a1, int a2)
{
  if (a1 == -1) {
    return 1;
  }
  if (a1)
  {
    if (a1 == -1 && a2 == 0x80000000) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
    }
    return a2 % a1 == 0;
  }
  else
  {
    return a2 == 0;
  }
}

BOOL specialized SignedInteger<>.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 | a1)
  {
    if (a2 == -1 && a1 == -1) {
      return 1;
    }
    Swift::tuple_partialValue__Int128_overflow_Bool v6 = _Int128.remainderReportingOverflow(dividingBy:)(*(Swift::_Int128 *)&a1);
    if (v6.overflow) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3DCuLL, 0);
    }
    Swift::UInt64 v4 = v6.partialValue.high | v6.partialValue.low;
  }
  else
  {
    Swift::UInt64 v4 = a4 | a3;
  }
  return v4 == 0;
}

uint64_t SignedInteger<>.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v136 = *(int ***)(*(void *)(v7 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v136, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v128 - v9;
  uint64_t v11 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  BOOL v130 = (char *)&v128 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v138 = (char *)&v128 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v132 = (char *)&v128 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v131 = (char *)&v128 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v128 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v142 = (char *)&v128 - v23;
  uint64_t v25 = v7 + 64;
  unint64_t v24 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  char v26 = v24(a2, v7);
  uint64_t v135 = v10;
  uint64_t v139 = v24;
  if ((v26 & 1) == 0)
  {
    uint64_t v134 = v11;
    char v34 = v24(a2, v7);
    unint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
    uint64_t v133 = a1;
    uint64_t v140 = v35;
    uint64_t v36 = v35(a2, v7);
    if (v34)
    {
      if (v36 <= 64)
      {
        uint64_t v129 = v3;
        unint64_t v40 = v136;
        uint64_t v39 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v136, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
        uint64_t v42 = v142;
        ((void (*)(char *, uint64_t, int **))v40[3])(v10, a2, v40);
        uint64_t v43 = v133;
        LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8)
                                                                          + 32))(v133, v42, a2);
        uint64_t v44 = v134;
        uint64_t v45 = *(void (**)(char *, uint64_t))(v134 + 8);
        v45(v42, a2);
        (*(void (**)(char *, uint64_t, uint64_t))(v44 + 16))(v22, v43, a2);
        unint64_t v141 = v45;
        if (v39)
        {
          uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
          v45(v22, a2);
          a1 = v133;
          uint64_t v11 = v134;
          uint64_t v4 = v129;
          goto LABEL_12;
        }
        v45(v22, a2);
        a1 = v133;
        uint64_t v11 = v134;
        uint64_t v4 = v129;
        uint64_t v54 = v139;
LABEL_27:
        if (v54(a2, v7))
        {
          uint64_t v76 = v140(a2, v7);
          uint64_t v79 = a1;
          if (v76 >= 64)
          {
            uint64_t v143 = -1;
            uint64_t v80 = v54;
            uint64_t v81 = v4;
            uint64_t v82 = v11;
            uint64_t v83 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
            unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
            uint64_t v134 = v25;
            uint64_t v85 = v142;
            v83(&v143, &type metadata for Int, v84, a2, v7);
            uint64_t v11 = v82;
            uint64_t v4 = v81;
            uint64_t v54 = v80;
            char v86 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(a1, v85, a2);
            v141(v85, a2);
            if (v86) {
              goto LABEL_37;
            }
LABEL_42:
            uint64_t v108 = v138;
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 168))(v4, v79, a2, v7);
            if (v54(a2, v7))
            {
              uint64_t v109 = v140(a2, v7);
              if (v109 < 64)
              {
LABEL_50:
                uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
                uint64_t v71 = v108;
                goto LABEL_51;
              }
            }
            else
            {
              char v112 = v54(a2, v7);
              uint64_t v109 = v140(a2, v7);
              if ((v112 & 1) == 0)
              {
                if (v109 >= 64)
                {
                  uint64_t v143 = 0;
                  uint64_t v123 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
                  unint64_t v124 = lazy protocol witness table accessor for type Int and conformance Int(v109, v110, v111);
                  int v125 = v142;
                  v123(&v143, &type metadata for Int, v124, a2, v7);
                  char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8)
                                                                           + 8))(v108, v125, a2);
                  uint64_t v126 = v141;
                  v141(v108, a2);
                  v126(v125, a2);
                  return v68 & 1;
                }
                goto LABEL_50;
              }
              if (v109 <= 64)
              {
                uint64_t v119 = v136;
                uint64_t v118 = AssociatedTypeWitness;
                uint64_t v120 = swift_getAssociatedConformanceWitness((uint64_t)v136, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                uint64_t v121 = v135;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v120 + 8))(&qword_18162B0B8, 256, v118, v120);
                uint64_t v122 = v142;
                ((void (*)(char *, uint64_t, int **))v119[3])(v121, a2, v119);
                LOBYTE(v118) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v7 + 32)
                                                                                              + 8)
                                                                                  + 32))(v108, v122, a2);
                v141(v122, a2);
                uint64_t v67 = v130;
                (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v130, v108, a2);
                if (v118) {
                  goto LABEL_22;
                }
                goto LABEL_53;
              }
            }
            uint64_t v143 = 0;
            uint64_t v113 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
            unint64_t v114 = lazy protocol witness table accessor for type Int and conformance Int(v109, v110, v111);
            uint64_t v115 = v142;
            v113(&v143, &type metadata for Int, v114, a2, v7);
            char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(v108, v115, a2);
            uint64_t v116 = v115;
            uint64_t v117 = v141;
            v141(v116, a2);
            v117(v108, a2);
            return v68 & 1;
          }
        }
        else
        {
          uint64_t v87 = a1;
          char v88 = v54(a2, v7);
          uint64_t v89 = v87;
          uint64_t v90 = v140(a2, v7);
          if (v88)
          {
            if (v90 <= 64)
            {
              uint64_t v102 = v136;
              uint64_t v101 = AssociatedTypeWitness;
              uint64_t v103 = swift_getAssociatedConformanceWitness((uint64_t)v136, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v104 = v135;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v103 + 8))(&qword_18162B0B8, 256, v101, v103);
              uint64_t v105 = v142;
              ((void (*)(char *, uint64_t, int **))v102[3])(v104, a2, v102);
              LOBYTE(v101) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8)
                                                                                 + 32))(v89, v105, a2);
              v141(v105, a2);
              unint64_t v106 = v132;
              (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v132, v89, a2);
              if (v101)
              {
                uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
                v141(v106, a2);
                uint64_t v79 = v89;
                uint64_t v54 = v139;
                if (v107 == -1) {
                  goto LABEL_37;
                }
              }
              else
              {
                v141(v106, a2);
                uint64_t v79 = v89;
                uint64_t v54 = v139;
              }
              goto LABEL_42;
            }
            uint64_t v143 = -1;
            uint64_t v93 = v4;
            uint64_t v94 = v11;
            char v95 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
            unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
            unint64_t v97 = v142;
            v95(&v143, &type metadata for Int, v96, a2, v7);
            uint64_t v11 = v94;
            uint64_t v4 = v93;
            uint64_t v79 = v87;
            char v98 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(v87, v97, a2);
            v141(v97, a2);
            uint64_t v54 = v139;
            if ((v98 & 1) == 0) {
              goto LABEL_42;
            }
LABEL_37:
            char v68 = 1;
            return v68 & 1;
          }
          uint64_t v79 = v87;
          uint64_t v54 = v139;
          if (v90 >= 64) {
            goto LABEL_42;
          }
        }
        int v99 = v142;
        (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, v79, a2);
        uint64_t v100 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
        v141(v99, a2);
        if (v100 != -1) {
          goto LABEL_42;
        }
        goto LABEL_37;
      }
    }
    else if (v36 < 64)
    {
      a1 = v133;
      uint64_t v11 = v134;
      unint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v134 + 16))(v142, v133, a2);
      uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
      unint64_t v32 = *(void (**)(char *, uint64_t))(v11 + 8);
      unint64_t v33 = v53;
      goto LABEL_11;
    }
    uint64_t v143 = 0;
    uint64_t v55 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v56 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
    uint64_t v57 = v142;
    v55(&v143, &type metadata for Int, v56, a2, v7);
    a1 = v133;
    char v50 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(v133, v57, a2);
    uint64_t v11 = v134;
    uint64_t v51 = *(void (**)(char *, uint64_t))(v134 + 8);
    uint64_t v52 = v57;
LABEL_15:
    unint64_t v141 = v51;
    v51(v52, a2);
    uint64_t v54 = v139;
    if (v50) {
      goto LABEL_16;
    }
    goto LABEL_27;
  }
  uint64_t v140 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
  uint64_t v27 = v140(a2, v7);
  if (v27 >= 64)
  {
    uint64_t v143 = 0;
    uint64_t v46 = v11;
    uint64_t v47 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    uint64_t v49 = v142;
    v47(&v143, &type metadata for Int, v48, a2, v7);
    uint64_t v11 = v46;
    uint64_t v4 = v3;
    char v50 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(a1, v49, a2);
    uint64_t v51 = *(void (**)(char *, uint64_t))(v11 + 8);
    uint64_t v52 = v49;
    uint64_t v25 = v7 + 64;
    goto LABEL_15;
  }
  unint64_t v30 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a1, a2);
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
  unint64_t v32 = *(void (**)(char *, uint64_t))(v11 + 8);
  unint64_t v33 = v30;
  uint64_t v25 = v7 + 64;
LABEL_11:
  unint64_t v141 = v32;
  v32(v33, a2);
LABEL_12:
  uint64_t v54 = v139;
  if (v31) {
    goto LABEL_27;
  }
LABEL_16:
  if (v54(a2, v7))
  {
    uint64_t v58 = v140(a2, v7);
    if (v58 >= 64) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  char v61 = v54(a2, v7);
  uint64_t v58 = v140(a2, v7);
  if (v61)
  {
    if (v58 <= 64)
    {
      uint64_t v63 = v136;
      char v62 = AssociatedTypeWitness;
      uint64_t v64 = swift_getAssociatedConformanceWitness((uint64_t)v136, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v65 = v135;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v64 + 8))(&qword_18162B0B8, 256, v62, v64);
      uint64_t v66 = v142;
      ((void (*)(char *, uint64_t, int **))v63[3])(v65, a2, v63);
      LOBYTE(v62) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8) + 32))(v4, v66, a2);
      v141(v66, a2);
      uint64_t v67 = v131;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v131, v4, a2);
      if (v62)
      {
LABEL_22:
        char v68 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7) == 0;
LABEL_54:
        v141(v67, a2);
        return v68 & 1;
      }
LABEL_53:
      char v68 = 0;
      goto LABEL_54;
    }
  }
  else if (v58 < 64)
  {
LABEL_24:
    uint64_t v69 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, v4, a2);
    uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(a2, v7);
    uint64_t v71 = v69;
LABEL_51:
    v141(v71, a2);
    char v68 = v70 == 0;
    return v68 & 1;
  }
LABEL_25:
  uint64_t v143 = 0;
  uint64_t v72 = v4;
  uint64_t v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
  unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
  uint64_t v75 = v142;
  v73(&v143, &type metadata for Int, v74, a2, v7);
  char v68 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(v72, v75, a2);
  v141(v75, a2);
  return v68 & 1;
}

uint64_t specialized SignedInteger<>.dividingFullWidth(_:)(uint64_t *a1, unint64_t a2, int64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a3;
  BOOL v11 = __CFSUB__(0, v7, a4 == 0);
  unint64_t v12 = (unsigned __int128)-(__int128)__PAIR128__(v7, a4) >> 64;
  int v13 = !v11;
  uint64_t v14 = v13 ^ 1u;
  int64_t v15 = ~a3;
  BOOL v11 = __CFADD__(v14, ~a2);
  unint64_t v16 = v14 + ~a2;
  if (v11) {
    int64_t v15 = -a3;
  }
  if (a3 < 0)
  {
    a4 = -(uint64_t)a4;
    a5 = v12;
    a2 = v16;
    a3 = v15;
  }
  unsigned long long v17 = __PAIR128__(a7 ^ (unint64_t)(a7 >> 63), a6 ^ (unint64_t)(a7 >> 63))
      - __PAIR128__(a7 >> 63, a7 >> 63);
  uint64_t result = specialized UnsignedInteger<>.dividingFullWidth(_:)((uint64_t *)&v24, a2, a3, a4, a5, v17, *((unint64_t *)&v17 + 1));
  if (((a7 ^ v9) & 0x8000000000000000) == 0)
  {
    if ((v19 & 0x8000000000000000) == 0)
    {
      uint64_t v21 = v25;
      if ((v25 & 0x8000000000000000) == 0) {
        goto LABEL_11;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000051, 0x80000001816E2A20, "Swift/Int128.swift", 18, 2, 0x99uLL, 0);
  }
  if (__PAIR128__(v19, result) >= __PAIR128__(0x8000000000000000, 1)) {
    _assertionFailure(_:_:file:line:flags:)("Precondition failed", 19, 2, 0xD00000000000001ELL, 0x80000001816E2A80, "Swift/Integers.swift", 20, 2, 0xEBEuLL, 0);
  }
  uint64_t result = -result;
  uint64_t v21 = v25;
  if (v25 < 0) {
    goto LABEL_16;
  }
LABEL_11:
  uint64_t v22 = v24;
  uint64_t v23 = (unsigned __int128)-(__int128)__PAIR128__(v20, v24) >> 64;
  if (v9 < 0)
  {
    uint64_t v22 = -(uint64_t)v24;
    uint64_t v21 = v23;
  }
  *a1 = v22;
  a1[1] = v21;
  return result;
}

uint64_t static SignedInteger<>._maskingAdd(_:_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 80))(a2);
}

uint64_t static SignedInteger<>._maskingSubtract(_:_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 88))(a2);
}

uint64_t (*JoinedSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

atomic_ullong *JoinedSequence._separator.getter(uint64_t a1)
{
  return swift_retain(*(atomic_ullong **)(v1 + *(int *)(a1 + 44)));
}

uint64_t JoinedSequence._separator.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a2 + 44);
  uint64_t result = swift_release(*(void *)(v2 + v4));
  *(void *)(v2 + v4) = a1;
  return result;
}

uint64_t (*JoinedSequence._separator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Class *JoinedSequence.init<A>(base:separator:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a7, a1);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
  uint64_t result = type metadata accessor for JoinedSequence(0, a2, a4, a6);
  *(void *)(a7 + *((int *)result + 11)) = v13;
  return result;
}

void JoinedSequence.Iterator._JoinIteratorState.hash(into:)(uint64_t a1, unsigned __int8 a2)
{
}

Swift::Int JoinedSequence.Iterator._JoinIteratorState.hashValue.getter(unsigned __int8 a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance JoinedSequence<A>.Iterator._JoinIteratorState()
{
  return JoinedSequence.Iterator._JoinIteratorState.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance JoinedSequence<A>.Iterator._JoinIteratorState(uint64_t a1)
{
  JoinedSequence.Iterator._JoinIteratorState.hash(into:)(a1, *v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance JoinedSequence<A>.Iterator._JoinIteratorState(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v3[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v3[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v4 = 0u;
  long long v5 = 0u;
  JoinedSequence.Iterator._JoinIteratorState.hash(into:)((uint64_t)v3, *v1);
  return Hasher._finalize()();
}

uint64_t JoinedSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t JoinedSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*JoinedSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.Iterator._inner.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 44);
  long long v5 = *(int ***)(a1 + 32);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v7 = swift_getAssociatedTypeWitness(255, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)v7, v8, v9);
  BOOL v11 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v10 - 1) + 2);

  return v11(a2, v4, v10);
}

uint64_t FlattenSequence.Iterator._inner.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 44);
  long long v5 = *(int ***)(a2 + 32);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v7 = swift_getAssociatedTypeWitness(255, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = type metadata accessor for Optional(0, (uint64_t)v7, v8, v9);
  BOOL v11 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v10 - 1) + 5);

  return v11(v4, a1, v10);
}

uint64_t (*JoinedSequence.Iterator._inner.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

atomic_ullong *JoinedSequence.Iterator._separatorData.getter(uint64_t a1)
{
  return swift_retain(*(atomic_ullong **)(v1 + *(int *)(a1 + 48)));
}

uint64_t JoinedSequence.Iterator._separatorData.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a2 + 48);
  uint64_t result = swift_release(*(void *)(v2 + v4));
  *(void *)(v2 + v4) = a1;
  return result;
}

uint64_t (*JoinedSequence.Iterator._separatorData.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

atomic_ullong *JoinedSequence.Iterator._separator.getter(uint64_t a1)
{
  return swift_retain(*(atomic_ullong **)(v1 + *(int *)(a1 + 52)));
}

uint64_t JoinedSequence.Iterator._separator.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v6 = (uint64_t *)(v3 + *(int *)(a3 + 52));
  uint64_t result = swift_release(*v6);
  *Swift::tuple_partialValue__Int128_overflow_Bool v6 = a1;
  v6[1] = a2;
  return result;
}

uint64_t (*JoinedSequence.Iterator._separator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t JoinedSequence.Iterator._state.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 56));
}

uint64_t JoinedSequence.Iterator._state.setter(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(v2 + *(int *)(a2 + 56)) = result;
  return result;
}

uint64_t (*JoinedSequence.Iterator._state.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t JoinedSequence.Iterator.init<A>(base:separator:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, int **a4@<X4>, uint64_t a5@<X5>, int **a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v13 = (int *)type metadata accessor for JoinedSequence.Iterator(0, a2, (uint64_t)a4, (uint64_t)a6);
  uint64_t v14 = a7 + v13[11];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v16 = swift_getAssociatedTypeWitness(0, a6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v16 - 1) + 56))(v14, 1, 1, v16);
  unsigned long long v17 = (void *)(a7 + v13[13]);
  *unsigned long long v17 = 0;
  v17[1] = 0;
  *(unsigned char *)(a7 + v13[14]) = 0;
  uint64_t v18 = swift_getAssociatedTypeWitness(0, a4, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v18 - 1) + 32))(a7, a1, v18);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
  *(void *)(a7 + v13[12]) = result;
  return result;
}

uint64_t JoinedSequence.Iterator.next()@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v4 = a1;
  uint64_t v106 = a2;
  long long v5 = (int **)*((void *)a1 + 3);
  Swift::tuple_partialValue__Int128_overflow_Bool v6 = (int **)*((void *)a1 + 4);
  uint64_t v121 = *((void *)a1 + 2);
  uint64_t v122 = v5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v121, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = swift_getAssociatedTypeWitness(255, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v117 = type metadata accessor for Optional(0, (uint64_t)v8, v9, v10);
  uint64_t v11 = (uint64_t)*(v117 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v117);
  uint64_t v111 = (char *)&v90 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v105 = (char *)&v90 - v14;
  int64_t v15 = swift_getAssociatedTypeWitness(255, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  unint64_t v114 = type metadata accessor for Optional(0, (uint64_t)v15, v16, v17);
  uint64_t v18 = (uint64_t)*(v114 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v114);
  uint64_t v102 = (char *)&v90 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  char v98 = (char *)&v90 - v22;
  MEMORY[0x1F4188790](v21);
  uint64_t v110 = (char *)&v90 - v23;
  uint64_t v104 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v24, v25);
  uint64_t v26 = MEMORY[0x1F4188790](v104);
  uint64_t v101 = (char *)&v90 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v115 = (char *)&v90 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v109 = (char *)&v90 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v30);
  uint64_t v108 = (char *)&v90 - v32;
  uint64_t v123 = v8 - 8;
  unint64_t v124 = v8;
  uint64_t v97 = v11;
  unint64_t v33 = (void (**)(char *, Class *))(v11 + 8);
  uint64_t v34 = v4[14];
  uint64_t v118 = v6;
  uint64_t v119 = (unsigned int (**)(char *, uint64_t, const char *))(v35 + 48);
  uint64_t v107 = (void (**)(char *, char *, const char *))(v35 + 32);
  uint64_t v36 = v6 + 4;
  uint64_t v37 = (uint64_t)v15;
  uint64_t v116 = v15 - 8;
  char v112 = v36;
  uint64_t v113 = (void (**)(uint64_t, char *, Class *))(v18 + 40);
  uint64_t v103 = (void (**)(char *, Class *))(v38 + 8);
  uint64_t v100 = (void (**)(char *, uint64_t, Class *))(v18 + 16);
  int v99 = (void (**)(char *, Class *))(v18 + 8);
  uint64_t v120 = v34;
  while (2)
  {
    char v39 = *(unsigned char *)(v3 + v34);
LABEL_6:
    switch(v39)
    {
      case 1:
        uint64_t v58 = (char *)(v3 + v4[11]);
        uint64_t v93 = *(void *)(v37 - 8);
        uint64_t v59 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v93 + 48);
        uint64_t v95 = v93 + 48;
        uint64_t v94 = v59;
        if (v59(v58, 1, v37) == 1)
        {
          unint64_t v89 = 103;
LABEL_28:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Join.swift", 16, 2, v89, 0);
        }
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v118, (uint64_t)AssociatedTypeWitness, v37, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
        char v61 = *(void (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 16);
        char v62 = v105;
        uint64_t v92 = v58;
        v61(v37, AssociatedConformanceWitness);
        uint64_t v63 = *((void *)v124 - 1);
        if ((*(unsigned int (**)(char *, uint64_t))(v63 + 48))(v62, 1) != 1) {
          return (*(uint64_t (**)(uint64_t, char *, Class *))(v97 + 32))(v106, v105, v117);
        }
        uint64_t v91 = v63;
        uint64_t v96 = v37;
        uint64_t v64 = v4;
        uint64_t v66 = v121;
        uint64_t v65 = v122;
        uint64_t v67 = swift_getAssociatedTypeWitness(255, v122, v121, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
        uint64_t v68 = swift_getAssociatedConformanceWitness((uint64_t)v65, v66, (uint64_t)v67, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
        uint64_t v69 = *(void (**)(uint64_t *, uint64_t))(v68 + 16);
        uint64_t v70 = swift_checkMetadataState(0, (uint64_t)v67);
        uint64_t v71 = v68;
        uint64_t v72 = v101;
        v69(v70, v71);
        if ((*v119)(v72, 1, AssociatedTypeWitness) == 1)
        {
          (*v103)(v72, v104);
          uint64_t v73 = 1;
          uint64_t v4 = v64;
          uint64_t v74 = v96;
          uint64_t v75 = v98;
        }
        else
        {
          uint64_t v75 = v98;
          ((void (*)(const char *))v118[4])(AssociatedTypeWitness);
          uint64_t v73 = 0;
          uint64_t v4 = v64;
          uint64_t v74 = v96;
        }
        uint64_t v76 = v92;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v93 + 56))(v75, v73, 1, v74);
        uint64_t v77 = v75;
        uint64_t v78 = v114;
        (*v113)((uint64_t)v76, v77, v114);
        uint64_t v79 = v102;
        (*v100)(v102, (uint64_t)v76, v78);
        LODWORD(v76) = v94(v79, 1, v74);
        (*v99)(v79, v78);
        if (v76 == 1)
        {
          (*v33)(v105, v117);
          *(unsigned char *)(v3 + v120) = 3;
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(v91 + 56))(v106, 1, 1, v124);
        }
        uint64_t v80 = *(void *)(v3 + v4[12]);
        uint64_t v81 = *v33;
        uint64_t v34 = v120;
        if (*(void *)(v80 + 16))
        {
          swift_retain(*(atomic_ullong **)(v3 + v4[12]));
          v81(v105, v117);
          uint64_t v82 = (uint64_t *)(v3 + v4[13]);
          swift_release(*v82);
          uint64_t *v82 = v80;
          v82[1] = 0;
          *(unsigned char *)(v3 + v34) = 2;
        }
        else
        {
          v81(v105, v117);
        }
        uint64_t v37 = v96;
        continue;
      case 2:
        unint64_t v53 = (uint64_t *)(v3 + v4[13]);
        uint64_t v54 = *v53;
        if (!*v53)
        {
          unint64_t v89 = 118;
          goto LABEL_28;
        }
        unint64_t v55 = v53[1];
        unint64_t v56 = *(void *)(v54 + 16);
        if (v55 != v56)
        {
          if (v55 >= v56) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
          }
          unint64_t v84 = v124;
          uint64_t v85 = *((void *)v124 - 1);
          uint64_t v86 = v85;
          unint64_t v87 = v54
              + ((*(unsigned __int8 *)(v86 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v86 + 80))
              + *(void *)(v85 + 72) * v55;
          v53[1] = v55 + 1;
          char v88 = v111;
          (*(void (**)(char *, unint64_t, const char *))(v85 + 16))(v111, v87, v84);
          (*(void (**)(char *, void, uint64_t, const char *))(v86 + 56))(v88, 0, 1, v84);
          return (*(uint64_t (**)(uint64_t, char *, Class *))(v97 + 32))(v106, v88, v117);
        }
        uint64_t v57 = v111;
        (*(void (**)(char *, uint64_t, uint64_t))(*((void *)v124 - 1) + 56))(v111, 1, 1);
        (*v33)(v57, v117);
        goto LABEL_5;
      case 3:
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)v124 - 1) + 56))(v106, 1, 1);
      default:
        uint64_t v40 = v37;
        uint64_t v41 = v4;
        uint64_t v43 = v121;
        uint64_t v42 = v122;
        uint64_t v44 = swift_getAssociatedTypeWitness(255, v122, v121, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
        uint64_t v45 = swift_getAssociatedConformanceWitness((uint64_t)v42, v43, (uint64_t)v44, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
        uint64_t v46 = *(void (**)(uint64_t *, uint64_t))(v45 + 16);
        uint64_t v47 = swift_checkMetadataState(0, (uint64_t)v44);
        uint64_t v48 = v45;
        uint64_t v49 = v115;
        v46(v47, v48);
        if ((*v119)(v49, 1, AssociatedTypeWitness) != 1)
        {
          char v50 = v108;
          uint64_t v51 = *v107;
          (*v107)(v108, v49, AssociatedTypeWitness);
          v51(v109, v50, AssociatedTypeWitness);
          uint64_t v52 = v110;
          ((void (*)(const char *))v118[4])(AssociatedTypeWitness);
          uint64_t v37 = v40;
          (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v40 - 8) + 56))(v52, 0, 1, v40);
          uint64_t v4 = v41;
          (*v113)(v3 + v41[11], v52, v114);
          uint64_t v34 = v120;
LABEL_5:
          char v39 = 1;
          *(unsigned char *)(v3 + v34) = 1;
          goto LABEL_6;
        }
        (*v103)(v49, v104);
        *(unsigned char *)(v3 + v120) = 3;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)v124 - 1) + 56))(v106, 1, 1);
    }
  }
}

uint64_t JoinedSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 32))((char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), v2, v5);
  uint64_t v8 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t))(v8 + 32))(v5, v8);
  uint64_t v9 = *(void *)(v2 + *(int *)(a1 + 44));
  uint64_t v10 = *(int ***)(a1 + 32);
  uint64_t v11 = (int *)type metadata accessor for JoinedSequence.Iterator(0, v5, v8, (uint64_t)v10);
  uint64_t v12 = a2 + v11[11];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v8, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v14 = swift_getAssociatedTypeWitness(0, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v14 - 1) + 56))(v12, 1, 1, v14);
  uint64_t v16 = (void *)(a2 + v11[13]);
  *uint64_t v16 = 0;
  v16[1] = 0;
  *(unsigned char *)(a2 + v11[14]) = 0;
  *(void *)(a2 + v11[12]) = v9;
  return result;
}

__objc2_class **JoinedSequence._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(int ***)(a1 + 24);
  uint64_t v76 = v2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v73 = (char *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v5 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v64 = (char *)v62 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v63 = (char *)v62 - v8;
  MEMORY[0x1F4188790](v7);
  uint64_t v70 = (char *)v62 - v9;
  uint64_t v12 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v67 = (uint64_t)*(v12 - 1);
  uint64_t v68 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  int64_t v15 = (char *)v62 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v66 = (char *)v62 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)v62 - v19;
  uint64_t v21 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)v62 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v79 = swift_getAssociatedTypeWitness(0, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v71 = *((void *)v79 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](v79);
  uint64_t v26 = (char *)v62 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v24);
  uint64_t v77 = *(int ***)(a1 + 32);
  uint64_t v78 = (char *)v62 - v27;
  uint64_t v69 = swift_getAssociatedTypeWitness(0, v77, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v81 = &_swiftEmptyArrayStorage;
  uint64_t v28 = a1;
  uint64_t v29 = *(atomic_ullong **)(v72 + *(int *)(a1 + 44));
  atomic_ullong v30 = v29[2];
  (*(void (**)(char *))(v21 + 16))(v23);
  uint64_t v31 = v76[4];
  uint64_t v32 = (int ***)(v73 + 48);
  if (v30)
  {
    uint64_t v33 = (uint64_t)v76;
    ((void (*)(uint64_t, int **))v31)(v3, v76);
    uint64_t v34 = v33;
    uint64_t v35 = v79;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v34, v3, (uint64_t)v79, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v37 = v66;
    uint64_t v78 = *(char **)(AssociatedConformanceWitness + 16);
    v62[1] = AssociatedConformanceWitness + 16;
    ((void (*)(const char *, uint64_t))v78)(v35, AssociatedConformanceWitness);
    uint64_t v76 = *v32;
    if (((unsigned int (*)(char *, uint64_t, const char *))v76)(v37, 1, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, const char *))(v71 + 8))(v26, v35);
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8))(v72, v28);
      (*(void (**)(char *))(v67 + 8))(v37);
    }
    else
    {
      uint64_t v65 = v28;
      uint64_t v74 = v32;
      uint64_t v75 = (void (*)(const char *))AssociatedConformanceWitness;
      char v50 = (void (*)(char *, char *, const char *))*((void *)v73 + 4);
      uint64_t v51 = v63;
      v50(v63, v37, AssociatedTypeWitness);
      uint64_t v52 = v26;
      unint64_t v53 = v70;
      v50(v70, v51, AssociatedTypeWitness);
      unint64_t v56 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v69, v54, v55);
      ContiguousArray.append<A>(contentsOf:)((void (*)(void, void, void))v53, (uint64_t)v56, (uint64_t)AssociatedTypeWitness, (uint64_t)v77);
      uint64_t v73 = v52;
      ((void (*)(const char *, void (*)(const char *)))v78)(v79, v75);
      int v57 = ((uint64_t (*)(char *, uint64_t, const char *))v76)(v15, 1, AssociatedTypeWitness);
      uint64_t v58 = v64;
      if (v57 != 1)
      {
        do
        {
          v50(v58, v15, AssociatedTypeWitness);
          uint64_t v80 = v29;
          swift_retain(v29);
          uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v56, v59);
          ContiguousArray.append<A>(contentsOf:)((void (*)(void, void, void))&v80, (uint64_t)v56, (uint64_t)v56, WitnessTable);
          v50(v53, v58, AssociatedTypeWitness);
          ContiguousArray.append<A>(contentsOf:)((void (*)(void, void, void))v53, (uint64_t)v56, (uint64_t)AssociatedTypeWitness, (uint64_t)v77);
          ((void (*)(const char *, void (*)(const char *)))v78)(v79, v75);
        }
        while (((unsigned int (*)(char *, uint64_t, const char *))v76)(v15, 1, AssociatedTypeWitness) != 1);
      }
      (*(void (**)(char *, const char *))(v71 + 8))(v73, v79);
      (*(void (**)(uint64_t))(*(void *)(v65 - 8) + 8))(v72);
      (*(void (**)(char *))(v67 + 8))(v15);
    }
  }
  else
  {
    uint64_t v65 = v28;
    uint64_t v38 = (uint64_t)v76;
    ((void (*)(uint64_t, int **))v31)(v3, v76);
    char v39 = v79;
    uint64_t v40 = swift_getAssociatedConformanceWitness(v38, v3, (uint64_t)v79, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v75 = *(void (**)(const char *))(v40 + 16);
    uint64_t v76 = (int **)v40;
    uint64_t v74 = (int ***)(v40 + 16);
    v75(v39);
    uint64_t v41 = *v32;
    int v42 = ((uint64_t (*)(char *, uint64_t, const char *))v41)(v20, 1, AssociatedTypeWitness);
    uint64_t v43 = v77;
    uint64_t v44 = v69;
    uint64_t v45 = (void (*)(void, void, void))v70;
    if (v42 != 1)
    {
      uint64_t v46 = (void (*)(void, char *, const char *))*((void *)v73 + 4);
      do
      {
        v46(v45, v20, AssociatedTypeWitness);
        uint64_t v49 = type metadata accessor for ContiguousArray(0, (uint64_t)v44, v47, v48);
        ContiguousArray.append<A>(contentsOf:)(v45, (uint64_t)v49, (uint64_t)AssociatedTypeWitness, (uint64_t)v43);
        ((void (*)(const char *, int **))v75)(v79, v76);
      }
      while (((unsigned int (*)(char *, uint64_t, const char *))v41)(v20, 1, AssociatedTypeWitness) != 1);
    }
    (*(void (**)(char *, const char *))(v71 + 8))(v78, v79);
    (*(void (**)(uint64_t))(*(void *)(v65 - 8) + 8))(v72);
  }
  return v81;
}

Class *Sequence<>.joined<A>(separator:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *))(v15 + 16))((char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a7, v7, a2);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
  uint64_t result = type metadata accessor for JoinedSequence(0, a2, a4, a6);
  *(void *)(a7 + *((int *)result + 11)) = v16;
  return result;
}

uint64_t static AnyKeyPath.rootType.getter()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t static AnyKeyPath.valueType.getter()
{
  (*(void (**)(void))(v0 + 120))();
  return v1;
}

unint64_t AnyKeyPath._kvcKeyPathString.getter()
{
  unint64_t result = *(void *)(v0 + 16);
  if (result)
  {
    uint64_t v2 = -(uint64_t)result;
    if (__OFSUB__(0, result))
    {
      __break(1u);
    }
    else
    {
      BOOL v3 = __OFSUB__(v2, 1);
      uint64_t v4 = v2 - 1;
      if (!v3)
      {
        if (v4 < 0) {
          return specialized String.init(validatingUTF8:)(result);
        }
        else {
          return 0;
        }
      }
    }
    __break(1u);
  }
  return result;
}

void static AnyKeyPath._rootAndValueType.getter()
{
}

void *static AnyKeyPath._create(capacityInBytes:initializedBy:)(uint64_t a1, void (*a2)(void *, char *))
{
  uint64_t v5 = a1 + 3;
  if (a1 >= 0) {
    uint64_t v5 = a1;
  }
  uint64_t v6 = swift_allocObject((unint64_t *)v2, ((*(unsigned int *)(v2 + 48) + 3) & 0x1FFFFFFFCLL) + (v5 & 0xFFFFFFFFFFFFFFFCLL), *(unsigned __int16 *)(v2 + 52) | 3);
  v6[2] = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  uint64_t v7 = v6;
  a2(v6 + 3, (char *)v6 + a1 + 24);
  return v7;
}

unint64_t specialized AnyKeyPath.withBuffer<A>(_:)(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if ((((_BYTE)a1 + 24) & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  uint64_t v4 = v3;
  LODWORD(v6) = *(_DWORD *)(a1 + 24);
  BOOL v167 = (int)v6 < 0;
  BOOL v168 = (v6 & 0x40000000) != 0;
  v6 &= 0xFFFFFFuLL;
  uint64_t v165 = a1 + 32;
  uint64_t v166 = a1 + 32 + v6;
  if (v6)
  {
    uint64_t v161 = v3;
    uint64_t v162 = *(uint64_t (**)(void))(a3 + 120);
    uint64_t v7 = (Class *)v162();
    while (1)
    {
      uint64_t v10 = (uint64_t *)v7;
      uint64_t v12 = KeyPathBuffer.next()();
      uint64_t v14 = v13;
      uint64_t v16 = v15;
      uint64_t v17 = v11;
      if (v11)
      {
        uint64_t v7 = v11;
      }
      else
      {
        v162();
        uint64_t v7 = v18;
      }
      RawKeyPathComponent.value.getter(v12, v14, v16, (uint64_t *)v169);
      outlined init with take of KeyPathComponent(v169, (uint64_t)&v178);
      if (v179 >> 61 != 5
        || ((uint64_t v19 = v181 | v182 | v183, v179 != 0xA000000000000000) || v19 | v178 | v184 | v180)
        && ((uint64_t v20 = v19 | v180, v184) || v179 != 0xA000000000000000 || v178 != 1 || v20)
        && (v184 || v179 != 0xA000000000000000 || v178 != 2 || v20))
      {
        unint64_t v21 = *a2;
        unint64_t v22 = a2[1];
        uint64_t v23 = HIBYTE(v22) & 0xF;
        if ((v22 & 0x2000000000000000) == 0) {
          uint64_t v23 = *a2 & 0xFFFFFFFFFFFFLL;
        }
        if (v23 || (v21 & ~v22 & 0x2000000000000000) != 0)
        {
          if ((v22 & 0x2000000000000000) != 0)
          {
            unint64_t v24 = specialized _SmallString.init(_:appending:)(v21, v22, 0x2EuLL, 0xE100000000000000);
            if ((v26 & 1) == 0)
            {
              unint64_t v27 = v24;
              unint64_t v28 = v25;
              swift_bridgeObjectRelease(0xE100000000000000);
              swift_bridgeObjectRelease(a2[1]);
              *a2 = v27;
              a2[1] = v28;
              goto LABEL_32;
            }
          }
          _StringGuts.append(_:)(46, 0xE100000000000000, 0, 1);
          uint64_t v29 = 0xE100000000000000;
        }
        else
        {
          *a2 = 46;
          a2[1] = 0xE100000000000000;
          uint64_t v29 = v22;
        }
        swift_bridgeObjectRelease(v29);
      }
LABEL_32:
      RawKeyPathComponent.value.getter(v12, v14, v16, (uint64_t *)v170);
      outlined init with take of KeyPathComponent(v170, (uint64_t)&v171);
      if ((v172 >> 61) - 2 < 3)
      {
        v172 &= 0x1FFFFFFFFFFFFFFFuLL;
        atomic_ullong v30 = (swift::SymbolInfo *)ComputedAccessorsPtr.getter<A, B>()(v173, (uint64_t)v10, (uint64_t)v7);
        uint64_t v31 = swift_keyPath_copySymbolName(v30);
        if (v31) {
          swift_keyPathSourceString(v31);
        }
        uint64_t v60 = specialized static String._createEmpty(withInitialCapacity:)(18);
        unint64_t v62 = (unint64_t)v61;
        __s._uint64_t countAndFlagsBits = v60;
        __s._object = v61;
        Swift::String v63 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("<computed ", 0xAuLL, 1);
        uint64_t v64 = HIBYTE(v62) & 0xF;
        if ((v62 & 0x2000000000000000) == 0) {
          uint64_t v64 = v60 & 0xFFFFFFFFFFFFLL;
        }
        if (!v64 && (v60 & ~v62 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v62);
          Swift::String __s = v63;
          goto LABEL_94;
        }
        if ((v62 & 0x2000000000000000) != 0)
        {
          if (((uint64_t)v63._object & 0x2000000000000000) != 0)
          {
            unint64_t v76 = specialized _SmallString.init(_:appending:)(v60, v62, v63._countAndFlagsBits, (unint64_t)v63._object);
            if (v78) {
              goto LABEL_92;
            }
            uint64_t v79 = v76;
            uint64_t v80 = v77;
            swift_bridgeObjectRelease(v62);
            swift_bridgeObjectRelease((uint64_t)v63._object);
            __s._uint64_t countAndFlagsBits = v79;
            __s._object = v80;
            goto LABEL_94;
          }
        }
        else if (((uint64_t)v63._object & 0x2000000000000000) != 0)
        {
LABEL_92:
          uint64_t v65 = ((unint64_t)v63._object >> 56) & 0xF;
LABEL_93:
          _StringGuts.append(_:)(v63._countAndFlagsBits, (unint64_t)v63._object, 0, v65);
          swift_bridgeObjectRelease((uint64_t)v63._object);
LABEL_94:
          unint64_t v185 = v30;
          _print_unlocked<A, B>(_:_:)((uint64_t)&v185, (uint64_t)&__s, (Class *)&type metadata for UnsafeRawPointer, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
          object = __s._object;
          unint64_t v82 = ((unint64_t)__s._object >> 56) & 0xF;
          if (((uint64_t)__s._object & 0x2000000000000000) == 0) {
            unint64_t v82 = __s._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
          }
          if (v82 || (__s._countAndFlagsBits & ~(uint64_t)__s._object & 0x2000000000000000) != 0)
          {
            if (((uint64_t)__s._object & 0x2000000000000000) == 0
              || (unint64_t v83 = specialized _SmallString.init(_:appending:)(__s._countAndFlagsBits, (unint64_t)__s._object, 0x2820uLL, 0xE200000000000000), (v85 & 1) != 0))
            {
              _StringGuts.append(_:)(10272, 0xE200000000000000, 0, 2);
              swift_bridgeObjectRelease(0xE200000000000000);
            }
            else
            {
              uint64_t v86 = v83;
              unint64_t v87 = v84;
              swift_bridgeObjectRelease((uint64_t)object);
              swift_bridgeObjectRelease(0xE200000000000000);
              __s._uint64_t countAndFlagsBits = v86;
              __s._object = v87;
            }
          }
          else
          {
            swift_bridgeObjectRelease((uint64_t)__s._object);
            __s._uint64_t countAndFlagsBits = 10272;
            __s._object = (void *)0xE200000000000000;
          }
          TypeName = (uint64_t *)swift_getTypeName(v7, 0);
          if (v89 < 0) {
            goto LABEL_197;
          }
          uint64_t v90 = (uint8x16_t *)TypeName;
          int64_t v91 = v89;
          int64_t v92 = validateUTF8(_:)(TypeName, v89);
          if (v94) {
            unint64_t v95 = repairUTF8(_:firstKnownBrokenRange:)(v90->i8, v91, v92, v93);
          }
          else {
            unint64_t v95 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v90, v91, v92 & 1);
          }
          uint64_t countAndFlagsBits = v95;
          unint64_t v98 = v96;
          int v99 = __s._object;
          unint64_t v100 = ((unint64_t)__s._object >> 56) & 0xF;
          if (((uint64_t)__s._object & 0x2000000000000000) == 0) {
            unint64_t v100 = __s._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
          }
          if (!v100 && (__s._countAndFlagsBits & ~(uint64_t)__s._object & 0x2000000000000000) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)__s._object);
            __s._uint64_t countAndFlagsBits = countAndFlagsBits;
            __s._object = (void *)v98;
            goto LABEL_119;
          }
          if (((uint64_t)__s._object & 0x2000000000000000) != 0)
          {
            if ((v96 & 0x2000000000000000) != 0)
            {
              unint64_t v102 = specialized _SmallString.init(_:appending:)(__s._countAndFlagsBits, (unint64_t)__s._object, v95, v96);
              if (v104) {
                goto LABEL_117;
              }
              uint64_t v105 = v102;
              uint64_t v106 = v103;
              swift_bridgeObjectRelease((uint64_t)v99);
              swift_bridgeObjectRelease(v98);
              __s._uint64_t countAndFlagsBits = v105;
              __s._object = v106;
              unint64_t v98 = (unint64_t)v106;
              uint64_t countAndFlagsBits = v105;
              goto LABEL_119;
            }
          }
          else if ((v96 & 0x2000000000000000) != 0)
          {
LABEL_117:
            uint64_t v101 = HIBYTE(v98) & 0xF;
LABEL_118:
            _StringGuts.append(_:)(countAndFlagsBits, v98, 0, v101);
            swift_bridgeObjectRelease(v98);
            uint64_t countAndFlagsBits = __s._countAndFlagsBits;
            unint64_t v98 = (unint64_t)__s._object;
LABEL_119:
            uint64_t v107 = HIBYTE(v98) & 0xF;
            if ((v98 & 0x2000000000000000) == 0) {
              uint64_t v107 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (v107 || (countAndFlagsBits & ~v98 & 0x2000000000000000) != 0)
            {
              if ((v98 & 0x2000000000000000) == 0
                || (unint64_t v108 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v98, 0x3E29uLL, 0xE200000000000000), (v110 & 1) != 0))
              {
                _StringGuts.append(_:)(15913, 0xE200000000000000, 0, 2);
                swift_bridgeObjectRelease(0xE200000000000000);
                uint64_t v111 = __s._countAndFlagsBits;
                unint64_t v112 = (unint64_t)__s._object;
              }
              else
              {
                uint64_t v111 = v108;
                unint64_t v112 = v109;
                swift_bridgeObjectRelease(v98);
                swift_bridgeObjectRelease(0xE200000000000000);
              }
            }
            else
            {
              swift_bridgeObjectRelease(v98);
              unint64_t v112 = 0xE200000000000000;
              uint64_t v111 = 15913;
            }
            unint64_t v113 = *a2;
            unint64_t v54 = a2[1];
            uint64_t v114 = HIBYTE(v54) & 0xF;
            if ((v54 & 0x2000000000000000) == 0) {
              uint64_t v114 = *a2 & 0xFFFFFFFFFFFFLL;
            }
            if (!v114 && (v113 & ~v54 & 0x2000000000000000) == 0)
            {
              *a2 = v111;
              a2[1] = v112;
              goto LABEL_191;
            }
            if ((v54 & 0x2000000000000000) != 0)
            {
              if ((v112 & 0x2000000000000000) == 0) {
                goto LABEL_4;
              }
              unint64_t v115 = specialized _SmallString.init(_:appending:)(v113, v54, v111, v112);
              if ((v117 & 1) == 0)
              {
                unint64_t v118 = v115;
                unint64_t v119 = v116;
                swift_bridgeObjectRelease(v112);
                swift_bridgeObjectRelease(a2[1]);
                *a2 = v118;
                a2[1] = v119;
                goto LABEL_8;
              }
LABEL_137:
              uint64_t v8 = HIBYTE(v112) & 0xF;
            }
            else
            {
              if ((v112 & 0x2000000000000000) != 0) {
                goto LABEL_137;
              }
LABEL_4:
              uint64_t v8 = v111 & 0xFFFFFFFFFFFFLL;
            }
            _StringGuts.append(_:)(v111, v112, 0, v8);
            goto LABEL_6;
          }
          uint64_t v101 = v95 & 0xFFFFFFFFFFFFLL;
          goto LABEL_118;
        }
        uint64_t v65 = v63._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        goto LABEL_93;
      }
      uint64_t v32 = v171;
      if ((v172 >> 61) >= 2)
      {
        uint64_t v51 = v174 | v173;
        uint64_t v52 = v176 | v175;
        if ((v172 != 0xA000000000000000 || v52 | v171 | v177 | v51)
          && v172 == 0xA000000000000000
          && v171 == 1
          && !(v52 | v51 | v177))
        {
          unint64_t v70 = *a2;
          unint64_t v54 = a2[1];
          uint64_t v71 = HIBYTE(v54) & 0xF;
          if ((v54 & 0x2000000000000000) == 0) {
            uint64_t v71 = *a2 & 0xFFFFFFFFFFFFLL;
          }
          if (v71 || (v70 & ~v54 & 0x2000000000000000) != 0)
          {
            if ((v54 & 0x2000000000000000) != 0)
            {
              unint64_t v56 = specialized _SmallString.init(_:appending:)(v70, v54, 0x21uLL, 0xE100000000000000);
              if ((v72 & 1) == 0) {
                goto LABEL_86;
              }
            }
            uint64_t v59 = 33;
            goto LABEL_182;
          }
          uint64_t v156 = 33;
        }
        else
        {
          unint64_t v53 = *a2;
          unint64_t v54 = a2[1];
          uint64_t v55 = HIBYTE(v54) & 0xF;
          if ((v54 & 0x2000000000000000) == 0) {
            uint64_t v55 = *a2 & 0xFFFFFFFFFFFFLL;
          }
          if (v55 || (v53 & ~v54 & 0x2000000000000000) != 0)
          {
            if ((v54 & 0x2000000000000000) != 0)
            {
              unint64_t v56 = specialized _SmallString.init(_:appending:)(v53, v54, 0x3FuLL, 0xE100000000000000);
              if ((v58 & 1) == 0)
              {
LABEL_86:
                unint64_t v73 = v56;
                unint64_t v74 = v57;
                swift_bridgeObjectRelease(0xE100000000000000);
                swift_bridgeObjectRelease(a2[1]);
                *a2 = v73;
                a2[1] = v74;
                goto LABEL_8;
              }
            }
            uint64_t v59 = 63;
LABEL_182:
            _StringGuts.append(_:)(v59, 0xE100000000000000, 0, 1);
            uint64_t v9 = 0xE100000000000000;
            goto LABEL_7;
          }
          uint64_t v156 = 63;
        }
        *a2 = v156;
        a2[1] = 0xE100000000000000;
LABEL_191:
        uint64_t v9 = v54;
        goto LABEL_7;
      }
      v172 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v33 = swift_reflectionMirror_recursiveCount(v10);
      if (v33 < 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      }
      uint64_t v34 = (char *)v33;
      uint64_t v35 = 0;
      do
      {
        if (v34 == v35)
        {
          uint64_t v42 = specialized static String._createEmpty(withInitialCapacity:)(16);
          uint64_t v44 = v43;
          __s._uint64_t countAndFlagsBits = v42;
          __s._object = (void *)v43;
          uint64_t v45 = HIBYTE(v43) & 0xF;
          if ((v43 & 0x2000000000000000) == 0) {
            uint64_t v45 = v42 & 0xFFFFFFFFFFFFLL;
          }
          if (v45 || (v42 & ~v43 & 0x2000000000000000) != 0)
          {
            if ((v43 & 0x2000000000000000) == 0
              || (unint64_t v46 = specialized _SmallString.init(_:appending:)(v42, v43, 0x2074657366666F3CuLL, 0xE800000000000000), (v48 & 1) != 0))
            {
              _StringGuts.append(_:)(0x2074657366666F3CLL, 0xE800000000000000, 0, 8);
              swift_bridgeObjectRelease(0xE800000000000000);
              uint64_t v49 = __s._countAndFlagsBits;
              unint64_t v50 = (unint64_t)__s._object;
            }
            else
            {
              uint64_t v49 = v46;
              unint64_t v50 = v47;
              swift_bridgeObjectRelease(0xE800000000000000);
              swift_bridgeObjectRelease(v44);
              __s._uint64_t countAndFlagsBits = v49;
              __s._object = (void *)v50;
            }
          }
          else
          {
            swift_bridgeObjectRelease(v43);
            unint64_t v50 = 0xE800000000000000;
            __s._uint64_t countAndFlagsBits = 0x2074657366666F3CLL;
            __s._object = (void *)0xE800000000000000;
            uint64_t v49 = 0x2074657366666F3CLL;
          }
          unint64_t v67 = _int64ToString(_:radix:uppercase:)(v32, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
          unint64_t v68 = v66;
          uint64_t v69 = HIBYTE(v50) & 0xF;
          if ((v50 & 0x2000000000000000) == 0) {
            uint64_t v69 = v49 & 0xFFFFFFFFFFFFLL;
          }
          if (!v69 && (v49 & ~v50 & 0x2000000000000000) == 0)
          {
            swift_bridgeObjectRelease(v50);
            __s._uint64_t countAndFlagsBits = v67;
            __s._object = (void *)v68;
            goto LABEL_147;
          }
          if ((v50 & 0x2000000000000000) != 0)
          {
            if ((v66 & 0x2000000000000000) != 0)
            {
              unint64_t v120 = specialized _SmallString.init(_:appending:)(v49, v50, v67, v66);
              if (v122) {
                goto LABEL_145;
              }
              uint64_t v123 = v120;
              unint64_t v124 = v121;
              swift_bridgeObjectRelease(v68);
              swift_bridgeObjectRelease(v50);
              __s._uint64_t countAndFlagsBits = v123;
              __s._object = v124;
              unint64_t v68 = (unint64_t)v124;
              unint64_t v67 = v123;
              goto LABEL_147;
            }
          }
          else if ((v66 & 0x2000000000000000) != 0)
          {
LABEL_145:
            uint64_t v75 = HIBYTE(v68) & 0xF;
LABEL_146:
            _StringGuts.append(_:)(v67, v68, 0, v75);
            swift_bridgeObjectRelease(v68);
            unint64_t v67 = __s._countAndFlagsBits;
            unint64_t v68 = (unint64_t)__s._object;
LABEL_147:
            uint64_t v125 = HIBYTE(v68) & 0xF;
            if ((v68 & 0x2000000000000000) == 0) {
              uint64_t v125 = v67 & 0xFFFFFFFFFFFFLL;
            }
            if (v125 || (v67 & ~v68 & 0x2000000000000000) != 0)
            {
              if ((v68 & 0x2000000000000000) == 0
                || (unint64_t v126 = specialized _SmallString.init(_:appending:)(v67, v68, 0x2820uLL, 0xE200000000000000),
                    (v128 & 1) != 0))
              {
                _StringGuts.append(_:)(10272, 0xE200000000000000, 0, 2);
                swift_bridgeObjectRelease(0xE200000000000000);
              }
              else
              {
                uint64_t v129 = v126;
                BOOL v130 = v127;
                swift_bridgeObjectRelease(0xE200000000000000);
                swift_bridgeObjectRelease(v68);
                __s._uint64_t countAndFlagsBits = v129;
                __s._object = v130;
              }
            }
            else
            {
              swift_bridgeObjectRelease(v68);
              __s._uint64_t countAndFlagsBits = 10272;
              __s._object = (void *)0xE200000000000000;
            }
            uint64_t v131 = (uint64_t *)swift_getTypeName(v7, 0);
            if ((v132 & 0x8000000000000000) == 0)
            {
              uint64_t v133 = (uint8x16_t *)v131;
              int64_t v134 = v132;
              int64_t v135 = validateUTF8(_:)(v131, v132);
              if (v137) {
                unint64_t v138 = repairUTF8(_:firstKnownBrokenRange:)(v133->i8, v134, v135, v136);
              }
              else {
                unint64_t v138 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v133, v134, v135 & 1);
              }
              uint64_t v140 = v138;
              unint64_t v141 = v139;
              uint64_t v142 = __s._object;
              unint64_t v143 = ((unint64_t)__s._object >> 56) & 0xF;
              if (((uint64_t)__s._object & 0x2000000000000000) == 0) {
                unint64_t v143 = __s._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
              }
              if (!v143 && (__s._countAndFlagsBits & ~(uint64_t)__s._object & 0x2000000000000000) == 0)
              {
                swift_bridgeObjectRelease((uint64_t)__s._object);
                __s._uint64_t countAndFlagsBits = v140;
                __s._object = (void *)v141;
                goto LABEL_172;
              }
              if (((uint64_t)__s._object & 0x2000000000000000) != 0)
              {
                if ((v139 & 0x2000000000000000) != 0)
                {
                  unint64_t v145 = specialized _SmallString.init(_:appending:)(__s._countAndFlagsBits, (unint64_t)__s._object, v138, v139);
                  if (v147) {
                    goto LABEL_170;
                  }
                  uint64_t v148 = v145;
                  uint64_t v149 = v146;
                  swift_bridgeObjectRelease(v141);
                  swift_bridgeObjectRelease((uint64_t)v142);
                  __s._uint64_t countAndFlagsBits = v148;
                  __s._object = v149;
                  unint64_t v141 = (unint64_t)v149;
                  uint64_t v140 = v148;
                  goto LABEL_172;
                }
              }
              else if ((v139 & 0x2000000000000000) != 0)
              {
LABEL_170:
                uint64_t v144 = HIBYTE(v141) & 0xF;
LABEL_171:
                _StringGuts.append(_:)(v140, v141, 0, v144);
                swift_bridgeObjectRelease(v141);
                uint64_t v140 = __s._countAndFlagsBits;
                unint64_t v141 = (unint64_t)__s._object;
LABEL_172:
                uint64_t v150 = HIBYTE(v141) & 0xF;
                if ((v141 & 0x2000000000000000) == 0) {
                  uint64_t v150 = v140 & 0xFFFFFFFFFFFFLL;
                }
                if (v150 || (v140 & ~v141 & 0x2000000000000000) != 0)
                {
                  if ((v141 & 0x2000000000000000) == 0
                    || (unint64_t v151 = specialized _SmallString.init(_:appending:)(v140, v141, 0x3E29uLL, 0xE200000000000000),
                        (v153 & 1) != 0))
                  {
                    _StringGuts.append(_:)(15913, 0xE200000000000000, 0, 2);
                    swift_bridgeObjectRelease(0xE200000000000000);
                    uint64_t v154 = __s._countAndFlagsBits;
                    unint64_t v112 = (unint64_t)__s._object;
                  }
                  else
                  {
                    uint64_t v154 = v151;
                    unint64_t v112 = v152;
                    swift_bridgeObjectRelease(0xE200000000000000);
                    swift_bridgeObjectRelease(v141);
                  }
                }
                else
                {
                  swift_bridgeObjectRelease(v141);
                  unint64_t v112 = 0xE200000000000000;
                  uint64_t v154 = 15913;
                }
                v155._uint64_t countAndFlagsBits = v154;
                v155._object = (void *)v112;
                String.append(_:)(v155);
LABEL_6:
                uint64_t v9 = v112;
LABEL_7:
                swift_bridgeObjectRelease(v9);
                goto LABEL_8;
              }
              uint64_t v144 = v138 & 0xFFFFFFFFFFFFLL;
              goto LABEL_171;
            }
LABEL_197:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
          }
          uint64_t v75 = v67 & 0xFFFFFFFFFFFFLL;
          goto LABEL_146;
        }
        uint64_t v36 = v35 + 1;
        uint64_t v37 = swift_reflectionMirror_recursiveChildOffset(v10, v35);
        uint64_t v35 = v36;
      }
      while (v37 != v32);
      __s._uint64_t countAndFlagsBits = 0;
      __s._object = 0;
      __int16 v164 = 0;
      swift_reflectionMirror_recursiveChildMetadata((char *)v10, v36 - 1, (char **)&__s);
      uint64_t v38 = (uint64_t *)__s._countAndFlagsBits;
      if (!__s._countAndFlagsBits) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while implicitly unwrapping an Optional value", 68, 2, "Swift/KeyPath.swift", 19, 2, 0x1036uLL, 0);
      }
      size_t v39 = _swift_stdlib_strlen((const char *)__s._countAndFlagsBits);
      if ((v39 & 0x8000000000000000) != 0) {
        goto LABEL_197;
      }
      v40._uint64_t countAndFlagsBits = (uint64_t)_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n(v38, v39);
      uint64_t v41 = v40._object;
      String.append(_:)(v40);
      swift_bridgeObjectRelease((uint64_t)v41);
      if (__s._object) {
        ((void (*)(uint64_t *))__s._object)(v38);
      }
LABEL_8:
      if (!v17)
      {
        unint64_t v157 = *a2;
        swift_bridgeObjectRetain(a2[1]);
        uint64_t v4 = v161;
        goto LABEL_194;
      }
    }
  }
  v159._uint64_t countAndFlagsBits = 0x666C65732ELL;
  v159._object = (void *)0xE500000000000000;
  String.append(_:)(v159);
  swift_bridgeObjectRelease(0xE500000000000000);
  unint64_t v157 = *a2;
  swift_bridgeObjectRetain(a2[1]);
LABEL_194:
  if (!v4) {
    return v157;
  }
  return v158;
}

uint64_t AnyKeyPath._storedInlineOffset.getter()
{
  uint64_t v1 = specialized KeyPathBuffer.init(base:)(v0 + 24);
  uint64_t v20 = v1;
  uint64_t v21 = v2;
  if (v1 && v2 != v1)
  {
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t v5 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v20, v21);
      if (!v5) {
        goto LABEL_52;
      }
      unint64_t v7 = v6 - (void)v5 - 4;
      if (__OFSUB__(v6 - (void)v5, 4))
      {
        __break(1u);
LABEL_47:
        __break(1u);
LABEL_48:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
      }
      if ((v7 & 0x8000000000000000) != 0) {
        goto LABEL_45;
      }
      unint64_t v8 = *v5;
      uint64_t v9 = (v8 >> 24) & 0x7F;
      if (v9 == 1 || v9 == 3)
      {
        unint64_t v11 = 4 * ((~v8 & 0x7FFFFF) == 0);
      }
      else
      {
        if (v9 != 2)
        {
          unint64_t v11 = 0;
          goto LABEL_32;
        }
        if ((v8 & 0x400000) != 0) {
          unint64_t v11 = 28;
        }
        else {
          unint64_t v11 = 20;
        }
        if ((v8 & 0x80000) != 0)
        {
          if ((v8 & 0x400000) != 0) {
            uint64_t v12 = 6;
          }
          else {
            uint64_t v12 = 4;
          }
          uint64_t v13 = (uint64_t)&v5[v12 + 2];
          if ((v13 & 7) != 0) {
            goto LABEL_48;
          }
          uint64_t v14 = *(void *)v13;
          BOOL v15 = __OFADD__(v11 + 16, v14);
          v11 += 16 + v14;
          if (v15)
          {
            __break(1u);
LABEL_51:
            __break(1u);
LABEL_52:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
          }
          if ((v8 & 0x10) != 0)
          {
            BOOL v15 = __OFADD__(v11, 8);
            v11 += 8;
            if (v15) {
              goto LABEL_51;
            }
          }
          if ((v11 & 0x8000000000000000) != 0) {
LABEL_45:
          }
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
        }
      }
      if (v7 < v11) {
        goto LABEL_45;
      }
LABEL_32:
      uint64_t v16 = v5 + 1;
      uint64_t v20 = (uint64_t)v5 + v11 + 4;
      uint64_t v21 = v6;
      if (v7 == v11)
      {
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v18 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v20, 1);
        if (!v18) {
          goto LABEL_52;
        }
        uint64_t v17 = *v18;
      }
      if (v9 != 1) {
        return 0;
      }
      uint64_t v19 = v8 & 0x7FFFFF;
      if ((v8 & 0x7FFFFF) == 0x7FFFFF)
      {
        if (v11 < 4) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load out of bounds", 41, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55EuLL, 0);
        }
        if ((v16 & 3) != 0) {
          goto LABEL_48;
        }
        uint64_t v19 = *v16;
      }
      BOOL v15 = __OFADD__(v3, v19);
      v3 += v19;
      if (v15) {
        goto LABEL_47;
      }
      if (!v17) {
        return v3;
      }
    }
  }
  return 0;
}

uint64_t KeyPathBuffer.next()()
{
  uint64_t v1 = (unsigned int *)specialized _pop<A>(from:as:count:)((uint64_t *)v0, 1);
  if (!v1) {
    goto LABEL_9;
  }
  uint64_t v2 = *v1;
  if ((v2 & 0x80000000) != 0) {
    *(unsigned char *)(v0 + 17) = 0;
  }
  uint64_t v3 = *(void *)v0;
  uint64_t v4 = RawKeyPathComponent.bodySize.getter(v2, *(void *)v0);
  specialized UnsafeRawBufferPointer.init<A>(_:)(v3, v4);
  specialized _pop<A>(from:as:count:)((uint64_t *)v0, v4);
  if (*(void *)v0)
  {
    if (*(void *)(v0 + 8) != *(void *)v0 && !specialized _pop<A>(from:as:count:)((uint64_t *)v0, 1)) {
LABEL_9:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return v2;
}

uint64_t AnyKeyPath.deinit()
{
  return v0;
}

void AnyKeyPath.__deallocating_deinit()
{
  swift_deallocClassInstance(v0);
}

Swift::Int AnyKeyPath.hashValue.getter()
{
  return Hasher._finalize()();
}

void AnyKeyPath.hash(into:)()
{
  Hasher._combine(_:)(*(void *)v0);
  if ((((_BYTE)v0 + 24) & 3) != 0) {
LABEL_76:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  uint64_t v1 = *(_DWORD *)(v0 + 24) & 0xFFFFFF;
  uint64_t v32 = v0 + 32;
  uint64_t v33 = v0 + 32 + v1;
  if (v1)
  {
    uint64_t v2 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v32, 1);
    if (!v2) {
LABEL_74:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    while (1)
    {
      unsigned int v3 = *v2;
      uint64_t v4 = v32;
      int v5 = HIBYTE(*v2) & 0x7F;
      if (v5 == 1 || v5 == 3)
      {
        if ((~v3 & 0x7FFFFF) != 0) {
          goto LABEL_17;
        }
        uint64_t v7 = 4;
      }
      else
      {
        if (v5 != 2)
        {
LABEL_17:
          uint64_t v7 = 0;
          uint64_t v8 = 0;
          uint64_t v9 = 0;
          if (!v32) {
            goto LABEL_28;
          }
          goto LABEL_27;
        }
        uint64_t v7 = 28;
        if ((v3 & 0x400000) == 0) {
          uint64_t v7 = 20;
        }
        if ((v3 & 0x80000) != 0)
        {
          if (!v32) {
            goto LABEL_74;
          }
          uint64_t v10 = 24;
          if ((v3 & 0x400000) == 0) {
            uint64_t v10 = 16;
          }
          uint64_t v11 = v32 + v10 + 4;
          if ((v11 & 7) != 0) {
            goto LABEL_76;
          }
          uint64_t v12 = v7 + 16;
          uint64_t v13 = *(void *)v11;
          BOOL v14 = __OFADD__(v12, v13);
          uint64_t v7 = v12 + v13;
          if (v14)
          {
            __break(1u);
LABEL_79:
            __break(1u);
LABEL_80:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
          }
          if ((v3 & 0x10) != 0)
          {
            BOOL v14 = __OFADD__(v7, 8);
            v7 += 8;
            if (v14) {
              goto LABEL_79;
            }
          }
          if (v7 < 0) {
            goto LABEL_77;
          }
          goto LABEL_27;
        }
      }
      if (!v32) {
        goto LABEL_80;
      }
LABEL_27:
      uint64_t v8 = v32 + v7;
      uint64_t v9 = v7;
LABEL_28:
      specialized _pop<A>(from:as:count:)(&v32, v9);
      if (v32 && v33 != v32)
      {
        uint64_t v19 = (Swift::UInt *)specialized _pop<A>(from:as:count:)(&v32, 1);
        if (!v19) {
          goto LABEL_74;
        }
        Swift::UInt v15 = *v19;
        if (v5 == 1)
        {
LABEL_38:
          unsigned int v20 = v3 & 0x7FFFFF;
          if ((v3 & 0x7FFFFF) == 0x7FFFFF) {
            unsigned int v20 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0, v4, v8);
          }
          Swift::UInt v17 = v20;
          Swift::UInt v18 = 0;
          goto LABEL_41;
        }
      }
      else
      {
        Swift::UInt v15 = 0;
        if (v5 == 1) {
          goto LABEL_38;
        }
      }
      if (v5 == 2)
      {
        uint64_t v21 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(4, v4, v8);
        if (!v4) {
          goto LABEL_74;
        }
        Swift::UInt v22 = v21;
        if ((v3 & 0x80000) != 0)
        {
          uint64_t v27 = 24;
          if ((v3 & 0x400000) != 0) {
            uint64_t v28 = 24;
          }
          else {
            uint64_t v28 = 16;
          }
          uint64_t v29 = v4 + v28 + 4;
          if ((v3 & 0x10) == 0) {
            uint64_t v27 = 16;
          }
          if ((v29 & 7) != 0) {
            goto LABEL_76;
          }
          if ((*(void *)v29 & 0x8000000000000000) != 0) {
LABEL_77:
          }
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
          if (((v29 + 8) & 7) != 0) {
            goto LABEL_76;
          }
          uint64_t v25 = *(void *)(v29 + 8);
          if ((v3 & 0x10) != 0)
          {
            if (((v29 + 16) & 7) != 0) {
              goto LABEL_76;
            }
            uint64_t v26 = *(void *)(v29 + 16);
          }
          else
          {
            uint64_t v26 = 0;
          }
          uint64_t v23 = v29 + v27;
          uint64_t v24 = v29 + v27 + *(void *)v29;
        }
        else
        {
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          uint64_t v26 = 0;
        }
        if ((v3 & 0x200000) != 0) {
          Swift::UInt v30 = 1;
        }
        else {
          Swift::UInt v30 = (v3 >> 19) & 2;
        }
        if ((v3 & 0x400000) != 0)
        {
          if ((v3 & 0x800000) != 0) {
            Swift::UInt v31 = 6;
          }
          else {
            Swift::UInt v31 = 7;
          }
        }
        else
        {
          Swift::UInt v31 = 5;
        }
        Hasher._combine(_:)(v31);
        Hasher._combine(_:)(v22);
        Hasher._combine(_:)(v30);
        appendHashFromArgument #1 (_:) in KeyPathComponent.hash(into:)(v23, v24, v25, v26);
        goto LABEL_72;
      }
      if (v5 != 3)
      {
        if ((v3 & 0xFFFFFF) != 0)
        {
          if ((v3 & 0xFFFFFF) == 1) {
            Hasher._combine(_:)(4uLL);
          }
          else {
            Hasher._combine(_:)(3uLL);
          }
        }
        else
        {
          Hasher._combine(_:)(2uLL);
        }
        goto LABEL_72;
      }
      unsigned int v16 = v3 & 0x7FFFFF;
      if ((v3 & 0x7FFFFF) == 0x7FFFFF) {
        unsigned int v16 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0, v4, v8);
      }
      Swift::UInt v17 = v16;
      Swift::UInt v18 = 1;
LABEL_41:
      Hasher._combine(_:)(v18);
      Hasher._combine(_:)(v17);
LABEL_72:
      if (!v15) {
        return;
      }
      Hasher._combine(_:)(v15);
      uint64_t v2 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v32, 1);
      if (!v2) {
        goto LABEL_74;
      }
    }
  }
}

void ObjectIdentifier.hash(into:)(int a1, Swift::UInt a2)
{
}

uint64_t RawKeyPathComponent.value.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unsigned int v5 = result;
  unsigned int v7 = BYTE3(result) & 0x7F;
  if (v7 == 1)
  {
    uint64_t v8 = result & 0x7FFFFF;
    if (v8 == 0x7FFFFF)
    {
      unint64_t result = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0, a2, a3);
      unint64_t v14 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v8 = result;
    }
    else
    {
      unint64_t v14 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
    }
    goto LABEL_33;
  }
  if (v7 != 2)
  {
    if (v7 == 3)
    {
      uint64_t v8 = result & 0x7FFFFF;
      if (v8 == 0x7FFFFF)
      {
        unint64_t result = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0, a2, a3);
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        unint64_t v14 = 0x2000000000000000;
        uint64_t v8 = result;
      }
      else
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        unint64_t v14 = 0x2000000000000000;
      }
    }
    else
    {
      uint64_t v8 = result & 0xFFFFFF;
      if ((result & 0xFFFFFF) != 0)
      {
        if (v8 == 1) {
          uint64_t v8 = 2;
        }
        else {
          uint64_t v8 = 1;
        }
        unint64_t v14 = 0xA000000000000000;
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t v13 = 0;
      }
      else
      {
        unint64_t v14 = 0xA000000000000000;
        uint64_t v9 = result & 0xFFFFFF;
        uint64_t v10 = v9;
        uint64_t v11 = v9;
        uint64_t v12 = v9;
        uint64_t v13 = v9;
      }
    }
    goto LABEL_33;
  }
  unint64_t result = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(4, a2, a3);
  if ((v5 & 0x200000) != 0) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = (v5 >> 19) & 2;
  }
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v8 = result;
  if ((v5 & 0x80000) != 0)
  {
    uint64_t v10 = RawKeyPathComponent._computedArguments.getter(v5, a2);
    uint64_t v16 = RawKeyPathComponent._computedArgumentSize.getter(v5, a2);
    if (v16 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
    }
    uint64_t v17 = v16;
    unint64_t result = RawKeyPathComponent._computedArgumentHeaderPointer.getter(v5, a2);
    if (((result + 8) & 7) == 0)
    {
      uint64_t v12 = *(void *)(result + 8);
      if ((v5 & 0x10) == 0)
      {
        uint64_t v13 = 0;
LABEL_28:
        uint64_t v11 = v10 + v17;
        goto LABEL_29;
      }
      unint64_t result = RawKeyPathComponent._computedArguments.getter(v5, a2);
      if (((result - 8) & 7) == 0)
      {
        uint64_t v13 = *(void *)(result - 8);
        goto LABEL_28;
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
LABEL_29:
  uint64_t v9 = a2 + 12;
  unint64_t v14 = v15 | 0x6000000000000000;
  if ((v5 & 0x800000) == 0) {
    unint64_t v14 = v15 | 0x8000000000000000;
  }
  if ((v5 & 0x400000) == 0) {
    unint64_t v14 = v15 | 0x4000000000000000;
  }
LABEL_33:
  *a4 = v8;
  a4[1] = v14;
  a4[2] = v9;
  a4[3] = v10;
  a4[4] = v11;
  a4[5] = v12;
  a4[6] = v13;
  return result;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance AnyKeyPath()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance AnyKeyPath()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance AnyKeyPath()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance AnyKeyPath(void **a1, void **a2)
{
  return specialized static AnyKeyPath.== infix(_:_:)(*a1, *a2);
}

uint64_t PartialKeyPath.deinit()
{
  return v0;
}

uint64_t static KeyPath._rootAndValueType.getter()
{
  return *(void *)(v0 + 144);
}

unsigned int *KeyPath._projectReadOnly(from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = *v4;
  uint64_t v8 = *(void *)(*v4 + 152);
  uint64_t v41 = type metadata accessor for Optional(0, v8, a2, a3);
  uint64_t v9 = (uint64_t)*(v41 - 1);
  MEMORY[0x1F4188790](v41);
  uint64_t v11 = (char *)&v40 - v10;
  uint64_t v12 = v4[2];
  if (v12)
  {
    BOOL v13 = __OFSUB__(0, v12);
    uint64_t v14 = -v12;
    if (v13) {
      goto LABEL_47;
    }
    BOOL v13 = __OFSUB__(v14, 1);
    uint64_t v15 = v14 - 1;
    if (v13)
    {
LABEL_48:
      __break(1u);
LABEL_49:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
    }
    if ((v15 & 0x8000000000000000) == 0)
    {
      if ((*(void *)(*(void *)(*(void *)(v7 + 144) - 8) + 64) & 0x8000000000000000) != 0) {
LABEL_43:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
      uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16);
      return (unsigned int *)v16(a4, a1 + v15, v8);
    }
  }
  uint64_t v47 = *(void *)(v7 + 144);
  uint64_t v18 = v47;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v46);
  uint64_t v20 = *(void *)(v18 - 8);
  (*(void (**)(void *, uint64_t, uint64_t))(v20 + 16))(boxed_opaque_existential_0Tm, a1, v18);
  uint64_t v21 = specialized KeyPathBuffer.init(base:)((uint64_t)(v4 + 3));
  if (v21 && v22 != v21)
  {
    uint64_t v40 = a4;
    unint64_t result = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v21, v22);
    if (!result) {
LABEL_40:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    uint64_t v24 = (void (**)(char *, Class *))(v9 + 8);
    while (1)
    {
      unint64_t v25 = v23 - (void)result - 4;
      if (__OFSUB__(v23 - (void)result, 4))
      {
        __break(1u);
LABEL_45:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
      }
      if ((v25 & 0x8000000000000000) != 0) {
        goto LABEL_43;
      }
      uint64_t v26 = (uint64_t)(result + 1);
      uint64_t v27 = *result;
      unsigned int v28 = BYTE3(v27) & 0x7F;
      if (v28 != 1)
      {
        if (v28 == 2)
        {
          if ((v27 & 0x400000) != 0) {
            unint64_t v29 = 28;
          }
          else {
            unint64_t v29 = 20;
          }
          if ((v27 & 0x80000) != 0)
          {
            uint64_t v30 = 6;
            if ((v27 & 0x400000) == 0) {
              uint64_t v30 = 4;
            }
            uint64_t v31 = (uint64_t)&result[v30 + 2];
            if ((v31 & 7) != 0) {
              goto LABEL_45;
            }
            uint64_t v32 = *(void *)v31;
            BOOL v13 = __OFADD__(v29 + 16, v32);
            v29 += 16 + v32;
            if (v13)
            {
              __break(1u);
LABEL_47:
              __break(1u);
              goto LABEL_48;
            }
            if ((v27 & 0x10) != 0)
            {
              BOOL v13 = __OFADD__(v29, 8);
              v29 += 8;
              if (v13)
              {
                __break(1u);
                return result;
              }
            }
            if ((v29 & 0x8000000000000000) != 0) {
              goto LABEL_43;
            }
          }
          goto LABEL_32;
        }
        if (v28 != 3)
        {
          unint64_t v29 = 0;
          uint64_t v33 = (uint64_t)(result + 1);
          goto LABEL_35;
        }
      }
      unint64_t v29 = 4 * ((~v27 & 0x7FFFFF) == 0);
LABEL_32:
      if (v25 < v29) {
        goto LABEL_43;
      }
      uint64_t v33 = v26 + v29;
LABEL_35:
      uint64_t v44 = v33;
      uint64_t v45 = v26 + v25;
      uint64_t v34 = v8;
      if (v25 != v29)
      {
        uint64_t v35 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v44, 1);
        if (!v35) {
          goto LABEL_40;
        }
        uint64_t v34 = *v35;
      }
      BOOL v36 = v25 == v29;
      outlined init with copy of Any((uint64_t)v46, (uint64_t)v42);
      uint64_t v37 = v43;
      uint64_t v38 = __swift_project_boxed_opaque_existential_0Tm(v42, v43);
      specialized project2 #1 <A, B><A1><A2>(_:) in project #1 <A, B><A1>(_:) in closure #2 in KeyPath._projectReadOnly(from:)(v27, v26, v33, (uint64_t)v38, v36, v46, v8, v37, (uint64_t)v11, v34);
      uint64_t v39 = *(void *)(v8 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v39 + 48))(v11, 1, v8) != 1)
      {
        (*(void (**)(uint64_t, char *, uint64_t))(v39 + 32))(v40, v11, v8);
        __swift_destroy_boxed_opaque_existential_1Tm(v42);
        return (unsigned int *)__swift_destroy_boxed_opaque_existential_1Tm(v46);
      }
      (*v24)(v11, v41);
      __swift_destroy_boxed_opaque_existential_1Tm(v42);
      unint64_t result = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v44, v45);
      if (!result) {
        goto LABEL_40;
      }
    }
  }
  if (*(void *)(v20 + 64) != *(void *)(*(void *)(v8 - 8) + 64)) {
    goto LABEL_49;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(a4, a1, v8);
  return (unsigned int *)__swift_destroy_boxed_opaque_existential_1Tm(v46);
}

Swift::UnsafeRawPointer __swiftcall UnsafeRawPointer.advanced(by:)(Swift::Int by)
{
  return (Swift::UnsafeRawPointer)(v1 + by);
}

uint64_t specialized project2 #1 <A, B><A1><A2>(_:) in project #1 <A, B><A1>(_:) in closure #2 in KeyPath._projectReadOnly(from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t *a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, uint64_t a10)
{
  char v78 = a6;
  int v80 = a5;
  char v88 = (void *)a4;
  uint64_t v81 = a9;
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  char v72 = type metadata accessor for Optional(0, a8, a3, a4);
  uint64_t v71 = (uint64_t)*(v72 - 1);
  uint64_t v15 = *(void *)(v71 + 64);
  MEMORY[0x1F4188790](v72);
  unint64_t v73 = (char *)&v69 - v16;
  unint64_t v76 = type metadata accessor for Optional(0, a10, v17, v18);
  uint64_t v75 = (uint64_t)*(v76 - 1);
  uint64_t v19 = *(void *)(v75 + 64);
  uint64_t v20 = MEMORY[0x1F4188790](v76);
  unint64_t v70 = (char *)&v69 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v20);
  unint64_t v74 = (char *)&v69 - v22;
  uint64_t v84 = *(void *)(a10 - 8);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v83 = (char *)&v69 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v79 = v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v69 = (char *)&v69 - v26;
  uint64_t v77 = *(void *)(a8 - 8);
  uint64_t v27 = *(void *)(v77 + 64);
  MEMORY[0x1F4188790](v25);
  uint64_t v85 = a10;
  uint64_t v86 = (const char *)a7;
  unint64_t v87 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0, a10, a7, v28);
  MEMORY[0x1F4188790](v87);
  unint64_t v82 = (char *)&v69 - v29;
  RawKeyPathComponent.value.getter(a1, a2, a3, (uint64_t *)v91);
  outlined init with take of KeyPathComponent(v91, (uint64_t)&v92);
  uint64_t v30 = v92;
  uint64_t v31 = (void *)v94;
  uint64_t v32 = (void *)v95;
  uint64_t v33 = v96;
  uint64_t v34 = v97;
  switch(v93 >> 61)
  {
    case 1uLL:
      v93 &= 0x1FFFFFFFFFFFFFFFuLL;
      if (v27 != 8) {
        goto LABEL_43;
      }
      uint64_t v48 = *v88 + v92;
      swift_beginAccess(v48, &v89, 0, 0);
      uint64_t v42 = v84;
      unint64_t v46 = *(void (**)(char *, char *, uint64_t))(v84 + 16);
      uint64_t v40 = v82;
      uint64_t v47 = v82;
      uint64_t v45 = (char *)v48;
LABEL_19:
      uint64_t v36 = v85;
      v46(v47, v45, v85);
      uint64_t v49 = v87;
      swift_storeEnumTagMultiPayload(v40, (uint64_t)v87, 0);
      uint64_t v41 = v86;
      uint64_t v43 = v83;
      goto LABEL_20;
    case 2uLL:
    case 3uLL:
    case 4uLL:
      v93 &= 0x1FFFFFFFFFFFFFFFuLL;
      if ((v94 & 7) != 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
      }
      uint64_t v35 = a8;
      uint64_t v36 = v85;
      swift_getFunctionTypeMetadata3(131075, v35, (uint64_t)&type metadata for UnsafeRawPointer, (uint64_t)&type metadata for Int, v85);
      if (!*v31) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
      }
      if (v34) {
        BOOL v37 = v32 == 0;
      }
      else {
        BOOL v37 = 1;
      }
      if (v37) {
        uint64_t v38 = 0;
      }
      else {
        uint64_t v38 = v33 - (void)v32;
      }
      if (v37) {
        uint64_t v39 = v31;
      }
      else {
        uint64_t v39 = v32;
      }
      uint64_t v40 = v82;
      ((void (*)(void *, void *, uint64_t))*v31)(v88, v39, v38);
      uint64_t v41 = v86;
      uint64_t v42 = v84;
      goto LABEL_14;
    case 5uLL:
      unint64_t v56 = v95 | v94;
      uint64_t v57 = v97 | v98;
      if (v93 == 0xA000000000000000 && !(v56 | v92 | v96 | v57))
      {
        if (v27 != v19) {
          goto LABEL_43;
        }
        uint64_t v58 = v75;
        uint64_t v59 = v74;
        uint64_t v60 = v76;
        (*(void (**)(char *, void *, Class *))(v75 + 16))(v74, v88, v76);
        uint64_t v42 = v84;
        uint64_t v36 = v85;
        int v61 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v84 + 48))(v59, 1, v85);
        uint64_t v41 = v86;
        uint64_t v43 = v83;
        uint64_t v40 = v82;
        if (v61 == 1)
        {
          (*(void (**)(char *, Class *))(v58 + 8))(v59, v60);
          uint64_t v90 = &unk_1ECA00E70;
          LOBYTE(v89) = 1;
          swift_dynamicCast(v40, (unint64_t *)&v89, qword_1ECA06310, v41, 7uLL);
          uint64_t v49 = v87;
          swift_storeEnumTagMultiPayload(v40, (uint64_t)v87, 1u);
          goto LABEL_20;
        }
        unint64_t v67 = *(void (**)(char *, char *, uint64_t))(v42 + 32);
        unint64_t v68 = v69;
        v67(v69, v59, v36);
        v67(v40, v68, v36);
        uint64_t v64 = v40;
        uint64_t v49 = v87;
LABEL_42:
        swift_storeEnumTagMultiPayload(v64, (uint64_t)v49, 0);
LABEL_20:
        if (swift_getEnumCaseMultiPayload((unsigned __int8 *)v40, (uint64_t)v49) == 1)
        {
          uint64_t v50 = *((void *)v41 - 1);
          uint64_t v51 = v81;
          (*(void (**)(uint64_t, char *, const char *))(v50 + 32))(v81, v40, v41);
          return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v50 + 56))(v51, 0, 1, v41);
        }
        goto LABEL_22;
      }
      if (v93 == 0xA000000000000000 && v92 == 1 && !(v56 | v96 | v57))
      {
        uint64_t v41 = v86;
        uint64_t v49 = v87;
        if (v27 != v19) {
          goto LABEL_43;
        }
        unint64_t v62 = v70;
        (*(void (**)(char *, void *, Class *))(v75 + 16))(v70, v88, v76);
        uint64_t v42 = v84;
        uint64_t v36 = v85;
        int v63 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v84 + 48))(v62, 1, v85);
        uint64_t v43 = v83;
        uint64_t v40 = v82;
        if (v63 == 1) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/KeyPath.swift", 19, 2, 0x6D6uLL, 0);
        }
        (*(void (**)(char *, char *, uint64_t))(v42 + 32))(v82, v62, v36);
        uint64_t v64 = v40;
        goto LABEL_42;
      }
      uint64_t v65 = v77;
      unint64_t v66 = v73;
      (*(void (**)(char *, void *, uint64_t))(v77 + 16))(v73, v88, a8);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v65 + 56))(v66, 0, 1, a8);
      if (v15 != v79) {
        goto LABEL_43;
      }
      uint64_t v42 = v84;
      uint64_t v40 = v82;
      uint64_t v36 = v85;
      (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v82, v66, v85);
      (*(void (**)(char *, Class *))(v71 + 8))(v66, v72);
      uint64_t v41 = v86;
LABEL_14:
      uint64_t v43 = v83;
      swift_storeEnumTagMultiPayload(v40, (uint64_t)v87, 0);
LABEL_22:
      uint64_t v52 = *(void (**)(char *, char *, uint64_t))(v42 + 32);
      v52(v43, v40, v36);
      if (v80)
      {
        uint64_t v50 = *((void *)v41 - 1);
        if (v79 == *(void *)(v50 + 64))
        {
          uint64_t v51 = v81;
          (*(void (**)(uint64_t, char *, const char *))(v50 + 16))(v81, v43, v41);
          (*(void (**)(char *, uint64_t))(v42 + 8))(v43, v36);
          return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v50 + 56))(v51, 0, 1, v41);
        }
LABEL_43:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
      uint64_t v90 = (void *)v36;
      unint64_t v54 = (char *)__swift_allocate_boxed_opaque_existential_0Tm(&v89);
      v52(v54, v43, v36);
      uint64_t v55 = v78;
      __swift_destroy_boxed_opaque_existential_1Tm(v78);
      outlined init with take of Any(&v89, v55);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v41 - 1) + 56))(v81, 1, 1, v41);
    default:
      v93 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v44 = v77;
      (*(void (**)(char *, void *, uint64_t))(v77 + 16))((char *)&v69 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0), v88, a8);
      if (v27 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
      }
      (*(void (**)(char *, uint64_t))(v44 + 8))((char *)&v69 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0), a8);
      uint64_t v45 = (char *)&v69 + v30 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
      uint64_t v42 = v84;
      unint64_t v46 = *(void (**)(char *, char *, uint64_t))(v84 + 16);
      uint64_t v40 = v82;
      uint64_t v47 = v82;
      goto LABEL_19;
  }
}

void RawKeyPathComponent._projectReadOnly<A, B, C>(_:to:endingWith:)(void *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, char *a8@<X8>, const char *a9)
{
  char v78 = a8;
  uint64_t v79 = a1;
  unint64_t v76 = a9;
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  unint64_t v68 = type metadata accessor for Optional(0, a6, a2, a3);
  uint64_t v67 = (uint64_t)*(v68 - 1);
  uint64_t v69 = *(void *)(v67 + 64);
  MEMORY[0x1F4188790](v68);
  unint64_t v70 = (char *)&v64 - v14;
  unint64_t v73 = type metadata accessor for Optional(0, a7, v15, v16);
  uint64_t v72 = (uint64_t)*(v73 - 1);
  uint64_t v17 = *(void *)(v72 + 64);
  uint64_t v18 = MEMORY[0x1F4188790](v73);
  unint64_t v66 = (char *)&v64 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v18);
  uint64_t v71 = (char *)&v64 - v20;
  uint64_t v77 = a7;
  uint64_t v75 = *(void *)(a7 - 8);
  uint64_t v21 = *(void *)(v75 + 64);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v65 = (char *)&v64 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v74 = *(void *)(a6 - 8);
  uint64_t v23 = *(void *)(v74 + 64);
  MEMORY[0x1F4188790](v22);
  RawKeyPathComponent.value.getter(a3, a4, a5, (uint64_t *)v81);
  outlined init with take of KeyPathComponent(v81, (uint64_t)&v82);
  uint64_t v24 = v82;
  uint64_t v26 = v84;
  uint64_t v25 = v85;
  uint64_t v27 = v86;
  uint64_t v28 = v87;
  switch(v83 >> 61)
  {
    case 1uLL:
      v83 &= 0x1FFFFFFFFFFFFFFFuLL;
      if (v23 != 8) {
        goto LABEL_35;
      }
      uint64_t v41 = *v79 + v82;
      swift_beginAccess(v41, v80, 0, 0);
      uint64_t v42 = v78;
      uint64_t v43 = v41;
      uint64_t v44 = v77;
      (*(void (**)(char *, uint64_t, uint64_t))(v75 + 16))(v78, v43, v77);
      uint64_t v46 = v44;
      goto LABEL_18;
    case 2uLL:
    case 3uLL:
    case 4uLL:
      v83 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v29 = v77;
      uint64_t v30 = (void (*)(void *, uint64_t, uint64_t))ComputedAccessorsPtr.getter<A, B>()(v84, a6, v77);
      if (v28) {
        BOOL v31 = v25 == 0;
      }
      else {
        BOOL v31 = 1;
      }
      if (v31) {
        uint64_t v32 = 0;
      }
      else {
        uint64_t v32 = v27 - v25;
      }
      if (v31) {
        uint64_t v33 = v26;
      }
      else {
        uint64_t v33 = v25;
      }
      uint64_t v34 = v78;
      v30(v79, v33, v32);
      uint64_t v36 = v29;
      goto LABEL_15;
    case 5uLL:
      uint64_t v48 = v85 | v84;
      uint64_t v49 = v87 | v88;
      if (v83 != 0xA000000000000000 || v48 | v82 | v86 | v49)
      {
        if (v83 == 0xA000000000000000 && v82 == 1 && !(v48 | v86 | v49))
        {
          if (v23 == v17)
          {
            uint64_t v58 = v66;
            (*(void (**)(char *, void *, Class *))(v72 + 16))(v66, v79, v73);
            uint64_t v59 = v75;
            uint64_t v38 = v77;
            if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v75 + 48))(v58, 1, v77) == 1) {
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/KeyPath.swift", 19, 2, 0x6D6uLL, 0);
            }
            uint64_t v34 = v78;
            (*(void (**)(char *, char *, uint64_t))(v59 + 32))(v78, v58, v38);
LABEL_14:
            uint64_t v36 = v38;
LABEL_15:
            uint64_t v39 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0, v36, (uint64_t)v76, v35);
            uint64_t v40 = v34;
            goto LABEL_19;
          }
        }
        else
        {
          uint64_t v60 = v74;
          int v61 = v70;
          (*(void (**)(char *, void *, uint64_t))(v74 + 16))(v70, v79, a6);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v60 + 56))(v61, 0, 1, a6);
          if (v69 == v21)
          {
            uint64_t v34 = v78;
            uint64_t v38 = v77;
            (*(void (**)(char *, char *, uint64_t))(v75 + 16))(v78, v61, v77);
            (*(void (**)(char *, Class *))(v67 + 8))(v61, v68);
            goto LABEL_14;
          }
        }
LABEL_35:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
      if (v23 != v17) {
        goto LABEL_35;
      }
      uint64_t v50 = v72;
      uint64_t v51 = v71;
      uint64_t v52 = v73;
      (*(void (**)(char *, void *, Class *))(v72 + 16))(v71, v79, v73);
      uint64_t v53 = v75;
      uint64_t v54 = v77;
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v75 + 48))(v51, 1, v77) == 1)
      {
        (*(void (**)(char *, Class *))(v50 + 8))(v51, v52);
        v80[3] = (unint64_t)&unk_1ECA00E70;
        LOBYTE(v80[0]) = 1;
        uint64_t v55 = v78;
        unint64_t v56 = v76;
        swift_dynamicCast(v78, v80, qword_1ECA06310, v76, 7uLL);
        uint64_t v39 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0, v54, (uint64_t)v56, v57);
        uint64_t v40 = v55;
        unsigned int v47 = 1;
        goto LABEL_20;
      }
      unint64_t v62 = *(void (**)(char *, char *, uint64_t))(v53 + 32);
      int v63 = v65;
      v62(v65, v51, v54);
      uint64_t v42 = v78;
      v62(v78, v63, v54);
      uint64_t v46 = v54;
LABEL_18:
      uint64_t v39 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0, v46, (uint64_t)v76, v45);
      uint64_t v40 = v42;
LABEL_19:
      unsigned int v47 = 0;
LABEL_20:
      swift_storeEnumTagMultiPayload(v40, (uint64_t)v39, v47);
      return;
    default:
      v83 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v37 = v74;
      (*(void (**)(char *, void *, uint64_t))(v74 + 16))((char *)&v64 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0), v79, a6);
      if (v23 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
      }
      (*(void (**)(char *, uint64_t))(v37 + 8))((char *)&v64 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0), a6);
      uint64_t v34 = v78;
      uint64_t v38 = v77;
      (*(void (**)(char *, char *, uint64_t))(v75 + 16))(v78, (char *)&v64 + v24 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0), v77);
      goto LABEL_14;
  }
}

uint64_t KeyPath.deinit()
{
  if (((v0 + 24) & 3) != 0) {
LABEL_58:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  int v1 = *(_DWORD *)(v0 + 24);
  if ((v1 & 0x80000000) == 0)
  {
    uint64_t v27 = v0 + 32;
    uint64_t v28 = v0 + 32 + (*(void *)&v1 & 0xFFFFFFLL);
    while (1)
    {
      uint64_t v2 = (_DWORD *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v27, v28);
      if (!v2) {
        goto LABEL_62;
      }
      uint64_t v4 = v2;
      unint64_t v5 = v3 - (void)v2 - 4;
      if (__OFSUB__(v3 - (void)v2, 4))
      {
        __break(1u);
        goto LABEL_58;
      }
      if ((v5 & 0x8000000000000000) != 0) {
        goto LABEL_56;
      }
      int v6 = *v2;
      int v7 = HIBYTE(*v2) & 0x7F;
      if (v7 == 1 || v7 == 3) {
        break;
      }
      if (v7 == 2)
      {
        unint64_t v9 = 28;
        if ((v6 & 0x400000) == 0) {
          unint64_t v9 = 20;
        }
        if ((v6 & 0x80000) != 0)
        {
          if ((v6 & 0x400000) != 0) {
            uint64_t v10 = 6;
          }
          else {
            uint64_t v10 = 4;
          }
          uint64_t v11 = (uint64_t)&v2[v10 + 2];
          if ((v11 & 7) != 0) {
            goto LABEL_58;
          }
          unint64_t v12 = v9 + 16;
          uint64_t v13 = *(void *)v11;
          BOOL v14 = __OFADD__(v12, v13);
          unint64_t v9 = v12 + v13;
          if (v14)
          {
            __break(1u);
LABEL_60:
            __break(1u);
LABEL_61:
            __break(1u);
LABEL_62:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
          }
          if ((v6 & 0x10) != 0)
          {
            BOOL v14 = __OFADD__(v9, 8);
            v9 += 8;
            if (v14) {
              goto LABEL_61;
            }
          }
          if ((v9 & 0x8000000000000000) != 0) {
            goto LABEL_56;
          }
        }
        goto LABEL_26;
      }
      unint64_t v9 = 0;
LABEL_29:
      uint64_t v27 = (uint64_t)v2 + v9 + 4;
      uint64_t v28 = v3;
      if (v5 == v9)
      {
        uint64_t v15 = 0;
      }
      else
      {
        uint64_t v16 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v27, 1);
        if (!v16) {
          goto LABEL_62;
        }
        uint64_t v15 = *v16;
      }
      BOOL v17 = (v6 & 0x7D000000) != 0x1000000 && v7 == 2;
      if (v17 && (v6 & 0x80000) != 0)
      {
        if ((v6 & 0x400000) != 0) {
          uint64_t v18 = 6;
        }
        else {
          uint64_t v18 = 4;
        }
        uint64_t v19 = &v4[v18];
        uint64_t v20 = (uint64_t)&v4[v18 + 4];
        if ((v20 & 7) != 0) {
          goto LABEL_58;
        }
        uint64_t v21 = *(void (***)(uint64_t *, uint64_t))v20;
        if ((v21 & 7) != 0) {
          goto LABEL_58;
        }
        if (*v21)
        {
          uint64_t v22 = (uint64_t *)(v19 + 2);
          if ((v6 & 0x10) != 0) {
            uint64_t v23 = 3;
          }
          else {
            uint64_t v23 = 2;
          }
          if ((v22 & 7) != 0) {
            goto LABEL_58;
          }
          uint64_t v24 = *v22;
          if ((v6 & 0x10) != 0)
          {
            if (((unint64_t)(v22 + 2) & 7) != 0) {
              goto LABEL_58;
            }
            uint64_t v25 = v22[2];
          }
          else
          {
            uint64_t v25 = 0;
          }
          if (__OFSUB__(v24, v25)) {
            goto LABEL_60;
          }
          (*v21)(&v22[v23], v24 - v25);
        }
      }
      if (!v15) {
        return v0;
      }
    }
    unint64_t v9 = 4 * ((~v6 & 0x7FFFFF) == 0);
LABEL_26:
    if (v5 < v9) {
LABEL_56:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
    goto LABEL_29;
  }
  return v0;
}

void KeyPath.__deallocating_deinit()
{
  KeyPath.deinit();

  swift_deallocClassInstance(v0);
}

void **WritableKeyPath._projectMutableAddress(from:)(void **a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = *v1;
  uint64_t v4 = v1[2];
  if (v4)
  {
    BOOL v5 = __OFSUB__(0, v4);
    uint64_t v6 = -v4;
    if (v5) {
      goto LABEL_38;
    }
    BOOL v5 = __OFSUB__(v6, 1);
    uint64_t v7 = v6 - 1;
    if (v5)
    {
LABEL_39:
      __break(1u);
LABEL_40:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
    }
    if ((v7 & 0x8000000000000000) == 0) {
      return (void **)((char *)a1 + v7);
    }
  }
  uint64_t v8 = *(void *)(*v1 + 168);
  uint64_t v28 = 0;
  uint64_t v9 = specialized KeyPathBuffer.init(base:)((uint64_t)(v1 + 3));
  uint64_t v26 = v9;
  unint64_t v27 = v10;
  if (v9 && v10 != v9)
  {
    do
    {
      uint64_t v11 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v26, v27);
      if (!v11) {
        goto LABEL_43;
      }
      unint64_t v13 = v12 - (void)v11 - 4;
      if (__OFSUB__(v12 - (void)v11, 4))
      {
        __break(1u);
LABEL_38:
        __break(1u);
        goto LABEL_39;
      }
      if ((v13 & 0x8000000000000000) != 0) {
        goto LABEL_36;
      }
      uint64_t v14 = (uint64_t)(v11 + 1);
      uint64_t v15 = *v11;
      unsigned int v16 = BYTE3(v15) & 0x7F;
      if (v16 != 1)
      {
        if (v16 == 2)
        {
          if ((v15 & 0x400000) != 0) {
            unint64_t v17 = 28;
          }
          else {
            unint64_t v17 = 20;
          }
          if ((v15 & 0x80000) != 0)
          {
            uint64_t v18 = 6;
            if ((v15 & 0x400000) == 0) {
              uint64_t v18 = 4;
            }
            uint64_t v19 = (uint64_t)&v11[v18 + 2];
            if ((v19 & 7) != 0) {
              goto LABEL_40;
            }
            unint64_t v20 = v17 + 16;
            uint64_t v21 = *(void *)v19;
            BOOL v5 = __OFADD__(v20, v21);
            unint64_t v17 = v20 + v21;
            if (v5)
            {
              __break(1u);
LABEL_42:
              __break(1u);
LABEL_43:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
            }
            if ((v15 & 0x10) != 0)
            {
              BOOL v5 = __OFADD__(v17, 8);
              v17 += 8;
              if (v5) {
                goto LABEL_42;
              }
            }
            if ((v17 & 0x8000000000000000) != 0) {
              goto LABEL_36;
            }
          }
          goto LABEL_27;
        }
        if (v16 != 3)
        {
          unint64_t v17 = 0;
          uint64_t v22 = (uint64_t)(v11 + 1);
          goto LABEL_30;
        }
      }
      unint64_t v17 = 4 * ((~v15 & 0x7FFFFF) == 0);
LABEL_27:
      if (v13 < v17) {
LABEL_36:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
      uint64_t v22 = v14 + v17;
LABEL_30:
      uint64_t v26 = v22;
      unint64_t v27 = v14 + v13;
      if (v13 == v17) {
        return specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)(v2, &v28, v15, v14, v22, v8, *(void *)(v3 + 176));
      }
      uint64_t v23 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v26, 1);
      if (!v23) {
        goto LABEL_43;
      }
      uint64_t v24 = *v23;
      uint64_t v2 = specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)(v2, &v28, v15, v14, v22, v8, *v23);
      uint64_t v8 = v24;
    }
    while (v24);
  }
  return v2;
}

void WritableKeyPath.__deallocating_deinit()
{
  KeyPath.deinit();

  swift_deallocClassInstance(v0);
}

void **ReferenceWritableKeyPath._projectMutableAddress(from:)(uint64_t a1)
{
  v65[1] = *(char **)MEMORY[0x1E4F143B8];
  uint64_t v53 = *v1;
  v65[0] = 0;
  uint64_t v3 = specialized KeyPathBuffer.init(base:)((uint64_t)(v1 + 3));
  __int16 v5 = v4;
  uint64_t v63 = v3;
  unint64_t v64 = v6;
  uint64_t v62 = *(void *)(v53 + 192);
  uint64_t v7 = v62;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v61);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 16))(boxed_opaque_existential_0Tm, a1, v7);
  if ((v5 & 0x100) != 0)
  {
    do
    {
      uint64_t v9 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v63, 1);
      if (!v9) {
        goto LABEL_67;
      }
      uint64_t v10 = *v9;
      uint64_t v11 = v63;
      unsigned int v12 = BYTE3(v10) & 0x7F;
      if (v12 == 1 || v12 == 3)
      {
        if ((~v10 & 0x7FFFFF) != 0) {
          goto LABEL_16;
        }
        uint64_t v14 = 4;
      }
      else
      {
        if (v12 != 2)
        {
LABEL_16:
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          if (!v63) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }
        uint64_t v14 = 28;
        if ((v10 & 0x400000) == 0) {
          uint64_t v14 = 20;
        }
        if ((v10 & 0x80000) != 0)
        {
          if (!v63) {
            goto LABEL_67;
          }
          uint64_t v17 = 24;
          if ((v10 & 0x400000) == 0) {
            uint64_t v17 = 16;
          }
          uint64_t v18 = v63 + v17 + 4;
          if ((v18 & 7) != 0) {
            goto LABEL_62;
          }
          uint64_t v19 = v14 + 16;
          uint64_t v20 = *(void *)v18;
          BOOL v21 = __OFADD__(v19, v20);
          uint64_t v14 = v19 + v20;
          if (v21)
          {
            __break(1u);
LABEL_64:
            __break(1u);
LABEL_65:
            __break(1u);
LABEL_66:
            __break(1u);
LABEL_67:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
          }
          if ((v10 & 0x10) != 0)
          {
            BOOL v21 = __OFADD__(v14, 8);
            v14 += 8;
            if (v21) {
              goto LABEL_65;
            }
          }
          if (v14 < 0) {
            goto LABEL_60;
          }
          goto LABEL_26;
        }
      }
      if (!v63) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
      }
LABEL_26:
      uint64_t v15 = v63 + v14;
      uint64_t v16 = v14;
LABEL_27:
      specialized _pop<A>(from:as:count:)(&v63, v16);
      if (!v63) {
        goto LABEL_67;
      }
      if (v64 == v63) {
        goto LABEL_67;
      }
      uint64_t v22 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v63, 1);
      if (!v22) {
        goto LABEL_67;
      }
      uint64_t v23 = *v22;
      outlined init with copy of Any((uint64_t)v61, (uint64_t)v57);
      uint64_t v55 = v58;
      uint64_t v54 = __swift_project_boxed_opaque_existential_0Tm(v57, v58);
      uint64_t v24 = *(const char **)(v53 + 200);
      uint64_t v26 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0, v23, (uint64_t)v24, v25);
      unint64_t v56 = &v52;
      uint64_t v27 = (uint64_t)*(v26 - 1);
      uint64_t v28 = *(void *)(v27 + 64);
      MEMORY[0x1F4188790](v26);
      uint64_t v29 = (char *)&v52 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
      RawKeyPathComponent._projectReadOnly<A, B, C>(_:to:endingWith:)(v54, v30, v10, v11, v15, v55, v23, v29, v24);
      uint64_t v60 = v23;
      BOOL v31 = __swift_allocate_boxed_opaque_existential_0Tm(&v59);
      MEMORY[0x1F4188790](v31);
      (*(void (**)(char *, char *, Class *))(v27 + 16))(v29, v29, v26);
      (*(void (**)(char *, Class *))(v27 + 8))(v29, v26);
      (*(void (**)(void *, char *, uint64_t))(*(void *)(v23 - 8) + 32))(v31, v29, v23);
      __swift_destroy_boxed_opaque_existential_1Tm(v57);
      __swift_destroy_boxed_opaque_existential_1Tm(v61);
      outlined init with take of Any(&v59, v61);
    }
    while ((v10 & 0x80000000) == 0);
  }
  uint64_t v32 = v62;
  uint64_t v33 = __swift_project_boxed_opaque_existential_0Tm(v61, v62);
  uint64_t v34 = *(void *)(v32 - 8);
  uint64_t v35 = *(void *)(v34 + 64);
  MEMORY[0x1F4188790](v33);
  uint64_t v36 = (void **)((char *)&v52 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(void **))(v34 + 16))(v36);
  if (v35 < 0) {
LABEL_60:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  (*(void (**)(char *, uint64_t))(v34 + 8))((char *)&v52 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0), v32);
  while (1)
  {
    uint64_t v37 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v63, v64);
    if (!v37) {
      goto LABEL_67;
    }
    unint64_t v39 = v38 - (void)v37 - 4;
    if (__OFSUB__(v38 - (void)v37, 4))
    {
      __break(1u);
LABEL_62:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
    }
    if ((v39 & 0x8000000000000000) != 0) {
      goto LABEL_60;
    }
    uint64_t v40 = (uint64_t)(v37 + 1);
    uint64_t v41 = *v37;
    unsigned int v42 = BYTE3(v41) & 0x7F;
    if (v42 != 1)
    {
      if (v42 == 2)
      {
        if ((v41 & 0x400000) != 0) {
          unint64_t v43 = 28;
        }
        else {
          unint64_t v43 = 20;
        }
        if ((v41 & 0x80000) != 0)
        {
          uint64_t v44 = 6;
          if ((v41 & 0x400000) == 0) {
            uint64_t v44 = 4;
          }
          uint64_t v45 = (uint64_t)&v37[v44 + 2];
          if ((v45 & 7) != 0) {
            goto LABEL_62;
          }
          unint64_t v46 = v43 + 16;
          uint64_t v47 = *(void *)v45;
          BOOL v21 = __OFADD__(v46, v47);
          unint64_t v43 = v46 + v47;
          if (v21) {
            goto LABEL_64;
          }
          if ((v41 & 0x10) != 0)
          {
            BOOL v21 = __OFADD__(v43, 8);
            v43 += 8;
            if (v21) {
              goto LABEL_66;
            }
          }
          if ((v43 & 0x8000000000000000) != 0) {
            goto LABEL_60;
          }
        }
        goto LABEL_51;
      }
      if (v42 != 3)
      {
        unint64_t v43 = 0;
        uint64_t v48 = (uint64_t)(v37 + 1);
        goto LABEL_54;
      }
    }
    unint64_t v43 = 4 * ((~v41 & 0x7FFFFF) == 0);
LABEL_51:
    if (v39 < v43) {
      goto LABEL_60;
    }
    uint64_t v48 = v40 + v43;
LABEL_54:
    uint64_t v63 = v48;
    unint64_t v64 = v40 + v39;
    if (v39 == v43) {
      break;
    }
    uint64_t v49 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v63, 1);
    if (!v49) {
      goto LABEL_67;
    }
    uint64_t v50 = *v49;
    uint64_t v36 = specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)(v36, v65, v41, v40, v48, v32, *v49);
    uint64_t v32 = v50;
    if (!v50) {
      goto LABEL_59;
    }
  }
  uint64_t v36 = specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)(v36, v65, v41, v40, v48, v32, *(void *)(v53 + 200));
LABEL_59:
  __swift_destroy_boxed_opaque_existential_1Tm(v61);
  return v36;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance ComputedPropertyID()
{
  Swift::UInt v1 = *(unsigned __int8 *)(v0 + 8);
  Hasher._combine(_:)(*(void *)v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance ComputedPropertyID()
{
  Swift::UInt v1 = *(unsigned __int8 *)(v0 + 8);
  Hasher._combine(_:)(*(void *)v0);
  Hasher._combine(_:)(v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance ComputedPropertyID()
{
  Swift::UInt v1 = *(unsigned __int8 *)(v0 + 8);
  Hasher._combine(_:)(*(void *)v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance ComputedPropertyID(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2 && *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
}

uint64_t ComputedAccessorsPtr.getter<A, B>()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  swift_getFunctionTypeMetadata3(131075, a2, (uint64_t)&type metadata for UnsafeRawPointer, (uint64_t)&type metadata for Int, a3);
  if (!*(void *)a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return *(void *)a1;
}

uint64_t ComputedAccessorsPtr.nonmutatingSetter<A, B>()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8;
  if (((a1 + 8) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  v5[0] = a3;
  v5[1] = a2;
  v5[2] = &type metadata for UnsafeRawPointer;
  v5[3] = &type metadata for Int;
  swift_getFunctionTypeMetadata(131076, (uint64_t)v5, 0, (uint64_t)&unk_1ECA06270);
  if (!*(void *)v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return *(void *)v3;
}

uint64_t ComputedAccessorsPtr.mutatingSetter<A, B>()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8;
  if (((a1 + 8) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  v5[0] = a3;
  v5[1] = a2;
  v5[2] = &type metadata for UnsafeRawPointer;
  v5[3] = &type metadata for Int;
  swift_getFunctionTypeMetadata(33685508, (uint64_t)v5, (uint64_t)&parameter_flags, (uint64_t)&unk_1ECA06270);
  if (!*(void *)v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return *(void *)v3;
}

uint64_t ComputedArgumentWitnessesPtr.destroy.getter(uint64_t a1)
{
  if ((a1 & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (*(void *)a1) {
    return *(void *)a1;
  }
  else {
    return 0;
  }
}

uint64_t ComputedArgumentWitnessesPtr.copy.getter(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  if (((a1 + 8) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (!*(void *)v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return *(void *)v1;
}

uint64_t ComputedArgumentWitnessesPtr.equals.getter(uint64_t a1)
{
  uint64_t v1 = a1 + 16;
  if (((a1 + 16) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (!*(void *)v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return *(void *)v1;
}

uint64_t ComputedArgumentWitnessesPtr.hash.getter(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  if (((a1 + 24) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (!*(void *)v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return *(void *)v1;
}

void KeyPathComponent.hash(into:)()
{
  outlined init with take of KeyPathComponent(v0, (uint64_t)&v10);
  Swift::UInt v1 = v10;
  unsigned __int8 v2 = v11;
  uint64_t v4 = v13;
  uint64_t v3 = v14;
  uint64_t v6 = v15;
  uint64_t v5 = v16;
  switch(v11 >> 61)
  {
    case 1uLL:
      Swift::UInt v7 = 1;
      goto LABEL_4;
    case 2uLL:
      v11 &= 0x1FFFFFFFFFFFFFFFuLL;
      Swift::UInt v8 = 5;
      goto LABEL_8;
    case 3uLL:
      v11 &= 0x1FFFFFFFFFFFFFFFuLL;
      Swift::UInt v8 = 6;
      goto LABEL_8;
    case 4uLL:
      v11 &= 0x1FFFFFFFFFFFFFFFuLL;
      Swift::UInt v8 = 7;
LABEL_8:
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v1);
      Hasher._combine(_:)(v2);
      appendHashFromArgument #1 (_:) in KeyPathComponent.hash(into:)(v4, v3, v6, v5);
      break;
    case 5uLL:
      if (v11 == 0xA000000000000000 && (v13 | v12 | v10 | v14 | v15 | v16) == 0)
      {
        Hasher._combine(_:)(2uLL);
      }
      else if (v11 == 0xA000000000000000 && v10 == 1 && !(v13 | v12 | v14 | v15 | v16))
      {
        Hasher._combine(_:)(3uLL);
      }
      else
      {
        Hasher._combine(_:)(4uLL);
      }
      break;
    default:
      Swift::UInt v7 = 0;
LABEL_4:
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v1);
      break;
  }
}

void appendHashFromArgument #1 (_:) in KeyPathComponent.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    Swift::UInt v7 = (uint64_t (*)(uint64_t, uint64_t))ComputedArgumentWitnessesPtr.hash.getter(a3);
    if (a1)
    {
      if (!__OFSUB__(a2 - a1, a4))
      {
        Swift::UInt v8 = v7(a1, a2 - a1 - a4);
        if (v8) {
          Hasher._combine(_:)(v8);
        }
        return;
      }
      __break(1u);
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance KeyPathComponent()
{
  outlined init with take of KeyPathComponent(v0, (uint64_t)v2);
  KeyPathComponent.hash(into:)();
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance KeyPathComponent()
{
  outlined init with take of KeyPathComponent(v0, (uint64_t)v1);
  KeyPathComponent.hash(into:)();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance KeyPathComponent()
{
  outlined init with take of KeyPathComponent(v0, (uint64_t)v2);
  KeyPathComponent.hash(into:)();
  return Hasher._finalize()();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance KeyPathComponent(long long *a1, long long *a2)
{
  outlined init with take of KeyPathComponent(a1, (uint64_t)v4);
  outlined init with take of KeyPathComponent(a2, (uint64_t)v5);
  return ((uint64_t (*)(unsigned char *, unsigned char *))specialized static KeyPathComponent.== infix(_:_:))(v4, v5) & 1;
}

void ClassHolder.__deallocating_deinit()
{
  swift_endAccess((swift::runtime::SwiftTLSContext *)(v0 + 4));
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[3]);

  swift_deallocClassInstance((uint64_t)v0);
}

void MutatingWritebackBuffer.__deallocating_deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)v1 + 88);
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v5 = (char *)&v10 - v4;
  uint64_t v6 = *(void (**)(char *, void, void, void))(v1 + 32);
  uint64_t v8 = v1 + *(void *)(v7 + 136);
  (*(void (**)(char *, uint64_t, uint64_t))(v3 + 16))((char *)&v10 - v4, v8, v2);
  v6(v5, *(void *)(v1 + 24), *(void *)(v1 + 40), *(void *)(v1 + 48));
  uint64_t v9 = *(void (**)(char *, uint64_t))(v3 + 8);
  v9(v5, v2);
  swift_unknownObjectRelease(*(id *)(v1 + 16));
  v9((char *)v8, v2);
  swift_deallocClassInstance(v1);
}

void NonmutatingWritebackBuffer.__deallocating_deinit(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *((void *)*v1 + 11);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v11 - v5;
  uint64_t v7 = *(void (**)(char *, char *, void, void))((char *)v1 + v2[14]);
  uint64_t v8 = (char *)v1 + v2[17];
  (*(void (**)(char *, char *, uint64_t))(v4 + 16))((char *)&v11 - v5, v8, v3);
  uint64_t v9 = (char *)v1 + *((void *)*v1 + 13);
  v7(v6, v9, *(id *)((char *)v1 + *((void *)*v1 + 15)), *(id *)((char *)v1 + *((void *)*v1 + 16)));
  uint64_t v10 = *(void (**)(char *, uint64_t))(v4 + 8);
  v10(v6, v3);
  swift_unknownObjectRelease(v1[2]);
  (*(void (**)(char *))(*(void *)(v2[10] - 8) + 8))(v9);
  v10(v8, v3);
  swift_deallocClassInstance((uint64_t)v1);
}

uint64_t static UInt32.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

uint64_t RawKeyPathComponent.Header.patternComponentBodySize.getter(unsigned int a1)
{
  switch(HIBYTE(a1) & 0x7F)
  {
    case 0:
      uint64_t result = 4 * (a1 & 0xFFFFFF) + 4;
      break;
    case 1:
    case 3:
      if ((~a1 & 0x7FFFFE) != 0) {
        uint64_t result = 4 * ((a1 & 0x7FFFFF) == 8388605);
      }
      else {
        uint64_t result = 4;
      }
      break;
    case 2:
      uint64_t v2 = 12;
      if ((a1 & 0x400000) == 0) {
        uint64_t v2 = 8;
      }
      if ((a1 & 0x80000) != 0) {
        uint64_t result = v2 + 12;
      }
      else {
        uint64_t result = v2;
      }
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t RawKeyPathComponent.Header.propertyDescriptorBodySize.getter(unsigned int a1)
{
  if (!a1) {
    return 0;
  }
  switch(HIBYTE(a1) & 0x7F)
  {
    case 0:
      uint64_t result = 4 * (a1 & 0xFFFFFF) + 4;
      break;
    case 1:
    case 3:
      if ((~a1 & 0x7FFFFE) != 0) {
        uint64_t result = 4 * ((a1 & 0x7FFFFF) == 8388605);
      }
      else {
        uint64_t result = 4;
      }
      break;
    case 2:
      if ((a1 & 0x400000) != 0) {
        uint64_t result = 12;
      }
      else {
        uint64_t result = 8;
      }
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t RawKeyPathComponent.bodySize.getter(unsigned int a1, uint64_t a2)
{
  int v3 = HIBYTE(a1) & 0x7F;
  if (v3 == 1) {
    return 4 * ((~a1 & 0x7FFFFF) == 0);
  }
  if (v3 != 2)
  {
    if (v3 == 3) {
      return 4 * ((~a1 & 0x7FFFFF) == 0);
    }
    return 0;
  }
  if ((a1 & 0x400000) != 0) {
    uint64_t result = 28;
  }
  else {
    uint64_t result = 20;
  }
  if ((a1 & 0x80000) != 0)
  {
    uint64_t v5 = result + 16;
    uint64_t v6 = RawKeyPathComponent._computedArgumentSize.getter(a1, a2);
    BOOL v7 = __OFADD__(v5, v6);
    uint64_t result = v5 + v6;
    if (v7)
    {
      __break(1u);
      return result;
    }
    if ((a1 & 0x10) != 0)
    {
      BOOL v7 = __OFADD__(result, 8);
      result += 8;
      if (v7)
      {
        __break(1u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t RawKeyPathComponent._computedArgumentSize.getter(int a1, uint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v2 = 24;
  if ((a1 & 0x400000) == 0) {
    uint64_t v2 = 16;
  }
  uint64_t v3 = a2 + v2 + 4;
  if ((v3 & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  return *(void *)v3;
}

uint64_t specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load with negative offset", 48, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55DuLL, 0);
  }
  uint64_t v3 = a1 + 4;
  if (__OFADD__(a1, 4))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (!a2)
  {
    if (v3 < 1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x560uLL, 0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load out of bounds", 41, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55EuLL, 0);
  }
  if (a3 - a2 < v3) {
    goto LABEL_12;
  }
  if (((a2 + a1) & 3) != 0) {
    goto LABEL_9;
  }
  return *(unsigned int *)(a2 + a1);
}

{
  uint64_t v3;

  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load with negative offset", 48, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55DuLL, 0);
  }
  uint64_t v3 = a1 + 8;
  if (__OFADD__(a1, 8))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (!a2)
  {
    if (v3 < 1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x560uLL, 0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load out of bounds", 41, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55EuLL, 0);
  }
  if (a3 - a2 < v3) {
    goto LABEL_12;
  }
  if (((a2 + a1) & 7) != 0) {
    goto LABEL_9;
  }
  return *(void *)(a2 + a1);
}

uint64_t UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load with negative offset", 48, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55DuLL, 0);
  }
  uint64_t v5 = *(void *)(a4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  BOOL v7 = __OFADD__(a1, v6);
  uint64_t v8 = a1 + v6;
  if (v7)
  {
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  if (!a2)
  {
    if (v8 < 1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x560uLL, 0);
    }
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer.load out of bounds", 41, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x55EuLL, 0);
  }
  if (a3 - a2 < v8) {
    goto LABEL_14;
  }
  if ((*(unsigned char *)(v5 + 80) & (a2 + a1)) != 0) {
    goto LABEL_11;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t))(v5 + 16);

  return v9(a5);
}

uint64_t RawKeyPathComponent._computedArgumentHeaderPointer.getter(int a1, uint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v2 = 24;
  if ((a1 & 0x400000) == 0) {
    uint64_t v2 = 16;
  }
  return a2 + v2 + 4;
}

uint64_t RawKeyPathComponent._computedArguments.getter(int a1, uint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v2 = 24;
  if ((a1 & 0x400000) != 0) {
    uint64_t v3 = 24;
  }
  else {
    uint64_t v3 = 16;
  }
  uint64_t v4 = a2 + v3;
  if ((a1 & 0x10) == 0) {
    uint64_t v2 = 16;
  }
  return v4 + v2 + 4;
}

Swift::Void __swiftcall RawKeyPathComponent.clone(into:endOfReferencePrefix:)(Swift::UnsafeMutableRawBufferPointer *into, Swift::Bool endOfReferencePrefix)
{
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  unsigned int v7 = v2;
  if (endOfReferencePrefix) {
    unsigned int v9 = 0x80000000;
  }
  else {
    unsigned int v9 = 0;
  }
  rawValue = into->_position.value._rawValue;
  uint64_t v11 = into->_end.value._rawValue;
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v9 & 0x80000000 | v2 & 0x7FFFFFFF, 0, (uint64_t)into->_position.value._rawValue, (uint64_t)v11);
  int v12 = HIBYTE(v7) & 0x7F;
  if (v12 == 1)
  {
LABEL_7:
    if ((~v7 & 0x7FFFFF) == 0)
    {
      uint64_t v13 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0, v6, v5);
      specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v13, 4, (uint64_t)rawValue, (uint64_t)v11);
      uint64_t v14 = 8;
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v14 = 4;
LABEL_10:
    if (rawValue) {
      goto LABEL_11;
    }
LABEL_43:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (v12 != 2)
  {
    if (v12 != 3) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }
  uint64_t v15 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(4, v6, v5);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v15, 8, (uint64_t)rawValue, (uint64_t)v11);
  if (!v6 || !rawValue) {
    goto LABEL_43;
  }
  UnsafeMutableRawPointer._copyAddressDiscriminatedFunctionPointer(from:discriminator:)((Swift::UnsafeRawPointer)(v6 + 12), 0x6F72uLL);
  if ((v7 & 0x400000) != 0)
  {
    if ((v7 & 0x800000) != 0) {
      Swift::UInt64 v16 = 29801;
    }
    else {
      Swift::UInt64 v16 = 28528;
    }
    UnsafeMutableRawPointer._copyAddressDiscriminatedFunctionPointer(from:discriminator:)((Swift::UnsafeRawPointer)(v6 + 20), v16);
    uint64_t v14 = 32;
    if ((v7 & 0x80000) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 24;
    if ((v7 & 0x80000) == 0) {
      goto LABEL_11;
    }
  }
  uint64_t v17 = RawKeyPathComponent._computedArguments.getter(v7, v6);
  uint64_t v18 = RawKeyPathComponent._computedArgumentSize.getter(v7, v6);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v18, v14, (uint64_t)rawValue, (uint64_t)v11);
  uint64_t v19 = (uint64_t *)(RawKeyPathComponent._computedArgumentHeaderPointer.getter(v7, v6) + 8);
  if ((v19 & 7) != 0) {
    goto LABEL_40;
  }
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(*v19, v14 + 8, (uint64_t)rawValue, (uint64_t)v11);
  uint64_t v20 = v14 + 16;
  if ((v7 & 0x10) != 0)
  {
    uint64_t v22 = (uint64_t *)(RawKeyPathComponent._computedArguments.getter(v7, v6) - 8);
    if ((v22 & 7) != 0) {
      goto LABEL_40;
    }
    specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(*v22, v14 + 16, (uint64_t)rawValue, (uint64_t)v11);
    uint64_t v23 = RawKeyPathComponent._computedArguments.getter(v7, v6);
    if (((v23 - 8) & 7) != 0) {
      goto LABEL_40;
    }
    uint64_t v20 = v14 + 24;
    uint64_t v21 = *(void *)(v23 - 8);
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t v24 = v18 - v21;
  if (__OFSUB__(v18, v21))
  {
    __break(1u);
LABEL_42:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  uint64_t v25 = (uint64_t *)(RawKeyPathComponent._computedArgumentHeaderPointer.getter(v7, v6) + 8);
  if ((v25 & 7) != 0) {
    goto LABEL_40;
  }
  uint64_t v26 = (void (*)(uint64_t, unsigned char *, uint64_t))ComputedArgumentWitnessesPtr.copy.getter(*v25);
  v26(v17, &rawValue[v20], v24);
  if ((v7 & 0x10) == 0) {
    goto LABEL_35;
  }
  uint64_t v27 = (size_t *)(RawKeyPathComponent._computedArguments.getter(v7, v6) - 8);
  if ((v27 & 7) != 0) {
LABEL_40:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  if ((*v27 & 0x8000000000000000) != 0) {
    goto LABEL_42;
  }
  memcpy(&rawValue[v20 + v24], (const void *)(v17 + v24), *v27);
LABEL_35:
  uint64_t v14 = v20 + v18;
  if (__OFADD__(v20, v18))
  {
    __break(1u);
    goto LABEL_38;
  }
LABEL_11:
  if (__OFSUB__(v11 - rawValue, v14))
  {
LABEL_38:
    __break(1u);
LABEL_39:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if (v11 - rawValue - v14 < 0) {
    goto LABEL_39;
  }
  into->_position.value._rawValue = &rawValue[v14];
  into->_end.value._rawValue = v11;
}

uint64_t specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes with negative offset", 61, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BCuLL, 0);
  }
  uint64_t v4 = a2 + 8;
  if (__OFADD__(a2, 8)) {
    __break(1u);
  }
  if (!a3)
  {
    if (v4 < 1) {
      goto LABEL_5;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BDuLL, 0);
  }
  if (a4 - a3 < v4) {
    goto LABEL_7;
  }
LABEL_5:
  *(void *)(a3 + a2) = result;
  return result;
}

{
  uint64_t v4;

  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes with negative offset", 61, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BCuLL, 0);
  }
  uint64_t v4 = a2 + 4;
  if (__OFADD__(a2, 4)) {
    __break(1u);
  }
  if (!a3)
  {
    if (v4 < 1) {
      goto LABEL_5;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BDuLL, 0);
  }
  if (a4 - a3 < v4) {
    goto LABEL_7;
  }
LABEL_5:
  *(_DWORD *)(a3 + a2) = result;
  return result;
}

{
  uint64_t v4;

  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes with negative offset", 61, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BCuLL, 0);
  }
  uint64_t v4 = a2 + 8;
  if (!__OFADD__(a2, 8))
  {
    if (a3)
    {
      if (a4 - a3 >= v4)
      {
LABEL_5:
        *(void *)(a3 + a2) = result;
        return result;
      }
    }
    else if (v4 < 1)
    {
      goto LABEL_5;
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BDuLL, 0);
  }
  __break(1u);
  return result;
}

Swift::Void __swiftcall UnsafeMutableRawPointer._copyAddressDiscriminatedFunctionPointer(from:discriminator:)(Swift::UnsafeRawPointer from, Swift::UInt64 discriminator)
{
  if (from._rawValue != v2)
  {
    if (((uint64_t)from._rawValue & 7) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
    }
    if (!*(void *)from._rawValue) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    }
    void *v2 = *(void *)from._rawValue;
  }
}

uint64_t specialized _pop<A>(from:as:count:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (!*a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v3 = a1[1] - v2;
  BOOL v4 = __OFSUB__(v3, a2);
  uint64_t v5 = v3 - a2;
  if (v4)
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v5 < 0) {
    goto LABEL_8;
  }
  *a1 = v2 + a2;
  a1[1] = v2 + a2 + v5;
  return v2;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t result = _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZypXp_Tgm5(*a1, a1[1]);
  if ((unint64_t)(a2 - 0x1000000000000000) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_8;
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (a2 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  uint64_t v6 = v5 - result - 8 * a2;
  if (__OFSUB__(v5 - result, 8 * a2))
  {
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v6 < 0) {
    goto LABEL_10;
  }
  unsigned int v7 = result + 8 * a2;
  *a1 = v7;
  a1[1] = v7 + v6;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t result = _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(*a1, a1[1]);
  if ((unint64_t)(a2 - 0x2000000000000000) >> 62 != 3)
  {
    __break(1u);
    goto LABEL_8;
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (a2 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  uint64_t v6 = v5 - result - 4 * a2;
  if (__OFSUB__(v5 - result, 4 * a2))
  {
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v6 < 0) {
    goto LABEL_10;
  }
  unsigned int v7 = result + 4 * a2;
  *a1 = v7;
  a1[1] = v7 + v6;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  uint64_t result = _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs5Int32V_Tgm5Tm(*a1, a1[1]);
  if ((unint64_t)(a2 - 0x2000000000000000) >> 62 != 3)
  {
    __break(1u);
    goto LABEL_8;
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (a2 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  uint64_t v6 = v5 - result - 4 * a2;
  if (__OFSUB__(v5 - result, 4 * a2))
  {
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v6 < 0) {
    goto LABEL_10;
  }
  unsigned int v7 = result + 4 * a2;
  *a1 = v7;
  a1[1] = v7 + v6;
  return result;
}

uint64_t _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZypXp_Tgm5(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if ((result & 7) == 0) {
    return result;
  }
  uint64_t v3 = -(int)result & 7;
  result += v3;
  if (__OFADD__(v2, v3))
  {
    __break(1u);
LABEL_13:
    __break(1u);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v2) {
    uint64_t v4 = a2 - v2;
  }
  else {
    uint64_t v4 = 0;
  }
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5) {
    goto LABEL_13;
  }
  if (v6 < 0) {
    goto LABEL_14;
  }
  if (v6)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
    }
  }
  return result;
}

uint64_t _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  if ((result & 3) == 0) {
    return result;
  }
  uint64_t v3 = -(int)result & 3;
  result += v3;
  if (__OFADD__(v2, v3))
  {
    __break(1u);
    goto LABEL_11;
  }
  uint64_t v4 = a2 - v2;
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5)
  {
LABEL_11:
    __break(1u);
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v6 < 0) {
    goto LABEL_12;
  }
  if (v6)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
    }
  }
  return result;
}

uint64_t _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs5Int32V_Tgm5Tm(uint64_t result, uint64_t a2)
{
  if (result && (result & 3) != 0)
  {
    uint64_t v2 = -(int)result & 3;
    if (__OFADD__(result, v2))
    {
      __break(1u);
    }
    else
    {
      BOOL v3 = __OFSUB__(a2 - result, v2);
      uint64_t v4 = a2 - result - v2;
      if (!v3) {
        return specialized UnsafeRawBufferPointer.init<A>(_:)(result + v2, v4);
      }
    }
    __break(1u);
  }
  return result;
}

Swift::UnsafeMutableRawBufferPointer __swiftcall UnsafeMutableRawBufferPointer.init(mutating:)(Swift::UnsafeMutableRawBufferPointer mutating)
{
  if (!mutating._position.value._rawValue) {
    mutating._end.value._rawValue = 0;
  }
  return mutating;
}

Swift::UnsafeMutableRawBufferPointer __swiftcall KeyPathBuffer.Builder.pushRaw(size:alignment:)(Swift::Int size, Swift::Int alignment)
{
  unint64_t v3 = *v2;
  if (!*v2) {
LABEL_17:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  if (__OFSUB__(alignment, 1))
  {
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  Swift::Int v4 = v3 & (alignment - 1);
  if (v4)
  {
    Swift::Int v5 = alignment - v4;
    if (__OFSUB__(alignment, v4))
    {
LABEL_16:
      __break(1u);
      goto LABEL_17;
    }
    uint64_t v6 = (char *)(v3 + v5);
    if (size < 0) {
LABEL_12:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  else
  {
    Swift::Int v5 = 0;
    uint64_t v6 = (char *)*v2;
    if (size < 0) {
      goto LABEL_12;
    }
  }
  unint64_t v7 = v2[1] - v3;
  BOOL v8 = __OFSUB__(v7, size);
  unint64_t v9 = v7 - size;
  if (v8) {
    goto LABEL_14;
  }
  BOOL v8 = __OFSUB__(v9, v5);
  unint64_t v10 = v9 - v5;
  if (v8)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }
  if ((v10 & 0x8000000000000000) != 0) {
    goto LABEL_12;
  }
  uint64_t v11 = &v6[size];
  unint64_t *v2 = (unint64_t)&v6[size];
  v2[1] = (unint64_t)&v6[size + v10];
  int v12 = v6;
  result._end.value._rawValue = v11;
  result._position.value._rawValue = v12;
  return result;
}

Swift::UnsafeMutableRawPointer __swiftcall UnsafeMutableRawPointer.advanced(by:)(Swift::Int by)
{
  return (Swift::UnsafeMutableRawPointer)(v1 + by);
}

unsigned int *swift_getAtPartialKeyPath@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)a2;
  (*(void (**)(void))(*(void *)a2 + 120))();
  uint64_t v8 = v7;
  unint64_t v10 = type metadata accessor for KeyPath(0, *(void *)(v6 + 136), v7, v9);
  if (!swift_dynamicCastClass(a2, (uint64_t)v10)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  a3[3] = v8;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a3);
  return KeyPath._projectReadOnly(from:)(a1, v12, v13, (uint64_t)boxed_opaque_existential_0Tm);
}

unsigned int *swift_getAtKeyPath@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return KeyPath._projectReadOnly(from:)(a1, a2, a3, a4);
}

double swift_getAtAnyKeyPath@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, Class *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v9 = (const char *)(*(uint64_t (**)(void))(*(void *)a2 + 120))();

  return openRoot #1 <A><A1>(_:) in _getAtAnyKeyPath<A>(root:keyPath:)(a1, a2, v8, a3, v9, a4);
}

double openRoot #1 <A><A1>(_:) in _getAtAnyKeyPath<A>(root:keyPath:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, Class *a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v32 = a3;
  uint64_t v33 = a2;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = type metadata accessor for Optional(0, (uint64_t)a5, a3, (uint64_t)a4);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (unint64_t *)((char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v18 = *((void *)a5 - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v31 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unint64_t *, uint64_t, Class *))(v21 + 16))(v17, a1, a4);
  int v22 = swift_dynamicCast(v14, v17, a4, a5, 6uLL);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v18 + 56);
  if (v22)
  {
    v23(v14, 0, 1, a5);
    (*(void (**)(char *, char *, const char *))(v18 + 32))(v20, v14, a5);
    uint64_t v24 = v32;
    uint64_t v26 = type metadata accessor for KeyPath(0, (uint64_t)a5, v32, v25);
    if (!swift_dynamicCastClass(v33, (uint64_t)v26)) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
    }
    *(void *)(a6 + 24) = v24;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm((void *)a6);
    KeyPath._projectReadOnly(from:)((uint64_t)v20, v28, v29, (uint64_t)boxed_opaque_existential_0Tm);
    (*(void (**)(char *, const char *))(v18 + 8))(v20, a5);
  }
  else
  {
    v23(v14, 1, 1, a5);
    (*(void (**)(char *, Class *))(v11 + 8))(v14, v10);
    double result = 0.0;
    *(_OWORD *)a6 = 0u;
    *(_OWORD *)(a6 + 16) = 0u;
  }
  return result;
}

void **_swift_modifyAtWritableKeyPath_impl(void **a1, uint64_t a2)
{
  if ((*(unsigned __int8 (**)(void))(*(void *)a2 + 160))() == 2) {
    return ReferenceWritableKeyPath._projectMutableAddress(from:)((uint64_t)a1);
  }
  else {
    return WritableKeyPath._projectMutableAddress(from:)(a1);
  }
}

void **_swift_modifyAtReferenceWritableKeyPath_impl(uint64_t a1)
{
  return ReferenceWritableKeyPath._projectMutableAddress(from:)(a1);
}

void swift_setAtWritableKeyPath(void **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  if ((*(unsigned __int8 (**)(void))(*a2 + 160))() == 2) {
    uint64_t v6 = ReferenceWritableKeyPath._projectMutableAddress(from:)((uint64_t)a1);
  }
  else {
    uint64_t v6 = WritableKeyPath._projectMutableAddress(from:)(a1);
  }
  uint64_t v8 = v7;
  (*(void (**)(void **, uint64_t))(*(void *)(*(void *)(v5 + 176) - 8) + 40))(v6, a3);

  swift_unknownObjectRelease(v8);
}

void swift_setAtReferenceWritableKeyPath(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = ReferenceWritableKeyPath._projectMutableAddress(from:)(a1);
  uint64_t v7 = v6;
  (*(void (**)(void **, uint64_t))(*(void *)(*(void *)(v4 + 200) - 8) + 40))(v5, a3);

  swift_unknownObjectRelease(v7);
}

uint64_t _AppendKeyPath<>.appending(path:)(atomic_ullong *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v6 = v5;
  if (v5 != (*(uint64_t (**)(void))(*a1 + 120))()) {
    return 0;
  }
  uint64_t v10 = v7;
  uint64_t v11 = type metadata accessor for KeyPath(0, v4, v6, v8);
  if (!swift_dynamicCastClass((uint64_t)v2, (uint64_t)v11)
    || (uint64_t v13 = type metadata accessor for KeyPath(0, v6, v10, v12), !swift_dynamicCastClass((uint64_t)a1, (uint64_t)v13))
    || (uint64_t v15 = type metadata accessor for KeyPath(0, v4, v10, v14),
        uint64_t v9 = _appendingKeyPaths<A, B, C, D>(root:leaf:)(v2, a1, (uint64_t)v15),
        uint64_t v18 = v9,
        _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)&v18, (uint64_t)v2, (uint64_t)a1),
        uint64_t v16 = type metadata accessor for AnyKeyPath(),
        !swift_dynamicCastClass(v9, v16)))
  {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  return v9;
}

uint64_t _tryToAppendKeyPaths<A>(root:leaf:)(atomic_ullong *a1, atomic_ullong *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*a1 + 120))();
  uint64_t v8 = v7;
  if (v7 == (*(uint64_t (**)(void))(*a2 + 120))()) {
    return open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)(a1, a2, a3, v6, v8, v9);
  }
  else {
    return 0;
  }
}

uint64_t _AppendKeyPath.appending<A>(path:)(atomic_ullong *a1)
{
  uint64_t v2 = v1;
  atomic_ullong v4 = *v1;
  uint64_t v5 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v7 = v6;
  if (v6 != (*(uint64_t (**)(void))(*a1 + 120))()) {
    return 0;
  }
  uint64_t v12 = v8;
  uint64_t v13 = type metadata accessor for PartialKeyPath(0, *(void *)(v4 + 136), v9, v10);
  return open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)(v2, a1, (uint64_t)v13, v5, v7, v12);
}

uint64_t _AppendKeyPath.appending<A, B, C>(path:)(atomic_ullong *a1)
{
  uint64_t v2 = v1;
  atomic_ullong v4 = *v1;
  atomic_ullong v5 = *a1;
  uint64_t v6 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v8 = v7;
  if (v7 != (*(uint64_t (**)(void))(*a1 + 120))()) {
    return 0;
  }
  uint64_t v12 = v9;
  uint64_t v13 = type metadata accessor for KeyPath(0, *(void *)(v4 + 136), *(void *)(v5 + 152), v10);
  return open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)(v2, a1, (uint64_t)v13, v6, v8, v12);
}

{
  atomic_ullong *v1;
  atomic_ullong *v2;
  atomic_ullong v4;
  atomic_ullong v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  Class *v13;
  uint64_t v14;
  Class *v15;
  uint64_t v16;
  Class *v17;
  uint64_t v18;
  Class *v19;
  uint64_t v21;

  uint64_t v2 = v1;
  atomic_ullong v4 = *v1;
  atomic_ullong v5 = *a1;
  uint64_t v6 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v8 = v7;
  if (v7 != (*(uint64_t (**)(void))(*a1 + 120))()) {
    return 0;
  }
  uint64_t v12 = v9;
  uint64_t v13 = type metadata accessor for KeyPath(0, v6, v8, v10);
  if (!swift_dynamicCastClass((uint64_t)v2, (uint64_t)v13)
    || (uint64_t v15 = type metadata accessor for KeyPath(0, v8, v12, v14), !swift_dynamicCastClass((uint64_t)a1, (uint64_t)v15))
    || (uint64_t v17 = type metadata accessor for KeyPath(0, v6, v12, v16),
        uint64_t v11 = _appendingKeyPaths<A, B, C, D>(root:leaf:)(v2, a1, (uint64_t)v17),
        uint64_t v21 = v11,
        _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)&v21, (uint64_t)v2, (uint64_t)a1),
        uint64_t v19 = type metadata accessor for ReferenceWritableKeyPath(0, *(void *)(v4 + 136), *(void *)(v5 + 200), v18),
        !swift_dynamicCastClass(v11, (uint64_t)v19)))
  {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  return v11;
}

uint64_t _AppendKeyPath.appending<A, B, C>(path:)(atomic_ullong *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for KeyPath(0, *(void *)(a2 + 144), *(void *)(*a1 + 152), a4);

  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, (uint64_t)v6);
}

{
  atomic_ullong *v4;
  Class *v6;
  uint64_t vars8;

  uint64_t v6 = type metadata accessor for ReferenceWritableKeyPath(0, *(void *)(*v4 + 144), *(void *)(*a1 + 200), a4);

  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, (uint64_t)v6);
}

{
  atomic_ullong *v4;
  Class *v6;
  uint64_t vars8;

  uint64_t v6 = type metadata accessor for WritableKeyPath(0, *(void *)(*v4 + 168), *(void *)(*a1 + 176), a4);

  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, (uint64_t)v6);
}

{
  atomic_ullong *v4;
  Class *v6;
  uint64_t vars8;

  uint64_t v6 = type metadata accessor for ReferenceWritableKeyPath(0, *(void *)(*v4 + 168), *(void *)(*a1 + 200), a4);

  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, (uint64_t)v6);
}

{
  atomic_ullong *v4;
  Class *v6;
  uint64_t vars8;

  uint64_t v6 = type metadata accessor for ReferenceWritableKeyPath(0, *(void *)(*v4 + 192), *(void *)(*a1 + 176), a4);

  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, (uint64_t)v6);
}

uint64_t _appendingKeyPaths<A, B, C, D>(root:leaf:)(atomic_ullong *a1, atomic_ullong *a2, uint64_t a3)
{
  atomic_ullong v6 = *a2;
  char v7 = (*(uint64_t (**)(void))(*a1 + 160))();
  int v9 = (*(unsigned __int8 (**)(void))(v6 + 160))();
  if (!v9) {
    goto LABEL_6;
  }
  if (v9 != 1)
  {
LABEL_7:
    type metadata accessor for ReferenceWritableKeyPath(0, *(void *)(a3 + 144), *(void *)(a3 + 152), v8);
    goto LABEL_8;
  }
  if (!v7)
  {
LABEL_6:
    type metadata accessor for KeyPath(0, *(void *)(a3 + 144), *(void *)(a3 + 152), v8);
    goto LABEL_8;
  }
  if (v7 != 1) {
    goto LABEL_7;
  }
  type metadata accessor for WritableKeyPath(0, *(void *)(a3 + 144), *(void *)(a3 + 152), v8);
LABEL_8:
  uint64_t v10 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  uint64_t v12 = v11;
  v43[0] = v10;
  v43[1] = v11;
  char v44 = v13 & 1;
  char v45 = v14 & 1;
  uint64_t v15 = specialized KeyPathBuffer.init(base:)((uint64_t)(a2 + 3));
  if (v15)
  {
    uint64_t v17 = v16 - v15;
    if (v16 != v15)
    {
      if (!v10 || (uint64_t v19 = v12 - v10, v12 == v10))
      {
        if (swift_dynamicCastClass((uint64_t)a2, a3))
        {
          swift_retain(a2);
          uint64_t v18 = a2;
          goto LABEL_44;
        }
LABEL_60:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
      }
      uint64_t v20 = a1[2];
      if (v20)
      {
        uint64_t v21 = -v20;
        if (__OFSUB__(0, v20))
        {
LABEL_50:
          __break(1u);
          goto LABEL_51;
        }
        BOOL v22 = __OFSUB__(v21, 1);
        uint64_t v23 = v21 - 1;
        if (v22)
        {
LABEL_51:
          __break(1u);
          goto LABEL_52;
        }
        if ((v23 & 0x8000000000000000) == 0) {
          goto LABEL_30;
        }
      }
      uint64_t v24 = a2[2];
      if (!v24) {
        goto LABEL_30;
      }
      uint64_t v25 = -v24;
      if (__OFSUB__(0, v24))
      {
        __break(1u);
      }
      else
      {
        uint64_t v26 = v25 - 1;
        if (!__OFSUB__(v25, 1))
        {
          size_t v27 = 0;
          if (!v20 || (v26 & 0x8000000000000000) == 0) {
            goto LABEL_31;
          }
          size_t v28 = _swift_stdlib_strlen((const char *)v20);
          size_t v29 = _swift_stdlib_strlen((const char *)v24);
          size_t v30 = v28 + 1;
          if (__OFADD__(v28, 1))
          {
LABEL_58:
            __break(1u);
            goto LABEL_59;
          }
          BOOL v22 = __OFADD__(v30, v29);
          size_t v31 = v30 + v29;
          if (v22)
          {
LABEL_59:
            __break(1u);
            goto LABEL_60;
          }
          BOOL v22 = __OFADD__(v31, 1);
          size_t v27 = v31 + 1;
          if (!v22)
          {
LABEL_31:
            if (__OFADD__(v19, 7))
            {
              __break(1u);
            }
            else
            {
              unint64_t v32 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
              BOOL v22 = __OFADD__(v32, v17);
              uint64_t v33 = v32 + v17;
              if (!v22)
              {
                uint64_t v34 = v33 + 16;
                if (!__OFADD__(v33, 16))
                {
                  uint64_t v35 = v34 + v27;
                  if (!__OFADD__(v34, v27))
                  {
                    BOOL v22 = __OFADD__(v35, 3);
                    uint64_t v36 = v35 + 3;
                    if (!v22)
                    {
                      uint64_t v37 = MEMORY[0x1F4188790](v36 & 0xFFFFFFFFFFFFFFFCLL);
                      uint64_t v18 = static AnyKeyPath._create(capacityInBytes:initializedBy:)(v37, (void (*)(void *, char *))partial apply for closure #1 in closure #1 in closure #1 in _appendingKeyPaths<A, B, C, D>(root:leaf:));
                      atomic_ullong v38 = a1[2];
                      if (!v38) {
                        goto LABEL_40;
                      }
                      atomic_ullong v39 = -v38;
                      if (!__OFSUB__(0, v38))
                      {
                        BOOL v22 = __OFSUB__(v39, 1);
                        atomic_ullong v40 = v39 - 1;
                        if (!v22)
                        {
                          if ((v40 & 0x8000000000000000) == 0) {
                            goto LABEL_43;
                          }
LABEL_40:
                          atomic_ullong v41 = a2[2];
                          if (!v41) {
                            goto LABEL_43;
                          }
                          if (!__OFSUB__(0, v41))
                          {
                            if (!__OFSUB__(-v41, 1))
                            {
LABEL_43:
                              if (swift_dynamicCastClass((uint64_t)v18, a3)) {
                                goto LABEL_44;
                              }
                              goto LABEL_60;
                            }
                            goto LABEL_57;
                          }
LABEL_56:
                          __break(1u);
LABEL_57:
                          __break(1u);
                          __break(1u);
                          __break(1u);
                          goto LABEL_58;
                        }
LABEL_53:
                        __break(1u);
                        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
                      }
LABEL_52:
                      __break(1u);
                      goto LABEL_53;
                    }
                    goto LABEL_49;
                  }
LABEL_48:
                  __break(1u);
LABEL_49:
                  __break(1u);
                  goto LABEL_50;
                }
LABEL_47:
                __break(1u);
                goto LABEL_48;
              }
            }
            __break(1u);
            goto LABEL_47;
          }
          __break(1u);
LABEL_30:
          size_t v27 = 0;
          goto LABEL_31;
        }
      }
      __break(1u);
      goto LABEL_56;
    }
  }
  if (!swift_dynamicCastClass((uint64_t)a1, a3)) {
    goto LABEL_60;
  }
  swift_retain(a1);
  uint64_t v18 = a1;
LABEL_44:
  v43[0] = v18;
  _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)v43, (uint64_t)a1, (uint64_t)a2);
  return swift_dynamicCastClassUnconditional((int64_t)v18, (Class *)a3, 0, 0, 0);
}

uint64_t _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3) {
    return result;
  }
  BOOL v4 = __OFSUB__(0, v3);
  uint64_t v5 = -v3;
  if (v4)
  {
    __break(1u);
    goto LABEL_14;
  }
  BOOL v4 = __OFSUB__(v5, 1);
  uint64_t v6 = v5 - 1;
  if (v4)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if ((v6 & 0x8000000000000000) == 0)
  {
    uint64_t v7 = *(void *)(a3 + 16);
    if (v7)
    {
      BOOL v4 = __OFSUB__(0, v7);
      uint64_t v8 = -v7;
      if (!v4)
      {
        BOOL v4 = __OFSUB__(v8, 1);
        uint64_t v9 = v8 - 1;
        if (!v4)
        {
          if (v9 < 0) {
            return result;
          }
          BOOL v4 = __OFADD__(v6, v9);
          uint64_t v10 = v6 + v9;
          if (!v4)
          {
            if ((v10 & 0x8000000000000000) == 0) {
              *(void *)(*(void *)result + 16) = ~v10;
            }
            return result;
          }
LABEL_17:
          __break(1u);
          return result;
        }
LABEL_16:
        __break(1u);
        goto LABEL_17;
      }
LABEL_15:
      __break(1u);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)(atomic_ullong *a1, atomic_ullong *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = type metadata accessor for KeyPath(0, a4, a5, a4);
  if (!swift_dynamicCastClass((uint64_t)a1, (uint64_t)v12)
    || (char v14 = type metadata accessor for KeyPath(0, a5, a6, v13), !swift_dynamicCastClass((uint64_t)a2, (uint64_t)v14))
    || (uint64_t v16 = type metadata accessor for KeyPath(0, a4, a6, v15),
        uint64_t v17 = _appendingKeyPaths<A, B, C, D>(root:leaf:)(a1, a2, (uint64_t)v16),
        uint64_t v19 = v17,
        _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)&v19, (uint64_t)a1, (uint64_t)a2),
        !swift_dynamicCastClass(v17, a3)))
  {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  return v17;
}

Swift::UnsafeRawPointer __swiftcall _swift_getKeyPath(pattern:arguments:)(Swift::UnsafeMutableRawPointer pattern, Swift::UnsafeRawPointer arguments)
{
  if ((((uint64_t)pattern._rawValue + 20) & 3) != 0) {
    goto LABEL_20;
  }
  if ((*((unsigned char *)pattern._rawValue + 23) & 0x3F) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Reserved bits set to an unexpected bit pattern", 46, 2, "Swift/KeyPath.swift", 19, 2, 0x7B5uLL, 0);
  }
  if (((uint64_t)pattern._rawValue & 3) != 0) {
    goto LABEL_20;
  }
  uint64_t v3 = *(int *)pattern._rawValue;
  if (v3)
  {
    BOOL v4 = (atomic_ullong **)((char *)pattern._rawValue + v3);
    if (!((char *)pattern._rawValue + v3)) {
      goto LABEL_13;
    }
    if ((v4 & 7) != 0)
    {
      unint64_t v14 = 440;
LABEL_21:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, v14, 0);
    }
    uint64_t v5 = *v4;
    if (*v4)
    {
      swift_retain(*v4);
      return (Swift::UnsafeRawPointer)v5;
    }
  }
  else
  {
    BOOL v4 = 0;
  }
  _getKeyPathClassAndInstanceSizeFromPattern(_:_:)((uint64_t)pattern._rawValue + 4, (uint64_t)arguments._rawValue);
  uint64_t v7 = MEMORY[0x1F4188790](v6);
  uint64_t v8 = static AnyKeyPath._create(capacityInBytes:initializedBy:)(v7, (void (*)(void *, char *))partial apply for closure #1 in _swift_getKeyPath(pattern:arguments:));
  uint64_t v9 = (int *)((char *)pattern._rawValue + 16);
  if ((((uint64_t)pattern._rawValue + 16) & 3) != 0)
  {
LABEL_20:
    unint64_t v14 = 1273;
    goto LABEL_21;
  }
  uint64_t v5 = v8;
  uint64_t v10 = *v9;
  if (v10)
  {
    uint64_t v11 = (char *)v9 + v10;
    if (!v11) {
LABEL_13:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    v8[2] = (atomic_ullong)v11;
  }
  else
  {
    v8[2] = 0;
  }
  if (v4)
  {
    swift_retain(v8);
    uint64_t v12 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)v4, (unint64_t *)&v12, (unint64_t)v5);
    if (v12)
    {
      swift_retain(v12);
      swift_release_n((uint64_t)v5, 2);
      return (Swift::UnsafeRawPointer)v12;
    }
  }
  return (Swift::UnsafeRawPointer)v5;
}

Class *_getKeyPathClassAndInstanceSizeFromPattern(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 8;
  __int16 v8 = 1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = a2;
  int v13 = 0;
  unint64_t v14 = &_swiftEmptyArrayStorage;
  specialized _walkKeyPathPattern<A>(_:walker:)(a1, &v7);
  if (HIBYTE(v8) == 1) {
    LOBYTE(v8) = 0;
  }
  if (!v9)
  {
    unint64_t v6 = 3425;
    goto LABEL_13;
  }
  if (!v10)
  {
    unint64_t v6 = 3423;
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/KeyPath.swift", 19, 2, v6, 0);
  }
  if ((_BYTE)v8)
  {
    if (v8 == 1) {
      uint64_t v3 = type metadata accessor for WritableKeyPath(0, v9, v10, v2);
    }
    else {
      uint64_t v3 = type metadata accessor for ReferenceWritableKeyPath(0, v9, v10, v2);
    }
  }
  else
  {
    uint64_t v3 = type metadata accessor for KeyPath(0, v9, v10, v2);
  }
  BOOL v4 = v3;
  swift_bridgeObjectRelease((uint64_t)v14);
  return v4;
}

unint64_t _instantiateKeyPathBuffer(_:_:_:_:)(uint64_t a1, _DWORD *a2, unsigned char *a3, void *a4, void *a5)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  unint64_t v6 = a3 - (unsigned char *)a2 - 8;
  if (__OFSUB__(a3 - (unsigned char *)a2, 8))
  {
    __break(1u);
LABEL_20:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if ((v6 & 0x8000000000000000) != 0) {
    goto LABEL_20;
  }
  v14[0].value._rawValue = a2 + 2;
  v14[1].value._rawValue = a3;
  v14[2].value._rawValue = 0;
  v14[3].value._rawValue = a5;
  v14[4].value._rawValue = a4;
  unsigned int v15 = 0;
  uint64_t v16 = &_swiftEmptyArrayStorage;
  char v17 = 1;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  specialized _walkKeyPathPattern<A>(_:walker:)(a1, v14);
  if (HIDWORD(v6)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
  uint64_t v7 = v18;
  if (v17 != 1)
  {
    if (v18) {
      goto LABEL_7;
    }
LABEL_10:
    *a2 = v6;
    goto LABEL_11;
  }
  LODWORD(v6) = v6 | 0x80000000;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_7:
  *a2 = v6 | 0x40000000;
  if ((v7 & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
  }
  *v7 |= 0x80000000;
LABEL_11:
  __int16 v8 = v16[2];
  if (v8)
  {
    uint64_t v9 = (char *)(v16 + 4);
    char v10 = 1;
    do
    {
      char v11 = *v9++;
      v10 &= v11;
      __int16 v8 = (__objc2_class *)((char *)v8 - 1);
    }
    while (v8);
  }
  else
  {
    char v10 = 1;
  }
  swift_bridgeObjectRelease((uint64_t)v16);
  uint64_t v12 = v15;
  LOBYTE(v14[0].value._rawValue) = (v10 & 1) == 0;
  if ((v10 & 1) == 0) {
    uint64_t v12 = 0;
  }
  return v12 | ((unint64_t)((v10 & 1) == 0) << 32);
}

BOOL static UInt8.<= infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a2 >= a1;
}

uint64_t _getTypeByMangledNameInEnvironmentOrContext(_:_:genericEnvironmentOrContext:genericArguments:)(unsigned __int8 *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    return swift_getTypeByMangledNameInContext(a1, a2, a3 & 0xFFFFFFFFFFFFFFFELL, a4);
  }
  else {
    return swift_getTypeByMangledNameInEnvironment(a1, a2, a3, a4);
  }
}

uint64_t _Pointer.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a1)
  {
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 56))(a4, a1, a2);
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 1;
  }
  uint64_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56);

  return v7(a4, v6, 1, a2);
}

Swift::UnsafeRawPointer __swiftcall _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)(Swift::UnsafeRawPointer _, Swift::UnsafeRawPointer_optional genericEnvironment, Swift::UnsafeRawPointer_optional arguments)
{
  if (((uint64_t)_._rawValue & 1) == 0) {
    return _;
  }
  BOOL v4 = (uint8x16_t *)((char *)_._rawValue - 1);
  unsigned int v3 = *((unsigned __int8 *)_._rawValue - 1);
  uint64_t v5 = (char *)_._rawValue - 1;
  if (!*((unsigned char *)_._rawValue - 1))
  {
LABEL_15:
    uint64_t v10 = v5 - (unsigned char *)v4;
    if (v5 - (unsigned char *)v4 == 0x7FFFFFFFFFFFFFFFLL)
    {
      __break(1u);
    }
    else if ((v10 & 0x8000000000000000) == 0)
    {
      _._rawValue = (Builtin::RawPointer)_getTypeByMangledNameInEnvironmentOrContext(_:_:genericEnvironmentOrContext:genericArguments:)((unsigned __int8 *)_._rawValue - 1, v5 - (unsigned char *)v4, (uint64_t)genericEnvironment.value._rawValue, (uint64_t)arguments.value._rawValue);
      if (_._rawValue) {
        return _;
      }
      int64_t v11 = validateUTF8(_:)(v4->i64, v10);
      if (v13) {
        uint64_t v14 = repairUTF8(_:firstKnownBrokenRange:)(v4->i8, v10, v11, v12);
      }
      else {
        uint64_t v14 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v4, v10, v11 & 1);
      }
      unint64_t v16 = v14;
      unint64_t v17 = v15;
      unint64_t v18 = specialized static String._createEmpty(withInitialCapacity:)(41);
      uint64_t v20 = v19;
      unint64_t v41 = v18;
      unint64_t v42 = v19;
      uint64_t v21 = HIBYTE(v19) & 0xF;
      if ((v19 & 0x2000000000000000) == 0) {
        uint64_t v21 = v18 & 0xFFFFFFFFFFFFLL;
      }
      if (v21 || (v18 & ~v19 & 0x2000000000000000) != 0)
      {
        if ((v19 & 0x2000000000000000) == 0
          || (0x80000001816E2FF0 & 0x2000000000000000) == 0
          || (unint64_t v24 = specialized _SmallString.init(_:appending:)(v18, v19, 0xD000000000000026, 0x80000001816E2FF0 | 0x8000000000000000), (v26 & 1) != 0))
        {
          if ((0x80000001816E2FF0 & 0x2000000000000000) != 0) {
            unint64_t v27 = (0x80000001816E2FF0 >> 56) & 0xF;
          }
          else {
            unint64_t v27 = 38;
          }
          _StringGuts.append(_:)(0xD000000000000026, 0x80000001816E2FF0 | 0x8000000000000000, 0, v27);
          swift_bridgeObjectRelease(0x80000001816E2FF0 | 0x8000000000000000);
          unint64_t v22 = v41;
          unint64_t v23 = v42;
LABEL_38:
          uint64_t v28 = HIBYTE(v23) & 0xF;
          if ((v23 & 0x2000000000000000) == 0) {
            uint64_t v28 = v22 & 0xFFFFFFFFFFFFLL;
          }
          if (!v28 && (v22 & ~v23 & 0x2000000000000000) == 0)
          {
            swift_bridgeObjectRetain(v17);
            swift_bridgeObjectRelease(v23);
            unint64_t v41 = v16;
            unint64_t v42 = v17;
            goto LABEL_53;
          }
          if ((v23 & 0x2000000000000000) != 0)
          {
            if ((v17 & 0x2000000000000000) != 0)
            {
              unint64_t v30 = specialized _SmallString.init(_:appending:)(v22, v23, v16, v17);
              if ((v32 & 1) == 0)
              {
                unint64_t v33 = v30;
                unint64_t v34 = v31;
                swift_bridgeObjectRelease(v23);
                unint64_t v41 = v33;
                unint64_t v42 = v34;
                unint64_t v17 = v34;
                unint64_t v16 = v33;
                goto LABEL_53;
              }
              goto LABEL_51;
            }
          }
          else if ((v17 & 0x2000000000000000) != 0)
          {
LABEL_51:
            uint64_t v29 = HIBYTE(v17) & 0xF;
            goto LABEL_52;
          }
          uint64_t v29 = v16 & 0xFFFFFFFFFFFFLL;
LABEL_52:
          _StringGuts.append(_:)(v16, v17, 0, v29);
          unint64_t v16 = v41;
          unint64_t v17 = v42;
LABEL_53:
          uint64_t v35 = HIBYTE(v17) & 0xF;
          if ((v17 & 0x2000000000000000) == 0) {
            uint64_t v35 = v16 & 0xFFFFFFFFFFFFLL;
          }
          if (v35 || (v16 & ~v17 & 0x2000000000000000) != 0)
          {
            if ((v17 & 0x2000000000000000) == 0
              || (unint64_t v38 = specialized _SmallString.init(_:appending:)(v16, v17, 0x27uLL, 0xE100000000000000),
                  (v40 & 1) != 0))
            {
              _StringGuts.append(_:)(39, 0xE100000000000000, 0, 1);
              swift_bridgeObjectRelease(0xE100000000000000);
              uint64_t v37 = v41;
              unint64_t v36 = v42;
            }
            else
            {
              uint64_t v37 = v38;
              unint64_t v36 = v39;
              swift_bridgeObjectRelease(v17);
              swift_bridgeObjectRelease(0xE100000000000000);
            }
          }
          else
          {
            swift_bridgeObjectRelease(v17);
            unint64_t v36 = 0xE100000000000000;
            uint64_t v37 = 39;
          }
          _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v37, v36, "Swift/KeyPath.swift", 19, 2, 0xB16uLL, 0);
        }
        unint64_t v22 = v24;
        unint64_t v23 = v25;
        swift_bridgeObjectRelease(v20);
        swift_bridgeObjectRelease(0x80000001816E2FF0 | 0x8000000000000000);
      }
      else
      {
        unint64_t v22 = 0xD000000000000026;
        swift_bridgeObjectRelease(v19);
        unint64_t v23 = 0x80000001816E2FF0 | 0x8000000000000000;
      }
      unint64_t v41 = v22;
      unint64_t v42 = v23;
      goto LABEL_38;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  if (v3 != 255)
  {
    uint64_t v5 = (char *)_._rawValue - 1;
    do
    {
LABEL_10:
      uint64_t v7 = 9;
      if (v3 > 0x1F) {
        uint64_t v7 = 1;
      }
      BOOL v8 = v3 > 0x17;
      uint64_t v9 = 5;
      if (v8) {
        uint64_t v9 = v7;
      }
      v5 += v9;
      unsigned int v3 = *v5;
    }
    while (*v5);
    goto LABEL_15;
  }
  uint64_t v5 = (char *)_._rawValue - 1;
  if (*(unsigned char *)_._rawValue != 9) {
    goto LABEL_10;
  }
  uint64_t v6 = (uint64_t (*)(Builtin::RawPointer))((char *)_._rawValue + *(int *)((char *)_._rawValue + 1) + 1);
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }

  return (Swift::UnsafeRawPointer)v6(arguments.value._rawValue);
}

uint64_t UnsafeRawPointer.bindMemory<A>(to:capacity:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

Swift::UnsafeRawPointer __swiftcall _resolveRelativeIndirectableAddress(_:_:)(Swift::UnsafeRawPointer a1, Swift::Int32 a2)
{
  if (a2)
  {
    if (__OFSUB__(a2, 1))
    {
      __break(1u);
    }
    else
    {
      unsigned int v3 = (Swift::UnsafeRawPointer *)((char *)a1._rawValue + a2 - 1);
      if (!v3) {
        goto LABEL_11;
      }
      if ((v3 & 7) == 0) {
        return (Swift::UnsafeRawPointer)v3->_rawValue;
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  result._rawValue = (char *)a1._rawValue + a2;
  if (!result._rawValue) {
LABEL_11:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  return result;
}

uint64_t static Int32.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

uint64_t static Int32.- infix(_:_:)(int a1, int a2)
{
  BOOL v2 = __OFSUB__(a1, a2);
  uint64_t result = (a1 - a2);
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(uint64_t a1, uint64_t a2)
{
  if (((a1 + a2) & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  uint64_t result = *(int *)(a1 + a2) + a1 + a2;
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return result;
}

Swift::UnsafeRawPointer specialized _walkKeyPathPattern<A>(_:walker:)(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 0);
  uint64_t v5 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 4);
  uint64_t v6 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 8);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 12);
  a2[4] = v4;
  v7.value._Builtin::RawPointer rawValue = (Builtin::RawPointer)a2[5];
  *((Swift::UnsafeRawPointer *)a2 + 2) = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)((Swift::UnsafeRawPointer)v5, (Swift::UnsafeRawPointer_optional)v4, v7);
  result._Builtin::RawPointer rawValue = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)((Swift::UnsafeRawPointer)v6, (Swift::UnsafeRawPointer_optional)v4, v7)._rawValue;
  a2[3] = (uint64_t)result._rawValue;
  if ((((_BYTE)a1 + 16) & 3) != 0) {
    goto LABEL_74;
  }
  uint64_t v9 = a1 + 20;
  uint64_t v10 = a1 + 20 + (*(_DWORD *)(a1 + 16) & 0xFFFFFF);
  uint64_t v53 = a1 + 20;
  uint64_t v54 = v10;
  while (v54 != v9)
  {
    result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized _pop<A>(from:as:count:)(&v53, 1);
    if (!result._rawValue) {
      goto LABEL_85;
    }
    int v11 = *(_DWORD *)result._rawValue;
    int v12 = HIBYTE(*(_DWORD *)result._rawValue) & 0x7F;
    uint64_t v13 = *(_DWORD *)result._rawValue & 0xFFFFFF;
    if (v12)
    {
      if ((v11 & 0x7D000000) != 0x1000000)
      {
        if (v12 == 2)
        {
          popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(*(_DWORD *)result._rawValue, &v53);
          uint64_t v21 = v20;
          result._Builtin::RawPointer rawValue = (Builtin::RawPointer)popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v11, &v53);
          if (v21)
          {
            if ((v11 & 0x800000) == 0)
            {
              char v22 = 2;
              goto LABEL_37;
            }
          }
          else
          {
            char v22 = 0;
LABEL_37:
            *((unsigned char *)a2 + 8) = v22;
          }
          uint64_t v41 = *a2 + 4;
          if (__OFADD__(*a2, 4)) {
            goto LABEL_76;
          }
          *a2 = v41;
          BOOL v23 = __OFADD__(v41, 7);
          uint64_t v42 = v41 + 7;
          if (v23) {
            goto LABEL_77;
          }
          unint64_t v43 = v42 & 0xFFFFFFFFFFFFFFF8;
          BOOL v23 = __OFADD__(v43, 16);
          uint64_t v44 = v43 + 16;
          if (v23) {
            goto LABEL_78;
          }
          *a2 = v44;
          if (v21)
          {
            BOOL v23 = __OFADD__(v44, 8);
            v44 += 8;
            if (v23) {
              goto LABEL_79;
            }
            *a2 = v44;
          }
          if (result._rawValue)
          {
            uint64_t v45 = v44 + 16;
            if (__OFADD__(v44, 16)) {
              goto LABEL_80;
            }
            result._Builtin::RawPointer rawValue = (Builtin::RawPointer)((uint64_t (*)(uint64_t))result._rawValue)(a2[5]);
            uint64_t v35 = (char *)result._rawValue + v45;
            if (__OFADD__(v45, result._rawValue)) {
              goto LABEL_81;
            }
LABEL_53:
            *a2 = (uint64_t)v35;
          }
          uint64_t v34 = v53;
          if (!v53) {
            return result;
          }
          goto LABEL_55;
        }
        if (v13)
        {
          if (v13 == 1)
          {
            *((_WORD *)a2 + 4) = 256;
            uint64_t v35 = (char *)(*a2 + 4);
            if (__OFADD__(*a2, 4)) {
              goto LABEL_82;
            }
          }
          else
          {
            uint64_t v35 = (char *)(*a2 + 4);
            if (__OFADD__(*a2, 4)) {
              goto LABEL_84;
            }
          }
        }
        else
        {
          *((_WORD *)a2 + 4) = 256;
          uint64_t v35 = (char *)(*a2 + 4);
          if (__OFADD__(*a2, 4)) {
            goto LABEL_83;
          }
        }
        goto LABEL_53;
      }
      uint64_t v14 = &v53;
      uint64_t v15 = *(unsigned int *)result._rawValue;
    }
    else
    {
      uint64_t v16 = v53;
      if (!v53) {
        goto LABEL_85;
      }
      unint64_t v17 = (int *)specialized _pop<A>(from:as:count:)(&v53, 1);
      if (!v17) {
        goto LABEL_85;
      }
      uint64_t v18 = *v17;
      if (v18)
      {
        BOOL v23 = __OFSUB__(v18, 1);
        int v24 = v18 - 1;
        if (v23)
        {
          __break(1u);
LABEL_76:
          __break(1u);
LABEL_77:
          __break(1u);
LABEL_78:
          __break(1u);
LABEL_79:
          __break(1u);
LABEL_80:
          __break(1u);
LABEL_81:
          __break(1u);
LABEL_82:
          __break(1u);
LABEL_83:
          __break(1u);
LABEL_84:
          __break(1u);
LABEL_85:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        unint64_t v25 = (unsigned int **)(v16 + v24);
        if (!v25) {
          goto LABEL_85;
        }
        if ((v25 & 7) != 0) {
          goto LABEL_74;
        }
        unint64_t v19 = *v25;
      }
      else
      {
        unint64_t v19 = (unsigned int *)(v16 + v18);
        if (!(v16 + v18)) {
          goto LABEL_85;
        }
      }
      if ((v19 & 3) != 0) {
        goto LABEL_74;
      }
      uint64_t v26 = *v19;
      result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized _pop<A>(from:as:count:)(&v53, v13);
      if (!v26) {
        goto LABEL_61;
      }
      Builtin::RawPointer rawValue = result._rawValue;
      uint64_t v29 = v27;
      unint64_t v30 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v53, 1);
      if (!v30) {
        goto LABEL_85;
      }
      unsigned int v31 = *v30;
      uint64_t v32 = RawKeyPathComponent.Header.patternComponentBodySize.getter(*v30);
      uint64_t v33 = RawKeyPathComponent.Header.propertyDescriptorBodySize.getter(v26);
      v52[0] = (uint64_t)(v19 + 1);
      v52[1] = (uint64_t)v19 + v33 + 4;
      if ((BYTE3(v26) & 0x7D | 2) != 3)
      {
        popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v26, v52);
        uint64_t v37 = v36;
        if ((HIBYTE(v31) & 0x7F) == 2 && (v31 & 0x80000) != 0)
        {
          popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v31, &v53);
          unint64_t v38 = (uint64_t (*)(void))popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v31, &v53);
          uint64_t v39 = v48;
          uint64_t v40 = v49;
        }
        else
        {
          specialized _pop<A>(from:as:count:)(&v53, v32);
          unint64_t v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
        }
        if (v13) {
          uint64_t v50 = (uint64_t)rawValue;
        }
        else {
          uint64_t v50 = 0;
        }
        if (v13) {
          uint64_t v51 = v29;
        }
        else {
          uint64_t v51 = 0;
        }
        result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)((v26 >> 23) & 1, v37, v38, v39, v40, v50, v51, v13 == 0);
        uint64_t v34 = v53;
        if (!v53) {
          return result;
        }
        goto LABEL_55;
      }
      specialized _pop<A>(from:as:count:)(&v53, v32);
      uint64_t v14 = v52;
      uint64_t v15 = v26;
    }
    result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v15, v14, a2);
    uint64_t v34 = v53;
    if (!v53) {
      return result;
    }
LABEL_55:
    if (v54 == v34) {
      return result;
    }
    result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized _pop<A>(from:as:count:)(&v53, 1);
    if (!result._rawValue || !(v34 + *(int *)result._rawValue)) {
      goto LABEL_85;
    }
    if (__OFADD__(*a2, 7))
    {
      __break(1u);
LABEL_73:
      __break(1u);
LABEL_74:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
    }
    unint64_t v46 = (*a2 + 7) & 0xFFFFFFFFFFFFFFF8;
    BOOL v23 = __OFADD__(v46, 8);
    uint64_t v47 = v46 + 8;
    if (v23) {
      goto LABEL_73;
    }
    *a2 = v47;
LABEL_61:
    uint64_t v9 = v53;
    if (!v53) {
      return result;
    }
  }
  return result;
}

uint64_t specialized _walkKeyPathPattern<A>(_:walker:)(uint64_t a1, Swift::UnsafeRawPointer_optional *a2)
{
  uint64_t v4 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 0);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 4);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 8);
  uint64_t result = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 12);
  a2[2].value._Builtin::RawPointer rawValue = (Builtin::RawPointer)v4;
  if ((((_BYTE)a1 + 16) & 3) != 0) {
LABEL_82:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  uint64_t v6 = a1 + 20;
  uint64_t v7 = a1 + 20 + (*(_DWORD *)(a1 + 16) & 0xFFFFFF);
  uint64_t v74 = a1 + 20;
  uint64_t v75 = v7;
  while (v75 != v6)
  {
    BOOL v8 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v74, 1);
    if (!v8) {
      goto LABEL_84;
    }
    unsigned int v9 = *v8;
    int v10 = HIBYTE(*v8) & 0x7F;
    uint64_t v11 = *v8 & 0xFFFFFF;
    if (v10)
    {
      if ((v9 & 0x7D000000) == 0x1000000)
      {
        uint64_t result = (uint64_t)specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(*v8, &v74);
      }
      else if (v10 == 2)
      {
        uint64_t v16 = popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(*v8, &v74);
        uint64_t v18 = v17;
        uint64_t v20 = v19;
        uint64_t v22 = v21;
        uint64_t v25 = popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v9, &v74);
        LODWORD(v26) = (v9 >> 19) & 2;
        if ((v9 & 0x200000) != 0) {
          uint64_t v26 = 1;
        }
        else {
          uint64_t v26 = v26;
        }
        uint64_t v27 = v9 & 0xF;
        if ((v9 & 0xF) != 0)
        {
          if (v27 == 2) {
            unsigned int v28 = 2;
          }
          else {
            unsigned int v28 = 3;
          }
          if (v27 == 3) {
            uint64_t v27 = 1;
          }
          else {
            uint64_t v27 = v28;
          }
        }
        LOBYTE(v71) = 1;
        uint64_t result = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, int))InstantiateKeyPathBuffer.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:))((v9 >> 23) & 1, v26, v27, v16, v18, v20, v22, v25, v23, v24, 0, 0, v71);
      }
      else if (v11)
      {
        if (v11 == 1)
        {
          Builtin::RawPointer rawValue = (__objc2_class **)a2[6].value._rawValue;
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)rawValue);
          a2[6].value._Builtin::RawPointer rawValue = rawValue;
          if (!isUniquelyReferenced_nonNull_native)
          {
            Builtin::RawPointer rawValue = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&rawValue[2]->isa + 1, 1, (uint64_t)rawValue);
            a2[6].value._Builtin::RawPointer rawValue = rawValue;
          }
          unint64_t v43 = rawValue[2];
          unint64_t v42 = (unint64_t)rawValue[3];
          if ((unint64_t)v43 >= v42 >> 1) {
            Builtin::RawPointer rawValue = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v42 > 1), (int64_t)&v43->isa + 1, 1, (uint64_t)rawValue);
          }
          rawValue[2] = (__objc2_class *)((char *)&v43->isa + 1);
          *((unsigned char *)&v43->info + (void)rawValue) = 0;
          a2[6].value._Builtin::RawPointer rawValue = rawValue;
          if (!a2->value._rawValue) {
            goto LABEL_84;
          }
          a2[9].value._Builtin::RawPointer rawValue = a2->value._rawValue;
          uint64_t result = (uint64_t)specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(67108865);
        }
        else
        {
          uint64_t v57 = (__objc2_class **)a2[6].value._rawValue;
          BOOL v58 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v57);
          a2[6].value._Builtin::RawPointer rawValue = v57;
          if (!v58)
          {
            uint64_t v57 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v57[2]->isa + 1, 1, (uint64_t)v57);
            a2[6].value._Builtin::RawPointer rawValue = v57;
          }
          uint64_t v60 = v57[2];
          unint64_t v59 = (unint64_t)v57[3];
          if ((unint64_t)v60 >= v59 >> 1) {
            uint64_t v57 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v59 > 1), (int64_t)&v60->isa + 1, 1, (uint64_t)v57);
          }
          v57[2] = (__objc2_class *)((char *)&v60->isa + 1);
          *((unsigned char *)&v60->info + (void)v57) = 0;
          a2[6].value._Builtin::RawPointer rawValue = v57;
          if (!a2->value._rawValue) {
            goto LABEL_84;
          }
          a2[9].value._Builtin::RawPointer rawValue = a2->value._rawValue;
          uint64_t result = (uint64_t)specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(67108866);
        }
      }
      else
      {
        uint64_t v53 = (__objc2_class **)a2[6].value._rawValue;
        BOOL v54 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v53);
        a2[6].value._Builtin::RawPointer rawValue = v53;
        if (!v54)
        {
          uint64_t v53 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v53[2]->isa + 1, 1, (uint64_t)v53);
          a2[6].value._Builtin::RawPointer rawValue = v53;
        }
        unint64_t v56 = v53[2];
        unint64_t v55 = (unint64_t)v53[3];
        if ((unint64_t)v56 >= v55 >> 1) {
          uint64_t v53 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v55 > 1), (int64_t)&v56->isa + 1, 1, (uint64_t)v53);
        }
        v53[2] = (__objc2_class *)((char *)&v56->isa + 1);
        *((unsigned char *)&v56->info + (void)v53) = 0;
        a2[6].value._Builtin::RawPointer rawValue = v53;
        if (!a2->value._rawValue) {
          goto LABEL_84;
        }
        a2[9].value._Builtin::RawPointer rawValue = a2->value._rawValue;
        uint64_t result = (uint64_t)specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(0x4000000);
      }
      goto LABEL_75;
    }
    uint64_t v12 = v74;
    if (!v74) {
      goto LABEL_84;
    }
    uint64_t v13 = (int *)specialized _pop<A>(from:as:count:)(&v74, 1);
    if (!v13) {
      goto LABEL_84;
    }
    uint64_t v14 = *v13;
    if (v14)
    {
      BOOL v29 = __OFSUB__(v14, 1);
      int v30 = v14 - 1;
      if (v29)
      {
        __break(1u);
LABEL_84:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
      }
      unsigned int v31 = (unsigned int **)(v12 + v30);
      if (!v31) {
        goto LABEL_84;
      }
      if ((v31 & 7) != 0) {
        goto LABEL_82;
      }
      uint64_t v15 = *v31;
    }
    else
    {
      uint64_t v15 = (unsigned int *)(v12 + v14);
      if (!(v12 + v14)) {
        goto LABEL_84;
      }
    }
    if ((v15 & 3) != 0) {
      goto LABEL_82;
    }
    unsigned int v32 = *v15;
    uint64_t result = specialized _pop<A>(from:as:count:)(&v74, v11);
    if (v32)
    {
      uint64_t v34 = result;
      uint64_t v35 = v33;
      uint64_t v36 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v74, 1);
      if (!v36) {
        goto LABEL_84;
      }
      unsigned int v37 = *v36;
      uint64_t v38 = RawKeyPathComponent.Header.patternComponentBodySize.getter(*v36);
      uint64_t v39 = RawKeyPathComponent.Header.propertyDescriptorBodySize.getter(v32);
      v73[0] = (uint64_t)(v15 + 1);
      v73[1] = (uint64_t)v15 + v39 + 4;
      if ((HIBYTE(v32) & 0x7D | 2) == 3)
      {
        specialized _pop<A>(from:as:count:)(&v74, v38);
        uint64_t result = (uint64_t)specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v32, v73);
      }
      else
      {
        uint64_t v72 = popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v32, v73);
        uint64_t v45 = v44;
        uint64_t v47 = v46;
        uint64_t v49 = v48;
        if ((HIBYTE(v37) & 0x7F) == 2 && (v37 & 0x80000) != 0)
        {
          popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v37, &v74);
          uint64_t v50 = popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v37, &v74);
        }
        else
        {
          specialized _pop<A>(from:as:count:)(&v74, v38);
          uint64_t v50 = 0;
          uint64_t v51 = 0;
          uint64_t v52 = 0;
        }
        LODWORD(v61) = (v32 >> 19) & 2;
        if ((v32 & 0x200000) != 0) {
          uint64_t v61 = 1;
        }
        else {
          uint64_t v61 = v61;
        }
        uint64_t v62 = v32 & 0xF;
        if ((v32 & 0xF) != 0)
        {
          if (v62 == 2) {
            unsigned int v63 = 2;
          }
          else {
            unsigned int v63 = 3;
          }
          if (v62 == 3) {
            uint64_t v62 = 1;
          }
          else {
            uint64_t v62 = v63;
          }
        }
        if (v11) {
          uint64_t v64 = v34;
        }
        else {
          uint64_t v64 = 0;
        }
        if (v11) {
          uint64_t v65 = v35;
        }
        else {
          uint64_t v65 = 0;
        }
        LOBYTE(v71) = v11 == 0;
        uint64_t result = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))InstantiateKeyPathBuffer.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:))((v32 >> 23) & 1, v61, v62, v72, v45, v47, v49, v50, v51, v52, v64, v65, v71);
      }
LABEL_75:
      uint64_t v66 = v74;
      if (!v74 || v75 == v74) {
        return result;
      }
      uint64_t v67 = (int *)specialized _pop<A>(from:as:count:)(&v74, 1);
      if (!v67) {
        goto LABEL_84;
      }
      v68._Builtin::RawPointer rawValue = (Builtin::RawPointer)(v66 + *v67);
      if (!v68._rawValue) {
        goto LABEL_84;
      }
      Builtin::RawPointer v69 = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)(v68, a2[2], a2[3])._rawValue;
      v73[0] = (uint64_t)v69;
      unint64_t MetatypeMetadata = swift_getMetatypeMetadata((unint64_t)v69);
      uint64_t result = (uint64_t)InstantiateKeyPathBuffer.pushDest<A>(_:)(v73, MetatypeMetadata);
      a2[4].value._Builtin::RawPointer rawValue = v69;
    }
    uint64_t v6 = v74;
    if (!v74) {
      return result;
    }
  }
  return result;
}

uint64_t specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  unsigned int v4 = result;
  int v5 = result & 0x7FFFFF;
  if ((result & 0x7FFFFF) == 0x7FFFFD)
  {
    v6._Builtin::RawPointer rawValue = (Builtin::RawPointer)*a2;
    if (!*a2 || (uint64_t v7 = (Swift::Int32 *)specialized _pop<A>(from:as:count:)(a2, 1)) == 0) {
LABEL_23:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    uint64_t result = (uint64_t)_resolveRelativeIndirectableAddress(_:_:)(v6, *v7)._rawValue;
    goto LABEL_9;
  }
  if (v5 == 8388606 || v5 == 0x7FFFFF)
  {
    uint64_t result = specialized _pop<A>(from:as:count:)(a2, 1);
    if (!result) {
      goto LABEL_23;
    }
LABEL_9:
    int v8 = 0;
    goto LABEL_11;
  }
  int v8 = 1;
LABEL_11:
  if ((HIBYTE(v4) & 0x7F) == 1)
  {
    if ((v4 & 0x800000) != 0) {
      goto LABEL_16;
    }
    LOBYTE(v9) = 0;
  }
  else
  {
    int v9 = (v4 >> 22) & 2;
  }
  *((unsigned char *)a3 + 8) = v9;
LABEL_16:
  uint64_t v10 = *a3;
  if (v8)
  {
    uint64_t v11 = v10 + 4;
    if (!__OFADD__(v10, 4)) {
      goto LABEL_21;
    }
    __break(1u);
  }
  uint64_t v11 = v10 + 8;
  if (__OFADD__(v10, 8))
  {
    __break(1u);
    goto LABEL_23;
  }
LABEL_21:
  *a3 = v11;
  return result;
}

_DWORD *specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(unsigned int a1, uint64_t *a2)
{
  Builtin::RawPointer rawValue = (_DWORD *)(a1 & 0x7FFFFF);
  switch(rawValue)
  {
    case 0x7FFFFD:
      v6._Builtin::RawPointer rawValue = (Builtin::RawPointer)*a2;
      if (!*a2) {
        goto LABEL_16;
      }
      uint64_t v7 = (Swift::Int32 *)specialized _pop<A>(from:as:count:)(a2, 1);
      if (!v7) {
        goto LABEL_16;
      }
      Builtin::RawPointer rawValue = _resolveRelativeIndirectableAddress(_:_:)(v6, *v7)._rawValue;
      char v5 = 3;
      break;
    case 0x7FFFFE:
      int v8 = (unsigned int *)specialized _pop<A>(from:as:count:)(a2, 1);
      if (!v8) {
        goto LABEL_16;
      }
      Builtin::RawPointer rawValue = (_DWORD *)*v8;
      char v5 = 2;
      break;
    case 0x7FFFFF:
      unsigned int v4 = (unsigned int *)specialized _pop<A>(from:as:count:)(a2, 1);
      if (v4)
      {
        Builtin::RawPointer rawValue = (_DWORD *)*v4;
        char v5 = 1;
        break;
      }
LABEL_16:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    default:
      char v5 = 0;
      break;
  }
  if ((HIBYTE(a1) & 0x7F) <= 3u) {
    char v9 = (0xDu >> (HIBYTE(a1) & 0xF)) & 1;
  }
  else {
    char v9 = 1;
  }
  return InstantiateKeyPathBuffer.visitStoredComponent(kind:mutable:offset:)(v9, (a1 & 0x800000) != 0, rawValue, v5);
}

uint64_t popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(int a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2
    || !specialized _pop<A>(from:as:count:)(a2, 1)
    || (uint64_t v5 = *a2) == 0
    || (Swift::UnsafeRawPointer v6 = (int *)specialized _pop<A>(from:as:count:)(a2, 1)) == 0
    || !(v5 + *v6)
    || (a1 & 0x400000) != 0
    && ((uint64_t v7 = *a2) == 0 || (v8 = (int *)specialized _pop<A>(from:as:count:)(a2, 1)) == 0 || !(v7 + *v8)))
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  return v2;
}

uint64_t popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(int a1, uint64_t *a2)
{
  if ((a1 & 0x80000) == 0) {
    return 0;
  }
  uint64_t v4 = *a2;
  if (!*a2
    || (uint64_t v5 = (int *)specialized _pop<A>(from:as:count:)(a2, 1)) == 0
    || (uint64_t v6 = *v5, !(v4 + v6))
    || (uint64_t v7 = *a2) == 0
    || (v2 = v4 + v6, (int v8 = (int *)specialized _pop<A>(from:as:count:)(a2, 1)) == 0))
  {
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v9 = *v8;
  if (v9)
  {
    if (!(v7 + v9)) {
      goto LABEL_16;
    }
    uint64_t v10 = *a2;
    if (!*a2) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v10 = *a2;
    if (!*a2) {
      goto LABEL_16;
    }
  }
  uint64_t v11 = (int *)specialized _pop<A>(from:as:count:)(a2, 1);
  if (!v11 || !(v10 + *v11)) {
    goto LABEL_16;
  }
  return v2;
}

uint64_t specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)()
{
  uint64_t v1 = *v0;
  if (!*v0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if ((v1 & 3) != 0) {
    uint64_t v2 = 4 - (*v0 & 3);
  }
  else {
    uint64_t v2 = 0;
  }
  return v1 + v2;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;

  uint64_t v1 = *v0;
  if (!*v0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if ((v1 & 7) != 0) {
    uint64_t v2 = 8 - (*v0 & 7);
  }
  else {
    uint64_t v2 = 0;
  }
  return v1 + v2;
}

uint64_t InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *v2;
  if (!*v2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80);
  if ((v4 & v3) != 0) {
    uint64_t v5 = v4 - (v4 & v3) + 1;
  }
  else {
    uint64_t v5 = 0;
  }
  return v3 + v5;
}

_DWORD *specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(int a1)
{
  uint64_t result = (_DWORD *)specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)();
  *uint64_t result = a1;
  uint64_t v5 = *v1;
  if (*v1) {
    uint64_t v5 = v1[1] - v5;
  }
  BOOL v6 = __OFSUB__(v5, 4);
  uint64_t v7 = v5 - 4;
  if (v6)
  {
    __break(1u);
    goto LABEL_8;
  }
  BOOL v6 = __OFSUB__(v7, v4);
  uint64_t v8 = v7 - v4;
  if (v6)
  {
LABEL_8:
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if (v8 < 0) {
    goto LABEL_9;
  }
  *uint64_t v1 = (uint64_t)(result + 1);
  v1[1] = (uint64_t)result + v8 + 4;
  return result;
}

void *specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(uint64_t a1)
{
  uint64_t result = (void *)specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)();
  *uint64_t result = a1;
  uint64_t v5 = *v1;
  if (*v1) {
    uint64_t v5 = v1[1] - v5;
  }
  BOOL v6 = __OFSUB__(v5, 8);
  uint64_t v7 = v5 - 8;
  if (v6)
  {
    __break(1u);
    goto LABEL_8;
  }
  BOOL v6 = __OFSUB__(v7, v4);
  uint64_t v8 = v7 - v4;
  if (v6)
  {
LABEL_8:
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if (v8 < 0) {
    goto LABEL_9;
  }
  *uint64_t v1 = (uint64_t)(result + 1);
  v1[1] = (uint64_t)result + v8 + 8;
  return result;
}

void *InstantiateKeyPathBuffer.pushDest<A>(_:)(const void *a1, uint64_t a2)
{
  size_t v4 = *(void *)(*(void *)(a2 - 8) + 64);
  uint64_t v5 = (char *)InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)((uint64_t)a1, a2);
  if ((v4 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  uint64_t v7 = v5;
  uint64_t v8 = v6;
  uint64_t result = memcpy(v5, a1, v4);
  uint64_t v10 = *v2;
  if (*v2) {
    uint64_t v10 = v2[1] - v10;
  }
  BOOL v11 = __OFSUB__(v10, v4);
  size_t v12 = v10 - v4;
  if (v11)
  {
    __break(1u);
    goto LABEL_10;
  }
  BOOL v11 = __OFSUB__(v12, v8);
  size_t v13 = v12 - v8;
  if (v11)
  {
LABEL_10:
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if ((v13 & 0x8000000000000000) != 0) {
    goto LABEL_11;
  }
  uint64_t *v2 = (uint64_t)&v7[v4];
  v2[1] = (uint64_t)&v7[v4 + v13];
  return result;
}

Swift::Void __swiftcall InstantiateKeyPathBuffer.pushAddressDiscriminatedFunctionPointer(_:discriminator:)(Swift::UnsafeRawPointer _, Swift::UInt64 discriminator)
{
  size_t v4 = (Swift::UnsafeRawPointer *)specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)();
  if (!_._rawValue) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  v4->_Builtin::RawPointer rawValue = _._rawValue;
  uint64_t v6 = *v2;
  if (*v2) {
    uint64_t v6 = v2[1] - v6;
  }
  BOOL v7 = __OFSUB__(v6, 8);
  uint64_t v8 = v6 - 8;
  if (v7)
  {
    __break(1u);
    goto LABEL_9;
  }
  BOOL v7 = __OFSUB__(v8, v5);
  uint64_t v9 = v8 - v5;
  if (v7)
  {
LABEL_9:
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if (v9 < 0) {
    goto LABEL_10;
  }
  uint64_t *v2 = (uint64_t)&v4[1];
  v2[1] = (uint64_t)&v4[1] + v9;
}

_DWORD *InstantiateKeyPathBuffer.visitStoredComponent(kind:mutable:offset:)(char a1, char a2, _DWORD *a3, char a4)
{
  if (!*(void *)v4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v9 = *(void *)(v4 + 72);
  *(void *)(v4 + 72) = *(void *)v4;
  uint64_t v10 = *(__objc2_class ***)(v4 + 48);
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v10);
  *(void *)(v4 + 48) = v10;
  if (a1)
  {
    if (!isUniquelyReferenced_nonNull_native)
    {
      uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v10[2]->isa + 1, 1, (uint64_t)v10);
      *(void *)(v4 + 48) = v10;
    }
    uint64_t v15 = v10[2];
    unint64_t v14 = (unint64_t)v10[3];
    if ((unint64_t)v15 >= v14 >> 1) {
      uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v14 > 1), (int64_t)&v15->isa + 1, 1, (uint64_t)v10);
    }
    v10[2] = (__objc2_class *)((char *)&v15->isa + 1);
    *((unsigned char *)&v15->info + (void)v10) = 0;
    *(void *)(v4 + 48) = v10;
    if (a2) {
      *(void *)(v4 + 64) = v9;
    }
  }
  else
  {
    if (!isUniquelyReferenced_nonNull_native)
    {
      uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v10[2]->isa + 1, 1, (uint64_t)v10);
      *(void *)(v4 + 48) = v10;
    }
    size_t v13 = v10[2];
    unint64_t v12 = (unint64_t)v10[3];
    if ((unint64_t)v13 >= v12 >> 1) {
      uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v12 > 1), (int64_t)&v13->isa + 1, 1, (uint64_t)v10);
    }
    v10[2] = (__objc2_class *)((char *)&v13->isa + 1);
    *((unsigned char *)&v13->info + (void)v10) = 1;
    *(void *)(v4 + 48) = v10;
  }
  switch(a4)
  {
    case 1:
      if (a1) {
        int v25 = 50331648;
      }
      else {
        int v25 = 0x1000000;
      }
      goto LABEL_40;
    case 2:
      uint64_t v22 = (_DWORD **)(*(void *)(v4 + 32) + a3);
      if (a1)
      {
        if ((v22 & 7) == 0)
        {
          a3 = *v22;
          if (!((unint64_t)*v22 >> 32))
          {
            int v25 = 50331648;
            goto LABEL_40;
          }
LABEL_48:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
LABEL_45:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
      }
      if ((v22 & 3) != 0) {
        goto LABEL_45;
      }
      LODWORD(a3) = *(_DWORD *)v22;
      int v23 = *(_DWORD *)(v4 + 40);
      BOOL v20 = __CFADD__(v23, a3);
      int v24 = v23 + a3;
      if (v20)
      {
LABEL_47:
        __break(1u);
        goto LABEL_48;
      }
      *(_DWORD *)(v4 + 40) = v24;
      int v25 = 0x1000000;
LABEL_40:
      if (a2) {
        int v26 = 0xFFFFFF;
      }
      else {
        int v26 = 0x7FFFFF;
      }
LABEL_43:
      specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(v25 | v26);
      return specialized InstantiateKeyPathBuffer.pushDest<A>(_:)((int)a3);
    case 3:
      LODWORD(a3) = *a3;
      if (a1) {
        int v25 = 50331648;
      }
      else {
        int v25 = 0x1000000;
      }
      if (a2) {
        int v26 = 0xFFFFFF;
      }
      else {
        int v26 = 0x7FFFFF;
      }
      goto LABEL_43;
    default:
      if (a1) {
        int v16 = 50331648;
      }
      else {
        int v16 = 0x1000000;
      }
      if (a2) {
        int v17 = 0x800000;
      }
      else {
        int v17 = 0;
      }
      uint64_t result = specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(v16 | v17 | a3);
      if (a1) {
        return result;
      }
      int v19 = *(_DWORD *)(v4 + 40);
      BOOL v20 = __CFADD__(v19, a3);
      int v21 = v19 + a3;
      if (!v20)
      {
        *(_DWORD *)(v4 + 40) = v21;
        return result;
      }
      __break(1u);
      goto LABEL_47;
  }
}

_DWORD *static UInt32.+= infix(_:_:)(_DWORD *result, int a2)
{
  if (__CFADD__(*result, a2))
  {
    __break(1u);
    JUMPOUT(0x181302560);
  }
  *result += a2;
  return result;
}

void *_createOffsetBasedKeyPath(root:value:offset:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for KeyPath(0, (uint64_t)a1, a2, a4);
  BOOL v7 = swift_allocObject((unint64_t *)v6, ((*((unsigned int *)v6 + 12) + 3) & 0x1FFFFFFFCLL) + 12, *((unsigned __int16 *)v6 + 26) | 3);
  v7[2] = 0;
  ((void (*)(void *, char *))partial apply for closure #1 in _createOffsetBasedKeyPath(root:value:offset:))(v7 + 3, (char *)v7 + 36);
  Swift::UInt MetadataKind = swift_getMetadataKind(a1);
  _MetadataKind.init(rawValue:)(MetadataKind);
  if (v10 == 1 && (a3 & 0x8000000000000000) == 0) {
    v7[2] = ~a3;
  }
  return v7;
}

uint64_t _rerootKeyPath<A>(_:to:)(Class **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  if (v5) {
    uint64_t v7 = v6 - v5;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *a1;
  uint64_t v9 = (uint64_t (*)(void))(*a1)[15];
  uint64_t v10 = v9();
  v9();
  uint64_t v12 = v11;
  if (type metadata accessor for ReferenceWritableKeyPath(0, v10, v11, v13) == v8)
  {
    type metadata accessor for ReferenceWritableKeyPath(0, a3, v12, v14);
  }
  else
  {
    if (type metadata accessor for KeyPath(0, v10, v12, v14) != v8) {
      goto LABEL_11;
    }
    type metadata accessor for KeyPath(0, a3, v12, v15);
  }
  if (__OFADD__(v7, 8))
  {
    __break(1u);
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000027, 0x80000001816DE940, "Swift/KeyPath.swift", 19, 2, 0xFB6uLL, 0);
  }
  uint64_t v16 = MEMORY[0x1F4188790](v7 + 8);
  int v17 = static AnyKeyPath._create(capacityInBytes:initializedBy:)(v16, (void (*)(void *, char *))partial apply for closure #2 in _rerootKeyPath<A>(_:to:));
  BOOL v20 = type metadata accessor for PartialKeyPath(0, a3, v18, v19);
  return swift_dynamicCastClassUnconditional((int64_t)v17, v20, 0, 0, 0);
}

unint64_t AnyKeyPath.debugDescription.getter()
{
  uint64_t v2 = (uint64_t)v0;
  unint64_t v3 = *v0;
  uint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(3);
  unint64_t v6 = v4;
  uint64_t v7 = v5;
  unint64_t v172 = v4;
  unint64_t v173 = v5;
  unint64_t v8 = HIBYTE(v5) & 0xF;
  uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000) != 0) {
    uint64_t v10 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v10 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (!v10 && (v4 & ~v5 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v5);
    unint64_t v172 = 92;
    unint64_t v173 = 0xE100000000000000;
    goto LABEL_70;
  }
  if ((v5 & 0x2000000000000000) == 0 || v8 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v7 & 0x1000000000000000) != 0) {
      goto LABEL_185;
    }
    Swift::Int v19 = v10 + 1;
    if (!__OFADD__(v10, 1)) {
      goto LABEL_18;
    }
LABEL_187:
    __break(1u);
    goto LABEL_188;
  }
  uint64_t v11 = 8 * (HIBYTE(v5) & 7);
  uint64_t v12 = (-255 << v11) - 1;
  uint64_t v13 = 92 << v11;
  unint64_t v14 = v13 | v12 & v5;
  unint64_t v15 = v13 | v12 & v4;
  if (v8 >= 8) {
    unint64_t v16 = v14;
  }
  else {
    unint64_t v16 = v5;
  }
  if (v8 < 8) {
    unint64_t v6 = v15;
  }
  swift_bridgeObjectRelease(v5);
  swift_bridgeObjectRelease(0xE100000000000000);
  unint64_t v17 = 0xA000000000000000;
  if (!(v6 & 0x8080808080808080 | v16 & 0x80808080808080)) {
    unint64_t v17 = 0xE000000000000000;
  }
  unint64_t v18 = (v17 & 0xFF00000000000000 | (v8 << 56) | v16 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
LABEL_69:
  unint64_t v172 = v6;
  unint64_t v173 = v18;
  while (1)
  {
LABEL_70:
    Swift::Int v170 = v3;
    uint64_t v56 = (*(uint64_t (**)(void))(v3 + 120))();
    uint64_t v57 = specialized String.init<A>(describing:)(v56);
    uint64_t v9 = v57;
    unint64_t v6 = v58;
    uint64_t v7 = v172;
    unint64_t v3 = v173;
    unint64_t v59 = HIBYTE(v173) & 0xF;
    if ((v173 & 0x2000000000000000) != 0) {
      unint64_t v60 = HIBYTE(v173) & 0xF;
    }
    else {
      unint64_t v60 = v172 & 0xFFFFFFFFFFFFLL;
    }
    if (!v60 && (v172 & ~v173 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v173);
      unint64_t v172 = v9;
      unint64_t v173 = v6;
      goto LABEL_121;
    }
    uint64_t v61 = v58 & 0x2000000000000000;
    unint64_t v38 = HIBYTE(v58) & 0xF;
    if ((v173 & 0x2000000000000000) == 0 || !v61)
    {
      uint64_t v169 = v2;
      goto LABEL_78;
    }
    unint64_t v77 = v59 + v38;
    if (v59 + v38 <= 0xF) {
      break;
    }
    uint64_t v169 = v2;
    uint64_t v61 = 1;
LABEL_78:
    if (v61) {
      uint64_t v2 = HIBYTE(v58) & 0xF;
    }
    else {
      uint64_t v2 = v57 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v58, 2);
    if ((v6 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v6, 5);
      v142._rawBits = 1;
      v143._rawBits = (v2 << 16) | 1;
      v144._rawBits = _StringGuts.validateScalarRange(_:)(v142, v143, v9, v6);
      if (v144._rawBits < 0x10000) {
        v144._rawBits |= 3;
      }
      Swift::Int v62 = specialized Collection.count.getter(v144, v145, v9, v6);
      swift_bridgeObjectRelease(v6);
      if ((v3 & 0x1000000000000000) == 0)
      {
LABEL_83:
        BOOL v63 = __OFADD__(v60, v62);
        Swift::Int v1 = v60 + v62;
        if (!v63) {
          goto LABEL_84;
        }
        goto LABEL_184;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v6, 4);
      Swift::Int v62 = v2;
      if ((v3 & 0x1000000000000000) == 0) {
        goto LABEL_83;
      }
    }
    Swift::Int v146 = String.UTF8View._foreignCount()();
    Swift::Int v1 = v146 + v62;
    if (!__OFADD__(v146, v62))
    {
LABEL_84:
      if ((v7 & ~v3 & 0x2000000000000000) == 0
        || !swift_isUniquelyReferenced_nonNull_native(v3 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v1 >= 16)
        {
          uint64_t v168 = v9 & 0xFFFFFFFFFFFFLL;
          uint64_t v64 = v172;
          uint64_t v7 = v173;
          goto LABEL_93;
        }
        unint64_t v3 = v173;
        if ((v173 & 0x2000000000000000) == 0)
        {
          uint64_t v7 = v173;
          goto LABEL_116;
        }
        int v76 = 0;
        uint64_t v7 = v173;
        goto LABEL_137;
      }
      uint64_t v168 = v9 & 0xFFFFFFFFFFFFLL;
      uint64_t v64 = v172;
      uint64_t v7 = v173;
      int64_t v65 = _StringGuts.nativeUnusedCapacity.getter(v172, v173);
      if ((v66 & 1) == 0)
      {
        if (v1 > 15) {
          goto LABEL_93;
        }
        if ((v7 & 0x2000000000000000) == 0)
        {
          unint64_t v3 = v7;
          if (v65 < v62)
          {
LABEL_116:
            int v76 = 1;
            goto LABEL_137;
          }
LABEL_93:
          int64_t v67 = _StringGuts.nativeUnusedCapacity.getter(v64, v7);
          unint64_t v40 = (v68 & 1) == 0 && v67 >= v62;
          if ((v64 & ~v7 & 0x2000000000000000) == 0
            || !swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
          {
            if ((v40 & 1) == 0) {
              goto LABEL_104;
            }
LABEL_110:
            _StringGuts.grow(_:)(v1);
            goto LABEL_111;
          }
          if (v40)
          {
LABEL_111:
            swift_bridgeObjectRelease_n(v6, 4);
            if ((v6 & 0x1000000000000000) == 0)
            {
              Swift::Int v1 = v170;
              if (v61)
              {
                swift_bridgeObjectRelease_n(v6, 2);
                *(void *)&v171[0] = v9;
                *((void *)&v171[0] + 1) = v6 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v74 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v6) & 0xF, (uint64_t)v171, HIBYTE(v6) & 0xF);
                _StringGuts.appendInPlace(_:isASCII:)(v74, v75, (v6 & 0x4000000000000000) != 0);
                uint64_t v2 = v169;
                swift_bridgeObjectRelease(v6);
              }
              else
              {
                if ((v9 & 0x1000000000000000) != 0)
                {
                  swift_bridgeObjectRelease(v6);
                  id v90 = (id)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v91 = v168;
                  uint64_t v92 = v168;
                }
                else
                {
                  id v90 = _StringObject.sharedUTF8.getter(v9, v6);
                  uint64_t v92 = v160;
                  swift_bridgeObjectRelease(v6);
                  if (v92 < v168) {
                    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
                  }
                  Swift::Int v1 = v170;
                  uint64_t v91 = v168;
                }
                unint64_t v93 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v91, (uint64_t)v90, v92);
                _StringGuts.appendInPlace(_:isASCII:)(v93, v94, v9 < 0);
                swift_bridgeObjectRelease_n(v6, 2);
                uint64_t v2 = v169;
              }
              goto LABEL_159;
            }
            swift_bridgeObjectRelease(v6);
            _StringGuts._foreignAppendInPlace(_:)(v9, v6, 0, v2);
            swift_bridgeObjectRelease_n(v6, 2);
            uint64_t v2 = v169;
LABEL_121:
            Swift::Int v1 = v170;
            goto LABEL_159;
          }
LABEL_104:
          uint64_t v70 = _StringGuts.nativeCapacity.getter(v64, v7);
          if (v71) {
            uint64_t v72 = 0;
          }
          else {
            uint64_t v72 = v70;
          }
          if (v72 + 0x4000000000000000 >= 0)
          {
            uint64_t v73 = 2 * v72;
            if (v73 > v1) {
              Swift::Int v1 = v73;
            }
            goto LABEL_110;
          }
          __break(1u);
LABEL_201:
          if ((v40 & 0x1000000000000000) != 0)
          {
            unint64_t v38 = _StringGuts._foreignConvertedToSmall()(v38, v40);
            unint64_t v167 = v166;
            swift_bridgeObjectRelease(v40);
            unint64_t v40 = v167;
          }
          else
          {
            if ((v38 & 0x1000000000000000) != 0)
            {
              uint64_t v156 = (unsigned __int8 *)((v40 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v157 = v38 & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              uint64_t v156 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v38, v40);
            }
            closure #1 in _StringGuts._convertedToSmall()(v156, v157, v171);
            swift_bridgeObjectRelease(v40);
            unint64_t v40 = *((void *)&v171[0] + 1);
            unint64_t v38 = *(void *)&v171[0];
          }
LABEL_56:
          uint64_t v41 = HIBYTE(v9) & 0xF;
          uint64_t v42 = HIBYTE(v40) & 0xF;
          uint64_t v43 = v42 + v41;
          if ((unint64_t)(v42 + v41) <= 0xF)
          {
            if (v42)
            {
              char v44 = 0;
              unint64_t v45 = 0;
              do
              {
                unint64_t v46 = v41 + v45;
                unint64_t v47 = v45 + 1;
                if (v45 >= 8) {
                  unint64_t v48 = v40;
                }
                else {
                  unint64_t v48 = v38;
                }
                unint64_t v49 = v48 >> (v44 & 0x38);
                char v50 = (8 * v41 + v44) & 0x38;
                uint64_t v51 = (-255 << v50) - 1;
                unint64_t v52 = (unint64_t)v49 << v50;
                unint64_t v53 = v52 | v51 & v9;
                unint64_t v54 = v52 | v51 & v6;
                if (v46 < 8) {
                  unint64_t v6 = v54;
                }
                else {
                  uint64_t v9 = v53;
                }
                v44 += 8;
                unint64_t v45 = v47;
              }
              while (v42 != v47);
            }
            swift_bridgeObjectRelease(v7);
            swift_bridgeObjectRelease(0xE100000000000000);
            unint64_t v55 = 0xA000000000000000;
            if (!(v6 & 0x8080808080808080 | v9 & 0x80808080808080)) {
              unint64_t v55 = 0xE000000000000000;
            }
            unint64_t v18 = v55 & 0xFF00000000000000 | (v43 << 56) | v9 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_69;
          }
LABEL_210:
          unint64_t v161 = 266;
LABEL_212:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v161, 0);
        }
        int v76 = 0;
        unint64_t v3 = v7;
LABEL_137:
        Swift::Int v1 = v170;
        swift_bridgeObjectRelease_n(v6, 5);
        unint64_t v95 = v172;
        if (v76)
        {
          if ((v3 & 0x1000000000000000) != 0)
          {
            unint64_t v95 = _StringGuts._foreignConvertedToSmall()(v172, v7);
            unint64_t v3 = v162;
          }
          else
          {
            if ((v172 & 0x1000000000000000) != 0)
            {
              unint64_t v152 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v153 = v172 & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              unint64_t v152 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v172, v7);
              unint64_t v153 = v165;
            }
            swift_bridgeObjectRetain(v7);
            closure #1 in _StringGuts._convertedToSmall()(v152, v153, v171);
            swift_bridgeObjectRelease(v7);
            unint64_t v3 = *((void *)&v171[0] + 1);
            unint64_t v95 = *(void *)&v171[0];
          }
        }
        v96._rawBits = (v2 << 16) | 1;
        v97._rawBits = 1;
        v98._rawBits = _StringGuts.validateScalarRange(_:)(v97, v96, v9, v6);
        if (v98._rawBits < 0x10000) {
          v98._rawBits |= 3;
        }
        unint64_t v100 = specialized String.init(_:)(v98, v99, v9, v6);
        unint64_t v102 = v101;
        swift_bridgeObjectRelease(v6);
        if ((v102 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v102);
          uint64_t v2 = v169;
        }
        else
        {
          uint64_t v2 = v169;
          if ((v102 & 0x1000000000000000) != 0)
          {
            unint64_t v100 = _StringGuts._foreignConvertedToSmall()(v100, v102);
            unint64_t v164 = v163;
            swift_bridgeObjectRelease(v102);
            unint64_t v102 = v164;
          }
          else
          {
            if ((v100 & 0x1000000000000000) != 0)
            {
              uint64_t v154 = (unsigned __int8 *)((v102 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v155 = v100 & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              uint64_t v154 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v100, v102);
            }
            closure #1 in _StringGuts._convertedToSmall()(v154, v155, v171);
            swift_bridgeObjectRelease(v102);
            unint64_t v102 = *((void *)&v171[0] + 1);
            unint64_t v100 = *(void *)&v171[0];
          }
        }
        uint64_t v103 = HIBYTE(v3) & 0xF;
        uint64_t v104 = HIBYTE(v102) & 0xF;
        uint64_t v105 = v104 + v103;
        if ((unint64_t)(v104 + v103) <= 0xF)
        {
          if (v104)
          {
            char v106 = 0;
            unint64_t v107 = 0;
            do
            {
              unint64_t v108 = v103 + v107;
              unint64_t v109 = v107 + 1;
              if (v107 >= 8) {
                unint64_t v110 = v102;
              }
              else {
                unint64_t v110 = v100;
              }
              unint64_t v111 = v110 >> (v106 & 0x38);
              char v112 = (8 * v103 + v106) & 0x38;
              uint64_t v113 = (-255 << v112) - 1;
              unint64_t v114 = (unint64_t)v111 << v112;
              unint64_t v115 = v114 | v113 & v3;
              unint64_t v116 = v114 | v113 & v95;
              if (v108 < 8) {
                unint64_t v95 = v116;
              }
              else {
                unint64_t v3 = v115;
              }
              v106 += 8;
              unint64_t v107 = v109;
            }
            while (v104 != v109);
          }
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v6);
          unint64_t v117 = 0xA000000000000000;
          if (!(v95 & 0x8080808080808080 | v3 & 0x80808080808080)) {
            unint64_t v117 = 0xE000000000000000;
          }
          unint64_t v172 = v95;
          unint64_t v173 = v117 & 0xFF00000000000000 | (v105 << 56) | v3 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_159;
        }
        goto LABEL_210;
      }
LABEL_211:
      unint64_t v161 = 258;
      goto LABEL_212;
    }
LABEL_184:
    __break(1u);
LABEL_185:
    Swift::Int v147 = String.UTF8View._foreignCount()();
    Swift::Int v19 = v147 + 1;
    if (__OFADD__(v147, 1)) {
      goto LABEL_187;
    }
LABEL_18:
    unint64_t v20 = v6 & ~v7;
    if ((v20 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v6, v7);
      if (v22) {
        goto LABEL_211;
      }
      if (v19 <= 15)
      {
        if ((v7 & 0x2000000000000000) != 0) {
          goto LABEL_51;
        }
        if (v21 <= 0) {
          goto LABEL_46;
        }
      }
    }
    else if (v19 <= 15)
    {
      if ((v7 & 0x2000000000000000) != 0)
      {
LABEL_51:
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        uint64_t v9 = v7;
      }
      else
      {
LABEL_46:
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        if ((v7 & 0x1000000000000000) != 0) {
          goto LABEL_206;
        }
        if ((v6 & 0x1000000000000000) != 0)
        {
          uint64_t v33 = (unsigned __int8 *)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          uint64_t v33 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, v7);
          uint64_t v9 = v159;
        }
        swift_bridgeObjectRetain(v7);
        closure #1 in _StringGuts._convertedToSmall()(v33, v9, v171);
        swift_bridgeObjectRelease(v7);
        uint64_t v9 = *((void *)&v171[0] + 1);
        unint64_t v6 = *(void *)&v171[0];
      }
LABEL_52:
      v34._rawBits = 1;
      v35._rawBits = 65537;
      v36._rawBits = _StringGuts.validateScalarRange(_:)(v34, v35, 0x5CuLL, 0xE100000000000000);
      if (v36._rawBits < 0x10000) {
        v36._rawBits |= 3;
      }
      unint64_t v38 = specialized String.init(_:)(v36, v37, 0x5CuLL, 0xE100000000000000);
      unint64_t v40 = v39;
      swift_bridgeObjectRelease(0xE100000000000000);
      if ((v40 & 0x2000000000000000) == 0) {
        goto LABEL_201;
      }
      swift_bridgeObjectRelease(v40);
      goto LABEL_56;
    }
    int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v6, v7);
    BOOL v26 = (v24 & 1) == 0 && v23 > 0;
    if ((v20 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (!v26)
      {
LABEL_37:
        uint64_t v27 = _StringGuts.nativeCapacity.getter(v6, v7);
        if (v28) {
          uint64_t v29 = 0;
        }
        else {
          uint64_t v29 = v27;
        }
        if (v29 + 0x4000000000000000 < 0)
        {
          __break(1u);
LABEL_206:
          unint64_t v6 = _StringGuts._foreignConvertedToSmall()(v6, v7);
          uint64_t v9 = v158;
          goto LABEL_52;
        }
        uint64_t v30 = 2 * v29;
        if (v30 > v19) {
          Swift::Int v19 = v30;
        }
      }
      _StringGuts.grow(_:)(v19);
      goto LABEL_44;
    }
    if (!v26) {
      goto LABEL_37;
    }
LABEL_44:
    swift_bridgeObjectRelease_n(0xE100000000000000, 6);
    v171[0] = xmmword_18162AD60;
    unsigned int v31 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)v171, 1);
    _StringGuts.appendInPlace(_:isASCII:)(v31, v32, 1);
    swift_bridgeObjectRelease(0xE100000000000000);
  }
  if (v38)
  {
    char v78 = 0;
    unint64_t v79 = 0;
    unint64_t v80 = v173;
    Swift::Int v1 = v170;
    do
    {
      unint64_t v81 = v59 + v79;
      unint64_t v82 = v79 + 1;
      if (v79 >= 8) {
        unint64_t v83 = v58;
      }
      else {
        unint64_t v83 = v57;
      }
      unint64_t v84 = v83 >> (v78 & 0x38);
      char v85 = (8 * v59 + v78) & 0x38;
      uint64_t v86 = (-255 << v85) - 1;
      unint64_t v87 = (unint64_t)v84 << v85;
      unint64_t v88 = v87 | v86 & v80;
      unint64_t v89 = v87 | v86 & v7;
      if (v81 < 8) {
        uint64_t v7 = v89;
      }
      else {
        unint64_t v80 = v88;
      }
      v78 += 8;
      unint64_t v79 = v82;
    }
    while (v38 != v82);
  }
  else
  {
    unint64_t v80 = v173;
    Swift::Int v1 = v170;
  }
  swift_bridgeObjectRelease(v173);
  swift_bridgeObjectRelease(v6);
  unint64_t v118 = 0xA000000000000000;
  if (!(v7 & 0x8080808080808080 | v80 & 0x80808080808080)) {
    unint64_t v118 = 0xE000000000000000;
  }
  unint64_t v172 = v7;
  unint64_t v173 = v118 & 0xFF00000000000000 | (v77 << 56) | v80 & 0xFFFFFFFFFFFFFFLL;
LABEL_159:
  unint64_t v6 = v172;
  uint64_t v7 = v173;
  unint64_t v119 = HIBYTE(v173) & 0xF;
  int64_t v120 = v172 & 0xFFFFFFFFFFFFLL;
  if ((v173 & 0x2000000000000000) != 0) {
    unint64_t v121 = HIBYTE(v173) & 0xF;
  }
  else {
    unint64_t v121 = v172 & 0xFFFFFFFFFFFFLL;
  }
  if (!v121 && (v172 & ~v173 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v173);
    unint64_t v6 = 0;
    unint64_t v140 = 0xE000000000000000;
    goto LABEL_191;
  }
  if ((v173 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v173);
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v141 = 0xA000000000000000;
    if (!(v7 & 0x80808080808080 | v6 & 0x8080808080808080)) {
      unint64_t v141 = 0xE000000000000000;
    }
    unint64_t v140 = v141 & 0xFF00000000000000 | (v119 << 56) | v7 & 0xFFFFFFFFFFFFFFLL;
    goto LABEL_191;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6);
  if ((v7 & 0x1000000000000000) == 0)
  {
    if ((v6 & ~v7 & 0x2000000000000000) != 0) {
      goto LABEL_167;
    }
LABEL_189:
    if (v120 > 15) {
      goto LABEL_190;
    }
LABEL_171:
    swift_bridgeObjectRelease_n(0xE000000000000000, 5);
    swift_bridgeObjectRetain(v7);
    unint64_t v124 = _StringGuts._convertedToSmall()(v6, v7);
    unint64_t v126 = v125;
    swift_bridgeObjectRelease(v7);
    v127._rawBits = 1;
    v128._rawBits = 1;
    v129._rawBits = _StringGuts.validateScalarRange(_:)(v127, v128, 0, 0xE000000000000000);
    if (v129._rawBits < 0x10000) {
      v129._rawBits |= 3;
    }
    unint64_t v131 = specialized String.init(_:)(v129, v130, 0, 0xE000000000000000);
    unint64_t v133 = v132;
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v134 = _StringGuts._convertedToSmall()(v131, v133);
    unint64_t v136 = v135;
    swift_bridgeObjectRelease(v133);
    unint64_t v137 = specialized _SmallString.init(_:appending:)(v124, v126, v134, v136);
    if (v139) {
      goto LABEL_210;
    }
    unint64_t v6 = v137;
    unint64_t v140 = v138;
    swift_bridgeObjectRelease(v7);
    swift_bridgeObjectRelease(0xE000000000000000);
    goto LABEL_191;
  }
LABEL_188:
  int64_t v120 = String.UTF8View._foreignCount()();
  if ((v6 & ~v7 & 0x2000000000000000) == 0) {
    goto LABEL_189;
  }
LABEL_167:
  if (!swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL)) {
    goto LABEL_189;
  }
  unint64_t v122 = _StringGuts.nativeUnusedCapacity.getter(v6, v7);
  if (v123) {
    goto LABEL_211;
  }
  if (v120 <= 15 && (v122 & 0x8000000000000000) != 0) {
    goto LABEL_171;
  }
LABEL_190:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v120, 0);
  swift_bridgeObjectRelease_n(0xE000000000000000, 6);
  v171[0] = 0uLL;
  uint64_t v148 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)v171, 0);
  _StringGuts.appendInPlace(_:isASCII:)(v148, v149, 1);
  swift_bridgeObjectRelease(0xE000000000000000);
  unint64_t v6 = v172;
  unint64_t v140 = v173;
LABEL_191:
  unint64_t v172 = v6;
  unint64_t v173 = v140;
  unint64_t v150 = specialized AnyKeyPath.withBuffer<A>(_:)(v2, &v172, v1);
  swift_bridgeObjectRelease(v173);
  return v150;
}

Swift::Void __swiftcall String.append(_:)(Swift::String a1)
{
  object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v4 = v1[1];
  uint64_t v5 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    uint64_t v5 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 || (*v1 & ~v4 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(a1._countAndFlagsBits, (unint64_t)a1._object);
  }
  else
  {
    swift_bridgeObjectRetain((unint64_t)a1._object);
    swift_bridgeObjectRelease(v4);
    *Swift::Int v1 = countAndFlagsBits;
    v1[1] = (uint64_t)object;
  }
}

uint64_t Sequence.first(where:)@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, char *a5@<X8>)
{
  unint64_t v40 = a1;
  uint64_t v41 = a2;
  uint64_t v33 = a5;
  uint64_t v42 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v35 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v33 - v9;
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1F4188790](v13 - 1);
  unint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v14);
  Swift::Int v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v20 = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v34 = *((void *)v20 - 1);
  MEMORY[0x1F4188790](v20);
  char v22 = (int **)((char *)&v33 - v21);
  (*(void (**)(char *, const char *, uint64_t))(v17 + 16))(v19, v43, a3);
  uint64_t v23 = (uint64_t)v42;
  ((void (*)(uint64_t, int **))v42[4])(a3, v42);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v23, a3, (uint64_t)v20, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int v25 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v42 = v22;
  uint64_t v43 = v20;
  BOOL v26 = v20;
  uint64_t v27 = v35;
  Swift::String::Index v37 = v25;
  uint64_t v38 = AssociatedConformanceWitness;
  ((void (*)(const char *))v25)(v26);
  Swift::String::Index v36 = *(unsigned int (**)(char *, uint64_t, const char *))(v27 + 48);
  if (v36(v16, 1, AssociatedTypeWitness) == 1)
  {
LABEL_6:
    (*(void (**)(int **, const char *))(v34 + 8))(v42, v43);
    uint64_t v30 = 1;
    unsigned int v31 = v33;
  }
  else
  {
    unint64_t v39 = *(void (**)(char *, char *, const char *))(v27 + 32);
    char v28 = (void (**)(char *, const char *))(v27 + 8);
    while (1)
    {
      v39(v10, v16, AssociatedTypeWitness);
      char v29 = v40(v10);
      if (v5)
      {
        (*v28)(v10, AssociatedTypeWitness);
        return (*(uint64_t (**)(int **, const char *))(v34 + 8))(v42, v43);
      }
      if (v29) {
        break;
      }
      (*v28)(v10, AssociatedTypeWitness);
      v37(v43, v38);
      if (v36(v16, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_6;
      }
    }
    (*(void (**)(int **, const char *))(v34 + 8))(v42, v43);
    unsigned int v31 = v33;
    v39(v33, v10, AssociatedTypeWitness);
    uint64_t v30 = 0;
  }
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v35 + 56))(v31, v30, 1, AssociatedTypeWitness);
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AnyKeyPath()
{
  return AnyKeyPath.debugDescription.getter();
}

uint64_t KeyValuePairs.startIndex.getter()
{
  return 0;
}

Swift::Int KeyValuePairs.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_getTupleTypeMetadata2(0, a2, a3, 0, 0);

  return Array._getCount()();
}

uint64_t KeyValuePairs.subscript.getter(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a2;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  uint64_t v12 = *(TupleTypeMetadata2 - 1);
  uint64_t v13 = *(void *)(v12 + 64);
  uint64_t v14 = (uint64_t *)MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v16 = (char *)&v23 - v15;
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v14, v14);
  char v18 = ((a4 & 0xC000000000000001) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)(a3, (a4 & 0xC000000000000001) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if (v18)
  {
    (*(void (**)(char *, unint64_t, uint64_t *))(v12 + 16))(v16, a4+ ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))+ *(void *)(v12 + 72) * a3, TupleTypeMetadata2);
  }
  else
  {
    id v21 = _ArrayBuffer._getElementSlowPath(_:)(a3, a4, TupleTypeMetadata2);
    char v22 = v21;
    if (v13 != 8)
    {
      swift_unknownObjectRelease(v21);
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
    }
    id v24 = v21;
    (*(void (**)(char *, id *, uint64_t *))(v12 + 16))(v16, &v24, TupleTypeMetadata2);
    swift_unknownObjectRelease(v22);
  }
  Swift::Int v19 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(a5 - 8) + 32))(a1, v16, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(a6 - 8) + 32))(v23, v19, a6);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance KeyValuePairs<A, B>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);

  return RandomAccessCollection<>.index(before:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance KeyValuePairs<A, B>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for KeyValuePairs<A, B>, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance KeyValuePairs<A, B>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance KeyValuePairs<A, B>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance KeyValuePairs<A, B>(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance KeyValuePairs<A, B>@<X0>(uint64_t a1@<X0>, Swift::Int *a2@<X8>)
{
  Swift::Int result = KeyValuePairs.endIndex.getter(*v2, *(void *)(a1 + 16), *(void *)(a1 + 24));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance KeyValuePairs<A, B>(void *a1, unint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t v8 = *(void *)(a3 + 24);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v9, v8, "key value ", 0);
  v7[4] = TupleTypeMetadata2;
  uint64_t v11 = *(TupleTypeMetadata2 - 1);
  v7[5] = v11;
  uint64_t v12 = (char *)malloc(*(void *)(v11 + 64));
  v7[6] = v12;
  uint64_t v13 = KeyValuePairs.subscript.read(v7, *a2, *v3, v9, v8);
  uint64_t v15 = v14;
  v7[7] = v13;
  (*(void (**)(char *))(*(void *)(v9 - 8) + 16))(v12);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(&v12[*((int *)TupleTypeMetadata2 + 12)], v15, v8);
  return protocol witness for Collection.subscript.read in conformance KeyValuePairs<A, B>;
}

void (*KeyValuePairs.subscript.read(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t a1)
{
  uint64_t v10 = malloc(0x28uLL);
  *a1 = v10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a4, a5, 0, 0);
  uint64_t v12 = *(TupleTypeMetadata2 - 1);
  size_t v24 = *(void *)(v12 + 64);
  uint64_t v13 = (char *)malloc(v24);
  v10[1] = v13;
  uint64_t v25 = a4;
  uint64_t v14 = swift_getTupleTypeMetadata2(0, a4, a5, "key value ", 0);
  v10[2] = v14;
  uint64_t v15 = *(v14 - 1);
  v10[3] = v15;
  unint64_t v16 = (char *)malloc(*(void *)(v15 + 64));
  v10[4] = v16;
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)TupleTypeMetadata2, TupleTypeMetadata2);
  char v18 = ((a3 & 0xC000000000000001) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)(a2, (a3 & 0xC000000000000001) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if (v18)
  {
    (*(void (**)(char *, unint64_t, uint64_t *))(v12 + 16))(v13, a3+ ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))+ *(void *)(v12 + 72) * a2, TupleTypeMetadata2);
  }
  else
  {
    id v22 = _ArrayBuffer._getElementSlowPath(_:)(a2, a3, TupleTypeMetadata2);
    uint64_t v23 = v22;
    if (v24 != 8)
    {
      swift_unknownObjectRelease(v22);
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
    }
    *uint64_t v10 = v22;
    (*(void (**)(char *, void *, uint64_t *))(v12 + 16))(v13, v10, TupleTypeMetadata2);
    swift_unknownObjectRelease(v23);
  }
  Swift::Int v19 = &v16[*((int *)v14 + 12)];
  unint64_t v20 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  (*(void (**)(char *, char *))(*(void *)(v25 - 8) + 32))(v16, v13);
  (*(void (**)(char *, char *))(*(void *)(a5 - 8) + 32))(v19, v20);
  return KeyValuePairs.subscript.read;
}

void KeyValuePairs.subscript.read(uint64_t a1)
{
  Swift::Int v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 32);
  unint64_t v3 = *(void **)(*(void *)a1 + 8);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 24) + 8))(v2, *(void *)(*(void *)a1 + 16));
  free(v2);
  free(v3);

  free(v1);
}

uint64_t protocol witness for Collection.indices.getter in conformance KeyValuePairs<A, B>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance KeyValuePairs<A, B>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);

  return RandomAccessCollection<>.index(after:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance KeyValuePairs<A, B>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for KeyValuePairs<A, B>, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>(void *a1, unint64_t *a2, uint64_t a3, int *a4, void *(*a5)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, a3);
  Swift::Int result = a5(&v10, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v10;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance KeyValuePairs<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance KeyValuePairs<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance KeyValuePairs<A, B>(uint64_t a1)
{
  return KeyValuePairs.description.getter(*v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t KeyValuePairs.description.getter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v238 = (char *)&v214 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v7);
  int64_t v235 = (char *)&v214 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v12, v13, 0, 0);
  uint64_t v15 = *(TupleTypeMetadata2 - 1);
  uint64_t v215 = *(void *)(v15 + 64);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v221 = (char *)&v214 - v16;
  unint64_t v233 = a3;
  uint64_t v17 = swift_getTupleTypeMetadata2(0, a2, a3, "key value ", 0);
  uint64_t v18 = *(v17 - 1);
  MEMORY[0x1F4188790](v17);
  uint64_t v222 = (char *)&v214 - v19;
  uint64_t v229 = type metadata accessor for Optional(0, (uint64_t)v17, v20, v21);
  uint64_t v22 = (uint64_t)*(v229 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v229);
  uint64_t v232 = (char *)&v214 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  v228 = (char *)&v214 - v25;
  uint64_t v230 = TupleTypeMetadata2;
  Swift::Int v231 = Array._getCount()();
  if (!v231) {
    return 6109787;
  }
  unint64_t v26 = 0;
  uint64_t v245 = 91;
  unint64_t v246 = 0xE100000000000000;
  unint64_t v220 = v5 & 0xC000000000000001;
  v219 = (void (**)(char *, long long *, uint64_t *))(v15 + 16);
  uint64_t v244 = 0;
  uint64_t v239 = (uint64_t *)(v10 + 32);
  uint64_t v240 = (char **)(v6 + 32);
  uint64_t v227 = (void (**)(char *, uint64_t, uint64_t, uint64_t *))(v18 + 56);
  uint64_t v226 = (void (**)(char *, char *, Class *))(v22 + 32);
  uint64_t v225 = (unsigned int (**)(char *, uint64_t, uint64_t *))(v18 + 48);
  uint64_t v27 = 1;
  long long v237 = xmmword_18162AC80;
  long long v217 = xmmword_18162AD30;
  long long v216 = xmmword_18162AC90;
  unint64_t v28 = v233;
  uint64_t v29 = (uint64_t)v235;
  uint64_t v224 = v17;
  uint64_t v30 = v232;
  uint64_t v234 = v5;
  uint64_t v218 = v15;
  while (1)
  {
    if (v26 == v231)
    {
      (*v227)(v30, 1, 1, v17);
      uint64_t v34 = v239;
    }
    else
    {
      BOOL v35 = v220 == 0;
      Swift::String::Index v36 = v230;
      char v37 = v35 | ~_swift_isClassOrObjCExistentialType((uint64_t)v230, v230);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v37 & 1);
      uint64_t v223 = v27;
      uint64_t v236 = (char *)v26;
      if (v37)
      {
        uint64_t v38 = v221;
        (*(void (**)(char *, unint64_t, uint64_t *))(v15 + 16))(v221, v5+ ((*(unsigned __int8 *)(v15 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80))+ *(void *)(v15 + 72) * v26, v36);
      }
      else
      {
        id v154 = _ArrayBuffer._getElementSlowPath(_:)(v26, v5, v36);
        uint64_t v155 = v154;
        if (v215 != 8)
        {
          swift_unknownObjectRelease(v154);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        *(void *)&long long v243 = v154;
        uint64_t v38 = v221;
        (*v219)(v221, &v243, v36);
        swift_unknownObjectRelease(v155);
      }
      unint64_t v39 = v224;
      unint64_t v40 = v222;
      uint64_t v41 = &v222[*((int *)v224 + 12)];
      uint64_t v42 = &v38[*((int *)v36 + 12)];
      uint64_t v43 = v38;
      uint64_t v44 = (uint64_t)v239;
      uint64_t v29 = *v239;
      ((void (*)(char *, char *, unint64_t))*v239)(v222, v43, a2);
      unint64_t v45 = *v240;
      unint64_t v46 = v42;
      unint64_t v28 = v233;
      ((void (*)(char *, char *, unint64_t))*v240)(v41, v46, v233);
      uint64_t v30 = v232;
      ((void (*)(char *, char *, unint64_t))v29)(v232, v40, a2);
      ((void (*)(char *, char *, unint64_t))v45)(&v30[*((int *)v39 + 12)], v41, v28);
      uint64_t v47 = v234;
      swift_bridgeObjectRetain(v234);
      Swift::Int v48 = Array._getCount()();
      if (v48 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
      }
      *(void *)&long long v243 = 0;
      *((void *)&v243 + 1) = v48;
      char v50 = (unint64_t *)type metadata accessor for KeyValuePairs(0, a2, v28, v49);
      uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, v50, v51);
      specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v244, (uint64_t)&v243, (uint64_t)v50, WitnessTable);
      swift_bridgeObjectRelease(v47);
      if (__OFADD__(v236, 1))
      {
        __break(1u);
LABEL_235:
        __break(1u);
LABEL_236:
        __break(1u);
LABEL_237:
        __break(1u);
LABEL_238:
        __break(1u);
LABEL_239:
        Swift::Int v205 = String.UTF8View._foreignCount()();
        uint64_t v172 = v205 + 1;
        if (!__OFADD__(v205, 1))
        {
LABEL_187:
          uint64_t v173 = v29 & ~v44;
          if ((v173 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v44 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v174 = _StringGuts.nativeUnusedCapacity.getter(v29, v44);
            if (v175)
            {
LABEL_252:
              unint64_t v209 = 258;
            }
            else
            {
              if (v172 > 15) {
                goto LABEL_193;
              }
              if ((v44 & 0x2000000000000000) != 0)
              {
                swift_bridgeObjectRelease_n(0xE100000000000000, 5);
                goto LABEL_205;
              }
              if (v174 > 0) {
                goto LABEL_193;
              }
LABEL_204:
              swift_bridgeObjectRelease_n(0xE100000000000000, 5);
              if ((v44 & 0x2000000000000000) != 0)
              {
LABEL_205:
                a2 = v44;
              }
              else if ((v44 & 0x1000000000000000) != 0)
              {
                uint64_t v29 = _StringGuts._foreignConvertedToSmall()(v29, v44);
                a2 = v212;
              }
              else
              {
                if ((v29 & 0x1000000000000000) != 0)
                {
                  uint64_t v208 = (unsigned __int8 *)((v44 & 0xFFFFFFFFFFFFFFFLL) + 32);
                }
                else
                {
                  uint64_t v208 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v29, v44);
                  a2 = v213;
                }
                swift_bridgeObjectRetain(v44);
                closure #1 in _StringGuts._convertedToSmall()(v208, a2, &v243);
                swift_bridgeObjectRelease(v44);
                a2 = *((void *)&v243 + 1);
                uint64_t v29 = v243;
              }
              v180._rawBits = 65537;
              v181._rawBits = 1;
              v182._rawBits = _StringGuts.validateScalarRange(_:)(v181, v180, 0x5DuLL, 0xE100000000000000);
              if (v182._rawBits < 0x10000) {
                v182._rawBits |= 3;
              }
              unint64_t v28 = specialized String.init(_:)(v182, v183, 0x5DuLL, 0xE100000000000000);
              uint64_t v172 = v184;
              swift_bridgeObjectRelease(0xE100000000000000);
              if ((v172 & 0x2000000000000000) != 0)
              {
                swift_bridgeObjectRelease(v172);
                goto LABEL_210;
              }
LABEL_242:
              if ((v172 & 0x1000000000000000) != 0)
              {
                unint64_t v28 = _StringGuts._foreignConvertedToSmall()(v28, v172);
                uint64_t v211 = v210;
                swift_bridgeObjectRelease(v172);
                uint64_t v172 = v211;
              }
              else
              {
                if ((v28 & 0x1000000000000000) != 0)
                {
                  uint64_t v206 = (unsigned __int8 *)((v172 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v207 = v28 & 0xFFFFFFFFFFFFLL;
                }
                else
                {
                  uint64_t v206 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v28, v172);
                }
                closure #1 in _StringGuts._convertedToSmall()(v206, v207, &v243);
                swift_bridgeObjectRelease(v172);
                uint64_t v172 = *((void *)&v243 + 1);
                unint64_t v28 = v243;
              }
LABEL_210:
              uint64_t v185 = HIBYTE(a2) & 0xF;
              uint64_t v186 = HIBYTE(v172) & 0xF;
              if ((unint64_t)(v186 + v185) <= 0xF)
              {
                if (v186)
                {
                  char v187 = 0;
                  unint64_t v188 = 0;
                  do
                  {
                    unint64_t v189 = v185 + v188;
                    unint64_t v190 = v188 + 1;
                    if (v188 >= 8) {
                      unint64_t v191 = v172;
                    }
                    else {
                      unint64_t v191 = v28;
                    }
                    unint64_t v192 = v191 >> (v187 & 0x38);
                    char v193 = (8 * v185 + v187) & 0x38;
                    uint64_t v194 = (-255 << v193) - 1;
                    unint64_t v195 = (unint64_t)v192 << v193;
                    unint64_t v196 = v195 | v194 & a2;
                    unint64_t v197 = v195 | v194 & v29;
                    if (v189 < 8) {
                      uint64_t v29 = v197;
                    }
                    else {
                      a2 = v196;
                    }
                    v187 += 8;
                    unint64_t v188 = v190;
                  }
                  while (v186 != v190);
                }
                swift_bridgeObjectRelease(v44);
                swift_bridgeObjectRelease(0xE100000000000000);
                return v29;
              }
LABEL_251:
              unint64_t v209 = 266;
            }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v209, 0);
          }
          if (v172 <= 15) {
            goto LABEL_204;
          }
LABEL_193:
          int64_t v176 = _StringGuts.nativeUnusedCapacity.getter(v29, v44);
          BOOL v179 = (v177 & 1) == 0 && v176 > 0;
          if ((v173 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v44 & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v179) {
              goto LABEL_229;
            }
LABEL_222:
            uint64_t v198 = _StringGuts.nativeCapacity.getter(v29, v44);
            if (v199) {
              uint64_t v200 = 0;
            }
            else {
              uint64_t v200 = v198;
            }
            if (v200 + 0x4000000000000000 < 0)
            {
              __break(1u);
              goto LABEL_251;
            }
            uint64_t v201 = 2 * v200;
            if (v201 > v172) {
              uint64_t v172 = v201;
            }
          }
          else if (!v179)
          {
            goto LABEL_222;
          }
          _StringGuts.grow(_:)(v172);
LABEL_229:
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v243 = xmmword_18162ACA0;
          uint64_t v202 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v243, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v202, v203, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v245;
        }
LABEL_241:
        __break(1u);
        goto LABEL_242;
      }
      uint64_t v244 = v236 + 1;
      uint64_t v17 = v224;
      (*v227)(v30, 0, 1, v224);
      uint64_t v29 = (uint64_t)v235;
      uint64_t v15 = v218;
      uint64_t v34 = v239;
      LOBYTE(v27) = v223;
    }
    unint64_t v53 = v228;
    (*v226)(v228, v30, v229);
    if ((*v225)(v53, 1, v17) == 1) {
      break;
    }
    unint64_t v54 = v53;
    unint64_t v55 = &v53[*((int *)v17 + 12)];
    uint64_t v56 = (void (*)(void *, uint64_t, unint64_t))*v34;
    ((void (*)(uint64_t, char *, unint64_t))*v34)(v29, v54, a2);
    uint64_t v236 = *v240;
    ((void (*)(char *, char *, unint64_t))v236)(v238, v55, v28);
    if (v27) {
      goto LABEL_79;
    }
    unint64_t v28 = v245;
    uint64_t v44 = v246;
    unint64_t v57 = HIBYTE(v246) & 0xF;
    uint64_t v58 = v245 & 0xFFFFFFFFFFFFLL;
    if ((v246 & 0x2000000000000000) != 0) {
      unint64_t v59 = HIBYTE(v246) & 0xF;
    }
    else {
      unint64_t v59 = v245 & 0xFFFFFFFFFFFFLL;
    }
    if (!v59 && (v245 & ~v246 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v246);
      uint64_t v245 = 8236;
      unint64_t v246 = 0xE200000000000000;
      goto LABEL_79;
    }
    if ((v246 & 0x2000000000000000) != 0 && v57 <= 0xD)
    {
      unint64_t v60 = 8 * (HIBYTE(v246) & 7);
      uint64_t v61 = (-255 << v60) - 1;
      uint64_t v62 = 44 << v60;
      char v63 = v57 + 1;
      if (v57 >= 8)
      {
        uint64_t v64 = v62 | v61 & v246;
LABEL_64:
        uint64_t v97 = (32 << (8 * (v63 & 7u))) | ((-255 << (8 * (v63 & 7u))) - 1) & v64;
      }
      else
      {
        unint64_t v28 = v62 | v61 & v245;
        if (v57 == 7)
        {
          char v63 = 8;
          uint64_t v64 = v246;
          goto LABEL_64;
        }
        unint64_t v28 = (32 << (8 * (v63 & 7u))) | ((-255 << (8 * (v63 & 7u))) - 1) & v28;
        uint64_t v97 = v246;
      }
      swift_bridgeObjectRelease(v246);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v104 = 0xE000000000000000;
      if (v28 & 0x8080808080808080 | v97 & 0x80808080808080) {
        unint64_t v104 = 0xA000000000000000;
      }
      uint64_t v245 = v28;
      unint64_t v246 = (v104 & 0xFF00000000000000 | (v57 << 56) | v97 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
      uint64_t v29 = (uint64_t)v235;
      goto LABEL_79;
    }
    swift_bridgeObjectRetain_n(0xE200000000000000, 6);
    if ((v44 & 0x1000000000000000) != 0)
    {
      Swift::Int v156 = String.UTF8View._foreignCount()();
      Swift::Int v66 = v156 + 2;
      if (__OFADD__(v156, 2)) {
        goto LABEL_236;
      }
    }
    else
    {
      BOOL v65 = __OFADD__(v59, 2);
      Swift::Int v66 = v59 + 2;
      if (v65) {
        goto LABEL_236;
      }
    }
    unint64_t v67 = v28 & ~v44;
    if ((v67 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v44 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v68 = _StringGuts.nativeUnusedCapacity.getter(v28, v44);
      if (v69) {
        goto LABEL_252;
      }
      if (v66 > 15)
      {
LABEL_53:
        int64_t v93 = _StringGuts.nativeUnusedCapacity.getter(v28, v44);
        BOOL v96 = (v94 & 1) == 0 && v93 > 1;
        if ((v67 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v44 & 0xFFFFFFFFFFFFFFFLL))
        {
          uint64_t v29 = (uint64_t)v235;
          if (v96) {
            goto LABEL_73;
          }
LABEL_66:
          uint64_t v98 = _StringGuts.nativeCapacity.getter(v28, v44);
          if (v99) {
            uint64_t v100 = 0;
          }
          else {
            uint64_t v100 = v98;
          }
          if (v100 + 0x4000000000000000 < 0) {
            goto LABEL_238;
          }
          uint64_t v101 = 2 * v100;
          if (v101 > v66) {
            Swift::Int v66 = v101;
          }
        }
        else
        {
          uint64_t v29 = (uint64_t)v235;
          if (!v96) {
            goto LABEL_66;
          }
        }
        _StringGuts.grow(_:)(v66);
LABEL_73:
        swift_bridgeObjectRelease_n(0xE200000000000000, 6);
        long long v243 = v216;
        unint64_t v102 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v243, 2);
        _StringGuts.appendInPlace(_:isASCII:)(v102, v103, 1);
        swift_bridgeObjectRelease(0xE200000000000000);
        goto LABEL_79;
      }
      if ((v44 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        goto LABEL_34;
      }
      if (v68 > 1) {
        goto LABEL_53;
      }
    }
    else if (v66 > 15)
    {
      goto LABEL_53;
    }
    swift_bridgeObjectRelease_n(0xE200000000000000, 5);
    if ((v44 & 0x2000000000000000) == 0)
    {
      if ((v44 & 0x1000000000000000) != 0)
      {
        unint64_t v28 = _StringGuts._foreignConvertedToSmall()(v28, v44);
        unint64_t v70 = v169;
      }
      else
      {
        if ((v28 & 0x1000000000000000) != 0)
        {
          unint64_t v162 = (unsigned __int8 *)((v44 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          unint64_t v162 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v28, v44);
          uint64_t v58 = v170;
        }
        swift_bridgeObjectRetain(v44);
        closure #1 in _StringGuts._convertedToSmall()(v162, v58, &v243);
        swift_bridgeObjectRelease(v44);
        unint64_t v70 = *((void *)&v243 + 1);
        unint64_t v28 = v243;
      }
      goto LABEL_35;
    }
LABEL_34:
    unint64_t v70 = v44;
LABEL_35:
    v71._rawBits = 1;
    v72._rawBits = 131073;
    v73._rawBits = _StringGuts.validateScalarRange(_:)(v71, v72, 0x202CuLL, 0xE200000000000000);
    if (v73._rawBits < 0x10000) {
      v73._rawBits |= 3;
    }
    unint64_t v75 = specialized String.init(_:)(v73, v74, 0x202CuLL, 0xE200000000000000);
    unint64_t v77 = v76;
    swift_bridgeObjectRelease(0xE200000000000000);
    if ((v77 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v77);
    }
    else if ((v77 & 0x1000000000000000) != 0)
    {
      unint64_t v75 = _StringGuts._foreignConvertedToSmall()(v75, v77);
      unint64_t v168 = v167;
      swift_bridgeObjectRelease(v77);
      unint64_t v77 = v168;
    }
    else
    {
      if ((v75 & 0x1000000000000000) != 0)
      {
        uint64_t v160 = (unsigned __int8 *)((v77 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v161 = v75 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        uint64_t v160 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v75, v77);
      }
      closure #1 in _StringGuts._convertedToSmall()(v160, v161, &v243);
      swift_bridgeObjectRelease(v77);
      unint64_t v77 = *((void *)&v243 + 1);
      unint64_t v75 = v243;
    }
    uint64_t v78 = HIBYTE(v70) & 0xF;
    uint64_t v79 = HIBYTE(v77) & 0xF;
    uint64_t v80 = v79 + v78;
    if ((unint64_t)(v79 + v78) > 0xF) {
      goto LABEL_251;
    }
    if (v79)
    {
      char v81 = 0;
      unint64_t v82 = 0;
      do
      {
        unint64_t v83 = v78 + v82;
        unint64_t v84 = v82 + 1;
        if (v82 >= 8) {
          unint64_t v85 = v77;
        }
        else {
          unint64_t v85 = v75;
        }
        unint64_t v86 = v85 >> (v81 & 0x38);
        char v87 = (8 * v78 + v81) & 0x38;
        uint64_t v88 = (-255 << v87) - 1;
        unint64_t v89 = (unint64_t)v86 << v87;
        unint64_t v90 = v89 | v88 & v70;
        unint64_t v91 = v89 | v88 & v28;
        if (v83 < 8) {
          unint64_t v28 = v91;
        }
        else {
          unint64_t v70 = v90;
        }
        v81 += 8;
        unint64_t v82 = v84;
      }
      while (v79 != v84);
    }
    swift_bridgeObjectRelease(v44);
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v92 = 0xE000000000000000;
    if (v28 & 0x8080808080808080 | v70 & 0x80808080808080) {
      unint64_t v92 = 0xA000000000000000;
    }
    uint64_t v245 = v28;
    unint64_t v246 = v92 & 0xFF00000000000000 | (v80 << 56) | v70 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v29 = (uint64_t)v235;
LABEL_79:
    unint64_t v28 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v28, &v242);
    *((_OWORD *)inited + 1) = v237;
    inited[7] = a2;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v56(boxed_opaque_existential_0Tm, v29, a2);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v245);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    uint64_t v108 = v245;
    uint64_t v107 = v246;
    unint64_t v109 = HIBYTE(v246) & 0xF;
    uint64_t v44 = v245 & 0xFFFFFFFFFFFFLL;
    if ((v246 & 0x2000000000000000) != 0) {
      unint64_t v110 = HIBYTE(v246) & 0xF;
    }
    else {
      unint64_t v110 = v245 & 0xFFFFFFFFFFFFLL;
    }
    if (!v110 && (v245 & ~v246 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v246);
      uint64_t v245 = 8250;
      unint64_t v246 = 0xE200000000000000;
      uint64_t v5 = v234;
LABEL_4:
      unsigned int v31 = (void (*)(void *, char *, unint64_t))v236;
      goto LABEL_5;
    }
    if ((v246 & 0x2000000000000000) == 0 || v109 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v107 & 0x1000000000000000) != 0) {
        unint64_t v110 = String.UTF8View._foreignCount()();
      }
      BOOL v65 = __OFADD__(v110, 2);
      Swift::Int v116 = v110 + 2;
      uint64_t v5 = v234;
      if (v65) {
        goto LABEL_235;
      }
      uint64_t v117 = v108 & ~v107;
      if ((v117 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v107 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v118 = _StringGuts.nativeUnusedCapacity.getter(v108, v107);
        if (v119) {
          goto LABEL_252;
        }
        if (v116 > 15) {
          goto LABEL_118;
        }
        if ((v107 & 0x2000000000000000) == 0)
        {
          if (v118 <= 1) {
            goto LABEL_98;
          }
LABEL_118:
          int64_t v143 = _StringGuts.nativeUnusedCapacity.getter(v108, v107);
          uint64_t v44 = (v144 & 1) == 0 && v143 > 1;
          if ((v117 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v107 & 0xFFFFFFFFFFFFFFFLL))
          {
            uint64_t v29 = (uint64_t)v235;
            if (v44) {
              goto LABEL_138;
            }
LABEL_131:
            uint64_t v147 = _StringGuts.nativeCapacity.getter(v108, v107);
            if (v148) {
              uint64_t v149 = 0;
            }
            else {
              uint64_t v149 = v147;
            }
            if (v149 + 0x4000000000000000 < 0) {
              goto LABEL_237;
            }
            uint64_t v150 = 2 * v149;
            if (v150 > v116) {
              Swift::Int v116 = v150;
            }
          }
          else
          {
            uint64_t v29 = (uint64_t)v235;
            if ((v44 & 1) == 0) {
              goto LABEL_131;
            }
          }
          _StringGuts.grow(_:)(v116);
LABEL_138:
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v243 = v217;
          unint64_t v151 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v243, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v151, v152, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
          goto LABEL_4;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_99:
        unint64_t v120 = v107;
      }
      else
      {
        if (v116 > 15) {
          goto LABEL_118;
        }
LABEL_98:
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        if ((v107 & 0x2000000000000000) != 0) {
          goto LABEL_99;
        }
        if ((v107 & 0x1000000000000000) != 0)
        {
          uint64_t v108 = _StringGuts._foreignConvertedToSmall()(v108, v107);
          unint64_t v120 = v165;
        }
        else
        {
          if ((v108 & 0x1000000000000000) != 0)
          {
            uint64_t v159 = (unsigned __int8 *)((v107 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            uint64_t v159 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v108, v107);
            uint64_t v44 = v166;
          }
          swift_bridgeObjectRetain(v107);
          closure #1 in _StringGuts._convertedToSmall()(v159, v44, &v243);
          swift_bridgeObjectRelease(v107);
          unint64_t v120 = *((void *)&v243 + 1);
          uint64_t v108 = v243;
        }
      }
      v121._rawBits = 1;
      v122._rawBits = 131073;
      v123._rawBits = _StringGuts.validateScalarRange(_:)(v121, v122, 0x203AuLL, 0xE200000000000000);
      if (v123._rawBits < 0x10000) {
        v123._rawBits |= 3;
      }
      unint64_t v125 = specialized String.init(_:)(v123, v124, 0x203AuLL, 0xE200000000000000);
      unint64_t v127 = v126;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v127 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v127);
      }
      else if ((v127 & 0x1000000000000000) != 0)
      {
        unint64_t v125 = _StringGuts._foreignConvertedToSmall()(v125, v127);
        unint64_t v164 = v163;
        swift_bridgeObjectRelease(v127);
        unint64_t v127 = v164;
      }
      else
      {
        if ((v125 & 0x1000000000000000) != 0)
        {
          uint64_t v157 = (unsigned __int8 *)((v127 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v158 = v125 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v157 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v125, v127);
        }
        closure #1 in _StringGuts._convertedToSmall()(v157, v158, &v243);
        swift_bridgeObjectRelease(v127);
        unint64_t v127 = *((void *)&v243 + 1);
        unint64_t v125 = v243;
      }
      uint64_t v128 = HIBYTE(v120) & 0xF;
      uint64_t v129 = HIBYTE(v127) & 0xF;
      uint64_t v130 = v129 + v128;
      if ((unint64_t)(v129 + v128) > 0xF) {
        goto LABEL_251;
      }
      if (v129)
      {
        char v131 = 0;
        unint64_t v132 = 0;
        do
        {
          unint64_t v133 = v128 + v132;
          unint64_t v134 = v132 + 1;
          if (v132 >= 8) {
            unint64_t v135 = v127;
          }
          else {
            unint64_t v135 = v125;
          }
          unint64_t v136 = v135 >> (v131 & 0x38);
          char v137 = (8 * v128 + v131) & 0x38;
          uint64_t v138 = (-255 << v137) - 1;
          unint64_t v139 = (unint64_t)v136 << v137;
          unint64_t v140 = v139 | v138 & v120;
          unint64_t v141 = v139 | v138 & v108;
          if (v133 < 8) {
            uint64_t v108 = v141;
          }
          else {
            unint64_t v120 = v140;
          }
          v131 += 8;
          unint64_t v132 = v134;
        }
        while (v129 != v134);
      }
      swift_bridgeObjectRelease(v107);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v142 = 0xE000000000000000;
      if (v108 & 0x8080808080808080 | v120 & 0x80808080808080) {
        unint64_t v142 = 0xA000000000000000;
      }
      uint64_t v245 = v108;
      unint64_t v246 = v142 & 0xFF00000000000000 | (v130 << 56) | v120 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v5 = v234;
      uint64_t v29 = (uint64_t)v235;
      goto LABEL_4;
    }
    unint64_t v111 = 8 * (HIBYTE(v246) & 7);
    uint64_t v112 = (-255 << v111) - 1;
    uint64_t v113 = 58 << v111;
    char v114 = v109 + 1;
    if (v109 >= 8)
    {
      uint64_t v115 = v113 | v112 & v246;
      unsigned int v31 = (void (*)(void *, char *, unint64_t))v236;
    }
    else
    {
      uint64_t v108 = v113 | v112 & v245;
      unsigned int v31 = (void (*)(void *, char *, unint64_t))v236;
      if (v109 != 7)
      {
        uint64_t v108 = (32 << (8 * (v114 & 7u))) | ((-255 << (8 * (v114 & 7u))) - 1) & v108;
        uint64_t v146 = v246;
        goto LABEL_140;
      }
      char v114 = 8;
      uint64_t v115 = v246;
    }
    uint64_t v146 = (32 << (8 * (v114 & 7u))) | ((-255 << (8 * (v114 & 7u))) - 1) & v115;
LABEL_140:
    swift_bridgeObjectRelease(v246);
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v153 = 0xE000000000000000;
    if (v108 & 0x8080808080808080 | v146 & 0x80808080808080) {
      unint64_t v153 = 0xA000000000000000;
    }
    uint64_t v245 = v108;
    unint64_t v246 = (v153 & 0xFF00000000000000 | (v109 << 56) | v146 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
    uint64_t v5 = v234;
    uint64_t v29 = (uint64_t)v235;
LABEL_5:
    size_t v32 = swift_initStackObject(v28, &v241);
    *((_OWORD *)v32 + 1) = v237;
    unint64_t v28 = v233;
    v32[7] = v233;
    uint64_t v33 = __swift_allocate_boxed_opaque_existential_0Tm(v32 + 4);
    v31(v33, v238, v28);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)v32, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v245);
    swift_bridgeObjectRelease((uint64_t)v32);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    uint64_t v27 = 0;
    unint64_t v26 = (unint64_t)v244;
    uint64_t v30 = v232;
  }
  uint64_t v29 = v245;
  uint64_t v44 = v246;
  unint64_t v28 = HIBYTE(v246) & 0xF;
  a2 = v245 & 0xFFFFFFFFFFFFLL;
  if ((v246 & 0x2000000000000000) != 0) {
    unint64_t v171 = HIBYTE(v246) & 0xF;
  }
  else {
    unint64_t v171 = v245 & 0xFFFFFFFFFFFFLL;
  }
  if (!v171 && (v245 & ~v246 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v246);
    return 93;
  }
  if ((v246 & 0x2000000000000000) == 0 || v28 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v44 & 0x1000000000000000) != 0) {
      goto LABEL_239;
    }
    BOOL v65 = __OFADD__(v171, 1);
    uint64_t v172 = v171 + 1;
    if (!v65) {
      goto LABEL_187;
    }
    goto LABEL_241;
  }
  if (v28 < 8) {
    uint64_t v29 = (93 << (8 * (HIBYTE(v246) & 7u))) | ((-255 << (8 * (HIBYTE(v246) & 7u))) - 1) & v245;
  }
  swift_bridgeObjectRelease(v246);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v29;
}

uint64_t LazyCollectionProtocol.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 32))();
}

uint64_t LazyCollectionProtocol<>.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 32))();
}

uint64_t LazySequence<>.startIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.indices.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))(*(void *)(a1 + 16));
}

uint64_t LazyDropWhileSequence<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = (uint64_t (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a3 + 80))(v12, a1, v6, a3);
  uint64_t v9 = v8;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(a4, v9, AssociatedTypeWitness);
  return v7(v12, 0);
}

uint64_t LazySequence<>.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>._customIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 120))(a1, *(void *)(a2 + 16));
}

uint64_t LazySequence<>._customLastIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 128))(a1, *(void *)(a2 + 16));
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return LazySequence<>.startIndex.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return LazySequence<>.endIndex.getter(a1, *(void *)(a2 - 8));
}

void LazyDropWhileSequence<>.subscript.read(uint64_t a1)
{
  Swift::Int v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 48);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 40) + 8))(v2, *(void *)(*(void *)a1 + 32));
  free(v2);

  free(v1);
}

uint64_t protocol witness for Collection.indices.getter in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return LazySequence<>.indices.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection.isEmpty.getter in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return LazySequence<>.isEmpty.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection.count.getter in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return LazySequence<>.count.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazySequence<>._customIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazySequence<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8));
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return LazySequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, *(void *)(a5 - 8));
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazySequence<>.index(after:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>(a1, a2, a3, (void (*)(uint64_t, uint64_t, int **))LazySequence<>.index(after:));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, int **))
{
  uint64_t v7 = *(int ***)(a3 - 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  a4(a1, a2, v7);
  (*(void (**)(uint64_t, const char *))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t))LazySequence<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v7 + 8), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  a4(a1, a2, v7);
  (*(void (**)(uint64_t, const char *))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return LazySequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, *(void *)(*(void *)(a5 - 8) + 8));
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8));
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(*(void *)(*(void *)(a4 - 8) + 8) + 8));
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return LazySequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, *(void *)(*(void *)(*(void *)(a5 - 8) + 8) + 8));
}

uint64_t protocol witness for RandomAccessCollection.distance(from:to:) in conformance <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(*(void *)(a4 - 8) + 8) + 8));
}

uint64_t LazySequenceProtocol.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t LazySequenceProtocol<>.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t (*LazySequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazySequence.makeIterator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *))(v4 + 32))((char *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 32))(v2);
}

uint64_t LazySequence.underestimatedCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))(*(void *)(a1 + 16));
}

uint64_t LazySequence._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *(void *)(a4 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))((char *)&v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v4, v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a4 + 24) + 64))(a1, a2, a3, v9);
}

uint64_t LazySequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 48))(a1, *(void *)(a2 + 16));
}

uint64_t LazySequence._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *))(v4 + 32))((char *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 56))(v2);
}

uint64_t DiscontiguousSlice.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 16))(a2, v2);
}

BOOL static Unicode.UTF16._isASCII(_:)(unsigned __int16 a1)
{
  return a1 < 0x80u;
}

Swift::Bool __swiftcall _isASCII(_:)(Swift::UInt8 a1)
{
  return (a1 & 0x80) == 0;
}

Swift::Bool __swiftcall _isContinuation(_:)(Swift::UInt8 a1)
{
  return (a1 & 0xC0) == 128;
}

BOOL static Unicode.UTF8.isContinuation(_:)(char a1)
{
  return (a1 & 0xC0) == 128;
}

uint64_t Substring._wholeString.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a3;
}

void String._withUTF8<A>(_:)(uint64_t (*a1)(void *, uint64_t), uint64_t a2, uint64_t a3, unint64_t a4)
{
}

void Substring._withUTF8<A>(_:)(void (*a1)(char *, int64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
}

Swift::Bool __swiftcall _branchHint(_:expected:)(Swift::Bool _, Swift::Bool expected)
{
  return _;
}

void String._nativeCopyUTF16CodeUnits(into:range:)()
{
}

uint64_t String.UTF16View._shortHeuristic.getter()
{
  return 32;
}

uint64_t withExtendedLifetime<A, B>(_:_:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

{
  return a2();
}

uint64_t withUnsafeMutablePointer<A, B>(to:_:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t withUnsafePointer<A, B>(to:_:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

{
  return a2();
}

uint64_t _StringGuts.withCString<A>(_:)(void (*a1)(__objc2_class **), uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  if ((a4 & 0x1000000000000000) != 0 || !(a4 & 0x2000000000000000 | a3 & 0x1000000000000000)) {
    return _StringGuts._slowWithCString<A>(_:)(a1, a2, a3, a4);
  }
  id v6 = (id)MEMORY[0x1F4188790](a1);
  void v16[2] = v10;
  v16[3] = v9;
  v16[4] = v11;
  if ((v8 & 0x2000000000000000) != 0)
  {
    v17[0] = v7;
    v17[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    return v9(v17);
  }
  else
  {
    if ((v7 & 0x1000000000000000) == 0) {
      id v6 = _StringObject.sharedUTF8.getter(v7, v8);
    }
    MEMORY[0x1F4188790](v6);
    v15[2] = a5;
    v15[3] = partial apply for closure #1 in _StringGuts.withCString<A>(_:);
    v15[4] = v16;
    return _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys4Int8VsAD_pqd_1_Isgyrzr_SRys5UInt8VGqd_1_sAD_pAIRszAGRsd__sAD_pRsd_0_Ri_d_1_r_1_lIetMgyrzo_Tpq5(partial apply for thunk for @callee_guaranteed (@unowned UnsafeBufferPointer<Int8>) -> (@out A, @error @owned Error), (uint64_t)v15, v13, v12);
  }
}

uint64_t _IndexBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 80) - 8) + 16))(a1, v1 + *(void *)(*(void *)v1 + 96));
}

uint64_t _IndexBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 80) - 8) + 40))(v1 + *(void *)(*(void *)v1 + 96), a1);
}

uint64_t (*ManagedBuffer.header.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _IndexBox.__deallocating_deinit()
{
  (*(void (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 80) - 8) + 8))(v0 + *(void *)(*(void *)v0 + 96));

  swift_deallocClassInstance(v0);
}

uint64_t ManagedBuffer.headerAddress.getter()
{
  return v0 + *(void *)(*(void *)v0 + 96);
}

uint64_t ManagedBuffer.capacity.getter()
{
  uint64_t v1 = *v0;
  size_t v2 = _swift_stdlib_malloc_size(v0);
  uint64_t v3 = *(void *)(*(void *)(v1 + 88) - 8);
  uint64_t v4 = *(void *)(v3 + 72);
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  int64_t v5 = v2
     - ((*(unsigned __int8 *)(v3 + 80) + (unint64_t)*(unsigned int *)(*v0 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
  if (v4 == -1 && v5 == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  }
  return v5 / v4;
}

uint64_t ManagedBuffer.withUnsafeMutablePointerToHeader<A>(_:)(uint64_t (*a1)(uint64_t))
{
  return a1(v1 + *(void *)(*(void *)v1 + 96));
}

uint64_t ManagedBuffer.withUnsafeMutablePointerToElements<A>(_:)(uint64_t (*a1)(unint64_t))
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)v1 + 88) - 8);
  return a1(v1+ ((*(unsigned __int8 *)(v2 + 80) + (unint64_t)*(unsigned int *)(*(void *)v1 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80)));
}

uint64_t ManagedBuffer.withUnsafeMutablePointers<A>(_:)(uint64_t (*a1)(uint64_t, unint64_t))
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)v1 + 88) - 8);
  return a1(v1 + *(void *)(*(void *)v1 + 96), v1+ ((*(unsigned __int8 *)(v2 + 80) + (unint64_t)*(unsigned int *)(*(void *)v1 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80)));
}

uint64_t (*ManagedBufferPointer._nativeBuffer.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)(unint64_t *a1, uint64_t a2, void (*a3)(id, uint64_t (*)(void *a1), unsigned char *), uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v35 = a3;
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = *(void *)(v11 + 64);
  uint64_t v13 = (uint64_t *)MEMORY[0x1F4188790](a1);
  uint64_t result = static ManagedBufferPointer._checkValidBufferClass(_:creating:)(v13, 1, v14, v15);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "ManagedBufferPointer must have non-negative capacity", 52, 2, "Swift/ManagedBuffer.swift", 25, 2, 0x14DuLL, 0);
  }
  uint64_t v17 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v18 = (v17 + 16) & ~v17;
  uint64_t v19 = v18 + v12;
  if (__OFADD__(v18, v12))
  {
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v20 = *(void *)(a6 - 8);
  unint64_t v21 = *(unsigned __int8 *)(v20 + 80) + 1;
  BOOL v22 = __CFADD__(v19, v21);
  uint64_t v23 = v19 + v21;
  if (v22)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v24 = *(void *)(v20 + 72);
  uint64_t v25 = a2 * v24;
  if ((unsigned __int128)(a2 * (__int128)v24) >> 64 != (a2 * v24) >> 63)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  uint64_t v26 = (v23 - 1) & -(uint64_t)v21;
  if (__OFADD__(v26, v25))
  {
LABEL_18:
    __break(1u);
    return result;
  }
  unint64_t v27 = v17 + 1;
  if (v21 > v27) {
    unint64_t v27 = *(unsigned __int8 *)(v20 + 80) + 1;
  }
  if (v27 <= 8) {
    unint64_t v27 = 8;
  }
  unint64_t v28 = swift_bufferAllocate(a1, v26 + v25, v27 - 1);
  uint64_t v29 = (void *)MEMORY[0x1F4188790](v28);
  uint64_t v32 = a5;
  uint64_t v33 = a6;
  id v30 = swift_unknownObjectRetain(v29);
  v35(v30, partial apply for closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:), v31);
  swift_unknownObjectRelease(v28);
  if (v6) {
    swift_unknownObjectRelease(v28);
  }
  else {
    (*(void (**)(char *, char *, uint64_t))(v11 + 32))((char *)v28 + v18, (char *)&v34 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0), a5);
  }
  return (uint64_t)v28;
}

void *ManagedBufferPointer.init(bufferClass:minimumCapacity:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (void *)static ManagedBufferPointer._checkValidBufferClass(_:creating:)(a1, 1, a3, a4);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "ManagedBufferPointer must have non-negative capacity", 52, 2, "Swift/ManagedBuffer.swift", 25, 2, 0x14DuLL, 0);
  }
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = (v10 + 16) & ~v10;
  uint64_t v12 = *(void *)(v9 + 64);
  BOOL v13 = __OFADD__(v11, v12);
  uint64_t v14 = v11 + v12;
  if (v13)
  {
    __break(1u);
    goto LABEL_15;
  }
  uint64_t v15 = *(void *)(a4 - 8);
  unint64_t v16 = *(unsigned __int8 *)(v15 + 80) + 1;
  BOOL v17 = __CFADD__(v14, v16);
  uint64_t v18 = v14 + v16;
  if (v17)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v19 = *(void *)(v15 + 72);
  uint64_t v20 = a2 * v19;
  if ((unsigned __int128)(a2 * (__int128)v19) >> 64 != (a2 * v19) >> 63)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v21 = (v18 - 1) & -(uint64_t)v16;
  if (__OFADD__(v21, v20))
  {
LABEL_17:
    __break(1u);
    return result;
  }
  unint64_t v22 = v10 + 1;
  if (v16 > v22) {
    unint64_t v22 = *(unsigned __int8 *)(v15 + 80) + 1;
  }
  if (v22 <= 8) {
    unint64_t v22 = 8;
  }

  return swift_bufferAllocate((unint64_t *)a1, v21 + v20, v22 - 1);
}

uint64_t closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)(void *a1, uint64_t a2, uint64_t a3)
{
  id v6 = swift_unknownObjectRetain(a1);
  uint64_t v7 = (const void *)ManagedBufferPointer.init(unsafeBufferObject:)((unint64_t)v6, a2);
  size_t v8 = _swift_stdlib_malloc_size(v7);
  uint64_t v9 = *(void *)(a2 - 8);
  unint64_t v10 = (*(unsigned __int8 *)(v9 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = *(void *)(v9 + 64);
  BOOL v12 = __OFADD__(v10, v11);
  uint64_t v13 = v10 + v11;
  if (v12)
  {
    __break(1u);
    goto LABEL_10;
  }
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80) + 1;
  BOOL v16 = __CFADD__(v13, v15);
  uint64_t v17 = v13 + v15;
  if (v16)
  {
LABEL_10:
    __break(1u);
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  uint64_t v18 = *(void *)(v14 + 72);
  if (!v18) {
    goto LABEL_11;
  }
  int64_t v19 = v8 - ((v17 - 1) & -v15);
  if (v19 == 0x8000000000000000 && v18 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  }
  swift_release((uint64_t)a1);
  return v19 / v18;
}

unint64_t ManagedBufferPointer.init(unsafeBufferObject:)(unint64_t a1, uint64_t a2)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  _swift_getObjCClassInstanceExtents(ObjectType);
  if (v5 < 0) {
    goto LABEL_8;
  }
  if (v5 == 16) {
    goto LABEL_6;
  }
  _swift_getObjCClassInstanceExtents(ObjectType);
  if (v6 < 0) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  uint64_t v7 = *(void *)(a2 - 8);
  unint64_t v8 = (*(unsigned __int8 *)(v7 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
  uint64_t v9 = *(void *)(v7 + 64);
  BOOL v10 = __OFADD__(v8, v9);
  uint64_t v11 = v8 + v9;
  if (v10)
  {
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "ManagedBufferPointer buffer class has illegal stored properties", 63, 2, "Swift/ManagedBuffer.swift", 25, 2, 0x1F5uLL, 0);
  }
  if (v6 != v11) {
    goto LABEL_11;
  }
LABEL_6:
  if ((_swift_objcClassUsesNativeSwiftReferenceCounting(ObjectType) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "ManagedBufferPointer buffer class must be non-@objc", 51, 2, "Swift/ManagedBuffer.swift", 25, 2, 0x1FDuLL, 0);
  }
  return a1;
}

uint64_t ManagedBufferPointer.capacity.getter(const void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = _swift_stdlib_malloc_size(a1);
  uint64_t v6 = *(void *)(a2 - 8);
  unint64_t v7 = (*(unsigned __int8 *)(v6 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = *(void *)(v6 + 64);
  BOOL v9 = __OFADD__(v7, v8);
  uint64_t v10 = v7 + v8;
  if (v9)
  {
    __break(1u);
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80) + 1;
  uint64_t v13 = v10 + v12;
  if (__CFADD__(v10, v12))
  {
LABEL_10:
    __break(1u);
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  uint64_t v14 = *(void *)(v11 + 72);
  if (!v14) {
    goto LABEL_11;
  }
  int64_t v15 = v5 - ((v13 - 1) & -v12);
  if (v15 == 0x8000000000000000 && v14 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  }
  return v15 / v14;
}

uint64_t static ManagedBufferPointer._checkValidBufferClass(_:creating:)(uint64_t *a1, char a2, uint64_t a3, uint64_t a4)
{
  _swift_getObjCClassInstanceExtents((uint64_t)a1);
  if (v8 < 0) {
    goto LABEL_10;
  }
  if (v8 == 16) {
    goto LABEL_8;
  }
  if (a2)
  {
    uint64_t v10 = (uint64_t *)type metadata accessor for ManagedBuffer(0, a3, a4, v9);
    if (!swift_dynamicCastMetatype(a1, v10)) {
LABEL_13:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "ManagedBufferPointer buffer class has illegal stored properties", 63, 2, "Swift/ManagedBuffer.swift", 25, 2, 0x1F5uLL, 0);
  }
  _swift_getObjCClassInstanceExtents((uint64_t)a1);
  if (v11 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  uint64_t v12 = *(void *)(a3 - 8);
  unint64_t v13 = (*(unsigned __int8 *)(v12 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  uint64_t v14 = *(void *)(v12 + 64);
  BOOL v15 = __OFADD__(v13, v14);
  uint64_t v16 = v13 + v14;
  if (v15)
  {
    __break(1u);
    goto LABEL_13;
  }
  if (v11 != v16) {
    goto LABEL_13;
  }
LABEL_8:
  uint64_t result = _swift_objcClassUsesNativeSwiftReferenceCounting((uint64_t)a1);
  if ((result & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "ManagedBufferPointer buffer class must be non-@objc", 51, 2, "Swift/ManagedBuffer.swift", 25, 2, 0x1FDuLL, 0);
  }
  return result;
}

uint64_t static ManagedBufferPointer._elementOffset.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 - 8);
  uint64_t result = a1 - 8;
  unint64_t v4 = (*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  uint64_t v5 = *(void *)(v3 + 64);
  BOOL v6 = __OFADD__(v4, v5);
  uint64_t v7 = v4 + v5;
  if (v6)
  {
    __break(1u);
  }
  else
  {
    uint64_t v8 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 1;
    BOOL v9 = __CFADD__(v7, v8);
    uint64_t v10 = v7 + v8;
    if (!v9) {
      return (v10 - 1) & -v8;
    }
  }
  __break(1u);
  return result;
}

uint64_t static ManagedBufferPointer._alignmentMask.getter(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(*(void *)(a1 - 8) + 80);
  if (*(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 1 <= v2 + 1) {
    LODWORD(v3) = v2 + 1;
  }
  else {
    LODWORD(v3) = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 1;
  }
  if (v3 <= 8) {
    uint64_t v3 = 8;
  }
  else {
    uint64_t v3 = v3;
  }
  return v3 - 1;
}

uint64_t ManagedBufferPointer.header.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a3, a1+ ((*(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a2 - 8) + 80)), a2);
}

uint64_t _ss20ManagedBufferPointerVsRi__rlE6headerxvpRi__r0_lAByxq_GTK@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(a2 + a1 - 16);
  uint64_t v5 = (uint64_t (*)(uint64_t *, void))ManagedBufferPointer.header.read();
  (*(void (**)(uint64_t))(*(void *)(v4 - 8) + 16))(a3);
  return v5(&v7, 0);
}

uint64_t _ss20ManagedBufferPointerVsRi__rlE6headerxvpRi__r0_lAByxq_GTk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a4 + a3 - 16);
  type metadata accessor for ManagedBufferPointer(0, v5, *(void *)(a4 + a3 - 8), a4);
  BOOL v6 = (uint64_t (*)(uint64_t *, void))ManagedBufferPointer.header.modify();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24))(v7, a1, v5);
  return v6(&v9, 0);
}

uint64_t ManagedBufferPointer._headerPointer.getter(uint64_t a1, uint64_t a2)
{
  return a1
       + ((*(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a2 - 8) + 80));
}

uint64_t ManagedBufferPointer.header.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 40))(*v2+ ((*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80)), a1);
}

uint64_t ManagedBufferPointer._elementPointer.getter(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 - 8);
  unint64_t v4 = (*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  uint64_t v5 = *(void *)(v3 + 64);
  BOOL v6 = __OFADD__(v4, v5);
  uint64_t v7 = v4 + v5;
  if (v6)
  {
    __break(1u);
  }
  else
  {
    uint64_t v8 = *(unsigned __int8 *)(*(void *)(a3 - 8) + 80) + 1;
    BOOL v9 = __CFADD__(v7, v8);
    uint64_t v10 = v7 + v8;
    if (!v9)
    {
      result += (v10 - 1) & -v8;
      return result;
    }
  }
  __break(1u);
  return result;
}

uint64_t ManagedBufferPointer.withUnsafeMutablePointerToHeader<A>(_:)(uint64_t (*a1)(unint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1(a3+ ((*(unsigned __int8 *)(*(void *)(a4 - 8) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a4 - 8) + 80)));
}

uint64_t (*ManagedBufferPointer.withUnsafeMutablePointerToElements<A>(_:)(uint64_t (*result)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t)
{
  uint64_t v5 = *(void *)(a4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  unint64_t v7 = (*(unsigned __int8 *)(v5 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  BOOL v8 = __OFADD__(v7, v6);
  uint64_t v9 = v7 + v6;
  if (v8)
  {
    __break(1u);
  }
  else
  {
    uint64_t v10 = *(unsigned __int8 *)(*(void *)(a5 - 8) + 80) + 1;
    BOOL v11 = __CFADD__(v9, v10);
    uint64_t v12 = v9 + v10;
    if (!v11) {
      return (uint64_t (*)(uint64_t))result(a3 + ((v12 - 1) & -v10));
    }
  }
  __break(1u);
  return result;
}

uint64_t (*ManagedBufferPointer.withUnsafeMutablePointers<A>(_:)(uint64_t (*result)(unint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(unint64_t, uint64_t)
{
  uint64_t v5 = *(void *)(a4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  unint64_t v7 = (*(unsigned __int8 *)(v5 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  uint64_t v8 = v7 + v6;
  if (__OFADD__(v7, v6))
  {
    __break(1u);
  }
  else
  {
    uint64_t v9 = *(unsigned __int8 *)(*(void *)(a5 - 8) + 80) + 1;
    BOOL v10 = __CFADD__(v8, v9);
    uint64_t v11 = v8 + v9;
    if (!v10) {
      return (uint64_t (*)(unint64_t, uint64_t))result(a3 + v7, a3 + ((v11 - 1) & -v9));
    }
  }
  __break(1u);
  return result;
}

unint64_t static ManagedBufferPointer._headerOffset.getter(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)(a1 - 8) + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a1 - 8) + 80);
}

BOOL static ManagedBufferPointer.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance ManagedBufferPointer<A, B>(uint64_t *a1, uint64_t *a2)
{
  return static ManagedBufferPointer.== infix(_:_:)(*a1, *a2);
}

uint64_t isKnownUniquelyReferenced<A>(_:)(unint64_t *a1)
{
  return swift_isUniquelyReferenced_nonNull(*a1);
}

uint64_t isKnownUniquelyReferenced<A>(_:)(uint64_t *a1)
{
  return swift_isUniquelyReferenced(*a1);
}

uint64_t (*LazyMapSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Class *LazyMapSequence.init(_base:transform:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(a7, a1, a4);
  uint64_t result = type metadata accessor for LazyMapSequence(0, a4, a5, a6);
  uint64_t v14 = (void *)(a7 + *((int *)result + 11));
  *uint64_t v14 = a2;
  v14[1] = a3;
  return result;
}

uint64_t (*LazyMapSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyMapSequence._transform.getter(uint64_t a1)
{
  int v2 = (uint64_t *)(v1 + *(int *)(a1 + 44));
  uint64_t v3 = *v2;
  swift_retain((atomic_ullong *)v2[1]);
  return v3;
}

uint64_t LazyMapSequence.Iterator.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 32), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v5(a2, v2, AssociatedTypeWitness);
}

Class *LazyMapSequence.Iterator.init(_base:_transform:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int **a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a7, a1, AssociatedTypeWitness);
  uint64_t result = type metadata accessor for LazyMapSequence.Iterator(0, a4, a5, (uint64_t)a6);
  uint64_t v16 = (void *)(a7 + *((int *)result + 11));
  *uint64_t v16 = a2;
  v16[1] = a3;
  return result;
}

unint64_t specialized LazyMapSequence.Iterator.next()()
{
  void (*v7)(void *__return_ptr, int *);
  uint64_t v8;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v10;
  void v11[2];
  int v12;

  uint64_t v1 = v0[2];
  uint64_t v2 = v0[3];
  if (v1 >= v2)
  {
    uint64_t v8 = 0;
    goto LABEL_11;
  }
  uint64_t v3 = v0[1];
  if ((v3 & 0x1000000000000000) != 0)
  {
    BOOL v10 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v1 << 16));
    Swift::Int scalarLength = v10.scalarLength;
    int value = v10._0._value;
  }
  else
  {
    if ((v3 & 0x2000000000000000) != 0)
    {
      v11[0] = *v0;
      v11[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int value = *((unsigned __int8 *)v11 + v1);
      if (*((char *)v11 + v1) < 0)
      {
        switch(__clz(value ^ 0xFF))
        {
          case 0x1Au:
            unint64_t v4 = v11;
LABEL_14:
            Swift::Int scalarLength = 2;
            int value = *((unsigned char *)v4 + v1 + 1) & 0x3F | ((value & 0x1F) << 6);
            break;
          case 0x1Bu:
            unint64_t v4 = v11;
LABEL_16:
            int value = ((value & 0xF) << 12) | ((*((unsigned char *)v4 + v1 + 1) & 0x3F) << 6) | *((unsigned char *)v4 + v1 + 2) & 0x3F;
            Swift::Int scalarLength = 3;
            break;
          case 0x1Cu:
            unint64_t v4 = v11;
LABEL_18:
            int value = ((value & 0xF) << 18) | ((*((unsigned char *)v4 + v1 + 1) & 0x3F) << 12) | ((*((unsigned char *)v4 + v1 + 2) & 0x3F) << 6) | *((unsigned char *)v4 + v1 + 3) & 0x3F;
            Swift::Int scalarLength = 4;
            break;
          default:
            goto LABEL_9;
        }
        goto LABEL_10;
      }
    }
    else
    {
      if ((*v0 & 0x1000000000000000) != 0) {
        unint64_t v4 = (void *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unint64_t v4 = _StringObject.sharedUTF8.getter(*v0, v0[1]);
      }
      int value = *((unsigned __int8 *)v4 + v1);
      if (*((char *)v4 + v1) < 0)
      {
        switch(__clz(value ^ 0xFF))
        {
          case 0x1Au:
            goto LABEL_14;
          case 0x1Bu:
            goto LABEL_16;
          case 0x1Cu:
            goto LABEL_18;
          default:
            break;
        }
      }
    }
LABEL_9:
    Swift::Int scalarLength = 1;
  }
LABEL_10:
  v0[2] += scalarLength;
  unint64_t v7 = (void (*)(void *__return_ptr, int *))v0[4];
  uint64_t v12 = value;
  v7(v11, &v12);
  uint64_t v8 = LODWORD(v11[0]);
LABEL_11:
  LOBYTE(v11[0]) = v1 >= v2;
  return v8 | ((unint64_t)(v1 >= v2) << 32);
}

{
  Swift::String::Index *v0;
  Swift::UInt64 rawBits;
  Swift::UInt64 v2;
  Swift::UInt64 v3;
  Swift::UInt64 v4;
  Swift::UInt64 v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  Swift::UInt64 v13;
  unint64_t v14;
  Swift::UInt64 v15;
  uint64_t v17;
  uint64_t v18;
  Swift::Int v19;
  Swift::Int v20;
  id v21;
  uint64_t v22;
  uint8x16_t *v23;
  uint64_t v24;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  Swift::UInt64 v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  Swift::Int v41;
  int64_t v42;
  char *v43;
  uint64_t v44;
  Swift::Int v45;
  int v46;
  char *v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  Swift::Int v53;
  char *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  void (*v58)(unint64_t *__return_ptr, void *);
  uint64_t v59;
  Swift::String v60;
  Swift::Int v61;
  Swift::String::Index v62;
  uint64_t v63;
  uint64_t v64;
  Swift::String::Index v65;
  Swift::Int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  Swift::String::Index v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void v78[2];
  unint64_t v79;
  uint64_t v80;

  rawBits = v0[4]._rawBits;
  uint64_t v2 = v0[1]._rawBits;
  uint64_t v3 = rawBits >> 14;
  unint64_t v4 = v2 >> 14;
  if (rawBits >> 14 == v2 >> 14) {
    return 0;
  }
  uint64_t v6 = v0->_rawBits;
  unint64_t v7 = v0[2]._rawBits;
  uint64_t v8 = v0[3]._rawBits;
  uint64_t v9 = (v7 >> 59) & 1;
  if ((v8 & 0x1000000000000000) == 0) {
    LOBYTE(v9) = 1;
  }
  BOOL v10 = v0[4]._rawBits & 0xC;
  uint64_t v11 = 4 << v9;
  if ((rawBits & 1) == 0 || v10 == v11)
  {
    BOOL v15 = rawBits >> 14;
    unint64_t v13 = v0[4]._rawBits;
    if (v10 == v11)
    {
      unint64_t v13 = _StringGuts._slowEnsureMatchingEncoding(_:)(v0[4])._rawBits;
      BOOL v15 = v13 >> 14;
    }
    if (v15 < v6 >> 14 || v15 >= v4) {
      goto LABEL_19;
    }
    if ((v13 & 1) == 0) {
      unint64_t v13 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v13)._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
    }
  }
  else
  {
    uint64_t v12 = v3 < v4 && v3 >= v6 >> 14;
    unint64_t v13 = v0[4]._rawBits;
    if (!v12)
    {
      uint64_t v14 = 143;
      goto LABEL_45;
    }
  }
  uint64_t v17 = (v13 >> 8) & 0x3F;
  uint64_t v18 = v13 >> 16;
  int64_t v19 = v2 >> 16;
  if (!v17)
  {
    if (v18 == v19)
    {
      uint64_t v17 = 0;
      goto LABEL_25;
    }
    if ((v8 & 0x1000000000000000) == 0)
    {
      if ((v8 & 0x2000000000000000) != 0)
      {
        uint64_t v79 = v7;
        uint64_t v80 = v8 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v45 = v18 + 1;
        if (v18 + 1 == (HIBYTE(v8) & 0xF)) {
          goto LABEL_70;
        }
        unint64_t v46 = *(unsigned __int16 *)((char *)&v79 + v18);
      }
      else
      {
        if ((v7 & 0x1000000000000000) != 0)
        {
          uint64_t v43 = (char *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v44 = v7 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v43 = (char *)_StringObject.sharedUTF8.getter(v7, v8);
        }
        unint64_t v45 = v18 + 1;
        if (v18 + 1 == v44)
        {
LABEL_70:
          if (v19 >= v45) {
            int64_t v19 = v45;
          }
          if (v19 >= v18)
          {
LABEL_29:
            if ((v8 & 0x2000000000000000) != 0)
            {
              uint64_t v79 = v7;
              uint64_t v80 = v8 & 0xFFFFFFFFFFFFFFLL;
              if ((uint64_t)(HIBYTE(v8) & 0xF) >= v19)
              {
                uint64_t v24 = v19 - v18;
                if (v19 - v18 < 0) {
                  _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
                }
                uint64_t v23 = (uint8x16_t *)((char *)&v79 + v18);
                goto LABEL_36;
              }
            }
            else if ((v7 & 0x1000000000000000) != 0)
            {
              uint64_t v21 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v22 = v7 & 0xFFFFFFFFFFFFLL;
              if ((uint64_t)(v7 & 0xFFFFFFFFFFFFLL) >= v19)
              {
LABEL_32:
                uint64_t v23 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v18, v19, (uint64_t)v21, v22);
LABEL_36:
                uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v23, v24);
                goto LABEL_37;
              }
            }
            else
            {
              uint64_t v21 = _StringObject.sharedUTF8.getter(v7, v8);
              unint64_t v22 = v61;
              if (v61 >= v19) {
                goto LABEL_32;
              }
            }
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
          }
LABEL_73:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
        }
        if (!v43) {
          goto LABEL_119;
        }
        unint64_t v46 = *(unsigned __int16 *)&v43[v18];
      }
      if (v46 != 2573 && (v46 & 0x80808080) == 0) {
        goto LABEL_70;
      }
    }
    uint64_t v17 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v18);
  }
LABEL_25:
  uint64_t v20 = v17 + v18;
  if (v19 >= v20) {
    int64_t v19 = v20;
  }
  if ((v8 & 0x1000000000000000) == 0)
  {
    if (v19 >= v18) {
      goto LABEL_29;
    }
    goto LABEL_73;
  }
  unint64_t v60 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v18, v19);
  object = v60._object;
  uint64_t countAndFlagsBits = v60._countAndFlagsBits;
LABEL_37:
  unint64_t v27 = countAndFlagsBits;
  unint64_t v28 = (uint64_t)object;
  uint64_t v29 = v0->_rawBits;
  id v30 = v0[1]._rawBits;
  unsigned int v31 = v0[2]._rawBits;
  uint64_t v32 = v0[3]._rawBits;
  uint64_t v33 = (v32 & 0x1000000000000000) == 0 || (v31 & 0x800000000000000) != 0;
  uint64_t v34 = 4 << v33;
  BOOL v35 = v30 >> 14;
  if ((rawBits & 2) == 0 || v10 == v34)
  {
    if (v10 == v34)
    {
      v62._rawBits = rawBits;
      char v63 = (uint64_t)object;
      uint64_t v64 = v27;
      v65._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v62)._rawBits;
      unint64_t v27 = v64;
      unint64_t v28 = v63;
      rawBits = v65._rawBits;
      uint64_t v3 = v65._rawBits >> 14;
    }
    if (v3 >= v29 >> 14 && v3 < v35)
    {
      if (rawBits)
      {
        if ((v29 & 2) != 0) {
          goto LABEL_52;
        }
      }
      else
      {
        unint64_t v77 = v28;
        char v69 = v27;
        v70._rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
        unint64_t v27 = v69;
        unint64_t v28 = v77;
        rawBits = rawBits & 0xC | v70._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
        if ((v29 & 2) != 0)
        {
LABEL_52:
          if ((rawBits & 2) != 0) {
            goto LABEL_56;
          }
        }
      }
      if (rawBits >> 14 != v29 >> 14 && rawBits >> 14 != v35)
      {
        Swift::String::Index v36 = rawBits;
        char v37 = v28;
        uint64_t v38 = v27;
        unint64_t v39 = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(v36, v29, v30, v31, v32);
        unint64_t v27 = v38;
        unint64_t v28 = v37;
        rawBits = v39;
      }
      goto LABEL_56;
    }
LABEL_19:
    uint64_t v14 = 43;
    goto LABEL_45;
  }
  if (v3 < v29 >> 14 || v3 >= v35)
  {
    uint64_t v14 = 267;
LABEL_45:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v14, 0);
  }
LABEL_56:
  unint64_t v40 = (rawBits >> 8) & 0x3F;
  uint64_t v41 = rawBits >> 16;
  uint64_t v42 = v30 >> 16;
  if (v40) {
    goto LABEL_86;
  }
  if (v41 == v42)
  {
    unint64_t v40 = 0;
    goto LABEL_86;
  }
  if ((v32 & 0x1000000000000000) != 0) {
    goto LABEL_115;
  }
  if ((v32 & 0x2000000000000000) == 0)
  {
    if ((v31 & 0x1000000000000000) != 0)
    {
      uint64_t v47 = (char *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
      Swift::Int v48 = v31 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      unint64_t v75 = v28;
      unint64_t v76 = v27;
      uint64_t v47 = (char *)_StringObject.sharedUTF8.getter(v31, v32);
      unint64_t v27 = v76;
      unint64_t v28 = v75;
    }
    if (v41 + 1 == v48) {
      goto LABEL_85;
    }
    if (!v47) {
      goto LABEL_119;
    }
    uint64_t v49 = *(unsigned __int16 *)&v47[v41];
    if (v49 == 2573) {
      goto LABEL_115;
    }
LABEL_84:
    if ((v49 & 0x80808080) == 0) {
      goto LABEL_85;
    }
    goto LABEL_115;
  }
  uint64_t v79 = v31;
  uint64_t v80 = v32 & 0xFFFFFFFFFFFFFFLL;
  if (v41 + 1 == (HIBYTE(v32) & 0xF))
  {
LABEL_85:
    unint64_t v40 = 1;
    goto LABEL_86;
  }
  uint64_t v49 = *(unsigned __int16 *)((char *)&v79 + v41);
  if (v49 != 2573) {
    goto LABEL_84;
  }
LABEL_115:
  Swift::String::Index v71 = v28;
  Swift::String::Index v72 = v27;
  unint64_t v40 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v41);
  unint64_t v27 = v72;
  unint64_t v28 = v71;
LABEL_86:
  char v50 = v40 + v41;
  if (v42 < v40 + v41) {
    char v50 = v42;
  }
  uint64_t v51 = v50 << 16;
  unint64_t v52 = v50 & 0xFFFFFFFFFFFFLL;
  if ((v50 & 0xFFFFFFFFFFFFLL) != v42)
  {
    if ((v32 & 0x1000000000000000) != 0) {
      goto LABEL_110;
    }
    if ((v32 & 0x2000000000000000) != 0)
    {
      uint64_t v79 = v31;
      uint64_t v80 = v32 & 0xFFFFFFFFFFFFFFLL;
      if (v52 + 1 == (HIBYTE(v32) & 0xF)) {
        goto LABEL_101;
      }
      uint64_t v56 = *(unsigned __int16 *)((char *)&v79 + v52);
      if (v56 == 2573) {
        goto LABEL_110;
      }
LABEL_100:
      if ((v56 & 0x80808080) != 0) {
        goto LABEL_110;
      }
LABEL_101:
      unint64_t v53 = 1;
      goto LABEL_102;
    }
    if ((v31 & 0x1000000000000000) != 0)
    {
      unint64_t v54 = (char *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
      unint64_t v55 = v31 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      Swift::String::Index v73 = v28;
      Swift::String::Index v74 = v27;
      unint64_t v54 = (char *)_StringObject.sharedUTF8.getter(v31, v32);
      unint64_t v27 = v74;
      unint64_t v28 = v73;
    }
    if (v52 + 1 == v55) {
      goto LABEL_101;
    }
    if (v54)
    {
      uint64_t v56 = *(unsigned __int16 *)&v54[v52];
      if (v56 == 2573)
      {
LABEL_110:
        Swift::Int v66 = v52;
        unint64_t v67 = v28;
        int64_t v68 = v27;
        unint64_t v53 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v66);
        unint64_t v27 = v68;
        unint64_t v28 = v67;
        if (v53 > 63) {
          goto LABEL_103;
        }
        goto LABEL_102;
      }
      goto LABEL_100;
    }
LABEL_119:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  unint64_t v53 = 0;
LABEL_102:
  v51 |= v53 << 8;
LABEL_103:
  unint64_t v57 = 8;
  if (v33) {
    unint64_t v57 = 4;
  }
  v0[4]._rawBits = v29 & 2 | v57 | v51 | 1;
  uint64_t v58 = (void (*)(unint64_t *__return_ptr, void *))v0[5]._rawBits;
  v78[0] = v27;
  v78[1] = v28;
  unint64_t v59 = v28;
  v58(&v79, v78);
  swift_bridgeObjectRelease(v59);
  return v79;
}

uint64_t specialized LazyMapSequence.Iterator.next()()
{
  void (*v18)(uint64_t *__return_ptr, void *);
  Swift::String v20;
  unint64_t v21;
  uint64_t v22;
  void v23[2];
  uint64_t v24;
  uint64_t v25;

  Swift::Int v1 = v0[2];
  if (v1 >= v0[3]) {
    return 0;
  }
  uint64_t v2 = *v0;
  unint64_t v3 = v0[1];
  if ((v3 & 0x1000000000000000) != 0)
  {
LABEL_30:
    Swift::Int v9 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v1);
    Swift::Int v6 = v9 + v1;
    uint64_t v10 = *v0;
    unint64_t v11 = v0[1];
    if ((v11 & 0x1000000000000000) != 0) {
      goto LABEL_31;
    }
    goto LABEL_17;
  }
  if ((v3 & 0x2000000000000000) != 0)
  {
    uint64_t v24 = *v0;
    uint64_t v25 = v3 & 0xFFFFFFFFFFFFFFLL;
    Swift::Int v6 = v1 + 1;
    if (v1 + 1 == (HIBYTE(v3) & 0xF)) {
      goto LABEL_16;
    }
    int v7 = *(unsigned __int16 *)((char *)&v24 + v1);
  }
  else
  {
    if ((v2 & 0x1000000000000000) != 0)
    {
      unint64_t v4 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      unint64_t v4 = (char *)_StringObject.sharedUTF8.getter(*v0, v0[1]);
    }
    Swift::Int v6 = v1 + 1;
    if (v1 + 1 == v5) {
      goto LABEL_16;
    }
    if (!v4) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    }
    int v7 = *(unsigned __int16 *)&v4[v1];
  }
  if (v7 == 2573 || (v7 & 0x8080) != 0) {
    goto LABEL_30;
  }
LABEL_16:
  Swift::Int v9 = 1;
  uint64_t v10 = *v0;
  unint64_t v11 = v0[1];
  if ((v11 & 0x1000000000000000) != 0)
  {
LABEL_31:
    uint64_t v20 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v1, v6);
    object = v20._object;
    uint64_t countAndFlagsBits = v20._countAndFlagsBits;
    goto LABEL_28;
  }
LABEL_17:
  if (v6 < v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((v11 & 0x2000000000000000) != 0)
  {
    uint64_t v24 = v10;
    uint64_t v25 = v11 & 0xFFFFFFFFFFFFFFLL;
    if ((v1 & 0x8000000000000000) == 0)
    {
      if ((uint64_t)(HIBYTE(v11) & 0xF) >= v6)
      {
        if (v9 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
        }
        uint64_t v14 = (uint8x16_t *)((char *)&v24 + v1);
        goto LABEL_27;
      }
      goto LABEL_34;
    }
    goto LABEL_37;
  }
  if ((v10 & 0x1000000000000000) != 0)
  {
    id v12 = (id)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = v10 & 0xFFFFFFFFFFFFLL;
    if ((v1 & 0x8000000000000000) == 0) {
      goto LABEL_21;
    }
LABEL_37:
    uint64_t v21 = 1860;
LABEL_38:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v21, 0);
  }
  id v12 = _StringObject.sharedUTF8.getter(v10, v11);
  uint64_t v13 = v22;
  if (v1 < 0) {
    goto LABEL_37;
  }
LABEL_21:
  if (v13 < v6)
  {
LABEL_34:
    uint64_t v21 = 1861;
    goto LABEL_38;
  }
  uint64_t v14 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v1, v6, (uint64_t)v12, v13);
LABEL_27:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v14, v9);
LABEL_28:
  uint64_t v17 = (uint64_t)object;
  v0[2] = v6;
  uint64_t v18 = (void (*)(uint64_t *__return_ptr, void *))v0[4];
  v23[0] = countAndFlagsBits;
  v23[1] = object;
  v18(&v24, v23);
  swift_bridgeObjectRelease(v17);
  return v24;
}

uint64_t LazyMapSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v28 = a2;
  unint64_t v4 = *(int ***)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v27 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v25 = (char *)&v25 - v7;
  uint64_t v26 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v10 = (uint64_t)*(v26 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v26);
  uint64_t v13 = (char *)&v25 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  BOOL v15 = (char *)&v25 - v14;
  uint64_t v16 = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v18 = *(void (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
  int64_t v19 = swift_checkMetadataState(0, (uint64_t)v16);
  v18(v19, AssociatedConformanceWitness);
  uint64_t v20 = *(void (**)(char *))(v2 + *(int *)(a1 + 44));
  (*(void (**)(char *, char *, Class *))(v10 + 32))(v13, v15, v26);
  uint64_t v21 = v27;
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v27 + 48))(v13, 1, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8) + 56))(v28, 1, 1);
  }
  uint64_t v23 = v25;
  (*(void (**)(char *, char *, const char *))(v21 + 32))(v25, v13, AssociatedTypeWitness);
  uint64_t v24 = v28;
  v20(v23);
  (*(void (**)(char *, const char *))(v21 + 8))(v23, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8) + 56))(v24, 0, 1);
}

__n128 LazyMapSequence.makeIterator()@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 32))((char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v2, v6);
  uint64_t v9 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t, uint64_t))(v9 + 32))(v6, v9);
  uint64_t v10 = *(int *)(a1 + 44);
  uint64_t v11 = type metadata accessor for LazyMapSequence.Iterator(0, v6, *(void *)(a1 + 24), v9);
  __n128 result = *(__n128 *)(v3 + v10);
  *(__n128 *)(a2 + *((int *)v11 + 11)) = result;
  return result;
}

uint64_t LazyMapSequence.underestimatedCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 40))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 184))(a1, *(void *)(a2 + 16));
}

Swift::Int specialized LazyMapSequence<>.formIndex(after:)(unint64_t *a1)
{
  unint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  uint64_t v5 = v1[2];
  unint64_t v6 = v1[3];
  unint64_t rawBits = *a1;
  int v8 = (v6 & 0x1000000000000000) == 0 || (v5 & 0x800000000000000) != 0;
  unint64_t v9 = rawBits & 0xC;
  uint64_t v10 = 4 << v8;
  unint64_t v11 = v3 >> 14;
  if ((rawBits & 2) != 0 && v9 != v10)
  {
    if (rawBits >> 14 >= v4 >> 14 && rawBits >> 14 < v11) {
      goto LABEL_27;
    }
    unint64_t v13 = 267;
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v13, 0);
  }
  if (v9 == v10) {
    unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  unint64_t v14 = v4 >> 14;
  if (rawBits >> 14 < v4 >> 14 || rawBits >> 14 >= v11)
  {
    unint64_t v13 = 43;
    goto LABEL_20;
  }
  if (rawBits)
  {
    if ((v4 & 2) != 0) {
      goto LABEL_23;
    }
  }
  else
  {
    int v39 = v8;
    char v31 = rawBits;
    v32._unint64_t rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    uint64_t v33 = v31 & 0xC;
    unint64_t v14 = v4 >> 14;
    int v8 = v39;
    unint64_t rawBits = v33 | v32._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if ((v4 & 2) != 0)
    {
LABEL_23:
      if ((rawBits & 2) != 0) {
        goto LABEL_27;
      }
    }
  }
  if (rawBits >> 14 != v14 && rawBits >> 14 != v11) {
    unint64_t rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(rawBits, v4, v3, v5, v6);
  }
LABEL_27:
  uint64_t v16 = (rawBits >> 8) & 0x3F;
  Swift::Int v17 = rawBits >> 16;
  int64_t v18 = v3 >> 16;
  if (v16) {
    goto LABEL_42;
  }
  if (v17 == v18)
  {
    uint64_t v16 = 0;
    goto LABEL_42;
  }
  if ((v6 & 0x1000000000000000) != 0) {
    goto LABEL_69;
  }
  if ((v6 & 0x2000000000000000) == 0)
  {
    if ((v5 & 0x1000000000000000) != 0)
    {
      int64_t v19 = (char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v20 = v5 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      Swift::Int v37 = rawBits >> 16;
      int64_t v38 = v18;
      int64_t v19 = (char *)_StringObject.sharedUTF8.getter(v5, v6);
      int64_t v18 = v38;
      Swift::Int v17 = v37;
    }
    if (v17 + 1 == v20) {
      goto LABEL_41;
    }
    if (!v19) {
      goto LABEL_72;
    }
    int v21 = *(unsigned __int16 *)&v19[v17];
    if (v21 == 2573) {
      goto LABEL_69;
    }
LABEL_40:
    if ((v21 & 0x80808080) == 0) {
      goto LABEL_41;
    }
    goto LABEL_69;
  }
  uint64_t v40 = v5;
  uint64_t v41 = v6 & 0xFFFFFFFFFFFFFFLL;
  if (v17 + 1 == (HIBYTE(v6) & 0xF))
  {
LABEL_41:
    uint64_t v16 = 1;
    goto LABEL_42;
  }
  int v21 = *(unsigned __int16 *)((char *)&v40 + v17);
  if (v21 != 2573) {
    goto LABEL_40;
  }
LABEL_69:
  Swift::Int v34 = v17;
  int64_t v35 = v18;
  Swift::Int v36 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v17);
  int64_t v18 = v35;
  uint64_t v16 = v36;
  Swift::Int v17 = v34;
LABEL_42:
  uint64_t v22 = v16 + v17;
  if (v18 < v22) {
    uint64_t v22 = v18;
  }
  uint64_t v23 = v22 << 16;
  Swift::Int v24 = v22 & 0xFFFFFFFFFFFFLL;
  if ((v22 & 0xFFFFFFFFFFFFLL) == v18)
  {
    Swift::Int result = 0;
LABEL_61:
    v23 |= result << 8;
    goto LABEL_62;
  }
  if ((v6 & 0x1000000000000000) == 0)
  {
    if ((v6 & 0x2000000000000000) != 0)
    {
      uint64_t v40 = v5;
      uint64_t v41 = v6 & 0xFFFFFFFFFFFFFFLL;
      if (v24 + 1 == (HIBYTE(v6) & 0xF)) {
        goto LABEL_60;
      }
      int v28 = *(unsigned __int16 *)((char *)&v40 + v24);
LABEL_55:
      if (v28 == 2573 || (v28 & 0x8080) != 0) {
        goto LABEL_65;
      }
LABEL_60:
      Swift::Int result = 1;
      goto LABEL_61;
    }
    if ((v5 & 0x1000000000000000) != 0)
    {
      uint64_t v26 = (char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v27 = v5 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(v5, v6);
    }
    if (v24 + 1 == v27) {
      goto LABEL_60;
    }
    if (v26)
    {
      int v28 = *(unsigned __int16 *)&v26[v24];
      goto LABEL_55;
    }
LABEL_72:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
LABEL_65:
  Swift::Int result = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v24);
  if (result <= 63) {
    goto LABEL_61;
  }
LABEL_62:
  uint64_t v30 = 8;
  if (v8) {
    uint64_t v30 = 4;
  }
  *a1 = v4 & 2 | v30 | v23 | 1;
  return result;
}

uint64_t LazyMapSequence<>.formIndex(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 192))(a1, *(void *)(a2 + 16));
}

uint64_t specialized LazyMapSequence<>.subscript.getter(Swift::String::Index a1, uint64_t a2, uint64_t a3, void (*a4)(void *__return_ptr, Swift::UInt32 *))
{
  v7._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  if ((a3 & 0x1000000000000000) != 0)
  {
    Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v7._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
  }
  else
  {
    Swift::UInt64 v8 = v7._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      v19[0] = a2;
      v19[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::UInt32 value = *((unsigned __int8 *)v19 + v8);
      if (*((char *)v19 + v8) < 0)
      {
        switch(__clz(value ^ 0xFF))
        {
          case 0x1Au:
            unint64_t v9 = v19;
LABEL_10:
            Swift::UInt32 value = *((unsigned char *)v9 + v8 + 1) & 0x3F | ((value & 0x1F) << 6);
            break;
          case 0x1Bu:
            unint64_t v9 = v19;
LABEL_12:
            unint64_t v11 = (char *)v9 + v8;
            char v12 = v11[1];
            char v13 = v11[2];
            int v14 = ((value & 0xF) << 12) | ((v12 & 0x3F) << 6);
            goto LABEL_15;
          case 0x1Cu:
            unint64_t v9 = v19;
LABEL_14:
            BOOL v15 = (char *)v9 + v8;
            char v16 = v15[1];
            char v17 = v15[2];
            char v13 = v15[3];
            int v14 = ((value & 0xF) << 18) | ((v16 & 0x3F) << 12) | ((v17 & 0x3F) << 6);
LABEL_15:
            Swift::UInt32 value = v14 & 0xFFFFFFC0 | v13 & 0x3F;
            break;
          default:
            break;
        }
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0) {
        unint64_t v9 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unint64_t v9 = _StringObject.sharedUTF8.getter(a2, a3);
      }
      Swift::UInt32 value = *((unsigned __int8 *)v9 + v8);
      if (*((char *)v9 + v8) < 0)
      {
        switch(__clz(value ^ 0xFF))
        {
          case 0x1Au:
            goto LABEL_10;
          case 0x1Bu:
            goto LABEL_12;
          case 0x1Cu:
            goto LABEL_14;
          default:
            break;
        }
      }
    }
  }
  Swift::UInt32 v20 = value;
  a4(v19, &v20);
  return LODWORD(v19[0]);
}

uint64_t specialized LazyMapSequence<>.subscript.getter(Swift::String::Index a1, uint64_t a2, unint64_t a3, void (*a4)(uint64_t *__return_ptr, void *))
{
  v7._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  uint64_t v8 = (v7._rawBits >> 8) & 0x3F;
  int64_t v9 = v7._rawBits >> 16;
  if (v8) {
    goto LABEL_24;
  }
  uint64_t v10 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v11 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7._rawBits >> 14 != 4 * v11)
  {
    if ((a3 & 0x1000000000000000) != 0) {
      goto LABEL_39;
    }
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v27 = a2;
      uint64_t v28 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v9 + 1 != (HIBYTE(a3) & 0xF))
      {
        int v15 = *(unsigned __int16 *)((char *)&v27 + v9);
        if (v15 == 2573 || (v15 & 0x80808080) != 0) {
          goto LABEL_39;
        }
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0) {
        char v13 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        char v13 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      if (v9 + 1 != v10)
      {
        if (!v13) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        int v14 = *(unsigned __int16 *)&v13[v9];
        if (v14 == 2573 || (v14 & 0x80808080) != 0)
        {
LABEL_39:
          uint64_t v8 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9);
          int64_t v12 = v8 + v9;
          if ((a3 & 0x1000000000000000) == 0) {
            goto LABEL_25;
          }
LABEL_40:
          Swift::String v25 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v9, v12);
          object = v25._object;
          uint64_t countAndFlagsBits = v25._countAndFlagsBits;
          goto LABEL_34;
        }
      }
    }
    uint64_t v8 = 1;
LABEL_24:
    int64_t v12 = v8 + v9;
    if ((a3 & 0x1000000000000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_40;
  }
  uint64_t v8 = 0;
  int64_t v12 = v7._rawBits >> 16;
  if ((a3 & 0x1000000000000000) != 0) {
    goto LABEL_40;
  }
LABEL_25:
  if (v12 < v9) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((a3 & 0x2000000000000000) != 0)
  {
    uint64_t v27 = a2;
    uint64_t v28 = a3 & 0xFFFFFFFFFFFFFFLL;
    if ((uint64_t)(HIBYTE(a3) & 0xF) >= v12)
    {
      if (v8 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
      }
      int64_t v19 = (uint8x16_t *)((char *)&v27 + v9);
      goto LABEL_33;
    }
    goto LABEL_37;
  }
  if ((a2 & 0x1000000000000000) == 0)
  {
    id v17 = _StringObject.sharedUTF8.getter(a2, a3);
    uint64_t v18 = v24;
    if (v24 >= v12) {
      goto LABEL_29;
    }
LABEL_37:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
  }
  id v17 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v18 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0xFFFFFFFFFFFFLL) < v12) {
    goto LABEL_37;
  }
LABEL_29:
  int64_t v19 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v12, (uint64_t)v17, v18);
LABEL_33:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v19, v8);
LABEL_34:
  uint64_t v22 = (uint64_t)object;
  v26[0] = countAndFlagsBits;
  v26[1] = object;
  a4(&v27, v26);
  swift_bridgeObjectRelease(v22);
  return v27;
}

uint64_t specialized LazyMapSequence<>.subscript.getter(Swift::UInt64 rawBits)
{
  void (*v6)(uint64_t *__return_ptr, void *);
  char v7;
  Swift::UInt64 v8;
  uint64_t v9;
  Swift::UInt64 v10;
  unint64_t v12;
  uint64_t v14;
  Swift::Int v15;
  Swift::Int v16;
  Swift::Int v17;
  Swift::Int v18;
  id v19;
  uint64_t v20;
  uint8x16_t *v21;
  uint64_t v22;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v25;
  char *v27;
  uint64_t v28;
  Swift::Int v29;
  int v30;
  Swift::String v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  Swift::Int v35;
  Swift::Int v36;
  void v37[2];
  uint64_t v38;
  uint64_t v39;

  unint64_t v2 = *v1;
  unint64_t v3 = v1[1];
  uint64_t v4 = v1[2];
  unint64_t v5 = v1[3];
  unint64_t v6 = (void (*)(uint64_t *__return_ptr, void *))v1[4];
  Swift::String::Index v7 = (v5 & 0x1000000000000000) == 0 || (v4 & 0x800000000000000) != 0;
  uint64_t v8 = rawBits & 0xC;
  int64_t v9 = 4 << v7;
  uint64_t v10 = v3 >> 14;
  if ((rawBits & 1) != 0 && v8 != v9)
  {
    if (rawBits >> 14 >= v2 >> 14 && rawBits >> 14 < v10) {
      goto LABEL_23;
    }
    int64_t v12 = 143;
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v12, 0);
  }
  if (v8 == v9) {
    unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  if (rawBits >> 14 < v2 >> 14 || rawBits >> 14 >= v10)
  {
    int64_t v12 = 43;
    goto LABEL_20;
  }
  if ((rawBits & 1) == 0) {
    unint64_t rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
  }
LABEL_23:
  int v14 = (rawBits >> 8) & 0x3F;
  int v15 = rawBits >> 16;
  char v16 = v3 >> 16;
  if (v14) {
    goto LABEL_26;
  }
  if (v15 == v16)
  {
    int v14 = 0;
    goto LABEL_26;
  }
  if ((v5 & 0x1000000000000000) != 0) {
    goto LABEL_60;
  }
  if ((v5 & 0x2000000000000000) != 0)
  {
    int64_t v38 = v4;
    int v39 = v5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v29 = v15 + 1;
    if (v15 + 1 != (HIBYTE(v5) & 0xF))
    {
      uint64_t v30 = *(unsigned __int16 *)((char *)&v38 + v15);
      goto LABEL_49;
    }
LABEL_51:
    if (v16 >= v29) {
      uint64_t v18 = v29;
    }
    else {
      uint64_t v18 = v16;
    }
    if (v18 >= v15) {
      goto LABEL_31;
    }
LABEL_55:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((v4 & 0x1000000000000000) != 0)
  {
    uint64_t v27 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v28 = v4 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v27 = (char *)_StringObject.sharedUTF8.getter(v4, v5);
    char v16 = v3 >> 16;
  }
  uint64_t v29 = v15 + 1;
  if (v15 + 1 == v28) {
    goto LABEL_51;
  }
  if (!v27) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  uint64_t v30 = *(unsigned __int16 *)&v27[v15];
LABEL_49:
  if (v30 != 2573 && (v30 & 0x80808080) == 0) {
    goto LABEL_51;
  }
LABEL_60:
  int64_t v35 = v16;
  Swift::Int v36 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v15);
  char v16 = v35;
  int v14 = v36;
LABEL_26:
  id v17 = v14 + v15;
  if (v16 >= v17) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = v16;
  }
  if ((v5 & 0x1000000000000000) != 0)
  {
    char v31 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v15, v18);
    object = v31._object;
    uint64_t countAndFlagsBits = v31._countAndFlagsBits;
    goto LABEL_39;
  }
  if (v18 < v15) {
    goto LABEL_55;
  }
LABEL_31:
  if ((v5 & 0x2000000000000000) != 0)
  {
    int64_t v38 = v4;
    int v39 = v5 & 0xFFFFFFFFFFFFFFLL;
    if ((uint64_t)(HIBYTE(v5) & 0xF) >= v18)
    {
      uint64_t v22 = v18 - v15;
      if (v22 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
      }
      int v21 = (uint8x16_t *)((char *)&v38 + v15);
      goto LABEL_38;
    }
    goto LABEL_58;
  }
  if ((v4 & 0x1000000000000000) == 0)
  {
    Swift::String::Index v32 = v4;
    uint64_t v33 = v18;
    int64_t v19 = _StringObject.sharedUTF8.getter(v32, v5);
    Swift::UInt32 v20 = v34;
    uint64_t v18 = v33;
    if (v20 >= v33) {
      goto LABEL_34;
    }
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
  }
  int64_t v19 = (id)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
  Swift::UInt32 v20 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0xFFFFFFFFFFFFLL) < v18) {
    goto LABEL_58;
  }
LABEL_34:
  int v21 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v15, v18, (uint64_t)v19, v20);
LABEL_38:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v21, v22);
LABEL_39:
  Swift::String v25 = (uint64_t)object;
  v37[0] = countAndFlagsBits;
  v37[1] = object;
  v6(&v38, v37);
  swift_bridgeObjectRelease(v25);
  return v38;
}

uint64_t LazyMapSequence<>.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = &v15[-v10];
  int64_t v12 = *(void (**)(unsigned char *))(v3 + *(int *)(a2 + 44));
  char v13 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(a3 + 80))(v15, a1, v7, a3);
  (*(void (**)(unsigned char *))(v9 + 16))(v11);
  v13(v15, 0);
  v12(v11);
  return (*(uint64_t (**)(unsigned char *, const char *))(v9 + 8))(v11, AssociatedTypeWitness);
}

atomic_ullong *LazyMapSequence<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t))(a3 + 88))(a1, v8);
  uint64_t v9 = (uint64_t *)(v4 + *(int *)(a2 + 44));
  uint64_t v11 = *v9;
  uint64_t v10 = (atomic_ullong *)v9[1];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a3, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  uint64_t v13 = *(void *)(a2 + 24);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  int v15 = (void *)(a4
                 + *((int *)type metadata accessor for LazyMapSequence(0, (uint64_t)AssociatedTypeWitness, v13, *(void *)(AssociatedConformanceWitness + 8))+ 11));
  *int v15 = v11;
  v15[1] = v10;

  return swift_retain(v10);
}

uint64_t LazySequence<>.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a4 + 136))(a1, a2, *(void *)(a3 + 16));
}

uint64_t LazySequence<>.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a5 + 144))(a1, a2, a3, *(void *)(a4 + 16));
}

unint64_t specialized LazyMapSequence<>.distance(from:to:)(Swift::String::Index a1, Swift::String::Index a2, uint64_t a3)
{
  unint64_t rawBits = a1._rawBits;
  unint64_t v7 = *v3;
  unint64_t v6 = v3[1];
  uint64_t v8 = v3[2];
  unint64_t v9 = v3[3];
  char v10 = (v9 & 0x1000000000000000) == 0 || (v8 & 0x800000000000000) != 0;
  uint64_t v11 = a1._rawBits & 0xC;
  uint64_t v12 = 4 << v10;
  Swift::UInt64 v13 = v6 >> 14;
  if ((a1._rawBits & 2) == 0 || v11 == v12)
  {
    if (v11 == v12) {
      goto LABEL_98;
    }
    goto LABEL_12;
  }
  if (a1._rawBits >> 14 < v7 >> 14 || v13 < a1._rawBits >> 14)
  {
LABEL_10:
    unint64_t v15 = 296;
    goto LABEL_17;
  }
LABEL_24:
  uint64_t v17 = a2._rawBits & 0xC;
  if ((a2._rawBits & 2) == 0 || v17 == v12)
  {
    if (v17 == v12) {
      a2._unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
    }
    if (a2._rawBits >> 14 < v7 >> 14 || v13 < a2._rawBits >> 14) {
      goto LABEL_16;
    }
    if (a2._rawBits)
    {
      if ((v7 & 2) != 0) {
        goto LABEL_35;
      }
    }
    else
    {
      a2._unint64_t rawBits = a2._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a2)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      if ((v7 & 2) != 0)
      {
LABEL_35:
        if ((a2._rawBits & 2) != 0) {
          goto LABEL_39;
        }
      }
    }
    if (a2._rawBits >> 14 != v7 >> 14 && a2._rawBits >> 14 != v13) {
      a2._unint64_t rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(a2._rawBits, v7, v6, v8, v9);
    }
    goto LABEL_39;
  }
  if (a2._rawBits >> 14 < v7 >> 14 || v13 < a2._rawBits >> 14) {
    goto LABEL_10;
  }
LABEL_39:
  Swift::UInt64 v13 = a2._rawBits >> 14;
  if (rawBits >> 14 < a2._rawBits >> 14)
  {
    unint64_t v7 = 0;
    a2._unint64_t rawBits = v6 >> 16;
    uint64_t v18 = HIBYTE(v9) & 0xF;
    uint64_t v19 = v9 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v20 = (v9 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v12 = v8 & 0xFFFFFFFFFFFFLL;
    if (((v9 >> 60) & ((v8 & 0x800000000000000) == 0)) != 0) {
      uint64_t v21 = 8;
    }
    else {
      uint64_t v21 = 4;
    }
    while (1)
    {
      unint64_t v6 = v7 + 1;
      if (__OFADD__(v7, 1))
      {
        __break(1u);
LABEL_97:
        __break(1u);
LABEL_98:
        unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
LABEL_12:
        if (rawBits >> 14 < v7 >> 14 || v13 < rawBits >> 14)
        {
LABEL_16:
          unint64_t v15 = 65;
LABEL_17:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v15, 0);
        }
        if (rawBits)
        {
          if ((v7 & 2) != 0) {
            goto LABEL_20;
          }
LABEL_21:
          if (rawBits >> 14 != v7 >> 14 && rawBits >> 14 != v13) {
            unint64_t rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(rawBits, v7, v6, v8, v9);
          }
        }
        else
        {
          unint64_t rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
          if ((v7 & 2) == 0) {
            goto LABEL_21;
          }
LABEL_20:
          if ((rawBits & 2) == 0) {
            goto LABEL_21;
          }
        }
        goto LABEL_24;
      }
      uint64_t v22 = (rawBits >> 8) & 0x3F;
      Swift::Int v23 = rawBits >> 16;
      if (!v22) {
        break;
      }
LABEL_59:
      Swift::UInt64 v27 = v22 + v23;
      if ((uint64_t)a2._rawBits < v22 + v23) {
        Swift::UInt64 v27 = a2._rawBits;
      }
      Swift::UInt64 v28 = v27 << 16;
      uint64_t v29 = v27 & 0xFFFFFFFFFFFFLL;
      if ((v27 & 0xFFFFFFFFFFFFLL) != a2._rawBits)
      {
        if ((v9 & 0x1000000000000000) != 0) {
          goto LABEL_81;
        }
        if ((v9 & 0x2000000000000000) != 0)
        {
          uint64_t v54 = v8;
          uint64_t v55 = v19;
          if (v29 + 1 != v18)
          {
            int v33 = *(unsigned __int16 *)((char *)&v54 + v29);
LABEL_72:
            if (v33 == 2573 || (v33 & 0x8080) != 0)
            {
LABEL_81:
              uint64_t v46 = v20;
              uint64_t v50 = v18;
              Swift::Int v35 = v29;
              uint64_t v36 = v19;
              Swift::Int v30 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v35);
              uint64_t v20 = v46;
              uint64_t v18 = v50;
              uint64_t v19 = v36;
              if (v30 > 63) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }
          }
        }
        else
        {
          char v31 = (char *)v20;
          uint64_t v32 = v8 & 0xFFFFFFFFFFFFLL;
          if ((v8 & 0x1000000000000000) == 0)
          {
            uint64_t v48 = v20;
            uint64_t v52 = v18;
            uint64_t v45 = v19;
            char v31 = (char *)_StringObject.sharedUTF8.getter(v8, v9);
            uint64_t v19 = v45;
            uint64_t v20 = v48;
            uint64_t v18 = v52;
          }
          if (v29 + 1 != v32)
          {
            if (!v31) {
LABEL_103:
            }
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
            int v33 = *(unsigned __int16 *)&v31[v29];
            goto LABEL_72;
          }
        }
        Swift::Int v30 = 1;
        goto LABEL_78;
      }
      Swift::Int v30 = 0;
LABEL_78:
      v28 |= v30 << 8;
LABEL_79:
      unint64_t rawBits = v21 | v28 | 1;
      ++v7;
      if (v13 <= v28 >> 14) {
        return v6;
      }
    }
    if (v23 == a2._rawBits)
    {
      uint64_t v22 = 0;
      goto LABEL_59;
    }
    if ((v9 & 0x1000000000000000) == 0)
    {
      if ((v9 & 0x2000000000000000) == 0)
      {
        int64_t v24 = (char *)v20;
        uint64_t v25 = v8 & 0xFFFFFFFFFFFFLL;
        if ((v8 & 0x1000000000000000) == 0)
        {
          uint64_t v49 = v20;
          uint64_t v53 = v18;
          uint64_t v38 = v19;
          int64_t v24 = (char *)_StringObject.sharedUTF8.getter(v8, v9);
          uint64_t v20 = v49;
          uint64_t v18 = v53;
          uint64_t v19 = v38;
        }
        if (v23 + 1 == v25)
        {
LABEL_58:
          uint64_t v22 = 1;
          goto LABEL_59;
        }
        if (!v24) {
          goto LABEL_103;
        }
        int v26 = *(unsigned __int16 *)&v24[v23];
        if (v26 == 2573) {
          goto LABEL_83;
        }
        goto LABEL_57;
      }
      uint64_t v54 = v8;
      uint64_t v55 = v19;
      if (v23 + 1 == v18) {
        goto LABEL_58;
      }
      int v26 = *(unsigned __int16 *)((char *)&v54 + v23);
      if (v26 != 2573)
      {
LABEL_57:
        if ((v26 & 0x80808080) == 0) {
          goto LABEL_58;
        }
      }
    }
LABEL_83:
    uint64_t v47 = v20;
    uint64_t v51 = v18;
    uint64_t v37 = v19;
    uint64_t v22 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v23);
    uint64_t v20 = v47;
    uint64_t v18 = v51;
    uint64_t v19 = v37;
    goto LABEL_59;
  }
  if (v13 >= rawBits >> 14) {
    return 0;
  }
  unint64_t v6 = 0;
  a2._unint64_t rawBits = v7 >> 16;
  uint64_t v39 = 4;
  if (((v9 >> 60) & ((v8 & 0x800000000000000) == 0)) != 0) {
    uint64_t v39 = 8;
  }
  uint64_t v12 = v7 & 2 | v39;
  do
  {
    if (__OFSUB__(v6--, 1)) {
      goto LABEL_97;
    }
    if ((rawBits ^ v7) >= 0x4000)
    {
      uint64_t v40 = _StringGuts._opaqueCharacterStride(endingAt:in:)(rawBits >> 16, v7 >> 16, a3, v8, v9);
      rawBits -= v40 << 16;
      uint64_t v41 = v40 << 8;
      if (v40 > 63) {
        uint64_t v41 = 0;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    unint64_t v42 = rawBits & 0xFFFFFFFFFFFF0000 | v41;
    unint64_t rawBits = v12 | v42 | 1;
  }
  while (v13 < v42 >> 14);
  return v6;
}

uint64_t LazySequence<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a4 + 152))(a1, a2, *(void *)(a3 + 16));
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> LazyMapSequence<A, B>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x28uLL);
  *a1 = v8;
  v8[4] = LazyMapSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*LazyMapSequence<>.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x40uLL);
  *a1 = v8;
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 8), v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = malloc(*(void *)(v11 + 64));
  uint64_t v13 = *(void *)(a3 + 24);
  v8[4] = v12;
  v8[5] = v13;
  uint64_t v14 = *(void *)(v13 - 8);
  v8[6] = v14;
  v8[7] = malloc(*(void *)(v14 + 64));
  unint64_t v15 = *(void (**)(void *))(v4 + *(int *)(a3 + 44));
  char v16 = (void (*)(void *, void))(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(a4 + 80))(v8, a2, v9, a4);
  (*(void (**)(void *))(v11 + 16))(v12);
  v16(v8, 0);
  v15(v12);
  (*(void (**)(void *, const char *))(v11 + 8))(v12, AssociatedTypeWitness);
  return LazyMapSequence<>.subscript.read;
}

atomic_ullong *protocol witness for Collection.subscript.getter in conformance <> LazyMapSequence<A, B>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyMapSequence<>.subscript.getter(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> LazyDropWhileSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a2 - 8), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  unint64_t v7 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v5, v6);
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, Class *))*((void *)*(v7 - 1) + 7);

  return v8(a3, 1, 1, v7);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazyMapSequence<>.formIndex(after:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t DefaultIndices<>.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 32))(a1, *(void *)(a2 + 16));
}

uint64_t DefaultIndices<>.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 40))(a1, *(void *)(a2 + 16));
}

atomic_ullong *LazyMapSequence.map<A>(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v28 = a5;
  uint64_t v29 = a2;
  uint64_t v27 = a1;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v9 = *(void *)(v8 + 64);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v26 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1F4188790](v10);
  char v16 = (char *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v5, v13);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v11, v5, a3);
  uint64_t v17 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v18 = (v17 + 64) & ~v17;
  uint64_t v19 = (char *)swift_allocObject(qword_1EC9F2AA0, v18 + v9, v17 | 7);
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v21 = *(void *)(a3 + 32);
  *((void *)v19 + 2) = v13;
  *((void *)v19 + 3) = v20;
  *((void *)v19 + 4) = a4;
  *((void *)v19 + 5) = v21;
  uint64_t v22 = v29;
  *((void *)v19 + 6) = v27;
  *((void *)v19 + 7) = v22;
  (*(void (**)(char *, char *, uint64_t))(v8 + 32))(&v19[v18], v11, a3);
  uint64_t v23 = v28;
  (*(void (**)(uint64_t, char *, uint64_t))(v14 + 32))(v28, v16, v13);
  int64_t v24 = (uint64_t (**)(uint64_t))(v23
                                         + *((int *)type metadata accessor for LazyMapSequence(0, v13, a4, v21) + 11));
  *int64_t v24 = partial apply for closure #1 in LazyMapSequence.map<A>(_:);
  v24[1] = (uint64_t (*)(uint64_t))v19;
  return swift_retain(v29);
}

uint64_t closure #1 in LazyMapSequence.map<A>(_:)(uint64_t a1, void (*a2)(char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v16 = type metadata accessor for LazyMapSequence(0, v13, v14, v15);
  (*(void (**)(uint64_t))(a4 + *((int *)v16 + 11)))(a1);
  a2(v12);
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, a6);
}

atomic_ullong *LazyMapSequence<>.map<A>(_:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7 = v6;
  uint64_t v28 = a1;
  uint64_t v29 = a2;
  uint64_t v30 = a6;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = *(void *)(v11 + 64);
  uint64_t v13 = MEMORY[0x1F4188790](a1);
  uint64_t v27 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void *)(v14 + 16);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v27 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))(v18, v7, v15);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))((char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0), v7, a3);
  uint64_t v19 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v20 = (v19 + 64) & ~v19;
  uint64_t v21 = (char *)swift_allocObject(qword_1EC9F2AC8, v20 + v12, v19 | 7);
  uint64_t v22 = *(void *)(a3 + 24);
  *((void *)v21 + 2) = v15;
  *((void *)v21 + 3) = v22;
  *((void *)v21 + 4) = a4;
  *((void *)v21 + 5) = a5;
  uint64_t v23 = v29;
  *((void *)v21 + 6) = v28;
  *((void *)v21 + 7) = v23;
  (*(void (**)(char *, char *, uint64_t))(v11 + 32))(&v21[v20], v27, a3);
  uint64_t v24 = v30;
  (*(void (**)(uint64_t, char *, uint64_t))(v16 + 32))(v30, v18, v15);
  uint64_t v25 = (uint64_t (**)(uint64_t))(v24
                                         + *((int *)type metadata accessor for LazyMapSequence(0, v15, a4, *(void *)(a5 + 8))+ 11));
  *uint64_t v25 = partial apply for closure #1 in LazyMapSequence<>.map<A>(_:);
  v25[1] = (uint64_t (*)(uint64_t))v21;
  return swift_retain(v23);
}

uint64_t closure #1 in LazyMapSequence<>.map<A>(_:)(uint64_t a1, void (*a2)(char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a6 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = type metadata accessor for LazyMapSequence(0, v14, v15, *(void *)(v13 + 8));
  (*(void (**)(uint64_t))(a4 + *((int *)v16 + 11)))(a1);
  a2(v12);
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, a6);
}

uint64_t static MemoryLayout.stride(ofValue:)(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a2 - 8) + 72);
}

uint64_t static MemoryLayout.alignment(ofValue:)(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 1;
}

uint64_t static MemoryLayout.offset(of:)()
{
  return AnyKeyPath._storedInlineOffset.getter();
}

uint64_t Unicode.Scalar._value.setter(uint64_t result)
{
  *Swift::Int v1 = result;
  return result;
}

uint64_t (*Unicode.Scalar._value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::UInt32 a1)
{
  BOOL v1 = HIWORD(a1) > 0x10u || a1 >> 11 == 27;
  unsigned __int8 v2 = v1;
  uint64_t v3 = a1;
  if (v1) {
    uint64_t v3 = 0;
  }
  return (Swift::Unicode::Scalar_optional)(v3 | ((unint64_t)v2 << 32));
}

BOOL static UInt32.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

BOOL static UInt32.> infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::UInt16 a1)
{
  if (a1 >> 11 == 27) {
    Swift::UInt16 v1 = 0;
  }
  else {
    Swift::UInt16 v1 = a1;
  }
  return (Swift::Unicode::Scalar_optional)(v1 | ((unint64_t)(a1 >> 11 == 27) << 32));
}

Swift::Unicode::Scalar __swiftcall Unicode.Scalar.init(_:)(Swift::UInt8 a1)
{
  *(_DWORD *)&a1 = a1;
  LOBYTE(result._value) = a1;
  return result;
}

Swift::String __swiftcall Unicode.Scalar.escaped(asASCII:)(Swift::Bool asASCII)
{
  unsigned int v2 = v1;
  Swift::String_optional v5 = Unicode.Scalar._escaped(asASCII:)(asASCII);
  object = v5.value._object;
  uint64_t countAndFlagsBits = v5.value._countAndFlagsBits;
  if (!v5.value._object) {
    uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v2);
  }
  result._object = object;
  result._uint64_t countAndFlagsBits = countAndFlagsBits;
  return result;
}

uint64_t lowNibbleAsHex #1 (_:) in Unicode.Scalar._escaped(asASCII:)(char a1)
{
  if ((a1 & 0xFu) >= 0xA) {
    unsigned int v1 = (a1 & 0xF) + 55;
  }
  else {
    unsigned int v1 = a1 & 0xF | 0x30;
  }
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v1);
}

uint64_t static UInt32.+ infix(_:_:)(int a1, int a2)
{
  BOOL v2 = __CFADD__(a1, a2);
  uint64_t result = (a1 + a2);
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t static UInt32.- infix(_:_:)(unsigned int a1, unsigned int a2)
{
  BOOL v2 = a1 >= a2;
  uint64_t result = a1 - a2;
  if (!v2) {
    __break(1u);
  }
  return result;
}

BOOL Unicode.Scalar.isASCII.getter(unsigned int a1)
{
  return a1 < 0x80;
}

uint64_t protocol witness for _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:) in conformance Unicode.Scalar@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

_DWORD *protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void Unicode.Scalar.debugDescription.getter(void *a1)
{
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(4);
  uint64_t v5 = v3;
  unint64_t object = v4;
  uint64_t v162 = v3;
  unint64_t v163 = v4;
  unint64_t v7 = HIBYTE(v4) & 0xF;
  uint64_t countAndFlagsBits = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000) != 0) {
    uint64_t v9 = HIBYTE(v4) & 0xF;
  }
  else {
    uint64_t v9 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v9 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v4);
    uint64_t v162 = 34;
    unint64_t v163 = 0xE100000000000000;
    goto LABEL_70;
  }
  if ((v4 & 0x2000000000000000) == 0 || v7 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((object & 0x1000000000000000) != 0) {
      goto LABEL_195;
    }
    BOOL v18 = __OFADD__(v9, 1);
    Swift::Int v19 = v9 + 1;
    if (!v18) {
      goto LABEL_18;
    }
LABEL_197:
    __break(1u);
    goto LABEL_198;
  }
  uint64_t v10 = 8 * (HIBYTE(v4) & 7);
  uint64_t v11 = (-255 << v10) - 1;
  uint64_t v12 = 34 << v10;
  unint64_t v13 = v12 | v11 & v4;
  uint64_t v14 = v12 | v11 & v3;
  if (v7 >= 8) {
    unint64_t v15 = v13;
  }
  else {
    unint64_t v15 = v4;
  }
  if (v7 < 8) {
    uint64_t v5 = v14;
  }
  swift_bridgeObjectRelease(v4);
  swift_bridgeObjectRelease(0xE100000000000000);
  unint64_t v16 = 0xA000000000000000;
  if (!(v5 & 0x8080808080808080 | v15 & 0x80808080808080)) {
    unint64_t v16 = 0xE000000000000000;
  }
  unint64_t v17 = (v16 & 0xFF00000000000000 | (v7 << 56) | v15 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
  while (2)
  {
    uint64_t v162 = v5;
    unint64_t v163 = v17;
    while (1)
    {
LABEL_70:
      Swift::String_optional v54 = Unicode.Scalar._escaped(asASCII:)(1);
      if (v54.value._object)
      {
        uint64_t countAndFlagsBits = v54.value._countAndFlagsBits;
        unint64_t object = (unint64_t)v54.value._object;
        a1 = 0;
      }
      else
      {
        unsigned int v55 = a1;
        a1 = 0;
        uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v55);
        unint64_t object = v56;
      }
      uint64_t v5 = v162;
      unint64_t v1 = v163;
      unint64_t v57 = HIBYTE(v163) & 0xF;
      if ((v163 & 0x2000000000000000) != 0) {
        unint64_t v58 = HIBYTE(v163) & 0xF;
      }
      else {
        unint64_t v58 = v162 & 0xFFFFFFFFFFFFLL;
      }
      if (!v58 && (v162 & ~v163 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v163);
        uint64_t v162 = countAndFlagsBits;
        unint64_t v163 = object;
        goto LABEL_160;
      }
      uint64_t v59 = object & 0x2000000000000000;
      unint64_t v7 = HIBYTE(object) & 0xF;
      if ((v163 & 0x2000000000000000) != 0 && v59)
      {
        unint64_t v75 = v57 + v7;
        if (v57 + v7 <= 0xF)
        {
          if (v7)
          {
            char v76 = 0;
            unint64_t v77 = 0;
            unint64_t v78 = v163;
            do
            {
              unint64_t v79 = v57 + v77;
              unint64_t v80 = v77 + 1;
              if (v77 >= 8) {
                unint64_t v81 = object;
              }
              else {
                unint64_t v81 = countAndFlagsBits;
              }
              unint64_t v82 = v81 >> (v76 & 0x38);
              char v83 = (8 * v57 + v76) & 0x38;
              uint64_t v84 = (-255 << v83) - 1;
              unint64_t v85 = (unint64_t)v82 << v83;
              unint64_t v86 = v85 | v84 & v78;
              unint64_t v87 = v85 | v84 & v5;
              if (v79 < 8) {
                uint64_t v5 = v87;
              }
              else {
                unint64_t v78 = v86;
              }
              v76 += 8;
              unint64_t v77 = v80;
            }
            while (v7 != v80);
          }
          else
          {
            unint64_t v78 = v163;
          }
          swift_bridgeObjectRelease(v163);
          swift_bridgeObjectRelease(object);
          unint64_t v114 = 0xA000000000000000;
          if (!(v5 & 0x8080808080808080 | v78 & 0x80808080808080)) {
            unint64_t v114 = 0xE000000000000000;
          }
          uint64_t v162 = v5;
          unint64_t v163 = v114 & 0xFF00000000000000 | (v75 << 56) | v78 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_160;
        }
        uint64_t v59 = 1;
      }
      a1 = (void *)(countAndFlagsBits & 0xFFFFFFFFFFFFLL);
      uint64_t v60 = v59 ? HIBYTE(object) & 0xF : countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      swift_bridgeObjectRetain_n(object, 2);
      if ((object & 0x1000000000000000) != 0) {
        break;
      }
      swift_bridgeObjectRetain_n(object, 4);
      Swift::Int v61 = v60;
      if ((v1 & 0x1000000000000000) != 0) {
        goto LABEL_192;
      }
LABEL_85:
      BOOL v18 = __OFADD__(v58, v61);
      Swift::Int v62 = v58 + v61;
      if (!v18) {
        goto LABEL_86;
      }
LABEL_194:
      __break(1u);
LABEL_195:
      Swift::Int v141 = String.UTF8View._foreignCount()();
      Swift::Int v19 = v141 + 1;
      if (__OFADD__(v141, 1)) {
        goto LABEL_197;
      }
LABEL_18:
      unint64_t v7 = v5 & ~object;
      if ((v7 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v5, object);
        if (v21) {
          goto LABEL_222;
        }
        if (v19 <= 15)
        {
          if ((object & 0x2000000000000000) != 0) {
            goto LABEL_51;
          }
          if (v20 <= 0) {
            goto LABEL_46;
          }
        }
      }
      else if (v19 <= 15)
      {
        if ((object & 0x2000000000000000) != 0)
        {
LABEL_51:
          swift_bridgeObjectRelease_n(0xE100000000000000, 5);
          uint64_t countAndFlagsBits = object;
        }
        else
        {
LABEL_46:
          swift_bridgeObjectRelease_n(0xE100000000000000, 5);
          if ((object & 0x1000000000000000) != 0) {
            goto LABEL_217;
          }
          if ((v5 & 0x1000000000000000) != 0)
          {
            uint64_t v32 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            uint64_t v32 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, object);
            uint64_t countAndFlagsBits = v151;
          }
          swift_bridgeObjectRetain(object);
          closure #1 in _StringGuts._convertedToSmall()(v32, countAndFlagsBits, v161);
          swift_bridgeObjectRelease(object);
          uint64_t countAndFlagsBits = *((void *)&v161[0] + 1);
          uint64_t v5 = *(void *)&v161[0];
        }
LABEL_52:
        v33._unint64_t rawBits = 1;
        v34._unint64_t rawBits = 65537;
        v35._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v33, v34, 0x22uLL, 0xE100000000000000);
        if (v35._rawBits < 0x10000) {
          v35._rawBits |= 3;
        }
        unint64_t v7 = specialized String.init(_:)(v35, v36, 0x22uLL, 0xE100000000000000);
        unint64_t v38 = v37;
        swift_bridgeObjectRelease(0xE100000000000000);
        if ((v38 & 0x2000000000000000) == 0) {
          goto LABEL_212;
        }
        swift_bridgeObjectRelease(v38);
        goto LABEL_56;
      }
      int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v5, object);
      BOOL v25 = (v23 & 1) == 0 && v22 > 0;
      if ((v7 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        if (!v25)
        {
LABEL_37:
          uint64_t v26 = _StringGuts.nativeCapacity.getter(v5, object);
          if (v27) {
            uint64_t v28 = 0;
          }
          else {
            uint64_t v28 = v26;
          }
          if (v28 + 0x4000000000000000 < 0)
          {
            __break(1u);
LABEL_217:
            uint64_t v5 = _StringGuts._foreignConvertedToSmall()(v5, object);
            uint64_t countAndFlagsBits = v150;
            goto LABEL_52;
          }
          uint64_t v29 = 2 * v28;
          if (v29 > v19) {
            Swift::Int v19 = v29;
          }
        }
        _StringGuts.grow(_:)(v19);
        goto LABEL_44;
      }
      if (!v25) {
        goto LABEL_37;
      }
LABEL_44:
      swift_bridgeObjectRelease_n(0xE100000000000000, 6);
      v161[0] = xmmword_18162AD70;
      uint64_t v30 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)v161, 1);
      _StringGuts.appendInPlace(_:isASCII:)(v30, v31, 1);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
    swift_bridgeObjectRetain_n(object, 5);
    v136._unint64_t rawBits = 1;
    v137._unint64_t rawBits = (v60 << 16) | 1;
    v138._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v136, v137, countAndFlagsBits, object);
    if (v138._rawBits < 0x10000) {
      v138._rawBits |= 3;
    }
    Swift::Int v61 = specialized Collection.count.getter(v138, v139, countAndFlagsBits, object);
    swift_bridgeObjectRelease(object);
    if ((v1 & 0x1000000000000000) == 0) {
      goto LABEL_85;
    }
LABEL_192:
    Swift::Int v140 = String.UTF8View._foreignCount()();
    Swift::Int v62 = v140 + v61;
    if (__OFADD__(v140, v61)) {
      goto LABEL_194;
    }
LABEL_86:
    uint64_t v160 = v60;
    if ((v5 & ~v1 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v1 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v38 = v162;
      uint64_t v5 = v163;
      int64_t v63 = _StringGuts.nativeUnusedCapacity.getter(v162, v163);
      if ((v64 & 1) == 0)
      {
        if (v62 <= 15)
        {
          if ((v5 & 0x2000000000000000) != 0)
          {
            int v74 = 0;
            unint64_t v1 = v5;
            goto LABEL_138;
          }
          unint64_t v1 = v5;
          if (v63 < v61)
          {
LABEL_118:
            int v74 = 1;
            goto LABEL_138;
          }
        }
LABEL_95:
        int64_t v65 = _StringGuts.nativeUnusedCapacity.getter(v38, v5);
        unint64_t v1 = (v66 & 1) == 0 && v65 >= v61;
        if ((v38 & ~v5 & 0x2000000000000000) == 0
          || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
        {
          if ((v1 & 1) == 0) {
            goto LABEL_106;
          }
LABEL_112:
          _StringGuts.grow(_:)(v62);
          goto LABEL_113;
        }
        if (v1)
        {
LABEL_113:
          swift_bridgeObjectRelease_n(object, 4);
          if ((object & 0x1000000000000000) != 0)
          {
            swift_bridgeObjectRelease(object);
            _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, object, 0, v160);
            swift_bridgeObjectRelease_n(object, 2);
            a1 = 0;
          }
          else if (v59)
          {
            swift_bridgeObjectRelease_n(object, 2);
            *(void *)&v161[0] = countAndFlagsBits;
            *((void *)&v161[0] + 1) = object & 0xFFFFFFFFFFFFFFLL;
            Swift::String::Index v72 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(object) & 0xF, (uint64_t)v161, HIBYTE(object) & 0xF);
            _StringGuts.appendInPlace(_:isASCII:)(v72, v73, (object & 0x4000000000000000) != 0);
            a1 = 0;
            swift_bridgeObjectRelease(object);
          }
          else
          {
            if ((countAndFlagsBits & 0x1000000000000000) != 0)
            {
              swift_bridgeObjectRelease(object);
              id v88 = (id)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v89 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              id v88 = _StringObject.sharedUTF8.getter(countAndFlagsBits, object);
              uint64_t v89 = v152;
              swift_bridgeObjectRelease(object);
              if (v89 < (uint64_t)a1) {
                _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
              }
            }
            unint64_t v90 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, countAndFlagsBits & 0xFFFFFFFFFFFFLL, (uint64_t)v88, v89);
            _StringGuts.appendInPlace(_:isASCII:)(v90, v91, countAndFlagsBits < 0);
            a1 = 0;
            swift_bridgeObjectRelease_n(object, 2);
          }
          goto LABEL_160;
        }
LABEL_106:
        uint64_t v68 = _StringGuts.nativeCapacity.getter(v38, v5);
        if (v69) {
          uint64_t v70 = 0;
        }
        else {
          uint64_t v70 = v68;
        }
        if (v70 + 0x4000000000000000 >= 0)
        {
          uint64_t v71 = 2 * v70;
          if (v71 > v62) {
            Swift::Int v62 = v71;
          }
          goto LABEL_112;
        }
        __break(1u);
LABEL_212:
        uint64_t v147 = v5;
        if ((v38 & 0x1000000000000000) != 0)
        {
          unint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v38);
          unint64_t v159 = v158;
          swift_bridgeObjectRelease(v38);
          unint64_t v38 = v159;
          uint64_t v5 = v147;
        }
        else
        {
          if ((v7 & 0x1000000000000000) != 0)
          {
            char v148 = (unsigned __int8 *)((v38 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v149 = v7 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            char v148 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v38);
          }
          closure #1 in _StringGuts._convertedToSmall()(v148, v149, v161);
          swift_bridgeObjectRelease(v38);
          unint64_t v38 = *((void *)&v161[0] + 1);
          unint64_t v7 = *(void *)&v161[0];
        }
LABEL_56:
        uint64_t v39 = HIBYTE(countAndFlagsBits) & 0xF;
        uint64_t v40 = HIBYTE(v38) & 0xF;
        uint64_t v41 = v40 + v39;
        if ((unint64_t)(v40 + v39) > 0xF) {
          goto LABEL_221;
        }
        if (v40)
        {
          char v42 = 0;
          unint64_t v43 = 0;
          do
          {
            unint64_t v44 = v39 + v43;
            unint64_t v45 = v43 + 1;
            if (v43 >= 8) {
              unint64_t v46 = v38;
            }
            else {
              unint64_t v46 = v7;
            }
            unint64_t v47 = v46 >> (v42 & 0x38);
            char v48 = (8 * v39 + v42) & 0x38;
            uint64_t v49 = (-255 << v48) - 1;
            unint64_t v50 = (unint64_t)v47 << v48;
            unint64_t v51 = v50 | v49 & countAndFlagsBits;
            unint64_t v52 = v50 | v49 & v5;
            if (v44 < 8) {
              uint64_t v5 = v52;
            }
            else {
              uint64_t countAndFlagsBits = v51;
            }
            v42 += 8;
            unint64_t v43 = v45;
          }
          while (v40 != v45);
        }
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease(0xE100000000000000);
        unint64_t v53 = 0xA000000000000000;
        if (!(v5 & 0x8080808080808080 | countAndFlagsBits & 0x80808080808080)) {
          unint64_t v53 = 0xE000000000000000;
        }
        unint64_t v17 = v53 & 0xFF00000000000000 | (v41 << 56) | countAndFlagsBits & 0xFFFFFFFFFFFFFFLL;
        continue;
      }
LABEL_222:
      unint64_t v153 = 258;
      goto LABEL_223;
    }
    break;
  }
  if (v62 >= 16)
  {
    unint64_t v38 = v162;
    uint64_t v5 = v163;
    goto LABEL_95;
  }
  unint64_t v1 = v163;
  if ((v163 & 0x2000000000000000) == 0)
  {
    uint64_t v5 = v163;
    goto LABEL_118;
  }
  int v74 = 0;
  uint64_t v5 = v163;
LABEL_138:
  a1 = 0;
  swift_bridgeObjectRelease_n(object, 5);
  unint64_t v7 = v162;
  if (v74) {
    goto LABEL_201;
  }
  while (2)
  {
    v92._unint64_t rawBits = (v160 << 16) | 1;
    v93._unint64_t rawBits = 1;
    v94._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v93, v92, countAndFlagsBits, object);
    if (v94._rawBits < 0x10000) {
      v94._rawBits |= 3;
    }
    unint64_t v96 = specialized String.init(_:)(v94, v95, countAndFlagsBits, object);
    unint64_t v98 = v97;
    swift_bridgeObjectRelease(object);
    if ((v98 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v98);
    }
    else if ((v98 & 0x1000000000000000) != 0)
    {
      unint64_t v96 = _StringGuts._foreignConvertedToSmall()(v96, v98);
      unint64_t v156 = v155;
      swift_bridgeObjectRelease(v98);
      unint64_t v98 = v156;
    }
    else
    {
      if ((v96 & 0x1000000000000000) != 0)
      {
        Swift::String::Index v145 = (unsigned __int8 *)((v98 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v146 = v96 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        Swift::String::Index v145 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v96, v98);
      }
      closure #1 in _StringGuts._convertedToSmall()(v145, v146, v161);
      if (a1) {
        goto LABEL_230;
      }
      swift_bridgeObjectRelease(v98);
      unint64_t v98 = *((void *)&v161[0] + 1);
      unint64_t v96 = *(void *)&v161[0];
    }
    uint64_t v99 = HIBYTE(v1) & 0xF;
    uint64_t v100 = HIBYTE(v98) & 0xF;
    uint64_t v101 = v100 + v99;
    if ((unint64_t)(v100 + v99) > 0xF) {
      goto LABEL_221;
    }
    if (v100)
    {
      char v102 = 0;
      unint64_t v103 = 0;
      do
      {
        unint64_t v104 = v99 + v103;
        unint64_t v105 = v103 + 1;
        if (v103 >= 8) {
          unint64_t v106 = v98;
        }
        else {
          unint64_t v106 = v96;
        }
        unint64_t v107 = v106 >> (v102 & 0x38);
        char v108 = (8 * v99 + v102) & 0x38;
        uint64_t v109 = (-255 << v108) - 1;
        unint64_t v110 = (unint64_t)v107 << v108;
        unint64_t v111 = v110 | v109 & v1;
        unint64_t v112 = v110 | v109 & v7;
        if (v104 < 8) {
          unint64_t v7 = v112;
        }
        else {
          unint64_t v1 = v111;
        }
        v102 += 8;
        unint64_t v103 = v105;
      }
      while (v100 != v105);
    }
    swift_bridgeObjectRelease(v5);
    swift_bridgeObjectRelease(object);
    unint64_t v113 = 0xA000000000000000;
    if (!(v7 & 0x8080808080808080 | v1 & 0x80808080808080)) {
      unint64_t v113 = 0xE000000000000000;
    }
    uint64_t v162 = v7;
    unint64_t v163 = v113 & 0xFF00000000000000 | (v101 << 56) | v1 & 0xFFFFFFFFFFFFFFLL;
LABEL_160:
    uint64_t v5 = v162;
    unint64_t object = v163;
    if ((v163 & 0x2000000000000000) != 0) {
      unint64_t v115 = HIBYTE(v163) & 0xF;
    }
    else {
      unint64_t v115 = v162 & 0xFFFFFFFFFFFFLL;
    }
    if (!v115 && (v162 & ~v163 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v163);
      return;
    }
    if ((v163 & 0x2000000000000000) != 0 && (HIBYTE(v163) & 0xF) != 0xF)
    {
      swift_bridgeObjectRelease(v163);
      swift_bridgeObjectRelease(0xE100000000000000);
      return;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((object & 0x1000000000000000) == 0)
    {
      uint64_t countAndFlagsBits = v115 + 1;
      if (!__OFADD__(v115, 1)) {
        goto LABEL_170;
      }
LABEL_200:
      __break(1u);
LABEL_201:
      if ((v1 & 0x1000000000000000) != 0)
      {
        unint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v5);
        unint64_t v1 = v154;
      }
      else
      {
        if ((v7 & 0x1000000000000000) != 0)
        {
          int64_t v143 = (unsigned __int8 *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v144 = v7 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          int64_t v143 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v5);
          uint64_t v144 = v157;
        }
        swift_bridgeObjectRetain(v5);
        closure #1 in _StringGuts._convertedToSmall()(v143, v144, v161);
        if (a1) {
          goto LABEL_230;
        }
        swift_bridgeObjectRelease(v5);
        unint64_t v1 = *((void *)&v161[0] + 1);
        unint64_t v7 = *(void *)&v161[0];
      }
      continue;
    }
    break;
  }
LABEL_198:
  Swift::Int v142 = String.UTF8View._foreignCount()();
  uint64_t countAndFlagsBits = v142 + 1;
  if (__OFADD__(v142, 1)) {
    goto LABEL_200;
  }
LABEL_170:
  if ((v5 & ~object & 0x2000000000000000) == 0
    || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if (countAndFlagsBits <= 15) {
      goto LABEL_181;
    }
    goto LABEL_186;
  }
  int64_t v116 = _StringGuts.nativeUnusedCapacity.getter(v5, object);
  if (v117) {
    goto LABEL_222;
  }
  BOOL v119 = (object & 0x2000000000000000) == 0 && v116 > 0;
  if (countAndFlagsBits <= 15 && !v119)
  {
LABEL_181:
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    swift_bridgeObjectRetain(object);
    unint64_t v120 = _StringGuts._convertedToSmall()(v5, object);
    unint64_t v122 = v121;
    swift_bridgeObjectRelease(object);
    v123._unint64_t rawBits = 1;
    v124._unint64_t rawBits = 65537;
    v125._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v123, v124, 0x22uLL, 0xE100000000000000);
    if (v125._rawBits < 0x10000) {
      v125._rawBits |= 3;
    }
    unint64_t v127 = specialized String.init(_:)(v125, v126, 0x22uLL, 0xE100000000000000);
    unint64_t v129 = v128;
    swift_bridgeObjectRelease(0xE100000000000000);
    unint64_t v130 = _StringGuts._convertedToSmall()(v127, v129);
    unint64_t v132 = v131;
    swift_bridgeObjectRelease(v129);
    specialized _SmallString.init(_:appending:)(v120, v122, v130, v132);
    if ((v133 & 1) == 0)
    {
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE100000000000000);
      return;
    }
LABEL_221:
    unint64_t v153 = 266;
LABEL_223:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v153, 0);
  }
LABEL_186:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(countAndFlagsBits, 1);
  swift_bridgeObjectRelease_n(0xE100000000000000, 6);
  v161[0] = xmmword_18162AD70;
  unint64_t v134 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)v161, 1);
  _StringGuts.appendInPlace(_:isASCII:)(v134, v135, 1);
  if (a1)
  {
LABEL_230:
    swift_errorRelease(a1);
    __break(1u);
    swift_errorRelease(a1);
    swift_bridgeObjectRelease(object);
    __break(1u);
  }
  else
  {
    swift_bridgeObjectRelease(0xE100000000000000);
  }
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Unicode.Scalar()
{
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(*v0);
}

void protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Unicode.Scalar()
{
  Unicode.Scalar.debugDescription.getter((void *)*v0);
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::String a1)
{
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v3 = specialized Collection.first.getter(a1._countAndFlagsBits, (unint64_t)a1._object);
  if ((v3 & 0x100000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)object);
    goto LABEL_5;
  }
  unsigned int v4 = v3;
  Swift::UInt64 rawBits = specialized Collection.count.getter(countAndFlagsBits, (unint64_t)object)._rawBits;
  swift_bridgeObjectRelease((uint64_t)object);
  if (rawBits != 1)
  {
LABEL_5:
    unsigned int v4 = 0;
    unsigned __int8 v6 = 1;
    return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v6 << 32));
  }
  unsigned __int8 v6 = 0;
  return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v6 << 32));
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Unicode.Scalar(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = specialized Collection.first.getter(a1, a2);
  if ((v6 & 0x100000000) != 0)
  {
    swift_bridgeObjectRelease(a2);
    goto LABEL_5;
  }
  int v7 = v6;
  Swift::UInt64 rawBits = specialized Collection.count.getter(a1, a2)._rawBits;
  swift_bridgeObjectRelease(a2);
  if (rawBits != 1)
  {
LABEL_5:
    int v7 = 0;
    char v9 = 1;
    goto LABEL_6;
  }
  char v9 = 0;
LABEL_6:
  *(_DWORD *)a3 = v7;
  *(unsigned char *)(a3 + 4) = v9;
}

void Unicode.Scalar.hash(into:)(int a1, Swift::UInt32 a2)
{
}

Swift::Int Unicode.Scalar.hashValue.getter()
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Unicode.Scalar()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Unicode.Scalar()
{
  Hasher._combine(_:)(*v0);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Unicode.Scalar()
{
  return Hasher._finalize()();
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::Int a1)
{
  unint64_t v1 = HIDWORD(a1);
  unsigned int v2 = a1 - 57344;
  if (WORD1(a1) <= 0x10u) {
    Swift::Int v3 = a1;
  }
  else {
    Swift::Int v3 = 0;
  }
  char v4 = (a1 != 55295) & __CFADD__(v2, 2049);
  if (v2 <= 0xFFFFF7FF) {
    Swift::Int v5 = v3;
  }
  else {
    Swift::Int v5 = 0;
  }
  if (v4) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = WORD1(a1) > 0x10u;
  }
  BOOL v7 = v1 == 0;
  if (v1) {
    Swift::Int v8 = 0;
  }
  else {
    Swift::Int v8 = v5;
  }
  unsigned __int8 v9 = !v7 || v6;
  return (Swift::Unicode::Scalar_optional)(v8 | ((unint64_t)v9 << 32));
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Unicode::Scalar a1)
{
  *(void *)&a1._Swift::UInt32 value = a1._value;
  LODWORD(result) = a1;
  return result;
}

BOOL static Unicode.Scalar.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Unicode.Scalar(_DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

uint64_t Unicode.Scalar.UTF16View.value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Unicode.Scalar.UTF16View.value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.Scalar.UTF16View.startIndex.getter()
{
  return 0;
}

uint64_t Unicode.Scalar.UTF16View.endIndex.getter(unsigned int a1)
{
  if (HIWORD(a1)) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t static Unicode.UTF16.width(_:)(unsigned int a1)
{
  if (HIWORD(a1)) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t Unicode.Scalar.UTF16View.subscript.getter(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = WORD1(a2);
  if (a1 == 1)
  {
    if (v2) {
      return a2 & 0x3FF | 0xFFFFDC00;
    }
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UTF16.swift", 17, 2, 0x5BuLL, 0);
  }
  if (!v2) {
    return a2;
  }
  uint64_t result = (unsigned __int16)((a2 + 67043328) >> 10) + 55296;
  if ((result & 0x10000) != 0)
  {
    __break(1u);
    goto LABEL_9;
  }
  return result;
}

uint64_t static Unicode.UTF16.trailSurrogate(_:)(unsigned int a1)
{
  if (!HIWORD(a1)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UTF16.swift", 17, 2, 0x5BuLL, 0);
  }
  return a1 & 0x3FF | 0xFFFFDC00;
}

uint64_t static Unicode.UTF16.leadSurrogate(_:)(unsigned int a1)
{
  if (!HIWORD(a1)) {
LABEL_4:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UTF16.swift", 17, 2, 0x43uLL, 0);
  uint64_t result = (unsigned __int16)((a1 + 67043328) >> 10) + 55296;
  if ((result & 0x10000) != 0)
  {
    __break(1u);
    goto LABEL_4;
  }
  return result;
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View(a1, a2, a3, (uint64_t (*)(void, void, uint64_t))specialized RandomAccessCollection<>.distance(from:to:), (uint64_t (*)(uint64_t, uint64_t, uint64_t))specialized RandomAccessCollection<>.index(_:offsetBy:), a4);
}

unint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Unicode.Scalar.UTF16View@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t *protocol witness for BidirectionalCollection.formIndex(before:) in conformance Unicode.Scalar.UTF16View(unint64_t *result)
{
  unint64_t v2 = *result - 1;
  if (__OFSUB__(*result, 1))
  {
    __break(1u);
  }
  else
  {
    if (*(_WORD *)(v1 + 2))
    {
      if (v2 >= 2) {
        goto LABEL_4;
      }
    }
    else if (*result != 1)
    {
LABEL_4:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
    }
    *unint64_t result = v2;
  }
  return result;
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Unicode.Scalar.UTF16View@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Unicode.Scalar.UTF16View(uint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2);
}

void protocol witness for Collection.endIndex.getter in conformance Unicode.Scalar.UTF16View(uint64_t *a1@<X8>)
{
  uint64_t v2 = 1;
  if (*(_WORD *)(v1 + 2)) {
    uint64_t v2 = 2;
  }
  *a1 = v2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Unicode.Scalar.UTF16View(_WORD *a1, uint64_t *a2))()
{
  *a1 = Unicode.Scalar.UTF16View.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

uint64_t protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View(a1, (uint64_t (*)(void, void, void))specialized Collection<>.subscript.getter, a2);
}

void protocol witness for Collection.indices.getter in conformance Unicode.Scalar.UTF16View(void *a1@<X8>)
{
  uint64_t v2 = 1;
  if (*(_WORD *)(v1 + 2)) {
    uint64_t v2 = 2;
  }
  *a1 = 0;
  a1[1] = v2;
}

unint64_t protocol witness for Collection.index(after:) in conformance Unicode.Scalar.UTF16View@<X0>(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t *protocol witness for Collection.formIndex(after:) in conformance Unicode.Scalar.UTF16View(unint64_t *result)
{
  unint64_t v2 = *result;
  if (*(_WORD *)(v1 + 2))
  {
    if (v2 >= 2) {
      goto LABEL_3;
    }
  }
  else if (v2)
  {
LABEL_3:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  *unint64_t result = v2 + 1;
  return result;
}

unint64_t protocol witness for Sequence.underestimatedCount.getter in conformance Unicode.Scalar.UTF16View()
{
  if (HIWORD(*v0)) {
    unint64_t v1 = 2;
  }
  else {
    unint64_t v1 = 1;
  }
  return specialized RandomAccessCollection<>.distance(from:to:)(0, v1, *v0);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance Unicode.Scalar.UTF16View()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode.Scalar.UTF16View(uint64_t a1, _WORD *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t Unicode.Scalar.UTF8View.value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Unicode.Scalar.UTF8View.value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.Scalar.UTF8View.startIndex.getter()
{
  return 0;
}

uint64_t Unicode.Scalar.UTF8View.endIndex.getter(unsigned int a1)
{
  uint64_t v1 = 2;
  uint64_t v2 = 3;
  if (a1 >= 0x10000) {
    uint64_t v2 = 4;
  }
  if (a1 > 0x7FF) {
    uint64_t v1 = v2;
  }
  if (a1 >= 0x80) {
    return v1;
  }
  else {
    return 1;
  }
}

uint64_t Unicode.Scalar.UTF8View.subscript.getter(unint64_t a1, unsigned int a2)
{
  if ((a1 & 0x8000000000000000) != 0) {
    goto LABEL_7;
  }
  if (a2 > 0x7F)
  {
    if (a2 > 0x7FF)
    {
      if (HIWORD(a2))
      {
        if (a1 < 4) {
          return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
        }
      }
      else if (a1 < 3)
      {
        return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
      }
    }
    else if (a1 < 2)
    {
      return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
    }
LABEL_7:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unicode.Scalar.UTF8View index is out of bounds", 46, 2, "Swift/UnicodeScalar.swift", 25, 2, 0x1E9uLL, 0);
  }
  if (a1) {
    goto LABEL_7;
  }
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
}

uint64_t _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n(unsigned int a1, uint64_t (*a2)(uint64_t *))
{
  if (a1 >= 0x80)
  {
    int v4 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
      int v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v2 = (v5 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v2 = v6;
      }
    }
    else
    {
      unsigned int v2 = (v4 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v2 = a1 + 1;
  }
  uint64_t v7 = (v2 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * (4 - (__clz(v2) >> 3))));
  return a2(&v7);
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(uint64_t result, unint64_t *a2)
{
  uint64_t v2 = 0;
  int v3 = (result & 0x3F) << 8;
  unsigned int v4 = (v3 | (result >> 6)) + 33217;
  unsigned int v5 = (v3 | (result >> 6) & 0x3F) << 8;
  unsigned int v6 = (((v5 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
  unsigned int v7 = (v5 | (result >> 12)) + 8487393;
  if (WORD1(result)) {
    unsigned int v7 = v6;
  }
  if (result >= 0x800) {
    unsigned int v4 = v7;
  }
  if (result < 0x80) {
    unsigned int v8 = result + 1;
  }
  else {
    unsigned int v8 = v4;
  }
  uint64_t v9 = 4 - (__clz(v8) >> 3);
  uint64_t v24 = (v8 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * v9));
  unint64_t v10 = *a2;
  do
  {
    uint64_t v21 = *((unsigned __int8 *)&v24 + v2);
    uint64_t v22 = HIBYTE(v10) & 7;
    char v23 = 8 * v22;
    if (v22 == 7)
    {
      unint64_t v11 = v10 & 0xFF00000000000000;
      uint64_t v12 = (v21 << v23) | v10 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v13 = a2[4] ^ v12;
      unint64_t v14 = a2[2];
      unint64_t v15 = v14 + a2[1];
      uint64_t v16 = v15 ^ __ROR8__(v14, 51);
      uint64_t v17 = a2[3] + v13;
      uint64_t v18 = v17 ^ __ROR8__(v13, 48);
      uint64_t v19 = v18 + __ROR8__(v15, 32);
      uint64_t v20 = v17 + v16;
      a2[3] = __ROR8__(v20, 32);
      a2[4] = v19 ^ __ROR8__(v18, 43);
      a2[1] = v19 ^ v12;
      a2[2] = v20 ^ __ROR8__(v16, 47);
    }
    else
    {
      unint64_t v11 = (v21 << v23) | v10;
    }
    ++v2;
    unint64_t v10 = v11 + 0x100000000000000;
  }
  while (v9 != v2);
  *a2 = v10;
  return result;
}

__objc2_class **specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1, uint64_t *a2)
{
  if (a1 >= 0x80)
  {
    int v7 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v8 = (v7 | (a1 >> 6) & 0x3F) << 8;
      int v9 = (((v8 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v4 = (v8 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v4 = v9;
      }
    }
    else
    {
      unsigned int v4 = (v7 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v4 = a1 + 1;
  }
  v11[1] = v2;
  v11[2] = v3;
  unsigned int v5 = __clz(v4);
  uint64_t v10 = 4 - (v5 >> 3);
  v11[0] = (__objc2_class *)((v4 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * (4 - (v5 >> 3)))));
  return specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v11, &v10, a2);
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 >= 0x80)
  {
    int v8 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v9 = (v8 | (a1 >> 6) & 0x3F) << 8;
      int v10 = (((v9 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v4 = (v9 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v4 = v10;
      }
    }
    else
    {
      unsigned int v4 = (v8 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v4 = a1 + 1;
  }
  unsigned int v5 = __clz(v4);
  uint64_t v11 = (v4 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (32 - (v5 & 0x18)));
  uint64_t result = a2();
  if (!v2)
  {
    unsigned int v7 = v5 >> 3;
    if (v7 != 3)
    {
      uint64_t result = ((uint64_t (*)(void))a2)(BYTE1(v11));
      if (v7 != 2)
      {
        uint64_t result = ((uint64_t (*)(void))a2)(BYTE2(v11));
        if (v7 != 1) {
          return ((uint64_t (*)(void))a2)(BYTE3(v11));
        }
      }
    }
  }
  return result;
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1)
{
  if (a1 >= 0x80)
  {
    int v4 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
      int v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v1 = (v5 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v1 = v6;
      }
    }
    else
    {
      unsigned int v1 = (v4 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v1 = a1 + 1;
  }
  unsigned int v2 = __clz(v1);
  var8.i64[0] = (v1 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * (4 - (v2 >> 3))));
  return specialized static String._uncheckedFromUTF8(_:)(&var8, 4 - (v2 >> 3));
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1, unint64_t a2)
{
  if (a1 >= 0x80)
  {
    int v5 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v6 = (v5 | (a1 >> 6) & 0x3F) << 8;
      int v7 = (((v6 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v2 = (v6 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v2 = v7;
      }
    }
    else
    {
      unsigned int v2 = (v5 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v2 = a1 + 1;
  }
  unint64_t v3 = 4 - (__clz(v2) >> 3);
  uint64_t v8 = (v2 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * v3));
  if ((a2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
  }
  if (v3 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  return *((unsigned __int8 *)&v8 + a2);
}

uint64_t Unicode.Scalar.withUTF8CodeUnits<A>(_:)(uint64_t (*a1)(uint64_t *), uint64_t a2, unsigned int a3)
{
  if (a3 >= 0x80)
  {
    int v5 = (a3 & 0x3F) << 8;
    if (a3 >= 0x800)
    {
      int v6 = (v5 | (a3 >> 6) & 0x3F) << 8;
      int v7 = (((v6 | (a3 >> 12) & 0x3F) << 8) | (a3 >> 18)) - 2122219023;
      unsigned int v3 = (v6 | (a3 >> 12)) + 8487393;
      if (HIWORD(a3)) {
        unsigned int v3 = v7;
      }
    }
    else
    {
      unsigned int v3 = (v5 | (a3 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v3 = a3 + 1;
  }
  uint64_t v8 = (v3 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * (4 - (__clz(v3) >> 3))));
  return a1(&v8);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF8View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View(a1, a2, a3, (uint64_t (*)(void, void, uint64_t))specialized RandomAccessCollection<>.distance(from:to:), (uint64_t (*)(uint64_t, uint64_t, uint64_t))specialized RandomAccessCollection<>.index(_:offsetBy:), a4);
}

unint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Unicode.Scalar.UTF8View@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance Unicode.Scalar.UTF8View(uint64_t *a1)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v1);
  *a1 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Unicode.Scalar.UTF8View@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Unicode.Scalar.UTF8View(unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2);
}

void protocol witness for Collection.endIndex.getter in conformance Unicode.Scalar.UTF8View(uint64_t *a1@<X8>)
{
  unsigned int v2 = *v1;
  uint64_t v3 = 2;
  uint64_t v4 = 3;
  if (*v1 >= 0x10000) {
    uint64_t v4 = 4;
  }
  if (v2 > 0x7FF) {
    uint64_t v3 = v4;
  }
  if (v2 >= 0x80) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = 1;
  }
  *a1 = v5;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Unicode.Scalar.UTF8View(unsigned char *a1, unint64_t *a2))()
{
  *a1 = Unicode.Scalar.UTF8View.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

uint64_t protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF8View@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View(a1, (uint64_t (*)(void, void, void))specialized Collection<>.subscript.getter, a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View@<X0>(void *a1@<X0>, uint64_t (*a2)(void, void, void)@<X3>, uint64_t a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], *v3);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 16) = v7;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance Unicode.Scalar.UTF8View@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.indices.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, void, uint64_t)@<X5>, uint64_t (*a5)(uint64_t, uint64_t, uint64_t)@<X6>, uint64_t a6@<X8>)
{
  uint64_t v10 = *a1;
  uint64_t v11 = *v6;
  uint64_t v12 = a4(*a1, *a3, v11);
  if (a2 < 1)
  {
    if (v12 <= 0 && v12 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    uint64_t result = a5(v10, a2, v11);
    char v14 = 0;
    goto LABEL_11;
  }
  if (v12 < 0 || v12 >= (unint64_t)a2) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t result = 0;
  char v14 = 1;
LABEL_11:
  *(void *)a6 = result;
  *(unsigned char *)(a6 + 8) = v14;
  return result;
}

unint64_t protocol witness for Collection.index(after:) in conformance Unicode.Scalar.UTF8View@<X0>(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t protocol witness for Collection.formIndex(after:) in conformance Unicode.Scalar.UTF8View(unint64_t *a1)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v1);
  *a1 = result;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Unicode.Scalar.UTF8View(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = *v1;
  *(void *)(a1 + 8) = 0;
}

unint64_t protocol witness for Collection.count.getter in conformance Unicode.Scalar.UTF8View()
{
  unsigned int v1 = *v0;
  uint64_t v2 = 2;
  uint64_t v3 = 3;
  if (*v0 >= 0x10000) {
    uint64_t v3 = 4;
  }
  if (v1 > 0x7FF) {
    uint64_t v2 = v3;
  }
  if (v1 >= 0x80) {
    unint64_t v4 = v2;
  }
  else {
    unint64_t v4 = 1;
  }
  return specialized RandomAccessCollection<>.distance(from:to:)(0, v4, v1);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance Unicode.Scalar.UTF8View()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode.Scalar.UTF8View(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t static Unicode.UTF32._replacementCodeUnit.getter()
{
  return 65533;
}

uint64_t static Unicode.UTF8.encode(_:)(unsigned int a1)
{
  if (a1 > 0x7F)
  {
    int v3 = (a1 & 0x3F) << 8;
    int v4 = (v3 | (a1 >> 6) & 0x3F) << 8;
    int v5 = (((v4 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
    unsigned int v6 = (v4 | (a1 >> 12)) + 8487393;
    if (HIWORD(a1)) {
      unsigned int v6 = v5;
    }
    unsigned int v1 = (v3 | (a1 >> 6)) + 33217;
    if (a1 > 0x7FF) {
      return v6;
    }
  }
  else
  {
    return a1 + 1;
  }
  return v1;
}

uint64_t _ValidUTF8Buffer._bytes.getter(unsigned int a1)
{
  return (a1 + 0xFEFEFEFEFEFEFFLL) & ~(-1 << (8 * ((4 - (__clz(a1) >> 3)) & 7)));
}

void specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)(char *a1, size_t *a2, void *a3)
{
  size_t v3 = *a2;
  if ((*a2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v5 = a3[1] & 0xFFFFFFFFFFFFFFFLL;
  specialized UnsafeMutablePointer.initialize(from:count:)(a1, *a2, (char *)(v5 + (*(void *)(v5 + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
  uint64_t v6 = *(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL;
  if (__OFADD__(v6, v3))
  {
    __break(1u);
  }
  else
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v6 + v3, 0);
    *a3 = *(void *)(v5 + 24);
  }
}

__objc2_class **specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)(__objc2_class **result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  if (*a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  if (v3)
  {
    uint64_t v5 = (char *)result;
    uint64_t v6 = *a3;
    do
    {
      char v7 = *v5;
      unint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(v6);
      *a3 = v6;
      if ((result & 1) == 0)
      {
        unint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v6 + 16) + 1, 1, v6);
        uint64_t v6 = (uint64_t)result;
        *a3 = (uint64_t)result;
      }
      unint64_t v9 = *(void *)(v6 + 16);
      unint64_t v8 = *(void *)(v6 + 24);
      if (v9 >= v8 >> 1)
      {
        unint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v8 > 1), v9 + 1, 1, v6);
        uint64_t v6 = (uint64_t)result;
      }
      ++v5;
      *(void *)(v6 + 16) = v9 + 1;
      *(unsigned char *)(v6 + v9 + 32) = v7;
      *a3 = v6;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t Float.customMirror.getter@<X0>(uint64_t a1@<X8>, float a2@<S0>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0, 0, a1, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Float@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0, 0, a1, *v1);
}

void Float.customPlaygroundQuickLook.getter(uint64_t a1@<X8>, float a2@<S0>)
{
  *(float *)a1 = a2;
  *(unsigned char *)(a1 + 32) = 3;
}

float protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Float@<S0>(uint64_t a1@<X8>)
{
  float result = *v1;
  *(float *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 3;
  return result;
}

uint64_t Double.customMirror.getter@<X0>(uint64_t a1@<X8>, double a2@<D0>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0, 0, a1, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Double@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0, 0, a1, *v1);
}

void Double.customPlaygroundQuickLook.getter(uint64_t a1@<X8>, double a2@<D0>)
{
  *(double *)a1 = a2;
  *(unsigned char *)(a1 + 32) = 4;
}

double protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Double@<D0>(uint64_t a1@<X8>)
{
  double result = *v1;
  *(double *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 4;
  return result;
}

uint64_t Bool.customMirror.getter@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Bool@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t Bool.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = result;
  a2[32] = 13;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Bool(unsigned char *a1@<X8>)
{
  *a1 = *v1;
  a1[32] = 13;
}

uint64_t String.customMirror.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  swift_bridgeObjectRetain(a2);

  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, a2, 8, 0, 0, a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String(a1, a2, (uint64_t (*)(uint64_t, unint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:));
}

unint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance String@<X0>(uint64_t a1@<X8>)
{
  unint64_t v2 = v1[1];
  *(void *)a1 = *v1;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 32) = 0;
  return swift_bridgeObjectRetain(v2);
}

uint64_t Character.customMirror.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  swift_bridgeObjectRetain(a2);

  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, a2, 8, 0, 0, a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Character(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String(a1, a2, (uint64_t (*)(uint64_t, unint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:));
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, unint64_t, uint64_t, void, void))
{
  uint64_t v5 = *v3;
  unint64_t v4 = v3[1];
  swift_bridgeObjectRetain(v4);

  return a3(v5, v4, 8, 0, 0);
}

unint64_t Character.customPlaygroundQuickLook.getter@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = a1;
  *(void *)(a3 + 8) = a2;
  *(unsigned char *)(a3 + 32) = 0;
  return swift_bridgeObjectRetain(a2);
}

uint64_t Unicode.Scalar.customMirror.getter@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Unicode.Scalar@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t Unicode.Scalar.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 32) = 2;
  return result;
}

uint64_t UInt8.customMirror.getter@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt8@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t UInt8.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 32) = 2;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt8(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 2;
}

uint64_t Int8.customMirror.getter@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int8@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t Int8.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (char)result;
  *(unsigned char *)(a2 + 32) = 1;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int8(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 1;
}

uint64_t UInt16.customMirror.getter@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt16@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t UInt16.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (unsigned __int16)result;
  *(unsigned char *)(a2 + 32) = 2;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt16(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 2;
}

uint64_t Int16.customMirror.getter@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int16@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t Int16.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (__int16)result;
  *(unsigned char *)(a2 + 32) = 1;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int16(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 1;
}

uint64_t UInt32.customMirror.getter@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt32@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t UInt32.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 32) = 2;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt32(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 2;
}

uint64_t Int32.customMirror.getter@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int32@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t Int32.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (int)result;
  *(unsigned char *)(a2 + 32) = 1;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int32(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 1;
}

uint64_t UInt64.customMirror.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt64@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt64(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 2;
}

uint64_t Int64.customMirror.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int64@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int64(uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(unsigned char *)(a1 + 32) = 1;
}

uint64_t UInt.customMirror.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t UInt.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 32) = 2;
  return result;
}

uint64_t Int.customMirror.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0, 0, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0, 0, a1);
}

uint64_t Int.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 32) = 1;
  return result;
}

uint64_t UInt128.customMirror.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, a2, 8, 0, 0, a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, v1[1], 8, 0, 0, a1);
}

uint64_t Int128.customMirror.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, a2, 8, 0, 0, a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, v1[1], 8, 0, 0, a1);
}

Swift::Bool __swiftcall _isPowerOf2(_:)(Swift::UInt a1)
{
  return a1 && (a1 & (a1 - 1)) == 0;
}

id _autorelease(_:)(void *a1)
{
  id v1 = a1;

  return swift_unknownObjectRetain(v1);
}

Swift::String_optional __swiftcall _getFunctionFullNameFromMangledName(mangledName:)(Swift::String mangledName)
{
  id v1 = specialized _copyCollectionToContiguousArray<A>(_:)(mangledName._countAndFlagsBits, (unint64_t)mangledName._object);
  FunctionFullNameFromMangledName = (uint8x16_t *)swift_getFunctionFullNameFromMangledName(v1 + 4, (size_t)v1[2]);
  uint64_t v4 = v3;
  swift_release((uint64_t)v1);
  if (v4)
  {
    if (v4 < 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    }
    int64_t v5 = validateUTF8(_:)(FunctionFullNameFromMangledName->i64, v4);
    if (v7) {
      uint64_t v8 = repairUTF8(_:firstKnownBrokenRange:)(FunctionFullNameFromMangledName->i8, v4, v5, v6);
    }
    else {
      uint64_t v8 = specialized static String._uncheckedFromUTF8(_:isASCII:)(FunctionFullNameFromMangledName, v4, v5 & 1);
    }
  }
  else
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
  }
  result.value._unint64_t object = v9;
  result.value._uint64_t countAndFlagsBits = v8;
  return result;
}

uint64_t UnsafeBufferPointer.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL static UInt.> infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 < a1;
}

uint64_t _typeName(_:qualified:)(Class *a1, char a2)
{
  TypeName = (uint64_t *)swift_getTypeName(a1, a2);
  if (v3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v4 = (uint8x16_t *)TypeName;
  int64_t v5 = v3;
  int64_t v6 = validateUTF8(_:)(TypeName, v3);
  if (v8)
  {
    return repairUTF8(_:firstKnownBrokenRange:)(v4->i8, v5, v6, v7);
  }
  else
  {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(v4, v5, v6 & 1);
  }
}

uint64_t _mangledTypeName(_:)(unint64_t a1)
{
  MangledTypeName = (uint64_t *)swift_getMangledTypeName(a1);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v3 = (uint8x16_t *)MangledTypeName;
  int64_t v4 = v2;
  int64_t v5 = validateUTF8(_:)(MangledTypeName, v2);
  if (v7)
  {
    repairUTF8(_:firstKnownBrokenRange:)(v3->i8, v4, v5, v6);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "repairs made to _mangledTypeName, this is not expected since names should be valid UTF-8", 88, 2, "Swift/Misc.swift", 16, 2, 0x74uLL, 0);
  }
  return specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, v4, v5 & 1);
}

uint64_t _typeByName(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2);
  uint64_t TypeByMangledNameUntrusted = swift_stdlib_getTypeByMangledNameUntrusted((unsigned __int8 *)v2 + 32, (unint64_t)v2[2]);
  swift_release((uint64_t)v2);
  return TypeByMangledNameUntrusted;
}

uint64_t MutableCollection.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v67 = a1;
  unint64_t v58 = a4;
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  Swift::Int v61 = (char *)&v52 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v56 = (char *)&v52 - v11;
  uint64_t v12 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v15 = (char *)&v52 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v52 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v52 - v20;
  MEMORY[0x1F4188790](v19);
  char v23 = (char *)&v52 - v22;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  Swift::Int v62 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v60 = (uint64_t)*(v62 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v62);
  uint64_t v59 = (char *)&v52 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  unint64_t v57 = (char *)&v52 - v28;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a2, v6);
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  uint64_t v64 = a2;
  uint64_t v65 = v4;
  uint64_t v63 = v6;
  v29(a2, v6);
  uint64_t v30 = (void (*)(char *, char *, const char *))v12[2];
  v30(v18, v23, AssociatedTypeWitness);
  unsigned int v55 = v21;
  v30(v15, v21, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v18, v15, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  size_t v31 = (void (*)(char *, const char *))v12[1];
  }
  Swift::String_optional v54 = v31;
  v31(v15, AssociatedTypeWitness);
  v31(v18, AssociatedTypeWitness);
  uint64_t v32 = TupleTypeMetadata2;
  Swift::String::Index v33 = v56;
  Swift::String::Index v34 = &v56[*((int *)TupleTypeMetadata2 + 12)];
  Swift::String::Index v35 = (void (*)(char *, char *, const char *))v12[4];
  v35(v56, v23, AssociatedTypeWitness);
  unint64_t v53 = v34;
  v35(v34, v55, AssociatedTypeWitness);
  Swift::String::Index v36 = v61;
  unint64_t v37 = &v61[*((int *)v32 + 12)];
  v30(v61, v33, AssociatedTypeWitness);
  v30(v37, v34, AssociatedTypeWitness);
  unint64_t v38 = v59;
  v35(v59, v36, AssociatedTypeWitness);
  uint64_t v39 = v37;
  uint64_t v40 = v54;
  v54(v39, AssociatedTypeWitness);
  uint64_t v41 = &v36[*((int *)TupleTypeMetadata2 + 12)];
  v35(v36, v33, AssociatedTypeWitness);
  v35(v41, v53, AssociatedTypeWitness);
  char v42 = v62;
  v35(&v38[*((int *)v62 + 9)], v41, AssociatedTypeWitness);
  v40(v36, AssociatedTypeWitness);
  uint64_t v43 = v60;
  unint64_t v44 = v57;
  (*(void (**)(char *, char *, Class *))(v60 + 32))(v57, v38, v42);
  uint64_t v45 = v63;
  uint64_t v46 = v64;
  uint64_t v47 = v65;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v63 + 176))(v67, v44, v64, v63);
  (*(void (**)(char *, Class *))(v43 + 8))(v44, v42);
  uint64_t v49 = type metadata accessor for Slice(0, v46, v45, v48);
  unint64_t v50 = v58;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v46 - 8) + 16))(&v58[*((int *)v49 + 10)], v47, v46);
  (*(void (**)(char *, uint64_t, Class *))(v43 + 16))(v38, v67, v42);
  v35(v50, v38, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, const char *))v35)(&v50[*((int *)v49 + 9)], &v38[*((int *)v42 + 9)], AssociatedTypeWitness);
}

uint64_t key path getter for MutableCollection.subscript(_:) : <A>AA@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return MutableCollection.subscript.getter(a1, *(void *)(a2 + a1 - 16), *(void *)(a2 + a1 - 8), a3);
}

uint64_t key path setter for MutableCollection.subscript(_:) : <A>AA(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  return specialized MutableCollection<>.subscript.setter(a1, a3, *(void *)&a3[a4 - 16], *(void *)&a3[a4 - 8]);
}

uint64_t MutableCollection.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  specialized MutableCollection<>.subscript.setter(a1, a2, a3, a4);
  uint64_t v8 = *(int ***)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  (*((void (**)(char *, Class *))*(v12 - 1) + 1))(a2, v12);
  uint64_t v14 = type metadata accessor for Slice(0, a3, (uint64_t)v8, v13);
  unint64_t v15 = (uint64_t (*)(uint64_t, Class *))*((void *)*(v14 - 1) + 1);

  return v15(a1, v14);
}

uint64_t _writeBackMutableSlice<A, B>(_:bounds:slice:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v142 = a5;
  uint64_t v143 = a7;
  uint64_t v135 = a3;
  Swift::String::Index v126 = a2;
  uint64_t v130 = a6;
  uint64_t v9 = *(void *)(a6 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v9 + 8), a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v110 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v127 = (char *)&v109 - v10;
  uint64_t v11 = swift_getAssociatedTypeWitness(255, (int **)v9, a4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v11, (uint64_t)v11, "lower upper ", 0);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  Swift::String::Index v125 = (void (**)(char *))((char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v144 = (char *)&v109 - v15;
  uint64_t v138 = *((void *)v11 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v112 = (char *)&v109 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v120 = (char *)&v109 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v133 = (char *)&v109 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  unint64_t v134 = (void (**)(char *))((char *)&v109 - v23);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v109 - v25;
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  BOOL v119 = (char *)&v109 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  int64_t v118 = (char *)&v109 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  unint64_t v121 = (char *)&v109 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  Swift::String::Index v35 = (char *)&v109 - v34;
  uint64_t v36 = MEMORY[0x1F4188790](v33);
  unint64_t v38 = (char *)&v109 - v37;
  uint64_t v39 = MEMORY[0x1F4188790](v36);
  uint64_t v41 = (char *)&v109 - v40;
  MEMORY[0x1F4188790](v39);
  uint64_t v43 = (char *)&v109 - v42;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v143, v142, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  Swift::String::Index v124 = type metadata accessor for Range(0, (uint64_t)v11, AssociatedConformanceWitness, v45);
  uint64_t v123 = (uint64_t)*(v124 - 1);
  uint64_t v46 = MEMORY[0x1F4188790](v124);
  unint64_t v131 = (char *)&v109 - ((v47 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  char v117 = (char *)&v109 - v49;
  MEMORY[0x1F4188790](v48);
  uint64_t v122 = v51;
  uint64_t v52 = *(void (**)(void))(v51 + 16);
  int64_t v116 = (char *)&v109 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0);
  v52();
  (*(void (**)(uint64_t, uint64_t))(v9 + 64))(a4, v9);
  unint64_t v53 = *(void (**)(uint64_t, uint64_t))(v9 + 72);
  uint64_t v129 = a1;
  uint64_t v136 = a4;
  uint64_t v137 = v9;
  v53(a4, v9);
  uint64_t v54 = v138;
  uint64_t v56 = v138 + 16;
  unsigned int v55 = *(void (**)(char *, char *, const char *))(v138 + 16);
  unint64_t v113 = v43;
  v55(v38, v43, v11);
  unint64_t v115 = v41;
  Swift::String::Index v145 = v55;
  v55(v35, v41, v11);
  unint64_t v57 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24);
  unint64_t v114 = (void (**)(char *))v38;
  if ((v57(v38, v35, v11, AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v141 = v56;
  uint64_t v59 = v54 + 8;
  unint64_t v58 = *(void (**)(void (**)(char *), const char *))(v54 + 8);
  Swift::Int v140 = v58;
  v58((void (**)(char *))v35, v11);
  v58(v114, v11);
  unint64_t v114 = (void (**)(char *))AssociatedConformanceWitness;
  uint64_t v60 = TupleTypeMetadata2;
  Swift::Int v61 = &v144[*((int *)TupleTypeMetadata2 + 12)];
  Swift::Int v62 = *(void (**)(void))(v54 + 32);
  v62();
  unint64_t v111 = v61;
  ((void (*)(char *, char *, const char *))v62)(v61, v115, v11);
  uint64_t v63 = v125;
  uint64_t v64 = (char *)v125 + *((int *)v60 + 12);
  uint64_t v65 = v145;
  v145((char *)v125, v144, v11);
  v65(v64, v61, v11);
  ((void (*)(char *, void (**)(char *), const char *))v62)(v131, v63, v11);
  char v66 = v140;
  v140((void (**)(char *))v64, v11);
  uint64_t v67 = (char *)v63 + *((int *)TupleTypeMetadata2 + 12);
  ((void (*)(void (**)(char *), char *, const char *))v62)(v63, v144, v11);
  ((void (*)(char *, char *, const char *))v62)(v67, v111, v11);
  uint64_t v68 = v124;
  char v69 = v131;
  ((void (*)(char *, char *, const char *))v62)(&v131[*((int *)v124 + 9)], v67, v11);
  uint64_t v138 = v59;
  v66(v63, v11);
  uint64_t v70 = v123;
  uint64_t v71 = v117;
  (*(void (**)(char *, char *, Class *))(v123 + 32))(v117, v69, v68);
  uint64_t v72 = v136;
  size_t v73 = v126;
  int v74 = v116;
  (*(void (**)(char *, char *, uint64_t))(v137 + 176))(v126, v71, v136);
  (*(void (**)(char *, Class *))(v70 + 8))(v71, v68);
  (*(void (**)(char *, uint64_t))(v122 + 8))(v74, v72);
  unint64_t v75 = v121;
  char v76 = (void (*)(char *, uint64_t, const char *))v145;
  v145(v121, v73, v11);
  unint64_t v77 = v118;
  v76(v118, (uint64_t)&v73[*((int *)v68 + 9)], v11);
  uint64_t v78 = v142;
  uint64_t v79 = v143;
  unint64_t v80 = v119;
  (*(void (**)(uint64_t, uint64_t))(v143 + 64))(v142, v143);
  (*(void (**)(uint64_t, uint64_t))(v79 + 72))(v78, v79);
  unint64_t v81 = (char *)v114[1];
  uint64_t v144 = (char *)*((void *)v81 + 1);
  LOBYTE(v74) = ((uint64_t (*)(char *, char *, const char *, void (*)(char *)))v144)(v75, v77, v11, (void (*)(char *))v81);
  unint64_t v82 = v134;
  v145((char *)v134, v26, v11);
  unint64_t v131 = v81;
  unint64_t v132 = v26;
  TupleTypeMetadata2 = (uint64_t *)(v81 + 8);
  if (v74)
  {
LABEL_6:
    uint64_t v84 = v81;
    unint64_t v85 = (void (*)(char *, const char *))v140;
    v140(v82, v11);
  }
  else
  {
    Swift::String::Index v126 = (char *)(v143 + 80);
    Swift::String::Index v125 = (void (**)(char *))(v110 + 16);
    Swift::String::Index v124 = (Class *)(v130 + 24);
    uint64_t v123 = v137 + 192;
    uint64_t v122 = v143 + 192;
    while (1)
    {
      char v83 = ((uint64_t (*)(char *, void (**)(char *), const char *, void (*)(char *)))v144)(v80, v82, v11, (void (*)(char *))v81);
      uint64_t v84 = v81;
      unint64_t v85 = (void (*)(char *, const char *))v140;
      v140(v82, v11);
      if (v83) {
        break;
      }
      unint64_t v86 = v133;
      v145(v133, v75, v11);
      uint64_t v88 = v142;
      uint64_t v87 = v143;
      uint64_t v89 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v143 + 80))(v146, v80, v142, v143);
      unint64_t v90 = v11;
      size_t v91 = v77;
      Swift::String::Index v92 = v80;
      Swift::String::Index v93 = v127;
      (*v125)(v127);
      ((void (*)(char *, void))v89)(v146, 0);
      Swift::String::Index v94 = v93;
      uint64_t v95 = v136;
      (*(void (**)(char *, char *, uint64_t))(v130 + 24))(v94, v86, v136);
      uint64_t v96 = v95;
      unint64_t v80 = v92;
      unint64_t v77 = v91;
      uint64_t v11 = v90;
      (*(void (**)(char *, uint64_t))(v137 + 192))(v75, v96);
      unint64_t v97 = *(void (**)(char *, uint64_t, uint64_t))(v87 + 192);
      uint64_t v98 = v87;
      unint64_t v82 = v134;
      v97(v80, v88, v98);
      unint64_t v81 = v131;
      LOBYTE(v89) = ((uint64_t (*)(char *, char *, const char *, char *))v144)(v75, v77, v90, v131);
      v145((char *)v82, v132, v90);
      if (v89) {
        goto LABEL_6;
      }
    }
  }
  uint64_t v99 = v120;
  v145(v120, v77, v11);
  uint64_t v100 = v84;
  uint64_t v101 = (uint64_t (*)(char *, char *, const char *, char *))v144;
  if ((((uint64_t (*)(char *, char *, const char *, char *))v144)(v75, v99, v11, v100) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Cannot replace a slice of a MutableCollection with a slice of a smaller size", 76, 2, "Swift/WriteBackMutableSlice.swift", 33, 2, 0x29uLL, 0);
  }
  char v102 = v101;
  v85(v99, v11);
  unint64_t v103 = v112;
  unint64_t v104 = v85;
  unint64_t v105 = v132;
  unint64_t v106 = v145;
  v145(v112, v132, v11);
  unint64_t v107 = v133;
  v106(v133, v80, v11);
  LOBYTE(v102) = v102(v107, v103, v11, v131);
  v104(v107, v11);
  if ((v102 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Cannot replace a slice of a MutableCollection with a slice of a larger size", 75, 2, "Swift/WriteBackMutableSlice.swift", 33, 2, 0x2CuLL, 0);
  }
  v104(v103, v11);
  v104(v105, v11);
  v104(v80, v11);
  v104(v77, v11);
  return ((uint64_t (*)(char *, const char *))v104)(v121, v11);
}

uint64_t (*MutableCollection.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v9 = malloc(0x58uLL);
  *a1 = v9;
  v9[1] = a4;
  v9[2] = v4;
  void *v9 = a3;
  uint64_t v10 = *(int ***)(a4 + 8);
  uint64_t v12 = type metadata accessor for Slice(0, a3, (uint64_t)v10, v11);
  v9[3] = v12;
  uint64_t v13 = (uint64_t)*(v12 - 1);
  v9[4] = v13;
  size_t v14 = *(void *)(v13 + 64);
  v9[5] = malloc(v14);
  uint64_t v15 = (char *)malloc(v14);
  v9[6] = v15;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v19 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  v9[7] = v19;
  uint64_t v20 = (uint64_t)*(v19 - 1);
  uint64_t v21 = v20;
  v9[8] = v20;
  size_t v22 = *(void *)(v20 + 64);
  v9[9] = malloc(v22);
  v9[10] = malloc(v22);
  (*(void (**)(void))(v21 + 16))();
  MutableCollection.subscript.getter(a2, a3, a4, v15);
  return MutableCollection.subscript.modify;
}

void MutableCollection<>.subscript.modify(uint64_t **a1, char a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (char *)(*a1)[9];
  uint64_t v5 = (*a1)[8];
  uint64_t v17 = (*a1)[7];
  uint64_t v18 = (char *)(*a1)[10];
  uint64_t v6 = (void *)(*a1)[5];
  char v7 = (void *)(*a1)[6];
  uint64_t v8 = (unint64_t *)(*a1)[3];
  uint64_t v9 = (*a1)[4];
  uint64_t v10 = (*a1)[1];
  uint64_t v11 = (*a1)[2];
  uint64_t v12 = **a1;
  if (a2)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 16))(v3[5], v3[6], v3[3]);
    (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v4, v18, v17);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, v8, v13);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v11, v4, (uint64_t)v6, v12, (uint64_t)v8, v10, WitnessTable);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v4, v17);
    uint64_t v15 = *(void (**)(void *, unint64_t *))(v9 + 8);
    v15(v6, v8);
    v15(v7, v8);
  }
  else
  {
    uint64_t v16 = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, (unint64_t *)v3[3], a3);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v11, v18, (uint64_t)v7, v12, (uint64_t)v8, v10, v16);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v18, v17);
    (*(void (**)(void *, unint64_t *))(v9 + 8))(v7, v8);
  }
  free(v18);
  free(v4);
  free(v7);
  free(v6);

  free(v3);
}

void MutableCollection.subscript.getter()
{
}

void key path getter for MutableCollection.subscript(_:) : <A>AA()
{
}

void key path setter for MutableCollection.subscript(_:) : <A>AA()
{
}

uint64_t key path getter for MutableCollection<>.subscript(_:) : <A>AA@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return MutableCollection<>.subscript.getter(a1, *(void *)(a2 + a1 - 16), *(void *)(a2 + a1 - 8), a3);
}

uint64_t MutableCollection.moveSubranges(_:to:)@<X0>(uint64_t *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v122 = a5;
  uint64_t v142 = a4;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v149 = (char *)&v120 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v147 = (char *)&v120 - v13;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v146 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v150 = (uint64_t)*(v146 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v146);
  Swift::String::Index v126 = (char *)&v120 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  Swift::Int v140 = (char *)&v120 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v130 = (char *)&v120 - v20;
  uint64_t v155 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  Swift::String::Index v125 = (char *)&v120 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  Swift::String::Index v124 = (char *)&v120 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  unint64_t v132 = (char *)&v120 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v131 = (char *)&v120 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  char v133 = (char *)&v120 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v123 = (uint64_t)&v120 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  uint64_t v136 = (char *)&v120 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v135 = (char *)&v120 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v144 = (char *)&v120 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v145 = (uint64_t)&v120 - v40;
  MEMORY[0x1F4188790](v39);
  uint64_t v42 = (char *)&v120 - v41;
  uint64_t v139 = *a1;
  unint64_t v154 = *(void (**)(uint64_t, uint64_t))(v9 + 64);
  uint64_t v43 = a3;
  v154(a3, v9);
  unint64_t v153 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 152);
  unint64_t v44 = a2;
  uint64_t v45 = a2;
  uint64_t v46 = v43;
  unint64_t v127 = (char *)v153(v42, (uint64_t)v45, v43, v9);
  uint64_t v48 = v155 + 8;
  uint64_t v47 = *(void (**)(char *, const char *))(v155 + 8);
  v47(v42, AssociatedTypeWitness);
  uint64_t v49 = *(void (**)(uint64_t, void))(v9 + 72);
  uint64_t v129 = v9 + 72;
  unint64_t v128 = v49;
  v49(v46, v9);
  uint64_t v50 = (char *)v153(v44, (uint64_t)v42, v46, v9);
  uint64_t v51 = v42;
  uint64_t v52 = v135;
  unint64_t v156 = v47;
  uint64_t v157 = v48;
  v47(v51, AssociatedTypeWitness);
  unint64_t v53 = v144;
  uint64_t v143 = v5;
  uint64_t v141 = v46;
  unint64_t v134 = (void (*)(uint64_t, Class *))v9;
  v154(v46, v9);
  uint64_t v54 = v155;
  unsigned int v55 = (void (*)(uint64_t, uint64_t))(v155 + 16);
  uint64_t v56 = *(void (**)(char *, char *, const char *))(v155 + 16);
  v56(v52, v53, AssociatedTypeWitness);
  unint64_t v57 = v136;
  uint64_t v151 = v44;
  unint64_t v153 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v56;
  unint64_t v154 = v55;
  v56(v136, v44, AssociatedTypeWitness);
  unint64_t v58 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24);
  uint64_t v138 = AssociatedConformanceWitness + 24;
  uint64_t v137 = v58;
  if ((((uint64_t (*)(char *, char *, const char *))v58)(v52, v57, AssociatedTypeWitness) & 1) == 0) {
    goto LABEL_5;
  }
  unint64_t v121 = v50;
  uint64_t v59 = v156;
  v156(v57, AssociatedTypeWitness);
  v59(v52, AssociatedTypeWitness);
  Swift::Int v61 = v147;
  uint64_t v60 = TupleTypeMetadata2;
  Swift::Int v62 = &v147[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v63 = *(void (**)(char *, char *, const char *))(v54 + 32);
  v63(v147, v144, AssociatedTypeWitness);
  uint64_t v136 = v62;
  uint64_t v64 = (void (*)(char *, char *, const char *))v153;
  ((void (*)(char *, char *, const char *))v153)(v62, v151, AssociatedTypeWitness);
  uint64_t v65 = v149;
  char v66 = &v149[*((int *)v60 + 12)];
  v64(v149, v61, AssociatedTypeWitness);
  v64(v66, v62, AssociatedTypeWitness);
  uint64_t v67 = v140;
  v63(v140, v65, AssociatedTypeWitness);
  uint64_t v68 = v66;
  char v69 = v156;
  v156(v68, AssociatedTypeWitness);
  uint64_t v70 = &v65[*((int *)v60 + 12)];
  v63(v65, v61, AssociatedTypeWitness);
  v63(v70, v136, AssociatedTypeWitness);
  uint64_t v71 = v146;
  uint64_t v72 = &v67[*((int *)v146 + 9)];
  uint64_t v155 = v54 + 32;
  uint64_t v144 = (char *)v63;
  v63(v72, v70, AssociatedTypeWitness);
  v69(v65, AssociatedTypeWitness);
  uint64_t v73 = v150;
  uint64_t v74 = (uint64_t)v130;
  uint64_t v136 = *(char **)(v150 + 32);
  uint64_t v135 = (char *)(v150 + 32);
  uint64_t v75 = ((uint64_t (*)(char *, char *, Class *))v136)(v130, v67, v71);
  MEMORY[0x1F4188790](v75);
  uint64_t v76 = v141;
  uint64_t v117 = v141;
  uint64_t v118 = v142;
  uint64_t v119 = v139;
  MutableCollection._indexedStablePartition(count:range:by:)(v127, v74, partial apply for closure #1 in MutableCollection.moveSubranges(_:to:), (uint64_t)(&v120 - 6), v141, v142, v145);
  uint64_t v79 = *(void (**)(uint64_t, Class *))(v73 + 8);
  uint64_t v78 = v73 + 8;
  unint64_t v77 = v79;
  v79(v74, v71);
  unint64_t v80 = v133;
  v128(v76, v134);
  unint64_t v81 = v131;
  unint64_t v82 = (void (*)(char *, char *, const char *))v153;
  ((void (*)(char *, char *, const char *))v153)(v131, v151, AssociatedTypeWitness);
  char v83 = v132;
  v82(v132, v80, AssociatedTypeWitness);
  if ((v137(v81, v83, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_5;
  }
  unint64_t v134 = v77;
  uint64_t v84 = v156;
  v156(v83, AssociatedTypeWitness);
  v84(v81, AssociatedTypeWitness);
  uint64_t v150 = v78;
  unint64_t v85 = TupleTypeMetadata2;
  uint64_t v86 = *((int *)TupleTypeMetadata2 + 12);
  unint64_t v132 = 0;
  uint64_t v87 = v147;
  uint64_t v88 = &v147[v86];
  uint64_t v89 = (void (*)(char *, char *, const char *))v153;
  ((void (*)(char *, char *, const char *))v153)(v147, v151, AssociatedTypeWitness);
  unint64_t v131 = v88;
  unint64_t v90 = (void (*)(char *, char *, const char *))v144;
  ((void (*)(char *, char *, const char *))v144)(v88, v80, AssociatedTypeWitness);
  size_t v91 = v149;
  Swift::String::Index v92 = &v149[*((int *)v85 + 12)];
  v89(v149, v87, AssociatedTypeWitness);
  v89(v92, v88, AssociatedTypeWitness);
  Swift::String::Index v93 = v140;
  v90(v140, v91, AssociatedTypeWitness);
  Swift::String::Index v94 = v156;
  v156(v92, AssociatedTypeWitness);
  uint64_t v95 = &v91[*((int *)v85 + 12)];
  v90(v91, v87, AssociatedTypeWitness);
  v90(v95, v131, AssociatedTypeWitness);
  uint64_t v96 = v146;
  v90(&v93[*((int *)v146 + 9)], v95, AssociatedTypeWitness);
  v94(v91, AssociatedTypeWitness);
  uint64_t v97 = (uint64_t)v126;
  uint64_t v98 = ((uint64_t (*)(char *, char *, Class *))v136)(v126, v93, v96);
  MEMORY[0x1F4188790](v98);
  uint64_t v117 = v141;
  uint64_t v118 = v142;
  uint64_t v119 = v139;
  uint64_t v99 = v123;
  MutableCollection._indexedStablePartition(count:range:by:)(v121, v97, (uint64_t (*)(uint64_t))partial apply for closure #2 in MutableCollection.moveSubranges(_:to:), (uint64_t)(&v120 - 6), v141, v142, v123);
  uint64_t v100 = v97;
  uint64_t v101 = v99;
  v134(v100, v96);
  char v102 = v124;
  unint64_t v103 = (void (*)(char *, uint64_t, const char *))v153;
  ((void (*)(char *, uint64_t, const char *))v153)(v124, v145, AssociatedTypeWitness);
  unint64_t v104 = v125;
  v103(v125, v99, AssociatedTypeWitness);
  if ((v137(v102, v104, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0) {
LABEL_5:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  unint64_t v105 = v156;
  v156(v104, AssociatedTypeWitness);
  v105(v102, AssociatedTypeWitness);
  unint64_t v106 = v147;
  unint64_t v107 = TupleTypeMetadata2;
  uint64_t v108 = (uint64_t)&v147[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v109 = (void (*)(uint64_t, uint64_t, const char *))v144;
  ((void (*)(char *, uint64_t, const char *))v144)(v147, v145, AssociatedTypeWitness);
  uint64_t AssociatedConformanceWitness = v108;
  v109(v108, v101, AssociatedTypeWitness);
  uint64_t v110 = v149;
  unint64_t v111 = &v149[*((int *)v107 + 12)];
  unint64_t v112 = (void (*)(char *, uint64_t, const char *))v153;
  ((void (*)(char *, char *, const char *))v153)(v149, v106, AssociatedTypeWitness);
  v112(v111, v108, AssociatedTypeWitness);
  uint64_t v113 = v122;
  v109(v122, (uint64_t)v110, AssociatedTypeWitness);
  unint64_t v114 = (uint64_t (*)(char *, const char *))v156;
  v156(v111, AssociatedTypeWitness);
  unint64_t v115 = &v110[*((int *)v107 + 12)];
  v109((uint64_t)v110, (uint64_t)v106, AssociatedTypeWitness);
  v109((uint64_t)v115, AssociatedConformanceWitness, AssociatedTypeWitness);
  v109(v113 + *((int *)v146 + 9), (uint64_t)v115, AssociatedTypeWitness);
  return v114(v110, AssociatedTypeWitness);
}

uint64_t RangeSet.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return RangeSet.Ranges._contains(_:)(a1, (uint64_t)v5) & 1;
}

uint64_t MutableCollection._swapNonemptySubrangePrefixes(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v52 = a4;
  unint64_t v53 = a2;
  uint64_t v37 = a1;
  uint64_t v9 = *(void *)(a6 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, a5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v49 = a5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v47 = (char *)&v36 - v16;
  uint64_t v17 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v36 = v17;
  uint64_t v18 = *(void (**)(void))(v17 + 16);
  uint64_t v51 = (char *)&v36 - v19;
  v18();
  ((void (*)(char *, uint64_t, const char *))v18)(v53, v52, AssociatedTypeWitness);
  uint64_t v50 = a6;
  uint64_t v45 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a6 + 64);
  uint64_t v46 = a6 + 64;
  uint64_t v48 = v9;
  uint64_t v43 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 192);
  uint64_t v44 = v9 + 192;
  uint64_t v20 = a3 + *((int *)v13 + 9);
  uint64_t v41 = v13;
  uint64_t v42 = v20;
  uint64_t v21 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v22 = *(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(v21 + 8);
  uint64_t v38 = (void (**)(char *, uint64_t, Class *))(v14 + 16);
  uint64_t v39 = AssociatedTypeWitness;
  uint64_t v40 = (void (**)(char *, Class *))(v14 + 8);
  uint64_t v23 = v53;
  uint64_t v24 = v48;
  while (1)
  {
    uint64_t v25 = v51;
    uint64_t v26 = v49;
    v45(v51, (uint64_t)v23, v49, v50);
    uint64_t v27 = v21;
    uint64_t v28 = v43;
    v43((uint64_t)v25, v26, v24);
    uint64_t v29 = v26;
    uint64_t v30 = v41;
    v28((uint64_t)v23, v29, v24);
    uint64_t v21 = v27;
    uint64_t v31 = v39;
    char v32 = v22(v25, v42, v39, v27);
    uint64_t v33 = v47;
    (*v38)(v47, v52, v30);
    if (v32) {
      break;
    }
    char v34 = v22(v53, (uint64_t)&v33[*((int *)v30 + 9)], v31, v27);
    (*v40)(v33, v30);
    if (v34) {
      return (*(uint64_t (**)(uint64_t, char *, const char *))(v36 + 32))(v37, v51, v31);
    }
  }
  (*v40)(v33, v30);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v36 + 32))(v37, v51, v31);
}

uint64_t (*_NativeDictionary._storage.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _NativeDictionary.age.getter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

Swift::Void __swiftcall _NativeDictionary.invalidateIndices()()
{
  ++*(_DWORD *)(v0 + 36);
}

uint64_t _NativeDictionary.uncheckedInitialize(at:toKey:value:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32))(*(void *)(a4 + 48) + *(void *)(*(void *)(a5 - 8) + 72) * a1, a2, a5);
  uint64_t v10 = *(void *)(a6 - 8);
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 32);
  uint64_t v12 = *(void *)(a4 + 56) + *(void *)(v10 + 72) * a1;

  return v11(v12, a3, a6);
}

unint64_t _NativeDictionary.find(_:hashValue:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, a4);
}

uint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = (int64x2_t *)*v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1 = *(void *)(*v2 + 24);
  }
  uint64_t v6 = (void *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1, (uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<ObjectIdentifier, Int>);
  if (v5[1].i64[0])
  {
    char v28 = a2;
    uint64_t v27 = v3;
    int64_t v7 = 0;
    uint64_t v8 = v5 + 4;
    uint64_t v9 = 1 << v5[2].i8[0];
    uint64_t v10 = -1;
    if (v9 < 64) {
      uint64_t v10 = ~(-1 << v9);
    }
    unint64_t v11 = v10 & v5[4].i64[0];
    int64_t v12 = (unint64_t)(v9 + 63) >> 6;
    if (!v11) {
      goto LABEL_8;
    }
LABEL_7:
    unint64_t v13 = __clz(__rbit64(v11));
    v11 &= v11 - 1;
    for (unint64_t i = v13 | (v7 << 6); ; unint64_t i = __clz(__rbit64(v16)) + (v7 << 6))
    {
      uint64_t v18 = 8 * i;
      uint64_t v19 = *(void *)(v5[3].i64[0] + v18);
      uint64_t v20 = *(void *)(v5[3].i64[1] + v18);
      uint64_t v21 = specialized static Hasher._hash(seed:_:)(v6[5], v19);
      unint64_t v22 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(v19, v21);
      if (v23) {
        goto LABEL_31;
      }
      *(void *)((char *)v6 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v22;
      uint64_t v24 = 8 * v22;
      *(void *)(v6[6] + v24) = v19;
      *(void *)(v6[7] + v24) = v20;
      ++v6[2];
      if (v11) {
        goto LABEL_7;
      }
LABEL_8:
      if (__OFADD__(v7++, 1)) {
        goto LABEL_30;
      }
      if (v7 >= v12) {
        break;
      }
      unint64_t v16 = v8->u64[v7];
      if (!v16)
      {
        int64_t v17 = v7 + 1;
        if (v7 + 1 >= v12) {
          break;
        }
        unint64_t v16 = v8->u64[v17];
        if (!v16)
        {
          while (1)
          {
            int64_t v7 = v17 + 1;
            if (__OFADD__(v17, 1)) {
              break;
            }
            if (v7 >= v12) {
              goto LABEL_21;
            }
            unint64_t v16 = v8->u64[v7];
            ++v17;
            if (v16) {
              goto LABEL_17;
            }
          }
          __break(1u);
LABEL_30:
          __break(1u);
LABEL_31:
          swift_retain(v5->i64);
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for ObjectIdentifier);
        }
        ++v7;
      }
LABEL_17:
      unint64_t v11 = (v16 - 1) & v16;
    }
LABEL_21:
    if (v28)
    {
      uint64_t v25 = 1 << v5[2].i8[0];
      if (v25 >= 64) {
        specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v25 + 63) >> 6, v5 + 4);
      }
      else {
        v8->i64[0] = -1 << v25;
      }
      v5[1].i64[0] = 0;
    }
    uint64_t result = swift_release((uint64_t)v5);
    uint64_t v3 = v27;
  }
  else
  {
    uint64_t result = swift_release((uint64_t)v5);
  }
  *uint64_t v3 = v6;
  return result;
}

{
  int64x2_t **v2;
  int64x2_t *v4;
  int64x2_t *v5;
  uint64_t v6;
  int64x2_t *v7;
  uint64_t v8;
  unint64_t v9;
  int64_t v10;
  uint64_t result;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  int64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  _OWORD *v21;
  uint64_t v22;
  _OWORD v23[2];

  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v5 = (int64x2_t *)specialized static _DictionaryStorage.allocate(capacity:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_28;
  }
  uint64_t v6 = 1 << v4[2].i8[0];
  int64_t v7 = v4 + 4;
  uint64_t v8 = -1;
  if (v6 < 64) {
    uint64_t v8 = ~(-1 << v6);
  }
  uint64_t v9 = v8 & v4[4].i64[0];
  uint64_t v10 = (unint64_t)(v6 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain(v4->i64);
  int64_t v12 = 0;
  while (1)
  {
    if (v9)
    {
      unint64_t v13 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      uint64_t v14 = v13 | (v12 << 6);
      goto LABEL_21;
    }
    if (__OFADD__(v12++, 1)) {
      goto LABEL_30;
    }
    if (v12 >= v10) {
      break;
    }
    unint64_t v16 = v7->u64[v12];
    if (!v16)
    {
      int64_t v17 = v12 + 1;
      if (v12 + 1 >= v10) {
        break;
      }
      unint64_t v16 = v7->u64[v17];
      if (!v16)
      {
        while (1)
        {
          int64_t v12 = v17 + 1;
          if (__OFADD__(v17, 1)) {
            break;
          }
          if (v12 >= v10) {
            goto LABEL_23;
          }
          unint64_t v16 = v7->u64[v12];
          ++v17;
          if (v16) {
            goto LABEL_20;
          }
        }
        __break(1u);
LABEL_30:
        __break(1u);
        return result;
      }
      ++v12;
    }
LABEL_20:
    uint64_t v9 = (v16 - 1) & v16;
    uint64_t v14 = __clz(__rbit64(v16)) + (v12 << 6);
LABEL_21:
    uint64_t v18 = (unint64_t *)(v4[3].i64[0] + 16 * v14);
    uint64_t v19 = *v18;
    uint64_t v20 = v18[1];
    uint64_t v21 = (_OWORD *)(v4[3].i64[1] + 32 * v14);
    if (a2)
    {
      outlined init with take of Any(v21, v23);
    }
    else
    {
      outlined init with copy of Any((uint64_t)v21, (uint64_t)v23);
      swift_bridgeObjectRetain(v20);
    }
    uint64_t result = (uint64_t)specialized _NativeDictionary._unsafeInsertNew(key:value:)(v19, v20, v23, v5);
  }
LABEL_23:
  swift_release((uint64_t)v4);
  if (a2)
  {
    unint64_t v22 = 1 << v4[2].i8[0];
    if (v22 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v22 + 63) >> 6, v4 + 4);
    }
    else {
      v7->i64[0] = -1 << v22;
    }
    v4[1].i64[0] = 0;
  }
LABEL_28:
  uint64_t result = swift_release((uint64_t)v4);
  void *v2 = v5;
  return result;
}

{
  int64x2_t **v2;
  int64x2_t *v4;
  int64x2_t *v5;
  uint64_t v6;
  int64x2_t *v7;
  uint64_t v8;
  unint64_t v9;
  int64_t v10;
  uint64_t result;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  int64_t v17;
  uint64_t v18;
  long long v19;
  long long v20;
  uint64_t v21;
  _OWORD v22[2];
  long long v23[2];
  uint64_t v24;

  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v5 = (int64x2_t *)specialized static _DictionaryStorage.allocate(capacity:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_28;
  }
  uint64_t v6 = 1 << v4[2].i8[0];
  int64_t v7 = v4 + 4;
  uint64_t v8 = -1;
  if (v6 < 64) {
    uint64_t v8 = ~(-1 << v6);
  }
  uint64_t v9 = v8 & v4[4].i64[0];
  uint64_t v10 = (unint64_t)(v6 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain(v4->i64);
  int64_t v12 = 0;
  while (1)
  {
    if (v9)
    {
      unint64_t v13 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      uint64_t v14 = v13 | (v12 << 6);
      goto LABEL_21;
    }
    if (__OFADD__(v12++, 1)) {
      goto LABEL_30;
    }
    if (v12 >= v10) {
      break;
    }
    unint64_t v16 = v7->u64[v12];
    if (!v16)
    {
      int64_t v17 = v12 + 1;
      if (v12 + 1 >= v10) {
        break;
      }
      unint64_t v16 = v7->u64[v17];
      if (!v16)
      {
        while (1)
        {
          int64_t v12 = v17 + 1;
          if (__OFADD__(v17, 1)) {
            break;
          }
          if (v12 >= v10) {
            goto LABEL_23;
          }
          unint64_t v16 = v7->u64[v12];
          ++v17;
          if (v16) {
            goto LABEL_20;
          }
        }
        __break(1u);
LABEL_30:
        __break(1u);
        return result;
      }
      ++v12;
    }
LABEL_20:
    uint64_t v9 = (v16 - 1) & v16;
    uint64_t v14 = __clz(__rbit64(v16)) + (v12 << 6);
LABEL_21:
    uint64_t v18 = v4[3].i64[0] + 40 * v14;
    if (a2)
    {
      uint64_t v19 = *(_OWORD *)v18;
      uint64_t v20 = *(_OWORD *)(v18 + 16);
      uint64_t v24 = *(void *)(v18 + 32);
      v23[0] = v19;
      v23[1] = v20;
      outlined init with take of Any((_OWORD *)(v4[3].i64[1] + 32 * v14), v22);
    }
    else
    {
      outlined init with copy of AnyHashable(v18, (uint64_t)v23);
      outlined init with copy of Any(v4[3].i64[1] + 32 * v14, (uint64_t)v22);
    }
    uint64_t result = (uint64_t)specialized _NativeDictionary._unsafeInsertNew(key:value:)(v23, v22, v5);
  }
LABEL_23:
  swift_release((uint64_t)v4);
  if (a2)
  {
    uint64_t v21 = 1 << v4[2].i8[0];
    if (v21 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v21 + 63) >> 6, v4 + 4);
    }
    else {
      v7->i64[0] = -1 << v21;
    }
    v4[1].i64[0] = 0;
  }
LABEL_28:
  uint64_t result = swift_release((uint64_t)v4);
  void *v2 = v5;
  return result;
}

{
  void *v2;
  void *v3;
  int64x2_t *v5;
  void *v6;
  int64_t v7;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t i;
  unint64_t v16;
  int64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  void *v27;
  char v28;

  uint64_t v3 = v2;
  uint64_t v5 = (int64x2_t *)*v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1 = *(void *)(*v2 + 24);
  }
  uint64_t v6 = (void *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1, (uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
  if (v5[1].i64[0])
  {
    char v28 = a2;
    uint64_t v27 = v3;
    int64_t v7 = 0;
    uint64_t v8 = v5 + 4;
    uint64_t v9 = 1 << v5[2].i8[0];
    uint64_t v10 = -1;
    if (v9 < 64) {
      uint64_t v10 = ~(-1 << v9);
    }
    unint64_t v11 = v10 & v5[4].i64[0];
    int64_t v12 = (unint64_t)(v9 + 63) >> 6;
    if (!v11) {
      goto LABEL_8;
    }
LABEL_7:
    unint64_t v13 = __clz(__rbit64(v11));
    v11 &= v11 - 1;
    for (unint64_t i = v13 | (v7 << 6); ; unint64_t i = __clz(__rbit64(v16)) + (v7 << 6))
    {
      uint64_t v18 = 8 * i;
      uint64_t v19 = *(void *)(v5[3].i64[0] + v18);
      uint64_t v20 = *(void *)(v5[3].i64[1] + v18);
      uint64_t v21 = specialized static Hasher._hash(seed:_:)(v6[5], v19);
      unint64_t v22 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(v19, v21);
      if (v23) {
        goto LABEL_31;
      }
      *(void *)((char *)v6 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v22;
      uint64_t v24 = 8 * v22;
      *(void *)(v6[6] + v24) = v19;
      *(void *)(v6[7] + v24) = v20;
      ++v6[2];
      if (v11) {
        goto LABEL_7;
      }
LABEL_8:
      if (__OFADD__(v7++, 1)) {
        goto LABEL_30;
      }
      if (v7 >= v12) {
        break;
      }
      unint64_t v16 = v8->u64[v7];
      if (!v16)
      {
        int64_t v17 = v7 + 1;
        if (v7 + 1 >= v12) {
          break;
        }
        unint64_t v16 = v8->u64[v17];
        if (!v16)
        {
          while (1)
          {
            int64_t v7 = v17 + 1;
            if (__OFADD__(v17, 1)) {
              break;
            }
            if (v7 >= v12) {
              goto LABEL_21;
            }
            unint64_t v16 = v8->u64[v7];
            ++v17;
            if (v16) {
              goto LABEL_17;
            }
          }
          __break(1u);
LABEL_30:
          __break(1u);
LABEL_31:
          swift_retain(v5->i64);
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for Int);
        }
        ++v7;
      }
LABEL_17:
      unint64_t v11 = (v16 - 1) & v16;
    }
LABEL_21:
    if (v28)
    {
      uint64_t v25 = 1 << v5[2].i8[0];
      if (v25 >= 64) {
        specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v25 + 63) >> 6, v5 + 4);
      }
      else {
        v8->i64[0] = -1 << v25;
      }
      v5[1].i64[0] = 0;
    }
    uint64_t result = swift_release((uint64_t)v5);
    uint64_t v3 = v27;
  }
  else
  {
    uint64_t result = swift_release((uint64_t)v5);
  }
  *uint64_t v3 = v6;
  return result;
}

unint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, char a2)
{
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v26 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_27;
  }
  uint64_t v25 = v2;
  uint64_t v5 = 1 << v4[2].i8[0];
  uint64_t v6 = v4 + 4;
  uint64_t v7 = -1;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  unint64_t v8 = v7 & v4[4].i64[0];
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  unint64_t result = (unint64_t)swift_retain(v4->i64);
  int64_t v11 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v12 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v13 = v12 | (v11 << 6);
      goto LABEL_20;
    }
    if (__OFADD__(v11++, 1)) {
      goto LABEL_29;
    }
    if (v11 >= v9) {
      break;
    }
    unint64_t v15 = v6->u64[v11];
    if (!v15)
    {
      int64_t v16 = v11 + 1;
      if (v11 + 1 >= v9) {
        break;
      }
      unint64_t v15 = v6->u64[v16];
      if (!v15)
      {
        while (1)
        {
          int64_t v11 = v16 + 1;
          if (__OFADD__(v16, 1)) {
            break;
          }
          if (v11 >= v9) {
            goto LABEL_22;
          }
          unint64_t v15 = v6->u64[v11];
          ++v16;
          if (v15) {
            goto LABEL_19;
          }
        }
        __break(1u);
LABEL_29:
        __break(1u);
        return result;
      }
      ++v11;
    }
LABEL_19:
    unint64_t v8 = (v15 - 1) & v15;
    unint64_t v13 = __clz(__rbit64(v15)) + (v11 << 6);
LABEL_20:
    uint64_t v17 = 16 * v13;
    uint64_t v18 = (unint64_t *)(v4[3].i64[0] + v17);
    unint64_t v20 = *v18;
    unint64_t v19 = v18[1];
    uint64_t v21 = (uint64_t *)(v4[3].i64[1] + v17);
    uint64_t v23 = *v21;
    unint64_t v22 = v21[1];
    if ((a2 & 1) == 0)
    {
      swift_bridgeObjectRetain(v18[1]);
      swift_bridgeObjectRetain(v22);
    }
    unint64_t result = specialized _NativeDictionary._unsafeInsertNew(key:value:)(v20, v19, v23, v22, v26);
  }
LABEL_22:
  swift_release((uint64_t)v4);
  uint64_t v2 = v25;
  if (a2)
  {
    uint64_t v24 = 1 << v4[2].i8[0];
    if (v24 > 63) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v24 + 63) >> 6, v4 + 4);
    }
    else {
      v6->i64[0] = -1 << v24;
    }
    v4[1].i64[0] = 0;
  }
LABEL_27:
  unint64_t result = swift_release((uint64_t)v4);
  void *v2 = v26;
  return result;
}

{
  int64x2_t **v2;
  int64x2_t *v4;
  uint64_t v5;
  int64x2_t *v6;
  uint64_t v7;
  unint64_t v8;
  int64_t v9;
  unint64_t result;
  int64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v15;
  int64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int64x2_t *v22;

  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  unint64_t v22 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_27;
  }
  uint64_t v5 = 1 << v4[2].i8[0];
  uint64_t v6 = v4 + 4;
  uint64_t v7 = -1;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  unint64_t v8 = v7 & v4[4].i64[0];
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  unint64_t result = (unint64_t)swift_retain(v4->i64);
  int64_t v11 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v12 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v13 = v12 | (v11 << 6);
      goto LABEL_20;
    }
    if (__OFADD__(v11++, 1)) {
      goto LABEL_29;
    }
    if (v11 >= v9) {
      break;
    }
    unint64_t v15 = v6->u64[v11];
    if (!v15)
    {
      int64_t v16 = v11 + 1;
      if (v11 + 1 >= v9) {
        break;
      }
      unint64_t v15 = v6->u64[v16];
      if (!v15)
      {
        while (1)
        {
          int64_t v11 = v16 + 1;
          if (__OFADD__(v16, 1)) {
            break;
          }
          if (v11 >= v9) {
            goto LABEL_22;
          }
          unint64_t v15 = v6->u64[v11];
          ++v16;
          if (v15) {
            goto LABEL_19;
          }
        }
        __break(1u);
LABEL_29:
        __break(1u);
        return result;
      }
      ++v11;
    }
LABEL_19:
    unint64_t v8 = (v15 - 1) & v15;
    unint64_t v13 = __clz(__rbit64(v15)) + (v11 << 6);
LABEL_20:
    uint64_t v17 = (unint64_t *)(v4[3].i64[0] + 16 * v13);
    unint64_t v19 = *v17;
    uint64_t v18 = v17[1];
    unint64_t v20 = *(void *)(v4[3].i64[1] + 8 * v13);
    if ((a2 & 1) == 0) {
      swift_bridgeObjectRetain(v17[1]);
    }
    unint64_t result = specialized _NativeDictionary._unsafeInsertNew(key:value:)(v19, v18, v20, v22);
  }
LABEL_22:
  swift_release((uint64_t)v4);
  if (a2)
  {
    uint64_t v21 = 1 << v4[2].i8[0];
    if (v21 > 63) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v21 + 63) >> 6, v4 + 4);
    }
    else {
      v6->i64[0] = -1 << v21;
    }
    v4[1].i64[0] = 0;
  }
LABEL_27:
  unint64_t result = swift_release((uint64_t)v4);
  void *v2 = v22;
  return result;
}

void specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, char a2)
{
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v5 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_29;
  }
  uint64_t v6 = 1 << v4[2].i8[0];
  uint64_t v7 = v4 + 4;
  uint64_t v8 = -1;
  if (v6 < 64) {
    uint64_t v8 = ~(-1 << v6);
  }
  unint64_t v9 = v8 & v4[4].i64[0];
  int64_t v10 = (unint64_t)(v6 + 63) >> 6;
  swift_retain(v4->i64);
  int64_t v11 = 0;
  while (1)
  {
    if (v9)
    {
      unint64_t v12 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      unint64_t v13 = v12 | (v11 << 6);
      goto LABEL_21;
    }
    if (__OFADD__(v11++, 1)) {
      goto LABEL_31;
    }
    if (v11 >= v10) {
      break;
    }
    unint64_t v15 = v7->u64[v11];
    if (!v15)
    {
      int64_t v16 = v11 + 1;
      if (v11 + 1 >= v10) {
        break;
      }
      unint64_t v15 = v7->u64[v16];
      if (!v15)
      {
        while (1)
        {
          int64_t v11 = v16 + 1;
          if (__OFADD__(v16, 1)) {
            break;
          }
          if (v11 >= v10) {
            goto LABEL_23;
          }
          unint64_t v15 = v7->u64[v11];
          ++v16;
          if (v15) {
            goto LABEL_20;
          }
        }
        __break(1u);
LABEL_31:
        __break(1u);
        return;
      }
      ++v11;
    }
LABEL_20:
    unint64_t v9 = (v15 - 1) & v15;
    unint64_t v13 = __clz(__rbit64(v15)) + (v11 << 6);
LABEL_21:
    uint64_t v17 = (unint64_t *)(v4[3].i64[0] + 16 * v13);
    unint64_t v18 = *v17;
    unint64_t v19 = v17[1];
    uint64_t v20 = v4[3].i64[1] + 40 * v13;
    if (a2)
    {
      long long v21 = *(_OWORD *)v20;
      long long v22 = *(_OWORD *)(v20 + 16);
      uint64_t v25 = *(void *)(v20 + 32);
      v24[0] = v21;
      v24[1] = v22;
    }
    else
    {
      outlined init with copy of AnyHashable(v20, (uint64_t)v24);
      swift_bridgeObjectRetain(v19);
    }
    specialized _NativeDictionary._unsafeInsertNew(key:value:)(v18, v19, (uint64_t)v24, v5);
  }
LABEL_23:
  swift_release((uint64_t)v4);
  if (a2)
  {
    uint64_t v23 = 1 << v4[2].i8[0];
    if (v23 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v23 + 63) >> 6, v4 + 4);
    }
    else {
      v7->i64[0] = -1 << v23;
    }
    v4[1].i64[0] = 0;
  }
LABEL_29:
  swift_release((uint64_t)v4);
  void *v2 = v5;
}

{
  int64x2_t **v2;
  int64x2_t *v4;
  int64x2_t *v5;
  uint64_t v6;
  int64x2_t *v7;
  uint64_t v8;
  unint64_t v9;
  int64_t v10;
  int64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v18;
  int64_t v19;
  uint64_t v20;
  long long v21;
  long long v22;
  uint64_t *v23;
  uint64_t v24;
  _OWORD v25[2];
  uint64_t v26;

  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v5 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_29;
  }
  uint64_t v6 = 1 << v4[2].i8[0];
  uint64_t v7 = v4 + 4;
  uint64_t v8 = -1;
  if (v6 < 64) {
    uint64_t v8 = ~(-1 << v6);
  }
  unint64_t v9 = v8 & v4[4].i64[0];
  int64_t v10 = (unint64_t)(v6 + 63) >> 6;
  swift_retain(v4->i64);
  int64_t v11 = 0;
  while (1)
  {
    if (v9)
    {
      unint64_t v15 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      int64_t v16 = v15 | (v11 << 6);
      goto LABEL_21;
    }
    if (__OFADD__(v11++, 1)) {
      goto LABEL_31;
    }
    if (v11 >= v10) {
      break;
    }
    unint64_t v18 = v7->u64[v11];
    if (!v18)
    {
      unint64_t v19 = v11 + 1;
      if (v11 + 1 >= v10) {
        break;
      }
      unint64_t v18 = v7->u64[v19];
      if (!v18)
      {
        while (1)
        {
          int64_t v11 = v19 + 1;
          if (__OFADD__(v19, 1)) {
            break;
          }
          if (v11 >= v10) {
            goto LABEL_23;
          }
          unint64_t v18 = v7->u64[v11];
          ++v19;
          if (v18) {
            goto LABEL_20;
          }
        }
        __break(1u);
LABEL_31:
        __break(1u);
        return;
      }
      ++v11;
    }
LABEL_20:
    unint64_t v9 = (v18 - 1) & v18;
    int64_t v16 = __clz(__rbit64(v18)) + (v11 << 6);
LABEL_21:
    uint64_t v20 = v4[3].i64[0] + 40 * v16;
    if (a2)
    {
      long long v21 = *(_OWORD *)v20;
      long long v22 = *(_OWORD *)(v20 + 16);
      uint64_t v26 = *(void *)(v20 + 32);
      v25[0] = v21;
      v25[1] = v22;
      uint64_t v23 = (uint64_t *)(v4[3].i64[1] + 16 * v16);
      unint64_t v13 = *v23;
      uint64_t v14 = v23[1];
    }
    else
    {
      outlined init with copy of AnyHashable(v20, (uint64_t)v25);
      unint64_t v12 = (uint64_t *)(v4[3].i64[1] + 16 * v16);
      unint64_t v13 = *v12;
      uint64_t v14 = v12[1];
      swift_bridgeObjectRetain(v14);
    }
    specialized _NativeDictionary._unsafeInsertNew(key:value:)((uint64_t)v25, v13, v14, v5);
  }
LABEL_23:
  swift_release((uint64_t)v4);
  if (a2)
  {
    uint64_t v24 = 1 << v4[2].i8[0];
    if (v24 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v24 + 63) >> 6, v4 + 4);
    }
    else {
      v7->i64[0] = -1 << v24;
    }
    v4[1].i64[0] = 0;
  }
LABEL_29:
  swift_release((uint64_t)v4);
  void *v2 = v5;
}

uint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, int a2, uint64_t a3)
{
  int v54 = a2;
  unint64_t v4 = *(void *)(a3 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  unint64_t v9 = (char *)&v43 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v3;
  if (*(void *)(*v3 + 24) > v6) {
    uint64_t v6 = *(void *)(*v3 + 24);
  }
  uint64_t v11 = *(void *)(v7 + 32);
  uint64_t v12 = specialized static _DictionaryStorage.allocate(capacity:)(v6, v4, v11);
  uint64_t v13 = v12;
  if (!*(void *)(v10 + 16)) {
    goto LABEL_30;
  }
  uint64_t v50 = v9;
  char v14 = *(unsigned char *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 64);
  uint64_t v46 = (int64x2_t *)(v10 + 64);
  uint64_t v16 = 1 << v14;
  uint64_t v17 = -1;
  if (v16 < 64) {
    uint64_t v17 = ~(-1 << v16);
  }
  unint64_t v18 = v17 & v15;
  uint64_t v44 = v3;
  int64_t v45 = (unint64_t)(v16 + 63) >> 6;
  unsigned int v55 = (void (**)(char *, unint64_t, unint64_t))(v5 + 32);
  uint64_t v51 = v11 + 32;
  uint64_t v52 = v11;
  unint64_t v53 = (void *)v12;
  uint64_t v47 = (void (**)(char *, unint64_t, unint64_t))(v5 + 16);
  uint64_t v48 = v12 + 64;
  swift_retain((atomic_ullong *)v10);
  int64_t v19 = 0;
  uint64_t v49 = v5;
  uint64_t v20 = v52;
  if (!v18) {
    goto LABEL_8;
  }
LABEL_7:
  unint64_t v21 = __clz(__rbit64(v18));
  uint64_t v22 = (v18 - 1) & v18;
  for (unint64_t i = v21 | (v19 << 6); ; unint64_t i = __clz(__rbit64(v26)) + (v19 << 6))
  {
    uint64_t v28 = *(void *)(v5 + 72);
    unint64_t v29 = *(void *)(v10 + 48) + v28 * i;
    unint64_t v56 = v22;
    uint64_t v30 = (uint64_t)v50;
    if (v54) {
      (*v55)(v50, v29, v4);
    }
    else {
      (*v47)(v50, v29, v4);
    }
    uint64_t v31 = v10;
    uint64_t v32 = *(void *)(v10 + 56) + 16 * i;
    char v33 = *(unsigned char *)(v32 + 8);
    uint64_t v34 = *(void *)v32;
    uint64_t v35 = v53;
    uint64_t v36 = (*(uint64_t (**)(void, unint64_t, uint64_t))(v20 + 32))(v53[5], v4, v20);
    unint64_t v37 = __RawDictionaryStorage.find<A>(_:hashValue:)(v30, v36, v4);
    if (v38) {
      goto LABEL_34;
    }
    unint64_t v39 = v37;
    *(void *)(v48 + ((v37 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v37;
    (*v55)((char *)(v35[6] + v28 * v37), v30, v4);
    uint64_t v40 = v35[7] + 16 * v39;
    *(void *)uint64_t v40 = v34;
    *(unsigned char *)(v40 + 8) = v33;
    ++v35[2];
    uint64_t v10 = v31;
    uint64_t v5 = v49;
    unint64_t v18 = v56;
    if (v56) {
      goto LABEL_7;
    }
LABEL_8:
    if (__OFADD__(v19++, 1)) {
      goto LABEL_33;
    }
    uint64_t v25 = v46;
    if (v19 >= v45) {
      break;
    }
    unint64_t v26 = v46->u64[v19];
    if (!v26)
    {
      int64_t v27 = v19 + 1;
      if (v19 + 1 >= v45) {
        break;
      }
      unint64_t v26 = v46->u64[v27];
      if (!v26)
      {
        while (1)
        {
          int64_t v19 = v27 + 1;
          if (__OFADD__(v27, 1)) {
            break;
          }
          if (v19 >= v45) {
            goto LABEL_24;
          }
          unint64_t v26 = v46->u64[v19];
          ++v27;
          if (v26) {
            goto LABEL_17;
          }
        }
        __break(1u);
LABEL_33:
        __break(1u);
LABEL_34:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v4);
      }
      ++v19;
    }
LABEL_17:
    uint64_t v22 = (v26 - 1) & v26;
  }
LABEL_24:
  swift_release(v10);
  if (v54)
  {
    uint64_t v41 = 1 << *(unsigned char *)(v10 + 32);
    uint64_t v3 = v44;
    uint64_t v13 = (uint64_t)v53;
    if (v41 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v41 + 63) >> 6, v25);
    }
    else {
      v25->i64[0] = -1 << v41;
    }
    *(void *)(v10 + 16) = 0;
LABEL_30:
    uint64_t result = swift_release(v10);
    goto LABEL_31;
  }
  uint64_t result = swift_release(v10);
  uint64_t v3 = v44;
  uint64_t v13 = (uint64_t)v53;
LABEL_31:
  *uint64_t v3 = v13;
  return result;
}

Swift::Void __swiftcall _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(Swift::Int capacity, Swift::Bool moveElements)
{
  BOOL v50 = moveElements;
  uint64_t v4 = *(void *)(*(void *)(v2 + 24) - 8);
  uint64_t v5 = MEMORY[0x1F4188790](capacity);
  uint64_t v52 = (char *)&v40 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v8 = *(void *)(v7 + 16);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v5);
  char v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *v3;
  if (*(void *)(*v3 + 24) > v10) {
    uint64_t v10 = *(void *)(*v3 + 24);
  }
  uint64_t v16 = *(void *)(v11 + 32);
  uint64_t v53 = v12;
  uint64_t v17 = specialized static _DictionaryStorage.resize(original:capacity:move:)(v10, v8, v12, v16);
  unint64_t v18 = (void *)v17;
  if (!*(void *)(v15 + 16)) {
    goto LABEL_27;
  }
  uint64_t v19 = 1 << *(unsigned char *)(v15 + 32);
  uint64_t v20 = *(void *)(v15 + 64);
  uint64_t v42 = (int64x2_t *)(v15 + 64);
  uint64_t v21 = -1;
  if (v19 < 64) {
    uint64_t v21 = ~(-1 << v19);
  }
  unint64_t v22 = v21 & v20;
  uint64_t v40 = v3;
  int64_t v41 = (unint64_t)(v19 + 63) >> 6;
  uint64_t v43 = v4 + 16;
  uint64_t v44 = (void (**)(char *, unint64_t, unint64_t))(v9 + 16);
  uint64_t v48 = v9;
  uint64_t v49 = v4;
  uint64_t v23 = (void (**)(char *, unint64_t, unint64_t))(v9 + 32);
  uint64_t v51 = (void (**)(unint64_t, char *, uint64_t))(v4 + 32);
  uint64_t v47 = v16 + 32;
  uint64_t v45 = v17 + 64;
  swift_retain((atomic_ullong *)v15);
  int64_t v24 = 0;
  uint64_t v46 = v15;
  if (!v22) {
    goto LABEL_8;
  }
LABEL_7:
  unint64_t v25 = __clz(__rbit64(v22));
  v22 &= v22 - 1;
  for (unint64_t i = v25 | (v24 << 6); ; unint64_t i = __clz(__rbit64(v29)) + (v24 << 6))
  {
    uint64_t v30 = *(void *)(v48 + 72);
    unint64_t v31 = *(void *)(v15 + 48) + v30 * i;
    if (v50)
    {
      (*v23)(v14, v31, v8);
      uint64_t v32 = *(void *)(v15 + 56);
      uint64_t v33 = *(void *)(v49 + 72);
      (*(void (**)(char *, unint64_t, uint64_t))(v49 + 32))(v52, v32 + v33 * i, v53);
    }
    else
    {
      (*v44)(v14, v31, v8);
      uint64_t v34 = *(void *)(v15 + 56);
      uint64_t v33 = *(void *)(v49 + 72);
      (*(void (**)(char *, unint64_t, uint64_t))(v49 + 16))(v52, v34 + v33 * i, v53);
    }
    uint64_t v35 = (*(uint64_t (**)(void, unint64_t, uint64_t))(v16 + 32))(v18[5], v8, v16);
    unint64_t v36 = __RawDictionaryStorage.find<A>(_:hashValue:)((uint64_t)v14, v35, v8);
    if (v37) {
      goto LABEL_31;
    }
    unint64_t v38 = v36;
    *(void *)(v45 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v36;
    (*v23)((char *)(v18[6] + v30 * v36), (unint64_t)v14, v8);
    (*v51)(v18[7] + v33 * v38, v52, v53);
    ++v18[2];
    uint64_t v15 = v46;
    if (v22) {
      goto LABEL_7;
    }
LABEL_8:
    int64_t v27 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      goto LABEL_30;
    }
    uint64_t v28 = v42;
    if (v27 >= v41) {
      break;
    }
    unint64_t v29 = v42->u64[v27];
    ++v24;
    if (!v29)
    {
      while (1)
      {
        int64_t v24 = v27 + 1;
        if (__OFADD__(v27, 1)) {
          break;
        }
        if (v24 >= v41) {
          goto LABEL_21;
        }
        unint64_t v29 = v42->u64[v24];
        ++v27;
        if (v29) {
          goto LABEL_14;
        }
      }
      __break(1u);
LABEL_30:
      __break(1u);
LABEL_31:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v8);
    }
LABEL_14:
    unint64_t v22 = (v29 - 1) & v29;
  }
LABEL_21:
  swift_release(v15);
  if (v50)
  {
    uint64_t v39 = 1 << *(unsigned char *)(v15 + 32);
    uint64_t v3 = v40;
    if (v39 > 63) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v39 + 63) >> 6, v28);
    }
    else {
      v28->i64[0] = -1 << v39;
    }
    *(void *)(v15 + 16) = 0;
LABEL_27:
    swift_release(v15);
    goto LABEL_28;
  }
  swift_release(v15);
  uint64_t v3 = v40;
LABEL_28:
  *uint64_t v3 = (uint64_t)v18;
}

Swift::Void __swiftcall _NativeDictionary.resize(capacity:)(Swift::Int capacity)
{
}

Swift::Void __swiftcall _NativeDictionary.copyAndResize(capacity:)(Swift::Int capacity)
{
}

uint64_t specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(char a1, uint64_t a2)
{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(a1, a2, (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:), (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(a1, a2, (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:), (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(a1, a2, (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:), (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(a1, a2, (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:), (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(a1, a2, (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:), (void (*)(void))specialized _NativeDictionary.copy());
}

uint64_t specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(char a1, uint64_t a2, void (*a3)(uint64_t, uint64_t), void (*a4)(void))
{
  uint64_t v5 = *(void *)(*(void *)v4 + 24);
  if (v5 >= a2 && (a1 & 1) != 0) {
    return 0;
  }
  if (a1)
  {
    uint64_t v6 = 1;
    a3(a2, 1);
  }
  else if (v5 < a2)
  {
    a3(a2, 0);
    return 1;
  }
  else
  {
    a4();
    return 0;
  }
  return v6;
}

Swift::Bool __swiftcall _NativeDictionary.ensureUnique(isUnique:capacity:)(Swift::Bool isUnique, Swift::Int capacity)
{
  Swift::Int v4 = *(void *)(*(void *)v2 + 24);
  if (v4 >= capacity)
  {
    if (!isUnique) {
      _NativeDictionary.copy()();
    }
  }
  else
  {
    if (isUnique)
    {
      Swift::Int v5 = capacity;
      Swift::Bool v6 = 1;
    }
    else
    {
      Swift::Int v5 = capacity;
      Swift::Bool v6 = 0;
    }
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v5, v6);
  }
  return v4 < capacity;
}

Swift::_HashTable::Bucket __swiftcall _NativeDictionary.validatedBucket(for:)(Swift::_HashTable::Index a1)
{
  if (a1.bucket.offset < 0
    || 1 << *(unsigned char *)(v1 + 32) <= a1.bucket.offset
    || ((*(void *)(v1 + 8 * ((unint64_t)a1.bucket.offset >> 6) + 64) >> SLOBYTE(a1.bucket.offset)) & 1) == 0
    || *(_DWORD *)(v1 + 36) != a1.age)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/NativeDictionary.swift", 28, 2, 0x119uLL, 0);
  }
  return a1.bucket;
}

uint64_t _NativeDictionary.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  if (*(void *)(a2 + 16) && (unint64_t v9 = __RawDictionaryStorage.find<A>(_:)(a1, a3, a5), (v10 & 1) != 0))
  {
    uint64_t v15 = *(void *)(a4 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v15 + 16))(a6, *(void *)(a2 + 56) + *(void *)(v15 + 72) * v9, a4);
    uint64_t v11 = v15;
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v11 = *(void *)(a4 - 8);
    uint64_t v12 = 1;
  }
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 56);

  return v13(a6, v12, 1, a4);
}

void $defer #1 <A, B>() in _NativeDictionary.subscript.modify(uint64_t a1, int a2, void **a3, unint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7, uint64_t a8)
{
  v32[0] = a5;
  v32[1] = a8;
  unint64_t v34 = a4;
  uint64_t v35 = a3;
  int v36 = a2;
  uint64_t v33 = *(a6 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)v32 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = type metadata accessor for Optional(0, v15, v13, v14);
  uint64_t v17 = (uint64_t)*(v16 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)v32 - v19;
  uint64_t v21 = *(void *)(a7 - 8);
  uint64_t v22 = MEMORY[0x1F4188790](v18);
  int64_t v24 = (char *)v32 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v22);
  unint64_t v26 = (char *)v32 - v25;
  (*(void (**)(char *, uint64_t, Class *))(v17 + 16))(v20, a1, v16);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v21 + 48))(v20, 1, a7) == 1)
  {
    int64_t v27 = v35;
    (*(void (**)(char *, Class *))(v17 + 8))(v20, v16);
    if (v36)
    {
      uint64_t v28 = (*v27)[6];
      v29.offset = v34;
      swift_arrayDestroy(v28 + *(void *)(v33 + 72) * v34, 1, a6);
      _NativeDictionary._delete(at:)(v29);
    }
  }
  else
  {
    uint64_t v30 = *(void (**)(char *, char *, uint64_t))(v21 + 32);
    v30(v26, v20, a7);
    unint64_t v31 = *v35;
    if (v36)
    {
      v30((char *)(v31[7] + *(void *)(v21 + 72) * v34), v26, a7);
    }
    else
    {
      (*(void (**)(char *, void, unint64_t *))(v33 + 16))(v12, v32[0], a6);
      v30(v24, v26, a7);
      _NativeDictionary._insert(at:key:value:)(v34, (uint64_t)v12, (uint64_t)v24, v31, (uint64_t)a6, a7);
    }
  }
}

uint64_t key path getter for _NativeDictionary.subscript(_:isUnique:) : <A, B>_NativeDictionary<A, B>AB@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = *(void *)(a3 + a2 - 16);
  uint64_t v6 = *a1;
  if (*(void *)(*a1 + 16)
    && (unint64_t v7 = __RawDictionaryStorage.find<A>(_:)(a2, *(void *)(a3 + a2 - 24), *(void *)(a3 + a2 - 8)), (v8 & 1) != 0))
  {
    uint64_t v13 = *(void *)(v5 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v13 + 16))(a4, *(void *)(v6 + 56) + *(void *)(v13 + 72) * v7, v5);
    uint64_t v9 = v13;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = *(void *)(v5 - 8);
    uint64_t v10 = 1;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);

  return v11(a4, v10, 1, v5);
}

uint64_t key path setter for _NativeDictionary.subscript(_:isUnique:) : <A, B>_NativeDictionary<A, B>AB(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = a1;
  uint64_t v6 = *(unint64_t **)(a4 + a3 - 24);
  uint64_t v7 = *(void *)(a4 + a3 - 16);
  uint64_t v8 = *(void *)(a4 + a3 - 8);
  unint64_t v38 = type metadata accessor for Optional(0, v7, a3, a4);
  uint64_t v9 = (uint64_t)*(v38 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v38);
  uint64_t v12 = &v33[-v11];
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = &v33[-v13];
  uint64_t v36 = v15;
  (*(void (**)(unsigned char *, uint64_t, unint64_t *))(v15 + 16))(&v33[-v13], a3, v6);
  char v16 = *(unsigned char *)(a3
                 + *((int *)swift_getTupleTypeMetadata2(0, (uint64_t)v6, (uint64_t)&type metadata for Bool, 0, 0)
                   + 12));
  uint64_t v17 = *a2;
  unint64_t v18 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)v6, v8);
  uint64_t v20 = *(void *)(v17 + 16);
  BOOL v21 = (v19 & 1) == 0;
  Swift::Int v22 = v20 + v21;
  if (__OFADD__(v20, v21))
  {
    __break(1u);
    goto LABEL_10;
  }
  int v23 = v19;
  uint64_t v35 = v9;
  unint64_t v24 = v18;
  uint64_t v39 = v8;
  type metadata accessor for _NativeDictionary(0, (uint64_t)v6, v7, v8);
  if (!_NativeDictionary.ensureUnique(isUnique:capacity:)(v16, v22)) {
    goto LABEL_5;
  }
  unint64_t v25 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)v6, v39);
  if ((v23 & 1) != (v26 & 1)) {
LABEL_10:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v6);
  unint64_t v24 = v25;
LABEL_5:
  int v34 = v23;
  uint64_t v27 = *(void *)(v7 - 8);
  if (v23)
  {
    (*(void (**)(unsigned char *, unint64_t, uint64_t))(*(void *)(v7 - 8) + 32))(v12, *(void *)(*a2 + 56) + *(void *)(*(void *)(v7 - 8) + 72) * v24, v7);
    uint64_t v28 = 0;
  }
  else
  {
    uint64_t v28 = 1;
  }
  (*(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v27 + 56))(v12, v28, 1, v7);
  uint64_t v29 = v35;
  uint64_t v30 = *(void (**)(unsigned char *, Class *))(v35 + 8);
  unint64_t v31 = v38;
  v30(v12, v38);
  (*(void (**)(unsigned char *, uint64_t, Class *))(v29 + 16))(v12, v37, v31);
  $defer #1 <A, B>() in _NativeDictionary.subscript.modify((uint64_t)v12, v34 & 1, (void **)a2, v24, (uint64_t)v14, v6, v7, v39);
  v30(v12, v31);
  return (*(uint64_t (**)(unsigned char *, unint64_t *))(v36 + 8))(v14, v6);
}

uint64_t _NativeDictionary.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = (void **)v4;
  char v7 = a3;
  uint64_t v35 = a1;
  uint64_t v9 = a4[3];
  int v34 = type metadata accessor for Optional(0, v9, a3, (uint64_t)a4);
  uint64_t v10 = (uint64_t)*(v34 - 1);
  MEMORY[0x1F4188790](v34);
  uint64_t v12 = (char *)&v33 - v11;
  uint64_t v13 = (void *)*v4;
  uint64_t v14 = (unint64_t *)a4[2];
  uint64_t v36 = a4[4];
  unint64_t v16 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v14, v36);
  uint64_t v17 = v13[2];
  BOOL v18 = (v15 & 1) == 0;
  Swift::Int v19 = v17 + v18;
  if (__OFADD__(v17, v18))
  {
    __break(1u);
    goto LABEL_14;
  }
  char v20 = v15;
  Swift::Int v21 = v13[3];
  if (v21 >= v19 && (v7 & 1) != 0) {
    goto LABEL_9;
  }
  if (v21 >= v19 && (v7 & 1) == 0)
  {
    unint64_t v22 = v16;
    _NativeDictionary.copy()();
    unint64_t v16 = v22;
    goto LABEL_9;
  }
  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v19, v7 & 1);
  unint64_t v23 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v14, v36);
  if ((v20 & 1) != (v24 & 1)) {
LABEL_14:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v14);
  unint64_t v16 = v23;
LABEL_9:
  char v26 = v34;
  uint64_t v25 = v35;
  uint64_t v35 = a2;
  if (v20)
  {
    uint64_t v27 = *(void *)(v9 - 8);
    unint64_t v28 = v16;
    (*(void (**)(char *, unint64_t, uint64_t))(v27 + 32))(v12, (*v5)[7] + *(void *)(v27 + 72) * v16, v9);
    (*(void (**)(char *, void, uint64_t, uint64_t))(v27 + 56))(v12, 0, 1, v9);
  }
  else
  {
    unint64_t v28 = v16;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 56))(v12, 1, 1, v9);
  }
  uint64_t v29 = *(void (**)(char *, Class *))(v10 + 8);
  v29(v12, v26);
  unint64_t v30 = v28;
  uint64_t v31 = v35;
  $defer #1 <A, B>() in _NativeDictionary.subscript.modify(v25, v20 & 1, v5, v30, v35, v14, v9, v36);
  (*(void (**)(uint64_t, unint64_t *))(*(v14 - 1) + 8))(v31, v14);
  return ((uint64_t (*)(uint64_t, Class *))v29)(v25, v26);
}

void KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(unint64_t a1)
{
  uint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(196);
  uint64_t v4 = v2;
  uint64_t v5 = v3;
  uint64_t v200 = v2;
  unint64_t v201 = v3;
  uint64_t v6 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v7 = v2 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = "Duplicate keys of type '";
  if (!v7 && (v2 & ~v3 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v3);
    unint64_t v9 = 0x80000001816DEC10 | 0x8000000000000000;
    uint64_t v200 = 0xD000000000000018;
LABEL_59:
    unint64_t v201 = v9;
    goto LABEL_60;
  }
  if ((v3 & 0x2000000000000000) != 0 && (0x80000001816DEC10 & 0x2000000000000000) != 0)
  {
    unint64_t v10 = v6 + ((0x80000001816DEC10 >> 56) & 0xF);
    if (v10 <= 0xF)
    {
      unint64_t v49 = (0x80000001816DEC10 >> 56) & 0xF;
      if (v49)
      {
        char v51 = 0;
        uint64_t v52 = 0;
        unint64_t v50 = v3;
        do
        {
          uint64_t v53 = v6 + v52;
          uint64_t v54 = v52 + 1;
          unint64_t v55 = 0x80000001816DEC10 | 0x8000000000000000;
          if (v52 < 8) {
            unint64_t v55 = 0xD000000000000018;
          }
          unint64_t v56 = v55 >> (v51 & 0x38);
          char v57 = (8 * v6 + v51) & 0x38;
          uint64_t v58 = (-255 << v57) - 1;
          unint64_t v59 = (unint64_t)v56 << v57;
          unint64_t v60 = v59 | v58 & v50;
          unint64_t v61 = v59 | v58 & v4;
          if (v53 < 8) {
            uint64_t v4 = v61;
          }
          else {
            unint64_t v50 = v60;
          }
          v51 += 8;
          uint64_t v52 = v54;
        }
        while (v49 != v54);
      }
      else
      {
        unint64_t v50 = v3;
      }
      swift_bridgeObjectRelease(v3);
      swift_bridgeObjectRelease(0x80000001816DEC10 | 0x8000000000000000);
      unint64_t v62 = 0xA000000000000000;
      if (!(v4 & 0x8080808080808080 | v50 & 0x80808080808080)) {
        unint64_t v62 = 0xE000000000000000;
      }
      unint64_t v9 = v62 & 0xFF00000000000000 | (v10 << 56) | v50 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_58;
    }
  }
  uint64_t v11 = 0x80000001816DEC10 | 0x8000000000000000;
  if ((0x80000001816DEC10 & 0x2000000000000000) != 0) {
    uint64_t v12 = (0x80000001816DEC10 >> 56) & 0xF;
  }
  else {
    uint64_t v12 = 24;
  }
  swift_bridgeObjectRetain_n(0x80000001816DEC10 | 0x8000000000000000, 2);
  if ((0x80000001816DEC10 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain_n(0x80000001816DEC10 | 0x8000000000000000, 5);
    v181._Swift::UInt64 rawBits = 1;
    v182._Swift::UInt64 rawBits = (v12 << 16) | 1;
    v183._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v181, v182, 0xD000000000000018, 0x80000001816DEC10 | 0x8000000000000000);
    if (v183._rawBits < 0x10000) {
      v183._rawBits |= 3;
    }
    uint64_t v13 = specialized Collection.count.getter(v183, v184, 0xD000000000000018, 0x80000001816DEC10 | 0x8000000000000000);
    swift_bridgeObjectRelease(0x80000001816DEC10 | 0x8000000000000000);
    if ((v5 & 0x1000000000000000) == 0)
    {
LABEL_15:
      BOOL v14 = __OFADD__(v7, v13);
      int64_t v15 = v7 + v13;
      if (!v14) {
        goto LABEL_16;
      }
      goto LABEL_185;
    }
  }
  else
  {
    swift_bridgeObjectRetain_n(0x80000001816DEC10 | 0x8000000000000000, 4);
    uint64_t v13 = v12;
    if ((v5 & 0x1000000000000000) == 0) {
      goto LABEL_15;
    }
  }
  Swift::Int v185 = String.UTF8View._foreignCount()();
  int64_t v15 = v185 + v13;
  if (!__OFADD__(v185, v13))
  {
LABEL_16:
    if ((v4 & ~v5 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v16 = _StringGuts.nativeUnusedCapacity.getter(v4, v5);
      if (v17) {
        goto LABEL_160;
      }
      if (v15 > 15 || (v5 & 0x2000000000000000) == 0 && v16 >= v13)
      {
LABEL_22:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v15, v13);
        if ((0x80000001816DEC10 & 0x1000000000000000) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(0xD000000000000018, 0x80000001816DEC10 | 0x8000000000000000, 0, v12);
          unint64_t v21 = 0x80000001816DEC10 | 0x8000000000000000;
        }
        else
        {
          char v18 = (0x80000001816DEC10 & 0x2000000000000000) == 0 || (0x80000001816DEC10 & 0x4000000000000000) != 0;
          swift_bridgeObjectRelease_n(0x80000001816DEC10 | 0x8000000000000000, 5);
          if ((0x80000001816DEC10 & 0x2000000000000000) != 0)
          {
            swift_bridgeObjectRelease(0x80000001816DEC10 | 0x8000000000000000);
            unint64_t v198 = 0xD000000000000018;
            unint64_t v199 = 0x80000001816DEC10 & 0xFFFFFFFFFFFFFFLL;
            unint64_t v114 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v12, (uint64_t)&v198, (0x80000001816DEC10 >> 56) & 0xF);
            _StringGuts.appendInPlace(_:isASCII:)(v114, v115, v18);
            swift_bridgeObjectRelease(0x80000001816DEC10 | 0x8000000000000000);
LABEL_60:
            TypeName = (uint64_t *)swift_getTypeName((Class *)a1, 0);
            if (v64 < 0) {
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
            }
            uint64_t v65 = (uint8x16_t *)TypeName;
            int64_t v66 = v64;
            int64_t v67 = validateUTF8(_:)(TypeName, v64);
            if (v69) {
              uint64_t v70 = repairUTF8(_:firstKnownBrokenRange:)(v65->i8, v66, v67, v68);
            }
            else {
              uint64_t v70 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v65, v66, v67 & 1);
            }
            uint64_t v4 = v70;
            a1 = v71;
            uint64_t v5 = v200;
            int64_t v15 = v201;
            unint64_t v72 = HIBYTE(v201) & 0xF;
            if ((v201 & 0x2000000000000000) != 0) {
              uint64_t v8 = (const char *)(HIBYTE(v201) & 0xF);
            }
            else {
              uint64_t v8 = (const char *)(v200 & 0xFFFFFFFFFFFFLL);
            }
            if (!v8 && (v200 & ~v201 & 0x2000000000000000) == 0)
            {
              swift_bridgeObjectRelease(v201);
              uint64_t v200 = v4;
              unint64_t v201 = a1;
              goto LABEL_126;
            }
            uint64_t v13 = v71 & 0x2000000000000000;
            uint64_t v12 = HIBYTE(v71) & 0xF;
            if ((v201 & 0x2000000000000000) != 0 && v13)
            {
              unint64_t v73 = v72 + v12;
              if (v72 + v12 <= 0xF)
              {
                if (v12)
                {
                  char v118 = 0;
                  unint64_t v119 = 0;
                  unint64_t v113 = v201;
                  do
                  {
                    unint64_t v120 = v72 + v119;
                    unint64_t v121 = v119 + 1;
                    if (v119 >= 8) {
                      unint64_t v122 = v71;
                    }
                    else {
                      unint64_t v122 = v70;
                    }
                    unint64_t v123 = v122 >> (v118 & 0x38);
                    char v124 = (8 * v72 + v118) & 0x38;
                    uint64_t v125 = (-255 << v124) - 1;
                    unint64_t v126 = (unint64_t)v123 << v124;
                    unint64_t v127 = v126 | v125 & v113;
                    unint64_t v128 = v126 | v125 & v5;
                    if (v120 < 8) {
                      uint64_t v5 = v128;
                    }
                    else {
                      unint64_t v113 = v127;
                    }
                    v118 += 8;
                    unint64_t v119 = v121;
                  }
                  while (v12 != v121);
                }
                else
                {
                  unint64_t v113 = v201;
                }
                swift_bridgeObjectRelease(v201);
                swift_bridgeObjectRelease(a1);
                unint64_t v129 = 0xA000000000000000;
                if (!(v5 & 0x8080808080808080 | v113 & 0x80808080808080)) {
                  unint64_t v129 = 0xE000000000000000;
                }
                uint64_t v200 = v5;
                unint64_t v201 = v129 & 0xFF00000000000000 | (v73 << 56) | v113 & 0xFFFFFFFFFFFFFFLL;
                goto LABEL_126;
              }
              uint64_t v13 = 1;
            }
            uint64_t v197 = v70 & 0xFFFFFFFFFFFFLL;
            if (v13) {
              uint64_t v11 = HIBYTE(v71) & 0xF;
            }
            else {
              uint64_t v11 = v70 & 0xFFFFFFFFFFFFLL;
            }
            swift_bridgeObjectRetain_n(v71, 2);
            if ((a1 & 0x1000000000000000) == 0)
            {
              swift_bridgeObjectRetain_n(a1, 4);
              Swift::Int v74 = v11;
              if ((v15 & 0x1000000000000000) == 0) {
                goto LABEL_79;
              }
              goto LABEL_189;
            }
LABEL_186:
            swift_bridgeObjectRetain_n(a1, 5);
            v186._Swift::UInt64 rawBits = 1;
            v187._Swift::UInt64 rawBits = (v11 << 16) | 1;
            v188._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v186, v187, v4, a1);
            if (v188._rawBits < 0x10000) {
              v188._rawBits |= 3;
            }
            Swift::Int v74 = specialized Collection.count.getter(v188, v189, v4, a1);
            swift_bridgeObjectRelease(a1);
            if ((v15 & 0x1000000000000000) == 0)
            {
LABEL_79:
              BOOL v14 = __OFADD__(v8, v74);
              int64_t v75 = (int64_t)&v8[v74];
              if (!v14) {
                goto LABEL_80;
              }
              goto LABEL_191;
            }
LABEL_189:
            Swift::Int v190 = String.UTF8View._foreignCount()();
            int64_t v75 = v190 + v74;
            if (!__OFADD__(v190, v74))
            {
LABEL_80:
              if ((v5 & ~v15 & 0x2000000000000000) != 0
                && swift_isUniquelyReferenced_nonNull_native(v15 & 0xFFFFFFFFFFFFFFFLL))
              {
                unint64_t v77 = v200;
                unint64_t v76 = v201;
                int64_t v78 = _StringGuts.nativeUnusedCapacity.getter(v200, v201);
                if (v79) {
                  goto LABEL_160;
                }
                if (v75 <= 15 && ((v76 & 0x2000000000000000) != 0 || v78 < v74))
                {
LABEL_94:
                  swift_bridgeObjectRetain(v76);
                  unint64_t v85 = _StringGuts._convertedToSmall()(v77, v76);
                  unint64_t v87 = v86;
                  swift_bridgeObjectRelease(v76);
                  v88._Swift::UInt64 rawBits = (v11 << 16) | 1;
                  v89._Swift::UInt64 rawBits = 1;
                  v90._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v89, v88, v4, a1);
                  if (v90._rawBits < 0x10000) {
                    v90._rawBits |= 3;
                  }
                  unint64_t v92 = specialized String.init(_:)(v90, v91, v4, a1);
                  unint64_t v94 = v93;
                  swift_bridgeObjectRelease(a1);
                  unint64_t v95 = _StringGuts._convertedToSmall()(v92, v94);
                  unint64_t v97 = v96;
                  swift_bridgeObjectRelease(v94);
                  uint64_t v98 = HIBYTE(v87) & 0xF;
                  uint64_t v99 = HIBYTE(v97) & 0xF;
                  uint64_t v100 = v99 + v98;
                  if ((unint64_t)(v99 + v98) <= 0xF)
                  {
                    if (v99)
                    {
                      char v101 = 0;
                      unint64_t v102 = 0;
                      do
                      {
                        unint64_t v103 = v98 + v102;
                        unint64_t v104 = v102 + 1;
                        if (v102 >= 8) {
                          unint64_t v105 = v97;
                        }
                        else {
                          unint64_t v105 = v95;
                        }
                        unint64_t v106 = v105 >> (v101 & 0x38);
                        char v107 = (8 * v98 + v101) & 0x38;
                        uint64_t v108 = (-255 << v107) - 1;
                        unint64_t v109 = (unint64_t)v106 << v107;
                        unint64_t v110 = v109 | v108 & v87;
                        unint64_t v111 = v109 | v108 & v85;
                        if (v103 < 8) {
                          unint64_t v85 = v111;
                        }
                        else {
                          unint64_t v87 = v110;
                        }
                        v101 += 8;
                        unint64_t v102 = v104;
                      }
                      while (v99 != v104);
                    }
                    swift_bridgeObjectRelease(v76);
                    swift_bridgeObjectRelease(a1);
                    unint64_t v112 = 0xA000000000000000;
                    if (!(v85 & 0x8080808080808080 | v87 & 0x80808080808080)) {
                      unint64_t v112 = 0xE000000000000000;
                    }
                    uint64_t v200 = v85;
                    unint64_t v201 = v112 & 0xFF00000000000000 | (v100 << 56) | v87 & 0xFFFFFFFFFFFFFFLL;
                    goto LABEL_126;
                  }
                  goto LABEL_152;
                }
              }
              else if (v75 <= 15)
              {
                unint64_t v77 = v200;
                unint64_t v76 = v201;
                goto LABEL_94;
              }
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v75, v74);
              if ((a1 & 0x1000000000000000) != 0)
              {
                _StringGuts._foreignAppendInPlace(_:)(v4, a1, 0, v11);
                goto LABEL_110;
              }
              swift_bridgeObjectRelease_n(a1, 4);
              if (!v13)
              {
                if ((v4 & 0x1000000000000000) == 0) {
                  goto LABEL_198;
                }
                swift_bridgeObjectRelease(a1);
                id v80 = (id)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v81 = v197;
                uint64_t v82 = v197;
                goto LABEL_92;
              }
              swift_bridgeObjectRelease_n(a1, 2);
              unint64_t v198 = v4;
              unint64_t v199 = a1 & 0xFFFFFFFFFFFFFFLL;
              int64_t v116 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v12, (uint64_t)&v198, v12);
              _StringGuts.appendInPlace(_:isASCII:)(v116, v117, (a1 & 0x4000000000000000) != 0);
              swift_bridgeObjectRelease(a1);
              while (1)
              {
LABEL_126:
                uint64_t v5 = v200;
                a1 = v201;
                unint64_t v130 = HIBYTE(v201) & 0xF;
                if ((v201 & 0x2000000000000000) != 0) {
                  uint64_t v12 = HIBYTE(v201) & 0xF;
                }
                else {
                  uint64_t v12 = v200 & 0xFFFFFFFFFFFFLL;
                }
                if (!v12 && (v200 & ~v201 & 0x2000000000000000) == 0)
                {
                  swift_bridgeObjectRelease(v201);
                  unint64_t v131 = 0x80000001816DEC30 | 0x8000000000000000;
                  uint64_t v200 = 0xD0000000000000AALL;
                  goto LABEL_176;
                }
                int64_t v75 = (int64_t)"' were found in a Dictionary.\n"
                                      "This usually means either that the type violates Hashable's requirements, or\n"
                                      "that members of such a dictionary were mutated after insertion.";
                if ((v201 & 0x2000000000000000) != 0 && (0x80000001816DEC30 & 0x2000000000000000) != 0)
                {
                  unint64_t v132 = v130 + ((0x80000001816DEC30 >> 56) & 0xF);
                  if (v132 <= 0xF)
                  {
                    unint64_t v164 = (0x80000001816DEC30 >> 56) & 0xF;
                    if (v164)
                    {
                      char v167 = 0;
                      uint64_t v168 = 0;
                      unint64_t v165 = v201;
                      do
                      {
                        uint64_t v169 = v130 + v168;
                        uint64_t v170 = v168 + 1;
                        unint64_t v171 = 0xD0000000000000AALL;
                        if (v168 >= 8) {
                          unint64_t v171 = 0x80000001816DEC30 | 0x8000000000000000;
                        }
                        unint64_t v172 = v171 >> (v167 & 0x38);
                        char v173 = (8 * v130 + v167) & 0x38;
                        uint64_t v174 = (-255 << v173) - 1;
                        unint64_t v175 = (unint64_t)v172 << v173;
                        unint64_t v176 = v175 | v174 & v165;
                        unint64_t v177 = v175 | v174 & v5;
                        if (v169 < 8) {
                          uint64_t v5 = v177;
                        }
                        else {
                          unint64_t v165 = v176;
                        }
                        v167 += 8;
                        uint64_t v168 = v170;
                      }
                      while (v164 != v170);
                    }
                    else
                    {
                      unint64_t v165 = v201;
                    }
                    swift_bridgeObjectRelease(v201);
                    swift_bridgeObjectRelease(0x80000001816DEC30 | 0x8000000000000000);
                    unint64_t v178 = 0xA000000000000000;
                    if (!(v5 & 0x8080808080808080 | v165 & 0x80808080808080)) {
                      unint64_t v178 = 0xE000000000000000;
                    }
                    unint64_t v131 = v178 & 0xFF00000000000000 | (v132 << 56) | v165 & 0xFFFFFFFFFFFFFFLL;
                    uint64_t v200 = v5;
LABEL_176:
                    unint64_t v201 = v131;
                    goto LABEL_177;
                  }
                }
                uint64_t v13 = 0x80000001816DEC30 | 0x8000000000000000;
                if ((0x80000001816DEC30 & 0x2000000000000000) != 0) {
                  uint64_t v4 = (0x80000001816DEC30 >> 56) & 0xF;
                }
                else {
                  uint64_t v4 = 170;
                }
                swift_bridgeObjectRetain_n(0x80000001816DEC30 | 0x8000000000000000, 2);
                if ((0x80000001816DEC30 & 0x1000000000000000) != 0)
                {
LABEL_192:
                  swift_bridgeObjectRetain_n(v13, 5);
                  v191._Swift::UInt64 rawBits = 1;
                  v192._Swift::UInt64 rawBits = (v4 << 16) | 1;
                  v193._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v191, v192, 0xD0000000000000AALL, v13);
                  if (v193._rawBits < 0x10000) {
                    v193._rawBits |= 3;
                  }
                  Swift::Int v133 = specialized Collection.count.getter(v193, v194, 0xD0000000000000AALL, v13);
                  swift_bridgeObjectRelease(v13);
                  if ((a1 & 0x1000000000000000) == 0)
                  {
LABEL_140:
                    BOOL v14 = __OFADD__(v12, v133);
                    int64_t v134 = v12 + v133;
                    if (!v14) {
                      goto LABEL_141;
                    }
                    goto LABEL_197;
                  }
                }
                else
                {
                  swift_bridgeObjectRetain_n(0x80000001816DEC30 | 0x8000000000000000, 4);
                  Swift::Int v133 = v4;
                  if ((a1 & 0x1000000000000000) == 0) {
                    goto LABEL_140;
                  }
                }
                Swift::Int v195 = String.UTF8View._foreignCount()();
                int64_t v134 = v195 + v133;
                if (!__OFADD__(v195, v133))
                {
LABEL_141:
                  if ((v5 & ~a1 & 0x2000000000000000) == 0
                    || !swift_isUniquelyReferenced_nonNull_native(a1 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if (v134 <= 15) {
                      goto LABEL_148;
                    }
                    goto LABEL_154;
                  }
                  int64_t v135 = _StringGuts.nativeUnusedCapacity.getter(v5, a1);
                  if ((v136 & 1) == 0)
                  {
                    uint64_t v137 = (a1 >> 61) & 1;
                    if (v135 < v133) {
                      LODWORD(v137) = 1;
                    }
                    if (v134 <= 15 && v137)
                    {
LABEL_148:
                      swift_bridgeObjectRetain(a1);
                      unint64_t v138 = _StringGuts._convertedToSmall()(v5, a1);
                      unint64_t v140 = v139;
                      swift_bridgeObjectRelease(a1);
                      v141._Swift::UInt64 rawBits = (v4 << 16) | 1;
                      v142._Swift::UInt64 rawBits = 1;
                      v143._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v142, v141, 0xD0000000000000AALL, (v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
                      if (v143._rawBits < 0x10000) {
                        v143._rawBits |= 3;
                      }
                      unint64_t v145 = specialized String.init(_:)(v143, v144, 0xD0000000000000AALL, (v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
                      unint64_t v147 = v146;
                      swift_bridgeObjectRelease((v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
                      unint64_t v148 = _StringGuts._convertedToSmall()(v145, v147);
                      unint64_t v150 = v149;
                      swift_bridgeObjectRelease(v147);
                      unint64_t v151 = specialized _SmallString.init(_:appending:)(v138, v140, v148, v150);
                      if ((v153 & 1) == 0)
                      {
                        uint64_t v154 = v151;
                        unint64_t v155 = v152;
                        swift_bridgeObjectRelease(a1);
                        swift_bridgeObjectRelease((v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
                        uint64_t v200 = v154;
                        unint64_t v201 = v155;
                        goto LABEL_177;
                      }
LABEL_152:
                      unint64_t v156 = 266;
LABEL_161:
                      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v156, 0);
                    }
LABEL_154:
                    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v134, v133);
                    int64_t v157 = v75 + 0x7FFFFFFFFFFFFFE0;
                    if (((v75 + 0x7FFFFFFFFFFFFFE0) & 0x1000000000000000) != 0)
                    {
                      unint64_t v166 = v157 | 0x8000000000000000;
                      _StringGuts._foreignAppendInPlace(_:)(0xD0000000000000AALL, v157 | 0x8000000000000000, 0, v4);
                      unint64_t v163 = v166;
LABEL_165:
                      swift_bridgeObjectRelease_n(v163, 2);
                    }
                    else
                    {
                      unint64_t v158 = v157 | 0x8000000000000000;
                      unint64_t v159 = ((v157 | 0x8000000000000000) >> 62) & 1;
                      if ((v158 & 0x2000000000000000) != 0) {
                        char v160 = v159;
                      }
                      else {
                        char v160 = 1;
                      }
                      swift_bridgeObjectRelease_n(v158, 5);
                      if ((v158 & 0x2000000000000000) == 0)
                      {
                        uint64_t v161 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v4, ((v75 + 0x7FFFFFFFFFFFFFE0) & 0xFFFFFFFFFFFFFFFLL) + 32, 170);
                        _StringGuts.appendInPlace(_:isASCII:)(v161, v162, v160);
                        unint64_t v163 = (v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000;
                        goto LABEL_165;
                      }
                      swift_bridgeObjectRelease((v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
                      unint64_t v198 = 0xD0000000000000AALL;
                      unint64_t v199 = (v75 + 0x7FFFFFFFFFFFFFE0) & 0xFFFFFFFFFFFFFFLL;
                      BOOL v179 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v4, (uint64_t)&v198, ((unint64_t)(v75 + 0x7FFFFFFFFFFFFFE0) >> 56) & 0xF);
                      _StringGuts.appendInPlace(_:isASCII:)(v179, v180, v160);
                      swift_bridgeObjectRelease((v75 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
                    }
LABEL_177:
                    _assertionFailure(_:_:flags:)("Fatal error", 11, 2, v200, v201, 0);
                  }
LABEL_160:
                  unint64_t v156 = 258;
                  goto LABEL_161;
                }
LABEL_197:
                __break(1u);
LABEL_198:
                id v80 = _StringObject.sharedUTF8.getter(v4, a1);
                uint64_t v82 = v196;
                swift_bridgeObjectRelease(a1);
                if (v82 < v197) {
                  _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
                }
                uint64_t v81 = v197;
LABEL_92:
                char v83 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v81, (uint64_t)v80, v82);
                _StringGuts.appendInPlace(_:isASCII:)(v83, v84, v4 < 0);
LABEL_110:
                swift_bridgeObjectRelease_n(a1, 2);
              }
            }
LABEL_191:
            __break(1u);
            goto LABEL_192;
          }
          Swift::Int v19 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v12, (0x80000001816DEC10 & 0xFFFFFFFFFFFFFFFLL) + 32, 24);
          _StringGuts.appendInPlace(_:isASCII:)(v19, v20, v18);
          unint64_t v21 = 0x80000001816DEC10 | 0x8000000000000000;
        }
        swift_bridgeObjectRelease_n(v21, 2);
        goto LABEL_60;
      }
    }
    else if (v15 > 15)
    {
      goto LABEL_22;
    }
    swift_bridgeObjectRetain(v5);
    uint64_t v4 = _StringGuts._convertedToSmall()(v4, v5);
    unint64_t v23 = v22;
    swift_bridgeObjectRelease(v5);
    v24._Swift::UInt64 rawBits = (v12 << 16) | 1;
    v25._Swift::UInt64 rawBits = 1;
    v26._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v25, v24, 0xD000000000000018, 0x80000001816DEC10 | 0x8000000000000000);
    if (v26._rawBits < 0x10000) {
      v26._rawBits |= 3;
    }
    unint64_t v28 = specialized String.init(_:)(v26, v27, 0xD000000000000018, 0x80000001816DEC10 | 0x8000000000000000);
    unint64_t v30 = v29;
    swift_bridgeObjectRelease(0x80000001816DEC10 | 0x8000000000000000);
    unint64_t v31 = _StringGuts._convertedToSmall()(v28, v30);
    unint64_t v33 = v32;
    swift_bridgeObjectRelease(v30);
    uint64_t v34 = HIBYTE(v23) & 0xF;
    uint64_t v35 = HIBYTE(v33) & 0xF;
    uint64_t v36 = v35 + v34;
    if ((unint64_t)(v35 + v34) > 0xF) {
      goto LABEL_152;
    }
    if (v35)
    {
      char v37 = 0;
      unint64_t v38 = 0;
      do
      {
        unint64_t v39 = v34 + v38;
        unint64_t v40 = v38 + 1;
        if (v38 >= 8) {
          unint64_t v41 = v33;
        }
        else {
          unint64_t v41 = v31;
        }
        unint64_t v42 = v41 >> (v37 & 0x38);
        char v43 = (8 * v34 + v37) & 0x38;
        uint64_t v44 = (-255 << v43) - 1;
        unint64_t v45 = (unint64_t)v42 << v43;
        unint64_t v46 = v45 | v44 & v23;
        unint64_t v47 = v45 | v44 & v4;
        if (v39 < 8) {
          uint64_t v4 = v47;
        }
        else {
          unint64_t v23 = v46;
        }
        v37 += 8;
        unint64_t v38 = v40;
      }
      while (v35 != v40);
    }
    swift_bridgeObjectRelease(v5);
    swift_bridgeObjectRelease(0x80000001816DEC10 | 0x8000000000000000);
    unint64_t v48 = 0xA000000000000000;
    if (!(v4 & 0x8080808080808080 | v23 & 0x80808080808080)) {
      unint64_t v48 = 0xE000000000000000;
    }
    unint64_t v9 = v48 & 0xFF00000000000000 | (v36 << 56) | v23 & 0xFFFFFFFFFFFFFFLL;
LABEL_58:
    uint64_t v200 = v4;
    goto LABEL_59;
  }
LABEL_185:
  __break(1u);
  goto LABEL_186;
}

__objc2_class **specialized _NativeDictionary.extractDictionary(using:count:)(unint64_t *a1, uint64_t a2, uint64_t a3, atomic_ullong *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v36 = a1;
  uint64_t v37 = a2;
  uint64_t v47 = *(void *)(a5 - 8);
  uint64_t v48 = a6;
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v36 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  unint64_t v46 = (char *)&v36 - v12;
  if (!v13) {
    return &_swiftEmptyDictionarySingleton;
  }
  if (a4[2] != a3)
  {
    uint64_t v45 = specialized static _DictionaryStorage.allocate(capacity:)(a3, a5, v48);
    if (v37 < 1) {
      unint64_t v14 = 0;
    }
    else {
      unint64_t v14 = *v36;
    }
    uint64_t v15 = 0;
    uint64_t v41 = v47 + 32;
    uint64_t v42 = v47 + 16;
    uint64_t v39 = v45 + 64;
    uint64_t v40 = v48 + 32;
    char v43 = v11;
    uint64_t v44 = a5;
    unint64_t v38 = a4;
    unint64_t v16 = a5;
    while (1)
    {
      uint64_t v51 = a3;
      if (v14)
      {
        uint64_t v49 = (v14 - 1) & v14;
        uint64_t v50 = v15;
        unint64_t v17 = __clz(__rbit64(v14)) | (v15 << 6);
      }
      else
      {
        uint64_t v18 = v15 + 1;
        if (__OFADD__(v15, 1)) {
          goto LABEL_29;
        }
        if (v18 >= v37) {
          return (__objc2_class **)v45;
        }
        unint64_t v19 = v36[v18];
        uint64_t v20 = v15 + 1;
        if (!v19)
        {
          uint64_t v20 = v15 + 2;
          if (v15 + 2 >= v37) {
            return (__objc2_class **)v45;
          }
          unint64_t v19 = v36[v20];
          if (!v19)
          {
            uint64_t v21 = v15 + 3;
            if (v15 + 3 >= v37) {
              return (__objc2_class **)v45;
            }
            unint64_t v19 = v36[v21];
            if (!v19)
            {
              while (1)
              {
                uint64_t v20 = v21 + 1;
                if (__OFADD__(v21, 1)) {
                  break;
                }
                if (v20 >= v37) {
                  return (__objc2_class **)v45;
                }
                unint64_t v19 = v36[v20];
                ++v21;
                if (v19) {
                  goto LABEL_22;
                }
              }
LABEL_30:
              __break(1u);
LABEL_31:
              KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v16);
            }
            uint64_t v20 = v15 + 3;
          }
        }
LABEL_22:
        uint64_t v49 = (v19 - 1) & v19;
        uint64_t v50 = v20;
        unint64_t v17 = __clz(__rbit64(v19)) + (v20 << 6);
      }
      unint64_t v22 = v46;
      uint64_t v23 = v47;
      uint64_t v24 = *(void *)(v47 + 72);
      (*(void (**)(char *, unint64_t, unint64_t))(v47 + 16))(v46, a4[6] + v24 * v17, v16);
      uint64_t v25 = a4[7] + 16 * v17;
      uint64_t v26 = *(void *)v25;
      char v27 = *(unsigned char *)(v25 + 8);
      unint64_t v28 = *(void (**)(char *, char *, unint64_t))(v23 + 32);
      v28(v11, v22, v16);
      unint64_t v29 = (void *)v45;
      uint64_t v30 = (*(uint64_t (**)(void, unint64_t, uint64_t))(v48 + 32))(*(void *)(v45 + 40), v16, v48);
      unint64_t v31 = __RawDictionaryStorage.find<A>(_:hashValue:)((uint64_t)v11, v30, v16);
      if (v32) {
        goto LABEL_31;
      }
      unint64_t v33 = v31;
      *(void *)(v39 + ((v31 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v31;
      v28((char *)(v29[6] + v31 * v24), v11, v16);
      uint64_t v34 = v29[7] + 16 * v33;
      *(void *)uint64_t v34 = v26;
      *(unsigned char *)(v34 + 8) = v27;
      ++v29[2];
      a3 = v51 - 1;
      if (__OFSUB__(v51, 1))
      {
        __break(1u);
LABEL_29:
        __break(1u);
        goto LABEL_30;
      }
      a4 = v38;
      unint64_t v14 = v49;
      uint64_t v15 = v50;
      if (v51 == 1) {
        return (__objc2_class **)v45;
      }
    }
  }
  swift_retain(a4);
  return (__objc2_class **)a4;
}

__objc2_class **_NativeDictionary.extractDictionary(using:count:)(unint64_t *a1, uint64_t a2, uint64_t a3, atomic_ullong *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v38 = a1;
  uint64_t v39 = a2;
  uint64_t v52 = a6;
  uint64_t v53 = *(void *)(a6 - 8);
  uint64_t v54 = a7;
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v49 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v48 = (char *)&v37 - v12;
  uint64_t v50 = *(void *)(v13 - 8);
  uint64_t v51 = v13;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v47 = (char *)&v37 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  unint64_t v46 = (char *)&v37 - v16;
  if (!v17) {
    return &_swiftEmptyDictionarySingleton;
  }
  if (a4[2] == a3)
  {
    swift_retain(a4);
    return (__objc2_class **)a4;
  }
  type metadata accessor for _DictionaryStorage(0, v51, v52, v54);
  uint64_t result = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a3);
  uint64_t v44 = a4;
  uint64_t v45 = result;
  if (v39 < 1) {
    unint64_t v19 = 0;
  }
  else {
    unint64_t v19 = *v38;
  }
  uint64_t v20 = 0;
  unint64_t v21 = v51;
  uint64_t v22 = v52;
  uint64_t v42 = v53 + 16;
  uint64_t v43 = v50 + 16;
  uint64_t v40 = v53 + 32;
  uint64_t v41 = v50 + 32;
  uint64_t v23 = v46;
  uint64_t v24 = v53;
  while (1)
  {
    if (v19)
    {
      unint64_t v25 = __clz(__rbit64(v19));
      v19 &= v19 - 1;
      unint64_t v26 = v25 | (v20 << 6);
      goto LABEL_21;
    }
    BOOL v27 = __OFADD__(v20++, 1);
    if (v27) {
      goto LABEL_27;
    }
    if (v20 >= v39) {
      return v45;
    }
    unint64_t v28 = v38[v20];
    if (!v28) {
      break;
    }
LABEL_20:
    unint64_t v19 = (v28 - 1) & v28;
    unint64_t v26 = __clz(__rbit64(v28)) + (v20 << 6);
LABEL_21:
    uint64_t v30 = v44;
    uint64_t v31 = v50;
    (*(void (**)(char *, unint64_t, unint64_t))(v50 + 16))(v23, v44[6] + *(void *)(v50 + 72) * v26, v21);
    unint64_t v32 = v30[7] + *(void *)(v24 + 72) * v26;
    unint64_t v33 = v48;
    (*(void (**)(char *, unint64_t, uint64_t))(v24 + 16))(v48, v32, v22);
    uint64_t v34 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
    uint64_t v35 = (uint64_t)v47;
    v34(v47, v23, v21);
    uint64_t v36 = (uint64_t)v49;
    (*(void (**)(char *, char *, uint64_t))(v24 + 32))(v49, v33, v22);
    uint64_t result = (__objc2_class **)_NativeDictionary._unsafeInsertNew(key:value:)(v35, v36, v45, v21, v22, v54);
    BOOL v27 = __OFSUB__(a3--, 1);
    if (v27)
    {
      __break(1u);
      goto LABEL_26;
    }
    if (!a3) {
      return v45;
    }
  }
  uint64_t v29 = v20 + 1;
  if (v20 + 1 >= v39) {
    return v45;
  }
  unint64_t v28 = v38[v29];
  if (v28)
  {
    ++v20;
    goto LABEL_20;
  }
  while (1)
  {
    uint64_t v20 = v29 + 1;
    if (__OFADD__(v29, 1)) {
      break;
    }
    if (v20 >= v39) {
      return v45;
    }
    unint64_t v28 = v38[v20];
    ++v29;
    if (v28) {
      goto LABEL_20;
    }
  }
LABEL_26:
  __break(1u);
LABEL_27:
  __break(1u);
  return result;
}

Swift::Int __swiftcall _NativeDictionary.hashValue(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v2 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](at.offset);
  uint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v7 + 16))(v10, *(void *)(v11 + 48) + *(void *)(v12 + 72) * v8);
  Swift::Int v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v4 + 32))(*(void *)(v6 + 40), v5, v4);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v5);
  return v13;
}

uint64_t protocol witness for _HashTableDelegate.hashValue(at:) in conformance _NativeDictionary<A, B>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *v2;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, *(void *)(v9 + 48) + *(void *)(v10 + 72) * v6, v4);
  uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a2 + 32) + 32))(*(void *)(v9 + 40), v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
  return v11;
}

char *protocol witness for _HashTableDelegate.moveEntry(from:to:) in conformance _NativeDictionary<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 72);
  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(*(void *)(v7 + 48) + v8 * a1), 1, (char *)(*(void *)(v7 + 48) + v8 * a2), *(unint64_t **)(a3 + 16));
  uint64_t v9 = *(void *)(v7 + 56);
  uint64_t v10 = *(unint64_t **)(a3 + 24);
  uint64_t v11 = *(void *)(*(v10 - 1) + 72);

  return UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v9 + v11 * a1), 1, (char *)(v9 + v11 * a2), v10);
}

Swift::Int specialized _NativeDictionary._delete(at:)(Swift::_HashTable::Bucket before, uint64_t a2)
{
  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (before.offset + 1) & v7;
      do
      {
        uint64_t v10 = (unint64_t *)(*(void *)(a2 + 48) + 16 * v6);
        unint64_t v11 = *v10;
        unint64_t v12 = v10[1];
        uint64_t v13 = _swift_stdlib_Hashing_parameters ^ *(void *)(a2 + 40);
        v28[0] = 0;
        v28[1] = v13 ^ 0x736F6D6570736575;
        v28[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
        v28[3] = v13 ^ 0x6C7967656E657261;
        v28[4] = unk_1EB208F00 ^ 0x7465646279746573;
        long long v29 = 0u;
        long long v30 = 0u;
        swift_bridgeObjectRetain(v12);
        String.hash(into:)(v28, v11, v12);
        swift_bridgeObjectRelease(v12);
        before.Swift::Int offset = Hasher._finalize()();
        unint64_t v14 = before.offset & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v14 < v8) {
            goto LABEL_5;
          }
        }
        else if (v14 >= v8)
        {
          goto LABEL_11;
        }
        if (offset >= (uint64_t)v14)
        {
LABEL_11:
          uint64_t v15 = *(void *)(a2 + 48);
          uint64_t v16 = (_OWORD *)(v15 + 16 * offset);
          uint64_t v17 = (_OWORD *)(v15 + 16 * v6);
          if (offset != v6 || v16 >= v17 + 1) {
            *uint64_t v16 = *v17;
          }
          uint64_t v18 = *(void *)(a2 + 56);
          unint64_t v19 = (_OWORD *)(v18 + 32 * offset);
          uint64_t v20 = (_OWORD *)(v18 + 32 * v6);
          if (offset != v6 || (Swift::Int offset = v6, v19 >= v20 + 2))
          {
            long long v9 = v20[1];
            _OWORD *v19 = *v20;
            v19[1] = v9;
            Swift::Int offset = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    unint64_t v21 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    uint64_t v22 = *v21;
    uint64_t v23 = (-1 << offset) - 1;
  }
  else
  {
    unint64_t v21 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    uint64_t v23 = *v21;
    uint64_t v22 = (-1 << SLOBYTE(before.offset)) - 1;
  }
  *unint64_t v21 = v23 & v22;
  uint64_t v24 = *(void *)(a2 + 16);
  BOOL v25 = __OFSUB__(v24, 1);
  uint64_t v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v26;
    ++*(_DWORD *)(a2 + 36);
  }
  return before.offset;
}

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Swift::Int v15;
  uint64_t v18;
  unint64_t v19;
  long long *v20;
  long long v21;
  long long v22;
  uint64_t v23;
  _OWORD *v24;
  _OWORD *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v33[3];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;

  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (before.offset + 1) & v7;
      do
      {
        outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v6, (uint64_t)v36);
        long long v9 = *(void *)(a2 + 40);
        uint64_t v10 = v37;
        unint64_t v11 = v38;
        __swift_project_boxed_opaque_existential_0Tm(v36, v37);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v11 + 8))(v33, v10, v11);
        unint64_t v12 = v34;
        uint64_t v13 = v35;
        __swift_project_boxed_opaque_existential_0Tm(v33, v34);
        unint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 40))(v9, v12, v13);
        __swift_destroy_boxed_opaque_existential_1Tm(v33);
        before.Swift::Int offset = (Swift::Int)outlined destroy of AnyHashable(v36);
        uint64_t v15 = v14 & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v15 >= v8 && offset >= v15)
          {
LABEL_16:
            uint64_t v18 = *(void *)(a2 + 48);
            unint64_t v19 = v18 + 40 * offset;
            uint64_t v20 = (long long *)(v18 + 40 * v6);
            if (offset != v6 || v19 >= (unint64_t)v20 + 40)
            {
              unint64_t v21 = *v20;
              uint64_t v22 = v20[1];
              *(void *)(v19 + 32) = *((void *)v20 + 4);
              *(_OWORD *)unint64_t v19 = v21;
              *(_OWORD *)(v19 + 16) = v22;
            }
            uint64_t v23 = *(void *)(a2 + 56);
            uint64_t v24 = (_OWORD *)(v23 + 16 * offset);
            BOOL v25 = (_OWORD *)(v23 + 16 * v6);
            if (offset != v6 || (Swift::Int offset = v6, v24 >= v25 + 1))
            {
              *uint64_t v24 = *v25;
              Swift::Int offset = v6;
            }
          }
        }
        else if (v15 >= v8 || offset >= v15)
        {
          goto LABEL_16;
        }
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    uint64_t v26 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    BOOL v27 = *v26;
    unint64_t v28 = (-1 << offset) - 1;
  }
  else
  {
    uint64_t v26 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    unint64_t v28 = *v26;
    BOOL v27 = (-1 << SLOBYTE(before.offset)) - 1;
  }
  *uint64_t v26 = v28 & v27;
  long long v29 = *(void *)(a2 + 16);
  long long v30 = __OFSUB__(v29, 1);
  uint64_t v31 = v29 - 1;
  if (v30)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v31;
    ++*(_DWORD *)(a2 + 36);
  }
  return before.offset;
}

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  long long v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  Swift::Int v16;
  uint64_t v19;
  unint64_t v20;
  long long *v21;
  long long v22;
  long long v23;
  uint64_t v24;
  _OWORD *v25;
  _OWORD *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v34[3];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37[3];
  uint64_t v38;
  uint64_t v39;

  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (before.offset + 1) & v7;
      do
      {
        outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v6, (uint64_t)v37);
        uint64_t v10 = *(void *)(a2 + 40);
        unint64_t v11 = v38;
        unint64_t v12 = v39;
        __swift_project_boxed_opaque_existential_0Tm(v37, v38);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v12 + 8))(v34, v11, v12);
        uint64_t v13 = v35;
        unint64_t v14 = v36;
        __swift_project_boxed_opaque_existential_0Tm(v34, v35);
        uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 40))(v10, v13, v14);
        __swift_destroy_boxed_opaque_existential_1Tm(v34);
        before.Swift::Int offset = (Swift::Int)outlined destroy of AnyHashable(v37);
        uint64_t v16 = v15 & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v16 >= v8 && offset >= v16)
          {
LABEL_16:
            unint64_t v19 = *(void *)(a2 + 48);
            uint64_t v20 = v19 + 40 * offset;
            unint64_t v21 = (long long *)(v19 + 40 * v6);
            if (offset != v6 || v20 >= (unint64_t)v21 + 40)
            {
              uint64_t v22 = *v21;
              uint64_t v23 = v21[1];
              *(void *)(v20 + 32) = *((void *)v21 + 4);
              *(_OWORD *)uint64_t v20 = v22;
              *(_OWORD *)(v20 + 16) = v23;
            }
            uint64_t v24 = *(void *)(a2 + 56);
            BOOL v25 = (_OWORD *)(v24 + 32 * offset);
            uint64_t v26 = (_OWORD *)(v24 + 32 * v6);
            if (offset != v6 || (Swift::Int offset = v6, v25 >= v26 + 2))
            {
              long long v9 = v26[1];
              *BOOL v25 = *v26;
              v25[1] = v9;
              Swift::Int offset = v6;
            }
          }
        }
        else if (v16 >= v8 || offset >= v16)
        {
          goto LABEL_16;
        }
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    BOOL v27 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    unint64_t v28 = *v27;
    long long v29 = (-1 << offset) - 1;
  }
  else
  {
    BOOL v27 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    long long v29 = *v27;
    unint64_t v28 = (-1 << SLOBYTE(before.offset)) - 1;
  }
  *BOOL v27 = v29 & v28;
  long long v30 = *(void *)(a2 + 16);
  uint64_t v31 = __OFSUB__(v30, 1);
  unint64_t v32 = v30 - 1;
  if (v31)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v32;
    ++*(_DWORD *)(a2 + 36);
  }
  return before.offset;
}

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  long long v9;
  long long v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  _OWORD *v18;
  uint64_t v19;
  unint64_t v20;
  long long *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  unint64_t v29[5];
  long long v30;
  long long v31;

  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (before.offset + 1) & v7;
      do
      {
        unint64_t v11 = (unint64_t *)(*(void *)(a2 + 48) + 16 * v6);
        unint64_t v12 = *v11;
        uint64_t v13 = v11[1];
        unint64_t v14 = _swift_stdlib_Hashing_parameters ^ *(void *)(a2 + 40);
        v29[0] = 0;
        v29[1] = v14 ^ 0x736F6D6570736575;
        v29[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
        v29[3] = v14 ^ 0x6C7967656E657261;
        v29[4] = unk_1EB208F00 ^ 0x7465646279746573;
        long long v30 = 0u;
        uint64_t v31 = 0u;
        swift_bridgeObjectRetain(v13);
        String.hash(into:)(v29, v12, v13);
        swift_bridgeObjectRelease(v13);
        before.Swift::Int offset = Hasher._finalize()();
        uint64_t v15 = before.offset & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v15 < v8) {
            goto LABEL_5;
          }
        }
        else if (v15 >= v8)
        {
          goto LABEL_11;
        }
        if (offset >= (uint64_t)v15)
        {
LABEL_11:
          uint64_t v16 = *(void *)(a2 + 48);
          uint64_t v17 = (_OWORD *)(v16 + 16 * offset);
          uint64_t v18 = (_OWORD *)(v16 + 16 * v6);
          if (offset != v6 || v17 >= v18 + 1) {
            *uint64_t v17 = *v18;
          }
          unint64_t v19 = *(void *)(a2 + 56);
          uint64_t v20 = v19 + 40 * offset;
          unint64_t v21 = (long long *)(v19 + 40 * v6);
          if (offset != v6 || (Swift::Int offset = v6, v20 >= (unint64_t)v21 + 40))
          {
            long long v9 = *v21;
            uint64_t v10 = v21[1];
            *(void *)(v20 + 32) = *((void *)v21 + 4);
            *(_OWORD *)uint64_t v20 = v9;
            *(_OWORD *)(v20 + 16) = v10;
            Swift::Int offset = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    uint64_t v22 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    uint64_t v23 = *v22;
    uint64_t v24 = (-1 << offset) - 1;
  }
  else
  {
    uint64_t v22 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    uint64_t v24 = *v22;
    uint64_t v23 = (-1 << SLOBYTE(before.offset)) - 1;
  }
  *uint64_t v22 = v24 & v23;
  BOOL v25 = *(void *)(a2 + 16);
  uint64_t v26 = __OFSUB__(v25, 1);
  BOOL v27 = v25 - 1;
  if (v26)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v27;
    ++*(_DWORD *)(a2 + 36);
  }
  return before.offset;
}

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  _OWORD *v18;
  _OWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  unint64_t v27[5];
  long long v28;
  long long v29;

  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (before.offset + 1) & v7;
      do
      {
        long long v9 = (unint64_t *)(*(void *)(a2 + 48) + 16 * v6);
        uint64_t v10 = *v9;
        unint64_t v11 = v9[1];
        unint64_t v12 = _swift_stdlib_Hashing_parameters ^ *(void *)(a2 + 40);
        v27[0] = 0;
        v27[1] = v12 ^ 0x736F6D6570736575;
        void v27[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
        v27[3] = v12 ^ 0x6C7967656E657261;
        v27[4] = unk_1EB208F00 ^ 0x7465646279746573;
        unint64_t v28 = 0u;
        long long v29 = 0u;
        swift_bridgeObjectRetain(v11);
        String.hash(into:)(v27, v10, v11);
        swift_bridgeObjectRelease(v11);
        before.Swift::Int offset = Hasher._finalize()();
        uint64_t v13 = before.offset & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v13 < v8) {
            goto LABEL_5;
          }
        }
        else if (v13 >= v8)
        {
          goto LABEL_11;
        }
        if (offset >= (uint64_t)v13)
        {
LABEL_11:
          unint64_t v14 = *(void *)(a2 + 48);
          uint64_t v15 = (_OWORD *)(v14 + 16 * offset);
          uint64_t v16 = (_OWORD *)(v14 + 16 * v6);
          if (offset != v6 || v15 >= v16 + 1) {
            *uint64_t v15 = *v16;
          }
          uint64_t v17 = *(void *)(a2 + 56);
          uint64_t v18 = (_OWORD *)(v17 + 16 * offset);
          unint64_t v19 = (_OWORD *)(v17 + 16 * v6);
          if (offset != v6 || (Swift::Int offset = v6, v18 >= v19 + 1))
          {
            *uint64_t v18 = *v19;
            Swift::Int offset = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    uint64_t v20 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    unint64_t v21 = *v20;
    uint64_t v22 = (-1 << offset) - 1;
  }
  else
  {
    uint64_t v20 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    uint64_t v22 = *v20;
    unint64_t v21 = (-1 << SLOBYTE(before.offset)) - 1;
  }
  *uint64_t v20 = v22 & v21;
  uint64_t v23 = *(void *)(a2 + 16);
  uint64_t v24 = __OFSUB__(v23, 1);
  BOOL v25 = v23 - 1;
  if (v24)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v25;
    ++*(_DWORD *)(a2 + 36);
  }
  return before.offset;
}

Swift::Void __swiftcall _NativeDictionary._delete(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v54 = v4;
  uint64_t v47 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  Swift::Int offset = at.offset;
  uint64_t v8 = *(v2 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](at.offset);
  unint64_t v11 = (char *)&v46 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = v12 + 64;
  uint64_t v14 = -1 << *(unsigned char *)(v12 + 32);
  unint64_t v15 = (v9 + 1) & ~v14;
  if (((1 << v15) & *(void *)(v12 + 64 + 8 * (v15 >> 6))) != 0)
  {
    uint64_t v16 = ~v14;
    v17.Swift::Int offset = _HashTable.previousHole(before:)((Swift::_HashTable::Bucket)offset).offset;
    if ((*(void *)(v13 + 8 * (v15 >> 6)) & (1 << v15)) != 0)
    {
      uint64_t v51 = *(uint64_t (**)(void, unint64_t *, uint64_t))(v54 + 32);
      uint64_t v52 = v54 + 32;
      unint64_t v50 = (v17.offset + 1) & v16;
      unint64_t v19 = *(void (**)(char *, unint64_t, unint64_t *))(v8 + 16);
      uint64_t v18 = v8 + 16;
      uint64_t v55 = *(void *)(v18 + 56);
      uint64_t v53 = v18;
      uint64_t v20 = (void (**)(char *, unint64_t *))(v18 - 8);
      uint64_t v48 = v47 - 1;
      uint64_t v49 = v19;
      uint64_t v21 = v16;
      do
      {
        uint64_t v22 = v13;
        int64_t v23 = v55 * v15;
        uint64_t v24 = v21;
        v49(v11, *(void *)(v6 + 48) + v55 * v15, v5);
        uint64_t v25 = v51(*(void *)(v6 + 40), v5, v54);
        (*v20)(v11, v5);
        uint64_t v21 = v24;
        Swift::Int v26 = v25 & v24;
        if (offset >= (uint64_t)v50)
        {
          if (v26 >= v50 && offset >= v26)
          {
LABEL_16:
            uint64_t v29 = *(void *)(v6 + 48);
            long long v30 = (char *)(v29 + v55 * offset);
            uint64_t v31 = (char *)(v29 + v23);
            unint64_t v32 = v29 + v23 + v55;
            BOOL v33 = v55 * offset < v23 || (unint64_t)v30 >= v32;
            uint64_t v13 = v22;
            if (v33)
            {
              swift_arrayInitWithTakeFrontToBack(v30, v31, 1, v5);
            }
            else if (v55 * offset != v23)
            {
              swift_arrayInitWithTakeBackToFront(v30, v31, 1, (uint64_t)v5);
            }
            uint64_t v34 = *(void *)(v6 + 56);
            uint64_t v35 = *(void *)(*v48 + 72);
            Swift::Int v36 = v35 * offset;
            uint64_t v37 = (char *)(v34 + v35 * offset);
            unint64_t v38 = (char *)(v34 + v35 * v15);
            if (v35 * offset < (uint64_t)(v35 * v15) || v37 >= &v38[v35])
            {
              swift_arrayInitWithTakeFrontToBack(v37, v38, 1, v47);
              Swift::Int offset = v15;
              uint64_t v21 = v24;
            }
            else
            {
              Swift::Int offset = v15;
              uint64_t v21 = v24;
              if (v36 != v35 * v15)
              {
                swift_arrayInitWithTakeBackToFront(v37, v38, 1, (uint64_t)v47);
                uint64_t v21 = v24;
                Swift::Int offset = v15;
              }
            }
            goto LABEL_5;
          }
        }
        else if (v26 >= v50 || offset >= v26)
        {
          goto LABEL_16;
        }
        uint64_t v13 = v22;
LABEL_5:
        unint64_t v15 = (v15 + 1) & v21;
      }
      while (((*(void *)(v13 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15) & 1) != 0);
    }
    uint64_t v40 = (uint64_t *)(v13 + 8 * ((unint64_t)offset >> 6));
    uint64_t v41 = *v40;
    uint64_t v42 = (-1 << offset) - 1;
  }
  else
  {
    uint64_t v40 = (uint64_t *)(v13 + 8 * ((unint64_t)offset >> 6));
    uint64_t v42 = *v40;
    uint64_t v41 = (-1 << offset) - 1;
  }
  *uint64_t v40 = v42 & v41;
  uint64_t v43 = *(void *)(v6 + 16);
  BOOL v44 = __OFSUB__(v43, 1);
  uint64_t v45 = v43 - 1;
  if (v44)
  {
    __break(1u);
  }
  else
  {
    *(void *)(v6 + 16) = v45;
    ++*(_DWORD *)(v6 + 36);
  }
}

__objc2_class **_ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, uint64_t *), uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v28 = a2;
  uint64_t v29 = a7;
  Swift::Int v36 = a4;
  long long v30 = a1;
  uint64_t v40 = a6;
  uint64_t v8 = *(void *)(a6 - 8);
  uint64_t result = (__objc2_class **)MEMORY[0x1F4188790](a1);
  unint64_t v11 = (char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v12 = 0;
  uint64_t v37 = (atomic_ullong *)v13;
  uint64_t v14 = *(void *)(v13 + 64);
  uint64_t v31 = 0;
  uint64_t v32 = v13 + 64;
  uint64_t v15 = 1 << *(unsigned char *)(v13 + 32);
  uint64_t v16 = -1;
  if (v15 < 64) {
    uint64_t v16 = ~(-1 << v15);
  }
  unint64_t v17 = v16 & v14;
  uint64_t v35 = v8 + 16;
  int64_t v33 = (unint64_t)(v15 + 63) >> 6;
  uint64_t v34 = v8 + 8;
  uint64_t v18 = v40;
  while (v17)
  {
    unint64_t v19 = __clz(__rbit64(v17));
    v17 &= v17 - 1;
    unint64_t v20 = v19 | (v12 << 6);
LABEL_15:
    uint64_t v24 = v37;
    (*(void (**)(char *, unint64_t, uint64_t))(v8 + 16))(v11, v37[6] + *(void *)(v8 + 72) * v20, v18);
    uint64_t v25 = v24[7] + 16 * v20;
    uint64_t v26 = *(void *)v25;
    LOBYTE(v25) = *(unsigned char *)(v25 + 8);
    uint64_t v38 = v26;
    char v39 = v25;
    char v27 = v36(v11, &v38);
    uint64_t result = (__objc2_class **)(*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v18);
    if (v7) {
      return result;
    }
    if (v27)
    {
      *(unint64_t *)((char *)v30 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v20;
      BOOL v21 = __OFADD__(v31++, 1);
      if (v21) {
        goto LABEL_28;
      }
    }
  }
  BOOL v21 = __OFADD__(v12++, 1);
  if (v21)
  {
    __break(1u);
    goto LABEL_27;
  }
  if (v12 >= v33) {
    return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v37, v40, v29);
  }
  unint64_t v22 = *(void *)(v32 + 8 * v12);
  if (v22)
  {
LABEL_14:
    unint64_t v17 = (v22 - 1) & v22;
    unint64_t v20 = __clz(__rbit64(v22)) + (v12 << 6);
    goto LABEL_15;
  }
  int64_t v23 = v12 + 1;
  if (v12 + 1 >= v33) {
    return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v37, v40, v29);
  }
  unint64_t v22 = *(void *)(v32 + 8 * v23);
  if (v22) {
    goto LABEL_13;
  }
  int64_t v23 = v12 + 2;
  if (v12 + 2 >= v33) {
    return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v37, v40, v29);
  }
  unint64_t v22 = *(void *)(v32 + 8 * v23);
  if (v22)
  {
LABEL_13:
    int64_t v12 = v23;
    goto LABEL_14;
  }
  while (1)
  {
    int64_t v12 = v23 + 1;
    if (__OFADD__(v23, 1)) {
      break;
    }
    if (v12 >= v33) {
      return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v37, v40, v29);
    }
    unint64_t v22 = *(void *)(v32 + 8 * v12);
    ++v23;
    if (v22) {
      goto LABEL_14;
    }
  }
LABEL_27:
  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

__objc2_class **closure #1 in _NativeDictionary.filter(_:)@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(char *, char *)@<X3>, uint64_t a4@<X6>, uint64_t a5@<X7>, __objc2_class ***a6@<X8>)
{
  uint64_t v40 = a5;
  uint64_t v54 = a3;
  uint64_t v38 = a2;
  uint64_t v41 = a1;
  char v39 = a6;
  uint64_t v57 = a4;
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v52 = (char *)&v37 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v56 = v8;
  uint64_t result = (__objc2_class **)MEMORY[0x1F4188790](v6);
  unint64_t v50 = (char *)&v37 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v13 = 0;
  uint64_t v55 = (atomic_ullong *)v14;
  uint64_t v15 = *(void *)(v14 + 64);
  uint64_t v42 = 0;
  uint64_t v43 = v14 + 64;
  uint64_t v16 = 1 << *(unsigned char *)(v14 + 32);
  uint64_t v17 = -1;
  if (v16 < 64) {
    uint64_t v17 = ~(-1 << v16);
  }
  unint64_t v18 = v17 & v15;
  int64_t v44 = (unint64_t)(v16 + 63) >> 6;
  uint64_t v48 = v10 + 16;
  uint64_t v49 = v11 + 16;
  uint64_t v53 = v10;
  uint64_t v51 = v11;
  uint64_t v46 = v11 + 8;
  uint64_t v47 = v10 + 8;
  uint64_t v19 = v11;
  unint64_t v20 = v50;
  uint64_t v22 = v56;
  uint64_t v21 = v57;
  uint64_t v23 = v10;
  while (v18)
  {
    uint64_t v58 = (v18 - 1) & v18;
    int64_t v59 = v13;
    unint64_t v24 = __clz(__rbit64(v18)) | (v13 << 6);
LABEL_16:
    uint64_t v29 = v55;
    (*(void (**)(char *, unint64_t, uint64_t))(v19 + 16))(v20, v55[6] + *(void *)(v19 + 72) * v24, v22);
    atomic_ullong v30 = v29[7];
    uint64_t v31 = *(void *)(v23 + 72);
    unint64_t v45 = v24;
    unint64_t v32 = v30 + v31 * v24;
    int64_t v33 = v52;
    (*(void (**)(char *, unint64_t, uint64_t))(v23 + 16))(v52, v32, v21);
    uint64_t v34 = v60;
    char v35 = v54(v20, v33);
    (*(void (**)(char *, uint64_t))(v23 + 8))(v33, v21);
    uint64_t result = (__objc2_class **)(*(uint64_t (**)(char *, uint64_t))(v19 + 8))(v20, v22);
    uint64_t v60 = v34;
    if (v34) {
      return result;
    }
    unint64_t v18 = v58;
    int64_t v13 = v59;
    if (v35)
    {
      *(unint64_t *)((char *)v41 + ((v45 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v45;
      BOOL v25 = __OFADD__(v42++, 1);
      if (v25)
      {
        __break(1u);
LABEL_21:
        Swift::Int v36 = v39;
        uint64_t result = _NativeDictionary.extractDictionary(using:count:)(v41, v38, v42, v55, v56, v57, v40);
        *Swift::Int v36 = result;
        return result;
      }
    }
  }
  BOOL v25 = __OFADD__(v13, 1);
  int64_t v26 = v13 + 1;
  if (v25) {
    goto LABEL_24;
  }
  if (v26 >= v44) {
    goto LABEL_21;
  }
  unint64_t v27 = *(void *)(v43 + 8 * v26);
  if (v27)
  {
LABEL_15:
    uint64_t v58 = (v27 - 1) & v27;
    int64_t v59 = v26;
    unint64_t v24 = __clz(__rbit64(v27)) + (v26 << 6);
    goto LABEL_16;
  }
  int64_t v28 = v26 + 1;
  if (v26 + 1 >= v44) {
    goto LABEL_21;
  }
  unint64_t v27 = *(void *)(v43 + 8 * v28);
  if (v27)
  {
    ++v26;
    goto LABEL_15;
  }
  while (1)
  {
    int64_t v26 = v28 + 1;
    if (__OFADD__(v28, 1)) {
      break;
    }
    if (v26 >= v44) {
      goto LABEL_21;
    }
    unint64_t v27 = *(void *)(v43 + 8 * v26);
    ++v28;
    if (v27) {
      goto LABEL_15;
    }
  }
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

uint64_t (*_NativeDictionary.Iterator.iterator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _NativeDictionary.Iterator.init(_:)@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1;
  uint64_t v3 = -1 << *(unsigned char *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t result = a1 + 64;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1 << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0;
  a2[4] = v2 & v5;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _NativeDictionary<A, B>@<X0>(void *a1@<X8>)
{
  return _NativeDictionary.makeIterator()(*v1, a1);
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _NativeDictionary<A, B>.Iterator@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = result;
  unint64_t v5 = v2[4];
  if (!v5)
  {
    uint64_t v18 = v2[3];
    int64_t v19 = v18 + 1;
    if (__OFADD__(v18, 1))
    {
      __break(1u);
      return result;
    }
    int64_t v20 = (unint64_t)(v2[2] + 64) >> 6;
    if (v19 < v20)
    {
      v2[3] = v19;
      uint64_t v21 = v2[1];
      unint64_t v22 = *(void *)(v21 + 8 * v19);
      v2[4] = v22;
      if (v22)
      {
LABEL_11:
        v2[4] = (v22 - 1) & v22;
        unint64_t v6 = __clz(__rbit64(v22)) + (v19 << 6);
        goto LABEL_3;
      }
      uint64_t v23 = v18 + 2;
      while (v20 != v23)
      {
        v2[3] = v23;
        unint64_t v22 = *(void *)(v21 + 8 * v23);
        v2[4] = v22;
        ++v23;
        if (v22)
        {
          int64_t v19 = v23 - 1;
          goto LABEL_11;
        }
      }
    }
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, *(void *)(result + 16), *(void *)(result + 24), "key value ", 0);
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(TupleTypeMetadata2 - 1) + 56);
    uint64_t v17 = TupleTypeMetadata2;
    uint64_t v15 = a2;
    uint64_t v16 = 1;
    goto LABEL_13;
  }
  v2[4] = (v5 - 1) & v5;
  unint64_t v6 = __clz(__rbit64(v5)) | (v2[3] << 6);
LABEL_3:
  uint64_t v7 = *v2;
  uint64_t v8 = *(void *)(result + 16);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(a2, *(void *)(v7 + 48) + *(void *)(*(void *)(v8 - 8) + 72) * v6, v8);
  uint64_t v9 = *(void *)(v7 + 56);
  uint64_t v10 = *(void *)(v3 + 24);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = v9 + *(void *)(v11 + 72) * v6;
  int64_t v13 = swift_getTupleTypeMetadata2(0, v8, v10, "key value ", 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 16))(a2 + *((int *)v13 + 12), v12, v10);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(v13 - 1) + 56);
  uint64_t v15 = a2;
  uint64_t v16 = 0;
  uint64_t v17 = v13;
LABEL_13:

  return v14(v15, v16, 1, v17);
}

uint64_t _NativeSet._storage.setter(uint64_t a1)
{
  uint64_t result = swift_release(*v1);
  *uint64_t v1 = a1;
  return result;
}

uint64_t (*_NativeSet._storage.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

__objc2_class **_NativeSet.init()()
{
  return &_swiftEmptySetSingleton;
}

__objc2_class **static __RawSetStorage.empty.getter()
{
  return &_swiftEmptySetSingleton;
}

__objc2_class **_NativeSet.init(capacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptySetSingleton;
  }
  type metadata accessor for _SetStorage(0, a2, a3, a4);
  return (__objc2_class **)static _SetStorage.allocate(capacity:)(a1);
}

uint64_t specialized static _SetStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v2 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v2 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }
  else
  {
    if (v4 <= (uint64_t)v2) {
      uint64_t v4 = (uint64_t)v2;
    }
    char v5 = 64 - __clz(v4 - 1);
    if ((unint64_t)v4 <= 2) {
      char v6 = 1;
    }
    else {
      char v6 = v5;
    }
    return (uint64_t)specialized static _SetStorage.allocate(scale:age:seed:)(v6, 0x100000000, 0, 1);
  }
  return result;
}

uint64_t static _SetStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v2 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v2 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }
  else
  {
    if (v4 <= (uint64_t)v2) {
      uint64_t v4 = (uint64_t)v2;
    }
    char v5 = 64 - __clz(v4 - 1);
    if ((unint64_t)v4 <= 2) {
      char v6 = 1;
    }
    else {
      char v6 = v5;
    }
    return (uint64_t)static _SetStorage.allocate(scale:age:seed:)(v6, 0x100000000, 0, 1);
  }
  return result;
}

__objc2_class **_NativeSet.init(_:)(void *a1, char *a2, uint64_t a3)
{
  id v6 = [a1 count];

  return _NativeSet.init(_:capacity:)(a1, (uint64_t)v6, a2, a3);
}

id __CocoaSet.count.getter(void *a1)
{
  return [a1 sel_count];
}

__objc2_class **_NativeSet.init(_:capacity:)(void *a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v12 = *((void *)a3 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v18 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!a2)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptySetSingleton;
  }
  uint64_t v45 = v13;
  uint64_t v46 = v15;
  uint64_t v44 = v16;
  type metadata accessor for _SetStorage(0, (uint64_t)a3, a4, v14);
  char v19 = specialized static _HashTable.scale(forCapacity:)(a2);
  unsigned int v20 = specialized static Hasher._hash(seed:_:)(0, (uint64_t)a1);
  LOBYTE(v48) = 0;
  uint64_t v21 = static _SetStorage.allocate(scale:age:seed:)(v19, v20, 0, 1);
  uint64_t v48 = v21;
  unint64_t v22 = (unint64_t *)type metadata accessor for __CocoaSet.Iterator();
  uint64_t v23 = swift_allocObject(v22, 0xE8uLL, 7uLL);
  uint64_t v24 = 0;
  *((_OWORD *)v23 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v23 + 5) = 0u;
  BOOL v25 = a1;
  v23[27] = 0;
  int64_t v26 = v23 + 27;
  *((_OWORD *)v23 + 2) = 0u;
  *((_OWORD *)v23 + 3) = 0u;
  *((_OWORD *)v23 + 4) = 0u;
  *((_OWORD *)v23 + 6) = 0u;
  *((_OWORD *)v23 + 7) = 0u;
  *((_OWORD *)v23 + 8) = 0u;
  *((_OWORD *)v23 + 9) = 0u;
  *((_OWORD *)v23 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 0) = 0u;
  *((_OWORD *)v23 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  uint64_t v42 = (void (**)(uint64_t, void *, uint64_t))(v9 + 16);
  uint64_t v43 = (void (**)(void *, uint64_t, uint64_t, char *))(v12 + 56);
  *((_OWORD *)v23 + 12) = 0u;
  uint64_t v40 = (void (**)(void *, uint64_t))(v9 + 8);
  uint64_t v41 = (unsigned int (**)(uint64_t, uint64_t, char *))(v12 + 48);
  v23[26] = v25;
  char v39 = (void (**)(char *, uint64_t, char *))(v12 + 32);
  v23[28] = 0;
  while (v24 != v23[28])
  {
LABEL_7:
    uint64_t v28 = v23[3];
    if (!v28) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/SetBridging.swift", 23, 2, 0x254uLL, 0);
    }
    if ((unint64_t)(v24 - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
LABEL_21:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
    }
    uint64_t v29 = (void **)(v28 + 8 * v24);
    if ((v29 & 7) != 0) {
      goto LABEL_21;
    }
    atomic_ullong v30 = *v29;
    *int64_t v26 = v24 + 1;
    swift_unknownObjectRetain(v30);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      uint64_t v47 = v30;
      swift_dynamicCast(v18, (unint64_t *)&v47, qword_1ECA06328, a3, 7uLL);
    }
    else
    {
      uint64_t v34 = v46;
      (*v43)(v46, 1, 1, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v30, (uint64_t)a3, v34);
      swift_unknownObjectRelease(v30);
      uint64_t v35 = v44;
      Swift::Int v36 = v34;
      uint64_t v37 = v45;
      (*v42)(v44, v36, v45);
      if ((*v41)(v35, 1, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
      }
      (*v40)(v46, v37);
      (*v39)(v18, v35, a3);
      uint64_t v21 = v48;
    }
    unint64_t v32 = v21[2];
    if (v21[3] <= v32)
    {
      Swift::Int v33 = v32 + 1;
      type metadata accessor for _NativeSet(0, (uint64_t)a3, a4, v31);
      _NativeSet.resize(capacity:)(v33);
      uint64_t v21 = v48;
    }
    _NativeSet._unsafeInsertNew(_:)((uint64_t)v18, (uint64_t)v21, (uint64_t)a3, a4);
    uint64_t v24 = *v26;
    if (*v26 < 0) {
      goto LABEL_18;
    }
  }
  id v27 = [v23[26] countByEnumeratingWithState:v23 + 2 objects:v23 + 10 count:16];
  v23[28] = v27;
  if (v27)
  {
    uint64_t v24 = 0;
    *int64_t v26 = 0;
    goto LABEL_7;
  }
  v23[27] = -1;
LABEL_18:
  swift_release((uint64_t)v23);
  return (__objc2_class **)v21;
}

uint64_t static _SetStorage.convert(_:capacity:)(uint64_t a1, uint64_t a2)
{
  return static _DictionaryStorage.convert(_:capacity:)(a1, a2, (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))static _SetStorage.allocate(scale:age:seed:));
}

uint64_t static _DictionaryStorage.convert(_:capacity:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, void, uint64_t))
{
  uint64_t v4 = specialized static _HashTable.scale(forCapacity:)(a2);
  uint64_t v5 = specialized static Hasher._hash(seed:_:)(0, a1);

  return a3(v4, v5, 0, 1);
}

double __CocoaSet.makeIterator()(uint64_t a1)
{
  return __CocoaDictionary.makeIterator()(a1, type metadata accessor for __CocoaSet.Iterator);
}

double __CocoaDictionary.makeIterator()(uint64_t a1, uint64_t (*a2)(void))
{
  BOOL v3 = (unint64_t *)a2();
  uint64_t v4 = swift_allocObject(v3, 0xE8uLL, 7uLL);
  double result = 0.0;
  *((_OWORD *)v4 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 0) = 0u;
  *((_OWORD *)v4 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v4 + 12) = 0u;
  v4[27] = 0;
  v4[28] = 0;
  v4[26] = a1;
  return result;
}

id __CocoaSet.Iterator.next()()
{
  uint64_t v1 = *(void *)(v0 + 216);
  if (v1 < 0) {
    return 0;
  }
  if (v1 != *(void *)(v0 + 224)) {
    goto LABEL_5;
  }
  id result = [*(id *)(v0 + 208) countByEnumeratingWithState:v0 + 16 objects:v0 + 80 count:16];
  *(void *)(v0 + 224) = result;
  if (result)
  {
    uint64_t v1 = 0;
    *(void *)(v0 + 216) = 0;
LABEL_5:
    uint64_t v3 = *(void *)(v0 + 24);
    if (!v3) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/SetBridging.swift", 23, 2, 0x254uLL, 0);
    }
    if ((unint64_t)(v1 - 0x1000000000000000) >> 61 == 7)
    {
      uint64_t v4 = (void **)(v3 + 8 * v1);
      if ((v4 & 7) == 0)
      {
        uint64_t v5 = *v4;
        *(void *)(v0 + 216) = v1 + 1;
        return swift_unknownObjectRetain(v5);
      }
    }
    else
    {
      __break(1u);
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
  }
  *(void *)(v0 + 216) = -1;
  return result;
}

uint64_t _NativeSet.insertNew(_:isUnique:)(uint64_t a1, char a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 <= v6 || (a2 & 1) == 0)
  {
    Swift::Int v8 = v6 + 1;
    if (a2)
    {
      _NativeSet.resize(capacity:)(v8);
    }
    else if (v7 <= v6)
    {
      _NativeSet.copyAndResize(capacity:)(v8);
    }
    else
    {
      _NativeSet.copy()();
    }
  }
  uint64_t v9 = *v3;
  uint64_t v10 = *(void *)(a3 + 16);
  uint64_t v11 = *(void *)(a3 + 24);

  return _NativeSet._unsafeInsertNew(_:)(a1, v9, v10, v11);
}

uint64_t _NativeSet.capacity.getter(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t __RawSetStorage._bucketCount.getter()
{
  return 1 << *(unsigned char *)(v0 + 32);
}

uint64_t _NativeSet.hashTable.getter(uint64_t a1)
{
  return a1 + 56;
}

uint64_t __RawSetStorage._hashTable.getter()
{
  return v0 + 56;
}

uint64_t _NativeSet.age.getter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t _NativeSet._elements.getter(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

Swift::Void __swiftcall _NativeSet.invalidateIndices()()
{
  ++*(_DWORD *)(v0 + 36);
}

uint64_t _NativeSet.uncheckedElement(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, *(void *)(a2 + 48) + *(void *)(*(void *)(a3 - 8) + 72) * a1);
}

uint64_t _NativeSet.uncheckedInitialize(at:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(*(void *)(a3 + 48) + *(void *)(*(void *)(a4 - 8) + 72) * a1, a2, a4);
}

uint64_t _NativeSet.hashValue(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
}

unint64_t _NativeSet.find(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v27 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = *(void *)(v11 + 40);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 32);
  uint64_t v31 = a1;
  uint64_t v16 = v14(v12, v15, v13);
  uint64_t v17 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v18 = v16 & ~v17;
  uint64_t v32 = a2;
  uint64_t v30 = a2 + 56;
  if ((*(void *)(a2 + 56 + ((v18 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v18))
  {
    uint64_t v28 = ~v17;
    uint64_t v19 = *(void *)(a4 + 8);
    uint64_t v29 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v19 + 8);
    unint64_t v22 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
    uint64_t v21 = v8 + 16;
    unsigned int v20 = v22;
    uint64_t v23 = *(void *)(v21 + 56);
    uint64_t v24 = (void (**)(char *, uint64_t))(v21 - 8);
    do
    {
      v20(v10, *(void *)(v32 + 48) + v23 * v18, a3);
      char v25 = v29(v10, v31, a3, v19);
      (*v24)(v10, a3);
      if (v25) {
        break;
      }
      unint64_t v18 = (v18 + 1) & v28;
    }
    while (((*(void *)(v30 + ((v18 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v18) & 1) != 0);
  }
  return v18;
}

unint64_t _NativeSet.find(_:hashValue:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = a1;
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v22 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = -1 << *(unsigned char *)(v9 + 32);
  unint64_t v12 = v11 & ~v10;
  uint64_t v27 = v9;
  uint64_t v25 = v9 + 56;
  if ((*(void *)(v9 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v12))
  {
    uint64_t v23 = ~v10;
    uint64_t v13 = *(void *)(v5 + 8);
    uint64_t v24 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 8);
    uint64_t v16 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    uint64_t v14 = v6 + 16;
    uint64_t v15 = v16;
    uint64_t v17 = *(void *)(v14 + 56);
    unint64_t v18 = (void (**)(char *, uint64_t))(v14 - 8);
    do
    {
      uint64_t v19 = v14;
      v15(v8, *(void *)(v27 + 48) + v17 * v12, a4);
      char v20 = v24(v8, v26, a4, v13);
      (*v18)(v8, a4);
      if (v20) {
        break;
      }
      unint64_t v12 = (v12 + 1) & v23;
      uint64_t v14 = v19;
    }
    while (((*(void *)(v25 + ((v12 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v12) & 1) != 0);
  }
  return v12;
}

Swift::Int specialized _NativeSet.resize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  uint64_t v4 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000, 0, 1);
  if (!*(void *)(v2 + 16)) {
    goto LABEL_26;
  }
  uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v6 = (void *)(v2 + 56);
  uint64_t v7 = -1;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  unint64_t v8 = v7 & *(void *)(v2 + 56);
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  Swift::Int result = (Swift::Int)swift_retain((atomic_ullong *)v2);
  int64_t v11 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v12 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v13 = v12 | (v11 << 6);
      goto LABEL_8;
    }
    int64_t v14 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
      __break(1u);
LABEL_28:
      __break(1u);
      return result;
    }
    if (v14 >= v9) {
      goto LABEL_22;
    }
    unint64_t v15 = v6[v14];
    ++v11;
    if (!v15)
    {
      int64_t v11 = v14 + 1;
      if (v14 + 1 >= v9) {
        goto LABEL_22;
      }
      unint64_t v15 = v6[v11];
      if (!v15) {
        break;
      }
    }
LABEL_21:
    unint64_t v8 = (v15 - 1) & v15;
    unint64_t v13 = __clz(__rbit64(v15)) + (v11 << 6);
LABEL_8:
    Swift::Int result = specialized _NativeSet._unsafeInsertNew(_:)(*(void *)(*(void *)(v2 + 48) + 16 * v13), *(void *)(*(void *)(v2 + 48) + 16 * v13 + 8), (uint64_t)v4);
  }
  int64_t v16 = v14 + 2;
  if (v16 < v9)
  {
    unint64_t v15 = v6[v16];
    if (!v15)
    {
      while (1)
      {
        int64_t v11 = v16 + 1;
        if (__OFADD__(v16, 1)) {
          goto LABEL_28;
        }
        if (v11 >= v9) {
          goto LABEL_22;
        }
        unint64_t v15 = v6[v11];
        ++v16;
        if (v15) {
          goto LABEL_21;
        }
      }
    }
    int64_t v11 = v16;
    goto LABEL_21;
  }
LABEL_22:
  swift_release(v2);
  uint64_t v17 = 1 << *(unsigned char *)(v2 + 32);
  if (v17 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v17 + 63) >> 6, (int64x2_t *)(v2 + 56));
  }
  else {
    *uint64_t v6 = -1 << v17;
  }
  *(void *)(v2 + 16) = 0;
LABEL_26:
  Swift::Int result = swift_release(v2);
  *uint64_t v1 = (uint64_t)v4;
  return result;
}

void specialized _NativeSet.resize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  LOBYTE(v19[0]) = 1;
  uint64_t v4 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000, 0, 1);
  if (!*(void *)(v2 + 16)) {
    goto LABEL_26;
  }
  uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v6 = (void *)(v2 + 56);
  uint64_t v7 = -1;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  unint64_t v8 = v7 & *(void *)(v2 + 56);
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  swift_retain((atomic_ullong *)v2);
  int64_t v10 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v11 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v12 = v11 | (v10 << 6);
      goto LABEL_8;
    }
    int64_t v15 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
LABEL_28:
      __break(1u);
      return;
    }
    if (v15 >= v9) {
      goto LABEL_22;
    }
    unint64_t v16 = v6[v15];
    ++v10;
    if (!v16)
    {
      int64_t v10 = v15 + 1;
      if (v15 + 1 >= v9) {
        goto LABEL_22;
      }
      unint64_t v16 = v6[v10];
      if (!v16) {
        break;
      }
    }
LABEL_21:
    unint64_t v8 = (v16 - 1) & v16;
    unint64_t v12 = __clz(__rbit64(v16)) + (v10 << 6);
LABEL_8:
    uint64_t v13 = *(void *)(v2 + 48) + 40 * v12;
    long long v14 = *(_OWORD *)(v13 + 16);
    v19[0] = *(_OWORD *)v13;
    v19[1] = v14;
    uint64_t v20 = *(void *)(v13 + 32);
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)v19, (uint64_t)v4);
  }
  int64_t v17 = v15 + 2;
  if (v17 < v9)
  {
    unint64_t v16 = v6[v17];
    if (!v16)
    {
      while (1)
      {
        int64_t v10 = v17 + 1;
        if (__OFADD__(v17, 1)) {
          goto LABEL_28;
        }
        if (v10 >= v9) {
          goto LABEL_22;
        }
        unint64_t v16 = v6[v10];
        ++v17;
        if (v16) {
          goto LABEL_21;
        }
      }
    }
    int64_t v10 = v17;
    goto LABEL_21;
  }
LABEL_22:
  swift_release(v2);
  uint64_t v18 = 1 << *(unsigned char *)(v2 + 32);
  if (v18 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v18 + 63) >> 6, (int64x2_t *)(v2 + 56));
  }
  else {
    *uint64_t v6 = -1 << v18;
  }
  *(void *)(v2 + 16) = 0;
LABEL_26:
  swift_release(v2);
  *uint64_t v1 = (uint64_t)v4;
}

uint64_t specialized _NativeSet.resize(capacity:)(uint64_t a1, uint64_t (*a2)(void), uint64_t (*a3)(void, void *))
{
  uint64_t v6 = *v3;
  if (*(void *)(*v3 + 24) > a1) {
    a1 = *(void *)(*v3 + 24);
  }
  char v7 = specialized static _HashTable.scale(forCapacity:)(a1);
  unint64_t v8 = specialized static _SetStorage.allocate(scale:age:seed:)(v7, 0x100000000, 0, 1, a2);
  if (!*(void *)(v6 + 16)) {
    goto LABEL_26;
  }
  uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
  int64_t v10 = (void *)(v6 + 56);
  uint64_t v11 = -1;
  if (v9 < 64) {
    uint64_t v11 = ~(-1 << v9);
  }
  unint64_t v12 = v11 & *(void *)(v6 + 56);
  int64_t v13 = (unint64_t)(v9 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain((atomic_ullong *)v6);
  int64_t v15 = 0;
  while (1)
  {
    if (v12)
    {
      unint64_t v16 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v17 = v16 | (v15 << 6);
      goto LABEL_8;
    }
    int64_t v18 = v15 + 1;
    if (__OFADD__(v15, 1))
    {
      __break(1u);
LABEL_28:
      __break(1u);
      return result;
    }
    if (v18 >= v13) {
      goto LABEL_22;
    }
    unint64_t v19 = v10[v18];
    ++v15;
    if (!v19)
    {
      int64_t v15 = v18 + 1;
      if (v18 + 1 >= v13) {
        goto LABEL_22;
      }
      unint64_t v19 = v10[v15];
      if (!v19) {
        break;
      }
    }
LABEL_21:
    unint64_t v12 = (v19 - 1) & v19;
    unint64_t v17 = __clz(__rbit64(v19)) + (v15 << 6);
LABEL_8:
    uint64_t result = a3(*(void *)(*(void *)(v6 + 48) + 8 * v17), v8);
  }
  int64_t v20 = v18 + 2;
  if (v20 < v13)
  {
    unint64_t v19 = v10[v20];
    if (!v19)
    {
      while (1)
      {
        int64_t v15 = v20 + 1;
        if (__OFADD__(v20, 1)) {
          goto LABEL_28;
        }
        if (v15 >= v13) {
          goto LABEL_22;
        }
        unint64_t v19 = v10[v15];
        ++v20;
        if (v19) {
          goto LABEL_21;
        }
      }
    }
    int64_t v15 = v20;
    goto LABEL_21;
  }
LABEL_22:
  swift_release(v6);
  uint64_t v21 = 1 << *(unsigned char *)(v6 + 32);
  if (v21 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v21 + 63) >> 6, (int64x2_t *)(v6 + 56));
  }
  else {
    *int64_t v10 = -1 << v21;
  }
  *(void *)(v6 + 16) = 0;
LABEL_26:
  uint64_t result = swift_release(v6);
  *char v3 = (uint64_t)v8;
  return result;
}

Swift::Void __swiftcall _NativeSet.resize(capacity:)(Swift::Int capacity)
{
  char v3 = v2;
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](capacity);
  int64_t v10 = (char *)&v27 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *v2;
  if (*(void *)(*v2 + 24) <= v6) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = *(void *)(*v2 + 24);
  }
  uint64_t v13 = *(void *)(v7 + 24);
  type metadata accessor for _SetStorage(0, v4, v13, v8);
  char v14 = specialized static _HashTable.scale(forCapacity:)(v12);
  char v30 = 1;
  uint64_t v29 = static _SetStorage.allocate(scale:age:seed:)(v14, 0x100000000, 0, 1);
  if (*(void *)(v11 + 16))
  {
    uint64_t v28 = v3;
    uint64_t v15 = 1 << *(unsigned char *)(v11 + 32);
    unint64_t v16 = (void *)(v11 + 56);
    uint64_t v17 = -1;
    if (v15 < 64) {
      uint64_t v17 = ~(-1 << v15);
    }
    unint64_t v18 = v17 & *(void *)(v11 + 56);
    int64_t v19 = (unint64_t)(v15 + 63) >> 6;
    swift_retain((atomic_ullong *)v11);
    int64_t v20 = 0;
    while (1)
    {
      if (v18)
      {
        unint64_t v21 = __clz(__rbit64(v18));
        v18 &= v18 - 1;
        unint64_t v22 = v21 | (v20 << 6);
      }
      else
      {
        if (__OFADD__(v20++, 1)) {
          goto LABEL_27;
        }
        if (v20 >= v19)
        {
LABEL_21:
          swift_release(v11);
          uint64_t v26 = 1 << *(unsigned char *)(v11 + 32);
          if (v26 > 63) {
            specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v26 + 63) >> 6, (int64x2_t *)(v11 + 56));
          }
          else {
            *unint64_t v16 = -1 << v26;
          }
          char v3 = v28;
          *(void *)(v11 + 16) = 0;
          break;
        }
        unint64_t v24 = v16[v20];
        if (!v24)
        {
          int64_t v25 = v20 + 1;
          if (v20 + 1 >= v19) {
            goto LABEL_21;
          }
          unint64_t v24 = v16[v25];
          if (!v24)
          {
            while (1)
            {
              int64_t v20 = v25 + 1;
              if (__OFADD__(v25, 1)) {
                break;
              }
              if (v20 >= v19) {
                goto LABEL_21;
              }
              unint64_t v24 = v16[v20];
              ++v25;
              if (v24) {
                goto LABEL_20;
              }
            }
            __break(1u);
LABEL_27:
            __break(1u);
            return;
          }
          ++v20;
        }
LABEL_20:
        unint64_t v18 = (v24 - 1) & v24;
        unint64_t v22 = __clz(__rbit64(v24)) + (v20 << 6);
      }
      (*(void (**)(char *, unint64_t, uint64_t))(v5 + 32))(v10, *(void *)(v11 + 48) + *(void *)(v5 + 72) * v22, v4);
      _NativeSet._unsafeInsertNew(_:)((uint64_t)v10, (uint64_t)v29, v4, v13);
    }
  }
  swift_release(v11);
  *char v3 = v29;
}

void *static _SetStorage.resize(original:capacity:move:)(uint64_t a1, uint64_t a2)
{
  char v2 = specialized static _HashTable.scale(forCapacity:)(a2);

  return static _SetStorage.allocate(scale:age:seed:)(v2, 0x100000000, 0, 1);
}

uint64_t _NativeSet.count.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__n128 specialized _NativeSet._unsafeInsertNew(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 8))(v32, v5, v6);
  uint64_t v7 = v33;
  uint64_t v8 = v34;
  __swift_project_boxed_opaque_existential_0Tm(v32, v33);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 40))(v4, v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v32);
  uint64_t v10 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v11 = v9 & ~v10;
  uint64_t v27 = a2;
  uint64_t v12 = a2 + 56;
  unint64_t v13 = v11 >> 6;
  uint64_t v14 = *(void *)(a2 + 56 + 8 * (v11 >> 6));
  uint64_t v15 = 1 << v11;
  if (((1 << v11) & v14) != 0)
  {
    uint64_t v16 = ~v10;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v27 + 48) + 40 * v11, (uint64_t)v32);
      uint64_t v17 = v33;
      uint64_t v18 = v34;
      __swift_project_boxed_opaque_existential_0Tm(v32, v33);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v18 + 8))(v29, v17, v18);
      uint64_t v19 = v30;
      uint64_t v20 = v31;
      __swift_project_boxed_opaque_existential_0Tm(v29, v30);
      uint64_t v21 = *(void *)(a1 + 24);
      uint64_t v22 = *(void *)(a1 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)a1, v21);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v22 + 8))(v28, v21, v22);
      char v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v20 + 16))(v28, v19, v20);
      __swift_destroy_boxed_opaque_existential_1Tm(v28);
      if (v23 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        outlined destroy of AnyHashable(v32);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        outlined destroy of AnyHashable(v32);
        if (v23) {
          ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
        }
      }
      unint64_t v11 = (v11 + 1) & v16;
      unint64_t v13 = v11 >> 6;
      uint64_t v14 = *(void *)(v12 + 8 * (v11 >> 6));
      uint64_t v15 = 1 << v11;
    }
    while ((v14 & (1 << v11)) != 0);
  }
  *(void *)(v12 + 8 * v13) = v15 | v14;
  uint64_t v24 = *(void *)(v27 + 48) + 40 * v11;
  __n128 result = *(__n128 *)a1;
  long long v26 = *(_OWORD *)(a1 + 16);
  *(void *)(v24 + 32) = *(void *)(a1 + 32);
  *(__n128 *)uint64_t v24 = result;
  *(_OWORD *)(v24 + 16) = v26;
  ++*(void *)(v27 + 16);
  return result;
}

uint64_t specialized _NativeSet._unsafeInsertNew(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(a2 + 40), a1);
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = result & ~v5;
  uint64_t v7 = a2 + 56;
  unint64_t v8 = v6 >> 6;
  uint64_t v9 = *(void *)(a2 + 56 + 8 * (v6 >> 6));
  uint64_t v10 = 1 << v6;
  uint64_t v11 = *(void *)(a2 + 48);
  if (((1 << v6) & v9) != 0)
  {
    uint64_t v12 = ~v5;
    do
    {
      if (*(void *)(v11 + 8 * v6) == a1) {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for ObjectIdentifier);
      }
      unint64_t v6 = (v6 + 1) & v12;
      unint64_t v8 = v6 >> 6;
      uint64_t v9 = *(void *)(v7 + 8 * (v6 >> 6));
      uint64_t v10 = 1 << v6;
    }
    while ((v9 & (1 << v6)) != 0);
  }
  *(void *)(v7 + 8 * v8) = v10 | v9;
  *(void *)(v11 + 8 * v6) = a1;
  ++*(void *)(a2 + 16);
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(a2 + 40), a1);
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = result & ~v5;
  uint64_t v7 = a2 + 56;
  unint64_t v8 = v6 >> 6;
  uint64_t v9 = *(void *)(a2 + 56 + 8 * (v6 >> 6));
  uint64_t v10 = 1 << v6;
  uint64_t v11 = *(void *)(a2 + 48);
  if (((1 << v6) & v9) != 0)
  {
    uint64_t v12 = ~v5;
    do
    {
      if (*(void *)(v11 + 8 * v6) == a1) {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for Int);
      }
      unint64_t v6 = (v6 + 1) & v12;
      unint64_t v8 = v6 >> 6;
      uint64_t v9 = *(void *)(v7 + 8 * (v6 >> 6));
      uint64_t v10 = 1 << v6;
    }
    while ((v9 & (1 << v6)) != 0);
  }
  *(void *)(v7 + 8 * v8) = v10 | v9;
  *(void *)(v11 + 8 * v6) = a1;
  ++*(void *)(a2 + 16);
  return result;
}

Swift::Int specialized _NativeSet._unsafeInsertNew(_:)(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ *(void *)(a3 + 40);
  v22[0] = 0;
  v22[1] = v6 ^ 0x736F6D6570736575;
  v22[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v22[3] = v6 ^ 0x6C7967656E657261;
  v22[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v23 = 0u;
  long long v24 = 0u;
  String.hash(into:)(v22, a1, a2);
  Swift::Int result = Hasher._finalize()();
  uint64_t v8 = -1 << *(unsigned char *)(a3 + 32);
  unint64_t v9 = result & ~v8;
  uint64_t v10 = a3 + 56;
  unint64_t v11 = v9 >> 6;
  uint64_t v12 = *(void *)(a3 + 56 + 8 * (v9 >> 6));
  uint64_t v13 = 1 << v9;
  if (((1 << v9) & v12) != 0)
  {
    uint64_t v14 = ~v8;
    uint64_t v15 = *(void *)(a3 + 48);
    do
    {
      uint64_t v16 = (Swift::Int *)(v15 + 16 * v9);
      Swift::Int result = *v16;
      unint64_t v17 = v16[1];
      BOOL v18 = *v16 == a1 && v17 == a2;
      if (v18
        || ((~v17 & 0x6000000000000000) == 0 ? (BOOL v19 = (a2 & 0x2000000000000000) == 0) : (BOOL v19 = 1),
            !v19 ? (BOOL v20 = (a2 & 0x4000000000000000) == 0) : (BOOL v20 = 1),
            v20 && (Swift::Int result = _stringCompareInternal(_:_:expecting:)(result, v17, a1, a2, 0), (result & 1) != 0)))
      {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for String);
      }
      unint64_t v9 = (v9 + 1) & v14;
      unint64_t v11 = v9 >> 6;
      uint64_t v12 = *(void *)(v10 + 8 * (v9 >> 6));
      uint64_t v13 = 1 << v9;
    }
    while ((v12 & (1 << v9)) != 0);
  }
  *(void *)(v10 + 8 * v1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v13 | v12;
  uint64_t v21 = (unint64_t *)(*(void *)(a3 + 48) + 16 * v9);
  *uint64_t v21 = a1;
  v21[1] = a2;
  ++*(void *)(a3 + 16);
  return result;
}

uint64_t _NativeSet._unsafeInsertNew(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v32 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = *(void *)(v11 + 40);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 32);
  uint64_t v36 = a1;
  uint64_t v16 = v14(v12, v15, v13);
  uint64_t v17 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v18 = v16 & ~v17;
  uint64_t v37 = a2;
  unint64_t v19 = v18 >> 6;
  uint64_t v35 = a2 + 56;
  uint64_t v20 = *(void *)(a2 + 56 + 8 * (v18 >> 6));
  uint64_t v21 = 1 << v18;
  if (((1 << v18) & v20) != 0)
  {
    uint64_t v32 = v8;
    uint64_t v33 = ~v17;
    uint64_t v22 = *(void *)(a4 + 8);
    uint64_t v34 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 8);
    int64_t v25 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
    uint64_t v23 = v8 + 16;
    long long v24 = v25;
    uint64_t v26 = *(void *)(v23 + 56);
    do
    {
      uint64_t v27 = v26;
      v24(v10, *(void *)(v37 + 48) + v26 * v18, a3);
      char v28 = v34(v10, v36, a3, v22);
      (*(void (**)(char *, uint64_t))(v23 - 8))(v10, a3);
      if (v28) {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(a3);
      }
      unint64_t v18 = (v18 + 1) & v33;
      unint64_t v19 = v18 >> 6;
      uint64_t v20 = *(void *)(v35 + 8 * (v18 >> 6));
      uint64_t v21 = 1 << v18;
      uint64_t v26 = v27;
    }
    while ((v20 & (1 << v18)) != 0);
    uint64_t v8 = v32;
  }
  else
  {
    uint64_t v26 = *(void *)(v8 + 72);
  }
  uint64_t v29 = v36;
  *(void *)(v35 + 8 * v19) = v21 | v20;
  uint64_t v30 = v37;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v8 + 32))(*(void *)(v37 + 48) + v26 * v18, v29, a3);
  ++*(void *)(v30 + 16);
  return result;
}

uint64_t specialized _NativeSet.copyAndResize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  uint64_t v4 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000, 0, 1);
  if (!*(void *)(v2 + 16))
  {
LABEL_23:
    uint64_t result = swift_release(v2);
    *uint64_t v1 = (uint64_t)v4;
    return result;
  }
  uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v6 = v2 + 56;
  uint64_t v7 = -1;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  unint64_t v8 = v7 & *(void *)(v2 + 56);
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  uint64_t result = swift_retain_n(v2, 2);
  int64_t v11 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v12 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v13 = v12 | (v11 << 6);
      goto LABEL_8;
    }
    int64_t v17 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v17 >= v9) {
      goto LABEL_22;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    ++v11;
    if (!v18)
    {
      int64_t v11 = v17 + 1;
      if (v17 + 1 >= v9) {
        goto LABEL_22;
      }
      unint64_t v18 = *(void *)(v6 + 8 * v11);
      if (!v18) {
        break;
      }
    }
LABEL_21:
    unint64_t v8 = (v18 - 1) & v18;
    unint64_t v13 = __clz(__rbit64(v18)) + (v11 << 6);
LABEL_8:
    uint64_t v14 = (unint64_t *)(*(void *)(v2 + 48) + 16 * v13);
    unint64_t v15 = *v14;
    unint64_t v16 = v14[1];
    swift_bridgeObjectRetain(v16);
    uint64_t result = specialized _NativeSet._unsafeInsertNew(_:)(v15, v16, (uint64_t)v4);
  }
  int64_t v19 = v17 + 2;
  if (v19 >= v9)
  {
LABEL_22:
    swift_release_n(v2, 2);
    goto LABEL_23;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18)
  {
    int64_t v11 = v19;
    goto LABEL_21;
  }
  while (1)
  {
    int64_t v11 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v11 >= v9) {
      goto LABEL_22;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v11);
    ++v19;
    if (v18) {
      goto LABEL_21;
    }
  }
LABEL_25:
  __break(1u);
  return result;
}

void specialized _NativeSet.copyAndResize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  v16[0] = 1;
  uint64_t v4 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000, 0, 1);
  if (!*(void *)(v2 + 16))
  {
    swift_release(v2);
LABEL_24:
    *uint64_t v1 = (uint64_t)v4;
    return;
  }
  uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v6 = v2 + 56;
  uint64_t v7 = -1;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  unint64_t v8 = v7 & *(void *)(v2 + 56);
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  swift_retain((atomic_ullong *)v2);
  int64_t v10 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v11 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v12 = v11 | (v10 << 6);
      goto LABEL_8;
    }
    int64_t v13 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
      goto LABEL_26;
    }
    if (v13 >= v9) {
      goto LABEL_22;
    }
    unint64_t v14 = *(void *)(v6 + 8 * v13);
    ++v10;
    if (!v14)
    {
      int64_t v10 = v13 + 1;
      if (v13 + 1 >= v9) {
        goto LABEL_22;
      }
      unint64_t v14 = *(void *)(v6 + 8 * v10);
      if (!v14) {
        break;
      }
    }
LABEL_21:
    unint64_t v8 = (v14 - 1) & v14;
    unint64_t v12 = __clz(__rbit64(v14)) + (v10 << 6);
LABEL_8:
    outlined init with copy of AnyHashable(*(void *)(v2 + 48) + 40 * v12, (uint64_t)v16);
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)v16, (uint64_t)v4);
  }
  int64_t v15 = v13 + 2;
  if (v15 >= v9)
  {
LABEL_22:
    swift_release_n(v2, 2);
    goto LABEL_24;
  }
  unint64_t v14 = *(void *)(v6 + 8 * v15);
  if (v14)
  {
    int64_t v10 = v15;
    goto LABEL_21;
  }
  while (1)
  {
    int64_t v10 = v15 + 1;
    if (__OFADD__(v15, 1)) {
      break;
    }
    if (v10 >= v9) {
      goto LABEL_22;
    }
    unint64_t v14 = *(void *)(v6 + 8 * v10);
    ++v15;
    if (v14) {
      goto LABEL_21;
    }
  }
LABEL_26:
  __break(1u);
}

uint64_t specialized _NativeSet.copyAndResize(capacity:)(uint64_t a1, uint64_t (*a2)(void), uint64_t (*a3)(void, void *))
{
  uint64_t v6 = *v3;
  if (*(void *)(*v3 + 24) > a1) {
    a1 = *(void *)(*v3 + 24);
  }
  char v7 = specialized static _HashTable.scale(forCapacity:)(a1);
  unint64_t v8 = specialized static _SetStorage.allocate(scale:age:seed:)(v7, 0x100000000, 0, 1, a2);
  if (!*(void *)(v6 + 16))
  {
LABEL_23:
    uint64_t result = swift_release(v6);
    *char v3 = (uint64_t)v8;
    return result;
  }
  uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v10 = v6 + 56;
  uint64_t v11 = -1;
  if (v9 < 64) {
    uint64_t v11 = ~(-1 << v9);
  }
  unint64_t v12 = v11 & *(void *)(v6 + 56);
  int64_t v13 = (unint64_t)(v9 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain((atomic_ullong *)v6);
  int64_t v15 = 0;
  while (1)
  {
    if (v12)
    {
      unint64_t v16 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v17 = v16 | (v15 << 6);
      goto LABEL_8;
    }
    int64_t v18 = v15 + 1;
    if (__OFADD__(v15, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v18 >= v13) {
      goto LABEL_22;
    }
    unint64_t v19 = *(void *)(v10 + 8 * v18);
    ++v15;
    if (!v19)
    {
      int64_t v15 = v18 + 1;
      if (v18 + 1 >= v13) {
        goto LABEL_22;
      }
      unint64_t v19 = *(void *)(v10 + 8 * v15);
      if (!v19) {
        break;
      }
    }
LABEL_21:
    unint64_t v12 = (v19 - 1) & v19;
    unint64_t v17 = __clz(__rbit64(v19)) + (v15 << 6);
LABEL_8:
    uint64_t result = a3(*(void *)(*(void *)(v6 + 48) + 8 * v17), v8);
  }
  int64_t v20 = v18 + 2;
  if (v20 >= v13)
  {
LABEL_22:
    swift_release(v6);
    goto LABEL_23;
  }
  unint64_t v19 = *(void *)(v10 + 8 * v20);
  if (v19)
  {
    int64_t v15 = v20;
    goto LABEL_21;
  }
  while (1)
  {
    int64_t v15 = v20 + 1;
    if (__OFADD__(v20, 1)) {
      break;
    }
    if (v15 >= v13) {
      goto LABEL_22;
    }
    unint64_t v19 = *(void *)(v10 + 8 * v15);
    ++v20;
    if (v19) {
      goto LABEL_21;
    }
  }
LABEL_25:
  __break(1u);
  return result;
}

Swift::Void __swiftcall _NativeSet.copyAndResize(capacity:)(Swift::Int capacity)
{
  char v3 = v2;
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](capacity);
  uint64_t v10 = (char *)&v26 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *v2;
  if (*(void *)(*v2 + 24) <= v6) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = *(void *)(*v2 + 24);
  }
  uint64_t v13 = *(void *)(v7 + 24);
  type metadata accessor for _SetStorage(0, v4, v13, v8);
  char v14 = specialized static _HashTable.scale(forCapacity:)(v12);
  char v29 = 1;
  char v28 = static _SetStorage.allocate(scale:age:seed:)(v14, 0x100000000, 0, 1);
  if (!*(void *)(v11 + 16))
  {
    swift_release(v11);
LABEL_23:
    *char v3 = v28;
    return;
  }
  uint64_t v27 = v3;
  uint64_t v15 = 1 << *(unsigned char *)(v11 + 32);
  uint64_t v16 = v11 + 56;
  uint64_t v17 = -1;
  if (v15 < 64) {
    uint64_t v17 = ~(-1 << v15);
  }
  unint64_t v18 = v17 & *(void *)(v11 + 56);
  int64_t v19 = (unint64_t)(v15 + 63) >> 6;
  swift_retain((atomic_ullong *)v11);
  int64_t v20 = 0;
  while (1)
  {
    if (v18)
    {
      unint64_t v21 = __clz(__rbit64(v18));
      v18 &= v18 - 1;
      unint64_t v22 = v21 | (v20 << 6);
      goto LABEL_9;
    }
    if (__OFADD__(v20++, 1)) {
      goto LABEL_25;
    }
    if (v20 >= v19)
    {
LABEL_21:
      swift_release_n(v11, 2);
      char v3 = v27;
      goto LABEL_23;
    }
    unint64_t v24 = *(void *)(v16 + 8 * v20);
    if (!v24) {
      break;
    }
LABEL_20:
    unint64_t v18 = (v24 - 1) & v24;
    unint64_t v22 = __clz(__rbit64(v24)) + (v20 << 6);
LABEL_9:
    (*(void (**)(char *, unint64_t, uint64_t))(v5 + 16))(v10, *(void *)(v11 + 48) + *(void *)(v5 + 72) * v22, v4);
    _NativeSet._unsafeInsertNew(_:)((uint64_t)v10, (uint64_t)v28, v4, v13);
  }
  int64_t v25 = v20 + 1;
  if (v20 + 1 >= v19) {
    goto LABEL_21;
  }
  unint64_t v24 = *(void *)(v16 + 8 * v25);
  if (v24)
  {
    ++v20;
    goto LABEL_20;
  }
  while (1)
  {
    int64_t v20 = v25 + 1;
    if (__OFADD__(v25, 1)) {
      break;
    }
    if (v20 >= v19) {
      goto LABEL_21;
    }
    unint64_t v24 = *(void *)(v16 + 8 * v20);
    ++v25;
    if (v24) {
      goto LABEL_20;
    }
  }
  __break(1u);
LABEL_25:
  __break(1u);
}

void *specialized _NativeSet.copy()()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _SetStorage.allocate(scale:age:seed:)(*(unsigned char *)(*v0 + 32), *(unsigned int *)(*v0 + 36), *(void **)(*v0 + 40), 0);
  char v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v1);
    *uint64_t v0 = (uint64_t)v3;
    return result;
  }
  uint64_t result = v2 + 7;
  uint64_t v5 = v1 + 56;
  unint64_t v6 = (unint64_t)((1 << *((unsigned char *)v3 + 32)) + 63) >> 6;
  if (v3 != (void *)v1 || (unint64_t)result >= v1 + 56 + 8 * v6) {
    uint64_t result = memmove(result, (const void *)(v1 + 56), 8 * v6);
  }
  int64_t v8 = 0;
  v3[2] = *(void *)(v1 + 16);
  uint64_t v9 = 1 << *(unsigned char *)(v1 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v1 + 56);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }
    int64_t v19 = v8 + 1;
    if (__OFADD__(v8, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v19 >= v12) {
      goto LABEL_26;
    }
    unint64_t v20 = *(void *)(v5 + 8 * v19);
    ++v8;
    if (!v20)
    {
      int64_t v8 = v19 + 1;
      if (v19 + 1 >= v12) {
        goto LABEL_26;
      }
      unint64_t v20 = *(void *)(v5 + 8 * v8);
      if (!v20) {
        break;
      }
    }
LABEL_25:
    unint64_t v11 = (v20 - 1) & v20;
    unint64_t v14 = __clz(__rbit64(v20)) + (v8 << 6);
LABEL_12:
    uint64_t v15 = 16 * v14;
    uint64_t v16 = (void *)(*(void *)(v1 + 48) + v15);
    unint64_t v17 = v16[1];
    unint64_t v18 = (void *)(v3[6] + v15);
    *unint64_t v18 = *v16;
    v18[1] = v17;
    uint64_t result = (void *)swift_bridgeObjectRetain(v17);
  }
  int64_t v21 = v19 + 2;
  if (v21 >= v12) {
    goto LABEL_26;
  }
  unint64_t v20 = *(void *)(v5 + 8 * v21);
  if (v20)
  {
    int64_t v8 = v21;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v8 = v21 + 1;
    if (__OFADD__(v21, 1)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_26;
    }
    unint64_t v20 = *(void *)(v5 + 8 * v8);
    ++v21;
    if (v20) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  void *v3;
  char v4;
  void *v5;
  void *v6;
  void *result;
  uint64_t v8;
  unint64_t v9;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  long long v20;
  long long v21;
  int64_t v22;
  unint64_t v23;
  int64_t v24;
  _OWORD v25[2];
  uint64_t v26;

  uint64_t v1 = *v0;
  uint64_t v2 = *(unsigned int *)(*v0 + 36);
  char v3 = *(void **)(*v0 + 40);
  uint64_t v4 = *(unsigned char *)(*v0 + 32);
  LOBYTE(v25[0]) = 0;
  uint64_t v5 = specialized static _SetStorage.allocate(scale:age:seed:)(v4, v2, v3, 0);
  unint64_t v6 = v5;
  if (!*(void *)(v1 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v1);
    *uint64_t v0 = (uint64_t)v6;
    return result;
  }
  uint64_t result = v5 + 7;
  int64_t v8 = v1 + 56;
  uint64_t v9 = (unint64_t)((1 << *((unsigned char *)v6 + 32)) + 63) >> 6;
  if (v6 != (void *)v1 || (unint64_t)result >= v1 + 56 + 8 * v9) {
    uint64_t result = memmove(result, (const void *)(v1 + 56), 8 * v9);
  }
  unint64_t v11 = 0;
  v6[2] = *(void *)(v1 + 16);
  int64_t v12 = 1 << *(unsigned char *)(v1 + 32);
  unint64_t v13 = -1;
  if (v12 < 64) {
    unint64_t v13 = ~(-1 << v12);
  }
  unint64_t v14 = v13 & *(void *)(v1 + 56);
  uint64_t v15 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      uint64_t v16 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v17 = v16 | (v11 << 6);
      goto LABEL_12;
    }
    unint64_t v22 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v22 >= v15) {
      goto LABEL_26;
    }
    uint64_t v23 = *(void *)(v8 + 8 * v22);
    ++v11;
    if (!v23)
    {
      unint64_t v11 = v22 + 1;
      if (v22 + 1 >= v15) {
        goto LABEL_26;
      }
      uint64_t v23 = *(void *)(v8 + 8 * v11);
      if (!v23) {
        break;
      }
    }
LABEL_25:
    unint64_t v14 = (v23 - 1) & v23;
    unint64_t v17 = __clz(__rbit64(v23)) + (v11 << 6);
LABEL_12:
    unint64_t v18 = 40 * v17;
    uint64_t result = (void *)outlined init with copy of AnyHashable(*(void *)(v1 + 48) + 40 * v17, (uint64_t)v25);
    int64_t v19 = v6[6] + v18;
    unint64_t v20 = v25[0];
    int64_t v21 = v25[1];
    *(void *)(v19 + 32) = v26;
    *(_OWORD *)int64_t v19 = v20;
    *(_OWORD *)(v19 + 16) = v21;
  }
  unint64_t v24 = v22 + 2;
  if (v24 >= v15) {
    goto LABEL_26;
  }
  uint64_t v23 = *(void *)(v8 + 8 * v24);
  if (v23)
  {
    unint64_t v11 = v24;
    goto LABEL_25;
  }
  while (1)
  {
    unint64_t v11 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v11 >= v15) {
      goto LABEL_26;
    }
    uint64_t v23 = *(void *)(v8 + 8 * v11);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *specialized _NativeSet.copy()(uint64_t (*a1)(void))
{
  uint64_t v2 = *v1;
  char v3 = specialized static _SetStorage.allocate(scale:age:seed:)(*(unsigned char *)(*v1 + 32), *(unsigned int *)(*v1 + 36), *(void **)(*v1 + 40), 0, a1);
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v2);
    *uint64_t v1 = (uint64_t)v4;
    return result;
  }
  uint64_t result = v3 + 7;
  uint64_t v6 = v2 + 56;
  unint64_t v7 = (unint64_t)((1 << *((unsigned char *)v4 + 32)) + 63) >> 6;
  if (v4 != (void *)v2 || (unint64_t)result >= v2 + 56 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 56), 8 * v7);
  }
  int64_t v9 = 0;
  v4[2] = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 56);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v16 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v16 >= v13) {
      goto LABEL_26;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v16);
    ++v9;
    if (!v17)
    {
      int64_t v9 = v16 + 1;
      if (v16 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v17 = *(void *)(v6 + 8 * v9);
      if (!v17) {
        break;
      }
    }
LABEL_25:
    unint64_t v19 = __clz(__rbit64(v17));
    unint64_t v12 = (v17 - 1) & v17;
    unint64_t v15 = v19 + (v9 << 6);
LABEL_12:
    *(void *)(v4[6] + 8 * v15) = *(void *)(*(void *)(v2 + 48) + 8 * v15);
  }
  int64_t v18 = v16 + 2;
  if (v18 >= v13) {
    goto LABEL_26;
  }
  unint64_t v17 = *(void *)(v6 + 8 * v18);
  if (v17)
  {
    int64_t v9 = v18;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v18 + 1;
    if (__OFADD__(v18, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v9);
    ++v18;
    if (v17) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

Swift::Void __swiftcall _NativeSet.copy()()
{
  uint64_t v2 = v1;
  uint64_t v3 = *(void *)(v0 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = ((uint64_t (*)())MEMORY[0x1F4188790])();
  unint64_t v7 = (char *)&v31 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = *v1;
  type metadata accessor for _SetStorage(0, v3, *(void *)(v5 + 24), v9);
  uint64_t v10 = *(unsigned int *)(v8 + 36);
  uint64_t v11 = *(void **)(v8 + 40);
  char v12 = *(unsigned char *)(v8 + 32);
  char v34 = 0;
  int64_t v13 = static _SetStorage.allocate(scale:age:seed:)(v12, v10, v11, 0);
  unint64_t v14 = v13;
  if (!*(void *)(v8 + 16))
  {
    swift_release(v8);
LABEL_26:
    uint64_t *v2 = (uint64_t)v14;
    return;
  }
  uint64_t v31 = v2;
  unint64_t v15 = v13 + 7;
  uint64_t v16 = v8 + 56;
  unint64_t v17 = (unint64_t)((1 << *((unsigned char *)v14 + 32)) + 63) >> 6;
  if (v14 != (void *)v8 || (unint64_t)v15 >= v8 + 56 + 8 * v17) {
    memmove(v15, (const void *)(v8 + 56), 8 * v17);
  }
  int64_t v19 = 0;
  uint64_t v20 = *(void *)(v8 + 16);
  uint64_t v32 = v14;
  uint64_t v33 = v8;
  void v14[2] = v20;
  uint64_t v21 = 1 << *(unsigned char *)(v8 + 32);
  uint64_t v22 = -1;
  if (v21 < 64) {
    uint64_t v22 = ~(-1 << v21);
  }
  unint64_t v23 = v22 & *(void *)(v8 + 56);
  int64_t v24 = (unint64_t)(v21 + 63) >> 6;
  while (1)
  {
    if (v23)
    {
      unint64_t v25 = __clz(__rbit64(v23));
      v23 &= v23 - 1;
      unint64_t v26 = v25 | (v19 << 6);
      goto LABEL_12;
    }
    if (__OFADD__(v19++, 1)) {
      goto LABEL_28;
    }
    if (v19 >= v24)
    {
LABEL_24:
      swift_release(v33);
      uint64_t v2 = v31;
      unint64_t v14 = v32;
      goto LABEL_26;
    }
    unint64_t v29 = *(void *)(v16 + 8 * v19);
    if (!v29) {
      break;
    }
LABEL_23:
    unint64_t v23 = (v29 - 1) & v29;
    unint64_t v26 = __clz(__rbit64(v29)) + (v19 << 6);
LABEL_12:
    unint64_t v27 = *(void *)(v4 + 72) * v26;
    (*(void (**)(char *, unint64_t, uint64_t))(v4 + 16))(v7, *(void *)(v33 + 48) + v27, v3);
    (*(void (**)(unint64_t, char *, uint64_t))(v4 + 32))(v32[6] + v27, v7, v3);
  }
  int64_t v30 = v19 + 1;
  if (v19 + 1 >= v24) {
    goto LABEL_24;
  }
  unint64_t v29 = *(void *)(v16 + 8 * v30);
  if (v29)
  {
    ++v19;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v19 = v30 + 1;
    if (__OFADD__(v30, 1)) {
      break;
    }
    if (v19 >= v24) {
      goto LABEL_24;
    }
    unint64_t v29 = *(void *)(v16 + 8 * v19);
    ++v30;
    if (v29) {
      goto LABEL_23;
    }
  }
  __break(1u);
LABEL_28:
  __break(1u);
}

void *static _SetStorage.copy(original:)(uint64_t a1)
{
  return static _SetStorage.allocate(scale:age:seed:)(*(unsigned char *)(a1 + 32), *(unsigned int *)(a1 + 36), *(void **)(a1 + 40), 0);
}

Swift::Bool __swiftcall _NativeSet.ensureUnique(isUnique:capacity:)(Swift::Bool isUnique, Swift::Int capacity)
{
  Swift::Int v4 = *(void *)(*(void *)v2 + 24);
  if (v4 >= capacity)
  {
    if (!isUnique) {
      _NativeSet.copy()();
    }
  }
  else if (isUnique)
  {
    _NativeSet.resize(capacity:)(capacity);
  }
  else
  {
    _NativeSet.copyAndResize(capacity:)(capacity);
  }
  return v4 < capacity;
}

Swift::_HashTable::Bucket __swiftcall _NativeSet.validatedBucket(for:)(Swift::_HashTable::Index a1)
{
  if (a1.bucket.offset < 0
    || 1 << *(unsigned char *)(v1 + 32) <= a1.bucket.offset
    || ((*(void *)(v1 + 8 * ((unint64_t)a1.bucket.offset >> 6) + 56) >> SLOBYTE(a1.bucket.offset)) & 1) == 0
    || *(_DWORD *)(v1 + 36) != a1.age)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/NativeSet.swift", 21, 2, 0x10AuLL, 0);
  }
  return a1.bucket;
}

uint64_t _NativeSet.validatedBucket(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6)
{
  uint64_t v10 = a1;
  uint64_t v11 = *((void *)a5 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  unint64_t v14 = (char *)v33 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  char v39 = (char *)v33 - v15;
  if (v16)
  {
    if (v10 >= 0) {
      uint64_t v18 = v10 & 0xFFFFFFFFFFFFFF8;
    }
    else {
      uint64_t v18 = v10;
    }
    uint64_t v19 = type metadata accessor for __CocoaSet.Index.Storage();
    swift_bridgeObjectRetain(v10);
    if (!swift_dynamicCastClass(v18, v19)) {
      goto LABEL_24;
    }
    if (*(_DWORD *)(a4 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v18 + 16))) {
      goto LABEL_20;
    }
    if (!swift_dynamicCastClass(v18, v19)) {
LABEL_24:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
    uint64_t v20 = *(void *)(v18 + 24);
    if (*(void *)(v20 + 16) <= a2) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/SetBridging.swift", 23, 2, 0x1E1uLL, 0);
    }
    uint64_t v21 = *(void **)(v20 + 8 * a2 + 24);
    swift_unknownObjectRetain(v21);
    outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
    _forceBridgeFromObjectiveC<A>(_:_:)(v21, a5, v22, v39);
    swift_unknownObjectRelease(v21);
    uint64_t v23 = (*(uint64_t (**)(void, char *, uint64_t))(a6 + 32))(*(void *)(a4 + 40), a5, a6);
    uint64_t v24 = -1 << *(unsigned char *)(a4 + 32);
    uint64_t v10 = v23 & ~v24;
    uint64_t v38 = a4;
    uint64_t v35 = a4 + 56;
    if (((*(void *)(a4 + 56 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) == 0)
    {
      (*(void (**)(char *, char *))(v11 + 8))(v39, a5);
LABEL_20:
      unint64_t v17 = 287;
LABEL_7:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/NativeSet.swift", 21, 2, v17, 0);
    }
    uint64_t v34 = ~v24;
    uint64_t v37 = *(void *)(a6 + 8);
    uint64_t v36 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v37 + 8);
    unint64_t v27 = *(void (**)(char *, uint64_t, char *))(v11 + 16);
    uint64_t v25 = v11 + 16;
    unint64_t v26 = v27;
    uint64_t v28 = *(void *)(v25 + 56);
    unint64_t v29 = (void (**)(char *, char *))(v25 - 8);
    v33[1] = (unint64_t)v29 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    while (1)
    {
      v26(v14, *(void *)(v38 + 48) + v28 * v10, a5);
      char v30 = v36(v14, v39, a5, v37);
      uint64_t v31 = *v29;
      (*v29)(v14, a5);
      if (v30) {
        break;
      }
      uint64_t v10 = (v10 + 1) & v34;
      if (((*(void *)(v35 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) == 0)
      {
        v31(v39, a5);
        goto LABEL_20;
      }
    }
    v31(v39, a5);
  }
  else if (v10 < 0 {
         || 1 << *(unsigned char *)(a4 + 32) <= v10
  }
         || ((*(void *)(a4 + 8 * ((unint64_t)v10 >> 6) + 56) >> v10) & 1) == 0
         || *(_DWORD *)(a4 + 36) != a2)
  {
    unint64_t v17 = 266;
    goto LABEL_7;
  }
  return v10;
}

unint64_t Set.Index._asCocoa.getter(unint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/Set.swift", 15, 2, 0x567uLL, 0);
  }
  return swift_bridgeObjectRetain(a1);
}

uint64_t __CocoaSet.Index.age.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.age.getter(a1, a2, type metadata accessor for __CocoaSet.Index.Storage);
}

uint64_t __CocoaDictionary.Index.age.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v4 = a3();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  return specialized static Hasher._hash(seed:_:)(0, *(void *)(v3 + 16));
}

id __CocoaSet.Index.element.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)specialized __CocoaSet.Index.element.getter(a1, a2);

  return swift_unknownObjectRetain(v2);
}

BOOL Set.Index._isNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

void Set.Index._asNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  if (a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/Set.swift", 15, 2, 0x55AuLL, 0);
  }
}

uint64_t _NativeSet.startIndex.getter(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 56);
  if (v1)
  {
    uint64_t v2 = 0;
    return __clz(__rbit64(v1)) + v2;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 1 << *(unsigned char *)(a1 + 32);
    unint64_t v4 = ((unint64_t)(v3 + 63) >> 6) - 1;
    uint64_t v5 = (unint64_t *)(a1 + 64);
    while (v4)
    {
      unint64_t v6 = *v5++;
      unint64_t v1 = v6;
      --v4;
      v2 += 64;
      if (v6) {
        return __clz(__rbit64(v1)) + v2;
      }
    }
  }
  return v3;
}

uint64_t _NativeSet.endIndex.getter(uint64_t a1)
{
  return 1 << *(unsigned char *)(a1 + 32);
}

int64_t specialized _NativeSet.index(after:)(unint64_t a1, int a2, char a3, uint64_t a4)
{
  if (a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/Set.swift", 15, 2, 0x55AuLL, 0);
  }
  if ((a1 & 0x8000000000000000) != 0
    || (int64_t result = 1 << *(unsigned char *)(a4 + 32), result <= (uint64_t)a1)
    || (v6 = a1 >> 6, uint64_t v7 = a4 + 56, v8 = *(void *)(a4 + 56 + 8 * (a1 >> 6)), ((v8 >> a1) & 1) == 0)
    || *(_DWORD *)(a4 + 36) != a2)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/NativeSet.swift", 21, 2, 0x10AuLL, 0);
  }
  unint64_t v9 = v8 & (-2 << (a1 & 0x3F));
  if (v9) {
    return __clz(__rbit64(v9)) | a1 & 0xFFFFFFFFFFFFFFC0;
  }
  unint64_t v10 = v6 + 1;
  unint64_t v11 = (unint64_t)(result + 63) >> 6;
  if (v6 + 1 < v11)
  {
    unint64_t v12 = *(void *)(v7 + 8 * v10);
    if (v12) {
      return __clz(__rbit64(v12)) + (v10 << 6);
    }
    unint64_t v10 = v6 + 2;
    if (v6 + 2 < v11)
    {
      unint64_t v12 = *(void *)(v7 + 8 * v10);
      if (v12) {
        return __clz(__rbit64(v12)) + (v10 << 6);
      }
      while (v11 - 3 != v6)
      {
        unint64_t v12 = *(void *)(a4 + 80 + 8 * v6++);
        if (v12)
        {
          unint64_t v10 = v6 + 2;
          return __clz(__rbit64(v12)) + (v10 << 6);
        }
      }
    }
  }
  return result;
}

int64_t _NativeSet.index(after:)(unint64_t a1, int a2, char a3, uint64_t a4)
{
  if (a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/Set.swift", 15, 2, 0x55AuLL, 0);
  }
  if ((a1 & 0x8000000000000000) != 0
    || (int64_t result = 1 << *(unsigned char *)(a4 + 32), result <= (uint64_t)a1)
    || (v6 = a1 >> 6, unint64_t v7 = *(void *)(a4 + 56 + 8 * (a1 >> 6)), ((v7 >> a1) & 1) == 0)
    || *(_DWORD *)(a4 + 36) != a2)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/NativeSet.swift", 21, 2, 0x10AuLL, 0);
  }
  unint64_t v8 = v7 & (-2 << (a1 & 0x3F));
  if (v8) {
    return __clz(__rbit64(v8)) | a1 & 0xFFFFFFFFFFFFFFC0;
  }
  unint64_t v9 = v6 + 1;
  unint64_t v10 = (unint64_t)(result + 63) >> 6;
  if (v6 + 1 < v10)
  {
    unint64_t v11 = *(void *)(a4 + 56 + 8 * v9);
    if (v11)
    {
      return __clz(__rbit64(v11)) + (v9 << 6);
    }
    else
    {
      while (v10 - 2 != v6)
      {
        unint64_t v11 = *(void *)(a4 + 72 + 8 * v6++);
        if (v11)
        {
          unint64_t v9 = v6 + 1;
          return __clz(__rbit64(v11)) + (v9 << 6);
        }
      }
    }
  }
  return result;
}

unint64_t _NativeSet.index(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v10 = (char *)&v23 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!*(void *)(v11 + 16)) {
    return 0;
  }
  uint64_t v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  uint64_t v13 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v14 = v12 & ~v13;
  uint64_t v27 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) == 0) {
    return 0;
  }
  uint64_t v28 = a2;
  uint64_t v24 = ~v13;
  uint64_t v15 = *(void *)(a4 + 8);
  uint64_t v25 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 8);
  uint64_t v26 = a1;
  uint64_t v18 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
  uint64_t v16 = v8 + 16;
  unint64_t v17 = v18;
  uint64_t v19 = *(void *)(v16 + 56);
  uint64_t v20 = (void (**)(char *, uint64_t))(v16 - 8);
  while (1)
  {
    v17(v10, *(void *)(v28 + 48) + v19 * v14, a3);
    char v21 = v25(v10, v26, a3, v15);
    (*v20)(v10, a3);
    if (v21) {
      break;
    }
    unint64_t v14 = (v14 + 1) & v24;
    if (((*(void *)(v27 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) == 0) {
      return 0;
    }
  }
  return v14;
}

uint64_t _NativeSet.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v10 = (char *)&v23 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (*(void *)(v11 + 16)
    && (uint64_t v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4),
        uint64_t v13 = -1 << *(unsigned char *)(a2 + 32),
        unint64_t v14 = v12 & ~v13,
        uint64_t v28 = a2 + 56,
        ((*(void *)(a2 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) != 0))
  {
    uint64_t v26 = a1;
    uint64_t v27 = a2;
    uint64_t v24 = ~v13;
    uint64_t v15 = *(void *)(a4 + 8);
    uint64_t v25 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 8);
    uint64_t v18 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
    uint64_t v16 = v8 + 16;
    unint64_t v17 = v18;
    uint64_t v19 = *(void *)(v16 + 56);
    uint64_t v20 = (void (**)(char *, uint64_t))(v16 - 8);
    do
    {
      v17(v10, *(void *)(v27 + 48) + v19 * v14, a3);
      char v21 = v25(v10, v26, a3, v15);
      (*v20)(v10, a3);
      if (v21) {
        break;
      }
      unint64_t v14 = (v14 + 1) & v24;
    }
    while (((*(void *)(v28 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) != 0);
  }
  else
  {
    char v21 = 0;
  }
  return v21 & 1;
}

uint64_t _NativeSet.element(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v12 = *((void *)a4 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](a1);
  uint64_t v15 = (char *)v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v44 = (char *)v37 - v16;
  if ((v17 & 1) == 0)
  {
    if ((a1 & 0x8000000000000000) == 0
      && 1 << *(unsigned char *)(a3 + 32) > a1
      && ((*(void *)(a3 + 8 * ((unint64_t)a1 >> 6) + 56) >> a1) & 1) != 0
      && *(_DWORD *)(a3 + 36) == a2)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, char *))(v12 + 16))(a6, *(void *)(a3 + 48) + *(void *)(v12 + 72) * a1, a4);
    }
    unint64_t v36 = 266;
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/NativeSet.swift", 21, 2, v36, 0);
  }
  if (a1 >= 0) {
    uint64_t v19 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  else {
    uint64_t v19 = a1;
  }
  uint64_t v20 = type metadata accessor for __CocoaSet.Index.Storage();
  swift_bridgeObjectRetain(a1);
  if (!swift_dynamicCastClass(v19, v20)) {
    goto LABEL_25;
  }
  if (*(_DWORD *)(a3 + 36) != specialized static Hasher._hash(seed:_:)(0, *(void *)(v19 + 16))) {
    goto LABEL_19;
  }
  if (!swift_dynamicCastClass(v19, v20)) {
LABEL_25:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  uint64_t v21 = *(void *)(v19 + 24);
  if (*(void *)(v21 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/SetBridging.swift", 23, 2, 0x1E1uLL, 0);
  }
  uint64_t v38 = a6;
  uint64_t v22 = *(void **)(v21 + 8 * a2 + 24);
  swift_unknownObjectRetain(v22);
  outlined consume of [A : B].Index._Variant<A, B>(a1, a2, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v22, a4, v23, v44);
  swift_unknownObjectRelease(v22);
  uint64_t v24 = (*(uint64_t (**)(void, char *, uint64_t))(a5 + 32))(*(void *)(a3 + 40), a4, a5);
  uint64_t v25 = -1 << *(unsigned char *)(a3 + 32);
  unint64_t v26 = v24 & ~v25;
  uint64_t v43 = a3;
  uint64_t v40 = a3 + 56;
  if (((*(void *)(a3 + 56 + ((v26 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v26) & 1) == 0)
  {
    (*(void (**)(char *, char *))(v12 + 8))(v44, a4);
LABEL_19:
    unint64_t v36 = 287;
    goto LABEL_23;
  }
  uint64_t v39 = ~v25;
  uint64_t v42 = *(void *)(a5 + 8);
  uint64_t v41 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v42 + 8);
  unint64_t v29 = *(void (**)(void, void, void))(v12 + 16);
  uint64_t v28 = v12 + 16;
  uint64_t v27 = v29;
  uint64_t v30 = *(void *)(v28 + 56);
  uint64_t v31 = (void (**)(char *, char *))(v28 - 8);
  v37[1] = (v28 - 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  v37[2] = v28 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  while (1)
  {
    uint64_t v32 = v30;
    uint64_t v33 = v27;
    v27(v15, *(void *)(v43 + 48) + v30 * v26, a4);
    char v34 = v41(v15, v44, a4, v42);
    uint64_t v35 = *v31;
    (*v31)(v15, a4);
    if (v34) {
      break;
    }
    unint64_t v26 = (v26 + 1) & v39;
    uint64_t v27 = v33;
    uint64_t v30 = v32;
    if (((*(void *)(v40 + ((v26 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v26) & 1) == 0)
    {
      v35(v44, a4);
      goto LABEL_19;
    }
  }
  v35(v44, a4);
  return ((uint64_t (*)(uint64_t, unint64_t, char *))v33)(v38, *(void *)(v43 + 48) + v32 * v26, a4);
}

void ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(uint64_t a1)
{
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(186);
  uint64_t v7 = v5;
  unint64_t v8 = v6;
  uint64_t v329 = v5;
  unint64_t v330 = v6;
  uint64_t v9 = HIBYTE(v6) & 0xF;
  uint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v11 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    unint64_t v12 = 0x80000001816DED50 | 0x8000000000000000;
    uint64_t v329 = 0xD00000000000001CLL;
    goto LABEL_86;
  }
  int64_t v3 = (int64_t)"Duplicate elements of type '";
  if ((v6 & 0x2000000000000000) != 0 && (0x80000001816DED50 & 0x2000000000000000) != 0)
  {
    unint64_t v13 = v9 + ((0x80000001816DED50 >> 56) & 0xF);
    if (v13 <= 0xF)
    {
      unint64_t v32 = (0x80000001816DED50 >> 56) & 0xF;
      if (v32)
      {
        char v53 = 0;
        uint64_t v54 = 0;
        unint64_t v33 = v6;
        do
        {
          uint64_t v55 = v9 + v54;
          uint64_t v56 = v54 + 1;
          unint64_t v57 = 0x80000001816DED50 | 0x8000000000000000;
          if (v54 < 8) {
            unint64_t v57 = 0xD00000000000001CLL;
          }
          unint64_t v58 = v57 >> (v53 & 0x38);
          char v59 = (8 * v9 + v53) & 0x38;
          uint64_t v60 = (-255 << v59) - 1;
          unint64_t v61 = (unint64_t)v58 << v59;
          unint64_t v62 = v61 | v60 & v33;
          unint64_t v63 = v61 | v60 & v7;
          if (v55 < 8) {
            uint64_t v7 = v63;
          }
          else {
            unint64_t v33 = v62;
          }
          v53 += 8;
          uint64_t v54 = v56;
        }
        while (v32 != v56);
      }
      else
      {
        unint64_t v33 = v6;
      }
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x80000001816DED50 | 0x8000000000000000);
      unint64_t v64 = 0xA000000000000000;
      if (!(v7 & 0x8080808080808080 | v33 & 0x80808080808080)) {
        unint64_t v64 = 0xE000000000000000;
      }
      unint64_t v12 = v64 & 0xFF00000000000000 | (v13 << 56) | v33 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_85;
    }
  }
  int64_t v2 = 0x80000001816DED50 | 0x8000000000000000;
  if ((0x80000001816DED50 & 0x2000000000000000) != 0) {
    uint64_t v14 = (0x80000001816DED50 >> 56) & 0xF;
  }
  else {
    uint64_t v14 = 28;
  }
  swift_bridgeObjectRetain_n(0x80000001816DED50 | 0x8000000000000000, 2);
  if ((0x80000001816DED50 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRetain_n(0x80000001816DED50 | 0x8000000000000000, 5);
    v302._Swift::UInt64 rawBits = 1;
    v303._Swift::UInt64 rawBits = (v14 << 16) | 1;
    v304._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v302, v303, 0xD00000000000001CLL, 0x80000001816DED50 | 0x8000000000000000);
    if (v304._rawBits < 0x10000) {
      v304._rawBits |= 3;
    }
    int64_t v1 = specialized Collection.count.getter(v304, v305, 0xD00000000000001CLL, 0x80000001816DED50 | 0x8000000000000000);
    swift_bridgeObjectRelease(0x80000001816DED50 | 0x8000000000000000);
    if ((v8 & 0x1000000000000000) == 0)
    {
LABEL_15:
      BOOL v15 = __OFADD__(v11, v1);
      uint64_t v16 = v11 + v1;
      if (!v15)
      {
LABEL_16:
        int64_t v2 = v7 & ~v8;
        if ((v2 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v17 = _StringGuts.nativeUnusedCapacity.getter(v7, v8);
          if (v18)
          {
LABEL_247:
            unint64_t v173 = 258;
            goto LABEL_248;
          }
          if (v16 > 15) {
            goto LABEL_24;
          }
          if ((v8 & 0x2000000000000000) == 0)
          {
            if (v17 < v1)
            {
LABEL_35:
              if ((v8 & 0x1000000000000000) == 0)
              {
                if ((v7 & 0x1000000000000000) != 0)
                {
                  uint64_t v23 = (unsigned __int8 *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
                }
                else
                {
                  uint64_t v23 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v8);
                  uint64_t v10 = v321;
                }
                swift_bridgeObjectRetain(v8);
                closure #1 in _StringGuts._convertedToSmall()(v23, v10, &v327);
                swift_bridgeObjectRelease(v8);
                uint64_t v7 = v327;
                uint64_t v10 = v328;
                goto LABEL_58;
              }
              goto LABEL_328;
            }
LABEL_24:
            int64_t v19 = _StringGuts.nativeUnusedCapacity.getter(v7, v8);
            BOOL v22 = (v20 & 1) == 0 && v19 >= v1;
            if ((v2 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
            {
              if (v22)
              {
LABEL_47:
                if ((0x80000001816DED50 & 0x1000000000000000) != 0)
                {
                  _StringGuts._foreignAppendInPlace(_:)(0xD00000000000001CLL, 0x80000001816DED50 | 0x8000000000000000, 0, v14);
                  unint64_t v31 = 0x80000001816DED50 | 0x8000000000000000;
                }
                else
                {
                  char v28 = (0x80000001816DED50 & 0x2000000000000000) == 0
                     || (0x80000001816DED50 & 0x4000000000000000) != 0;
                  swift_bridgeObjectRelease_n(0x80000001816DED50 | 0x8000000000000000, 5);
                  if ((0x80000001816DED50 & 0x2000000000000000) != 0)
                  {
                    swift_bridgeObjectRelease(0x80000001816DED50 | 0x8000000000000000);
                    unint64_t v327 = 0xD00000000000001CLL;
                    unint64_t v328 = 0x80000001816DED50 & 0xFFFFFFFFFFFFFFLL;
                    unint64_t v131 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v14, (uint64_t)&v327, (0x80000001816DED50 >> 56) & 0xF);
                    _StringGuts.appendInPlace(_:isASCII:)(v131, v132, v28);
                    swift_bridgeObjectRelease(0x80000001816DED50 | 0x8000000000000000);
                    goto LABEL_87;
                  }
                  unint64_t v29 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v14, (0x80000001816DED50 & 0xFFFFFFFFFFFFFFFLL) + 32, 28);
                  _StringGuts.appendInPlace(_:isASCII:)(v29, v30, v28);
                  unint64_t v31 = 0x80000001816DED50 | 0x8000000000000000;
                }
                swift_bridgeObjectRelease_n(v31, 2);
                goto LABEL_87;
              }
            }
            else if (v22)
            {
LABEL_46:
              _StringGuts.grow(_:)(v16);
              goto LABEL_47;
            }
            uint64_t v24 = _StringGuts.nativeCapacity.getter(v7, v8);
            if (v25) {
              uint64_t v26 = 0;
            }
            else {
              uint64_t v26 = v24;
            }
            if (v26 + 0x4000000000000000 < 0) {
              goto LABEL_327;
            }
            uint64_t v27 = 2 * v26;
            if (v27 > v16) {
              uint64_t v16 = v27;
            }
            goto LABEL_46;
          }
        }
        else
        {
          if (v16 > 15) {
            goto LABEL_24;
          }
          if ((v8 & 0x2000000000000000) == 0) {
            goto LABEL_35;
          }
        }
        uint64_t v10 = v8;
        goto LABEL_58;
      }
      goto LABEL_309;
    }
  }
  else
  {
    swift_bridgeObjectRetain_n(0x80000001816DED50 | 0x8000000000000000, 4);
    int64_t v1 = v14;
    if ((v8 & 0x1000000000000000) == 0) {
      goto LABEL_15;
    }
  }
  Swift::Int v306 = String.UTF8View._foreignCount()();
  uint64_t v16 = v306 + v1;
  if (!__OFADD__(v306, v1)) {
    goto LABEL_16;
  }
LABEL_309:
  __break(1u);
LABEL_310:
  __break(1u);
  while (1)
  {
    swift_bridgeObjectRetain_n(a1, 5);
    v307._Swift::UInt64 rawBits = 1;
    v308._Swift::UInt64 rawBits = (v2 << 16) | 1;
    v309._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v307, v308, v10, a1);
    if (v309._rawBits < 0x10000) {
      v309._rawBits |= 3;
    }
    int64_t v2 = specialized Collection.count.getter(v309, v310, v10, a1);
    swift_bridgeObjectRelease(a1);
    if ((v8 & 0x1000000000000000) != 0) {
      goto LABEL_314;
    }
    while (2)
    {
      BOOL v15 = __OFADD__(v3, v2);
      v3 += v2;
      if (v15) {
        goto LABEL_316;
      }
LABEL_122:
      if ((v14 & ~v8 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v72 = _StringGuts.nativeUnusedCapacity.getter(v14, v8);
        if (v73) {
          goto LABEL_247;
        }
        uint64_t v74 = (v8 >> 61) & 1;
        if (v72 < v2) {
          LODWORD(v74) = 1;
        }
        if (v3 <= 15 && v74)
        {
LABEL_129:
          swift_bridgeObjectRetain(v8);
          unint64_t v75 = _StringGuts._convertedToSmall()(v14, v8);
          unint64_t v77 = v76;
          swift_bridgeObjectRelease(v8);
          v78._Swift::UInt64 rawBits = (v326 << 16) | 1;
          v79._Swift::UInt64 rawBits = 1;
          v80._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v79, v78, v10, a1);
          if (v80._rawBits < 0x10000) {
            v80._rawBits |= 3;
          }
          unint64_t v82 = specialized String.init(_:)(v80, v81, v10, a1);
          unint64_t v84 = v83;
          swift_bridgeObjectRelease(a1);
          unint64_t v85 = _StringGuts._convertedToSmall()(v82, v84);
          int64_t v2 = v86;
          swift_bridgeObjectRelease(v84);
          unint64_t v87 = specialized _SmallString.init(_:appending:)(v75, v77, v85, v2);
          if ((v89 & 1) == 0)
          {
            uint64_t v90 = v87;
            unint64_t v91 = v88;
            swift_bridgeObjectRelease(v8);
            swift_bridgeObjectRelease(a1);
            uint64_t v329 = v90;
            unint64_t v330 = v91;
            goto LABEL_212;
          }
          goto LABEL_238;
        }
      }
      else if (v3 <= 15)
      {
        goto LABEL_129;
      }
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v3, v2);
      if ((a1 & 0x1000000000000000) != 0) {
        goto LABEL_194;
      }
      swift_bridgeObjectRelease_n(a1, 4);
      if (!v1)
      {
        if ((v10 & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRelease(a1);
          unint64_t v92 = (uint64_t *)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v93 = v325;
          uint64_t v14 = v325;
          goto LABEL_138;
        }
        unint64_t v92 = (uint64_t *)_StringObject.sharedUTF8.getter(v10, a1);
        uint64_t v14 = v322;
        swift_bridgeObjectRelease(a1);
        if (v14 < v325) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
        }
        goto LABEL_337;
      }
      swift_bridgeObjectRelease_n(a1, 2);
      uint64_t v14 = ((unint64_t)a1 >> 62) & 1;
      unint64_t v327 = v10;
      unint64_t v328 = a1 & 0xFFFFFFFFFFFFFFLL;
      Swift::Int v133 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v16, (uint64_t)&v327, v16);
      unint64_t v92 = &v329;
      _StringGuts.appendInPlace(_:isASCII:)(v133, v134, (a1 & 0x4000000000000000) != 0);
      if (!v7)
      {
        swift_bridgeObjectRelease(a1);
        goto LABEL_212;
      }
LABEL_335:
      swift_errorRelease((id)v7);
      __break(1u);
      while (1)
      {
        swift_errorRelease((id)v7);
        swift_bridgeObjectRelease(v10 | 0x8000000000000000);
        __break(1u);
LABEL_337:
        uint64_t v93 = v325;
LABEL_138:
        unint64_t v94 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v93, (uint64_t)v92, v14);
        _StringGuts.appendInPlace(_:isASCII:)(v94, v95, v10 < 0);
        if (!v7) {
          goto LABEL_195;
        }
        swift_errorRelease((id)v7);
        swift_bridgeObjectRelease(a1);
        __break(1u);
LABEL_140:
        if (((*(void *)(v14 + 8) | *(void *)v14) & 0x8080808080808080) == 0)
        {
          unint64_t v96 = v14 + v69;
          int64_t v68 = (uint64_t *)(v14 + 16);
          while ((unint64_t)v68 < v96)
          {
            uint64_t v97 = *v68;
            uint64_t v98 = v68[1];
            v68 += 2;
            if (((v98 | v97) & 0x8080808080808080) != 0) {
              goto LABEL_144;
            }
          }
          goto LABEL_98;
        }
LABEL_144:
        unint64_t v8 = 0;
        uint64_t v99 = (unsigned char *)(v14 + a1);
        char v70 = 1;
        uint64_t v100 = (unsigned char *)v14;
        char v101 = (unsigned char *)v14;
        while (1)
        {
          int v104 = (char)*v101++;
          unsigned __int8 v103 = v104;
          if (v104 < 0) {
            break;
          }
          uint64_t v102 = 1;
LABEL_146:
          v8 += v102;
          uint64_t v100 = v101;
          if (v101 == v99)
          {
            if (a1 > 15) {
              goto LABEL_111;
            }
            goto LABEL_267;
          }
        }
        if ((v103 + 62) > 0x32u) {
          goto LABEL_183;
        }
        if (v103 <= 0xDFu)
        {
          if (v101 == v99 || (*v101 & 0xC0) != 0x80) {
            goto LABEL_183;
          }
          char v70 = 0;
          char v101 = v100 + 2;
          uint64_t v102 = 2;
          goto LABEL_146;
        }
        if (v103 == 224)
        {
          if (v101 == v99 || (v100[1] & 0xE0) != 0xA0) {
            goto LABEL_183;
          }
          goto LABEL_164;
        }
        if (v103 <= 0xECu)
        {
LABEL_158:
          if (v101 == v99) {
            goto LABEL_183;
          }
          LOBYTE(v105) = v100[1];
LABEL_163:
          if ((v105 & 0xC0) != 0x80) {
            goto LABEL_183;
          }
LABEL_164:
          if (v100 + 2 == v99 || (v100[2] & 0xC0) != 0x80) {
            goto LABEL_183;
          }
          char v70 = 0;
          char v101 = v100 + 3;
          uint64_t v102 = 3;
          goto LABEL_146;
        }
        if (v103 == 237)
        {
          if (v101 == v99) {
            goto LABEL_183;
          }
          unsigned int v105 = v100[1];
          if (v105 > 0x9F) {
            goto LABEL_183;
          }
          goto LABEL_163;
        }
        if (v103 <= 0xEFu) {
          goto LABEL_158;
        }
        if (v103 == 240)
        {
          if (v101 == v99 || (v100[1] + 64) < 0xD0u) {
            goto LABEL_183;
          }
          goto LABEL_178;
        }
        if ((v103 + 15) <= 2u)
        {
          if (v101 == v99) {
            goto LABEL_183;
          }
          LOBYTE(v106) = v100[1];
LABEL_177:
          if ((v106 & 0xC0) != 0x80) {
            goto LABEL_183;
          }
LABEL_178:
          if (v100 + 2 == v99 || (v100[2] & 0xC0) != 0x80 || v100 + 3 == v99 || (v100[3] & 0xC0) != 0x80) {
            goto LABEL_183;
          }
          char v70 = 0;
          char v101 = v100 + 4;
          uint64_t v102 = 4;
          goto LABEL_146;
        }
        if (v101 != v99)
        {
          unsigned int v106 = v100[1];
          if (v106 <= 0x8F) {
            goto LABEL_177;
          }
        }
LABEL_183:
        uint64_t v10 = (uint64_t)swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
        uint64_t v7 = v10;
        swift_willThrow();
        swift_errorRelease((id)v10);
        uint64_t v107 = specialized Collection.subscript.getter(v8, v14, a1);
        uint64_t v16 = findInvalidRange #1 (_:) in validateUTF8(_:)(v107, v108, v109, v110);
        unint64_t v327 = 0;
        unint64_t v328 = 0xE000000000000000;
        if (__OFADD__(a1, 15)) {
          goto LABEL_310;
        }
        uint64_t v10 = v111;
        _StringGuts.reserveCapacity(_:)(a1 + 15);
        uint64_t v7 = 0;
        while (2)
        {
          uint64_t v112 = specialized Collection.subscript.getter(v16, v14, a1);
          uint64_t v116 = v327 & 0xFFFFFFFFFFFFLL;
          if ((v328 & 0x2000000000000000) != 0) {
            uint64_t v116 = HIBYTE(v328) & 0xF;
          }
          BOOL v15 = __OFADD__(v116, a1);
          uint64_t v117 = v116 + a1;
          if (v15)
          {
            __break(1u);
LABEL_193:
            __break(1u);
LABEL_194:
            _StringGuts._foreignAppendInPlace(_:)(v10, a1, 0, v326);
LABEL_195:
            swift_bridgeObjectRelease_n(a1, 2);
            goto LABEL_212;
          }
          uint64_t v118 = v112;
          if (__OFADD__(v117, 3)) {
            goto LABEL_193;
          }
          uint64_t v119 = v113;
          int64_t v2 = v114;
          uint64_t v120 = v115;
          _StringGuts.reserveCapacity(_:)(v117 + 3);
          unint64_t v121 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v118, v119, v2, v120);
          _StringGuts.appendInPlace(_:isASCII:)(v121, v122, 0);
          size_t v331 = 3;
          uint64_t v332 = 12435439;
          specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v332, &v331, &v327);
          uint64_t v123 = specialized Collection.subscript.getter(v10, v14, a1);
          uint64_t v14 = specialized UnsafeBufferPointer.init(rebasing:)(v123, v124, v125, v126);
          a1 = v127;
          uint64_t v128 = validateUTF8(_:)((uint64_t *)v14, v127);
          if (v130)
          {
            uint64_t v16 = v128;
            uint64_t v10 = v129;
            if (!a1) {
              goto LABEL_303;
            }
            continue;
          }
          break;
        }
        _StringGuts.appendInPlace(_:isASCII:)((char *)v14, a1, 0);
LABEL_303:
        uint64_t v10 = v327;
        a1 = v328;
LABEL_91:
        uint64_t v14 = v329;
        unint64_t v8 = v330;
        unint64_t v67 = HIBYTE(v330) & 0xF;
        if ((v330 & 0x2000000000000000) != 0) {
          int64_t v3 = HIBYTE(v330) & 0xF;
        }
        else {
          int64_t v3 = v329 & 0xFFFFFFFFFFFFLL;
        }
        if (!v3 && (v329 & ~v330 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v330);
          uint64_t v329 = v10;
          unint64_t v330 = a1;
          goto LABEL_212;
        }
        int64_t v1 = a1 & 0x2000000000000000;
        uint64_t v16 = HIBYTE(a1) & 0xF;
        if ((v330 & 0x2000000000000000) == 0 || !v1) {
          break;
        }
        unint64_t v71 = v67 + v16;
        if (v67 + v16 > 0xF)
        {
          int64_t v1 = 1;
          break;
        }
        if (v16)
        {
          char v135 = 0;
          unint64_t v136 = 0;
          int64_t v2 = v330;
          do
          {
            unint64_t v137 = v67 + v136;
            unint64_t v138 = v136 + 1;
            if (v136 >= 8) {
              unint64_t v139 = a1;
            }
            else {
              unint64_t v139 = v10;
            }
            unint64_t v140 = v139 >> (v135 & 0x38);
            char v141 = (8 * v67 + v135) & 0x38;
            uint64_t v142 = (-255 << v141) - 1;
            unint64_t v143 = (unint64_t)v140 << v141;
            unint64_t v144 = v143 | v142 & v2;
            unint64_t v145 = v143 | v142 & v14;
            if (v137 < 8) {
              uint64_t v14 = v145;
            }
            else {
              int64_t v2 = v144;
            }
            v135 += 8;
            unint64_t v136 = v138;
          }
          while (v16 != v138);
        }
        else
        {
          int64_t v2 = v330;
        }
        swift_bridgeObjectRelease(v330);
        swift_bridgeObjectRelease(a1);
        unint64_t v146 = 0xA000000000000000;
        if (!(v14 & 0x8080808080808080 | v2 & 0x80808080808080)) {
          unint64_t v146 = 0xE000000000000000;
        }
        uint64_t v329 = v14;
        unint64_t v330 = v146 & 0xFF00000000000000 | (v71 << 56) | v2 & 0xFFFFFFFFFFFFFFLL;
LABEL_212:
        unint64_t v8 = v329;
        a1 = v330;
        unint64_t v147 = HIBYTE(v330) & 0xF;
        if ((v330 & 0x2000000000000000) != 0) {
          unint64_t v148 = HIBYTE(v330) & 0xF;
        }
        else {
          unint64_t v148 = v329 & 0xFFFFFFFFFFFFLL;
        }
        int64_t v3 = (int64_t)"' were found in a Set.\n"
                             "This usually means either that the type violates Hashable's requirements, or\n"
                             "that members of such a set were mutated after insertion.";
        if (!v148 && (v329 & ~v330 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v330);
          uint64_t v329 = 0xD00000000000009CLL;
          unint64_t v330 = 0x80000001816DED70 | 0x8000000000000000;
          goto LABEL_265;
        }
        if ((v330 & 0x2000000000000000) != 0 && (0x80000001816DED70 & 0x2000000000000000) != 0)
        {
          unint64_t v149 = v147 + ((0x80000001816DED70 >> 56) & 0xF);
          if (v149 <= 0xF)
          {
            unint64_t v177 = (0x80000001816DED70 >> 56) & 0xF;
            if (v177)
            {
              char v179 = 0;
              uint64_t v180 = 0;
              unint64_t v178 = v330;
              do
              {
                uint64_t v181 = v147 + v180;
                uint64_t v182 = v180 + 1;
                unint64_t v183 = 0xD00000000000009CLL;
                if (v180 >= 8) {
                  unint64_t v183 = 0x80000001816DED70 | 0x8000000000000000;
                }
                unint64_t v184 = v183 >> (v179 & 0x38);
                char v185 = (8 * v147 + v179) & 0x38;
                uint64_t v186 = (-255 << v185) - 1;
                unint64_t v187 = (unint64_t)v184 << v185;
                unint64_t v188 = v187 | v186 & v178;
                unint64_t v189 = v187 | v186 & v8;
                if (v181 < 8) {
                  unint64_t v8 = v189;
                }
                else {
                  unint64_t v178 = v188;
                }
                v179 += 8;
                uint64_t v180 = v182;
              }
              while (v177 != v182);
            }
            else
            {
              unint64_t v178 = v330;
            }
            swift_bridgeObjectRelease(v330);
            swift_bridgeObjectRelease(0x80000001816DED70 | 0x8000000000000000);
            unint64_t v190 = 0xA000000000000000;
            if (!(v8 & 0x8080808080808080 | v178 & 0x80808080808080)) {
              unint64_t v190 = 0xE000000000000000;
            }
            uint64_t v329 = v8;
            unint64_t v330 = v190 & 0xFF00000000000000 | (v149 << 56) | v178 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_265;
          }
        }
        int64_t v1 = 0x80000001816DED70 | 0x8000000000000000;
        if ((0x80000001816DED70 & 0x2000000000000000) != 0) {
          uint64_t v14 = (0x80000001816DED70 >> 56) & 0xF;
        }
        else {
          uint64_t v14 = 156;
        }
        swift_bridgeObjectRetain_n(0x80000001816DED70 | 0x8000000000000000, 2);
        if ((0x80000001816DED70 & 0x1000000000000000) == 0)
        {
          swift_bridgeObjectRetain_n(0x80000001816DED70 | 0x8000000000000000, 4);
          Swift::Int v150 = v14;
          if ((a1 & 0x1000000000000000) == 0) {
            goto LABEL_226;
          }
LABEL_324:
          Swift::Int v319 = String.UTF8View._foreignCount()();
          int64_t v151 = v319 + v150;
          if (!__OFADD__(v319, v150)) {
            goto LABEL_227;
          }
LABEL_326:
          __break(1u);
LABEL_327:
          __break(1u);
LABEL_328:
          uint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v8);
          uint64_t v10 = v320;
LABEL_58:
          v34._Swift::UInt64 rawBits = (v14 << 16) | 1;
          v35._Swift::UInt64 rawBits = 1;
          v36._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v35, v34, 0xD00000000000001CLL, (v3 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
          if (v36._rawBits < 0x10000) {
            v36._rawBits |= 3;
          }
          uint64_t v16 = specialized String.init(_:)(v36, v37, 0xD00000000000001CLL, (v3 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
          uint64_t v14 = v38;
          swift_bridgeObjectRelease((v3 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
          if ((v14 & 0x2000000000000000) != 0)
          {
            swift_bridgeObjectRelease(v14);
            goto LABEL_62;
          }
LABEL_317:
          unint64_t v312 = v8;
          if ((v14 & 0x1000000000000000) != 0)
          {
            uint64_t v16 = _StringGuts._foreignConvertedToSmall()(v16, v14);
            uint64_t v324 = v323;
            swift_bridgeObjectRelease(v14);
            uint64_t v14 = v324;
            unint64_t v8 = v312;
          }
          else
          {
            if ((v16 & 0x1000000000000000) != 0)
            {
              uint64_t v313 = (unsigned __int8 *)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v314 = v16 & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              uint64_t v313 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v16, v14);
            }
            closure #1 in _StringGuts._convertedToSmall()(v313, v314, &v327);
            swift_bridgeObjectRelease(v14);
            uint64_t v16 = v327;
            uint64_t v14 = v328;
          }
LABEL_62:
          uint64_t v39 = HIBYTE(v10) & 0xF;
          uint64_t v40 = HIBYTE(v14) & 0xF;
          int64_t v1 = v40 + v39;
          if ((unint64_t)(v40 + v39) > 0xF) {
            goto LABEL_238;
          }
          if (v40)
          {
            char v41 = 0;
            unint64_t v42 = 0;
            do
            {
              unint64_t v43 = v39 + v42;
              unint64_t v44 = v42 + 1;
              if (v42 >= 8) {
                unint64_t v45 = v14;
              }
              else {
                unint64_t v45 = v16;
              }
              unint64_t v46 = v45 >> (v41 & 0x38);
              char v47 = (8 * v39 + v41) & 0x38;
              uint64_t v48 = (-255 << v47) - 1;
              unint64_t v49 = (unint64_t)v46 << v47;
              unint64_t v50 = v49 | v48 & v10;
              unint64_t v51 = v49 | v48 & v7;
              if (v43 < 8) {
                uint64_t v7 = v51;
              }
              else {
                uint64_t v10 = v50;
              }
              v41 += 8;
              unint64_t v42 = v44;
            }
            while (v40 != v44);
          }
          swift_bridgeObjectRelease(v8);
          swift_bridgeObjectRelease((v3 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
          unint64_t v52 = 0xA000000000000000;
          if (!(v7 & 0x8080808080808080 | v10 & 0x80808080808080)) {
            unint64_t v52 = 0xE000000000000000;
          }
          unint64_t v12 = v52 & 0xFF00000000000000 | (v1 << 56) | v10 & 0xFFFFFFFFFFFFFFLL;
LABEL_85:
          uint64_t v329 = v7;
LABEL_86:
          unint64_t v330 = v12;
LABEL_87:
          TypeName = (uint64_t *)swift_getTypeName((Class *)a1, 0);
          if (v66 < 0) {
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
          }
          a1 = v66;
          if (!v66)
          {
            uint64_t v10 = 0;
            a1 = 0xE000000000000000;
LABEL_90:
            uint64_t v7 = 0;
            goto LABEL_91;
          }
          uint64_t v14 = (uint64_t)TypeName;
          int64_t v68 = TypeName;
          unint64_t v69 = v66 & 0xFFFFFFFFFFFFFFF0;
          if ((v66 & 0xFFFFFFFFFFFFFFF0) != 0) {
            goto LABEL_140;
          }
LABEL_98:
          if ((unint64_t)v68 >= v14 + (a1 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_101;
          }
          if ((*v68 & 0x8080808080808080) == 0)
          {
            ++v68;
LABEL_101:
            if ((unint64_t)v68 < v14 + (a1 & 0xFFFFFFFFFFFFFFFCLL))
            {
              if ((*(_DWORD *)v68 & 0x80808080) == 0)
              {
                int64_t v68 = (uint64_t *)((char *)v68 + 4);
                goto LABEL_104;
              }
              goto LABEL_144;
            }
LABEL_104:
            if ((unint64_t)v68 < v14 + (a1 & 0xFFFFFFFFFFFFFFFELL))
            {
              if ((*(_WORD *)v68 & 0x8080) != 0) {
                goto LABEL_144;
              }
              int64_t v68 = (uint64_t *)((char *)v68 + 2);
            }
            if ((unint64_t)v68 >= v14 + a1 || (*(char *)v68 & 0x80000000) == 0)
            {
              if (a1 > 15)
              {
                char v70 = 1;
LABEL_111:
                a1 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)((char *)v14, a1, a1, v70 & 1);
                uint64_t v7 = 0;
                uint64_t v10 = *(void *)(a1 + 24);
                goto LABEL_91;
              }
LABEL_267:
              unint64_t v193 = a1 - 8;
              unint64_t v194 = 8;
              if (a1 < 8) {
                unint64_t v194 = a1;
              }
              if ((v194 & 0x8000000000000000) != 0) {
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
              }
              if (v194 < 8)
              {
                unint64_t v195 = 0;
                uint64_t v10 = 0;
                unint64_t v196 = 0;
                goto LABEL_280;
              }
              if (v194 >= 0x10)
              {
                unint64_t v195 = v194 & 0xFFFFFFFFFFFFFFF0;
                uint16x8_t v220 = vmovl_high_u8(*(uint8x16_t *)v14);
                int8x16_t v221 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v220.i8);
                uint16x8_t v222 = vmovl_u8(*(uint8x8_t *)v14);
                int8x16_t v223 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v222.i8);
                int8x16_t v224 = (int8x16_t)vmovl_high_u16(v220);
                int8x8_t v225 = (int8x8_t)vextq_s8(v224, v224, 8uLL).u64[0];
                int8x16_t v226 = (int8x16_t)vmovl_high_u16(v222);
                int8x8_t v227 = (int8x8_t)vextq_s8(v226, v226, 8uLL).u64[0];
                *(int8x8_t *)v226.i8 = vorr_s8(*(int8x8_t *)v226.i8, *(int8x8_t *)v224.i8);
                v228.i64[0] = v226.u32[0];
                v228.i64[1] = v226.u32[1];
                int8x16_t v229 = (int8x16_t)vshlq_u64(v228, (uint64x2_t)xmmword_18162AD00);
                *(int8x8_t *)v224.i8 = vorr_s8(*(int8x8_t *)v223.i8, *(int8x8_t *)v221.i8);
                v228.i64[0] = v224.u32[0];
                v228.i64[1] = v224.u32[1];
                int8x16_t v230 = vorrq_s8((int8x16_t)vshlq_u64(v228, (uint64x2_t)xmmword_18162ACF0), v229);
                *(int8x8_t *)v224.i8 = vorr_s8(v227, v225);
                v228.i64[0] = v224.u32[0];
                v228.i64[1] = v224.u32[1];
                int8x16_t v231 = (int8x16_t)vshlq_u64(v228, (uint64x2_t)xmmword_18162ACE0);
                *(int8x8_t *)v221.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v223, v223, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v221, v221, 8uLL));
                v228.i64[0] = v221.u32[0];
                v228.i64[1] = v221.u32[1];
                int8x16_t v232 = vorrq_s8(v230, vorrq_s8((int8x16_t)vshlq_u64(v228, (uint64x2_t)xmmword_18162ACD0), v231));
                uint64_t v10 = (uint64_t)vorr_s8(*(int8x8_t *)v232.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v232, v232, 8uLL));
                if (v194 != (v194 & 0xFFFFFFFFFFFFFFF0))
                {
                  unint64_t v196 = 8 * v195;
                  if ((v194 & 8) == 0) {
                    goto LABEL_280;
                  }
                  goto LABEL_274;
                }
              }
              else
              {
                uint64_t v10 = 0;
                unint64_t v196 = 0;
                unint64_t v195 = 0;
LABEL_274:
                unint64_t v197 = v195;
                int64x2_t v198 = vdupq_n_s64(v196);
                unint64_t v195 = v194 & 0xFFFFFFFFFFFFFFF8;
                unint64_t v196 = 8 * (v194 & 0xFFFFFFFFFFFFFFF8);
                int8x16_t v199 = 0uLL;
                int8x16_t v200 = (int8x16_t)(unint64_t)v10;
                int64x2_t v201 = vaddq_s64(v198, (int64x2_t)xmmword_18162ACE0);
                int64x2_t v202 = vaddq_s64(v198, (int64x2_t)xmmword_18162AD00);
                int64x2_t v203 = vaddq_s64(v198, (int64x2_t)xmmword_18162ACD0);
                int64x2_t v204 = vaddq_s64(v198, (int64x2_t)xmmword_18162ACF0);
                Swift::Int v205 = (uint8x8_t *)(v14 + v197);
                int8x16_t v206 = (int8x16_t)vdupq_n_s64(0x38uLL);
                unint64_t v207 = v197 - (v194 & 0xFFFFFFFFFFFFFFF8);
                int64x2_t v208 = vdupq_n_s64(0x40uLL);
                int8x16_t v209 = 0uLL;
                int8x16_t v210 = 0uLL;
                do
                {
                  uint8x8_t v211 = *v205++;
                  uint16x8_t v212 = vmovl_u8(v211);
                  uint32x4_t v213 = vmovl_high_u16(v212);
                  v214.i64[0] = v213.u32[2];
                  v214.i64[1] = v213.u32[3];
                  uint64x2_t v215 = v214;
                  v214.i64[0] = v213.u32[0];
                  v214.i64[1] = v213.u32[1];
                  uint64x2_t v216 = v214;
                  uint32x4_t v217 = vmovl_u16(*(uint16x4_t *)v212.i8);
                  v214.i64[0] = v217.u32[2];
                  v214.i64[1] = v217.u32[3];
                  uint64x2_t v218 = v214;
                  v214.i64[0] = v217.u32[0];
                  v214.i64[1] = v217.u32[1];
                  int8x16_t v210 = vorrq_s8((int8x16_t)vshlq_u64(v215, (uint64x2_t)vandq_s8((int8x16_t)v201, v206)), v210);
                  int8x16_t v209 = vorrq_s8((int8x16_t)vshlq_u64(v216, (uint64x2_t)vandq_s8((int8x16_t)v202, v206)), v209);
                  int8x16_t v199 = vorrq_s8((int8x16_t)vshlq_u64(v218, (uint64x2_t)vandq_s8((int8x16_t)v203, v206)), v199);
                  int8x16_t v200 = vorrq_s8((int8x16_t)vshlq_u64(v214, (uint64x2_t)vandq_s8((int8x16_t)v204, v206)), v200);
                  int64x2_t v202 = vaddq_s64(v202, v208);
                  int64x2_t v203 = vaddq_s64(v203, v208);
                  int64x2_t v204 = vaddq_s64(v204, v208);
                  int64x2_t v201 = vaddq_s64(v201, v208);
                  v207 += 8;
                }
                while (v207);
                int8x16_t v219 = vorrq_s8(vorrq_s8(v200, v209), vorrq_s8(v199, v210));
                uint64_t v10 = (uint64_t)vorr_s8(*(int8x8_t *)v219.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v219, v219, 8uLL));
                if (v194 != v195)
                {
LABEL_280:
                  unint64_t v233 = (unsigned __int8 *)(v14 + v195);
                  unint64_t v234 = v194 - v195;
                  do
                  {
                    unsigned int v235 = *v233++;
                    v10 |= (unint64_t)v235 << (v196 & 0x38);
                    v196 += 8;
                    --v234;
                  }
                  while (v234);
                }
              }
              if (a1 < 9)
              {
                int8x8_t v237 = 0;
              }
              else
              {
                if (v193 < 8)
                {
                  unint64_t v236 = 0;
                  int8x8_t v237 = 0;
                  unint64_t v238 = 0;
                  goto LABEL_296;
                }
                if (v193 >= 0x10)
                {
                  v262 = (uint8x16_t *)(v14 + 8);
                  unint64_t v236 = v193 & 0xFFFFFFFFFFFFFFF0;
                  int64x2_t v263 = (int64x2_t)xmmword_18162AD80;
                  int64x2_t v264 = (int64x2_t)xmmword_18162AD90;
                  int64x2_t v265 = (int64x2_t)xmmword_18162ADA0;
                  int64x2_t v266 = (int64x2_t)xmmword_18162ADB0;
                  int64x2_t v267 = (int64x2_t)xmmword_18162ACE0;
                  int64x2_t v268 = (int64x2_t)xmmword_18162AD00;
                  int8x16_t v269 = (int8x16_t)vdupq_n_s64(0x38uLL);
                  int64x2_t v270 = vdupq_n_s64(0x80uLL);
                  int64x2_t v271 = (int64x2_t)xmmword_18162ACD0;
                  unint64_t v238 = 8 * (v193 & 0xFFFFFFFFFFFFFFF0);
                  int8x16_t v272 = 0uLL;
                  int8x16_t v273 = 0uLL;
                  int64x2_t v274 = (int64x2_t)xmmword_18162ACF0;
                  unint64_t v275 = v193 & 0xFFFFFFFFFFFFFFF0;
                  int8x16_t v276 = 0uLL;
                  int8x16_t v277 = 0uLL;
                  int8x16_t v278 = 0uLL;
                  int8x16_t v279 = 0uLL;
                  int8x16_t v280 = 0uLL;
                  int8x16_t v281 = 0uLL;
                  do
                  {
                    uint8x16_t v282 = *v262++;
                    uint16x8_t v283 = vmovl_u8(*(uint8x8_t *)v282.i8);
                    uint32x4_t v284 = vmovl_high_u16(v283);
                    v285.i64[0] = v284.u32[2];
                    v285.i64[1] = v284.u32[3];
                    uint64x2_t v286 = v285;
                    uint16x8_t v287 = vmovl_high_u8(v282);
                    uint32x4_t v288 = vmovl_u16(*(uint16x4_t *)v287.i8);
                    v285.i64[0] = v288.u32[2];
                    v285.i64[1] = v288.u32[3];
                    uint64x2_t v289 = v285;
                    v285.i64[0] = v288.u32[0];
                    v285.i64[1] = v288.u32[1];
                    uint64x2_t v290 = v285;
                    v285.i64[0] = v284.u32[0];
                    v285.i64[1] = v284.u32[1];
                    uint64x2_t v291 = v285;
                    uint32x4_t v292 = vmovl_u16(*(uint16x4_t *)v283.i8);
                    v285.i64[0] = v292.u32[2];
                    v285.i64[1] = v292.u32[3];
                    uint64x2_t v293 = v285;
                    uint32x4_t v294 = vmovl_high_u16(v287);
                    v285.i64[0] = v294.u32[0];
                    v285.i64[1] = v294.u32[1];
                    uint64x2_t v295 = v285;
                    v285.i64[0] = v292.u32[0];
                    v285.i64[1] = v292.u32[1];
                    uint64x2_t v296 = v285;
                    v285.i64[0] = v294.u32[2];
                    v285.i64[1] = v294.u32[3];
                    int8x16_t v277 = vorrq_s8((int8x16_t)vshlq_u64(v286, (uint64x2_t)vandq_s8((int8x16_t)v267, v269)), v277);
                    int8x16_t v279 = vorrq_s8((int8x16_t)vshlq_u64(v289, (uint64x2_t)vandq_s8((int8x16_t)v265, v269)), v279);
                    int8x16_t v278 = vorrq_s8((int8x16_t)vshlq_u64(v290, (uint64x2_t)vandq_s8((int8x16_t)v266, v269)), v278);
                    int8x16_t v276 = vorrq_s8((int8x16_t)vshlq_u64(v291, (uint64x2_t)vandq_s8((int8x16_t)v268, v269)), v276);
                    int8x16_t v273 = vorrq_s8((int8x16_t)vshlq_u64(v293, (uint64x2_t)vandq_s8((int8x16_t)v271, v269)), v273);
                    int8x16_t v280 = vorrq_s8((int8x16_t)vshlq_u64(v295, (uint64x2_t)vandq_s8((int8x16_t)v264, v269)), v280);
                    int8x16_t v272 = vorrq_s8((int8x16_t)vshlq_u64(v296, (uint64x2_t)vandq_s8((int8x16_t)v274, v269)), v272);
                    int8x16_t v281 = vorrq_s8((int8x16_t)vshlq_u64(v285, (uint64x2_t)vandq_s8((int8x16_t)v263, v269)), v281);
                    int64x2_t v268 = vaddq_s64(v268, v270);
                    int64x2_t v271 = vaddq_s64(v271, v270);
                    int64x2_t v274 = vaddq_s64(v274, v270);
                    int64x2_t v267 = vaddq_s64(v267, v270);
                    int64x2_t v266 = vaddq_s64(v266, v270);
                    int64x2_t v265 = vaddq_s64(v265, v270);
                    int64x2_t v264 = vaddq_s64(v264, v270);
                    int64x2_t v263 = vaddq_s64(v263, v270);
                    v275 -= 16;
                  }
                  while (v275);
                  int8x16_t v297 = vorrq_s8(vorrq_s8(vorrq_s8(v272, v278), vorrq_s8(v276, v280)), vorrq_s8(vorrq_s8(v273, v279), vorrq_s8(v277, v281)));
                  int8x8_t v237 = vorr_s8(*(int8x8_t *)v297.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v297, v297, 8uLL));
                  if (v193 != v236)
                  {
                    if ((v193 & 8) == 0) {
                      goto LABEL_296;
                    }
                    goto LABEL_288;
                  }
                }
                else
                {
                  int8x8_t v237 = 0;
                  unint64_t v238 = 0;
                  unint64_t v236 = 0;
LABEL_288:
                  unint64_t v239 = v236;
                  unint64_t v236 = v193 & 0xFFFFFFFFFFFFFFF8;
                  int64x2_t v240 = vdupq_n_s64(v238);
                  unint64_t v238 = 8 * (v193 & 0xFFFFFFFFFFFFFFF8);
                  int8x16_t v241 = (int8x16_t)(unint64_t)v237;
                  int8x16_t v242 = 0uLL;
                  int64x2_t v243 = vaddq_s64(v240, (int64x2_t)xmmword_18162ACE0);
                  int64x2_t v244 = vaddq_s64(v240, (int64x2_t)xmmword_18162AD00);
                  int64x2_t v245 = vaddq_s64(v240, (int64x2_t)xmmword_18162ACD0);
                  int64x2_t v246 = vaddq_s64(v240, (int64x2_t)xmmword_18162ACF0);
                  uint64_t v247 = (uint8x8_t *)(v239 + v14 + 8);
                  int8x16_t v248 = (int8x16_t)vdupq_n_s64(0x38uLL);
                  unint64_t v249 = v239 - (v193 & 0xFFFFFFFFFFFFFFF8);
                  int64x2_t v250 = vdupq_n_s64(0x40uLL);
                  int8x16_t v251 = 0uLL;
                  int8x16_t v252 = 0uLL;
                  do
                  {
                    uint8x8_t v253 = *v247++;
                    uint16x8_t v254 = vmovl_u8(v253);
                    uint32x4_t v255 = vmovl_high_u16(v254);
                    v256.i64[0] = v255.u32[2];
                    v256.i64[1] = v255.u32[3];
                    uint64x2_t v257 = v256;
                    v256.i64[0] = v255.u32[0];
                    v256.i64[1] = v255.u32[1];
                    uint64x2_t v258 = v256;
                    uint32x4_t v259 = vmovl_u16(*(uint16x4_t *)v254.i8);
                    v256.i64[0] = v259.u32[2];
                    v256.i64[1] = v259.u32[3];
                    uint64x2_t v260 = v256;
                    v256.i64[0] = v259.u32[0];
                    v256.i64[1] = v259.u32[1];
                    int8x16_t v252 = vorrq_s8((int8x16_t)vshlq_u64(v257, (uint64x2_t)vandq_s8((int8x16_t)v243, v248)), v252);
                    int8x16_t v251 = vorrq_s8((int8x16_t)vshlq_u64(v258, (uint64x2_t)vandq_s8((int8x16_t)v244, v248)), v251);
                    int8x16_t v242 = vorrq_s8((int8x16_t)vshlq_u64(v260, (uint64x2_t)vandq_s8((int8x16_t)v245, v248)), v242);
                    int8x16_t v241 = vorrq_s8((int8x16_t)vshlq_u64(v256, (uint64x2_t)vandq_s8((int8x16_t)v246, v248)), v241);
                    int64x2_t v244 = vaddq_s64(v244, v250);
                    int64x2_t v245 = vaddq_s64(v245, v250);
                    int64x2_t v246 = vaddq_s64(v246, v250);
                    int64x2_t v243 = vaddq_s64(v243, v250);
                    v249 += 8;
                  }
                  while (v249);
                  int8x16_t v261 = vorrq_s8(vorrq_s8(v241, v251), vorrq_s8(v242, v252));
                  int8x8_t v237 = vorr_s8(*(int8x8_t *)v261.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v261, v261, 8uLL));
                  if (v193 != v236)
                  {
LABEL_296:
                    uint64_t v298 = a1 - v236 - 8;
                    v299 = (unsigned __int8 *)(v236 + v14 + 8);
                    do
                    {
                      unsigned int v300 = *v299++;
                      *(void *)&v237 |= (unint64_t)v300 << (v238 & 0x38);
                      v238 += 8;
                      --v298;
                    }
                    while (v298);
                  }
                }
              }
              unint64_t v301 = 0xA000000000000000;
              if (((*(void *)&v237 | v10) & 0x8080808080808080) == 0) {
                unint64_t v301 = 0xE000000000000000;
              }
              a1 = v301 | (a1 << 56) | *(void *)&v237;
              goto LABEL_90;
            }
          }
          goto LABEL_144;
        }
        swift_bridgeObjectRetain_n(0x80000001816DED70 | 0x8000000000000000, 5);
        int64_t v2 = 0xD00000000000009CLL;
        v315._Swift::UInt64 rawBits = 1;
        v316._Swift::UInt64 rawBits = (v14 << 16) | 1;
        v317._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v315, v316, 0xD00000000000009CLL, 0x80000001816DED70 | 0x8000000000000000);
        if (v317._rawBits < 0x10000) {
          v317._rawBits |= 3;
        }
        Swift::Int v150 = specialized Collection.count.getter(v317, v318, 0xD00000000000009CLL, 0x80000001816DED70 | 0x8000000000000000);
        swift_bridgeObjectRelease(0x80000001816DED70 | 0x8000000000000000);
        if ((a1 & 0x1000000000000000) != 0) {
          goto LABEL_324;
        }
LABEL_226:
        BOOL v15 = __OFADD__(v148, v150);
        int64_t v151 = v148 + v150;
        if (v15) {
          goto LABEL_326;
        }
LABEL_227:
        if ((v8 & ~a1 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(a1 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v152 = _StringGuts.nativeUnusedCapacity.getter(v8, a1);
          if (v153) {
            goto LABEL_247;
          }
          uint64_t v154 = ((unint64_t)a1 >> 61) & 1;
          if (v152 < v150) {
            LODWORD(v154) = 1;
          }
          if (v151 <= 15 && v154)
          {
LABEL_234:
            swift_bridgeObjectRetain(a1);
            unint64_t v155 = _StringGuts._convertedToSmall()(v8, a1);
            unint64_t v157 = v156;
            swift_bridgeObjectRelease(a1);
            v158._Swift::UInt64 rawBits = (v14 << 16) | 1;
            v159._Swift::UInt64 rawBits = 1;
            v160._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v159, v158, 0xD00000000000009CLL, 0x80000001816DED70 | 0x8000000000000000);
            if (v160._rawBits < 0x10000) {
              v160._rawBits |= 3;
            }
            unint64_t v162 = specialized String.init(_:)(v160, v161, 0xD00000000000009CLL, 0x80000001816DED70 | 0x8000000000000000);
            unint64_t v164 = v163;
            swift_bridgeObjectRelease(0x80000001816DED70 | 0x8000000000000000);
            unint64_t v165 = _StringGuts._convertedToSmall()(v162, v164);
            unint64_t v167 = v166;
            swift_bridgeObjectRelease(v164);
            unint64_t v168 = specialized _SmallString.init(_:appending:)(v155, v157, v165, v167);
            if ((v170 & 1) == 0)
            {
              uint64_t v171 = v168;
              unint64_t v172 = v169;
              swift_bridgeObjectRelease(a1);
              swift_bridgeObjectRelease(0x80000001816DED70 | 0x8000000000000000);
              uint64_t v329 = v171;
              unint64_t v330 = v172;
              goto LABEL_265;
            }
LABEL_238:
            unint64_t v173 = 266;
LABEL_248:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v173, 0);
          }
        }
        else if (v151 <= 15)
        {
          goto LABEL_234;
        }
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v151, v150);
        if ((0x80000001816DED70 & 0x1000000000000000) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(0xD00000000000009CLL, 0x80000001816DED70 | 0x8000000000000000, 0, v14);
          unint64_t v176 = 0x80000001816DED70 | 0x8000000000000000;
LABEL_252:
          swift_bridgeObjectRelease_n(v176, 2);
LABEL_265:
          _assertionFailure(_:_:flags:)("Fatal error", 11, 2, v329, v330, 0);
        }
        if ((0x80000001816DED70 & 0x2000000000000000) != 0) {
          a1 = ((0x80000001816DED70 | 0x8000000000000000) >> 62) & 1;
        }
        else {
          a1 = 1;
        }
        swift_bridgeObjectRelease_n(0x80000001816DED70 | 0x8000000000000000, 5);
        if ((0x80000001816DED70 & 0x2000000000000000) != 0)
        {
          uint64_t v10 = 0x80000001816DED70 | 0x8000000000000000;
          swift_bridgeObjectRelease(0x80000001816DED70 | 0x8000000000000000);
          unint64_t v327 = 0xD00000000000009CLL;
          unint64_t v328 = 0x80000001816DED70 & 0xFFFFFFFFFFFFFFLL;
          Swift::String::Index v191 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v14, (uint64_t)&v327, (0x80000001816DED70 >> 56) & 0xF);
          unint64_t v92 = &v329;
          _StringGuts.appendInPlace(_:isASCII:)(v191, v192, a1);
          if (!v7)
          {
            swift_bridgeObjectRelease(0x80000001816DED70 | 0x8000000000000000);
            goto LABEL_265;
          }
          goto LABEL_335;
        }
        uint64_t v10 = 0x80000001816DED70;
        uint64_t v174 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v14, (0x80000001816DED70 & 0xFFFFFFFFFFFFFFFLL) + 32, 156);
        unint64_t v92 = &v329;
        _StringGuts.appendInPlace(_:isASCII:)(v174, v175, a1);
        if (!v7)
        {
          unint64_t v176 = 0x80000001816DED70 | 0x8000000000000000;
          goto LABEL_252;
        }
      }
      uint64_t v325 = v10 & 0xFFFFFFFFFFFFLL;
      if (v1) {
        int64_t v2 = HIBYTE(a1) & 0xF;
      }
      else {
        int64_t v2 = v10 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(a1, 2);
      uint64_t v326 = v2;
      if ((a1 & 0x1000000000000000) == 0)
      {
        swift_bridgeObjectRetain_n(a1, 4);
        if ((v8 & 0x1000000000000000) == 0) {
          continue;
        }
LABEL_314:
        Swift::Int v311 = String.UTF8View._foreignCount()();
        int64_t v3 = v311 + v2;
        if (!__OFADD__(v311, v2)) {
          goto LABEL_122;
        }
LABEL_316:
        __break(1u);
        goto LABEL_317;
      }
      break;
    }
  }
}

uint64_t specialized _NativeSet._unsafeInsertNew(_:at:)(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  *(void *)(a4 + 8 * (a3 >> 6) + 56) |= 1 << a3;
  unint64_t v4 = (void *)(*(void *)(a4 + 48) + 16 * a3);
  *unint64_t v4 = result;
  v4[1] = a2;
  uint64_t v5 = *(void *)(a4 + 16);
  BOOL v6 = __OFADD__(v5, 1);
  uint64_t v7 = v5 + 1;
  if (v6) {
    __break(1u);
  }
  else {
    *(void *)(a4 + 16) = v7;
  }
  return result;
}

uint64_t specialized _NativeSet._unsafeInsertNew(_:at:)(uint64_t result, unint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t v3 = *(void *)(a3 + 48) + 40 * a2;
  long long v4 = *(_OWORD *)(result + 16);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)result;
  *(_OWORD *)(v3 + 16) = v4;
  *(void *)(v3 + 32) = *(void *)(result + 32);
  uint64_t v5 = *(void *)(a3 + 16);
  BOOL v6 = __OFADD__(v5, 1);
  uint64_t v7 = v5 + 1;
  if (v6) {
    __break(1u);
  }
  else {
    *(void *)(a3 + 16) = v7;
  }
  return result;
}

uint64_t _NativeSet._unsafeInsertNew(_:at:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(*(void *)(a3 + 48) + *(void *)(*(void *)(a4 - 8) + 72) * a2, a1, a4);
  uint64_t v6 = *(void *)(a3 + 16);
  BOOL v7 = __OFADD__(v6, 1);
  uint64_t v8 = v6 + 1;
  if (v7) {
    __break(1u);
  }
  else {
    *(void *)(a3 + 16) = v8;
  }
  return result;
}

uint64_t specialized _NativeSet.insertNew(_:at:isUnique:)(uint64_t result, unint64_t a2, char a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 <= v6 || (a3 & 1) == 0)
  {
    uint64_t v8 = v6 + 1;
    if (a3)
    {
      specialized _NativeSet.resize(capacity:)(v8, (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>, (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }
    else
    {
      if (v7 > v6)
      {
        uint64_t result = (uint64_t)specialized _NativeSet.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>);
        goto LABEL_12;
      }
      specialized _NativeSet.copyAndResize(capacity:)(v8, (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>, (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }
    uint64_t v9 = *v3;
    uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(*v3 + 40), v5);
    uint64_t v10 = -1 << *(unsigned char *)(v9 + 32);
    a2 = result & ~v10;
    if ((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
    {
      uint64_t v11 = ~v10;
      while (*(void *)(*(void *)(v9 + 48) + 8 * a2) != v5)
      {
        a2 = (a2 + 1) & v11;
        if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) == 0) {
          goto LABEL_12;
        }
      }
LABEL_15:
      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for ObjectIdentifier);
    }
  }
LABEL_12:
  uint64_t v12 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  *(void *)(*(void *)(v12 + 48) + 8 * a2) = v5;
  uint64_t v13 = *(void *)(v12 + 16);
  BOOL v14 = __OFADD__(v13, 1);
  uint64_t v15 = v13 + 1;
  if (v14)
  {
    __break(1u);
    goto LABEL_15;
  }
  *(void *)(v12 + 16) = v15;
  return result;
}

{
  uint64_t *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  long long v28;
  long long v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35[5];
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39[3];
  uint64_t v40;
  uint64_t v41;

  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_15;
  }
  uint64_t v8 = v6 + 1;
  if (a3)
  {
    specialized _NativeSet.resize(capacity:)(v8);
  }
  else
  {
    if (v7 > v6)
    {
      uint64_t result = (uint64_t)specialized _NativeSet.copy()();
      goto LABEL_15;
    }
    specialized _NativeSet.copyAndResize(capacity:)(v8);
  }
  uint64_t v9 = *v3;
  uint64_t v10 = *(void *)(*v3 + 40);
  uint64_t v11 = *(void *)(v5 + 24);
  uint64_t v12 = *(void *)(v5 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)v5, v11);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v12 + 8))(v39, v11, v12);
  uint64_t v13 = v40;
  BOOL v14 = v41;
  __swift_project_boxed_opaque_existential_0Tm(v39, v40);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 40))(v10, v13, v14);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v39);
  uint64_t v16 = -1 << *(unsigned char *)(v9 + 32);
  a2 = v15 & ~v16;
  Swift::String::Index v34 = v9;
  int64_t v17 = v9 + 56;
  if ((*(void *)(v17 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
  {
    char v18 = ~v16;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v34 + 48) + 40 * a2, (uint64_t)v39);
      int64_t v19 = v40;
      char v20 = v41;
      __swift_project_boxed_opaque_existential_0Tm(v39, v40);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v36, v19, v20);
      uint64_t v21 = v37;
      BOOL v22 = v38;
      __swift_project_boxed_opaque_existential_0Tm(v36, v37);
      uint64_t v23 = *(void *)(v5 + 24);
      uint64_t v24 = *(void *)(v5 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)v5, v23);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v24 + 8))(v35, v23, v24);
      char v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v22 + 16))(v35, v21, v22);
      __swift_destroy_boxed_opaque_existential_1Tm(v35);
      if (v25 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v36);
        uint64_t result = (uint64_t)outlined destroy of AnyHashable(v39);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v36);
        uint64_t result = (uint64_t)outlined destroy of AnyHashable(v39);
        if (v25) {
          ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
        }
      }
      a2 = (a2 + 1) & v18;
    }
    while (((*(void *)(v17 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) != 0);
  }
LABEL_15:
  uint64_t v26 = *v33;
  *(void *)(*v33 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t v27 = *(void *)(v26 + 48) + 40 * a2;
  char v28 = *(_OWORD *)v5;
  unint64_t v29 = *(_OWORD *)(v5 + 16);
  *(void *)(v27 + 32) = *(void *)(v5 + 32);
  *(_OWORD *)uint64_t v27 = v28;
  *(_OWORD *)(v27 + 16) = v29;
  size_t v30 = *(void *)(v26 + 16);
  unint64_t v31 = __OFADD__(v30, 1);
  unint64_t v32 = v30 + 1;
  if (v31) {
    __break(1u);
  }
  else {
    *(void *)(v26 + 16) = v32;
  }
  return result;
}

{
  uint64_t *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;

  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 <= v6 || (a3 & 1) == 0)
  {
    uint64_t v8 = v6 + 1;
    if (a3)
    {
      specialized _NativeSet.resize(capacity:)(v8, (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<Int>, (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }
    else
    {
      if (v7 > v6)
      {
        uint64_t result = (uint64_t)specialized _NativeSet.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<Int>);
        goto LABEL_12;
      }
      specialized _NativeSet.copyAndResize(capacity:)(v8, (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<Int>, (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }
    uint64_t v9 = *v3;
    uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(*v3 + 40), v5);
    uint64_t v10 = -1 << *(unsigned char *)(v9 + 32);
    a2 = result & ~v10;
    if ((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
    {
      uint64_t v11 = ~v10;
      while (*(void *)(*(void *)(v9 + 48) + 8 * a2) != v5)
      {
        a2 = (a2 + 1) & v11;
        if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) == 0) {
          goto LABEL_12;
        }
      }
LABEL_15:
      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for Int);
    }
  }
LABEL_12:
  uint64_t v12 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  *(void *)(*(void *)(v12 + 48) + 8 * a2) = v5;
  uint64_t v13 = *(void *)(v12 + 16);
  BOOL v14 = __OFADD__(v13, 1);
  uint64_t v15 = v13 + 1;
  if (v14)
  {
    __break(1u);
    goto LABEL_15;
  }
  *(void *)(v12 + 16) = v15;
  return result;
}

uint64_t specialized _NativeSet.insertNew(_:at:isUnique:)(uint64_t result, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = v4;
  unint64_t v8 = result;
  unint64_t v9 = *(void *)(*v4 + 16);
  unint64_t v10 = *(void *)(*v4 + 24);
  if (v10 > v9 && (a4 & 1) != 0) {
    goto LABEL_25;
  }
  uint64_t v11 = v9 + 1;
  if (a4)
  {
    specialized _NativeSet.resize(capacity:)(v11);
  }
  else
  {
    if (v10 > v9)
    {
      uint64_t result = (uint64_t)specialized _NativeSet.copy()();
      goto LABEL_25;
    }
    specialized _NativeSet.copyAndResize(capacity:)(v11);
  }
  uint64_t v12 = *v4;
  uint64_t v13 = _swift_stdlib_Hashing_parameters ^ *(void *)(*v4 + 40);
  v28[0] = 0;
  v28[1] = v13 ^ 0x736F6D6570736575;
  v28[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v28[3] = v13 ^ 0x6C7967656E657261;
  v28[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v29 = 0u;
  long long v30 = 0u;
  String.hash(into:)(v28, v8, a2);
  uint64_t result = Hasher._finalize()();
  uint64_t v14 = -1 << *(unsigned char *)(v12 + 32);
  a3 = result & ~v14;
  uint64_t v15 = v12 + 56;
  if ((*(void *)(v12 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3))
  {
    uint64_t v16 = ~v14;
    uint64_t v17 = *(void *)(v12 + 48);
    do
    {
      char v18 = (uint64_t *)(v17 + 16 * a3);
      uint64_t result = *v18;
      unint64_t v19 = v18[1];
      BOOL v20 = *v18 == v8 && v19 == a2;
      if (v20
        || ((~v19 & 0x6000000000000000) == 0 ? (BOOL v21 = (a2 & 0x2000000000000000) == 0) : (BOOL v21 = 1),
            !v21 ? (BOOL v22 = (a2 & 0x4000000000000000) == 0) : (BOOL v22 = 1),
            v22 && (uint64_t result = _stringCompareInternal(_:_:expecting:)(result, v19, v8, a2, 0), (result & 1) != 0)))
      {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for String);
      }
      a3 = (a3 + 1) & v16;
    }
    while (((*(void *)(v15 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3) & 1) != 0);
  }
LABEL_25:
  uint64_t v23 = *v5;
  *(void *)(*v5 + 8 * (a3 >> 6) + 56) |= 1 << a3;
  uint64_t v24 = (unint64_t *)(*(void *)(v23 + 48) + 16 * a3);
  *uint64_t v24 = v8;
  v24[1] = a2;
  uint64_t v25 = *(void *)(v23 + 16);
  BOOL v26 = __OFADD__(v25, 1);
  uint64_t v27 = v25 + 1;
  if (v26) {
    __break(1u);
  }
  else {
    *(void *)(v23 + 16) = v27;
  }
  return result;
}

void specialized _NativeSet.insertNew(_:at:isUnique:)(long long *a1, unint64_t a2, char a3)
{
  uint64_t v5 = *v3;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_90;
  }
  uint64_t v8 = v6 + 1;
  if ((a3 & 1) == 0)
  {
    if (v7 > v6)
    {
      uint64_t v23 = *(unsigned int *)(v5 + 36);
      uint64_t v24 = *(void **)(v5 + 40);
      char v25 = *(unsigned char *)(v5 + 32);
      LOBYTE(v87) = 0;
      BOOL v26 = specialized static _SetStorage.allocate(scale:age:seed:)(v25, v23, v24, 0);
      uint64_t v27 = v26;
      if (!*(void *)(v5 + 16)) {
        goto LABEL_78;
      }
      char v28 = v26 + 7;
      uint64_t v29 = v5 + 56;
      unint64_t v30 = (unint64_t)((1 << *((unsigned char *)v27 + 32)) + 63) >> 6;
      if (v27 != (void *)v5 || (unint64_t)v28 >= v5 + 56 + 8 * v30) {
        memmove(v28, (const void *)(v5 + 56), 8 * v30);
      }
      int64_t v32 = 0;
      void v27[2] = *(void *)(v5 + 16);
      uint64_t v33 = 1 << *(unsigned char *)(v5 + 32);
      uint64_t v34 = -1;
      if (v33 < 64) {
        uint64_t v34 = ~(-1 << v33);
      }
      unint64_t v35 = v34 & *(void *)(v5 + 56);
      int64_t v36 = (unint64_t)(v33 + 63) >> 6;
      while (1)
      {
        if (v35)
        {
          unint64_t v37 = __clz(__rbit64(v35));
          v35 &= v35 - 1;
          unint64_t v38 = v37 | (v32 << 6);
        }
        else
        {
          int64_t v43 = v32 + 1;
          if (__OFADD__(v32, 1))
          {
LABEL_93:
            __break(1u);
            goto LABEL_94;
          }
          if (v43 >= v36) {
            goto LABEL_78;
          }
          unint64_t v44 = *(void *)(v29 + 8 * v43);
          ++v32;
          if (!v44)
          {
            int64_t v32 = v43 + 1;
            if (v43 + 1 >= v36) {
              goto LABEL_78;
            }
            unint64_t v44 = *(void *)(v29 + 8 * v32);
            if (!v44)
            {
              int64_t v32 = v43 + 2;
              if (v43 + 2 >= v36) {
                goto LABEL_78;
              }
              unint64_t v44 = *(void *)(v29 + 8 * v32);
              if (!v44)
              {
                int64_t v45 = v43 + 3;
                if (v45 >= v36) {
                  goto LABEL_78;
                }
                unint64_t v44 = *(void *)(v29 + 8 * v45);
                if (!v44)
                {
                  while (1)
                  {
                    int64_t v32 = v45 + 1;
                    if (__OFADD__(v45, 1)) {
                      goto LABEL_97;
                    }
                    if (v32 >= v36) {
                      break;
                    }
                    unint64_t v44 = *(void *)(v29 + 8 * v32);
                    ++v45;
                    if (v44) {
                      goto LABEL_54;
                    }
                  }
LABEL_78:
                  swift_release(v5);
                  *uint64_t v3 = (uint64_t)v27;
LABEL_90:
                  uint64_t v74 = *v81;
                  *(void *)(*v81 + 8 * (a2 >> 6) + 56) |= 1 << a2;
                  uint64_t v75 = *(void *)(v74 + 48) + 40 * a2;
                  long long v76 = *a1;
                  long long v77 = a1[1];
                  *(void *)(v75 + 32) = *((void *)a1 + 4);
                  *(_OWORD *)uint64_t v75 = v76;
                  *(_OWORD *)(v75 + 16) = v77;
                  uint64_t v78 = *(void *)(v74 + 16);
                  BOOL v79 = __OFADD__(v78, 1);
                  uint64_t v80 = v78 + 1;
                  if (!v79)
                  {
                    *(void *)(v74 + 16) = v80;
                    return;
                  }
LABEL_95:
                  __break(1u);
                  goto LABEL_96;
                }
                int64_t v32 = v45;
              }
            }
          }
LABEL_54:
          unint64_t v35 = (v44 - 1) & v44;
          unint64_t v38 = __clz(__rbit64(v44)) + (v32 << 6);
        }
        uint64_t v39 = 40 * v38;
        outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v38, (uint64_t)&v87);
        uint64_t v40 = v27[6] + v39;
        long long v41 = v87;
        long long v42 = v88;
        *(void *)(v40 + 32) = v89;
        *(_OWORD *)uint64_t v40 = v41;
        *(_OWORD *)(v40 + 16) = v42;
      }
    }
    char v47 = specialized static _HashTable.scale(forCapacity:)(v8);
    LOBYTE(v87) = 1;
    unint64_t v10 = specialized static _SetStorage.allocate(scale:age:seed:)(v47, 0x100000000, 0, 1);
    if (*(void *)(v5 + 16))
    {
      uint64_t v48 = 1 << *(unsigned char *)(v5 + 32);
      uint64_t v49 = v5 + 56;
      uint64_t v50 = -1;
      if (v48 < 64) {
        uint64_t v50 = ~(-1 << v48);
      }
      unint64_t v51 = v50 & *(void *)(v5 + 56);
      int64_t v52 = (unint64_t)(v48 + 63) >> 6;
      swift_retain((atomic_ullong *)v5);
      int64_t v53 = 0;
      while (1)
      {
        if (v51)
        {
          unint64_t v54 = __clz(__rbit64(v51));
          v51 &= v51 - 1;
          unint64_t v55 = v54 | (v53 << 6);
        }
        else
        {
          int64_t v56 = v53 + 1;
          if (__OFADD__(v53, 1))
          {
LABEL_94:
            __break(1u);
            goto LABEL_95;
          }
          if (v56 >= v52) {
            goto LABEL_82;
          }
          unint64_t v57 = *(void *)(v49 + 8 * v56);
          ++v53;
          if (!v57)
          {
            int64_t v53 = v56 + 1;
            if (v56 + 1 >= v52) {
              goto LABEL_82;
            }
            unint64_t v57 = *(void *)(v49 + 8 * v53);
            if (!v57)
            {
              int64_t v53 = v56 + 2;
              if (v56 + 2 >= v52) {
                goto LABEL_82;
              }
              unint64_t v57 = *(void *)(v49 + 8 * v53);
              if (!v57)
              {
                int64_t v58 = v56 + 3;
                if (v58 >= v52) {
                  goto LABEL_82;
                }
                unint64_t v57 = *(void *)(v49 + 8 * v58);
                if (!v57)
                {
                  while (1)
                  {
                    int64_t v53 = v58 + 1;
                    if (__OFADD__(v58, 1)) {
                      goto LABEL_98;
                    }
                    if (v53 >= v52) {
                      break;
                    }
                    unint64_t v57 = *(void *)(v49 + 8 * v53);
                    ++v58;
                    if (v57) {
                      goto LABEL_77;
                    }
                  }
LABEL_82:
                  swift_release_n(v5, 2);
LABEL_83:
                  *uint64_t v3 = (uint64_t)v10;
                  uint64_t v59 = v10[5];
                  uint64_t v60 = *((void *)a1 + 3);
                  uint64_t v61 = *((void *)a1 + 4);
                  __swift_project_boxed_opaque_existential_0Tm(a1, v60);
                  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v61 + 8))(&v87, v60, v61);
                  uint64_t v62 = *((void *)&v88 + 1);
                  uint64_t v63 = v89;
                  __swift_project_boxed_opaque_existential_0Tm(&v87, *((uint64_t *)&v88 + 1));
                  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v63 + 40))(v59, v62, v63);
                  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v87);
                  uint64_t v65 = -1 << *((unsigned char *)v10 + 32);
                  a2 = v64 & ~v65;
                  if ((*(void *)((char *)v10 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) >> a2))
                  {
                    uint64_t v66 = ~v65;
                    do
                    {
                      outlined init with copy of AnyHashable(v10[6] + 40 * a2, (uint64_t)&v87);
                      uint64_t v67 = *((void *)&v88 + 1);
                      uint64_t v68 = v89;
                      __swift_project_boxed_opaque_existential_0Tm(&v87, *((uint64_t *)&v88 + 1));
                      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v68 + 8))(v84, v67, v68);
                      uint64_t v69 = v85;
                      uint64_t v70 = v86;
                      __swift_project_boxed_opaque_existential_0Tm(v84, v85);
                      uint64_t v71 = *((void *)a1 + 3);
                      uint64_t v72 = *((void *)a1 + 4);
                      __swift_project_boxed_opaque_existential_0Tm(a1, v71);
                      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v72 + 8))(v83, v71, v72);
                      char v73 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v70 + 16))(v83, v69, v70);
                      __swift_destroy_boxed_opaque_existential_1Tm(v83);
                      if (v73 == 2)
                      {
                        __swift_destroy_boxed_opaque_existential_1Tm(v84);
                        outlined destroy of AnyHashable((uint64_t *)&v87);
                      }
                      else
                      {
                        __swift_destroy_boxed_opaque_existential_1Tm(v84);
                        outlined destroy of AnyHashable((uint64_t *)&v87);
                        if (v73) {
                          ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
                        }
                      }
                      a2 = (a2 + 1) & v66;
                    }
                    while (((*(void *)((char *)v10 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) >> a2) & 1) != 0);
                  }
                  goto LABEL_90;
                }
                int64_t v53 = v58;
              }
            }
          }
LABEL_77:
          unint64_t v51 = (v57 - 1) & v57;
          unint64_t v55 = __clz(__rbit64(v57)) + (v53 << 6);
        }
        outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v55, (uint64_t)&v87);
        specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v87, (uint64_t)v10);
      }
    }
LABEL_81:
    swift_release(v5);
    goto LABEL_83;
  }
  if (v7 > v6) {
    uint64_t v8 = *(void *)(*v3 + 24);
  }
  char v9 = specialized static _HashTable.scale(forCapacity:)(v8);
  LOBYTE(v87) = 1;
  unint64_t v10 = specialized static _SetStorage.allocate(scale:age:seed:)(v9, 0x100000000, 0, 1);
  if (!*(void *)(v5 + 16)) {
    goto LABEL_81;
  }
  uint64_t v11 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v12 = (void *)(v5 + 56);
  uint64_t v13 = -1;
  if (v11 < 64) {
    uint64_t v13 = ~(-1 << v11);
  }
  unint64_t v14 = v13 & *(void *)(v5 + 56);
  int64_t v15 = (unint64_t)(v11 + 63) >> 6;
  swift_retain((atomic_ullong *)v5);
  int64_t v16 = 0;
  while (1)
  {
    if (v14)
    {
      unint64_t v17 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v18 = v17 | (v16 << 6);
      goto LABEL_11;
    }
    int64_t v20 = v16 + 1;
    if (__OFADD__(v16, 1))
    {
      __break(1u);
      goto LABEL_93;
    }
    if (v20 >= v15)
    {
LABEL_55:
      swift_release(v5);
      uint64_t v46 = 1 << *(unsigned char *)(v5 + 32);
      if (v46 > 63) {
        specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v46 + 63) >> 6, (int64x2_t *)(v5 + 56));
      }
      else {
        *uint64_t v12 = -1 << v46;
      }
      *(void *)(v5 + 16) = 0;
      goto LABEL_81;
    }
    unint64_t v21 = v12[v20];
    ++v16;
    if (!v21)
    {
      int64_t v16 = v20 + 1;
      if (v20 + 1 >= v15) {
        goto LABEL_55;
      }
      unint64_t v21 = v12[v16];
      if (!v21)
      {
        int64_t v16 = v20 + 2;
        if (v20 + 2 >= v15) {
          goto LABEL_55;
        }
        unint64_t v21 = v12[v16];
        if (!v21) {
          break;
        }
      }
    }
LABEL_26:
    unint64_t v14 = (v21 - 1) & v21;
    unint64_t v18 = __clz(__rbit64(v21)) + (v16 << 6);
LABEL_11:
    uint64_t v19 = *(void *)(v5 + 48) + 40 * v18;
    long long v87 = *(_OWORD *)v19;
    long long v88 = *(_OWORD *)(v19 + 16);
    uint64_t v89 = *(void *)(v19 + 32);
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v87, (uint64_t)v10);
  }
  int64_t v22 = v20 + 3;
  if (v22 >= v15) {
    goto LABEL_55;
  }
  unint64_t v21 = v12[v22];
  if (v21)
  {
    int64_t v16 = v22;
    goto LABEL_26;
  }
  while (1)
  {
    int64_t v16 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v16 >= v15) {
      goto LABEL_55;
    }
    unint64_t v21 = v12[v16];
    ++v22;
    if (v21) {
      goto LABEL_26;
    }
  }
LABEL_96:
  __break(1u);
LABEL_97:
  __break(1u);
LABEL_98:
  __break(1u);
}

uint64_t _NativeSet.insertNew(_:at:isUnique:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = a1;
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v31 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v12 = *(void *)(*v4 + 16);
  unint64_t v13 = *(void *)(*v4 + 24);
  int64_t v32 = v4;
  uint64_t v33 = v8;
  if (v13 <= v12 || (v9 & 1) == 0)
  {
    Swift::Int v14 = v12 + 1;
    if (v9)
    {
      _NativeSet.resize(capacity:)(v14);
    }
    else
    {
      if (v13 > v12)
      {
        _NativeSet.copy()();
        goto LABEL_12;
      }
      _NativeSet.copyAndResize(capacity:)(v14);
    }
    uint64_t v15 = *v4;
    uint64_t v16 = *(void *)(a4 + 24);
    uint64_t v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v16 + 32))(*(void *)(*v4 + 40), v7, v16);
    uint64_t v18 = -1 << *(unsigned char *)(v15 + 32);
    a2 = v17 & ~v18;
    uint64_t v36 = v15 + 56;
    uint64_t v37 = v15;
    if ((*(void *)(v15 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
    {
      uint64_t v35 = *(void *)(v16 + 8);
      uint64_t v34 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v35 + 8);
      uint64_t v19 = ~v18;
      int64_t v22 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
      uint64_t v20 = v8 + 16;
      unint64_t v21 = v22;
      uint64_t v23 = *(void *)(v20 + 56);
      while (1)
      {
        v21(v11, *(void *)(v37 + 48) + v23 * a2, v7);
        char v24 = v34(v11, v38, v7, v35);
        (*(void (**)(char *, uint64_t))(v20 - 8))(v11, v7);
        if (v24) {
          break;
        }
        a2 = (a2 + 1) & v19;
        if (((*(void *)(v36 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) == 0) {
          goto LABEL_12;
        }
      }
LABEL_15:
      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v7);
    }
  }
LABEL_12:
  uint64_t v25 = v33;
  uint64_t v26 = *v32;
  *(void *)(v26 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v25 + 32))(*(void *)(v26 + 48) + *(void *)(v25 + 72) * a2, v38, v7);
  uint64_t v28 = *(void *)(v26 + 16);
  BOOL v29 = __OFADD__(v28, 1);
  uint64_t v30 = v28 + 1;
  if (v29)
  {
    __break(1u);
    goto LABEL_15;
  }
  *(void *)(v26 + 16) = v30;
  return result;
}

double specialized _NativeSet.update(with:isUnique:)@<D0>(long long *a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 40);
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v8 + 8))(&v117, v7, v8);
  uint64_t v9 = *((void *)&v118 + 1);
  uint64_t v10 = v119;
  __swift_project_boxed_opaque_existential_0Tm(&v117, *((uint64_t *)&v118 + 1));
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v6, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v117);
  uint64_t v12 = -1 << *(unsigned char *)(v5 + 32);
  unint64_t v13 = v11 & ~v12;
  if ((*(void *)(v5 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13))
  {
    char v108 = a2;
    uint64_t v14 = ~v12;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v13, (uint64_t)&v117);
      uint64_t v15 = *((void *)&v118 + 1);
      uint64_t v16 = v119;
      __swift_project_boxed_opaque_existential_0Tm(&v117, *((uint64_t *)&v118 + 1));
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 8))(v114, v15, v16);
      uint64_t v17 = v115;
      uint64_t v18 = v116;
      __swift_project_boxed_opaque_existential_0Tm(v114, v115);
      uint64_t v19 = *((void *)a1 + 3);
      uint64_t v20 = *((void *)a1 + 4);
      __swift_project_boxed_opaque_existential_0Tm(a1, v19);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v113, v19, v20);
      char v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v18 + 16))(v113, v17, v18);
      __swift_destroy_boxed_opaque_existential_1Tm(v113);
      if (v21 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v114);
        outlined destroy of AnyHashable((uint64_t *)&v117);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v114);
        outlined destroy of AnyHashable((uint64_t *)&v117);
        if (v21)
        {
          int v22 = 1;
          a2 = v108;
          goto LABEL_10;
        }
      }
      unint64_t v13 = (v13 + 1) & v14;
    }
    while (((*(void *)(v5 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) != 0);
    int v22 = 0;
    a2 = v108;
  }
  else
  {
    int v22 = 0;
  }
LABEL_10:
  uint64_t v23 = *v111;
  uint64_t v24 = *(void *)(*v111 + 16);
  uint64_t v25 = v22 ^ 1u;
  uint64_t v26 = v24 + v25;
  if (__OFADD__(v24, v25)) {
    goto LABEL_108;
  }
  uint64_t v27 = *(void *)(v23 + 24);
  if (v27 >= v26 && (a2 & 1) != 0)
  {
    uint64_t v28 = (void *)*v111;
    if (v22) {
      goto LABEL_100;
    }
    goto LABEL_14;
  }
  int v109 = v22;
  if (a2)
  {
    if (v27 > v26) {
      uint64_t v26 = *(void *)(v23 + 24);
    }
    char v31 = specialized static _HashTable.scale(forCapacity:)(v26);
    LOBYTE(v117) = 1;
    int64_t v32 = specialized static _SetStorage.allocate(scale:age:seed:)(v31, 0x100000000, 0, 1);
    if (*(void *)(v23 + 16))
    {
      uint64_t v33 = 1 << *(unsigned char *)(v23 + 32);
      uint64_t v34 = (void *)(v23 + 56);
      uint64_t v35 = -1;
      if (v33 < 64) {
        uint64_t v35 = ~(-1 << v33);
      }
      unint64_t v36 = v35 & *(void *)(v23 + 56);
      int64_t v37 = (unint64_t)(v33 + 63) >> 6;
      swift_retain((atomic_ullong *)v23);
      int64_t v38 = 0;
      while (1)
      {
        if (v36)
        {
          unint64_t v39 = __clz(__rbit64(v36));
          v36 &= v36 - 1;
          unint64_t v40 = v39 | (v38 << 6);
        }
        else
        {
          int64_t v42 = v38 + 1;
          if (__OFADD__(v38, 1))
          {
            __break(1u);
LABEL_106:
            __break(1u);
LABEL_107:
            __break(1u);
LABEL_108:
            __break(1u);
            goto LABEL_109;
          }
          if (v42 >= v37) {
            goto LABEL_64;
          }
          unint64_t v43 = v34[v42];
          ++v38;
          if (!v43)
          {
            int64_t v38 = v42 + 1;
            if (v42 + 1 >= v37) {
              goto LABEL_64;
            }
            unint64_t v43 = v34[v38];
            if (!v43)
            {
              int64_t v38 = v42 + 2;
              if (v42 + 2 >= v37) {
                goto LABEL_64;
              }
              unint64_t v43 = v34[v38];
              if (!v43)
              {
                int64_t v44 = v42 + 3;
                if (v44 >= v37)
                {
LABEL_64:
                  swift_release(v23);
                  uint64_t v66 = 1 << *(unsigned char *)(v23 + 32);
                  if (v66 > 63) {
                    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v66 + 63) >> 6, (int64x2_t *)(v23 + 56));
                  }
                  else {
                    *uint64_t v34 = -1 << v66;
                  }
                  *(void *)(v23 + 16) = 0;
                  break;
                }
                unint64_t v43 = v34[v44];
                if (!v43)
                {
                  while (1)
                  {
                    int64_t v38 = v44 + 1;
                    if (__OFADD__(v44, 1)) {
                      break;
                    }
                    if (v38 >= v37) {
                      goto LABEL_64;
                    }
                    unint64_t v43 = v34[v38];
                    ++v44;
                    if (v43) {
                      goto LABEL_38;
                    }
                  }
LABEL_109:
                  __break(1u);
LABEL_110:
                  __break(1u);
LABEL_111:
                  __break(1u);
LABEL_112:
                  __break(1u);
                  goto LABEL_113;
                }
                int64_t v38 = v44;
              }
            }
          }
LABEL_38:
          unint64_t v36 = (v43 - 1) & v43;
          unint64_t v40 = __clz(__rbit64(v43)) + (v38 << 6);
        }
        uint64_t v41 = *(void *)(v23 + 48) + 40 * v40;
        long long v117 = *(_OWORD *)v41;
        long long v118 = *(_OWORD *)(v41 + 16);
        uint64_t v119 = *(void *)(v41 + 32);
        specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v117, (uint64_t)v32);
      }
    }
LABEL_92:
    swift_release(v23);
    *uint64_t v111 = (uint64_t)v32;
    uint64_t v79 = v32[5];
    uint64_t v80 = *((void *)a1 + 3);
    uint64_t v81 = *((void *)a1 + 4);
    __swift_project_boxed_opaque_existential_0Tm(a1, v80);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v81 + 8))(&v117, v80, v81);
    uint64_t v82 = *((void *)&v118 + 1);
    uint64_t v83 = v119;
    __swift_project_boxed_opaque_existential_0Tm(&v117, *((uint64_t *)&v118 + 1));
    uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v83 + 40))(v79, v82, v83);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v117);
    uint64_t v85 = -1 << *((unsigned char *)v32 + 32);
    unint64_t v13 = v84 & ~v85;
    uint64_t v86 = v32 + 7;
    unint64_t v29 = v13 >> 6;
    uint64_t v30 = 1 << v13;
    if (((1 << v13) & v32[(v13 >> 6) + 7]) != 0)
    {
      uint64_t v87 = ~v85;
      do
      {
        long long v88 = v32;
        outlined init with copy of AnyHashable(v32[6] + 40 * v13, (uint64_t)&v117);
        uint64_t v89 = *((void *)&v118 + 1);
        uint64_t v90 = v119;
        __swift_project_boxed_opaque_existential_0Tm(&v117, *((uint64_t *)&v118 + 1));
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v90 + 8))(v114, v89, v90);
        uint64_t v91 = v115;
        uint64_t v92 = v116;
        __swift_project_boxed_opaque_existential_0Tm(v114, v115);
        uint64_t v93 = *((void *)a1 + 3);
        uint64_t v94 = *((void *)a1 + 4);
        __swift_project_boxed_opaque_existential_0Tm(a1, v93);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v94 + 8))(v113, v93, v94);
        char v95 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v92 + 16))(v113, v91, v92);
        __swift_destroy_boxed_opaque_existential_1Tm(v113);
        if (v95 == 2)
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v114);
          outlined destroy of AnyHashable((uint64_t *)&v117);
        }
        else
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v114);
          outlined destroy of AnyHashable((uint64_t *)&v117);
          if (v95)
          {
            if (v109)
            {
              uint64_t v28 = (void *)*v111;
              goto LABEL_100;
            }
LABEL_113:
            ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
          }
        }
        unint64_t v13 = (v13 + 1) & v87;
        unint64_t v29 = v13 >> 6;
        uint64_t v30 = 1 << v13;
        int64_t v32 = v88;
      }
      while ((v86[v13 >> 6] & (1 << v13)) != 0);
    }
    if (v109) {
      goto LABEL_113;
    }
    goto LABEL_102;
  }
  if (v27 < v26)
  {
    char v67 = specialized static _HashTable.scale(forCapacity:)(v26);
    LOBYTE(v117) = 1;
    int64_t v32 = specialized static _SetStorage.allocate(scale:age:seed:)(v67, 0x100000000, 0, 1);
    if (!*(void *)(v23 + 16)) {
      goto LABEL_92;
    }
    uint64_t v68 = 1 << *(unsigned char *)(v23 + 32);
    uint64_t v69 = v23 + 56;
    uint64_t v70 = -1;
    if (v68 < 64) {
      uint64_t v70 = ~(-1 << v68);
    }
    unint64_t v71 = v70 & *(void *)(v23 + 56);
    int64_t v72 = (unint64_t)(v68 + 63) >> 6;
    swift_retain((atomic_ullong *)v23);
    int64_t v73 = 0;
    while (1)
    {
      if (v71)
      {
        unint64_t v74 = __clz(__rbit64(v71));
        v71 &= v71 - 1;
        unint64_t v75 = v74 | (v73 << 6);
      }
      else
      {
        int64_t v76 = v73 + 1;
        if (__OFADD__(v73, 1)) {
          goto LABEL_107;
        }
        if (v76 >= v72) {
          goto LABEL_91;
        }
        unint64_t v77 = *(void *)(v69 + 8 * v76);
        ++v73;
        if (!v77)
        {
          int64_t v73 = v76 + 1;
          if (v76 + 1 >= v72) {
            goto LABEL_91;
          }
          unint64_t v77 = *(void *)(v69 + 8 * v73);
          if (!v77)
          {
            int64_t v73 = v76 + 2;
            if (v76 + 2 >= v72) {
              goto LABEL_91;
            }
            unint64_t v77 = *(void *)(v69 + 8 * v73);
            if (!v77)
            {
              int64_t v78 = v76 + 3;
              if (v78 >= v72) {
                goto LABEL_91;
              }
              unint64_t v77 = *(void *)(v69 + 8 * v78);
              if (!v77)
              {
                while (1)
                {
                  int64_t v73 = v78 + 1;
                  if (__OFADD__(v78, 1)) {
                    goto LABEL_112;
                  }
                  if (v73 >= v72) {
                    break;
                  }
                  unint64_t v77 = *(void *)(v69 + 8 * v73);
                  ++v78;
                  if (v77) {
                    goto LABEL_86;
                  }
                }
LABEL_91:
                swift_release(v23);
                goto LABEL_92;
              }
              int64_t v73 = v78;
            }
          }
        }
LABEL_86:
        unint64_t v71 = (v77 - 1) & v77;
        unint64_t v75 = __clz(__rbit64(v77)) + (v73 << 6);
      }
      outlined init with copy of AnyHashable(*(void *)(v23 + 48) + 40 * v75, (uint64_t)&v117);
      specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v117, (uint64_t)v32);
    }
  }
  uint64_t v45 = *(unsigned int *)(v23 + 36);
  uint64_t v46 = *(void **)(v23 + 40);
  char v47 = *(unsigned char *)(v23 + 32);
  LOBYTE(v117) = 0;
  uint64_t v48 = specialized static _SetStorage.allocate(scale:age:seed:)(v47, v45, v46, 0);
  uint64_t v28 = v48;
  if (!*(void *)(v23 + 16)) {
    goto LABEL_87;
  }
  uint64_t v49 = v48 + 7;
  uint64_t v50 = v23 + 56;
  unint64_t v51 = (unint64_t)((1 << *((unsigned char *)v28 + 32)) + 63) >> 6;
  if (v28 != (void *)v23 || (unint64_t)v49 >= v50 + 8 * v51) {
    memmove(v49, (const void *)(v23 + 56), 8 * v51);
  }
  int64_t v52 = 0;
  v28[2] = *(void *)(v23 + 16);
  uint64_t v53 = 1 << *(unsigned char *)(v23 + 32);
  uint64_t v54 = -1;
  if (v53 < 64) {
    uint64_t v54 = ~(-1 << v53);
  }
  unint64_t v55 = v54 & *(void *)(v23 + 56);
  int64_t v56 = (unint64_t)(v53 + 63) >> 6;
  while (1)
  {
    if (v55)
    {
      unint64_t v57 = __clz(__rbit64(v55));
      v55 &= v55 - 1;
      unint64_t v58 = v57 | (v52 << 6);
      goto LABEL_48;
    }
    int64_t v63 = v52 + 1;
    if (__OFADD__(v52, 1)) {
      goto LABEL_106;
    }
    if (v63 >= v56) {
      goto LABEL_87;
    }
    unint64_t v64 = *(void *)(v50 + 8 * v63);
    ++v52;
    if (!v64)
    {
      int64_t v52 = v63 + 1;
      if (v63 + 1 >= v56) {
        goto LABEL_87;
      }
      unint64_t v64 = *(void *)(v50 + 8 * v52);
      if (!v64)
      {
        int64_t v52 = v63 + 2;
        if (v63 + 2 >= v56) {
          goto LABEL_87;
        }
        unint64_t v64 = *(void *)(v50 + 8 * v52);
        if (!v64) {
          break;
        }
      }
    }
LABEL_63:
    unint64_t v55 = (v64 - 1) & v64;
    unint64_t v58 = __clz(__rbit64(v64)) + (v52 << 6);
LABEL_48:
    uint64_t v59 = 40 * v58;
    outlined init with copy of AnyHashable(*(void *)(v23 + 48) + 40 * v58, (uint64_t)&v117);
    uint64_t v60 = v28[6] + v59;
    long long v61 = v117;
    long long v62 = v118;
    *(void *)(v60 + 32) = v119;
    *(_OWORD *)uint64_t v60 = v61;
    *(_OWORD *)(v60 + 16) = v62;
  }
  int64_t v65 = v63 + 3;
  if (v65 >= v56) {
    goto LABEL_87;
  }
  unint64_t v64 = *(void *)(v50 + 8 * v65);
  if (v64)
  {
    int64_t v52 = v65;
    goto LABEL_63;
  }
  while (1)
  {
    int64_t v52 = v65 + 1;
    if (__OFADD__(v65, 1)) {
      goto LABEL_111;
    }
    if (v52 >= v56) {
      break;
    }
    unint64_t v64 = *(void *)(v50 + 8 * v52);
    ++v65;
    if (v64) {
      goto LABEL_63;
    }
  }
LABEL_87:
  swift_release(v23);
  *uint64_t v111 = (uint64_t)v28;
  if (v109)
  {
LABEL_100:
    uint64_t v96 = v28[6] + 40 * v13;
    long long v97 = *(_OWORD *)(v96 + 16);
    *(_OWORD *)a3 = *(_OWORD *)v96;
    *(_OWORD *)(a3 + 16) = v97;
    *(void *)(a3 + 32) = *(void *)(v96 + 32);
    uint64_t v98 = *((void *)a1 + 4);
    long long v99 = a1[1];
    *(_OWORD *)uint64_t v96 = *a1;
    *(_OWORD *)(v96 + 16) = v99;
    *(void *)(v96 + 32) = v98;
    return *(double *)&v99;
  }
LABEL_14:
  unint64_t v29 = v13 >> 6;
  uint64_t v30 = 1 << v13;
LABEL_102:
  uint64_t v100 = *v111;
  *(void *)(*v111 + 8 * v29 + 56) |= v30;
  uint64_t v101 = *(void *)(v100 + 48) + 40 * v13;
  long long v102 = *a1;
  long long v103 = a1[1];
  *(void *)(v101 + 32) = *((void *)a1 + 4);
  *(_OWORD *)uint64_t v101 = v102;
  *(_OWORD *)(v101 + 16) = v103;
  uint64_t v104 = *(void *)(v100 + 16);
  BOOL v105 = __OFADD__(v104, 1);
  uint64_t v106 = v104 + 1;
  if (v105) {
    goto LABEL_110;
  }
  *(void *)(v100 + 16) = v106;
  *(void *)&long long v99 = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)(a3 + 32) = 0;
  return *(double *)&v99;
}

uint64_t _NativeSet.update(with:isUnique:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  LODWORD(v57) = a2;
  uint64_t v54 = a4;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)v52 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v56 = v4;
  uint64_t v9 = *v4;
  uint64_t v10 = *(void *)(*v4 + 40);
  uint64_t v52[2] = v11;
  uint64_t v12 = *(void *)(v11 + 24);
  unint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 32);
  unint64_t v63 = v14;
  v52[0] = v13;
  v52[1] = v12 + 32;
  uint64_t v15 = v13(v10, v5, v12);
  uint64_t v16 = -1 << *(unsigned char *)(v9 + 32);
  unint64_t v17 = v15 & ~v16;
  uint64_t v61 = v9 + 56;
  uint64_t v62 = v9;
  uint64_t v18 = *(void *)(v9 + 56 + ((v17 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v17;
  uint64_t v55 = v6;
  uint64_t v53 = v12;
  if (v18)
  {
    uint64_t v60 = *(void *)(v12 + 8);
    uint64_t v19 = *(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v60 + 8);
    uint64_t v58 = ~v16;
    uint64_t v59 = v19;
    int v22 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    uint64_t v21 = v6 + 16;
    uint64_t v20 = v22;
    uint64_t v23 = *(void *)(v21 + 56);
    do
    {
      v20(v8, *(void *)(v62 + 48) + v23 * v17, v5);
      char v24 = v59(v8, v63, v5, v60);
      (*(void (**)(char *, uint64_t))(v21 - 8))(v8, v5);
      if (v24) {
        break;
      }
      unint64_t v17 = (v17 + 1) & v58;
    }
    while (((*(void *)(v61 + ((v17 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v17) & 1) != 0);
  }
  else
  {
    char v24 = 0;
  }
  uint64_t v25 = v56;
  uint64_t v26 = *(void *)(*v56 + 16);
  BOOL v27 = (v24 & 1) == 0;
  Swift::Int v28 = v26 + v27;
  if (__OFADD__(v26, v27))
  {
    __break(1u);
    goto LABEL_30;
  }
  Swift::Int v29 = *(void *)(*v56 + 24);
  uint64_t v30 = v55;
  if (v29 >= v28 && (v57 & 1) != 0)
  {
    if (v24)
    {
LABEL_11:
      unint64_t v31 = *(void *)(v30 + 72) * v17;
LABEL_27:
      uint64_t v49 = *v25;
      uint64_t v50 = *(void (**)(uint64_t, unint64_t, uint64_t))(v30 + 32);
      uint64_t v48 = v54;
      v50(v54, *(void *)(*v25 + 48) + v31, v5);
      v50(*(void *)(v49 + 48) + v31, v63, v5);
      uint64_t v47 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v30 + 56))(v48, v47, 1, v5);
    }
LABEL_16:
    unint64_t v33 = v17 >> 6;
    uint64_t v34 = 1 << v17;
    goto LABEL_24;
  }
  if (v57)
  {
    _NativeSet.resize(capacity:)(v28);
    uint64_t v32 = v53;
  }
  else
  {
    uint64_t v32 = v53;
    if (v29 >= v28)
    {
      _NativeSet.copy()();
      if (v24) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
    _NativeSet.copyAndResize(capacity:)(v28);
  }
  uint64_t v35 = *v25;
  uint64_t v36 = ((uint64_t (*)(void, uint64_t, uint64_t))v52[0])(*(void *)(*v25 + 40), v5, v32);
  uint64_t v37 = -1 << *(unsigned char *)(v35 + 32);
  unint64_t v17 = v36 & ~v37;
  unint64_t v33 = v17 >> 6;
  uint64_t v61 = v35 + 56;
  uint64_t v62 = v35;
  uint64_t v34 = 1 << v17;
  if (((1 << v17) & *(void *)(v35 + 56 + 8 * (v17 >> 6))) == 0) {
    goto LABEL_23;
  }
  uint64_t v57 = ~v37;
  uint64_t v60 = *(void *)(v32 + 8);
  int64_t v38 = *(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v60 + 8);
  unint64_t v40 = *(void (**)(void, void, void))(v30 + 16);
  uint64_t v39 = v30 + 16;
  uint64_t v58 = (uint64_t)v40;
  uint64_t v59 = v38;
  uint64_t v41 = *(void *)(v39 + 56);
  do
  {
    unint64_t v31 = v41 * v17;
    ((void (*)(char *, unint64_t, uint64_t))v58)(v8, *(void *)(v62 + 48) + v41 * v17, v5);
    char v42 = v59(v8, v63, v5, v60);
    (*(void (**)(char *, uint64_t))(v39 - 8))(v8, v5);
    if (v42)
    {
      uint64_t v30 = v55;
      uint64_t v25 = v56;
      if (v24) {
        goto LABEL_27;
      }
LABEL_31:
      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v5);
    }
    unint64_t v17 = (v17 + 1) & v57;
    unint64_t v33 = v17 >> 6;
    uint64_t v34 = 1 << v17;
  }
  while ((*(void *)(v61 + 8 * (v17 >> 6)) & (1 << v17)) != 0);
  uint64_t v30 = v55;
  uint64_t v25 = v56;
LABEL_23:
  if (v24) {
    goto LABEL_31;
  }
LABEL_24:
  uint64_t v43 = *v25;
  *(void *)(*v25 + 8 * v33 + 56) |= v34;
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v30 + 32))(*(void *)(v43 + 48) + *(void *)(v30 + 72) * v17, v63, v5);
  uint64_t v44 = *(void *)(v43 + 16);
  BOOL v45 = __OFADD__(v44, 1);
  uint64_t v46 = v44 + 1;
  if (v45)
  {
LABEL_30:
    __break(1u);
    goto LABEL_31;
  }
  *(void *)(v43 + 16) = v46;
  uint64_t v47 = 1;
  uint64_t v48 = v54;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v30 + 56))(v48, v47, 1, v5);
}

uint64_t _NativeSet._unsafeUpdate(with:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v28 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  Swift::Int v29 = v2;
  uint64_t v7 = *v2;
  uint64_t v8 = *(void *)(*v2 + 40);
  uint64_t v10 = *(void *)(v9 + 24);
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 32);
  uint64_t v35 = v12;
  uint64_t v13 = v11(v8, v3, v10);
  uint64_t v14 = -1 << *(unsigned char *)(v7 + 32);
  unint64_t v15 = v13 & ~v14;
  uint64_t v33 = v7 + 56;
  uint64_t v34 = v7;
  uint64_t v16 = *(void *)(v7 + 56 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15;
  uint64_t v28 = v4;
  if (v16)
  {
    uint64_t v32 = *(void *)(v10 + 8);
    unint64_t v17 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v32 + 8);
    uint64_t v30 = ~v14;
    unint64_t v31 = v17;
    uint64_t v20 = *(void (**)(char *, unint64_t, uint64_t))(v4 + 16);
    uint64_t v18 = v4 + 16;
    uint64_t v19 = v20;
    uint64_t v21 = *(void *)(v18 + 56);
    while (1)
    {
      v19(v6, *(void *)(v34 + 48) + v21 * v15, v3);
      char v22 = v31(v6, v35, v3, v32);
      (*(void (**)(char *, uint64_t))(v18 - 8))(v6, v3);
      if (v22) {
        return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v28 + 40))(*(void *)(*v29 + 48) + v21 * v15, v35, v3);
      }
      unint64_t v15 = (v15 + 1) & v30;
      if (((*(void *)(v33 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15) & 1) == 0) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    uint64_t v23 = *v29;
    if (*(void *)(*v29 + 16) >= *(void *)(*v29 + 24)) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/NativeSet.swift", 21, 2, 0x1DFuLL, 0);
    }
    *(void *)(v23 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) |= 1 << v15;
    uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v28 + 32))(*(void *)(v23 + 48) + *(void *)(v28 + 72) * v15, v35, v3);
    uint64_t v25 = *(void *)(v23 + 16);
    BOOL v26 = __OFADD__(v25, 1);
    uint64_t v27 = v25 + 1;
    if (v26) {
      __break(1u);
    }
    else {
      *(void *)(v23 + 16) = v27;
    }
  }
  return result;
}

uint64_t _NativeSet.isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  int64_t v56 = (char *)&v39 - v13;
  uint64_t result = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v39 - v15;
  if (v17 == result) {
    return 1;
  }
  if (*(void *)(a2 + 16) != *(void *)(v7 + 16)) {
    return 0;
  }
  int64_t v18 = 0;
  uint64_t v19 = *(void *)(a2 + 56);
  uint64_t v40 = a2 + 56;
  uint64_t v20 = 1 << *(unsigned char *)(a2 + 32);
  if (v20 < 64) {
    uint64_t v21 = ~(-1 << v20);
  }
  else {
    uint64_t v21 = -1;
  }
  unint64_t v22 = v21 & v19;
  int64_t v23 = (unint64_t)(v20 + 63) >> 6;
  uint64_t v50 = v8 + 32;
  uint64_t v49 = a4 + 32;
  uint64_t v53 = v7 + 56;
  uint64_t v54 = v8 + 16;
  unint64_t v55 = v8 + 8;
  int64_t v41 = v23;
  char v42 = (char *)&v39 - v15;
  uint64_t v44 = a2;
  uint64_t v45 = a4;
  uint64_t v43 = v8;
  if (!v22) {
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v48 = (v22 - 1) & v22;
  for (unint64_t i = __clz(__rbit64(v22)) | (v18 << 6); ; unint64_t i = __clz(__rbit64(v26)) + (v18 << 6))
  {
    uint64_t v28 = *(void *)(v8 + 72);
    unint64_t v29 = *(void *)(a2 + 48) + v28 * i;
    unint64_t v51 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
    uint64_t v52 = v28;
    v51(v16, v29, a3);
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v56, v16, a3);
    uint64_t v30 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(v7 + 40), a3, a4);
    uint64_t v31 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v32 = v30 & ~v31;
    if (((*(void *)(v53 + ((v32 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v32) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t))v55)(v56, a3);
      return 0;
    }
    uint64_t v46 = v55 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    int64_t v47 = v18;
    uint64_t v33 = v7;
    uint64_t v34 = ~v31;
    uint64_t v35 = *(void *)(a4 + 8);
    uint64_t v36 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v35 + 8);
    while (1)
    {
      v51(v11, *(void *)(v33 + 48) + v32 * v52, a3);
      char v37 = v36(v11, v56, a3, v35);
      int64_t v38 = *(void (**)(char *, uint64_t))v55;
      (*(void (**)(char *, uint64_t))v55)(v11, a3);
      if (v37) {
        break;
      }
      unint64_t v32 = (v32 + 1) & v34;
      if (((*(void *)(v53 + ((v32 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v32) & 1) == 0)
      {
        v38(v56, a3);
        return 0;
      }
    }
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v38)(v56, a3);
    a2 = v44;
    a4 = v45;
    uint64_t v7 = v33;
    uint64_t v16 = v42;
    uint64_t v8 = v43;
    int64_t v18 = v47;
    unint64_t v22 = v48;
    int64_t v23 = v41;
    if (v48) {
      goto LABEL_7;
    }
LABEL_9:
    if (__OFADD__(v18++, 1)) {
      break;
    }
    if (v18 >= v23) {
      return 1;
    }
    unint64_t v26 = *(void *)(v40 + 8 * v18);
    if (!v26)
    {
      int64_t v27 = v18 + 1;
      if (v18 + 1 >= v23) {
        return 1;
      }
      unint64_t v26 = *(void *)(v40 + 8 * v27);
      if (!v26)
      {
        while (1)
        {
          int64_t v18 = v27 + 1;
          if (__OFADD__(v27, 1)) {
            break;
          }
          if (v18 >= v23) {
            return 1;
          }
          unint64_t v26 = *(void *)(v40 + 8 * v18);
          ++v27;
          if (v26) {
            goto LABEL_18;
          }
        }
        __break(1u);
        break;
      }
      ++v18;
    }
LABEL_18:
    uint64_t v48 = (v26 - 1) & v26;
  }
  __break(1u);
  return result;
}

uint64_t _NativeSet.makeIterator()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1;
  uint64_t v3 = -1 << *(unsigned char *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = a1 + 56;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1 << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0;
  a2[4] = v2 & v5;
  return result;
}

uint64_t _NativeSet.Iterator.next()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (!v4)
  {
    uint64_t v12 = v2[3];
    int64_t v13 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      return result;
    }
    int64_t v14 = (unint64_t)(v2[2] + 64) >> 6;
    if (v13 < v14)
    {
      v2[3] = v13;
      uint64_t v15 = v2[1];
      unint64_t v16 = *(void *)(v15 + 8 * v13);
      v2[4] = v16;
      if (v16)
      {
LABEL_11:
        v2[4] = (v16 - 1) & v16;
        unint64_t v5 = __clz(__rbit64(v16)) + (v13 << 6);
        goto LABEL_3;
      }
      uint64_t v17 = v12 + 2;
      while (v14 != v17)
      {
        v2[3] = v17;
        unint64_t v16 = *(void *)(v15 + 8 * v17);
        v2[4] = v16;
        ++v17;
        if (v16)
        {
          int64_t v13 = v17 - 1;
          goto LABEL_11;
        }
      }
    }
    uint64_t v11 = *(void *)(result + 16);
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56);
    uint64_t v9 = a2;
    uint64_t v10 = 1;
    goto LABEL_13;
  }
  v2[4] = (v4 - 1) & v4;
  unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
  uint64_t v6 = *(void *)(*v2 + 48);
  uint64_t v7 = *(void *)(result + 16);
  uint64_t v18 = *(void *)(v7 - 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v18 + 16))(a2, v6 + *(void *)(v18 + 72) * v5, v7);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 56);
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = v7;
LABEL_13:

  return v8(v9, v10, 1, v11);
}

void _NativeSet.isEqual(to:)(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(a3 - 1);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (void *)MEMORY[0x1F4188790](v8);
  uint64_t v11 = (id *)((char *)&v28 - v10);
  id v13 = *(id *)(v12 + 16);
  if (v13 == objc_msgSend(v9, sel_count))
  {
    unint64_t v29 = (id *)((char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
    uint64_t v31 = a2;
    id v32 = a1;
    int64_t v14 = 0;
    uint64_t v15 = a2 + 56;
    uint64_t v16 = 1 << *(unsigned char *)(a2 + 32);
    uint64_t v17 = -1;
    if (v16 < 64) {
      uint64_t v17 = ~(-1 << v16);
    }
    unint64_t v18 = v17 & *(void *)(a2 + 56);
    int64_t v19 = (unint64_t)(v16 + 63) >> 6;
    uint64_t v33 = v6 + 16;
    uint64_t v28 = (void (**)(char *, id *, uint64_t *))(v6 + 32);
    uint64_t v30 = v7;
    if (!v18) {
      goto LABEL_6;
    }
LABEL_5:
    unint64_t v20 = __clz(__rbit64(v18));
    v18 &= v18 - 1;
    for (unint64_t i = v20 | (v14 << 6); ; unint64_t i = __clz(__rbit64(v23)) + (v14 << 6))
    {
      (*(void (**)(id *, unint64_t, uint64_t *))(v6 + 16))(v11, *(void *)(a2 + 48) + *(void *)(v6 + 72) * i, a3);
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
      {
        if (v7 != 8) {
          goto LABEL_23;
        }
        char v24 = *v11;
        uint64_t v25 = *(void (**)(id *, uint64_t *))(v6 + 8);
        swift_unknownObjectRetain(*v11);
        v25(v11, a3);
      }
      else
      {
        int64_t v27 = v29;
        (*v28)((char *)v29, v11, a3);
        char v24 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v27, a3);
      }
      id v26 = [v32 sel_member_:v24 v28];
      swift_unknownObjectRelease(v24);
      if (!v26) {
        break;
      }
      swift_unknownObjectRelease(v26);
      uint64_t v7 = v30;
      a2 = v31;
      if (v18) {
        goto LABEL_5;
      }
LABEL_6:
      int64_t v22 = v14 + 1;
      if (__OFADD__(v14, 1))
      {
        __break(1u);
        return;
      }
      if (v22 >= v19) {
        return;
      }
      unint64_t v23 = *(void *)(v15 + 8 * v22);
      ++v14;
      if (!v23)
      {
        while (1)
        {
          int64_t v14 = v22 + 1;
          if (__OFADD__(v22, 1)) {
            break;
          }
          if (v14 >= v19) {
            return;
          }
          unint64_t v23 = *(void *)(v15 + 8 * v14);
          ++v22;
          if (v23) {
            goto LABEL_12;
          }
        }
        __break(1u);
LABEL_23:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
LABEL_12:
      unint64_t v18 = (v23 - 1) & v23;
    }
  }
}

BOOL __CocoaSet.contains(_:)(uint64_t a1, void *a2)
{
  return __CocoaDictionary.contains(_:)(a1, a2, (SEL *)&selRef_member_);
}

BOOL __CocoaDictionary.contains(_:)(uint64_t a1, id a2, SEL *a3)
{
  id v3 = [a2 *a3:a1];
  id v4 = v3;
  if (v3) {
    swift_unknownObjectRelease(v3);
  }
  return v4 != 0;
}

Swift::Int __swiftcall _NativeSet.hashValue(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v2 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](at.offset);
  uint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v7 + 16))(v10, *(void *)(v11 + 48) + *(void *)(v12 + 72) * v8);
  Swift::Int v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v4 + 32))(*(void *)(v6 + 40), v5, v4);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v5);
  return v13;
}

Swift::Void __swiftcall _NativeSet.moveEntry(from:to:)(Swift::_HashTable::Bucket from, Swift::_HashTable::Bucket to)
{
  uint64_t v5 = *(void *)(v2 + 48);
  uint64_t v6 = *(void *)(*(v3 - 1) + 72);
  Swift::Int v7 = v6 * to.offset;
  uint64_t v8 = (char *)(v5 + v6 * to.offset);
  Swift::Int v9 = v6 * from.offset;
  uint64_t v10 = (char *)(v5 + v9);
  unint64_t v11 = v5 + v9 + v6;
  if (v7 < v9 || (unint64_t)v8 >= v11)
  {
    swift_arrayInitWithTakeFrontToBack(v8, v10, 1, v3);
  }
  else if (v7 != v9)
  {
    swift_arrayInitWithTakeBackToFront(v8, v10, 1, (uint64_t)v3);
  }
}

uint64_t protocol witness for _HashTableDelegate.hashValue(at:) in conformance _NativeSet<A>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *v2;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, *(void *)(v9 + 48) + *(void *)(v10 + 72) * v6, v4);
  uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a2 + 24) + 32))(*(void *)(v9 + 40), v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
  return v11;
}

char *protocol witness for _HashTableDelegate.moveEntry(from:to:) in conformance _NativeSet<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)v3 + 48);
  uint64_t v6 = *(unint64_t **)(a3 + 16);
  uint64_t v7 = *(void *)(*(v6 - 1) + 72);
  uint64_t v8 = v7 * a2;
  uint64_t result = (char *)(v5 + v7 * a2);
  uint64_t v10 = v7 * a1;
  uint64_t v11 = (char *)(v5 + v10);
  unint64_t v12 = v5 + v10 + v7;
  if (v8 < v10 || (unint64_t)result >= v12) {
    return swift_arrayInitWithTakeFrontToBack(result, v11, 1, v6);
  }
  if (v8 != v10) {
    return swift_arrayInitWithTakeBackToFront(result, v11, 1, (uint64_t)v6);
  }
  return result;
}

unint64_t specialized _NativeSet._delete(at:)(unint64_t result)
{
  v2.Swift::Int offset = result;
  uint64_t v3 = (uint64_t)*v1;
  uint64_t v4 = (uint64_t)(*v1 + 7);
  uint64_t v5 = -1 << *((unsigned char *)*v1 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(v4 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    swift_retain(*v1);
    v8.Swift::Int offset = _HashTable.previousHole(before:)(v2).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v9 = (v8.offset + 1) & v7;
      do
      {
        uint64_t v10 = (unint64_t *)(*(void *)(v3 + 48) + 16 * v6);
        unint64_t v11 = *v10;
        unint64_t v12 = v10[1];
        uint64_t v13 = _swift_stdlib_Hashing_parameters ^ *(void *)(v3 + 40);
        v21[0] = 0;
        v21[1] = v13 ^ 0x736F6D6570736575;
        void v21[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
        v21[3] = v13 ^ 0x6C7967656E657261;
        v21[4] = unk_1EB208F00 ^ 0x7465646279746573;
        long long v22 = 0u;
        long long v23 = 0u;
        swift_bridgeObjectRetain(v12);
        String.hash(into:)(v21, v11, v12);
        swift_bridgeObjectRelease(v12);
        unint64_t v14 = Hasher._finalize()() & v7;
        if (v2.offset >= (uint64_t)v9)
        {
          if (v14 < v9) {
            goto LABEL_5;
          }
        }
        else if (v14 >= v9)
        {
          goto LABEL_11;
        }
        if (v2.offset >= (uint64_t)v14)
        {
LABEL_11:
          uint64_t v15 = *(void *)(v3 + 48);
          uint64_t v16 = (_OWORD *)(v15 + 16 * v2.offset);
          uint64_t v17 = (_OWORD *)(v15 + 16 * v6);
          if (v2.offset != v6 || (v2.Swift::Int offset = v6, v16 >= v17 + 1))
          {
            *uint64_t v16 = *v17;
            v2.Swift::Int offset = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    *(void *)(v4 + (((unint64_t)v2.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << SLOBYTE(v2.offset)) - 1;
    uint64_t result = swift_release(v3);
  }
  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << result) - 1;
  }
  uint64_t v18 = *(void *)(v3 + 16);
  BOOL v19 = __OFSUB__(v18, 1);
  uint64_t v20 = v18 - 1;
  if (v19)
  {
    __break(1u);
  }
  else
  {
    *(void *)(v3 + 16) = v20;
    ++*(_DWORD *)(v3 + 36);
  }
  return result;
}

{
  atomic_ullong **v1;
  Swift::_HashTable::Bucket v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  Swift::_HashTable::Bucket v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  _OWORD *v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  unint64_t v21[5];
  long long v22;
  long long v23;

  v2.Swift::Int offset = result;
  uint64_t v3 = (uint64_t)*v1;
  uint64_t v4 = (uint64_t)(*v1 + 7);
  uint64_t v5 = -1 << *((unsigned char *)*v1 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(v4 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    swift_retain(*v1);
    v8.Swift::Int offset = _HashTable.previousHole(before:)(v2).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v9 = (v8.offset + 1) & v7;
      do
      {
        uint64_t v10 = (unint64_t *)(*(void *)(v3 + 48) + 16 * v6);
        unint64_t v11 = *v10;
        unint64_t v12 = v10[1];
        uint64_t v13 = _swift_stdlib_Hashing_parameters ^ *(void *)(v3 + 40);
        v21[0] = 0;
        v21[1] = v13 ^ 0x736F6D6570736575;
        void v21[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
        v21[3] = v13 ^ 0x6C7967656E657261;
        v21[4] = unk_1EB208F00 ^ 0x7465646279746573;
        long long v22 = 0u;
        long long v23 = 0u;
        swift_bridgeObjectRetain(v12);
        String.hash(into:)(v21, v11, v12);
        swift_bridgeObjectRelease(v12);
        unint64_t v14 = Hasher._finalize()() & v7;
        if (v2.offset >= (uint64_t)v9)
        {
          if (v14 < v9) {
            goto LABEL_5;
          }
        }
        else if (v14 >= v9)
        {
          goto LABEL_11;
        }
        if (v2.offset >= (uint64_t)v14)
        {
LABEL_11:
          uint64_t v15 = *(void *)(v3 + 48);
          uint64_t v16 = (_OWORD *)(v15 + 16 * v2.offset);
          uint64_t v17 = (_OWORD *)(v15 + 16 * v6);
          if (v2.offset != v6 || (v2.Swift::Int offset = v6, v16 >= v17 + 1))
          {
            *uint64_t v16 = *v17;
            v2.Swift::Int offset = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    *(void *)(v4 + (((unint64_t)v2.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << SLOBYTE(v2.offset)) - 1;
    uint64_t result = swift_release(v3);
  }
  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << result) - 1;
  }
  uint64_t v18 = *(void *)(v3 + 16);
  BOOL v19 = __OFSUB__(v18, 1);
  uint64_t v20 = v18 - 1;
  if (v19)
  {
    __break(1u);
  }
  else
  {
    *(void *)(v3 + 16) = v20;
    ++*(_DWORD *)(v3 + 36);
  }
  return result;
}

{
  atomic_ullong **v1;
  Swift::_HashTable::Bucket v2;
  atomic_ullong *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  Swift::_HashTable::Bucket v8;
  unint64_t v9;
  long long v10;
  long long v11;
  atomic_ullong v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  Swift::Int v18;
  atomic_ullong v21;
  unint64_t v22;
  unint64_t v23;
  atomic_ullong *v24;
  atomic_ullong v25;
  BOOL v26;
  atomic_ullong v27;
  atomic_ullong **v28;
  uint64_t v29[3];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32[3];
  uint64_t v33;
  uint64_t v34;

  v2.Swift::Int offset = result;
  uint64_t v3 = *v1;
  uint64_t v4 = (uint64_t)(*v1 + 7);
  uint64_t v5 = -1 << *((unsigned char *)*v1 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(v4 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v28 = v1;
    uint64_t v7 = ~v5;
    swift_retain(v3);
    v8.Swift::Int offset = _HashTable.previousHole(before:)(v2).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v9 = (v8.offset + 1) & v7;
      do
      {
        outlined init with copy of AnyHashable(v3[6] + 40 * v6, (uint64_t)v32);
        unint64_t v12 = v3[5];
        uint64_t v13 = v33;
        unint64_t v14 = v34;
        __swift_project_boxed_opaque_existential_0Tm(v32, v33);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 8))(v29, v13, v14);
        uint64_t v15 = v30;
        uint64_t v16 = v31;
        __swift_project_boxed_opaque_existential_0Tm(v29, v30);
        uint64_t v17 = (*(uint64_t (**)(atomic_ullong, uint64_t, uint64_t))(v16 + 40))(v12, v15, v16);
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        outlined destroy of AnyHashable(v32);
        uint64_t v18 = v17 & v7;
        if (v2.offset >= (uint64_t)v9)
        {
          if (v18 >= v9 && v2.offset >= v18)
          {
LABEL_16:
            uint64_t v21 = v3[6];
            long long v22 = v21 + 40 * v2.offset;
            long long v23 = v21 + 40 * v6;
            if (v2.offset != v6 || (v2.Swift::Int offset = v6, v22 >= v23 + 40))
            {
              uint64_t v10 = *(_OWORD *)v23;
              unint64_t v11 = *(_OWORD *)(v23 + 16);
              *(void *)(v22 + 32) = *(void *)(v23 + 32);
              *(_OWORD *)long long v22 = v10;
              *(_OWORD *)(v22 + 16) = v11;
              v2.Swift::Int offset = v6;
            }
          }
        }
        else if (v18 >= v9 || v2.offset >= v18)
        {
          goto LABEL_16;
        }
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    *(void *)(v4 + (((unint64_t)v2.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << SLOBYTE(v2.offset)) - 1;
    uint64_t result = swift_release((uint64_t)v3);
    uint64_t v1 = v28;
  }
  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << result) - 1;
  }
  char v24 = *v1;
  uint64_t v25 = (*v1)[2];
  id v26 = __OFSUB__(v25, 1);
  int64_t v27 = v25 - 1;
  if (v26)
  {
    __break(1u);
  }
  else
  {
    _OWORD v24[2] = v27;
    ++*((_DWORD *)v24 + 9);
  }
  return result;
}

{
  atomic_ullong **v1;
  Swift::_HashTable::Bucket v2;
  atomic_ullong *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  Swift::_HashTable::Bucket v8;
  unint64_t v9;
  long long v10;
  long long v11;
  atomic_ullong v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  Swift::Int v18;
  atomic_ullong v21;
  unint64_t v22;
  unint64_t v23;
  atomic_ullong *v24;
  atomic_ullong v25;
  BOOL v26;
  atomic_ullong v27;
  atomic_ullong **v28;
  uint64_t v29[3];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32[3];
  uint64_t v33;
  uint64_t v34;

  v2.Swift::Int offset = result;
  uint64_t v3 = *v1;
  uint64_t v4 = (uint64_t)(*v1 + 7);
  uint64_t v5 = -1 << *((unsigned char *)*v1 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(v4 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v28 = v1;
    uint64_t v7 = ~v5;
    swift_retain(v3);
    v8.Swift::Int offset = _HashTable.previousHole(before:)(v2).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v9 = (v8.offset + 1) & v7;
      do
      {
        outlined init with copy of AnyHashable(v3[6] + 40 * v6, (uint64_t)v32);
        unint64_t v12 = v3[5];
        uint64_t v13 = v33;
        unint64_t v14 = v34;
        __swift_project_boxed_opaque_existential_0Tm(v32, v33);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 8))(v29, v13, v14);
        uint64_t v15 = v30;
        uint64_t v16 = v31;
        __swift_project_boxed_opaque_existential_0Tm(v29, v30);
        uint64_t v17 = (*(uint64_t (**)(atomic_ullong, uint64_t, uint64_t))(v16 + 40))(v12, v15, v16);
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        outlined destroy of AnyHashable(v32);
        uint64_t v18 = v17 & v7;
        if (v2.offset >= (uint64_t)v9)
        {
          if (v18 >= v9 && v2.offset >= v18)
          {
LABEL_16:
            uint64_t v21 = v3[6];
            long long v22 = v21 + 40 * v2.offset;
            long long v23 = v21 + 40 * v6;
            if (v2.offset != v6 || (v2.Swift::Int offset = v6, v22 >= v23 + 40))
            {
              uint64_t v10 = *(_OWORD *)v23;
              unint64_t v11 = *(_OWORD *)(v23 + 16);
              *(void *)(v22 + 32) = *(void *)(v23 + 32);
              *(_OWORD *)long long v22 = v10;
              *(_OWORD *)(v22 + 16) = v11;
              v2.Swift::Int offset = v6;
            }
          }
        }
        else if (v18 >= v9 || v2.offset >= v18)
        {
          goto LABEL_16;
        }
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    *(void *)(v4 + (((unint64_t)v2.offset >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << SLOBYTE(v2.offset)) - 1;
    uint64_t result = swift_release((uint64_t)v3);
    uint64_t v1 = v28;
  }
  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << result) - 1;
  }
  char v24 = *v1;
  uint64_t v25 = (*v1)[2];
  id v26 = __OFSUB__(v25, 1);
  int64_t v27 = v25 - 1;
  if (v26)
  {
    __break(1u);
  }
  else
  {
    _OWORD v24[2] = v27;
    ++*((_DWORD *)v24 + 9);
  }
  return result;
}

Swift::Void __swiftcall _NativeSet._delete(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v3 = v1;
  Swift::Int offset = at.offset;
  uint64_t v5 = *(unint64_t **)(v1 + 16);
  uint64_t v44 = *(v5 - 1);
  uint64_t v6 = MEMORY[0x1F4188790](at.offset);
  Swift::_HashTable::Bucket v8 = (char *)&v36 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v9 = *v2;
  uint64_t v10 = (uint64_t)(*v2 + 7);
  uint64_t v11 = -1 << *((unsigned char *)*v2 + 32);
  unint64_t v12 = (v6 + 1) & ~v11;
  if (((1 << v12) & *(void *)(v10 + 8 * (v12 >> 6))) != 0)
  {
    char v37 = v2;
    uint64_t v13 = ~v11;
    swift_retain(v9);
    uint64_t v36 = v13;
    v14.Swift::Int offset = _HashTable.previousHole(before:)((Swift::_HashTable::Bucket)offset).offset;
    uint64_t v15 = (uint64_t)v9;
    if ((*(void *)(v10 + 8 * (v12 >> 6)) & (1 << v12)) != 0)
    {
      uint64_t v16 = v36;
      unint64_t v43 = (v14.offset + 1) & v36;
      uint64_t v42 = *(void *)(v3 + 24);
      uint64_t v40 = *(uint64_t (**)(void, unint64_t *, uint64_t))(v42 + 32);
      uint64_t v41 = v42 + 32;
      uint64_t v17 = *(void (**)(char *, unint64_t, unint64_t *))(v44 + 16);
      uint64_t v18 = *(void *)(v44 + 72);
      v44 += 16;
      uint64_t v45 = v18;
      int64_t v38 = (void (**)(char *, unint64_t *))(v44 - 8);
      uint64_t v39 = v17;
      do
      {
        uint64_t v19 = v10;
        int64_t v20 = v45 * v12;
        uint64_t v21 = v16;
        v39(v8, *(void *)(v15 + 48) + v45 * v12, v5);
        uint64_t v22 = v40(*(void *)(v15 + 40), v5, v42);
        (*v38)(v8, v5);
        uint64_t v16 = v21;
        Swift::Int v23 = v22 & v21;
        if (offset >= (uint64_t)v43)
        {
          if (v23 < v43 || offset < v23)
          {
LABEL_4:
            uint64_t v10 = v19;
            goto LABEL_5;
          }
        }
        else if (v23 < v43 && offset < v23)
        {
          goto LABEL_4;
        }
        uint64_t v26 = *(void *)(v15 + 48);
        Swift::Int v27 = v45 * offset;
        uint64_t v28 = (char *)(v26 + v45 * offset);
        unint64_t v29 = (char *)(v26 + v20);
        unint64_t v30 = v26 + v20 + v45;
        BOOL v31 = v45 * offset < v20 || (unint64_t)v28 >= v30;
        uint64_t v10 = v19;
        if (v31)
        {
          swift_arrayInitWithTakeFrontToBack(v28, v29, 1, v5);
LABEL_24:
          uint64_t v16 = v21;
          Swift::Int offset = v12;
          goto LABEL_5;
        }
        Swift::Int offset = v12;
        if (v27 != v20)
        {
          swift_arrayInitWithTakeBackToFront(v28, v29, 1, (uint64_t)v5);
          goto LABEL_24;
        }
LABEL_5:
        unint64_t v12 = (v12 + 1) & v16;
      }
      while (((*(void *)(v10 + ((v12 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v12) & 1) != 0);
    }
    *(void *)(v10 + (((unint64_t)offset >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << offset) - 1;
    swift_release(v15);
    Swift::_HashTable::Bucket v2 = v37;
  }
  else
  {
    *(void *)(v10 + (((unint64_t)offset >> 3) & 0x1FFFFFFFFFFFFFF8)) &= (-1 << offset) - 1;
  }
  id v32 = *v2;
  atomic_ullong v33 = (*v2)[2];
  BOOL v34 = __OFSUB__(v33, 1);
  atomic_ullong v35 = v33 - 1;
  if (v34)
  {
    __break(1u);
  }
  else
  {
    void v32[2] = v35;
    ++*((_DWORD *)v32 + 9);
  }
}

void _NativeSet.uncheckedRemove(at:isUnique:)(Swift::_HashTable::Bucket a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if ((a2 & 1) == 0) {
    _NativeSet.copy()();
  }
  (*(void (**)(uint64_t, Swift::Int))(*(void *)(*(void *)(a3 + 16) - 8) + 32))(a4, *(void *)(*(void *)v4 + 48) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 72) * a1.offset);

  _NativeSet._delete(at:)(a1);
}

Swift::Void __swiftcall _NativeSet.removeAll(isUnique:)(Swift::Bool isUnique)
{
  uint64_t v4 = v3;
  uint64_t v5 = v1;
  uint64_t v6 = *v3;
  char v7 = *(unsigned char *)(*v3 + 32);
  if (!isUnique)
  {
    type metadata accessor for _SetStorage(0, *(void *)(v1 + 16), *(void *)(v1 + 24), v2);
    uint64_t v19 = static _SetStorage.allocate(scale:age:seed:)(v7, 0x100000000, 0, 1);
    swift_release(v6);
    *uint64_t v4 = v19;
    return;
  }
  uint64_t v8 = 1 << v7;
  unint64_t v9 = (void *)(v6 + 56);
  uint64_t v10 = -1;
  if (v8 < 64) {
    uint64_t v10 = ~(-1 << v8);
  }
  unint64_t v11 = v10 & *(void *)(v6 + 56);
  int64_t v12 = (unint64_t)(v8 + 63) >> 6;
  swift_retain((atomic_ullong *)v6);
  int64_t v13 = 0;
  while (1)
  {
    if (v11)
    {
      unint64_t v14 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v15 = v14 | (v13 << 6);
      goto LABEL_6;
    }
    if (__OFADD__(v13++, 1)) {
      goto LABEL_24;
    }
    if (v13 >= v12) {
      break;
    }
    unint64_t v17 = v9[v13];
    if (!v17)
    {
      int64_t v18 = v13 + 1;
      if (v13 + 1 >= v12) {
        break;
      }
      unint64_t v17 = v9[v18];
      if (!v17)
      {
        while (1)
        {
          int64_t v13 = v18 + 1;
          if (__OFADD__(v18, 1)) {
            break;
          }
          if (v13 >= v12) {
            goto LABEL_19;
          }
          unint64_t v17 = v9[v13];
          ++v18;
          if (v17) {
            goto LABEL_17;
          }
        }
        __break(1u);
LABEL_24:
        __break(1u);
        return;
      }
      ++v13;
    }
LABEL_17:
    unint64_t v11 = (v17 - 1) & v17;
    unint64_t v15 = __clz(__rbit64(v17)) + (v13 << 6);
LABEL_6:
    swift_arrayDestroy(*(void *)(v6 + 48) + *(void *)(*(void *)(*(void *)(v5 + 16) - 8) + 72) * v15, 1, *(unint64_t **)(v5 + 16));
  }
LABEL_19:
  swift_release(v6);
  uint64_t v20 = 1 << *(unsigned char *)(v6 + 32);
  if (v20 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, (unint64_t)(v20 + 63) >> 6, (int64x2_t *)(v6 + 56));
  }
  else {
    void *v9 = -1 << v20;
  }
  *(void *)(v6 + 16) = 0;
  ++*(_DWORD *)(v6 + 36);
}

void *specialized static _SetStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v8 = a1;
  uint64_t v9 = 1 << a1;
  unint64_t v10 = (unint64_t)((1 << a1) + 63) >> 6;
  unint64_t v11 = (unint64_t *)canonical specialized generic type metadata accessor for _SetStorage<AnyHashable>();
  int64_t v12 = swift_allocObject(v11, ((8 * v10 + 63) & 0x3FFFFFFFFFFFFFF8) + (40 << v8), 7uLL);
  v12[2] = 0;
  double v13 = (double)v9 * 0.75;
  if ((~*(void *)&v13 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v13 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v13 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  unint64_t v14 = v12;
  unint64_t v15 = (int64x2_t *)(v12 + 7);
  uint64_t v16 = (uint64_t)&v12[v10 + 7];
  v12[3] = (uint64_t)v13;
  *((unsigned char *)v12 + 32) = a1;
  *((unsigned char *)v12 + 33) = 0;
  *((_WORD *)v12 + 17) = 0;
  if ((a2 & 0x100000000) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v12);
  }
  *((_DWORD *)v14 + 9) = a2;
  if ((_BYTE)qword_1EB208F08) {
    unint64_t v17 = (void *)v8;
  }
  else {
    unint64_t v17 = v14;
  }
  if ((a4 & 1) == 0) {
    unint64_t v17 = a3;
  }
  Swift::UnsafeRawPointer_optional v14[5] = v17;
  v14[6] = v16;
  if (v9 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v10, v15);
  }
  else {
    v15->i64[0] = -1 << v9;
  }
  return v14;
}

{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  void *v12;
  double v13;
  void *v14;
  int64x2_t *v15;
  uint64_t v16;
  void *v17;

  uint64_t v8 = a1;
  uint64_t v9 = 1 << a1;
  unint64_t v10 = (unint64_t)((1 << a1) + 63) >> 6;
  unint64_t v11 = (unint64_t *)canonical specialized generic type metadata accessor for _SetStorage<String>();
  int64_t v12 = swift_allocObject(v11, ((8 * v10 + 63) & 0x3FFFFFFFFFFFFFF8) + (16 << v8), 7uLL);
  v12[2] = 0;
  double v13 = (double)v9 * 0.75;
  if ((~*(void *)&v13 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v13 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v13 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  unint64_t v14 = v12;
  unint64_t v15 = (int64x2_t *)(v12 + 7);
  uint64_t v16 = (uint64_t)&v12[v10 + 7];
  v12[3] = (uint64_t)v13;
  *((unsigned char *)v12 + 32) = a1;
  *((unsigned char *)v12 + 33) = 0;
  *((_WORD *)v12 + 17) = 0;
  if ((a2 & 0x100000000) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v12);
  }
  *((_DWORD *)v14 + 9) = a2;
  if ((_BYTE)qword_1EB208F08) {
    unint64_t v17 = (void *)v8;
  }
  else {
    unint64_t v17 = v14;
  }
  if ((a4 & 1) == 0) {
    unint64_t v17 = a3;
  }
  Swift::UnsafeRawPointer_optional v14[5] = v17;
  v14[6] = v16;
  if (v9 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v10, v15);
  }
  else {
    v15->i64[0] = -1 << v9;
  }
  return v14;
}

void *specialized static _SetStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, void *a3, char a4, uint64_t (*a5)(void))
{
  uint64_t v9 = a1;
  uint64_t v10 = 1 << a1;
  unint64_t v11 = (unint64_t)((1 << a1) + 63) >> 6;
  int64_t v12 = (unint64_t *)a5(0);
  double v13 = swift_allocObject(v12, ((8 * v11 + 63) & 0x3FFFFFFFFFFFFFF8) + (8 << v9), 7uLL);
  v13[2] = 0;
  double v14 = (double)v10 * 0.75;
  if ((~*(void *)&v14 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v14 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v14 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  unint64_t v15 = v13;
  uint64_t v16 = (int64x2_t *)(v13 + 7);
  uint64_t v17 = (uint64_t)&v13[v11 + 7];
  v13[3] = (uint64_t)v14;
  *((unsigned char *)v13 + 32) = a1;
  *((unsigned char *)v13 + 33) = 0;
  *((_WORD *)v13 + 17) = 0;
  if ((a2 & 0x100000000) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v13);
  }
  *((_DWORD *)v15 + 9) = a2;
  if ((_BYTE)qword_1EB208F08) {
    int64_t v18 = (void *)v9;
  }
  else {
    int64_t v18 = v15;
  }
  if ((a4 & 1) == 0) {
    int64_t v18 = a3;
  }
  v15[5] = v18;
  void v15[6] = v17;
  if (v10 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v11, v16);
  }
  else {
    v16->i64[0] = -1 << v10;
  }
  return v15;
}

void *static _SetStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = a1;
  uint64_t v11 = 1 << a1;
  unint64_t v12 = (unint64_t)((1 << a1) + 63) >> 6;
  uint64_t v13 = *(void *)(v4[21] - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = v14 + 8 * v12;
  uint64_t v16 = swift_allocObject(v5, ((v15 + 56) & ~v14) + (*(void *)(v13 + 72) << a1), v14 | 7);
  void v16[2] = 0;
  double v17 = (double)v11 * 0.75;
  if ((~*(void *)&v17 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v17 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v17 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  int64_t v18 = v16;
  unint64_t v24 = v12;
  uint64_t v19 = a3;
  uint64_t v20 = (int64x2_t *)(v16 + 7);
  v16[3] = (uint64_t)v17;
  uint64_t v21 = ((unint64_t)v16 + v15 + 56) & ~v14;
  *((unsigned char *)v16 + 32) = a1;
  *((unsigned char *)v16 + 33) = 0;
  *((_WORD *)v16 + 17) = 0;
  if ((a2 & 0x100000000) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v16);
  }
  *((_DWORD *)v18 + 9) = a2;
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v22 = (void *)v10;
  }
  else {
    uint64_t v22 = v18;
  }
  if ((a4 & 1) == 0) {
    uint64_t v22 = v19;
  }
  v18[5] = v22;
  v18[6] = v21;
  if (v11 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v24, v20);
  }
  else {
    v20->i64[0] = -1 << v11;
  }
  return v18;
}

atomic_ullong *_NativeSet.Iterator.base.getter()
{
  return swift_retain(*v0);
}

uint64_t _NativeSet.Iterator.iterator.getter()
{
  return *(void *)(v0 + 8);
}

uint64_t _NativeSet.Iterator.iterator.setter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[1] = result;
  v4[2] = a2;
  v4[3] = a3;
  v4[4] = a4;
  return result;
}

uint64_t (*_NativeSet.Iterator.iterator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _NativeSet.Iterator.init(_:)@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1;
  uint64_t v3 = -1 << *(unsigned char *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = a1 + 56;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1 << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0;
  a2[4] = v2 & v5;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance _NativeSet<A>(void *a1@<X8>)
{
  uint64_t v2 = *v1;
  uint64_t v3 = -1;
  uint64_t v4 = -1 << *(unsigned char *)(*v1 + 32);
  *a1 = *v1;
  uint64_t v7 = *(void *)(v2 + 56);
  uint64_t v5 = v2 + 56;
  uint64_t v6 = v7;
  if (-v4 < 64) {
    uint64_t v3 = ~(-1 << -(char)v4);
  }
  a1[1] = v5;
  a1[2] = ~v4;
  a1[3] = 0;
  a1[4] = v3 & v6;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _NativeSet<A>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = specialized Sequence._copyToContiguousArray()(v2, a1, a2);
  swift_release(*v2);
  return v3;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _NativeSet<A>.Iterator@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (!v4)
  {
    uint64_t v12 = v2[3];
    int64_t v13 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      return result;
    }
    int64_t v14 = (unint64_t)(v2[2] + 64) >> 6;
    if (v13 < v14)
    {
      v2[3] = v13;
      uint64_t v15 = v2[1];
      unint64_t v16 = *(void *)(v15 + 8 * v13);
      v2[4] = v16;
      if (v16)
      {
LABEL_11:
        v2[4] = (v16 - 1) & v16;
        unint64_t v5 = __clz(__rbit64(v16)) + (v13 << 6);
        goto LABEL_3;
      }
      uint64_t v17 = v12 + 2;
      while (v14 != v17)
      {
        v2[3] = v17;
        unint64_t v16 = *(void *)(v15 + 8 * v17);
        v2[4] = v16;
        ++v17;
        if (v16)
        {
          int64_t v13 = v17 - 1;
          goto LABEL_11;
        }
      }
    }
    uint64_t v11 = *(void *)(result + 16);
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56);
    uint64_t v9 = a2;
    uint64_t v10 = 1;
    goto LABEL_13;
  }
  v2[4] = (v4 - 1) & v4;
  unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
  uint64_t v6 = *(void *)(*v2 + 48);
  uint64_t v7 = *(void *)(result + 16);
  uint64_t v18 = *(void *)(v7 - 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v18 + 16))(a2, v6 + *(void *)(v18 + 72) * v5, v7);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 56);
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = v7;
LABEL_13:

  return v8(v9, v10, 1, v11);
}

uint64_t closure #1 in _NativeSet.isSubset<A>(of:)@<X0>(uint64_t a1@<X0>, void *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, char *a8@<X8>)
{
  uint64_t v11 = a4;
  uint64_t v72 = a3;
  unint64_t v76 = (unint64_t)a2;
  uint64_t v53 = a1;
  unint64_t v51 = a8;
  unint64_t v55 = *(void **)(a4 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v69 = (char *)&v50 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v50 - v14;
  uint64_t v19 = type metadata accessor for Optional(0, v18, v16, v17);
  uint64_t v20 = MEMORY[0x1F4188790](v19 - 1);
  int64_t v56 = (char *)&v50 - v21;
  uint64_t v22 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](v20);
  unint64_t v24 = (char *)&v50 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a7, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v50 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  Swift::Int v27 = (char *)&v50 - v26;
  (*(void (**)(char *, unint64_t, uint64_t))(v22 + 16))(v24, v76, a5);
  uint64_t v28 = v56;
  (*(void (**)(uint64_t, uint64_t))(a7 + 32))(a5, a7);
  uint64_t v29 = a5;
  unint64_t v30 = v55;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, v29, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  id v32 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v66 = v27;
  char v67 = AssociatedTypeWitness;
  uint64_t v64 = AssociatedConformanceWitness + 16;
  uint64_t v65 = AssociatedConformanceWitness;
  unint64_t v63 = v32;
  ((void (*)(const char *))v32)(AssociatedTypeWitness);
  uint64_t v61 = (uint64_t (*)(char *, uint64_t, uint64_t))v30[6];
  uint64_t v62 = v30 + 6;
  if (v61(v28, 1, v11) != 1)
  {
    uint64_t v52 = 0;
    atomic_ullong v33 = (void (*)(char *, char *, uint64_t))v30[4];
    uint64_t v58 = a6 + 32;
    uint64_t v59 = v33;
    uint64_t v34 = v72;
    uint64_t v75 = v72 + 56;
    uint64_t v68 = v30 + 2;
    uint64_t v60 = v30 + 4;
    unint64_t v76 = (unint64_t)(v30 + 1);
    uint64_t v54 = a6;
    int64_t v73 = v15;
    uint64_t v74 = v11;
    v33(v15, v28, v11);
    while (1)
    {
      uint64_t v36 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(v34 + 40), v11, a6);
      uint64_t v37 = -1 << *(unsigned char *)(v34 + 32);
      unint64_t v38 = v36 & ~v37;
      if ((*(void *)(v75 + ((v38 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v38))
      {
        uint64_t v57 = v76 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        uint64_t v70 = ~v37;
        uint64_t v72 = *(void *)(a6 + 8);
        unint64_t v71 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v72 + 8);
        uint64_t v39 = v30[9];
        uint64_t v40 = (void (*)(char *, unint64_t, uint64_t))v30[2];
        while (1)
        {
          uint64_t v41 = v34;
          uint64_t v42 = v69;
          uint64_t v43 = v74;
          v40(v69, *(void *)(v34 + 48) + v39 * v38, v74);
          char v44 = v71(v42, v73, v43, v72);
          atomic_ullong v35 = *(uint64_t (**)(char *, uint64_t))v76;
          (*(void (**)(char *, uint64_t))v76)(v42, v43);
          if (v44) {
            break;
          }
          unint64_t v38 = (v38 + 1) & v70;
          uint64_t v34 = v41;
          if (((*(void *)(v75 + ((v38 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v38) & 1) == 0)
          {
            a6 = v54;
            uint64_t v15 = v73;
            uint64_t v11 = v74;
            unint64_t v30 = v55;
            uint64_t v28 = v56;
            goto LABEL_4;
          }
        }
        uint64_t v15 = v73;
        uint64_t v11 = v74;
        uint64_t result = v35(v73, v74);
        uint64_t v46 = (v38 >> 3) & 0x1FFFFFFFFFFFFFF8;
        uint64_t v47 = *(void *)(v53 + v46);
        *(void *)(v53 + v46) = v47 | (1 << v38);
        if ((v47 & (1 << v38)) != 0)
        {
          a6 = v54;
          uint64_t v34 = v41;
          uint64_t v28 = v56;
        }
        else
        {
          a6 = v54;
          uint64_t v28 = v56;
          if (__OFADD__(v52, 1))
          {
            __break(1u);
            return result;
          }
          uint64_t v34 = v41;
          if (v52 + 1 == *(void *)(v41 + 16))
          {
            char v49 = 1;
            goto LABEL_18;
          }
          ++v52;
        }
        v63(v67, v65);
        int v48 = v61(v28, 1, v11);
        unint64_t v30 = v55;
        if (v48 == 1) {
          break;
        }
      }
      else
      {
        atomic_ullong v35 = *(uint64_t (**)(char *, uint64_t))v76;
LABEL_4:
        v35(v15, v11);
        v63(v67, v65);
        if (v61(v28, 1, v11) == 1) {
          break;
        }
      }
      v59(v15, v28, v11);
    }
  }
  char v49 = 0;
LABEL_18:
  uint64_t result = (*(uint64_t (**)(char *, const char *))(v50 + 8))(v66, v67);
  char *v51 = v49;
  return result;
}

uint64_t _NativeSet.isSubset<A>(of:)(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(unsigned __int8 *__return_ptr, int64x2_t *, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v13 = isStackAllocationSafe;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  char v14 = *(unsigned char *)(a2 + 32);
  unint64_t v15 = (unint64_t)((1 << v14) + 63) >> 6;
  size_t v16 = 8 * v15;
  if ((v14 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1F4188790](isStackAllocationSafe);
    uint64_t v17 = (int64x2_t *)((char *)&v20 - ((v16 + 15) & 0x3FFFFFFFFFFFFFF0));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v15, v17);
    a7(&v21, v17, v15, v13, a2, a3, a4, a5, a6);
    return v21;
  }
  else
  {
    uint64_t v19 = (int64x2_t *)swift_slowAlloc(v16, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v15, v19);
    a7(&v21, v19, v15, v13, a2, a3, a4, a5, a6);
    swift_slowDealloc(v19);
    return v21;
  }
}

uint64_t closure #1 in _NativeSet.isStrictSubset<A>(of:)@<X0>(uint64_t a1@<X0>, void (**a2)(char *, void)@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, int **a7@<X7>, char *a8@<X8>)
{
  uint64_t v76 = (uint64_t)a7;
  uint64_t v11 = a4;
  unint64_t v79 = (unint64_t)a2;
  uint64_t v55 = a1;
  uint64_t v54 = a8;
  uint64_t v13 = *(void **)(a4 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](a1);
  int64_t v73 = (char *)&v52 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v80 = (char *)&v52 - v16;
  uint64_t v20 = type metadata accessor for Optional(0, v19, v17, v18);
  uint64_t v21 = MEMORY[0x1F4188790](v20 - 1);
  uint64_t v23 = (char *)&v52 - v22;
  uint64_t v77 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v52 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = a7;
  uint64_t v27 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v26, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v53 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v30 = (char *)&v52 - v29;
  BOOL v31 = *(void (**)(char *, unint64_t, uint64_t))(v77 + 16);
  uint64_t v75 = v27;
  v31(v25, v79, v27);
  uint64_t v32 = v27;
  uint64_t v33 = v76;
  (*(void (**)(uint64_t))(v76 + 32))(v32);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v33, v75, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  atomic_ullong v35 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v68 = v30;
  uint64_t v69 = AssociatedTypeWitness;
  uint64_t v66 = AssociatedConformanceWitness + 16;
  uint64_t v67 = AssociatedConformanceWitness;
  uint64_t v65 = v35;
  ((void (*)(const char *))v35)(AssociatedTypeWitness);
  unint64_t v63 = (unsigned int (*)(char *, uint64_t, uint64_t))v13[6];
  uint64_t v64 = v13 + 6;
  if (v63(v23, 1, v11) != 1)
  {
    uint64_t v56 = 0;
    int v70 = 0;
    unint64_t v38 = (void (*)(char *, char *, uint64_t))v13[4];
    uint64_t v60 = a6 + 32;
    uint64_t v61 = v38;
    uint64_t v75 = a3 + 56;
    uint64_t v72 = v13 + 2;
    uint64_t v62 = v13 + 4;
    unint64_t v79 = (unint64_t)(v13 + 1);
    uint64_t v58 = a6;
    uint64_t v78 = v11;
    uint64_t v59 = v13;
    uint64_t v57 = v23;
    v38(v80, v23, v11);
    while (1)
    {
      uint64_t v40 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a3 + 40), v11, a6);
      uint64_t v41 = -1 << *(unsigned char *)(a3 + 32);
      unint64_t v42 = v40 & ~v41;
      if ((*(void *)(v75 + ((v42 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v42))
      {
        uint64_t v71 = v79 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        uint64_t v74 = ~v41;
        uint64_t v77 = *(void *)(a6 + 8);
        uint64_t v76 = *(void *)(v77 + 8);
        uint64_t v43 = v13[9];
        char v44 = (void (*)(char *, unint64_t, uint64_t))v13[2];
        while (1)
        {
          uint64_t v45 = a3;
          uint64_t v46 = v73;
          uint64_t v47 = v78;
          v44(v73, *(void *)(a3 + 48) + v43 * v42, v78);
          char v48 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v76)(v46, v80, v47, v77);
          char v49 = *(void (**)(char *, uint64_t))v79;
          (*(void (**)(char *, uint64_t))v79)(v46, v47);
          if (v48) {
            break;
          }
          unint64_t v42 = (v42 + 1) & v74;
          a3 = v45;
          if (((*(void *)(v75 + ((v42 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v42) & 1) == 0)
          {
            a6 = v58;
            uint64_t v11 = v78;
            uint64_t v23 = v57;
            v49(v80, v78);
            goto LABEL_12;
          }
        }
        uint64_t v11 = v78;
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v49)(v80, v78);
        uint64_t v50 = (v42 >> 3) & 0x1FFFFFFFFFFFFFF8;
        uint64_t v51 = *(void *)(v55 + v50);
        *(void *)(v55 + v5_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 0) = v51 | (1 << v42);
        if ((v51 & (1 << v42)) != 0)
        {
          a6 = v58;
          a3 = v45;
        }
        else
        {
          if (__OFADD__(v56, 1))
          {
            __break(1u);
            return result;
          }
          if (((v56 + 1 == *(void *)(v45 + 16)) & v70) != 0) {
            goto LABEL_23;
          }
          a3 = v45;
          ++v56;
          a6 = v58;
        }
        uint64_t v13 = v59;
        uint64_t v23 = v57;
        v65(v69, v67);
        if (v63(v23, 1, v11) == 1) {
          break;
        }
      }
      else
      {
        (*(void (**)(char *, uint64_t))v79)(v80, v11);
LABEL_12:
        if ((v70 & 1) == 0 && v56 == *(void *)(a3 + 16))
        {
LABEL_23:
          char v36 = 1;
          goto LABEL_3;
        }
        v65(v69, v67);
        int v70 = 1;
        unsigned int v39 = v63(v23, 1, v11);
        uint64_t v13 = v59;
        if (v39 == 1) {
          break;
        }
      }
      v61(v80, v23, v11);
    }
  }
  char v36 = 0;
LABEL_3:
  uint64_t result = (*(uint64_t (**)(char *, const char *))(v53 + 8))(v68, v69);
  *uint64_t v54 = v36;
  return result;
}

uint64_t closure #1 in _NativeSet.isStrictSuperset<A>(of:)@<X0>(uint64_t a1@<X0>, void (**a2)(char *, uint64_t)@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, char *a8@<X8>)
{
  uint64_t v69 = a8;
  uint64_t v78 = a3;
  uint64_t v80 = a2;
  uint64_t v67 = a1;
  uint64_t v11 = *(void **)(a4 - 8);
  uint64_t v72 = a6;
  int64_t v73 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  unint64_t v79 = (char *)v57 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v82 = (char *)v57 - v14;
  uint64_t v18 = type metadata accessor for Optional(0, v17, v15, v16);
  uint64_t v19 = MEMORY[0x1F4188790](v18 - 1);
  uint64_t v21 = (char *)v57 - v20;
  uint64_t v22 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)v57 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a7, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v68 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v27 = (char *)v57 - v26;
  (*(void (**)(char *, void (**)(char *, uint64_t), uint64_t))(v22 + 16))(v24, v80, a5);
  (*(void (**)(uint64_t, uint64_t))(a7 + 32))(a5, a7);
  uint64_t v28 = a7;
  uint64_t v29 = v21;
  uint64_t v30 = v78;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v28, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v32 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  int v70 = v27;
  uint64_t v71 = AssociatedTypeWitness;
  uint64_t v33 = v72;
  uint64_t v65 = AssociatedConformanceWitness + 16;
  uint64_t v66 = AssociatedConformanceWitness;
  uint64_t v64 = v32;
  ((void (*)(const char *))v32)(AssociatedTypeWitness);
  uint64_t v34 = v73 + 6;
  char v35 = 1;
  unint64_t v63 = (unsigned int (*)(char *, uint64_t, uint64_t))v73[6];
  if (v63(v21, 1, a4) == 1)
  {
LABEL_16:
    uint64_t result = (*(uint64_t (**)(char *, const char *))(v68 + 8))(v70, v71);
    *uint64_t v69 = v35;
    return result;
  }
  uint64_t v36 = a4;
  v57[0] = 0;
  uint64_t v37 = (void (*)(void, void, void))v73[4];
  uint64_t v38 = v30 + 56;
  uint64_t v75 = v73 + 2;
  unint64_t v39 = (unint64_t)(v73 + 1);
  uint64_t v81 = v36;
  uint64_t v61 = v21;
  uint64_t v60 = v34;
  uint64_t v59 = v73 + 4;
  uint64_t v58 = v37;
  v57[1] = v33 + 32;
  uint64_t v80 = (void (**)(char *, uint64_t))(v73 + 1);
  while (1)
  {
    uint64_t v40 = v36;
    v37(v82, v29, v36);
    uint64_t v41 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v33 + 32))(*(void *)(v30 + 40), v40, v33);
    uint64_t v42 = -1 << *(unsigned char *)(v30 + 32);
    uint64_t v43 = v33;
    unint64_t v44 = v41 & ~v42;
    if (((*(void *)(v38 + ((v44 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v44) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t))v39)(v82, v81);
LABEL_15:
      char v35 = 0;
      goto LABEL_16;
    }
    uint64_t v62 = v39 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
    uint64_t v74 = ~v42;
    uint64_t v78 = *(void *)(v43 + 8);
    uint64_t v45 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v78 + 8);
    uint64_t v76 = v73[9];
    uint64_t v77 = v45;
    uint64_t v46 = (void (*)(char *, unint64_t, uint64_t))v73[2];
    while (1)
    {
      uint64_t v47 = v30;
      char v48 = v79;
      uint64_t v49 = v81;
      v46(v79, *(void *)(v30 + 48) + v76 * v44, v81);
      char v50 = v77(v48, v82, v49, v78);
      uint64_t v51 = *v80;
      (*v80)(v48, v49);
      if (v50) {
        break;
      }
      unint64_t v44 = (v44 + 1) & v74;
      uint64_t v30 = v47;
      if (((*(void *)(v38 + ((v44 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v44) & 1) == 0)
      {
        v51(v82, v81);
        goto LABEL_15;
      }
    }
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v51)(v82, v81);
    uint64_t v53 = (v44 >> 3) & 0x1FFFFFFFFFFFFFF8;
    uint64_t v54 = *(void *)(v67 + v53);
    *(void *)(v67 + v53) = v54 | (1 << v44);
    if ((v54 & (1 << v44)) != 0)
    {
      uint64_t v55 = v81;
      uint64_t v33 = v72;
      uint64_t v30 = v47;
      uint64_t v29 = v61;
      goto LABEL_13;
    }
    uint64_t v33 = v72;
    uint64_t v29 = v61;
    if (__OFADD__(v57[0], 1)) {
      break;
    }
    uint64_t v30 = v47;
    uint64_t v55 = v81;
    if (v57[0] + 1 == *(void *)(v47 + 16)) {
      goto LABEL_15;
    }
    ++v57[0];
LABEL_13:
    v64(v71, v66);
    char v35 = 1;
    unsigned int v56 = v63(v29, 1, v55);
    uint64_t v37 = v58;
    uint64_t v36 = v55;
    unint64_t v39 = (unint64_t)v80;
    if (v56 == 1) {
      goto LABEL_16;
    }
  }
  __break(1u);
  return result;
}

__objc2_class **_NativeSet.extractSubset(using:count:)(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v26 = a6;
  uint64_t v11 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v25 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!v15)
  {
    swift_release(a4);
    return &_swiftEmptySetSingleton;
  }
  if (*(void *)(a4 + 16) == a3) {
    return (__objc2_class **)a4;
  }
  type metadata accessor for _SetStorage(0, a5, v26, v12);
  uint64_t result = (__objc2_class **)static _SetStorage.allocate(capacity:)(a3);
  uint64_t v16 = (uint64_t)result;
  if (a2 < 1) {
    unint64_t v18 = 0;
  }
  else {
    unint64_t v18 = *a1;
  }
  uint64_t v19 = 0;
  uint64_t v25 = v11 + 16;
  while (1)
  {
    if (v18)
    {
      unint64_t v20 = __clz(__rbit64(v18));
      v18 &= v18 - 1;
      unint64_t v21 = v20 | (v19 << 6);
      goto LABEL_21;
    }
    BOOL v22 = __OFADD__(v19++, 1);
    if (v22) {
      goto LABEL_27;
    }
    if (v19 >= a2)
    {
LABEL_23:
      swift_release(a4);
      return (__objc2_class **)v16;
    }
    unint64_t v23 = a1[v19];
    if (!v23) {
      break;
    }
LABEL_20:
    unint64_t v18 = (v23 - 1) & v23;
    unint64_t v21 = __clz(__rbit64(v23)) + (v19 << 6);
LABEL_21:
    (*(void (**)(char *, unint64_t, uint64_t))(v11 + 16))(v14, *(void *)(a4 + 48) + *(void *)(v11 + 72) * v21, a5);
    uint64_t result = (__objc2_class **)_NativeSet._unsafeInsertNew(_:)((uint64_t)v14, v16, a5, v26);
    BOOL v22 = __OFSUB__(a3--, 1);
    if (v22)
    {
      __break(1u);
      goto LABEL_26;
    }
    if (!a3) {
      goto LABEL_23;
    }
  }
  uint64_t v24 = v19 + 1;
  if (v19 + 1 >= a2) {
    goto LABEL_23;
  }
  unint64_t v23 = a1[v24];
  if (v23)
  {
    ++v19;
    goto LABEL_20;
  }
  while (1)
  {
    uint64_t v19 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v19 >= a2) {
      goto LABEL_23;
    }
    unint64_t v23 = a1[v19];
    ++v24;
    if (v23) {
      goto LABEL_20;
    }
  }
LABEL_26:
  __break(1u);
LABEL_27:
  __break(1u);
  return result;
}

__objc2_class **_NativeSet.subtracting<A>(_:)(uint64_t a1, __objc2_class **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v74 = a5;
  uint64_t v8 = a3;
  v83[1] = *(__objc2_class ***)MEMORY[0x1E4F143B8];
  uint64_t v11 = type metadata accessor for Optional(0, a3, a3, a4);
  uint64_t v71 = (uint64_t)*(v11 - 1);
  uint64_t v72 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v55 - v13;
  uint64_t v73 = *(void *)(v8 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v80 = (char *)&v55 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v82 = (char *)&v55 - v18;
  uint64_t v19 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v17);
  unint64_t v21 = (char *)&v55 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v25 = (char *)&v55 - v24;
  if (a2[2])
  {
    uint64_t v65 = v23;
    (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v21, a1, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a4, a6);
    uint64_t v58 = (int **)a6;
    uint64_t v59 = a4;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v27 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v69 = AssociatedConformanceWitness + 16;
    uint64_t v70 = AssociatedConformanceWitness;
    uint64_t v68 = v27;
    ((void (*)(const char *))v27)(AssociatedTypeWitness);
    uint64_t v28 = v73;
    uint64_t v66 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v73 + 48);
    uint64_t v67 = v73 + 48;
    int v29 = v66(v14, 1, v8);
    uint64_t v30 = v74;
    if (v29 == 1)
    {
LABEL_3:
      (*(void (**)(char *, Class *))(v71 + 8))(v14, v72);
      (*(void (**)(char *, const char *))(v65 + 8))(v25, AssociatedTypeWitness);
    }
    else
    {
      unint64_t v63 = *(void (**)(char *, char *, uint64_t))(v28 + 32);
      uint64_t v62 = v74 + 32;
      uint64_t v81 = (char *)(a2 + 7);
      uint64_t v76 = v28 + 16;
      uint64_t v64 = v28 + 32;
      unint64_t v79 = (void (**)(char *, uint64_t))(v28 + 8);
      uint64_t v60 = (v28 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      uint64_t v77 = v8;
      uint64_t v78 = a2;
      uint64_t v57 = AssociatedTypeWitness;
      uint64_t v61 = v25;
      unsigned int v56 = v14;
      while (1)
      {
        v63(v82, v14, v8);
        uint64_t v31 = (*(uint64_t (**)(__objc2_class *, uint64_t, uint64_t))(v30 + 32))(a2[5], v8, v30);
        uint64_t v32 = -1 << *((unsigned char *)a2 + 32);
        unint64_t v33 = v31 & ~v32;
        if ((*(void *)&v81[(v33 >> 3) & 0xFFFFFFFFFFFFFF8] >> v33)) {
          break;
        }
        uint64_t v42 = *v79;
LABEL_12:
        v42(v82, v8);
        v68(AssociatedTypeWitness, v70);
        if (v66(v14, 1, v8) == 1) {
          goto LABEL_3;
        }
      }
      uint64_t v75 = ~v32;
      uint64_t v34 = *(void *)(v30 + 8);
      char v35 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 8);
      uint64_t v36 = v28;
      uint64_t v37 = *(void *)(v28 + 72);
      uint64_t v38 = *(void (**)(char *, char *, uint64_t))(v36 + 16);
      while (1)
      {
        uint64_t v39 = v77;
        uint64_t v40 = v80;
        v38(v80, (char *)v78[6] + v37 * v33, v77);
        char v41 = v35(v40, v82, v39, v34);
        uint64_t v42 = *v79;
        (*v79)(v40, v39);
        if (v41) {
          break;
        }
        unint64_t v33 = (v33 + 1) & v75;
        if (((*(void *)&v81[(v33 >> 3) & 0xFFFFFFFFFFFFFF8] >> v33) & 1) == 0)
        {
          uint64_t v8 = v77;
          a2 = v78;
          uint64_t v28 = v73;
          uint64_t v30 = v74;
          uint64_t AssociatedTypeWitness = v57;
          uint64_t v25 = v61;
          uint64_t v14 = v56;
          goto LABEL_12;
        }
      }
      uint64_t v43 = v77;
      uint64_t isStackAllocationSafe = ((uint64_t (*)(char *, uint64_t))v42)(v82, v77);
      uint64_t v45 = (uint64_t)v78;
      char v46 = *((unsigned char *)v78 + 32);
      unint64_t v47 = (unint64_t)((1 << v46) + 63) >> 6;
      size_t v48 = 8 * v47;
      if ((v46 & 0x3Fu) < 0xE
        || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), isStackAllocationSafe))
      {
        MEMORY[0x1F4188790](isStackAllocationSafe);
        uint64_t v49 = (char *)&v55 - ((v48 + 15) & 0x3FFFFFFFFFFFFFF0);
        specialized UnsafeMutablePointer.initialize(from:count:)(v81, v47, v49);
        closure #1 in _NativeSet.subtracting<A>(_:)((unint64_t *)v49, v47, v45, v33, (uint64_t)v61, v43, v59, v74, v83, v58);
        swift_release(v45);
        char v50 = v57;
        uint64_t v51 = v65;
        a2 = v83[0];
        uint64_t v52 = (uint64_t)v61;
      }
      else
      {
        uint64_t v53 = (char *)swift_slowAlloc(v48, 0xFFFFFFFFFFFFFFFFLL);
        specialized UnsafeMutablePointer.initialize(from:count:)(v81, v47, v53);
        uint64_t v52 = (uint64_t)v61;
        closure #1 in _NativeSet.subtracting<A>(_:)((unint64_t *)v53, v47, v45, v33, (uint64_t)v61, v43, v59, v74, v83, v58);
        swift_release(v45);
        char v50 = v57;
        uint64_t v51 = v65;
        swift_slowDealloc(v53);
        a2 = v83[0];
      }
      (*(void (**)(uint64_t, const char *))(v51 + 8))(v52, v50);
    }
  }
  else
  {
    swift_release((uint64_t)a2);
    return &_swiftEmptySetSingleton;
  }
  return a2;
}

__objc2_class **closure #1 in _NativeSet.subtracting<A>(_:)@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, __objc2_class ***a9@<X8>, int **a10)
{
  uint64_t v12 = a6;
  uint64_t v68 = a5;
  uint64_t v14 = a3;
  uint64_t v51 = a2;
  uint64_t v52 = a9;
  char v50 = type metadata accessor for Optional(0, a6, a3, a4);
  uint64_t v49 = (uint64_t)*(v50 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v50);
  uint64_t v18 = (char *)&v49 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v70 = (char *)&v49 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v77 = (char *)&v49 - v21;
  uint64_t v22 = *(void *)(v14 + 16);
  uint64_t v23 = (a4 >> 3) & 0x1FFFFFFFFFFFFFF8;
  uint64_t v24 = -1 << a4;
  uint64_t v26 = v25;
  uint64_t v27 = *(unint64_t *)((char *)a1 + v23) & (v24 - 1);
  uint64_t v53 = a1;
  *(unint64_t *)((char *)a1 + v23) = v27;
  uint64_t v54 = v22 - 1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a10, a7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a10, a7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = *(void (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v66 = AssociatedTypeWitness;
  uint64_t v67 = v30;
  uint64_t v31 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v64 = AssociatedConformanceWitness + 16;
  uint64_t v65 = AssociatedConformanceWitness;
  v67(v31, AssociatedConformanceWitness);
  uint64_t v62 = (unsigned int (*)(char *, uint64_t, uint64_t))v26[6];
  unint64_t v63 = v26 + 6;
  if (v62(v18, 1, v12) != 1)
  {
    unint64_t v33 = (void (*)(char *, char *, uint64_t))v26[4];
    uint64_t v59 = a8 + 32;
    uint64_t v60 = v33;
    uint64_t v75 = v12;
    uint64_t v76 = v14 + 56;
    uint64_t v69 = v26 + 2;
    uint64_t v61 = v26 + 4;
    unint64_t v34 = (unint64_t)(v26 + 1);
    unsigned int v56 = v18;
    uint64_t v57 = a8;
    uint64_t v55 = v26;
    uint64_t v74 = (uint64_t (**)(char *, uint64_t))(v26 + 1);
    v33(v77, v18, v12);
    while (1)
    {
      uint64_t v37 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a8 + 32))(*(void *)(v14 + 40), v12, a8);
      uint64_t v38 = -1 << *(unsigned char *)(v14 + 32);
      unint64_t v39 = v37 & ~v38;
      if ((*(void *)(v76 + ((v39 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v39))
      {
        uint64_t v58 = v34 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        uint64_t v71 = ~v38;
        uint64_t v73 = *(void *)(a8 + 8);
        uint64_t v72 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v73 + 8);
        uint64_t v40 = v26[9];
        char v41 = (void (*)(char *, unint64_t, uint64_t))v26[2];
        while (1)
        {
          uint64_t v42 = v14;
          uint64_t v43 = v70;
          uint64_t v44 = v75;
          v41(v70, *(void *)(v14 + 48) + v40 * v39, v75);
          char v45 = v72(v43, v77, v44, v73);
          char v35 = *v74;
          (*v74)(v43, v44);
          if (v45) {
            break;
          }
          unint64_t v39 = (v39 + 1) & v71;
          uint64_t v14 = v42;
          if (((*(void *)(v76 + ((v39 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v39) & 1) == 0)
          {
            uint64_t v18 = v56;
            a8 = v57;
            unint64_t v34 = (unint64_t)v74;
            uint64_t v12 = v75;
            uint64_t v26 = v55;
            goto LABEL_6;
          }
        }
        unint64_t v34 = (unint64_t)v74;
        uint64_t v12 = v75;
        uint64_t result = (__objc2_class **)v35(v77, v75);
        uint64_t v46 = (v39 >> 3) & 0x1FFFFFFFFFFFFFF8;
        uint64_t v47 = *(unint64_t *)((char *)v53 + v46);
        *(unint64_t *)((char *)v53 + v46) = v47 & ~(1 << v39);
        if ((v47 & (1 << v39)) != 0)
        {
          uint64_t v48 = v54 - 1;
          uint64_t v18 = v56;
          a8 = v57;
          if (__OFSUB__(v54, 1))
          {
            __break(1u);
            return result;
          }
          uint64_t v14 = v42;
          uint64_t v26 = v55;
          --v54;
          if (!v48)
          {
            uint64_t result = &_swiftEmptySetSingleton;
            goto LABEL_3;
          }
        }
        else
        {
          uint64_t v18 = v56;
          a8 = v57;
          uint64_t v14 = v42;
          uint64_t v26 = v55;
        }
      }
      else
      {
        char v35 = *(uint64_t (**)(char *, uint64_t))v34;
LABEL_6:
        v35(v77, v12);
      }
      uint64_t v36 = swift_checkMetadataState(0, (uint64_t)v66);
      v67(v36, v65);
      if (v62(v18, 1, v12) == 1) {
        break;
      }
      v60(v77, v18, v12);
    }
  }
  (*(void (**)(char *, Class *))(v49 + 8))(v18, v50);
  swift_retain((atomic_ullong *)v14);
  uint64_t result = _NativeSet.extractSubset(using:count:)(v53, v51, v54, v14, v12, a8);
LABEL_3:
  *uint64_t v52 = result;
  return result;
}

void _NativeSet.filter(_:)(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t (*)(char *))isStackAllocationSafe;
  v17[1] = *(__objc2_class ***)MEMORY[0x1E4F143B8];
  char v10 = *(unsigned char *)(a3 + 32);
  unint64_t v11 = (unint64_t)((1 << v10) + 63) >> 6;
  size_t v12 = 8 * v11;
  if ((v10 & 0x3Fu) <= 0xD
    || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1F4188790](isStackAllocationSafe);
    uint64_t v13 = (int64x2_t *)((char *)&v15 - ((v12 + 15) & 0x3FFFFFFFFFFFFFF0));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v11, v13);
    closure #1 in _NativeSet.filter(_:)((unint64_t *)v13, v11, v9, a4, a5, &v16);
    swift_release(a3);
    if (v5) {
      swift_willThrow();
    }
  }
  else
  {
    uint64_t v14 = (int64x2_t *)swift_slowAlloc(v12, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v11, v14);
    closure #1 in _NativeSet.filter(_:)((unint64_t *)v14, v11, v9, a4, a5, v17);
    swift_release(a3);
    swift_slowDealloc(v14);
  }
}

__objc2_class **closure #1 in _NativeSet.filter(_:)@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(char *)@<X3>, uint64_t a4@<X5>, uint64_t a5@<X6>, __objc2_class ***a6@<X8>)
{
  uint64_t v31 = a5;
  uint64_t v32 = a1;
  uint64_t v38 = a3;
  uint64_t v29 = a2;
  uint64_t v30 = a6;
  uint64_t v8 = *(void *)(a4 - 8);
  uint64_t result = (__objc2_class **)MEMORY[0x1F4188790](a1);
  unint64_t v11 = (char *)&v29 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v12 = 0;
  unint64_t v39 = (atomic_ullong *)v13;
  uint64_t v14 = *(void *)(v13 + 56);
  uint64_t v33 = 0;
  uint64_t v34 = v13 + 56;
  uint64_t v15 = 1 << *(unsigned char *)(v13 + 32);
  uint64_t v16 = -1;
  if (v15 < 64) {
    uint64_t v16 = ~(-1 << v15);
  }
  unint64_t v17 = v16 & v14;
  uint64_t v37 = v8 + 16;
  int64_t v35 = (unint64_t)(v15 + 63) >> 6;
  uint64_t v36 = v8 + 8;
  while (v17)
  {
    unint64_t v18 = __clz(__rbit64(v17));
    v17 &= v17 - 1;
    unint64_t v19 = v18 | (v12 << 6);
LABEL_16:
    (*(void (**)(char *, unint64_t, uint64_t))(v8 + 16))(v11, v39[6] + *(void *)(v8 + 72) * v19, a4);
    char v23 = v38(v11);
    uint64_t result = (__objc2_class **)(*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, a4);
    if (v6) {
      return result;
    }
    if (v23)
    {
      *(unint64_t *)((char *)v32 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v19;
      BOOL v20 = __OFADD__(v33++, 1);
      if (v20)
      {
        __break(1u);
LABEL_21:
        uint64_t v24 = v30;
        uint64_t v25 = v31;
        uint64_t v26 = v29;
        uint64_t v27 = v33;
        uint64_t v28 = v39;
        swift_retain(v39);
        uint64_t result = _NativeSet.extractSubset(using:count:)(v32, v26, v27, (uint64_t)v28, a4, v25);
        *uint64_t v24 = result;
        return result;
      }
    }
  }
  BOOL v20 = __OFADD__(v12++, 1);
  if (v20) {
    goto LABEL_24;
  }
  if (v12 >= v35) {
    goto LABEL_21;
  }
  unint64_t v21 = *(void *)(v34 + 8 * v12);
  if (v21)
  {
LABEL_15:
    unint64_t v17 = (v21 - 1) & v21;
    unint64_t v19 = __clz(__rbit64(v21)) + (v12 << 6);
    goto LABEL_16;
  }
  int64_t v22 = v12 + 1;
  if (v12 + 1 >= v35) {
    goto LABEL_21;
  }
  unint64_t v21 = *(void *)(v34 + 8 * v22);
  if (v21)
  {
    ++v12;
    goto LABEL_15;
  }
  while (1)
  {
    int64_t v12 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v12 >= v35) {
      goto LABEL_21;
    }
    unint64_t v21 = *(void *)(v34 + 8 * v12);
    ++v22;
    if (v21) {
      goto LABEL_15;
    }
  }
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

__objc2_class **_NativeSet.intersection(_:)(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = isStackAllocationSafe;
  v15[1] = *(__objc2_class ***)MEMORY[0x1E4F143B8];
  char v8 = *(unsigned char *)(a2 + 32);
  unint64_t v9 = (unint64_t)((1 << v8) + 63) >> 6;
  size_t v10 = 8 * v9;
  if ((v8 & 0x3Fu) <= 0xD
    || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1F4188790](isStackAllocationSafe);
    unint64_t v11 = (int64x2_t *)((char *)v15 - ((v10 + 15) & 0x3FFFFFFFFFFFFFF0));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v9, v11);
    closure #1 in _NativeSet.intersection(_:)((unint64_t *)v11, v9, a2, v7, a3, a4, v15);
    swift_release(a2);
    return v15[0];
  }
  else
  {
    uint64_t v13 = (int64x2_t *)swift_slowAlloc(v10, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v9, v13);
    closure #1 in _NativeSet.intersection(_:)((unint64_t *)v13, v9, a2, v7, a3, a4, v15);
    swift_release(a2);
    swift_slowDealloc(v13);
    return v15[0];
  }
}

__objc2_class **closure #1 in _NativeSet.intersection(_:)@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, __objc2_class ***a7@<X8>)
{
  uint64_t v68 = a2;
  uint64_t v70 = a1;
  uint64_t v69 = a7;
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v68 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v89 = (char *)&v68 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v19 = (char *)&v68 - v18;
  uint64_t result = (__objc2_class **)MEMORY[0x1F4188790](v17);
  int64_t v22 = (char *)&v68 - v21;
  unint64_t v24 = *(void *)(v23 + 16);
  unint64_t v26 = *(void *)(v25 + 16);
  uint64_t v90 = v11 + 16;
  uint64_t v75 = v27;
  uint64_t v86 = v25;
  uint64_t v87 = v23;
  uint64_t v79 = v11;
  if (v26 < v24)
  {
    int64_t v28 = 0;
    uint64_t v29 = *(void *)(a4 + 56);
    uint64_t v76 = a4 + 56;
    uint64_t v30 = 1 << *(unsigned char *)(a4 + 32);
    if (v30 < 64) {
      uint64_t v31 = ~(-1 << v30);
    }
    else {
      uint64_t v31 = -1;
    }
    unint64_t v32 = v31 & v29;
    int64_t v77 = (unint64_t)(v30 + 63) >> 6;
    uint64_t v78 = 0;
    uint64_t v73 = a6 + 32;
    unint64_t v74 = v11 + 32;
    uint64_t v83 = a3 + 56;
    long long v88 = (void (**)(char *, uint64_t))(v11 + 8);
    uint64_t v81 = (uint64_t)v19;
    uint64_t v72 = (char *)&v68 - v21;
    if (v32) {
      goto LABEL_9;
    }
LABEL_10:
    BOOL v33 = __OFADD__(v28, 1);
    int64_t v35 = v28 + 1;
    if (v33) {
      goto LABEL_57;
    }
    if (v35 < v77)
    {
      unint64_t v36 = *(void *)(v76 + 8 * v35);
      if (v36)
      {
LABEL_19:
        uint64_t v82 = (v36 - 1) & v36;
        int64_t v80 = v35;
        for (unint64_t i = __clz(__rbit64(v36)) + (v35 << 6); ; unint64_t i = __clz(__rbit64(v32)) | (v28 << 6))
        {
          uint64_t v38 = *(void *)(v11 + 72);
          unint64_t v39 = *(void *)(a4 + 48) + v38 * i;
          uint64_t v84 = *(void (**)(char *, unint64_t, uint64_t))(v11 + 16);
          uint64_t v85 = v38;
          v84(v22, v39, a5);
          (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v19, v22, a5);
          uint64_t v40 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a3 + 40), a5, a6);
          uint64_t v41 = -1 << *(unsigned char *)(a3 + 32);
          unint64_t v42 = v40 & ~v41;
          if ((*(void *)(v83 + ((v42 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v42))
          {
            uint64_t v71 = (unint64_t)v88 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
            uint64_t v43 = ~v41;
            uint64_t v44 = *(void *)(a6 + 8);
            char v45 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 8);
            while (1)
            {
              uint64_t v46 = v89;
              v84(v89, *(void *)(v87 + 48) + v42 * v85, a5);
              char v47 = v45(v46, v81, a5, v44);
              uint64_t v48 = *v88;
              (*v88)(v46, a5);
              if (v47) {
                break;
              }
              unint64_t v42 = (v42 + 1) & v43;
              if (((*(void *)(v83 + ((v42 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v42) & 1) == 0)
              {
                a6 = v75;
                a4 = v86;
                a3 = v87;
                uint64_t v11 = v79;
                int64_t v28 = v80;
                unint64_t v19 = (char *)v81;
                int64_t v22 = v72;
                goto LABEL_26;
              }
            }
            unint64_t v19 = (char *)v81;
            uint64_t result = (__objc2_class **)((uint64_t (*)(uint64_t, uint64_t))v48)(v81, a5);
            *(unint64_t *)((char *)v70 + ((v42 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v42;
            uint64_t v11 = v79;
            BOOL v33 = __OFADD__(v78++, 1);
            a6 = v75;
            a4 = v86;
            a3 = v87;
            int64_t v22 = v72;
            int64_t v28 = v80;
            unint64_t v32 = v82;
            if (v33) {
              goto LABEL_59;
            }
            if (!v82) {
              goto LABEL_10;
            }
          }
          else
          {
            uint64_t v48 = *v88;
            int64_t v22 = v72;
            int64_t v28 = v80;
LABEL_26:
            uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v48)(v19, a5);
            unint64_t v32 = v82;
            if (!v82) {
              goto LABEL_10;
            }
          }
LABEL_9:
          uint64_t v82 = (v32 - 1) & v32;
          int64_t v80 = v28;
        }
      }
      int64_t v37 = v35 + 1;
      if (v35 + 1 < v77)
      {
        unint64_t v36 = *(void *)(v76 + 8 * v37);
        if (v36)
        {
          ++v35;
          goto LABEL_19;
        }
        while (1)
        {
          int64_t v35 = v37 + 1;
          if (__OFADD__(v37, 1)) {
            break;
          }
          if (v35 >= v77) {
            goto LABEL_54;
          }
          unint64_t v36 = *(void *)(v76 + 8 * v35);
          ++v37;
          if (v36) {
            goto LABEL_19;
          }
        }
        __break(1u);
        goto LABEL_56;
      }
    }
LABEL_54:
    uint64_t v67 = v78;
    swift_retain((atomic_ullong *)a3);
    uint64_t result = _NativeSet.extractSubset(using:count:)(v70, v68, v67, a3, a5, a6);
    *uint64_t v69 = result;
    return result;
  }
  uint64_t v78 = 0;
  int64_t v49 = 0;
  char v50 = (char *)(a3 + 56);
  uint64_t v51 = 1 << *(unsigned char *)(a3 + 32);
  if (v51 < 64) {
    uint64_t v52 = ~(-1 << v51);
  }
  else {
    uint64_t v52 = -1;
  }
  unint64_t v53 = v52 & *(void *)(a3 + 56);
  int64_t v80 = (unint64_t)(v51 + 63) >> 6;
  uint64_t v76 = a6 + 32;
  uint64_t v82 = (uint64_t)v14;
  uint64_t v83 = a4 + 56;
  long long v88 = (void (**)(char *, uint64_t))(v11 + 8);
  uint64_t v72 = (char *)(a3 + 56);
  if (v53) {
    goto LABEL_35;
  }
LABEL_36:
  BOOL v33 = __OFADD__(v49++, 1);
  if (v33) {
    goto LABEL_58;
  }
  if (v49 >= v80) {
    goto LABEL_54;
  }
  unint64_t v55 = *(void *)&v50[8 * v49];
  if (v55)
  {
LABEL_45:
    uint64_t v81 = (v55 - 1) & v55;
    for (unint64_t j = __clz(__rbit64(v55)) + (v49 << 6); ; unint64_t j = __clz(__rbit64(v53)) | (v49 << 6))
    {
      uint64_t v57 = *(void *)(a3 + 48);
      uint64_t v85 = *(void *)(v11 + 72);
      uint64_t v84 = *(void (**)(char *, unint64_t, uint64_t))(v11 + 16);
      v84(v14, v57 + v85 * j, a5);
      uint64_t v58 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a4 + 40), a5, a6);
      uint64_t v59 = -1 << *(unsigned char *)(a4 + 32);
      unint64_t v60 = v58 & ~v59;
      if ((*(void *)(v83 + ((v60 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v60))
      {
        uint64_t v73 = (unint64_t)v88 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        unint64_t v74 = j;
        int64_t v77 = v49;
        uint64_t v61 = ~v59;
        uint64_t v62 = *(void *)(a6 + 8);
        unint64_t v63 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v62 + 8);
        while (1)
        {
          uint64_t v64 = v89;
          v84(v89, *(void *)(v86 + 48) + v60 * v85, a5);
          char v65 = v63(v64, v82, a5, v62);
          uint64_t v66 = *v88;
          (*v88)(v64, a5);
          if (v65) {
            break;
          }
          unint64_t v60 = (v60 + 1) & v61;
          if (((*(void *)(v83 + ((v60 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v60) & 1) == 0)
          {
            a6 = v75;
            a4 = v86;
            a3 = v87;
            uint64_t v11 = v79;
            uint64_t v14 = (char *)v82;
            char v50 = v72;
            int64_t v49 = v77;
            goto LABEL_52;
          }
        }
        uint64_t v14 = (char *)v82;
        uint64_t result = (__objc2_class **)((uint64_t (*)(uint64_t, uint64_t))v66)(v82, a5);
        a6 = v75;
        *(unint64_t *)((char *)v70 + ((v74 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v74;
        uint64_t v11 = v79;
        BOOL v33 = __OFADD__(v78++, 1);
        a4 = v86;
        a3 = v87;
        char v50 = v72;
        int64_t v49 = v77;
        unint64_t v53 = v81;
        if (v33) {
          goto LABEL_60;
        }
        if (!v81) {
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v66 = *v88;
        uint64_t v11 = v79;
LABEL_52:
        uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v66)(v14, a5);
        unint64_t v53 = v81;
        if (!v81) {
          goto LABEL_36;
        }
      }
LABEL_35:
      uint64_t v81 = (v53 - 1) & v53;
    }
  }
  int64_t v56 = v49 + 1;
  if (v49 + 1 >= v80) {
    goto LABEL_54;
  }
  unint64_t v55 = *(void *)&v50[8 * v56];
  if (v55)
  {
    ++v49;
    goto LABEL_45;
  }
  while (1)
  {
    int64_t v49 = v56 + 1;
    if (__OFADD__(v56, 1)) {
      break;
    }
    if (v49 >= v80) {
      goto LABEL_54;
    }
    unint64_t v55 = *(void *)&v50[8 * v49];
    ++v56;
    if (v55) {
      goto LABEL_45;
    }
  }
LABEL_56:
  __break(1u);
LABEL_57:
  __break(1u);
LABEL_58:
  __break(1u);
LABEL_59:
  __break(1u);
LABEL_60:
  __break(1u);
  return result;
}

__objc2_class **_NativeSet.genericIntersection<A>(_:)(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (atomic_ullong *)isStackAllocationSafe;
  v19[1] = *(__objc2_class ***)MEMORY[0x1E4F143B8];
  char v12 = *(unsigned char *)(a2 + 32);
  unint64_t v13 = (unint64_t)((1 << v12) + 63) >> 6;
  size_t v14 = 8 * v13;
  if ((v12 & 0x3Fu) <= 0xD
    || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1F4188790](isStackAllocationSafe);
    uint64_t v15 = (int64x2_t *)((char *)v19 - ((v14 + 15) & 0x3FFFFFFFFFFFFFF0));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v13, v15);
    closure #1 in _NativeSet.genericIntersection<A>(_:)((unint64_t *)v15, v13, v11, (atomic_ullong *)a2, a3, a4, a5, a6, v19);
    swift_release(a2);
    return v19[0];
  }
  else
  {
    uint64_t v17 = (int64x2_t *)swift_slowAlloc(v14, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v13, v17);
    closure #1 in _NativeSet.genericIntersection<A>(_:)((unint64_t *)v17, v13, v11, (atomic_ullong *)a2, a3, a4, a5, a6, v19);
    swift_release(a2);
    swift_slowDealloc(v17);
    return v19[0];
  }
}

__objc2_class **closure #1 in _NativeSet.genericIntersection<A>(_:)@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X2>, atomic_ullong *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, __objc2_class ***a9@<X8>)
{
  uint64_t v12 = a5;
  uint64_t v75 = a3;
  uint64_t v76 = a4;
  uint64_t v51 = a2;
  uint64_t v54 = a1;
  uint64_t v52 = a9;
  uint64_t v57 = *(void **)(a5 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](a1);
  uint64_t v70 = (char *)&v49 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  int64_t v77 = (char *)&v49 - v15;
  unint64_t v19 = type metadata accessor for Optional(0, v18, v16, v17);
  uint64_t v20 = MEMORY[0x1F4188790](v19 - 1);
  int64_t v22 = (char *)&v49 - v21;
  uint64_t v23 = *(void *)(a6 - 8);
  MEMORY[0x1F4188790](v20);
  uint64_t v25 = (char *)&v49 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a8, a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v50 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  int64_t v28 = (char *)&v49 - v27;
  (*(void (**)(char *, atomic_ullong *, uint64_t))(v23 + 16))(v25, v75, a6);
  (*(void (**)(uint64_t, uint64_t))(a8 + 32))(a6, a8);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a8, a6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v67 = v28;
  uint64_t v68 = AssociatedTypeWitness;
  uint64_t v65 = AssociatedConformanceWitness + 16;
  uint64_t v66 = AssociatedConformanceWitness;
  uint64_t v64 = v30;
  ((void (*)(const char *))v30)(AssociatedTypeWitness);
  uint64_t v62 = (uint64_t (*)(char *, uint64_t, uint64_t))v57[6];
  unint64_t v63 = v57 + 6;
  int v31 = v62(v22, 1, v12);
  uint64_t v53 = 0;
  if (v31 == 1)
  {
LABEL_2:
    (*(void (**)(char *, const char *))(v50 + 8))(v67, v68);
    unint64_t v32 = v76;
    swift_retain(v76);
    uint64_t result = _NativeSet.extractSubset(using:count:)(v54, v51, v53, (uint64_t)v32, v12, a7);
    *uint64_t v52 = result;
    return result;
  }
  uint64_t v53 = 0;
  uint64_t v34 = (void (*)(char *, char *, uint64_t))v57[4];
  uint64_t v59 = a7 + 32;
  unint64_t v60 = v34;
  uint64_t v74 = v12;
  uint64_t v75 = v76 + 7;
  uint64_t v69 = v57 + 2;
  uint64_t v61 = v57 + 4;
  unint64_t v35 = (unint64_t)(v57 + 1);
  uint64_t v56 = a7;
  unint64_t v55 = v22;
  uint64_t v73 = (void (**)(char *, uint64_t))(v57 + 1);
  v34(v77, v22, v12);
  while (1)
  {
    int64_t v37 = v76;
    uint64_t v38 = (*(uint64_t (**)(atomic_ullong, uint64_t, uint64_t))(a7 + 32))(v76[5], v12, a7);
    uint64_t v39 = -1 << *((unsigned char *)v37 + 32);
    unint64_t v40 = v38 & ~v39;
    if ((*(unint64_t *)((char *)v75 + ((v40 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v40)) {
      break;
    }
    unint64_t v36 = *(void (**)(char *, uint64_t))v35;
LABEL_5:
    v36(v77, v12);
LABEL_6:
    v64(v68, v66);
    if (v62(v22, 1, v12) == 1) {
      goto LABEL_2;
    }
    v60(v77, v22, v12);
  }
  uint64_t v58 = v35 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  uint64_t v71 = ~v39;
  uint64_t v41 = *(void *)(a7 + 8);
  uint64_t v72 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 8);
  uint64_t v42 = v57[9];
  uint64_t v43 = (void (*)(char *, unint64_t, uint64_t))v57[2];
  while (1)
  {
    uint64_t v44 = v70;
    uint64_t v45 = v74;
    v43(v70, v76[6] + v42 * v40, v74);
    char v46 = v72(v44, v77, v45, v41);
    unint64_t v36 = *v73;
    (*v73)(v44, v45);
    if (v46) {
      break;
    }
    unint64_t v40 = (v40 + 1) & v71;
    if (((*(unint64_t *)((char *)v75 + ((v40 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v40) & 1) == 0)
    {
      a7 = v56;
      unint64_t v35 = (unint64_t)v73;
      uint64_t v12 = v74;
      int64_t v22 = v55;
      goto LABEL_5;
    }
  }
  unint64_t v35 = (unint64_t)v73;
  uint64_t v12 = v74;
  uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v36)(v77, v74);
  uint64_t v47 = (v40 >> 3) & 0x1FFFFFFFFFFFFFF8;
  uint64_t v48 = *(unint64_t *)((char *)v54 + v47);
  *(unint64_t *)((char *)v54 + v47) = v48 | (1 << v40);
  if ((v48 & (1 << v40)) != 0)
  {
    a7 = v56;
    int64_t v22 = v55;
    goto LABEL_6;
  }
  a7 = v56;
  int64_t v22 = v55;
  if (!__OFADD__(v53, 1))
  {
    ++v53;
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

uint64_t _SwiftNewtypeWrapper<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a1, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  size_t v10 = (char *)&v13 - v9;
  (*(void (**)(uint64_t, uint64_t))(v6 + 24))(a1, v6);
  uint64_t v11 = (*(uint64_t (**)(const char *, uint64_t))(a4 + 16))(AssociatedTypeWitness, a4);
  (*(void (**)(char *, const char *))(v8 + 8))(v10, AssociatedTypeWitness);
  return v11;
}

uint64_t _SwiftNewtypeWrapper<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v14 - v11;
  (*(void (**)(uint64_t, uint64_t))(v8 + 24))(a2, v8);
  (*(void (**)(uint64_t, const char *, uint64_t))(a5 + 24))(a1, AssociatedTypeWitness, a5);
  return (*(uint64_t (**)(char *, const char *))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _SwiftNewtypeWrapper<>._rawHashValue(seed:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  (*(void (**)(uint64_t, uint64_t))(v8 + 24))(a2, v8);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(a5 + 32))(a1, AssociatedTypeWitness, a5);
  (*(void (**)(char *, const char *))(v10 + 8))(v12, AssociatedTypeWitness);
  return v13;
}

double _SwiftNewtypeWrapper._toCustomAnyHashable()@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8))(v2, a1);
  *(void *)(a2 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return result;
}

uint64_t _SwiftNewtypeWrapper<>._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  v10[0] = a1;
  v10[1] = a2;
  v10[2] = a3;
  v10[3] = a4;
  a5[3] = type metadata accessor for _NewtypeWrapperAnyHashableBox(0, (uint64_t)v10);
  a5[4] = &protocol witness table for _NewtypeWrapperAnyHashableBox<A>;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a5);
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32))(boxed_opaque_existential_0Tm, v5, a1);
}

uint64_t _NewtypeWrapperAnyHashableBox._canonicalBox.getter(void *a1)
{
  uint64_t v2 = *(void *)(a1[4] + 8);
  uint64_t v3 = a1[2];
  uint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, (int **)v2, v3, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v6 = (char *)&v11[-1] - v5;
  (*(void (**)(uint64_t, uint64_t))(v2 + 24))(v3, v2);
  AnyHashable.init<A>(_:)((uint64_t)v6, AssociatedTypeWitness, a1[5], (uint64_t)v11);
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  (*(void (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v11);
}

uint64_t _ConcreteHashableBox._base.getter@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  a2[3] = v3;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a2);
  uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(v3 - 8) + 16);

  return v5(boxed_opaque_existential_0Tm, v2, v3);
}

uint64_t _NewtypeWrapperAnyHashableBox._unbox<A>()@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v41 = a3;
  uint64_t v7 = *(Class **)(a1 + 16);
  int64_t v37 = *(int ***)(*(void *)(a1 + 32) + 8);
  uint64_t AssociatedTypeWitness = (Class *)swift_getAssociatedTypeWitness(0, v37, (uint64_t)v7, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v36 = (unint64_t *)((char *)&v33 - v9);
  uint64_t v10 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v33 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)a2, v13, v14);
  uint64_t v42 = (uint64_t)*(v15 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v33 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (unint64_t *)((char *)&v33 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(unint64_t *, uint64_t, Class *))(v24 + 16))(v23, v4, v7);
  uint64_t v34 = v7;
  int v25 = swift_dynamicCast(v21, v23, v7, a2, 6uLL);
  uint64_t v26 = *((void *)a2 - 1);
  uint64_t v39 = *(void (**)(char *, void, uint64_t, const char *))(v26 + 56);
  v39(v21, v25 ^ 1u, 1, a2);
  uint64_t v40 = v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, v4, a1);
  uint64_t v27 = *(void (**)(char *, char *, Class *))(v42 + 32);
  unint64_t v35 = v15;
  v27(v18, v21, v15);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v26 + 48))(v18, 1, a2) == 1)
  {
    int64_t v28 = v36;
    ((void (*)(Class *))v37[3])(v34);
    (*(void (**)(char *, uint64_t))(v40 + 8))(v12, a1);
    uint64_t v29 = v41;
    int v30 = swift_dynamicCast(v41, v28, AssociatedTypeWitness, a2, 6uLL);
    v39(v29, v30 ^ 1u, 1, a2);
    return (*(uint64_t (**)(char *, Class *))(v42 + 8))(v18, v35);
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v40 + 8))(v12, a1);
    unint64_t v32 = v41;
    (*(void (**)(char *, char *, const char *))(v26 + 32))(v41, v18, a2);
    return ((uint64_t (*)(char *, void, uint64_t, const char *))v39)(v32, 0, 1, a2);
  }
}

uint64_t _NewtypeWrapperAnyHashableBox._downCastConditional<A>(into:)(char *a1, uint64_t a2, const char *a3)
{
  uint64_t v41 = a1;
  uint64_t v5 = *(Class **)(a2 + 16);
  uint64_t v40 = *(int ***)(*(void *)(a2 + 32) + 8);
  uint64_t AssociatedTypeWitness = (Class *)swift_getAssociatedTypeWitness(0, v40, (uint64_t)v5, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  int64_t v37 = (unint64_t *)((char *)&v35 - v6);
  uint64_t v39 = type metadata accessor for Optional(0, (uint64_t)a3, v7, v8);
  uint64_t v42 = (uint64_t)*(v39 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v39);
  uint64_t v11 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v35 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (unint64_t *)((char *)&v35 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v18 = *((void *)a3 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v15);
  uint64_t v21 = (char *)&v35 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v35 - v22;
  (*(void (**)(unint64_t *, uint64_t, Class *))(v24 + 16))(v17, v3, v5);
  int v25 = swift_dynamicCast(v14, v17, v5, a3, 6uLL);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v18 + 56);
  if (v25)
  {
    uint64_t v27 = 1;
    v26(v14, 0, 1, a3);
    int64_t v28 = *(void (**)(char *, char *, const char *))(v18 + 32);
    v28(v23, v14, a3);
    v28(v41, v23, a3);
  }
  else
  {
    v26(v14, 1, 1, a3);
    uint64_t v29 = *(void (**)(char *, Class *))(v42 + 8);
    int v30 = v14;
    int v31 = v39;
    v42 += 8;
    unint64_t v36 = v29;
    v29(v30, v39);
    unint64_t v32 = v37;
    ((void (*)(Class *))v40[3])(v5);
    if (swift_dynamicCast(v11, v32, AssociatedTypeWitness, a3, 6uLL))
    {
      uint64_t v27 = 1;
      v26(v11, 0, 1, a3);
      uint64_t v33 = *(void (**)(char *, char *, const char *))(v18 + 32);
      v33(v21, v11, a3);
      v33(v41, v21, a3);
    }
    else
    {
      v26(v11, 1, 1, a3);
      v36(v11, v31);
      return 0;
    }
  }
  return v27;
}

void protocol witness for _AnyHashableBox._isEqual(to:) in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

void protocol witness for _AnyHashableBox._hashValue.getter in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

void protocol witness for _AnyHashableBox._hash(into:) in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

void protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _NewtypeWrapperAnyHashableBox<A>@<X0>(const char *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return _NewtypeWrapperAnyHashableBox._unbox<A>()(a2, a1, a3);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _NewtypeWrapperAnyHashableBox<A>(char *a1, const char *a2, uint64_t a3)
{
  return _NewtypeWrapperAnyHashableBox._downCastConditional<A>(into:)(a1, a3, a2);
}

uint64_t _SwiftNewtypeWrapper<>._bridgeToObjectiveC()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, a1, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v12 - v8;
  (*(void (**)(uint64_t, uint64_t))(v5 + 24))(a1, v5);
  uint64_t v10 = (*(uint64_t (**)(const char *, uint64_t))(a3 + 16))(AssociatedTypeWitness, a3);
  (*(void (**)(char *, const char *))(v7 + 8))(v9, AssociatedTypeWitness);
  return v10;
}

uint64_t static _SwiftNewtypeWrapper<>._forceBridgeFromObjectiveC(_:result:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v30 = a1;
  uint64_t v31 = a5;
  uint64_t v29 = *(int ***)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v29, a3, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  int64_t v28 = (char *)&v28 - v9;
  uint64_t v32 = a3;
  uint64_t v12 = type metadata accessor for Optional(0, a3, v10, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v28 - v14;
  uint64_t v18 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v16, v17);
  uint64_t v19 = (uint64_t)*(v18 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v28 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v28 - v23;
  int v25 = *(void (**)(uint64_t, Class *))(v13 + 8);
  uint64_t v33 = a2;
  v25(a2, v12);
  (*(void (**)(char *, uint64_t, uint64_t, const char *))(v8 + 56))(v24, 1, 1, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, const char *))(v31 + 24))(v30, v24, AssociatedTypeWitness);
  (*(void (**)(char *, char *, Class *))(v19 + 32))(v22, v24, v18);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v8 + 48))(v22, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v32 - 8) + 56))(v15, 1, 1);
  }
  else
  {
    uint64_t v26 = v28;
    (*(void (**)(char *, char *, const char *))(v8 + 32))(v28, v22, AssociatedTypeWitness);
    ((void (*)(char *))v29[2])(v26);
  }
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v13 + 32))(v33, v15, v12);
}

uint64_t static _SwiftNewtypeWrapper<>._conditionallyBridgeFromObjectiveC(_:result:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = a1;
  uint64_t v32 = a5;
  uint64_t v30 = *(int ***)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v30, a3, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v29 = (char *)&v29 - v9;
  uint64_t v33 = a3;
  uint64_t v12 = type metadata accessor for Optional(0, a3, v10, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v29 - v14;
  uint64_t v18 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v16, v17);
  uint64_t v19 = (uint64_t)*(v18 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v29 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v29 - v23;
  int v25 = *(void (**)(uint64_t, Class *))(v13 + 8);
  uint64_t v34 = a2;
  v25(a2, v12);
  (*(void (**)(char *, uint64_t, uint64_t, const char *))(v8 + 56))(v24, 1, 1, AssociatedTypeWitness);
  char v26 = (*(uint64_t (**)(uint64_t, char *, const char *))(v32 + 32))(v31, v24, AssociatedTypeWitness);
  (*(void (**)(char *, char *, Class *))(v19 + 32))(v22, v24, v18);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v8 + 48))(v22, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v33 - 8) + 56))(v15, 1, 1);
  }
  else
  {
    uint64_t v27 = v29;
    (*(void (**)(char *, char *, const char *))(v8 + 32))(v29, v22, AssociatedTypeWitness);
    ((void (*)(char *))v30[2])(v27);
  }
  (*(void (**)(uint64_t, char *, Class *))(v13 + 32))(v34, v15, v12);
  return v26 & 1;
}

uint64_t static _SwiftNewtypeWrapper<>._unconditionallyBridgeFromObjectiveC(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v20 - v11;
  uint64_t v15 = type metadata accessor for Optional(0, a2, v13, v14);
  MEMORY[0x1F4188790](v15 - 1);
  uint64_t v17 = (char *)&v20 - v16;
  (*(void (**)(uint64_t, const char *, uint64_t))(a4 + 40))(a1, AssociatedTypeWitness, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, v9);
  uint64_t v18 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v18 + 48))(v17, 1, a2) == 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x8DuLL, 0);
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v18 + 32))(a5, v17, a2);
}

uint64_t _SwiftNewtypeWrapper<>._bridgeToObjectiveC()(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)(a2 + 8) + 24))(&v3);
  return v3;
}

uint64_t static _SwiftNewtypeWrapper<>._forceBridgeFromObjectiveC(_:result:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0, a3, a3, a4);
  (*((void (**)(uint64_t, Class *))*(v8 - 1) + 1))(a2, v8);
  uint64_t v12 = a1;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(uint64_t (**)(void **, uint64_t, uint64_t))(v9 + 16);
  swift_unknownObjectRetain(a1);
  return v10(&v12, a3, v9);
}

BOOL static _SwiftNewtypeWrapper<>._conditionallyBridgeFromObjectiveC(_:result:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0, a3, a3, a4);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  MEMORY[0x1F4188790](v8);
  uint64_t v11 = (char *)&v16 - v10;
  uint64_t v16 = *(void (**)(uint64_t, Class *))(v9 + 8);
  v16(a2, v8);
  uint64_t v17 = a1;
  uint64_t v12 = *(void *)(a4 + 8);
  uint64_t v13 = *(void (**)(void **, uint64_t, uint64_t))(v12 + 16);
  swift_unknownObjectRetain(a1);
  v13(&v17, a3, v12);
  (*(void (**)(char *, uint64_t, Class *))(v9 + 16))(v11, a2, v8);
  BOOL v14 = (*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 48))(v11, 1, a3) != 1;
  v16((uint64_t)v11, v8);
  return v14;
}

uint64_t static _SwiftNewtypeWrapper<>._unconditionallyBridgeFromObjectiveC(_:)@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = type metadata accessor for Optional(0, a2, a3, a4);
  MEMORY[0x1F4188790](v9 - 1);
  uint64_t v11 = (char *)&v16 - v10;
  if (!a1
    || (uint64_t v17 = a1,
        uint64_t v12 = *(void *)(a3 + 8),
        uint64_t v13 = *(void (**)(void **, uint64_t, uint64_t))(v12 + 16),
        swift_unknownObjectRetain(a1),
        v13(&v17, a2, v12),
        uint64_t v14 = *(void *)(a2 - 8),
        (*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v11, 1, a2) == 1))
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0xADuLL, 0);
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v14 + 32))(a5, v11, a2);
}

uint64_t static UInt32.% infix(_:_:)(unsigned int a1, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  }
  return a1 % a2;
}

unint64_t specialized Unicode._InternalNFC.Iterator.next()()
{
  uint64_t v1 = *(__objc2_class ***)v0;
  if (*(void *)(*(void *)v0 + 16))
  {
    if ((*(unsigned char *)(v0 + 8) & 1) == 0)
    {
      specialized MutableCollection<>.reverse()();
      *(unsigned char *)(v0 + 8) = 1;
    }
    int v2 = specialized RangeReplaceableCollection<>.removeLast()();
    LOBYTE(v3) = 0;
    LODWORD(v4) = v2;
    return v4 | ((unint64_t)v3 << 32);
  }
  *(unsigned char *)(v0 + 8) = 0;
  unint64_t v5 = specialized Unicode._InternalNFD.Iterator.next()();
  if ((v5 & 0x1000000000000) != 0)
  {
LABEL_34:
    LODWORD(v4) = *(_DWORD *)(v0 + 12);
    LOBYTE(v3) = *(unsigned char *)(v0 + 16);
    *(_DWORD *)(v0 + 12) = 0;
    *(unsigned char *)(v0 + 16) = 1;
    return v4 | ((unint64_t)v3 << 32);
  }
  unint64_t v4 = v5;
  while (1)
  {
    while ((*(unsigned char *)(v0 + 16) & 1) != 0)
    {
      if ((v4 & 0x7F800000000) != 0)
      {
        LOBYTE(v3) = 0;
        return v4 | ((unint64_t)v3 << 32);
      }
      LODWORD(v6) = v4;
LABEL_10:
      *(_DWORD *)(v0 + 12) = v6;
      *(unsigned char *)(v0 + 16) = 0;
      unint64_t v4 = specialized Unicode._InternalNFD.Iterator.next()();
      if ((v4 & 0x1000000000000) != 0) {
        goto LABEL_34;
      }
    }
    unsigned int v7 = *(_DWORD *)(v0 + 12);
    uint64_t v8 = v1[2];
    if (!v8) {
      break;
    }
    unsigned int v3 = (v4 >> 35);
    if (v3 > (WORD2(v1[(void)v8 + 3]) >> 3))
    {
      if (v4 >= 0x300 && (v4 & 0x600000000) != 0)
      {
        unint64_t v6 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v0 + 12), v4);
        if ((v6 & 0x100000000) == 0) {
          goto LABEL_10;
        }
        LODWORD(v6) = _swift_stdlib_getComposition(v7, v4);
        if (v6 != -1) {
          goto LABEL_10;
        }
      }
      goto LABEL_24;
    }
    if (!(v4 >> 35)) {
      goto LABEL_38;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v1);
    *(void *)uint64_t v0 = v1;
    if (!isUniquelyReferenced_nonNull_native)
    {
      int64_t v14 = (int64_t)&v8->isa + 1;
      goto LABEL_33;
    }
LABEL_25:
    unint64_t v11 = (unint64_t)v1[2];
    unint64_t v10 = (unint64_t)v1[3];
    if (v11 >= v10 >> 1) {
      uint64_t v1 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v10 > 1), v11 + 1, 1, (uint64_t)v1);
    }
    v1[2] = (__objc2_class *)(v11 + 1);
    uint64_t v12 = &v1[v11];
    *((_DWORD *)v12 + 8) = v4;
    *((_WORD *)v12 + 18) = WORD2(v4);
    *(void *)uint64_t v0 = v1;
    unint64_t v4 = specialized Unicode._InternalNFD.Iterator.next()();
    if ((v4 & 0x1000000000000) != 0) {
      goto LABEL_34;
    }
  }
  if (v4 >= 0x300 && (v4 & 0x600000000) != 0)
  {
    unint64_t v6 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v0 + 12), v4);
    if ((v6 & 0x100000000) == 0) {
      goto LABEL_10;
    }
    LODWORD(v6) = _swift_stdlib_getComposition(v7, v4);
    if (v6 != -1) {
      goto LABEL_10;
    }
  }
  if ((v4 & 0x7F800000000) != 0)
  {
LABEL_24:
    BOOL v9 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v1);
    *(void *)uint64_t v0 = v1;
    if (v9) {
      goto LABEL_25;
    }
    int64_t v14 = (int64_t)&v1[2]->isa + 1;
LABEL_33:
    uint64_t v1 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v14, 1, (uint64_t)v1);
    *(void *)uint64_t v0 = v1;
    goto LABEL_25;
  }
  LOBYTE(v3) = 0;
LABEL_38:
  *(_DWORD *)(v0 + 12) = v4;
  *(unsigned char *)(v0 + 16) = 0;
  LODWORD(v4) = v7;
  return v4 | ((unint64_t)v3 << 32);
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._InternalNFC.Iterator.next()()
{
  unsigned int v3 = *(__objc2_class ***)v2;
  if (*(void *)(*(void *)v2 + 16))
  {
    if ((*(unsigned char *)(v2 + 8) & 1) == 0)
    {
      specialized MutableCollection<>.reverse()();
      *(unsigned char *)(v2 + 8) = 1;
    }
    unsigned int v4 = specialized RangeReplaceableCollection<>.removeLast()();
    LOBYTE(v5) = 0;
    return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
  }
  *(unsigned char *)(v2 + 8) = 0;
  type metadata accessor for Unicode._InternalNFD.Iterator(0, *(void *)(v0 + 16), *(void *)(v0 + 24), v1);
  Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional v20 = Unicode._InternalNFD.Iterator.next()();
  if ((*(void *)&v20.value.scalar._value & 0x1000000000000) != 0)
  {
LABEL_35:
    unsigned int v4 = *(_DWORD *)(v2 + 12);
    LOBYTE(v5) = *(unsigned char *)(v2 + 16);
    *(_DWORD *)(v2 + 12) = 0;
    *(unsigned char *)(v2 + 16) = 1;
    return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
  }
  unint64_t v6 = *(void *)&v20.value.scalar._value;
  for (unint64_t i = (char *)v3 + 36; ; unint64_t i = (char *)v3 + 36)
  {
    while ((*(unsigned char *)(v2 + 16) & 1) != 0)
    {
      if ((v6 & 0x7F800000000) != 0)
      {
        LOBYTE(v5) = 0;
        unsigned int v4 = v6;
        return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
      }
      LODWORD(v8) = v6;
LABEL_10:
      *(_DWORD *)(v2 + 12) = v8;
      *(unsigned char *)(v2 + 16) = 0;
      *(Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional *)&long long v9 = Unicode._InternalNFD.Iterator.next()();
      unint64_t v6 = v9;
      if ((v9 & 0x1000000000000) != 0) {
        goto LABEL_35;
      }
    }
    unsigned int v4 = *(_DWORD *)(v2 + 12);
    unint64_t v10 = v3[2];
    if (!v10) {
      break;
    }
    unsigned int v5 = (v6 >> 35);
    if (v5 > (*(unsigned __int16 *)&i[8 * (void)v10 - 8] >> 3))
    {
      if ((v6 & 0x600000000) != 0 && v6 >= 0x300)
      {
        unint64_t v8 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v2 + 12), v6);
        if ((v8 & 0x100000000) == 0) {
          goto LABEL_10;
        }
        LODWORD(v8) = _swift_stdlib_getComposition(v4, v6);
        if (v8 != -1) {
          goto LABEL_10;
        }
      }
      goto LABEL_22;
    }
    if (!(v6 >> 35)) {
      goto LABEL_39;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v3);
    *(void *)uint64_t v2 = v3;
    if (!isUniquelyReferenced_nonNull_native)
    {
      int64_t v17 = (int64_t)&v10->isa + 1;
LABEL_31:
      unsigned int v3 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v17, 1, (uint64_t)v3);
      *(void *)uint64_t v2 = v3;
    }
LABEL_23:
    unint64_t v13 = (unint64_t)v3[2];
    unint64_t v12 = (unint64_t)v3[3];
    if (v13 >= v12 >> 1) {
      unsigned int v3 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v12 > 1), v13 + 1, 1, (uint64_t)v3);
    }
    v3[2] = (__objc2_class *)(v13 + 1);
    int64_t v14 = &v3[v13];
    *((_DWORD *)v14 + 8) = v6;
    *((_WORD *)v14 + 18) = WORD2(v6);
    *(void *)uint64_t v2 = v3;
    *(Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional *)&long long v15 = Unicode._InternalNFD.Iterator.next()();
    unint64_t v6 = v15;
    if ((v15 & 0x1000000000000) != 0) {
      goto LABEL_35;
    }
  }
  if ((v6 & 0x600000000) != 0 && v6 >= 0x300)
  {
    unint64_t v8 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v2 + 12), v6);
    if ((v8 & 0x100000000) == 0) {
      goto LABEL_10;
    }
    LODWORD(v8) = _swift_stdlib_getComposition(v4, v6);
    if (v8 != -1) {
      goto LABEL_10;
    }
  }
  if ((v6 & 0x7F800000000) != 0)
  {
LABEL_22:
    BOOL v11 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v3);
    *(void *)uint64_t v2 = v3;
    if (v11) {
      goto LABEL_23;
    }
    int64_t v17 = (int64_t)&v3[2]->isa + 1;
    goto LABEL_31;
  }
  LOBYTE(v5) = 0;
LABEL_39:
  *(_DWORD *)(v2 + 12) = v6;
  *(unsigned char *)(v2 + 16) = 0;
  return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
}

unint64_t specialized Unicode._InternalNFD.Iterator.next()()
{
  uint64_t v1 = *(void *)v0;
  if (*(void *)(*(void *)v0 + 16)) {
    goto LABEL_2;
  }
  *(unsigned char *)(v0 + 8) = 0;
  v6._Swift::UInt64 rawBits = *(void *)(v0 + 16);
  unint64_t v7 = *(void *)(v0 + 32);
  Swift::UInt64 v8 = v6._rawBits >> 14;
  if (v6._rawBits >> 14 >= v7 >> 14) {
    goto LABEL_93;
  }
  do
  {
    unint64_t v9 = *(void *)(v0 + 24);
    uint64_t v11 = *(void *)(v0 + 40);
    uint64_t v10 = *(void *)(v0 + 48);
    char v12 = (v10 & 0x1000000000000000) == 0 || (v11 & 0x800000000000000) != 0;
    uint64_t v13 = v6._rawBits & 0xC;
    uint64_t v14 = 4 << v12;
    if ((v6._rawBits & 1) != 0 && v13 != v14)
    {
      if (v8 >= v7 >> 14 || v8 < v9 >> 14)
      {
        unint64_t v50 = 143;
        goto LABEL_92;
      }
LABEL_22:
      if ((v10 & 0x1000000000000000) != 0) {
        goto LABEL_72;
      }
      goto LABEL_23;
    }
    if (v13 == v14) {
      v6._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v6)._rawBits;
    }
    if (v6._rawBits >> 14 < v9 >> 14 || v6._rawBits >> 14 >= v7 >> 14)
    {
      unint64_t v50 = 43;
LABEL_92:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v50, 0);
    }
    if (v6._rawBits) {
      goto LABEL_22;
    }
    v6._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v6)._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
    if ((v10 & 0x1000000000000000) != 0)
    {
LABEL_72:
      Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v6._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
      if (value < 0xC0) {
        goto LABEL_42;
      }
      goto LABEL_73;
    }
LABEL_23:
    Swift::UInt64 v16 = v6._rawBits >> 16;
    if ((v10 & 0x2000000000000000) != 0)
    {
      uint64_t v67 = v11;
      uint64_t v68 = v10 & 0xFFFFFFFFFFFFFFLL;
      Swift::UInt32 value = *((unsigned __int8 *)&v67 + v16);
      if (*((char *)&v67 + v16) < 0)
      {
        switch(__clz(value ^ 0xFF))
        {
          case 0x1Au:
            uint64_t v19 = (unsigned __int8 *)&v67 + v16;
LABEL_32:
            Swift::UInt32 value = v19[1] & 0x3F | ((value & 0x1F) << 6);
            if (value >= 0xC0) {
              goto LABEL_73;
            }
            goto LABEL_42;
          case 0x1Bu:
            Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional v20 = (unsigned __int8 *)&v67 + v16;
LABEL_37:
            char v22 = v20[1];
            char v23 = v20[2];
            int v24 = ((value & 0xF) << 12) | ((v22 & 0x3F) << 6);
            goto LABEL_40;
          case 0x1Cu:
            uint64_t v21 = (unsigned __int8 *)&v67 + v16;
LABEL_39:
            char v25 = v21[1];
            char v26 = v21[2];
            char v23 = v21[3];
            int v24 = ((value & 0xF) << 18) | ((v25 & 0x3F) << 12) | ((v26 & 0x3F) << 6);
LABEL_40:
            Swift::UInt32 value = v24 & 0xFFFFFFC0 | v23 & 0x3F;
            break;
          default:
            break;
        }
      }
    }
    else
    {
      if ((v11 & 0x1000000000000000) != 0) {
        int64_t v17 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        int64_t v17 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v10);
      }
      Swift::UInt32 value = v17[v16];
      if ((char)v17[v16] < 0)
      {
        switch(__clz(value ^ 0xFF))
        {
          case 0x1Au:
            uint64_t v19 = &v17[v16];
            goto LABEL_32;
          case 0x1Bu:
            Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional v20 = &v17[v16];
            goto LABEL_37;
          case 0x1Cu:
            uint64_t v21 = &v17[v16];
            goto LABEL_39;
          default:
            break;
        }
      }
    }
    if (value < 0xC0)
    {
LABEL_42:
      uint64_t v27 = 0;
      goto LABEL_43;
    }
LABEL_73:
    int NormData = _swift_stdlib_getNormData(value);
    uint64_t v27 = NormData | ((value - 44032) >> 2 < 0xAE9);
    if ((NormData & 0x7F8) != 0)
    {
      char v28 = 0;
      goto LABEL_45;
    }
LABEL_43:
    uint64_t v1 = *(void *)v0;
    if (*(void *)(*(void *)v0 + 16)) {
      goto LABEL_93;
    }
    char v28 = 1;
LABEL_45:
    uint64_t v30 = *(void *)(v0 + 40);
    unint64_t v29 = *(void *)(v0 + 48);
    Swift::UInt64 rawBits = *(void *)(v0 + 16);
    char v32 = (v29 & 0x1000000000000000) == 0 || (v30 & 0x800000000000000) != 0;
    uint64_t v33 = *(void *)(v0 + 16) & 0xCLL;
    uint64_t v34 = 4 << v32;
    if ((rawBits & 1) != 0 && v33 != v34)
    {
      unint64_t v35 = v30 & 0xFFFFFFFFFFFFLL;
      if ((v29 & 0x2000000000000000) != 0) {
        unint64_t v35 = HIBYTE(v29) & 0xF;
      }
      if (v35 <= rawBits >> 16)
      {
        unint64_t v65 = 121;
        goto LABEL_117;
      }
LABEL_60:
      if ((v29 & 0x1000000000000000) != 0) {
        goto LABEL_77;
      }
      goto LABEL_61;
    }
    if (v33 == v34) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    unint64_t v36 = v30 & 0xFFFFFFFFFFFFLL;
    if ((v29 & 0x2000000000000000) != 0) {
      unint64_t v36 = HIBYTE(v29) & 0xF;
    }
    if (v36 <= rawBits >> 16)
    {
      unint64_t v65 = 31;
LABEL_117:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringIndexValidation.swift", 33, 2, v65, 0);
    }
    if (rawBits) {
      goto LABEL_60;
    }
    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if ((v29 & 0x1000000000000000) != 0)
    {
LABEL_77:
      v6._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
      *(Swift::String::Index *)(v0 + 16) = v6;
      if ((v27 & 1) == 0) {
        goto LABEL_69;
      }
      goto LABEL_78;
    }
LABEL_61:
    Swift::UInt64 v37 = rawBits >> 16;
    if ((v29 & 0x2000000000000000) != 0)
    {
      uint64_t v67 = v30;
      uint64_t v68 = v29 & 0xFFFFFFFFFFFFFFLL;
      int v39 = *((unsigned __int8 *)&v67 + v37);
    }
    else
    {
      if ((v30 & 0x1000000000000000) != 0) {
        uint64_t v38 = (unsigned __int8 *)((v29 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v38 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v30, v29);
      }
      int v39 = v38[v37];
    }
    int v40 = (char)v39;
    unsigned int v41 = __clz(v39 ^ 0xFF) - 24;
    if (v40 >= 0) {
      LOBYTE(v4_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 1;
    }
    v6._Swift::UInt64 rawBits = ((v37 + v41) << 16) | 5;
    *(Swift::String::Index *)(v0 + 16) = v6;
    if ((v27 & 1) == 0)
    {
LABEL_69:
      if (v28)
      {
        unsigned __int8 v3 = 0;
        uint64_t v4 = value | (unint64_t)(v27 << 32);
        goto LABEL_5;
      }
      goto LABEL_79;
    }
LABEL_78:
    if (value > 0xBF)
    {
      if (value - 55204 > 0xFFFFD45B) {
        specialized Unicode._InternalNFD.Iterator.decomposeHangul(_:)(value);
      }
      else {
        specialized Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)(value, v27);
      }
      goto LABEL_84;
    }
LABEL_79:
    uint64_t v43 = *(__objc2_class ***)v0;
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*(void *)v0);
    *(void *)uint64_t v0 = v43;
    if (!isUniquelyReferenced_nonNull_native)
    {
      uint64_t v43 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v43[2]->isa + 1, 1, (uint64_t)v43);
      *(void *)uint64_t v0 = v43;
    }
    unint64_t v46 = (unint64_t)v43[2];
    unint64_t v45 = (unint64_t)v43[3];
    uint64_t v47 = (__objc2_class *)(v46 + 1);
    if (v46 >= v45 >> 1)
    {
      uint64_t v49 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v45 > 1), v46 + 1, 1, (uint64_t)v43);
      uint64_t v47 = (__objc2_class *)(v46 + 1);
      uint64_t v43 = v49;
    }
    void v43[2] = v47;
    uint64_t v48 = &v43[v46];
    *((_DWORD *)v48 + 8) = value;
    *((_WORD *)v48 + 18) = v27;
    *(void *)uint64_t v0 = v43;
LABEL_84:
    unint64_t v7 = *(void *)(v0 + 32);
    Swift::UInt64 v8 = v6._rawBits >> 14;
  }
  while (v6._rawBits >> 14 < v7 >> 14);
  uint64_t v1 = *(void *)v0;
LABEL_93:
  unint64_t v51 = *(void *)(v1 + 16);
  if (v51 >= 2)
  {
    unint64_t v52 = 1;
    uint64_t v53 = 44;
    do
    {
      unint64_t v54 = *(void *)(v1 + 16);
      if (v52 >= v54)
      {
LABEL_111:
        unint64_t v64 = 675;
        goto LABEL_112;
      }
      if ((*(unsigned __int16 *)(v1 + 8 * v52 + 36) >> 3) < (*(unsigned __int16 *)(v1 + 8 * v52 + 28) >> 3))
      {
        unint64_t v55 = v52;
        uint64_t v56 = v53;
        while (1)
        {
          if (v55 >= v54) {
            goto LABEL_111;
          }
          unint64_t v57 = v55 - 1;
          if (v55 - 1 >= v54) {
            goto LABEL_111;
          }
          int v66 = *(_DWORD *)(v1 + v56 - 4);
          __int16 v58 = *(_WORD *)(v1 + v56);
          int v59 = *(_DWORD *)(v1 + v56 - 12);
          __int16 v60 = *(_WORD *)(v1 + v56 - 8);
          BOOL v61 = swift_isUniquelyReferenced_nonNull_native(v1);
          *(void *)uint64_t v0 = v1;
          if (!v61)
          {
            uint64_t v1 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(v1);
            *(void *)uint64_t v0 = v1;
          }
          if (v57 + 1 >= *(void *)(v1 + 16)) {
            break;
          }
          uint64_t v62 = (_WORD *)(v1 + v56);
          *((_DWORD *)v62 - _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v59;
          *uint64_t v62 = v60;
          *(void *)uint64_t v0 = v1;
          unint64_t v55 = v57;
          if (v57 >= *(void *)(v1 + 16)) {
            break;
          }
          *((_DWORD *)v62 - 3) = v66;
          *(v62 - 4) = v58;
          *(void *)uint64_t v0 = v1;
          if (!v57) {
            goto LABEL_97;
          }
          unint64_t v54 = *(void *)(v1 + 16);
          if (v57 >= v54) {
            goto LABEL_111;
          }
          uint64_t v63 = v1 + v56;
          v56 -= 8;
          if (((unsigned __int16)*(v62 - 4) >> 3) >= (*(unsigned __int16 *)(v63 - 16) >> 3)) {
            goto LABEL_97;
          }
        }
        unint64_t v64 = 688;
LABEL_112:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, v64, 0);
      }
LABEL_97:
      ++v52;
      v53 += 8;
    }
    while (v52 != v51);
    if (*(void *)(v1 + 16)) {
      goto LABEL_2;
    }
LABEL_95:
    uint64_t v4 = 0;
    *(unsigned char *)(v0 + 8) = 0;
    unsigned __int8 v3 = 1;
  }
  else
  {
    if (!v51) {
      goto LABEL_95;
    }
LABEL_2:
    if ((*(unsigned char *)(v0 + 8) & 1) == 0)
    {
      specialized MutableCollection<>.reverse()();
      *(unsigned char *)(v0 + 8) = 1;
    }
    uint64_t v2 = specialized RangeReplaceableCollection<>.removeLast()();
    unsigned __int8 v3 = 0;
    uint64_t v4 = v2 & 0xFFFFFFFFFFFFLL;
  }
LABEL_5:
  LOBYTE(v67) = v3;
  return v4 | ((unint64_t)v3 << 48);
}

Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional __swiftcall Unicode._InternalNFD.Iterator.next()()
{
  void (*v40)(void *__return_ptr, const char *, uint64_t);
  uint64_t v41;
  void v42[4];
  unint64_t v43;
  Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional result;

  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v5 = *(void *)(v0 + 16);
  uint64_t v4 = *(int ***)(v0 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v9 = (char *)&v33 - v8;
  if (!*(void *)(*(void *)v2 + 16))
  {
    *(unsigned char *)(v2 + 8) = 0;
    uint64_t v10 = *(int *)(v3 + 40);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated conformance descriptor for StringProtocol.StringProtocol.UnicodeScalarView: BidirectionalCollection);
    char v12 = (unint64_t *)(v2 + 16);
    unint64_t v13 = *(void *)(v2 + 16);
    uint64_t v14 = v2 + v10;
    uint64_t v15 = *(void *)(AssociatedConformanceWitness + 8);
    int v40 = *(void (**)(void *__return_ptr, const char *, uint64_t))(v15 + 72);
    unsigned int v41 = v15 + 72;
    v40(v42, AssociatedTypeWitness, v15);
    if (v13 >> 14 < v42[0] >> 14)
    {
      Swift::UInt64 v16 = *(uint64_t (**)(void *, unint64_t *, const char *, uint64_t))(v15 + 80);
      Swift::UInt64 v37 = (void (**)(char *, uint64_t, const char *))(v7 + 16);
      uint64_t v38 = v16;
      uint64_t v39 = v15 + 80;
      unint64_t v35 = (void (**)(char *, const char *))(v7 + 8);
      uint64_t v36 = v15 + 192;
      uint64_t v34 = (unint64_t *)(v2 + 16);
      while (1)
      {
        uint64_t v43 = v13;
        int64_t v17 = (void (*)(void *, void))v38(v42, &v43, AssociatedTypeWitness, v15);
        uint64_t v19 = *v18;
        v17(v42, 0);
        uint64_t v20 = 0;
        if (v19 >= 0xC0
          && (int NormData = _swift_stdlib_getNormData(v19),
              uint64_t v20 = NormData | ((v19 - 44032) >> 2 < 0xAE9),
              (NormData & 0x7F8) != 0))
        {
          int v21 = 0;
        }
        else
        {
          if (*(void *)(*(void *)v2 + 16)) {
            goto LABEL_22;
          }
          int v21 = 1;
        }
        (*v37)(v9, v14, AssociatedTypeWitness);
        (*(void (**)(unint64_t *, const char *, uint64_t))(v15 + 192))(v12, AssociatedTypeWitness, v15);
        (*v35)(v9, AssociatedTypeWitness);
        if ((v20 & 1) == 0) {
          break;
        }
        if (v19 <= 0xBF) {
          goto LABEL_13;
        }
        if ((v19 - 55204) > 0xFFFFD45B) {
          specialized Unicode._InternalNFD.Iterator.decomposeHangul(_:)(v19);
        }
        else {
          Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)((Swift::Unicode::Scalar)v19, (Swift::Unicode::_NormData)v20);
        }
LABEL_5:
        unint64_t v13 = *v12;
        v40(v42, AssociatedTypeWitness, v15);
        if (v13 >> 14 >= v42[0] >> 14) {
          goto LABEL_22;
        }
      }
      if (v21)
      {
        unsigned __int8 v31 = 0;
        uint64_t v32 = v19 | (v20 << 32);
        goto LABEL_26;
      }
LABEL_13:
      char v23 = *(__objc2_class ***)v2;
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*(void *)v2);
      *(void *)uint64_t v2 = v23;
      if (!isUniquelyReferenced_nonNull_native)
      {
        char v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v23[2]->isa + 1, 1, (uint64_t)v23);
        *(void *)uint64_t v2 = v23;
      }
      unint64_t v26 = (unint64_t)v23[2];
      unint64_t v25 = (unint64_t)v23[3];
      if (v26 >= v25 >> 1) {
        char v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v25 > 1), v26 + 1, 1, (uint64_t)v23);
      }
      v23[2] = (__objc2_class *)(v26 + 1);
      uint64_t v27 = &v23[v26];
      *((_DWORD *)v27 + 8) = v19;
      *((_WORD *)v27 + 18) = v20;
      *(void *)uint64_t v2 = v23;
      char v12 = v34;
      goto LABEL_5;
    }
LABEL_22:
    Unicode._NormDataBuffer.sort()();
    uint64_t v32 = *(void *)(*(void *)v2 + 16);
    if (!v32)
    {
      *(unsigned char *)(v2 + 8) = 0;
      unsigned __int8 v31 = 1;
      goto LABEL_26;
    }
  }
  if ((*(unsigned char *)(v2 + 8) & 1) == 0)
  {
    specialized MutableCollection<>.reverse()();
    *(unsigned char *)(v2 + 8) = 1;
  }
  uint64_t v29 = specialized RangeReplaceableCollection<>.removeLast()();
  unsigned __int8 v31 = 0;
  uint64_t v32 = v29 & 0xFFFFFFFFFFFFLL;
LABEL_26:
  LOBYTE(v42[0]) = v31;
  unint64_t v30 = v32 | ((unint64_t)v31 << 48);
  result.Swift::UInt32 value = (Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData)v30;
  result.is_nil = v22;
  return result;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._InternalNFC<A>.Iterator@<X0>(uint64_t a1@<X8>)
{
  *(Swift::Unicode::Scalar_optional *)&uint64_t result = Unicode._InternalNFC.Iterator.next()();
  *(_DWORD *)a1 = result;
  *(unsigned char *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t Unicode._InternalNFC.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  void (*v11)(uint64_t *__return_ptr, uint64_t *, uint64_t);
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  Class *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;

  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  Swift::String::Index v6 = type metadata accessor for Unicode._InternalNFD(0, v4, v5, a2);
  MEMORY[0x1F4188790](v6 - 1);
  uint64_t v8 = (char *)&v19 - v7;
  (*(void (**)(uint64_t, uint64_t))(v5 + 136))(v4, v5);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v5, v4, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness(v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated conformance descriptor for StringProtocol.StringProtocol.UnicodeScalarView: BidirectionalCollection)+ 8);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t))(v10 + 64);
  char v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v11(&v20, v12, v10);
  unint64_t v13 = v20;
  uint64_t v15 = a3 + *((int *)type metadata accessor for Unicode._InternalNFC.Iterator(0, v4, v5, v14) + 10);
  int64_t v17 = type metadata accessor for Unicode._InternalNFD.Iterator(0, v4, v5, v16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(v12 - 1) + 32))(v15 + *((int *)v17 + 10), v8, v12);
  *(void *)uint64_t v15 = &_swiftEmptyArrayStorage;
  *(unsigned char *)(v15 + 8) = 0;
  *(void *)(v15 + 16) = v13;
  *(void *)a3 = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t Unicode._InternalNFD.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void (*v8)(uint64_t *__return_ptr, uint64_t *, uint64_t);
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  Class *v12;
  uint64_t result;
  uint64_t v14;

  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v7 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated conformance descriptor for StringProtocol.StringProtocol.UnicodeScalarView: BidirectionalCollection)+ 8);
  uint64_t v8 = *(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t))(v7 + 64);
  unint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v8(&v14, v9, v7);
  uint64_t v10 = v14;
  char v12 = type metadata accessor for Unicode._InternalNFD.Iterator(0, v5, (uint64_t)v4, v11);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(v9 - 1) + 16))(a2 + *((int *)v12 + 10), v2, v9);
  *(void *)a2 = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = v10;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>(a1, a2, (void (*)(void))Unicode._InternalNFC.makeIterator());
}

__objc2_class **specialized Unicode._InternalNFD.Iterator.decomposeHangul(_:)(int a1)
{
  unsigned int v2 = a1 - 44032;
  unsigned int v3 = (a1 - 44032) / 0x24Cu;
  uint64_t v4 = *v1;
  uint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = v4;
  if ((result & 1) == 0)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v4 + 16) + 1, 1, v4);
    uint64_t v4 = (uint64_t)result;
    *uint64_t v1 = (uint64_t)result;
  }
  unint64_t v7 = *(void *)(v4 + 16);
  unint64_t v6 = *(void *)(v4 + 24);
  unint64_t v8 = v7 + 1;
  if (v7 >= v6 >> 1)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v6 > 1), v7 + 1, 1, v4);
    uint64_t v4 = (uint64_t)result;
  }
  *(void *)(v4 + 16) = v8;
  uint64_t v9 = v4 + 8 * v7;
  *(_DWORD *)(v9 + 32) = v3 + 4352;
  *(_WORD *)(v9 + 36) = 0;
  unsigned int v10 = (unsigned __int16)(v2 - 588 * v3) / 0x1Cu + 4449;
  *uint64_t v1 = v4;
  unint64_t v11 = *(void *)(v4 + 24);
  unint64_t v12 = v7 + 2;
  if ((uint64_t)(v7 + 2) > (uint64_t)(v11 >> 1))
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v11 > 1), v7 + 2, 1, v4);
    uint64_t v4 = (uint64_t)result;
  }
  *(void *)(v4 + 16) = v12;
  uint64_t v13 = v4 + 8 * v8;
  *(_DWORD *)(v13 + 32) = v10;
  *(_WORD *)(v13 + 36) = 4;
  *uint64_t v1 = v4;
  if (v2 % 0x1C)
  {
    unsigned int v14 = v2 % 0x1C + 4519;
    unint64_t v15 = *(void *)(v4 + 24);
    if ((uint64_t)(v7 + 3) > (uint64_t)(v15 >> 1))
    {
      uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v15 > 1), v7 + 3, 1, v4);
      uint64_t v4 = (uint64_t)result;
    }
    *(void *)(v4 + 16) = v7 + 3;
    uint64_t v16 = v4 + 8 * v12;
    *(_DWORD *)(v16 + 32) = v14;
    *(_WORD *)(v16 + 36) = 4;
    *uint64_t v1 = v4;
  }
  return result;
}

uint64_t specialized Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)(int a1, __int16 a2)
{
  uint64_t result = _swift_stdlib_getDecompositionEntry(a1);
  if ((result & 0x3FFFF) == a1)
  {
    uint64_t v6 = _swift_stdlib_nfd_decomp[(unint64_t)result >> 18];
    if (_swift_stdlib_nfd_decomp[(unint64_t)result >> 18])
    {
      unint64_t v7 = (char *)(((unint64_t)result >> 18) + 0x18163A0A9);
      uint64_t v8 = *v2;
      while (1)
      {
        unsigned int v9 = *v7;
        if (*v7 < 0)
        {
          switch(__clz(v9 ^ 0xFF))
          {
            case 0x1Au:
              unsigned int v9 = v7[1] & 0x3F | ((v9 & 0x1F) << 6);
              unint64_t v10 = 2;
              break;
            case 0x1Bu:
              unsigned int v9 = ((v9 & 0xF) << 12) | ((v7[1] & 0x3F) << 6) | v7[2] & 0x3F;
              unint64_t v10 = 3;
              break;
            case 0x1Cu:
              unsigned int v9 = ((v9 & 0xF) << 18) | ((v7[1] & 0x3F) << 12) | ((v7[2] & 0x3F) << 6) | v7[3] & 0x3F;
              unint64_t v10 = 4;
              break;
            default:
              goto LABEL_5;
          }
        }
        else
        {
LABEL_5:
          unint64_t v10 = 1;
        }
        BOOL v11 = v6 >= v10;
        v6 -= v10;
        if (!v11) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
        }
        if (v6 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
        }
        if (v9 > 0x2FF)
        {
          __int16 v12 = _swift_stdlib_getNormData(v9) | ((v9 - 44032) >> 2 < 0xAE9);
          uint64_t result = swift_isUniquelyReferenced_nonNull_native(v8);
          if ((result & 1) == 0)
          {
LABEL_20:
            uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v8 + 16) + 1, 1, v8);
            uint64_t v8 = result;
          }
        }
        else
        {
          uint64_t result = swift_isUniquelyReferenced_nonNull_native(v8);
          __int16 v12 = 0;
          if ((result & 1) == 0) {
            goto LABEL_20;
          }
        }
        unint64_t v14 = *(void *)(v8 + 16);
        unint64_t v13 = *(void *)(v8 + 24);
        if (v14 >= v13 >> 1)
        {
          uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v13 > 1), v14 + 1, 1, v8);
          uint64_t v8 = result;
        }
        v7 += v10;
        *(void *)(v8 + 16) = v14 + 1;
        uint64_t v15 = v8 + 8 * v14;
        *(_DWORD *)(v15 + 32) = v9;
        *(_WORD *)(v15 + 36) = v12;
        if (v6 <= 0) {
          goto LABEL_26;
        }
      }
    }
  }
  else
  {
    uint64_t v8 = *v2;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v2);
    uint64_t *v2 = v8;
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v8 + 16) + 1, 1, v8);
      uint64_t v8 = result;
      uint64_t *v2 = result;
    }
    unint64_t v17 = *(void *)(v8 + 16);
    unint64_t v16 = *(void *)(v8 + 24);
    if (v17 >= v16 >> 1)
    {
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v16 > 1), v17 + 1, 1, v8);
      uint64_t v8 = result;
    }
    *(void *)(v8 + 16) = v17 + 1;
    uint64_t v18 = v8 + 8 * v17;
    *(_DWORD *)(v18 + 32) = a1;
    *(_WORD *)(v18 + 36) = a2;
LABEL_26:
    uint64_t *v2 = v8;
  }
  return result;
}

Swift::Void __swiftcall Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)(Swift::Unicode::Scalar _, Swift::Unicode::_NormData with)
{
  unsigned int DecompositionEntry = _swift_stdlib_getDecompositionEntry(_._value);
  if ((DecompositionEntry & 0x3FFFF) == _._value)
  {
    uint64_t v7 = _swift_stdlib_nfd_decomp[(unint64_t)DecompositionEntry >> 18];
    if (_swift_stdlib_nfd_decomp[(unint64_t)DecompositionEntry >> 18])
    {
      uint64_t v8 = ((unint64_t)DecompositionEntry >> 18) + 0x18163A0A9;
      unsigned int v9 = (__objc2_class **)*v2;
      while (1)
      {
        unsigned int v10 = _decodeScalar(_:startingAt:)(v8, v6, 0);
        if (v7 < v11) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
        }
        if (v8) {
          v8 += v11;
        }
        else {
          uint64_t v8 = 0;
        }
        v7 -= v11;
        if (v7 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
        }
        unsigned int v12 = v10;
        if (v7 && !v8) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer has a nil start and nonzero count", 53, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x541uLL, 0);
        }
        if (v10 >= 0x300)
        {
          __int16 v13 = _swift_stdlib_getNormData(v10) | ((v10 - 44032) >> 2 < 0xAE9);
          if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v9)) {
LABEL_18:
          }
            unsigned int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v9[2]->isa + 1, 1, (uint64_t)v9);
        }
        else
        {
          __int16 v13 = 0;
          if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v9)) {
            goto LABEL_18;
          }
        }
        unint64_t v15 = (unint64_t)v9[2];
        unint64_t v14 = (unint64_t)v9[3];
        if (v15 >= v14 >> 1) {
          unsigned int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v14 > 1), v15 + 1, 1, (uint64_t)v9);
        }
        v9[2] = (__objc2_class *)(v15 + 1);
        unint64_t v16 = &v9[v15];
        *((_DWORD *)v16 + 8) = v12;
        *((_WORD *)v16 + 18) = v13;
        if (!v7) {
          goto LABEL_24;
        }
      }
    }
  }
  else
  {
    unsigned int v9 = (__objc2_class **)*v2;
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
    uint64_t *v2 = (uint64_t)v9;
    if (!isUniquelyReferenced_nonNull_native)
    {
      unsigned int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v9[2]->isa + 1, 1, (uint64_t)v9);
      uint64_t *v2 = (uint64_t)v9;
    }
    unint64_t v19 = (unint64_t)v9[2];
    unint64_t v18 = (unint64_t)v9[3];
    if (v19 >= v18 >> 1) {
      unsigned int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v18 > 1), v19 + 1, 1, (uint64_t)v9);
    }
    v9[2] = (__objc2_class *)(v19 + 1);
    uint64_t v20 = &v9[v19];
    *((Swift::Unicode::Scalar *)v20 + 8) = _;
    *((Swift::Unicode::_NormData *)v20 + 18) = with;
LABEL_24:
    uint64_t *v2 = (uint64_t)v9;
  }
}

uint64_t static UInt32./ infix(_:_:)(unsigned int a1, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  }
  return a1 / a2;
}

uint64_t _decodeScalar(_:startingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(char *)(a1 + a3);
  uint64_t result = *(unsigned __int8 *)(a1 + a3);
  if (v4 < 0)
  {
    switch(__clz(result ^ 0xFF))
    {
      case 0x1Au:
        uint64_t result = *(unsigned char *)(a3 + a1 + 1) & 0x3F | ((result & 0x1F) << 6);
        break;
      case 0x1Bu:
        uint64_t result = ((result & 0xF) << 12) | ((*(unsigned char *)(a3 + a1 + 1) & 0x3F) << 6) | *(unsigned char *)(a3 + a1 + 2) & 0x3F;
        break;
      case 0x1Cu:
        uint64_t result = ((result & 0xF) << 18) | ((*(unsigned char *)(a3 + a1 + 1) & 0x3F) << 12) | ((*(unsigned char *)(a3 + a1 + 2) & 0x3F) << 6) | *(unsigned char *)(a3 + a1 + 3) & 0x3F;
        break;
      default:
        return result;
    }
  }
  return result;
}

BOOL static String.Index.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >> 14 < a2 >> 14;
}

Swift::Void __swiftcall Unicode._NormDataBuffer.sort()()
{
  uint64_t v1 = (__objc2_class **)*v0;
  unint64_t v2 = *(void *)(*v0 + 16);
  if (v2 >= 2)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
    *uint64_t v0 = (uint64_t)v1;
    if (!isUniquelyReferenced_nonNull_native) {
      uint64_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v1);
    }
    *uint64_t v0 = (uint64_t)v1;
    int v4 = (_WORD *)v1 + 22;
    for (unint64_t i = 1; i != v2; ++i)
    {
      unint64_t v6 = (unint64_t)v1[2];
      if (i >= v6)
      {
LABEL_16:
        unint64_t v14 = 675;
        goto LABEL_17;
      }
      unint64_t v7 = i - 1;
      if ((WORD2(v1[i + 4]) >> 3) < (WORD2(v1[i + 3]) >> 3))
      {
        uint64_t v8 = v4;
        while (1)
        {
          if (v7 + 1 >= v6 || v7 >= v6) {
            goto LABEL_16;
          }
          int v9 = *((_DWORD *)v8 - 1);
          __int16 v10 = *v8;
          __int16 v11 = *(v8 - 4);
          *((_DWORD *)v8 - _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = *((_DWORD *)v8 - 3);
          *uint64_t v8 = v11;
          if (v7 >= (unint64_t)v1[2]) {
            break;
          }
          *((_DWORD *)v8 - 3) = v9;
          *(v8 - 4) = v10;
          if (!v7) {
            goto LABEL_5;
          }
          unint64_t v6 = (unint64_t)v1[2];
          if (v7 >= v6) {
            goto LABEL_16;
          }
          unsigned int v12 = (unsigned __int16)*(v8 - 4);
          unsigned int v13 = (unsigned __int16)*(v8 - 8);
          v8 -= 4;
          --v7;
          if ((v12 >> 3) >= (v13 >> 3)) {
            goto LABEL_5;
          }
        }
        unint64_t v14 = 688;
LABEL_17:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, v14, 0);
      }
LABEL_5:
      v4 += 4;
    }
    *uint64_t v0 = (uint64_t)v1;
  }
}

uint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._InternalNFD<A>.Iterator@<X0>(uint64_t a1@<X8>)
{
  Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional v4 = Unicode._InternalNFD.Iterator.next()();
  *(_DWORD *)a1 = v4.value.scalar._value;
  *(_WORD *)(a1 + 4) = v4.value.normData.rawValue;
  *(unsigned char *)(a1 + 6) = v2 & 1;
  LODWORD(result) = v4.value.scalar._value;
  WORD2(result) = v4.value.normData.rawValue;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFD<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>(a1, a2, (void (*)(void))Unicode._InternalNFD.makeIterator());
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>(uint64_t a1, uint64_t a2, void (*a3)(void))
{
  a3();
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8);

  return v5(v3, a1);
}

uint64_t ObjectIdentifier.debugDescription.getter(unint64_t a1)
{
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(20);
  uint64_t v5 = v3;
  uint64_t v6 = v4;
  uint64_t v186 = v3;
  unint64_t v187 = v4;
  uint64_t v7 = HIBYTE(v4) & 0xF;
  unint64_t i = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000) != 0) {
    Swift::Int v9 = HIBYTE(v4) & 0xF;
  }
  else {
    Swift::Int v9 = v3 & 0xFFFFFFFFFFFFLL;
  }
  __int16 v10 = "ObjectIdentifier(";
  if (!v9 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v4);
    uint64_t v186 = 0xD000000000000011;
    unint64_t v187 = 0x80000001816DEE30 | 0x8000000000000000;
    goto LABEL_86;
  }
  if ((v4 & 0x2000000000000000) != 0 && (0x80000001816DEE30 & 0x2000000000000000) != 0)
  {
    unint64_t v11 = v7 + ((0x80000001816DEE30 >> 56) & 0xF);
    if (v11 <= 0xF)
    {
      unint64_t i = 0x80000001816DEE30;
      unint64_t v30 = (0x80000001816DEE30 >> 56) & 0xF;
      if (v30)
      {
        char v54 = 0;
        uint64_t v55 = 0;
        unint64_t v31 = v4;
        do
        {
          uint64_t v56 = v7 + v55;
          uint64_t v57 = v55 + 1;
          unint64_t v58 = 0x80000001816DEE30 | 0x8000000000000000;
          if (v55 < 8) {
            unint64_t v58 = 0xD000000000000011;
          }
          unint64_t v59 = v58 >> (v54 & 0x38);
          char v60 = (8 * v7 + v54) & 0x38;
          uint64_t v61 = (-255 << v60) - 1;
          unint64_t v62 = (unint64_t)v59 << v60;
          unint64_t v63 = v62 | v61 & v31;
          unint64_t v64 = v62 | v61 & v5;
          if (v56 < 8) {
            uint64_t v5 = v64;
          }
          else {
            unint64_t v31 = v63;
          }
          v54 += 8;
          uint64_t v55 = v57;
        }
        while (v30 != v57);
      }
      else
      {
        unint64_t v31 = v4;
      }
      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0x80000001816DEE30 | 0x8000000000000000);
      unint64_t v65 = 0xA000000000000000;
      if (!(v5 & 0x8080808080808080 | v31 & 0x80808080808080)) {
        unint64_t v65 = 0xE000000000000000;
      }
      unint64_t v53 = v65 & 0xFF00000000000000 | (v11 << 56) | v31 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_85;
    }
  }
  uint64_t v12 = 0x80000001816DEE30 | 0x8000000000000000;
  if ((0x80000001816DEE30 & 0x2000000000000000) != 0) {
    uint64_t v13 = (0x80000001816DEE30 >> 56) & 0xF;
  }
  else {
    uint64_t v13 = 17;
  }
  swift_bridgeObjectRetain_n(0x80000001816DEE30 | 0x8000000000000000, 2);
  if ((0x80000001816DEE30 & 0x1000000000000000) != 0) {
    goto LABEL_227;
  }
  swift_bridgeObjectRetain_n(0x80000001816DEE30 | 0x8000000000000000, 4);
  Swift::Int v1 = v13;
  if ((v6 & 0x1000000000000000) != 0) {
    goto LABEL_230;
  }
LABEL_14:
  BOOL v14 = __OFADD__(v9, v1);
  v9 += v1;
  if (v14) {
    goto LABEL_232;
  }
LABEL_15:
  uint64_t v15 = v5 & ~v6;
  if ((v15 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v16 = _StringGuts.nativeUnusedCapacity.getter(v5, v6);
    if (v17) {
      goto LABEL_255;
    }
    if (v9 > 15) {
      goto LABEL_23;
    }
    if ((v6 & 0x2000000000000000) == 0)
    {
      if (v16 < v1)
      {
LABEL_48:
        swift_bridgeObjectRelease_n((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000, 5);
        if ((v6 & 0x1000000000000000) == 0)
        {
          if ((v5 & 0x1000000000000000) != 0)
          {
            uint64_t v29 = (unsigned __int8 *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            uint64_t v29 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v6);
            unint64_t i = v175;
          }
          swift_bridgeObjectRetain(v6);
          closure #1 in _StringGuts._convertedToSmall()(v29, i, &v185);
          swift_bridgeObjectRelease(v6);
          unint64_t i = *((void *)&v185 + 1);
          uint64_t v5 = v185;
          goto LABEL_57;
        }
        goto LABEL_250;
      }
LABEL_23:
      int64_t v18 = _StringGuts.nativeUnusedCapacity.getter(v5, v6);
      BOOL v21 = (v19 & 1) == 0 && v18 >= v1;
      if ((v15 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v21)
        {
LABEL_41:
          unint64_t i = (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000;
          swift_bridgeObjectRelease_n(i, 4);
          if (((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) & 0x1000000000000000) != 0)
          {
            swift_bridgeObjectRelease((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
            _StringGuts._foreignAppendInPlace(_:)(0xD000000000000011, (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000, 0, v13);
          }
          else
          {
            char v26 = ((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) & 0x2000000000000000) == 0
               || (i & 0x4000000000000000) != 0;
            swift_bridgeObjectRelease((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
            if (((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) & 0x2000000000000000) != 0)
            {
              unint64_t i = (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000;
              swift_bridgeObjectRelease(i);
              *(void *)&long long v185 = 0xD000000000000011;
              *((void *)&v185 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) & 0xFFFFFFFFFFFFFFLL;
              uint64_t v104 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v13, (uint64_t)&v185, ((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) >> 56) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v104, v105, v26);
              swift_bridgeObjectRelease(i);
              goto LABEL_86;
            }
            unint64_t i = (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000;
            uint64_t v27 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v13, ((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) & 0xFFFFFFFFFFFFFFFLL) + 32, 17);
            _StringGuts.appendInPlace(_:isASCII:)(v27, v28, v26);
          }
          swift_bridgeObjectRelease_n(i, 2);
          goto LABEL_86;
        }
LABEL_34:
        uint64_t v22 = _StringGuts.nativeCapacity.getter(v5, v6);
        if (v23) {
          uint64_t v24 = 0;
        }
        else {
          uint64_t v24 = v22;
        }
        if (v24 + 0x4000000000000000 < 0) {
          goto LABEL_249;
        }
        uint64_t v25 = 2 * v24;
        if (v25 > v9) {
          Swift::Int v9 = v25;
        }
      }
      else if (!v21)
      {
        goto LABEL_34;
      }
      _StringGuts.grow(_:)(v9);
      goto LABEL_41;
    }
  }
  else
  {
    if (v9 > 15) {
      goto LABEL_23;
    }
    if ((v6 & 0x2000000000000000) == 0) {
      goto LABEL_48;
    }
  }
  swift_bridgeObjectRelease_n((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000, 5);
  for (unint64_t i = v6; ; unint64_t i = v174)
  {
LABEL_57:
    v32._Swift::UInt64 rawBits = (v13 << 16) | 1;
    v33._Swift::UInt64 rawBits = 1;
    v34._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v33, v32, 0xD000000000000011, (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    if (v34._rawBits < 0x10000) {
      v34._rawBits |= 3;
    }
    unint64_t v36 = specialized String.init(_:)(v34, v35, 0xD000000000000011, (unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    unint64_t v38 = v37;
    swift_bridgeObjectRelease((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    if ((v38 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v38);
    }
    else if ((v38 & 0x1000000000000000) != 0)
    {
      unint64_t v36 = _StringGuts._foreignConvertedToSmall()(v36, v38);
      unint64_t v183 = v182;
      swift_bridgeObjectRelease(v38);
      unint64_t v38 = v183;
    }
    else
    {
      if ((v36 & 0x1000000000000000) != 0)
      {
        unint64_t v172 = (unsigned __int8 *)((v38 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v173 = v36 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        unint64_t v172 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v36, v38);
      }
      closure #1 in _StringGuts._convertedToSmall()(v172, v173, &v185);
      swift_bridgeObjectRelease(v38);
      unint64_t v38 = *((void *)&v185 + 1);
      unint64_t v36 = v185;
    }
    uint64_t v39 = HIBYTE(i) & 0xF;
    uint64_t v40 = HIBYTE(v38) & 0xF;
    Swift::Int v1 = v40 + v39;
    if ((unint64_t)(v40 + v39) > 0xF) {
      goto LABEL_254;
    }
    if (v40)
    {
      char v41 = 0;
      unint64_t v42 = 0;
      do
      {
        unint64_t v43 = v39 + v42;
        unint64_t v44 = v42 + 1;
        if (v42 >= 8) {
          unint64_t v45 = v38;
        }
        else {
          unint64_t v45 = v36;
        }
        unint64_t v46 = v45 >> (v41 & 0x38);
        char v47 = (8 * v39 + v41) & 0x38;
        uint64_t v48 = (-255 << v47) - 1;
        unint64_t v49 = (unint64_t)v46 << v47;
        unint64_t v50 = v49 | v48 & i;
        unint64_t v51 = v49 | v48 & v5;
        if (v43 < 8) {
          uint64_t v5 = v51;
        }
        else {
          unint64_t i = v50;
        }
        v41 += 8;
        unint64_t v42 = v44;
      }
      while (v40 != v44);
    }
    swift_bridgeObjectRelease(v6);
    swift_bridgeObjectRelease((unint64_t)(v10 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    unint64_t v52 = 0xA000000000000000;
    if (!(v5 & 0x8080808080808080 | i & 0x80808080808080)) {
      unint64_t v52 = 0xE000000000000000;
    }
    unint64_t v53 = v52 & 0xFF00000000000000 | (v1 << 56) | i & 0xFFFFFFFFFFFFFFLL;
LABEL_85:
    uint64_t v186 = v5;
    unint64_t v187 = v53;
LABEL_86:
    Swift::String v66 = _uint64ToString(_:radix:uppercase:)(a1, 16, 0);
    unint64_t countAndFlagsBits = v66._countAndFlagsBits;
    unint64_t object = v66._object;
    if (((uint64_t)v66._object & 0x1000000000000000) != 0)
    {
      Swift::Int v70 = String.UTF16View._foreignCount()();
    }
    else
    {
      unint64_t v69 = ((unint64_t)v66._object >> 56) & 0xF;
      if (((uint64_t)v66._object & 0x2000000000000000) == 0) {
        unint64_t v69 = v66._countAndFlagsBits;
      }
      Swift::Int v70 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v69 << 16) | 7));
    }
    Swift::Int v71 = 16 - v70;
    if (__OFSUB__(16, v70))
    {
      __break(1u);
LABEL_220:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    if (v71 < 0) {
      goto LABEL_220;
    }
    if (v71)
    {
      Swift::Int v72 = v70 - 16;
      do
      {
        unint64_t countAndFlagsBits = specialized static String.+ infix(_:_:)(0x30uLL, 0xE100000000000000, countAndFlagsBits, (unint64_t)object);
        uint64_t v74 = v73;
        swift_bridgeObjectRelease(0xE100000000000000);
        swift_bridgeObjectRelease((uint64_t)object);
        unint64_t object = v74;
      }
      while (!__CFADD__(v72++, 1));
    }
    else
    {
      uint64_t v74 = v66._object;
    }
    uint64_t v5 = specialized static String.+ infix(_:_:)(0x7830uLL, 0xE200000000000000, countAndFlagsBits, (unint64_t)v74);
    a1 = v76;
    swift_bridgeObjectRelease(0xE200000000000000);
    swift_bridgeObjectRelease((uint64_t)v74);
    uint64_t v6 = v186;
    Swift::Int v9 = v187;
    unint64_t v77 = HIBYTE(v187) & 0xF;
    if ((v187 & 0x2000000000000000) != 0) {
      unint64_t v78 = HIBYTE(v187) & 0xF;
    }
    else {
      unint64_t v78 = v186 & 0xFFFFFFFFFFFFLL;
    }
    if (!v78 && (v186 & ~v187 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v187);
      uint64_t v186 = v5;
      unint64_t v187 = a1;
      goto LABEL_187;
    }
    uint64_t v13 = a1 & 0x2000000000000000;
    unint64_t i = HIBYTE(a1) & 0xF;
    if ((v187 & 0x2000000000000000) != 0 && v13)
    {
      unint64_t v79 = v77 + i;
      if (v77 + i <= 0xF)
      {
        if (i)
        {
          char v93 = 0;
          unint64_t v94 = 0;
          Swift::Int v1 = v187;
          do
          {
            unint64_t v95 = v77 + v94;
            unint64_t v96 = v94 + 1;
            if (v94 >= 8) {
              unint64_t v97 = a1;
            }
            else {
              unint64_t v97 = v5;
            }
            unint64_t v98 = v97 >> (v93 & 0x38);
            char v99 = (8 * v77 + v93) & 0x38;
            uint64_t v100 = (-255 << v99) - 1;
            unint64_t v101 = (unint64_t)v98 << v99;
            Swift::Int v102 = v101 | v100 & v1;
            unint64_t v103 = v101 | v100 & v6;
            if (v95 < 8) {
              uint64_t v6 = v103;
            }
            else {
              Swift::Int v1 = v102;
            }
            v93 += 8;
            unint64_t v94 = v96;
          }
          while (i != v96);
        }
        else
        {
          Swift::Int v1 = v187;
        }
        swift_bridgeObjectRelease(v187);
        swift_bridgeObjectRelease(a1);
        unint64_t v132 = 0xA000000000000000;
        if (!(v6 & 0x8080808080808080 | v1 & 0x80808080808080)) {
          unint64_t v132 = 0xE000000000000000;
        }
        uint64_t v186 = v6;
        unint64_t v187 = v132 & 0xFF00000000000000 | (v79 << 56) | v1 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_187;
      }
      uint64_t v13 = 1;
    }
    Swift::Int v1 = v13 ? HIBYTE(a1) & 0xF : v5 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a1, 2);
    if ((a1 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(a1, 5);
      v157._Swift::UInt64 rawBits = 1;
      v158._Swift::UInt64 rawBits = (v1 << 16) | 1;
      v159._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v157, v158, v5, a1);
      if (v159._rawBits < 0x10000) {
        v159._rawBits |= 3;
      }
      __int16 v10 = (const char *)specialized Collection.count.getter(v159, v160, v5, a1);
      swift_bridgeObjectRelease(a1);
      if ((v9 & 0x1000000000000000) == 0)
      {
LABEL_112:
        BOOL v14 = __OFADD__(v78, v10);
        uint64_t v12 = (uint64_t)&v10[v78];
        if (v14) {
          goto LABEL_226;
        }
        goto LABEL_113;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(a1, 4);
      __int16 v10 = (const char *)v1;
      if ((v9 & 0x1000000000000000) == 0) {
        goto LABEL_112;
      }
    }
    Swift::Int v161 = String.UTF8View._foreignCount()();
    uint64_t v12 = (uint64_t)&v10[v161];
    if (__OFADD__(v161, v10))
    {
LABEL_226:
      __break(1u);
LABEL_227:
      swift_bridgeObjectRetain_n(v12, 5);
      v162._Swift::UInt64 rawBits = 1;
      v163._Swift::UInt64 rawBits = (v13 << 16) | 1;
      v164._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v162, v163, 0xD000000000000011, v12);
      if (v164._rawBits < 0x10000) {
        v164._rawBits |= 3;
      }
      Swift::Int v1 = specialized Collection.count.getter(v164, v165, 0xD000000000000011, v12);
      swift_bridgeObjectRelease(v12);
      if ((v6 & 0x1000000000000000) != 0)
      {
LABEL_230:
        Swift::Int v166 = String.UTF8View._foreignCount()();
        Swift::Int v9 = v166 + v1;
        if (!__OFADD__(v166, v1)) {
          goto LABEL_15;
        }
LABEL_232:
        __break(1u);
        goto LABEL_233;
      }
      goto LABEL_14;
    }
LABEL_113:
    if ((v6 & ~v9 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL)) {
      break;
    }
    uint64_t v184 = v5 & 0xFFFFFFFFFFFFLL;
    uint64_t v80 = v186;
    uint64_t v6 = v187;
    int64_t v81 = _StringGuts.nativeUnusedCapacity.getter(v186, v187);
    if (v82) {
      goto LABEL_255;
    }
    if (v12 <= 15)
    {
      if ((v6 & 0x2000000000000000) != 0)
      {
        int v92 = 0;
        Swift::Int v9 = v6;
        goto LABEL_165;
      }
      Swift::Int v9 = v6;
      if (v81 < (uint64_t)v10) {
        goto LABEL_145;
      }
    }
LABEL_122:
    int64_t v83 = _StringGuts.nativeUnusedCapacity.getter(v80, v6);
    Swift::Int v9 = (v84 & 1) == 0 && v83 >= (uint64_t)v10;
    if ((v80 & ~v6 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v9) {
        goto LABEL_140;
      }
    }
    else if (v9)
    {
      goto LABEL_139;
    }
    uint64_t v86 = _StringGuts.nativeCapacity.getter(v80, v6);
    if (v87) {
      uint64_t v88 = 0;
    }
    else {
      uint64_t v88 = v86;
    }
    if (v88 + 0x4000000000000000 >= 0)
    {
      uint64_t v89 = 2 * v88;
      if (v89 > v12) {
        uint64_t v12 = v89;
      }
LABEL_139:
      _StringGuts.grow(_:)(v12);
LABEL_140:
      swift_bridgeObjectRelease_n(a1, 4);
      if ((a1 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(a1);
        _StringGuts._foreignAppendInPlace(_:)(v5, a1, 0, v1);
      }
      else
      {
        if (v13)
        {
          swift_bridgeObjectRelease_n(a1, 2);
          *(void *)&long long v185 = v5;
          *((void *)&v185 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a1 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v90 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, i, (uint64_t)&v185, i);
          _StringGuts.appendInPlace(_:isASCII:)(v90, v91, (a1 & 0x4000000000000000) != 0);
          swift_bridgeObjectRelease(a1);
          goto LABEL_187;
        }
        if ((v5 & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRelease(a1);
          id v106 = (id)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v107 = v184;
          uint64_t v108 = v184;
        }
        else
        {
          id v106 = _StringObject.sharedUTF8.getter(v5, a1);
          uint64_t v108 = v176;
          swift_bridgeObjectRelease(a1);
          if (v108 < v184) {
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
          }
          uint64_t v107 = v184;
        }
        int v109 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v107, (uint64_t)v106, v108);
        _StringGuts.appendInPlace(_:isASCII:)(v109, v110, v5 < 0);
      }
      swift_bridgeObjectRelease_n(a1, 2);
      goto LABEL_187;
    }
    __break(1u);
LABEL_249:
    __break(1u);
LABEL_250:
    uint64_t v5 = _StringGuts._foreignConvertedToSmall()(v5, v6);
  }
  if (v12 >= 16)
  {
    uint64_t v184 = v5 & 0xFFFFFFFFFFFFLL;
    uint64_t v80 = v186;
    uint64_t v6 = v187;
    goto LABEL_122;
  }
  Swift::Int v9 = v187;
  if ((v187 & 0x2000000000000000) != 0)
  {
    int v92 = 0;
    uint64_t v6 = v187;
  }
  else
  {
    uint64_t v6 = v187;
LABEL_145:
    int v92 = 1;
  }
LABEL_165:
  swift_bridgeObjectRelease_n(a1, 5);
  unint64_t i = v186;
  if (v92) {
    goto LABEL_236;
  }
  while (1)
  {
    v111._Swift::UInt64 rawBits = (v1 << 16) | 1;
    v112._Swift::UInt64 rawBits = 1;
    v113._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v112, v111, v5, a1);
    if (v113._rawBits < 0x10000) {
      v113._rawBits |= 3;
    }
    unint64_t v115 = specialized String.init(_:)(v113, v114, v5, a1);
    unint64_t v117 = v116;
    swift_bridgeObjectRelease(a1);
    if ((v117 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v117);
    }
    else if ((v117 & 0x1000000000000000) != 0)
    {
      unint64_t v115 = _StringGuts._foreignConvertedToSmall()(v115, v117);
      unint64_t v180 = v179;
      swift_bridgeObjectRelease(v117);
      unint64_t v117 = v180;
    }
    else
    {
      if ((v115 & 0x1000000000000000) != 0)
      {
        char v170 = (unsigned __int8 *)((v117 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v171 = v115 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        char v170 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v115, v117);
      }
      closure #1 in _StringGuts._convertedToSmall()(v170, v171, &v185);
      swift_bridgeObjectRelease(v117);
      unint64_t v117 = *((void *)&v185 + 1);
      unint64_t v115 = v185;
    }
    uint64_t v118 = HIBYTE(v9) & 0xF;
    uint64_t v119 = HIBYTE(v117) & 0xF;
    Swift::Int v1 = v119 + v118;
    if ((unint64_t)(v119 + v118) > 0xF) {
      goto LABEL_254;
    }
    if (v119)
    {
      char v120 = 0;
      unint64_t v121 = 0;
      do
      {
        unint64_t v122 = v118 + v121;
        unint64_t v123 = v121 + 1;
        if (v121 >= 8) {
          unint64_t v124 = v117;
        }
        else {
          unint64_t v124 = v115;
        }
        unint64_t v125 = v124 >> (v120 & 0x38);
        char v126 = (8 * v118 + v120) & 0x38;
        uint64_t v127 = (-255 << v126) - 1;
        unint64_t v128 = (unint64_t)v125 << v126;
        Swift::Int v129 = v128 | v127 & v9;
        unint64_t v130 = v128 | v127 & i;
        if (v122 < 8) {
          unint64_t i = v130;
        }
        else {
          Swift::Int v9 = v129;
        }
        v120 += 8;
        unint64_t v121 = v123;
      }
      while (v119 != v123);
    }
    swift_bridgeObjectRelease(v6);
    swift_bridgeObjectRelease(a1);
    unint64_t v131 = 0xA000000000000000;
    if (!(i & 0x8080808080808080 | v9 & 0x80808080808080)) {
      unint64_t v131 = 0xE000000000000000;
    }
    uint64_t v186 = i;
    unint64_t v187 = v131 & 0xFF00000000000000 | (v1 << 56) | v9 & 0xFFFFFFFFFFFFFFLL;
LABEL_187:
    uint64_t v6 = v186;
    a1 = v187;
    unint64_t v133 = HIBYTE(v187) & 0xF;
    if ((v187 & 0x2000000000000000) != 0) {
      unint64_t v134 = HIBYTE(v187) & 0xF;
    }
    else {
      unint64_t v134 = v186 & 0xFFFFFFFFFFFFLL;
    }
    if (!v134 && (v186 & ~v187 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v187);
      return 41;
    }
    if ((v187 & 0x2000000000000000) != 0 && v133 != 15) {
      break;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((a1 & 0x1000000000000000) != 0)
    {
LABEL_233:
      Swift::Int v167 = String.UTF8View._foreignCount()();
      uint64_t v5 = v167 + 1;
      if (!__OFADD__(v167, 1))
      {
LABEL_199:
        if ((v6 & ~a1 & 0x2000000000000000) == 0
          || !swift_isUniquelyReferenced_nonNull_native(a1 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v5 <= 15) {
            goto LABEL_210;
          }
          goto LABEL_215;
        }
        int64_t v135 = _StringGuts.nativeUnusedCapacity.getter(v6, a1);
        if ((v136 & 1) == 0)
        {
          BOOL v138 = (a1 & 0x2000000000000000) == 0 && v135 > 0;
          if (v5 <= 15 && !v138)
          {
LABEL_210:
            swift_bridgeObjectRelease_n(0xE100000000000000, 5);
            swift_bridgeObjectRetain(a1);
            unint64_t v139 = _StringGuts._convertedToSmall()(v6, a1);
            unint64_t v141 = v140;
            swift_bridgeObjectRelease(a1);
            v142._Swift::UInt64 rawBits = 1;
            v143._Swift::UInt64 rawBits = 65537;
            v144._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v142, v143, 0x29uLL, 0xE100000000000000);
            if (v144._rawBits < 0x10000) {
              v144._rawBits |= 3;
            }
            unint64_t v146 = specialized String.init(_:)(v144, v145, 0x29uLL, 0xE100000000000000);
            unint64_t v148 = v147;
            swift_bridgeObjectRelease(0xE100000000000000);
            unint64_t v149 = _StringGuts._convertedToSmall()(v146, v148);
            unint64_t v151 = v150;
            swift_bridgeObjectRelease(v148);
            unint64_t v152 = specialized _SmallString.init(_:appending:)(v139, v141, v149, v151);
            if ((v153 & 1) == 0)
            {
              uint64_t v6 = v152;
              swift_bridgeObjectRelease(a1);
              swift_bridgeObjectRelease(0xE100000000000000);
              return v6;
            }
LABEL_254:
            unint64_t v177 = 266;
LABEL_256:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v177, 0);
          }
LABEL_215:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v5, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v185 = xmmword_18162ADC0;
          uint64_t v154 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v185, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v154, v155, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v186;
        }
LABEL_255:
        unint64_t v177 = 258;
        goto LABEL_256;
      }
    }
    else
    {
      BOOL v14 = __OFADD__(v134, 1);
      uint64_t v5 = v134 + 1;
      if (!v14) {
        goto LABEL_199;
      }
    }
    __break(1u);
LABEL_236:
    if ((v9 & 0x1000000000000000) != 0)
    {
      unint64_t i = _StringGuts._foreignConvertedToSmall()(i, v6);
      Swift::Int v9 = v178;
    }
    else
    {
      if ((i & 0x1000000000000000) != 0)
      {
        unint64_t v168 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v169 = i & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        unint64_t v168 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(i, v6);
        uint64_t v169 = v181;
      }
      swift_bridgeObjectRetain(v6);
      closure #1 in _StringGuts._convertedToSmall()(v168, v169, &v185);
      swift_bridgeObjectRelease(v6);
      Swift::Int v9 = *((void *)&v185 + 1);
      unint64_t i = v185;
    }
  }
  if (v133 < 8) {
    uint64_t v6 = (41 << (8 * (HIBYTE(v187) & 7u))) | ((-255 << (8 * (HIBYTE(v187) & 7u))) - 1) & v186;
  }
  swift_bridgeObjectRelease(v187);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v6;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance ObjectIdentifier()
{
  return ObjectIdentifier.debugDescription.getter(*v0);
}

BOOL static ObjectIdentifier.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 < a2;
}

BOOL static UInt.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance ObjectIdentifier(void *a1, void *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance ObjectIdentifier(void *a1, void *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance ObjectIdentifier(void *a1, void *a2)
{
  return *a2 < *a1;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance ObjectIdentifier()
{
  return specialized static Hasher._hash(seed:_:)(0, *v0);
}

void protocol witness for Hashable.hash(into:) in conformance ObjectIdentifier()
{
  Hasher._combine(_:)(*v0);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance ObjectIdentifier(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(a1, *v1);
}

uint64_t Optional.init(nilLiteral:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56))(a2, 1, 1, a1);
}

uint64_t _sxSgs23ExpressibleByNilLiteralsRi_zrlsABP03nilD0xyt_tcfCTW@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 56))(a2, 1, 1);
}

uint64_t Optional.map<A>(_:)@<X0>(void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  char v19 = a1;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  unint64_t v11 = (char *)&v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v14 + 16))(v13, v15);
  uint64_t v16 = 1;
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v13, 1, v7) != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v11, v13, v7);
    v19(v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
    if (v4) {
      return result;
    }
    uint64_t v16 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56))(a4, v16, 1, a3);
}

uint64_t Optional.flatMap<A>(_:)@<X0>(void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  unint64_t v11 = (char *)v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v14 + 16))(v13, v15);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v13, 1, v7) == 1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56))(a4, 1, 1, a3);
  }
  (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v11, v13, v7);
  a1(v11);
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
}

uint64_t Optional.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = (char *)&v49[-2] - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v3);
  uint64_t v7 = (char *)&v49[-2] - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v8 + 16))(v7);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v2 + 48))(v7, 1, v1) == 1) {
    return 7104878;
  }
  uint64_t v10 = *(void (**)(char *, char *, uint64_t))(v2 + 32);
  v10(v5, v7, v1);
  Swift::String v50 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Optional(", 9uLL, 1);
  uint64_t v11 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  inited = swift_initStackObject(v11, v49);
  *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_18162AC80;
  inited[7] = v1;
  boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  v10(boxed_opaque_existential_0Tm, v5, v1);
  specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v50._countAndFlagsBits);
  swift_bridgeObjectRelease(0xE000000000000000);
  swift_bridgeObjectRelease(0xE100000000000000);
  swift_setDeallocating((uint64_t)inited);
  swift_arrayDestroy((uint64_t)(inited + 4), 1, (unint64_t *)qword_1ECA06310);
  unint64_t object = (unint64_t)v50._object;
  uint64_t countAndFlagsBits = v50._countAndFlagsBits;
  size_t v16 = ((unint64_t)v50._object >> 56) & 0xF;
  uint64_t v17 = v50._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v50._object & 0x2000000000000000) != 0) {
    int64_t v18 = ((unint64_t)v50._object >> 56) & 0xF;
  }
  else {
    int64_t v18 = v50._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v18 && (v50._countAndFlagsBits & ~(uint64_t)v50._object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v50._object);
    return 41;
  }
  if (((uint64_t)v50._object & 0x2000000000000000) == 0 || v16 == 15)
  {
    swift_bridgeObjectRetain(0xE100000000000000);
    if ((object & 0x1000000000000000) != 0)
    {
      Swift::Int v42 = String.UTF8View._foreignCount()();
      uint64_t v21 = v42 + 1;
      if (!__OFADD__(v42, 1)) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v21 = v18 + 1;
      if (!__OFADD__(v18, 1))
      {
LABEL_13:
        unint64_t v22 = countAndFlagsBits & ~object;
        if ((v22 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
          if (v24)
          {
            unint64_t v45 = 258;
            goto LABEL_74;
          }
          if (v21 > 15 || (object & 0x2000000000000000) == 0 && v23 > 0) {
            goto LABEL_19;
          }
        }
        else if (v21 > 15)
        {
LABEL_19:
          int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
          BOOL v28 = (v26 & 1) == 0 && v25 > 0;
          if ((v22 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v28) {
              goto LABEL_61;
            }
          }
          else if (v28)
          {
            goto LABEL_43;
          }
          uint64_t v31 = 2 * _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
          if (v32) {
            uint64_t v31 = 0;
          }
          if (v31 > v21) {
            uint64_t v21 = v31;
          }
LABEL_43:
          uint64_t v33 = _StringGuts.uniqueNativeCapacity.getter();
          if (v34)
          {
            if ((object & 0x1000000000000000) != 0) {
              int64_t v18 = String.UTF8View._foreignCount()();
            }
          }
          else
          {
            int64_t v18 = 2 * v33;
          }
          if (v18 <= v21) {
            int64_t v18 = v21;
          }
          if ((object & 0x1000000000000000) == 0)
          {
            if ((object & 0x2000000000000000) != 0)
            {
              *(void *)&long long __src = countAndFlagsBits;
              *((void *)&__src + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = object & 0xFFFFFFFFFFFFFFLL;
              unint64_t v36 = v16 | 0xC000000000000000;
              if ((object & 0x4000000000000000) == 0) {
                unint64_t v36 = HIBYTE(object) & 0xF;
              }
              uint64_t v37 = v36 | 0x3000000000000000;
              unint64_t object = _allocateStringStorage(codeUnitCapacity:)(v18);
              *(void *)(object + 16) = v38;
              *(void *)(object + 24) = v37;
              if (v38 < 0)
              {
                *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
                uint64_t v37 = *(void *)(object + 24);
              }
              *(unsigned char *)(object + 32 + (v37 & 0xFFFFFFFFFFFFLL)) = 0;
              specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v16, (char *)(object + 32));
            }
            else
            {
              if ((countAndFlagsBits & 0x1000000000000000) != 0)
              {
                Swift::String::Index v35 = (char *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
              }
              else
              {
                Swift::String::Index v35 = (char *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
                uint64_t v17 = v44;
              }
              unint64_t object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(v35, v17, v18, countAndFlagsBits < 0);
            }
            swift_bridgeObjectRelease((uint64_t)v50._object);
            goto LABEL_61;
          }
          goto LABEL_66;
        }
        if ((object & 0x2000000000000000) != 0)
        {
          unint64_t v29 = object;
        }
        else if ((object & 0x1000000000000000) != 0)
        {
          uint64_t countAndFlagsBits = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
          unint64_t v29 = v46;
        }
        else
        {
          if ((countAndFlagsBits & 0x1000000000000000) != 0)
          {
            unint64_t v43 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            unint64_t v43 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
            uint64_t v17 = v47;
          }
          swift_bridgeObjectRetain(object);
          closure #1 in _StringGuts._convertedToSmall()(v43, v17, &__src);
          swift_bridgeObjectRelease(object);
          unint64_t v29 = *((void *)&__src + 1);
          uint64_t countAndFlagsBits = __src;
        }
        swift_bridgeObjectRelease(0xE100000000000000);
        unint64_t v30 = HIBYTE(v29) & 0xF;
        if (v30 != 15)
        {
          uint64_t v19 = (41 << (8 * (HIBYTE(v29) & 7u))) | ((-255 << (8 * (HIBYTE(v29) & 7u))) - 1) & countAndFlagsBits;
          BOOL v20 = v30 >= 8;
          goto LABEL_34;
        }
        unint64_t v45 = 266;
LABEL_74:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v45, 0);
      }
    }
    __break(1u);
LABEL_66:
    _StringGuts._foreignGrow(_:)(v18);
    unint64_t object = (unint64_t)v50._object;
LABEL_61:
    swift_bridgeObjectRelease(0xE100000000000000);
    long long __src = xmmword_18162ADC0;
    uint64_t v39 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&__src, 1);
    __StringStorage.appendInPlace(_:isASCII:)(v39, v40, 1);
    swift_bridgeObjectRelease(0xE100000000000000);
    return *(void *)((object & 0xFFFFFFFFFFFFFFFLL) + 0x18);
  }
  uint64_t v19 = (41 << (8 * (HIBYTE(v50._object) & 7u))) | ((-255 << (8 * (HIBYTE(v50._object) & 7u))) - 1) & v50._countAndFlagsBits;
  BOOL v20 = v16 >= 8;
LABEL_34:
  if (v20) {
    uint64_t v9 = countAndFlagsBits;
  }
  else {
    uint64_t v9 = v19;
  }
  swift_bridgeObjectRelease(object);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v9;
}

uint64_t Optional.customMirror.getter@<X0>(swift *a1@<X0>, swift **a2@<X8>)
{
  uint64_t v3 = v2;
  unint64_t v51 = a2;
  uint64_t v5 = *((void *)a1 + 2);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v47 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *(void *)(v7 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v7);
  uint64_t v48 = (unint64_t *)((char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v47 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  unint64_t v49 = (unint64_t *)((char *)&v47 - v17);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  BOOL v20 = (char *)&v47 - v19;
  MEMORY[0x1F4188790](v18);
  unint64_t v22 = (char *)&v47 - v21;
  uint64_t v50 = v10;
  int64_t v23 = *(void (**)(char *, uint64_t, swift *))(v10 + 16);
  v23((char *)&v47 - v21, v3, a1);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48))(v22, 1, v5) == 1)
  {
    v23(v15, v3, a1);
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    char v24 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v15, (uint64_t)&v52, a1);
    char v26 = v25;
    uint64_t v27 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
    BOOL v28 = (swift *)swift_allocObject(v27, 0x48uLL, 7uLL);
    *((void *)v28 + 6) = &_swiftEmptyArrayStorage;
    *((void *)v28 + 7) = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
    *((void *)v28 + 8) = 0;
    unint64_t v29 = (unint64_t *)canonical specialized generic type metadata accessor for _IndexBox<Int>();
    unint64_t v30 = swift_allocObject(v29, 0x18uLL, 7uLL);
    v30[2] = 0;
    uint64_t v31 = swift_allocObject(v29, 0x18uLL, 7uLL);
    v31[2] = 0;
    *((void *)v28 + 2) = v30;
    *((void *)v28 + 3) = &protocol witness table for _IndexBox<A>;
    *((void *)v28 + 4) = v31;
    *((void *)v28 + 5) = &protocol witness table for _IndexBox<A>;
    char v32 = v48;
    (*(void (**)(unint64_t *, char *, swift *))(v50 + 32))(v48, v15, a1);
  }
  else
  {
    uint64_t v33 = *(void (**)(char *, char *, uint64_t))(v6 + 32);
    v33(v9, v22, v5);
    v23(v20, v3, a1);
    char v34 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
    Swift::String::Index v35 = swift_allocObject(v34, 0x50uLL, 7uLL);
    *((_OWORD *)v35 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_18162AC80;
    v35[4] = 1701670771;
    v35[5] = 0xE400000000000000;
    v35[9] = v5;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(v35 + 6);
    v33(boxed_opaque_existential_0Tm, v9, v5);
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    char v24 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v20, (uint64_t)&v52, a1);
    char v26 = v37;
    uint64_t v38 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
    BOOL v28 = (swift *)swift_allocObject(v38, 0x48uLL, 7uLL);
    *((void *)v28 + 6) = v35;
    *((void *)v28 + 7) = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
    *((void *)v28 + 8) = 0;
    uint64_t v39 = (unint64_t *)canonical specialized generic type metadata accessor for _IndexBox<Int>();
    size_t v40 = swift_allocObject(v39, 0x18uLL, 7uLL);
    v40[2] = 0;
    uint64_t v41 = v35[2];
    Swift::Int v42 = swift_allocObject(v39, 0x18uLL, 7uLL);
    v42[2] = v41;
    *((void *)v28 + 2) = v40;
    *((void *)v28 + 3) = &protocol witness table for _IndexBox<A>;
    *((void *)v28 + 4) = v42;
    *((void *)v28 + 5) = &protocol witness table for _IndexBox<A>;
    char v32 = v49;
    (*(void (**)(unint64_t *, char *, swift *))(v50 + 32))(v49, v20, a1);
  }
  unint64_t v43 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)&v52, v32, (Class *)a1, v43, 6uLL);
  char v45 = result;
  if (result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(&v52);
  }
  unint64_t v46 = v51;
  char *v51 = a1;
  v46[1] = v28;
  *((unsigned char *)v46 + 16) = 4;
  uint64_t v46[3] = (swift *)v24;
  v46[4] = v26;
  *((unsigned char *)v46 + 4_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = v45;
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> A?(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = a3;
  uint64_t v31 = a2;
  uint64_t v6 = a3[2];
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v29 = *(void *)(a4 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  BOOL v28 = (char *)&v27 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1F4188790](v8);
  char v32 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v13, v13, 0, 0);
  uint64_t v30 = *(TupleTypeMetadata2 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v17 = (char *)&v27 - v16;
  uint64_t v18 = (char *)&v27 + *(int *)(v15 + 48) - v16;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t *))(v11 + 16);
  v19((char *)&v27 - v16, a1, v4);
  v19(v18, v31, v4);
  uint64_t v31 = v7;
  BOOL v20 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48);
  if (v20(v17, 1, v6) == 1)
  {
    if (v20(v18, 1, v6) == 1)
    {
      char v21 = 1;
    }
    else
    {
      uint64_t v11 = v30;
      uint64_t v4 = TupleTypeMetadata2;
      char v21 = 0;
    }
  }
  else
  {
    v19(v32, (uint64_t)v17, v4);
    if (v20(v18, 1, v6) == 1)
    {
      (*(void (**)(char *, uint64_t))(v31 + 8))(v32, v6);
      char v21 = 0;
      uint64_t v11 = v30;
      uint64_t v4 = TupleTypeMetadata2;
    }
    else
    {
      uint64_t v22 = v31;
      int64_t v23 = v28;
      (*(void (**)(char *, char *, uint64_t))(v31 + 32))(v28, v18, v6);
      char v24 = v32;
      char v21 = (*(uint64_t (**)(char *, char *, uint64_t))(v29 + 8))(v32, v23, v6);
      int64_t v25 = *(void (**)(char *, uint64_t))(v22 + 8);
      v25(v23, v6);
      v25(v24, v6);
    }
  }
  (*(void (**)(char *, uint64_t *))(v11 + 8))(v17, v4);
  return v21 & 1;
}

void Optional<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v12 + 16))(v11, v13);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48))(v11, 1, v5) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(v9, v11, v5);
    Hasher._combine(_:)(1u);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v5, a3);
    (*(void (**)(char *, uint64_t))(v6 + 8))(v9, v5);
  }
}

Swift::Int Optional<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v14[-1] - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v10 = (char *)&v14[-1] - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14[0] = 0;
  v14[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  void v14[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v14[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v14[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v15 = 0u;
  long long v16 = 0u;
  (*(void (**)(char *, uint64_t))(v11 + 16))(v10, v2);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v5 + 48))(v10, 1, v4) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v8, v10, v4);
    Hasher._combine(_:)(1u);
    (*(void (**)(void *, uint64_t, uint64_t))(a2 + 24))(v14, v4, a2);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
  }
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> A?(uint64_t a1, uint64_t a2)
{
  return Optional<A>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> A?(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> A?(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))Optional<A>.hash(into:));
}

BOOL static Optional.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 48))(a1, 1, a2) == 1;
}

BOOL static Optional.!= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 48))(a1, 1, a2) != 1;
}

uint64_t ?? infix<A>(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = type metadata accessor for Optional(0, a4, a3, a4);
  MEMORY[0x1F4188790](v9);
  uint64_t v11 = (char *)v15 - v10;
  (*(void (**)(char *, uint64_t))(v12 + 16))((char *)v15 - v10, a1);
  uint64_t v13 = *(void *)(a4 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48))(v11, 1, a4) == 1) {
    return a2();
  }
  else {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v13 + 32))(a5, v11, a4);
  }
}

{
  Class *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void v15[2];

  uint64_t v9 = type metadata accessor for Optional(0, a4, a3, a4);
  MEMORY[0x1F4188790](v9);
  uint64_t v11 = (char *)v15 - v10;
  (*(void (**)(char *, uint64_t))(v12 + 16))((char *)v15 - v10, a1);
  uint64_t v13 = *(void *)(a4 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48))(v11, 1, a4) == 1) {
    return a2();
  }
  (*(void (**)(uint64_t, char *, uint64_t))(v13 + 32))(a5, v11, a4);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v13 + 56))(a5, 0, 1, a4);
}

__SwiftNull *Optional._bridgeToObjectiveC()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = (char *)&v12 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(unint64_t **)(v3 + 16);
  uint64_t v7 = *(v6 - 1);
  MEMORY[0x1F4188790](v3);
  uint64_t v9 = (id *)((char *)&v12 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(char *))(v2 + 16))(v5);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(v7 + 48))(v5, 1, v6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v2 + 8))(v5, a1);
    return _swift_Foundation_getOptionalNilSentinelObject(v6);
  }
  else
  {
    (*(void (**)(id *, char *, unint64_t *))(v7 + 32))(v9, v5, v6);
    uint64_t v10 = _bridgeAnythingToObjectiveC<A>(_:)(v9, (uint64_t *)v6);
    (*(void (**)(id *, unint64_t *))(v7 + 8))(v9, v6);
  }
  return (__SwiftNull *)v10;
}

uint64_t static Optional._forceBridgeFromObjectiveC(_:result:)(__SwiftNull *a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6 = *(a3 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = type metadata accessor for Optional(255, v9, v9, v10);
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)v11, v12, v13);
  (*((void (**)(uint64_t, Class *))*(v14 - 1) + 1))(a2, v14);
  OptionalNilSentinelObject = _swift_Foundation_getOptionalNilSentinelObject(a3);
  swift_unknownObjectRelease(OptionalNilSentinelObject);
  if (OptionalNilSentinelObject == a1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(v6 + 56))(a2, 1, 1, a3);
    uint64_t v17 = (uint64_t (*)(uint64_t, void, uint64_t, Class *))*((void *)*(v11 - 1) + 7);
    return v17(a2, 0, 1, v11);
  }
  else
  {
    uint64_t v19 = a1;
    swift_unknownObjectRetain(a1);
    swift_dynamicCast(v8, (unint64_t *)&v19, qword_1ECA06328, (const char *)a3, 7uLL);
    (*(void (**)(uint64_t, char *, unint64_t *))(v6 + 16))(a2, v8, a3);
    (*(void (**)(uint64_t, void, uint64_t, unint64_t *))(v6 + 56))(a2, 0, 1, a3);
    (*((void (**)(uint64_t, void, uint64_t, Class *))*(v11 - 1) + 7))(a2, 0, 1, v11);
    return (*(uint64_t (**)(char *, unint64_t *))(v6 + 8))(v8, a3);
  }
}

uint64_t static Optional._conditionallyBridgeFromObjectiveC(_:result:)(__SwiftNull *a1, char *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for Optional(0, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v24 - v10;
  uint64_t v12 = *(a3 - 1);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = type metadata accessor for Optional(0, (uint64_t)v7, v15, v16);
  (*((void (**)(char *, Class *))*(v17 - 1) + 1))(a2, v17);
  OptionalNilSentinelObject = _swift_Foundation_getOptionalNilSentinelObject(a3);
  swift_unknownObjectRelease(OptionalNilSentinelObject);
  if (OptionalNilSentinelObject == a1)
  {
    uint64_t v21 = 1;
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v12 + 56))(a2, 1, 1, a3);
    (*(void (**)(char *, void, uint64_t, Class *))(v8 + 56))(a2, 0, 1, v7);
  }
  else
  {
    int64_t v25 = a1;
    swift_unknownObjectRetain(a1);
    int v19 = swift_dynamicCast(v11, (unint64_t *)&v25, qword_1ECA06328, (const char *)a3, 6uLL);
    BOOL v20 = *(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v12 + 56);
    if (v19)
    {
      uint64_t v21 = 1;
      v20(v11, 0, 1, a3);
      char v24 = v7;
      uint64_t v22 = *(void (**)(char *, char *, unint64_t *))(v12 + 32);
      v22(v14, v11, a3);
      v22(a2, v14, a3);
      v20(a2, 0, 1, a3);
      (*(void (**)(char *, void, uint64_t, Class *))(v8 + 56))(a2, 0, 1, v24);
    }
    else
    {
      v20(v11, 1, 1, a3);
      (*(void (**)(char *, Class *))(v8 + 8))(v11, v7);
      (*(void (**)(char *, uint64_t, uint64_t, Class *))(v8 + 56))(a2, 1, 1, v7);
      return 0;
    }
  }
  return v21;
}

uint64_t static Optional._unconditionallyBridgeFromObjectiveC(_:)@<X0>(__SwiftNull *a1@<X0>, unint64_t *a2@<X1>, char *a3@<X8>)
{
  if (a1)
  {
    swift_unknownObjectRetain(a1);
    OptionalNilSentinelObject = _swift_Foundation_getOptionalNilSentinelObject(a2);
    swift_unknownObjectRelease(OptionalNilSentinelObject);
    if (OptionalNilSentinelObject != a1)
    {
      uint64_t v9 = a1;
      swift_dynamicCast(a3, (unint64_t *)&v9, qword_1ECA06328, (const char *)a2, 7uLL);
      return (*(uint64_t (**)(char *, void, uint64_t, unint64_t *))(*(a2 - 1) + 56))(a3, 0, 1, a2);
    }
    swift_unknownObjectRelease(a1);
  }
  uint64_t v8 = *(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t *))(*(a2 - 1) + 56);

  return v8(a3, 1, 1, a2);
}

uint64_t protocol witness for static _ObjectiveCBridgeable._forceBridgeFromObjectiveC(_:result:) in conformance A?(__SwiftNull *a1, uint64_t a2, uint64_t a3)
{
  return static Optional._forceBridgeFromObjectiveC(_:result:)(a1, a2, *(unint64_t **)(a3 + 16));
}

uint64_t protocol witness for static _ObjectiveCBridgeable._conditionallyBridgeFromObjectiveC(_:result:) in conformance A?(__SwiftNull *a1, char *a2, uint64_t a3, uint64_t a4)
{
  return static Optional._conditionallyBridgeFromObjectiveC(_:result:)(a1, a2, *(unint64_t **)(a3 + 16), a4);
}

uint64_t protocol witness for static _ObjectiveCBridgeable._unconditionallyBridgeFromObjectiveC(_:) in conformance A?@<X0>(__SwiftNull *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  return static Optional._unconditionallyBridgeFromObjectiveC(_:)(a1, *(unint64_t **)(a2 + 16), a3);
}

uint64_t OptionSet.union(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v10, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v13 = (char *)&v15 - v12;
  (*(void (**)(uint64_t, uint64_t))(v10 + 24))(a2, v10);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 24))(v13, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(*(void *)(a3 + 16) + 96))(v8, a2);
}

uint64_t OptionSet.intersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(uint64_t, uint64_t))(v6 + 24))(a2, v6);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 24))(v9, a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 + 16) + 104))(a1, a2);
}

uint64_t OptionSet.symmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v10, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v13 = (char *)&v15 - v12;
  (*(void (**)(uint64_t, uint64_t))(v10 + 24))(a2, v10);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 24))(v13, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(*(void *)(a3 + 16) + 112))(v8, a2);
}

uint64_t OptionSet<>.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)(a3 + 16) + 144))();
}

uint64_t OptionSet<>.insert(_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  unint64_t v36 = a1;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)&type metadata for Bool, a3, "inserted memberAfterInsert ", 0);
  uint64_t v10 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v34 = (char *)&v31 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = *(void *)(a3 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v12);
  uint64_t v18 = (char *)&v31 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  BOOL v20 = (char *)&v31 - v19;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v15 + 16);
  uint64_t v33 = v5;
  uint64_t v31 = v21;
  v21(v18, v5, a3);
  uint64_t v22 = *(void *)(a4 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 56))(a2, a3, v22);
  int64_t v23 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v22 + 8) + 8);
  uint64_t v32 = a2;
  char v24 = v23(v20, a2, a3) ^ 1;
  Swift::String::Index v35 = TupleTypeMetadata2;
  int64_t v25 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  *uint64_t v14 = v24 & 1;
  if (v24)
  {
    (*(void (**)(char *, uint64_t))(v15 + 8))(v20, a3);
    BOOL v28 = v31;
    uint64_t v27 = v32;
    v31(v25, v32, a3);
    v28(v18, v27, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v22 + 96))(v18, a3, v22);
    char v26 = *(void (**)(char *, char *, uint64_t))(v15 + 32);
  }
  else
  {
    char v26 = *(void (**)(char *, char *, uint64_t))(v15 + 32);
    v26(v25, v20, a3);
  }
  uint64_t v29 = &v34[*((int *)v35 + 12)];
  v26(v29, v25, a3);
  v26(v36, v29, a3);
  return v24 & 1;
}

uint64_t OptionSet<>.remove(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, v5, a2);
  uint64_t v16 = *(void *)(a3 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 56))(a1, a2, v16);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v16 + 152))(a2, v16))
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, a2);
    uint64_t v17 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 168))(a1, a2, v16);
    (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))(a4, v15, a2);
    uint64_t v17 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a4, v17, 1, a2);
}

uint64_t OptionSet<>.update(with:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v22 = a4;
  uint64_t v9 = *(void *)(a2 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v21 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v21 - v13;
  uint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15(v12, v5, a2);
  uint64_t v16 = *(void *)(a3 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 56))(a1, a2, v16);
  v15(v12, a1, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 96))(v12, a2, v16);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v16 + 152))(a2, v16))
  {
    (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a2);
    uint64_t v17 = 1;
    uint64_t v18 = v22;
  }
  else
  {
    uint64_t v19 = v22;
    (*(void (**)(uint64_t, char *, uint64_t))(v9 + 32))(v22, v14, a2);
    uint64_t v17 = 0;
    uint64_t v18 = v19;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56))(v18, v17, 1, a2);
}

uint64_t OptionSet<>.init()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 8), a1, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v15 - v7;
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a3 + 8) + 24) + 16);
  uint64_t v10 = swift_getAssociatedTypeWitness(0, (int **)v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v10);
  uint64_t v12 = (char *)&v15 - v11;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, (uint64_t)AssociatedTypeWitness, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v10, AssociatedConformanceWitness);
  (*(void (**)(char *, const char *, uint64_t))(v9 + 24))(v12, AssociatedTypeWitness, v9);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(a2 + 24))(v8, a1, a2);
}

uint64_t OptionSet<>.formUnion(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  v20[1] = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)v20 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)v20 - v15;
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v6 + 24);
  v20[0] = v4;
  v17(a2, v6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(v4, a2);
  v17(a2, v6);
  (*(void (**)(char *, char *, const char *))(*(void *)(v21 + 8) + 208))(v14, v11, AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, const char *))(v8 + 8);
  v18(v11, AssociatedTypeWitness);
  v18(v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v22 + 24))(v16, a2);
}

uint64_t OptionSet<>.formIntersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  v20[1] = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)v20 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)v20 - v15;
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v6 + 24);
  v20[0] = v4;
  v17(a2, v6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(v4, a2);
  v17(a2, v6);
  (*(void (**)(char *, char *, const char *))(*(void *)(v21 + 8) + 192))(v14, v11, AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, const char *))(v8 + 8);
  v18(v11, AssociatedTypeWitness);
  v18(v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v22 + 24))(v16, a2);
}

uint64_t OptionSet<>.formSymmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  v20[1] = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for RawRepresentable, associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)v20 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)v20 - v15;
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v6 + 24);
  v20[0] = v4;
  v17(a2, v6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(v4, a2);
  v17(a2, v6);
  (*(void (**)(char *, char *, const char *))(*(void *)(v21 + 8) + 224))(v14, v11, AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, const char *))(v8 + 8);
  v18(v11, AssociatedTypeWitness);
  v18(v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v22 + 24))(v16, a2);
}

void specialized TextOutputStream._writeASCII(_:)(uint8x16_t *a1, uint64_t a2)
{
  unint64_t v2 = specialized static String._uncheckedFromASCII(_:)(a1, a2);
  unint64_t v4 = v3;
  uint64_t v5 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (!v5) {
    goto LABEL_9;
  }
  uint64_t v6 = v2;
  swift_bridgeObjectRetain(v3);
  if ((v4 & 0x1000000000000000) != 0)
  {
    uint64_t v6 = specialized static String._copying(_:)(v6, v4);
    unint64_t v7 = v10;
    swift_bridgeObjectRelease(v4);
    if ((v7 & 0x2000000000000000) == 0) {
      goto LABEL_6;
    }
LABEL_13:
    v12[0] = v6;
    v12[1] = v7 & 0xFFFFFFFFFFFFFFLL;
    _swift_stdlib_fwrite_stdout(v12, 1uLL, HIBYTE(v7) & 0xF);
    swift_bridgeObjectRelease(v7);
    swift_bridgeObjectRelease(v4);
    return;
  }
  unint64_t v7 = v4;
  if ((v4 & 0x2000000000000000) != 0) {
    goto LABEL_13;
  }
LABEL_6:
  if ((v6 & 0x1000000000000000) != 0)
  {
    id v8 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
    size_t v9 = v6 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    id v8 = _StringObject.sharedUTF8.getter(v6, v7);
    if (!v8) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/OutputStream.swift", 24, 2, 0x239uLL, 0);
    }
    size_t v9 = v11;
  }
  _swift_stdlib_fwrite_stdout(v8, 1uLL, v9);
  swift_bridgeObjectRelease(v7);
LABEL_9:

  swift_bridgeObjectRelease(v4);
}

void TextOutputStream._writeASCII(_:)(uint8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = specialized static String._uncheckedFromASCII(_:)(a1, a2);
  uint64_t v7 = v6;
  (*(void (**)(unint64_t))(a4 + 24))(v5);

  swift_bridgeObjectRelease(v7);
}

uint64_t _fallbackEnumRawValue<A>(_:)(char *a1, uint64_t a2)
{
  uint64_t result = 0;
  switch(*(void *)(*(void *)(a2 - 8) + 64))
  {
    case 1:
      uint64_t result = *a1;
      break;
    case 2:
      uint64_t result = *(__int16 *)a1;
      break;
    case 4:
      uint64_t result = *(int *)a1;
      break;
    case 8:
      uint64_t result = *(void *)a1;
      break;
    default:
      return result;
  }
  return result;
}

void printTypeName #1 <A, B>(_:) in _adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:)(Class *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  TypeName = (uint8x16_t *)swift_getTypeName(a1, a3);
  if (v9 < 0) {
LABEL_188:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  uint64_t v10 = v9;
  if (!v9)
  {
    int8x8_t v15 = 0;
    int64_t v16 = 0xE000000000000000;
    goto LABEL_185;
  }
  size_t v11 = TypeName;
  uint64_t v12 = TypeName;
  if ((v9 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0) {
      goto LABEL_23;
    }
    uint64_t v12 = TypeName + 1;
    while (v12 < (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFF0])
    {
      uint64_t v13 = v12->i64[0];
      uint64_t v14 = v12->i64[1];
      ++v12;
      if (((v14 | v13) & 0x8080808080808080) != 0) {
        goto LABEL_23;
      }
    }
  }
  if (v12 < (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v12->i64[0] & 0x8080808080808080) != 0) {
      goto LABEL_23;
    }
    uint64_t v12 = (uint8x16_t *)((char *)v12 + 8);
  }
  if (v12 < (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v12->i32[0] & 0x80808080) != 0) {
      goto LABEL_23;
    }
    uint64_t v12 = (uint8x16_t *)((char *)v12 + 4);
  }
  if (v12 >= (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_19:
    if (v12 >= (uint8x16_t *)&TypeName->i8[v9] || (v12->i8[0] & 0x80000000) == 0)
    {
      if (v9 <= 15) {
        goto LABEL_74;
      }
      char v17 = 1;
      goto LABEL_64;
    }
    goto LABEL_23;
  }
  if ((v12->i16[0] & 0x8080) == 0)
  {
    uint64_t v12 = (uint8x16_t *)((char *)v12 + 2);
    goto LABEL_19;
  }
LABEL_23:
  uint64_t v18 = 0;
  uint64_t v19 = (uint8x16_t *)((char *)TypeName + v9);
  char v17 = 1;
  BOOL v20 = TypeName;
  uint64_t v21 = TypeName;
  while (1)
  {
    int v24 = v21->i8[0];
    uint64_t v21 = (uint8x16_t *)((char *)v21 + 1);
    unsigned __int8 v23 = v24;
    if (v24 < 0) {
      break;
    }
    uint64_t v22 = 1;
LABEL_25:
    v18 += v22;
    BOOL v20 = v21;
    if (v21 == v19)
    {
      if (v9 <= 15) {
        goto LABEL_74;
      }
LABEL_64:
      int64_t v16 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v9, v9, v17 & 1);
      int8x8_t v15 = *(int8x8_t *)(v16 + 24);
      goto LABEL_185;
    }
  }
  if ((v23 + 62) > 0x32u) {
    goto LABEL_65;
  }
  if ((v23 + 32) < 0xE2u)
  {
    if (v23 == 224)
    {
      if (v21 == v19 || (v20->i8[1] & 0xE0) != 0xA0) {
        goto LABEL_65;
      }
      goto LABEL_49;
    }
    if ((v23 + 19) < 0xF4u)
    {
      if (v23 == 237)
      {
        if (v21 == v19) {
          goto LABEL_65;
        }
        unsigned int v25 = v20->u8[1];
        if (v25 > 0x9F) {
          goto LABEL_65;
        }
        goto LABEL_48;
      }
      if ((v23 + 16) < 0xFEu)
      {
        if (v23 == 240)
        {
          if (v21 == v19 || (v20->i8[1] + 64) < 0xD0u) {
            goto LABEL_65;
          }
        }
        else
        {
          if (v23 > 0xF3u)
          {
            if (v21 == v19) {
              goto LABEL_65;
            }
            unsigned int v26 = v20->u8[1];
            if (v26 > 0x8F) {
              goto LABEL_65;
            }
          }
          else
          {
            if (v21 == v19) {
              goto LABEL_65;
            }
            LOBYTE(v26) = v20->i8[1];
          }
          if ((v26 & 0xC0) != 0x80) {
            goto LABEL_65;
          }
        }
        if (&v20->i16[1] == (__int16 *)v19
          || (v20->i8[2] & 0xC0) != 0x80
          || (uint8x16_t *)((char *)v20->i32 + 3) == v19
          || (v20->i8[3] & 0xC0) != 0x80)
        {
          goto LABEL_65;
        }
        char v17 = 0;
        uint64_t v21 = (uint8x16_t *)((char *)v20->i64 + 4);
        uint64_t v22 = 4;
        goto LABEL_25;
      }
    }
    if (v21 == v19) {
      goto LABEL_65;
    }
    LOBYTE(v25) = v20->i8[1];
LABEL_48:
    if ((v25 & 0xC0) != 0x80) {
      goto LABEL_65;
    }
LABEL_49:
    if (&v20->i16[1] == (__int16 *)v19 || (v20->i8[2] & 0xC0) != 0x80) {
      goto LABEL_65;
    }
    char v17 = 0;
    uint64_t v21 = (uint8x16_t *)((char *)v20->i32 + 3);
    uint64_t v22 = 3;
    goto LABEL_25;
  }
  if (v21 != v19 && (v21->i8[0] & 0xC0) == 0x80)
  {
    char v17 = 0;
    uint64_t v21 = (uint8x16_t *)&v20->i16[1];
    uint64_t v22 = 2;
    goto LABEL_25;
  }
LABEL_65:
  uint64_t v185 = a5;
  a5 = a2;
  uint64_t v27 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v27);
  uint64_t v28 = specialized Collection.subscript.getter(v18, (uint64_t)v11, v10);
  uint64_t v32 = v28;
  uint64_t v33 = v29;
  uint64_t v34 = v30;
  uint64_t v35 = v31;
  uint64_t v36 = v28;
  if (v28 != v29)
  {
    specialized Slice.subscript.getter(v28, v28, v29, v30, v31);
    uint64_t v36 = v32 + 1;
    if (__OFADD__(v32, 1))
    {
LABEL_186:
      unint64_t v183 = 1525;
      goto LABEL_187;
    }
  }
  uint64_t v184 = a4;
  a4 = v33 + v32 - v36;
  uint64_t v37 = v32;
  while (1)
  {
    if (v33 == v36) {
      goto LABEL_80;
    }
    char v38 = specialized Slice.subscript.getter(v36, v32, v33, v34, v35);
    if (__OFADD__(v36, 1)) {
      goto LABEL_186;
    }
    if ((v38 & 0xC0) != 0x80) {
      break;
    }
    ++v36;
    BOOL v39 = __OFADD__(v37++, 1);
    if (v39)
    {
      __break(1u);
LABEL_74:
      unint64_t v40 = v10 - 8;
      unint64_t v41 = 8;
      if (v10 < 8) {
        unint64_t v41 = v10;
      }
      if ((v41 & 0x8000000000000000) == 0)
      {
        if (v41 < 8)
        {
          unint64_t v42 = 0;
          int8x8_t v15 = 0;
          unint64_t v43 = 0;
          goto LABEL_165;
        }
        if (v41 >= 0x10)
        {
          unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFF0;
          uint16x8_t v101 = vmovl_high_u8(*v11);
          int8x16_t v102 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v101.i8);
          uint16x8_t v103 = vmovl_u8(*(uint8x8_t *)v11->i8);
          int8x16_t v104 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v103.i8);
          int8x16_t v105 = (int8x16_t)vmovl_high_u16(v101);
          int8x8_t v106 = (int8x8_t)vextq_s8(v105, v105, 8uLL).u64[0];
          int8x16_t v107 = (int8x16_t)vmovl_high_u16(v103);
          int8x8_t v108 = (int8x8_t)vextq_s8(v107, v107, 8uLL).u64[0];
          *(int8x8_t *)v107.i8 = vorr_s8(*(int8x8_t *)v107.i8, *(int8x8_t *)v105.i8);
          v109.i64[0] = v107.u32[0];
          v109.i64[1] = v107.u32[1];
          int8x16_t v110 = (int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_18162AD00);
          *(int8x8_t *)v105.i8 = vorr_s8(*(int8x8_t *)v104.i8, *(int8x8_t *)v102.i8);
          v109.i64[0] = v105.u32[0];
          v109.i64[1] = v105.u32[1];
          int8x16_t v111 = vorrq_s8((int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_18162ACF0), v110);
          *(int8x8_t *)v105.i8 = vorr_s8(v108, v106);
          v109.i64[0] = v105.u32[0];
          v109.i64[1] = v105.u32[1];
          int8x16_t v112 = (int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_18162ACE0);
          *(int8x8_t *)v102.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v102, v102, 8uLL));
          v109.i64[0] = v102.u32[0];
          v109.i64[1] = v102.u32[1];
          int8x16_t v113 = vorrq_s8(v111, vorrq_s8((int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_18162ACD0), v112));
          int8x8_t v15 = vorr_s8(*(int8x8_t *)v113.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL));
          if (v41 != (v41 & 0xFFFFFFFFFFFFFFF0))
          {
            unint64_t v43 = 8 * v42;
            if ((v41 & 8) == 0) {
              goto LABEL_165;
            }
            goto LABEL_159;
          }
        }
        else
        {
          int8x8_t v15 = 0;
          unint64_t v43 = 0;
          unint64_t v42 = 0;
LABEL_159:
          unint64_t v78 = v42;
          int64x2_t v79 = vdupq_n_s64(v43);
          unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v43 = 8 * (v41 & 0xFFFFFFFFFFFFFFF8);
          int8x16_t v80 = 0uLL;
          int8x16_t v81 = (int8x16_t)(unint64_t)v15;
          int64x2_t v82 = vaddq_s64(v79, (int64x2_t)xmmword_18162ACE0);
          int64x2_t v83 = vaddq_s64(v79, (int64x2_t)xmmword_18162AD00);
          int64x2_t v84 = vaddq_s64(v79, (int64x2_t)xmmword_18162ACD0);
          int64x2_t v85 = vaddq_s64(v79, (int64x2_t)xmmword_18162ACF0);
          uint64_t v86 = (uint8x8_t *)&v11->i8[v78];
          int8x16_t v87 = (int8x16_t)vdupq_n_s64(0x38uLL);
          unint64_t v88 = v78 - (v41 & 0xFFFFFFFFFFFFFFF8);
          int64x2_t v89 = vdupq_n_s64(0x40uLL);
          int8x16_t v90 = 0uLL;
          int8x16_t v91 = 0uLL;
          do
          {
            uint8x8_t v92 = *v86++;
            uint16x8_t v93 = vmovl_u8(v92);
            uint32x4_t v94 = vmovl_high_u16(v93);
            v95.i64[0] = v94.u32[2];
            v95.i64[1] = v94.u32[3];
            uint64x2_t v96 = v95;
            v95.i64[0] = v94.u32[0];
            v95.i64[1] = v94.u32[1];
            uint64x2_t v97 = v95;
            uint32x4_t v98 = vmovl_u16(*(uint16x4_t *)v93.i8);
            v95.i64[0] = v98.u32[2];
            v95.i64[1] = v98.u32[3];
            uint64x2_t v99 = v95;
            v95.i64[0] = v98.u32[0];
            v95.i64[1] = v98.u32[1];
            int8x16_t v91 = vorrq_s8((int8x16_t)vshlq_u64(v96, (uint64x2_t)vandq_s8((int8x16_t)v82, v87)), v91);
            int8x16_t v90 = vorrq_s8((int8x16_t)vshlq_u64(v97, (uint64x2_t)vandq_s8((int8x16_t)v83, v87)), v90);
            int8x16_t v80 = vorrq_s8((int8x16_t)vshlq_u64(v99, (uint64x2_t)vandq_s8((int8x16_t)v84, v87)), v80);
            int8x16_t v81 = vorrq_s8((int8x16_t)vshlq_u64(v95, (uint64x2_t)vandq_s8((int8x16_t)v85, v87)), v81);
            int64x2_t v83 = vaddq_s64(v83, v89);
            int64x2_t v84 = vaddq_s64(v84, v89);
            int64x2_t v85 = vaddq_s64(v85, v89);
            int64x2_t v82 = vaddq_s64(v82, v89);
            v88 += 8;
          }
          while (v88);
          int8x16_t v100 = vorrq_s8(vorrq_s8(v81, v90), vorrq_s8(v80, v91));
          int8x8_t v15 = vorr_s8(*(int8x8_t *)v100.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v100, v100, 8uLL));
          if (v41 != v42)
          {
LABEL_165:
            Swift::String::Index v114 = &v11->u8[v42];
            unint64_t v115 = v41 - v42;
            do
            {
              unsigned int v116 = *v114++;
              *(void *)&v15 |= (unint64_t)v116 << (v43 & 0x38);
              v43 += 8;
              --v115;
            }
            while (v115);
          }
        }
        if (v10 < 9)
        {
          int8x8_t v118 = 0;
        }
        else
        {
          if (v40 < 8)
          {
            unint64_t v117 = 0;
            int8x8_t v118 = 0;
            unint64_t v119 = 0;
            goto LABEL_180;
          }
          if (v40 >= 0x10)
          {
            char v120 = (uint8x16_t *)&v11->u64[1];
            unint64_t v117 = v40 & 0xFFFFFFFFFFFFFFF0;
            int64x2_t v121 = (int64x2_t)xmmword_18162AD80;
            int64x2_t v122 = (int64x2_t)xmmword_18162AD90;
            int64x2_t v123 = (int64x2_t)xmmword_18162ADA0;
            int64x2_t v124 = (int64x2_t)xmmword_18162ADB0;
            int64x2_t v125 = (int64x2_t)xmmword_18162ACE0;
            int64x2_t v126 = (int64x2_t)xmmword_18162AD00;
            int8x16_t v127 = (int8x16_t)vdupq_n_s64(0x38uLL);
            int64x2_t v128 = vdupq_n_s64(0x80uLL);
            int64x2_t v129 = (int64x2_t)xmmword_18162ACD0;
            unint64_t v119 = 8 * (v40 & 0xFFFFFFFFFFFFFFF0);
            int8x16_t v130 = 0uLL;
            int8x16_t v131 = 0uLL;
            int64x2_t v132 = (int64x2_t)xmmword_18162ACF0;
            unint64_t v133 = v40 & 0xFFFFFFFFFFFFFFF0;
            int8x16_t v134 = 0uLL;
            int8x16_t v135 = 0uLL;
            int8x16_t v136 = 0uLL;
            int8x16_t v137 = 0uLL;
            int8x16_t v138 = 0uLL;
            int8x16_t v139 = 0uLL;
            do
            {
              uint8x16_t v140 = *v120++;
              uint16x8_t v141 = vmovl_u8(*(uint8x8_t *)v140.i8);
              uint32x4_t v142 = vmovl_high_u16(v141);
              v143.i64[0] = v142.u32[2];
              v143.i64[1] = v142.u32[3];
              uint64x2_t v144 = v143;
              uint16x8_t v145 = vmovl_high_u8(v140);
              uint32x4_t v146 = vmovl_u16(*(uint16x4_t *)v145.i8);
              v143.i64[0] = v146.u32[2];
              v143.i64[1] = v146.u32[3];
              uint64x2_t v147 = v143;
              v143.i64[0] = v146.u32[0];
              v143.i64[1] = v146.u32[1];
              uint64x2_t v148 = v143;
              v143.i64[0] = v142.u32[0];
              v143.i64[1] = v142.u32[1];
              uint64x2_t v149 = v143;
              uint32x4_t v150 = vmovl_u16(*(uint16x4_t *)v141.i8);
              v143.i64[0] = v150.u32[2];
              v143.i64[1] = v150.u32[3];
              uint64x2_t v151 = v143;
              uint32x4_t v152 = vmovl_high_u16(v145);
              v143.i64[0] = v152.u32[0];
              v143.i64[1] = v152.u32[1];
              uint64x2_t v153 = v143;
              v143.i64[0] = v150.u32[0];
              v143.i64[1] = v150.u32[1];
              uint64x2_t v154 = v143;
              v143.i64[0] = v152.u32[2];
              v143.i64[1] = v152.u32[3];
              int8x16_t v135 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v125, v127)), v135);
              int8x16_t v137 = vorrq_s8((int8x16_t)vshlq_u64(v147, (uint64x2_t)vandq_s8((int8x16_t)v123, v127)), v137);
              int8x16_t v136 = vorrq_s8((int8x16_t)vshlq_u64(v148, (uint64x2_t)vandq_s8((int8x16_t)v124, v127)), v136);
              int8x16_t v134 = vorrq_s8((int8x16_t)vshlq_u64(v149, (uint64x2_t)vandq_s8((int8x16_t)v126, v127)), v134);
              int8x16_t v131 = vorrq_s8((int8x16_t)vshlq_u64(v151, (uint64x2_t)vandq_s8((int8x16_t)v129, v127)), v131);
              int8x16_t v138 = vorrq_s8((int8x16_t)vshlq_u64(v153, (uint64x2_t)vandq_s8((int8x16_t)v122, v127)), v138);
              int8x16_t v130 = vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)vandq_s8((int8x16_t)v132, v127)), v130);
              int8x16_t v139 = vorrq_s8((int8x16_t)vshlq_u64(v143, (uint64x2_t)vandq_s8((int8x16_t)v121, v127)), v139);
              int64x2_t v126 = vaddq_s64(v126, v128);
              int64x2_t v129 = vaddq_s64(v129, v128);
              int64x2_t v132 = vaddq_s64(v132, v128);
              int64x2_t v125 = vaddq_s64(v125, v128);
              int64x2_t v124 = vaddq_s64(v124, v128);
              int64x2_t v123 = vaddq_s64(v123, v128);
              int64x2_t v122 = vaddq_s64(v122, v128);
              int64x2_t v121 = vaddq_s64(v121, v128);
              v133 -= 16;
            }
            while (v133);
            int8x16_t v155 = vorrq_s8(vorrq_s8(vorrq_s8(v130, v136), vorrq_s8(v134, v138)), vorrq_s8(vorrq_s8(v131, v137), vorrq_s8(v135, v139)));
            int8x8_t v118 = vorr_s8(*(int8x8_t *)v155.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
            if (v40 != v117)
            {
              if ((v40 & 8) == 0) {
                goto LABEL_180;
              }
              goto LABEL_177;
            }
          }
          else
          {
            int8x8_t v118 = 0;
            unint64_t v119 = 0;
            unint64_t v117 = 0;
LABEL_177:
            unint64_t v156 = v117;
            unint64_t v117 = v40 & 0xFFFFFFFFFFFFFFF8;
            int64x2_t v157 = vdupq_n_s64(v119);
            unint64_t v119 = 8 * (v40 & 0xFFFFFFFFFFFFFFF8);
            int8x16_t v158 = (int8x16_t)(unint64_t)v118;
            int8x16_t v159 = 0uLL;
            int64x2_t v160 = vaddq_s64(v157, (int64x2_t)xmmword_18162ACE0);
            int64x2_t v161 = vaddq_s64(v157, (int64x2_t)xmmword_18162AD00);
            int64x2_t v162 = vaddq_s64(v157, (int64x2_t)xmmword_18162ACD0);
            int64x2_t v163 = vaddq_s64(v157, (int64x2_t)xmmword_18162ACF0);
            Swift::String::Index v164 = (uint8x8_t *)((char *)&v11->u64[1] + v156);
            int8x16_t v165 = (int8x16_t)vdupq_n_s64(0x38uLL);
            unint64_t v166 = v156 - (v40 & 0xFFFFFFFFFFFFFFF8);
            int64x2_t v167 = vdupq_n_s64(0x40uLL);
            int8x16_t v168 = 0uLL;
            int8x16_t v169 = 0uLL;
            do
            {
              uint8x8_t v170 = *v164++;
              uint16x8_t v171 = vmovl_u8(v170);
              uint32x4_t v172 = vmovl_high_u16(v171);
              v173.i64[0] = v172.u32[2];
              v173.i64[1] = v172.u32[3];
              uint64x2_t v174 = v173;
              v173.i64[0] = v172.u32[0];
              v173.i64[1] = v172.u32[1];
              uint64x2_t v175 = v173;
              uint32x4_t v176 = vmovl_u16(*(uint16x4_t *)v171.i8);
              v173.i64[0] = v176.u32[2];
              v173.i64[1] = v176.u32[3];
              uint64x2_t v177 = v173;
              v173.i64[0] = v176.u32[0];
              v173.i64[1] = v176.u32[1];
              int8x16_t v169 = vorrq_s8((int8x16_t)vshlq_u64(v174, (uint64x2_t)vandq_s8((int8x16_t)v160, v165)), v169);
              int8x16_t v168 = vorrq_s8((int8x16_t)vshlq_u64(v175, (uint64x2_t)vandq_s8((int8x16_t)v161, v165)), v168);
              int8x16_t v159 = vorrq_s8((int8x16_t)vshlq_u64(v177, (uint64x2_t)vandq_s8((int8x16_t)v162, v165)), v159);
              int8x16_t v158 = vorrq_s8((int8x16_t)vshlq_u64(v173, (uint64x2_t)vandq_s8((int8x16_t)v163, v165)), v158);
              int64x2_t v161 = vaddq_s64(v161, v167);
              int64x2_t v162 = vaddq_s64(v162, v167);
              int64x2_t v163 = vaddq_s64(v163, v167);
              int64x2_t v160 = vaddq_s64(v160, v167);
              v166 += 8;
            }
            while (v166);
            int8x16_t v178 = vorrq_s8(vorrq_s8(v158, v168), vorrq_s8(v159, v169));
            int8x8_t v118 = vorr_s8(*(int8x8_t *)v178.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v178, v178, 8uLL));
            if (v40 != v117)
            {
LABEL_180:
              uint64_t v179 = v10 - v117 - 8;
              unint64_t v180 = &v11->u8[v117 + 8];
              do
              {
                unsigned int v181 = *v180++;
                *(void *)&v118 |= (unint64_t)v181 << (v119 & 0x38);
                v119 += 8;
                --v179;
              }
              while (v179);
            }
          }
        }
        unint64_t v182 = 0xA000000000000000;
        if (((*(void *)&v118 | *(void *)&v15) & 0x8080808080808080) == 0) {
          unint64_t v182 = 0xE000000000000000;
        }
        int64_t v16 = v182 | (v10 << 56) | *(void *)&v118;
        goto LABEL_185;
      }
LABEL_189:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
  }
  a4 = v37;
LABEL_80:
  if (a4 < v32) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  if (__OFADD__(a4, 1))
  {
    __break(1u);
    goto LABEL_196;
  }
  uint64_t v44 = specialized Slice.subscript.getter(v32, a4 + 1, v32, v33);
  uint64_t v48 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v44, v45, v46, v47);
  int8x8_t v186 = 0;
  unint64_t v187 = 0xE000000000000000;
  uint64_t v50 = v10 + 15;
  if (__OFADD__(v10, 15))
  {
LABEL_196:
    __break(1u);
    return;
  }
  int64_t v51 = v48;
  uint64_t v52 = v49;
  if (v50 >= 16)
  {
    uint64_t v53 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v54 & 1) != 0 || v53 < v50) {
      _StringGuts.grow(_:)(v10 + 15);
    }
  }
  a5 = v185;
  while (2)
  {
    if (v51 < 0) {
      goto LABEL_189;
    }
    uint64_t v61 = v10;
    if (v10 < v51)
    {
      unint64_t v183 = 1861;
      goto LABEL_187;
    }
    unint64_t v62 = v187;
    uint64_t v63 = *(void *)&v186 & 0xFFFFFFFFFFFFLL;
    if ((v187 & 0x2000000000000000) != 0) {
      uint64_t v63 = HIBYTE(v187) & 0xF;
    }
    BOOL v39 = __OFADD__(v63, v10);
    uint64_t v64 = v63 + v10;
    if (v39)
    {
      __break(1u);
      goto LABEL_192;
    }
    Swift::Int v65 = v64 + 3;
    if (__OFADD__(v64, 3))
    {
LABEL_192:
      __break(1u);
LABEL_193:
      unint64_t v183 = 1860;
LABEL_187:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v183, 0);
    }
    if (v65 >= 16)
    {
      uint64_t v66 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v67 & 1) != 0 || v66 < v65)
      {
        _StringGuts.grow(_:)(v65);
        unint64_t v62 = v187;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v62 & 0xFFFFFFFFFFFFFFFLL, v11->i8, v51, 0);
    int8x8_t v186 = *(int8x8_t *)((v62 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
    size_t v188 = 3;
    uint64_t v189 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v189, &v188, &v186);
    if (v61 < v52) {
      goto LABEL_189;
    }
    if (v52 < 0) {
      goto LABEL_193;
    }
    uint64_t v10 = v61 - v52;
    if (v61 - v52 < 0) {
      goto LABEL_188;
    }
    uint64_t v68 = (uint64_t)v11->i64 + v52;
    if (_allASCII(_:)((uint64_t *)((char *)v11->i64 + v52), v61 - v52))
    {
LABEL_155:
      _StringGuts.appendInPlace(_:isASCII:)(&v11->i8[v52], v61 - v52, 0);
      break;
    }
    uint64_t v69 = 0;
    Swift::Int v70 = &v11->u8[v61];
    if (!v11) {
      Swift::Int v70 = 0;
    }
    for (unint64_t i = &v11->u8[v52]; ; ++i)
    {
      while (1)
      {
LABEL_107:
        if (!i || i == v70) {
          goto LABEL_155;
        }
        unsigned int v73 = *i++;
        unsigned int v72 = v73;
        if ((v72 & 0x80) != 0) {
          break;
        }
        ++v69;
      }
      if ((v72 + 62) >= 0x33u) {
        goto LABEL_88;
      }
      if (v72 > 0xDF) {
        break;
      }
      if (!i || i == v70 || (*i & 0xC0) != 0x80) {
        goto LABEL_88;
      }
      v69 += 2;
    }
    if (v72 == 224)
    {
      if (!i) {
        goto LABEL_88;
      }
      if (i == v70) {
        goto LABEL_88;
      }
      uint64_t v74 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_88;
      }
      goto LABEL_134;
    }
    if (v72 <= 0xEC) {
      goto LABEL_130;
    }
    if (v72 == 237)
    {
      if (!i) {
        goto LABEL_88;
      }
      if (i == v70) {
        goto LABEL_88;
      }
      uint64_t v74 = i + 1;
      unsigned int v75 = *i;
      if (v75 > 0x9F) {
        goto LABEL_88;
      }
      goto LABEL_133;
    }
    if (v72 <= 0xEF)
    {
LABEL_130:
      if (!i || i == v70) {
        goto LABEL_88;
      }
      uint64_t v74 = i + 1;
      LOBYTE(v75) = *i;
LABEL_133:
      if ((v75 & 0xC0) != 0x80) {
        goto LABEL_88;
      }
LABEL_134:
      if (v74 == v70 || (*v74 & 0xC0) != 0x80) {
        goto LABEL_88;
      }
      i += 2;
      v69 += 3;
      goto LABEL_107;
    }
    if (v72 == 240)
    {
      if (!i) {
        goto LABEL_88;
      }
      if (i == v70) {
        goto LABEL_88;
      }
      unint64_t v76 = i + 1;
      if ((*i + 64) < 0xD0u) {
        goto LABEL_88;
      }
      goto LABEL_150;
    }
    if ((v72 + 15) <= 2u)
    {
      if (!i || i == v70) {
        goto LABEL_88;
      }
      unint64_t v76 = i + 1;
      LOBYTE(v77) = *i;
      goto LABEL_149;
    }
    if (i)
    {
      if (i != v70)
      {
        unint64_t v76 = i + 1;
        unsigned int v77 = *i;
        if (v77 <= 0x8F)
        {
LABEL_149:
          if ((v77 & 0xC0) != 0x80) {
            goto LABEL_88;
          }
LABEL_150:
          if (v76 == v70 || (i[1] & 0xC0) != 0x80 || i + 2 == v70 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_88;
          }
          i += 3;
          v69 += 4;
          goto LABEL_107;
        }
      }
    }
LABEL_88:
    uint64_t v55 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v55);
    uint64_t v56 = specialized Collection.subscript.getter(v69, v68, v61 - v52);
    int64_t v51 = findInvalidRange #1 (_:) in validateUTF8(_:)(v56, v57, v58, v59);
    uint64_t v52 = v60;
    size_t v11 = (uint8x16_t *)v68;
    if (v10) {
      continue;
    }
    break;
  }
  int8x8_t v15 = v186;
  int64_t v16 = v187;
  a4 = v184;
LABEL_185:
  (*(void (**)(int8x8_t, int64_t, uint64_t, uint64_t))(a5 + 24))(v15, v16, a4, a5);
  swift_bridgeObjectRelease(v16);
}

uint64_t String.subscript.getter(Swift::String::Index a1, uint64_t a2, unint64_t a3)
{
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  uint64_t v6 = (v5._rawBits >> 8) & 0x3F;
  int64_t v7 = v5._rawBits >> 16;
  if (v6) {
    goto LABEL_24;
  }
  uint64_t v8 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000) != 0) {
    uint64_t v9 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v9 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5._rawBits >> 14 != 4 * v9)
  {
    if ((a3 & 0x1000000000000000) != 0) {
      goto LABEL_39;
    }
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v21 = a2;
      uint64_t v22 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v7 + 1 != (HIBYTE(a3) & 0xF))
      {
        int v13 = *(unsigned __int16 *)((char *)&v21 + v7);
        if (v13 == 2573 || (v13 & 0x80808080) != 0) {
          goto LABEL_39;
        }
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0) {
        size_t v11 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        size_t v11 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      if (v7 + 1 != v8)
      {
        if (!v11) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        int v12 = *(unsigned __int16 *)&v11[v7];
        if (v12 == 2573 || (v12 & 0x80808080) != 0)
        {
LABEL_39:
          uint64_t v6 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v7);
          int64_t v10 = v6 + v7;
          if ((a3 & 0x1000000000000000) == 0) {
            goto LABEL_25;
          }
LABEL_40:
          return _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v7, v10)._countAndFlagsBits;
        }
      }
    }
    uint64_t v6 = 1;
LABEL_24:
    int64_t v10 = v6 + v7;
    if ((a3 & 0x1000000000000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_40;
  }
  uint64_t v6 = 0;
  int64_t v10 = v5._rawBits >> 16;
  if ((a3 & 0x1000000000000000) != 0) {
    goto LABEL_40;
  }
LABEL_25:
  if (v10 < v7) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((a3 & 0x2000000000000000) == 0)
  {
    if ((a2 & 0x1000000000000000) != 0)
    {
      id v15 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v16 = a2 & 0xFFFFFFFFFFFFLL;
      if ((a2 & 0xFFFFFFFFFFFFLL) >= v10)
      {
LABEL_29:
        char v17 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v7, v10, (uint64_t)v15, v16);
        return specialized static String._uncheckedFromUTF8(_:)(v17, v18);
      }
    }
    else
    {
      id v15 = _StringObject.sharedUTF8.getter(a2, a3);
      uint64_t v16 = v20;
      if (v20 >= v10) {
        goto LABEL_29;
      }
    }
LABEL_37:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
  }
  uint64_t v21 = a2;
  uint64_t v22 = a3 & 0xFFFFFFFFFFFFFFLL;
  if ((uint64_t)(HIBYTE(a3) & 0xF) < v10) {
    goto LABEL_37;
  }
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)&v21 + v7), v6);
}

void specialized String.write<A>(to:)(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v6 = a1[1];
  uint64_t v7 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000) == 0) {
    uint64_t v7 = *a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (*a1 & ~v6 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(a2, a3);
  }
  else
  {
    swift_bridgeObjectRetain(a3);
    swift_bridgeObjectRelease(v6);
    *a1 = a2;
    a1[1] = a3;
  }
}

void protocol witness for TextOutputStream.write(_:) in conformance _Stdout(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    unint64_t v3 = a1;
    unint64_t v4 = a2;
    swift_bridgeObjectRetain(a2);
    specialized String.withUTF8<A>(_:)(&v3);
    swift_bridgeObjectRelease(v4);
  }
}

Swift::Void __swiftcall String.write(_:)(Swift::String a1)
{
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v4 = v1[1];
  uint64_t v5 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    uint64_t v5 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 || (*v1 & ~v4 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(a1._countAndFlagsBits, (unint64_t)a1._object);
  }
  else
  {
    swift_bridgeObjectRetain((unint64_t)a1._object);
    swift_bridgeObjectRelease(v4);
    *uint64_t v1 = countAndFlagsBits;
    v1[1] = (uint64_t)object;
  }
}

uint64_t _StringGuts.init(_:isASCII:)(uint64_t a1, unint64_t a2, char a3)
{
  unint64_t v3 = a2 | 0xC000000000000000;
  if ((a3 & 1) == 0) {
    unint64_t v3 = a2;
  }
  return v3 | 0x1000000000000000;
}

void _StringGuts.append(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v5 = v2[1];
  if ((v5 & 0x2000000000000000) != 0)
  {
    if ((a2 & 0x2000000000000000) != 0)
    {
      unint64_t v7 = specialized _SmallString.init(_:appending:)(*v2, v2[1], a1, a2);
      if ((v9 & 1) == 0)
      {
        unint64_t v10 = v7;
        unint64_t v11 = v8;
        swift_bridgeObjectRelease(v5);
        unint64_t *v2 = v10;
        v2[1] = v11;
        return;
      }
      goto LABEL_8;
    }
  }
  else if ((a2 & 0x2000000000000000) != 0)
  {
LABEL_8:
    uint64_t v6 = HIBYTE(a2) & 0xF;
    goto LABEL_9;
  }
  uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
LABEL_9:

  _StringGuts.append(_:)(a1, a2, 0, v6);
}

uint64_t Character.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(a2, a3, a4, a5);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Character(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Character.write<A>(to:)(a1, *v3, v3[1], a2, a3);
}

void Unicode.Scalar.write<A>(to:)(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2);
  uint64_t v7 = v6;
  (*(void (**)(uint64_t))(a4 + 24))(v5);

  swift_bridgeObjectRelease(v7);
}

void protocol witness for TextOutputStreamable.write<A>(to:) in conformance Unicode.Scalar(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Unicode.Scalar.write<A>(to:)(a1, *v3, a2, a3);
}

void *_playgroundPrintHook.getter()
{
  uint64_t v0 = _playgroundPrintHook;
  outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((atomic_ullong *)_playgroundPrintHook, (atomic_ullong *)qword_1E8EBFEF8);
  return v0;
}

uint64_t _playgroundPrintHook.setter(void *a1, uint64_t a2)
{
  uint64_t v2 = _playgroundPrintHook;
  uint64_t v3 = qword_1E8EBFEF8;
  _playgroundPrintHook = a1;
  qword_1E8EBFEF8 = a2;
  return outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v2, v3);
}

uint64_t (*_playgroundPrintHook.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Void __swiftcall _TeeStream.write(_:)(Swift::String a1)
{
  uint64_t v2 = v1;
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  (*(void (**)(uint64_t, void *, void))(*(void *)(v1 + 32) + 24))(a1._countAndFlagsBits, a1._object, *(void *)(v1 + 16));
  (*(void (**)(uint64_t, void *, void))(*(void *)(v2 + 40) + 24))(countAndFlagsBits, object, *(void *)(v2 + 24));
}

Swift::Void __swiftcall _TeeStream._lock()()
{
  uint64_t v1 = v0;
  (*(void (**)(void))(*(void *)(v0 + 32) + 8))(*(void *)(v0 + 16));
  (*(void (**)(void))(*(void *)(v1 + 40) + 8))(*(void *)(v1 + 24));
}

Swift::Void __swiftcall _TeeStream._unlock()()
{
  uint64_t v1 = v0;
  (*(void (**)(void))(*(void *)(v0 + 40) + 16))(*(void *)(v0 + 24));
  uint64_t v2 = *(void (**)(uint64_t))(*(void *)(v1 + 32) + 16);
  uint64_t v3 = *(void *)(v1 + 16);

  v2(v3);
}

uint64_t _Pointer.successor()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(a2 + 48))();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for _Pointer, associated type descriptor for _Pointer.Pointee);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 56))(v4 + *(void *)(*((void *)AssociatedTypeWitness - 1) + 72), a1, a2);
}

uint64_t _Pointer.predecessor()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(a2 + 48))();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for _Pointer, associated type descriptor for _Pointer.Pointee);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 56))(v4 - *(void *)(*((void *)AssociatedTypeWitness - 1) + 72), a1, a2);
}

void *static Strideable<>.-= infix(_:_:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 32);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int v12 = (char *)&v16 - v11;
  size_t v13 = *(void *)(*(void *)(a3 - 8) + 64);
  MEMORY[0x1F4188790](v10);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric);
  (*(void (**)(uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 16))(a2, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 48))(v12, a3, v7);
  (*(void (**)(char *, const char *))(v9 + 8))(v12, AssociatedTypeWitness);
  return memcpy(a1, (char *)&v16 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v13);
}

void *_convertConstArrayToPointerArgument<A, B>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  swift_bridgeObjectRetain(a2);
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    || (a2 & 0x8000000000000000) == 0 && (a2 & 0x4000000000000000) == 0)
  {
    swift_bridgeObjectRelease(a2);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)) {
      unint64_t v9 = (a2 & 0xFFFFFFFFFFFFFF8)
    }
         + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80));
    else {
      unint64_t v9 = a2
    }
         + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80));
LABEL_7:
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (a2 < 0 || (a2 & 0x4000000000000000) != 0))
    {
      if (a2 < 0) {
        uint64_t v10 = (void *)a2;
      }
      else {
        uint64_t v10 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
      }
      swift_unknownObjectRetain(v10);
      if (v9) {
        goto LABEL_14;
      }
    }
    else
    {
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)) {
        uint64_t v10 = (void *)(a2 & 0xFFFFFFFFFFFFFF8);
      }
      else {
        uint64_t v10 = (void *)a2;
      }
      swift_bridgeObjectRetain(a2);
      if (v9) {
        goto LABEL_14;
      }
    }
    (*(void (**)(unint64_t, uint64_t, uint64_t))(a5 + 56))(~*(unsigned char *)(*(a3 - 1) + 80) | 0xFFFFFFFFFFFFFF00, a4, a5);
    return v10;
  }
  if (!Array._getCount()())
  {
    swift_bridgeObjectRelease(a2);
    unint64_t v9 = 0;
    goto LABEL_7;
  }
  uint64_t v14 = (unint64_t *)type metadata accessor for _ArrayBuffer(0, (uint64_t)a3, v11, v12);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _ArrayBuffer<A>, v14, v15);
  uint64_t v10 = (void *)(*(uint64_t (**)(unint64_t *, uint64_t))(WitnessTable + 56))(v14, WitnessTable);
  unint64_t v9 = (unint64_t)v10
     + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80));
LABEL_14:
  (*(void (**)(unint64_t, uint64_t, uint64_t))(a5 + 56))(v9, a4, a5);
  return v10;
}

void *_convertMutableArrayToPointerArgument<A, B>(_:)(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)a3, (uint64_t)a3, a4);
  Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(0, 0);
  unint64_t v10 = *a2;
  if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    && ((v10 & 0x8000000000000000) != 0 || (v10 & 0x4000000000000000) != 0))
  {
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v9, v11);
    if ((Collection.isEmpty.getter((uint64_t)v9, WitnessTable) & 1) == 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Pointer.swift", 19, 2, 0x1E3uLL, 0);
    }
  }
  else
  {
    _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
  }
  uint64_t v12 = *a2;
  swift_bridgeObjectRetain(*a2);
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    || (v12 & 0x8000000000000000) == 0 && (v12 & 0x4000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v12);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)) {
      unint64_t v13 = (v12 & 0xFFFFFFFFFFFFFF8)
    }
          + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80));
    else {
      unint64_t v13 = v12
    }
          + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80));
LABEL_11:
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (v12 < 0 || (v12 & 0x4000000000000000) != 0))
    {
      if (v12 < 0) {
        uint64_t v14 = (void *)v12;
      }
      else {
        uint64_t v14 = (void *)(v12 & 0xFFFFFFFFFFFFFF8);
      }
      swift_unknownObjectRetain(v14);
      if (v13) {
        goto LABEL_18;
      }
    }
    else
    {
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)) {
        uint64_t v14 = (void *)(v12 & 0xFFFFFFFFFFFFFF8);
      }
      else {
        uint64_t v14 = (void *)v12;
      }
      swift_bridgeObjectRetain(v12);
      if (v13) {
        goto LABEL_18;
      }
    }
    (*(void (**)(unint64_t, uint64_t, uint64_t))(a5 + 56))(~*(unsigned char *)(*(a3 - 1) + 80) | 0xFFFFFFFFFFFFFF00, a4, a5);
    return v14;
  }
  if (!Array._getCount()())
  {
    swift_bridgeObjectRelease(v12);
    unint64_t v13 = 0;
    goto LABEL_11;
  }
  uint64_t v19 = (unint64_t *)type metadata accessor for _ArrayBuffer(0, (uint64_t)a3, v16, v17);
  uint64_t v21 = swift_getWitnessTable(protocol conformance descriptor for _ArrayBuffer<A>, v19, v20);
  uint64_t v14 = (void *)(*(uint64_t (**)(unint64_t *, uint64_t))(v21 + 56))(v19, v21);
  unint64_t v13 = (unint64_t)v14
      + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80));
LABEL_18:
  (*(void (**)(unint64_t, uint64_t, uint64_t))(a5 + 56))(v13, a4, a5);
  return v14;
}

__objc2_class **_convertConstStringToUTF8PointerArgument<A>(_:)(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = String.utf8CString.getter(a2, a3);
  (*(void (**)(__objc2_class **, uint64_t, uint64_t))(a5 + 56))(v7 + 4, a4, a5);
  return v7;
}

__objc2_class **String.utf8CString.getter(unint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000) == 0)
  {
    if ((a2 & 0x2000000000000000) != 0)
    {
      v11[0] = a1;
      v11[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      int64_t v5 = HIBYTE(a2) & 0xF;
      uint64_t v4 = (char *)v11;
    }
    else if ((a1 & 0x1000000000000000) != 0)
    {
      uint64_t v4 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      int64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      uint64_t v4 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
      if (!v4)
      {
        uint64_t v6 = &_swiftEmptyArrayStorage;
        goto LABEL_7;
      }
    }
    uint64_t v6 = specialized _copyCollectionToContiguousArray<A>(_:)(v4, v5);
LABEL_7:
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v6);
    v11[0] = v6;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v6[2]->isa + 1, 1);
      uint64_t v6 = (__objc2_class **)v11[0];
    }
    unint64_t v9 = v6[2];
    unint64_t v8 = (unint64_t)v6[3];
    if ((unint64_t)v9 >= v8 >> 1)
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v8 > 1), (int64_t)&v9->isa + 1, 1);
      uint64_t v6 = (__objc2_class **)v11[0];
    }
    v6[2] = (__objc2_class *)((char *)&v9->isa + 1);
    *((unsigned char *)&v9->info + (void)v6) = 0;
    return v6;
  }
  return String._slowUTF8CString()(a1, a2);
}

uint64_t protocol witness for Error._domain.getter in conformance Never(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError(a1, a2, &demangling cache variable for type metadata for Never.Type);
}

uint64_t protocol witness for Error._domain.getter in conformance _MergeError(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = a1;
  v5[0] = 0;
  v5[1] = 0xE000000000000000;
  uint64_t v3 = (Class *)__swift_instantiateConcreteTypeFromMangledName(a3);
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v6, (uint64_t)v5, v3, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  return v5[0];
}

uint64_t Never.init(from:)(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v2);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8))(v2, v3);
  swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
  *(void *)uint64_t v5 = &type metadata for Never;
  *(void *)(v5 + 8) = v4;
  *(void *)(v5 + 16) = 0xD000000000000026;
  *(void *)(v5 + 24) = 0x80000001816DEEF0;
  *(void *)(v5 + 32) = 0;
  *(unsigned char *)(v5 + 72) = 0;
  swift_willThrow();
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Never(uint64_t *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 8))(v4, v5);
  swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
  *(void *)uint64_t v7 = v2;
  *(void *)(v7 + 8) = v6;
  *(void *)(v7 + 16) = 0xD000000000000026;
  *(void *)(v7 + 24) = 0x80000001816DEEF0;
  *(void *)(v7 + 32) = 0;
  *(unsigned char *)(v7 + 72) = 0;
  swift_willThrow();
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t (*LazyPrefixWhileSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyPrefixWhileSequence.init(_base:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return LazyDropWhileSequence.init(_base:predicate:)(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyPrefixWhileSequence, a6);
}

uint64_t LazyDropWhileSequence.init(_base:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t (*a6)(void, uint64_t, uint64_t)@<X5>, uint64_t a7@<X8>)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(a7, a1, a4);
  uint64_t result = a6(0, a4, a5);
  uint64_t v14 = (void *)(a7 + *(int *)(result + 36));
  *uint64_t v14 = a2;
  v14[1] = a3;
  return result;
}

uint64_t LazyPrefixWhileSequence.Iterator._predicateHasFailed.getter()
{
  return *v0;
}

uint64_t (*LazyPrefixWhileSequence.Iterator._predicateHasFailed.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyPrefixWhileSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t LazyPrefixWhileSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*LazyPrefixWhileSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.Iterator._predicate.getter(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(v1 + *(int *)(a1 + 40));
  uint64_t v3 = *v2;
  swift_retain((atomic_ullong *)v2[1]);
  return v3;
}

uint64_t LazyPrefixWhileSequence.Iterator.init(_base:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, unsigned char *a6@<X8>)
{
  return LazyDropWhileSequence.Iterator.init(_base:predicate:)(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, int **))type metadata accessor for LazyPrefixWhileSequence.Iterator, a6);
}

uint64_t LazyDropWhileSequence.Iterator.init(_base:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, uint64_t (*a6)(void, uint64_t, int **)@<X5>, unsigned char *a7@<X8>)
{
  *a7 = 0;
  uint64_t v13 = a6(0, a4, a5);
  uint64_t v14 = &a7[*(int *)(v13 + 36)];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(v14, a1, AssociatedTypeWitness);
  uint64_t v17 = &a7[*(int *)(v13 + 40)];
  *uint64_t v17 = a2;
  v17[1] = a3;
  return result;
}

uint64_t LazyPrefixWhileSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v10 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v27 - v12;
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  uint64_t v18 = (char *)&v27 - v17;
  if ((*v2 & 1) == 0)
  {
    uint64_t v27 = v16;
    uint64_t v28 = v15;
    uint64_t v29 = v2;
    uint64_t v30 = a2;
    uint64_t v20 = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)v20, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v22 = *(void (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
    unsigned __int8 v23 = swift_checkMetadataState(0, (uint64_t)v20);
    v22(v23, AssociatedConformanceWitness);
    if ((*(unsigned int (**)(char *, uint64_t, const char *))(v14 + 48))(v13, 1, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v27 + 8))(v13, v28);
      uint64_t v19 = 1;
    }
    else
    {
      int v24 = *(void (**)(char *, char *, const char *))(v14 + 32);
      v24(v18, v13, AssociatedTypeWitness);
      if ((*(uint64_t (**)(char *))&v29[*(int *)(a1 + 40)])(v18))
      {
        unsigned int v25 = v30;
        v24(v30, v18, AssociatedTypeWitness);
        a2 = v25;
        uint64_t v19 = 0;
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v14 + 56))(a2, v19, 1, AssociatedTypeWitness);
      }
      (*(void (**)(char *, const char *))(v14 + 8))(v18, AssociatedTypeWitness);
      uint64_t v19 = 1;
      *uint64_t v29 = 1;
    }
    a2 = v30;
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v14 + 56))(a2, v19, 1, AssociatedTypeWitness);
  }
  uint64_t v19 = 1;
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v14 + 56))(a2, v19, 1, AssociatedTypeWitness);
}

double LazyPrefixWhileSequence.makeIterator()@<D0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  *(void *)&double result = LazyDropWhileSequence.makeIterator()(a1, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyPrefixWhileSequence.Iterator, a2).n128_u64[0];
  return result;
}

__n128 LazyDropWhileSequence.makeIterator()@<Q0>(uint64_t a1@<X0>, uint64_t (*a2)(void, uint64_t, uint64_t)@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 32))((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v3, v7);
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t))(v10 + 32);
  uint64_t v12 = a2(0, v7, v10);
  v11(v7, v10);
  uint64_t v13 = *(int *)(a1 + 36);
  *a3 = 0;
  __n128 result = *(__n128 *)(v3 + v13);
  *(__n128 *)&a3[*(int *)(v12 + 40)] = result;
  return result;
}

atomic_ullong *LazySequenceProtocol.prefix(while:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazySequenceProtocol.drop(while:)(a1, a2, a3, a4, (uint64_t (*)(void, const char *, uint64_t))type metadata accessor for LazyPrefixWhileSequence, a5);
}

atomic_ullong *LazySequenceProtocol.drop(while:)@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void, const char *, uint64_t)@<X4>, uint64_t a6@<X8>)
{
  uint64_t v20 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v19 - v14;
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(v6, a3);
  (*(void (**)(uint64_t, char *, const char *))(v13 + 32))(a6, v15, AssociatedTypeWitness);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v17 = (void *)(a6 + *(int *)(a5(0, AssociatedTypeWitness, AssociatedConformanceWitness) + 36));
  *uint64_t v17 = v20;
  v17[1] = a2;
  return swift_retain(a2);
}

uint64_t LazyPrefixWhileSequence<>.Index._value.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v5 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v5 - 1) + 2);

  return v6(a3, v3, v5);
}

uint64_t LazyPrefixWhileSequence<>.Index.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(uint64_t, uint64_t, const char *))(v9 + 32))(a4, a1, AssociatedTypeWitness);
  uint64_t v7 = *(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v9 + 56);

  return v7(a4, 0, 1, AssociatedTypeWitness);
}

uint64_t LazyPrefixWhileSequence<>.Index.init(endOf:)@<X0>(uint64_t a1@<X1>, int **a2@<X2>, uint64_t a3@<X8>)
{
  (*(void (**)(void))(*(void *)(a1 - 8) + 8))();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a2, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56);

  return v7(a3, 1, 1, AssociatedTypeWitness);
}

uint64_t static LazyPrefixWhileSequence<>.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t v33 = a1;
  uint64_t v34 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v31 = (char *)&v29 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v30 = (char *)&v29 - v10;
  uint64_t v32 = a3;
  uint64_t v12 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(255, a3, (uint64_t)a4, v11);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v12, (uint64_t)v12, 0, 0);
  uint64_t v14 = MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  uint64_t v16 = (char *)&v29 - v15;
  uint64_t v17 = (char *)&v29 + *(int *)(v14 + 56) - v15;
  uint64_t v18 = (uint64_t)*(v12 - 1);
  uint64_t v19 = *(void (**)(char *, uint64_t, Class *))(v18 + 16);
  v19((char *)&v29 - v15, v33, v12);
  v19(v17, v34, v12);
  uint64_t v20 = (uint64_t (*)(char *, uint64_t, const char *))v7[6];
  LODWORD(v19) = v20(v16, 1, AssociatedTypeWitness);
  int v21 = v20(v17, 1, AssociatedTypeWitness);
  if (v19 != 1)
  {
    if (v21 != 1)
    {
      unsigned __int8 v23 = (void (*)(char *, char *, const char *))v7[4];
      int v24 = v30;
      v23(v30, v16, AssociatedTypeWitness);
      unsigned int v25 = v31;
      v23(v31, v17, AssociatedTypeWitness);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, v32, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
      char v22 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v24, v25, AssociatedTypeWitness);
      uint64_t v27 = (void (*)(char *, const char *))v7[1];
      v27(v25, AssociatedTypeWitness);
      v27(v24, AssociatedTypeWitness);
      return v22 & 1;
    }
    ((void (*)(char *, const char *))v7[1])(v16, AssociatedTypeWitness);
    goto LABEL_7;
  }
  if (v21 != 1)
  {
    (*(void (**)(char *, Class *))(v18 + 8))(v17, v12);
LABEL_7:
    char v22 = 0;
    return v22 & 1;
  }
  char v22 = 1;
  return v22 & 1;
}

uint64_t static LazyPrefixWhileSequence<>.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t v32 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v30 = (char *)&v29 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v29 = (char *)&v29 - v11;
  uint64_t v31 = a3;
  uint64_t v13 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(255, a3, (uint64_t)a4, v12);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v13, (uint64_t)v13, 0, 0);
  uint64_t v15 = MEMORY[0x1F4188790](TupleTypeMetadata2 - 1);
  uint64_t v17 = (char *)&v29 - v16;
  uint64_t v18 = (char *)&v29 + *(int *)(v15 + 56) - v16;
  uint64_t v19 = (uint64_t)*(v13 - 1);
  uint64_t v20 = *(void (**)(char *, uint64_t, Class *))(v19 + 16);
  v20((char *)&v29 - v16, a1, v13);
  v20(v18, v32, v13);
  int v21 = *(unsigned int (**)(char *, uint64_t, const char *))(v8 + 48);
  if (v21(v17, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v19 + 8))(v18, v13);
    char v22 = 0;
  }
  else if (v21(v18, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, const char *))(v8 + 8))(v17, AssociatedTypeWitness);
    char v22 = 1;
  }
  else
  {
    unsigned __int8 v23 = *(void (**)(char *, char *, const char *))(v8 + 32);
    int v24 = v29;
    v23(v29, v17, AssociatedTypeWitness);
    unsigned int v25 = v30;
    v23(v30, v18, AssociatedTypeWitness);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, v31, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
    char v22 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 16))(v24, v25, AssociatedTypeWitness, AssociatedConformanceWitness);
    uint64_t v27 = *(void (**)(char *, const char *))(v8 + 8);
    v27(v25, AssociatedTypeWitness);
    v27(v24, AssociatedTypeWitness);
  }
  return v22 & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance LazyPrefixWhileSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static LazyPrefixWhileSequence<>.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(int ***)(a3 + 24));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance LazyPrefixWhileSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static LazyPrefixWhileSequence<>.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(int ***)(a3 + 24));
}

void LazyPrefixWhileSequence<>.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v7 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  uint64_t v14 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0, v8, (uint64_t)v7, v13);
  MEMORY[0x1F4188790](v14);
  uint64_t v16 = (char *)&v18 - v15;
  (*(void (**)(char *, uint64_t))(v17 + 16))((char *)&v18 - v15, v4);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v10 + 48))(v16, 1, AssociatedTypeWitness) == 1)
  {
    Hasher._combine(_:)(0x7FFFFFFFFFFFFFFFuLL);
  }
  else
  {
    (*(void (**)(char *, char *, const char *))(v10 + 32))(v12, v16, AssociatedTypeWitness);
    (*(void (**)(uint64_t, const char *, uint64_t))(a3 + 24))(a1, AssociatedTypeWitness, a3);
    (*(void (**)(char *, const char *))(v10 + 8))(v12, AssociatedTypeWitness);
  }
}

Swift::Int LazyPrefixWhileSequence<>.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18[-1] - v9;
  uint64_t v12 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0, v6, (uint64_t)v5, v11);
  MEMORY[0x1F4188790](v12);
  uint64_t v14 = (char *)&v18[-1] - v13;
  v18[0] = 0;
  v18[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v18[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v18[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v18[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v19 = 0u;
  long long v20 = 0u;
  (*(void (**)(char *, uint64_t))(v15 + 16))((char *)&v18[-1] - v13, v3);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v8 + 48))(v14, 1, AssociatedTypeWitness) == 1)
  {
    Hasher._combine(_:)(0x7FFFFFFFFFFFFFFFuLL);
  }
  else
  {
    (*(void (**)(char *, char *, const char *))(v8 + 32))(v10, v14, AssociatedTypeWitness);
    (*(void (**)(void *, const char *, uint64_t))(a2 + 24))(v18, AssociatedTypeWitness, a2);
    (*(void (**)(char *, const char *))(v8 + 8))(v10, AssociatedTypeWitness);
  }
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> LazyPrefixWhileSequence<A><>.Index(uint64_t a1, uint64_t a2)
{
  return LazyPrefixWhileSequence<>.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <> LazyPrefixWhileSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> LazyPrefixWhileSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))LazyPrefixWhileSequence<>.Index<>.hash(into:));
}

uint64_t LazyPrefixWhileSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(a2 + 64))(v5);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *(uint64_t (**)(uint64_t, void, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56);

  return v7(a3, 0, 1, AssociatedTypeWitness);
}

uint64_t LazyPrefixWhileSequence<>.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v22 = a1;
  uint64_t v23 = a3;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a2 + 8), v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t v10 = (uint64_t)*(v9 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v22 - v12;
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v22 - v15;
  Collection.first.getter(v5, a2, (uint64_t)v13);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v14 + 48))(v13, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v10 + 8))(v13, v9);
  }
  else
  {
    (*(void (**)(char *, char *, const char *))(v14 + 32))(v16, v13, AssociatedTypeWitness);
    char v17 = (*(uint64_t (**)(char *))(v3 + *(int *)(v22 + 36)))(v16);
    (*(void (**)(char *, const char *))(v14 + 8))(v16, AssociatedTypeWitness);
    if (v17)
    {
      uint64_t v18 = swift_getAssociatedTypeWitness(0, (int **)a2, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v18 - 1) + 56))(v23, 1, 1, v18);
    }
  }
  uint64_t v20 = v23;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(v5, a2);
  int v21 = swift_getAssociatedTypeWitness(0, (int **)a2, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(*((void *)v21 - 1) + 56))(v20, 0, 1, v21);
}

uint64_t LazyPrefixWhileSequence<>.index(after:)@<X0>(void (*a1)(char *, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint16x8_t v103 = a1;
  uint64_t v88 = a5;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v107 = a2;
  uint64x2_t v97 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0, v6, a3, a4);
  uint64_t v95 = (uint64_t)*(v97 - 1);
  MEMORY[0x1F4188790](v97);
  uint64x2_t v96 = (char *)&v83 - v8;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v106 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint32x4_t v94 = (char *)&v83 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint16x8_t v93 = (char *)&v83 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  int8x16_t v100 = (char *)&v83 - v14;
  MEMORY[0x1F4188790](v13);
  int8x16_t v91 = (char *)&v83 - v15;
  uint64_t v16 = swift_getAssociatedTypeWitness(255, *(int ***)(a3 + 8), v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int8x16_t v87 = type metadata accessor for Optional(0, (uint64_t)v16, v17, v18);
  uint64_t v86 = (uint64_t)*(v87 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v87);
  int v21 = (char *)&v83 - v20;
  uint64_t v99 = *((void *)v16 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  int64x2_t v84 = (char *)&v83 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unsigned int v26 = (char *)&v83 - v25;
  uint64_t v27 = *(void *)(a2 - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v24);
  uint8x8_t v92 = (char *)&v83 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v28);
  uint64_t v31 = (char *)&v83 - v30;
  uint64_t v33 = type metadata accessor for LazyPrefixWhileSequence<>.Index(0, v6, a3, v32);
  uint64_t v34 = (uint64_t)*(v33 - 1);
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v37 = (char *)&v83 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v35);
  BOOL v39 = (char *)&v83 - v38;
  unint64_t v40 = *(void (**)(char *, void))(v34 + 16);
  uint32x4_t v98 = v41;
  v40((char *)&v83 - v38, v103);
  uint64_t v105 = v27;
  uint64_t v42 = v27;
  uint64_t v43 = v107;
  uint64_t v44 = *(void (**)(char *, uint64_t (*)(void), uint64_t))(v42 + 16);
  uint64_t v90 = v42 + 16;
  int64x2_t v89 = v44;
  v44(v31, v101, v107);
  uint64_t v102 = v6;
  Collection.first.getter(v6, a3, (uint64_t)v21);
  uint64_t v45 = v99;
  int v46 = (*(uint64_t (**)(char *, uint64_t, const char *))(v99 + 48))(v21, 1, v16);
  int64x2_t v85 = v16;
  if (v46 == 1)
  {
    (*(void (**)(char *, Class *))(v86 + 8))(v21, v87);
  }
  else
  {
    (*(void (**)(char *, char *, const char *))(v45 + 32))(v26, v21, v16);
    char v47 = (*(uint64_t (**)(char *))&v31[*(int *)(v43 + 36)])(v26);
    (*(void (**)(char *, const char *))(v45 + 8))(v26, v16);
    if (v47)
    {
      uint64_t v48 = v106;
      uint64_t v49 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v106 + 56);
      v49(v37, 1, 1, AssociatedTypeWitness);
      uint64_t v50 = v102;
      goto LABEL_6;
    }
  }
  uint64_t v50 = v102;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v102, a3);
  uint64_t v48 = v106;
  uint64_t v49 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v106 + 56);
  v49(v37, 0, 1, AssociatedTypeWitness);
LABEL_6:
  int64_t v51 = v98;
  char v52 = static LazyPrefixWhileSequence<>.Index.== infix(_:_:)((uint64_t)v39, (uint64_t)v37, v50, (int **)a3);
  uint64_t v53 = *(void (**)(char *, void (*)(char *, uint64_t, uint64_t, const char *)))(v34 + 8);
  v53(v37, v51);
  if (v52) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't advance past endIndex", 27, 2, "Swift/PrefixWhile.swift", 23, 2, 0xEDuLL, 0);
  }
  uint32x4_t v98 = v49;
  char v54 = *(Class **)(v105 + 8);
  v105 += 8;
  int8x16_t v87 = v54;
  ((void (*)(char *, uint64_t))v54)(v31, v107);
  v53(v39, v51);
  uint64_t v56 = v95;
  uint64_t v55 = v96;
  uint64_t v57 = v97;
  (*(void (**)(char *, void (*)(char *, uint64_t), Class *))(v95 + 16))(v96, v103, v97);
  uint64_t v58 = (uint64_t)AssociatedTypeWitness;
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v48 + 48))(v55, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v56 + 8))(v55, v57);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index passed to index(after:)", 37, 2, "Swift/PrefixWhile.swift", 23, 2, 0xEFuLL, 0);
  }
  uint64_t v59 = v91;
  uint64x2_t v96 = *(char **)(v48 + 32);
  uint64x2_t v97 = (Class *)(v48 + 32);
  ((void (*)(char *, char *, uint64_t))v96)(v91, v55, v58);
  uint64_t v61 = v100;
  uint64_t v60 = v101;
  uint64_t v62 = v102;
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 184))(v59, v102, a3);
  uint64_t v63 = *(void (**)(char *, uint64_t))(v48 + 8);
  v63(v59, v58);
  uint64_t v64 = v93;
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v62, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, v62, v58, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v61, v64, v58);
  uint16x8_t v103 = v63;
  v63(v64, v58);
  uint64_t v66 = v92;
  uint64_t v67 = v107;
  v89(v92, v60, v107);
  uint64_t v68 = v94;
  (*(void (**)(char *, char *, uint64_t))(v106 + 16))(v94, v61, v58);
  if (v59)
  {
    uint64_t v69 = v68;
    Swift::Int v70 = v103;
    v103(v69, v58);
    ((void (*)(char *, uint64_t))v87)(v66, v67);
    uint64_t v71 = v88;
LABEL_12:
    v70(v100, v58);
    uint64_t v81 = 1;
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v98)(v71, v81, 1, v58);
  }
  unsigned int v72 = &v66[*(int *)(v67 + 36)];
  unsigned int v73 = (atomic_ullong *)*((void *)v72 + 1);
  uint16x8_t v101 = *(uint64_t (**)(void))v72;
  uint64_t v74 = *(uint64_t (**)(unsigned char *, char *, uint64_t, uint64_t))(a3 + 80);
  swift_retain(v73);
  unsigned int v75 = (void (*)(unsigned char *, void))v74(v108, v68, v62, a3);
  uint64_t v76 = v99;
  unsigned int v77 = v84;
  unint64_t v78 = v85;
  (*(void (**)(char *))(v99 + 16))(v84);
  v75(v108, 0);
  int64x2_t v79 = v68;
  Swift::Int v70 = v103;
  v103(v79, v58);
  ((void (*)(char *, uint64_t))v87)(v66, v67);
  char v80 = v101(v77);
  swift_release((uint64_t)v73);
  (*(void (**)(char *, const char *))(v76 + 8))(v77, v78);
  uint64_t v71 = v88;
  if ((v80 & 1) == 0) {
    goto LABEL_12;
  }
  ((void (*)(uint64_t, char *, uint64_t))v96)(v88, v100, v58);
  uint64_t v81 = 0;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v98)(v71, v81, 1, v58);
}

uint64_t LazyPrefixWhileSequence<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = &v22[-v10];
  uint64_t v13 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0, v7, a3, v12);
  MEMORY[0x1F4188790](v13);
  uint64_t v15 = &v22[-v14];
  (*(void (**)(unsigned char *, uint64_t))(v16 + 16))(&v22[-v14], a1);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, const char *))(v9 + 48))(v15, 1, AssociatedTypeWitness) == 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/PrefixWhile.swift", 23, 2, 0xFEuLL, 0);
  }
  (*(void (**)(unsigned char *, unsigned char *, const char *))(v9 + 32))(v11, v15, AssociatedTypeWitness);
  uint64_t v17 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t, uint64_t))(a3 + 80))(v22, v11, v7, a3);
  uint64_t v19 = v18;
  uint64_t v20 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v20 - 1) + 16))(a4, v19, v20);
  v17(v22, 0);
  return (*(uint64_t (**)(unsigned char *, const char *))(v9 + 8))(v11, AssociatedTypeWitness);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazyPrefixWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyPrefixWhileSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), a3);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> LazyPrefixWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyPrefixWhileSequence<>.endIndex.getter(a1, *(void *)(a2 - 8), a3);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> LazyPrefixWhileSequence<A>(const char ***a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = (const char **)malloc(0x28uLL);
  *a1 = v8;
  v8[4] = (const char *)LazyPrefixWhileSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*LazyPrefixWhileSequence<>.subscript.read(const char **a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  *a1 = AssociatedTypeWitness;
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  a1[1] = (const char *)v9;
  uint64_t v10 = (const char *)malloc(*(void *)(v9 + 64));
  a1[2] = v10;
  LazyPrefixWhileSequence<>.subscript.getter(a2, a3, a4, (uint64_t)v10);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> LazyPrefixWhileSequence<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = type metadata accessor for LazyPrefixWhileSequence<>.Index(255, *(void *)(a1 + 16), *(void *)(a2 - 8), a3);
  uint64_t v8 = type metadata accessor for Optional(0, (uint64_t)v5, v6, v7);
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, Class *))*((void *)*(v8 - 1) + 7);

  return v9(a4, 1, 1, v8);
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazyPrefixWhileSequence<A>@<X0>(void (*a1)(char *, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazyPrefixWhileSequence<>.index(after:)(a1, a2, *(void *)(a3 - 8), a4, a5);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyPrefixWhileSequence<A>(void (*a1)(char *, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = type metadata accessor for LazyPrefixWhileSequence<>.Index(0, *(void *)(a2 + 16), v6, a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v13 - v9;
  LazyPrefixWhileSequence<>.index(after:)(a1, a2, v6, v11, (uint64_t)&v13 - v9);
  (*(void (**)(void, Class *))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(void (*)(char *, uint64_t), char *, Class *))(v8 + 32))(a1, v10, v7);
}

uint64_t LazyPrefixWhileSequence<>.index(before:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v96 = a1;
  uint64_t v70 = a4;
  uint64_t v8 = *((void *)a3 + 1);
  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v8 + 8), v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int64x2_t v82 = (void (**)(char *, char *, uint64_t))*((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int64x2_t v89 = (char *)&v68 - v11;
  uint64_t v93 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint32x4_t v94 = (void (**)(char *, uint64_t))((char *)&v68 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v12);
  uint64_t v95 = (char *)&v68 - v14;
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v8, v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v16 = *((void *)v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  int8x16_t v91 = (char *)&v68 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint8x8_t v92 = (char *)&v68 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v68 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  unsigned int v26 = (char *)&v68 - v25;
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  uint64_t v86 = (char *)&v68 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v88 = (char *)&v68 - v29;
  uint64_t v31 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0, v9, v8, v30);
  MEMORY[0x1F4188790](v31);
  uint64_t v33 = (char *)&v68 - v32;
  (*(void (**)(char *, uint64_t))(v34 + 16))((char *)&v68 - v32, v96);
  uint64_t v35 = *(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48);
  uint64_t v96 = (uint64_t)v15;
  if (v35(v33, 1, v15) == 1)
  {
    uint64_t v36 = v23;
    (*(void (**)(uint64_t, uint64_t))(v8 + 64))(v9, v8);
    int64x2_t v85 = *(void (**)(char *, uint64_t, char *))(v8 + 184);
    uint64_t v86 = (char *)(v8 + 184);
    uint64_t v83 = *(void (**)(uint64_t, char *))(v8 + 72);
    uint64_t v84 = v8 + 72;
    uint64_t v81 = *(void *)(swift_getAssociatedConformanceWitness(v8, v9, v96, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable)+ 8);
    int64x2_t v79 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v81 + 8);
    uint64_t v80 = v81 + 8;
    uint64_t v95 = (char *)(v16 + 8);
    unsigned int v77 = (void (**)(void (**)(char *, uint64_t), uint64_t, uint64_t))(v93 + 16);
    uint64_t v76 = (void (**)(char *, char *, uint64_t))(v16 + 16);
    uint64_t v88 = (char *)v8;
    uint64_t v75 = v8 + 80;
    uint64_t v74 = (void (**)(char *))(v82 + 2);
    unint64_t v78 = (void (**)(char *, uint64_t))(v93 + 8);
    unsigned int v73 = (void (**)(char *, const char *))(v82 + 1);
    uint64_t v69 = v16;
    int64x2_t v82 = (void (**)(char *, char *, uint64_t))(v16 + 32);
    uint64_t v37 = v92;
    uint64_t v38 = a2;
    unsigned int v72 = v26;
    int8x16_t v87 = v36;
    uint64_t v71 = v5;
    while (1)
    {
      BOOL v39 = v88;
      v85(v36, v9, v88);
      v83(v9, v39);
      uint64_t v40 = v96;
      char v41 = v79(v37, v26, v96, v81);
      uint64_t v42 = *(void (**)(char *, uint64_t))v95;
      (*(void (**)(char *, uint64_t))v95)(v26, v40);
      (*v77)(v94, v5, v38);
      uint64_t v43 = v38;
      uint64_t v44 = v91;
      (*v76)(v91, v37, v40);
      if (v41) {
        break;
      }
      uint64_t v45 = (char *)v94 + *(int *)(v43 + 36);
      uint64_t v46 = v43;
      char v47 = (atomic_ullong *)*((void *)v45 + 1);
      uint64_t v93 = *(void *)v45;
      uint64_t v48 = (char *)v94;
      uint64_t v49 = (uint64_t (*)(unsigned char *, char *, uint64_t, char *))*((void *)v39 + 10);
      swift_retain(v47);
      uint64_t v50 = v49(v97, v44, v9, v39);
      char v52 = v89;
      int64_t v51 = AssociatedTypeWitness;
      (*v74)(v89);
      ((void (*)(unsigned char *, void))v50)(v97, 0);
      v42(v44, v96);
      uint64_t v38 = v46;
      (*v78)(v48, v46);
      LOBYTE(v5_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = ((uint64_t (*)(char *))v93)(v52);
      uint64_t v53 = (uint64_t)v47;
      uint64_t v37 = v92;
      swift_release(v53);
      (*v73)(v52, v51);
      if ((v50 & 1) == 0) {
        goto LABEL_9;
      }
      uint64_t v36 = v87;
      uint64_t v54 = v96;
      v42(v87, v96);
      (*v82)(v36, v37, v54);
      uint64_t v5 = v71;
      unsigned int v26 = v72;
    }
    v42(v44, v96);
    (*v78)((char *)v94, v43);
LABEL_9:
    uint64_t v65 = v96;
    v42(v37, v96);
    uint64_t v66 = v69;
    uint64_t v67 = v70;
    (*(void (**)(uint64_t, char *, uint64_t))(v69 + 32))(v70, v87, v65);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v66 + 56))(v67, 0, 1, v65);
  }
  else
  {
    uint32x4_t v94 = (void (**)(char *, uint64_t))a3;
    uint64_t v55 = v88;
    uint64_t v56 = v96;
    int8x16_t v91 = *(char **)(v16 + 32);
    uint8x8_t v92 = (char *)(v16 + 32);
    ((void (*)(char *, char *, uint64_t))v91)(v88, v33, v96);
    uint64_t v57 = v86;
    (*(void (**)(char *, char *, uint64_t))(v16 + 16))(v86, v55, v56);
    (*(void (**)(char *, uint64_t, uint64_t))(v93 + 16))(v95, v5, a2);
    (*(void (**)(uint64_t, uint64_t))(v8 + 64))(v9, v8);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, v9, v56, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
    LOBYTE(v55) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                     + 8))(v57, v26, v56);
    uint64_t v59 = v26;
    uint64_t v60 = *(void (**)(char *, uint64_t))(v16 + 8);
    v60(v26, v56);
    if (v55) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't move before startIndex", 28, 2, "Swift/PrefixWhile.swift", 23, 2, 0x10BuLL, 0);
    }
    (*(void (**)(char *, uint64_t))(v93 + 8))(v95, a2);
    uint64_t v61 = v96;
    v60(v86, v96);
    uint64_t v62 = v88;
    v94[4](v88, v9);
    v60(v62, v61);
    uint64_t v63 = v70;
    ((void (*)(uint64_t, char *, uint64_t))v91)(v70, v59, v61);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v16 + 56))(v63, 0, 1, v61);
  }
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> LazyPrefixWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyPrefixWhileSequence<>.index(before:)(a1, a2, *(char **)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = type metadata accessor for LazyPrefixWhileSequence<>.Index(0, *(void *)(a2 + 16), *(void *)(v6 + 8), a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v12 - v9;
  LazyPrefixWhileSequence<>.index(before:)(a1, a2, (char *)v6, (uint64_t)&v12 - v9);
  (*(void (**)(uint64_t, Class *))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v8 + 32))(a1, v10, v7);
}

Swift::Void __swiftcall _prespecialize()()
{
  canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  canonical specialized generic type metadata accessor for _ContiguousArrayStorage<AnyHashable>();
  canonical specialized generic type metadata accessor for _ContiguousArrayStorage<[String : Swift.AnyObject]>();
  canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int64>();

  canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
}

void Dictionary._Variant.__specialize_setValue(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void Array.__specialize_append(_:)(uint64_t a1, uint64_t a2)
{
}

{
  (*(void (**)(void))(*(void *)(*(void *)(a2 + 16) - 8) + 8))();
  __break(1u);
}

void ContiguousArray.__specialize_append(_:)(uint64_t a1, uint64_t a2)
{
}

void Set._Variant.__specialize_insert(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t specialized Set._Variant.insert(_:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = specialized static Hasher._hash(seed:_:)(*(void *)(v6 + 40), a2);
  uint64_t v8 = -1 << *(unsigned char *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if ((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9))
  {
    uint64_t v10 = ~v8;
    while (*(void *)(*(void *)(v6 + 48) + 8 * v9) != a2)
    {
      unint64_t v9 = (v9 + 1) & v10;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0) {
        goto LABEL_5;
      }
    }
    uint64_t result = 0;
  }
  else
  {
LABEL_5:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    specialized _NativeSet.insertNew(_:at:isUnique:)(a2, v9, isUniquelyReferenced_nonNull_native);
    uint64_t v12 = *v3;
    *uint64_t v3 = v14;
    swift_bridgeObjectRelease(v12);
    uint64_t result = 1;
  }
  *a1 = a2;
  return result;
}

{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;

  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = specialized static Hasher._hash(seed:_:)(*(void *)(v6 + 40), a2);
  uint64_t v8 = -1 << *(unsigned char *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if ((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9))
  {
    uint64_t v10 = ~v8;
    while (*(void *)(*(void *)(v6 + 48) + 8 * v9) != a2)
    {
      unint64_t v9 = (v9 + 1) & v10;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0) {
        goto LABEL_5;
      }
    }
    uint64_t result = 0;
  }
  else
  {
LABEL_5:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    specialized _NativeSet.insertNew(_:at:isUnique:)(a2, v9, isUniquelyReferenced_nonNull_native);
    uint64_t v12 = *v3;
    *uint64_t v3 = v14;
    swift_bridgeObjectRelease(v12);
    uint64_t result = 1;
  }
  *a1 = a2;
  return result;
}

uint64_t specialized Set._Variant.insert(_:)(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v7 = *v3;
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ *(void *)(*v3 + 40);
  v24[0] = 0;
  v24[1] = v8 ^ 0x736F6D6570736575;
  _OWORD v24[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v24[3] = v8 ^ 0x6C7967656E657261;
  v24[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v25 = 0u;
  long long v26 = 0u;
  swift_bridgeObjectRetain(v7);
  String.hash(into:)(v24, a2, a3);
  Swift::Int v9 = Hasher._finalize()();
  uint64_t v10 = -1 << *(unsigned char *)(v7 + 32);
  unint64_t v11 = v9 & ~v10;
  if ((*(void *)(v7 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11))
  {
    uint64_t v12 = ~v10;
    uint64_t v13 = *(void *)(v7 + 48);
    while (1)
    {
      uint64_t v14 = (uint64_t *)(v13 + 16 * v11);
      unint64_t v15 = v14[1];
      if (*v14 == a2 && v15 == a3) {
        break;
      }
      BOOL v17 = (~v15 & 0x6000000000000000) != 0 || (a3 & 0x2000000000000000) == 0;
      BOOL v18 = v17 || (a3 & 0x4000000000000000) == 0;
      if (v18 && (_stringCompareInternal(_:_:expecting:)(*v14, v15, a2, a3, 0) & 1) != 0) {
        break;
      }
      unint64_t v11 = (v11 + 1) & v12;
      if (((*(void *)(v7 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11) & 1) == 0) {
        goto LABEL_18;
      }
    }
    swift_bridgeObjectRelease(a3);
    swift_bridgeObjectRelease(v7);
    uint64_t v19 = (unint64_t *)(*(void *)(*v3 + 48) + 16 * v11);
    unint64_t v20 = v19[1];
    *a1 = *v19;
    a1[1] = v20;
    swift_bridgeObjectRetain(v20);
    return 0;
  }
  else
  {
LABEL_18:
    swift_bridgeObjectRelease(v7);
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    v24[0] = *v3;
    *uint64_t v3 = 0x8000000000000000;
    swift_bridgeObjectRetain(a3);
    specialized _NativeSet.insertNew(_:at:isUnique:)(a2, a3, v11, isUniquelyReferenced_nonNull_native);
    uint64_t v23 = *v3;
    *uint64_t v3 = v24[0];
    swift_bridgeObjectRelease(v23);
    *a1 = a2;
    a1[1] = a3;
    return 1;
  }
}

uint64_t specialized Set._Variant.insert(_:)(uint64_t a1, uint64_t a2)
{
  void (*v9)(uint64_t *__return_ptr, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v25;
  long long v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29[5];
  uint64_t v30[3];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33[3];
  uint64_t v34;
  uint64_t v35;

  unint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 40);
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a2, v7);
  Swift::Int v9 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8);
  swift_bridgeObjectRetain(v5);
  v9(v33, v7, v8);
  uint64_t v10 = v34;
  unint64_t v11 = v35;
  __swift_project_boxed_opaque_existential_0Tm(v33, v34);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11 + 40))(v6, v10, v11);
  __swift_destroy_boxed_opaque_existential_1Tm(v33);
  uint64_t v13 = -1 << *(unsigned char *)(v5 + 32);
  uint64_t v14 = v12 & ~v13;
  uint64_t v28 = a1;
  if ((*(void *)(v5 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14))
  {
    unint64_t v15 = ~v13;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v14, (uint64_t)v33);
      uint64_t v16 = v34;
      BOOL v17 = v35;
      __swift_project_boxed_opaque_existential_0Tm(v33, v34);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v17 + 8))(v30, v16, v17);
      BOOL v18 = v31;
      uint64_t v19 = v32;
      __swift_project_boxed_opaque_existential_0Tm(v30, v31);
      uint64_t v21 = *(void *)(a2 + 24);
      unint64_t v20 = *(void *)(a2 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)a2, v21);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v29, v21, v20);
      uint64_t v22 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v19 + 16))(v29, v18, v19);
      __swift_destroy_boxed_opaque_existential_1Tm(v29);
      if (v22 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v30);
        outlined destroy of AnyHashable(v33);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v30);
        outlined destroy of AnyHashable(v33);
        if (v22)
        {
          swift_bridgeObjectRelease(v5);
          outlined destroy of AnyHashable((uint64_t *)a2);
          outlined init with copy of AnyHashable(*(void *)(*v27 + 48) + 40 * v14, v28);
          return 0;
        }
      }
      uint64_t v14 = (v14 + 1) & v15;
    }
    while (((*(void *)(v5 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) != 0);
  }
  swift_bridgeObjectRelease(v5);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v27);
  outlined init with copy of AnyHashable(a2, (uint64_t)v33);
  v30[0] = *v27;
  *uint64_t v27 = 0x8000000000000000;
  specialized _NativeSet.insertNew(_:at:isUnique:)((uint64_t)v33, v14, isUniquelyReferenced_nonNull_native);
  long long v25 = *v27;
  *uint64_t v27 = v30[0];
  swift_bridgeObjectRelease(v25);
  long long v26 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v28 = *(_OWORD *)a2;
  *(_OWORD *)(v28 + 16) = v26;
  *(void *)(v28 + 32) = *(void *)(a2 + 32);
  return 1;
}

{
  unint64_t *v2;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(long long *__return_ptr, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v25;
  long long v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29[5];
  uint64_t v30[3];
  uint64_t v31;
  uint64_t v32;
  long long v33;
  uint64_t v34;
  uint64_t v35;

  unint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 40);
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a2, v7);
  Swift::Int v9 = *(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v8 + 8);
  swift_bridgeObjectRetain(v5);
  v9(&v33, v7, v8);
  uint64_t v10 = v34;
  unint64_t v11 = v35;
  __swift_project_boxed_opaque_existential_0Tm(&v33, v34);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11 + 40))(v6, v10, v11);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v33);
  uint64_t v13 = -1 << *(unsigned char *)(v5 + 32);
  uint64_t v14 = v12 & ~v13;
  uint64_t v28 = a1;
  if ((*(void *)(v5 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14))
  {
    unint64_t v15 = ~v13;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v14, (uint64_t)&v33);
      uint64_t v16 = v34;
      BOOL v17 = v35;
      __swift_project_boxed_opaque_existential_0Tm(&v33, v34);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v17 + 8))(v30, v16, v17);
      BOOL v18 = v31;
      uint64_t v19 = v32;
      __swift_project_boxed_opaque_existential_0Tm(v30, v31);
      uint64_t v21 = *(void *)(a2 + 24);
      unint64_t v20 = *(void *)(a2 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)a2, v21);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v29, v21, v20);
      uint64_t v22 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v19 + 16))(v29, v18, v19);
      __swift_destroy_boxed_opaque_existential_1Tm(v29);
      if (v22 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v30);
        outlined destroy of AnyHashable((uint64_t *)&v33);
      }
      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v30);
        outlined destroy of AnyHashable((uint64_t *)&v33);
        if (v22)
        {
          swift_bridgeObjectRelease(v5);
          outlined destroy of AnyHashable((uint64_t *)a2);
          outlined init with copy of AnyHashable(*(void *)(*v27 + 48) + 40 * v14, v28);
          return 0;
        }
      }
      uint64_t v14 = (v14 + 1) & v15;
    }
    while (((*(void *)(v5 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) != 0);
  }
  swift_bridgeObjectRelease(v5);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v27);
  outlined init with copy of AnyHashable(a2, (uint64_t)&v33);
  v30[0] = *v27;
  *uint64_t v27 = 0x8000000000000000;
  specialized _NativeSet.insertNew(_:at:isUnique:)(&v33, v14, isUniquelyReferenced_nonNull_native);
  long long v25 = *v27;
  *uint64_t v27 = v30[0];
  swift_bridgeObjectRelease(v25);
  long long v26 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v28 = *(_OWORD *)a2;
  *(_OWORD *)(v28 + 16) = v26;
  *(void *)(v28 + 32) = *(void *)(a2 + 32);
  return 1;
}

uint64_t Set._Variant.insert(_:)(char *a1, id *a2, uint64_t a3)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(uint64_t **)(a3 + 16);
  uint64_t v8 = *(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  unint64_t v11 = (char *)v47 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)v47 - v12;
  uint64_t v14 = *v3;
  if ((*v3 & 0xC000000000000001) != 0)
  {
    int64_t v51 = v6;
    unint64_t v15 = _bridgeAnythingToObjectiveC<A>(_:)(a2, v7);
    uint64_t v16 = *v3;
    if ((*v3 & 0x8000000000000000) != 0) {
      BOOL v17 = (void *)*v3;
    }
    else {
      BOOL v17 = (void *)(*v3 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(*v3);
    id v18 = [v17 sel_member_:v15];
    swift_unknownObjectRelease(v15);
    if (v18)
    {
      (*(void (**)(id *, uint64_t *))(v8 + 8))(a2, v7);
      swift_bridgeObjectRelease(v16);
      _forceBridgeFromObjectiveC<A>(_:_:)(v18, (char *)v7, v19, v51);
      swift_unknownObjectRelease(v18);
      return 0;
    }
    uint64_t v34 = (uint64_t *)v3;
    uint64_t result = (uint64_t)[v17 count];
    uint64_t v35 = v51;
    if (__OFADD__(result, 1))
    {
      __break(1u);
      return result;
    }
    uint64_t v36 = *(void *)(a3 + 24);
    uint64_t v37 = _NativeSet.init(_:capacity:)(v17, result + 1, (char *)v7, v36);
    uint64_t v59 = v37;
    (*(void (**)(char *, id *, uint64_t *))(v8 + 16))(v11, a2, v7);
    BOOL v39 = v37[2];
    if (v37[3] <= v39)
    {
      Swift::Int v40 = (Swift::Int)&v39->isa + 1;
      type metadata accessor for _NativeSet(0, (uint64_t)v7, v36, v38);
      _NativeSet.resize(capacity:)(v40);
      uint64_t v37 = v59;
    }
    _NativeSet._unsafeInsertNew(_:)((uint64_t)v11, (uint64_t)v37, (uint64_t)v7, v36);
    uint64_t v41 = *v34;
    *uint64_t v34 = (uint64_t)v37;
    swift_bridgeObjectRelease(v41);
    (*(void (**)(char *, id *, uint64_t *))(v8 + 32))(v35, a2, v7);
    return 1;
  }
  uint64_t v49 = (uint64_t *)v3;
  uint64_t v50 = v8;
  uint64_t v21 = *(void *)(v14 + 40);
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(v22 + 32);
  swift_bridgeObjectRetain(v14);
  uint64_t v58 = a2;
  uint64_t v24 = v23(v21, v7, v22);
  uint64_t v25 = -1 << *(unsigned char *)(v14 + 32);
  unint64_t v26 = v24 & ~v25;
  uint64_t v57 = v14 + 56;
  if (((*(void *)(v14 + 56 + ((v26 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v26) & 1) == 0)
  {
    swift_bridgeObjectRelease(v14);
    uint64_t v33 = v50;
    uint64_t v27 = *(void (**)(char *, id *, uint64_t *))(v50 + 16);
LABEL_17:
    uint64_t v42 = v49;
    LODWORD(v57) = swift_isUniquelyReferenced_nonNull_native(*v49);
    uint64_t v43 = v58;
    v27(v13, v58, v7);
    uint64_t v59 = (__objc2_class **)*v42;
    uint64_t *v42 = 0x8000000000000000;
    uint64_t v45 = type metadata accessor for _NativeSet(0, (uint64_t)v7, v22, v44);
    _NativeSet.insertNew(_:at:isUnique:)((uint64_t)v13, v26, v57, (uint64_t)v45);
    uint64_t v46 = *v42;
    uint64_t *v42 = (uint64_t)v59;
    swift_bridgeObjectRelease(v46);
    (*(void (**)(char *, id *, uint64_t *))(v33 + 32))(v6, v43, v7);
    return 1;
  }
  int64_t v51 = v6;
  uint64_t v52 = ~v25;
  uint64_t v48 = v22;
  uint64_t v56 = *(void *)(v22 + 8);
  uint64_t v54 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v56 + 8);
  uint64_t v55 = v56 + 8;
  uint64_t v27 = *(void (**)(char *, id *, uint64_t *))(v50 + 16);
  uint64_t v53 = *(void *)(v50 + 72);
  uint64_t v28 = (void (**)(char *, uint64_t *))(v50 + 8);
  v47[1] = (v50 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  while (1)
  {
    unint64_t v29 = v53 * v26;
    uint64_t v30 = v27;
    v27(v13, (id *)(*(void *)(v14 + 48) + v53 * v26), v7);
    char v31 = v54(v13, v58, v7, v56);
    uint64_t v32 = *v28;
    (*v28)(v13, v7);
    if (v31) {
      break;
    }
    unint64_t v26 = (v26 + 1) & v52;
    uint64_t v27 = v30;
    if (((*(void *)(v57 + ((v26 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v26) & 1) == 0)
    {
      swift_bridgeObjectRelease(v14);
      uint64_t v33 = v50;
      uint64_t v6 = v51;
      uint64_t v22 = v48;
      goto LABEL_17;
    }
  }
  swift_bridgeObjectRelease(v14);
  v32((char *)v58, v7);
  v30(v51, (id *)(*(void *)(*v49 + 48) + v29), v7);
  return 0;
}

uint64_t specialized Set._Variant.remove(_:)(unint64_t a1, unint64_t a2)
{
  unint64_t v5 = *v2;
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ *(void *)(*v2 + 40);
  v22[0] = 0;
  v22[1] = v6 ^ 0x736F6D6570736575;
  v22[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v22[3] = v6 ^ 0x6C7967656E657261;
  v22[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v23 = 0u;
  long long v24 = 0u;
  swift_bridgeObjectRetain(v5);
  String.hash(into:)(v22, a1, a2);
  Swift::Int v7 = Hasher._finalize()();
  uint64_t v8 = -1 << *(unsigned char *)(v5 + 32);
  unint64_t v9 = v7 & ~v8;
  if ((*(void *)(v5 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9))
  {
    uint64_t v10 = ~v8;
    uint64_t v11 = *(void *)(v5 + 48);
    while (1)
    {
      uint64_t v12 = (uint64_t *)(v11 + 16 * v9);
      unint64_t v13 = v12[1];
      if (*v12 == a1 && v13 == a2) {
        break;
      }
      BOOL v15 = (~v13 & 0x6000000000000000) != 0 || (a2 & 0x2000000000000000) == 0;
      BOOL v16 = v15 || (a2 & 0x4000000000000000) == 0;
      if (v16 && (_stringCompareInternal(_:_:expecting:)(*v12, v13, a1, a2, 0) & 1) != 0) {
        break;
      }
      unint64_t v9 = (v9 + 1) & v10;
      if (((*(void *)(v5 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0) {
        goto LABEL_20;
      }
    }
    swift_bridgeObjectRelease(v5);
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
    unint64_t v18 = *v2;
    v22[0] = *v2;
    uint64_t *v2 = 0x8000000000000000;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeSet.copy()();
      unint64_t v18 = v22[0];
    }
    uint64_t v19 = *(void *)(*(void *)(v18 + 48) + 16 * v9);
    specialized _NativeSet._delete(at:)(v9);
    uint64_t v20 = *v2;
    uint64_t *v2 = v22[0];
    swift_bridgeObjectRelease(v20);
  }
  else
  {
LABEL_20:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  return v19;
}

double specialized Set._Variant.remove(_:)@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  void (*v8)(uint64_t *__return_ptr, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  BOOL isUniquelyReferenced_nonNull_native;
  uint64_t v22;
  uint64_t v23;
  long long v24;
  uint64_t v25;
  double result;
  uint64_t *v27;
  uint64_t v29;
  uint64_t v30[5];
  uint64_t v31[3];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34[3];
  uint64_t v35;
  uint64_t v36;

  unint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 40);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  uint64_t v8 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 8);
  swift_bridgeObjectRetain(v4);
  v8(v34, v6, v7);
  unint64_t v9 = v35;
  uint64_t v10 = v36;
  __swift_project_boxed_opaque_existential_0Tm(v34, v35);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v5, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v34);
  uint64_t v12 = -1 << *(unsigned char *)(v4 + 32);
  unint64_t v13 = v11 & ~v12;
  if (((*(void *)(v4 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(v4);
    *(void *)(a2 + 32) = 0;
    uint64_t result = 0.0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    return result;
  }
  unint64_t v29 = ~v12;
  while (1)
  {
    outlined init with copy of AnyHashable(*(void *)(v4 + 48) + 40 * v13, (uint64_t)v34);
    uint64_t v14 = v35;
    BOOL v15 = v36;
    __swift_project_boxed_opaque_existential_0Tm(v34, v35);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v15 + 8))(v31, v14, v15);
    BOOL v16 = v32;
    BOOL v17 = v33;
    __swift_project_boxed_opaque_existential_0Tm(v31, v32);
    uint64_t v19 = a1[3];
    unint64_t v18 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v19);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v18 + 8))(v30, v19, v18);
    uint64_t v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v17 + 16))(v30, v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(v30);
    if (v20 != 2) {
      break;
    }
    __swift_destroy_boxed_opaque_existential_1Tm(v31);
    outlined destroy of AnyHashable(v34);
LABEL_4:
    unint64_t v13 = (v13 + 1) & v29;
    if (((*(void *)(v4 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0) {
      goto LABEL_10;
    }
  }
  __swift_destroy_boxed_opaque_existential_1Tm(v31);
  outlined destroy of AnyHashable(v34);
  if ((v20 & 1) == 0) {
    goto LABEL_4;
  }
  swift_bridgeObjectRelease(v4);
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v27);
  uint64_t v22 = *v27;
  v34[0] = *v27;
  *uint64_t v27 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized _NativeSet.copy()();
    uint64_t v22 = v34[0];
  }
  long long v23 = *(void *)(v22 + 48) + 40 * v13;
  long long v24 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v23;
  *(_OWORD *)(a2 + 16) = v24;
  *(void *)(a2 + 32) = *(void *)(v23 + 32);
  specialized _NativeSet._delete(at:)(v13);
  uint64_t v25 = *v27;
  *uint64_t v27 = v34[0];
  swift_bridgeObjectRelease(v25);
  return result;
}

void specialized Set._Variant.remove(_:)(void *a1@<X0>, uint64_t a2@<X8>)
{
  void (*v8)(long long *__return_ptr, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t *v21;
  BOOL isUniquelyReferenced_nonNull_native;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  long long v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  char v30;
  void *v31;
  void *v32;
  uint64_t v33;
  unint64_t v34;
  int64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  int64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  long long v44;
  long long v45;
  int64_t v46;
  unint64_t v47;
  int64_t v48;
  uint64_t *v49;
  uint64_t v51;
  uint64_t v52[5];
  uint64_t v53[3];
  uint64_t v54;
  uint64_t v55;
  long long v56;
  long long v57;
  uint64_t v58;

  unint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 40);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  uint64_t v8 = *(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v7 + 8);
  swift_bridgeObjectRetain(v4);
  v8(&v56, v6, v7);
  unint64_t v9 = *((void *)&v57 + 1);
  uint64_t v10 = v58;
  __swift_project_boxed_opaque_existential_0Tm(&v56, *((uint64_t *)&v57 + 1));
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v5, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v56);
  uint64_t v12 = -1 << *(unsigned char *)(v4 + 32);
  unint64_t v13 = v11 & ~v12;
  if (((*(void *)(v4 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(v4);
    *(void *)(a2 + 32) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    return;
  }
  int64_t v51 = ~v12;
  while (1)
  {
    outlined init with copy of AnyHashable(*(void *)(v4 + 48) + 40 * v13, (uint64_t)&v56);
    uint64_t v14 = *((void *)&v57 + 1);
    BOOL v15 = v58;
    __swift_project_boxed_opaque_existential_0Tm(&v56, *((uint64_t *)&v57 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v15 + 8))(v53, v14, v15);
    BOOL v16 = v54;
    BOOL v17 = v55;
    __swift_project_boxed_opaque_existential_0Tm(v53, v54);
    uint64_t v19 = a1[3];
    unint64_t v18 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v19);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v18 + 8))(v52, v19, v18);
    uint64_t v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v17 + 16))(v52, v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(v52);
    if (v20 != 2) {
      break;
    }
    __swift_destroy_boxed_opaque_existential_1Tm(v53);
    outlined destroy of AnyHashable((uint64_t *)&v56);
LABEL_4:
    unint64_t v13 = (v13 + 1) & v51;
    if (((*(void *)(v4 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0) {
      goto LABEL_10;
    }
  }
  __swift_destroy_boxed_opaque_existential_1Tm(v53);
  outlined destroy of AnyHashable((uint64_t *)&v56);
  if ((v20 & 1) == 0) {
    goto LABEL_4;
  }
  swift_bridgeObjectRelease(v4);
  uint64_t v21 = v49;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v49);
  long long v23 = *v49;
  v53[0] = *v49;
  *uint64_t v49 = 0x8000000000000000;
  if (isUniquelyReferenced_nonNull_native)
  {
    long long v24 = v23;
LABEL_9:
    uint64_t v25 = *(void *)(v24 + 48) + 40 * v13;
    unint64_t v26 = *(_OWORD *)(v25 + 16);
    *(_OWORD *)a2 = *(_OWORD *)v25;
    *(_OWORD *)(a2 + 16) = v26;
    *(void *)(a2 + 32) = *(void *)(v25 + 32);
    specialized _NativeSet._delete(at:)(v13);
    uint64_t v27 = *v21;
    *uint64_t v21 = v53[0];
    swift_bridgeObjectRelease(v27);
    return;
  }
  uint64_t v28 = *(unsigned int *)(v23 + 36);
  unint64_t v29 = *(void **)(v23 + 40);
  uint64_t v30 = *(unsigned char *)(v23 + 32);
  LOBYTE(v56) = 0;
  char v31 = specialized static _SetStorage.allocate(scale:age:seed:)(v30, v28, v29, 0);
  long long v24 = (uint64_t)v31;
  if (!*(void *)(v23 + 16))
  {
LABEL_36:
    swift_bridgeObjectRelease(v23);
    v53[0] = v24;
    uint64_t v21 = v49;
    goto LABEL_9;
  }
  uint64_t v32 = v31 + 7;
  uint64_t v33 = v23 + 56;
  uint64_t v34 = (unint64_t)((1 << *(unsigned char *)(v24 + 32)) + 63) >> 6;
  if (v24 != v23 || (unint64_t)v32 >= v33 + 8 * v34) {
    memmove(v32, (const void *)(v23 + 56), 8 * v34);
  }
  uint64_t v35 = 0;
  *(void *)(v24 + 16) = *(void *)(v23 + 16);
  uint64_t v36 = 1 << *(unsigned char *)(v23 + 32);
  uint64_t v37 = -1;
  if (v36 < 64) {
    uint64_t v37 = ~(-1 << v36);
  }
  uint64_t v38 = v37 & *(void *)(v23 + 56);
  BOOL v39 = (unint64_t)(v36 + 63) >> 6;
  while (2)
  {
    if (v38)
    {
      Swift::Int v40 = __clz(__rbit64(v38));
      v38 &= v38 - 1;
      uint64_t v41 = v40 | (v35 << 6);
LABEL_20:
      uint64_t v42 = 40 * v41;
      outlined init with copy of AnyHashable(*(void *)(v23 + 48) + 40 * v41, (uint64_t)&v56);
      uint64_t v43 = *(void *)(v24 + 48) + v42;
      uint64_t v44 = v56;
      uint64_t v45 = v57;
      *(void *)(v43 + 32) = v58;
      *(_OWORD *)uint64_t v43 = v44;
      *(_OWORD *)(v43 + 16) = v45;
      continue;
    }
    break;
  }
  uint64_t v46 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_38;
  }
  if (v46 >= v39) {
    goto LABEL_36;
  }
  char v47 = *(void *)(v33 + 8 * v46);
  ++v35;
  if (v47) {
    goto LABEL_35;
  }
  uint64_t v35 = v46 + 1;
  if (v46 + 1 >= v39) {
    goto LABEL_36;
  }
  char v47 = *(void *)(v33 + 8 * v35);
  if (v47) {
    goto LABEL_35;
  }
  uint64_t v35 = v46 + 2;
  if (v46 + 2 >= v39) {
    goto LABEL_36;
  }
  char v47 = *(void *)(v33 + 8 * v35);
  if (v47)
  {
LABEL_35:
    uint64_t v38 = (v47 - 1) & v47;
    uint64_t v41 = __clz(__rbit64(v47)) + (v35 << 6);
    goto LABEL_20;
  }
  uint64_t v48 = v46 + 3;
  if (v48 >= v39) {
    goto LABEL_36;
  }
  char v47 = *(void *)(v33 + 8 * v48);
  if (v47)
  {
    uint64_t v35 = v48;
    goto LABEL_35;
  }
  while (1)
  {
    uint64_t v35 = v48 + 1;
    if (__OFADD__(v48, 1)) {
      break;
    }
    if (v35 >= v39) {
      goto LABEL_36;
    }
    char v47 = *(void *)(v33 + 8 * v35);
    ++v48;
    if (v47) {
      goto LABEL_35;
    }
  }
LABEL_38:
  __break(1u);
}

void Set._Variant.remove(_:)(id *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = v3;
  uint64_t v8 = *(uint64_t **)(a2 + 16);
  uint64_t v38 = *(v8 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *v4;
  if ((*v4 & 0xC000000000000001) != 0)
  {
    if (v11 < 0) {
      uint64_t v12 = (void *)*v4;
    }
    else {
      uint64_t v12 = (void *)(v11 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(*v4);
    unint64_t v13 = _bridgeAnythingToObjectiveC<A>(_:)(a1, v8);
    id v14 = [v12 sel_member_:v13];
    swift_unknownObjectRelease(v13);
    if (v14)
    {
      swift_unknownObjectRelease(v14);
      Set._Variant._migrateToNative(_:removing:)(v12, (char *)a1, a2, a3);
      swift_bridgeObjectRelease(v11);
      BOOL v15 = *(void (**)(uint64_t, void, uint64_t, uint64_t *))(v38 + 56);
      v15(a3, 0, 1, v8);
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v38 + 56))(a3, 1, 1, v8);
      swift_bridgeObjectRelease(v11);
    }
  }
  else
  {
    uint64_t v16 = *(void *)(v11 + 40);
    uint64_t v17 = *(void *)(a2 + 24);
    unint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(v17 + 32);
    swift_bridgeObjectRetain(*v4);
    uint64_t v44 = a1;
    uint64_t v19 = v18(v16, v8, v17);
    uint64_t v20 = -1 << *(unsigned char *)(v11 + 32);
    unint64_t v21 = v19 & ~v20;
    uint64_t v43 = v11 + 56;
    if ((*(void *)(v11 + 56 + ((v21 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v21))
    {
      uint64_t v35 = (uint64_t *)v4;
      uint64_t v36 = v17;
      uint64_t v37 = a3;
      uint64_t v42 = *(void *)(v17 + 8);
      uint64_t v22 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v42 + 8);
      uint64_t v39 = ~v20;
      Swift::Int v40 = *(void (**)(char *, unint64_t, uint64_t *))(v38 + 16);
      uint64_t v41 = v22;
      uint64_t v23 = *(void *)(v38 + 72);
      long long v24 = (void (**)(char *, uint64_t *))(v38 + 8);
      while (1)
      {
        v40(v10, *(void *)(v11 + 48) + v23 * v21, v8);
        char v25 = v41(v10, v44, v8, v42);
        (*v24)(v10, v8);
        if (v25) {
          break;
        }
        unint64_t v21 = (v21 + 1) & v39;
        if (((*(void *)(v43 + ((v21 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v21) & 1) == 0)
        {
          swift_bridgeObjectRelease(v11);
          a3 = v37;
          goto LABEL_18;
        }
      }
      swift_bridgeObjectRelease(v11);
      unint64_t v26 = v35;
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v35);
      uint64_t v29 = *v26;
      uint64_t v45 = *v26;
      *unint64_t v26 = 0x8000000000000000;
      if (!isUniquelyReferenced_nonNull_native)
      {
        type metadata accessor for _NativeSet(0, (uint64_t)v8, v36, v28);
        _NativeSet.copy()();
        uint64_t v29 = v45;
      }
      unint64_t v30 = *(void *)(v29 + 48) + v23 * v21;
      uint64_t v31 = v37;
      (*(void (**)(uint64_t, unint64_t, uint64_t *))(v38 + 32))(v37, v30, v8);
      type metadata accessor for _NativeSet(0, (uint64_t)v8, v36, v32);
      _NativeSet._delete(at:)((Swift::_HashTable::Bucket)v21);
      uint64_t v33 = *v26;
      *unint64_t v26 = v29;
      swift_bridgeObjectRelease(v33);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t *))(v38 + 56))(v31, 0, 1, v8);
    }
    else
    {
      swift_bridgeObjectRelease(v11);
LABEL_18:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v38 + 56))(a3, 1, 1, v8);
    }
  }
}

void _NativeSet.__specialize_insertNew(_:at:isUnique:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _NativeSet.__specialize__unsafeInsertNew(_:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void print(_:separator:terminator:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
}

void specialized _print<A>(_:separator:terminator:to:)(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, void *a5, unint64_t *a6)
{
  uint64_t v7 = a5;
  uint64_t v8 = a4;
  uint64_t v9 = *(void *)(a1 + 16);
  if (!v9)
  {
    a3 = 0xE000000000000000;
    goto LABEL_13;
  }
  outlined init with copy of Any(a1 + 32, (uint64_t)v36);
  outlined init with take of Any(v36, v35);
  unint64_t v13 = *a6;
  unint64_t v14 = a6[1];
  uint64_t v15 = HIBYTE(v14) & 0xF;
  if ((v14 & 0x2000000000000000) == 0) {
    uint64_t v15 = *a6 & 0xFFFFFFFFFFFFLL;
  }
  if (v15 || (v13 & ~v14 & 0x2000000000000000) != 0)
  {
    if ((v14 & 0x2000000000000000) == 0
      || (unint64_t v16 = specialized _SmallString.init(_:appending:)(v13, a6[1], 0, 0xE000000000000000), (v18 & 1) != 0))
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease(0xE000000000000000);
    }
    else
    {
      unint64_t v19 = v16;
      unint64_t v20 = v17;
      swift_bridgeObjectRelease(v14);
      swift_bridgeObjectRelease(0xE000000000000000);
      *a6 = v19;
      a6[1] = v20;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a6[1]);
    *a6 = 0;
    a6[1] = 0xE000000000000000;
  }
  _print_unlocked<A, B>(_:_:)((uint64_t)v35, (uint64_t)a6, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v35);
  swift_bridgeObjectRetain(a3);
  uint64_t v21 = v9 - 1;
  if (v9 != 1)
  {
    uint64_t v23 = a1 + 64;
    while (1)
    {
      outlined init with copy of Any(v23, (uint64_t)v36);
      outlined init with take of Any(v36, v35);
      unint64_t v25 = *a6;
      unint64_t v26 = a6[1];
      uint64_t v27 = HIBYTE(v26) & 0xF;
      if ((v26 & 0x2000000000000000) == 0) {
        uint64_t v27 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v27 && (v25 & ~v26 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(a6[1]);
        *a6 = a2;
        a6[1] = a3;
        goto LABEL_17;
      }
      if ((v26 & 0x2000000000000000) == 0) {
        break;
      }
      if ((a3 & 0x2000000000000000) == 0) {
        goto LABEL_15;
      }
      unint64_t v28 = specialized _SmallString.init(_:appending:)(v25, a6[1], a2, a3);
      uint64_t v24 = HIBYTE(a3) & 0xF;
      if ((v30 & 1) == 0)
      {
        unint64_t v31 = v28;
        unint64_t v32 = v29;
        swift_bridgeObjectRelease(v26);
        swift_bridgeObjectRelease(a3);
        *a6 = v31;
        a6[1] = v32;
        goto LABEL_17;
      }
LABEL_16:
      _StringGuts.append(_:)(a2, a3, 0, v24);
      swift_bridgeObjectRelease(a3);
LABEL_17:
      _print_unlocked<A, B>(_:_:)((uint64_t)v35, (uint64_t)a6, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
      __swift_destroy_boxed_opaque_existential_1Tm(v35);
      swift_bridgeObjectRetain(a3);
      v23 += 32;
      if (!--v21) {
        goto LABEL_11;
      }
    }
    uint64_t v24 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000) != 0) {
      goto LABEL_16;
    }
LABEL_15:
    uint64_t v24 = a2 & 0xFFFFFFFFFFFFLL;
    goto LABEL_16;
  }
LABEL_11:
  uint64_t v8 = a4;
  uint64_t v7 = a5;
LABEL_13:
  swift_bridgeObjectRelease(a3);
  v22._uint64_t countAndFlagsBits = v8;
  v22._unint64_t object = v7;
  String.write(_:)(v22);
}

void specialized _print<A>(_:separator:terminator:to:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  _swift_stdlib_flockfile_stdout();
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11)
  {
    uint64_t v39 = a4;
    unint64_t v40 = a5;
    uint64_t v12 = 0;
    uint64_t v13 = a1 + 32;
    unint64_t v14 = 0xE000000000000000;
    unint64_t v41 = a3;
    while (1)
    {
      outlined init with copy of Any(v13, (uint64_t)v45);
      outlined init with take of Any(v45, v44);
      unint64_t v17 = *a6;
      unint64_t v18 = a6[1];
      uint64_t v19 = HIBYTE(v18) & 0xF;
      if ((v18 & 0x2000000000000000) == 0) {
        uint64_t v19 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v19 && (v17 & ~v18 & 0x2000000000000000) == 0) {
        break;
      }
      uint64_t v20 = v14 & 0x2000000000000000;
      if ((v18 & 0x2000000000000000) == 0
        || !v20
        || (unint64_t v21 = specialized _SmallString.init(_:appending:)(v17, a6[1], v12, v14), (v23 & 1) != 0))
      {
        if (v20) {
          uint64_t v27 = HIBYTE(v14) & 0xF;
        }
        else {
          uint64_t v27 = v12 & 0xFFFFFFFFFFFFLL;
        }
        _StringGuts.append(_:)(v12, v14, 0, v27);
        unint64_t v26 = v14;
        a3 = v41;
LABEL_19:
        uint64_t v28 = HIBYTE(v26) & 0xF;
        if (!v20) {
          uint64_t v28 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (!v28) {
          goto LABEL_5;
        }
        goto LABEL_22;
      }
      unint64_t v24 = v21;
      unint64_t v25 = v22;
      swift_bridgeObjectRelease(v18);
      *a6 = v24;
      a6[1] = v25;
      unint64_t v26 = v14;
      a3 = v41;
      if ((v14 & 0xF00000000000000) == 0) {
        goto LABEL_5;
      }
LABEL_22:
      swift_bridgeObjectRetain(v14);
      if ((v26 & 0x1000000000000000) != 0)
      {
        uint64_t v12 = specialized static String._copying(_:)(v12, v14);
        unint64_t v26 = v30;
        swift_bridgeObjectRelease(v14);
        uint64_t v29 = v26;
        if ((v26 & 0x2000000000000000) == 0)
        {
LABEL_24:
          if ((v12 & 0x1000000000000000) != 0)
          {
            unint64_t v16 = (void *)((v26 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v15 = v12 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            unint64_t v16 = _StringObject.sharedUTF8.getter(v12, v29);
            if (!v16) {
              goto LABEL_46;
            }
            size_t v15 = v31;
          }
          goto LABEL_4;
        }
      }
      else
      {
        uint64_t v29 = v14;
        if ((v26 & 0x2000000000000000) == 0) {
          goto LABEL_24;
        }
      }
      size_t v15 = HIBYTE(v26) & 0xF;
      v43[0] = v12;
      v43[1] = v26 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v16 = v43;
LABEL_4:
      _swift_stdlib_fwrite_stdout(v16, 1uLL, v15);
      swift_bridgeObjectRelease(v29);
LABEL_5:
      swift_bridgeObjectRelease(v14);
      _print_unlocked<A, B>(_:_:)((uint64_t)v44, (uint64_t)a6, qword_1ECA06310, (uint64_t)&unk_1ECA02F30, (uint64_t)&protocol witness table for _TeeStream<A, B>);
      __swift_destroy_boxed_opaque_existential_1Tm(v44);
      swift_bridgeObjectRetain(a3);
      v13 += 32;
      unint64_t v14 = a3;
      uint64_t v12 = a2;
      if (!--v11)
      {
        a4 = v39;
        a5 = v40;
        goto LABEL_33;
      }
    }
    swift_bridgeObjectRetain(v14);
    swift_bridgeObjectRelease(v18);
    *a6 = v12;
    a6[1] = v14;
    uint64_t v20 = v14 & 0x2000000000000000;
    unint64_t v26 = v14;
    goto LABEL_19;
  }
  a3 = 0xE000000000000000;
LABEL_33:
  swift_bridgeObjectRelease(a3);
  v32._uint64_t countAndFlagsBits = a4;
  v32._unint64_t object = (void *)a5;
  String.write(_:)(v32);
  uint64_t v33 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000) == 0) {
    uint64_t v33 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v33)
  {
    swift_bridgeObjectRetain(a5);
    if ((a5 & 0x1000000000000000) != 0)
    {
      a4 = specialized static String._copying(_:)(a4, a5);
      unint64_t v37 = v36;
      swift_bridgeObjectRelease(a5);
      a5 = v37;
      if ((v37 & 0x2000000000000000) == 0)
      {
LABEL_38:
        if ((a4 & 0x1000000000000000) != 0)
        {
          uint64_t v34 = (_OWORD *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v35 = a4 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v34 = _StringObject.sharedUTF8.getter(a4, a5);
          if (!v34) {
LABEL_46:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/OutputStream.swift", 24, 2, 0x239uLL, 0);
          size_t v35 = v38;
        }
        goto LABEL_42;
      }
    }
    else if ((a5 & 0x2000000000000000) == 0)
    {
      goto LABEL_38;
    }
    size_t v35 = HIBYTE(a5) & 0xF;
    *(void *)&v45[0] = a4;
    *((void *)&v45[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v34 = v45;
LABEL_42:
    _swift_stdlib_fwrite_stdout(v34, 1uLL, v35);
    swift_bridgeObjectRelease(a5);
  }
  _swift_stdlib_funlockfile_stdout();
}

void debugPrint(_:separator:terminator:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
}

void print(_:separator:terminator:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, void (*a6)(uint64_t, uint64_t, unint64_t, uint64_t, unint64_t, uint64_t *), void (*a7)(uint64_t *, uint64_t, Class *, ValueMetadata *, _UNKNOWN **))
{
  uint64_t v12 = (void (*)(uint64_t, unint64_t))_playgroundPrintHook;
  if (_playgroundPrintHook)
  {
    uint64_t v14 = qword_1E8EBFEF8;
    uint64_t v16 = 0;
    unint64_t v17 = 0xE000000000000000;
    swift_retain((atomic_ullong *)qword_1E8EBFEF8);
    a6(a1, a2, a3, a4, a5, &v16);
    uint64_t v15 = v17;
    v12(v16, v17);
    swift_bridgeObjectRelease(v15);
    outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v12, v14);
  }
  else
  {
    specialized _print<A>(_:separator:terminator:to:)(a1, a2, a3, a4, a5, (uint64_t)a6, a7);
  }
}

void specialized _debugPrint<A>(_:separator:terminator:to:)(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t *a6)
{
  unint64_t v7 = a5;
  unint64_t v8 = a4;
  uint64_t v120 = *(void *)(a1 + 16);
  if (v120)
  {
    unint64_t v9 = a3;
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    uint64_t v119 = a1 + 32;
    unint64_t v12 = 0xE000000000000000;
    while (1)
    {
      outlined init with copy of Any(v119 + 32 * v10, (uint64_t)v126);
      outlined init with take of Any(v126, v125);
      uint64_t v14 = *a6;
      unint64_t v13 = a6[1];
      uint64_t v15 = HIBYTE(v13) & 0xF;
      if ((v13 & 0x2000000000000000) != 0) {
        uint64_t v16 = HIBYTE(v13) & 0xF;
      }
      else {
        uint64_t v16 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v16 && (v14 & ~v13 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(a6[1]);
        *a6 = v11;
        a6[1] = v12;
        goto LABEL_4;
      }
      uint64_t v17 = HIBYTE(v12) & 0xF;
      if ((v13 & 0x2000000000000000) != 0)
      {
        if ((v12 & 0x2000000000000000) != 0)
        {
          uint64_t v19 = v15 + v17;
          if ((unint64_t)(v15 + v17) <= 0xF)
          {
            if (v17)
            {
              char v82 = 0;
              unint64_t v83 = 0;
              uint64_t v84 = a6[1];
              do
              {
                unint64_t v85 = v15 + v83;
                unint64_t v86 = v83 + 1;
                if (v83 >= 8) {
                  unint64_t v87 = v12;
                }
                else {
                  unint64_t v87 = v11;
                }
                unint64_t v88 = v87 >> (v82 & 0x38);
                char v89 = (8 * v15 + v82) & 0x38;
                uint64_t v90 = (-255 << v89) - 1;
                unint64_t v91 = (unint64_t)v88 << v89;
                unint64_t v92 = v91 | v90 & v84;
                unint64_t v93 = v91 | v90 & v14;
                if (v85 < 8) {
                  uint64_t v14 = v93;
                }
                else {
                  uint64_t v84 = v92;
                }
                v82 += 8;
                unint64_t v83 = v86;
              }
              while (v17 != v86);
            }
            else
            {
              uint64_t v84 = a6[1];
            }
            swift_bridgeObjectRelease(a6[1]);
            swift_bridgeObjectRelease(v12);
            unint64_t v97 = 0xE000000000000000;
            if (v14 & 0x8080808080808080 | v84 & 0x80808080808080) {
              unint64_t v97 = 0xA000000000000000;
            }
            unint64_t v49 = v97 & 0xFF00000000000000 | (v19 << 56) | v84 & 0xFFFFFFFFFFFFFFLL;
LABEL_122:
            *a6 = v14;
            a6[1] = v49;
            goto LABEL_4;
          }
          uint64_t v18 = 1;
        }
        else
        {
          uint64_t v18 = 0;
        }
      }
      else
      {
        uint64_t v18 = v12 & 0x2000000000000000;
      }
      uint64_t v20 = v11 & 0xFFFFFFFFFFFFLL;
      uint64_t v122 = v18;
      if (v18) {
        uint64_t v21 = HIBYTE(v12) & 0xF;
      }
      else {
        uint64_t v21 = v11 & 0xFFFFFFFFFFFFLL;
      }
      uint64_t v118 = v21;
      if ((v12 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRetain_n(v12, 2);
        v98._Swift::UInt64 rawBits = 1;
        v99._Swift::UInt64 rawBits = (v21 << 16) | 1;
        v100._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v98, v99, v11, v12);
        if (v100._rawBits < 0x10000) {
          v100._rawBits |= 3;
        }
        uint64_t v21 = specialized Collection.count.getter(v100, v101, v11, v12);
        swift_bridgeObjectRelease(v12);
        if ((v13 & 0x1000000000000000) == 0)
        {
LABEL_21:
          BOOL v22 = __OFADD__(v16, v21);
          uint64_t v23 = v16 + v21;
          if (v22) {
            goto LABEL_159;
          }
          goto LABEL_22;
        }
      }
      else
      {
        swift_bridgeObjectRetain(v12);
        if ((v13 & 0x1000000000000000) == 0) {
          goto LABEL_21;
        }
      }
      Swift::Int v102 = String.UTF8View._foreignCount()();
      uint64_t v23 = v102 + v21;
      if (__OFADD__(v102, v21))
      {
LABEL_159:
        __break(1u);
LABEL_160:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
      }
LABEL_22:
      if ((v14 & ~v13 & 0x2000000000000000) != 0
        && (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL),
            uint64_t v14 = *a6,
            unint64_t v13 = a6[1],
            isUniquelyReferenced_nonNull_native))
      {
        int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(*a6, a6[1]);
        if (v26)
        {
          unint64_t v114 = 258;
LABEL_164:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v114, 0);
        }
        if (v23 <= 15 && ((v13 & 0x2000000000000000) != 0 || v25 < v21))
        {
LABEL_39:
          if ((v13 & 0x2000000000000000) != 0)
          {
            unint64_t v32 = v13;
            unint64_t v9 = a3;
          }
          else
          {
            unint64_t v9 = a3;
            if ((v13 & 0x1000000000000000) != 0)
            {
              uint64_t v14 = _StringGuts._foreignConvertedToSmall()(v14, v13);
              unint64_t v32 = v109;
            }
            else
            {
              if ((v14 & 0x1000000000000000) != 0)
              {
                uint16x8_t v103 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v104 = v14 & 0xFFFFFFFFFFFFLL;
              }
              else
              {
                uint16x8_t v103 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v14, v13);
              }
              closure #1 in _StringGuts._convertedToSmall()(v103, v104, &__src);
              uint64_t v14 = __src;
              unint64_t v32 = v124;
            }
          }
          if (v122)
          {
            swift_bridgeObjectRelease(v12);
            unint64_t v33 = v12;
          }
          else if ((v12 & 0x1000000000000000) != 0)
          {
            unint64_t v11 = _StringGuts._foreignConvertedToSmall()(v11, v12);
            unint64_t v33 = v110;
            swift_bridgeObjectRelease(v12);
          }
          else
          {
            if ((v11 & 0x1000000000000000) != 0)
            {
              uint64_t v105 = (unsigned __int8 *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }
            else
            {
              uint64_t v105 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v12);
              uint64_t v20 = v111;
            }
            closure #1 in _StringGuts._convertedToSmall()(v105, v20, &__src);
            swift_bridgeObjectRelease(v12);
            unint64_t v11 = __src;
            unint64_t v33 = v124;
          }
          uint64_t v34 = HIBYTE(v32) & 0xF;
          uint64_t v35 = HIBYTE(v33) & 0xF;
          uint64_t v36 = v35 + v34;
          if ((unint64_t)(v35 + v34) > 0xF)
          {
            unint64_t v114 = 266;
            goto LABEL_164;
          }
          if (v35)
          {
            char v37 = 0;
            unint64_t v38 = 0;
            do
            {
              unint64_t v39 = v34 + v38;
              unint64_t v40 = v38 + 1;
              if (v38 >= 8) {
                unint64_t v41 = v33;
              }
              else {
                unint64_t v41 = v11;
              }
              unint64_t v42 = v41 >> (v37 & 0x38);
              char v43 = (8 * v34 + v37) & 0x38;
              uint64_t v44 = (-255 << v43) - 1;
              unint64_t v45 = (unint64_t)v42 << v43;
              unint64_t v46 = v45 | v44 & v32;
              unint64_t v47 = v45 | v44 & v14;
              if (v39 < 8) {
                uint64_t v14 = v47;
              }
              else {
                unint64_t v32 = v46;
              }
              v37 += 8;
              unint64_t v38 = v40;
            }
            while (v35 != v40);
          }
          swift_bridgeObjectRelease(v13);
          swift_bridgeObjectRelease(v12);
          unint64_t v48 = 0xE000000000000000;
          if (v14 & 0x8080808080808080 | v32 & 0x80808080808080) {
            unint64_t v48 = 0xA000000000000000;
          }
          unint64_t v49 = v48 & 0xFF00000000000000 | (v36 << 56) | v32 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_122;
        }
      }
      else if (v23 <= 15)
      {
        goto LABEL_39;
      }
      int64_t v27 = _StringGuts.nativeUnusedCapacity.getter(v14, v13);
      BOOL v30 = (v28 & 1) == 0 && v27 >= v21;
      if ((v14 & ~v13 & 0x2000000000000000) != 0)
      {
        BOOL v31 = swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL);
        uint64_t v14 = *a6;
        unint64_t v13 = a6[1];
        if (v31)
        {
          if (v30) {
            goto LABEL_90;
          }
LABEL_57:
          uint64_t v50 = 2 * _StringGuts.nativeCapacity.getter(v14, v13);
          if (v51) {
            uint64_t v50 = 0;
          }
          if (v50 > v23) {
            uint64_t v23 = v50;
          }
          goto LABEL_61;
        }
      }
      if (!v30) {
        goto LABEL_57;
      }
LABEL_61:
      uint64_t v52 = _StringGuts.uniqueNativeCapacity.getter();
      if (v53)
      {
        unint64_t v55 = a6[1];
        if ((v55 & 0x1000000000000000) != 0)
        {
          Swift::Int v54 = String.UTF8View._foreignCount()();
        }
        else if ((v55 & 0x2000000000000000) != 0)
        {
          Swift::Int v54 = HIBYTE(v55) & 0xF;
        }
        else
        {
          Swift::Int v54 = *a6 & 0xFFFFFFFFFFFFLL;
        }
      }
      else
      {
        Swift::Int v54 = 2 * v52;
      }
      if (v54 <= v23) {
        int64_t v56 = v23;
      }
      else {
        int64_t v56 = v54;
      }
      unint64_t v57 = a6[1];
      if ((v57 & 0x1000000000000000) != 0)
      {
        _StringGuts._foreignGrow(_:)(v56);
        if ((v12 & 0x1000000000000000) == 0)
        {
LABEL_91:
          swift_bridgeObjectRelease(v12);
          unint64_t v9 = a3;
          if (v122)
          {
            uint64_t __src = v11;
            uint64_t v124 = v12 & 0xFFFFFFFFFFFFFFLL;
            uint64_t v71 = a6[1] & 0xFFFFFFFFFFFFFFFLL;
            uint64_t v72 = v71 + 32;
            unsigned int v73 = (char *)(v71 + 32 + (*(void *)(v71 + 0x18) & 0xFFFFFFFFFFFFLL));
            if (&__src < (uint64_t *)&v73[v17] && v73 < (char *)&__src + v17) {
              goto LABEL_160;
            }
            memcpy(v73, &__src, HIBYTE(v12) & 0xF);
            uint64_t v74 = *(void *)(v71 + 24);
            unint64_t v75 = (v74 & 0xFFFFFFFFFFFFLL) + v17;
            BOOL v76 = v74 > -1 || (v12 & 0x4000000000000000) == 0;
            unint64_t v77 = v75 | 0xC000000000000000;
            if (v76) {
              unint64_t v77 = v75;
            }
            uint64_t v78 = v77 | 0x3000000000000000;
            *(void *)(v71 + 24) = v77 | 0x3000000000000000;
            *(unsigned char *)(v72 + (v77 & 0xFFFFFFFFFFFFLL)) = 0;
            uint64_t v79 = *(void *)(v71 + 16);
            if (v79 < 0)
            {
              uint64_t v80 = (uint64_t *)((v72 + (v79 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8);
              uint64_t v81 = *v80;
              *uint64_t v80 = 0;
              swift_release(v81);
              uint64_t v78 = *(void *)(v71 + 24);
            }
            swift_bridgeObjectRelease(v12);
            *a6 = v78;
          }
          else
          {
            if ((v11 & 0x1000000000000000) != 0)
            {
              uint32x4_t v94 = (char *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }
            else
            {
              uint64_t v107 = (char *)_StringObject.sharedUTF8.getter(v11, v12);
              if (v108 < v20) {
                _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
              }
              uint32x4_t v94 = v107;
              if (v20)
              {
                unint64_t v9 = a3;
                if (!v107) {
                  _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer has a nil start and nonzero count", 53, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x541uLL, 0);
                }
              }
              else
              {
                unint64_t v9 = a3;
                uint64_t v20 = 0;
              }
            }
            uint64_t v95 = a6[1] & 0xFFFFFFFFFFFFFFFLL;
            uint64_t v96 = (char *)(v95 + (*(void *)(v95 + 0x18) & 0xFFFFFFFFFFFFLL) + 32);
            if (&v96[v20] > v94 && v96 < &v94[v20]) {
              goto LABEL_160;
            }
            memcpy(v96, v94, v20);
            __StringStorage._updateCountAndFlags(newCount:newIsASCII:)((*(void *)(v95 + 24) & 0xFFFFFFFFFFFFLL) + v20, (*(void *)(v95 + 24) & v11 & 0x8000000000000000) != 0);
            *a6 = *(void *)(v95 + 24);
            swift_bridgeObjectRelease(v12);
          }
          goto LABEL_4;
        }
        goto LABEL_3;
      }
      uint64_t v58 = *a6;
      if ((v57 & 0x2000000000000000) != 0)
      {
        size_t v67 = HIBYTE(v57) & 0xF;
        uint64_t __src = *a6;
        uint64_t v124 = v57 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v68 = v67 | 0xC000000000000000;
        if ((v57 & 0x4000000000000000) == 0) {
          unint64_t v68 = HIBYTE(v57) & 0xF;
        }
        uint64_t v66 = v68 | 0x3000000000000000;
        int64_t v64 = _allocateStringStorage(codeUnitCapacity:)(v56);
        *(void *)(v64 + 16) = v69;
        *(void *)(v64 + 24) = v66;
        if (v69 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
          uint64_t v66 = *(void *)(v64 + 24);
        }
        uint64_t v70 = (char *)(v64 + 32);
        *(unsigned char *)(v64 + 32 + (v66 & 0xFFFFFFFFFFFFLL)) = 0;
        if ((unint64_t)&__src < v64 + 32 + v67 && v70 < (char *)&__src + v67) {
          goto LABEL_160;
        }
        memcpy(v70, &__src, v67);
      }
      else
      {
        if ((v58 & 0x1000000000000000) != 0)
        {
          uint64_t v59 = (char *)((v57 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v60 = v58 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v59 = (char *)_StringObject.sharedUTF8.getter(v58, v57);
          size_t v60 = v106;
        }
        if (v58 >= 0) {
          unint64_t v61 = v60;
        }
        else {
          unint64_t v61 = v60 | 0xC000000000000000;
        }
        int64_t v62 = _allocateStringStorage(codeUnitCapacity:)(v56);
        int64_t v64 = v62;
        *(void *)(v62 + 16) = v63;
        *(void *)(v62 + 24) = v61 | 0x3000000000000000;
        if (v63 < 0) {
          *(void *)((v62 + (v63 & 0xFFFFFFFFFFFFLL) + 39) & 0xFFFFFFFFFFFFFFF8) = 0;
        }
        uint64_t v65 = (char *)(v62 + 32);
        *(unsigned char *)(v64 + 32 + (v61 & 0xFFFFFFFFFFFFLL)) = 0;
        uint64_t v20 = v11 & 0xFFFFFFFFFFFFLL;
        if (v64 + 32 + v60 > (unint64_t)v59 && v65 < &v59[v60]) {
          goto LABEL_160;
        }
        memcpy(v65, v59, v60);
        uint64_t v66 = *(void *)(v64 + 24);
      }
      swift_bridgeObjectRelease(a6[1]);
      *a6 = v66;
      a6[1] = v64;
LABEL_90:
      if ((v12 & 0x1000000000000000) == 0) {
        goto LABEL_91;
      }
LABEL_3:
      _StringGuts._foreignAppendInPlace(_:)(v11, v12, 0, v118);
      swift_bridgeObjectRelease_n(v12, 2);
      unint64_t v9 = a3;
LABEL_4:
      ++v10;
      _debugPrint_unlocked<A, B>(_:_:)((uint64_t)v125, (uint64_t)a6, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
      __swift_destroy_boxed_opaque_existential_1Tm(v125);
      swift_bridgeObjectRetain(v9);
      unint64_t v12 = v9;
      unint64_t v11 = a2;
      if (v10 == v120)
      {
        unint64_t v8 = a4;
        unint64_t v7 = a5;
        goto LABEL_152;
      }
    }
  }
  unint64_t v9 = 0xE000000000000000;
LABEL_152:
  swift_bridgeObjectRelease(v9);
  unint64_t v112 = a6[1];
  uint64_t v113 = HIBYTE(v112) & 0xF;
  if ((v112 & 0x2000000000000000) == 0) {
    uint64_t v113 = *a6 & 0xFFFFFFFFFFFFLL;
  }
  if (v113 || (*a6 & ~v112 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(v8, v7);
  }
  else
  {
    swift_bridgeObjectRetain(v7);
    swift_bridgeObjectRelease(v112);
    *a6 = v8;
    a6[1] = v7;
  }
}

void specialized _debugPrint<A>(_:separator:terminator:to:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  _swift_stdlib_flockfile_stdout();
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11)
  {
    uint64_t v39 = a4;
    unint64_t v40 = a5;
    uint64_t v12 = 0;
    uint64_t v13 = a1 + 32;
    unint64_t v14 = 0xE000000000000000;
    unint64_t v41 = a3;
    while (1)
    {
      outlined init with copy of Any(v13, (uint64_t)v45);
      outlined init with take of Any(v45, v44);
      unint64_t v17 = *a6;
      unint64_t v18 = a6[1];
      uint64_t v19 = HIBYTE(v18) & 0xF;
      if ((v18 & 0x2000000000000000) == 0) {
        uint64_t v19 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v19 && (v17 & ~v18 & 0x2000000000000000) == 0) {
        break;
      }
      uint64_t v20 = v14 & 0x2000000000000000;
      if ((v18 & 0x2000000000000000) == 0
        || !v20
        || (unint64_t v21 = specialized _SmallString.init(_:appending:)(v17, a6[1], v12, v14), (v23 & 1) != 0))
      {
        if (v20) {
          uint64_t v27 = HIBYTE(v14) & 0xF;
        }
        else {
          uint64_t v27 = v12 & 0xFFFFFFFFFFFFLL;
        }
        _StringGuts.append(_:)(v12, v14, 0, v27);
        unint64_t v26 = v14;
        a3 = v41;
LABEL_19:
        uint64_t v28 = HIBYTE(v26) & 0xF;
        if (!v20) {
          uint64_t v28 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (!v28) {
          goto LABEL_5;
        }
        goto LABEL_22;
      }
      unint64_t v24 = v21;
      unint64_t v25 = v22;
      swift_bridgeObjectRelease(v18);
      *a6 = v24;
      a6[1] = v25;
      unint64_t v26 = v14;
      a3 = v41;
      if ((v14 & 0xF00000000000000) == 0) {
        goto LABEL_5;
      }
LABEL_22:
      swift_bridgeObjectRetain(v14);
      if ((v26 & 0x1000000000000000) != 0)
      {
        uint64_t v12 = specialized static String._copying(_:)(v12, v14);
        unint64_t v26 = v30;
        swift_bridgeObjectRelease(v14);
        uint64_t v29 = v26;
        if ((v26 & 0x2000000000000000) == 0)
        {
LABEL_24:
          if ((v12 & 0x1000000000000000) != 0)
          {
            uint64_t v16 = (void *)((v26 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v15 = v12 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v16 = _StringObject.sharedUTF8.getter(v12, v29);
            if (!v16) {
              goto LABEL_46;
            }
            size_t v15 = v31;
          }
          goto LABEL_4;
        }
      }
      else
      {
        uint64_t v29 = v14;
        if ((v26 & 0x2000000000000000) == 0) {
          goto LABEL_24;
        }
      }
      size_t v15 = HIBYTE(v26) & 0xF;
      v43[0] = v12;
      v43[1] = v26 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v16 = v43;
LABEL_4:
      _swift_stdlib_fwrite_stdout(v16, 1uLL, v15);
      swift_bridgeObjectRelease(v29);
LABEL_5:
      swift_bridgeObjectRelease(v14);
      _debugPrint_unlocked<A, B>(_:_:)((uint64_t)v44, (uint64_t)a6, qword_1ECA06310, (uint64_t)&unk_1ECA02F30, (uint64_t)&protocol witness table for _TeeStream<A, B>);
      __swift_destroy_boxed_opaque_existential_1Tm(v44);
      swift_bridgeObjectRetain(a3);
      v13 += 32;
      unint64_t v14 = a3;
      uint64_t v12 = a2;
      if (!--v11)
      {
        a4 = v39;
        a5 = v40;
        goto LABEL_33;
      }
    }
    swift_bridgeObjectRetain(v14);
    swift_bridgeObjectRelease(v18);
    *a6 = v12;
    a6[1] = v14;
    uint64_t v20 = v14 & 0x2000000000000000;
    unint64_t v26 = v14;
    goto LABEL_19;
  }
  a3 = 0xE000000000000000;
LABEL_33:
  swift_bridgeObjectRelease(a3);
  v32._uint64_t countAndFlagsBits = a4;
  v32._unint64_t object = (void *)a5;
  String.write(_:)(v32);
  uint64_t v33 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000) == 0) {
    uint64_t v33 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v33)
  {
    swift_bridgeObjectRetain(a5);
    if ((a5 & 0x1000000000000000) != 0)
    {
      a4 = specialized static String._copying(_:)(a4, a5);
      unint64_t v37 = v36;
      swift_bridgeObjectRelease(a5);
      a5 = v37;
      if ((v37 & 0x2000000000000000) == 0)
      {
LABEL_38:
        if ((a4 & 0x1000000000000000) != 0)
        {
          uint64_t v34 = (_OWORD *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v35 = a4 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v34 = _StringObject.sharedUTF8.getter(a4, a5);
          if (!v34) {
LABEL_46:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/OutputStream.swift", 24, 2, 0x239uLL, 0);
          size_t v35 = v38;
        }
        goto LABEL_42;
      }
    }
    else if ((a5 & 0x2000000000000000) == 0)
    {
      goto LABEL_38;
    }
    size_t v35 = HIBYTE(a5) & 0xF;
    *(void *)&v45[0] = a4;
    *((void *)&v45[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v34 = v45;
LABEL_42:
    _swift_stdlib_fwrite_stdout(v34, 1uLL, v35);
    swift_bridgeObjectRelease(a5);
  }
  _swift_stdlib_funlockfile_stdout();
}

void specialized _print<A>(_:separator:terminator:to:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, void (*a7)(uint64_t *, uint64_t, Class *, ValueMetadata *, _UNKNOWN **))
{
  _swift_stdlib_flockfile_stdout();
  uint64_t v14 = *(void *)(a1 + 16);
  if (v14)
  {
    uint64_t v30 = a4;
    unint64_t v31 = a5;
    uint64_t v15 = 0;
    uint64_t v16 = a1 + 32;
    unint64_t v17 = 0xE000000000000000;
    while (1)
    {
      outlined init with copy of Any(v16, (uint64_t)v34);
      outlined init with take of Any(v34, v33);
      uint64_t v20 = HIBYTE(v17) & 0xF;
      if ((v17 & 0x2000000000000000) == 0) {
        uint64_t v20 = v15 & 0xFFFFFFFFFFFFLL;
      }
      if (!v20) {
        goto LABEL_5;
      }
      swift_bridgeObjectRetain(v17);
      if ((v17 & 0x1000000000000000) != 0)
      {
        uint64_t v15 = specialized static String._copying(_:)(v15, v17);
        unint64_t v21 = v22;
        swift_bridgeObjectRelease(v17);
        if ((v21 & 0x2000000000000000) == 0)
        {
LABEL_11:
          if ((v15 & 0x1000000000000000) != 0)
          {
            uint64_t v19 = (void *)((v21 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v18 = v15 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v19 = _StringObject.sharedUTF8.getter(v15, v21);
            if (!v19) {
              goto LABEL_32;
            }
            size_t v18 = v23;
          }
          goto LABEL_4;
        }
      }
      else
      {
        unint64_t v21 = v17;
        if ((v17 & 0x2000000000000000) == 0) {
          goto LABEL_11;
        }
      }
      size_t v18 = HIBYTE(v21) & 0xF;
      v32[0] = v15;
      v32[1] = v21 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v19 = v32;
LABEL_4:
      _swift_stdlib_fwrite_stdout(v19, 1uLL, v18);
      swift_bridgeObjectRelease(v21);
LABEL_5:
      swift_bridgeObjectRelease(v17);
      a7(v33, a6, qword_1ECA06310, &type metadata for _Stdout, &protocol witness table for _Stdout);
      __swift_destroy_boxed_opaque_existential_1Tm(v33);
      swift_bridgeObjectRetain(a3);
      v16 += 32;
      unint64_t v17 = a3;
      uint64_t v15 = a2;
      if (!--v14)
      {
        a4 = v30;
        a5 = v31;
        goto LABEL_19;
      }
    }
  }
  a3 = 0xE000000000000000;
LABEL_19:
  swift_bridgeObjectRelease(a3);
  uint64_t v24 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000) == 0) {
    uint64_t v24 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v24)
  {
    swift_bridgeObjectRetain(a5);
    if ((a5 & 0x1000000000000000) != 0)
    {
      a4 = specialized static String._copying(_:)(a4, a5);
      unint64_t v28 = v27;
      swift_bridgeObjectRelease(a5);
      a5 = v28;
      if ((v28 & 0x2000000000000000) == 0)
      {
LABEL_24:
        if ((a4 & 0x1000000000000000) != 0)
        {
          unint64_t v25 = (_OWORD *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v26 = a4 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v25 = _StringObject.sharedUTF8.getter(a4, a5);
          if (!v25) {
LABEL_32:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/OutputStream.swift", 24, 2, 0x239uLL, 0);
          size_t v26 = v29;
        }
        goto LABEL_28;
      }
    }
    else if ((a5 & 0x2000000000000000) == 0)
    {
      goto LABEL_24;
    }
    size_t v26 = HIBYTE(a5) & 0xF;
    *(void *)&v34[0] = a4;
    *((void *)&v34[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a5 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v25 = v34;
LABEL_28:
    _swift_stdlib_fwrite_stdout(v25, 1uLL, v26);
    swift_bridgeObjectRelease(a5);
  }
  _swift_stdlib_funlockfile_stdout();
}

uint64_t _print<A>(_:separator:terminator:to:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void (*a9)(uint64_t *, uint64_t))
{
  (*(void (**)(uint64_t, uint64_t))(a8 + 8))(a7, a8);
  uint64_t v17 = *(void *)(a1 + 16);
  if (v17)
  {
    uint64_t v22 = a5;
    outlined init with copy of Any(a1 + 32, (uint64_t)v23);
    size_t v18 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a8 + 24);
    v18(0, 0xE000000000000000, a7, a8);
    swift_bridgeObjectRelease(0xE000000000000000);
    a9(v23, a6);
    __swift_destroy_boxed_opaque_existential_1Tm(v23);
    swift_bridgeObjectRetain(a3);
    uint64_t v19 = v17 - 1;
    if (v19)
    {
      uint64_t v20 = a1 + 64;
      do
      {
        outlined init with copy of Any(v20, (uint64_t)v23);
        v18(a2, a3, a7, a8);
        swift_bridgeObjectRelease(a3);
        ((void (*)(uint64_t *, uint64_t, Class *, uint64_t, uint64_t))a9)(v23, a6, qword_1ECA06310, a7, a8);
        __swift_destroy_boxed_opaque_existential_1Tm(v23);
        swift_bridgeObjectRetain(a3);
        v20 += 32;
        --v19;
      }
      while (v19);
    }
    a5 = v22;
  }
  else
  {
    a3 = 0xE000000000000000;
  }
  swift_bridgeObjectRelease(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a8 + 24))(a4, a5, a7, a8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a8 + 16))(a7, a8);
}

Swift::UInt64 __swiftcall SystemRandomNumberGenerator.next()()
{
  Swift::UInt64 __buf = 0;
  swift_stdlib_random(&__buf, 8uLL);
  return __buf;
}

uint64_t protocol witness for RandomNumberGenerator.next() in conformance SystemRandomNumberGenerator()
{
  uint64_t __buf = 0;
  swift_stdlib_random(&__buf, 8uLL);
  return __buf;
}

uint64_t RandomAccessCollection.index(_:offsetBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return BidirectionalCollection.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 + 8), a5);
}

uint64_t RandomAccessCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return BidirectionalCollection.distance(from:to:)(a1, a2, a3, *(void *)(a4 + 8));
}

uint64_t Range.init(uncheckedBounds:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v52 = a5;
  char v53 = (char *)a4;
  unint64_t v8 = type metadata accessor for Range(0, a3, a4, a4);
  uint64_t v50 = (uint64_t)*(v8 - 1);
  char v51 = v8;
  MEMORY[0x1F4188790](v8);
  unint64_t v55 = (char *)&v44 - v9;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a3, a3, "lower upper ", 0);
  unint64_t v45 = (char *)*(TupleTypeMetadata2 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v49 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  unint64_t v47 = (char *)&v44 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  Swift::Int v54 = (char *)&v44 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v46 = (char *)&v44 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  unint64_t v21 = (char *)&v44 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v44 - v23;
  unint64_t v25 = (char *)&v44 + *(int *)(v22 + 48) - v23;
  uint64_t v26 = *(void *)(a3 - 8);
  unint64_t v27 = *(void (**)(void))(v26 + 32);
  ((void (*)(char *, uint64_t, uint64_t))v27)((char *)&v44 - v23, a1, a3);
  ((void (*)(char *, uint64_t, uint64_t))v27)(v25, a2, a3);
  unint64_t v28 = TupleTypeMetadata2;
  size_t v29 = &v21[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v48 = v26;
  uint64_t v30 = *(void (**)(char *, char *, uint64_t))(v26 + 16);
  v30(v21, v24, a3);
  v30(v29, v25, a3);
  if (((*((uint64_t (**)(char *, char *, uint64_t))v53 + 3))(v21, v29, a3) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  (*((void (**)(char *, uint64_t *))v45 + 1))(v21, v28);
  unint64_t v31 = v46;
  char v53 = &v46[*((int *)v28 + 12)];
  Swift::String v32 = v53;
  v30(v46, v24, a3);
  v30(v32, v25, a3);
  uint64_t v33 = &v54[*((int *)v28 + 12)];
  v27();
  ((void (*)(char *, char *, uint64_t))v27)(v33, v25, a3);
  uint64_t v34 = v47;
  size_t v35 = &v47[*((int *)v28 + 12)];
  ((void (*)(char *, char *, uint64_t))v27)(v47, v31, a3);
  unint64_t v45 = v35;
  ((void (*)(char *, char *, uint64_t))v27)(v35, v33, a3);
  unint64_t v36 = v49;
  unint64_t v37 = v30;
  size_t v38 = &v49[*((int *)v28 + 12)];
  v37(v49, v34, a3);
  v37(v38, v35, a3);
  ((void (*)(char *, char *, uint64_t))v27)(v55, v36, a3);
  uint64_t v39 = *(void (**)(char *, uint64_t))(v48 + 8);
  v39(v38, a3);
  unint64_t v40 = &v36[*((int *)v28 + 12)];
  ((void (*)(char *, char *, uint64_t))v27)(v36, v34, a3);
  ((void (*)(char *, char *, uint64_t))v27)(v40, v45, a3);
  unint64_t v41 = v51;
  unint64_t v42 = v55;
  ((void (*)(char *, char *, uint64_t))v27)(&v55[*((int *)v51 + 9)], v40, a3);
  v39(v36, a3);
  (*(void (**)(uint64_t, char *, Class *))(v50 + 32))(v52, v42, v41);
  v39(v54, a3);
  return ((uint64_t (*)(char *, uint64_t))v39)(v53, a3);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance <> Range<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v5 = a1[2];
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = &v17.i8[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v10 = *(void *)(v7 - 8);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, unint64_t *))(v10 + 16);
  int8x16_t v17 = *(int8x16_t *)(v12 - 16);
  v11(a2, v2, a1);
  Range<>.startIndex.getter((uint64_t)a1, (uint64_t)v9);
  (*(void (**)(uint64_t, unint64_t *))(v10 + 8))(v2, a1);
  int8x16_t v18 = vextq_s8(v17, v17, 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a1, (uint64_t)&v18);
  uint64_t v15 = type metadata accessor for IndexingIterator(0, (uint64_t)a1, WitnessTable, v14);
  return (*(uint64_t (**)(uint64_t, __int8 *, unint64_t))(v6 + 32))(a2 + *((int *)v15 + 9), v9, v5);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance <> Range<A>(unint64_t *a1, uint64_t a2)
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>(a1, a2, protocol conformance descriptor for <> Range<A>, (uint64_t (*)(unint64_t *, uint64_t))Collection.underestimatedCount.getter);
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance <> Range<A>(uint64_t a1, uint64_t a2)
{
  return Range<>._customContainsEquatableElement(_:)(a1, a2);
}

uint64_t Range<>._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = *(void *)(v15 + 8);
  char v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 24))(v3, a1, v11, v16);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, a1, v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v9, v3, a2);
  if (v17) {
    char v18 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v16 + 16))(v14, &v9[*(int *)(a2 + 36)], v11, v16);
  }
  else {
    char v18 = 0;
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  return v18 & 1;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance <> Range<A>(unint64_t *a1, uint64_t a2)
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>(a1, a2, protocol conformance descriptor for <> Range<A>, (uint64_t (*)(unint64_t *, uint64_t))Collection._copyToContiguousArray());
}

uint64_t Range<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 16))(a2, v2);
}

uint64_t Range<>.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 16))(a2, v2 + *(int *)(a1 + 36));
}

uint64_t Range<>.index(after:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v69 = a4;
  uint64_t v75 = a5;
  BOOL v76 = a1;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, v8, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v73 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v72 = (char *)&v56 - v10;
  uint64_t v70 = *(int ***)(*(void *)(swift_getAssociatedConformanceWitness(a3, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)+ 8)+ 16);
  uint64_t v74 = AssociatedTypeWitness;
  unint64_t v68 = swift_getAssociatedTypeWitness(0, v70, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v68);
  size_t v67 = (char *)&v56 - v11;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v8, v8, "lower upper ", 0);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v66 = (char *)&v56 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  unint64_t v61 = (char *)&v56 - v15;
  uint64_t v16 = *(void *)(v8 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v56 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v56 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v25 = (char *)&v56 - v24;
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  unint64_t v28 = (char *)&v56 - v27;
  uint64_t v71 = a2;
  uint64_t v65 = *(void *)(a2 - 8);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  uint64_t v63 = (char *)&v56 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v29);
  int64_t v64 = (char *)&v56 - v31;
  uint64_t v59 = v16;
  Swift::String v32 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v32(v28, v5, v8);
  v32(v25, v5 + *(int *)(a2 + 36), v8);
  v32(v22, (uint64_t)v28, v8);
  int64_t v62 = v25;
  size_t v60 = v32;
  v32(v19, (uint64_t)v25, v8);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 24))(v22, v19, v8) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v33 = v59;
  uint64_t v58 = a3;
  uint64_t v34 = *(void (**)(char *, uint64_t))(v59 + 8);
  unint64_t v77 = v34;
  v34(v19, v8);
  v34(v22, v8);
  size_t v35 = TupleTypeMetadata2;
  unint64_t v36 = v61;
  unint64_t v37 = &v61[*((int *)TupleTypeMetadata2 + 12)];
  size_t v38 = *(void (**)(char *, char *, uint64_t))(v33 + 32);
  v38(v61, v28, v8);
  unint64_t v57 = v37;
  v38(v37, v62, v8);
  uint64_t v39 = v66;
  unint64_t v40 = &v66[*((int *)v35 + 12)];
  unint64_t v41 = (void (*)(char *, char *, uint64_t))v60;
  v60(v66, (uint64_t)v36, v8);
  v41(v40, v37, v8);
  unint64_t v42 = v63;
  v38(v63, v39, v8);
  v77(v40, v8);
  char v43 = &v39[*((int *)TupleTypeMetadata2 + 12)];
  v38(v39, v36, v8);
  v38(v43, v57, v8);
  uint64_t v44 = (unint64_t *)v71;
  v38(&v42[*(int *)(v71 + 36)], v43, v8);
  v77(v39, v8);
  uint64_t v46 = (uint64_t)v64;
  uint64_t v45 = v65;
  (*(void (**)(char *, char *, unint64_t *))(v65 + 32))(v64, v42, v44);
  uint64_t v47 = v58;
  v79[0] = v58;
  v79[1] = v69;
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, v44, (uint64_t)v79);
  specialized Collection._failEarlyRangeCheck(_:bounds:)(v76, v46, (uint64_t)v44, WitnessTable);
  (*(void (**)(uint64_t, unint64_t *))(v45 + 8))(v46, v44);
  unint64_t v49 = v70;
  uint64_t v50 = (uint64_t)v74;
  char v51 = v68;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v70, (uint64_t)v74, (uint64_t)v68, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v53 = v67;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, v51, AssociatedConformanceWitness);
  Swift::Int v54 = v72;
  ((void (*)(char *, uint64_t, int **))v49[3])(v53, v50, v49);
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 48))(v54, v8, v47);
  return (*(uint64_t (**)(char *, uint64_t))(v73 + 8))(v54, v50);
}

uint64_t Range<>.index(before:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, v7, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v44 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v43 = (char *)&v38 - v9;
  unint64_t v42 = *(int ***)(*(void *)(swift_getAssociatedConformanceWitness(a3, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)+ 8)+ 16);
  uint64_t v45 = AssociatedTypeWitness;
  unint64_t v41 = swift_getAssociatedTypeWitness(0, v42, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](v41);
  unint64_t v40 = (char *)&v38 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v49 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v18 = *(void *)(v7 - 8);
  uint64_t v19 = MEMORY[0x1F4188790](v15);
  uint64_t v21 = (char *)&v38 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v38 - v22;
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  uint64_t v50 = a1;
  uint64_t v48 = v24;
  v24((char *)&v38 - v22, a1, v7);
  uint64_t v53 = v12;
  unint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v51 = a2;
  uint64_t v47 = v25;
  v25(v17, v52, a2);
  uint64_t v26 = *(void *)(a3 + 8);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v26 + 40))(v23, v17, v7, v26) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Range.swift", 17, 2, 0xF1uLL, 0);
  }
  uint64_t v39 = a3;
  uint64_t v27 = *(void (**)(char *, uint64_t))(v53 + 8);
  uint64_t v28 = v51;
  v53 += 8;
  v27(v17, v51);
  uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
  v29(v23, v7);
  v48(v21, v50, v7);
  uint64_t v30 = v49;
  v47(v49, v52, v28);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v26 + 24))(v21, &v30[*(int *)(v28 + 36)], v7, v26) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Range.swift", 17, 2, 0xF2uLL, 0);
  }
  v27(v30, v51);
  v29(v21, v7);
  uint64_t v31 = v41;
  Swift::String v32 = v42;
  uint64_t v33 = (uint64_t)v45;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v42, (uint64_t)v45, (uint64_t)v41, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  size_t v35 = v40;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&unk_18162B0C8, 257, v31, AssociatedConformanceWitness);
  unint64_t v36 = v43;
  ((void (*)(char *, uint64_t, int **))v32[3])(v35, v33, v32);
  (*(void (**)(char *, uint64_t))(v39 + 48))(v36, v7);
  return (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v36, v33);
}

uint64_t Range<>.index(_:offsetBy:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v47 = a6;
  uint64_t v44 = a1;
  uint64_t v46 = a3;
  uint64_t v49 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  unint64_t v42 = (char *)&v42 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  char v43 = (char *)&v42 - v12;
  uint64_t v14 = *(void *)(v13 + 16);
  uint64_t v50 = *(void *)(v14 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  uint64_t v45 = (char *)&v42 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v42 - v17;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, v14, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v20 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v21 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v23 = (char *)&v42 - v22;
  uint64_t v51 = a2;
  uint64_t v24 = *(void *)(a5 + 8);
  unint64_t v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v24 + 88);
  unint64_t v28 = lazy protocol witness table accessor for type Int and conformance Int(v21, v26, v27);
  v25(&v51, &type metadata for Int, v28, AssociatedTypeWitness, v24);
  uint64_t v29 = v49;
  uint64_t v30 = v47;
  (*(void (**)(char *, uint64_t, uint64_t))(a4 + 48))(v23, v14, a4);
  (*(void (**)(char *, const char *))(v20 + 8))(v23, AssociatedTypeWitness);
  uint64_t v31 = *(void (**)(char *, uint64_t, uint64_t))(v50 + 16);
  v31(v18, v30, v14);
  Swift::String v32 = *(void (**)(char *, uint64_t, uint64_t))(v29 + 16);
  uint64_t v33 = v43;
  v32(v43, v48, v46);
  uint64_t v34 = *(void *)(a4 + 8);
  size_t v35 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 32);
  uint64_t v44 = v18;
  if ((v35(v18, v33, v14, v34) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Range.swift", 17, 2, 0xFAuLL, 0);
  }
  unint64_t v36 = *(void (**)(char *, uint64_t))(v29 + 8);
  uint64_t v37 = v46;
  uint64_t v49 = v29 + 8;
  v36(v33, v46);
  uint64_t v38 = *(void (**)(char *, uint64_t))(v50 + 8);
  v50 += 8;
  v38(v44, v14);
  uint64_t v39 = v45;
  v31(v45, v47, v14);
  unint64_t v40 = v42;
  v32(v42, v48, v37);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 24))(v39, &v40[*(int *)(v37 + 36)], v14, v34) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Range.swift", 17, 2, 0xFBuLL, 0); {
  v36(v40, v37);
  }
  return ((uint64_t (*)(char *, uint64_t))v38)(v45, v14);
}

uint64_t Range<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return specialized Range<>.distance(from:to:)(a1, a2, *(void *)(a3 + 16), a4, a5);
}

uint64_t Range<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a3, a1, a2);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v18;

  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, v15, a2);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v16(v10, a1, v6);
  if ((Range.contains(_:)((uint64_t)v10, a2) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
  }
  (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v6);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, a2);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v16)(a3, a1, v6);
}

uint64_t Range<>.indices.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a2, v2, a1);
}

uint64_t Range<>._customIndexOfEquatableElement(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v33 = a3;
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v15 = (char *)&v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = *(void *)(v16 + 8);
  char v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 24))(v4, a1, v12, v17);
  uint64_t v31 = a1;
  uint64_t v32 = v13;
  uint64_t v19 = a1;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v20(v15, v19, v12);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, v4, a2);
  if (v18)
  {
    uint64_t v30 = (void (*)(uint64_t, uint64_t, uint64_t))v20;
    uint64_t v21 = v31;
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v17 + 16))(v15, &v10[*(int *)(a2 + 36)], v12, v17);
    (*(void (**)(char *, uint64_t))(v7 + 8))(v10, a2);
    uint64_t v23 = v32;
    (*(void (**)(char *, uint64_t))(v32 + 8))(v15, v12);
    uint64_t v24 = v33;
    if (v22)
    {
      v30(v33, v21, v12);
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t v25 = 1;
    }
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v7 + 8))(v10, a2);
    uint64_t v23 = v32;
    (*(void (**)(char *, uint64_t))(v32 + 8))(v15, v12);
    uint64_t v25 = 1;
    uint64_t v24 = v33;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v23 + 56))(v24, v25, 1, v12);
  unint64_t v28 = type metadata accessor for Optional(0, v12, v26, v27);
  return (*((uint64_t (**)(uint64_t, void, uint64_t, Class *))*(v28 - 1) + 7))(v24, 0, 1, v28);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> Range<A>(void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = Range<>.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*Range<>.subscript.read(void *a1, uint64_t a2, uint64_t a3))(void ***a1)
{
  uint64_t v4 = v3;
  uint64_t v7 = malloc(0x30uLL);
  uint64_t v8 = *(void *)(a3 - 8);
  *a1 = v7;
  uint64_t v9 = v8;
  uint64_t v10 = malloc(*(void *)(v8 + 64));
  uint64_t v11 = *(void *)(a3 + 16);
  *uint64_t v7 = v10;
  v7[1] = v11;
  uint64_t v12 = *(void **)(v11 - 8);
  size_t v13 = v12[8];
  uint64_t v14 = malloc(v13);
  v7[2] = v14;
  uint64_t v15 = malloc(v13);
  v7[3] = v15;
  (*(void (**)(void *, uint64_t, uint64_t))(v9 + 16))(v10, v4, a3);
  uint64_t v16 = (void (*)(void *, uint64_t, uint64_t))v12[2];
  v16(v14, a2, v11);
  if ((Range.contains(_:)((uint64_t)v14, a3) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
  }
  uint64_t v17 = (void (*)(void *, uint64_t))v12[1];
  v7[4] = v17;
  v7[5] = (unint64_t)(v12 + 1) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
  v17(v14, v11);
  (*(void (**)(void *, uint64_t))(v9 + 8))(v10, a3);
  v16(v15, a2, v11);
  return Range<>.subscript.read;
}

void Range<>.subscript.read(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = (*a1)[2];
  uint64_t v2 = (*a1)[3];
  uint64_t v4 = **a1;
  ((void (*)(void *, void *))(*a1)[4])(v2, (*a1)[1]);
  free(v2);
  free(v3);
  free(v4);

  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance <> Range<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return Range<>.subscript.getter(a1, a2, a3);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> Range<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return Range<>._customIndexOfEquatableElement(_:)(a1, a2, a3);
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Range<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> Range<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> ClosedRange<A>(a1, a2, a3, a4, a5, protocol conformance descriptor for <> Range<A>, a6);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return specialized Range<>.distance(from:to:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> Range<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v56 = a1;
  uint64_t v71 = a4;
  uint64_t v66 = a3;
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v69 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v68 = (char *)&v53 - v8;
  uint64_t v65 = *(int ***)(*(void *)(swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)+ 8)+ 16);
  uint64_t v70 = AssociatedTypeWitness;
  int64_t v64 = swift_getAssociatedTypeWitness(0, v65, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v64);
  uint64_t v63 = (char *)&v53 - v9;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v10 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  int64_t v62 = (char *)&v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v61 = (char *)&v53 - v13;
  uint64_t v14 = *(void **)(v6 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v53 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v53 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v53 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  uint64_t v26 = (char *)&v53 - v25;
  uint64_t v60 = *(void *)(a2 - 8);
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  uint64_t v58 = (char *)&v53 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v27);
  uint64_t v59 = (char *)&v53 - v29;
  Range<>.startIndex.getter(a2, (uint64_t)v26);
  uint64_t v67 = a2;
  Range<>.endIndex.getter(a2, (uint64_t)v23);
  uint64_t v30 = (void (*)(char *, char *, uint64_t))v14[2];
  v30(v20, v26, v6);
  unint64_t v57 = v23;
  v30(v17, v23, v6);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v5 + 8) + 24))(v20, v17, v6) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v55 = v5;
  uint64_t v31 = (void (*)(char *, uint64_t))v14[1];
  uint64_t v72 = v31;
  v31(v17, v6);
  v31(v20, v6);
  uint64_t v53 = v30;
  uint64_t v32 = TupleTypeMetadata2;
  uint64_t v33 = v61;
  uint64_t v34 = &v61[*((int *)TupleTypeMetadata2 + 12)];
  size_t v35 = (void (*)(char *, char *, uint64_t))v14[4];
  v35(v61, v26, v6);
  Swift::Int v54 = v34;
  v35(v34, v57, v6);
  unint64_t v36 = v62;
  uint64_t v37 = &v62[*((int *)v32 + 12)];
  uint64_t v38 = v6;
  uint64_t v39 = v6;
  unint64_t v40 = v53;
  v53(v62, v33, v38);
  v40(v37, v34, v39);
  unint64_t v41 = v58;
  v35(v58, v36, v39);
  v72(v37, v39);
  unint64_t v42 = &v36[*((int *)TupleTypeMetadata2 + 12)];
  v35(v36, v33, v39);
  v35(v42, v54, v39);
  uint64_t v43 = v67;
  v35(&v41[*(int *)(v67 + 36)], v42, v39);
  v72(v36, v39);
  uint64_t v45 = v59;
  uint64_t v44 = v60;
  (*(void (**)(char *, char *, uint64_t))(v60 + 32))(v59, v41, v43);
  Collection._failEarlyRangeCheck(_:bounds:)(v56, v45, v43, v66);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v45, v43);
  uint64_t v46 = v64;
  uint64_t v47 = v65;
  uint64_t v48 = (uint64_t)v70;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v65, (uint64_t)v70, (uint64_t)v64, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v50 = v63;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, v46, AssociatedConformanceWitness);
  uint64_t v51 = v68;
  ((void (*)(char *, uint64_t, int **))v47[3])(v50, v48, v47);
  (*(void (**)(char *, uint64_t))(v55 + 48))(v51, v39);
  return (*(uint64_t (**)(char *, uint64_t))(v69 + 8))(v51, v48);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> Range<A>(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v81 = a1;
  uint64_t v75 = a3;
  uint64_t v4 = *(void *)(a3 - 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v4, v5, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v78 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v77 = (char *)&v60 - v7;
  uint64_t v74 = *(int ***)(*(void *)(swift_getAssociatedConformanceWitness(v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)+ 8)+ 16);
  uint64_t v79 = AssociatedTypeWitness;
  uint64_t v73 = swift_getAssociatedTypeWitness(0, v74, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v73);
  uint64_t v72 = (char *)&v60 - v8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v5, v5, "lower upper ", 0);
  uint64_t v9 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v69 = (char *)&v60 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v65 = (char *)&v60 - v12;
  uint64_t v70 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v60 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  unint64_t v68 = (char *)&v60 - v17;
  uint64_t v18 = *(void *)(v5 - 8);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v21 = (char *)&v60 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v60 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v60 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v30 = (char *)&v60 - v29;
  MEMORY[0x1F4188790](v28);
  uint64_t v71 = (char *)&v60 - v31;
  Range<>.startIndex.getter(a2, (uint64_t)v30);
  uint64_t v76 = a2;
  Range<>.endIndex.getter(a2, (uint64_t)v27);
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v18 + 16);
  v32(v24, v30, v5);
  uint64_t v66 = v27;
  int64_t v64 = v32;
  v32(v21, v27, v5);
  uint64_t v80 = v4;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v4 + 8) + 24))(v24, v21, v5) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v33 = *(void (**)(char *, uint64_t))(v18 + 8);
  char v82 = v33;
  uint64_t v63 = v18 + 8;
  v33(v21, v5);
  v33(v24, v5);
  uint64_t v34 = v15;
  int64_t v62 = v15;
  uint64_t v35 = v18;
  unint64_t v36 = TupleTypeMetadata2;
  uint64_t v37 = v65;
  uint64_t v38 = &v65[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v39 = *(void (**)(char *, char *, uint64_t))(v35 + 32);
  unint64_t v61 = v39;
  v39(v65, v30, v5);
  v39(v38, v66, v5);
  unint64_t v40 = v69;
  unint64_t v41 = &v69[*((int *)v36 + 12)];
  unint64_t v42 = v64;
  v64(v69, v37, v5);
  v42(v41, v38, v5);
  uint64_t v43 = v34;
  uint64_t v44 = v61;
  v61(v43, v40, v5);
  uint64_t v45 = v82;
  v82(v41, v5);
  uint64_t v46 = &v40[*((int *)v36 + 12)];
  v44(v40, v37, v5);
  v44(v46, v38, v5);
  uint64_t v47 = v76;
  uint64_t v48 = v62;
  v44(&v62[*(int *)(v76 + 36)], v46, v5);
  v45(v40, v5);
  uint64_t v49 = v70;
  uint64_t v50 = v68;
  (*(void (**)(char *, char *, uint64_t))(v70 + 32))(v68, v48, v47);
  uint64_t v51 = v81;
  Collection._failEarlyRangeCheck(_:bounds:)(v81, v50, v47, v75);
  (*(void (**)(char *, uint64_t))(v49 + 8))(v50, v47);
  uint64_t v52 = v73;
  uint64_t v53 = v74;
  uint64_t v54 = (uint64_t)v79;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v74, (uint64_t)v79, (uint64_t)v73, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v56 = v72;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, v52, AssociatedConformanceWitness);
  unint64_t v57 = v77;
  ((void (*)(char *, uint64_t, int **))v53[3])(v56, v54, v53);
  uint64_t v58 = v71;
  (*(void (**)(char *, uint64_t))(v80 + 48))(v57, v5);
  v82(v51, v5);
  (*(void (**)(char *, uint64_t))(v78 + 8))(v57, v54);
  return ((uint64_t (*)(char *, char *, uint64_t))v44)(v51, v58, v5);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> Range<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> Range<A>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  Range<>.index(before:)(v5, v8, v9, (uint64_t)v7);
  (*(void (**)(uint64_t, uint64_t))(v4 + 8))(a1, v3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v4 + 32))(a1, v7, v3);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> Range<A>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return Range<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16), a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> ClosedRange<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X4>, int *a6@<X5>, uint64_t a7@<X8>)
{
  int8x16_t v14 = vextq_s8(*(int8x16_t *)(a5 - 16), *(int8x16_t *)(a5 - 16), 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(a6, a4, (uint64_t)&v14);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a7);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Range<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v47 = a1;
  uint64_t v45 = a4;
  uint64_t v48 = swift_getTupleTypeMetadata2(0, a2, a2, "lower upper ", 0) - 1;
  uint64_t v6 = MEMORY[0x1F4188790](v48);
  uint64_t v44 = (char *)v40 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v43 = (char *)v40 - v8;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v41 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)v40 - v10;
  uint64_t v12 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)+ 8)+ 16);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)v12, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)v40 - v15;
  uint64_t v46 = *(void *)(a2 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)v40 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)v40 - v20;
  uint64_t v42 = *(void *)(a3 + 8);
  uint64_t v23 = type metadata accessor for ClosedRange(0, a2, v42, v22);
  v40[1] = v47 + *((int *)v23 + 9);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v12, (uint64_t)AssociatedTypeWitness, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, v13, AssociatedConformanceWitness);
  (*(void (**)(char *, const char *, uint64_t))(v12 + 24))(v16, AssociatedTypeWitness, v12);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 48))(v11, a2, a3);
  (*(void (**)(char *, const char *))(v41 + 8))(v11, AssociatedTypeWitness);
  uint64_t v26 = v46;
  uint64_t v25 = v47;
  uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t))(v46 + 16);
  v27(v19, v47, a2);
  (*((void (**)(uint64_t, Class *))*(v23 - 1) + 1))(v25, v23);
  uint64_t v28 = v48;
  uint64_t v29 = v43;
  uint64_t v30 = &v43[*((int *)v48 + 14)];
  uint64_t v31 = *(void (**)(char *, char *, uint64_t))(v26 + 32);
  v31(v43, v19, a2);
  v31(v30, v21, a2);
  uint64_t v32 = v44;
  uint64_t v33 = &v44[*((int *)v28 + 14)];
  v27(v44, (uint64_t)v29, a2);
  v27(v33, (uint64_t)v30, a2);
  uint64_t v34 = v45;
  v31(v45, v32, a2);
  uint64_t v35 = *(void (**)(char *, uint64_t))(v46 + 8);
  v35(v33, a2);
  unint64_t v36 = &v32[*((int *)v48 + 14)];
  v31(v32, v29, a2);
  v31(v36, v30, a2);
  uint64_t v38 = type metadata accessor for Range(0, a2, v42, v37);
  v31(&v34[*((int *)v38 + 9)], v36, a2);
  return ((uint64_t (*)(char *, uint64_t))v35)(v32, a2);
}

uint64_t Range.relative<A>(to:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a2, v2, a1);
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance Range<A>@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return Range.relative<A>(to:)(a1, a2);
}

uint64_t ClosedRange.clamped(to:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v5 = a2;
  uint64_t v53 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v52 = (char *)&v47 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v51 = (char *)&v47 - v11;
  uint64_t v12 = *(void *)(v7 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v50 = (char *)&v47 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v47 - v15;
  uint64_t v17 = *(void *)(v5 + 24);
  uint64_t v48 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v17 + 40);
  char v18 = v48(a1, v4, v7, v17);
  uint64_t v54 = v16;
  uint64_t v55 = v5;
  if (v18)
  {
    uint64_t v19 = v12;
    uint64_t v20 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    v20(v16, a1, v7);
    uint64_t v21 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v17 + 16);
  }
  else
  {
    uint64_t v22 = *(int *)(v5 + 36);
    uint64_t v49 = a1;
    uint64_t v23 = &a1[v22];
    uint64_t v21 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v17 + 16);
    char v24 = v21(&a1[v22], v4, v7, v17);
    uint64_t v19 = v12;
    uint64_t v20 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    if (v24)
    {
      uint64_t v25 = v54;
      uint64_t v26 = v23;
    }
    else
    {
      uint64_t v25 = v54;
      uint64_t v26 = v4;
    }
    v20(v25, v26, v7);
    uint64_t v5 = v55;
    a1 = v49;
  }
  uint64_t v27 = *(int *)(v5 + 36);
  uint64_t v28 = &a1[v27];
  uint64_t v29 = &v4[v27];
  char v30 = v21(&a1[v27], v29, v7, v17);
  uint64_t v49 = (char *)v20;
  if (v30)
  {
    uint64_t v31 = v50;
    v20(v50, v28, v7);
  }
  else
  {
    char v32 = v48(a1, v29, v7, v17);
    uint64_t v31 = v50;
    if (v32)
    {
      uint64_t v33 = v50;
      uint64_t v34 = a1;
    }
    else
    {
      uint64_t v33 = v50;
      uint64_t v34 = v29;
    }
    v20(v33, v34, v7);
  }
  uint64_t v35 = TupleTypeMetadata2;
  unint64_t v36 = v51;
  uint64_t v37 = &v51[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v38 = v19;
  uint64_t v39 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  v39(v51, v54, v7);
  uint64_t v50 = v37;
  v39(v37, v31, v7);
  unint64_t v40 = v52;
  uint64_t v41 = &v52[*((int *)v35 + 12)];
  uint64_t v42 = v49;
  ((void (*)(char *, char *, uint64_t))v49)(v52, v36, v7);
  ((void (*)(char *, char *, uint64_t))v42)(v41, v37, v7);
  uint64_t v43 = v53;
  v39(v53, v40, v7);
  uint64_t v44 = *(void (**)(char *, uint64_t))(v38 + 8);
  v44(v41, v7);
  uint64_t v45 = &v40[*((int *)TupleTypeMetadata2 + 12)];
  v39(v40, v36, v7);
  v39(v45, v50, v7);
  v39(&v43[*(int *)(v55 + 36)], v45, v7);
  return ((uint64_t (*)(char *, uint64_t))v44)(v40, v7);
}

unint64_t Range.description.getter(uint64_t a1)
{
  uint64_t v2 = v1;
  unint64_t v14 = specialized static String._createEmpty(withInitialCapacity:)(7);
  unint64_t v15 = v4;
  uint64_t v5 = *(Class **)(a1 + 16);
  _print_unlocked<A, B>(_:_:)(v1, (uint64_t)&v14, v5, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  uint64_t v6 = v15;
  unint64_t v7 = HIBYTE(v15) & 0xF;
  if ((v15 & 0x2000000000000000) == 0) {
    unint64_t v7 = v14 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (v14 & ~v15 & 0x2000000000000000) != 0)
  {
    if ((v15 & 0x2000000000000000) == 0
      || (unint64_t v8 = specialized _SmallString.init(_:appending:)(v14, v15, 0x3C2E2EuLL, 0xE300000000000000), (v10 & 1) != 0))
    {
      _StringGuts.append(_:)(3943982, 0xE300000000000000, 0, 3);
    }
    else
    {
      unint64_t v11 = v8;
      unint64_t v12 = v9;
      swift_bridgeObjectRelease(v6);
      unint64_t v14 = v11;
      unint64_t v15 = v12;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v15);
    unint64_t v14 = 3943982;
    unint64_t v15 = 0xE300000000000000;
  }
  _print_unlocked<A, B>(_:_:)(v2 + *(int *)(a1 + 36), (uint64_t)&v14, v5, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  return v14;
}

unint64_t Range.debugDescription.getter(uint64_t a1)
{
  uint64_t v3 = v1;
  uint64_t v232 = a1;
  int64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (uint64_t)&v224 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = specialized static String._createEmpty(withInitialCapacity:)(8);
  unint64_t v10 = v8;
  unint64_t v11 = v9;
  unint64_t v235 = v8;
  unint64_t v236 = v9;
  unint64_t v12 = HIBYTE(v9) & 0xF;
  if ((v9 & 0x2000000000000000) != 0) {
    uint64_t v13 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v13 = v8 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v233 = v3;
  if (!v13 && (v8 & ~v9 & 0x2000000000000000) == 0)
  {
    unint64_t v10 = 0x2865676E6152;
    swift_bridgeObjectRelease(v9);
    unint64_t v41 = 0xE600000000000000;
    goto LABEL_40;
  }
  if ((v9 & 0x2000000000000000) == 0 || v12 > 9)
  {
    swift_bridgeObjectRetain_n(0xE600000000000000, 6);
    if ((v11 & 0x1000000000000000) != 0) {
      goto LABEL_159;
    }
    BOOL v19 = __OFADD__(v13, 6);
    int64_t v20 = v13 + 6;
    if (!v19) {
      goto LABEL_13;
    }
LABEL_161:
    __break(1u);
    goto LABEL_162;
  }
  uint64_t v14 = 8 * HIBYTE(v9);
  uint64_t v15 = (-255 << (v14 & 0x38)) - 1;
  uint64_t v16 = 82 << (v14 & 0x38);
  char v17 = v12 + 1;
  if (v12 >= 8)
  {
    unint64_t v18 = v16 | v15 & v9;
    goto LABEL_31;
  }
  unint64_t v10 = v16 | v15 & v8;
  if (v12 == 7)
  {
    char v17 = 8;
    unint64_t v18 = v9;
LABEL_31:
    uint64_t v44 = (97 << (8 * (v17 & 7u))) | ((-255 << (8 * (v17 & 7u))) - 1) & v18;
    char v45 = v12 + 2;
LABEL_32:
    uint64_t v46 = (110 << (8 * (v45 & 7u))) | ((-255 << (8 * (v45 & 7u))) - 1) & v44;
    char v47 = v12 + 3;
LABEL_33:
    uint64_t v48 = (103 << (8 * (v47 & 7u))) | ((-255 << (8 * (v47 & 7u))) - 1) & v46;
    char v49 = v12 + 4;
LABEL_34:
    uint64_t v50 = (101 << (8 * (v49 & 7u))) | ((-255 << (8 * (v49 & 7u))) - 1) & v48;
    char v51 = v12 + 5;
    goto LABEL_35;
  }
  unint64_t v10 = (97 << (8 * (v17 & 7u))) | ((-255 << (8 * (v17 & 7u))) - 1) & v10;
  if (v12 >= 6)
  {
    char v45 = 8;
    uint64_t v44 = v9;
    goto LABEL_32;
  }
  unint64_t v10 = (110 << ((v14 + 16) & 0x38)) | ((-255 << ((v14 + 16) & 0x38)) - 1) & v10;
  if (v12 == 5)
  {
    char v47 = 8;
    uint64_t v46 = v9;
    goto LABEL_33;
  }
  unint64_t v10 = (103 << ((v14 + 24) & 0x38)) | ((-255 << ((v14 + 24) & 0x38)) - 1) & v10;
  if (v12 >= 4)
  {
    char v49 = 8;
    uint64_t v48 = v9;
    goto LABEL_34;
  }
  unint64_t v10 = (101 << ((v14 + 32) & 0x38)) | ((-255 << ((v14 + 32) & 0x38)) - 1) & v10;
  if (v12 != 3)
  {
    unint64_t v10 = (40 << ((v14 + 40) & 0x38)) | ((-255 << ((v14 + 40) & 0x38)) - 1) & v10;
    uint64_t v52 = v9;
    goto LABEL_36;
  }
  char v51 = 8;
  uint64_t v50 = v9;
LABEL_35:
  uint64_t v52 = (40 << (8 * (v51 & 7u))) | ((-255 << (8 * (v51 & 7u))) - 1) & v50;
LABEL_36:
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(0xE600000000000000);
  unint64_t v53 = 0xA000000000000000;
  if (!(v10 & 0x8080808080808080 | v52 & 0x80808080808080)) {
    unint64_t v53 = 0xE000000000000000;
  }
  unint64_t v41 = (v53 & 0xFF00000000000000 | (v12 << 56) | v52 & 0xFFFFFFFFFFFFFFLL) + 0x600000000000000;
LABEL_40:
  unint64_t v235 = v10;
  unint64_t v236 = v41;
  while (1)
  {
    int8x16_t v229 = *(void (**)(uint64_t, uint64_t, int64_t))(v5 + 16);
    uint64_t v230 = v5 + 16;
    v229(v7, v3, v4);
    *(void *)&long long v234 = 0;
    *((void *)&v234 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0xE000000000000000;
    _debugPrint_unlocked<A, B>(_:_:)(v7, (uint64_t)&v234, (Class *)v4, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
    uint64_t v55 = *(void (**)(uint64_t, int64_t))(v5 + 8);
    uint64_t v54 = v5 + 8;
    uint64_t v231 = v7;
    uint64x2_t v228 = v55;
    v55(v7, v4);
    unint64_t v11 = *((void *)&v234 + 1);
    uint64_t v7 = v234;
    uint64_t v56 = HIBYTE(v41) & 0xF;
    uint64_t v2 = v10 & 0xFFFFFFFFFFFFLL;
    if ((v41 & 0x2000000000000000) != 0) {
      uint64_t v57 = HIBYTE(v41) & 0xF;
    }
    else {
      uint64_t v57 = v10 & 0xFFFFFFFFFFFFLL;
    }
    if (!v57 && (v10 & ~v41 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v41);
      unint64_t v235 = v7;
      unint64_t v236 = v11;
      goto LABEL_128;
    }
    uint64_t v227 = v54;
    uint64_t v3 = *((void *)&v234 + 1) & 0x2000000000000000;
    uint64_t v5 = HIBYTE(*((void *)&v234 + 1)) & 0xFLL;
    if ((v41 & 0x2000000000000000) != 0)
    {
      if (v3) {
        break;
      }
    }
LABEL_50:
    int64_t v226 = v4;
    uint64_t v224 = v234 & 0xFFFFFFFFFFFFLL;
    if (v3) {
      int64_t v4 = HIBYTE(*((void *)&v234 + 1)) & 0xFLL;
    }
    else {
      int64_t v4 = v234 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(*((uint64_t *)&v234 + 1), 2);
    uint64_t v225 = v4;
    if ((v11 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v11, 5);
      v138._Swift::UInt64 rawBits = 1;
      v139._Swift::UInt64 rawBits = (v4 << 16) | 1;
      v140._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v138, v139, v7, v11);
      if (v140._rawBits < 0x10000) {
        v140._rawBits |= 3;
      }
      int64_t v4 = specialized Collection.count.getter(v140, v141, v7, v11);
      swift_bridgeObjectRelease(v11);
      if ((v41 & 0x1000000000000000) != 0)
      {
LABEL_156:
        Swift::Int v142 = String.UTF8View._foreignCount()();
        Swift::Int v59 = v142 + v4;
        if (!__OFADD__(v142, v4))
        {
LABEL_56:
          unint64_t v60 = v10 & ~v41;
          if ((v60 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v61 = _StringGuts.nativeUnusedCapacity.getter(v10, v41);
            if ((v62 & 1) == 0)
            {
              if (v59 > 15) {
                goto LABEL_62;
              }
              if ((v41 & 0x2000000000000000) != 0)
              {
                swift_bridgeObjectRelease_n(v11, 5);
                unint64_t v67 = v41;
                int64_t v4 = v226;
              }
              else
              {
                if (v61 >= v4) {
                  goto LABEL_62;
                }
LABEL_73:
                swift_bridgeObjectRelease_n(v11, 5);
                if ((v41 & 0x2000000000000000) != 0)
                {
                  unint64_t v67 = v41;
                  int64_t v4 = v226;
                }
                else
                {
                  int64_t v4 = v226;
                  if ((v41 & 0x1000000000000000) != 0)
                  {
                    unint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, v41);
                    unint64_t v67 = v222;
                  }
                  else
                  {
                    if ((v10 & 0x1000000000000000) != 0)
                    {
                      uint64x2_t v216 = (unsigned __int8 *)((v41 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    }
                    else
                    {
                      uint64x2_t v216 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v41);
                      uint64_t v2 = v223;
                    }
                    swift_bridgeObjectRetain(v41);
                    closure #1 in _StringGuts._convertedToSmall()(v216, v2, &v234);
                    swift_bridgeObjectRelease(v41);
                    unint64_t v67 = *((void *)&v234 + 1);
                    unint64_t v10 = v234;
                  }
                }
              }
              v68._Swift::UInt64 rawBits = (v225 << 16) | 1;
              v69._Swift::UInt64 rawBits = 1;
              v70._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v69, v68, v7, v11);
              if (v70._rawBits < 0x10000) {
                v70._rawBits |= 3;
              }
              uint64_t v72 = specialized String.init(_:)(v70, v71, v7, v11);
              uint64_t v74 = v73;
              swift_bridgeObjectRelease(v11);
              if ((v74 & 0x2000000000000000) == 0) {
                goto LABEL_241;
              }
              swift_bridgeObjectRelease(v74);
              goto LABEL_79;
            }
LABEL_255:
            unint64_t v219 = 258;
LABEL_256:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v219, 0);
          }
          if (v59 <= 15) {
            goto LABEL_73;
          }
LABEL_62:
          int64_t v63 = _StringGuts.nativeUnusedCapacity.getter(v10, v41);
          BOOL v66 = (v64 & 1) == 0 && v63 >= v4;
          if ((v60 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v4 = v226;
            if (v66)
            {
LABEL_100:
              swift_bridgeObjectRelease_n(v11, 4);
              if ((v11 & 0x1000000000000000) != 0)
              {
                swift_bridgeObjectRelease(v11);
                _StringGuts._foreignAppendInPlace(_:)(v7, v11, 0, v225);
                swift_bridgeObjectRelease_n(v11, 2);
                goto LABEL_104;
              }
              if (v3)
              {
                swift_bridgeObjectRelease_n(v11, 2);
                *(void *)&long long v234 = v7;
                *((void *)&v234 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v11 & 0xFFFFFFFFFFFFFFLL;
                uint32x4_t v94 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v11) & 0xF, (uint64_t)&v234, HIBYTE(v11) & 0xF);
                _StringGuts.appendInPlace(_:isASCII:)(v94, v95, (v11 & 0x4000000000000000) != 0);
                swift_bridgeObjectRelease(v11);
LABEL_104:
                uint64_t v3 = v233;
                goto LABEL_128;
              }
              if ((v7 & 0x1000000000000000) != 0)
              {
                swift_bridgeObjectRelease(v11);
                id v108 = (id)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v109 = v224;
                uint64_t v110 = v224;
                uint64_t v3 = v233;
                goto LABEL_121;
              }
LABEL_250:
              id v108 = _StringObject.sharedUTF8.getter(v7, v11);
              uint64_t v110 = v217;
              swift_bridgeObjectRelease(v11);
              if (v110 < v224) {
                goto LABEL_253;
              }
              int64_t v4 = v226;
              uint64_t v3 = v233;
              uint64_t v109 = v224;
LABEL_121:
              uint64_t v111 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v109, (uint64_t)v108, v110);
              _StringGuts.appendInPlace(_:isASCII:)(v111, v112, v7 < 0);
              swift_bridgeObjectRelease_n(v11, 2);
              goto LABEL_128;
            }
LABEL_93:
            uint64_t v90 = _StringGuts.nativeCapacity.getter(v10, v41);
            if (v91) {
              uint64_t v92 = 0;
            }
            else {
              uint64_t v92 = v90;
            }
            if (v92 + 0x4000000000000000 < 0)
            {
              __break(1u);
              goto LABEL_250;
            }
            uint64_t v93 = 2 * v92;
            if (v93 > v59) {
              Swift::Int v59 = v93;
            }
          }
          else
          {
            int64_t v4 = v226;
            if (!v66) {
              goto LABEL_93;
            }
          }
          _StringGuts.grow(_:)(v59);
          goto LABEL_100;
        }
        goto LABEL_158;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v11, 4);
      if ((v41 & 0x1000000000000000) != 0) {
        goto LABEL_156;
      }
    }
    BOOL v19 = __OFADD__(v57, v4);
    Swift::Int v59 = v57 + v4;
    if (!v19) {
      goto LABEL_56;
    }
LABEL_158:
    __break(1u);
LABEL_159:
    Swift::Int v143 = String.UTF8View._foreignCount()();
    int64_t v20 = v143 + 6;
    if (__OFADD__(v143, 6)) {
      goto LABEL_161;
    }
LABEL_13:
    if ((v10 & ~v11 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
      if (v22) {
        goto LABEL_255;
      }
      BOOL v24 = (v11 & 0x2000000000000000) == 0 && v21 > 5;
      if (v20 > 15 || v24) {
        goto LABEL_29;
      }
LABEL_24:
      swift_bridgeObjectRelease_n(0xE600000000000000, 5);
      swift_bridgeObjectRetain(v11);
      unint64_t v25 = _StringGuts._convertedToSmall()(v10, v11);
      unint64_t v27 = v26;
      swift_bridgeObjectRelease(v11);
      v28._Swift::UInt64 rawBits = 1;
      v29._Swift::UInt64 rawBits = 393217;
      v30._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v28, v29, 0x2865676E6152uLL, 0xE600000000000000);
      if (v30._rawBits < 0x10000) {
        v30._rawBits |= 3;
      }
      unint64_t v32 = specialized String.init(_:)(v30, v31, 0x2865676E6152uLL, 0xE600000000000000);
      unint64_t v34 = v33;
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v35 = _StringGuts._convertedToSmall()(v32, v34);
      unint64_t v37 = v36;
      swift_bridgeObjectRelease(v34);
      unint64_t v38 = specialized _SmallString.init(_:appending:)(v25, v27, v35, v37);
      if (v40) {
        goto LABEL_254;
      }
      unint64_t v10 = v38;
      unint64_t v41 = v39;
      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v235 = v10;
      unint64_t v236 = v41;
      uint64_t v3 = v233;
    }
    else
    {
      if (v20 <= 15) {
        goto LABEL_24;
      }
LABEL_29:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v20, 6);
      swift_bridgeObjectRelease_n(0xE600000000000000, 6);
      long long v234 = xmmword_18162ADD0;
      uint64_t v42 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 6, (uint64_t)&v234, 6);
      _StringGuts.appendInPlace(_:isASCII:)(v42, v43, 1);
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v10 = v235;
      unint64_t v41 = v236;
    }
  }
  uint64_t v58 = v56 + v5;
  if ((unint64_t)(v56 + v5) > 0xF)
  {
    uint64_t v3 = 1;
    goto LABEL_50;
  }
  uint64_t v3 = v233;
  if (v5)
  {
    char v96 = 0;
    unint64_t v97 = 0;
    unint64_t v98 = v41;
    do
    {
      unint64_t v99 = v56 + v97;
      unint64_t v100 = v97 + 1;
      if (v97 >= 8) {
        unint64_t v101 = *((void *)&v234 + 1);
      }
      else {
        unint64_t v101 = v234;
      }
      unint64_t v102 = v101 >> (v96 & 0x38);
      char v103 = (8 * v56 + v96) & 0x38;
      uint64_t v104 = (-255 << v103) - 1;
      unint64_t v105 = (unint64_t)v102 << v103;
      unint64_t v106 = v105 | v104 & v98;
      unint64_t v107 = v105 | v104 & v10;
      if (v99 < 8) {
        unint64_t v10 = v107;
      }
      else {
        unint64_t v98 = v106;
      }
      v96 += 8;
      unint64_t v97 = v100;
    }
    while (v5 != v100);
  }
  else
  {
    unint64_t v98 = v41;
  }
  swift_bridgeObjectRelease(v41);
  swift_bridgeObjectRelease(v11);
  unint64_t v113 = 0xA000000000000000;
  if (!(v10 & 0x8080808080808080 | v98 & 0x80808080808080)) {
    unint64_t v113 = 0xE000000000000000;
  }
  unint64_t v235 = v10;
  unint64_t v236 = v113 & 0xFF00000000000000 | (v58 << 56) | v98 & 0xFFFFFFFFFFFFFFLL;
  while (1)
  {
LABEL_128:
    uint64_t v2 = v235;
    unint64_t v10 = v236;
    unint64_t v114 = HIBYTE(v236) & 0xF;
    int64_t v115 = v235 & 0xFFFFFFFFFFFFLL;
    if ((v236 & 0x2000000000000000) != 0) {
      unint64_t v116 = HIBYTE(v236) & 0xF;
    }
    else {
      unint64_t v116 = v235 & 0xFFFFFFFFFFFFLL;
    }
    if (!v116 && (v235 & ~v236 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v236);
      uint64_t v2 = 0;
      unint64_t v235 = 0;
      unint64_t v136 = 0xE000000000000000;
      goto LABEL_165;
    }
    if ((v236 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v236);
      swift_bridgeObjectRelease(0xE000000000000000);
      unint64_t v137 = 0xA000000000000000;
      if (!(v10 & 0x80808080808080 | v2 & 0x8080808080808080)) {
        unint64_t v137 = 0xE000000000000000;
      }
      unint64_t v136 = v137 & 0xFF00000000000000 | (v114 << 56) | v10 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v235 = v2;
      goto LABEL_165;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6);
    if ((v10 & 0x1000000000000000) != 0)
    {
LABEL_162:
      int64_t v115 = String.UTF8View._foreignCount()();
      if ((v2 & ~v10 & 0x2000000000000000) == 0) {
        goto LABEL_163;
      }
    }
    else if ((v2 & ~v10 & 0x2000000000000000) == 0)
    {
      goto LABEL_163;
    }
    if (swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v117 = _StringGuts.nativeUnusedCapacity.getter(v2, v10);
      if (v118) {
        goto LABEL_255;
      }
      if (v115 > 15 || (v117 & 0x8000000000000000) == 0)
      {
LABEL_164:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v115, 0);
        swift_bridgeObjectRelease_n(0xE000000000000000, 6);
        long long v234 = 0uLL;
        uint64x2_t v144 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v234, 0);
        _StringGuts.appendInPlace(_:isASCII:)(v144, v145, 1);
        swift_bridgeObjectRelease(0xE000000000000000);
        uint64_t v2 = v235;
        unint64_t v136 = v236;
        goto LABEL_165;
      }
      goto LABEL_140;
    }
LABEL_163:
    if (v115 > 15) {
      goto LABEL_164;
    }
LABEL_140:
    uint64_t v119 = v3;
    swift_bridgeObjectRelease_n(0xE000000000000000, 5);
    swift_bridgeObjectRetain(v10);
    unint64_t v120 = _StringGuts._convertedToSmall()(v2, v10);
    unint64_t v122 = v121;
    swift_bridgeObjectRelease(v10);
    v123._Swift::UInt64 rawBits = 1;
    v124._Swift::UInt64 rawBits = 1;
    v125._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v123, v124, 0, 0xE000000000000000);
    if (v125._rawBits < 0x10000) {
      v125._rawBits |= 3;
    }
    unint64_t v127 = specialized String.init(_:)(v125, v126, 0, 0xE000000000000000);
    unint64_t v129 = v128;
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v130 = _StringGuts._convertedToSmall()(v127, v129);
    unint64_t v132 = v131;
    swift_bridgeObjectRelease(v129);
    unint64_t v133 = specialized _SmallString.init(_:appending:)(v120, v122, v130, v132);
    if (v135) {
      goto LABEL_254;
    }
    uint64_t v2 = v133;
    unint64_t v136 = v134;
    swift_bridgeObjectRelease(v10);
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v235 = v2;
    uint64_t v3 = v119;
LABEL_165:
    unint64_t v146 = specialized static String._createEmpty(withInitialCapacity:)(6);
    uint64_t v148 = v147;
    unint64_t v235 = v146;
    unint64_t v236 = v147;
    uint64_t v149 = HIBYTE(v147) & 0xF;
    if ((v147 & 0x2000000000000000) == 0) {
      uint64_t v149 = v146 & 0xFFFFFFFFFFFFLL;
    }
    if (v149 || (v146 & ~v147 & 0x2000000000000000) != 0)
    {
      if ((v147 & 0x2000000000000000) == 0
        || (unint64_t v150 = specialized _SmallString.init(_:appending:)(v146, v147, 0x3C2E2EuLL, 0xE300000000000000),
            (v152 & 1) != 0))
      {
        swift_bridgeObjectRetain(0xE300000000000000);
        _StringGuts.append(_:)(3943982, 0xE300000000000000, 0, 3);
        swift_bridgeObjectRelease_n(0xE300000000000000, 2);
        uint64_t v72 = v235;
        unint64_t v10 = v236;
        goto LABEL_175;
      }
      uint64_t v72 = v150;
      unint64_t v10 = v151;
      swift_bridgeObjectRelease(v148);
      swift_bridgeObjectRelease(0xE300000000000000);
    }
    else
    {
      uint64_t v72 = 3943982;
      swift_bridgeObjectRelease(v147);
      unint64_t v10 = 0xE300000000000000;
    }
    unint64_t v235 = v72;
    unint64_t v236 = v10;
LABEL_175:
    uint64_t v153 = v231;
    v229(v231, v3 + *(int *)(v232 + 36), v4);
    *(void *)&long long v234 = 0;
    *((void *)&v234 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0xE000000000000000;
    _debugPrint_unlocked<A, B>(_:_:)(v153, (uint64_t)&v234, (Class *)v4, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
    v228(v153, v4);
    unint64_t v154 = *((void *)&v234 + 1);
    uint64_t v155 = v234;
    uint64_t v156 = HIBYTE(v10) & 0xF;
    if ((v10 & 0x2000000000000000) != 0) {
      uint64_t v157 = HIBYTE(v10) & 0xF;
    }
    else {
      uint64_t v157 = v72 & 0xFFFFFFFFFFFFLL;
    }
    if (!v157 && (v72 & ~v10 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v10);
      unint64_t v235 = v155;
      unint64_t v236 = v154;
      goto LABEL_225;
    }
    unint64_t v233 = v136;
    unint64_t v11 = *((void *)&v234 + 1) & 0x2000000000000000;
    unint64_t v67 = HIBYTE(*((void *)&v234 + 1)) & 0xFLL;
    uint64_t v227 = v2;
    if ((v10 & 0x2000000000000000) != 0 && v11)
    {
      unint64_t v158 = v156 + v67;
      if (v156 + v67 <= 0xF)
      {
        if (v67)
        {
          char v183 = 0;
          unint64_t v184 = 0;
          unint64_t v185 = v10;
          do
          {
            unint64_t v186 = v156 + v184;
            unint64_t v187 = v184 + 1;
            if (v184 >= 8) {
              unint64_t v188 = *((void *)&v234 + 1);
            }
            else {
              unint64_t v188 = v234;
            }
            unint64_t v189 = v188 >> (v183 & 0x38);
            char v190 = (8 * v156 + v183) & 0x38;
            uint64_t v191 = (-255 << v190) - 1;
            unint64_t v192 = (unint64_t)v189 << v190;
            unint64_t v193 = v192 | v191 & v185;
            unint64_t v194 = v192 | v191 & v72;
            if (v186 < 8) {
              uint64_t v72 = v194;
            }
            else {
              unint64_t v185 = v193;
            }
            v183 += 8;
            unint64_t v184 = v187;
          }
          while (v67 != v187);
        }
        else
        {
          unint64_t v185 = v10;
        }
        swift_bridgeObjectRelease(v10);
        swift_bridgeObjectRelease(v154);
        unint64_t v199 = 0xA000000000000000;
        if (!(v72 & 0x8080808080808080 | v185 & 0x80808080808080)) {
          unint64_t v199 = 0xE000000000000000;
        }
        unint64_t v235 = v72;
        unint64_t v236 = v199 & 0xFF00000000000000 | (v158 << 56) | v185 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_224;
      }
      unint64_t v11 = 1;
    }
    uint64_t v74 = v234 & 0xFFFFFFFFFFFFLL;
    unint64_t v41 = v11 ? HIBYTE(*((void *)&v234 + 1)) & 0xFLL : v234 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(*((uint64_t *)&v234 + 1), 2);
    if ((v154 & 0x1000000000000000) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v154, 4);
    int64_t v4 = v41;
    if ((v10 & 0x1000000000000000) != 0) {
      goto LABEL_238;
    }
LABEL_189:
    BOOL v19 = __OFADD__(v157, v4);
    int64_t v159 = v157 + v4;
    if (!v19) {
      goto LABEL_190;
    }
LABEL_240:
    __break(1u);
LABEL_241:
    if ((v74 & 0x1000000000000000) != 0)
    {
      uint64_t v72 = _StringGuts._foreignConvertedToSmall()(v72, v74);
      uint64_t v221 = v220;
      swift_bridgeObjectRelease(v74);
      uint64_t v74 = v221;
    }
    else
    {
      if ((v72 & 0x1000000000000000) != 0)
      {
        uint64x2_t v214 = (unsigned __int8 *)((v74 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v215 = v72 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        uint64x2_t v214 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v72, v74);
      }
      closure #1 in _StringGuts._convertedToSmall()(v214, v215, &v234);
      swift_bridgeObjectRelease(v74);
      uint64_t v74 = *((void *)&v234 + 1);
      uint64_t v72 = v234;
    }
LABEL_79:
    uint64_t v75 = HIBYTE(v67) & 0xF;
    uint64_t v76 = HIBYTE(v74) & 0xF;
    uint64_t v77 = v76 + v75;
    if ((unint64_t)(v76 + v75) > 0xF) {
      goto LABEL_254;
    }
    if (v76)
    {
      char v78 = 0;
      unint64_t v79 = 0;
      do
      {
        unint64_t v80 = v75 + v79;
        unint64_t v81 = v79 + 1;
        if (v79 >= 8) {
          unint64_t v82 = v74;
        }
        else {
          unint64_t v82 = v72;
        }
        unint64_t v83 = v82 >> (v78 & 0x38);
        char v84 = (8 * v75 + v78) & 0x38;
        uint64_t v85 = (-255 << v84) - 1;
        unint64_t v86 = (unint64_t)v83 << v84;
        unint64_t v87 = v86 | v85 & v67;
        unint64_t v88 = v86 | v85 & v10;
        if (v80 < 8) {
          unint64_t v10 = v88;
        }
        else {
          unint64_t v67 = v87;
        }
        v78 += 8;
        unint64_t v79 = v81;
      }
      while (v76 != v81);
    }
    swift_bridgeObjectRelease(v41);
    swift_bridgeObjectRelease(v11);
    unint64_t v89 = 0xA000000000000000;
    if (!(v10 & 0x8080808080808080 | v67 & 0x80808080808080)) {
      unint64_t v89 = 0xE000000000000000;
    }
    unint64_t v235 = v10;
    unint64_t v236 = v89 & 0xFF00000000000000 | (v77 << 56) | v67 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v3 = v233;
  }
  swift_bridgeObjectRetain_n(v154, 5);
  v209._Swift::UInt64 rawBits = 1;
  v210._Swift::UInt64 rawBits = (v41 << 16) | 1;
  v211._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v209, v210, v155, v154);
  if (v211._rawBits < 0x10000) {
    v211._rawBits |= 3;
  }
  int64_t v4 = specialized Collection.count.getter(v211, v212, v155, v154);
  swift_bridgeObjectRelease(v154);
  if ((v10 & 0x1000000000000000) == 0) {
    goto LABEL_189;
  }
LABEL_238:
  Swift::Int v213 = String.UTF8View._foreignCount()();
  int64_t v159 = v213 + v4;
  if (__OFADD__(v213, v4)) {
    goto LABEL_240;
  }
LABEL_190:
  if ((v72 & ~v10 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v159 > 15) {
      goto LABEL_202;
    }
LABEL_197:
    swift_bridgeObjectRelease_n(v154, 5);
    swift_bridgeObjectRetain(v10);
    unint64_t v163 = _StringGuts._convertedToSmall()(v72, v10);
    unint64_t v165 = v164;
    swift_bridgeObjectRelease(v10);
    v166._Swift::UInt64 rawBits = (v41 << 16) | 1;
    v167._Swift::UInt64 rawBits = 1;
    v168._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v167, v166, v155, v154);
    if (v168._rawBits < 0x10000) {
      v168._rawBits |= 3;
    }
    unint64_t v170 = specialized String.init(_:)(v168, v169, v155, v154);
    unint64_t v172 = v171;
    swift_bridgeObjectRelease(v154);
    unint64_t v173 = _StringGuts._convertedToSmall()(v170, v172);
    unint64_t v175 = v174;
    swift_bridgeObjectRelease(v172);
    unint64_t v176 = specialized _SmallString.init(_:appending:)(v163, v165, v173, v175);
    unint64_t v136 = v233;
    if ((v178 & 1) == 0)
    {
      unint64_t v179 = v176;
      unint64_t v180 = v177;
      swift_bridgeObjectRelease(v10);
      swift_bridgeObjectRelease(v154);
      unint64_t v235 = v179;
      unint64_t v236 = v180;
      uint64_t v2 = v227;
      goto LABEL_225;
    }
LABEL_254:
    unint64_t v219 = 266;
    goto LABEL_256;
  }
  int64_t v160 = _StringGuts.nativeUnusedCapacity.getter(v72, v10);
  if (v161) {
    goto LABEL_255;
  }
  uint64_t v162 = (v10 >> 61) & 1;
  if (v160 < v4) {
    LODWORD(v162) = 1;
  }
  if (v159 <= 15 && v162) {
    goto LABEL_197;
  }
LABEL_202:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v159, v4);
  swift_bridgeObjectRelease_n(v154, 4);
  if ((v154 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v154);
    _StringGuts._foreignAppendInPlace(_:)(v155, v154, 0, v41);
    swift_bridgeObjectRelease_n(v154, 2);
LABEL_224:
    uint64_t v2 = v227;
    unint64_t v136 = v233;
    goto LABEL_225;
  }
  if (v11)
  {
    swift_bridgeObjectRelease_n(v154, 2);
    *(void *)&long long v234 = v155;
    *((void *)&v234 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v154 & 0xFFFFFFFFFFFFFFLL;
    unsigned int v181 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v154) & 0xF, (uint64_t)&v234, HIBYTE(v154) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v181, v182, (v154 & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease(v154);
    goto LABEL_224;
  }
  if ((v155 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v154);
    id v195 = (id)((v154 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v196 = v155 & 0xFFFFFFFFFFFFLL;
    goto LABEL_219;
  }
  id v195 = _StringObject.sharedUTF8.getter(v155, v154);
  uint64_t v196 = v218;
  swift_bridgeObjectRelease(v154);
  if (v196 < v74) {
LABEL_253:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
LABEL_219:
  unint64_t v136 = v233;
  unint64_t v197 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v155 & 0xFFFFFFFFFFFFLL, (uint64_t)v195, v196);
  _StringGuts.appendInPlace(_:isASCII:)(v197, v198, v155 < 0);
  swift_bridgeObjectRelease_n(v154, 2);
  uint64_t v2 = v227;
LABEL_225:
  uint64_t v200 = v236;
  unint64_t v201 = HIBYTE(v236) & 0xF;
  if ((v236 & 0x2000000000000000) == 0) {
    unint64_t v201 = v235 & 0xFFFFFFFFFFFFLL;
  }
  if (v201 || (v235 & ~v236 & 0x2000000000000000) != 0)
  {
    if ((v236 & 0x2000000000000000) == 0
      || (unint64_t v202 = specialized _SmallString.init(_:appending:)(v235, v236, 0x29uLL, 0xE100000000000000), (v204 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      unint64_t v205 = v235;
      unint64_t v206 = v236;
    }
    else
    {
      unint64_t v205 = v202;
      unint64_t v206 = v203;
      swift_bridgeObjectRelease(v200);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v236);
    unint64_t v206 = 0xE100000000000000;
    unint64_t v205 = 41;
  }
  unint64_t v207 = specialized static String.+ infix(_:_:)(v2, v136, v205, v206);
  swift_bridgeObjectRelease(v136);
  swift_bridgeObjectRelease(v206);
  return v207;
}

uint64_t ClosedRange.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  Swift::String::Index v31 = (unint64_t *)((char *)&v32[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v7);
  unint64_t v10 = (char *)&v32[-1] - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))((char *)&v32[-1] - v9, v3, a1);
  unint64_t v11 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  unint64_t v12 = swift_allocObject(v11, 0x80uLL, 7uLL);
  *((_OWORD *)v12 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_18162AD10;
  v12[4] = 0x756F427265776F6CLL;
  v12[5] = 0xEA0000000000646ELL;
  uint64_t v13 = *(void *)(a1 + 16);
  v12[9] = v13;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 6);
  uint64_t v15 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 16);
  v15(boxed_opaque_existential_0Tm, v3, v13);
  v12[10] = 0x756F427265707075;
  v12[11] = 0xEA0000000000646ELL;
  uint64_t v16 = v3 + *(int *)(a1 + 36);
  v12[15] = v13;
  char v17 = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 12);
  v15(v17, v16, v13);
  v32[0] = 0;
  v32[1] = 0;
  unint64_t v18 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v10, (uint64_t)v32, (swift *)a1);
  uint64_t v20 = v19;
  int64_t v21 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  char v22 = swift_allocObject(v21, 0x48uLL, 7uLL);
  v22[6] = v12;
  v22[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v22[8] = 0;
  uint64_t v23 = (unint64_t *)canonical specialized generic type metadata accessor for _IndexBox<Int>();
  BOOL v24 = swift_allocObject(v23, 0x18uLL, 7uLL);
  _OWORD v24[2] = 0;
  uint64_t v25 = v12[2];
  unint64_t v26 = swift_allocObject(v23, 0x18uLL, 7uLL);
  void v26[2] = v25;
  v22[2] = v24;
  v22[3] = &protocol witness table for _IndexBox<A>;
  v22[4] = v26;
  unint64_t v22[5] = &protocol witness table for _IndexBox<A>;
  unint64_t v27 = v31;
  (*(void (**)(unint64_t *, char *, uint64_t))(v6 + 32))(v31, v10, a1);
  Swift::String::Index v28 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v32, v27, (Class *)a1, v28, 6uLL);
  char v30 = result;
  if (result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v32);
  }
  *(void *)a2 = a1;
  *(void *)(a2 + 8) = v22;
  *(unsigned char *)(a2 + 16) = 8;
  *(void *)(a2 + 24) = v18;
  *(void *)(a2 + 32) = v20;
  *(unsigned char *)(a2 + 4_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = v30;
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Range<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static Range.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t ClosedRange<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a3 + 24);
  uint64_t v6 = *(void *)(a2 + 16);
  v5(a1, v6);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v5)(a1, v6, a3);
}

Swift::Int ClosedRange<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = *(void (**)(void *, uint64_t, uint64_t))(a2 + 24);
  uint64_t v4 = *(void *)(a1 + 16);
  v3(v6, v4, a2);
  v3(v6, v4, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))Range<>.hash(into:));
}

uint64_t Range<>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return ClosedRange<>.init(from:)(a1, a2, a3, a4, (uint64_t (*)(void, uint64_t, char *))type metadata accessor for Range, a5);
}

uint64_t ClosedRange<>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void, uint64_t, char *)@<X4>, uint64_t a6@<X8>)
{
  uint64_t v117 = a4;
  uint64_t v112 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a2, a2, "lower upper ", 0);
  uint64_t v10 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v111 = (char *)&v107 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  unint64_t v113 = a3;
  unint64_t v114 = (char *)&v107 - v12;
  uint64_t v13 = (Class *)a5(0, a2, a3);
  uint64_t v110 = (uint64_t)*(v13 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v107 - v15;
  uint64_t v116 = *(void *)(a2 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v107 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  int64_t v21 = (char *)&v107 - v20;
  uint64_t v22 = a1[3];
  uint64_t v23 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v22);
  BOOL v24 = v123;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v23 + 32))(v120, v22, v23);
  if (v24)
  {
LABEL_63:
    uint64_t v46 = a1;
    return __swift_destroy_boxed_opaque_existential_1Tm(v46);
  }
  unint64_t v107 = v16;
  id v108 = v13;
  uint64_t v109 = v19;
  Swift::String::Index v123 = a1;
  unint64_t v25 = v121;
  uint64_t v26 = v122;
  __swift_mutable_project_boxed_opaque_existential_1(v120, v121);
  uint64_t v27 = v117;
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t))(v26 + 176))(a2, a2, v117, v25, v26);
  uint64_t v28 = (uint64_t)v21;
  unint64_t v29 = v121;
  uint64_t v30 = v122;
  __swift_mutable_project_boxed_opaque_existential_1(v120, v121);
  uint64_t v31 = (uint64_t)v109;
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t))(v30 + 176))(a2, a2, v27, v29, v30);
  char v32 = (*((uint64_t (**)(char *, uint64_t, uint64_t))v113 + 3))(v21, v31, a2);
  uint64_t v33 = v116;
  if ((v32 & 1) == 0)
  {
    char v47 = (Class *)a2;
    swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
    uint64_t v49 = v48;
    uint64_t v50 = v123[3];
    uint64_t v51 = v123[4];
    __swift_project_boxed_opaque_existential_0Tm(v123, v50);
    uint64_t v117 = (*(uint64_t (**)(uint64_t, uint64_t))(v51 + 8))(v50, v51);
    unint64_t v52 = specialized static String._createEmpty(withInitialCapacity:)(72);
    uint64_t v54 = v53;
    unint64_t v118 = v52;
    unint64_t v119 = v53;
    uint64_t v55 = HIBYTE(v53) & 0xF;
    if ((v53 & 0x2000000000000000) == 0) {
      uint64_t v55 = v52 & 0xFFFFFFFFFFFFLL;
    }
    if (v55 || (v52 & ~v53 & 0x2000000000000000) != 0)
    {
      if ((v53 & 0x2000000000000000) != 0
        && (0x80000001816DD670 & 0x2000000000000000) != 0
        && (unint64_t v56 = specialized _SmallString.init(_:appending:)(v52, v53, 0xD000000000000012, 0x80000001816DD670 | 0x8000000000000000), (v58 & 1) == 0))
      {
        unint64_t v59 = v56;
        unint64_t v60 = v57;
        swift_bridgeObjectRelease(v54);
        swift_bridgeObjectRelease(0x80000001816DD670 | 0x8000000000000000);
        unint64_t v118 = v59;
        unint64_t v119 = v60;
      }
      else
      {
        if ((0x80000001816DD670 & 0x2000000000000000) != 0) {
          unint64_t v61 = (0x80000001816DD670 >> 56) & 0xF;
        }
        else {
          unint64_t v61 = 18;
        }
        _StringGuts.append(_:)(0xD000000000000012, 0x80000001816DD670 | 0x8000000000000000, 0, v61);
        swift_bridgeObjectRelease(0x80000001816DD670 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v53);
      unint64_t v118 = 0xD000000000000012;
      unint64_t v119 = 0x80000001816DD670 | 0x8000000000000000;
    }
    TypeName = (uint64_t *)swift_getTypeName(v108, 0);
    if (v63 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    char v64 = (uint8x16_t *)TypeName;
    int64_t v65 = v63;
    int64_t v66 = validateUTF8(_:)(TypeName, v63);
    if (v68) {
      unint64_t v69 = repairUTF8(_:firstKnownBrokenRange:)(v64->i8, v65, v66, v67);
    }
    else {
      unint64_t v69 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v64, v65, v66 & 1);
    }
    unint64_t v71 = v69;
    unint64_t v72 = v70;
    uint64_t v73 = v119;
    unint64_t v74 = HIBYTE(v119) & 0xF;
    if ((v119 & 0x2000000000000000) == 0) {
      unint64_t v74 = v118 & 0xFFFFFFFFFFFFLL;
    }
    if (!v74 && (v118 & ~v119 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v119);
      unint64_t v118 = v71;
      unint64_t v119 = v72;
      goto LABEL_30;
    }
    if ((v119 & 0x2000000000000000) != 0)
    {
      if ((v70 & 0x2000000000000000) != 0)
      {
        uint64_t v101 = v28;
        unint64_t v102 = specialized _SmallString.init(_:appending:)(v118, v119, v69, v70);
        if ((v104 & 1) == 0)
        {
          unint64_t v105 = v102;
          unint64_t v106 = v103;
          swift_bridgeObjectRelease(v73);
          swift_bridgeObjectRelease(v72);
          unint64_t v118 = v105;
          unint64_t v119 = v106;
          unint64_t v72 = v106;
          unint64_t v71 = v105;
          uint64_t v33 = v116;
          uint64_t v28 = v101;
          goto LABEL_30;
        }
        uint64_t v75 = HIBYTE(v72) & 0xF;
        uint64_t v33 = v116;
LABEL_29:
        _StringGuts.append(_:)(v71, v72, 0, v75);
        swift_bridgeObjectRelease(v72);
        unint64_t v71 = v118;
        unint64_t v72 = v119;
LABEL_30:
        uint64_t v76 = HIBYTE(v72) & 0xF;
        if ((v72 & 0x2000000000000000) == 0) {
          uint64_t v76 = v71 & 0xFFFFFFFFFFFFLL;
        }
        if (v76 || (v71 & ~v72 & 0x2000000000000000) != 0)
        {
          if ((v72 & 0x2000000000000000) != 0
            && (0x80000001816DDBA0 & 0x2000000000000000) != 0
            && (unint64_t v77 = specialized _SmallString.init(_:appending:)(v71, v72, 0xD000000000000014, 0x80000001816DDBA0 | 0x8000000000000000), (v79 & 1) == 0))
          {
            unint64_t v80 = v77;
            unint64_t v81 = v78;
            swift_bridgeObjectRelease(v72);
            swift_bridgeObjectRelease(0x80000001816DDBA0 | 0x8000000000000000);
            unint64_t v118 = v80;
            unint64_t v119 = v81;
          }
          else
          {
            if ((0x80000001816DDBA0 & 0x2000000000000000) != 0) {
              unint64_t v82 = (0x80000001816DDBA0 >> 56) & 0xF;
            }
            else {
              unint64_t v82 = 20;
            }
            _StringGuts.append(_:)(0xD000000000000014, 0x80000001816DDBA0 | 0x8000000000000000, 0, v82);
            swift_bridgeObjectRelease(0x80000001816DDBA0 | 0x8000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v72);
          unint64_t v118 = 0xD000000000000014;
          unint64_t v119 = 0x80000001816DDBA0 | 0x8000000000000000;
        }
        _print_unlocked<A, B>(_:_:)(v28, (uint64_t)&v118, v47, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
        unint64_t v83 = *(void (**)(uint64_t, Class *))(v33 + 8);
        v83(v28, v47);
        uint64_t v84 = v119;
        unint64_t v85 = HIBYTE(v119) & 0xF;
        if ((v119 & 0x2000000000000000) == 0) {
          unint64_t v85 = v118 & 0xFFFFFFFFFFFFLL;
        }
        if (v85 || (v118 & ~v119 & 0x2000000000000000) != 0)
        {
          if ((v119 & 0x2000000000000000) != 0
            && (0x80000001816DDBC0 & 0x2000000000000000) != 0
            && (unint64_t v86 = specialized _SmallString.init(_:appending:)(v118, v119, 0xD00000000000001BLL, 0x80000001816DDBC0 | 0x8000000000000000), (v88 & 1) == 0))
          {
            unint64_t v89 = v86;
            unint64_t v90 = v87;
            swift_bridgeObjectRelease(v84);
            swift_bridgeObjectRelease(0x80000001816DDBC0 | 0x8000000000000000);
            unint64_t v118 = v89;
            unint64_t v119 = v90;
          }
          else
          {
            if ((0x80000001816DDBC0 & 0x2000000000000000) != 0) {
              unint64_t v91 = (0x80000001816DDBC0 >> 56) & 0xF;
            }
            else {
              unint64_t v91 = 27;
            }
            _StringGuts.append(_:)(0xD00000000000001BLL, 0x80000001816DDBC0 | 0x8000000000000000, 0, v91);
            swift_bridgeObjectRelease(0x80000001816DDBC0 | 0x8000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v119);
          unint64_t v118 = 0xD00000000000001BLL;
          unint64_t v119 = 0x80000001816DDBC0 | 0x8000000000000000;
        }
        uint64_t v92 = (uint64_t)v109;
        _print_unlocked<A, B>(_:_:)((uint64_t)v109, (uint64_t)&v118, v47, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
        v83(v92, v47);
        uint64_t v93 = v119;
        unint64_t v94 = HIBYTE(v119) & 0xF;
        if ((v119 & 0x2000000000000000) == 0) {
          unint64_t v94 = v118 & 0xFFFFFFFFFFFFLL;
        }
        if (v94 || (v118 & ~v119 & 0x2000000000000000) != 0)
        {
          if ((v119 & 0x2000000000000000) == 0
            || (unint64_t v95 = specialized _SmallString.init(_:appending:)(v118, v119, 0x29uLL, 0xE100000000000000),
                (v97 & 1) != 0))
          {
            _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
            swift_bridgeObjectRelease(0xE100000000000000);
            unint64_t v98 = v118;
            unint64_t v99 = v119;
          }
          else
          {
            unint64_t v98 = v95;
            unint64_t v99 = v96;
            swift_bridgeObjectRelease(v93);
            swift_bridgeObjectRelease(0xE100000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v119);
          unint64_t v99 = 0xE100000000000000;
          unint64_t v98 = 41;
        }
        *(void *)uint64_t v49 = v117;
        *(void *)(v49 + 8) = v98;
        *(void *)(v49 + 16) = v99;
        *(void *)(v49 + 24) = 0;
        *(unsigned char *)(v49 + 72) = 3;
        swift_willThrow();
        __swift_destroy_boxed_opaque_existential_1Tm(v120);
        a1 = v123;
        goto LABEL_63;
      }
    }
    else if ((v70 & 0x2000000000000000) != 0)
    {
      uint64_t v75 = HIBYTE(v70) & 0xF;
      goto LABEL_29;
    }
    uint64_t v75 = v69 & 0xFFFFFFFFFFFFLL;
    goto LABEL_29;
  }
  unint64_t v34 = TupleTypeMetadata2;
  unint64_t v35 = &v114[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v117 = 0;
  uint64_t v36 = v116;
  unint64_t v37 = *(void (**)(void))(v116 + 32);
  v37();
  unint64_t v113 = v35;
  ((void (*)(char *, uint64_t, uint64_t))v37)(v35, v31, a2);
  unint64_t v38 = v111;
  unint64_t v39 = &v111[*((int *)v34 + 12)];
  char v40 = *(void (**)(char *, char *, uint64_t))(v36 + 16);
  unint64_t v41 = v114;
  v40(v111, v114, a2);
  v40(v39, v35, a2);
  uint64_t v42 = v107;
  ((void (*)(char *, char *, uint64_t))v37)(v107, v38, a2);
  size_t v43 = *(void (**)(char *, uint64_t))(v116 + 8);
  v43(v39, a2);
  uint64_t v44 = &v38[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, uint64_t))v37)(v38, v41, a2);
  ((void (*)(char *, char *, uint64_t))v37)(v44, v113, a2);
  char v45 = v108;
  ((void (*)(char *, char *, uint64_t))v37)(&v42[*((int *)v108 + 9)], v44, a2);
  v43(v38, a2);
  (*(void (**)(uint64_t, char *, Class *))(v110 + 32))(v112, v42, v45);
  __swift_destroy_boxed_opaque_existential_1Tm(v120);
  uint64_t v46 = v123;
  return __swift_destroy_boxed_opaque_existential_1Tm(v46);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> Range<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(from:)(a1, *(void *)(a2 + 16), *(char **)(a2 + 24), *(void *)(a3 - 8), a4);
}

uint64_t Range<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return ClosedRange<>.encode(to:)(a1, a2, a3);
}

uint64_t PartialRangeUpTo.relative<A>(to:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v45 = a1;
  uint64_t v42 = a4;
  uint64_t v6 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v9 = (char *)&v39 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  size_t v43 = (char *)&v39 - v11;
  uint64_t v12 = *(void **)(v6 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  int64_t v21 = (char *)&v39 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v39 - v22;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  BOOL v24 = (void (*)(char *, char *, uint64_t))v12[2];
  v24(v21, v44, v6);
  v24(v18, v23, v6);
  uint64_t v44 = v21;
  v24(v15, v21, v6);
  uint64_t v25 = *(void *)(v45 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v6, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v45 = v25;
  uint64_t v26 = (uint64_t (*)(char *, uint64_t))v12[1];
  unint64_t v41 = v26;
  v26(v15, v6);
  v26(v18, v6);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v43;
  unint64_t v29 = v23;
  uint64_t v30 = &v43[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v12[4];
  v31(v43, v29, v6);
  char v40 = v30;
  v31(v30, v44, v6);
  char v32 = &v9[*((int *)v27 + 12)];
  v24(v9, v28, v6);
  v24(v32, v30, v6);
  uint64_t v33 = v42;
  v31(v42, v9, v6);
  unint64_t v34 = v41;
  v41(v32, v6);
  unint64_t v35 = &v9[*((int *)TupleTypeMetadata2 + 12)];
  v31(v9, v28, v6);
  v31(v35, v40, v6);
  unint64_t v37 = type metadata accessor for Range(0, v6, v45, v36);
  v31(&v33[*((int *)v37 + 9)], v35, v6);
  return v34(v9, v6);
}

uint64_t PartialRangeUpTo.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 16))(a1, v2) & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance PartialRangeUpTo<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v45 = a3;
  uint64_t v42 = a4;
  uint64_t v6 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v9 = (char *)&v39 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  size_t v43 = (char *)&v39 - v11;
  uint64_t v12 = *(void **)(v6 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  int64_t v21 = (char *)&v39 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v39 - v22;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  BOOL v24 = (void (*)(char *, char *, uint64_t))v12[2];
  v24(v21, v44, v6);
  v24(v18, v23, v6);
  uint64_t v44 = v21;
  v24(v15, v21, v6);
  uint64_t v25 = *(void *)(v45 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v6, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v45 = v25;
  uint64_t v26 = (uint64_t (*)(char *, uint64_t))v12[1];
  unint64_t v41 = v26;
  v26(v15, v6);
  v26(v18, v6);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v43;
  unint64_t v29 = v23;
  uint64_t v30 = &v43[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v12[4];
  v31(v43, v29, v6);
  char v40 = v30;
  v31(v30, v44, v6);
  char v32 = &v9[*((int *)v27 + 12)];
  v24(v9, v28, v6);
  v24(v32, v30, v6);
  uint64_t v33 = v42;
  v31(v42, v9, v6);
  unint64_t v34 = v41;
  v41(v32, v6);
  unint64_t v35 = &v9[*((int *)TupleTypeMetadata2 + 12)];
  v31(v9, v28, v6);
  v31(v35, v40, v6);
  unint64_t v37 = type metadata accessor for Range(0, v6, v45, v36);
  v31(&v33[*((int *)v37 + 9)], v35, v6);
  return v34(v9, v6);
}

uint64_t protocol witness for RangeExpression.contains(_:) in conformance PartialRangeUpTo<A>(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 16))(a1, v2) & 1;
}

uint64_t PartialRangeUpTo<>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return PartialRangeUpTo<>.init(from:)(a1, a2, a3, a4);
}

{
  uint64_t v4;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v18[3];
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;

  int64_t v21 = a3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = (void *)MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v18[-1] - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = v9[3];
  uint64_t v13 = v9[4];
  __swift_project_boxed_opaque_existential_0Tm(v9, v12);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v13 + 32))(v18, v12, v13);
  if (!v4)
  {
    uint64_t v14 = v19;
    uint64_t v15 = v20;
    __swift_mutable_project_boxed_opaque_existential_1(v18, v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t))(v15 + 176))(a2, a2, v21, v14, v15);
    (*(void (**)(uint64_t, char *, uint64_t))(v8 + 32))(a4, v11, a2);
    __swift_destroy_boxed_opaque_existential_1Tm(v18);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t PartialRangeUpTo<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeUpTo<>.encode(to:)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v11[3];
  unint64_t v12;
  uint64_t v13;

  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 32))(v11, v6, v7);
  uint64_t v8 = v12;
  uint64_t v9 = v13;
  __swift_mutable_project_boxed_opaque_existential_1(v11, v12);
  (*(void (**)(uint64_t, void, uint64_t, unint64_t, uint64_t))(v9 + 160))(v3, *(void *)(a2 + 16), a3, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v11);
}

uint64_t PartialRangeThrough.relative<A>(to:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v44 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v45 = (char *)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  size_t v43 = (char *)&v40 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v40 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  int64_t v21 = (char *)&v40 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v40 - v22;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 184))(v46, a2, a3);
  BOOL v24 = (void (*)(char *, char *, uint64_t))v12[2];
  v24(v18, v23, v7);
  uint64_t v46 = v21;
  v24(v15, v21, v7);
  uint64_t v25 = *(void *)(a1 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v7, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v42 = v25;
  uint64_t v26 = (uint64_t (*)(char *, uint64_t))v12[1];
  unint64_t v41 = v26;
  v26(v15, v7);
  v26(v18, v7);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v43;
  unint64_t v29 = &v43[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v30 = (void (*)(char *, char *, uint64_t))v12[4];
  v30(v43, v23, v7);
  char v40 = v29;
  v30(v29, v46, v7);
  uint64_t v31 = v45;
  char v32 = &v45[*((int *)v27 + 12)];
  v24(v45, v28, v7);
  v24(v32, v29, v7);
  uint64_t v33 = v44;
  v30(v44, v31, v7);
  unint64_t v34 = v32;
  unint64_t v35 = v41;
  v41(v34, v7);
  uint64_t v36 = &v31[*((int *)TupleTypeMetadata2 + 12)];
  v30(v31, v28, v7);
  v30(v36, v40, v7);
  unint64_t v38 = type metadata accessor for Range(0, v7, v42, v37);
  v30(&v33[*((int *)v38 + 9)], v36, v7);
  return v35(v31, v7);
}

uint64_t PartialRangeThrough.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 24))(a1, v2) & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance PartialRangeThrough<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  char v47 = a4;
  uint64_t v7 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v48 = (char *)&v41 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v46 = (char *)&v41 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v41 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v41 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  int64_t v21 = (char *)&v41 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v41 - v22;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(a2 + 184))(v49, a1, a2);
  BOOL v24 = (void (*)(char *, char *, uint64_t))v12[2];
  v24(v18, v23, v7);
  uint64_t v49 = v21;
  v24(v15, v21, v7);
  uint64_t v25 = *(void *)(a3 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v7, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v45 = v25;
  uint64_t v26 = (uint64_t (*)(char *, uint64_t))v12[1];
  uint64_t v44 = v26;
  v26(v15, v7);
  v26(v18, v7);
  uint64_t v42 = v24;
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v46;
  unint64_t v29 = &v46[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v30 = (void (*)(char *, char *, uint64_t))v12[4];
  v30(v46, v23, v7);
  uint64_t v31 = v29;
  size_t v43 = v29;
  v30(v29, v49, v7);
  char v32 = v48;
  uint64_t v33 = &v48[*((int *)v27 + 12)];
  unint64_t v34 = v42;
  v42(v48, v28, v7);
  v34(v33, v31, v7);
  unint64_t v35 = v47;
  v30(v47, v32, v7);
  uint64_t v36 = v44;
  v44(v33, v7);
  uint64_t v37 = &v32[*((int *)TupleTypeMetadata2 + 12)];
  v30(v32, v28, v7);
  v30(v37, v43, v7);
  uint64_t v39 = type metadata accessor for Range(0, v7, v45, v38);
  v30(&v35[*((int *)v39 + 9)], v37, v7);
  return v36(v32, v7);
}

uint64_t protocol witness for RangeExpression.contains(_:) in conformance PartialRangeThrough<A>(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 24))(a1, v2) & 1;
}

uint64_t PartialRangeThrough<>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return PartialRangeUpTo<>.init(from:)(a1, a2, a3, a4);
}

uint64_t PartialRangeThrough<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeUpTo<>.encode(to:)(a1, a2, a3);
}

uint64_t PartialRangeFrom.relative<A>(to:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, void (*a3)(char *, uint64_t, uint64_t)@<X2>, void (**a4)(void (*)(char *, uint64_t, uint64_t))@<X3>, char *a5@<X8>)
{
  size_t v43 = a4;
  uint64_t v44 = a1;
  uint64_t v45 = a3;
  uint64_t v46 = a2;
  uint64_t v42 = a5;
  uint64_t v6 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v9 = (char *)&v40 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v41 = (char *)&v40 - v11;
  uint64_t v12 = *(void **)(v6 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v40 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  int64_t v21 = (char *)&v40 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v40 - v22;
  BOOL v24 = (void (*)(char *, uint64_t, uint64_t))v12[2];
  v24((char *)&v40 - v22, v5, v6);
  v43[9](v45);
  v24(v18, (uint64_t)v23, v6);
  uint64_t v44 = v21;
  uint64_t v45 = v24;
  v24(v15, (uint64_t)v21, v6);
  uint64_t v25 = *(void *)(v46 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v6, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v46 = v25;
  uint64_t v26 = (void (**)(void (*)(char *, uint64_t, uint64_t)))v12[1];
  size_t v43 = v26;
  ((void (*)(char *, uint64_t))v26)(v15, v6);
  ((void (*)(char *, uint64_t))v26)(v18, v6);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v41;
  unint64_t v29 = &v41[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v30 = (void (*)(char *, char *, uint64_t))v12[4];
  v30(v41, v23, v6);
  uint64_t v31 = v29;
  v30(v29, v44, v6);
  char v32 = &v9[*((int *)v27 + 12)];
  uint64_t v33 = (void (*)(char *, char *, uint64_t))v45;
  v45(v9, (uint64_t)v28, v6);
  v33(v32, v31, v6);
  unint64_t v34 = v42;
  v30(v42, v9, v6);
  unint64_t v35 = (uint64_t (*)(char *, uint64_t))v43;
  ((void (*)(char *, uint64_t))v43)(v32, v6);
  uint64_t v36 = &v9[*((int *)TupleTypeMetadata2 + 12)];
  v30(v9, v28, v6);
  v30(v36, v31, v6);
  uint64_t v38 = type metadata accessor for Range(0, v6, v46, v37);
  v30(&v34[*((int *)v38 + 9)], v36, v6);
  return v35(v9, v6);
}

uint64_t PartialRangeFrom.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 24))(v2, a1) & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance PartialRangeFrom<A>@<X0>(char *a1@<X0>, void (*a2)(char *, uint64_t, uint64_t)@<X1>, void (**a3)(void (*)(char *, uint64_t, uint64_t))@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v45 = a2;
  uint64_t v46 = a4;
  size_t v43 = a3;
  uint64_t v44 = a1;
  uint64_t v42 = a5;
  uint64_t v6 = *(void *)(a4 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v9 = (char *)&v40 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v41 = (char *)&v40 - v11;
  uint64_t v12 = *(void **)(v6 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v40 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  int64_t v21 = (char *)&v40 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v40 - v22;
  BOOL v24 = (void (*)(char *, uint64_t, uint64_t))v12[2];
  v24((char *)&v40 - v22, v5, v6);
  v43[9](v45);
  v24(v18, (uint64_t)v23, v6);
  uint64_t v44 = v21;
  uint64_t v45 = v24;
  v24(v15, (uint64_t)v21, v6);
  uint64_t v25 = *(void *)(v46 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v6, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v46 = v25;
  uint64_t v26 = (void (**)(void (*)(char *, uint64_t, uint64_t)))v12[1];
  size_t v43 = v26;
  ((void (*)(char *, uint64_t))v26)(v15, v6);
  ((void (*)(char *, uint64_t))v26)(v18, v6);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v41;
  unint64_t v29 = &v41[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v30 = (void (*)(char *, char *, uint64_t))v12[4];
  v30(v41, v23, v6);
  uint64_t v31 = v29;
  v30(v29, v44, v6);
  char v32 = &v9[*((int *)v27 + 12)];
  uint64_t v33 = (void (*)(char *, char *, uint64_t))v45;
  v45(v9, (uint64_t)v28, v6);
  v33(v32, v31, v6);
  unint64_t v34 = v42;
  v30(v42, v9, v6);
  unint64_t v35 = (uint64_t (*)(char *, uint64_t))v43;
  ((void (*)(char *, uint64_t))v43)(v32, v6);
  uint64_t v36 = &v9[*((int *)TupleTypeMetadata2 + 12)];
  v30(v9, v28, v6);
  v30(v36, v31, v6);
  uint64_t v38 = type metadata accessor for Range(0, v6, v46, v37);
  v30(&v34[*((int *)v38 + 9)], v36, v6);
  return v35(v9, v6);
}

uint64_t (*PartialRangeFrom<>.Iterator._current.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.init(_base:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a3, a1, a2);
}

uint64_t PartialRangeFrom<>.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v20 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v20, v4, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v21 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v19 = (char *)&v18 - v6;
  uint64_t v7 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness((uint64_t)v20, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Strideable, associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)+ 8)+ 16);
  uint64_t v8 = swift_getAssociatedTypeWitness(0, (int **)v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](v8);
  uint64_t v11 = (char *)&v18 - v10;
  uint64_t v12 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a2, v2, v4);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v12 + 56))(a2, 0, 1, v4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, (uint64_t)AssociatedTypeWitness, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, v8, AssociatedConformanceWitness);
  uint64_t v16 = v19;
  (*(void (**)(char *, const char *, uint64_t))(v7 + 24))(v11, AssociatedTypeWitness, v7);
  ((void (*)(char *, uint64_t))v20[6])(v16, v4);
  (*(void (**)(char *, const char *))(v21 + 8))(v16, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v12 + 40))(v2, v14, v4);
}

uint64_t PartialRangeFrom<>.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 32))(a2, v2);
}

uint64_t PartialRangeFrom<>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return PartialRangeUpTo<>.init(from:)(a1, a2, a3, a4);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> PartialRangeFrom<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return PartialRangeFrom<>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8), a4);
}

uint64_t PartialRangeFrom<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeUpTo<>.encode(to:)(a1, a2, a3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> PartialRangeFrom<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeFrom<>.encode(to:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t static Comparable...< prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return static Comparable.... postfix(_:)(a1, a2, a3, "Range cannot have an unordered upper bound.", 0x311uLL, a4);
}

uint64_t static Comparable.... prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return static Comparable.... postfix(_:)(a1, a2, a3, "Range cannot have an unordered upper bound.", 0x330uLL, a4);
}

uint64_t static Comparable.... postfix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v15(v14, a1, a2);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 8))(v14, v14, a2) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a4, 43, 2, "Swift/Range.swift", 17, 2, a5, 0);
  }
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, a2);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v15)(a6, a1, a2);
}

uint64_t Collection.subscript.getter@<X0>(uint64_t a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v69 = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v68 = (char *)&v58 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v63 = (char *)&v58 - v9;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v66 = (uint64_t)*(v12 - 1);
  int64_t v67 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  char v62 = (char *)&v58 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  char v64 = (char *)&v58 - v16;
  uint64_t v17 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v70 = (char *)&v58 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v73 = (char *)&v58 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v75 = (char *)&v58 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v74 = (char *)&v58 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v58 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v58 - v29;
  char v32 = type metadata accessor for PartialRangeFrom(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v31);
  uint64_t v61 = (uint64_t)*(v32 - 1);
  MEMORY[0x1F4188790](v32);
  unint64_t v34 = (char *)&v58 - v33;
  unint64_t v35 = *(void (**)(uint64_t, uint64_t))(a2 + 64);
  uint64_t v76 = a1;
  uint64_t v77 = v3;
  uint64_t v78 = a2;
  v35(a1, a2);
  unint64_t v72 = (void (*)(char *, char *, const char *))v17[2];
  v72(v28, v30, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v28, v28, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range cannot have an unordered lower bound.", 43, 2, "Swift/Range.swift", 17, 2, 0x34FuLL, 0); {
  unint64_t v59 = v32;
  }
  uint64_t v36 = (char *)(v17 + 1);
  unint64_t v71 = (void (*)(char *, const char *))v17[1];
  v71(v28, AssociatedTypeWitness);
  uint64_t v37 = (void (*)(char *, char *, const char *))v17[4];
  unint64_t v60 = v17 + 4;
  v37(v34, v30, AssociatedTypeWitness);
  uint64_t v38 = v74;
  uint64_t v39 = v72;
  v72(v74, v34, AssociatedTypeWitness);
  uint64_t v40 = v75;
  (*(void (**)(uint64_t))(v78 + 72))(v76);
  uint64_t v41 = v73;
  v39(v73, v38, AssociatedTypeWitness);
  uint64_t v42 = v70;
  v39(v70, v40, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v41, v42, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  size_t v43 = v71;
  }
  v71(v42, AssociatedTypeWitness);
  v43(v73, AssociatedTypeWitness);
  (*(void (**)(char *, Class *))(v61 + 8))(v34, v59);
  uint64_t v44 = TupleTypeMetadata2;
  uint64_t v45 = v63;
  uint64_t v46 = &v63[*((int *)TupleTypeMetadata2 + 12)];
  char v47 = v74;
  unint64_t v74 = v36;
  v37(v63, v47, AssociatedTypeWitness);
  v37(v46, v75, AssociatedTypeWitness);
  uint64_t v48 = v68;
  uint64_t v49 = &v68[*((int *)v44 + 12)];
  uint64_t v50 = v72;
  v72(v68, v45, AssociatedTypeWitness);
  v50(v49, v46, AssociatedTypeWitness);
  uint64_t v51 = v62;
  v37(v62, v48, AssociatedTypeWitness);
  unint64_t v52 = v71;
  v71(v49, AssociatedTypeWitness);
  unint64_t v53 = &v48[*((int *)v44 + 12)];
  v37(v48, v45, AssociatedTypeWitness);
  v37(v53, v46, AssociatedTypeWitness);
  uint64_t v54 = v67;
  v37(&v51[*((int *)v67 + 9)], v53, AssociatedTypeWitness);
  v52(v48, AssociatedTypeWitness);
  uint64_t v55 = v66;
  unint64_t v56 = v64;
  (*(void (**)(char *, char *, Class *))(v66 + 32))(v64, v51, v54);
  (*(void (**)(char *, uint64_t))(v78 + 88))(v56, v76);
  return (*(uint64_t (**)(char *, Class *))(v55 + 8))(v56, v54);
}

uint64_t specialized MutableCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 8);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(v5 + 72))(v8, a2, v5);
  uint64_t v6 = v8[0];
  if (v8[0] < a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v8[0] = a1;
  v8[1] = v6;
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(v5 + 88))(v8, a2, v5);
}

uint64_t MutableCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RangeExpression, associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v13 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v18 - v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(v5, a2, v9, a3, a5);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 88))(v16, a2, v9);
  return (*(uint64_t (**)(char *, Class *))(v14 + 8))(v16, v13);
}

uint64_t key path getter for MutableCollection.subscript<A>(_:) : <A><A1>AAA1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MutableCollection.subscript.getter(a2, *(void *)(a3 + a2 - 32), *(void *)(a3 + a2 - 24), *(void *)(a3 + a2 - 16), *(void *)(a3 + a2 - 8));
}

uint64_t key path setter for MutableCollection.subscript<A>(_:) : <A><A1>AAA1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a4 + a3 - 32);
  uint64_t v7 = *(void *)(a4 + a3 - 24);
  uint64_t v8 = *(void *)(a4 + a3 - 16);
  uint64_t v9 = *(void *)(a4 + a3 - 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v8 + 8), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  (*(void (**)(char *, uint64_t))(v13 + 16))((char *)&v15 - v11, a1);
  return specialized MutableCollection.subscript.setter((uint64_t)v12, a3, v6, v7, v8, v9);
}

uint64_t MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  specialized MutableCollection.subscript.setter(a1, a2, a3, a4, a5, a6);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8);

  return v8(a2, a4);
}

void (*MutableCollection.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6))(uint64_t a1, char a2)
{
  uint64_t v12 = malloc(0x80uLL);
  *a1 = v12;
  void v12[2] = a5;
  v12[3] = a6;
  *uint64_t v12 = a3;
  v12[1] = a4;
  uint64_t v13 = *(void *)(a5 + 8);
  v12[4] = v6;
  v12[5] = v13;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v13, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RangeExpression, associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v28 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v17 = (uint64_t)*(v28 - 1);
  uint64_t v18 = malloc(*(void *)(v17 + 64));
  v12[6] = v18;
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)v13, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  v12[7] = v19;
  uint64_t v20 = *((void *)v19 - 1);
  v12[8] = v20;
  size_t v21 = *(void *)(v20 + 64);
  v12[9] = malloc(v21);
  uint64_t v22 = malloc(v21);
  uint64_t v23 = *(void *)(a4 - 8);
  uint64_t v24 = v23;
  v12[10] = v22;
  v12[11] = v23;
  size_t v25 = *(void *)(v23 + 64);
  v12[12] = malloc(v25);
  v12[13] = malloc(v25);
  (*(void (**)(void))(v24 + 16))();
  uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 24);
  v12[14] = v26;
  v12[15] = (a6 + 24) & 0xFFFFFFFFFFFFLL | 0x25A2000000000000;
  v26(v29, a3, v13, a4, a6);
  (*(void (**)(void *, uint64_t, uint64_t))(v13 + 88))(v18, a3, v13);
  (*(void (**)(void *, Class *))(v17 + 8))(v18, v28);
  return MutableCollection.subscript.modify;
}

void MutableCollection.subscript.modify(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 88);
  uint64_t v20 = *(void **)(*(void *)a1 + 96);
  size_t v21 = *(void **)(*(void *)a1 + 104);
  uint64_t v4 = *(void **)(*(void *)a1 + 72);
  uint64_t v5 = *(void **)(*(void *)a1 + 80);
  if (a2)
  {
    uint64_t v6 = v2[8];
    uint64_t v7 = (void *)v2[6];
    uint64_t v8 = v2[4];
    uint64_t v16 = v2[5];
    uint64_t v17 = v2[3];
    uint64_t v9 = v2[1];
    uint64_t v18 = v2[2];
    uint64_t v19 = v2[7];
    uint64_t v15 = *v2;
    uint64_t v10 = *(void **)(*(void *)a1 + 80);
    uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 112);
    (*(void (**)(void *, void *))(v6 + 16))(v4, v10);
    (*(void (**)(void *, void *, uint64_t))(v3 + 32))(v20, v21, v9);
    v11(v8, v15, v16, v9, v17);
    (*(void (**)(void *, uint64_t))(v3 + 8))(v20, v9);
    uint64_t v5 = v10;
    (*(void (**)(void *, void *, uint64_t))(v18 + 40))(v4, v7, v15);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v10, v19);
  }
  else
  {
    uint64_t v7 = (void *)v2[6];
    uint64_t v13 = v2[1];
    uint64_t v12 = v2[2];
    uint64_t v14 = *v2;
    (*(void (**)(void, void, void, uint64_t, void))(*(void *)a1 + 112))(v2[4], *v2, v2[5], v13, v2[3]);
    (*(void (**)(void *, uint64_t))(v3 + 8))(v21, v13);
    (*(void (**)(void *, void *, uint64_t, uint64_t))(v12 + 40))(v5, v7, v14, v12);
  }
  free(v21);
  free(v20);
  free(v5);
  free(v4);
  free(v7);

  free(v2);
}

uint64_t MutableCollection.subscript.getter@<X0>(uint64_t a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v69 = a3;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v5, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v68 = (char *)&v58 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v63 = (char *)&v58 - v9;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v66 = (uint64_t)*(v12 - 1);
  int64_t v67 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  char v62 = (char *)&v58 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  char v64 = (char *)&v58 - v16;
  uint64_t v17 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v71 = (char *)&v58 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  unint64_t v74 = (char *)&v58 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  unint64_t v70 = (char *)&v58 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v58 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v58 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v58 - v29;
  char v32 = type metadata accessor for PartialRangeFrom(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v31);
  uint64_t v61 = (uint64_t)*(v32 - 1);
  MEMORY[0x1F4188790](v32);
  unint64_t v34 = (char *)&v58 - v33;
  unint64_t v35 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v77 = a1;
  uint64_t v78 = v3;
  uint64_t v76 = v5;
  v35(a1, v5);
  uint64_t v73 = (void (*)(char *, char *, const char *))v17[2];
  v73(v28, v30, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v28, v28, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range cannot have an unordered lower bound.", 43, 2, "Swift/Range.swift", 17, 2, 0x34FuLL, 0); {
  unint64_t v59 = v32;
  }
  uint64_t v36 = (char *)(v17 + 1);
  unint64_t v72 = (void (*)(char *, const char *))v17[1];
  v72(v28, AssociatedTypeWitness);
  uint64_t v37 = (void (*)(char *, char *, const char *))v17[4];
  unint64_t v60 = v17 + 4;
  v37(v34, v30, AssociatedTypeWitness);
  uint64_t v38 = v75;
  uint64_t v39 = v73;
  v73(v75, v34, AssociatedTypeWitness);
  uint64_t v40 = v70;
  (*(void (**)(uint64_t))(v76 + 72))(v77);
  uint64_t v41 = v74;
  v39(v74, v38, AssociatedTypeWitness);
  uint64_t v42 = v71;
  v39(v71, v40, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v41, v42, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  size_t v43 = v72;
  }
  v72(v42, AssociatedTypeWitness);
  v43(v74, AssociatedTypeWitness);
  (*(void (**)(char *, Class *))(v61 + 8))(v34, v59);
  uint64_t v44 = TupleTypeMetadata2;
  uint64_t v45 = v63;
  uint64_t v46 = &v63[*((int *)TupleTypeMetadata2 + 12)];
  char v47 = v75;
  uint64_t v75 = v36;
  v37(v63, v47, AssociatedTypeWitness);
  v37(v46, v40, AssociatedTypeWitness);
  uint64_t v48 = v68;
  uint64_t v49 = &v68[*((int *)v44 + 12)];
  uint64_t v50 = v73;
  v73(v68, v45, AssociatedTypeWitness);
  v50(v49, v46, AssociatedTypeWitness);
  uint64_t v51 = v62;
  v37(v62, v48, AssociatedTypeWitness);
  unint64_t v52 = v72;
  v72(v49, AssociatedTypeWitness);
  unint64_t v53 = &v48[*((int *)v44 + 12)];
  v37(v48, v45, AssociatedTypeWitness);
  v37(v53, v46, AssociatedTypeWitness);
  uint64_t v54 = v67;
  v37(&v51[*((int *)v67 + 9)], v53, AssociatedTypeWitness);
  v52(v48, AssociatedTypeWitness);
  uint64_t v55 = v66;
  unint64_t v56 = v64;
  (*(void (**)(char *, char *, Class *))(v66 + 32))(v64, v51, v54);
  (*(void (**)(char *, uint64_t))(v76 + 88))(v56, v77);
  return (*(uint64_t (**)(char *, Class *))(v55 + 8))(v56, v54);
}

uint64_t MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return specialized MutableCollection.subscript.setter(a1, a4, a5);
}

void (*MutableCollection.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x38uLL);
  *a1 = v9;
  v9[1] = a5;
  v9[2] = v5;
  void *v9 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a5 + 8), a4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  v9[3] = AssociatedTypeWitness;
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  v9[4] = v11;
  size_t v12 = *(void *)(v11 + 64);
  v9[5] = malloc(v12);
  uint64_t v13 = malloc(v12);
  v9[6] = v13;
  MutableCollection.subscript.getter(a4, a5, (uint64_t)v13);
  return MutableCollection.subscript.modify;
}

void MutableCollection.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)(*a1)[5];
  uint64_t v4 = (void *)(*a1)[6];
  if (a2)
  {
    uint64_t v5 = v2[3];
    uint64_t v6 = v2[4];
    uint64_t v7 = v2[1];
    uint64_t v8 = *v2;
    (*(void (**)(uint64_t, void *, uint64_t))(v6 + 16))((*a1)[5], v4, v5);
    specialized MutableCollection.subscript.setter((uint64_t)v3, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }
  else
  {
    specialized MutableCollection.subscript.setter((*a1)[6], *v2, v2[1]);
  }
  free(v4);
  free(v3);

  free(v2);
}

uint64_t Range.overlaps(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v37 = a1;
  uint64_t v5 = *(void *)(a2 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v36 = (char *)&v33 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  unint64_t v35 = (char *)&v33 - v9;
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  size_t v12 = (char *)&v33 - v11;
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v33 - v14;
  uint64_t v17 = v13 + *(int *)(v16 + 36);
  uint64_t v18 = *(void *)(v16 + 16);
  uint64_t v19 = *(void *)(v16 + 24);
  uint64_t v33 = *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v19 + 24);
  char v20 = v33(v17, (char *)v3, v18, v19);
  uint64_t v38 = v5;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 16);
  unint64_t v34 = v3;
  v21(v15, (uint64_t)v3, a2);
  v21(v12, v37, a2);
  if (v20) {
    char v22 = 1;
  }
  else {
    char v22 = v33((uint64_t)&v15[*(int *)(a2 + 36)], v12, v18, v19);
  }
  uint64_t v23 = v38 + 8;
  uint64_t v24 = *(void (**)(char *, uint64_t))(v38 + 8);
  v24(v12, a2);
  v24(v15, a2);
  uint64_t v25 = v35;
  v21(v35, (uint64_t)v34, a2);
  if (v22)
  {
    v24(v25, a2);
    uint64_t v26 = v36;
    v21(v36, v37, a2);
    char v27 = 0;
  }
  else
  {
    uint64_t v28 = &v25[*(int *)(a2 + 36)];
    uint64_t v29 = *(void *)(v19 + 8);
    unint64_t v34 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v29 + 8);
    uint64_t v30 = v21;
    char v31 = v34(v25, v28, v18, v29);
    uint64_t v38 = v23;
    v24(v25, a2);
    uint64_t v26 = v36;
    v30(v36, v37, a2);
    if (v31) {
      char v27 = 0;
    }
    else {
      char v27 = v34(v26, &v26[*(int *)(a2 + 36)], v18, v29) ^ 1;
    }
  }
  v24(v26, a2);
  return v27 & 1;
}

unint64_t String.Index._encodedOffset.getter(unint64_t a1)
{
  return a1 >> 16;
}

Swift::Void __swiftcall RangeReplaceableCollection.reserveCapacity(_:)(Swift::Int a1)
{
}

{
  EnumeratedSequence._base.modify();
}

uint64_t RangeReplaceableCollection.init(repeating:count:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v28 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a4[1] + 8), a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  size_t v12 = type metadata accessor for Repeated(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v27 - v17;
  uint64_t v19 = (void (*)(uint64_t, void *))a4[3];
  uint64_t v27 = a5;
  v19(a3, a4);
  if (a2)
  {
    uint64_t v20 = v28;
    if (a2 < 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
    }
    *(void *)uint64_t v16 = a2;
    (*(void (**)(char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(&v16[*((int *)v12 + 7)], v20, AssociatedTypeWitness);
    (*(void (**)(char *, char *, Class *))(v13 + 32))(v18, v16, v12);
    uint64_t v21 = (uint64_t (*)(char *, Class *, uint64_t, uint64_t, void *))a4[9];
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, (unint64_t *)v12, v22);
    return v21(v18, v12, WitnessTable, a3, a4);
  }
  else
  {
    uint64_t v25 = *(uint64_t (**)(uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 8);
    uint64_t v26 = v28;
    return v25(v26, AssociatedTypeWitness);
  }
}

uint64_t RangeReplaceableCollection.append(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v12 - v9;
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(a2, v6);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a3 + 80))(a1, v10, a2, a3);
  return (*(uint64_t (**)(char *, const char *))(v8 + 8))(v10, AssociatedTypeWitness);
}

uint64_t RangeReplaceableCollection.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return RangeReplaceableCollection.append<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  int **v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  Class *v15;
  uint64_t v16;
  char *v17;
  const char *v18;
  uint64_t v19;
  char *v20;
  uint64_t AssociatedConformanceWitness;
  void (*v22)(const char *);
  unsigned int (*v23)(char *, uint64_t, const char *);
  void (*v24)(char *, char *, const char *);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  const char *v32;

  uint64_t v29 = a4;
  uint64_t v8 = *(int ***)(*(void *)(a4 + 8) + 8);
  uint64_t v28 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v8, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v26 - v11;
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  MEMORY[0x1F4188790](v15 - 1);
  uint64_t v17 = (char *)&v26 - v16;
  uint64_t v18 = swift_getAssociatedTypeWitness(0, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v26 = *((void *)v18 - 1);
  MEMORY[0x1F4188790](v18);
  uint64_t v20 = (char *)&v26 - v19;
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)v18, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v22 = *(void (**)(const char *))(AssociatedConformanceWitness + 16);
  char v31 = v20;
  char v32 = v18;
  uint64_t v27 = AssociatedConformanceWitness;
  v22(v18);
  uint64_t v30 = v10;
  uint64_t v23 = *(unsigned int (**)(char *, uint64_t, const char *))(v10 + 48);
  if (v23(v17, 1, AssociatedTypeWitness) != 1)
  {
    uint64_t v24 = *(void (**)(char *, char *, const char *))(v30 + 32);
    v30 += 32;
    do
    {
      v24(v12, v17, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t))(v29 + 64))(v12, v28);
      ((void (*)(const char *, uint64_t))v22)(v32, v27);
    }
    while (v23(v17, 1, AssociatedTypeWitness) != 1);
  }
  return (*(uint64_t (**)(char *, const char *))(v26 + 8))(v31, v32);
}

uint64_t specialized RangeReplaceableCollection.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v11)(uint64_t *__return_ptr, const char *, uint64_t);
  uint64_t v13;
  uint64_t v14;

  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v13 - v8;
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v11(&v14, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v14 & 0x100) == 0)
  {
    do
    {
      if (HIBYTE(*v3)) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
      }
      *v3 |= (v14 + 1) << (-(__clz(*v3) & 0x18) & 0x18);
      v11(&v14, AssociatedTypeWitness, AssociatedConformanceWitness);
    }
    while (BYTE1(v14) != 1);
  }
  return (*(uint64_t (**)(char *, const char *))(v7 + 8))(v9, AssociatedTypeWitness);
}

{
  uint64_t v3;
  const char *AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t *__return_ptr, const char *, uint64_t);
  Swift::String::Index v12;
  Swift::String::Index v13;
  uint64_t v15;
  uint64_t v16;

  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v15 - v8;
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v16 & 0x100000000) == 0)
  {
    do
    {
      v12._Swift::UInt64 rawBits = *(void *)(v3 + 8);
      v13._Swift::UInt64 rawBits = v12._rawBits;
      specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v12, v13);
      v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
    }
    while (BYTE4(v16) != 1);
  }
  return (*(uint64_t (**)(char *, const char *))(v7 + 8))(v9, AssociatedTypeWitness);
}

uint64_t specialized RangeReplaceableCollection.insert(_:at:)(uint64_t result, unsigned int a2)
{
  char v4 = result;
  unsigned int v5 = *v2;
  if (!a2) {
    goto LABEL_5;
  }
  unsigned int v19 = a2;
  MEMORY[0x1F4188790](result);
  uint64_t v18 = &v19;
  unint64_t v7 = v6 | (v6 << 32);
  uint64_t v8 = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v16, v7, 0);
  if ((v8 & 1) == 0)
  {
    LODWORD(v18) = 0;
    unint64_t v14 = 193;
    goto LABEL_25;
  }
  unsigned int v19 = a2;
  MEMORY[0x1F4188790](v8);
  uint64_t v18 = &v19;
  uint64_t result = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v16, v7, 0);
  if ((result & 1) == 0)
  {
    LODWORD(v18) = 0;
    unint64_t v14 = 194;
LABEL_25:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v14, (int)v18);
  }
  unsigned int v5 = *v2;
  if (*v2 < a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_5:
  if (v5 == a2)
  {
    unsigned int v9 = 0;
    goto LABEL_7;
  }
  unsigned int v9 = 0;
  unsigned int v13 = v5;
  do
  {
    if (v5 < v13 || v13 <= a2) {
      goto LABEL_21;
    }
    if (HIBYTE(v9)) {
      goto LABEL_20;
    }
    v9 |= v13 << (-(__clz(v9) & 0x18) & 0x18);
    v13 >>= 8;
  }
  while (v13 != a2);
  if (HIBYTE(v9))
  {
LABEL_20:
    LODWORD(v18) = 0;
    unint64_t v14 = 167;
    goto LABEL_25;
  }
LABEL_7:
  if (v5 < a2)
  {
    LODWORD(v18) = 0;
    unint64_t v17 = 730;
    v16[0] = 2;
    uint64_t v15 = "Range out of bounds";
    goto LABEL_22;
  }
  unsigned int v10 = ((v4 + 1) << (-(__clz(v9) & 0x18) & 0x18)) | v9;
  if (a2)
  {
    unsigned int v11 = a2;
    while (v11 <= a2)
    {
      if (HIBYTE(v10)) {
        goto LABEL_20;
      }
      v10 |= v11 << (-(__clz(v10) & 0x18) & 0x18);
      BOOL v12 = v11 >= 0x100;
      v11 >>= 8;
      if (!v12) {
        goto LABEL_13;
      }
    }
LABEL_21:
    LODWORD(v18) = 0;
    unint64_t v17 = 714;
    v16[0] = 2;
    uint64_t v15 = "Index out of bounds";
LABEL_22:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v15, 19, 2, "Swift/Collection.swift", 22, v16[0], v17, (int)v18);
  }
LABEL_13:
  unsigned int *v2 = v10;
  return result;
}

uint64_t RangeReplaceableCollection.insert(_:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = a4;
  uint64_t v62 = a1;
  uint64_t v6 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v61 = (unint64_t *)type metadata accessor for CollectionOfOne(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  MEMORY[0x1F4188790](v61);
  unint64_t v59 = (char *)&v49 - v9;
  unsigned int v10 = swift_getAssociatedTypeWitness(255, (int **)v6, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v10, (uint64_t)v10, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v55 = (char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v54 = (char *)&v49 - v14;
  uint64_t v15 = (void *)*((void *)v10 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v49 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v49 - v19;
  uint64_t v63 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a3, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v23 = type metadata accessor for Range(0, (uint64_t)v10, AssociatedConformanceWitness, v22);
  uint64_t v57 = (uint64_t)*(v23 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](v23);
  unint64_t v53 = (char *)&v49 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v24);
  uint64_t v27 = (char *)&v49 - v26;
  uint64_t v28 = (void (*)(char *, uint64_t, const char *))v15[2];
  v28(v20, a2, v10);
  uint64_t v58 = a2;
  v28(v18, a2, v10);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v20, v18, v10, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v51 = v23;
  }
  uint64_t v29 = (void (*)(char *, const char *))v15[1];
  int64_t v65 = v29;
  v29(v18, v10);
  v29(v20, v10);
  unint64_t v52 = v27;
  uint64_t v30 = TupleTypeMetadata2;
  char v31 = v54;
  char v32 = &v54[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v33 = v58;
  v28(v54, v58, v10);
  uint64_t v50 = v32;
  v28(v32, v33, v10);
  unint64_t v34 = v55;
  unint64_t v35 = &v55[*((int *)v30 + 12)];
  v28(v55, (uint64_t)v31, v10);
  v28(v35, (uint64_t)v32, v10);
  uint64_t v36 = (void (*)(char *, char *, const char *))v15[4];
  uint64_t v37 = v53;
  v36(v53, v34, v10);
  v65(v35, v10);
  uint64_t v38 = &v34[*((int *)v30 + 12)];
  v36(v34, v31, v10);
  v36(v38, v50, v10);
  uint64_t v39 = v51;
  v36(&v37[*((int *)v51 + 9)], v38, v10);
  v65(v34, v10);
  uint64_t v40 = v57;
  uint64_t v41 = v52;
  (*(void (**)(char *, char *, Class *))(v57 + 32))(v52, v37, v39);
  uint64_t v42 = v59;
  (*(void (**)(char *, uint64_t))(*((void *)AssociatedTypeWitness - 1) + 32))(v59, v62);
  uint64_t v43 = v64;
  uint64_t v44 = *(void (**)(char *, char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v64 + 32);
  uint64_t v45 = v61;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v61, v46);
  v44(v41, v42, v45, WitnessTable, v63, v43);
  return (*(uint64_t (**)(char *, Class *))(v40 + 8))(v41, v39);
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(Swift::UInt64 a1)
{
  uint64_t v3 = *v1;
  unint64_t v2 = v1[1];
  uint64_t v4 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000) == 0) {
    uint64_t v4 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1)._rawBits;
  if ((v2 & 0x1000000000000000) != 0)
  {
    uint64_t v9 = *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v6._rawBits & 0xFFFFFFFFFFFF0000));
  }
  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v2 & 0x2000000000000000) != 0)
    {
      uint64_t v31 = v3;
      uint64_t v32 = v2 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v9 = *((unsigned __int8 *)&v31 + v7);
      if (*((char *)&v31 + v7) < 0)
      {
        switch(__clz(v9 ^ 0xFF))
        {
          case 0x1Au:
            unsigned int v10 = (unsigned __int8 *)&v31 + v7;
LABEL_14:
            uint64_t v9 = v10[1] & 0x3F | ((v9 & 0x1F) << 6);
            break;
          case 0x1Bu:
            uint64_t v11 = (unsigned __int8 *)&v31 + v7;
LABEL_18:
            char v13 = v11[1];
            char v14 = v11[2];
            int v15 = ((v9 & 0xF) << 12) | ((v13 & 0x3F) << 6);
            goto LABEL_21;
          case 0x1Cu:
            uint64_t v12 = (unsigned __int8 *)&v31 + v7;
LABEL_20:
            char v16 = v12[1];
            char v17 = v12[2];
            char v14 = v12[3];
            int v15 = ((v9 & 0xF) << 18) | ((v16 & 0x3F) << 12) | ((v17 & 0x3F) << 6);
LABEL_21:
            uint64_t v9 = v15 & 0xFFFFFFC0 | v14 & 0x3F;
            break;
          default:
            break;
        }
      }
    }
    else
    {
      if ((v3 & 0x1000000000000000) != 0) {
        uint64_t v8 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v2);
      }
      uint64_t v9 = v8[v7];
      if ((char)v8[v7] < 0)
      {
        switch(__clz(v9 ^ 0xFF))
        {
          case 0x1Au:
            unsigned int v10 = &v8[v7];
            goto LABEL_14;
          case 0x1Bu:
            uint64_t v11 = &v8[v7];
            goto LABEL_18;
          case 0x1Cu:
            uint64_t v12 = &v8[v7];
            goto LABEL_20;
          default:
            break;
        }
      }
    }
  }
  uint64_t v19 = *v1;
  uint64_t v18 = v1[1];
  v20._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1)._rawBits;
  if ((v18 & 0x1000000000000000) != 0)
  {
    v26._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v20)._rawBits;
  }
  else
  {
    Swift::UInt64 v21 = v20._rawBits >> 16;
    if ((v18 & 0x2000000000000000) != 0)
    {
      uint64_t v31 = v19;
      uint64_t v32 = v18 & 0xFFFFFFFFFFFFFFLL;
      int v23 = *((unsigned __int8 *)&v31 + v21);
    }
    else
    {
      if ((v19 & 0x1000000000000000) != 0) {
        uint64_t v22 = (unsigned __int8 *)((v18 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v22 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v19, v18);
      }
      int v23 = v22[v21];
    }
    int v24 = (char)v23;
    unsigned int v25 = __clz(v23 ^ 0xFF) - 24;
    if (v24 >= 0) {
      LOBYTE(v25) = 1;
    }
    v26._Swift::UInt64 rawBits = ((v21 + v25) << 16) | 5;
  }
  if (v26._rawBits >> 14 < a1 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v27._Swift::UInt64 rawBits = a1;
  Swift::UInt64 v28 = _StringGuts.validateScalarRange_5_7(_:)(v27, v26, *v1, v1[1]);
  specialized _StringGuts.replaceSubrange<A>(_:with:)(v28, v29);
  return v9;
}

{
  uint64_t v1;
  uint64_t v3;
  Swift::String::Index v4;
  Swift::String::Index v5;
  Swift::String::Index v6;

  if (!((*(void *)(v1 + 8) ^ *(void *)v1) >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  uint64_t v3 = Substring.subscript.getter(a1, *(void *)v1, *(void *)(v1 + 8), *(void *)(v1 + 16), *(void *)(v1 + 24));
  v4._Swift::UInt64 rawBits = Substring.index(after:)((Swift::String::Index)a1)._rawBits;
  if (v4._rawBits >> 14 < a1 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v5._Swift::UInt64 rawBits = v4._rawBits;
  v6._Swift::UInt64 rawBits = a1;
  specialized Substring._replaceSubrange<A>(_:with:)(v6, v5);
  return v3;
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(uint64_t a1)
{
  if (!*v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  unsigned int v2 = a1;
  if (!a1)
  {
    LODWORD(v17) = 0;
    unint64_t v14 = 105;
    goto LABEL_30;
  }
  unsigned int v18 = a1;
  MEMORY[0x1F4188790](a1);
  char v17 = &v18;
  unint64_t v4 = v3 | (v3 << 32);
  uint64_t v5 = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v15, v4, 0);
  if ((v5 & 1) == 0)
  {
    LODWORD(v17) = 0;
    unint64_t v14 = 193;
    goto LABEL_30;
  }
  unsigned int v6 = v2 >> 8;
  if (v2 >= 0x100)
  {
    unsigned int v18 = v2 >> 8;
    MEMORY[0x1F4188790](v5);
    char v17 = &v18;
    if ((specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v15, v4, 0) & 1) == 0)
    {
      LODWORD(v17) = 0;
      unint64_t v14 = 194;
      goto LABEL_30;
    }
  }
  unsigned int v7 = *v1;
  if (*v1 < v2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unsigned int v8 = 0;
  if (v7 != v2)
  {
    unsigned int v10 = *v1;
    while (1)
    {
      if (v7 < v10 || v10 <= v2) {
        goto LABEL_22;
      }
      if (HIBYTE(v8)) {
        break;
      }
      v8 |= v10 << (-(__clz(v8) & 0x18) & 0x18);
      v10 >>= 8;
      if (v10 == v2) {
        goto LABEL_9;
      }
    }
LABEL_28:
    LODWORD(v17) = 0;
    unint64_t v14 = 167;
LABEL_30:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v14, (int)v17);
  }
LABEL_9:
  if (v7 < v6)
  {
    LODWORD(v17) = 0;
    unint64_t v16 = 730;
    v15[0] = 2;
    char v13 = "Range out of bounds";
    goto LABEL_23;
  }
  if (v2 >= 0x100)
  {
    unsigned int v11 = v2 >> 8;
    while (v6 >= v11)
    {
      if (HIBYTE(v8)) {
        goto LABEL_28;
      }
      v8 |= v11 << (-(__clz(v8) & 0x18) & 0x18);
      BOOL v12 = v11 >= 0x100;
      v11 >>= 8;
      if (!v12) {
        goto LABEL_11;
      }
    }
LABEL_22:
    LODWORD(v17) = 0;
    unint64_t v16 = 714;
    v15[0] = 2;
    char v13 = "Index out of bounds";
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v13, 19, 2, "Swift/Collection.swift", 22, v15[0], v16, (int)v17);
  }
LABEL_11:
  uint64_t result = v2 - 1;
  *uint64_t v1 = v8;
  return result;
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(Swift::String::Index a1)
{
  Swift::UInt64 v2 = *v1 >> 14;
  Swift::UInt64 v3 = v1[1] >> 14;
  if (v2 == v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  v4._Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = v1[2];
  uint64_t v5 = v1[3];
  char v7 = (v5 & 0x1000000000000000) == 0 || (v6 & 0x800000000000000) != 0;
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4 << v7;
  if ((a1._rawBits & 1) != 0 && v8 != v9)
  {
    if (a1._rawBits >> 14 >= v2 && a1._rawBits >> 14 < v3)
    {
LABEL_23:
      if ((v5 & 0x1000000000000000) == 0) {
        goto LABEL_24;
      }
LABEL_56:
      uint64_t v15 = *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(a1._rawBits & 0xFFFFFFFFFFFF0000));
      goto LABEL_41;
    }
    unint64_t v11 = 143;
LABEL_21:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v11, 0);
  }
  if (v8 == v9) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (a1._rawBits >> 14 < v2 || a1._rawBits >> 14 >= v3)
  {
    unint64_t v11 = 43;
    goto LABEL_21;
  }
  if (a1._rawBits) {
    goto LABEL_23;
  }
  a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(a1)._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
  if ((v5 & 0x1000000000000000) != 0) {
    goto LABEL_56;
  }
LABEL_24:
  Swift::UInt64 v13 = a1._rawBits >> 16;
  if ((v5 & 0x2000000000000000) != 0)
  {
    uint64_t v35 = v6;
    uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v15 = *((unsigned __int8 *)&v35 + v13);
    if (*((char *)&v35 + v13) < 0)
    {
      switch(__clz(v15 ^ 0xFF))
      {
        case 0x1Au:
          unint64_t v16 = (unsigned __int8 *)&v35 + v13;
LABEL_33:
          uint64_t v15 = v16[1] & 0x3F | ((v15 & 0x1F) << 6);
          break;
        case 0x1Bu:
          char v17 = (unsigned __int8 *)&v35 + v13;
LABEL_37:
          char v19 = v17[1];
          char v20 = v17[2];
          int v21 = ((v15 & 0xF) << 12) | ((v19 & 0x3F) << 6);
          goto LABEL_40;
        case 0x1Cu:
          unsigned int v18 = (unsigned __int8 *)&v35 + v13;
LABEL_39:
          char v22 = v18[1];
          char v23 = v18[2];
          char v20 = v18[3];
          int v21 = ((v15 & 0xF) << 18) | ((v22 & 0x3F) << 12) | ((v23 & 0x3F) << 6);
LABEL_40:
          uint64_t v15 = v21 & 0xFFFFFFC0 | v20 & 0x3F;
          break;
        default:
          break;
      }
    }
  }
  else
  {
    if ((v6 & 0x1000000000000000) != 0) {
      unint64_t v14 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      unint64_t v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, v5);
    }
    uint64_t v15 = v14[v13];
    if ((char)v14[v13] < 0)
    {
      switch(__clz(v15 ^ 0xFF))
      {
        case 0x1Au:
          unint64_t v16 = &v14[v13];
          goto LABEL_33;
        case 0x1Bu:
          char v17 = &v14[v13];
          goto LABEL_37;
        case 0x1Cu:
          unsigned int v18 = &v14[v13];
          goto LABEL_39;
        default:
          break;
      }
    }
  }
LABEL_41:
  uint64_t v25 = v1[2];
  uint64_t v24 = v1[3];
  v26._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v4)._rawBits;
  if ((v24 & 0x1000000000000000) != 0)
  {
    v32._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v26)._rawBits;
  }
  else
  {
    Swift::UInt64 v27 = v26._rawBits >> 16;
    if ((v24 & 0x2000000000000000) != 0)
    {
      uint64_t v35 = v25;
      uint64_t v36 = v24 & 0xFFFFFFFFFFFFFFLL;
      int v29 = *((unsigned __int8 *)&v35 + v27);
    }
    else
    {
      if ((v25 & 0x1000000000000000) != 0) {
        Swift::UInt64 v28 = (unsigned __int8 *)((v24 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v28 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v25, v24);
      }
      int v29 = v28[v27];
    }
    int v30 = (char)v29;
    unsigned int v31 = __clz(v29 ^ 0xFF) - 24;
    if (v30 >= 0) {
      LOBYTE(v3_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 1;
    }
    v32._Swift::UInt64 rawBits = ((v27 + v31) << 16) | 5;
  }
  if (v32._rawBits >> 14 < v4._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v33._Swift::UInt64 rawBits = v4._rawBits;
  specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v33, v32);
  return v15;
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(unsigned int a1)
{
  unint64_t v2 = *((unsigned __int8 *)v1 + 4);
  if (!*((unsigned char *)v1 + 4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  if (a1 >= 0xF0u) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unsigned int v3 = *v1;
  unsigned int v4 = a1 + 16;
  if (v2 < a1) {
    goto LABEL_9;
  }
  unsigned int v5 = (a1 + 16);
  if (v2 < v5) {
    unsigned int v5 = *((unsigned __int8 *)v1 + 4);
  }
  if (v5 != v4) {
LABEL_9:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xD4uLL, 0);
  uint64_t v6 = -((int)((a1 + 16)
             - a1
             + ((((a1 + 16) - a1) & 0xF000u) >> 12)) >> 4);
  if ((uint64_t)(v6 + (v2 >> 4)) >= 3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xDDuLL, 0);
  }
  *uint64_t v1 = (v3 >> ((v4 >> 1) & 0x18) >> ((v4 >> 1) & 0x18) << ((16 * v6 + v4) & 0x10)) | v3 & ((1 << ((a1 >> 1) & 0x18) << ((a1 >> 1) & 0x18))
                                                                                          - 1);
  *((unsigned char *)v1 + 4) = v2 + 16 * v6;
  return v3 >> a1;
}

{
  unsigned int *v1;
  unint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  unint64_t v2 = *((unsigned __int8 *)v1 + 4);
  if (!*((unsigned char *)v1 + 4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  if (a1 >= 0xF8u) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unsigned int v3 = *v1;
  unsigned int v4 = a1 + 8;
  if (v2 < a1) {
    goto LABEL_9;
  }
  unsigned int v5 = (a1 + 8);
  if (v2 < v5) {
    unsigned int v5 = *((unsigned __int8 *)v1 + 4);
  }
  if (v5 != v4) {
LABEL_9:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xD4uLL, 0);
  uint64_t v6 = -((int)((a1 + 8)
             - a1
             + ((((a1 + 8) - a1) & 0xE000u) >> 13)) >> 3);
  if ((uint64_t)(v6 + (v2 >> 3)) >= 5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xDDuLL, 0);
  }
  *uint64_t v1 = (v3 >> ((v4 >> 1) & 0x1C) >> ((v4 >> 1) & 0x1C) << ((8 * v6 + v4) & 0x18)) | v3 & ((1 << ((a1 >> 1) & 0x1C) << ((a1 >> 1) & 0x1C))
                                                                                         - 1);
  *((unsigned char *)v1 + 4) = v2 + 8 * v6;
  return v3 >> a1;
}

uint64_t RangeReplaceableCollection.remove(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v71 = a3;
  uint64_t v72 = a4;
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v9 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v11 = (char *)&v61 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  unint64_t v70 = (char *)&v61 - v13;
  uint64_t v14 = *(void *)(a2 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  char v17 = (char *)&v61 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v77 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v74 = (char *)&v61 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v73 = (char *)&v61 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v76 = (char *)&v61 - v22;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v25 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v24);
  uint64_t v69 = (uint64_t)*(v25 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v25);
  int64_t v67 = (char *)&v61 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  char v68 = (char *)&v61 - v28;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v7 + 104))(a2, v7)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove from an empty collection", 37, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x222uLL, 0);
  }
  uint64_t v64 = v25;
  int64_t v65 = v11;
  int v29 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v7 + 80))(v78, a1, a2, v7);
  uint64_t v31 = v30;
  Swift::String::Index v32 = swift_getAssociatedTypeWitness(0, *(int ***)(v7 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  Swift::String::Index v33 = *(void (**)(uint64_t, uint64_t))(*((void *)v32 - 1) + 16);
  uint64_t v63 = v32;
  v33(v72, v31);
  v29(v78, 0);
  unint64_t v34 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v72 = v4;
  v34(v17, v4, a2);
  uint64_t v35 = v76;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 184))(a1, a2, v7);
  uint64_t v36 = *(void (**)(char *, uint64_t))(v14 + 8);
  uint64_t v66 = a2;
  v36(v17, a2);
  uint64_t v37 = *(void (**)(char *, uint64_t, const char *))(v77 + 16);
  uint64_t v38 = v73;
  v37(v73, a1, AssociatedTypeWitness);
  uint64_t v39 = v74;
  v37(v74, (uint64_t)v35, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v38, v39, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v40 = v77;
  }
  uint64_t v41 = *(void (**)(char *, const char *))(v77 + 8);
  uint64_t v62 = v41;
  v41(v39, AssociatedTypeWitness);
  v41(v38, AssociatedTypeWitness);
  uint64_t v42 = TupleTypeMetadata2;
  uint64_t v43 = v70;
  uint64_t v44 = &v70[*((int *)TupleTypeMetadata2 + 12)];
  v37(v70, a1, AssociatedTypeWitness);
  uint64_t v45 = *(void (**)(char *, char *, const char *))(v40 + 32);
  unint64_t v74 = v44;
  v45(v44, v76, AssociatedTypeWitness);
  uint64_t v46 = *((int *)v42 + 12);
  char v47 = v65;
  uint64_t v48 = &v65[v46];
  v37(v65, (uint64_t)v43, AssociatedTypeWitness);
  v37(v48, (uint64_t)v44, AssociatedTypeWitness);
  uint64_t v49 = v67;
  v45(v67, v47, AssociatedTypeWitness);
  uint64_t v50 = v62;
  v62(v48, AssociatedTypeWitness);
  uint64_t v51 = &v47[*((int *)TupleTypeMetadata2 + 12)];
  v45(v47, v43, AssociatedTypeWitness);
  v45(v51, v74, AssociatedTypeWitness);
  unint64_t v52 = v64;
  v45(&v49[*((int *)v64 + 9)], v51, AssociatedTypeWitness);
  v50(v47, AssociatedTypeWitness);
  uint64_t v54 = v68;
  uint64_t v53 = v69;
  (*(void (**)(char *, char *, Class *))(v69 + 32))(v68, v49, v52);
  uint64_t v55 = *(void (**)(char *))(v71 + 32);
  uint64_t v58 = (unint64_t *)type metadata accessor for EmptyCollection(0, (uint64_t)v63, v56, v57);
  swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, v58, v59);
  v55(v54);
  return (*(uint64_t (**)(char *, Class *))(v53 + 8))(v54, v52);
}

uint64_t RangeReplaceableCollection._customRemoveLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return RangeReplaceableCollection._customRemoveLast()(a1, a2, a3);
}

{
  const char *AssociatedTypeWitness;
  uint64_t (*v5)(uint64_t, uint64_t, uint64_t, const char *);
  uint64_t vars8;

  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a2 + 8) + 8), a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unsigned int v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56);

  return v5(a3, 1, 1, AssociatedTypeWitness);
}

void specialized RangeReplaceableCollection.removeAll(keepingCapacity:)(char a1)
{
  if (a1)
  {
    unint64_t v2 = *v1;
    unint64_t v3 = v1[1];
    uint64_t v4 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000) == 0) {
      uint64_t v4 = *v1;
    }
    uint64_t v5 = 7;
    if (((v3 >> 60) & ((v2 & 0x800000000000000) == 0)) != 0) {
      uint64_t v5 = 11;
    }
    v6._Swift::UInt64 rawBits = v5 | (v4 << 16);
    v7._Swift::UInt64 rawBits = 15;
    Swift::UInt64 v8 = _StringGuts.validateScalarRange_5_7(_:)(v7, v6, v2, v3);
    specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, v9);
  }
  else
  {
    swift_bridgeObjectRelease(v1[1]);
    *uint64_t v1 = 0;
    v1[1] = 0xE000000000000000;
  }
}

double specialized RangeReplaceableCollection.removeAll(keepingCapacity:)(char a1)
{
  if (a1)
  {
    v2._Swift::UInt64 rawBits = *v1;
    v3._Swift::UInt64 rawBits = v1[1];
    if (v3._rawBits >> 14 < *v1 >> 14) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v2, v3);
  }
  else
  {
    swift_bridgeObjectRelease(v1[3]);
    *(void *)&double result = 15;
    *(_OWORD *)uint64_t v1 = xmmword_18162ACC0;
    v1[2] = 0;
    v1[3] = 0xE000000000000000;
  }
  return result;
}

{
  Swift::UInt64 *v1;
  Swift::String::Index v2;
  Swift::String::Index v3;
  double result;
  uint64_t vars8;

  if (a1)
  {
    v2._Swift::UInt64 rawBits = *v1;
    v3._Swift::UInt64 rawBits = v1[1];
    if (v3._rawBits >> 14 < *v1 >> 14) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    specialized Substring._replaceSubrange<A>(_:with:)(v2, v3);
  }
  else
  {
    swift_bridgeObjectRelease(v1[3]);
    *(void *)&double result = 15;
    *(_OWORD *)uint64_t v1 = xmmword_18162ACC0;
    v1[2] = 0;
    v1[3] = 0xE000000000000000;
  }
  return result;
}

uint64_t specialized RangeReplaceableCollection.removeAll(keepingCapacity:)(uint64_t result)
{
  if ((result & 1) != 0 && (uint64_t v2 = *v1, v2))
  {
    unsigned int v9 = *v1;
    MEMORY[0x1F4188790](result);
    Swift::UInt64 v8 = &v9;
    double result = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v7, v2 | (v2 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v8) = 0;
      unint64_t v6 = 193;
      goto LABEL_18;
    }
    unsigned int v3 = *v1;
    if (*v1 < v2) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    unsigned int v4 = 0;
    if (v3 != v2)
    {
      unsigned int v5 = *v1;
      while (1)
      {
        if (v3 < v5 || v2 >= v5) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
        }
        if (HIBYTE(v4)) {
          break;
        }
        v4 |= v5 << (-(__clz(v4) & 0x18) & 0x18);
        v5 >>= 8;
        if (v5 == v2) {
          goto LABEL_13;
        }
      }
      LODWORD(v8) = 0;
      unint64_t v6 = 167;
LABEL_18:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v6, (int)v8);
    }
  }
  else
  {
    unsigned int v4 = 0;
  }
LABEL_13:
  *uint64_t v1 = v4;
  return result;
}

Swift::Void __swiftcall RangeReplaceableCollection.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  unint64_t v6 = *(int ***)(v2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v69 = (char *)&v59 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  char v68 = (char *)&v59 - v11;
  uint64_t v12 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v70 = (char *)&v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  char v17 = (char *)&v59 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v72 = (char *)&v59 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v21 = (char *)&v59 - v20;
  uint64_t v73 = v6;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v24 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v23);
  uint64_t v25 = MEMORY[0x1F4188790](v24);
  uint64_t v26 = MEMORY[0x1F4188790](v25);
  if (keepingCapacity)
  {
    uint64_t v62 = v29;
    uint64_t v63 = (char *)&v59 - v27;
    uint64_t v64 = v28;
    uint64_t v65 = v26;
    uint64_t v67 = v3;
    uint64_t v30 = v73;
    ((void (*)(uint64_t, int **))v73[8])(v4, v73);
    uint64_t v31 = v30[9];
    Swift::String::Index v32 = v72;
    uint64_t v66 = v4;
    ((void (*)(uint64_t, int **))v31)(v4, v30);
    Swift::String::Index v33 = (void (*)(char *, char *, const char *))v12[2];
    v33(v17, v21, AssociatedTypeWitness);
    unint64_t v34 = v70;
    v33(v70, v32, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v17, v34, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
    uint64_t v35 = (void (*)(char *, const char *))v12[1];
    }
    uint64_t v61 = v35;
    v35(v34, AssociatedTypeWitness);
    v35(v17, AssociatedTypeWitness);
    uint64_t v36 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v37 = TupleTypeMetadata2;
    unint64_t v60 = v33;
    uint64_t v38 = v68;
    uint64_t v39 = &v68[v36];
    uint64_t v40 = (void (*)(char *, char *, const char *))v12[4];
    v40(v68, v21, AssociatedTypeWitness);
    unint64_t v70 = v39;
    v40(v39, v72, AssociatedTypeWitness);
    uint64_t v41 = v69;
    uint64_t v42 = &v69[*((int *)v37 + 12)];
    uint64_t v43 = v60;
    v60(v69, v38, AssociatedTypeWitness);
    v43(v42, v39, AssociatedTypeWitness);
    uint64_t v44 = v62;
    v40(v62, v41, AssociatedTypeWitness);
    uint64_t v45 = v42;
    uint64_t v46 = v61;
    v61(v45, AssociatedTypeWitness);
    char v47 = &v41[*((int *)TupleTypeMetadata2 + 12)];
    v40(v41, v38, AssociatedTypeWitness);
    v40(v47, v70, AssociatedTypeWitness);
    uint64_t v48 = v65;
    v40(&v44[*(int *)(v65 + 36)], v47, AssociatedTypeWitness);
    v46(v41, AssociatedTypeWitness);
    uint64_t v50 = v63;
    uint64_t v49 = v64;
    uint64_t v51 = v44;
    uint64_t v52 = v48;
    (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v63, v51, v48);
    uint64_t v53 = *(void (**)(char *))(v67 + 32);
    uint64_t v54 = swift_getAssociatedTypeWitness(255, (int **)v73[1], v66, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    uint64_t v57 = (unint64_t *)type metadata accessor for EmptyCollection(0, (uint64_t)v54, v55, v56);
    swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, v57, v58);
    v53(v50);
    (*(void (**)(char *, uint64_t))(v49 + 8))(v50, v52);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(v74, v4);
    (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v4, v3);
  }
}

uint64_t RangeReplaceableCollection.removeAll(where:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeReplaceableCollection.removeAll(where:)(a1, a2, a3, a4);
}

{
  uint64_t v4;
  int **v6;
  const char *AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  Class *v14;
  uint64_t v15;
  char *v16;
  int **v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t);
  int **v27;
  uint64_t AssociatedConformanceWitness;
  void (*v29)(int **, uint64_t);
  int **v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int (*v33)(char *, uint64_t, const char *);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v38;
  void (*v39)(char *, char *, const char *);
  void (*v40)(char *, char *, const char *);
  char *v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int (*v54)(char *, uint64_t, const char *);
  uint64_t v55;
  void (*v56)(int **, uint64_t);
  uint64_t (*v57)(char *);
  uint64_t v58;
  char *v59;
  int **v60;

  uint64_t v53 = a4;
  uint64_t v57 = a1;
  uint64_t v58 = a2;
  unint64_t v60 = *(int ***)(*(void *)(a4 + 8) + 8);
  unint64_t v6 = v60;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v60, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v44 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v11 = (char *)&v44 - v10;
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v12, v13);
  MEMORY[0x1F4188790](v14 - 1);
  uint64_t v16 = (char *)&v44 - v15;
  char v17 = (int **)swift_getAssociatedTypeWitness(0, v6, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v46 = (uint64_t)*(v17 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v17);
  uint64_t v20 = (char *)&v44 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v44 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v45 = v24;
  (*(void (**)(char *, uint64_t, uint64_t))(v24 + 16))((char *)&v44 - v25, v47, a3);
  uint64_t v26 = *(void (**)(uint64_t))(v53 + 24);
  uint64_t v51 = v23;
  v26(a3);
  uint64_t v27 = v60;
  ((void (*)(uint64_t))v60[4])(a3);
  uint64_t v52 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v27, a3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int v29 = *(void (**)(int **, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v59 = v20;
  unint64_t v60 = v17;
  uint64_t v30 = v17;
  uint64_t v31 = AssociatedConformanceWitness;
  uint64_t v56 = v29;
  v29(v30, AssociatedConformanceWitness);
  Swift::String::Index v32 = v49;
  Swift::String::Index v33 = *(unsigned int (**)(char *, uint64_t, const char *))(v49 + 48);
  if (v33(v16, 1, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    unint64_t v34 = v45;
    uint64_t v35 = v47;
    uint64_t v36 = v52;
    (*(void (**)(uint64_t, uint64_t))(v45 + 8))(v47, v52);
    (*(void (**)(char *, int **))(v46 + 8))(v59, v60);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v34 + 32))(v35, v51, v36);
  }
  else
  {
    uint64_t v54 = v33;
    uint64_t v55 = v31;
    uint64_t v40 = *(void (**)(char *, char *, const char *))(v32 + 32);
    uint64_t v38 = v32 + 32;
    uint64_t v39 = v40;
    uint64_t v48 = v53 + 64;
    uint64_t v49 = v38 - 24;
    while (1)
    {
      uint64_t v42 = v38;
      v39(v11, v16, AssociatedTypeWitness);
      uint64_t v43 = v57(v11);
      if (v4) {
        break;
      }
      if (v43)
      {
        (*(void (**)(char *, const char *))v49)(v11, AssociatedTypeWitness);
      }
      else
      {
        uint64_t v41 = v50;
        v39(v50, v11, AssociatedTypeWitness);
        (*(void (**)(char *, uint64_t))(v53 + 64))(v41, v52);
      }
      v56(v60, v55);
      uint64_t v38 = v42;
      if (v54(v16, 1, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }
    (*(void (**)(char *, const char *))v49)(v11, AssociatedTypeWitness);
    (*(void (**)(char *, int **))(v46 + 8))(v59, v60);
    return (*(uint64_t (**)(char *, uint64_t))(v45 + 8))(v51, v52);
  }
}

void specialized RangeReplaceableCollection.removeAll(where:)(uint64_t (*a1)(void *))
{
  unint64_t v4 = v1[1];
  unint64_t v5 = 0xE000000000000000;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    uint64_t v6 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  v22[2] = *v1;
  v22[3] = v4;
  v22[4] = 0;
  unint64_t v22[5] = v6;
  unint64_t v23 = 0;
  unint64_t v25 = v4;
  swift_bridgeObjectRetain(v4);
  Swift::String_optional v7 = String.Iterator.next()();
  if (v7.value._object)
  {
    uint64_t countAndFlagsBits = v7.value._countAndFlagsBits;
    unint64_t object = (unint64_t)v7.value._object;
    while (1)
    {
      v22[0] = countAndFlagsBits;
      v22[1] = object;
      char v12 = a1(v22);
      if (v2)
      {
        swift_bridgeObjectRelease(v25);
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease(v24);
        return;
      }
      if ((v12 & 1) == 0)
      {
        uint64_t v13 = v24;
        unint64_t v14 = HIBYTE(v24) & 0xF;
        if ((v24 & 0x2000000000000000) == 0) {
          unint64_t v14 = v23 & 0xFFFFFFFFFFFFLL;
        }
        if (!v14 && (v23 & ~v24 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v24);
          unint64_t v23 = countAndFlagsBits;
          unint64_t v24 = object;
          goto LABEL_10;
        }
        if ((object & 0x2000000000000000 & v24) != 0)
        {
          unint64_t v15 = specialized _SmallString.init(_:appending:)(v23, v24, countAndFlagsBits, object);
          if ((v17 & 1) == 0)
          {
            unint64_t v18 = v15;
            unint64_t v19 = v16;
            swift_bridgeObjectRelease(object);
            swift_bridgeObjectRelease(v13);
            unint64_t v23 = v18;
            unint64_t v24 = v19;
            goto LABEL_10;
          }
        }
        if ((object & 0x2000000000000000) != 0) {
          uint64_t v10 = HIBYTE(object) & 0xF;
        }
        else {
          uint64_t v10 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        _StringGuts.append(_:)(countAndFlagsBits, object, 0, v10);
      }
      swift_bridgeObjectRelease(object);
LABEL_10:
      Swift::String_optional v11 = String.Iterator.next()();
      uint64_t countAndFlagsBits = v11.value._countAndFlagsBits;
      unint64_t object = (unint64_t)v11.value._object;
      if (!v11.value._object)
      {
        unint64_t v20 = v23;
        unint64_t v5 = v24;
        goto LABEL_23;
      }
    }
  }
  unint64_t v20 = 0;
LABEL_23:
  swift_bridgeObjectRelease_n(v25, 2);
  *uint64_t v21 = v20;
  v21[1] = v5;
}

void specialized RangeReplaceableCollection.removeAll(where:)(uint64_t (*a1)(void *), uint64_t a2)
{
  uint64_t v34 = a2;
  uint64_t v5 = *v2;
  unint64_t v4 = v2[1];
  unint64_t v6 = 0xE000000000000000;
  unint64_t v32 = 0;
  uint64_t v33 = 0xE000000000000000;
  if ((v4 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(v4) & 0xF;
  }
  else {
    uint64_t v7 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    unint64_t v28 = 0;
    goto LABEL_27;
  }
  swift_bridgeObjectRetain(v4);
  for (uint64_t i = 0; i < v7; i += v16)
  {
    if ((v4 & 0x1000000000000000) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v14 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(i << 16));
      Swift::Int scalarLength = v14.scalarLength;
      unsigned int value = v14._0._value;
    }
    else
    {
      if ((v4 & 0x2000000000000000) != 0)
      {
        v31[0] = v5;
        v31[1] = v4 & 0xFFFFFFFFFFFFFFLL;
        Swift::String_optional v11 = v31;
      }
      else
      {
        Swift::String_optional v11 = (void *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v5 & 0x1000000000000000) == 0) {
          Swift::String_optional v11 = _StringObject.sharedUTF8.getter(v5, v4);
        }
      }
      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v11, v8, i);
    }
    unsigned int v15 = value;
    Swift::Int v16 = scalarLength;
    LODWORD(v31[0]) = value;
    char v17 = a1(v31);
    if (v3)
    {
      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(v33);
      return;
    }
    if ((v17 & 1) == 0)
    {
      uint64_t v19 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v15);
      unint64_t v20 = v18;
      uint64_t v21 = v33;
      if ((v33 & 0x2000000000000000) == 0)
      {
        if ((v18 & 0x2000000000000000) != 0) {
LABEL_24:
        }
          uint64_t v10 = HIBYTE(v20) & 0xF;
        else {
LABEL_6:
        }
          uint64_t v10 = v19 & 0xFFFFFFFFFFFFLL;
        _StringGuts.append(_:)(v19, v20, 0, v10);
        swift_bridgeObjectRelease(v20);
        continue;
      }
      if ((v18 & 0x2000000000000000) == 0) {
        goto LABEL_6;
      }
      unint64_t v22 = specialized _SmallString.init(_:appending:)(v32, v33, v19, v18);
      if (v24) {
        goto LABEL_24;
      }
      unint64_t v25 = v22;
      uint64_t v26 = v20;
      uint64_t v27 = v23;
      swift_bridgeObjectRelease(v26);
      swift_bridgeObjectRelease(v21);
      unint64_t v32 = v25;
      uint64_t v33 = v27;
    }
  }
  swift_bridgeObjectRelease(v4);
  uint64_t v2 = (uint64_t *)v29;
  unint64_t v4 = *(void *)(v29 + 8);
  unint64_t v28 = v32;
  unint64_t v6 = v33;
LABEL_27:
  swift_bridgeObjectRelease(v4);
  uint64_t *v2 = v28;
  v2[1] = v6;
}

{
  unint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  Swift::UInt64 rawBits;
  Swift::UInt64 v11;
  Swift::String::Index v12;
  unint64_t v13;
  Swift::UInt64 v14;
  Swift::UInt64 v15;
  char v16;
  Swift::String::Index v17;
  Swift::String::Index v18;
  void v20[2];
  Swift::String::Index v21[2];
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;

  char v24 = a2;
  unint64_t v4 = *v2;
  uint64_t v5 = v2[1];
  uint64_t v7 = v2[2];
  unint64_t v6 = v2[3];
  *(_OWORD *)&v21[0]._Swift::UInt64 rawBits = xmmword_18162ACC0;
  uint64_t v8 = 0xE000000000000000;
  unint64_t v22 = 0;
  uint64_t v23 = 0xE000000000000000;
  if ((v4 ^ v5) >= 0x4000)
  {
    v12._Swift::UInt64 rawBits = v4;
    while (1)
    {
      uint64_t v13 = Substring.subscript.getter(v12._rawBits, v4, v5, v7, v6);
      unsigned int v15 = v14;
      v12._Swift::UInt64 rawBits = Substring.index(after:)(v12)._rawBits;
      v20[0] = v13;
      v20[1] = v15;
      Swift::Int v16 = a1(v20);
      if (v3) {
        break;
      }
      if ((v16 & 1) == 0)
      {
        v17._Swift::UInt64 rawBits = v21[1]._rawBits;
        v18._Swift::UInt64 rawBits = v21[1]._rawBits;
        specialized Substring._replaceSubrange<A>(_:with:)(v17, v18, v13, v15);
      }
      swift_bridgeObjectRelease(v15);
      if ((v12._rawBits ^ v5) < 0x4000)
      {
        Swift::UInt64 rawBits = v21[0]._rawBits;
        Swift::String_optional v11 = v21[1]._rawBits;
        uint64_t v9 = v22;
        uint64_t v8 = v23;
        goto LABEL_9;
      }
    }
    swift_bridgeObjectRelease(v15);
    swift_bridgeObjectRelease(v23);
  }
  else
  {
    uint64_t v9 = 0;
    Swift::UInt64 rawBits = 15;
    Swift::String_optional v11 = 7;
LABEL_9:
    swift_bridgeObjectRelease(v6);
    uint64_t *v2 = rawBits;
    v2[1] = v11;
    v2[2] = v9;
    v2[3] = v8;
  }
}

void specialized RangeReplaceableCollection.removeAll(where:)(uint64_t (*a1)(uint64_t *), uint64_t a2)
{
  unint64_t v6 = *v2;
  unint64_t v7 = v2[1];
  uint64_t v9 = v2[2];
  unint64_t v8 = v2[3];
  *(_OWORD *)&v39[0]._Swift::UInt64 rawBits = xmmword_18162ACC0;
  unint64_t v10 = 0xE000000000000000;
  Swift::UInt64 v40 = 0;
  unint64_t v41 = 0xE000000000000000;
  swift_bridgeObjectRetain(v8);
  if ((v6 ^ v7) >= 0x4000)
  {
    uint64_t v36 = a1;
    uint64_t v42 = a2;
    v16._Swift::UInt64 rawBits = v6;
    do
    {
      v17._Swift::UInt64 rawBits = v16._rawBits;
      v18._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(v17, v6, v7, v9, v8)._rawBits;
      if ((v8 & 0x1000000000000000) != 0)
      {
        int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v18._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
        v33._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v16)._rawBits;
        v16._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v33)._rawBits;
      }
      else
      {
        Swift::UInt64 v20 = v18._rawBits >> 16;
        if ((v8 & 0x2000000000000000) != 0)
        {
          uint64_t v37 = v9;
          uint64_t v38 = v8 & 0xFFFFFFFFFFFFFFLL;
          int value = _decodeScalar(_:startingAt:)((uint64_t)&v37, v19._rawBits, v20);
          Swift::UInt64 v25 = _StringGuts.validateScalarIndex(_:)(v16)._rawBits >> 16;
          uint64_t v37 = v9;
          uint64_t v38 = v8 & 0xFFFFFFFFFFFFFFLL;
          int v26 = *((unsigned __int8 *)&v37 + v25);
        }
        else
        {
          id v21 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v9 & 0x1000000000000000) == 0) {
            id v21 = _StringObject.sharedUTF8.getter(v9, v8);
          }
          int v22 = _decodeScalar(_:startingAt:)((uint64_t)v21, v19._rawBits, v20);
          v23._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v16)._rawBits;
          char v24 = (unsigned __int8 *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v9 & 0x1000000000000000) == 0) {
            char v24 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v8);
          }
          Swift::UInt64 v25 = v23._rawBits >> 16;
          int v26 = v24[v23._rawBits >> 16];
          int value = v22;
        }
        int v28 = (char)v26;
        unsigned int v29 = __clz(v26 ^ 0xFF) - 24;
        if (v28 >= 0) {
          LOBYTE(v29) = 1;
        }
        v16._Swift::UInt64 rawBits = ((v25 + v29) << 16) | 5;
      }
      LODWORD(v37) = value;
      char v30 = v36(&v37);
      if (v3)
      {
        uint64_t v34 = v41;
        swift_bridgeObjectRelease(v8);
        swift_bridgeObjectRelease(v34);
        return;
      }
      if ((v30 & 1) == 0)
      {
        v31._Swift::UInt64 rawBits = v39[1]._rawBits;
        v32._Swift::UInt64 rawBits = v39[1]._rawBits;
        specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v31, v32);
      }
    }
    while ((v16._rawBits ^ v7) >= 0x4000);
    unsigned int v15 = v35;
    uint64_t v14 = v35[3];
    Swift::UInt64 rawBits = v39[0]._rawBits;
    Swift::UInt64 v13 = v39[1]._rawBits;
    Swift::UInt64 v11 = v40;
    unint64_t v10 = v41;
  }
  else
  {
    Swift::UInt64 v11 = 0;
    Swift::UInt64 rawBits = 15;
    Swift::UInt64 v13 = 7;
    uint64_t v14 = v8;
    unsigned int v15 = v35;
  }
  swift_bridgeObjectRelease(v8);
  swift_bridgeObjectRelease(v14);
  *unsigned int v15 = rawBits;
  v15[1] = v13;
  void v15[2] = v11;
  v15[3] = v10;
}

uint64_t specialized RangeReplaceableCollection.removeAll(where:)(uint64_t result)
{
  unsigned int v3 = *v1;
  if (*v1)
  {
    unint64_t v4 = (uint64_t (*)(char *))result;
    unsigned int v5 = 0;
    while (1)
    {
      char v7 = v3 - 1;
      double result = v4(&v7);
      if (v2) {
        break;
      }
      if ((result & 1) == 0)
      {
        if (HIBYTE(v5)) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
        }
        v5 |= v3 << (-(__clz(v5) & 0x18) & 0x18);
      }
      BOOL v6 = v3 >= 0x100;
      v3 >>= 8;
      if (!v6) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    unsigned int v5 = 0;
LABEL_10:
    *uint64_t v1 = v5;
  }
  return result;
}

uint64_t Repeated.init(_repeating:count:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  }
  *a5 = a2;
  char v7 = (char *)a5 + *((int *)type metadata accessor for Repeated(0, a3, a3, a4) + 7);
  unint64_t v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32);

  return v8(v7, a1, a3);
}

uint64_t RangeReplaceableCollection.replaceSubrange<A, B>(_:with:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a4;
  uint64_t v25 = a7;
  uint64_t v23 = a2;
  Swift::UInt64 v13 = *(int ***)(a6 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a8, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RangeExpression, associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  Swift::String::Index v17 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = (uint64_t)*(v17 - 1);
  MEMORY[0x1F4188790](v17);
  Swift::UInt64 v20 = (char *)&v22 - v19;
  (*(void (**)(uint64_t, uint64_t, int **, uint64_t, uint64_t))(a8 + 24))(v8, a3, v13, a5, a8);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 32))(v20, v23, v24, v25, a3, a6);
  return (*(uint64_t (**)(char *, Class *))(v18 + 8))(v20, v17);
}

uint64_t RangeReplaceableCollection.removeSubrange<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = *(int ***)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RangeExpression, associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v14 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (uint64_t)*(v14 - 1);
  MEMORY[0x1F4188790](v14);
  Swift::String::Index v17 = (char *)&v19 - v16;
  (*(void (**)(uint64_t, uint64_t, int **, uint64_t, uint64_t))(a5 + 24))(v5, a2, v10, a3, a5);
  (*(void (**)(char *, uint64_t, uint64_t))(a4 + 104))(v17, a2, a4);
  return (*(uint64_t (**)(char *, Class *))(v15 + 8))(v17, v14);
}

uint64_t specialized RangeReplaceableCollection<>._customRemoveLast()()
{
  unint64_t rawBits = v0->_rawBits;
  unint64_t v2 = v0[1]._rawBits;
  Swift::UInt64 v3 = v0->_rawBits >> 14;
  if (v3 == v2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x331uLL, 0);
  }
  unint64_t v5 = v0[2]._rawBits;
  unint64_t v4 = v0[3]._rawBits;
  v6._unint64_t rawBits = Substring.index(before:)(v0[1])._rawBits;
  uint64_t v7 = Substring.subscript.getter(v6._rawBits, rawBits, v2, v5, v4);
  uint64_t v9 = v8;
  v10._unint64_t rawBits = Substring.index(before:)((Swift::String::Index)v2)._rawBits;
  if (v3 > v10._rawBits >> 14)
  {
    swift_bridgeObjectRelease(v9);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v11._unint64_t rawBits = v10._rawBits;
  v12._unint64_t rawBits = rawBits;
  Swift::UInt64 v13 = specialized Substring.subscript.getter(v12, v11, rawBits, v2, v5, v4);
  Swift::UInt64 v15 = v14;
  Swift::UInt64 v17 = v16;
  Swift::UInt64 v19 = v18;
  swift_bridgeObjectRetain(v18);
  swift_bridgeObjectRelease(v4);
  v0->_unint64_t rawBits = v13;
  v0[1]._unint64_t rawBits = v15;
  v0[2]._unint64_t rawBits = v17;
  v0[3]._unint64_t rawBits = v19;
  return v7;
}

{
  unint64_t *v0;
  Swift::UInt64 v1;
  Swift::UInt64 v2;
  unint64_t v3;
  unint64_t v4;
  Swift::String::Index v5;
  unint64_t v6;
  unsigned int v7;
  Swift::String::Index v8;
  Swift::UInt64 rawBits;
  char *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int v17;
  Swift::UInt64 v18;
  Swift::String::Index v19;
  Swift::String::Index v20;
  Swift::UInt64 v21;
  unint64_t v22;
  unint64_t v23;
  void v25[2];

  unint64_t v2 = *v0;
  uint64_t v1 = v0[1];
  Swift::UInt64 v3 = v0[2];
  unint64_t v4 = v0[3];
  v5._unint64_t rawBits = v1;
  Swift::String::Index v6 = specialized BidirectionalCollection.last.getter(*v0, v5, v3, v4);
  if ((v6 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x331uLL, 0);
  }
  uint64_t v7 = v6;
  swift_bridgeObjectRetain(v4);
  v8._unint64_t rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)v1)._rawBits;
  if (!(v8._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  unint64_t rawBits = v8._rawBits;
  if ((v4 & 0x1000000000000000) != 0)
  {
    unint64_t v18 = String.UnicodeScalarView._foreignIndex(before:)(v8)._rawBits;
    swift_bridgeObjectRelease(v4);
  }
  else
  {
    if ((v4 & 0x2000000000000000) != 0)
    {
      v25[0] = v3;
      v25[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      swift_bridgeObjectRelease(v4);
      Swift::UInt64 v14 = (char *)v25 + (rawBits >> 16);
      if ((*(v14 - 1) & 0xC0) == 0x80)
      {
        Swift::UInt64 v15 = 0;
        Swift::UInt64 v16 = v14 - 2;
        do
          Swift::UInt64 v17 = v16[v15--] & 0xC0;
        while (v17 == 128);
        Swift::UInt64 v13 = 1 - v15;
      }
      else
      {
        Swift::UInt64 v13 = 1;
      }
    }
    else
    {
      if ((v3 & 0x1000000000000000) != 0) {
        Swift::String::Index v10 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::String::Index v10 = (char *)_StringObject.sharedUTF8.getter(v3, v4);
      }
      Swift::String::Index v11 = 0;
      do
        Swift::String::Index v12 = v10[(rawBits >> 16) - 1 + v11--] & 0xC0;
      while (v12 == 128);
      swift_bridgeObjectRelease(v4);
      Swift::UInt64 v13 = -v11;
    }
    unint64_t v18 = (rawBits - (v13 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
  }
  if (v18 >> 14 < v2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  swift_bridgeObjectRetain(v4);
  v19._unint64_t rawBits = v2;
  v20._unint64_t rawBits = v18;
  id v21 = _StringGuts.validateScalarRange(_:in:)(v19, v20, v2, v1, v3, v4);
  uint64_t v23 = v22;
  swift_bridgeObjectRelease(v4);
  *uint64_t v0 = v21;
  v0[1] = v23;
  v0[2] = v3;
  v0[3] = v4;
  LOBYTE(v25[0]) = 0;
  return v7;
}

uint64_t RangeReplaceableCollection<>._customRemoveLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v89 = a3;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v88 = (char *)&v75 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v83 = (char *)&v75 - v11;
  uint64_t v92 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v95 = (char *)&v75 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v93 = (char *)&v75 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v90 = (char *)&v75 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v94 = (char *)&v75 - v19;
  MEMORY[0x1F4188790](v18);
  unint64_t v100 = (char *)&v75 - v20;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v22 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  uint64_t v86 = (uint64_t)*(v22 - 1);
  unint64_t v87 = v22;
  uint64_t v23 = MEMORY[0x1F4188790](v22);
  uint64_t v84 = (char *)&v75 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  unint64_t v85 = (char *)&v75 - v26;
  uint64_t v27 = *(void *)(a1 - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  char v30 = (char *)&v75 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v28);
  uint64_t v101 = (char *)&v75 - v31;
  Swift::String::Index v32 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v35 = type metadata accessor for Optional(0, (uint64_t)v32, v33, v34);
  uint64_t v36 = MEMORY[0x1F4188790](v35 - 1);
  uint64_t v38 = (char *)&v75 - v37;
  MEMORY[0x1F4188790](v36);
  unint64_t v98 = (char *)&v75 - v39;
  uint64_t v96 = a2;
  uint64_t v40 = a2;
  uint64_t v42 = v41;
  BidirectionalCollection.last.getter(a1, v40, (uint64_t)v38);
  uint64_t v99 = v42;
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v42 + 48))(v38, 1, v32) == 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x331uLL, 0);
  }
  uint64_t v43 = *(void (**)(uint64_t, char *, const char *))(v99 + 32);
  unint64_t v80 = v32;
  uint64_t v79 = v99 + 32;
  uint64_t v78 = v43;
  v43((uint64_t)v98, v38, v32);
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v27 + 16);
  v44(v101, v3, a1);
  uint64_t v45 = v100;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a1, v6);
  v44(v30, v3, a1);
  uint64_t v46 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  char v47 = v90;
  uint64_t v82 = v6;
  v46(a1, v6);
  uint64_t v48 = *(void (**)(uint64_t, uint64_t))(v27 + 8);
  uint64_t v81 = v3;
  v48(v3, a1);
  uint64_t v49 = v94;
  (*(void (**)(char *, uint64_t))(v96 + 32))(v47, a1);
  uint64_t v50 = v92;
  uint64_t v96 = *(void *)(v92 + 8);
  ((void (*)(char *, const char *))v96)(v47, AssociatedTypeWitness);
  unint64_t v90 = (char *)(v27 + 8);
  uint64_t v77 = (void (*)(char *, char *))v48;
  v48((uint64_t)v30, a1);
  uint64_t v51 = v50;
  uint64_t v52 = *(void (**)(char *, char *, const char *))(v50 + 16);
  uint64_t v53 = v93;
  v52(v93, v45, AssociatedTypeWitness);
  uint64_t v54 = v95;
  uint64_t v76 = v52;
  v52(v95, v49, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *))(AssociatedConformanceWitness + 24))(v53, v54, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v55 = v54;
  }
  uint64_t v56 = (void (*)(char *, const char *))v96;
  ((void (*)(char *, const char *))v96)(v55, AssociatedTypeWitness);
  v56(v53, AssociatedTypeWitness);
  unint64_t v95 = (char *)a1;
  uint64_t v57 = TupleTypeMetadata2;
  uint64_t v58 = v83;
  uint64_t v59 = &v83[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v60 = *(void (**)(char *, char *, const char *))(v51 + 32);
  v60(v83, v100, AssociatedTypeWitness);
  v60(v59, v49, AssociatedTypeWitness);
  uint64_t v61 = v88;
  uint64_t v62 = &v88[*((int *)v57 + 12)];
  uint64_t v63 = v76;
  v76(v88, v58, AssociatedTypeWitness);
  v63(v62, v59, AssociatedTypeWitness);
  uint64_t v64 = v84;
  v60(v84, v61, AssociatedTypeWitness);
  uint64_t v65 = (void (*)(char *, const char *))v96;
  ((void (*)(char *, const char *))v96)(v62, AssociatedTypeWitness);
  uint64_t v66 = &v61[*((int *)TupleTypeMetadata2 + 12)];
  v60(v61, v58, AssociatedTypeWitness);
  v60(v66, v59, AssociatedTypeWitness);
  uint64_t v67 = v87;
  v60(&v64[*((int *)v87 + 9)], v66, AssociatedTypeWitness);
  v65(v61, AssociatedTypeWitness);
  uint64_t v69 = v85;
  uint64_t v68 = v86;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v85, v64, v67);
  unint64_t v70 = v101;
  uint64_t v71 = v95;
  (*(void (**)(char *, char *))(v82 + 88))(v69, v95);
  (*(void (**)(char *, Class *))(v68 + 8))(v69, v67);
  v77(v70, v71);
  uint64_t v72 = v89;
  uint64_t v73 = v80;
  v78(v89, v98, v80);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v99 + 56))(v72, 0, 1, v73);
}

uint64_t RangeReplaceableCollection<>.removeLast(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeReplaceableCollection<>.removeLast(_:)(a1, a2, a3, a4, 0x37CuLL, (void (*)(char *, char *, const char *))0x383);
}

{
  return RangeReplaceableCollection<>.removeLast(_:)(a1, a2, a3, a4, 0x3C6uLL, (void (*)(char *, char *, const char *))0x3CD);
}

uint64_t RangeReplaceableCollection<>.popLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v32 = a3;
  uint64_t v33 = a4;
  uint64_t v29 = a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v30 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v29 - v10;
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v5 + 8), a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)v12, v13, v14);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v29 - v18;
  uint64_t v34 = *((void *)v12 - 1);
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v29 - v20;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v5 + 104))(a1, v5))
  {
    uint64_t v22 = v33;
    uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(v34 + 56);
    return v23((uint64_t)v22, 1, 1, v12);
  }
  else
  {
    (*(void (**)(uint64_t))(v32 + 112))(a1);
    if ((*(unsigned int (**)(char *, uint64_t, const char *))(v34 + 48))(v19, 1, v12) == 1)
    {
      (*(void (**)(char *, Class *))(v16 + 8))(v19, v15);
      (*(void (**)(uint64_t, uint64_t))(v5 + 72))(a1, v5);
      (*(void (**)(char *, uint64_t))(v29 + 32))(v9, a1);
      uint64_t v25 = v31;
      uint64_t v26 = *(void (**)(char *, const char *))(v30 + 8);
      v26(v9, v31);
      uint64_t v27 = v33;
      (*(void (**)(char *, uint64_t))(v32 + 96))(v11, a1);
      v26(v11, v25);
    }
    else
    {
      uint64_t v28 = *(void (**)(char *, char *, const char *))(v34 + 32);
      v28(v21, v19, v12);
      uint64_t v27 = v33;
      v28(v33, v21, v12);
    }
    return (*(uint64_t (**)(char *, void, uint64_t, const char *))(v34 + 56))(v27, 0, 1, v12);
  }
}

uint64_t RangeReplaceableCollection<>.removeLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v27 = a4;
  uint64_t v28 = a2;
  uint64_t v31 = a5;
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a1, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v29 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v30 = AssociatedTypeWitness;
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v26 - v12;
  uint64_t v14 = swift_getAssociatedTypeWitness(255, *(int ***)(v7 + 8), a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v17 = type metadata accessor for Optional(0, (uint64_t)v14, v15, v16);
  uint64_t v18 = (uint64_t)*(v17 - 1);
  MEMORY[0x1F4188790](v17);
  uint64_t v20 = (char *)&v26 - v19;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v7 + 104))(a1, v7)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove last element from an empty collection", 50, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, v27, 0);
  }
  uint64_t v21 = *(void (**)(uint64_t, unint64_t))(a3 + 112);
  unint64_t v27 = a3;
  v21(a1, a3);
  uint64_t v22 = *((void *)v14 - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v22 + 48))(v20, 1, v14) != 1) {
    return (*(uint64_t (**)(uint64_t, char *, const char *))(v22 + 32))(v31, v20, v14);
  }
  (*(void (**)(char *, Class *))(v18 + 8))(v20, v17);
  (*(void (**)(uint64_t, uint64_t))(v7 + 72))(a1, v7);
  (*(void (**)(char *, uint64_t))(v28 + 32))(v11, a1);
  uint64_t v23 = v30;
  uint64_t v24 = *(void (**)(char *, const char *))(v29 + 8);
  v24(v11, v30);
  (*(void (**)(char *, uint64_t))(v27 + 96))(v13, a1);
  return ((uint64_t (*)(char *, const char *))v24)(v13, v23);
}

uint64_t RangeReplaceableCollection<>.removeLast(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, void (*a6)(char *, char *, const char *))
{
  uint64_t v61 = a6;
  uint64_t v74 = a4;
  unint64_t v75 = a5;
  uint64_t v72 = a3;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v68 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v63 = (char *)&v58 - v13;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v66 = (uint64_t)*(v15 - 1);
  uint64_t v67 = v15;
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  uint64_t v62 = (char *)&v58 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v64 = (char *)&v58 - v18;
  uint64_t v21 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v19, v20);
  uint64_t v59 = (uint64_t)*(v21 - 1);
  unint64_t v60 = v21;
  uint64_t v22 = MEMORY[0x1F4188790](v21);
  uint64_t v24 = (char *)&v58 - v23;
  uint64_t v25 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v22);
  unint64_t v70 = (char *)&v58 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v58 - v29;
  uint64_t v31 = MEMORY[0x1F4188790](v28);
  uint64_t v33 = (char *)&v58 - v32;
  uint64_t v34 = MEMORY[0x1F4188790](v31);
  uint64_t v69 = (char *)&v58 - v35;
  uint64_t result = MEMORY[0x1F4188790](v34);
  uint64_t v38 = (char *)&v58 - v37;
  if (a1)
  {
    uint64_t v73 = a2;
    if (a1 < 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Number of elements to remove should be non-negative", 51, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, v75, 0);
    }
    uint64_t v39 = v73;
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(v74 + 120);
    unint64_t v75 = v6;
    uint64_t result = v40(a1, v73);
    if ((result & 1) == 0)
    {
      (*(void (**)(uint64_t, uint64_t))(v9 + 72))(v39, v9);
      (*(void (**)(uint64_t, uint64_t))(v9 + 64))(v39, v9);
      (*(void (**)(char *, uint64_t, char *, uint64_t))(v72 + 56))(v38, -a1, v33, v39);
      uint64_t v72 = *(void *)(v25 + 8);
      ((void (*)(char *, const char *))v72)(v33, AssociatedTypeWitness);
      if ((*(unsigned int (**)(char *, uint64_t, const char *))(v25 + 48))(v24, 1, AssociatedTypeWitness) == 1)
      {
        (*(void (**)(char *, Class *))(v59 + 8))(v24, v60);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove more items from a collection than it contains", 58, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, (unint64_t)v61, 0);
      }
      uint64_t v41 = *(void (**)(char *, char *, const char *))(v25 + 32);
      uint64_t v42 = v69;
      v41(v69, v24, AssociatedTypeWitness);
      uint64_t v43 = *(void (**)(char *, char *, const char *))(v25 + 16);
      v43(v30, v42, AssociatedTypeWitness);
      uint64_t v44 = v70;
      uint64_t v61 = v43;
      v43(v70, v38, AssociatedTypeWitness);
      if (((*(uint64_t (**)(char *, char *, const char *))(AssociatedConformanceWitness + 24))(v30, v44, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
      uint64_t v45 = (void (*)(char *, const char *))v72;
      }
      ((void (*)(char *, const char *))v72)(v44, AssociatedTypeWitness);
      v45(v30, AssociatedTypeWitness);
      uint64_t AssociatedConformanceWitness = v25 + 8;
      uint64_t v46 = TupleTypeMetadata2;
      char v47 = v63;
      uint64_t v48 = &v63[*((int *)TupleTypeMetadata2 + 12)];
      v41(v63, v42, AssociatedTypeWitness);
      v41(v48, v38, AssociatedTypeWitness);
      uint64_t v49 = v68;
      uint64_t v50 = &v68[*((int *)v46 + 12)];
      uint64_t v51 = v61;
      v61(v68, v47, AssociatedTypeWitness);
      v51(v50, v48, AssociatedTypeWitness);
      uint64_t v52 = v62;
      v41(v62, v49, AssociatedTypeWitness);
      uint64_t v53 = (void (*)(char *, const char *))v72;
      ((void (*)(char *, const char *))v72)(v50, AssociatedTypeWitness);
      uint64_t v54 = &v49[*((int *)v46 + 12)];
      v41(v49, v47, AssociatedTypeWitness);
      v41(v54, v48, AssociatedTypeWitness);
      uint64_t v55 = v67;
      v41(&v52[*((int *)v67 + 9)], v54, AssociatedTypeWitness);
      v53(v49, AssociatedTypeWitness);
      uint64_t v56 = v66;
      uint64_t v57 = v64;
      (*(void (**)(char *, char *, Class *))(v66 + 32))(v64, v52, v55);
      (*(void (**)(char *, uint64_t))(v74 + 104))(v57, v73);
      return (*(uint64_t (**)(char *, Class *))(v56 + 8))(v57, v55);
    }
  }
  return result;
}

uint64_t static RangeReplaceableCollection.+ infix<A>(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v13 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(*(void *)(v16 - 8) + 16))(a7);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a2, a4);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72))(v15, a4, a6, a3, a5);
}

{
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v18;

  uint64_t v13 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(*(void *)(v16 - 8) + 16))(a7);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a2, a4);
  return (*(uint64_t (**)(char *, uint64_t, void, uint64_t, uint64_t))(a5 + 72))(v15, a4, *(void *)(*(void *)(a6 + 8) + 8), a3, a5);
}

uint64_t static RangeReplaceableCollection.+ infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v35 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v33 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void *)(v14 - 8);
  MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v18 + 24);
  uint64_t v31 = v20;
  v19(v21, v18);
  uint64_t v22 = *(void *)(a5 + 8);
  uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 112);
  uint64_t v36 = a2;
  uint64_t v24 = v23(a3, v22);
  uint64_t v25 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 40);
  uint64_t v32 = a1;
  uint64_t v34 = a6;
  uint64_t v26 = v25(a4, a6);
  BOOL v27 = __OFADD__(v24, v26);
  uint64_t result = v24 + v26;
  if (v27)
  {
    __break(1u);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 40))(result, a3, a5);
    (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v17, v32, a4);
    uint64_t v29 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72);
    v29(v17, a4, v34, a3, a5);
    uint64_t v30 = v33;
    (*(void (**)(char *, uint64_t, uint64_t))(v35 + 16))(v33, v36, a3);
    return ((uint64_t (*)(char *, uint64_t, void, uint64_t, uint64_t))v29)(v30, a3, *(void *)(v22 + 8), a3, a5);
  }
  return result;
}

uint64_t static RangeReplaceableCollection.+= infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v12 + 16))(v11);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72))(v11, a4, a6, a3, a5);
}

uint64_t RangeReplaceableCollection.filter(_:)@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v42 = a4;
  uint64_t v46 = a1;
  uint64_t v47 = a2;
  uint64_t v8 = *(void *)(*(void *)(a4 + 8) + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v39 = (char *)&v35 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v35 - v12;
  uint64_t v16 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v14, v15);
  MEMORY[0x1F4188790](v16 - 1);
  uint64_t v18 = (char *)&v35 - v17;
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v36 = *((void *)v19 - 1);
  MEMORY[0x1F4188790](v19);
  uint64_t v21 = (char *)&v35 - v20;
  uint64_t v22 = *(void (**)(uint64_t))(v42 + 24);
  uint64_t v40 = a5;
  v22(a3);
  (*(void (**)(uint64_t, uint64_t))(v8 + 32))(a3, v8);
  uint64_t v41 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v48 = v21;
  uint64_t v25 = AssociatedConformanceWitness;
  uint64_t v49 = v19;
  uint64_t v45 = v24;
  v24(v19, AssociatedConformanceWitness);
  uint64_t v26 = v38;
  BOOL v27 = *(unsigned int (**)(char *, uint64_t, const char *))(v38 + 48);
  if (v27(v18, 1, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, const char *))(v36 + 8))(v48, v49);
  }
  uint64_t v43 = v27;
  uint64_t v44 = v25;
  uint64_t v31 = *(void (**)(char *, char *, const char *))(v26 + 32);
  uint64_t v29 = v26 + 32;
  uint64_t v30 = v31;
  uint64_t v37 = v42 + 64;
  uint64_t v38 = v29 - 24;
  while (1)
  {
    uint64_t v32 = v29;
    v30(v13, v18, AssociatedTypeWitness);
    char v33 = v46(v13);
    if (v5) {
      break;
    }
    if (v33)
    {
      uint64_t v34 = v39;
      v30(v39, v13, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t))(v42 + 64))(v34, v41);
    }
    else
    {
      (*(void (**)(char *, const char *))v38)(v13, AssociatedTypeWitness);
    }
    v45(v49, v44);
    uint64_t v29 = v32;
    if (v43(v18, 1, AssociatedTypeWitness) == 1) {
      return (*(uint64_t (**)(char *, const char *))(v36 + 8))(v48, v49);
    }
  }
  (*(void (**)(char *, const char *))v38)(v13, AssociatedTypeWitness);
  (*(void (**)(char *, const char *))(v36 + 8))(v48, v49);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v41 - 8) + 8))(v40, v41);
}

uint64_t RangeReplaceableCollection.removeSubranges(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v42 = (char *)v37 - v7;
  uint64_t v8 = swift_getAssociatedTypeWitness(255, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v41 = type metadata accessor for Range(0, (uint64_t)v8, AssociatedConformanceWitness, v10);
  uint64_t v11 = (uint64_t)*(v41 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v41);
  uint64_t v40 = (char *)v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)v37 - v15;
  uint64_t v17 = *(void *)(a2 - 8);
  uint64_t result = MEMORY[0x1F4188790](v14);
  uint64_t v21 = (char *)v37 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (*(void *)(*(void *)a1 + 16))
  {
    uint64_t v22 = type metadata accessor for RangeSet(0, (uint64_t)v8, AssociatedConformanceWitness, v19);
    RangeSet._inverted<A>(within:)((uint64_t)v22, a2, v6, &v45);
    (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
    uint64_t v23 = v45;
    unint64_t v24 = *(void *)(v45 + 16);
    if (v24)
    {
      unint64_t v25 = 0;
      v37[4] = v11 + 32;
      v37[5] = v11 + 16;
      v37[2] = v11 + 8;
      void v37[3] = v6 + 88;
      v37[1] = a3 + 72;
      do
      {
        if (v25 >= v24) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
        unint64_t v26 = v23
            + ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))
            + *(void *)(v11 + 72) * v25;
        BOOL v27 = *(void (**)(char *, unint64_t, Class *))(v11 + 16);
        uint64_t v28 = v40;
        uint64_t v39 = v17;
        uint64_t v29 = v41;
        v27(v40, v26, v41);
        (*(void (**)(char *, char *, Class *))(v11 + 32))(v16, v28, v29);
        ++v25;
        uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 88);
        uint64_t v38 = v23;
        uint64_t v31 = v42;
        v30(v16, a2, v6);
        (*(void (**)(char *, Class *))(v11 + 8))(v16, v29);
        uint64_t v32 = *(void (**)(char *, const char *, uint64_t, uint64_t, uint64_t))(a3 + 72);
        char v33 = AssociatedTypeWitness;
        uint64_t v34 = *(void *)(swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection)+ 8);
        uint64_t v35 = v31;
        uint64_t v23 = v38;
        v32(v35, v33, v34, a2, a3);
        uint64_t v17 = v39;
        unint64_t v24 = *(void *)(v23 + 16);
      }
      while (v25 != v24);
    }
    uint64_t v36 = v44;
    (*(void (**)(uint64_t, uint64_t))(v17 + 8))(v44, a2);
    swift_release(v23);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v17 + 32))(v36, v21, a2);
  }
  return result;
}

uint64_t MutableCollection<>.removeSubranges(_:)(atomic_ullong **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v116 = a4;
  unint64_t v150 = (char *)a3;
  uint64_t v6 = *(int ***)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  int64_t v115 = (char *)&v112 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v119 = (char *)&v112 - v11;
  uint64_t v123 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v118 = (char *)&v112 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v117 = (char *)&v112 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v122 = (char *)&v112 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v121 = (char *)&v112 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  Swift::Int v143 = (char *)&v112 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v148 = (char *)&v112 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  Swift::String::Index v139 = (char *)&v112 - v25;
  MEMORY[0x1F4188790](v24);
  BOOL v27 = (char *)&v112 - v26;
  unint64_t v136 = v6;
  uint64_t v134 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v30 = type metadata accessor for Range(255, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v29);
  unint64_t v147 = type metadata accessor for Optional(0, (uint64_t)v30, v31, v32);
  uint64_t v33 = (uint64_t)*(v147 - 1);
  uint64_t v34 = MEMORY[0x1F4188790](v147);
  uint64_t v36 = (char *)&v112 - v35;
  uint64_t v37 = (uint64_t)*(v30 - 1);
  uint64_t v38 = MEMORY[0x1F4188790](v34);
  unint64_t v113 = (char *)&v112 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  unint64_t v114 = (char *)&v112 - v41;
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  Swift::Int v142 = (char *)&v112 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  unint64_t v131 = (char *)&v112 - v45;
  MEMORY[0x1F4188790](v44);
  uint64_t v47 = (char *)&v112 - v46;
  unint64_t v146 = *a1;
  unint64_t v154 = v146;
  uint64_t v138 = AssociatedConformanceWitness;
  uint64_t v49 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v48);
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v49, v50);
  Collection.first.getter((uint64_t)v49, (uint64_t)WitnessTable, (uint64_t)v36);
  if ((*(unsigned int (**)(char *, uint64_t, Class *))(v37 + 48))(v36, 1, v30) == 1) {
    return (*(uint64_t (**)(char *, Class *))(v33 + 8))(v36, v147);
  }
  uint64_t v53 = *(void (**)(char *, char *, Class *))(v37 + 32);
  uint64_t v130 = v37 + 32;
  unint64_t v129 = v53;
  v53(v47, v36, v30);
  uint64_t v54 = (uint64_t)v49;
  uint64_t v56 = v123 + 16;
  uint64_t v55 = *(void (**)(char *, char *, const char *))(v123 + 16);
  uint64x2_t v144 = v27;
  v55(v27, v47, AssociatedTypeWitness);
  uint64_t v57 = &v47[*((int *)v30 + 9)];
  char v135 = v55;
  v55(v139, v57, AssociatedTypeWitness);
  unint64_t v154 = v146;
  swift_retain(v146);
  Swift::String::Index v141 = (char *)v54;
  unint64_t v128 = WitnessTable;
  Collection.dropFirst(_:)(1, v54, (uint64_t)WitnessTable, (uint64_t)&v151);
  uint64_t v59 = v151;
  uint64_t v58 = v152;
  uint64_t v60 = v153;
  unint64_t v154 = v151;
  uint64_t v155 = v152;
  uint64_t v156 = v153;
  uint64_t v157 = v151;
  uint64_t v61 = v150;
  uint64_t v112 = v47;
  unint64_t v132 = v30;
  uint64_t v137 = v37;
  uint64_t v149 = AssociatedTypeWitness;
  uint64_t v133 = v56;
  if (v151 != v152)
  {
    uint64_t v62 = v30;
    uint64_t v63 = v37;
    Swift::String::Index v140 = (char *)&v157;
    uint64_t v127 = v37 + 16;
    unint64_t v146 = (atomic_ullong *)(v150 + 64);
    Swift::String::Index v126 = (void (**)(char *, uint64_t, int **))(v136 + 24);
    Swift::String::Index v125 = (void (**)(char *, const char *))(v123 + 8);
    Swift::String::Index v124 = (void (**)(char *, Class *))(v37 + 8);
    uint64_t v64 = v135;
    uint64_t v65 = v148;
    do
    {
      unint64_t v151 = v154;
      char v152 = v58;
      uint64_t v68 = v128;
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v140, (uint64_t)&v151, (uint64_t)v141, v128);
      if (((unint64_t)v59 & 0x8000000000000000) != 0
        || (uint64_t v69 = v156, (unint64_t)v59 >= *(void *)(v156 + 16)))
      {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      }
      unint64_t v70 = v156
          + ((*(unsigned __int8 *)(v63 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v63 + 80))
          + *(void *)(v63 + 72) * (void)v59;
      uint64_t v71 = *(void (**)(char *, unint64_t, Class *))(v63 + 16);
      uint64_t v72 = v68;
      uint64_t v73 = v131;
      v71(v131, v70, v62);
      uint64_t v74 = *(atomic_ullong **)(v69 + 16);
      unint64_t v151 = 0;
      char v152 = v74;
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v140, (uint64_t)&v151, (uint64_t)v141, v72);
      uint64_t v157 = (atomic_ullong *)((char *)v59 + 1);
      unint64_t v75 = v142;
      v129(v142, v73, v62);
      v64(v65, v75, AssociatedTypeWitness);
      uint64_t v76 = v139;
      uint64_t v77 = *(uint64_t (**)(char *, char *))(*(void *)(v138 + 8) + 8);
      unint64_t v147 = *(Class **)(v138 + 8);
      char v78 = v77(v139, v65);
      uint64_t v79 = v134;
      unint64_t v80 = v136;
      uint64_t v81 = v144;
      if ((v78 & 1) == 0)
      {
        atomic_ullong v145 = *v146;
        uint64_t v82 = *v126;
        do
        {
          ((void (*)(char *, char *, uint64_t, char *))v145)(v81, v76, v79, v150);
          v82(v81, v79, v80);
          v82(v76, v79, v80);
        }
        while ((v77(v76, v148) & 1) == 0);
      }
      uint64_t v66 = *v125;
      uint64_t v65 = v148;
      uint64_t AssociatedTypeWitness = v149;
      (*v125)(v148, v149);
      v66(v76, AssociatedTypeWitness);
      uint64_t v62 = v132;
      uint64_t v67 = v142;
      uint64_t v64 = v135;
      v135(v76, &v142[*((int *)v132 + 9)], AssociatedTypeWitness);
      (*v124)(v67, v62);
      uint64_t v59 = v157;
      uint64_t v58 = v155;
      uint64_t v61 = v150;
      uint64_t v63 = v137;
    }
    while (v157 != v155);
    uint64_t v60 = v156;
  }
  swift_release(v60);
  unint64_t v83 = v136;
  uint64_t v84 = (atomic_ullong *)v136[9];
  unint64_t v85 = v139;
  atomic_ullong v145 = *(void *)(v138 + 8);
  unint64_t v146 = v84;
  Swift::Int v142 = *(char **)(v145 + 8);
  unint64_t v147 = (Class *)(v136 + 9);
  uint64_t v148 = (char *)(v123 + 8);
  Swift::String::Index v141 = v61 + 64;
  uint64_t v86 = v134;
  unint64_t v87 = v143;
  while (1)
  {
    ((void (*)(uint64_t, int **))v146)(v86, v83);
    char v88 = v149;
    char v89 = ((uint64_t (*)(char *, char *, const char *, atomic_ullong))v142)(v85, v87, v149, v145);
    unint64_t v90 = *(void (**)(char *, const char *))v148;
    (*(void (**)(char *, const char *))v148)(v87, v88);
    if (v89) {
      break;
    }
    unint64_t v91 = v144;
    (*((void (**)(char *, char *, uint64_t))v150 + 8))(v144, v85, v86);
    uint64_t v92 = v83[24];
    ((void (*)(char *, uint64_t, int **))v92)(v91, v86, v83);
    ((void (*)(char *, uint64_t, int **))v92)(v85, v86, v83);
  }
  uint64_t v93 = v121;
  unint64_t v94 = v149;
  unint64_t v95 = v135;
  v135(v121, v144, v149);
  uint64_t v96 = v122;
  ((void (*)(uint64_t, int **))v146)(v86, v83);
  char v97 = v117;
  v95(v117, v93, v94);
  unint64_t v98 = v118;
  v95(v118, v96, v94);
  if (((*(uint64_t (**)(char *, char *, const char *))(v138 + 24))(v97, v98, v94) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v90(v98, v94);
  v90(v97, v94);
  v90(v139, v94);
  v90(v144, v94);
  uint64_t v99 = *(Class **)(v137 + 8);
  v137 += 8;
  unint64_t v147 = v99;
  ((void (*)(char *, Class *))v99)(v112, v132);
  unint64_t v100 = TupleTypeMetadata2;
  uint64_t v101 = v119;
  unint64_t v150 = &v119[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v102 = v150;
  unint64_t v103 = *(void (**)(char *, char *, const char *))(v123 + 32);
  v103(v119, v121, v94);
  v103(v102, v122, v94);
  uint64_t v104 = *((int *)v100 + 12);
  unint64_t v105 = v115;
  unint64_t v106 = &v115[v104];
  unint64_t v107 = v135;
  v135(v115, v101, v94);
  v107(v106, v150, v94);
  id v108 = v113;
  v103(v113, v105, v94);
  v90(v106, v94);
  uint64_t v109 = &v105[*((int *)TupleTypeMetadata2 + 12)];
  v103(v105, v119, v94);
  v103(v109, v150, v94);
  uint64_t v110 = v132;
  v103(&v108[*((int *)v132 + 9)], v109, v94);
  v90(v105, v94);
  uint64_t v111 = v114;
  v129(v114, v108, v110);
  (*(void (**)(char *, uint64_t))(v116 + 104))(v111, v86);
  return ((uint64_t (*)(char *, Class *))v147)(v111, v110);
}

uint64_t RangeSet._ranges.setter(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t result = swift_release(*v1);
  *uint64_t v1 = v2;
  return result;
}

uint64_t (*RangeSet._ranges.modify())()
{
  return EnumeratedSequence._base.modify;
}

void RangeSet.init()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  uint64_t v5 = (uint64_t *)type metadata accessor for Range(0, a1, a2, a3);
  _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
  uint64_t v6 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v5);
  if (v6)
  {
    uint64_t v9 = (__objc2_class **)v6;
  }
  else
  {
    uint64_t v13 = &_swiftEmptyArrayStorage;
    uint64_t v10 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v5, v7, v8);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v10, v11);
    uint64_t v9 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, (uint64_t)v10, WitnessTable);
  }
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  *a4 = v9;
}

void RangeSet.Ranges.init()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  uint64_t v5 = (uint64_t *)type metadata accessor for Range(0, a1, a2, a3);
  _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
  uint64_t v6 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v5);
  if (v6)
  {
    uint64_t v9 = (__objc2_class **)v6;
  }
  else
  {
    uint64_t v13 = &_swiftEmptyArrayStorage;
    uint64_t v10 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v5, v7, v8);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v10, v11);
    uint64_t v9 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, (uint64_t)v10, WitnessTable);
  }
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  *a4 = v9;
}

void RangeSet.Ranges.init(_range:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7 = (uint64_t *)type metadata accessor for Range(255, a2, a3, a4);
  uint64_t v10 = (unint64_t *)type metadata accessor for _ContiguousArrayStorage(0, (uint64_t)v7, v8, v9);
  uint64_t v11 = *(v7 - 1);
  uint64_t v12 = swift_allocObject(v10, ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))+ *(void *)(v11 + 72), *(unsigned __int8 *)(v11 + 80) | 7);
  uint64_t v13 = static Array._adoptStorage(_:count:)(v12, 1);
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(v11 + 32))(v14, a1, v7);
  uint64_t v15 = _ArrayBuffer.requestNativeBuffer()((unint64_t)v13, v7);
  if (!v15)
  {
    uint64_t v22 = v13;
    uint64_t v18 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v7, v16, v17);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v18, v19);
    uint64_t v15 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v22, (uint64_t)v18, WitnessTable);
  }
  uint64_t v21 = v15;
  swift_bridgeObjectRelease((uint64_t)v13);
  *a5 = v21;
}

void *RangeSet.init<A>(_:)@<X0>(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, Class *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, atomic_ullong **a6@<X8>)
{
  uint64_t v12 = (uint64_t)*(a3 - 1);
  MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (type metadata accessor for RangeSet.Ranges(0, v15, v16, v16) == a3)
  {
    uint64_t v19 = *a1;
    uint64_t v20 = *(uint64_t (**)(atomic_ullong **, Class *))(v12 + 8);
    swift_retain(*a1);
    uint64_t result = (void *)v20(a1, a3);
  }
  else
  {
    (*(void (**)(char *, atomic_ullong **, Class *))(v12 + 32))(v14, a1, a3);
    uint64_t v17 = (*(uint64_t (**)(Class *, uint64_t))(a5 + 56))(a3, a5);
    uint64_t result = RangeSet.Ranges.init(_unorderedRanges:)(v17, a2, a4, (uint64_t *)&v22);
    uint64_t v19 = v22;
  }
  *a6 = v19;
  return result;
}

void *RangeSet.init(_ranges:)@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void *RangeSet.Ranges.init(_unorderedRanges:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v95 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a2, a2, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v104 = (char *)&v95 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  unint64_t v103 = (char *)&v95 - v10;
  uint64_t v11 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v95 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  id v108 = (char *)&v95 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v107 = (char *)&v95 - v18;
  MEMORY[0x1F4188790](v17);
  unint64_t v106 = (char *)&v95 - v19;
  uint64_t v125 = a2;
  uint64_t v21 = type metadata accessor for Range(0, a2, a3, v20);
  uint64_t v123 = (uint64_t)*(v21 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v21);
  uint64_t v122 = (char *)&v95 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v114 = (char *)&v95 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  unint64_t v121 = (char *)&v95 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v95 - v28;
  uint64_t v30 = _ArrayBuffer.requestNativeBuffer()(a1, (uint64_t *)v21);
  uint64_t v109 = v14;
  if (!v30)
  {
    uint64_t v128 = a1;
    uint64_t v33 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v21, v31, v32);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v33, v34);
    uint64_t v30 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v128, (uint64_t)v33, WitnessTable);
  }
  uint64_t v36 = v30;
  swift_bridgeObjectRelease(a1);
  uint64_t v128 = v36;
  MEMORY[0x1F4188790](v37);
  uint64_t v93 = v125;
  uint64_t v94 = a3;
  uint64_t v40 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v21, v38, v39);
  uint64_t v42 = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v40, v41);
  uint64_t v44 = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v40, v43);
  int64_t v115 = v40;
  uint64_t result = MutableCollection<>.sort(by:)((uint64_t)partial apply for closure #1 in RangeSet.Ranges.init(_unorderedRanges:), (uint64_t)v92, (uint64_t)v40, v42, v44);
  uint64_t v46 = v128;
  unint64_t v47 = *(void *)(v128 + 16);
  if (v47)
  {
    unint64_t v48 = 0;
    uint64_t v126 = v123 + 16;
    uint64_t v49 = (uint64_t (**)(char *, Class *))(v123 + 8);
    uint64_t v50 = (void (**)(char *, char *, uint64_t))(v11 + 16);
    uint64_t v101 = a3 + 24;
    unint64_t v119 = (void (**)(char *, uint64_t))(v11 + 8);
    unint64_t v98 = (void (**)(char *, char *, uint64_t))(v11 + 32);
    char v97 = (void (**)(char *, uint64_t, Class *))(v123 + 32);
    uint64_t v96 = (void (**)(char *, char *, Class *))(v123 + 40);
    uint64_t v51 = (uint64_t)v115;
    uint64_t v100 = a3;
    uint64_t v99 = v29;
    uint64_t v113 = a3 + 32;
    unint64_t v120 = (uint64_t (**)(char *, Class *))(v123 + 8);
    unint64_t v102 = v50;
    uint64_t v112 = v21;
    do
    {
      if (v48 >= v47) {
LABEL_23:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      uint64_t v52 = a3;
      unint64_t v124 = (*(unsigned __int8 *)(v123 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v123 + 80);
      unint64_t v53 = v46 + v124;
      uint64_t v54 = *(void *)(v123 + 72);
      uint64_t v55 = *(void (**)(char *, unint64_t, Class *))(v123 + 16);
      v55(v29, v46 + v124 + v54 * v48, v21);
      unint64_t v127 = v48;
      if (v48)
      {
        unint64_t v56 = v127 - 1;
        if (v127 - 1 >= *(void *)(v46 + 16)) {
          goto LABEL_23;
        }
        unint64_t v117 = v54 * v56;
        unint64_t v118 = v127 - 1;
        unint64_t v57 = v53 + v54 * v56;
        uint64_t v58 = v52;
        uint64_t v59 = v125;
        uint64_t v60 = v29;
        uint64_t v61 = v121;
        v55(v121, v57, v21);
        uint64_t v62 = &v61[*((int *)v21 + 9)];
        uint64_t v63 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v58 + 32);
        if (v63(v62, v60, v59, v58))
        {
          uint64_t v64 = &v60[*((int *)v21 + 9)];
          char v65 = v63(v64, v62, v59, v58);
          uint64_t v66 = *v102;
          if (v65) {
            uint64_t v67 = v64;
          }
          else {
            uint64_t v67 = v62;
          }
          uint64_t v68 = v106;
          v66(v106, v67, v59);
          uint64_t v69 = v107;
          v66(v107, v61, v59);
          unint64_t v70 = v108;
          v66(v108, v69, v59);
          uint64_t v71 = v109;
          v66(v109, v68, v59);
          if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v58 + 24))(v70, v71, v59, v58) & 1) == 0) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
          }
          uint64_t v72 = v71;
          uint64_t v116 = *v119;
          uint64_t v73 = v116;
          v116(v72, v59);
          v73(v70, v59);
          uint64_t v74 = *v120;
          unint64_t v75 = v112;
          (*v120)(v121, v112);
          uint64_t v111 = v74;
          v74(v60, v75);
          uint64_t v76 = TupleTypeMetadata2;
          uint64_t v77 = v68;
          char v78 = v103;
          uint64_t v79 = &v103[*((int *)TupleTypeMetadata2 + 12)];
          unint64_t v80 = *v98;
          (*v98)(v103, v69, v59);
          uint64_t v110 = v79;
          v80(v79, v77, v59);
          uint64_t v81 = v104;
          uint64_t v82 = &v104[*((int *)v76 + 12)];
          v66(v104, v78, v59);
          v66(v82, v79, v59);
          uint64_t v83 = (uint64_t)v122;
          v80(v122, v81, v59);
          v116(v82, v59);
          uint64_t v84 = &v81[*((int *)v76 + 12)];
          v80(v81, v78, v59);
          v80(v84, v110, v59);
          unint64_t v85 = v112;
          v80((char *)(v83 + *((int *)v112 + 9)), v84, v59);
          v116(v81, v59);
          (*v97)(v114, v83, v85);
          uint64_t v86 = (__objc2_class **)v128;
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v128);
          uint64_t v128 = (uint64_t)v86;
          uint64_t v21 = v85;
          uint64_t v51 = (uint64_t)v115;
          if (!isUniquelyReferenced_nonNull_native)
          {
            uint64_t v86 = _ContiguousArrayBuffer._consumeAndCreateNew()((uint64_t)v86, (uint64_t *)v115[2]);
            uint64_t v128 = (uint64_t)v86;
          }
          unint64_t v48 = v127;
          specialized Array._checkSubscript_mutating(_:)(v118, (uint64_t)v86);
          (*v96)((char *)v86 + v124 + v117, v114, v85);
          uint64_t v91 = (uint64_t)v122;
          ContiguousArray.remove(at:)(v48, v51, (uint64_t)v122);
          uint64_t v49 = v120;
          uint64_t result = (void *)v111((char *)v91, v85);
          a3 = v100;
          uint64_t v29 = v99;
          goto LABEL_6;
        }
        uint64_t v49 = v120;
        (*v120)(v61, v21);
        uint64_t v29 = v60;
        uint64_t v52 = v58;
        uint64_t v51 = (uint64_t)v115;
      }
      a3 = v52;
      char v88 = (*(uint64_t (**)(char *, char *))(*(void *)(v52 + 8) + 8))(v29, &v29[*((int *)v21 + 9)]);
      char v89 = *v49;
      uint64_t result = (void *)(*v49)(v29, v21);
      if (v88)
      {
        uint64_t v90 = (uint64_t)v122;
        unint64_t v48 = v127;
        ContiguousArray.remove(at:)(v127, v51, (uint64_t)v122);
        uint64_t result = (void *)v89((char *)v90, v21);
      }
      else
      {
        unint64_t v48 = v127 + 1;
      }
LABEL_6:
      uint64_t v46 = v128;
      unint64_t v47 = *(void *)(v128 + 16);
    }
    while (v48 < v47);
  }
  *unint64_t v95 = v46;
  return result;
}

uint64_t RangeSet.Ranges.init(_ranges:)@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t RangeSet.Ranges._contains(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v23 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *(void *)(v8 + 24);
  uint64_t v11 = type metadata accessor for Range(0, v4, v9, v10);
  uint64_t v12 = (uint64_t)*(v11 - 1);
  MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v23 - v13;
  uint64_t v29 = (atomic_ullong *)*v2;
  uint64_t v15 = v29;
  uint64_t v26 = v4;
  uint64_t v27 = v9;
  uint64_t v24 = a1;
  uint64_t v28 = a1;
  uint64_t v18 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v11, v16, v17);
  swift_retain(v15);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v18, v19);
  Collection._partitioningIndex(where:)((uint64_t (*)(char *))partial apply for closure #1 in RangeSet.Ranges._contains(_:), (uint64_t)v25, (uint64_t)v18, WitnessTable, (char *)&v30);
  swift_release((uint64_t)v29);
  if (v30 == v15[2])
  {
    char v21 = 0;
  }
  else
  {
    ContiguousArray.subscript.getter(v30, (uint64_t)v15, (uint64_t)v11, (uint64_t)v14);
    (*(void (**)(char *, char *, uint64_t))(v5 + 16))(v7, v14, v4);
    (*(void (**)(char *, Class *))(v12 + 8))(v14, v11);
    char v21 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 24))(v7, v24, v4, v9);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  }
  return v21 & 1;
}

uint64_t RangeSet.insert(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = type metadata accessor for Range(0, v5, v6, a4);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 8))(a1, a1 + *((int *)v7 + 9), v5);
  if ((result & 1) == 0)
  {
    uint64_t v10 = type metadata accessor for RangeSet.Ranges(0, v5, v6, v9);
    return RangeSet.Ranges._insert(contentsOf:)(a1, (uint64_t)v10);
  }
  return result;
}

uint64_t RangeSet.Ranges._insert(contentsOf:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v5, v5, "lower upper ", 0);
  uint64_t v6 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v120 = (char *)v110 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  unint64_t v119 = (char *)v110 - v9;
  uint64_t v134 = *(void *)(v5 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v124 = (char *)v110 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v122 = (char *)v110 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v125 = (char *)v110 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v123 = (char *)v110 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v132 = (char *)v110 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v126 = (char *)v110 - v20;
  char v21 = *(char **)(a2 + 24);
  uint64_t v23 = type metadata accessor for Range(255, v5, (uint64_t)v21, v22);
  unint64_t v129 = (unint64_t *)type metadata accessor for CollectionOfOne(0, (uint64_t)v23, v24, v25);
  uint64_t v26 = MEMORY[0x1F4188790](v129);
  unint64_t v131 = (char *)v110 - v27;
  uint64_t v28 = (uint64_t)*(v23 - 1);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  unint64_t v114 = (char *)v110 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  int64_t v115 = (char *)v110 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  uint64_t v113 = (uint64_t)v110 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  unint64_t v118 = (char *)v110 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v128 = (char *)v110 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v121 = (uint64_t)v110 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  uint64_t v43 = (char *)v110 - v42;
  MEMORY[0x1F4188790](v41);
  uint64_t v45 = (char *)v110 - v44;
  char v135 = (uint64_t *)v2;
  uint64_t v46 = *v2;
  swift_retain(*v2);
  uint64_t v47 = a1;
  uint64_t v48 = specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, v46, 1, v5, (uint64_t)v21);
  uint64_t v50 = v49;
  swift_release((uint64_t)v46);
  uint64_t v133 = v50;
  if (v48 != v50)
  {
    uint64_t v111 = v45;
    uint64_t v127 = v48;
    ContiguousArray.subscript.getter(v48, (uint64_t)v46, (uint64_t)v23, (uint64_t)v43);
    uint64_t v62 = v134;
    uint64_t v64 = v134 + 16;
    uint64_t v63 = *(void (**)(char *, char *, uint64_t))(v134 + 16);
    char v65 = v132;
    v63(v132, v43, v5);
    uint64_t v116 = *(void (**)(char *, Class *))(v28 + 8);
    uint64_t v117 = v28 + 8;
    v116(v43, v23);
    char v66 = (*((uint64_t (**)(uint64_t, char *, uint64_t, char *))v21 + 2))(v47, v65, v5, v21);
    uint64_t v67 = v62;
    uint64_t v112 = v28;
    uint64_t v68 = v47;
    if (v66)
    {
      (*(void (**)(char *, uint64_t))(v62 + 8))(v132, v5);
      uint64_t v69 = v126;
      uint64_t v70 = v64;
      uint64_t v71 = (void (*)(char *, uint64_t, uint64_t))v63;
      v63(v126, (char *)v47, v5);
    }
    else
    {
      uint64_t v71 = (void (*)(char *, uint64_t, uint64_t))v63;
      uint64_t v70 = v64;
      uint64_t v69 = v126;
      (*(void (**)(char *, char *, uint64_t))(v67 + 32))(v126, v132, v5);
    }
    uint64_t v72 = v125;
    if (__OFSUB__(v133, 1))
    {
      __break(1u);
    }
    else
    {
      uint64_t v73 = v121;
      ContiguousArray.subscript.getter(v133 - 1, *v135, (uint64_t)v23, v121);
      v71(v72, v73 + *((int *)v23 + 9), v5);
      v116((char *)v73, v23);
      uint64_t v74 = v68 + *((int *)v23 + 9);
      if ((*((uint64_t (**)(uint64_t, char *, uint64_t, char *))v21 + 4))(v74, v72, v5, v21))
      {
        (*(void (**)(char *, uint64_t))(v134 + 8))(v72, v5);
        unint64_t v75 = v123;
        v71(v123, v74, v5);
      }
      else
      {
        unint64_t v75 = v123;
        (*(void (**)(char *, char *, uint64_t))(v134 + 32))(v123, v72, v5);
      }
      uint64_t v76 = v122;
      v110[1] = v70;
      v71(v122, (uint64_t)v69, v5);
      uint64_t v77 = v124;
      v71(v124, (uint64_t)v75, v5);
      if ((*((uint64_t (**)(char *, char *, uint64_t, char *))v21 + 3))(v76, v77, v5, v21))
      {
        uint64_t v123 = v21;
        char v78 = v69;
        uint64_t v79 = v134;
        uint64_t v125 = (char *)v71;
        unint64_t v80 = *(char **)(v134 + 8);
        uint64_t v126 = v80;
        ((void (*)(char *, uint64_t))v80)(v77, v5);
        ((void (*)(char *, uint64_t))v80)(v76, v5);
        unint64_t v132 = (char *)v23;
        uint64_t v81 = TupleTypeMetadata2;
        uint64_t v82 = v119;
        uint64_t v83 = &v119[*((int *)TupleTypeMetadata2 + 12)];
        uint64_t v84 = *(void (**)(char *, char *, uint64_t))(v79 + 32);
        v84(v119, v78, v5);
        unint64_t v124 = v83;
        v84(v83, v75, v5);
        unint64_t v85 = v120;
        uint64_t v86 = &v120[*((int *)v81 + 12)];
        unint64_t v87 = (void (*)(char *, char *, uint64_t))v125;
        ((void (*)(char *, char *, uint64_t))v125)(v120, v82, v5);
        v87(v86, v83, v5);
        char v88 = v111;
        v84(v111, v85, v5);
        char v89 = v126;
        ((void (*)(char *, uint64_t))v126)(v86, v5);
        uint64_t v90 = (uint64_t)v132;
        uint64_t v91 = &v85[*((int *)TupleTypeMetadata2 + 12)];
        v84(v85, v82, v5);
        v84(v91, v124, v5);
        v84(&v88[*(int *)(v90 + 36)], v91, v5);
        ((void (*)(char *, uint64_t))v89)(v85, v5);
        uint64_t v92 = v112;
        uint64_t v93 = *(uint64_t (**)(char *, char *, uint64_t))(v112 + 32);
        uint64_t v94 = v128;
        uint64_t result = v93(v128, v88, v90);
        uint64_t v96 = v133 - v127;
        if (__OFSUB__(v133, v127))
        {
          __break(1u);
          return result;
        }
        char v97 = v118;
        (*(void (**)(char *, char *, uint64_t))(v92 + 16))(v118, v94, v90);
        if (v96 == 1)
        {
          uint64_t v98 = v113;
          ContiguousArray.subscript.getter(v127, *v135, v90, v113);
          uint64_t v99 = *((void *)v123 + 1);
          uint64_t v134 = *(void *)(v99 + 8);
          char v100 = ((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v134)(v97, v98, v5, v99);
          uint64_t v101 = v115;
          v93(v115, v97, v90);
          unint64_t v102 = v114;
          v93(v114, (char *)v98, v90);
          if (v100)
          {
            char v103 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v134)(&v101[*(int *)(v90 + 36)], &v102[*(int *)(v90 + 36)], v5, v99);
            uint64_t v104 = (void (*)(char *, uint64_t))v116;
            v116(v102, (Class *)v90);
            v104(v101, v90);
            unint64_t v105 = v131;
            uint64_t v94 = v128;
            if (v103)
            {
              v104(v128, v90);
              return 0;
            }
            goto LABEL_19;
          }
          unint64_t v106 = (void (*)(char *, uint64_t))v116;
          v116(v102, (Class *)v90);
          uint64_t v94 = v128;
          v106(v101, v90);
        }
        else
        {
          v116(v97, (Class *)v90);
        }
        unint64_t v105 = v131;
LABEL_19:
        v93(v105, v94, v90);
        uint64_t v55 = type metadata accessor for ContiguousArray(0, v90, v107, v108);
        unint64_t v56 = v129;
        uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v129, v109);
        uint64_t v59 = v127;
        uint64_t v60 = v133;
        uint64_t v61 = (uint64_t)v105;
        goto LABEL_20;
      }
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  (*(void (**)(char *, uint64_t, Class *))(v28 + 16))(v45, v47, v23);
  ContiguousArray._checkIndex(_:)(v48);
  uint64_t v51 = v131;
  (*(void (**)(char *, char *, Class *))(v28 + 32))(v131, v45, v23);
  uint64_t v54 = v48;
  uint64_t v55 = type metadata accessor for ContiguousArray(0, (uint64_t)v23, v52, v53);
  unint64_t v56 = v129;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v129, v57);
  uint64_t v59 = v54;
  uint64_t v60 = v54;
  uint64_t v61 = (uint64_t)v51;
LABEL_20:
  ContiguousArray.replaceSubrange<A>(_:with:)(v59, v60, v61, (uint64_t)v55, (uint64_t)v56, WitnessTable);
  return 1;
}

void RangeSet.remove(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = type metadata accessor for Range(0, v5, v6, a4);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 8))(a1, a1 + *((int *)v7 + 9), v5) & 1) == 0)
  {
    uint64_t v9 = type metadata accessor for RangeSet.Ranges(0, v5, v6, v8);
    RangeSet.Ranges._remove(contentsOf:)(a1, (uint64_t)v9, v10, v11);
  }
}

void RangeSet.Ranges._remove(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 24);
  uint64_t v9 = type metadata accessor for Range(255, v7, v8, a4);
  int64x2_t v244 = type metadata accessor for _Pair(0, (uint64_t)v9, v10, v11);
  MEMORY[0x1F4188790](v244);
  int64x2_t v243 = (char *)&v232 - v12;
  int8x16_t v261 = (unint64_t *)type metadata accessor for CollectionOfOne(0, (uint64_t)v9, v13, v14);
  MEMORY[0x1F4188790](v261);
  uint64x2_t v260 = (char *)&v232 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, "lower upper ", 0);
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  int64x2_t v271 = (char *)&v232 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  int8x16_t v273 = (char *)&v232 - v19;
  int8x16_t v277 = v9;
  uint64_t v281 = (uint64_t)*(v9 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v232 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  int8x16_t v242 = (char *)&v232 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v232 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v30 = (char *)&v232 - v29;
  uint64_t v31 = MEMORY[0x1F4188790](v28);
  uint64_t v259 = (uint64_t)&v232 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  int64x2_t v246 = (char *)&v232 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v258 = (uint64_t)&v232 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  int64x2_t v245 = (char *)&v232 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v41 = (char *)&v232 - v40;
  uint8x16_t v282 = *(void **)(v7 - 8);
  uint64_t v42 = MEMORY[0x1F4188790](v39);
  unint64_t v249 = (char *)&v232 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  int8x16_t v248 = (char *)&v232 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  int64x2_t v250 = (char *)&v232 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  uint64_t v247 = (char *)&v232 - v49;
  uint64_t v50 = MEMORY[0x1F4188790](v48);
  uint64x2_t v256 = (char *)&v232 - v51;
  uint64_t v52 = MEMORY[0x1F4188790](v50);
  uint32x4_t v255 = (char *)&v232 - v53;
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  uint64x2_t v257 = (char *)&v232 - v55;
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  int64x2_t v266 = (char *)&v232 - v57;
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  uint16x8_t v254 = (char *)&v232 - v59;
  uint64_t v60 = MEMORY[0x1F4188790](v58);
  uint8x8_t v253 = (char *)&v232 - v61;
  uint64_t v62 = MEMORY[0x1F4188790](v60);
  int64x2_t v265 = (char *)&v232 - v63;
  uint64_t v64 = MEMORY[0x1F4188790](v62);
  int64x2_t v264 = (char *)&v232 - v65;
  uint64_t v66 = MEMORY[0x1F4188790](v64);
  int8x16_t v252 = (char *)&v232 - v67;
  uint64_t v68 = MEMORY[0x1F4188790](v66);
  int8x16_t v251 = (char *)&v232 - v69;
  uint64_t v70 = MEMORY[0x1F4188790](v68);
  int64x2_t v263 = (char *)&v232 - v71;
  uint64_t v72 = MEMORY[0x1F4188790](v70);
  v262 = (char *)&v232 - v73;
  uint64_t v74 = MEMORY[0x1F4188790](v72);
  int8x16_t v279 = (char *)&v232 - v75;
  MEMORY[0x1F4188790](v74);
  uint64_t v77 = (char *)&v232 - v76;
  int8x16_t v278 = (uint64_t *)v5;
  char v78 = *v5;
  swift_retain(*v5);
  uint64_t v275 = v8;
  unint64_t v79 = specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, v78, 0, v7, v8);
  uint64_t v81 = v80;
  swift_release((uint64_t)v78);
  if (v79 != v81)
  {
    unint64_t v233 = v27;
    uint64_t v232 = v22;
    unint64_t v235 = v30;
    uint64_t v82 = v282 + 2;
    uint64_t v83 = (void (*)(char *, uint64_t, uint64_t))v282[2];
    v83(v77, a1, v7);
    unint64_t v270 = v79;
    uint64_t v84 = (uint64_t)v277;
    ContiguousArray.subscript.getter(v79, (uint64_t)v78, (uint64_t)v277, (uint64_t)v41);
    int64x2_t v274 = v77;
    unint64_t v85 = v279;
    v83(v279, (uint64_t)v41, v7);
    uint64_t v86 = *(void (**)(uint64_t, uint64_t))(v281 + 8);
    int8x16_t v272 = v41;
    uint64_t v241 = v281 + 8;
    int64x2_t v240 = v86;
    v86((uint64_t)v41, v84);
    uint64_t v87 = v275;
    int v238 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v275 + 40))(v274, v85, v7, v275);
    uint64_t v88 = a1;
    uint64_t v89 = v81;
    uint64_t v91 = v282 + 1;
    uint64_t v90 = (void (*)(char *, uint64_t))v282[1];
    uint64_t v92 = v85;
    uint64_t v93 = v274;
    v90(v92, v7);
    int8x16_t v280 = v90;
    v90(v93, v7);
    uint64_t v94 = *(int *)(v84 + 36);
    uint64_t v237 = v88;
    uint64_t v95 = v88 + v94;
    uint64_t v96 = v93;
    char v97 = v93;
    uint64_t v236 = v95;
    uint64_t v98 = v83;
    ((void (*)(char *))v83)(v97);
    uint64_t v239 = v89;
    unint64_t v99 = v89 - 1;
    if (__OFSUB__(v89, 1))
    {
      __break(1u);
    }
    else
    {
      uint64_t v100 = v87;
      uint64_t v101 = v84;
      unint64_t v102 = v278;
      uint64_t v103 = *v278;
      uint64_t v104 = (uint64_t)v272;
      unint64_t v234 = v99;
      ContiguousArray.subscript.getter(v99, v103, v84, (uint64_t)v272);
      uint64_t v105 = v104 + *(int *)(v84 + 36);
      unint64_t v106 = v279;
      int64x2_t v268 = v98;
      int8x16_t v269 = v82;
      v98(v279, v105, v7);
      uint64_t v107 = v104;
      uint64_t v108 = v240;
      v240(v107, v101);
      uint64_t v109 = v96;
      char v110 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v100 + 16))(v96, v106, v7, v100);
      uint64_t v111 = v100;
      char v112 = v110;
      uint64_t v113 = v106;
      unint64_t v114 = v280;
      v280(v113, v7);
      v114(v109, v7);
      uint64_t v117 = v91;
      if (v238)
      {
        unint64_t v118 = v108;
        uint64_t v119 = *v102;
        int8x16_t v279 = (char *)(v111 + 24);
        int64x2_t v267 = v117;
        if (v112)
        {
          uint64_t v120 = (uint64_t)v233;
          ContiguousArray.subscript.getter(v270, v119, v101, (uint64_t)v233);
          uint64_t v121 = v266;
          uint64_t v122 = v268;
          v268(v266, v120, v7);
          v108(v120, v101);
          uint64_t v123 = v257;
          v122(v257, v237, v7);
          unint64_t v124 = v255;
          v122(v255, (uint64_t)v121, v7);
          uint64_t v125 = v256;
          v122(v256, (uint64_t)v123, v7);
          int64x2_t v274 = *(char **)(v111 + 24);
          char v126 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v274)(v124, v125, v7, v111);
          uint64_t v127 = v273;
          if (v126)
          {
            uint64_t v128 = v280;
            v280(v125, v7);
            v128(v124, v7);
            unint64_t v129 = TupleTypeMetadata2;
            uint64_t v130 = &v127[*((int *)TupleTypeMetadata2 + 12)];
            unint64_t v131 = v282 + 4;
            unint64_t v132 = (void (*)(char *, char *, uint64_t))v282[4];
            v132(v127, v266, v7);
            int64x2_t v265 = v130;
            v132(v130, v123, v7);
            uint64_t v133 = v271;
            uint64_t v134 = &v271[*((int *)v129 + 12)];
            char v135 = (void (*)(char *, char *, uint64_t))v268;
            v268(v271, (uint64_t)v127, v7);
            v135(v134, v130, v7);
            uint64_t v136 = (uint64_t)v272;
            v132(v272, v133, v7);
            v280(v134, v7);
            uint64_t v137 = &v133[*((int *)v129 + 12)];
            v132(v133, v127, v7);
            v132(v137, v265, v7);
            uint64_t v138 = (uint64_t)v277;
            uint64_t v139 = v136 + *((int *)v277 + 9);
            uint8x16_t v282 = v131;
            int64x2_t v266 = (char *)v132;
            v132((char *)v139, v137, v7);
            Swift::String::Index v140 = v133;
            v280(v133, v7);
            Swift::String::Index v141 = *(char **)(v281 + 32);
            v281 += 32;
            int64x2_t v265 = v141;
            ((void (*)(char *, uint64_t, uint64_t))v141)(v235, v136, v138);
            Swift::Int v142 = v247;
            Swift::Int v143 = v268;
            v268(v247, v236, v7);
            uint64_t v144 = (uint64_t)v232;
            ContiguousArray.subscript.getter(v234, *v278, v138, (uint64_t)v232);
            atomic_ullong v145 = v250;
            v143(v250, v144 + *(int *)(v138 + 36), v7);
            v240(v144, v138);
            unint64_t v146 = v248;
            v143(v248, (uint64_t)v142, v7);
            unint64_t v147 = v249;
            v143(v249, (uint64_t)v145, v7);
            if (((uint64_t (*)(char *, char *, uint64_t, uint64_t))v274)(v146, v147, v7, v275))
            {
              uint64_t v148 = v280;
              v280(v147, v7);
              v148(v146, v7);
              uint64_t v149 = TupleTypeMetadata2;
              unint64_t v150 = v273;
              unint64_t v151 = &v273[*((int *)TupleTypeMetadata2 + 12)];
              char v152 = v142;
              uint64_t v153 = (void (*)(char *, char *, uint64_t))v266;
              ((void (*)(char *, char *, uint64_t))v266)(v273, v152, v7);
              v153(v151, v145, v7);
              unint64_t v154 = &v140[*((int *)v149 + 12)];
              uint64_t v155 = (void (*)(char *, char *, uint64_t))v268;
              v268(v140, (uint64_t)v150, v7);
              v155(v154, v151, v7);
              uint64_t v156 = (uint64_t)v272;
              v153(v272, v140, v7);
              uint64_t v157 = v280;
              v280(v154, v7);
              unint64_t v158 = &v140[*((int *)v149 + 12)];
              v153(v140, v150, v7);
              v153(v158, v151, v7);
              uint64_t v159 = (uint64_t)v277;
              v153((char *)(v156 + *((int *)v277 + 9)), v158, v7);
              v157(v140, v7);
              int64_t v160 = v242;
              char v161 = (void (*)(char *, char *, uint64_t))v265;
              ((void (*)(char *, uint64_t, uint64_t))v265)(v242, v156, v159);
              uint64_t v162 = v243;
              v161(v243, v235, v159);
              unint64_t v163 = swift_getTupleTypeMetadata2(0, v159, v159, "first second ", 0);
              v161(&v162[*((int *)v163 + 12)], v160, v159);
              Swift::String::Index v167 = type metadata accessor for ContiguousArray(0, v159, v164, v165);
              Swift::String::Index v168 = (int *)&protocol conformance descriptor for _Pair<A>;
              p_TupleTypeMetadata2 = &TupleTypeMetadata2;
LABEL_13:
              unint64_t v197 = (unint64_t *)*(p_TupleTypeMetadata2 - 32);
              uint64_t WitnessTable = swift_getWitnessTable(v168, v197, v166);
              uint64_t v200 = v270;
              uint64_t v201 = v239;
              uint64_t v202 = (uint64_t)v162;
              goto LABEL_14;
            }
          }
        }
        else
        {
          uint64_t v203 = v259;
          ContiguousArray.subscript.getter(v270, v119, v101, v259);
          char v204 = v264;
          unint64_t v205 = v268;
          v268(v264, v203, v7);
          v118(v203, v101);
          unint64_t v206 = v265;
          v205(v265, v237, v7);
          unint64_t v207 = v253;
          v205(v253, (uint64_t)v204, v7);
          int64x2_t v208 = v254;
          v205(v254, (uint64_t)v206, v7);
          char v209 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v111 + 24))(v207, v208, v7, v111);
          Swift::String::Index v210 = v273;
          if (v209)
          {
            Swift::String::Index v211 = v280;
            v280(v208, v7);
            v211(v207, v7);
            Swift::String::Index v212 = TupleTypeMetadata2;
            Swift::Int v213 = &v210[*((int *)TupleTypeMetadata2 + 12)];
            uint64x2_t v214 = (void (*)(char *, char *, uint64_t))v282[4];
            v214(v210, v264, v7);
            int8x16_t v279 = v213;
            v214(v213, v265, v7);
            uint64_t v215 = v271;
            uint64x2_t v216 = &v271[*((int *)v212 + 12)];
            v205(v271, (uint64_t)v210, v7);
            v205(v216, (uint64_t)v213, v7);
            uint64_t v217 = (uint64_t)v272;
            v214(v272, v215, v7);
            uint64_t v218 = v280;
            v280(v216, v7);
            unint64_t v219 = &v215[*((int *)TupleTypeMetadata2 + 12)];
            v214(v215, v210, v7);
            v214(v219, v279, v7);
            uint64_t v220 = (uint64_t)v277;
            v214((char *)(v217 + *((int *)v277 + 9)), v219, v7);
            v218(v215, v7);
            uint64_t v221 = *(void (**)(char *, uint64_t, uint64_t))(v281 + 32);
            unint64_t v222 = v246;
            v221(v246, v217, v220);
            uint64_t v162 = v260;
            v221(v260, (uint64_t)v222, v220);
            Swift::String::Index v167 = type metadata accessor for ContiguousArray(0, v220, v223, v224);
            Swift::String::Index v168 = protocol conformance descriptor for CollectionOfOne<A>;
            p_TupleTypeMetadata2 = (uint64_t **)&v283;
            goto LABEL_13;
          }
        }
      }
      else
      {
        uint64_t v170 = v239;
        unint64_t v171 = v270;
        if ((v112 & 1) == 0)
        {
          uint64_t v227 = type metadata accessor for ContiguousArray(0, v101, v115, v116);
          uint64_t v230 = (unint64_t *)type metadata accessor for EmptyCollection(0, v101, v228, v229);
          uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, v230, v231);
          uint64_t v200 = v171;
          uint64_t v201 = v170;
          uint64_t v225 = (uint64_t)v227;
          uint64_t v226 = (uint64_t)v230;
          goto LABEL_16;
        }
        int64x2_t v267 = v91;
        unint64_t v172 = v262;
        unint64_t v173 = v268;
        unint64_t v174 = v108;
        v268(v262, v236, v7);
        uint64_t v175 = *v102;
        uint64_t v176 = v258;
        ContiguousArray.subscript.getter(v234, v175, v101, v258);
        unint64_t v177 = v263;
        v173(v263, v176 + *(int *)(v101 + 36), v7);
        v174(v176, v101);
        char v178 = v251;
        v173(v251, (uint64_t)v172, v7);
        unint64_t v179 = v252;
        v173(v252, (uint64_t)v177, v7);
        if ((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v111 + 24))(v178, v179, v7, v111))
        {
          unint64_t v180 = v179;
          unsigned int v181 = v280;
          v280(v180, v7);
          v181(v178, v7);
          size_t v182 = TupleTypeMetadata2;
          char v183 = v273;
          unint64_t v184 = &v273[*((int *)TupleTypeMetadata2 + 12)];
          unint64_t v185 = (void (*)(char *, char *, uint64_t))v282[4];
          v185(v273, v262, v7);
          int8x16_t v279 = v184;
          v185(v184, v263, v7);
          unint64_t v186 = v271;
          unint64_t v187 = &v271[*((int *)v182 + 12)];
          unint64_t v188 = (void (*)(char *, char *, uint64_t))v268;
          v268(v271, (uint64_t)v183, v7);
          v188(v187, v184, v7);
          uint64_t v189 = (uint64_t)v272;
          v185(v272, v186, v7);
          char v190 = v280;
          v280(v187, v7);
          uint64_t v191 = &v186[*((int *)TupleTypeMetadata2 + 12)];
          v185(v186, v183, v7);
          v185(v191, v279, v7);
          v185((char *)(v189 + *(int *)(v101 + 36)), v191, v7);
          v190(v186, v7);
          unint64_t v192 = *(void (**)(char *, uint64_t, uint64_t))(v281 + 32);
          unint64_t v193 = v245;
          v192(v245, v189, v101);
          unint64_t v194 = v260;
          v192(v260, (uint64_t)v193, v101);
          Swift::String::Index v167 = type metadata accessor for ContiguousArray(0, v101, v195, v196);
          unint64_t v197 = v261;
          uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v261, v198);
          uint64_t v200 = v270;
          uint64_t v201 = v239;
          uint64_t v202 = (uint64_t)v194;
LABEL_14:
          uint64_t v225 = (uint64_t)v167;
          uint64_t v226 = (uint64_t)v197;
LABEL_16:
          ContiguousArray.replaceSubrange<A>(_:with:)(v200, v201, v202, v225, v226, WitnessTable);
          return;
        }
      }
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
}

uint64_t static RangeSet.== infix(_:_:)(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a3;
  uint64_t v50 = a4;
  uint64_t v7 = type metadata accessor for Range(0, a3, a4, a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v37 - v15;
  uint64_t v17 = *a1;
  uint64_t v18 = *a2;
  atomic_ullong v19 = (*a1)[2];
  if (v19 != v18[2]) {
    return 0;
  }
  if (!v19 || v17 == v18) {
    return 1;
  }
  uint64_t v52 = v14;
  uint64_t v45 = v13;
  uint64_t v46 = v12;
  unint64_t v20 = (*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);
  uint64_t v41 = (char *)v18 + v20;
  uint64_t v47 = v8 + 16;
  uint64_t v48 = (char *)v17 + v20;
  uint64_t v40 = (void (**)(uint64_t, char *, Class *))(v8 + 32);
  uint64_t v42 = (void (**)(uint64_t, Class *))(v8 + 8);
  swift_retain(v17);
  swift_retain(v18);
  unint64_t v21 = 0;
  uint64_t v38 = v16;
  uint64_t v39 = v8;
  uint64_t v43 = v17;
  uint64_t v44 = v18;
  atomic_ullong v37 = v19;
  do
  {
    BOOL v49 = v19 == v21;
    if (v19 == v21) {
      break;
    }
    if (v21 >= v17[2]
      || (unint64_t v22 = *(void *)(v8 + 72) * v21,
          uint64_t v23 = *(void (**)(char *, char *, Class *))(v8 + 16),
          v23(v16, &v48[v22], v7),
          v21 >= v18[2]))
    {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
    uint64_t v24 = v16;
    uint64_t v25 = v4;
    uint64_t v26 = v52;
    v23(v52, &v41[v22], v7);
    uint64_t v27 = *(void *)(v50 + 8);
    uint64_t v28 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 8);
    int v51 = v28(v24, v26, v25, v27);
    uint64_t v29 = *v40;
    uint64_t v30 = v45;
    (*v40)(v45, v24, v7);
    uint64_t v31 = v7;
    uint64_t v32 = v46;
    v29(v46, v52, v31);
    if ((v51 & 1) == 0)
    {
      uint64_t v36 = *v42;
      (*v42)(v32, v31);
      v36(v30, v31);
      uint64_t v17 = v43;
      uint64_t v18 = v44;
      break;
    }
    char v33 = v28((char *)(v30 + *((int *)v31 + 9)), (char *)(v32 + *((int *)v31 + 9)), v25, v27);
    uint64_t v34 = *v42;
    (*v42)(v32, v31);
    v34(v30, v31);
    ++v21;
    uint64_t v7 = v31;
    uint64_t v17 = v43;
    uint64_t v18 = v44;
    uint64_t v4 = v25;
    uint64_t v16 = v38;
    uint64_t v8 = v39;
    atomic_ullong v19 = v37;
  }
  while ((v33 & 1) != 0);
  swift_release((uint64_t)v17);
  swift_release((uint64_t)v18);
  return v49;
}

BOOL static RangeSet.Ranges.== infix(_:_:)(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v49 = a4;
  uint64_t v7 = type metadata accessor for Range(0, a3, a4, a4);
  uint64_t v50 = (uint64_t)*(v7 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)v37 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = *a1;
  uint64_t v17 = *a2;
  uint64_t v18 = *(void *)(*a1 + 16);
  if (v18 == *(void *)(*a2 + 16))
  {
    uint64_t v48 = (char *)v37 - v13;
    if (!v18 || v16 == v17)
    {
      return 1;
    }
    else
    {
      uint64_t v44 = v15;
      uint64_t v45 = v14;
      unint64_t v19 = 0;
      unint64_t v20 = (*(unsigned __int8 *)(v50 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v50 + 80);
      uint64_t v46 = a3;
      uint64_t v47 = v16 + v20;
      uint64_t v42 = v17 + v20;
      uint64_t v40 = v16;
      uint64_t v41 = (void (**)(uint64_t, char *, Class *))(v50 + 32);
      uint64_t v43 = (void (**)(char *, Class *))(v50 + 8);
      uint64_t v38 = v18;
      uint64_t v39 = v17;
      v37[1] = v50 + 16;
      do
      {
        BOOL v51 = v18 == v19;
        if (v18 == v19) {
          break;
        }
        if (v19 >= *(void *)(v16 + 16)
          || (uint64_t v21 = *(void *)(v50 + 72) * v19,
              unint64_t v22 = v48,
              uint64_t v23 = *(void (**)(char *, uint64_t, Class *))(v50 + 16),
              v23(v48, v47 + v21, v7),
              unint64_t v24 = *(void *)(v17 + 16),
              unint64_t v52 = v19,
              v19 >= v24))
        {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
        uint64_t v25 = v44;
        v23(v44, v42 + v21, v7);
        uint64_t v26 = *(void *)(v49 + 8);
        uint64_t v27 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v26 + 8);
        uint64_t v28 = v46;
        int v53 = v27(v22, v25, v46, v26);
        uint64_t v29 = v7;
        uint64_t v30 = v22;
        uint64_t v31 = *v41;
        uint64_t v32 = v45;
        (*v41)((uint64_t)v45, v30, v29);
        v31((uint64_t)v10, v25, v29);
        if ((v53 & 1) == 0)
        {
          uint64_t v36 = *v43;
          (*v43)(v10, v29);
          v36(v32, v29);
          return 0;
        }
        char v33 = v27(&v32[*((int *)v29 + 9)], &v10[*((int *)v29 + 9)], v28, v26);
        uint64_t v34 = *v43;
        (*v43)(v10, v29);
        v34(v32, v29);
        unint64_t v19 = v52 + 1;
        uint64_t v7 = v29;
        uint64_t v17 = v39;
        uint64_t v16 = v40;
        uint64_t v18 = v38;
      }
      while ((v33 & 1) != 0);
    }
  }
  else
  {
    return 0;
  }
  return v51;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance RangeSet<A>(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return static RangeSet.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t RangeSet<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = a3;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v25 = *(void *)(a2 + 16);
  uint64_t v23 = type metadata accessor for Range(0, v25, v6, a4);
  uint64_t v27 = (uint64_t)*(v23 - 1);
  MEMORY[0x1F4188790](v23);
  unint64_t v22 = (char *)v21 - v7;
  uint64_t v8 = *v4;
  Swift::UInt v9 = (*v4)[2];
  uint64_t v26 = a1;
  Hasher._combine(_:)(v9);
  swift_retain(v8);
  Swift::UInt v24 = v9;
  if (v9)
  {
    unint64_t v10 = 0;
    uint64_t v11 = v28;
    uint64_t v12 = v27;
    void v21[2] = v28 + 24;
    v21[3] = v27 + 16;
    v21[1] = v27 + 8;
    uint64_t v14 = v22;
    uint64_t v13 = v23;
    uint64_t v15 = v25;
    do
    {
      if (v10 >= v8[2]) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      }
      unint64_t v29 = v10 + 1;
      (*(void (**)(char *, unint64_t, Class *))(v12 + 16))(v14, (unint64_t)v8+ ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))+ *(void *)(v12 + 72) * v10, v13);
      uint64_t v16 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 24);
      uint64_t v17 = v8;
      uint64_t v18 = v26;
      v16(v26, v15, v11);
      uint64_t v19 = v18;
      uint64_t v8 = v17;
      v16(v19, v15, v11);
      (*(void (**)(char *, Class *))(v12 + 8))(v14, v13);
      unint64_t v10 = v29;
    }
    while (v24 != v29);
  }
  return swift_release((uint64_t)v8);
}

Swift::Int RangeSet<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *v4;
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  RangeSet<>.hash(into:)((uint64_t)v6, a1, a2, a4);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> RangeSet<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeSet<>.hashValue.getter(a1, *(void *)(a2 - 8), a3, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> RangeSet<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeSet<>.hash(into:)(a1, a2, *(void *)(a3 - 8), a4);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))RangeSet<>.hash(into:));
}

uint64_t RangeSet.init<A, B>(_:within:)@<X0>(char **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X4>, int **a6@<X5>, uint64_t a7@<X6>, __objc2_class ***a8@<X8>)
{
  unint64_t v106 = a4;
  uint64_t v107 = a6;
  uint64_t v97 = a2;
  uint64_t v103 = a1;
  uint64_t v77 = a8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a3, a3, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v92 = (char *)&v75 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v91 = (char *)&v75 - v13;
  uint64_t v95 = a7;
  uint64_t v98 = a5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a5, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = (uint64_t *)type metadata accessor for Range(0, a3, AssociatedConformanceWitness, v14);
  unint64_t v102 = (char *)*(v15 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  uint64_t v90 = (char *)&v75 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v89 = (char *)&v75 - v19;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v75 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  uint64_t v26 = (char *)&v75 - v25;
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  unint64_t v29 = (char *)&v75 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v31 = (char *)&v75 - v30;
  uint64_t v34 = type metadata accessor for Optional(0, a3, v32, v33);
  MEMORY[0x1F4188790](v34 - 1);
  uint64_t v36 = (char *)&v75 - v35;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v107, (uint64_t)v106, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v76 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v99 = (char *)&v75 - v37;
  _swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
  uint64_t v94 = v15;
  uint64_t v38 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v15);
  uint64_t v96 = v36;
  if (v38)
  {
    uint64_t v41 = (__objc2_class **)v38;
  }
  else
  {
    uint64_t v109 = &_swiftEmptyArrayStorage;
    uint64_t v42 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v94, v39, v40);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v42, v43);
    uint64_t v41 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v109, (uint64_t)v42, WitnessTable);
  }
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v109 = v41;
  uint64_t v46 = v106;
  uint64_t v45 = v107;
  ((void (*)(void *, int **))v107[4])(v106, v107);
  uint64_t v47 = (uint64_t)v45;
  uint64_t v48 = AssociatedTypeWitness;
  uint64_t v49 = swift_getAssociatedConformanceWitness(v47, (uint64_t)v46, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v50 = *(void (**)(const char *, uint64_t))(v49 + 16);
  BOOL v51 = v48;
  unint64_t v52 = v96;
  uint64_t v88 = v49;
  uint64_t v87 = v49 + 16;
  uint64_t v86 = v50;
  ((void (*)(const char *))v50)(v51);
  int v53 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48);
  uint64_t v85 = v20 + 48;
  uint64_t v84 = v53;
  if (v53(v52, 1, a3) != 1)
  {
    uint64_t v55 = *(int ***)(v20 + 32);
    uint64_t v54 = v20 + 32;
    uint64_t v107 = v55;
    uint64_t v83 = v95 + 184;
    unint64_t v106 = (void *)(v54 - 16);
    uint64_t v82 = AssociatedConformanceWitness + 24;
    uint64_t v103 = (char **)(v54 - 24);
    unint64_t v79 = (void (**)(char *, char *, uint64_t))(v102 + 32);
    char v78 = (void (**)(uint64_t, uint64_t))(v102 + 8);
    uint64_t v81 = v23;
    uint64_t v80 = v26;
    uint64_t v104 = v31;
    uint64_t v105 = v29;
    do
    {
      ((void (*)(char *, char *, uint64_t))v107)(v31, v52, a3);
      (*(void (**)(char *, uint64_t))(v95 + 184))(v31, v98);
      uint64_t v56 = (void (*)(char *, char *, uint64_t))*v106;
      ((void (*)(char *, char *, uint64_t))*v106)(v26, v31, a3);
      v56(v23, v29, a3);
      if (((*(uint64_t (**)(char *, char *, uint64_t))(AssociatedConformanceWitness + 24))(v26, v23, a3) & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      }
      uint64_t v57 = *v103;
      unint64_t v102 = v57;
      ((void (*)(char *, uint64_t))v57)(v23, a3);
      ((void (*)(char *, uint64_t))v57)(v26, a3);
      uint64_t v58 = TupleTypeMetadata2;
      uint64_t v59 = v91;
      uint64_t v60 = &v91[*((int *)TupleTypeMetadata2 + 12)];
      v56(v91, v104, a3);
      uint64_t v101 = v60;
      uint64_t v61 = v107;
      ((void (*)(char *, char *, uint64_t))v107)(v60, v105, a3);
      uint64_t v62 = v92;
      uint64_t v63 = &v92[*((int *)v58 + 12)];
      v56(v92, v59, a3);
      v56(v63, v60, a3);
      uint64_t v64 = v90;
      ((void (*)(char *, char *, uint64_t))v61)(v90, v62, a3);
      uint64_t v65 = (void (*)(void))v102;
      ((void (*)(char *, uint64_t))v102)(v63, a3);
      uint64_t v66 = *((int *)v58 + 12);
      uint64_t v67 = (uint64_t)v94;
      uint64_t v68 = &v62[v66];
      uint64_t v69 = v59;
      uint64_t v26 = v80;
      ((void (*)(char *, char *, uint64_t))v61)(v62, v69, a3);
      ((void (*)(char *, char *, uint64_t))v61)(v68, v101, a3);
      ((void (*)(char *, char *, uint64_t))v61)(&v64[*(int *)(v67 + 36)], v68, a3);
      ((void (*)(char *, uint64_t))v65)(v62, a3);
      uint64_t v70 = (uint64_t)v89;
      (*v79)(v89, v64, v67);
      uint64_t v72 = type metadata accessor for RangeSet.Ranges(0, a3, AssociatedConformanceWitness, v71);
      RangeSet.Ranges._insert(contentsOf:)(v70, (uint64_t)v72);
      uint64_t v73 = v70;
      uint64_t v23 = v81;
      (*v78)(v73, v67);
      uint64_t v31 = v104;
      v65();
      unint64_t v29 = v105;
      unint64_t v52 = v96;
      v86(AssociatedTypeWitness, v88);
    }
    while (v84(v52, 1, a3) != 1);
  }
  (*(void (**)(uint64_t))(*(void *)(v98 - 8) + 8))(v97);
  uint64_t result = (*(uint64_t (**)(char *, const char *))(v76 + 8))(v99, AssociatedTypeWitness);
  char *v77 = v109;
  return result;
}

uint64_t RangeSet.insert<A>(_:within:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v56 = a2;
  uint64_t v57 = a4;
  uint64_t v8 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v8, v8, "lower upper ", 0);
  uint64_t v9 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v48 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v54 = (char *)&v48 - v13;
  uint64_t v14 = *(void *)(v8 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v48 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v48 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v48 - v21;
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v49 = type metadata accessor for Range(0, v8, v23, v24);
  uint64_t v55 = (uint64_t)*(v49 - 1);
  uint64_t v25 = MEMORY[0x1F4188790](v49);
  BOOL v51 = (char *)&v48 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v25);
  unint64_t v52 = (char *)&v48 - v27;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 184))(a1, v57, a5);
  uint64_t v53 = v14;
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v56 = a1;
  v28(v20, a1, v8);
  uint64_t v50 = v22;
  v28(v17, (uint64_t)v22, v8);
  unint64_t v29 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v23 + 24);
  uint64_t v57 = v23;
  if ((v29(v20, v17, v8, v23) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v30 = TupleTypeMetadata2;
  uint64_t v31 = v53;
  uint64_t v32 = *(void (**)(char *, uint64_t))(v53 + 8);
  uint64_t v48 = v32;
  v32(v17, v8);
  v32(v20, v8);
  uint64_t v33 = *((int *)v30 + 12);
  uint64_t v34 = v30;
  uint64_t v35 = v54;
  uint64_t v36 = &v54[v33];
  v28(v54, v56, v8);
  uint64_t v37 = *(void (**)(char *, char *, uint64_t))(v31 + 32);
  v37(v36, v50, v8);
  uint64_t v38 = &v11[*((int *)v34 + 12)];
  v28(v11, (uint64_t)v35, v8);
  v28(v38, (uint64_t)v36, v8);
  uint64_t v39 = v51;
  v37(v51, v11, v8);
  uint64_t v40 = v48;
  v48(v38, v8);
  uint64_t v41 = &v11[*((int *)TupleTypeMetadata2 + 12)];
  v37(v11, v35, v8);
  v37(v41, v36, v8);
  uint64_t v42 = v49;
  v37(&v39[*((int *)v49 + 9)], v41, v8);
  v40(v11, v8);
  uint64_t v43 = v55;
  uint64_t v44 = (uint64_t)v52;
  (*(void (**)(char *, char *, Class *))(v55 + 32))(v52, v39, v42);
  uint64_t v46 = type metadata accessor for RangeSet.Ranges(0, v8, v57, v45);
  LOBYTE(v39) = RangeSet.Ranges._insert(contentsOf:)(v44, (uint64_t)v46);
  (*(void (**)(uint64_t, Class *))(v43 + 8))(v44, v42);
  return v39 & 1;
}

uint64_t RangeSet.remove<A>(_:within:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v58 = a2;
  uint64_t v59 = a4;
  uint64_t v8 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v8, v8, "lower upper ", 0);
  uint64_t v9 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v49 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v54 = (char *)&v49 - v13;
  uint64_t v14 = *(void *)(v8 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v49 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v49 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v49 - v21;
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v55 = type metadata accessor for Range(0, v8, v23, v24);
  uint64_t v57 = (uint64_t)*(v55 - 1);
  uint64_t v25 = MEMORY[0x1F4188790](v55);
  uint64_t v60 = (char *)&v49 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v25);
  uint64_t v56 = (char *)&v49 - v27;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 184))(a1, v59, a5);
  uint64_t v52 = v14;
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v58 = a1;
  v28(v20, a1, v8);
  uint64_t v53 = v22;
  v28(v17, (uint64_t)v22, v8);
  unint64_t v29 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v23 + 24);
  uint64_t v59 = v23;
  if ((v29(v20, v17, v8, v23) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v30 = v52;
  uint64_t v31 = *(void (**)(char *, uint64_t))(v52 + 8);
  BOOL v51 = v31;
  v31(v17, v8);
  v31(v20, v8);
  uint64_t v32 = TupleTypeMetadata2;
  uint64_t v33 = v54;
  uint64_t v34 = &v54[*((int *)TupleTypeMetadata2 + 12)];
  v28(v54, v58, v8);
  uint64_t v35 = *(void (**)(char *, char *, uint64_t))(v30 + 32);
  uint64_t v50 = v34;
  v35(v34, v53, v8);
  uint64_t v36 = &v11[*((int *)v32 + 12)];
  v28(v11, (uint64_t)v33, v8);
  v28(v36, (uint64_t)v34, v8);
  v35(v60, v11, v8);
  uint64_t v37 = v51;
  v51(v36, v8);
  uint64_t v38 = &v11[*((int *)TupleTypeMetadata2 + 12)];
  v35(v11, v33, v8);
  v35(v38, v50, v8);
  uint64_t v39 = v55;
  uint64_t v40 = v60;
  v35(&v60[*((int *)v55 + 9)], v38, v8);
  v37(v11, v8);
  uint64_t v42 = (uint64_t)v56;
  uint64_t v41 = v57;
  (*(void (**)(char *, char *, Class *))(v57 + 32))(v56, v40, v39);
  uint64_t v43 = v59;
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v59 + 8) + 8))(v42, v42 + *((int *)v39 + 9), v8) & 1) == 0)
  {
    uint64_t v45 = type metadata accessor for RangeSet.Ranges(0, v8, v43, v44);
    RangeSet.Ranges._remove(contentsOf:)(v42, (uint64_t)v45, v46, v47);
  }
  return (*(uint64_t (**)(uint64_t, Class *))(v41 + 8))(v42, v39);
}

void RangeSet.Ranges._gaps(boundedBy:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  Swift::String::Index v169 = a3;
  uint64_t v6 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v9 = (char *)v137 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  Swift::String::Index v167 = (char *)v137 - v10;
  uint64_t v11 = *(void *)(a2 + 24);
  uint64_t v13 = type metadata accessor for Range(0, v6, v11, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)v137 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v154 = (char *)v137 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v166 = (char *)v137 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v161 = (char *)v137 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v171 = (char *)v137 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v164 = (char *)v137 - v27;
  uint64_t v28 = *(void *)(v6 - 8);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  uint64_t v157 = (char *)v137 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v156 = (char *)v137 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  unint64_t v158 = (char *)v137 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v155 = (char *)v137 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  unint64_t v163 = (char *)v137 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v162 = (char *)v137 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  unint64_t v173 = (char *)v137 - v42;
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  unint64_t v172 = (char *)v137 - v44;
  MEMORY[0x1F4188790](v43);
  uint64_t v46 = (char *)v137 - v45;
  uint64_t v47 = *v3;
  uint64_t v175 = a1;
  uint64_t v176 = v11;
  uint64_t v48 = specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, v47, 1, v6, v11);
  if (v48 == v49)
  {
    uint64_t v50 = v169;
    (*(void (**)(char *, uint64_t, Class *))(v14 + 16))(v17, v175, v13);
    uint64_t v53 = (unint64_t *)type metadata accessor for _ContiguousArrayStorage(0, (uint64_t)v13, v51, v52);
    uint64_t v54 = swift_allocObject(v53, ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80))+ *(void *)(v14 + 72), *(unsigned __int8 *)(v14 + 80) | 7);
    uint64_t v55 = (__objc2_class **)static Array._adoptStorage(_:count:)(v54, 1);
    (*(void (**)(uint64_t, char *, Class *))(v14 + 32))(v56, v17, v13);
    uint64_t v57 = _ArrayBuffer.requestNativeBuffer()((unint64_t)v55, (uint64_t *)v13);
    if (v57)
    {
LABEL_5:
      uint64_t v64 = v57;
      goto LABEL_6;
    }
    char v178 = v55;
    uint64_t v60 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v13, v58, v59);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v60, v61);
    uint64_t v63 = &v178;
LABEL_4:
    uint64_t v57 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)v63, (uint64_t)v60, WitnessTable);
    goto LABEL_5;
  }
  Swift::Int v65 = v48;
  Swift::Int v66 = v49;
  uint64_t v153 = v9;
  _swift_isClassOrObjCExistentialType((uint64_t)v13, (uint64_t *)v13);
  uint64_t v67 = *(unsigned __int8 *)(v14 + 80);
  char v178 = &_swiftEmptyArrayStorage;
  uint64_t v68 = *(void (**)(void, void, void))(v28 + 16);
  uint64_t v165 = v46;
  uint64_t v170 = v68;
  v68(v46, v175, v6);
  ContiguousArray._checkIndex(_:)(v65);
  ContiguousArray._checkIndex(_:)(v66);
  if (v66 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  uint64_t v152 = v6;
  uint64_t v160 = v28 + 16;
  uint64_t v69 = (char *)v47 + ((v67 + 32) & ~v67);
  uint64_t v70 = v14 + 16;
  uint64_t v71 = v14 + 32;
  uint64_t v151 = v176 + 24;
  Swift::String::Index v168 = (void (**)(char *, uint64_t))(v28 + 8);
  unint64_t v150 = (void (**)(char *, char *, uint64_t))(v28 + 32);
  uint64_t v72 = (void (**)(uint64_t, Class *))(v14 + 8);
  uint64_t v73 = v172;
  uint64_t v74 = v173;
  do
  {
    if (v65 >= v66) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/SliceBuffer.swift", 23, 2, 0x132uLL, 0);
    }
    Swift::Int v144 = v66;
    unint64_t v147 = v72;
    uint64_t v75 = *(void *)(v14 + 72);
    Swift::Int v145 = v65;
    Swift::Int v143 = v69;
    uint64_t v76 = &v69[v75 * v65];
    uint64_t v77 = *(void (**)(char *, char *, Class *))(v14 + 16);
    char v78 = v164;
    uint64_t v142 = v70;
    v77(v164, v76, v13);
    uint64_t v146 = v14;
    unint64_t v79 = *(void (**)(char *, char *, Class *))(v14 + 32);
    uint64_t v80 = v171;
    uint64_t v159 = v71;
    v79(v171, v78, v13);
    uint64_t v81 = v165;
    uint64_t v82 = v152;
    uint64_t v83 = (void (*)(char *, char *, uint64_t))v170;
    v170(v73, v165, v152);
    uint64_t v84 = v80;
    uint64_t v85 = v83;
    v83(v74, v84, v82);
    uint64_t v86 = v162;
    v83(v162, v73, v82);
    uint64_t v87 = v163;
    v85(v163, v74, v82);
    uint64_t v139 = *(uint64_t (**)(char *, char *, uint64_t))(v176 + 24);
    if ((v139(v86, v87, v82) & 1) == 0) {
      goto LABEL_23;
    }
    uint64_t v148 = v79;
    uint64_t v88 = *v168;
    (*v168)(v87, v82);
    v88(v86, v82);
    v88(v81, v82);
    uint64_t v89 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v90 = TupleTypeMetadata2;
    uint64_t v149 = v13;
    uint64_t v91 = v167;
    uint64_t v92 = &v167[v89];
    uint64_t v93 = (char *)*v150;
    (*v150)(v167, v73, v82);
    Swift::String::Index v141 = v92;
    ((void (*)(char *, char *, uint64_t))v93)(v92, v74, v82);
    uint64_t v94 = v153;
    uint64_t v95 = &v153[*((int *)v90 + 12)];
    uint64_t v96 = (void (*)(char *, char *, uint64_t))v170;
    v170(v153, v91, v82);
    v96(v95, v92, v82);
    uint64_t v97 = v166;
    ((void (*)(char *, char *, uint64_t))v93)(v166, v94, v82);
    v88(v95, v82);
    uint64_t v98 = &v94[*((int *)TupleTypeMetadata2 + 12)];
    unint64_t v99 = v91;
    uint64_t v13 = v149;
    ((void (*)(char *, char *, uint64_t))v93)(v94, v99, v82);
    ((void (*)(char *, char *, uint64_t))v93)(v98, v141, v82);
    uint64_t v100 = &v97[*((int *)v13 + 9)];
    Swift::String::Index v141 = v93;
    ((void (*)(char *, char *, uint64_t))v93)(v100, v98, v82);
    Swift::String::Index v140 = v88;
    v88(v94, v82);
    uint64_t v101 = (uint64_t)v161;
    v148(v161, v97, v13);
    uint64_t v102 = v101 + *((int *)v13 + 9);
    uint64_t v103 = *(void *)(v176 + 8);
    uint64_t v104 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v103 + 8);
    uint64_t v138 = v103;
    v137[1] = v103 + 8;
    v137[0] = v104;
    uint64_t v107 = v82;
    if (v104(v101, v102, v82))
    {
      uint64_t v72 = v147;
      (*v147)(v101, v13);
    }
    else
    {
      uint64_t v108 = type metadata accessor for Array(0, (uint64_t)v13, v105, v106);
      Array.append(_:)(v101, (uint64_t)v108);
      uint64_t v72 = v147;
    }
    uint64_t v14 = v146;
    Swift::Int v66 = v144;
    Swift::Int v65 = v145 + 1;
    uint64_t v109 = v171;
    v170(v165, &v171[*((int *)v13 + 9)], v107);
    char v110 = *v72;
    (*v72)((uint64_t)v109, v13);
    uint64_t v71 = v159;
    uint64_t v73 = v172;
    uint64_t v74 = v173;
    uint64_t v69 = v143;
    uint64_t v70 = v142;
  }
  while (v66 != v65);
  uint64_t v111 = v155;
  uint64_t v112 = v152;
  uint64_t v113 = (void (*)(char *, uint64_t, uint64_t))v170;
  v170(v155, v165, v152);
  unint64_t v114 = v158;
  v113(v158, v175 + *((int *)v13 + 9), v112);
  uint64_t v115 = v156;
  v113(v156, (uint64_t)v111, v112);
  uint64_t v116 = v157;
  v113(v157, (uint64_t)v114, v112);
  if ((((uint64_t (*)(char *, char *, uint64_t, uint64_t))v139)(v115, v116, v112, v176) & 1) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v117 = v116;
  unint64_t v118 = v140;
  v140(v117, v112);
  v118(v115, v112);
  v118(v165, v112);
  uint64_t v119 = TupleTypeMetadata2;
  uint64_t v120 = v167;
  uint64_t v121 = &v167[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v122 = v111;
  uint64_t v123 = v141;
  ((void (*)(char *, char *, uint64_t))v141)(v167, v122, v112);
  uint64_t v176 = (uint64_t)v121;
  ((void (*)(char *, char *, uint64_t))v123)(v121, v114, v112);
  unint64_t v124 = v153;
  uint64_t v125 = &v153[*((int *)v119 + 12)];
  v113(v153, (uint64_t)v120, v112);
  v113(v125, (uint64_t)v121, v112);
  char v126 = v166;
  ((void (*)(char *, char *, uint64_t))v123)(v166, v124, v112);
  v140(v125, v112);
  uint64_t v127 = &v124[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, uint64_t))v123)(v124, v120, v112);
  ((void (*)(char *, uint64_t, uint64_t))v123)(v127, v176, v112);
  uint64_t v128 = (uint64_t)v149;
  ((void (*)(char *, char *, uint64_t))v123)(&v126[*((int *)v149 + 9)], v127, v112);
  v140(v124, v112);
  uint64_t v129 = (uint64_t)v154;
  v148(v154, v126, (Class *)v128);
  if (((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v137[0])(v129, v129 + *(int *)(v128 + 36), v112, v138))
  {
    v110(v129, (Class *)v128);
  }
  else
  {
    unint64_t v132 = type metadata accessor for Array(0, v128, v130, v131);
    Array.append(_:)(v129, (uint64_t)v132);
  }
  uint64_t v50 = v169;
  uint64_t v55 = v178;
  unint64_t v133 = swift_bridgeObjectRetain((unint64_t)v178);
  uint64_t v64 = _ArrayBuffer.requestNativeBuffer()(v133, (uint64_t *)v128);
  swift_bridgeObjectRelease((uint64_t)v55);
  if (!v64)
  {
    unint64_t v177 = v55;
    uint64_t v60 = (unint64_t *)type metadata accessor for Array(0, v128, v134, v135);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v60, v136);
    uint64_t v63 = &v177;
    goto LABEL_4;
  }
LABEL_6:
  swift_bridgeObjectRelease((uint64_t)v55);
  *uint64_t v50 = v64;
}

uint64_t RangeSet.formUnion(_:)(atomic_ullong **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *v4;
  v9[0] = *a1;
  uint64_t v5 = v9[0];
  v9[1] = v6;
  uint64_t v7 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._union(_:)(v9, (uint64_t)v7, &v10);
  swift_release((uint64_t)v6);
  uint64_t result = swift_release((uint64_t)v5);
  *uint64_t v4 = v10;
  return result;
}

uint64_t RangeSet.union(_:)@<X0>(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v7 = *v4;
  v10[0] = *a1;
  uint64_t v6 = v10[0];
  v10[1] = v7;
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  RangeSet.Ranges._union(_:)(v10, (uint64_t)v8, &v11);
  swift_release((uint64_t)v7);
  uint64_t result = swift_release((uint64_t)v6);
  *a4 = v11;
  return result;
}

uint64_t RangeSet.formIntersection(_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *v4;
  v8[0] = *a1;
  v8[1] = v5;
  uint64_t v6 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._intersection(_:)(v8, (uint64_t)v6, &v9);
  uint64_t result = swift_release(v5);
  *uint64_t v4 = v9;
  return result;
}

uint64_t RangeSet.formSymmetricDifference(_:)(atomic_ullong **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *v4;
  uint64_t v14 = *a1;
  uint64_t v6 = v14;
  uint64_t v15 = v7;
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._union(_:)(&v14, (uint64_t)v8, &v16);
  uint64_t v9 = v16;
  uint64_t v14 = v6;
  uint64_t v15 = v7;
  RangeSet.Ranges._intersection(_:)((uint64_t *)&v14, (uint64_t)v8, (uint64_t *)&v16);
  swift_release((uint64_t)v6);
  swift_release((uint64_t)v7);
  uint64_t v10 = (uint64_t)v16;
  uint64_t v15 = v16;
  uint64_t v16 = v9;
  RangeSet.subtract(_:)(&v15, a2, v11, v12);
  uint64_t result = swift_release(v10);
  *uint64_t v4 = v16;
  return result;
}

uint64_t RangeSet.symmetricDifference(_:)@<X0>(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, atomic_ullong **a4@<X8>)
{
  uint64_t v8 = *v4;
  uint64_t v15 = *a1;
  uint64_t v7 = v15;
  uint64_t v16 = v8;
  uint64_t v9 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  RangeSet.Ranges._union(_:)(&v15, (uint64_t)v9, &v17);
  uint64_t v10 = v17;
  uint64_t v15 = v7;
  uint64_t v16 = v8;
  RangeSet.Ranges._intersection(_:)((uint64_t *)&v15, (uint64_t)v9, (uint64_t *)&v17);
  swift_release((uint64_t)v7);
  swift_release(v8);
  uint64_t v11 = v17;
  *a4 = v10;
  uint64_t v17 = v11;
  RangeSet.subtract(_:)(&v17, a2, v12, v13);

  return swift_release((uint64_t)v11);
}

uint64_t RangeSet.subtract(_:)(atomic_ullong **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v36 = *(void *)(a2 + 24);
  uint64_t v37 = v6;
  uint64_t v7 = type metadata accessor for Range(0, v6, v36, a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)v31 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)v31 - v12;
  uint64_t v16 = type metadata accessor for Optional(0, (uint64_t)v7, v14, v15);
  MEMORY[0x1F4188790](v16 - 1);
  uint64_t v18 = (char *)v31 - v17;
  uint64_t v19 = (uint64_t)*a1;
  unint64_t v20 = (*a1)[2];
  swift_retain(*a1);
  if (v20)
  {
    v31[1] = v4;
    unint64_t v21 = 0;
    uint64_t v22 = v8 + 16;
    uint64_t v23 = (void (**)(char *, Class *))(v8 + 8);
    uint64_t v34 = v8 + 56;
    uint64_t v35 = v8 + 32;
    v31[0] = (v8 + 56) & 0xFFFFFFFFFFFFLL | 0xA0D1000000000000;
    do
    {
      if (v21 >= v20) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      }
      uint64_t v32 = v23;
      uint64_t v33 = v22;
      (*(void (**)(char *, unint64_t, Class *))(v8 + 16))(v13, v19+ ((*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80))+ *(void *)(v8 + 72) * v21, v7);
      uint64_t v24 = *(void (**)(char *, char *, Class *))(v8 + 32);
      v24(v18, v13, v7);
      uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t, Class *))(v8 + 56);
      v25(v18, 0, 1, v7);
      v24(v11, v18, v7);
      if (((*(uint64_t (**)(char *, char *))(*(void *)(v36 + 8) + 8))(v11, &v11[*((int *)v7 + 9)]) & 1) == 0)
      {
        uint64_t v27 = type metadata accessor for RangeSet.Ranges(0, v37, v36, v26);
        RangeSet.Ranges._remove(contentsOf:)((uint64_t)v11, (uint64_t)v27, v28, v29);
      }
      ++v21;
      uint64_t v23 = v32;
      (*v32)(v11, v7);
      unint64_t v20 = *(void *)(v19 + 16);
      uint64_t v22 = v33;
    }
    while (v21 != v20);
  }
  else
  {
    uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t, Class *))(v8 + 56);
  }
  v25(v18, 1, 1, v7);
  return swift_release(v19);
}

void RangeSet.Ranges._union(_:)(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v142 = (char *)&v131 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  Swift::String::Index v141 = (char *)&v131 - v10;
  uint64_t v166 = *(void *)(a2 + 24);
  uint64_t v12 = (uint64_t *)type metadata accessor for Range(0, v7, v166, v11);
  uint64_t v135 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v149 = (char *)&v131 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  Swift::String::Index v140 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v158 = (char *)&v131 - v18;
  uint64_t v19 = *(void *)(v7 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v146 = (char *)&v131 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  Swift::Int v145 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  Swift::Int v144 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  unint64_t v147 = (char *)&v131 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v131 - v29;
  uint64_t v31 = MEMORY[0x1F4188790](v28);
  char v161 = (char *)&v131 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  uint64_t v162 = (char *)&v131 - v34;
  MEMORY[0x1F4188790](v33);
  uint64_t v136 = (char *)&v131 - v35;
  uint64_t v36 = *a1;
  uint64_t v157 = *v3;
  if (v36[2])
  {
    if (v157[2])
    {
      uint64_t v37 = v157;
      swift_retain(v157);
      swift_retain(v36);
      _swift_isClassOrObjCExistentialType((uint64_t)v12, v12);
      uint64_t v38 = *(unsigned __int8 *)(v135 + 80);
      unint64_t v173 = &_swiftEmptyArrayStorage;
      atomic_ullong v39 = v37[2];
      unint64_t v163 = v12;
      if (v39)
      {
        uint64_t v131 = a3;
        unint64_t v40 = v36[2];
        if (v40)
        {
          unint64_t v41 = 0;
          unint64_t v42 = 0;
          uint64_t v43 = (v38 + 32) & ~v38;
          unint64_t v133 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v166 + 16);
          uint64_t v44 = (void (**)(char *, char *, uint64_t))(v19 + 16);
          uint64_t v165 = (void (**)(char *, uint64_t))(v19 + 8);
          unint64_t v132 = (void (**)(char *, char *, uint64_t))(v135 + 16);
          uint64_t v159 = v166 + 32;
          uint64_t v134 = v166 + 16;
          uint64_t v139 = v166 + 24;
          uint64_t v138 = (void (**)(char *, uint64_t))(v135 + 8);
          uint64_t v137 = (void (**)(char *, char *, uint64_t))(v19 + 32);
          uint64_t v148 = (void (**)(char *, char *, uint64_t))(v135 + 32);
          uint64_t v151 = v30;
          uint64_t v152 = v43;
          uint64_t v155 = (void (**)(char *, char *, uint64_t))(v19 + 16);
          while (1)
          {
            if (v41 >= v40) {
              goto LABEL_55;
            }
            uint64_t v45 = *(void *)(v135 + 72);
            uint64_t v46 = (void (*)(void))*v44;
            (*v44)(v136, (char *)v36 + v43 + v45 * v41, v7);
            if ((v42 & 0x8000000000000000) != 0 || v42 >= v157[2]) {
              goto LABEL_55;
            }
            atomic_ullong v154 = v42;
            uint64_t v47 = v157;
            uint64_t v48 = v162;
            uint64_t v156 = v46;
            ((void (*)(char *, char *, uint64_t))v46)(v162, (char *)v157 + v43 + v45 * v42, v7);
            Swift::Int v49 = v136;
            unint64_t v167 = v41;
            LODWORD(v164) = v133(v136, v48, v7, v166);
            uint64_t v50 = *v165;
            (*v165)(v48, v7);
            Swift::String::Index v168 = v50;
            v50(v49, v7);
            if (v164) {
              unint64_t v51 = v154;
            }
            else {
              unint64_t v51 = v167;
            }
            if (v164) {
              unint64_t v52 = v167;
            }
            else {
              unint64_t v52 = v154;
            }
            if (v164) {
              uint64_t v53 = v47;
            }
            else {
              uint64_t v53 = v36;
            }
            if (v164) {
              uint64_t v47 = v36;
            }
            uint64_t v157 = v47;
            if (v52 >= v47[2]) {
LABEL_55:
            }
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
            uint64_t v54 = (uint64_t)v163;
            (*v132)(v158, (char *)v157 + v43 + v52 * v45, (uint64_t)v163);
            atomic_ullong v154 = v52 + 1;
            uint64_t v55 = v53;
            if (v51 >= v53[2])
            {
              unint64_t v41 = v51;
              uint64_t v36 = v53;
              uint64_t v44 = v155;
            }
            else
            {
              uint64_t v153 = v45;
              uint64_t v160 = &v158[*(int *)(v54 + 36)];
              unint64_t v41 = v51;
              uint64_t v44 = v155;
              uint64_t v56 = v156;
              ((void (*)(char *, char *, uint64_t))v156)(v161, v160, v7);
              while (1)
              {
                if ((v41 & 0x8000000000000000) != 0 || v41 >= v55[2]) {
                  goto LABEL_55;
                }
                unint64_t v57 = (unint64_t)v55 + v43 + v41 * v153;
                uint64_t v58 = v162;
                ((void (*)(char *, unint64_t, uint64_t))v56)(v162, v57, v7);
                uint64_t v59 = *(uint64_t (**)(char *, char *, uint64_t))(v166 + 32);
                uint64_t v60 = v161;
                unint64_t v61 = v41;
                LODWORD(v167) = v59(v161, v58, v7);
                uint64_t v62 = v168;
                v168(v58, v7);
                v62(v60, v7);
                if ((v167 & 1) == 0) {
                  break;
                }
                uint64_t v63 = v151;
                ((void (*)(char *, char *, uint64_t))v56)(v151, v160, v7);
                if (v61 >= v55[2]) {
                  goto LABEL_55;
                }
                uint64_t v164 = v55;
                unint64_t v167 = v61;
                uint64_t v64 = v162;
                ((void (*)(char *, unint64_t, uint64_t))v56)(v162, v57 + *((int *)v163 + 9), v7);
                char v65 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v59)(v63, v64, v7, v166);
                Swift::Int v66 = v64;
                uint64_t v67 = v168;
                v168(v66, v7);
                v67(v63, v7);
                if (v65)
                {
                  unint64_t v41 = v167 + 1;
                  uint64_t v55 = v164;
                  uint64_t v36 = v164;
                }
                else
                {
                  uint64_t v68 = v147;
                  ((void (*)(char *, char *, uint64_t))v56)(v147, v158, v7);
                  if (v167 >= v164[2]) {
                    goto LABEL_55;
                  }
                  uint64_t v69 = v144;
                  v56();
                  uint64_t v70 = v145;
                  ((void (*)(char *, char *, uint64_t))v56)(v145, v68, v7);
                  uint64_t v71 = v146;
                  ((void (*)(char *, char *, uint64_t))v56)(v146, v69, v7);
                  if (((*(uint64_t (**)(char *, char *, uint64_t))(v166 + 24))(v70, v71, v7) & 1) == 0) {
                    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
                  }
                  uint64_t v72 = v168;
                  v168(v71, v7);
                  v72(v70, v7);
                  (*v138)(v158, (uint64_t)v163);
                  uint64_t v73 = TupleTypeMetadata2;
                  uint64_t v74 = v141;
                  uint64_t v75 = &v141[*((int *)TupleTypeMetadata2 + 12)];
                  uint64_t v76 = *v137;
                  (*v137)(v141, v68, v7);
                  unint64_t v150 = v75;
                  v76(v75, v69, v7);
                  uint64_t v77 = v142;
                  char v78 = &v142[*((int *)v73 + 12)];
                  ((void (*)(char *, char *, uint64_t))v156)(v142, v74, v7);
                  ((void (*)(char *, char *, uint64_t))v156)(v78, v75, v7);
                  unint64_t v79 = v149;
                  v76(v149, v77, v7);
                  uint64_t v80 = v168;
                  v168(v78, v7);
                  uint64_t v81 = *((int *)v73 + 12);
                  uint64_t v82 = v7;
                  uint64_t v83 = v155;
                  uint64_t v84 = &v77[v81];
                  v76(v77, v74, v82);
                  v76(v84, v150, v82);
                  uint64_t v85 = (uint64_t)v163;
                  v76(&v79[*((int *)v163 + 9)], v84, v82);
                  uint64_t v44 = v83;
                  uint64_t v7 = v82;
                  v80(v77, v82);
                  uint64_t v56 = v156;
                  uint64_t v86 = *v148;
                  uint64_t v87 = v140;
                  (*v148)(v140, v79, v85);
                  v86(v158, v87, v85);
                  unint64_t v41 = v154;
                  atomic_ullong v154 = v167 + 1;
                  uint64_t v36 = v157;
                  uint64_t v157 = v164;
                  uint64_t v55 = v36;
                }
                uint64_t v43 = v152;
                if ((uint64_t)v41 >= v36[2]) {
                  goto LABEL_36;
                }
                ((void (*)(char *, char *, uint64_t))v56)(v161, v160, v7);
              }
              uint64_t v36 = v55;
              unint64_t v41 = v61;
              uint64_t v43 = v152;
            }
LABEL_36:
            uint64_t v88 = (uint64_t)v149;
            uint64_t v89 = (uint64_t)v163;
            (*v148)(v149, v158, (uint64_t)v163);
            uint64_t v92 = type metadata accessor for Array(0, v89, v90, v91);
            Array.append(_:)(v88, (uint64_t)v92);
            atomic_ullong v39 = v157[2];
            unint64_t v42 = v154;
            if (v154 >= v39) {
              break;
            }
            unint64_t v40 = v36[2];
            if (v41 >= v40) {
              goto LABEL_46;
            }
          }
        }
        else
        {
          unint64_t v41 = 0;
          unint64_t v42 = 0;
LABEL_46:
          if ((uint64_t)v42 < v39)
          {
            swift_release((uint64_t)v36);
            uint64_t v94 = v42;
            uint64_t v95 = v157;
            *(void *)&long long v169 = v157;
            uint64_t v96 = v163;
            unint64_t v99 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v163, v97, v98);
            uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v99, v100);
            specialized MutableCollection.subscript.getter(v94, (uint64_t)v99, WitnessTable);
            swift_release((uint64_t)v95);
            long long v169 = v171;
            long long v170 = v172;
            uint64_t v104 = type metadata accessor for Array(0, (uint64_t)v96, v102, v103);
            uint64_t v107 = (unint64_t *)type metadata accessor for ArraySlice(0, (uint64_t)v96, v105, v106);
            uint64_t v109 = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, v107, v108);
            Array.append<A>(contentsOf:)((void (*)(void, void))&v169, (uint64_t)v104, (uint64_t)v107, v109);
            a3 = v131;
            goto LABEL_52;
          }
        }
        a3 = v131;
      }
      else
      {
        unint64_t v41 = 0;
      }
      swift_release((uint64_t)v157);
      if (v41 >= v36[2])
      {
        swift_release((uint64_t)v36);
        uint64_t v96 = v163;
      }
      else
      {
        *(void *)&long long v169 = v36;
        uint64_t v96 = v163;
        uint64_t v112 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v163, v110, v111);
        uint64_t v114 = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v112, v113);
        specialized MutableCollection.subscript.getter(v41, (uint64_t)v112, v114);
        swift_release((uint64_t)v36);
        long long v169 = v171;
        long long v170 = v172;
        uint64_t v117 = type metadata accessor for Array(0, (uint64_t)v96, v115, v116);
        uint64_t v120 = (unint64_t *)type metadata accessor for ArraySlice(0, (uint64_t)v96, v118, v119);
        uint64_t v122 = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, v120, v121);
        Array.append<A>(contentsOf:)((void (*)(void, void))&v169, (uint64_t)v117, (uint64_t)v120, v122);
      }
LABEL_52:
      uint64_t v123 = v173;
      unint64_t v124 = swift_bridgeObjectRetain((unint64_t)v173);
      uint64_t v125 = _ArrayBuffer.requestNativeBuffer()(v124, v96);
      swift_bridgeObjectRelease((uint64_t)v123);
      if (!v125)
      {
        *(void *)&long long v171 = v123;
        uint64_t v128 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v96, v126, v127);
        uint64_t v130 = swift_getWitnessTable(protocol conformance descriptor for [A], v128, v129);
        uint64_t v125 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v171, (uint64_t)v128, v130);
      }
      swift_bridgeObjectRelease((uint64_t)v123);
      *a3 = v125;
      return;
    }
    *a3 = v36;
    uint64_t v93 = v36;
  }
  else
  {
    uint64_t v93 = v157;
    *a3 = v157;
  }

  swift_retain(v93);
}

void RangeSet.Ranges._intersection(_:)(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, "lower upper ", 0);
  uint64_t v8 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  Swift::Int v143 = (char *)&v124 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v142 = (char *)&v124 - v11;
  uint64_t v12 = *(void *)(v7 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v124 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v139 = (char *)&v124 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v153 = (char *)&v124 - v18;
  uint64_t v19 = *(void *)(a2 + 24);
  uint64_t v167 = v7;
  uint64_t v21 = type metadata accessor for Range(0, v7, v19, v20);
  uint64_t v22 = (uint64_t)*(v21 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  Swift::String::Index v141 = (char *)&v124 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v146 = (char *)&v124 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  Swift::String::Index v140 = (char *)&v124 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v31 = (char *)&v124 - v30;
  uint64_t v32 = MEMORY[0x1F4188790](v29);
  Swift::Int v145 = (char *)&v124 - v33;
  uint64_t v34 = (uint64_t *)MEMORY[0x1F4188790](v32);
  uint64_t v159 = (char *)&v124 - v35;
  uint64_t v36 = *a1;
  uint64_t v37 = *v3;
  Swift::String::Index v168 = v34;
  _swift_isClassOrObjCExistentialType((uint64_t)v34, v34);
  uint64_t v38 = v37;
  uint64_t v39 = *(unsigned __int8 *)(v22 + 80);
  unint64_t v40 = &_swiftEmptyArrayStorage;
  long long v170 = &_swiftEmptyArrayStorage;
  uint64_t v129 = *(void *)(v38 + 16);
  if (v129)
  {
    unint64_t v124 = a3;
    unint64_t v41 = 0;
    unint64_t v42 = 0;
    uint64_t v43 = (v39 + 32) & ~v39;
    uint64_t v128 = v38 + v43;
    uint64_t v164 = v22 + 16;
    uint64_t v148 = v19 + 24;
    unint64_t v163 = (void (**)(char *, uint64_t *))(v22 + 8);
    uint64_t v156 = v19 + 16;
    uint64_t v155 = v19 + 40;
    uint64_t v134 = (void (**)(char *, char *, uint64_t))(v12 + 16);
    uint64_t v137 = (void (**)(char *, char *, uint64_t))(v12 + 32);
    uint64_t v136 = (void (**)(char *, uint64_t))(v12 + 8);
    uint64_t v135 = (void (**)(char *, uint64_t, uint64_t *))(v22 + 32);
    uint64_t v127 = v36 + v43;
    uint64_t v138 = v15;
    uint64_t v133 = v19;
    unint64_t v132 = v31;
    uint64_t v44 = v145;
    uint64_t v126 = v22;
    uint64_t v154 = v36;
    uint64_t v125 = v38;
    do
    {
      if (v41 >= *(void *)(v38 + 16)) {
LABEL_45:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      uint64_t v47 = *(void *)(v22 + 72);
      unint64_t v130 = v41;
      uint64_t v48 = *(void (**)(char *, unint64_t, uint64_t *))(v22 + 16);
      Swift::Int v49 = v159;
      uint64_t v50 = v168;
      uint64_t v147 = v42;
      v48(v159, v128 + v47 * v41, v168);
      uint64_t v51 = *(void *)(v36 + 16);
      unint64_t v158 = (void (*)(char *, char *, uint64_t *))v48;
      v48(v44, (unint64_t)v49, v50);
      unint64_t v52 = v147;
      uint64_t v131 = (unint64_t)v163 & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      uint64_t v160 = v51;
      uint64_t v157 = v47;
      if (v147 >= v51)
      {
        uint64_t v59 = *v163;
        uint64_t v57 = v47;
        uint64_t v58 = v159;
LABEL_14:
        uint64_t v165 = v59;
        v59(v44, v168);
      }
      else
      {
        uint64_t v53 = v127 + v147 * v47;
        while (1)
        {
          if (v52 >= *(void *)(v36 + 16)) {
            goto LABEL_45;
          }
          unint64_t v54 = v52;
          uint64_t v55 = v168;
          char v56 = (*(uint64_t (**)(uint64_t, char *))(v19 + 24))(v53 + *((int *)v168 + 9), v44);
          uint64_t v165 = *v163;
          v165(v44, v55);
          if ((v56 & 1) == 0) {
            break;
          }
          unint64_t v52 = v54 + 1;
          v158(v44, v159, v168);
          uint64_t v57 = v157;
          v53 += v157;
          if (v160 == v52)
          {
            uint64_t v58 = v159;
            unint64_t v52 = v160;
            uint64_t v59 = v165;
            goto LABEL_14;
          }
        }
        uint64_t v58 = v159;
        unint64_t v52 = v54;
        uint64_t v57 = v157;
      }
      uint64_t v60 = v158;
      v158(v31, v58, v168);
      if ((uint64_t)v52 >= v160)
      {
LABEL_3:
        uint64_t v45 = v165;
        v165(v31, v168);
        unint64_t v166 = v52;
        v45(v58, v168);
LABEL_4:
        uint64_t v22 = v126;
        uint64_t v38 = v125;
        unint64_t v46 = v130;
      }
      else
      {
        uint64_t v61 = v19;
        uint64_t v62 = v36;
        uint64_t v63 = (void (*)(char *, uint64_t, uint64_t *))v60;
        uint64_t v64 = v58;
        uint64_t v65 = v61;
        Swift::Int v66 = v146;
        uint64_t v67 = v31;
        uint64_t v68 = v127 + v52 * v57;
        unint64_t v166 = v52;
        uint64_t v69 = v63;
        uint64_t v147 = v52;
        while (1)
        {
          if ((v52 & 0x8000000000000000) != 0 || v166 >= *(void *)(v62 + 16)) {
            goto LABEL_45;
          }
          uint64_t v70 = v168;
          uint64_t v71 = &v67[*((int *)v168 + 9)];
          uint64_t v72 = *(uint64_t (**)(uint64_t, char *))(v65 + 16);
          uint64_t v162 = v68;
          uint64_t v73 = v68;
          uint64_t v31 = v67;
          char v74 = v72(v73, v71);
          v165(v67, v70);
          if ((v74 & 1) == 0)
          {
            uint64_t v19 = v65;
            uint64_t v36 = v154;
            v165(v64, v168);
            goto LABEL_4;
          }
          if (v166 >= *(void *)(v154 + 16)) {
            goto LABEL_45;
          }
          uint64_t v75 = v66;
          v69(v66, v162, v168);
          uint64_t v76 = *(uint64_t (**)(char *, char *))(v65 + 40);
          uint64_t v77 = v64;
          if (v76(v64, v75))
          {
            unint64_t v78 = (unint64_t)v134;
            unint64_t v79 = *v134;
            (*v134)(v153, v64, v167);
          }
          else
          {
            uint64_t v80 = &v64[*((int *)v168 + 9)];
            char v81 = v72((uint64_t)v80, v75);
            unint64_t v78 = (unint64_t)v134;
            unint64_t v79 = *v134;
            if (v81)
            {
              uint64_t v82 = v153;
              uint64_t v83 = v80;
            }
            else
            {
              uint64_t v82 = v153;
              uint64_t v83 = v75;
            }
            v79(v82, v83, v167);
          }
          uint64_t v84 = *((int *)v168 + 9);
          uint64_t v85 = &v64[v84];
          uint64_t v86 = &v75[v84];
          char v87 = v72((uint64_t)&v77[v84], &v75[v84]);
          uint64_t v149 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v76;
          uint64_t v152 = v85;
          char v161 = v79;
          if (v87)
          {
            v165(v75, v168);
            unint64_t v88 = v78 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
            uint64_t v89 = v139;
            uint64_t v90 = v85;
            uint64_t v91 = v167;
            v79(v139, v90, v167);
          }
          else
          {
            if (v76(v77, v86))
            {
              v165(v75, v168);
              uint64_t v89 = v139;
              uint64_t v91 = v167;
              v79(v139, v77, v167);
            }
            else
            {
              uint64_t v89 = v139;
              uint64_t v91 = v167;
              v79(v139, v86, v167);
              v165(v75, v168);
            }
            unint64_t v88 = v78 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
          }
          unint64_t v151 = v88;
          uint64_t v92 = TupleTypeMetadata2;
          uint64_t v93 = v142;
          uint64_t v94 = &v142[*((int *)TupleTypeMetadata2 + 12)];
          uint64_t v95 = *v137;
          (*v137)(v142, v153, v91);
          unint64_t v150 = v94;
          v95(v94, v89, v91);
          uint64_t v96 = v143;
          uint64_t v97 = &v143[*((int *)v92 + 12)];
          uint64_t v98 = v161;
          v161(v143, v93, v91);
          v98(v97, v94, v91);
          uint64_t v99 = (uint64_t)v141;
          v95(v141, v96, v91);
          uint64_t v100 = *v136;
          (*v136)(v97, v91);
          uint64_t v101 = &v96[*((int *)v92 + 12)];
          v95(v96, v93, v91);
          v95(v101, v150, v91);
          uint64_t v102 = v168;
          v95((char *)(v99 + *((int *)v168 + 9)), v101, v91);
          uint64_t v103 = v100;
          v100(v96, v91);
          uint64_t v104 = *v135;
          uint64_t v105 = v140;
          (*v135)(v140, v99, v102);
          v104((char *)v99, (uint64_t)v105, v102);
          uint64_t v108 = type metadata accessor for Array(0, (uint64_t)v102, v106, v107);
          Array.append(_:)(v99, (uint64_t)v108);
          uint64_t v109 = v138;
          v161(v138, v152, v91);
          uint64_t v62 = v154;
          if (v166 >= *(void *)(v154 + 16)) {
            goto LABEL_45;
          }
          uint64_t v110 = v167;
          uint64_t v111 = v162;
          uint64_t v112 = v133;
          char v113 = v149(v109, v162 + *((int *)v168 + 9), v167, v133);
          v103(v109, v110);
          if ((v113 & 1) == 0) {
            break;
          }
          uint64_t v65 = v112;
          unint64_t v114 = v166 + 1;
          uint64_t v67 = v132;
          uint64_t v69 = (void (*)(char *, uint64_t, uint64_t *))v158;
          uint64_t v64 = v159;
          ((void (*)(void))v158)();
          uint64_t v68 = v111 + v157;
          unint64_t v166 = v114;
          BOOL v115 = v160 == v114;
          Swift::Int v66 = v146;
          uint64_t v44 = v145;
          unint64_t v52 = v147;
          if (v115)
          {
            unint64_t v52 = v160;
            uint64_t v31 = v67;
            uint64_t v116 = v65;
            uint64_t v58 = v64;
            uint64_t v36 = v62;
            uint64_t v19 = v116;
            goto LABEL_3;
          }
        }
        v165(v159, v168);
        uint64_t v22 = v126;
        uint64_t v31 = v132;
        uint64_t v44 = v145;
        uint64_t v38 = v125;
        unint64_t v46 = v130;
        uint64_t v36 = v62;
        uint64_t v19 = v112;
      }
      unint64_t v41 = v46 + 1;
      unint64_t v42 = v166;
    }
    while (v41 != v129);
    unint64_t v40 = v170;
    a3 = v124;
  }
  unint64_t v117 = swift_bridgeObjectRetain((unint64_t)v40);
  uint64_t v118 = _ArrayBuffer.requestNativeBuffer()(v117, v168);
  swift_bridgeObjectRelease((uint64_t)v40);
  if (!v118)
  {
    long long v169 = v40;
    uint64_t v121 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v168, v119, v120);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v121, v122);
    uint64_t v118 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v169, (uint64_t)v121, WitnessTable);
  }
  swift_bridgeObjectRelease((uint64_t)v40);
  *a3 = v118;
}

uint64_t RangeSet.subtracting(_:)@<X0>(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v6 = *a1;
  *a5 = *v5;
  uint64_t v8 = v6;
  return RangeSet.subtract(_:)(&v8, a2, a3, a4);
}

uint64_t RangeSet.isSubset(of:)(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v58 = *(void (***)(char *, uint64_t))(v4 - 8);
  MEMORY[0x1F4188790](a1);
  Swift::Int v66 = (char *)&v56 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(void *)(v6 + 24);
  uint64_t v9 = type metadata accessor for Range(0, v4, v7, v8);
  uint64_t v69 = (void (**)(void, void))*(v9 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v65 = (uint64_t)&v56 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v56 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v56 - v15;
  uint64_t v18 = *v2;
  *(void *)&long long v74 = *a1;
  uint64_t v17 = (atomic_ullong *)v74;
  uint64_t v67 = v4;
  uint64_t v20 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, v4, v7, v19);
  swift_retain(v17);
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v20, v21);
  Collection.subscript.getter((uint64_t)v20, (uint64_t)WitnessTable, (uint64_t)&v80);
  uint64_t v61 = v17;
  swift_release((uint64_t)v17);
  unint64_t v78 = v18;
  unint64_t v79 = 0;
  uint64_t v23 = v18 + 2;
  atomic_ullong v22 = v18[2];
  swift_retain(v18);
  if (v22)
  {
    uint64_t v25 = v7;
    unint64_t v26 = 0;
    uint64_t v70 = 0;
    uint64_t v64 = (char *)&v79;
    uint64_t v62 = (uint64_t (**)(char *, char *, Class *))(v69 + 4);
    uint64_t v60 = (void (**)(char *, uint64_t, uint64_t))(v58 + 2);
    ++v69;
    uint64_t v63 = v25;
    uint64_t v59 = v25 + 16;
    ++v58;
    uint64_t v27 = WitnessTable;
    uint64_t v57 = v20;
    while (1)
    {
      RangeSet.Ranges.subscript.getter(v26, (uint64_t)v20, v24, (uint64_t)v16);
      uint64_t v28 = *v23;
      *(void *)&long long v74 = 0;
      *((void *)&v74 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v28;
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v64, (uint64_t)&v74, (uint64_t)v20, v27);
      if (__OFADD__(v26, 1))
      {
        __break(1u);
LABEL_16:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      }
      uint64_t v29 = v27;
      unint64_t v79 = v26 + 1;
      uint64_t v30 = (*v62)(v14, v16, v9);
      uint64_t v31 = v81;
      long long v74 = v80;
      uint64_t v75 = v81;
      MEMORY[0x1F4188790](v30);
      uint64_t v32 = v67;
      uint64_t v33 = (uint64_t)v29;
      uint64_t v34 = v63;
      uint64_t v53 = v67;
      uint64_t v54 = v63;
      uint64_t v55 = v14;
      uint64_t v36 = (unint64_t *)type metadata accessor for Slice(0, (uint64_t)v20, v33, v35);
      swift_retain(v31);
      uint64_t v38 = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, v36, v37);
      uint64_t v39 = v70;
      Collection.firstIndex(where:)((uint64_t (*)(char *))partial apply for closure #1 in RangeSet.isSubset(of:), (uint64_t)(&v56 - 6), (uint64_t)v36, v38, (uint64_t)&v76);
      swift_release((uint64_t)v75);
      uint64_t v40 = (uint64_t)v81;
      if (v77)
      {
        swift_release((uint64_t)v81);
        swift_release((uint64_t)v78);
        (*v69)(v14, v9);
        return 0;
      }
      uint64_t v70 = v39;
      unint64_t v41 = v16;
      unint64_t v42 = v76;
      long long v72 = v80;
      uint64_t v73 = (uint64_t)v81;
      uint64_t v71 = v76;
      uint64_t v43 = v14;
      uint64_t v44 = v65;
      Slice.subscript.getter((uint64_t)&v71, (uint64_t)v36, v65);
      swift_release(v40);
      uint64_t v45 = v66;
      (*v60)(v66, v44 + *((int *)v9 + 9), v32);
      unint64_t v46 = (void (*)(char *, Class *))*v69;
      uint64_t v47 = v44;
      uint64_t v14 = v43;
      (*v69)(v47, v9);
      char v48 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 16))(v45, &v43[*((int *)v9 + 9)], v32, v34);
      (*v58)(v45, v32);
      if (v48) {
        break;
      }
      uint64_t v76 = v61;
      atomic_ullong v49 = v61[2];
      if (v49 < (uint64_t)v42) {
        goto LABEL_16;
      }
      *(void *)&long long v72 = v42;
      *((void *)&v72 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v49;
      uint64_t v50 = (uint64_t)v57;
      uint64_t v27 = WitnessTable;
      Collection<>.subscript.getter((uint64_t)&v72, (uint64_t)v57, (uint64_t)WitnessTable, (char *)&v74);
      v46(v43, v9);
      uint64_t v51 = (uint64_t)v75;
      long long v80 = v74;
      char v81 = v75;
      uint64_t v18 = v78;
      unint64_t v26 = v79;
      uint64_t v23 = v78 + 2;
      uint64_t v16 = v41;
      uint64_t v20 = (unint64_t *)v50;
      if (v79 == v78[2]) {
        goto LABEL_10;
      }
    }
    swift_release((uint64_t)v78);
    v46(v43, v9);
    return 0;
  }
  else
  {
    uint64_t v51 = (uint64_t)v81;
LABEL_10:
    swift_release((uint64_t)v18);
    swift_release(v51);
    return 1;
  }
}

uint64_t closure #1 in RangeSet.isSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Range(0, a3, a4, a4);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v19 - v11;
  uint64_t v13 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 24))(a1, a2, a3, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a2, a3);
  (*(void (**)(char *, uint64_t, Class *))(v9 + 16))(v12, a1, v8);
  if (v16) {
    char v17 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a4 + 16))(v15, &v12[*((int *)v8 + 9)], a3, a4);
  }
  else {
    char v17 = 0;
  }
  (*(void (**)(char *, Class *))(v9 + 8))(v12, v8);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v15, a3);
  return v17 & 1;
}

uint64_t RangeSet.isSuperset(of:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  v5[0] = *v2;
  v5[1] = v3;
  return RangeSet.isSubset(of:)(v5, a2) & 1;
}

uint64_t RangeSet.isStrictSubset(of:)(atomic_ullong **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *v2;
  uint64_t v8 = *a1;
  uint64_t v9 = v5;
  if (static RangeSet.== infix(_:_:)(&v9, &v8, *(void *)(a2 + 16), *(void *)(a2 + 24)))
  {
    char v6 = 0;
  }
  else
  {
    uint64_t v8 = v4;
    uint64_t v9 = v5;
    char v6 = RangeSet.isSubset(of:)(&v8, a2);
  }
  return v6 & 1;
}

uint64_t RangeSet.isStrictSuperset(of:)(atomic_ullong **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *v2;
  uint64_t v8 = v5;
  uint64_t v9 = v4;
  if (static RangeSet.== infix(_:_:)(&v9, &v8, *(void *)(a2 + 16), *(void *)(a2 + 24)))
  {
    char v6 = 0;
  }
  else
  {
    uint64_t v8 = v5;
    uint64_t v9 = v4;
    char v6 = RangeSet.isSubset(of:)(&v8, a2);
  }
  return v6 & 1;
}

BOOL RangeSet.isDisjoint(_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *v4;
  v9[0] = *a1;
  v9[1] = v5;
  char v6 = type metadata accessor for RangeSet.Ranges(0, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._intersection(_:)(v9, (uint64_t)v6, &v10);
  uint64_t v7 = *(void *)(v10 + 16);
  swift_release(v10);
  return v7 == 0;
}

uint64_t RangeSet.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v121 = *(void *)(a1 + 24);
  uint64_t v122 = v5;
  char v6 = type metadata accessor for Range(0, v5, v121, a4);
  uint64_t v7 = (uint64_t)*(v6 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  unint64_t v124 = (char *)&v115 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v115 - v11;
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v115 - v13;
  uint64_t v15 = *v4;
  swift_bridgeObjectRelease(0xE000000000000000);
  uint64_t v16 = 91;
  unint64_t v17 = 0xE100000000000000;
  uint64_t v128 = 91;
  unint64_t v129 = 0xE100000000000000;
  long long v127 = (unint64_t)v15;
  unint64_t v18 = v15[2];
  swift_retain(v15);
  if (!v18) {
    goto LABEL_47;
  }
  unint64_t v19 = 0;
  uint64_t v120 = (char *)&v127 + 8;
  uint64_t v20 = v7 + 16;
  uint64_t v123 = v7 + 32;
  char v21 = 1;
  long long v119 = xmmword_18162AC80;
  long long v117 = xmmword_18162AC90;
  Swift::UInt64 v116 = 131073;
  do
  {
    if (v19 >= v18) {
      goto LABEL_46;
    }
    unint64_t v22 = (unint64_t)v15
        + ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
        + *(void *)(v7 + 72) * v19;
    uint64_t v23 = *(void (**)(char *, unint64_t, Class *))(v7 + 16);
    uint64_t v118 = v20;
    v23(v12, v22, v6);
    uint64_t v24 = *(void (**)(char *, char *, Class *))(v7 + 32);
    v24(v14, v12, v6);
    *(void *)&long long v126 = 0;
    *((void *)&v126 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v18;
    unint64_t v26 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, v122, v121, v25);
    uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v26, v27);
    specialized Collection._failEarlyRangeCheck(_:bounds:)(v120, (uint64_t)&v126, (uint64_t)v26, WitnessTable);
    *((void *)&v127 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v19 + 1;
    v24(v124, v14, v6);
    if ((v21 & 1) == 0)
    {
      uint64_t v30 = v128;
      uint64_t v29 = v129;
      unint64_t v31 = HIBYTE(v129) & 0xF;
      if ((v129 & 0x2000000000000000) != 0) {
        unint64_t v32 = HIBYTE(v129) & 0xF;
      }
      else {
        unint64_t v32 = v128 & 0xFFFFFFFFFFFFLL;
      }
      if (!v32 && (v128 & ~v129 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v129);
        uint64_t v128 = 8236;
        unint64_t v129 = 0xE200000000000000;
        goto LABEL_41;
      }
      if ((v129 & 0x2000000000000000) != 0 && v31 <= 0xD)
      {
        unint64_t v33 = 8 * (HIBYTE(v129) & 7);
        uint64_t v34 = (-255 << v33) - 1;
        uint64_t v35 = 44 << v33;
        char v36 = v31 + 1;
        if (v31 >= 8)
        {
          uint64_t v37 = v35 | v34 & v129;
LABEL_35:
          uint64_t v63 = (32 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v37;
        }
        else
        {
          uint64_t v30 = v35 | v34 & v128;
          if (v31 == 7)
          {
            char v36 = 8;
            uint64_t v37 = v129;
            goto LABEL_35;
          }
          uint64_t v30 = (32 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v30;
          uint64_t v63 = v129;
        }
        swift_bridgeObjectRelease(v129);
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v64 = 0xE000000000000000;
        if (v30 & 0x8080808080808080 | v63 & 0x80808080808080) {
          unint64_t v64 = 0xA000000000000000;
        }
        uint64_t v128 = v30;
        unint64_t v129 = (v64 & 0xFF00000000000000 | (v31 << 56) | v63 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
        goto LABEL_41;
      }
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v29 & 0x1000000000000000) != 0)
      {
        Swift::Int v68 = String.UTF8View._foreignCount()();
        int64_t v39 = v68 + 2;
        if (__OFADD__(v68, 2))
        {
LABEL_45:
          __break(1u);
LABEL_46:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
      }
      else
      {
        BOOL v38 = __OFADD__(v32, 2);
        int64_t v39 = v32 + 2;
        if (v38) {
          goto LABEL_45;
        }
      }
      if ((v30 & ~v29 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v29 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v40 = _StringGuts.nativeUnusedCapacity.getter(v30, v29);
        if (v41) {
          goto LABEL_118;
        }
        BOOL v43 = (v29 & 0x2000000000000000) == 0 && v40 > 1;
        if (v39 > 15 || v43)
        {
LABEL_33:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v39, 2);
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v126 = v117;
          uint64_t v61 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v126, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v61, v62, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
          goto LABEL_41;
        }
      }
      else if (v39 > 15)
      {
        goto LABEL_33;
      }
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      swift_bridgeObjectRetain(v29);
      unint64_t v44 = _StringGuts._convertedToSmall()(v30, v29);
      unint64_t v46 = v45;
      swift_bridgeObjectRelease(v29);
      v47._unint64_t rawBits = 1;
      v48._unint64_t rawBits = v116;
      v49._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v47, v48, 0x202CuLL, 0xE200000000000000);
      if (v49._rawBits < 0x10000) {
        v49._rawBits |= 3;
      }
      unint64_t v51 = specialized String.init(_:)(v49, v50, 0x202CuLL, 0xE200000000000000);
      unint64_t v53 = v52;
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v54 = _StringGuts._convertedToSmall()(v51, v53);
      unint64_t v115 = v55;
      swift_bridgeObjectRelease(v53);
      unint64_t v56 = specialized _SmallString.init(_:appending:)(v44, v46, v54, v115);
      if (v58) {
        goto LABEL_117;
      }
      uint64_t v59 = v56;
      unint64_t v60 = v57;
      swift_bridgeObjectRelease(v29);
      swift_bridgeObjectRelease(0xE200000000000000);
      uint64_t v128 = v59;
      unint64_t v129 = v60;
    }
LABEL_41:
    uint64_t v65 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v65, v125);
    *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v119;
    inited[7] = v6;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v24(boxed_opaque_existential_0Tm, v124, v6);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v128);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    char v21 = 0;
    unint64_t v19 = *((void *)&v127 + 1);
    uint64_t v15 = (atomic_ullong *)v127;
    unint64_t v18 = *(void *)(v127 + 16);
    uint64_t v20 = v118;
  }
  while (*((void *)&v127 + 1) != v18);
  uint64_t v16 = v128;
  unint64_t v17 = v129;
LABEL_47:
  swift_release((uint64_t)v15);
  unint64_t v69 = HIBYTE(v17) & 0xF;
  unint64_t v70 = v16 & 0xFFFFFFFFFFFFLL;
  if ((v17 & 0x2000000000000000) != 0) {
    uint64_t v71 = HIBYTE(v17) & 0xF;
  }
  else {
    uint64_t v71 = v16 & 0xFFFFFFFFFFFFLL;
  }
  if (!v71 && (v16 & ~v17 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v17);
    return 93;
  }
  if ((v17 & 0x2000000000000000) != 0 && v69 != 15)
  {
    if (v69 < 8) {
      uint64_t v16 = (93 << (8 * (HIBYTE(v17) & 7u))) | ((-255 << (8 * (HIBYTE(v17) & 7u))) - 1) & v16;
    }
    goto LABEL_56;
  }
  swift_bridgeObjectRetain_n(0xE100000000000000, 6);
  if ((v17 & 0x1000000000000000) != 0)
  {
    Swift::Int v105 = String.UTF8View._foreignCount()();
    uint64_t v72 = v105 + 1;
    if (!__OFADD__(v105, 1)) {
      goto LABEL_59;
    }
    goto LABEL_107;
  }
  BOOL v38 = __OFADD__(v71, 1);
  uint64_t v72 = v71 + 1;
  if (v38)
  {
LABEL_107:
    __break(1u);
    goto LABEL_108;
  }
LABEL_59:
  unint64_t v73 = v16 & ~v17;
  if ((v73 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v72 <= 15) {
      goto LABEL_76;
    }
LABEL_65:
    int64_t v76 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
    BOOL v79 = (v77 & 1) == 0 && v76 > 0;
    if ((v73 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v79) {
        goto LABEL_101;
      }
    }
    else if (v79)
    {
LABEL_100:
      _StringGuts.grow(_:)(v72);
LABEL_101:
      swift_bridgeObjectRelease_n(0xE100000000000000, 6);
      long long v127 = xmmword_18162ACA0;
      uint64_t v102 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v127, 1);
      _StringGuts.appendInPlace(_:isASCII:)(v102, v103, 1);
      swift_bridgeObjectRelease(0xE100000000000000);
      return v128;
    }
    uint64_t v98 = _StringGuts.nativeCapacity.getter(v16, v17);
    if (v99) {
      uint64_t v100 = 0;
    }
    else {
      uint64_t v100 = v98;
    }
    if (v100 + 0x4000000000000000 < 0)
    {
      __break(1u);
      goto LABEL_117;
    }
    uint64_t v101 = 2 * v100;
    if (v101 > v72) {
      uint64_t v72 = v101;
    }
    goto LABEL_100;
  }
  int64_t v74 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
  if (v75)
  {
LABEL_118:
    unint64_t v110 = 258;
LABEL_119:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v110, 0);
  }
  if (v72 > 15) {
    goto LABEL_65;
  }
  if ((v17 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    goto LABEL_77;
  }
  if (v74 > 0) {
    goto LABEL_65;
  }
LABEL_76:
  swift_bridgeObjectRelease_n(0xE100000000000000, 5);
  if ((v17 & 0x2000000000000000) != 0)
  {
LABEL_77:
    unint64_t v70 = v17;
  }
  else if ((v17 & 0x1000000000000000) != 0)
  {
    uint64_t v16 = _StringGuts._foreignConvertedToSmall()(v16, v17);
    unint64_t v70 = v113;
  }
  else
  {
    if ((v16 & 0x1000000000000000) != 0)
    {
      uint64_t v109 = (unsigned __int8 *)((v17 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v109 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v16, v17);
      unint64_t v70 = v114;
    }
    swift_bridgeObjectRetain(v17);
    closure #1 in _StringGuts._convertedToSmall()(v109, v70, &v127);
    swift_bridgeObjectRelease(v17);
    unint64_t v70 = *((void *)&v127 + 1);
    uint64_t v16 = v127;
  }
  v80._unint64_t rawBits = 1;
  v81._unint64_t rawBits = 65537;
  v82._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v80, v81, 0x5DuLL, 0xE100000000000000);
  if (v82._rawBits < 0x10000) {
    v82._rawBits |= 3;
  }
  unint64_t v69 = specialized String.init(_:)(v82, v83, 0x5DuLL, 0xE100000000000000);
  uint64_t v72 = v84;
  swift_bridgeObjectRelease(0xE100000000000000);
  if ((v72 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v72);
    goto LABEL_82;
  }
LABEL_108:
  uint64_t v106 = v16;
  if ((v72 & 0x1000000000000000) != 0)
  {
    unint64_t v69 = _StringGuts._foreignConvertedToSmall()(v69, v72);
    uint64_t v112 = v111;
    swift_bridgeObjectRelease(v72);
    uint64_t v72 = v112;
    uint64_t v16 = v106;
  }
  else
  {
    if ((v69 & 0x1000000000000000) != 0)
    {
      uint64_t v107 = (unsigned __int8 *)((v72 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v108 = v69 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      uint64_t v107 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v69, v72);
    }
    closure #1 in _StringGuts._convertedToSmall()(v107, v108, &v127);
    swift_bridgeObjectRelease(v72);
    uint64_t v72 = *((void *)&v127 + 1);
    unint64_t v69 = v127;
  }
LABEL_82:
  uint64_t v85 = HIBYTE(v70) & 0xF;
  uint64_t v86 = HIBYTE(v72) & 0xF;
  if ((unint64_t)(v86 + v85) > 0xF)
  {
LABEL_117:
    unint64_t v110 = 266;
    goto LABEL_119;
  }
  if (v86)
  {
    char v87 = 0;
    unint64_t v88 = 0;
    do
    {
      unint64_t v89 = v85 + v88;
      unint64_t v90 = v88 + 1;
      if (v88 >= 8) {
        unint64_t v91 = v72;
      }
      else {
        unint64_t v91 = v69;
      }
      unint64_t v92 = v91 >> (v87 & 0x38);
      char v93 = (8 * v85 + v87) & 0x38;
      uint64_t v94 = (-255 << v93) - 1;
      unint64_t v95 = (unint64_t)v92 << v93;
      unint64_t v96 = v95 | v94 & v70;
      unint64_t v97 = v95 | v94 & v16;
      if (v89 < 8) {
        uint64_t v16 = v97;
      }
      else {
        unint64_t v70 = v96;
      }
      v87 += 8;
      unint64_t v88 = v90;
    }
    while (v86 != v90);
  }
LABEL_56:
  swift_bridgeObjectRelease(v17);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v16;
}

uint64_t RangeSet.Ranges.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v6 = type metadata accessor for Range(0, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  uint64_t v7 = (uint64_t)*(v6 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v121 = (char *)&v112 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v112 - v11;
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v112 - v13;
  uint64_t v15 = *v4;
  swift_bridgeObjectRelease(0xE000000000000000);
  uint64_t v16 = 91;
  unint64_t v17 = 0xE100000000000000;
  uint64_t v125 = 91;
  unint64_t v126 = 0xE100000000000000;
  long long v124 = (unint64_t)v15;
  unint64_t v18 = v15[2];
  swift_retain(v15);
  if (!v18) {
    goto LABEL_47;
  }
  unint64_t v19 = 0;
  uint64_t v20 = v7 + 16;
  long long v119 = (char *)&v124 + 8;
  uint64_t v120 = v7 + 32;
  char v21 = 1;
  long long v118 = xmmword_18162AC80;
  long long v116 = xmmword_18162AC90;
  Swift::UInt64 v115 = 131073;
  do
  {
    if (v19 >= v18) {
      goto LABEL_46;
    }
    unint64_t v22 = (unint64_t)v15
        + ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
        + *(void *)(v7 + 72) * v19;
    uint64_t v23 = *(void (**)(char *, unint64_t, Class *))(v7 + 16);
    uint64_t v117 = v20;
    v23(v12, v22, v6);
    uint64_t v24 = *(void (**)(char *, char *, Class *))(v7 + 32);
    v24(v14, v12, v6);
    *(void *)&long long v123 = 0;
    *((void *)&v123 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v18;
    uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, (unint64_t *)a1, v25);
    specialized Collection._failEarlyRangeCheck(_:bounds:)(v119, (uint64_t)&v123, a1, WitnessTable);
    *((void *)&v124 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v19 + 1;
    v24(v121, v14, v6);
    if ((v21 & 1) == 0)
    {
      uint64_t v28 = v125;
      uint64_t v27 = v126;
      unint64_t v29 = HIBYTE(v126) & 0xF;
      if ((v126 & 0x2000000000000000) != 0) {
        unint64_t v30 = HIBYTE(v126) & 0xF;
      }
      else {
        unint64_t v30 = v125 & 0xFFFFFFFFFFFFLL;
      }
      if (!v30 && (v125 & ~v126 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v126);
        uint64_t v125 = 8236;
        unint64_t v126 = 0xE200000000000000;
        goto LABEL_41;
      }
      if ((v126 & 0x2000000000000000) != 0 && v29 <= 0xD)
      {
        unint64_t v31 = 8 * (HIBYTE(v126) & 7);
        uint64_t v32 = (-255 << v31) - 1;
        uint64_t v33 = 44 << v31;
        char v34 = v29 + 1;
        if (v29 >= 8)
        {
          uint64_t v35 = v33 | v32 & v126;
LABEL_35:
          uint64_t v60 = (32 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v35;
        }
        else
        {
          uint64_t v28 = v33 | v32 & v125;
          if (v29 == 7)
          {
            char v34 = 8;
            uint64_t v35 = v126;
            goto LABEL_35;
          }
          uint64_t v28 = (32 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v28;
          uint64_t v60 = v126;
        }
        swift_bridgeObjectRelease(v126);
        swift_bridgeObjectRelease(0xE200000000000000);
        unint64_t v61 = 0xE000000000000000;
        if (v28 & 0x8080808080808080 | v60 & 0x80808080808080) {
          unint64_t v61 = 0xA000000000000000;
        }
        uint64_t v125 = v28;
        unint64_t v126 = (v61 & 0xFF00000000000000 | (v29 << 56) | v60 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
        goto LABEL_41;
      }
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v27 & 0x1000000000000000) != 0)
      {
        Swift::Int v65 = String.UTF8View._foreignCount()();
        int64_t v37 = v65 + 2;
        if (__OFADD__(v65, 2))
        {
LABEL_45:
          __break(1u);
LABEL_46:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
      }
      else
      {
        BOOL v36 = __OFADD__(v30, 2);
        int64_t v37 = v30 + 2;
        if (v36) {
          goto LABEL_45;
        }
      }
      if ((v28 & ~v27 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v38 = _StringGuts.nativeUnusedCapacity.getter(v28, v27);
        if (v39) {
          goto LABEL_118;
        }
        BOOL v41 = (v27 & 0x2000000000000000) == 0 && v38 > 1;
        if (v37 > 15 || v41)
        {
LABEL_33:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v37, 2);
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v123 = v116;
          char v58 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v123, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v58, v59, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
          goto LABEL_41;
        }
      }
      else if (v37 > 15)
      {
        goto LABEL_33;
      }
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      swift_bridgeObjectRetain(v27);
      unint64_t v42 = _StringGuts._convertedToSmall()(v28, v27);
      unint64_t v114 = v43;
      swift_bridgeObjectRelease(v27);
      v44._unint64_t rawBits = 1;
      v45._unint64_t rawBits = v115;
      v46._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v44, v45, 0x202CuLL, 0xE200000000000000);
      if (v46._rawBits < 0x10000) {
        v46._rawBits |= 3;
      }
      unint64_t v48 = specialized String.init(_:)(v46, v47, 0x202CuLL, 0xE200000000000000);
      unint64_t v50 = v49;
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v51 = _StringGuts._convertedToSmall()(v48, v50);
      unint64_t v113 = v52;
      swift_bridgeObjectRelease(v50);
      unint64_t v53 = specialized _SmallString.init(_:appending:)(v42, v114, v51, v113);
      if (v55) {
        goto LABEL_117;
      }
      uint64_t v56 = v53;
      unint64_t v57 = v54;
      swift_bridgeObjectRelease(v27);
      swift_bridgeObjectRelease(0xE200000000000000);
      uint64_t v125 = v56;
      unint64_t v126 = v57;
    }
LABEL_41:
    uint64_t v62 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v62, v122);
    *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v118;
    inited[7] = v6;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v24(boxed_opaque_existential_0Tm, v121, v6);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v125);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    char v21 = 0;
    unint64_t v19 = *((void *)&v124 + 1);
    uint64_t v15 = (atomic_ullong *)v124;
    unint64_t v18 = *(void *)(v124 + 16);
    uint64_t v20 = v117;
  }
  while (*((void *)&v124 + 1) != v18);
  uint64_t v16 = v125;
  unint64_t v17 = v126;
LABEL_47:
  swift_release((uint64_t)v15);
  unint64_t v66 = HIBYTE(v17) & 0xF;
  unint64_t v67 = v16 & 0xFFFFFFFFFFFFLL;
  if ((v17 & 0x2000000000000000) != 0) {
    uint64_t v68 = HIBYTE(v17) & 0xF;
  }
  else {
    uint64_t v68 = v16 & 0xFFFFFFFFFFFFLL;
  }
  if (!v68 && (v16 & ~v17 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v17);
    return 93;
  }
  if ((v17 & 0x2000000000000000) != 0 && v66 != 15)
  {
    if (v66 < 8) {
      uint64_t v16 = (93 << (8 * (HIBYTE(v17) & 7u))) | ((-255 << (8 * (HIBYTE(v17) & 7u))) - 1) & v16;
    }
    goto LABEL_56;
  }
  swift_bridgeObjectRetain_n(0xE100000000000000, 6);
  if ((v17 & 0x1000000000000000) != 0)
  {
    Swift::Int v102 = String.UTF8View._foreignCount()();
    uint64_t v69 = v102 + 1;
    if (!__OFADD__(v102, 1)) {
      goto LABEL_59;
    }
    goto LABEL_107;
  }
  BOOL v36 = __OFADD__(v68, 1);
  uint64_t v69 = v68 + 1;
  if (v36)
  {
LABEL_107:
    __break(1u);
    goto LABEL_108;
  }
LABEL_59:
  unint64_t v70 = v16 & ~v17;
  if ((v70 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v69 <= 15) {
      goto LABEL_76;
    }
LABEL_65:
    int64_t v73 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
    BOOL v76 = (v74 & 1) == 0 && v73 > 0;
    if ((v70 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v76) {
        goto LABEL_101;
      }
    }
    else if (v76)
    {
LABEL_100:
      _StringGuts.grow(_:)(v69);
LABEL_101:
      swift_bridgeObjectRelease_n(0xE100000000000000, 6);
      long long v124 = xmmword_18162ACA0;
      char v99 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v124, 1);
      _StringGuts.appendInPlace(_:isASCII:)(v99, v100, 1);
      swift_bridgeObjectRelease(0xE100000000000000);
      return v125;
    }
    uint64_t v95 = _StringGuts.nativeCapacity.getter(v16, v17);
    if (v96) {
      uint64_t v97 = 0;
    }
    else {
      uint64_t v97 = v95;
    }
    if (v97 + 0x4000000000000000 < 0)
    {
      __break(1u);
      goto LABEL_117;
    }
    uint64_t v98 = 2 * v97;
    if (v98 > v69) {
      uint64_t v69 = v98;
    }
    goto LABEL_100;
  }
  int64_t v71 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
  if (v72)
  {
LABEL_118:
    unint64_t v107 = 258;
LABEL_119:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v107, 0);
  }
  if (v69 > 15) {
    goto LABEL_65;
  }
  if ((v17 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    goto LABEL_77;
  }
  if (v71 > 0) {
    goto LABEL_65;
  }
LABEL_76:
  swift_bridgeObjectRelease_n(0xE100000000000000, 5);
  if ((v17 & 0x2000000000000000) != 0)
  {
LABEL_77:
    unint64_t v67 = v17;
  }
  else if ((v17 & 0x1000000000000000) != 0)
  {
    uint64_t v16 = _StringGuts._foreignConvertedToSmall()(v16, v17);
    unint64_t v67 = v110;
  }
  else
  {
    if ((v16 & 0x1000000000000000) != 0)
    {
      uint64_t v106 = (unsigned __int8 *)((v17 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v106 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v16, v17);
      unint64_t v67 = v111;
    }
    swift_bridgeObjectRetain(v17);
    closure #1 in _StringGuts._convertedToSmall()(v106, v67, &v124);
    swift_bridgeObjectRelease(v17);
    unint64_t v67 = *((void *)&v124 + 1);
    uint64_t v16 = v124;
  }
  v77._unint64_t rawBits = 1;
  v78._unint64_t rawBits = 65537;
  v79._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v77, v78, 0x5DuLL, 0xE100000000000000);
  if (v79._rawBits < 0x10000) {
    v79._rawBits |= 3;
  }
  unint64_t v66 = specialized String.init(_:)(v79, v80, 0x5DuLL, 0xE100000000000000);
  uint64_t v69 = v81;
  swift_bridgeObjectRelease(0xE100000000000000);
  if ((v69 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v69);
    goto LABEL_82;
  }
LABEL_108:
  uint64_t v103 = v16;
  if ((v69 & 0x1000000000000000) != 0)
  {
    unint64_t v66 = _StringGuts._foreignConvertedToSmall()(v66, v69);
    uint64_t v109 = v108;
    swift_bridgeObjectRelease(v69);
    uint64_t v69 = v109;
    uint64_t v16 = v103;
  }
  else
  {
    if ((v66 & 0x1000000000000000) != 0)
    {
      uint64_t v104 = (unsigned __int8 *)((v69 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v105 = v66 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      uint64_t v104 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v66, v69);
    }
    closure #1 in _StringGuts._convertedToSmall()(v104, v105, &v124);
    swift_bridgeObjectRelease(v69);
    uint64_t v69 = *((void *)&v124 + 1);
    unint64_t v66 = v124;
  }
LABEL_82:
  uint64_t v82 = HIBYTE(v67) & 0xF;
  uint64_t v83 = HIBYTE(v69) & 0xF;
  if ((unint64_t)(v83 + v82) > 0xF)
  {
LABEL_117:
    unint64_t v107 = 266;
    goto LABEL_119;
  }
  if (v83)
  {
    char v84 = 0;
    unint64_t v85 = 0;
    do
    {
      unint64_t v86 = v82 + v85;
      unint64_t v87 = v85 + 1;
      if (v85 >= 8) {
        unint64_t v88 = v69;
      }
      else {
        unint64_t v88 = v66;
      }
      unint64_t v89 = v88 >> (v84 & 0x38);
      char v90 = (8 * v82 + v84) & 0x38;
      uint64_t v91 = (-255 << v90) - 1;
      unint64_t v92 = (unint64_t)v89 << v90;
      unint64_t v93 = v92 | v91 & v67;
      unint64_t v94 = v92 | v91 & v16;
      if (v86 < 8) {
        uint64_t v16 = v94;
      }
      else {
        unint64_t v67 = v93;
      }
      v84 += 8;
      unint64_t v85 = v87;
    }
    while (v83 != v87);
  }
LABEL_56:
  swift_bridgeObjectRelease(v17);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v16;
}

void *MutableCollection<>.sort(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v118 = a5;
  uint64_t v9 = *(void *)(a4 + 8);
  long long v116 = *(int ***)(v9 + 8);
  uint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness(0, v116, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v108 = *(AssociatedTypeWitness - 1);
  uint64_t v97 = *(void *)(v108 + 64);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  size_t v100 = (char *)&v87 - v10;
  uint64_t v11 = swift_getAssociatedTypeWitness(255, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = type metadata accessor for Optional(0, (uint64_t)v11, v12, v13);
  uint64_t v111 = (uint64_t)*(v14 - 1);
  uint64_t v112 = v14;
  uint64_t v15 = MEMORY[0x1F4188790](v14);
  unint64_t v110 = (char *)&v87 - v16;
  uint64_t v109 = *((void *)v11 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  Swift::Int v102 = (char *)&v87 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  unint64_t v107 = (char *)&v87 - v19;
  unint64_t v113 = v11;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v11, (uint64_t)&type metadata for Int, 0, 0);
  MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v98 = (char *)&v87 - v20;
  char v21 = swift_getAssociatedTypeWitness(0, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Indices);
  uint64_t v106 = (uint64_t *)*((void *)v21 - 1);
  MEMORY[0x1F4188790](v21);
  uint64_t v105 = (char *)&v87 - v22;
  uint64_t v117 = v9;
  unint64_t v23 = *(void *)(swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Indices: Collection)+ 8);
  uint64_t v25 = lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, protocol conformance descriptor for <> Range<A>, v24);
  uint64_t v127 = (uint64_t)v21;
  uint64_t v128 = qword_1EC9FFE50;
  unint64_t v129 = v23;
  uint64_t v130 = v25;
  uint64_t v104 = type metadata accessor for Zip2Sequence(0, (uint64_t)&v127);
  MEMORY[0x1F4188790](v104);
  uint64_t v103 = (char *)&v87 - v26;
  uint64_t v127 = (uint64_t)v21;
  uint64_t v128 = qword_1EC9FFE50;
  unint64_t v27 = v23;
  unint64_t v129 = v23;
  uint64_t v130 = v25;
  uint64_t v28 = type metadata accessor for Zip2Sequence.Iterator(0, (uint64_t)&v127);
  uint64_t v101 = (uint64_t)*(v28 - 1);
  uint64_t v29 = MEMORY[0x1F4188790](v28);
  unint64_t v31 = (char *)&v87 - v30;
  uint64_t v115 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v29);
  uint64_t v33 = (char *)&v87 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v122 = a3;
  uint64_t v123 = a4;
  uint64_t v34 = v119;
  uint64_t v124 = v118;
  uint64_t v125 = a1;
  uint64_t v118 = a1;
  uint64_t v35 = a2;
  uint64_t v126 = a2;
  uint64_t result = (*(void *(**)(uint64_t *__return_ptr, void (*)(uint64_t), char *, void *, uint64_t, uint64_t))(a4 + 80))(&v127, partial apply for closure #1 in MutableCollection<>.sort(by:), v121, &unk_1ECA06270, a3, a4);
  if (!v34)
  {
    unint64_t v92 = v27;
    int64_t v37 = v116;
    uint64_t v91 = v21;
    uint64_t v96 = v35;
    uint64_t v38 = v117;
    uint64_t v95 = v31;
    unint64_t v94 = v28;
    uint64_t v119 = a3;
    uint64_t v93 = a4;
    if (v127 == 1)
    {
      uint64_t v39 = v119;
      (*(void (**)(char *, uint64_t, uint64_t))(v115 + 16))(v33, v120, v119);
      uint64_t v127 = ((uint64_t (*)(uint64_t, int **))v37[7])(v39, v37);
      int64_t v40 = AssociatedTypeWitness;
      unint64_t v43 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)AssociatedTypeWitness, v41, v42);
      uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v43, v44);
      uint64_t v47 = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v43, v46);
      MutableCollection<>.sort(by:)(v118, v96, v43, WitnessTable, v47);
      uint64_t v48 = v127;
      uint64_t v118 = 0;
      unint64_t v49 = v103;
      (*(void (**)(uint64_t, uint64_t))(v38 + 96))(v39, v38);
      uint64_t v117 = v48;
      uint64_t v131 = v48;
      unint64_t v52 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v40, v50, v51);
      uint64_t v54 = swift_getWitnessTable(protocol conformance descriptor for [A], v52, v53);
      RandomAccessCollection<>.indices.getter((uint64_t)v52, v54, (uint64_t)&protocol witness table for Int, (char *)&v127);
      uint64_t v56 = v127;
      char v55 = (int **)v128;
      unint64_t v57 = (uint64_t *)&v49[*((int *)v104 + 13)];
      *unint64_t v57 = v127;
      v57[1] = (uint64_t)v55;
      uint64_t v58 = (uint64_t)v91;
      ((void (*)(const char *, char *, const char *))v106[4])(v105, v49, v91);
      size_t v59 = (int **)v92;
      uint64_t v60 = v95;
      (*(void (**)(uint64_t, unint64_t))(v92 + 32))(v58, v92);
      unint64_t v61 = v94;
      uint64_t v62 = (uint64_t *)&v60[*((int *)v94 + 13)];
      *uint64_t v62 = v56;
      v62[1] = (uint64_t)v55;
      long long v116 = v55;
      uint64_t v106 = v62;
      void v62[2] = v56;
      uint64_t v115 = *((int *)v61 + 14);
      v60[v115] = 0;
      uint64_t v63 = swift_getAssociatedTypeWitness(255, v59, v58, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v59, v58, (uint64_t)v63, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      Swift::Int v65 = *(char **)(AssociatedConformanceWitness + 16);
      uint64_t v96 = AssociatedConformanceWitness + 16;
      uint64_t v105 = v63;
      unint64_t v66 = swift_checkMetadataState(0, (uint64_t)v63);
      unint64_t v67 = v110;
      uint64_t v104 = (Class *)AssociatedConformanceWitness;
      uint64_t v103 = v65;
      ((void (*)(uint64_t *, uint64_t))v65)(v66, AssociatedConformanceWitness);
      uint64_t v68 = v109;
      uint64_t v69 = *(uint64_t (**)(char *, uint64_t, const char *))(v109 + 48);
      unint64_t v70 = v113;
      int v71 = v69(v67, 1, v113);
      uint64_t v72 = v111;
      if (v71 == 1)
      {
LABEL_4:
        (*(void (**)(char *))(v72 + 8))(v67);
      }
      else
      {
        char v74 = *(void (**)(char *, char *, const char *))(v68 + 32);
        unint64_t v92 = v117 & 0xC000000000000001;
        uint64_t v91 = (const char *)(v108 + 16);
        uint64_t v90 = v93 + 24;
        while (1)
        {
          v74(v107, v67, v70);
          if (v116 == (int **)v56) {
            break;
          }
          if (v56 >= (uint64_t)v116) {
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
          }
          unint64_t v88 = v69;
          BOOL v75 = v92 == 0;
          v106[2] = v56 + 1;
          uint64_t v76 = *((int *)TupleTypeMetadata2 + 12);
          Swift::String::Index v77 = v98;
          v74(v98, v107, v70);
          *(void *)&v77[v76] = v56;
          unint64_t v89 = v74;
          v74(v102, v77, v70);
          Swift::String::Index v78 = AssociatedTypeWitness;
          char v79 = v75 | ~_swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
          uint64_t v80 = v117;
          Array._checkSubscript(_:wasNativeTypeChecked:)(v56, v79 & 1);
          if (v79)
          {
            unint64_t v81 = v80
                + ((*(unsigned __int8 *)(v108 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v108 + 80))
                + *(void *)(v108 + 72) * v56;
            uint64_t v82 = v100;
            (*(void (**)(char *, unint64_t, uint64_t *))(v108 + 16))(v100, v81, v78);
          }
          else
          {
            id v85 = _ArrayBuffer._getElementSlowPath(_:)(v56, v80, v78);
            unint64_t v86 = v85;
            if (v97 != 8)
            {
              swift_unknownObjectRelease(v85);
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
            }
            uint64_t v127 = (uint64_t)v85;
            uint64_t v82 = v100;
            (*(void (**)(char *, uint64_t *, uint64_t *))v91)(v100, &v127, AssociatedTypeWitness);
            swift_unknownObjectRelease(v86);
            uint64_t v39 = v119;
          }
          uint64_t v69 = v88;
          (*(void (**)(char *, char *, uint64_t))(v93 + 24))(v82, v102, v39);
          uint64_t v83 = swift_checkMetadataState(0, (uint64_t)v105);
          unint64_t v67 = v110;
          ((void (*)(uint64_t *, Class *))v103)(v83, v104);
          unint64_t v70 = v113;
          int v84 = v69(v67, 1, v113);
          ++v56;
          uint64_t v72 = v111;
          uint64_t v68 = v109;
          char v74 = v89;
          if (v84 == 1) {
            goto LABEL_4;
          }
        }
        (*(void (**)(char *, const char *))(v68 + 8))(v107, v70);
      }
      uint64_t v73 = v101;
      v95[v115] = 1;
      (*(void (**)(void))(v73 + 8))();
      return (void *)swift_release(v117);
    }
  }
  return result;
}

uint64_t RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, void *a2, char a3, uint64_t a4)
{
  return specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, a2, a3, *(void *)(a4 + 16), *(void *)(a4 + 24));
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance RangeSet<A>.Ranges(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance RangeSet<A>.Ranges(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t RangeSet.Ranges.startIndex.getter()
{
  return 0;
}

uint64_t RangeSet.Ranges.count.getter()
{
  return *(void *)(*(void *)v0 + 16);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance RangeSet<A>.Ranges@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = RangeSet.Ranges.count.getter();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance RangeSet<A>.Ranges(Class ***a1, unint64_t *a2, uint64_t a3))()
{
  char v6 = (Class **)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (Class *)RangeSet.Ranges.subscript.read(v6, *a2, a3, v7);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*RangeSet.Ranges.subscript.read(Class **a1, unint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v7 = type metadata accessor for Range(0, *(void *)(a3 + 16), *(void *)(a3 + 24), a4);
  *a1 = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = v8;
  a1[1] = (Class *)v8;
  a1[2] = (Class *)malloc(*(void *)(v8 + 64));
  if ((a2 & 0x8000000000000000) != 0 || *(void *)(*(void *)v4 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
  (*(void (**)(void))(v9 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.indices.getter in conformance RangeSet<A>.Ranges@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance RangeSet<A>.Ranges@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);

  return RandomAccessCollection<>.index(after:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance RangeSet<A>.Ranges@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);

  return RandomAccessCollection<>.index(before:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance RangeSet<A>.Ranges(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

void *protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges(void *a1, unint64_t *a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  uint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance RangeSet<A>.Ranges@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance RangeSet<A>.Ranges@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance RangeSet<A>.Ranges(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return static RangeSet.Ranges.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

void RangeSet.Ranges<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = a3;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v24 = *(void *)(a2 + 16);
  uint64_t v22 = type metadata accessor for Range(0, v24, v6, a4);
  uint64_t v26 = (uint64_t)*(v22 - 1);
  MEMORY[0x1F4188790](v22);
  char v21 = (char *)v20 - v7;
  uint64_t v8 = *v4;
  Swift::UInt v9 = *(void *)(*v4 + 16);
  uint64_t v25 = a1;
  Hasher._combine(_:)(v9);
  Swift::UInt v23 = v9;
  if (v9)
  {
    unint64_t v10 = 0;
    uint64_t v11 = v27;
    uint64_t v12 = v26;
    void v20[2] = v27 + 24;
    v20[3] = v26 + 16;
    v20[1] = v26 + 8;
    uint64_t v14 = v21;
    uint64_t v13 = v22;
    uint64_t v15 = v24;
    do
    {
      if (v10 >= *(void *)(v8 + 16)) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      }
      unint64_t v28 = v10 + 1;
      (*(void (**)(char *, unint64_t, Class *))(v12 + 16))(v14, v8+ ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))+ *(void *)(v12 + 72) * v10, v13);
      uint64_t v16 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 24);
      uint64_t v17 = v8;
      uint64_t v18 = v25;
      v16(v25, v15, v11);
      uint64_t v19 = v18;
      uint64_t v8 = v17;
      v16(v19, v15, v11);
      (*(void (**)(char *, Class *))(v12 + 8))(v14, v13);
      unint64_t v10 = v28;
    }
    while (v23 != v28);
  }
}

Swift::Int RangeSet.Ranges<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *v4;
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  RangeSet.Ranges<>.hash(into:)((uint64_t)v6, a1, a2, a4);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeSet.Ranges<>.hashValue.getter(a1, *(void *)(a2 - 8), a3, a4);
}

void protocol witness for Hashable.hash(into:) in conformance <> RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))RangeSet.Ranges<>.hash(into:));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, uint64_t, uint64_t))
{
  uint64_t v4 = *(void *)(a3 - 8);
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  a4(v6, a2, v4);
  return Hasher._finalize()();
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _Pair<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);

  return RandomAccessCollection<>.index(before:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _Pair<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _Pair<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _Pair<A>(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

void protocol witness for Collection.endIndex.getter in conformance _Pair<A>(void *a1@<X8>)
{
  *a1 = 2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _Pair<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = _Pair.subscript.read(v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*_Pair.subscript.read(void *a1, uint64_t a2, uint64_t a3))(void **a1)
{
  long long v7 = malloc(0x28uLL);
  *a1 = v7;
  uint64_t v8 = *(void *)(a3 + 16);
  *long long v7 = v8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v8, v8, "first second ", 0);
  unint64_t v10 = (char *)malloc(*(void *)(*(TupleTypeMetadata2 - 1) + 64));
  v7[1] = v10;
  uint64_t v11 = *(void *)(v8 - 8);
  uint64_t v12 = v11;
  v7[2] = v11;
  uint64_t v13 = malloc(*(void *)(v11 + 64));
  v7[3] = v13;
  if (a2 == 1)
  {
    uint64_t v14 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v15 = &v10[v14];
    uint64_t v16 = &v10[v14];
    uint64_t v22 = v10;
  }
  else
  {
    if (a2) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index is out of range", 21, 2, "Swift/RangeSetRanges.swift", 26, 2, 0x19EuLL, 0);
    }
    uint64_t v14 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v15 = &v10[v14];
    uint64_t v16 = v10;
    uint64_t v22 = &v10[v14];
  }
  uint64_t v17 = v3;
  uint64_t v18 = v3 + v14;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v19(v10, v17, v8);
  v19(v15, v18, v8);
  (*(void (**)(void *, char *, uint64_t))(v12 + 32))(v13, v16, v8);
  uint64_t v20 = *(void (**)(char *, uint64_t))(v12 + 8);
  v7[4] = v20;
  v20(v22, v8);
  return _Pair.subscript.read;
}

void _Pair.subscript.read(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)(*a1)[3];
  uint64_t v3 = (void *)(*a1)[1];
  ((void (*)(void *, void))(*a1)[4])(v2, **a1);
  free(v2);
  free(v3);

  free(v1);
}

uint64_t protocol witness for Collection.indices.getter in conformance _Pair<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance _Pair<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);

  return RandomAccessCollection<>.index(after:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance _Pair<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>(void *a1, unint64_t *a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  uint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

Class *protocol witness for Sequence.makeIterator() in conformance _Pair<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>(a1, protocol conformance descriptor for _Pair<A>, a2);
}

Class *protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>@<X0>(unint64_t *a1@<X0>, int *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = v3;
  (*(void (**)(uint64_t, uint64_t, unint64_t *))(*(a1 - 1) + 32))(a3, v6, a1);
  uint64_t WitnessTable = swift_getWitnessTable(a2, a1, v8);
  uint64_t result = type metadata accessor for IndexingIterator(0, (uint64_t)a1, WitnessTable, v10);
  *(void *)(a3 + *((int *)result + 9)) = 0;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _Pair<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _Pair<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>(swift::SwiftError **a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  outlined init with take of Mirror?(a3, (uint64_t)v204);
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v202);
  if (!a2)
  {
    uint64_t v8 = v203;
    uint64_t v9 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(v202, (uint64_t)v203);
    DynamicType = (unint64_t *)swift_getDynamicType(v9, v8, 1);
    a2 = swift_reflectionMirror_normalizedType(v202, DynamicType, (uint64_t *)&unk_1ECA06310);
  }
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v202);
  unint64_t v11 = swift_reflectionMirror_count(a1, (objc_class *)a2, (unint64_t *)&unk_1ECA06310);
  if ((v11 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unint64_t v12 = v11;
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v201);
  uint64_t v13 = swift_allocObject(qword_1ECA02728, 0x38uLL, 7uLL);
  outlined init with take of Any(v201, (_OWORD *)v13 + 1);
  v13[6] = a2;
  uint64_t v14 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<Range<Int>, (label: String?, value: Any)>>);
  uint64_t v15 = swift_allocObject(v14, 0x50uLL, 7uLL);
  void v15[6] = 0;
  v15[7] = v12;
  char v15[8] = partial apply for closure #1 in Mirror.init(internalReflecting:subjectType:customAncestor:);
  v15[9] = v13;
  uint64_t v16 = (unint64_t *)canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v17 = swift_allocObject(v16, 0x18uLL, 7uLL);
  void v17[2] = 0;
  uint64_t v18 = swift_allocObject(v16, 0x18uLL, 7uLL);
  v18[2] = v12;
  void v15[2] = v17;
  v15[3] = &protocol witness table for _IndexBox<A>;
  v15[4] = v18;
  v15[5] = &protocol witness table for _IndexBox<A>;
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v201);
  uint64_t v19 = swift_allocObject(qword_1ECA02750, 0x68uLL, 7uLL);
  _OWORD v19[2] = a2;
  outlined init with take of Mirror?((uint64_t)v204, (uint64_t)(v19 + 3));
  outlined init with take of Any(v201, v19 + 9);
  char v20 = swift_reflectionMirror_displayStyle(a1, (uint64_t *)&unk_1ECA06310);
  if (v20 < 0)
  {
LABEL_13:
    *((void *)&v199 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v20;
    uint64_t v23 = specialized static String._createEmpty(withInitialCapacity:)(30);
    unint64_t v25 = v23;
    unint64_t v26 = v24;
    *(void *)&v201[0] = v23;
    *((void *)&v201[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v24;
    uint64_t v27 = HIBYTE(v24) & 0xF;
    if ((v24 & 0x2000000000000000) != 0) {
      unint64_t v28 = HIBYTE(v24) & 0xF;
    }
    else {
      unint64_t v28 = v23 & 0xFFFFFFFFFFFFLL;
    }
    if (!v28 && (v23 & ~v24 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v24);
      unint64_t v29 = 0x80000001816E3100 | 0x8000000000000000;
      for (*(void *)&v201[0] = 0xD00000000000001BLL; ; *(void *)&v201[0] = v28)
      {
LABEL_97:
        *((void *)&v201[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v29;
LABEL_98:
        *(void *)&long long v199 = _int64ToString(_:radix:uppercase:)(*((uint64_t *)&v199 + 1), 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        *((void *)&v199 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v86;
        unint64_t v26 = *((void *)&v201[0] + 1);
        unint64_t v25 = *(void *)&v201[0];
        uint64_t v87 = HIBYTE(*((void *)&v201[0] + 1)) & 0xFLL;
        if ((*((void *)&v201[0] + 1) & 0x2000000000000000) != 0) {
          uint64_t v33 = HIBYTE(*((void *)&v201[0] + 1)) & 0xFLL;
        }
        else {
          uint64_t v33 = *(void *)&v201[0] & 0xFFFFFFFFFFFFLL;
        }
        if (!v33 && (*(void *)&v201[0] & ~*((void *)&v201[0] + 1) & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v201[0] + 1));
          v201[0] = v199;
          goto LABEL_167;
        }
        uint64_t v4 = v86 & 0x2000000000000000;
        unint64_t v28 = HIBYTE(v86) & 0xF;
        if ((*((void *)&v201[0] + 1) & 0x2000000000000000) != 0 && v4)
        {
          unint64_t v88 = v87 + v28;
          if (v87 + v28 <= 0xF)
          {
            if (v28)
            {
              uint64_t v131 = 0;
              unint64_t v132 = 0;
              unint64_t v113 = *((void *)&v201[0] + 1);
              uint64_t v114 = v86;
              do
              {
                unint64_t v133 = v87 + v132;
                unint64_t v134 = v132 + 1;
                if (v132 >= 8) {
                  unint64_t v135 = v86;
                }
                else {
                  unint64_t v135 = v199;
                }
                unint64_t v136 = v135 >> (v131 & 0x38);
                char v137 = (8 * v87 + v131) & 0x38;
                uint64_t v138 = (-255 << v137) - 1;
                unint64_t v139 = (unint64_t)v136 << v137;
                unint64_t v140 = v138 & v113 | v139;
                unint64_t v141 = v138 & v25 | v139;
                if (v133 < 8) {
                  unint64_t v25 = v141;
                }
                else {
                  unint64_t v113 = v140;
                }
                v131 += 8;
                unint64_t v132 = v134;
              }
              while (v28 != v134);
            }
            else
            {
              unint64_t v113 = *((void *)&v201[0] + 1);
              uint64_t v114 = v86;
            }
            swift_bridgeObjectRelease(v114);
            swift_bridgeObjectRelease(v26);
            unint64_t v142 = 0xA000000000000000;
            if (!(v25 & 0x8080808080808080 | v113 & 0x80808080808080)) {
              unint64_t v142 = 0xE000000000000000;
            }
            *(void *)&v201[0] = v25;
            for (*((void *)&v201[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v142 & 0xFF00000000000000 | (v88 << 56) | v113 & 0xFFFFFFFFFFFFFFLL;
                  ;
                  *((void *)&v201[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v130 & 0xFF00000000000000 | (v111 << 56) | v99 & 0xFFFFFFFFFFFFFFLL)
            {
LABEL_167:
              unint64_t v91 = *((void *)&v201[0] + 1);
              unint64_t v99 = *(void *)&v201[0];
              unint64_t v106 = HIBYTE(*((void *)&v201[0] + 1)) & 0xFLL;
              if ((*((void *)&v201[0] + 1) & 0x2000000000000000) != 0) {
                uint64_t v143 = HIBYTE(*((void *)&v201[0] + 1)) & 0xFLL;
              }
              else {
                uint64_t v143 = *(void *)&v201[0] & 0xFFFFFFFFFFFFLL;
              }
              if (!v143 && (*(void *)&v201[0] & ~*((void *)&v201[0] + 1) & 0x2000000000000000) == 0)
              {
                swift_bridgeObjectRelease(*((uint64_t *)&v201[0] + 1));
                unint64_t v144 = 0xE100000000000000;
                unint64_t v99 = 39;
                goto LABEL_199;
              }
              if ((*((void *)&v201[0] + 1) & 0x2000000000000000) != 0 && v106 != 15)
              {
                uint64_t v145 = HIBYTE(*((void *)&v201[0] + 1));
                swift_bridgeObjectRelease(0xE100000000000000);
                swift_bridgeObjectRelease(v91);
                char v146 = 8 * (v145 & 7);
                uint64_t v147 = (-255 << v146) - 1;
                uint64_t v148 = 39 << v146;
                unint64_t v149 = v147 & v91 | v148;
                unint64_t v150 = v147 & v99 | v148;
                if (v106 >= 8) {
                  unint64_t v151 = v149;
                }
                else {
                  unint64_t v151 = v91;
                }
                if (v106 < 8) {
                  unint64_t v99 = v150;
                }
                unint64_t v152 = 0xA000000000000000;
                if (!(v151 & 0x80808080808080 | v99 & 0x8080808080808080)) {
                  unint64_t v152 = 0xE000000000000000;
                }
                unint64_t v144 = (v152 & 0xFF00000000000000 | (v106 << 56) | v151 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
                goto LABEL_199;
              }
              swift_bridgeObjectRetain_n(0xE100000000000000, 6);
              if ((v91 & 0x1000000000000000) != 0)
              {
                Swift::Int v186 = String.UTF8View._foreignCount()();
                uint64_t v108 = v186 + 1;
                if (!__OFADD__(v186, 1))
                {
LABEL_185:
                  if ((v99 & ~v91 & 0x2000000000000000) == 0
                    || !swift_isUniquelyReferenced_nonNull_native(v91 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if (v108 <= 15) {
                      goto LABEL_192;
                    }
                    goto LABEL_198;
                  }
                  int64_t v153 = _StringGuts.nativeUnusedCapacity.getter(v99, v91);
                  if ((v154 & 1) == 0)
                  {
                    uint64_t v155 = (v91 >> 61) & 1;
                    if (v153 < 1) {
                      LOBYTE(v155) = 1;
                    }
                    if (v108 <= 15 && (v155 & 1) != 0)
                    {
LABEL_192:
                      swift_bridgeObjectRetain(v91);
                      unint64_t v156 = _StringGuts._convertedToSmall()(v99, v91);
                      unint64_t v158 = v157;
                      swift_bridgeObjectRelease(v91);
                      v159._unint64_t rawBits = 1;
                      v160._unint64_t rawBits = 65537;
                      v161._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v159, v160, 0x27uLL, 0xE100000000000000);
                      if (v161._rawBits < 0x10000) {
                        v161._rawBits |= 3;
                      }
                      unint64_t v163 = specialized String.init(_:)(v161, v162, 0x27uLL, 0xE100000000000000);
                      unint64_t v165 = v164;
                      swift_bridgeObjectRelease(0xE100000000000000);
                      unint64_t v166 = _StringGuts._convertedToSmall()(v163, v165);
                      unint64_t v168 = v167;
                      swift_bridgeObjectRelease(v165);
                      unint64_t v169 = specialized _SmallString.init(_:appending:)(v156, v158, v166, v168);
                      if ((v171 & 1) == 0)
                      {
                        unint64_t v99 = v169;
                        unint64_t v144 = v170;
                        swift_bridgeObjectRelease(0xE100000000000000);
                        swift_bridgeObjectRelease(v91);
                        goto LABEL_199;
                      }
LABEL_196:
                      unint64_t v172 = 266;
LABEL_201:
                      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v172, 0);
                    }
LABEL_198:
                    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v108, 1);
                    swift_bridgeObjectRelease_n(0xE100000000000000, 6);
                    long long v200 = xmmword_18162ADE0;
                    unint64_t v173 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v200, 1);
                    _StringGuts.appendInPlace(_:isASCII:)(v173, v174, 1);
                    swift_bridgeObjectRelease(0xE100000000000000);
                    unint64_t v144 = *((void *)&v201[0] + 1);
                    unint64_t v99 = *(void *)&v201[0];
LABEL_199:
                    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v99, v144, "Swift/ReflectionMirror.swift", 28, 2, 0xB0uLL, 0);
                  }
LABEL_200:
                  unint64_t v172 = 258;
                  goto LABEL_201;
                }
              }
              else
              {
                BOOL v89 = __OFADD__(v143, 1);
                uint64_t v108 = v143 + 1;
                if (!v89) {
                  goto LABEL_185;
                }
              }
              __break(1u);
LABEL_223:
              if ((v108 & 0x1000000000000000) != 0)
              {
                unint64_t v106 = _StringGuts._foreignConvertedToSmall()(v106, v108);
                uint64_t v197 = v196;
                swift_bridgeObjectRelease(v108);
                uint64_t v108 = v197;
              }
              else
              {
                if ((v106 & 0x1000000000000000) != 0)
                {
                  unint64_t v187 = (unsigned __int8 *)((v108 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v188 = v106 & 0xFFFFFFFFFFFFLL;
                }
                else
                {
                  unint64_t v187 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v106, v108);
                }
                closure #1 in _StringGuts._convertedToSmall()(v187, v188, &v200);
                swift_bridgeObjectRelease(v108);
                uint64_t v108 = *((void *)&v200 + 1);
                unint64_t v106 = v200;
              }
LABEL_136:
              uint64_t v109 = HIBYTE(v99) & 0xF;
              uint64_t v110 = HIBYTE(v108) & 0xF;
              uint64_t v111 = v110 + v109;
              if ((unint64_t)(v110 + v109) > 0xF) {
                goto LABEL_196;
              }
              if (v110)
              {
                char v119 = 0;
                unint64_t v120 = 0;
                unint64_t v112 = v198;
                do
                {
                  unint64_t v121 = v109 + v120;
                  unint64_t v122 = v120 + 1;
                  if (v120 >= 8) {
                    unint64_t v123 = v108;
                  }
                  else {
                    unint64_t v123 = v106;
                  }
                  unint64_t v124 = v123 >> (v119 & 0x38);
                  char v125 = (8 * v109 + v119) & 0x38;
                  uint64_t v126 = (-255 << v125) - 1;
                  unint64_t v127 = (unint64_t)v124 << v125;
                  unint64_t v128 = v126 & v99 | v127;
                  unint64_t v129 = v126 & v112 | v127;
                  if (v121 < 8) {
                    unint64_t v112 = v129;
                  }
                  else {
                    unint64_t v99 = v128;
                  }
                  v119 += 8;
                  unint64_t v120 = v122;
                }
                while (v110 != v122);
              }
              else
              {
                unint64_t v112 = v198;
              }
              swift_bridgeObjectRelease(*((uint64_t *)&v199 + 1));
              swift_bridgeObjectRelease(v91);
              unint64_t v130 = 0xA000000000000000;
              if (!(v112 & 0x8080808080808080 | v99 & 0x80808080808080)) {
                unint64_t v130 = 0xE000000000000000;
              }
              *(void *)&v201[0] = v112;
            }
          }
          uint64_t v4 = 1;
        }
        uint64_t v34 = v199 & 0xFFFFFFFFFFFFLL;
        if (v4) {
          unint64_t v32 = HIBYTE(v86) & 0xF;
        }
        else {
          unint64_t v32 = v199 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v86, 2);
        if ((*((void *)&v199 + 1) & 0x1000000000000000) != 0)
        {
LABEL_210:
          swift_bridgeObjectRetain_n(*((uint64_t *)&v199 + 1), 5);
          v179._unint64_t rawBits = 1;
          v180._unint64_t rawBits = (v32 << 16) | 1;
          v181._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v179, v180, v199, *((unint64_t *)&v199 + 1));
          if (v181._rawBits < 0x10000) {
            v181._rawBits |= 3;
          }
          uint64_t v30 = (const char *)specialized Collection.count.getter(v181, v182, v199, *((unint64_t *)&v199 + 1));
          swift_bridgeObjectRelease(*((uint64_t *)&v199 + 1));
          if ((v26 & 0x1000000000000000) == 0)
          {
LABEL_113:
            BOOL v89 = __OFADD__(v33, v30);
            int64_t v90 = (int64_t)&v30[v33];
            if (!v89) {
              goto LABEL_114;
            }
            goto LABEL_215;
          }
        }
        else
        {
          swift_bridgeObjectRetain_n(*((uint64_t *)&v199 + 1), 4);
          uint64_t v30 = (const char *)v32;
          if ((v26 & 0x1000000000000000) == 0) {
            goto LABEL_113;
          }
        }
        Swift::Int v183 = String.UTF8View._foreignCount()();
        int64_t v90 = (int64_t)&v30[v183];
        if (!__OFADD__(v183, v30))
        {
LABEL_114:
          if ((v25 & ~v26 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v26 & 0xFFFFFFFFFFFFFFFLL))
          {
            unint64_t v91 = *((void *)&v201[0] + 1);
            unint64_t v198 = *(void *)&v201[0];
            int64_t v92 = _StringGuts.nativeUnusedCapacity.getter(*(uint64_t *)&v201[0], *((uint64_t *)&v201[0] + 1));
            if (v93) {
              goto LABEL_200;
            }
            if (v90 > 15) {
              goto LABEL_122;
            }
            if ((v91 & 0x2000000000000000) == 0)
            {
              if (v92 < (uint64_t)v30) {
                goto LABEL_128;
              }
LABEL_122:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v90, (int64_t)v30);
              if ((*((void *)&v199 + 1) & 0x1000000000000000) != 0)
              {
                _StringGuts._foreignAppendInPlace(_:)(v199, *((unint64_t *)&v199 + 1), 0, v32);
                uint64_t v98 = *((void *)&v199 + 1);
              }
              else
              {
                swift_bridgeObjectRelease_n(*((uint64_t *)&v199 + 1), 4);
                if (v4)
                {
                  swift_bridgeObjectRelease_n(*((uint64_t *)&v199 + 1), 2);
                  *(void *)&long long v200 = v199;
                  *((void *)&v200 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = *((void *)&v199 + 1) & 0xFFFFFFFFFFFFFFLL;
                  uint64_t v117 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v28, (uint64_t)&v200, v28);
                  _StringGuts.appendInPlace(_:isASCII:)(v117, v118, (*((void *)&v199 + 1) & 0x4000000000000000) != 0);
                  swift_bridgeObjectRelease(*((uint64_t *)&v199 + 1));
                  goto LABEL_167;
                }
                if ((v199 & 0x1000000000000000) != 0)
                {
                  swift_bridgeObjectRelease(*((uint64_t *)&v199 + 1));
                  id v94 = (id)((*((void *)&v199 + 1) & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v95 = v34;
                }
                else
                {
                  id v94 = _StringObject.sharedUTF8.getter(v199, *((uint64_t *)&v199 + 1));
                  uint64_t v95 = v193;
                  swift_bridgeObjectRelease(*((uint64_t *)&v199 + 1));
                  if (v95 < v34) {
                    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
                  }
                }
                uint64_t v96 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v34, (uint64_t)v94, v95);
                _StringGuts.appendInPlace(_:isASCII:)(v96, v97, (uint64_t)v199 < 0);
                uint64_t v98 = *((void *)&v199 + 1);
              }
              swift_bridgeObjectRelease_n(v98, 2);
              goto LABEL_167;
            }
            unint64_t v99 = v91;
          }
          else
          {
            if (v90 > 15) {
              goto LABEL_122;
            }
            unint64_t v91 = *((void *)&v201[0] + 1);
            unint64_t v99 = *((void *)&v201[0] + 1);
            unint64_t v198 = *(void *)&v201[0];
            if ((*((void *)&v201[0] + 1) & 0x2000000000000000) == 0)
            {
LABEL_128:
              if ((v91 & 0x1000000000000000) != 0)
              {
                unint64_t v198 = _StringGuts._foreignConvertedToSmall()(v198, v91);
                unint64_t v99 = v191;
              }
              else
              {
                if ((v198 & 0x1000000000000000) != 0)
                {
                  size_t v100 = (unsigned __int8 *)((v91 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v101 = v198 & 0xFFFFFFFFFFFFLL;
                }
                else
                {
                  size_t v100 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v198, v91);
                  uint64_t v101 = v192;
                }
                swift_bridgeObjectRetain(v91);
                closure #1 in _StringGuts._convertedToSmall()(v100, v101, &v200);
                swift_bridgeObjectRelease(v91);
                unint64_t v99 = *((void *)&v200 + 1);
                unint64_t v198 = v200;
              }
            }
          }
          v102._unint64_t rawBits = (v32 << 16) | 1;
          v103._unint64_t rawBits = 1;
          v104._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v103, v102, v199, *((unint64_t *)&v199 + 1));
          if (v104._rawBits < 0x10000) {
            v104._rawBits |= 3;
          }
          unint64_t v106 = specialized String.init(_:)(v104, v105, v199, *((unint64_t *)&v199 + 1));
          uint64_t v108 = v107;
          swift_bridgeObjectRelease(*((uint64_t *)&v199 + 1));
          if ((v108 & 0x2000000000000000) == 0) {
            goto LABEL_223;
          }
          swift_bridgeObjectRelease(v108);
          goto LABEL_136;
        }
LABEL_215:
        __break(1u);
LABEL_216:
        if ((v32 & 0x1000000000000000) != 0)
        {
          uint64_t v34 = _StringGuts._foreignConvertedToSmall()(v34, v32);
          unint64_t v195 = v194;
          swift_bridgeObjectRelease(v32);
          unint64_t v32 = v195;
        }
        else
        {
          if ((v34 & 0x1000000000000000) != 0)
          {
            unint64_t v184 = (unsigned __int8 *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v185 = v34 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            unint64_t v184 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v34, v32);
          }
          closure #1 in _StringGuts._convertedToSmall()(v184, v185, &v200);
          swift_bridgeObjectRelease(v32);
          unint64_t v32 = *((void *)&v200 + 1);
          uint64_t v34 = v200;
        }
LABEL_56:
        uint64_t v49 = HIBYTE(v26) & 0xF;
        uint64_t v50 = HIBYTE(v32) & 0xF;
        uint64_t v51 = v50 + v49;
        if ((unint64_t)(v50 + v49) > 0xF) {
          goto LABEL_196;
        }
        if (v50)
        {
          char v52 = 0;
          unint64_t v53 = 0;
          do
          {
            unint64_t v54 = v49 + v53;
            unint64_t v55 = v53 + 1;
            if (v53 >= 8) {
              unint64_t v56 = v32;
            }
            else {
              unint64_t v56 = v34;
            }
            unint64_t v57 = v56 >> (v52 & 0x38);
            char v58 = (8 * v49 + v52) & 0x38;
            uint64_t v59 = (-255 << v58) - 1;
            unint64_t v60 = (unint64_t)v57 << v58;
            unint64_t v61 = v59 & v26 | v60;
            unint64_t v62 = v59 & v28 | v60;
            if (v54 < 8) {
              unint64_t v28 = v62;
            }
            else {
              unint64_t v26 = v61;
            }
            v52 += 8;
            unint64_t v53 = v55;
          }
          while (v50 != v55);
        }
        swift_bridgeObjectRelease((unint64_t)(v30 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
        swift_bridgeObjectRelease(v25);
        unint64_t v63 = 0xA000000000000000;
        if (!(v28 & 0x8080808080808080 | v26 & 0x80808080808080)) {
          unint64_t v63 = 0xE000000000000000;
        }
        unint64_t v29 = v63 & 0xFF00000000000000 | (v51 << 56) | v26 & 0xFFFFFFFFFFFFFFLL;
      }
    }
    uint64_t v30 = "Unknown raw display style '";
    if ((v24 & 0x2000000000000000) != 0 && (0x80000001816E3100 & 0x2000000000000000) != 0)
    {
      unint64_t v31 = v27 + ((0x80000001816E3100 >> 56) & 0xF);
      if (v31 <= 0xF)
      {
        unint64_t v72 = (0x80000001816E3100 >> 56) & 0xF;
        if (v72)
        {
          char v74 = 0;
          uint64_t v75 = 0;
          unint64_t v73 = v24;
          do
          {
            uint64_t v76 = v27 + v75;
            uint64_t v77 = v75 + 1;
            unint64_t v78 = 0x80000001816E3100 | 0x8000000000000000;
            if (v75 < 8) {
              unint64_t v78 = 0xD00000000000001BLL;
            }
            unint64_t v79 = v78 >> (v74 & 0x38);
            char v80 = (8 * v27 + v74) & 0x38;
            uint64_t v81 = (-255 << v80) - 1;
            unint64_t v82 = (unint64_t)v79 << v80;
            unint64_t v83 = v81 & v73 | v82;
            unint64_t v84 = v81 & v25 | v82;
            if (v76 < 8) {
              unint64_t v25 = v84;
            }
            else {
              unint64_t v73 = v83;
            }
            v74 += 8;
            uint64_t v75 = v77;
          }
          while (v72 != v77);
        }
        else
        {
          unint64_t v73 = v24;
        }
        swift_bridgeObjectRelease(0x80000001816E3100 | 0x8000000000000000);
        swift_bridgeObjectRelease(v26);
        unint64_t v85 = 0xA000000000000000;
        if (!(v25 & 0x8080808080808080 | v73 & 0x80808080808080)) {
          unint64_t v85 = 0xE000000000000000;
        }
        unint64_t v29 = v85 & 0xFF00000000000000 | (v31 << 56) | v73 & 0xFFFFFFFFFFFFFFLL;
        *(void *)&v201[0] = v25;
        goto LABEL_97;
      }
    }
    if ((0x80000001816E3100 & 0x2000000000000000) != 0) {
      unint64_t v32 = (0x80000001816E3100 >> 56) & 0xF;
    }
    else {
      unint64_t v32 = 27;
    }
    swift_bridgeObjectRetain_n(0x80000001816E3100 | 0x8000000000000000, 2);
    if ((0x80000001816E3100 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(0x80000001816E3100 | 0x8000000000000000, 5);
      v175._unint64_t rawBits = 1;
      v176._unint64_t rawBits = (v32 << 16) | 1;
      v177._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v175, v176, 0xD00000000000001BLL, 0x80000001816E3100 | 0x8000000000000000);
      if (v177._rawBits < 0x10000) {
        v177._rawBits |= 3;
      }
      uint64_t v33 = specialized Collection.count.getter(v177, v178, 0xD00000000000001BLL, 0x80000001816E3100 | 0x8000000000000000);
      swift_bridgeObjectRelease(0x80000001816E3100 | 0x8000000000000000);
      if ((v26 & 0x1000000000000000) == 0)
      {
LABEL_27:
        uint64_t v34 = v28 + v33;
        if (!__OFADD__(v28, v33)) {
          goto LABEL_28;
        }
        goto LABEL_209;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(0x80000001816E3100 | 0x8000000000000000, 4);
      uint64_t v33 = v32;
      if ((v26 & 0x1000000000000000) == 0) {
        goto LABEL_27;
      }
    }
    unint64_t v28 = String.UTF8View._foreignCount()();
    uint64_t v34 = v28 + v33;
    if (!__OFADD__(v28, v33))
    {
LABEL_28:
      if ((v25 & ~v26 & 0x2000000000000000) != 0)
      {
        BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v26 & 0xFFFFFFFFFFFFFFFLL);
        unint64_t v25 = *((void *)&v201[0] + 1);
        unint64_t v28 = *(void *)&v201[0];
        if (isUniquelyReferenced_nonNull_native)
        {
          int64_t v36 = _StringGuts.nativeUnusedCapacity.getter(*(uint64_t *)&v201[0], *((uint64_t *)&v201[0] + 1));
          if (v37) {
            goto LABEL_200;
          }
          if (v34 > 15) {
            goto LABEL_37;
          }
          if ((v25 & 0x2000000000000000) != 0)
          {
            unint64_t v26 = v25;
            goto LABEL_52;
          }
          if (v36 >= v33) {
            goto LABEL_37;
          }
          goto LABEL_48;
        }
      }
      else
      {
        unint64_t v25 = *((void *)&v201[0] + 1);
        unint64_t v28 = *(void *)&v201[0];
      }
      if (v34 > 15)
      {
LABEL_37:
        int64_t v38 = _StringGuts.nativeUnusedCapacity.getter(v28, v25);
        BOOL v41 = (v39 & 1) == 0 && v38 >= v33;
        if ((v28 & ~v25 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v25 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v41)
          {
LABEL_77:
            if ((0x80000001816E3100 & 0x1000000000000000) != 0)
            {
              _StringGuts._foreignAppendInPlace(_:)(0xD00000000000001BLL, 0x80000001816E3100 | 0x8000000000000000, 0, v32);
              unint64_t v71 = 0x80000001816E3100 | 0x8000000000000000;
            }
            else
            {
              swift_bridgeObjectRelease_n(0x80000001816E3100 | 0x8000000000000000, 5);
              char v68 = (0x80000001816E3100 & 0x2000000000000000) == 0
                 || (0x80000001816E3100 & 0x4000000000000000) != 0;
              if ((0x80000001816E3100 & 0x2000000000000000) != 0)
              {
                swift_bridgeObjectRelease(0x80000001816E3100 | 0x8000000000000000);
                *(void *)&long long v200 = 0xD00000000000001BLL;
                *((void *)&v200 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0x80000001816E3100 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v115 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v32, (uint64_t)&v200, (0x80000001816E3100 >> 56) & 0xF);
                _StringGuts.appendInPlace(_:isASCII:)(v115, v116, v68);
                swift_bridgeObjectRelease(0x80000001816E3100 | 0x8000000000000000);
                goto LABEL_98;
              }
              uint64_t v69 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v32, (0x80000001816E3100 & 0xFFFFFFFFFFFFFFFLL) + 32, 27);
              _StringGuts.appendInPlace(_:isASCII:)(v69, v70, v68);
              unint64_t v71 = 0x80000001816E3100 | 0x8000000000000000;
            }
            swift_bridgeObjectRelease_n(v71, 2);
            goto LABEL_98;
          }
        }
        else if (v41)
        {
LABEL_76:
          _StringGuts.grow(_:)(v34);
          goto LABEL_77;
        }
        uint64_t v64 = _StringGuts.nativeCapacity.getter(v28, v25);
        if (v65) {
          uint64_t v66 = 0;
        }
        else {
          uint64_t v66 = v64;
        }
        if (v66 + 0x4000000000000000 >= 0)
        {
          uint64_t v67 = 2 * v66;
          if (v67 > v34) {
            uint64_t v34 = v67;
          }
          goto LABEL_76;
        }
        __break(1u);
        goto LABEL_228;
      }
      unint64_t v26 = v25;
      if ((v25 & 0x2000000000000000) != 0) {
        goto LABEL_52;
      }
LABEL_48:
      if ((v25 & 0x1000000000000000) == 0)
      {
        if ((v28 & 0x1000000000000000) != 0)
        {
          uint64_t v42 = (unsigned __int8 *)((v25 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v43 = v28 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v42 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v28, v25);
          uint64_t v43 = v190;
        }
        swift_bridgeObjectRetain(v25);
        closure #1 in _StringGuts._convertedToSmall()(v42, v43, &v200);
        swift_bridgeObjectRelease(v25);
        unint64_t v26 = *((void *)&v200 + 1);
        unint64_t v28 = v200;
LABEL_52:
        v44._unint64_t rawBits = (v32 << 16) | 1;
        v45._unint64_t rawBits = 1;
        v46._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v45, v44, 0xD00000000000001BLL, 0x80000001816E3100 | 0x8000000000000000);
        if (v46._rawBits < 0x10000) {
          v46._rawBits |= 3;
        }
        uint64_t v34 = specialized String.init(_:)(v46, v47, 0xD00000000000001BLL, 0x80000001816E3100 | 0x8000000000000000);
        unint64_t v32 = v48;
        swift_bridgeObjectRelease(0x80000001816E3100 | 0x8000000000000000);
        if ((v32 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v32);
          goto LABEL_56;
        }
        goto LABEL_216;
      }
LABEL_228:
      unint64_t v28 = _StringGuts._foreignConvertedToSmall()(v28, v25);
      unint64_t v26 = v189;
      goto LABEL_52;
    }
LABEL_209:
    __break(1u);
    goto LABEL_210;
  }
  char v21 = 1;
  switch(v20)
  {
    case 'c':
      goto LABEL_11;
    case 'd':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
      goto LABEL_13;
    case 'e':
      char v21 = 2;
      goto LABEL_11;
    case 's':
      char v21 = 0;
      goto LABEL_11;
    case 't':
      char v21 = 3;
      goto LABEL_11;
    default:
      if (v20) {
        goto LABEL_13;
      }
      char v21 = 8;
LABEL_11:
      uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
      *(void *)a4 = a2;
      *(void *)(a4 + 8) = v15;
      *(unsigned char *)(a4 + 16) = v21;
      *(void *)(a4 + 24) = partial apply for closure #2 in Mirror.init(internalReflecting:subjectType:customAncestor:);
      *(void *)(a4 + 32) = v19;
      *(unsigned char *)(a4 + 4_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = 0;
      return result;
  }
}

uint64_t _EachFieldOptions.rawValue.getter()
{
  return *v0;
}

uint64_t _EachFieldOptions.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_EachFieldOptions.rawValue.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::_EachFieldOptions __swiftcall _EachFieldOptions.init(rawValue:)(Swift::_EachFieldOptions rawValue)
{
  v1->Builtin::RawPointer rawValue = rawValue.rawValue;
  return rawValue;
}

void static _EachFieldOptions.classType.getter(_DWORD *a1@<X8>)
{
  *a1 = static _EachFieldOptions.classType;
}

int *static _EachFieldOptions.classType.setter(int *result)
{
  static _EachFieldOptions.classType = *result;
  return result;
}

uint64_t (*static _EachFieldOptions.classType.modify())()
{
  return EnumeratedSequence._base.modify;
}

void static _EachFieldOptions.ignoreUnknown.getter(_DWORD *a1@<X8>)
{
  *a1 = static _EachFieldOptions.ignoreUnknown;
}

int *static _EachFieldOptions.ignoreUnknown.setter(int *result)
{
  static _EachFieldOptions.ignoreUnknown = *result;
  return result;
}

uint64_t (*static _EachFieldOptions.ignoreUnknown.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for SetAlgebra.init() in conformance _EachFieldOptions(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

_DWORD *protocol witness for SetAlgebra.union(_:) in conformance _EachFieldOptions@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.intersection(_:) in conformance _EachFieldOptions@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.symmetricDifference(_:) in conformance _EachFieldOptions@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL protocol witness for SetAlgebra.insert(_:) in conformance _EachFieldOptions(_DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1 = v3;
  return v4 != v3;
}

_DWORD *protocol witness for SetAlgebra.remove(_:) in conformance _EachFieldOptions@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(_DWORD *)a2 = v3;
  *(unsigned char *)(a2 + 4) = v3 == 0;
  return result;
}

int *protocol witness for SetAlgebra.update(with:) in conformance _EachFieldOptions@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  *v2 |= *result;
  int v5 = v4 & v3;
  *(_DWORD *)a2 = v5;
  *(unsigned char *)(a2 + 4) = v5 == 0;
  return result;
}

_DWORD *protocol witness for SetAlgebra.formUnion(_:) in conformance _EachFieldOptions(_DWORD *result)
{
  *v1 |= *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.formIntersection(_:) in conformance _EachFieldOptions(_DWORD *result)
{
  *v1 &= *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.formSymmetricDifference(_:) in conformance _EachFieldOptions(_DWORD *result)
{
  *v1 ^= *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.subtracting(_:) in conformance _EachFieldOptions@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

uint64_t SetAlgebra.subtracting(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v20[0] = a1;
  v20[1] = a4;
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)v20 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)v20 - v15;
  MEMORY[0x1F4188790](v14);
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v17((char *)v20 - v18, v4, a2);
  v17(v13, v4, a2);
  v17(v10, v20[0], a2);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 64))(v10, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 56))(v16, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v16, a2);
}

{
  uint64_t v4;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t vars8;

  SetAlgebra.subtracting(_:)(a1, a2, a3, a4);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8);

  return v6(v4, a2);
}

BOOL protocol witness for SetAlgebra.isSubset(of:) in conformance _EachFieldOptions(_DWORD *a1)
{
  return (*v1 & ~*a1) == 0;
}

uint64_t SetAlgebra.isSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v15 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v11, v4, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(v7, a2, a3);
  LOBYTE(v7) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a3 + 8) + 8))(v13, v4, a2);
  (*(void (**)(char *, uint64_t))(v8 + 8))(v13, a2);
  return v7 & 1;
}

BOOL protocol witness for SetAlgebra.isDisjoint(with:) in conformance _EachFieldOptions(_DWORD *a1)
{
  return (*v1 & *a1) == 0;
}

uint64_t SetAlgebra.isDisjoint(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v14 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, v3, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(a1, a2, a3);
  LOBYTE(a3) = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 152))(a2, a3);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v12, a2);
  return a3 & 1;
}

BOOL protocol witness for SetAlgebra.isSuperset(of:) in conformance _EachFieldOptions(_DWORD *a1)
{
  return (*a1 & ~*v1) == 0;
}

uint64_t SetAlgebra.isSuperset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 128))(v3) & 1;
}

BOOL protocol witness for SetAlgebra.isEmpty.getter in conformance _EachFieldOptions()
{
  return *v0 == 0;
}

uint64_t SetAlgebra.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v12 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v10 + 32))(v7);
  LOBYTE(v3) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(a2 + 8) + 8))(v3, v9, a1);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a1);
  return v3 & 1;
}

uint64_t specialized SetAlgebra.init<A>(_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _DWORD *a3@<X8>)
{
  void (*v11)(uint64_t *__return_ptr, const char *, uint64_t);
  int v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;

  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v15 - v8;
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v16 & 0x100000000) != 0)
  {
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = v16;
      if ((v16 & ~v12) == 0) {
        uint64_t v13 = 0;
      }
      v12 |= v13;
      v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
    }
    while (BYTE4(v16) != 1);
  }
  uint64_t result = (*(uint64_t (**)(char *, const char *))(v7 + 8))(v9, AssociatedTypeWitness);
  *a3 = v12;
  return result;
}

uint64_t SetAlgebra.init<A>(_:)@<X0>(unsigned int (*a1)(char *, uint64_t, const char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v53 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a2, (uint64_t)&protocol requirements base descriptor for SetAlgebra, associated type descriptor for SetAlgebra.Element);
  uint64_t v59 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v55 = (char *)&v48 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  unint64_t v54 = (char *)&v48 - v14;
  uint64_t v17 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v15, v16);
  MEMORY[0x1F4188790](v17 - 1);
  uint64_t v19 = (char *)&v48 - v18;
  char v20 = swift_getAssociatedTypeWitness(0, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v49 = *((void *)v20 - 1);
  MEMORY[0x1F4188790](v20);
  uint64_t v22 = (char *)&v48 - v21;
  uint64_t v23 = *(void (**)(uint64_t, uint64_t))(a4 + 32);
  uint64_t v56 = a6;
  uint64_t v57 = a2;
  uint64_t v58 = a4;
  uint64_t v24 = a4;
  uint64_t v26 = v25;
  v23(a2, v24);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t v27 = v22;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, v26, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = AssociatedConformanceWitness + 16;
  unint64_t v29 = *(void (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 16);
  v29(v26, AssociatedConformanceWitness);
  uint64_t v31 = v59;
  uint64_t v33 = v59 + 48;
  unint64_t v32 = *(unsigned int (**)(char *, uint64_t, const char *))(v59 + 48);
  if (v32(v19, 1, AssociatedTypeWitness) != 1)
  {
    uint64_t v34 = *(void (**)(char *, char *, const char *))(v31 + 32);
    uint64_t v51 = v58 + 72;
    char v52 = v34;
    uint64_t v59 = v31 + 32;
    uint64_t v50 = (void (**)(char *, const char *))(v31 + 8);
    unint64_t v53 = v32;
    do
    {
      uint64_t v35 = v55;
      v52(v55, v19, AssociatedTypeWitness);
      int64_t v36 = v19;
      char v37 = AssociatedTypeWitness;
      uint64_t v38 = v33;
      char v39 = v29;
      uint64_t v40 = v30;
      uint64_t v41 = AssociatedConformanceWitness;
      uint64_t v42 = v27;
      uint64_t v43 = v26;
      Swift::String::Index v44 = v54;
      (*(void (**)(char *, char *, uint64_t))(v58 + 72))(v54, v35, v57);
      Swift::String::Index v45 = v44;
      uint64_t v26 = v43;
      uint64_t v27 = v42;
      uint64_t AssociatedConformanceWitness = v41;
      uint64_t v30 = v40;
      unint64_t v29 = v39;
      uint64_t v33 = v38;
      uint64_t AssociatedTypeWitness = v37;
      uint64_t v19 = v36;
      Swift::String::Index v46 = v53;
      (*v50)(v45, AssociatedTypeWitness);
      v29(v26, AssociatedConformanceWitness);
    }
    while (v46(v19, 1, AssociatedTypeWitness) != 1);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v49 + 8))(v27, v26);
}

{
  return SetAlgebra.init<A>(_:)(a1, a4, a2, a5, a3, a6);
}

_DWORD *protocol witness for SetAlgebra.subtract(_:) in conformance _EachFieldOptions(_DWORD *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t SetAlgebra.subtract(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v19 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v19 - v15;
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v17(v14, v4, a2);
  v17(v11, a1, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 64))(v11, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 104))(v16, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v16, a2);
}

_DWORD *protocol witness for RawRepresentable.init(rawValue:) in conformance _EachFieldOptions@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *result;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance _EachFieldOptions(_DWORD *a1@<X8>)
{
  *a1 = *v1;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _EachFieldOptions(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

void specialized SetAlgebra<>.init(arrayLiteral:)(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    int v4 = 0;
    int v5 = (int *)(a1 + 32);
    do
    {
      int v7 = *v5++;
      int v6 = v7;
      if ((v7 & ~v4) == 0) {
        int v6 = 0;
      }
      v4 |= v6;
      --v3;
    }
    while (v3);
  }
  else
  {
    int v4 = 0;
  }
  swift_bridgeObjectRelease(a1);
  *a2 = v4;
}

uint64_t SetAlgebra<>.init(arrayLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a1;
  int v5 = *(uint64_t (**)(uint64_t *, unint64_t *, uint64_t, uint64_t, uint64_t))(a3 + 160);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a3 + 16), a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByArrayLiteral, associated type descriptor for ExpressibleByArrayLiteral.ArrayLiteralElement);
  uint64_t v9 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v9, v10);
  return v5(&v13, v9, WitnessTable, a2, a3);
}

Swift::_MetadataKind_optional __swiftcall _MetadataKind.init(rawValue:)(Swift::UInt rawValue)
{
  if ((uint64_t)rawValue > 1023)
  {
    if ((uint64_t)rawValue > 1280)
    {
      if (rawValue == 1281)
      {
        *uint64_t v1 = 14;
        return (Swift::_MetadataKind_optional)rawValue;
      }
      if (rawValue == 0xFFFF)
      {
        *uint64_t v1 = 15;
        return (Swift::_MetadataKind_optional)rawValue;
      }
    }
    else
    {
      if (rawValue == 1024)
      {
        *uint64_t v1 = 12;
        return (Swift::_MetadataKind_optional)rawValue;
      }
      if (rawValue == 1280)
      {
        *uint64_t v1 = 13;
        return (Swift::_MetadataKind_optional)rawValue;
      }
    }
LABEL_18:
    *uint64_t v1 = 16;
    return (Swift::_MetadataKind_optional)rawValue;
  }
  switch(rawValue)
  {
    case 0x300uLL:
      *uint64_t v1 = 5;
      break;
    case 0x301uLL:
      *uint64_t v1 = 6;
      break;
    case 0x302uLL:
      *uint64_t v1 = 7;
      break;
    case 0x303uLL:
      *uint64_t v1 = 8;
      break;
    case 0x304uLL:
      *uint64_t v1 = 9;
      break;
    case 0x305uLL:
      *uint64_t v1 = 10;
      break;
    case 0x306uLL:
      *uint64_t v1 = 11;
      break;
    default:
      char v2 = 1;
      switch(rawValue)
      {
        case 0x200uLL:
          goto LABEL_17;
        case 0x201uLL:
          *uint64_t v1 = 2;
          break;
        case 0x202uLL:
          *uint64_t v1 = 3;
          break;
        case 0x203uLL:
          *uint64_t v1 = 4;
          break;
        default:
          if (rawValue) {
            goto LABEL_18;
          }
          char v2 = 0;
LABEL_17:
          *uint64_t v1 = v2;
          break;
      }
      break;
  }
  return (Swift::_MetadataKind_optional)rawValue;
}

uint64_t _MetadataKind.rawValue.getter()
{
  return qword_181636860[*v0];
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _MetadataKind(char *a1, char *a2)
{
  return qword_181636860[*a1] == qword_181636860[*a2];
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance _MetadataKind()
{
  Hasher._combine(_:)(qword_181636860[*v0]);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance _MetadataKind()
{
  Hasher._combine(_:)(qword_181636860[*v0]);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance _MetadataKind()
{
  Hasher._combine(_:)(qword_181636860[*v0]);
  return Hasher._finalize()();
}

Swift::_MetadataKind_optional protocol witness for RawRepresentable.init(rawValue:) in conformance _MetadataKind(Swift::UInt *a1)
{
  return _MetadataKind.init(rawValue:)(*a1);
}

void protocol witness for RawRepresentable.rawValue.getter in conformance _MetadataKind(void *a1@<X8>)
{
  *a1 = qword_181636860[*v1];
}

uint64_t _forEachField(of:options:body:)(uint64_t *a1, int *a2, uint64_t (*a3)(char *, uint64_t, void *, char *))
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v5 = *a2;
  if (swift_isClassType(a1) == ((static _EachFieldOptions.classType & ~v5) != 0)) {
    return 0;
  }
  uint64_t v6 = swift_reflectionMirror_recursiveCount(a1);
  if (v6 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v7 = (char *)v6;
  if (!v6) {
    return 1;
  }
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t v9 = swift_reflectionMirror_recursiveChildOffset(a1, v8);
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    __int16 v20 = 0;
    uint64_t v10 = (void *)swift_reflectionMirror_recursiveChildMetadata((char *)a1, v8, &v18);
    Swift::UInt MetadataKind = swift_getMetadataKind(v10);
    _MetadataKind.init(rawValue:)(MetadataKind);
    char v12 = v17 == 16 ? 15 : v17;
    uint64_t v13 = v18;
    if (!v18) {
      break;
    }
    char v17 = v12;
    if ((a3(v18, v9, v10, &v17) & 1) == 0)
    {
      uint64_t v15 = v19;
      if (!v19) {
        return 0;
      }
      uint64_t v16 = v13;
      goto LABEL_20;
    }
LABEL_13:
    if (v19) {
      v19(v13);
    }
    if (v7 == ++v8) {
      return 1;
    }
  }
  char v17 = v12;
  if (a3("", v9, v10, &v17)) {
    goto LABEL_13;
  }
  uint64_t v15 = v19;
  if (!v19) {
    return 0;
  }
  uint64_t v16 = 0;
LABEL_20:
  v15(v16);
  return 0;
}

uint64_t _forEachFieldWithKeyPath<A>(of:options:body:)(uint64_t *a1, int *a2, uint64_t (*a3)(char *, void *), uint64_t a4, uint64_t a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v8 = *a2;
  if (swift_isClassType(a1) || (static _EachFieldOptions.classType & ~v8) == 0) {
    return 0;
  }
  int v10 = static _EachFieldOptions.ignoreUnknown;
  uint64_t v11 = swift_reflectionMirror_recursiveCount(a1);
  if (v11 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  char v12 = (char *)v11;
  if (!v11) {
    return 1;
  }
  uint64_t v13 = 0;
  int v14 = v10 & v8;
  while (1)
  {
    if (v12 == v13) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
    }
    swift_reflectionMirror_recursiveChildOffset(a1, v13);
    unint64_t v29 = 0;
    uint64_t v30 = 0;
    __int16 v31 = 0;
    uint64_t v15 = (void *)swift_reflectionMirror_recursiveChildMetadata((char *)a1, v13, &v29);
    Swift::UInt MetadataKind = swift_getMetadataKind(v15);
    _MetadataKind.init(rawValue:)(MetadataKind);
    BOOL v18 = v28 > 0xBu || ((1 << v28) & 0x94F) == 0;
    if (!v18 && (v31 & 1) != 0) {
      break;
    }
    __int16 v20 = v30;
    if (v14 != v10)
    {
      if (!v30) {
        return 0;
      }
      uint64_t v26 = v29;
      goto LABEL_37;
    }
    if (v30) {
      v30(v29);
    }
LABEL_27:
    ++v13;
    uint64_t result = 1;
    if (v12 == v13) {
      return result;
    }
  }
  int v27 = v14;
  if (HIBYTE(v31) == 1) {
    uint64_t v19 = type metadata accessor for WritableKeyPath(0, a5, (uint64_t)v15, v17);
  }
  else {
    uint64_t v19 = type metadata accessor for KeyPath(0, a5, (uint64_t)v15, v17);
  }
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v22 = swift_allocObject((unint64_t *)v21, ((*(unsigned int *)(v21 + 48) + 3) & 0x1FFFFFFFCLL) + 12, *(unsigned __int16 *)(v21 + 52) | 3);
  v22[2] = 0;
  partial apply for closure #1 in _forEachFieldWithKeyPath<A>(of:options:body:)(v22 + 3, (char *)v22 + 36);
  uint64_t v23 = v29;
  if (v29)
  {
    char v24 = a3(v29, v22);
    swift_release((uint64_t)v22);
    if ((v24 & 1) == 0)
    {
      __int16 v20 = v30;
      if (!v30) {
        return 0;
      }
      uint64_t v26 = v23;
      goto LABEL_37;
    }
    goto LABEL_24;
  }
  char v25 = a3("", v22);
  swift_release((uint64_t)v22);
  if (v25)
  {
LABEL_24:
    if (v30) {
      v30(v23);
    }
    int v14 = v27;
    goto LABEL_27;
  }
  __int16 v20 = v30;
  if (!v30) {
    return 0;
  }
  uint64_t v26 = 0;
LABEL_37:
  v20(v26);
  return 0;
}

uint64_t Repeated.count.getter()
{
  return *(void *)v0;
}

uint64_t Repeated.repeatedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 16))(a2, v2 + *(int *)(a1 + 28));
}

uint64_t Repeated.startIndex.getter()
{
  return 0;
}

uint64_t Repeated.endIndex.getter()
{
  return *(void *)v0;
}

uint64_t Repeated.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v18 - v12;
  int v14 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v14((char *)&v18 - v12, v4, a2);
  v14(v11, (uint64_t)v13, a2);
  if (a1 < 0)
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, a2);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Repeat.swift", 18, 2, 0x51uLL, 0);
  }
  uint64_t v15 = *(void *)v11;
  uint64_t v16 = *(void (**)(char *, uint64_t))(v8 + 8);
  v16(v11, a2);
  if (v15 <= a1) {
    goto LABEL_5;
  }
  v16(v13, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 16))(a3, v4 + *(int *)(a2 + 28));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Repeated<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);

  return RandomAccessCollection<>.index(before:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Repeated<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Repeated<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Repeated<A>(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance Repeated<A>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = Repeated.endIndex.getter();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Repeated<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = Repeated.subscript.read(v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*Repeated.subscript.read(void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = *(void *)(a3 + 16);
  *a1 = v6;
  uint64_t v7 = *(void *)(v6 - 8);
  a1[1] = v7;
  uint64_t v8 = malloc(*(void *)(v7 + 64));
  a1[2] = v8;
  Repeated.subscript.getter(a2, a3, (uint64_t)v8);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.indices.getter in conformance Repeated<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance Repeated<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);

  return RandomAccessCollection<>.index(after:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance Repeated<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>(void *a1, unint64_t *a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);
  uint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

Class *protocol witness for Sequence.makeIterator() in conformance Repeated<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2;
  (*(void (**)(uint64_t, uint64_t, unint64_t *))(*(a1 - 1) + 32))(a2, v4, a1);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a1, v6);
  uint64_t result = type metadata accessor for IndexingIterator(0, (uint64_t)a1, WitnessTable, v8);
  *(void *)(a2 + *((int *)result + 9)) = 0;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance Repeated<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Repeated<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t repeatElement<A>(_:count:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v7 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v7 + 16))(v9);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  }
  *(void *)a4 = a2;
  uint64_t v12 = type metadata accessor for Repeated(0, a3, v10, v11);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v7 + 32))(&a4[*((int *)v12 + 7)], v9, a3);
}

Swift::Void __swiftcall _replPrintLiteralString(_:)(Swift::String a1)
{
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  uint64_t v3 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  inited = swift_initStackObject(v3, v11);
  *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_18162AC80;
  inited[7] = &type metadata for String;
  inited[4] = countAndFlagsBits;
  inited[5] = object;
  int v5 = (atomic_ullong *)_playgroundPrintHook;
  if (_playgroundPrintHook)
  {
    uint64_t v6 = (atomic_ullong *)qword_1E8EBFEF8;
    unint64_t v9 = 0;
    unint64_t v10 = 0xE000000000000000;
    swift_bridgeObjectRetain((unint64_t)object);
    outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?(v5, v6);
    specialized _print<A>(_:separator:terminator:to:)((uint64_t)inited, 32, 0xE100000000000000, 0, 0xE000000000000000, &v9);
    swift_bridgeObjectRelease((uint64_t)inited);
    uint64_t v7 = v10;
    ((void (*)(unint64_t, unint64_t))v5)(v9, v10);
    swift_bridgeObjectRelease(v7);
    outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v5, (uint64_t)v6);
  }
  else
  {
    swift_bridgeObjectRetain((unint64_t)object);
    specialized _print<A>(_:separator:terminator:to:)((uint64_t)inited, 32, 0xE100000000000000, 0, 0xE000000000000000, v8, (void (*)(uint64_t *, uint64_t, Class *, ValueMetadata *, _UNKNOWN **))_print_unlocked<A, B>(_:_:));
    swift_bridgeObjectRelease((uint64_t)inited);
  }
}

void _replDebugPrintln<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  inited = swift_initStackObject(v4, v13);
  *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_18162AC80;
  inited[7] = a2;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(boxed_opaque_existential_0Tm, a1, a2);
  uint64_t v8 = (void (*)(unint64_t, unint64_t))_playgroundPrintHook;
  if (_playgroundPrintHook)
  {
    uint64_t v9 = qword_1E8EBFEF8;
    unint64_t v11 = 0;
    unint64_t v12 = 0xE000000000000000;
    swift_retain((atomic_ullong *)qword_1E8EBFEF8);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 32, 0xE100000000000000, 10, 0xE100000000000000, &v11);
    swift_bridgeObjectRelease((uint64_t)inited);
    uint64_t v10 = v12;
    v8(v11, v12);
    swift_bridgeObjectRelease(v10);
    outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v8, v9);
  }
  else
  {
    specialized _print<A>(_:separator:terminator:to:)((uint64_t)inited, 32, 0xE100000000000000, 10, 0xE100000000000000, v7, (void (*)(uint64_t *, uint64_t, Class *, ValueMetadata *, _UNKNOWN **))_debugPrint_unlocked<A, B>(_:_:));
    swift_bridgeObjectRelease((uint64_t)inited);
  }
}

uint64_t static Result<>.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v38 = a5;
  uint64_t v39 = a6;
  uint64_t v44 = a1;
  uint64_t v45 = a2;
  uint64_t v42 = *(void *)(a4 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  char v37 = (char *)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v41 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v7);
  int64_t v36 = (char *)&v36 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v43 = v11;
  uint64_t v14 = type metadata accessor for Result(0, v12, v11, v13);
  uint64_t v15 = (uint64_t)*(v14 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v36 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  __int16 v20 = (char *)&v36 - v19;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v14, (uint64_t)v14, 0, 0);
  uint64_t v40 = *(TupleTypeMetadata2 - 1);
  uint64_t v22 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v24 = (unsigned __int8 *)&v36 - v23;
  char v25 = (unsigned __int8 *)&v36 + *(int *)(v22 + 48) - v23;
  uint64_t v26 = *(void (**)(char *, uint64_t, Class *))(v15 + 16);
  v26((char *)&v36 - v23, v44, v14);
  v26((char *)v25, v45, v14);
  if (swift_getEnumCaseMultiPayload(v24, (uint64_t)v14) != 1)
  {
    v26(v20, (uint64_t)v24, v14);
    if (swift_getEnumCaseMultiPayload(v25, (uint64_t)v14) != 1)
    {
      uint64_t v32 = v41;
      uint64_t v33 = v36;
      (*(void (**)(char *, unsigned __int8 *, uint64_t))(v41 + 32))(v36, v25, a3);
      char v30 = (*(uint64_t (**)(char *, char *, uint64_t))(v38 + 8))(v20, v33, a3);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v32 + 8);
      v34(v33, a3);
      v34(v20, a3);
      goto LABEL_9;
    }
    (*(void (**)(char *, uint64_t))(v41 + 8))(v20, a3);
    goto LABEL_7;
  }
  v26(v18, (uint64_t)v24, v14);
  if (swift_getEnumCaseMultiPayload(v25, (uint64_t)v14) != 1)
  {
    (*(void (**)(char *, uint64_t))(v42 + 8))(v18, v43);
LABEL_7:
    char v30 = 0;
    uint64_t v15 = v40;
    uint64_t v14 = (Class *)TupleTypeMetadata2;
    goto LABEL_9;
  }
  uint64_t v28 = v42;
  uint64_t v27 = v43;
  unint64_t v29 = v37;
  (*(void (**)(char *, unsigned __int8 *, uint64_t))(v42 + 32))(v37, v25, v43);
  char v30 = (*(uint64_t (**)(char *, char *, uint64_t))(v39 + 8))(v18, v29, v27);
  __int16 v31 = *(void (**)(char *, uint64_t))(v28 + 8);
  v31(v29, v27);
  v31(v18, v27);
LABEL_9:
  (*(void (**)(unsigned __int8 *, Class *))(v15 + 8))(v24, v14);
  return v30 & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <> Result<A, B>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return static Result<>.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24), *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t Result<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = a4;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v9);
  uint64_t v17 = (char *)&v23 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (unsigned __int8 *)&v23 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v20 + 16))(v19, v21, a2);
  if (swift_getEnumCaseMultiPayload(v19, a2) == 1)
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v8 + 32))(v11, v19, v7);
    Hasher._combine(_:)(1uLL);
    (*(void (**)(uint64_t, uint64_t))(v24 + 24))(a1, v7);
    return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
  }
  else
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v14 + 32))(v17, v19, v13);
    Hasher._combine(_:)(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v13, a3);
    return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v17, v13);
  }
}

Swift::Int Result<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = 0;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v4[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v4[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v5 = 0u;
  long long v6 = 0u;
  Result<>.hash(into:)((uint64_t)v4, a1, a2, a3);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> Result<A, B>(uint64_t a1, uint64_t a2)
{
  return Result<>.hashValue.getter(a1, *(void *)(a2 - 8), *(void *)(a2 - 16));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> Result<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Result<>.hash(into:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> Result<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t, uint64_t))Result<>.hash(into:));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v5 = *(void *)(a3 - 16);
  uint64_t v6 = *(void *)(a3 - 8);
  v8[0] = 0;
  v8[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  uint64_t v8[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v8[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v8[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v9 = 0u;
  long long v10 = 0u;
  a4(v8, a2, v6, v5);
  return Hasher._finalize()();
}

void Result.map<A>(_:)(void (*a1)(char *)@<X0>, void *a2@<X2>, uint64_t a3@<X3>, unsigned char *a4@<X8>)
{
  uint64_t v8 = a2[2];
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v20 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (unsigned __int8 *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t))(v15 + 16))(v14, v16);
  if (swift_getEnumCaseMultiPayload(v14, (uint64_t)a2) == 1)
  {
    uint64_t v17 = a2[3];
    (*(void (**)(unsigned char *, unsigned __int8 *, uint64_t))(*(void *)(v17 - 8) + 32))(a4, v14, v17);
    unsigned int v18 = 1;
  }
  else
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v9 + 32))(v12, v14, v8);
    a1(v12);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
    unsigned int v18 = 0;
    uint64_t v17 = a2[3];
  }
  uint64_t v19 = type metadata accessor for Result(0, a3, v17, a2[4]);
  swift_storeEnumTagMultiPayload(a4, (uint64_t)v19, v18);
}

void Result.mapError<A>(_:)(void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unsigned char *a5@<X8>)
{
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (unsigned __int8 *)&v22 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t))(v17 + 16))(v16, v18);
  if (swift_getEnumCaseMultiPayload(v16, a2) == 1)
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v11 + 32))(v14, v16, v10);
    a1(v14);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    uint64_t v19 = *(void *)(a2 + 16);
    unsigned int v20 = 1;
  }
  else
  {
    uint64_t v19 = *(void *)(a2 + 16);
    (*(void (**)(unsigned char *, unsigned __int8 *, uint64_t))(*(void *)(v19 - 8) + 32))(a5, v16, v19);
    unsigned int v20 = 0;
  }
  uint64_t v21 = type metadata accessor for Result(0, v19, a3, a4);
  swift_storeEnumTagMultiPayload(a5, (uint64_t)v21, v20);
}

void Result.flatMap<A>(_:)(void (*a1)(char *)@<X0>, void *a2@<X2>, uint64_t a3@<X3>, unsigned char *a4@<X8>)
{
  uint64_t v8 = a2[2];
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v19 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (unsigned __int8 *)&v19 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t))(v15 + 16))(v14, v16);
  if (swift_getEnumCaseMultiPayload(v14, (uint64_t)a2) == 1)
  {
    uint64_t v17 = a2[3];
    (*(void (**)(unsigned char *, unsigned __int8 *, uint64_t))(*(void *)(v17 - 8) + 32))(a4, v14, v17);
    uint64_t v18 = type metadata accessor for Result(0, a3, v17, a2[4]);
    swift_storeEnumTagMultiPayload(a4, (uint64_t)v18, 1u);
  }
  else
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v9 + 32))(v12, v14, v8);
    a1(v12);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }
}

void Result.flatMapError<A>(_:)(void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unsigned char *a5@<X8>)
{
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (unsigned __int8 *)&v21 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t))(v17 + 16))(v16, v18);
  if (swift_getEnumCaseMultiPayload(v16, a2) == 1)
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v11 + 32))(v14, v16, v10);
    a1(v14);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
  }
  else
  {
    uint64_t v19 = *(void *)(a2 + 16);
    (*(void (**)(unsigned char *, unsigned __int8 *, uint64_t))(*(void *)(v19 - 8) + 32))(a5, v16, v19);
    unsigned int v20 = type metadata accessor for Result(0, v19, a3, a4);
    swift_storeEnumTagMultiPayload(a5, (uint64_t)v20, 0);
  }
}

uint64_t Result.get()@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v10 = (unsigned __int8 *)v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *))(v11 + 16))(v10);
  if (swift_getEnumCaseMultiPayload(v10, (uint64_t)a1) != 1) {
    return (*(uint64_t (**)(uint64_t, unsigned __int8 *))(*(void *)(a1[2] - 8) + 32))(a2, v10);
  }
  uint64_t v12 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v5 + 32);
  v12(v8, v10, v4);
  swift_allocError(v4, a1[4], 0, 0);
  v12(v13, (unsigned __int8 *)v8, v4);
  return swift_willThrow();
}

uint64_t Result<>.init(catching:)@<X0>(void (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for Error);
  uint64_t v7 = type metadata accessor for Result(0, a2, v6, (uint64_t)&protocol self-conformance witness table for Error);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v13 - v10;
  a1(v9);
  swift_storeEnumTagMultiPayload(v11, (uint64_t)v7, 0);
  return (*(uint64_t (**)(uint64_t, unsigned char *, Class *))(v8 + 32))(a3, v11, v7);
}

uint64_t ReversedCollection.Iterator._position.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a1 + 24) + 8), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v6(a2, v4, AssociatedTypeWitness);
}

uint64_t ReversedCollection.Iterator._position.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 36);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a2 + 24) + 8), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40);

  return v6(v4, a1, AssociatedTypeWitness);
}

uint64_t (*ReversedCollection.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t ReversedCollection.Iterator.init(_base:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v17 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))(a4, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v8 + 72))(a2, v8);
  (*(void (**)(uint64_t, uint64_t))(v13 + 8))(a1, a2);
  uint64_t v15 = type metadata accessor for ReversedCollection.Iterator(0, a2, a3, v14);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v10 + 32))(a4 + *((int *)v15 + 9), v12, AssociatedTypeWitness);
}

uint64_t ReversedCollection.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v4 = a1;
  uint64_t v26 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v25 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v25 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v25 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v25 - v12;
  uint64_t v14 = v3 + *(int *)(v4 + 36);
  (*(void (**)(char *, uint64_t, const char *))(v8 + 16))((char *)&v25 - v12, v14, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v4) = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                       + 8))(v13, v11, AssociatedTypeWitness);
  uint64_t v16 = *(void (**)(char *, const char *))(v8 + 8);
  v16(v11, AssociatedTypeWitness);
  v16(v13, AssociatedTypeWitness);
  if (v4)
  {
    uint64_t v24 = swift_getAssociatedTypeWitness(0, *(int ***)(v6 + 8), v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v24 - 1) + 56))(v26, 1, 1, v24);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(v25 + 40))(v14, v5);
    uint64_t v17 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v6 + 80))(v27, v14, v5, v6);
    uint64_t v19 = v18;
    unsigned int v20 = swift_getAssociatedTypeWitness(0, *(int ***)(v6 + 8), v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    uint64_t v21 = *((void *)v20 - 1);
    uint64_t v22 = v26;
    (*(void (**)(uint64_t, uint64_t, const char *))(v21 + 16))(v26, v19, v20);
    v17(v27, 0);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v21 + 56))(v22, 0, 1, v20);
  }
}

uint64_t protocol witness for IteratorProtocol.next() in conformance ReversedCollection<A>.Iterator@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v26 = a2;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v25 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(v25 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v25 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v25 - v11;
  uint64_t v13 = v2 + *(int *)(a1 + 36);
  (*(void (**)(char *, uint64_t, const char *))(v7 + 16))((char *)&v25 - v11, v13, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v4, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v15 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v12, v10, AssociatedTypeWitness);
  uint64_t v16 = *(void (**)(char *, const char *))(v7 + 8);
  v16(v10, AssociatedTypeWitness);
  v16(v12, AssociatedTypeWitness);
  if (v15)
  {
    uint64_t v24 = swift_getAssociatedTypeWitness(0, *(int ***)(v5 + 8), v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v24 - 1) + 56))(v26, 1, 1, v24);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(v25 + 40))(v13, v4);
    uint64_t v17 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v5 + 80))(v27, v13, v4, v5);
    uint64_t v19 = v18;
    unsigned int v20 = swift_getAssociatedTypeWitness(0, *(int ***)(v5 + 8), v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    uint64_t v21 = *((void *)v20 - 1);
    uint64_t v22 = v26;
    (*(void (**)(uint64_t, uint64_t, const char *))(v21 + 16))(v26, v19, v20);
    v17(v27, 0);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v21 + 56))(v22, 0, 1, v20);
  }
}

uint64_t ReversedCollection.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v18 - v10;
  uint64_t v12 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 32))(v14, v2, v5);
  (*(void (**)(uint64_t, char *, uint64_t))(v12 + 16))(a2, v14, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v5);
  uint64_t v16 = type metadata accessor for ReversedCollection.Iterator(0, v5, v4, v15);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v8 + 32))(a2 + *((int *)v16 + 9), v11, AssociatedTypeWitness);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance ReversedCollection<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v18 - v10;
  uint64_t v12 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 32))(v14, v2, v5);
  (*(void (**)(uint64_t, char *, uint64_t))(v12 + 16))(a2, v14, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v5);
  uint64_t v16 = type metadata accessor for ReversedCollection.Iterator(0, v5, v4, v15);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v8 + 32))(a2 + *((int *)v16 + 9), v11, AssociatedTypeWitness);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance ReversedCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance ReversedCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t ReversedCollection.Index.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a1 + 24) + 8), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v5(a2, v2, AssociatedTypeWitness);
}

uint64_t ReversedCollection.Index.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32);

  return v7(a4, a1, AssociatedTypeWitness);
}

uint64_t static ReversedCollection.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(int ***)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(a1, a2, AssociatedTypeWitness) & 1;
}

uint64_t static ReversedCollection.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(int ***)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 40))(a1, a2, AssociatedTypeWitness, AssociatedConformanceWitness) & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance ReversedCollection<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static ReversedCollection.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance ReversedCollection<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static ReversedCollection.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t ReversedCollection.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(uint64_t (**)(uint64_t, const char *, uint64_t))(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a2 + 24) + 8), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);

  return v7(a1, AssociatedTypeWitness, a3);
}

Swift::Int ReversedCollection.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = *(void (**)(void *, const char *, uint64_t))(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a1 + 24) + 8), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v3(v6, AssociatedTypeWitness, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> ReversedCollection<A>.Index(uint64_t a1, uint64_t a2)
{
  return ReversedCollection.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> ReversedCollection<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ReversedCollection.Index<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> ReversedCollection<A>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))ReversedCollection.Index<>.hash(into:));
}

uint64_t ReversedCollection.startIndex.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 8) + 72))(*(void *)(a1 + 16));
}

uint64_t ReversedCollection.endIndex.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 8) + 64))(*(void *)(a1 + 16));
}

uint64_t ReversedCollection.index(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 32))(a1, *(void *)(a2 + 16));
}

uint64_t ReversedCollection.index(before:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(a2 + 24) + 8) + 184))(a1, *(void *)(a2 + 16));
}

uint64_t ReversedCollection.index(_:offsetBy:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  BOOL v3 = __OFSUB__(0, a2);
  uint64_t v4 = -a2;
  if (!v3) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 48))(result, v4, *(void *)(a3 + 16));
  }
  __break(1u);
  return result;
}

uint64_t ReversedCollection.index(_:offsetBy:limitedBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v28 = a5;
  uint64_t v9 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(a4 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(v8 + 8), v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v27 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t result = MEMORY[0x1F4188790](v15);
  unsigned int v20 = (char *)&v27 - v19;
  if (__OFSUB__(0, a2))
  {
    __break(1u);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))(a1, -a2, a3, v9, v8);
    (*(void (**)(char *, char *, Class *))(v14 + 32))(v17, v20, v13);
    uint64_t v21 = *((void *)AssociatedTypeWitness - 1);
    if ((*(unsigned int (**)(char *, uint64_t, const char *))(v21 + 48))(v17, 1, AssociatedTypeWitness) == 1)
    {
      uint64_t v23 = type metadata accessor for ReversedCollection.Index(0, v9, v8, v22);
      return (*((uint64_t (**)(uint64_t, uint64_t, uint64_t, Class *))*(v23 - 1) + 7))(v28, 1, 1, v23);
    }
    else
    {
      uint64_t v24 = v28;
      (*(void (**)(uint64_t, char *, const char *))(v21 + 32))(v28, v17, AssociatedTypeWitness);
      uint64_t v26 = type metadata accessor for ReversedCollection.Index(0, v9, v8, v25);
      return (*((uint64_t (**)(uint64_t, void, uint64_t, Class *))*(v26 - 1) + 7))(v24, 0, 1, v26);
    }
  }
  return result;
}

uint64_t ReversedCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 64))(a2, a1, *(void *)(a3 + 16));
}

uint64_t ReversedCollection.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(v5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = &v17[-v10];
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 32))(a1, v6, v5);
  uint64_t v12 = (void (*)(unsigned char *, void))(*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t, uint64_t))(v7 + 80))(v17, v11, v6, v7);
  uint64_t v14 = v13;
  uint64_t v15 = swift_getAssociatedTypeWitness(0, *(int ***)(v7 + 8), v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v15 - 1) + 16))(a3, v14, v15);
  v12(v17, 0);
  return (*(uint64_t (**)(unsigned char *, const char *))(v9 + 8))(v11, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>(a1, a2, a3, (void (*)(uint64_t, uint64_t))ReversedCollection.index(before:));
}

uint64_t (*protocol witness for Collection.subscript.read in conformance ReversedCollection<A>(void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = ReversedCollection.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*ReversedCollection.subscript.read(void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v5 = malloc(0x40uLL);
  *a1 = v5;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(a3 + 24);
  uint64_t v8 = *(void *)(v7 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  void v5[4] = v10;
  uint64_t v11 = swift_getAssociatedTypeWitness(0, *(int ***)(v8 + 8), v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v5[5] = v11;
  uint64_t v12 = *((void *)v11 - 1);
  uint64_t v13 = v12;
  v5[6] = v12;
  uint64_t v14 = malloc(*(void *)(v12 + 64));
  v5[7] = v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a2, v6, v7);
  uint64_t v15 = (void (*)(void *, void))(*(uint64_t (**)(void *, void *, uint64_t, uint64_t))(v8 + 80))(v5, v10, v6, v8);
  (*(void (**)(void *))(v13 + 16))(v14);
  v15(v5, 0);
  (*(void (**)(void *, const char *))(v9 + 8))(v10, AssociatedTypeWitness);
  return LazyMapSequence<>.subscript.read;
}

void LazyMapSequence<>.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 56);
  BOOL v3 = *(void **)(*(void *)a1 + 32);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 48) + 8))(v2, *(void *)(*(void *)a1 + 40));
  free(v2);
  free(v3);

  free(v1);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance ReversedCollection<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v4 = type metadata accessor for ReversedCollection.Index(255, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  uint64_t v7 = type metadata accessor for Optional(0, (uint64_t)v4, v5, v6);
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, Class *))*((void *)*(v7 - 1) + 7);

  return v8(a3, 1, 1, v7);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>(a1, a2, a3, (void (*)(uint64_t, uint64_t))ReversedCollection.index(after:));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t))
{
  uint64_t v7 = type metadata accessor for ReversedCollection.Index(0, *(void *)(a2 + 16), *(void *)(a2 + 24), (uint64_t)a4);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v12 - v9;
  a4(a1, a2);
  (*(void (**)(uint64_t, Class *))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v8 + 32))(a1, v10, v7);
}

uint64_t ReversedCollection.reversed()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 32))(a2, v2);
}

uint64_t BidirectionalCollection.reversed()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32))(a2, v2, a1);
}

BOOL _stdlib_atomicCompareExchangeStrongPtr(object:expected:desired:)(atomic_ullong *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong(a1, (unint64_t *)&v4, a3);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

BOOL _stdlib_atomicCompareExchangeStrongPtr<A>(object:expected:desired:)(atomic_ullong *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong(a1, (unint64_t *)&v4, a3);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  BOOL result;

  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong(a1, (unint64_t *)&v4, a3);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

BOOL static Int64.>= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 >= a2;
}

Swift::Int String.UTF16View.count.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000) != 0) {
    return String.UTF16View._foreignCount()();
  }
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v2 = a1;
  }
  return String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v2 << 16) | 7));
}

void *__SwiftNativeNSArray.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t __SwiftNativeNSArray.init()()
{
  return v0;
}

uint64_t __SwiftNativeNSArray.deinit()
{
  return v0;
}

void *_SwiftNativeNSMutableArray.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t _SwiftNativeNSMutableArray.init()()
{
  return v0;
}

uint64_t _SwiftNativeNSMutableArray.deinit()
{
  return v0;
}

void *__SwiftNativeNSSet.__allocating_init(coder:)(void *a1)
{
  swift_unknownObjectRelease(a1);

  return swift_allocObject(v1, 0x10uLL, 7uLL);
}

uint64_t __SwiftNativeNSSet.init(coder:)(void *a1)
{
  swift_unknownObjectRelease(a1);
  return v1;
}

uint64_t __SwiftNativeNSSet.deinit()
{
  return v0;
}

uint64_t static UInt64.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t DropFirstSequence.init(_:dropping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return DropFirstSequence.init(_:dropping:)(a1, a2, a3, a4, "Can't drop a negative number of elements from a sequence", 56, 0x1E3uLL, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for DropFirstSequence, a5);
}

uint64_t DropFirstSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  char v30 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v10 = (uint64_t)*(v30 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v30);
  uint64_t v13 = (char *)&v27 - v12;
  MEMORY[0x1F4188790](v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))((char *)&v27 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0), v2, v6);
  uint64_t v16 = *(void (**)(uint64_t, uint64_t))(v5 + 32);
  uint64_t v31 = a2;
  v16(v6, v5);
  uint64_t v17 = *(int *)(a1 + 36);
  uint64_t v32 = v2;
  uint64_t v28 = a1;
  uint64_t v29 = v17;
  if (*(uint64_t *)(v2 + v17) >= 1)
  {
    uint64_t v18 = v10;
    uint64_t v19 = swift_getAssociatedTypeWitness(255, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v21 = 0;
    uint64_t v22 = *(void (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v23 = (void (**)(char *, Class *))(v18 + 8);
    do
    {
      uint64_t v24 = swift_checkMetadataState(0, (uint64_t)v19);
      v22(v24, AssociatedConformanceWitness);
      int v25 = (*(uint64_t (**)(char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 48))(v13, 1, AssociatedTypeWitness);
      (*v23)(v13, v30);
      if (v25 == 1) {
        break;
      }
      ++v21;
    }
    while (v21 < *(void *)(v32 + v29));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)(v28 - 8) + 8))(v32);
}

uint64_t DropFirstSequence.dropFirst(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v4, v8);
  uint64_t v12 = *(void *)(v4 + *(int *)(a2 + 36));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(v4, a2);
  uint64_t v13 = v12 + a1;
  if (__OFADD__(v12, a1))
  {
    __break(1u);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't drop a negative number of elements from a sequence", 56, 2, "Swift/Sequence.swift", 20, 2, 0x1E3uLL, 0);
  }
  if (v13 < 0) {
    goto LABEL_5;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 32))(a3, v11, v8);
  *(void *)(a3 + *(int *)(a2 + 36)) = v13;
  return result;
}

uint64_t (*PrefixSequence._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t PrefixSequence._maxLength.getter(uint64_t a1)
{
  return *(void *)(v1 + *(int *)(a1 + 36));
}

uint64_t PrefixSequence.init(_:maxLength:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return DropFirstSequence.init(_:dropping:)(a1, a2, a3, a4, "Can't take a prefix of negative length", 38, 0x211uLL, (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for PrefixSequence, a5);
}

uint64_t DropFirstSequence.init(_:dropping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t (*a8)(void, uint64_t, uint64_t)@<X7>, uint64_t a9@<X8>)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a5, a6, 2, "Swift/Sequence.swift", 20, 2, a7, 0);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 32))(a9, a1);
  uint64_t result = a8(0, a3, a4);
  *(void *)(a9 + *(int *)(result + 36)) = a2;
  return result;
}

uint64_t PrefixSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t PrefixSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*PrefixSequence.Iterator._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t PrefixSequence.Iterator._remaining.setter(uint64_t result, uint64_t a2)
{
  *(void *)(v2 + *(int *)(a2 + 36)) = result;
  return result;
}

uint64_t (*PrefixSequence.Iterator._remaining.modify())()
{
  return EnumeratedSequence._base.modify;
}

Class *PrefixSequence.Iterator.init(_:maxLength:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a5, a1, AssociatedTypeWitness);
  uint64_t result = type metadata accessor for PrefixSequence.Iterator(0, a3, (uint64_t)a4, v11);
  *(void *)(a5 + *((int *)result + 9)) = a2;
  return result;
}

uint64_t PrefixSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(int *)(a1 + 36);
  uint64_t v5 = *(void *)(v2 + v4);
  if (v5)
  {
    *(void *)(v2 + v4) = v5 - 1;
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = *(int ***)(a1 + 24);
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v14 = *(uint64_t (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v10 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    return v14(v10, AssociatedConformanceWitness);
  }
  else
  {
    uint64_t v12 = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v12 - 1) + 56);
    return v13(a2, 1, 1, v12);
  }
}

Class *PrefixSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v19 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v8 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, v3, v6);
  (*(void (**)(uint64_t, uint64_t))(v11 + 32))(v6, v11);
  uint64_t v16 = *(void *)(v3 + *(int *)(a1 + 36));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8))(v3, a1);
  (*(void (**)(uint64_t, char *, const char *))(v13 + 32))(a2, v15, AssociatedTypeWitness);
  uint64_t result = type metadata accessor for PrefixSequence.Iterator(0, v6, v11, v17);
  *(void *)(a2 + *((int *)result + 9)) = v16;
  return result;
}

uint64_t PrefixSequence.prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (*(void *)(v9 + *(int *)(v8 + 36)) >= v7) {
    uint64_t v12 = v7;
  }
  else {
    uint64_t v12 = *(void *)(v9 + *(int *)(v8 + 36));
  }
  uint64_t v13 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 32);
  v13(v11, v9, v5);
  if (v12 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't take a prefix of negative length", 38, 2, "Swift/Sequence.swift", 20, 2, 0x211uLL, 0);
  }
  uint64_t result = ((uint64_t (*)(uint64_t, char *, uint64_t))v13)(a3, v11, v5);
  *(void *)(a3 + *(int *)(a2 + 36)) = v12;
  return result;
}

uint64_t DropWhileSequence._iterator.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t DropWhileSequence._iterator.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*DropWhileSequence._iterator.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*DropWhileSequence._nextElement.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DropWhileSequence.init(iterator:predicate:)@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v48 = a2;
  uint64_t v49 = a3;
  uint64_t v47 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v51 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v35 - v11;
  uint64_t v50 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t v36 = (uint64_t)*(v50 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v50);
  uint64_t v17 = (char *)&v35 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v35 - v18;
  uint64_t v46 = a4;
  uint64_t v35 = type metadata accessor for DropWhileSequence(0, a4, (uint64_t)a5, v20);
  uint64_t v21 = a6 + *((int *)v35 + 9);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(v51 + 56))(v21, 1, 1, AssociatedTypeWitness);
  uint64_t v22 = swift_getAssociatedTypeWitness(0, a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v22 - 1) + 32))(a6, v47, v22);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a5, v46, (uint64_t)v22, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = *(void (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v25 = a6;
  uint64_t v26 = v19;
  uint64_t v46 = (uint64_t)v22;
  uint64_t v47 = v25;
  uint64_t v44 = AssociatedConformanceWitness + 16;
  uint64_t v45 = AssociatedConformanceWitness;
  uint64_t v43 = v24;
  ((void (*)(const char *))v24)(v22);
  uint64_t v27 = v36;
  uint64_t v28 = v50;
  uint64_t v41 = *(void (**)(uint64_t, char *, Class *))(v36 + 40);
  uint64_t v42 = v36 + 40;
  v41(v21, v19, v50);
  uint64_t v29 = v51;
  uint64_t v39 = *(void (**)(char *, uint64_t, Class *))(v27 + 16);
  uint64_t v40 = v27 + 16;
  v39(v17, v21, v28);
  uint64_t v38 = *(unsigned int (**)(char *, uint64_t, const char *))(v29 + 48);
  if (v38(v17, 1, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, Class *))(v36 + 8))(v17, v50);
  }
  char v37 = *(void (**)(char *, char *, const char *))(v29 + 32);
  uint64_t v51 = v29 + 32;
  char v30 = (uint64_t (**)(char *, const char *))(v29 + 8);
  while (1)
  {
    v37(v12, v17, AssociatedTypeWitness);
    char v31 = v48(v12);
    if (v6) {
      break;
    }
    char v32 = v31;
    uint64_t result = (*v30)(v12, AssociatedTypeWitness);
    if ((v32 & 1) == 0) {
      return result;
    }
    v43(v46, v45);
    uint64_t v34 = v50;
    v41(v21, v26, v50);
    v39(v17, v21, v34);
    if (v38(v17, 1, AssociatedTypeWitness) == 1) {
      return (*(uint64_t (**)(char *, Class *))(v36 + 8))(v17, v50);
    }
  }
  (*v30)(v12, AssociatedTypeWitness);
  return (*((uint64_t (**)(uint64_t, Class *))*(v35 - 1) + 1))(v47, v35);
}

uint64_t DropWhileSequence.init(_:predicate:)@<X0>(uint64_t (*a1)(char *)@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  MEMORY[0x1F4188790](AssociatedTypeWitness - 8);
  uint64_t v10 = (char *)&v25 - v9;
  uint64_t v12 = type metadata accessor for DropWhileSequence(0, a3, a4, v11);
  uint64_t v13 = (uint64_t)*(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v25 - v15;
  uint64_t v17 = *(int *)(v14 + 36);
  uint64_t v26 = a5;
  uint64_t v18 = a5 + v17;
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)v19 - 1) + 56))(v18, 1, 1, v19);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t v20 = v29;
  DropWhileSequence.init(iterator:predicate:)((uint64_t)v10, v27, v28, a3, (int **)a4, (uint64_t)v16);
  uint64_t v23 = type metadata accessor for Optional(0, (uint64_t)v19, v21, v22);
  if (v20) {
    return (*((uint64_t (**)(uint64_t, Class *))*(v23 - 1) + 1))(v18, v23);
  }
  (*((void (**)(uint64_t, Class *))*(v23 - 1) + 1))(v18, v23);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v13 + 32))(v26, v16, v12);
}

uint64_t DropWhileSequence.Iterator._iterator.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, a2);
}

uint64_t DropWhileSequence.Iterator._iterator.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t (*DropWhileSequence.Iterator._iterator.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DropWhileSequence._nextElement.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v6, v7);
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v8 - 1) + 2);

  return v9(a2, v4, v8);
}

uint64_t DropWhileSequence._nextElement.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 36);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v6, v7);
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v8 - 1) + 5);

  return v9(v4, a1, v8);
}

uint64_t (*DropWhileSequence.Iterator._nextElement.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DropWhileSequence.Iterator.init(_:nextElement:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = a5 + *((int *)type metadata accessor for DropWhileSequence.Iterator(0, a3, (uint64_t)a4, (uint64_t)a4) + 9);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56))(v10, 1, 1, AssociatedTypeWitness);
  uint64_t v12 = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)v12 - 1) + 32))(a5, a1, v12);
  uint64_t v15 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t v16 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v15 - 1) + 5);

  return v16(v10, a2, v15);
}

uint64_t DropWhileSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v28 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t v10 = (uint64_t)*(v9 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v25 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v25 - v14;
  uint64_t v16 = *(int *)(a1 + 36);
  uint64_t v27 = v2;
  uint64_t v17 = v2 + v16;
  (*(void (**)(char *, uint64_t, Class *))(v10 + 16))((char *)&v25 - v14, v17, v9);
  uint64_t v18 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v18 + 48))(v15, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, Class *))(v10 + 8))(v15, v9);
    uint64_t v19 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, char *, const char *))(v18 + 32))(v28, v15, AssociatedTypeWitness);
    uint64_t v26 = v17;
    uint64_t v20 = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)v20, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v22 = *(void (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v23 = swift_checkMetadataState(0, (uint64_t)v20);
    v22(v23, AssociatedConformanceWitness);
    (*(void (**)(uint64_t, char *, Class *))(v10 + 40))(v26, v13, v9);
    uint64_t v19 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(v18 + 56))(v28, v19, 1, AssociatedTypeWitness);
}

uint64_t DropWhileSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(int ***)(a1 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v23 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t v9 = (uint64_t)*(v23 - 1);
  MEMORY[0x1F4188790](v23);
  uint64_t v11 = (char *)&v23 - v10;
  uint64_t v12 = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v13 = *((void *)v12 - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v23 - v14;
  (*(void (**)(char *, uint64_t, const char *))(v13 + 16))((char *)&v23 - v14, v2, v12);
  uint64_t v16 = v2 + *(int *)(a1 + 36);
  uint64_t v17 = v23;
  (*(void (**)(char *, uint64_t, Class *))(v9 + 16))(v11, v16, v23);
  uint64_t v19 = type metadata accessor for DropWhileSequence.Iterator(0, v5, (uint64_t)v4, v18);
  uint64_t v20 = v24;
  uint64_t v21 = v24 + *((int *)v19 + 9);
  (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56))(v21, 1, 1, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, const char *))(v13 + 32))(v20, v15, v12);
  return (*(uint64_t (**)(uint64_t, char *, Class *))(v9 + 40))(v21, v11, v17);
}

uint64_t DropWhileSequence.drop(while:)@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v35 = a1;
  uint64_t v36 = a2;
  uint64_t v37 = a4;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v34 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v33 = (char *)&v30 - v7;
  uint64_t v8 = swift_getAssociatedTypeWitness(255, v6, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for Optional(0, (uint64_t)v8, v9, v10);
  uint64_t v12 = (uint64_t)*(v11 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v30 - v14;
  uint64_t v16 = *((void *)v8 - 1);
  MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v30 - v17;
  uint64_t v38 = a3;
  (*(void (**)(char *, uint64_t, Class *))(v12 + 16))(v15, v40 + *(int *)(a3 + 36), v11);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v16 + 48))(v15, 1, v8) == 1)
  {
    (*(void (**)(char *, Class *))(v12 + 8))(v15, v11);
    uint64_t v19 = v38;
    uint64_t v20 = v40;
    uint64_t v21 = v37;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v19 - 8) + 32))(v21, v20, v19);
  }
  uint64_t v23 = v34;
  uint64_t v30 = v5;
  char v31 = v6;
  (*(void (**)(char *, char *, const char *))(v16 + 32))(v18, v15, v8);
  uint64_t v25 = v35;
  uint64_t v24 = v36;
  uint64_t v26 = v39;
  char v27 = v35(v18);
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)(v38 - 8) + 8))(v40);
    return (*(uint64_t (**)(char *, const char *))(v16 + 8))(v18, v8);
  }
  else
  {
    char v28 = v27;
    (*(void (**)(char *, const char *))(v16 + 8))(v18, v8);
    uint64_t v20 = v40;
    uint64_t v21 = v37;
    uint64_t v19 = v38;
    if ((v28 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v19 - 8) + 32))(v21, v20, v19);
    }
    uint64_t v29 = (uint64_t)v33;
    (*(void (**)(char *, uint64_t, const char *))(v23 + 16))(v33, v40, AssociatedTypeWitness);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v19 - 8) + 8))(v20, v19);
    return DropWhileSequence.init(iterator:predicate:)(v29, v25, v24, v30, v31, v21);
  }
}

uint64_t protocol witness for Sequence.makeIterator() in conformance DropWhileSequence<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  DropWhileSequence.makeIterator()(a1, a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8);

  return v4(v2, a1);
}

uint64_t Sequence.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Collection.map<A>(_:)(a1, a2, a3, a4, a5, (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error), (uint64_t (*)(uint64_t, void *))_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSTRzsAE_pRsd_0_r_0_lIetMgnozo_Tpq5Tm);
}

uint64_t Collection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t (*a7)(uint64_t, void *))
{
  uint64_t v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  void v8[5] = a1;
  v8[6] = a2;
  return a7(a6, v8);
}

uint64_t Sequence<>.split(separator:maxSplits:omittingEmptySubsequences:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(a1, a2, a3, a4, a5, a6, (uint64_t)partial apply for closure #1 in Sequence<>.contains(_:), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, uint64_t))Sequence.split(maxSplits:omittingEmptySubsequences:whereSeparator:));
}

uint64_t Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, uint64_t))
{
  uint64_t v23 = a8;
  uint64_t v10 = v8;
  uint64_t v17 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))((char *)&v22 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0), v10, v19);
  uint64_t v25 = a4;
  uint64_t v26 = a5;
  uint64_t v27 = a6;
  uint64_t v28 = a1;
  uint64_t v20 = v23(a2, a3, a7, v24, a4, a5);
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(v10, a4);
  return v20;
}

void (*Sequence.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(uint64_t a1, char a2, char *a3, void (*a4)(char *, const char *), uint64_t a5, uint64_t a6))(uint64_t, const char *)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Must take zero or more splits", 29, 2, "Swift/Sequence.swift", 20, 2, 0x3CBuLL, 0);
  }
  (*(void (**)(uint64_t, uint64_t))(a6 + 56))(a5, a6);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a6, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v15 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for [A], v15, v16);
  return Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(a1, a2 & 1, a3, a4, (uint64_t)v15, WitnessTable);
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(Swift::String::Index *a1, uint64_t a2, uint64_t a3, Swift::String::Index position, Swift::UInt64 a5, unint64_t a6, unint64_t a7)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v9 = 0;
      Swift::UInt64 v10 = a5 >> 14;
      uint64_t v11 = (a6 >> 59) & 1;
      if ((a7 & 0x1000000000000000) == 0) {
        LOBYTE(v1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 1;
      }
      uint64_t v12 = 4 << v11;
      Swift::UInt64 v13 = position._rawBits >> 14;
      uint64_t v14 = a7 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v15 = (a7 & 0xFFFFFFFFFFFFFFFLL) + 32;
      unint64_t v16 = a6 & 0xFFFFFFFFFFFFLL;
      if ((a7 & 0x2000000000000000) != 0) {
        unint64_t v16 = HIBYTE(a7) & 0xF;
      }
      Swift::UInt64 rawBits = position._rawBits;
      while (1)
      {
        Swift::UInt64 v18 = rawBits >> 14;
        if (rawBits >> 14 == v10) {
          goto LABEL_31;
        }
        Swift::UInt64 v19 = rawBits & 0xC;
        Swift::UInt64 v20 = rawBits;
        if (v19 == v12)
        {
          uint64_t v54 = a2;
          uint64_t v58 = a3;
          Swift::UInt64 v63 = a5;
          uint64_t v68 = v15;
          Swift::UInt64 v24 = v10;
          unint64_t v25 = a6;
          Swift::UInt64 v73 = v13;
          uint64_t v78 = v9;
          Swift::UInt64 v26 = position._rawBits;
          uint64_t v27 = v14;
          unint64_t v28 = v16;
          Swift::UInt64 v20 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          unint64_t v16 = v28;
          uint64_t v15 = v68;
          Swift::UInt64 v13 = v73;
          uint64_t v14 = v27;
          uint64_t v9 = v78;
          position._Swift::UInt64 rawBits = v26;
          a6 = v25;
          a2 = v54;
          a3 = v58;
          Swift::UInt64 v10 = v24;
          a5 = v63;
          Swift::UInt64 v18 = v20 >> 14;
          if (v20 >> 14 < v73) {
LABEL_32:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/Substring.swift", 21, 2, 0x29BuLL, 0);
        }
        else if (v18 < v13)
        {
          goto LABEL_32;
        }
        if (v18 >= v10) {
          goto LABEL_32;
        }
        if ((a7 & 0x1000000000000000) != 0)
        {
          uint64_t v55 = a2;
          uint64_t v59 = a3;
          Swift::UInt64 v64 = a5;
          unint64_t v69 = v16;
          Swift::UInt64 v29 = v10;
          unint64_t v30 = a6;
          Swift::UInt64 v31 = position._rawBits;
          uint64_t v74 = v14;
          uint64_t v79 = v9;
          uint64_t v32 = v15;
          Swift::UInt8 v23 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)v20);
          unint64_t v16 = v69;
          uint64_t v14 = v74;
          uint64_t v15 = v32;
          uint64_t v9 = v79;
          position._Swift::UInt64 rawBits = v31;
          a6 = v30;
          a2 = v55;
          a3 = v59;
          Swift::UInt64 v10 = v29;
          a5 = v64;
          if (v19 != v12) {
            goto LABEL_20;
          }
        }
        else
        {
          Swift::UInt64 v21 = v20 >> 16;
          if ((a7 & 0x2000000000000000) != 0)
          {
            v82[0] = a6;
            v82[1] = v14;
            Swift::UInt8 v23 = *((unsigned char *)v82 + v21);
            if (v19 != v12) {
              goto LABEL_20;
            }
          }
          else
          {
            uint64_t v22 = (unsigned char *)v15;
            if ((a6 & 0x1000000000000000) == 0)
            {
              unint64_t v53 = a6;
              uint64_t v57 = a2;
              Swift::UInt64 v62 = position._rawBits;
              Swift::UInt64 v67 = a5;
              uint64_t v77 = v14;
              Swift::UInt64 v81 = v10;
              uint64_t v49 = a3;
              uint64_t v50 = v9;
              uint64_t v51 = v15;
              unint64_t v72 = v16;
              uint64_t v22 = _StringObject.sharedUTF8.getter(a6, a7);
              unint64_t v16 = v72;
              uint64_t v14 = v77;
              uint64_t v15 = v51;
              uint64_t v9 = v50;
              a2 = v57;
              position._Swift::UInt64 rawBits = v62;
              a6 = v53;
              a3 = v49;
              Swift::UInt64 v10 = v81;
              a5 = v67;
            }
            Swift::UInt8 v23 = v22[v21];
            if (v19 != v12)
            {
LABEL_20:
              if ((a7 & 0x1000000000000000) != 0) {
                goto LABEL_26;
              }
              goto LABEL_21;
            }
          }
        }
        Swift::UInt8 v65 = v23;
        v33._Swift::UInt64 rawBits = rawBits;
        uint64_t v56 = a2;
        uint64_t v60 = a3;
        Swift::UInt64 v34 = a5;
        Swift::UInt64 v35 = v10;
        unint64_t v36 = a6;
        Swift::UInt64 v37 = position._rawBits;
        uint64_t v38 = v9;
        unint64_t v70 = v16;
        uint64_t v75 = v14;
        uint64_t v39 = v15;
        v40._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v33)._rawBits;
        unint64_t v16 = v70;
        uint64_t v14 = v75;
        uint64_t v15 = v39;
        uint64_t v9 = v38;
        position._Swift::UInt64 rawBits = v37;
        a6 = v36;
        a2 = v56;
        a3 = v60;
        Swift::UInt64 v10 = v35;
        a5 = v34;
        Swift::UInt64 rawBits = v40._rawBits;
        Swift::UInt8 v23 = v65;
        if ((a7 & 0x1000000000000000) != 0)
        {
LABEL_26:
          Swift::UInt8 v66 = v23;
          uint64_t v71 = v15;
          uint64_t v76 = v14;
          uint64_t v80 = v9;
          Swift::UInt64 v61 = position._rawBits;
          if (v16 <= rawBits >> 16) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0x90uLL, 0);
          }
          uint64_t v41 = a3;
          uint64_t v42 = a2;
          Swift::UInt64 v43 = v10;
          Swift::UInt64 v44 = a5;
          unint64_t v45 = v16;
          v46._Swift::UInt64 rawBits = rawBits;
          unint64_t v47 = a6;
          v48._Swift::UInt64 rawBits = String.UTF8View._foreignIndex(after:)(v46)._rawBits;
          a6 = v47;
          Swift::UInt64 rawBits = v48._rawBits;
          a5 = v44;
          Swift::UInt64 v10 = v43;
          a2 = v42;
          a3 = v41;
          position._Swift::UInt64 rawBits = v61;
          uint64_t v14 = v76;
          uint64_t v9 = v80;
          uint64_t v15 = v71;
          unint64_t v16 = v45;
          Swift::UInt8 v23 = v66;
          goto LABEL_28;
        }
LABEL_21:
        Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000) + 65540;
LABEL_28:
        *(unsigned char *)(a2 + v9++) = v23;
        if (a3 == v9)
        {
          uint64_t v9 = a3;
          goto LABEL_31;
        }
      }
    }
  }
  uint64_t v9 = 0;
  Swift::UInt64 rawBits = position._rawBits;
LABEL_31:
  a1->_Swift::UInt64 rawBits = position._rawBits;
  a1[1]._Swift::UInt64 rawBits = a5;
  a1[2]._Swift::UInt64 rawBits = a6;
  a1[3]._Swift::UInt64 rawBits = a7;
  a1[4]._Swift::UInt64 rawBits = rawBits;
  return v9;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 == 1)
      {
        uint64_t v5 = 1;
      }
      else
      {
        a2[1] = a5;
        uint64_t v5 = 2;
        a3 = 2;
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
    a3 = 0;
  }
  *a1 = a4;
  a1[1] = a5;
  a1[2] = v5;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t result, _WORD *a2, uint64_t a3, unsigned int a4)
{
  if (!a2)
  {
    uint64_t v5 = 0;
LABEL_13:
    *(_DWORD *)uint64_t result = a4;
    *(void *)(result + 8) = v5;
    return v5;
  }
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  if (!a3)
  {
    uint64_t v5 = 0;
    goto LABEL_13;
  }
  LOWORD(v4) = a4;
  if (!HIWORD(a4) || (int v4 = (unsigned __int16)((a4 + 67043328) >> 10) + 55296, (v4 & 0x10000) == 0))
  {
    *a2 = v4;
    uint64_t v5 = 1;
    if (a3 != 1 && a4 >= 0x10000)
    {
      a2[1] = a4 & 0x3FF | 0xDC00;
      uint64_t v5 = 2;
      if (a3 == 2) {
        uint64_t v5 = 2;
      }
    }
    goto LABEL_13;
  }
  __break(1u);
  return result;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, unsigned char *a2, uint64_t a3, unsigned int a4)
{
  if (!a2)
  {
    uint64_t v8 = 0;
    uint64_t v6 = 0;
    goto LABEL_13;
  }
  uint64_t v6 = a3;
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  if (!a3)
  {
    uint64_t v8 = 0;
    goto LABEL_13;
  }
  *a2 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 0);
  if (a4 >= 0x80)
  {
    if (v6 == 1)
    {
      uint64_t v8 = 1;
      goto LABEL_13;
    }
    a2[1] = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 1uLL);
    if (v6 == 2)
    {
      uint64_t v8 = 2;
      goto LABEL_13;
    }
    if (a4 >= 0x800)
    {
      a2[2] = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 2uLL);
      if (v6 == 3)
      {
        uint64_t v8 = 3;
        goto LABEL_13;
      }
      uint64_t v8 = 3;
      if (a4 >= 0x10000)
      {
        a2[3] = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 3uLL);
        uint64_t v8 = v6;
        if (v6 == 4) {
          goto LABEL_13;
        }
        uint64_t v8 = 4;
        if (!HIWORD(a4)) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unicode.Scalar.UTF8View index is out of bounds", 46, 2, "Swift/UnicodeScalar.swift", 25, 2, 0x1E9uLL, 0);
        }
      }
    }
    else
    {
      uint64_t v8 = 2;
    }
    goto LABEL_6;
  }
  uint64_t v8 = 1;
  if (v6 != 1) {
LABEL_6:
  }
    uint64_t v6 = v8;
LABEL_13:
  *(_DWORD *)a1 = a4;
  *(void *)(a1 + 8) = v8;
  return v6;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, void *a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *(_DWORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, void *a2, uint64_t a3, unsigned __int16 a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *(_WORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, void *a2, uint64_t a3, unsigned __int8 a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *(unsigned char *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *(_DWORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, void *a2, uint64_t a3, __int16 a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *(_WORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *(unsigned char *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(int64x2_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v14.i64[0] = a4;
  v14.i64[1] = a4;
  uint64_t v15 = a5;
  uint64_t v16 = a6;
  uint64_t v17 = a7;
  if (a2)
  {
    uint64_t v8 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = specialized Unicode._InternalNFD.Iterator.next()();
        if ((v11 & 0x1000000000000) != 0) {
          break;
        }
        *(_DWORD *)(a2 + 4 * v10++) = v11;
        if (v8 == v10)
        {
          int64x2_t v12 = v14;
          a5 = v15;
          a6 = v16;
          a7 = v17;
          goto LABEL_10;
        }
      }
      int64x2_t v12 = v14;
      a5 = v15;
      a6 = v16;
      a7 = v17;
      a1->i64[0] = (uint64_t)&_swiftEmptyArrayStorage;
      a1->i8[8] = 0;
      uint64_t v8 = v10;
    }
    else
    {
      int64x2_t v12 = vdupq_n_s64(a4);
LABEL_10:
      a1->i64[0] = (uint64_t)&_swiftEmptyArrayStorage;
      a1->i8[8] = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
    a1->i64[0] = (uint64_t)&_swiftEmptyArrayStorage;
    a1->i8[8] = 0;
    int64x2_t v12 = vdupq_n_s64(a4);
  }
  a1[1] = v12;
  a1[2].i64[0] = a5;
  a1[2].i64[1] = a6;
  a1[3].i64[0] = a7;
  return v8;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, _DWORD *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v54 = &_swiftEmptyArrayStorage;
  char v55 = 0;
  int v56 = 0;
  char v57 = 1;
  v58.i64[0] = a4;
  v58.i64[1] = a4;
  uint64_t v59 = a5;
  uint64_t v60 = a6;
  uint64_t v61 = a7;
  if (!a2)
  {
    a3 = 0;
    *(void *)a1 = &_swiftEmptyArrayStorage;
    *(unsigned char *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(unsigned char *)(a1 + 16) = 1;
    *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
    *(unsigned char *)(a1 + 32) = 0;
    int64x2_t v15 = vdupq_n_s64(a4);
    goto LABEL_8;
  }
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  char v8 = 1;
  if (!a3)
  {
    int v16 = 0;
    char v17 = 0;
    int64x2_t v15 = vdupq_n_s64(a4);
    Swift::UInt64 v18 = &_swiftEmptyArrayStorage;
    goto LABEL_7;
  }
  uint64_t v9 = a2;
  BOOL v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  Swift::UInt64 v13 = &_swiftEmptyArrayStorage;
  char v14 = 1;
  uint64_t v50 = a3;
  while (2)
  {
    unint64_t v22 = (unint64_t)v13[2];
    BOOL v51 = v22 != 0;
    if (v22)
    {
      if (!v10)
      {
        unint64_t v23 = v22 - 1;
        if (v22 <= 1)
        {
          char v55 = 1;
        }
        else
        {
          unsigned int v53 = v11;
          uint64_t v24 = 0;
          uint64_t v25 = 8 * v22 + 24;
          uint64_t v26 = 1;
          do
          {
            unint64_t v27 = (unint64_t)v13[2];
            if (v26 - 1 >= v27 || v23 >= v27)
            {
              unint64_t v46 = 675;
              goto LABEL_81;
            }
            __int16 v47 = WORD2(v13[v24 + 4]);
            int v48 = (int)v13[v24 + 4];
            int v28 = *(_DWORD *)((char *)v13 + v25);
            __int16 v49 = *(_WORD *)((char *)v13 + v25 + 4);
            if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v13)) {
              Swift::UInt64 v13 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v13);
            }
            unint64_t v29 = (unint64_t)v13[2];
            if (v26 - 1 >= v29 || (unint64_t v30 = &v13[v24], *((_DWORD *)v30 + 8) = v28, *((_WORD *)v30 + 18) = v49, v23 >= v29))
            {
              unint64_t v46 = 688;
LABEL_81:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, v46, 0);
            }
            Swift::UInt64 v31 = (char *)v13 + v25;
            *(_DWORD *)Swift::UInt64 v31 = v48;
            *((_WORD *)v31 + 2) = v47;
            --v23;
            v25 -= 8;
            ++v24;
          }
          while (v26++ < (uint64_t)v23);
          char v55 = 1;
          unint64_t v11 = v53;
          if (!v13[2]) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't remove last element from an empty collection", 50, 2, "Swift/RangeReplaceableCollection.swift", 38, 2, 0x363uLL, 0);
          }
        }
      }
      if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v13))
      {
        Swift::UInt64 v44 = v13[2];
        if (v44)
        {
LABEL_73:
          unint64_t v45 = (__objc2_class *)((char *)v44 - 1);
          int v21 = (int)v13[(void)v44 - 1 + 4];
          v13[2] = v45;
          uint64_t v54 = v13;
          unint64_t v20 = v11;
          goto LABEL_12;
        }
      }
      else
      {
        Swift::UInt64 v13 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v13);
        Swift::UInt64 v44 = v13[2];
        if (v44) {
          goto LABEL_73;
        }
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't removeLast from an empty Array", 36, 2, "Swift/Array.swift", 17, 2, 0x51CuLL, 0);
    }
    unsigned int v52 = v11;
    char v55 = 0;
    unint64_t v33 = specialized Unicode._InternalNFD.Iterator.next()();
    if ((v33 & 0x1000000000000) != 0)
    {
      int v56 = 0;
      char v57 = 1;
      if ((v14 & 1) == 0)
      {
        unint64_t v20 = 0;
        int v21 = v11;
        char v14 = 1;
        goto LABEL_12;
      }
      int64x2_t v15 = v58;
      a5 = v59;
      a6 = v60;
      a7 = v61;
      *(void *)a1 = v54;
      *(unsigned char *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(unsigned char *)(a1 + 16) = 1;
      *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
      a3 = v12;
      *(unsigned char *)(a1 + 32) = 0;
      goto LABEL_8;
    }
    unint64_t v20 = v33;
    while (1)
    {
      Swift::UInt64 v34 = (char *)v13 + 36;
      if (v14) {
        break;
      }
      __int16 v37 = WORD2(v20);
      uint64_t v38 = v13[2];
      if (!v38)
      {
        if ((v20 & 0x600000000) != 0 && v20 >= 0x300)
        {
          unint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v52, v20);
          if ((v35 & 0x100000000) == 0) {
            goto LABEL_30;
          }
          LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
          if (v35 != -1) {
            goto LABEL_30;
          }
        }
LABEL_54:
        if ((v20 & 0x7F800000000) == 0) {
          goto LABEL_74;
        }
LABEL_55:
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v13))
        {
          int64_t v43 = (int64_t)&v13[2]->isa + 1;
          goto LABEL_64;
        }
        goto LABEL_56;
      }
      unsigned int v39 = (v20 >> 35);
      if (v39 > (*(unsigned __int16 *)&v34[8 * (void)v38 - 8] >> 3))
      {
        if ((v20 & 0x600000000) != 0 && v20 >= 0x300)
        {
          unint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v52, v20);
          if ((v35 & 0x100000000) == 0) {
            goto LABEL_30;
          }
          LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
          if (v35 != -1) {
            goto LABEL_30;
          }
        }
        goto LABEL_55;
      }
LABEL_60:
      if (!v39)
      {
LABEL_74:
        char v14 = 0;
        int v56 = v20;
        char v57 = 0;
        goto LABEL_11;
      }
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v13))
      {
        int64_t v43 = (int64_t)&v38->isa + 1;
LABEL_64:
        Swift::UInt64 v13 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v43, 1, (uint64_t)v13);
      }
LABEL_56:
      unint64_t v41 = (unint64_t)v13[2];
      unint64_t v40 = (unint64_t)v13[3];
      if (v41 >= v40 >> 1) {
        Swift::UInt64 v13 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v40 > 1), v41 + 1, 1, (uint64_t)v13);
      }
      v13[2] = (__objc2_class *)(v41 + 1);
      uint64_t v42 = &v13[v41];
      *((_DWORD *)v42 + 8) = v20;
      *((_WORD *)v42 + 18) = v37;
      uint64_t v54 = v13;
      unint64_t v20 = specialized Unicode._InternalNFD.Iterator.next()();
      char v14 = 0;
      if ((v20 & 0x1000000000000) != 0) {
        goto LABEL_10;
      }
    }
    if ((v20 & 0x7F800000000) == 0)
    {
      LODWORD(v35) = v20;
LABEL_30:
      int v56 = v35;
      char v57 = 0;
      unint64_t v36 = specialized Unicode._InternalNFD.Iterator.next()();
      if ((v36 & 0x1000000000000) == 0)
      {
        unint64_t v20 = v36;
        do
        {
          unsigned int v52 = v35;
          __int16 v37 = WORD2(v20);
          uint64_t v38 = v13[2];
          if (v38)
          {
            unsigned int v39 = (v20 >> 35);
            if (v39 <= (*(unsigned __int16 *)&v34[8 * (void)v38 - 8] >> 3)) {
              goto LABEL_60;
            }
            if ((v20 & 0x600000000) == 0) {
              goto LABEL_55;
            }
            if (v20 < 0x300) {
              goto LABEL_55;
            }
            unint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v35, v20);
            if ((v35 & 0x100000000) != 0)
            {
              LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
              if (v35 == -1) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            if ((v20 & 0x600000000) == 0) {
              goto LABEL_54;
            }
            if (v20 < 0x300) {
              goto LABEL_54;
            }
            unint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v35, v20);
            if ((v35 & 0x100000000) != 0)
            {
              LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
              if (v35 == -1) {
                goto LABEL_54;
              }
            }
          }
          int v56 = v35;
          char v57 = 0;
          unint64_t v20 = specialized Unicode._InternalNFD.Iterator.next()();
        }
        while ((v20 & 0x1000000000000) == 0);
      }
      unsigned int v52 = v35;
LABEL_10:
      unint64_t v20 = 0;
      int v56 = 0;
      char v14 = 1;
      char v57 = 1;
LABEL_11:
      int v21 = v52;
      goto LABEL_12;
    }
    char v14 = 1;
    int v21 = v20;
    unint64_t v20 = v52;
LABEL_12:
    ++v12;
    *v9++ = v21;
    BOOL v10 = v51;
    unint64_t v11 = v20;
    a3 = v50;
    if (v12 != v50) {
      continue;
    }
    break;
  }
  Swift::UInt64 v18 = v54;
  char v17 = v55;
  int v16 = v56;
  char v8 = v57;
  int64x2_t v15 = v58;
  a5 = v59;
  a6 = v60;
  a7 = v61;
LABEL_7:
  *(void *)a1 = v18;
  *(unsigned char *)(a1 + 8) = v17;
  *(_DWORD *)(a1 + 12) = v16;
  *(unsigned char *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a1 + 32) = 0;
LABEL_8:
  *(int64x2_t *)(a1 + 4_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = v15;
  *(void *)(a1 + 56) = a5;
  *(void *)(a1 + 64) = a6;
  *(void *)(a1 + 72) = a7;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, void *a2, uint64_t a3, void *a4)
{
  char v8 = (unint64_t *)type metadata accessor for __CocoaDictionary.Iterator();
  uint64_t v9 = swift_allocObject(v8, 0xE8uLL, 7uLL);
  *((_OWORD *)v9 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  v9[27] = 0;
  BOOL v10 = v9 + 27;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  *((_OWORD *)v9 + 9) = 0u;
  *((_OWORD *)v9 + 1_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = 0u;
  *((_OWORD *)v9 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v9 + 12) = 0u;
  v9[28] = 0;
  v9[26] = a4;
  unint64_t v20 = a1;
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    uint64_t v11 = 0;
    if (a3)
    {
      while (1)
      {
        uint64_t v12 = *v10;
        if (*v10 < 0) {
          break;
        }
        if (v12 == v9[28])
        {
          id v13 = [a4 countByEnumeratingWithState:v9 + 2 objects:v9 + 10 count:16];
          v9[28] = v13;
          if (!v13)
          {
            *BOOL v10 = -1;
            break;
          }
          uint64_t v12 = 0;
          *BOOL v10 = 0;
        }
        uint64_t v14 = v9[3];
        if (!v14)
        {
          unint64_t v19 = 773;
          goto LABEL_22;
        }
        if ((unint64_t)(v12 - 0x1000000000000000) >> 61 != 7)
        {
          __break(1u);
LABEL_18:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
        }
        int64x2_t v15 = (void **)(v14 + 8 * v12);
        if ((v15 & 7) != 0) {
          goto LABEL_18;
        }
        int v16 = *v15;
        *BOOL v10 = v12 + 1;
        swift_unknownObjectRetain(v16);
        id v17 = [a4 objectForKey:v16];
        if (!v17)
        {
          unint64_t v19 = 784;
LABEL_22:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/DictionaryBridging.swift", 30, 2, v19, 0);
        }
        ++v11;
        *a2 = v16;
        a2[1] = v17;
        a2 += 2;
        if (a3 == v11)
        {
          uint64_t v11 = a3;
          break;
        }
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  *unint64_t v20 = v9;
  return v11;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(unsigned int *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v4 = 0;
      while (a4)
      {
        *(unsigned char *)(a2 + v4) = a4 - 1;
        a4 >>= 8;
        if (a3 == ++v4) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      uint64_t v4 = a3;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *a1 = a4;
  return v4;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(unint64_t **a1, unint64_t *a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  if (a5 >= 1)
  {
    unint64_t v5 = *a4;
    if (a2) {
      goto LABEL_3;
    }
LABEL_20:
    uint64_t v6 = 0;
    a3 = 0;
    goto LABEL_25;
  }
  unint64_t v5 = 0;
  if (!a2) {
    goto LABEL_20;
  }
LABEL_3:
  if (a3 < 0) {
    goto LABEL_28;
  }
  uint64_t v6 = 0;
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (v5)
      {
        unint64_t v8 = __clz(__rbit64(v5));
        v5 &= v5 - 1;
        unint64_t v9 = v8 | (v6 << 6);
      }
      else
      {
        uint64_t v10 = v6 + 1;
        if (__OFADD__(v6, 1)) {
          goto LABEL_27;
        }
        if (v10 >= a5)
        {
          unint64_t v5 = 0;
          goto LABEL_24;
        }
        unint64_t v11 = a4[v10];
        if (!v11)
        {
          uint64_t v12 = v6 + 2;
          if (v10 + 1 >= a5)
          {
            unint64_t v5 = 0;
            uint64_t v6 = v10;
LABEL_24:
            a3 = i;
            break;
          }
          unint64_t v11 = a4[v12];
          if (!v11)
          {
            while (1)
            {
              uint64_t v10 = v12 + 1;
              if (__OFADD__(v12, 1)) {
                break;
              }
              if (v10 >= a5)
              {
                unint64_t v5 = 0;
                uint64_t v6 = a5 - 1;
                goto LABEL_24;
              }
              unint64_t v11 = a4[v10];
              ++v12;
              if (v11) {
                goto LABEL_18;
              }
            }
            __break(1u);
LABEL_27:
            __break(1u);
LABEL_28:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
          }
          ++v10;
        }
LABEL_18:
        unint64_t v13 = __clz(__rbit64(v11));
        unint64_t v5 = (v11 - 1) & v11;
        unint64_t v9 = v13 + (v10 << 6);
        uint64_t v6 = v10;
      }
      *a2++ = v9;
    }
  }
LABEL_25:
  *a1 = a4;
  a1[1] = (unint64_t *)a5;
  a1[2] = (unint64_t *)v6;
  a1[3] = (unint64_t *)v5;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v4 = 0;
      while (a4)
      {
        *(void *)(a2 + 8 * v4) = __clz(__rbit64(a4));
        a4 &= a4 - 1;
        if (a3 == ++v4) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      uint64_t v4 = a3;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *a1 = a4;
  return v4;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      char v5 = 0;
      unint64_t v6 = 0;
      while ((HIBYTE(a5) & 0xF) != v6)
      {
        if (v6 >= 8) {
          unint64_t v7 = a5;
        }
        else {
          unint64_t v7 = a4;
        }
        *(unsigned char *)(a2 + v6) = v7 >> (v5 & 0x38);
        v5 += 8;
        if (a3 == ++v6) {
          goto LABEL_13;
        }
      }
      a3 = HIBYTE(a5) & 0xF;
    }
  }
  else
  {
    a3 = 0;
  }
LABEL_13:
  *a1 = a4;
  a1[1] = a5;
  a1[2] = a3;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v8 = (unint64_t *)type metadata accessor for __CocoaSet.Iterator();
  unint64_t v9 = swift_allocObject(v8, 0xE8uLL, 7uLL);
  *((_OWORD *)v9 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  v9[27] = 0;
  uint64_t v10 = v9 + 27;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  *((_OWORD *)v9 + 9) = 0u;
  *((_OWORD *)v9 + 1_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_rawHashValue(_seed:) called on non-canonical AnyHashable box", 61, 2, "Swift/NewtypeWrapper.swift", 26, 2, 0x4FuLL, 0) = 0u;
  *((_OWORD *)v9 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v9 + 12) = 0u;
  v9[28] = 0;
  v9[26] = a4;
  if (!a2) {
    goto LABEL_14;
  }
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  if (a3)
  {
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v12 = *v10;
      if (*v10 < 0) {
        break;
      }
      if (v12 == v9[28])
      {
        id v13 = [a4 countByEnumeratingWithState:v9 + 2 objects:v9 + 10 count:16];
        v9[28] = v13;
        if (!v13)
        {
          *uint64_t v10 = -1;
          break;
        }
        uint64_t v12 = 0;
        *uint64_t v10 = 0;
      }
      uint64_t v14 = v9[3];
      if (!v14) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/SetBridging.swift", 23, 2, 0x254uLL, 0);
      }
      if ((unint64_t)(v12 - 0x1000000000000000) >> 61 != 7)
      {
        __break(1u);
LABEL_18:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
      }
      int64x2_t v15 = (void **)(v14 + 8 * v12);
      if ((v15 & 7) != 0) {
        goto LABEL_18;
      }
      int v16 = *v15;
      *uint64_t v10 = v12 + 1;
      *(void *)(a2 + 8 * v1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v16;
      swift_unknownObjectRetain(v16);
      if (a3 == ++v11)
      {
        uint64_t v11 = a3;
        break;
      }
    }
  }
  else
  {
LABEL_14:
    uint64_t v11 = 0;
  }
  *a1 = v9;
  return v11;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, unint64_t *a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (a5 + 1 < 64) {
    uint64_t v5 = ~(-1 << (a5 + 1));
  }
  else {
    uint64_t v5 = -1;
  }
  unint64_t v6 = *a4 & v5;
  if (!a2)
  {
    int64_t v8 = 0;
    a3 = 0;
    goto LABEL_27;
  }
  if (a3 < 0) {
    goto LABEL_30;
  }
  if (!a3)
  {
    int64_t v8 = 0;
    goto LABEL_27;
  }
  uint64_t v7 = 0;
  int64_t v8 = 0;
  int64_t v9 = (unint64_t)(a5 + 64) >> 6;
  while (v6)
  {
    unint64_t v10 = __clz(__rbit64(v6));
    v6 &= v6 - 1;
    unint64_t v11 = v10 | (v8 << 6);
LABEL_9:
    ++v7;
    *a2++ = v11;
    if (v7 == a3) {
      goto LABEL_27;
    }
  }
  int64_t v12 = v8 + 1;
  if (__OFADD__(v8, 1)) {
    goto LABEL_29;
  }
  if (v12 >= v9)
  {
    unint64_t v6 = 0;
    goto LABEL_26;
  }
  unint64_t v13 = a4[v12];
  if (v13)
  {
LABEL_20:
    unint64_t v15 = __clz(__rbit64(v13));
    unint64_t v6 = (v13 - 1) & v13;
    unint64_t v11 = v15 + (v12 << 6);
    int64_t v8 = v12;
    goto LABEL_9;
  }
  int64_t v14 = v8 + 2;
  if (v12 + 1 < v9)
  {
    unint64_t v13 = a4[v14];
    if (!v13)
    {
      while (1)
      {
        int64_t v12 = v14 + 1;
        if (__OFADD__(v14, 1)) {
          break;
        }
        if (v12 >= v9)
        {
          unint64_t v6 = 0;
          int64_t v8 = v9 - 1;
          goto LABEL_26;
        }
        unint64_t v13 = a4[v12];
        ++v14;
        if (v13) {
          goto LABEL_20;
        }
      }
      __break(1u);
LABEL_29:
      __break(1u);
LABEL_30:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    ++v12;
    goto LABEL_20;
  }
  unint64_t v6 = 0;
  int64_t v8 = v12;
LABEL_26:
  a3 = v7;
LABEL_27:
  *a1 = a4;
  a1[1] = a5;
  a1[2] = v8;
  a1[3] = v6;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(unint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      int64_t v12 = a2;
      unint64_t v19 = a1;
      uint64_t v13 = 0;
      v14._Swift::UInt64 rawBits = a4;
      while ((v14._rawBits ^ a5) >= 0x4000)
      {
        ++v13;
        uint64_t v15 = Substring.subscript.getter(v14._rawBits, a4, a5, a6, a7);
        uint64_t v17 = v16;
        v14._Swift::UInt64 rawBits = Substring.index(after:)(v14)._rawBits;
        *int64_t v12 = v15;
        v12[1] = v17;
        v12 += 2;
        if (a3 == v13)
        {
          uint64_t v13 = a3;
          break;
        }
      }
      a1 = v19;
    }
    else
    {
      v14._Swift::UInt64 rawBits = a4;
      uint64_t v13 = 0;
    }
  }
  else
  {
    uint64_t v13 = 0;
    v14._Swift::UInt64 rawBits = a4;
  }
  *a1 = a4;
  a1[1] = a5;
  a1[2] = a6;
  a1[3] = a7;
  a1[4] = v14._rawBits;
  return v13;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(Swift::UInt64 *a1, uint64_t a2, uint64_t a3, Swift::String::Index a4, Swift::UInt64 a5, unint64_t a6, unint64_t a7)
{
  uint64_t v7 = a6;
  Swift::UInt64 rawBits = a4._rawBits;
  if (a2)
  {
    uint64_t v10 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v11 = a2;
      uint64_t v12 = 0;
      Swift::UInt64 v13 = a5 >> 14;
      uint64_t v14 = (a6 >> 59) & 1;
      if ((a7 & 0x1000000000000000) == 0) {
        LOBYTE(v14) = 1;
      }
      uint64_t v15 = 4 << v14;
      Swift::UInt64 v16 = a4._rawBits >> 14;
      uint64_t v17 = a7 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v18 = (a7 & 0xFFFFFFFFFFFFFFFLL) + 32;
      if ((a7 & 0x2000000000000000) != 0) {
        unint64_t v19 = HIBYTE(a7) & 0xF;
      }
      else {
        unint64_t v19 = a6 & 0xFFFFFFFFFFFFLL;
      }
      v20._Swift::UInt64 rawBits = a4._rawBits;
      while (1)
      {
        Swift::UInt64 v21 = v20._rawBits >> 14;
        if (v20._rawBits >> 14 == v13) {
          goto LABEL_71;
        }
        uint64_t v22 = v20._rawBits & 0xC;
        BOOL v23 = (v20._rawBits & 1) == 0 || v22 == v15;
        int v24 = v23;
        if (v23)
        {
          Swift::UInt64 v25 = v20._rawBits;
          if (v22 == v15)
          {
            unint64_t v123 = v19;
            uint64_t v131 = v18;
            uint64_t v107 = v17;
            Swift::UInt64 v115 = a5;
            Swift::UInt64 v44 = v13;
            uint64_t v93 = v15;
            Swift::UInt64 v99 = v16;
            unint64_t v45 = a7;
            int v88 = v24;
            Swift::UInt64 v25 = _StringGuts._slowEnsureMatchingEncoding(_:)(v20)._rawBits;
            int v24 = v88;
            a7 = v45;
            unint64_t v19 = v123;
            uint64_t v18 = v131;
            Swift::UInt64 v16 = v99;
            uint64_t v17 = v107;
            uint64_t v15 = v93;
            Swift::UInt64 v13 = v44;
            a5 = v115;
            Swift::UInt64 v21 = v25 >> 14;
            if (v25 >> 14 < v99)
            {
LABEL_73:
              unint64_t v84 = 43;
LABEL_74:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index is out of bounds", 32, 2, "Swift/StringIndexValidation.swift", 33, 2, v84, 0);
            }
          }
          else if (v21 < v16)
          {
            goto LABEL_73;
          }
          if (v21 >= v13) {
            goto LABEL_73;
          }
          if ((v25 & 1) == 0)
          {
            unint64_t v121 = v19;
            uint64_t v129 = v18;
            uint64_t v105 = v17;
            Swift::UInt64 v113 = a5;
            Swift::UInt64 v26 = v13;
            uint64_t v91 = v15;
            Swift::UInt64 v97 = v16;
            unint64_t v27 = a7;
            int v87 = v24;
            v28._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v25)._rawBits;
            int v24 = v87;
            a7 = v27;
            unint64_t v19 = v121;
            uint64_t v18 = v129;
            Swift::UInt64 v16 = v97;
            uint64_t v17 = v105;
            uint64_t v15 = v91;
            Swift::UInt64 v13 = v26;
            a5 = v113;
            Swift::UInt64 v25 = v28._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
          }
        }
        else if (v21 < v16 || (Swift::UInt64 v25 = v20._rawBits, v21 >= v13))
        {
          unint64_t v84 = 143;
          goto LABEL_74;
        }
        if ((a7 & 0x1000000000000000) != 0)
        {
          unint64_t v124 = v19;
          uint64_t v132 = v18;
          uint64_t v108 = v17;
          Swift::UInt64 v116 = a5;
          Swift::UInt64 v46 = v13;
          uint64_t v94 = v15;
          Swift::UInt64 v100 = v16;
          unint64_t v47 = a7;
          int v89 = v24;
          Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v25 & 0xFFFFFFFFFFFF0000))._0._value;
          a7 = v47;
          unint64_t v19 = v124;
          uint64_t v18 = v132;
          Swift::UInt64 v16 = v100;
          uint64_t v17 = v108;
          uint64_t v15 = v94;
          Swift::UInt64 v13 = v46;
          a5 = v116;
          unsigned int v31 = value;
          if (v89) {
            goto LABEL_46;
          }
        }
        else
        {
          Swift::UInt64 v29 = v25 >> 16;
          if ((a7 & 0x2000000000000000) != 0)
          {
            uint64_t v137 = v7;
            uint64_t v138 = v17;
            unsigned int v31 = *((unsigned __int8 *)&v137 + v29);
            if (*((char *)&v137 + v29) < 0)
            {
              switch(__clz(v31 ^ 0xFF))
              {
                case 0x1Au:
                  uint64_t v32 = (unsigned __int8 *)&v137 + v29;
LABEL_36:
                  unsigned int v31 = v32[1] & 0x3F | ((v31 & 0x1F) << 6);
                  if (!v24) {
                    goto LABEL_53;
                  }
                  goto LABEL_46;
                case 0x1Bu:
                  unint64_t v33 = (unsigned __int8 *)&v137 + v29;
LABEL_41:
                  char v35 = v33[1];
                  char v36 = v33[2];
                  int v37 = ((v31 & 0xF) << 12) | ((v35 & 0x3F) << 6);
                  goto LABEL_44;
                case 0x1Cu:
                  Swift::UInt64 v34 = (unsigned __int8 *)&v137 + v29;
LABEL_43:
                  char v38 = v34[1];
                  char v39 = v34[2];
                  char v36 = v34[3];
                  int v37 = ((v31 & 0xF) << 18) | ((v38 & 0x3F) << 12) | ((v39 & 0x3F) << 6);
LABEL_44:
                  unsigned int v31 = v37 & 0xFFFFFFC0 | v36 & 0x3F;
                  break;
                default:
                  break;
              }
            }
          }
          else
          {
            unint64_t v30 = (unsigned __int8 *)v18;
            if ((v7 & 0x1000000000000000) == 0)
            {
              Swift::UInt64 v127 = v13;
              uint64_t v135 = v18;
              uint64_t v111 = v17;
              Swift::UInt64 v119 = a5;
              uint64_t v95 = v15;
              Swift::UInt64 v103 = v16;
              unint64_t v72 = v19;
              unint64_t v86 = a7;
              int v90 = v24;
              unint64_t v30 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, a7);
              int v24 = v90;
              a7 = v86;
              unint64_t v19 = v72;
              Swift::UInt64 v13 = v127;
              uint64_t v18 = v135;
              Swift::UInt64 v16 = v103;
              uint64_t v17 = v111;
              uint64_t v15 = v95;
              a5 = v119;
            }
            unsigned int v31 = v30[v29];
            if ((char)v30[v29] < 0)
            {
              switch(__clz(v31 ^ 0xFF))
              {
                case 0x1Au:
                  uint64_t v32 = &v30[v29];
                  goto LABEL_36;
                case 0x1Bu:
                  unint64_t v33 = &v30[v29];
                  goto LABEL_41;
                case 0x1Cu:
                  Swift::UInt64 v34 = &v30[v29];
                  goto LABEL_43;
                default:
                  break;
              }
            }
          }
          if (v24)
          {
LABEL_46:
            if (v22 == v15)
            {
              v66._Swift::UInt64 rawBits = v20._rawBits;
              Swift::UInt64 v126 = v19;
              uint64_t v134 = v18;
              uint64_t v110 = v17;
              Swift::UInt64 v118 = a5;
              Swift::UInt64 v67 = v13;
              uint64_t v68 = v15;
              Swift::UInt64 v69 = v16;
              unint64_t v70 = a7;
              unsigned int v102 = v31;
              v71._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v66)._rawBits;
              unsigned int v31 = v102;
              a7 = v70;
              unint64_t v19 = v126;
              uint64_t v18 = v134;
              uint64_t v17 = v110;
              a5 = v118;
              Swift::UInt64 v16 = v69;
              uint64_t v15 = v68;
              Swift::UInt64 v13 = v67;
              v20._Swift::UInt64 rawBits = v71._rawBits;
              if (v126 <= v71._rawBits >> 16)
              {
LABEL_77:
                unint64_t v85 = 31;
LABEL_78:
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringIndexValidation.swift", 33, 2, v85, 0);
              }
            }
            else if (v19 <= v20._rawBits >> 16)
            {
              goto LABEL_77;
            }
            if ((v20._rawBits & 1) == 0)
            {
              unint64_t v122 = v19;
              uint64_t v130 = v18;
              uint64_t v106 = v17;
              Swift::UInt64 v114 = a5;
              Swift::UInt64 v40 = v13;
              uint64_t v92 = v15;
              Swift::UInt64 v41 = v16;
              unint64_t v42 = a7;
              unsigned int v98 = v31;
              v43._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v20)._rawBits;
              unsigned int v31 = v98;
              a7 = v42;
              unint64_t v19 = v122;
              uint64_t v18 = v130;
              uint64_t v17 = v106;
              a5 = v114;
              Swift::UInt64 v16 = v41;
              uint64_t v15 = v92;
              Swift::UInt64 v13 = v40;
              v20._Swift::UInt64 rawBits = v20._rawBits & 0xC | v43._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
            }
            goto LABEL_54;
          }
        }
LABEL_53:
        if (v19 <= v20._rawBits >> 16)
        {
          unint64_t v85 = 121;
          goto LABEL_78;
        }
LABEL_54:
        if ((a7 & 0x1000000000000000) != 0)
        {
          v52._Swift::UInt64 rawBits = v20._rawBits;
          unint64_t v125 = v19;
          uint64_t v133 = v18;
          Swift::UInt64 v53 = a5;
          Swift::UInt64 v54 = v13;
          uint64_t v55 = v15;
          uint64_t v109 = v12;
          uint64_t v117 = a1;
          uint64_t v101 = v7;
          Swift::UInt64 v56 = rawBits;
          uint64_t v57 = v10;
          uint64_t v58 = v11;
          Swift::UInt64 v59 = v16;
          uint64_t v60 = v17;
          unint64_t v61 = a7;
          unsigned int v62 = v31;
          v63._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v52)._rawBits;
          unsigned int v31 = v62;
          a7 = v61;
          unint64_t v19 = v125;
          uint64_t v18 = v133;
          uint64_t v17 = v60;
          Swift::UInt64 v16 = v59;
          uint64_t v11 = v58;
          uint64_t v10 = v57;
          Swift::UInt64 rawBits = v56;
          uint64_t v7 = v101;
          uint64_t v12 = v109;
          a1 = v117;
          uint64_t v15 = v55;
          Swift::UInt64 v13 = v54;
          a5 = v53;
          v20._Swift::UInt64 rawBits = v63._rawBits;
        }
        else
        {
          Swift::UInt64 v49 = v20._rawBits >> 16;
          if ((a7 & 0x2000000000000000) != 0)
          {
            uint64_t v137 = v7;
            uint64_t v138 = v17;
            int v51 = *((unsigned __int8 *)&v137 + v49);
          }
          else
          {
            uint64_t v50 = (unsigned __int8 *)v18;
            if ((v7 & 0x1000000000000000) == 0)
            {
              uint64_t v73 = v7;
              Swift::UInt64 v128 = rawBits;
              uint64_t v136 = v18;
              Swift::UInt64 v74 = a5;
              Swift::UInt64 v75 = v13;
              uint64_t v96 = v15;
              uint64_t v104 = v7;
              uint64_t v112 = v12;
              unint64_t v120 = a1;
              uint64_t v76 = v10;
              uint64_t v77 = v11;
              Swift::UInt64 v78 = v16;
              uint64_t v79 = v17;
              unint64_t v80 = v19;
              unint64_t v81 = a7;
              unsigned int v82 = v31;
              uint64_t v50 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v73, a7);
              unsigned int v31 = v82;
              a7 = v81;
              unint64_t v19 = v80;
              uint64_t v17 = v79;
              Swift::UInt64 v16 = v78;
              uint64_t v11 = v77;
              uint64_t v10 = v76;
              Swift::UInt64 rawBits = v128;
              uint64_t v18 = v136;
              uint64_t v7 = v104;
              uint64_t v12 = v112;
              a1 = v120;
              uint64_t v15 = v96;
              Swift::UInt64 v13 = v75;
              a5 = v74;
            }
            int v51 = v50[v49];
          }
          int v64 = (char)v51;
          unsigned int v65 = __clz(v51 ^ 0xFF) - 24;
          if (v64 >= 0) {
            LOBYTE(v65) = 1;
          }
          v20._Swift::UInt64 rawBits = ((v49 + v65) << 16) | 5;
        }
        *(_DWORD *)(v11 + 4 * v12++) = v31;
        if (v10 == v12) {
          goto LABEL_70;
        }
      }
    }
    v20._Swift::UInt64 rawBits = a4._rawBits;
LABEL_70:
    uint64_t v12 = v10;
  }
  else
  {
    uint64_t v12 = 0;
    v20._Swift::UInt64 rawBits = a4._rawBits;
  }
LABEL_71:
  *a1 = rawBits;
  a1[1] = a5;
  a1[2] = v7;
  a1[3] = a7;
  a1[4] = v20._rawBits;
  return v12;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    a3 = 0;
  }
  *a1 = a4;
  a1[1] = v4;
  return a3;
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  int64_t v12;
  uint64_t v13;
  int64_t v14;
  unint64_t v15;
  unint64_t v16;
  void *v17;
  unint64_t v18;
  int64_t v19;
  unint64_t v20;
  int64_t v21;

  unint64_t v6 = a4 + 56;
  uint64_t v7 = -1 << *(unsigned char *)(a4 + 32);
  if (-v7 < 64) {
    int64_t v8 = ~(-1 << -(char)v7);
  }
  else {
    int64_t v8 = -1;
  }
  int64_t v9 = v8 & *(void *)(a4 + 56);
  if (!a2)
  {
    uint64_t v12 = 0;
    uint64_t v10 = 0;
    goto LABEL_33;
  }
  uint64_t v10 = a3;
  if (a3 < 0) {
LABEL_37:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  if (!a3)
  {
    uint64_t v12 = 0;
    goto LABEL_33;
  }
  uint64_t v11 = a2;
  uint64_t v12 = 0;
  Swift::UInt64 v13 = 0;
  uint64_t v14 = (unint64_t)(63 - v7) >> 6;
  while (v9)
  {
    uint64_t v15 = __clz(__rbit64(v9));
    v9 &= v9 - 1;
    Swift::UInt64 v16 = v15 | (v12 << 6);
LABEL_9:
    ++v13;
    uint64_t v17 = (void *)(*(void *)(a4 + 48) + 16 * v16);
    uint64_t v18 = v17[1];
    *uint64_t v11 = *v17;
    v11[1] = v18;
    v11 += 2;
    swift_bridgeObjectRetain(v18);
    if (v13 == v10) {
      goto LABEL_33;
    }
  }
  unint64_t v19 = v12 + 1;
  if (__OFADD__(v12, 1))
  {
    __break(1u);
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  if (v19 >= v14) {
    goto LABEL_29;
  }
  Swift::String::Index v20 = *(void *)(v6 + 8 * v19);
  if (v20) {
    goto LABEL_26;
  }
  v12 += 2;
  if (v19 + 1 >= v14)
  {
    int64_t v9 = 0;
    uint64_t v12 = v19;
    goto LABEL_32;
  }
  Swift::String::Index v20 = *(void *)(v6 + 8 * v12);
  if (v20)
  {
    ++v19;
LABEL_26:
    int64_t v9 = (v20 - 1) & v20;
    Swift::UInt64 v16 = __clz(__rbit64(v20)) + (v19 << 6);
    uint64_t v12 = v19;
    goto LABEL_9;
  }
  if (v19 + 2 >= v14)
  {
LABEL_29:
    int64_t v9 = 0;
    goto LABEL_32;
  }
  Swift::String::Index v20 = *(void *)(v6 + 8 * (v19 + 2));
  if (v20)
  {
    v19 += 2;
    goto LABEL_26;
  }
  Swift::UInt64 v21 = v19 + 3;
  if (v19 + 3 >= v14)
  {
    int64_t v9 = 0;
    uint64_t v12 = v19 + 2;
    goto LABEL_32;
  }
  Swift::String::Index v20 = *(void *)(v6 + 8 * v21);
  if (v20)
  {
    v19 += 3;
    goto LABEL_26;
  }
  while (1)
  {
    unint64_t v19 = v21 + 1;
    if (__OFADD__(v21, 1)) {
      goto LABEL_36;
    }
    if (v19 >= v14) {
      break;
    }
    Swift::String::Index v20 = *(void *)(v6 + 8 * v19);
    ++v21;
    if (v20) {
      goto LABEL_26;
    }
  }
  int64_t v9 = 0;
  uint64_t v12 = v14 - 1;
LABEL_32:
  uint64_t v10 = v13;
LABEL_33:
  *a1 = a4;
  a1[1] = v6;
  a1[2] = ~v7;
  a1[3] = v12;
  a1[4] = v9;
  return v10;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(char **a1, uint64_t a2, uint64_t a3, char *a4, char *a5)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v5 = 0;
      while (a4)
      {
        if (a5 && a4 == a5) {
          goto LABEL_14;
        }
        if (!a5) {
          goto LABEL_17;
        }
        if (a4 >= a5) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
        }
        char v6 = *a4++;
        *(unsigned char *)(a2 + v5++) = v6;
        if (a3 == v5) {
          goto LABEL_11;
        }
      }
      if (a5) {
LABEL_17:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
    }
    else
    {
LABEL_11:
      uint64_t v5 = a3;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
LABEL_14:
  *a1 = a4;
  a1[1] = a5;
  return v5;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, Swift::String_optional *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6 = HIBYTE(a5) & 0xF;
  uint64_t v12 = a4;
  unint64_t v13 = a5;
  if ((a5 & 0x2000000000000000) == 0) {
    uint64_t v6 = a4 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v14 = v6;
  if (a2)
  {
    uint64_t v7 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      int64_t v8 = a2;
      uint64_t v9 = 0;
      while (1)
      {
        Swift::String_optional v10 = String.Iterator.next()();
        if (!v10.value._object) {
          break;
        }
        ++v9;
        *v8++ = v10;
        if (v7 == v9)
        {
          a4 = v12;
          a5 = v13;
          goto LABEL_13;
        }
      }
      a4 = v12;
      a5 = v13;
      uint64_t v7 = v9;
LABEL_13:
      uint64_t v6 = v14;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  *a1 = a4;
  a1[1] = a5;
  a1[2] = 0;
  a1[3] = v6;
  return v7;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x2000000000000000) != 0) {
    uint64_t v8 = HIBYTE(a5) & 0xF;
  }
  else {
    uint64_t v8 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (!a2)
  {
    uint64_t v11 = 0;
    __int16 v12 = 0;
    uint64_t v9 = 0;
    char v16 = 1;
    goto LABEL_39;
  }
  uint64_t v9 = a3;
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  swift_bridgeObjectRetain_n(a5, 3);
  if (!v9)
  {
    uint64_t v11 = 0;
    __int16 v12 = 0;
    char v16 = 1;
    goto LABEL_38;
  }
  uint64_t v31 = a1;
  uint64_t v11 = 0;
  __int16 v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = a5 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v15 = (a5 & 0xFFFFFFFFFFFFFFFLL) + 32;
  char v16 = 1;
  while ((v16 & 1) == 0)
  {
    char v16 = 1;
    LOWORD(v17) = v12;
    __int16 v12 = 0;
LABEL_9:
    *(_WORD *)(a2 + 2 * v13++) = v17;
    if (v9 == v13)
    {
      a1 = v31;
      goto LABEL_38;
    }
  }
  if (v11 < v8)
  {
    if ((a5 & 0x1000000000000000) != 0)
    {
      uint64_t v22 = v14;
      uint64_t v23 = v15;
      Swift::tuple_Unicode_Scalar_scalarLength_Int v24 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v11 << 16));
      Swift::Int scalarLength = v24.scalarLength;
      uint64_t v15 = v23;
      uint64_t v14 = v22;
      uint64_t v17 = *(void *)&v24._0._value;
    }
    else
    {
      if ((a5 & 0x2000000000000000) == 0)
      {
        uint64_t v18 = (unsigned char *)v15;
        if ((a4 & 0x1000000000000000) == 0)
        {
          uint64_t v26 = v14;
          uint64_t v27 = v15;
          uint64_t v18 = _StringObject.sharedUTF8.getter(a4, a5);
          uint64_t v15 = v27;
          uint64_t v14 = v26;
        }
        LODWORD(v17) = v18[v11];
        if ((char)v18[v11] < 0)
        {
          switch(__clz(v17 ^ 0xFF))
          {
            case 0x1Au:
              LOWORD(v17) = v18[v11 + 1] & 0x3F | ((v17 & 0x1F) << 6);
              uint64_t v19 = 2;
              goto LABEL_18;
            case 0x1Bu:
              LOWORD(v17) = ((v17 & 0xF) << 12) | ((v18[v11 + 1] & 0x3F) << 6) | v18[v11 + 2] & 0x3F;
              uint64_t v19 = 3;
              goto LABEL_18;
            case 0x1Cu:
              Swift::UInt64 v21 = &v18[v11];
              goto LABEL_29;
            default:
              break;
          }
        }
        uint64_t v19 = 1;
LABEL_18:
        v11 += v19;
LABEL_31:
        char v16 = 1;
        goto LABEL_9;
      }
      v32[0] = a4;
      v32[1] = v14;
      uint64_t v17 = *((unsigned __int8 *)v32 + v11);
      if (*((char *)v32 + v11) < 0)
      {
        switch(__clz(v17 ^ 0xFF))
        {
          case 0x1Au:
            uint64_t v17 = *((unsigned char *)v32 + v11 + 1) & 0x3F | ((v17 & 0x1F) << 6);
            Swift::Int scalarLength = 2;
            break;
          case 0x1Bu:
            uint64_t v17 = ((v17 & 0xF) << 12) | ((*((unsigned char *)v32 + v11 + 1) & 0x3F) << 6) | *((unsigned char *)v32 + v11 + 2) & 0x3F;
            Swift::Int scalarLength = 3;
            break;
          case 0x1Cu:
            Swift::UInt64 v21 = (char *)v32 + v11;
LABEL_29:
            uint64_t v17 = ((v17 & 0xF) << 18) | ((v21[1] & 0x3F) << 12) | ((v21[2] & 0x3F) << 6) | v21[3] & 0x3F;
            Swift::Int scalarLength = 4;
            break;
          default:
            goto LABEL_20;
        }
      }
      else
      {
LABEL_20:
        Swift::Int scalarLength = 1;
      }
    }
    v11 += scalarLength;
    if (v17 >= 0x10000)
    {
      uint64_t v29 = v15;
      uint64_t v30 = v14;
      __int16 v25 = Unicode.Scalar.UTF16View.subscript.getter(1, v17);
      LODWORD(v17) = (unsigned __int16)((v17 + 67043328) >> 10) + 55296;
      if ((v17 & 0x10000) != 0)
      {
        __break(1u);
        JUMPOUT(0x181360834);
      }
      __int16 v12 = v25;
      char v16 = 0;
      uint64_t v15 = v29;
      uint64_t v14 = v30;
      goto LABEL_9;
    }
    goto LABEL_31;
  }
  char v16 = 1;
  uint64_t v9 = v13;
  a1 = v31;
LABEL_38:
  swift_bridgeObjectRelease_n(a5, 3);
LABEL_39:
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = a5;
  *(void *)(a1 + 16) = v11;
  *(void *)(a1 + 24) = v8;
  *(_WORD *)(a1 + 32) = v12;
  *(unsigned char *)(a1 + 34) = v16;
  return v9;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x2000000000000000) != 0) {
    uint64_t v8 = HIBYTE(a5) & 0xF;
  }
  else {
    uint64_t v8 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (a2)
  {
    uint64_t v9 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      while (1)
      {
        if (v12 >= v8)
        {
          uint64_t v9 = v11;
          goto LABEL_31;
        }
        if ((a5 & 0x1000000000000000) != 0)
        {
          uint64_t v22 = a1;
          Swift::tuple_Unicode_Scalar_scalarLength_Int v19 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v12 << 16));
          Swift::Int scalarLength = v19.scalarLength;
          int value = v19._0._value;
          a1 = v22;
        }
        else
        {
          if ((a5 & 0x2000000000000000) != 0)
          {
            v24[0] = a4;
            v24[1] = a5 & 0xFFFFFFFFFFFFFFLL;
            int value = *((unsigned __int8 *)v24 + v12);
            if (*((char *)v24 + v12) < 0)
            {
              switch(__clz(value ^ 0xFF))
              {
                case 0x1Au:
                  char v16 = (char *)v24 + v12;
LABEL_21:
                  int value = v16[1] & 0x3F | ((value & 0x1F) << 6);
                  Swift::Int scalarLength = 2;
                  break;
                case 0x1Bu:
                  uint64_t v17 = (char *)v24 + v12;
LABEL_25:
                  int value = ((value & 0xF) << 12) | ((v17[1] & 0x3F) << 6) | v17[2] & 0x3F;
                  Swift::Int scalarLength = 3;
                  break;
                case 0x1Cu:
                  uint64_t v18 = (char *)v24 + v12;
LABEL_27:
                  int value = ((value & 0xF) << 18) | ((v18[1] & 0x3F) << 12) | ((v18[2] & 0x3F) << 6) | v18[3] & 0x3F;
                  Swift::Int scalarLength = 4;
                  break;
                default:
                  goto LABEL_9;
              }
              goto LABEL_10;
            }
          }
          else
          {
            uint64_t v15 = (a5 & 0xFFFFFFFFFFFFFFFLL) + 32;
            if ((a4 & 0x1000000000000000) == 0)
            {
              uint64_t v23 = a1;
              id v20 = _StringObject.sharedUTF8.getter(a4, a5);
              a1 = v23;
              uint64_t v15 = (uint64_t)v20;
            }
            int value = *(unsigned __int8 *)(v15 + v12);
            if (*(char *)(v15 + v12) < 0)
            {
              switch(__clz(value ^ 0xFF))
              {
                case 0x1Au:
                  char v16 = (char *)(v12 + v15);
                  goto LABEL_21;
                case 0x1Bu:
                  uint64_t v17 = (char *)(v12 + v15);
                  goto LABEL_25;
                case 0x1Cu:
                  uint64_t v18 = (char *)(v12 + v15);
                  goto LABEL_27;
                default:
                  break;
              }
            }
          }
LABEL_9:
          Swift::Int scalarLength = 1;
        }
LABEL_10:
        *(_DWORD *)(a2 + 4 * v1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = value;
        v12 += scalarLength;
        if (v9 == ++v11) {
          goto LABEL_31;
        }
      }
    }
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v9 = 0;
  }
LABEL_31:
  *a1 = a4;
  a1[1] = a5;
  a1[2] = v12;
  a1[3] = v8;
  return v9;
}

unint64_t specialized Sequence._copySequenceContents(initializing:)(void *a1, void *a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    unint64_t v6 = a3;
    if ((a3 & 0x8000000000000000) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    if (a3)
    {
      uint64_t v7 = a2;
      unint64_t v8 = 0;
      uint64_t v9 = (unint64_t *)(a4 + 40);
      while (1)
      {
        unint64_t v10 = *(void *)(a4 + 16);
        if (v8 == v10) {
          break;
        }
        if (v8 >= v10) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        }
        ++v8;
        unint64_t v11 = *v9;
        *uint64_t v7 = *(v9 - 1);
        v7[1] = v11;
        v7 += 2;
        swift_bridgeObjectRetain(v11);
        v9 += 2;
        if (v6 == v8) {
          goto LABEL_10;
        }
      }
      unint64_t v6 = v8;
    }
  }
  else
  {
    unint64_t v6 = 0;
  }
LABEL_10:
  *a1 = a4;
  a1[1] = v6;
  return v6;
}

uint64_t Sequence._copySequenceContents(initializing:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v36 = a3;
  uint64_t v31 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v28 = (uint64_t)*(v11 - 1);
  uint64_t v29 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v27 - v13;
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v27 - v16;
  uint64_t v18 = swift_getAssociatedTypeWitness(0, (int **)a5, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v19 = *((void *)v18 - 1);
  MEMORY[0x1F4188790](v18);
  Swift::UInt64 v21 = (char *)&v27 - v20;
  uint64_t v22 = *(void (**)(uint64_t, uint64_t))(a5 + 32);
  uint64_t v33 = a4;
  v22(a4, a5);
  if (a2)
  {
    Swift::UInt64 v34 = v21;
    uint64_t v30 = v19;
    if (v36 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
    }
    char v35 = v18;
    if (v36)
    {
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, v33, (uint64_t)v35, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v24 = 0;
      uint64_t v32 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
      uint64_t v33 = AssociatedConformanceWitness;
      while (1)
      {
        v32(v35, v33);
        if ((*(unsigned int (**)(char *, uint64_t, const char *))(v15 + 48))(v14, 1, AssociatedTypeWitness) == 1) {
          break;
        }
        ++v24;
        __int16 v25 = *(void (**)(char *, char *, const char *))(v15 + 32);
        v25(v17, v14, AssociatedTypeWitness);
        v25(a2, v17, AssociatedTypeWitness);
        a2 += *(void *)(v15 + 72);
        if (v36 == v24) {
          goto LABEL_7;
        }
      }
      (*(void (**)(char *, Class *))(v28 + 8))(v14, v29);
      (*(void (**)(uint64_t, char *, const char *))(v30 + 32))(v31, v34, v35);
      return v24;
    }
    else
    {
LABEL_7:
      (*(void (**)(uint64_t, char *, const char *))(v30 + 32))(v31, v34, v35);
      return v36;
    }
  }
  else
  {
    (*(void (**)(uint64_t, char *, const char *))(v19 + 32))(v31, v21, v18);
    return 0;
  }
}

uint64_t UnsafeBufferPointer.indices.getter(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0xB2uLL, 0);
  }
  return 0;
}

uint64_t (*IteratorSequence._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t IteratorSequence.next()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))(*(void *)(a1 + 16));
}

uint64_t Sequence.min(by:)@<X0>(uint64_t (*a1)(char *, char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, uint64_t a5@<X8>)
{
  Swift::String::Index v63 = a4;
  Swift::UInt64 v59 = a1;
  uint64_t v60 = a2;
  uint64_t v54 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v52 = (uint64_t)*(v11 - 1);
  Swift::UInt64 v53 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  int v51 = (char *)&v49 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v49 - v15;
  uint64_t v56 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v49 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  unsigned int v65 = (char *)&v49 - v21;
  uint64_t v22 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v49 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  __int16 v25 = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v55 = *((void *)v25 - 1);
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = (char *)&v49 - v26;
  (*(void (**)(char *, void, uint64_t))(v22 + 16))(v24, v64, a3);
  uint64_t v28 = (uint64_t)v63;
  ((void (*)(uint64_t, int **))v63[4])(a3, v63);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v28, a3, (uint64_t)v25, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v31 = AssociatedConformanceWitness + 16;
  uint64_t v30 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v61 = AssociatedConformanceWitness;
  unsigned int v62 = v25;
  uint64_t v50 = v30;
  ((void (*)(const char *))v30)(v25);
  uint64_t v32 = v56;
  uint64_t v33 = *(unsigned int (**)(char *, uint64_t, const char *))(v56 + 48);
  int v64 = (void (*)(void, void, void))v16;
  if (v33(v16, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, const char *))(v55 + 8))(v27, v62);
    (*(void (**)(void (*)(void, void, void), Class *))(v52 + 8))(v64, v53);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(v32 + 56))(v54, 1, 1, AssociatedTypeWitness);
  }
  else
  {
    char v35 = *(void (**)(void, void, void))(v32 + 32);
    uint64_t v36 = v64;
    Swift::String::Index v63 = (int **)(v32 + 32);
    int v64 = v35;
    v35(v65, v36, AssociatedTypeWitness);
    int v37 = v51;
    uint64_t v58 = v27;
    char v38 = v50;
    v50(v62, v61);
    char v39 = v37;
    if (v33(v37, 1, AssociatedTypeWitness) == 1)
    {
LABEL_4:
      (*(void (**)(char *, const char *))(v55 + 8))(v58, v62);
      (*(void (**)(char *, Class *))(v52 + 8))(v39, v53);
      uint64_t v40 = v54;
      v64(v54, v65, AssociatedTypeWitness);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v56 + 56))(v40, 0, 1, AssociatedTypeWitness);
    }
    else
    {
      uint64_t v41 = v31;
      unint64_t v42 = v38;
      uint64_t v57 = v41;
      Swift::String::Index v43 = (void (**)(char *, const char *))(v56 + 8);
      while (1)
      {
        Swift::UInt64 v44 = v39;
        v64(v19, v39, AssociatedTypeWitness);
        char v45 = v59(v19, v65);
        if (v5) {
          break;
        }
        Swift::UInt64 v46 = *v43;
        if (v45)
        {
          unint64_t v47 = v65;
          v46(v65, AssociatedTypeWitness);
          v64(v47, v19, AssociatedTypeWitness);
        }
        else
        {
          v46(v19, AssociatedTypeWitness);
        }
        v42(v62, v61);
        char v39 = v44;
        if (v33(v44, 1, AssociatedTypeWitness) == 1) {
          goto LABEL_4;
        }
      }
      int v48 = *v43;
      (*v43)(v19, AssociatedTypeWitness);
      v48(v65, AssociatedTypeWitness);
      return (*(uint64_t (**)(char *, const char *))(v55 + 8))(v58, v62);
    }
  }
}

uint64_t Sequence.max(by:)@<X0>(uint64_t (*a1)(char *, char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int **a4@<X3>, uint64_t a5@<X8>)
{
  Swift::String::Index v63 = a4;
  Swift::UInt64 v59 = a1;
  uint64_t v60 = a2;
  uint64_t v54 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v52 = (uint64_t)*(v11 - 1);
  Swift::UInt64 v53 = v11;
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  int v51 = (char *)&v49 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v49 - v15;
  uint64_t v56 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v49 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  unsigned int v65 = (char *)&v49 - v21;
  uint64_t v22 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v49 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  __int16 v25 = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v55 = *((void *)v25 - 1);
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = (char *)&v49 - v26;
  (*(void (**)(char *, void, uint64_t))(v22 + 16))(v24, v64, a3);
  uint64_t v28 = (uint64_t)v63;
  ((void (*)(uint64_t, int **))v63[4])(a3, v63);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v28, a3, (uint64_t)v25, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v31 = AssociatedConformanceWitness + 16;
  uint64_t v30 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v61 = AssociatedConformanceWitness;
  unsigned int v62 = v25;
  uint64_t v50 = v30;
  ((void (*)(const char *))v30)(v25);
  uint64_t v32 = v56;
  uint64_t v33 = *(unsigned int (**)(char *, uint64_t, const char *))(v56 + 48);
  int v64 = (void (*)(void, void, void))v16;
  if (v33(v16, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, const char *))(v55 + 8))(v27, v62);
    (*(void (**)(void (*)(void, void, void), Class *))(v52 + 8))(v64, v53);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(v32 + 56))(v54, 1, 1, AssociatedTypeWitness);
  }
  else
  {
    char v35 = *(void (**)(void, void, void))(v32 + 32);
    uint64_t v36 = v64;
    Swift::String::Index v63 = (int **)(v32 + 32);
    int v64 = v35;
    v35(v65, v36, AssociatedTypeWitness);
    int v37 = v51;
    uint64_t v58 = v27;
    char v38 = v50;
    v50(v62, v61);
    char v39 = v37;
    if (v33(v37, 1, AssociatedTypeWitness) == 1)
    {
LABEL_4:
      (*(void (**)(char *, const char *))(v55 + 8))(v58, v62);
      (*(void (**)(char *, Class *))(v52 + 8))(v39, v53);
      uint64_t v40 = v54;
      v64(v54, v65, AssociatedTypeWitness);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, const char *))(v56 + 56))(v40, 0, 1, AssociatedTypeWitness);
    }
    else
    {
      uint64_t v41 = v31;
      unint64_t v42 = v38;
      uint64_t v57 = v41;
      Swift::String::Index v43 = (void (**)(char *, const char *))(v56 + 8);
      while (1)
      {
        Swift::UInt64 v44 = v39;
        v64(v19, v39, AssociatedTypeWitness);
        char v45 = v59(v65, v19);
        if (v5) {
          break;
        }
        Swift::UInt64 v46 = *v43;
        if (v45)
        {
          unint64_t v47 = v65;
          v46(v65, AssociatedTypeWitness);
          v64(v47, v19, AssociatedTypeWitness);
        }
        else
        {
          v46(v19, AssociatedTypeWitness);
        }
        v42(v62, v61);
        char v39 = v44;
        if (v33(v44, 1, AssociatedTypeWitness) == 1) {
          goto LABEL_4;
        }
      }
      int v48 = *v43;
      (*v43)(v19, AssociatedTypeWitness);
      v48(v65, AssociatedTypeWitness);
      return (*(uint64_t (**)(char *, const char *))(v55 + 8))(v58, v62);
    }
  }
}

uint64_t Sequence<>.min()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v59 = a3;
  int v51 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t v49 = (uint64_t)*(v9 - 1);
  uint64_t v50 = v9;
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v46 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v46 - v14;
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v13);
  uint64_t v58 = (char *)&v46 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v61 = (char *)&v46 - v20;
  uint64_t v21 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v46 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v48 = *((void *)v24 - 1);
  MEMORY[0x1F4188790](v24);
  uint64_t v26 = (char *)&v46 - v25;
  (*(void (**)(char *, unsigned int (*)(char *, uint64_t, const char *), uint64_t))(v21 + 16))(v23, v60, a1);
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  uint64_t v27 = a2;
  uint64_t v28 = v16;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v27, a1, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = AssociatedConformanceWitness + 16;
  uint64_t v31 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v31(v24, AssociatedConformanceWitness);
  uint64_t v32 = v15;
  uint64_t v33 = v28 + 48;
  uint64_t v60 = *(unsigned int (**)(char *, uint64_t, const char *))(v28 + 48);
  if (v60(v32, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, const char *))(v48 + 8))(v26, v24);
    (*(void (**)(char *, Class *))(v49 + 8))(v32, v50);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v28 + 56))(v51, 1, 1, AssociatedTypeWitness);
  }
  else
  {
    uint64_t v47 = v28;
    uint64_t v56 = *(void (**)(char *, char *, const char *))(v28 + 32);
    uint64_t v57 = v28 + 32;
    v56(v61, v32, AssociatedTypeWitness);
    v31(v24, AssociatedConformanceWitness);
    char v35 = v26;
    if (v60(v12, 1, AssociatedTypeWitness) != 1)
    {
      Swift::UInt64 v53 = (void (**)(char *, const char *))(v47 + 8);
      uint64_t v54 = v59 + 16;
      uint64_t v55 = v33;
      uint64_t v52 = v31;
      int v37 = v56;
      do
      {
        uint64_t v38 = v30;
        uint64_t v39 = AssociatedConformanceWitness;
        uint64_t v40 = v24;
        uint64_t v41 = AssociatedTypeWitness;
        unint64_t v42 = v58;
        v37(v58, v12, v41);
        Swift::String::Index v43 = v61;
        char v44 = (*(uint64_t (**)(char *, char *, const char *))(v59 + 16))(v42, v61, v41);
        char v45 = *v53;
        if (v44)
        {
          v45(v43, v41);
          v37(v43, v42, v41);
        }
        else
        {
          v45(v42, v41);
        }
        uint64_t v24 = v40;
        uint64_t AssociatedConformanceWitness = v39;
        uint64_t v30 = v38;
        uint64_t AssociatedTypeWitness = v41;
        v52(v24, AssociatedConformanceWitness);
      }
      while (v60(v12, 1, v41) != 1);
    }
    (*(void (**)(char *, const char *))(v48 + 8))(v35, v24);
    (*(void (**)(char *, Class *))(v49 + 8))(v12, v50);
    uint64_t v36 = v51;
    v56(v51, v61, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, void, uint64_t, const char *))(v47 + 56))(v36, 0, 1, AssociatedTypeWitness);
  }
}

uint64_t Sequence<>.max()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v59 = a3;
  int v51 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v7, v8);
  uint64_t v49 = (uint64_t)*(v9 - 1);
  uint64_t v50 = v9;
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v46 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v46 - v14;
  uint64_t v16 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v13);
  uint64_t v58 = (char *)&v46 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v61 = (char *)&v46 - v20;
  uint64_t v21 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v46 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = swift_getAssociatedTypeWitness(0, (int **)a2, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v48 = *((void *)v24 - 1);
  MEMORY[0x1F4188790](v24);
  uint64_t v26 = (char *)&v46 - v25;
  (*(void (**)(char *, unsigned int (*)(char *, uint64_t, const char *), uint64_t))(v21 + 16))(v23, v60, a1);
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  uint64_t v27 = a2;
  uint64_t v28 = v16;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v27, a1, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = AssociatedConformanceWitness + 16;
  uint64_t v31 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v31(v24, AssociatedConformanceWitness);
  uint64_t v32 = v15;
  uint64_t v33 = v28 + 48;
  uint64_t v60 = *(unsigned int (**)(char *, uint64_t, const char *))(v28 + 48);
  if (v60(v32, 1, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, const char *))(v48 + 8))(v26, v24);
    (*(void (**)(char *, Class *))(v49 + 8))(v32, v50);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, const char *))(v28 + 56))(v51, 1, 1, AssociatedTypeWitness);
  }
  else
  {
    uint64_t v47 = v28;
    uint64_t v56 = *(void (**)(char *, char *, const char *))(v28 + 32);
    uint64_t v57 = v28 + 32;
    v56(v61, v32, AssociatedTypeWitness);
    v31(v24, AssociatedConformanceWitness);
    char v35 = v26;
    if (v60(v12, 1, AssociatedTypeWitness) != 1)
    {
      Swift::UInt64 v53 = (void (**)(char *, const char *))(v47 + 8);
      uint64_t v54 = v59 + 16;
      uint64_t v55 = v33;
      uint64_t v52 = v31;
      int v37 = v56;
      do
      {
        uint64_t v38 = v30;
        uint64_t v39 = AssociatedConformanceWitness;
        uint64_t v40 = v24;
        uint64_t v41 = AssociatedTypeWitness;
        unint64_t v42 = v58;
        v37(v58, v12, v41);
        Swift::String::Index v43 = v61;
        char v44 = (*(uint64_t (**)(char *, char *, const char *))(v59 + 16))(v61, v42, v41);
        char v45 = *v53;
        if (v44)
        {
          v45(v43, v41);
          v37(v43, v42, v41);
        }
        else
        {
          v45(v42, v41);
        }
        uint64_t v24 = v40;
        uint64_t AssociatedConformanceWitness = v39;
        uint64_t v30 = v38;
        uint64_t AssociatedTypeWitness = v41;
        v52(v24, AssociatedConformanceWitness);
      }
      while (v60(v12, 1, v41) != 1);
    }
    (*(void (**)(char *, const char *))(v48 + 8))(v35, v24);
    (*(void (**)(char *, Class *))(v49 + 8))(v12, v50);
    uint64_t v36 = v51;
    v56(v51, v61, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, void, uint64_t, const char *))(v47 + 56))(v36, 0, 1, AssociatedTypeWitness);
  }
}

uint64_t Sequence.starts<A>(with:by:)(char *a1, uint64_t (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, int **a6, int **a7)
{
  unint64_t v86 = a7;
  Swift::String::Index v71 = a2;
  uint64_t v72 = a3;
  unint64_t v84 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a7, a5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  Swift::String::Index v66 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v65 = (uint64_t)*(v66 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v66);
  int v64 = (char *)&v64 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  Swift::UInt64 v74 = (char *)&v64 - v16;
  uint64_t v77 = AssociatedTypeWitness;
  uint64_t v73 = (void (**)(char *, const char *))*((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](v15);
  unint64_t v70 = (char *)&v64 - v17;
  uint64_t v79 = a6;
  uint64_t v18 = swift_getAssociatedTypeWitness(0, a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v69 = *((void *)v18 - 1);
  MEMORY[0x1F4188790](v18);
  uint64_t v20 = (char *)&v64 - v19;
  uint64_t v23 = type metadata accessor for Optional(0, (uint64_t)v18, v21, v22);
  uint64_t v24 = MEMORY[0x1F4188790](v23 - 1);
  unint64_t v81 = (char *)&v64 - v25;
  Swift::UInt64 v75 = (unsigned int (**)(char *, uint64_t, const char *))a4;
  uint64_t AssociatedConformanceWitness = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v24);
  Swift::UInt64 v78 = (char *)&v64 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = swift_getAssociatedTypeWitness(0, a6, v27, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v67 = *((void *)v28 - 1);
  uint64_t v29 = MEMORY[0x1F4188790](v28);
  uint64_t v31 = (char *)&v64 - v30;
  uint64_t v32 = a5;
  uint64_t v33 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](v29);
  char v35 = (char *)&v64 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v36 = v86;
  unint64_t v83 = swift_getAssociatedTypeWitness(0, v86, v32, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v68 = *((void *)v83 - 1);
  MEMORY[0x1F4188790](v83);
  uint64_t v38 = (char *)&v64 - v37;
  (*(void (**)(char *, char *, uint64_t))(v33 + 16))(v35, v84, v32);
  uint64_t v39 = v36[4];
  unsigned int v82 = v38;
  uint64_t v76 = v32;
  ((void (*)(uint64_t, int **))v39)(v32, v36);
  uint64_t v40 = (uint64_t)v75;
  (*(void (**)(char *, const char *, unsigned int (**)(char *, uint64_t, const char *)))(AssociatedConformanceWitness + 16))(v78, v85, v75);
  uint64_t v41 = (uint64_t)v79;
  unint64_t v42 = v79[4];
  unint64_t v84 = v31;
  ((void (*)(uint64_t, int **))v42)(v40, v79);
  unint64_t v85 = v28;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v41, v40, (uint64_t)v28, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  Swift::UInt64 v78 = *(char **)(AssociatedConformanceWitness + 16);
  uint64_t v79 = (int **)(AssociatedConformanceWitness + 16);
  Swift::String::Index v43 = (const char *)(v69 + 48);
  char v44 = (void (**)(char *, char *, const char *))(v69 + 32);
  Swift::UInt64 v75 = (unsigned int (**)(char *, uint64_t, const char *))(v73 + 6);
  char v45 = (void (**)(char *, char *, const char *))(v73 + 4);
  uint64_t v46 = v73 + 1;
  uint64_t v73 = (void (**)(char *, const char *))(v69 + 8);
  while (1)
  {
    uint64_t v47 = v81;
    ((void (*)(const char *, uint64_t))v78)(v85, AssociatedConformanceWitness);
    if ((*(unsigned int (**)(char *, uint64_t, const char *))v43)(v47, 1, v18) == 1)
    {
      (*(void (**)(char *, const char *))(v67 + 8))(v84, v85);
      Swift::String::Index v43 = v83;
      uint64_t v60 = swift_getAssociatedConformanceWitness((uint64_t)v86, v76, (uint64_t)v83, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v61 = v64;
      unsigned int v62 = v82;
      (*(void (**)(const char *, uint64_t))(v60 + 16))(v43, v60);
      (*(void (**)(char *, const char *))(v68 + 8))(v62, v43);
      LOBYTE(v43) = (*v75)(v61, 1, v77) == 1;
      (*(void (**)(char *, Class *))(v65 + 8))(v61, v66);
      return v43 & 1;
    }
    (*v44)(v20, v47, v18);
    uint64_t v48 = v83;
    uint64_t v49 = swift_getAssociatedConformanceWitness((uint64_t)v86, v76, (uint64_t)v83, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v50 = v20;
    int v51 = v74;
    (*(void (**)(const char *, uint64_t))(v49 + 16))(v48, v49);
    uint64_t v52 = v51;
    Swift::UInt64 v53 = v51;
    uint64_t v54 = v77;
    if ((*v75)(v53, 1, v77) == 1)
    {
      (*v73)(v50, v18);
      (*(void (**)(char *, const char *))(v67 + 8))(v84, v85);
      (*(void (**)(char *, const char *))(v68 + 8))(v82, v83);
      (*(void (**)(char *, Class *))(v65 + 8))(v52, v66);
      LOBYTE(v43) = 1;
      return v43 & 1;
    }
    uint64_t v55 = v18;
    uint64_t v56 = v70;
    (*v45)(v70, v52, v54);
    uint64_t v57 = v87;
    char v58 = v71(v50, v56);
    uint64_t v87 = v57;
    if (v57) {
      break;
    }
    char v59 = v58;
    (*v46)(v56, v54);
    uint64_t v18 = v55;
    (*v73)(v50, v55);
    uint64_t v20 = v50;
    if ((v59 & 1) == 0)
    {
      (*(void (**)(char *, const char *))(v67 + 8))(v84, v85);
      (*(void (**)(char *, const char *))(v68 + 8))(v82, v83);
      LOBYTE(v43) = 0;
      return v43 & 1;
    }
  }
  (*v46)(v56, v54);
  (*v73)(v50, v55);
  (*(void (**)(char *, const char *))(v67 + 8))(v84, v85);
  (*(void (**)(char *, const char *))(v68 + 8))(v82, v83);
  return v43 & 1;
}

uint64_t specialized Sequence<>.starts<A>(with:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v21)(uint64_t *__return_ptr, const char *, uint64_t);
  unint64_t i;
  uint64_t v23;
  Swift::String_optional v24;
  char v26;
  void *object;
  uint64_t v28;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;

  uint64_t v5 = v4;
  uint64_t v10 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, v13, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v15 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v30 - v16;
  uint64_t v18 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v18 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v32 = a1;
  uint64_t v33 = a2;
  uint64_t v34 = 0;
  char v35 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, v5, a3);
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(a4 + 32);
  swift_bridgeObjectRetain(a2);
  v19(a3, a4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v21 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v21(&v30, AssociatedTypeWitness, AssociatedConformanceWitness);
  for (uint64_t i = v31; v31; uint64_t i = v31)
  {
    uint64_t v23 = v30;
    uint64_t v24 = String.Iterator.next()();
    if (!v24.value._object)
    {
      swift_bridgeObjectRelease(i);
      (*(void (**)(char *, const char *))(v15 + 8))(v17, AssociatedTypeWitness);
      swift_bridgeObjectRelease(v33);
      return 1;
    }
    if (v23 == v24.value._countAndFlagsBits && (void *)i == v24.value._object)
    {
      swift_bridgeObjectRelease(i);
      swift_bridgeObjectRelease((uint64_t)v24.value._object);
    }
    else
    {
      if ((~(i & (unint64_t)v24.value._object) & 0x6000000000000000) == 0)
      {
        swift_bridgeObjectRelease(i);
        swift_bridgeObjectRelease((uint64_t)v24.value._object);
LABEL_20:
        (*(void (**)(char *, const char *))(v15 + 8))(v17, AssociatedTypeWitness);
        uint64_t v28 = v33;
LABEL_21:
        swift_bridgeObjectRelease(v28);
        return 0;
      }
      uint64_t v26 = _stringCompareInternal(_:_:expecting:)(v23, i, v24.value._countAndFlagsBits, (unint64_t)v24.value._object, 0);
      swift_bridgeObjectRelease(i);
      swift_bridgeObjectRelease((uint64_t)v24.value._object);
      if ((v26 & 1) == 0) {
        goto LABEL_20;
      }
    }
    v21(&v30, AssociatedTypeWitness, AssociatedConformanceWitness);
  }
  (*(void (**)(char *, const char *))(v15 + 8))(v17, AssociatedTypeWitness);
  unint64_t object = String.Iterator.next()().value._object;
  swift_bridgeObjectRelease(v33);
  if (object)
  {
    uint64_t v28 = (uint64_t)object;
    goto LABEL_21;
  }
  return 1;
}

{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  const char *AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  Swift::UInt64 v18;
  uint64_t AssociatedConformanceWitness;
  void (*v20)(uint64_t *__return_ptr, const char *, uint64_t);
  unint64_t v21;
  uint64_t v22;
  Swift::String::Index v23;
  Swift::UInt64 rawBits;
  uint64_t v25;
  char *v26;
  int v27;
  uint64_t v28;
  int v29;
  Swift::String::Index v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  char v37;
  Swift::String::Index v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  void v47[2];
  uint64_t v48;
  unint64_t v49;

  uint64_t v9 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v41 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  unint64_t v42 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v41 - v14;
  uint64_t v16 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v16 = a1;
  }
  uint64_t v17 = 7;
  if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0) {
    uint64_t v17 = 11;
  }
  char v45 = v17;
  uint64_t v18 = v17 | (v16 << 16);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v4, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v20 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v46 = AssociatedTypeWitness;
  v20(&v48, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v49;
  if (v49)
  {
    Swift::String::Index v43 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    char v44 = a2 & 0xFFFFFFFFFFFFFFLL;
    while (1)
    {
      if (v18 < 0x4000)
      {
        swift_bridgeObjectRelease(v21);
        (*(void (**)(char *, const char *))(v42 + 8))(v15, v46);
        return 1;
      }
      uint64_t v22 = v48;
      v23._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)v18)._rawBits;
      Swift::UInt64 rawBits = v23._rawBits;
      if (!(v23._rawBits >> 14)) {
        break;
      }
      uint64_t v25 = v23._rawBits >> 16;
      if (v23._rawBits >= 0x20000)
      {
        if ((a2 & 0x1000000000000000) == 0)
        {
          if ((a2 & 0x2000000000000000) != 0)
          {
            v47[0] = a1;
            v47[1] = v44;
            uint64_t v29 = *(unsigned __int16 *)((char *)v47 + v25 - 2);
            if (v29 != 2573 && (v29 & 0x80808080) == 0) {
              goto LABEL_17;
            }
          }
          else
          {
            uint64_t v26 = (char *)v43;
            if ((a1 & 0x1000000000000000) == 0)
            {
              uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
              if (!v26) {
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
              }
            }
            uint64_t v27 = *(unsigned __int16 *)&v26[v25 - 2];
            if (v27 != 2573 && (v27 & 0x80808080) == 0)
            {
LABEL_17:
              uint64_t v25 = 1;
LABEL_18:
              uint64_t v28 = v25 << 8;
              goto LABEL_26;
            }
          }
        }
        uint64_t v25 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
      }
      uint64_t v28 = v25 << 8;
      if (v25 > 63) {
        uint64_t v28 = 0;
      }
LABEL_26:
      uint64_t v18 = v28 | v45 | (rawBits - (v25 << 16)) & 0xFFFFFFFFFFFF0000;
      v31._Swift::UInt64 rawBits = v18;
      uint64_t v32 = String.subscript.getter(v31, a1, a2);
      uint64_t v34 = v33;
      if (v22 == v32 && v21 == v33)
      {
        swift_bridgeObjectRelease(v21);
        swift_bridgeObjectRelease(v34);
      }
      else
      {
        if ((~v21 & 0x6000000000000000) == 0
          && (v33 & 0x2000000000000000) != 0
          && (v33 & 0x4000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v21);
          swift_bridgeObjectRelease(v34);
LABEL_44:
          (*(void (**)(char *, const char *))(v42 + 8))(v15, v46);
          return 0;
        }
        uint64_t v37 = _stringCompareInternal(_:_:expecting:)(v22, v21, v32, v33, 0);
        swift_bridgeObjectRelease(v21);
        swift_bridgeObjectRelease(v34);
        if ((v37 & 1) == 0) {
          goto LABEL_44;
        }
      }
      v20(&v48, v46, AssociatedConformanceWitness);
      uint64_t v21 = v49;
      if (!v49) {
        goto LABEL_42;
      }
    }
    if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringCharacterView.swift", 31, 2, 0x62uLL, 0);
    }
    uint64_t v25 = 0;
    goto LABEL_18;
  }
LABEL_42:
  (*(void (**)(char *, const char *))(v42 + 8))(v15, v46);
  if (v18 < 0x4000) {
    return 1;
  }
  v38._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)v18)._rawBits;
  String.subscript.getter(v38, a1, a2);
  swift_bridgeObjectRelease(v39);
  return 0;
}

uint64_t specialized Sequence<>.starts<A>(with:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  swift_bridgeObjectRetain(a2);
  swift_bridgeObjectRetain(a4);
  Swift::String_optional v6 = String.Iterator.next()();
  if (v6.value._object)
  {
    uint64_t countAndFlagsBits = v6.value._countAndFlagsBits;
    unint64_t object = (unint64_t)v6.value._object;
    do
    {
      Swift::String_optional v10 = String.Iterator.next()();
      if (!v10.value._object)
      {
        swift_bridgeObjectRelease(a2);
        swift_bridgeObjectRelease(a4);
        swift_bridgeObjectRelease(object);
        return 1;
      }
      if (countAndFlagsBits == v10.value._countAndFlagsBits && (void *)object == v10.value._object)
      {
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease((uint64_t)v10.value._object);
      }
      else
      {
        if ((~(object & (unint64_t)v10.value._object) & 0x6000000000000000) == 0)
        {
          swift_bridgeObjectRelease(object);
          swift_bridgeObjectRelease((uint64_t)v10.value._object);
LABEL_16:
          swift_bridgeObjectRelease(a2);
          uint64_t v13 = a4;
LABEL_17:
          swift_bridgeObjectRelease(v13);
          return 0;
        }
        char v11 = _stringCompareInternal(_:_:expecting:)(countAndFlagsBits, object, v10.value._countAndFlagsBits, (unint64_t)v10.value._object, 0);
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease((uint64_t)v10.value._object);
        if ((v11 & 1) == 0) {
          goto LABEL_16;
        }
      }
      Swift::String_optional v9 = String.Iterator.next()();
      uint64_t countAndFlagsBits = v9.value._countAndFlagsBits;
      unint64_t object = (unint64_t)v9.value._object;
    }
    while (v9.value._object);
  }
  swift_bridgeObjectRelease(a4);
  uint64_t v12 = String.Iterator.next()().value._object;
  swift_bridgeObjectRelease(a2);
  if (v12)
  {
    uint64_t v13 = (uint64_t)v12;
    goto LABEL_17;
  }
  return 1;
}

{
  uint64_t v6;
  uint64_t v7;
  Swift::UInt64 v8;
  uint64_t v9;
  uint64_t v10;
  Swift::UInt64 v11;
  Swift::String::Index v14;
  Swift::UInt64 rawBits;
  uint64_t v16;
  char *v17;
  char *v18;
  int v19;
  uint64_t v21;
  Swift::String::Index v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  Swift::String::Index v27;
  Swift::UInt64 v28;
  uint64_t v29;
  char *v30;
  char *v31;
  int v32;
  uint64_t v33;
  Swift::String::Index v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  Swift::String::Index v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;

  Swift::String_optional v6 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    Swift::String_optional v6 = a1;
  }
  if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0) {
    uint64_t v7 = 11;
  }
  else {
    uint64_t v7 = 7;
  }
  uint64_t v47 = v7;
  uint64_t v8 = v7 | (v6 << 16);
  Swift::String_optional v9 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000) == 0) {
    Swift::String_optional v9 = a3;
  }
  if (((a4 >> 60) & ((a3 & 0x800000000000000) == 0)) != 0) {
    Swift::String_optional v10 = 11;
  }
  else {
    Swift::String_optional v10 = 7;
  }
  char v11 = v10 | (v9 << 16);
  if (v11 >= 0x4000)
  {
    char v45 = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v46 = a4 & 0xFFFFFFFFFFFFFFLL;
    Swift::String::Index v43 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    char v44 = a2 & 0xFFFFFFFFFFFFFFLL;
    while (1)
    {
      v14._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)v11)._rawBits;
      Swift::UInt64 rawBits = v14._rawBits;
      if (!(v14._rawBits >> 14)) {
        break;
      }
      uint64_t v16 = v14._rawBits >> 16;
      if (v14._rawBits >= 0x20000)
      {
        if ((a4 & 0x1000000000000000) == 0)
        {
          if ((a4 & 0x2000000000000000) != 0)
          {
            uint64_t v48 = a3;
            uint64_t v49 = v46;
            uint64_t v18 = (char *)&v48 + v16;
          }
          else
          {
            uint64_t v17 = (char *)v45;
            if ((a3 & 0x1000000000000000) == 0)
            {
              uint64_t v17 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
              if (!v17) {
LABEL_61:
              }
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
            }
            uint64_t v18 = &v17[v16];
          }
          uint64_t v19 = *((unsigned __int16 *)v18 - 1);
          if (v19 != 2573 && (v19 & 0x80808080) == 0)
          {
            uint64_t v16 = 1;
LABEL_28:
            uint64_t v21 = v16 << 8;
            goto LABEL_34;
          }
        }
        uint64_t v16 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
      }
      uint64_t v21 = v16 << 8;
      if (v16 > 63) {
        uint64_t v21 = 0;
      }
LABEL_34:
      char v11 = v21 | v10 | (rawBits - (v16 << 16)) & 0xFFFFFFFFFFFF0000;
      v22._Swift::UInt64 rawBits = v11;
      uint64_t v23 = String.subscript.getter(v22, a3, a4);
      uint64_t v25 = v24;
      if (v8 < 0x4000)
      {
        uint64_t v39 = 1;
LABEL_63:
        swift_bridgeObjectRelease(v25);
        return v39;
      }
      uint64_t v26 = v23;
      v27._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)v8)._rawBits;
      uint64_t v28 = v27._rawBits;
      if (!(v27._rawBits >> 14))
      {
        if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
LABEL_69:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringCharacterView.swift", 31, 2, 0x62uLL, 0);
        uint64_t v29 = 0;
        goto LABEL_45;
      }
      uint64_t v29 = v27._rawBits >> 16;
      if (v27._rawBits >= 0x20000)
      {
        if ((a2 & 0x1000000000000000) == 0)
        {
          if ((a2 & 0x2000000000000000) != 0)
          {
            uint64_t v48 = a1;
            uint64_t v49 = v44;
            uint64_t v31 = (char *)&v48 + v29;
          }
          else
          {
            uint64_t v30 = (char *)v43;
            if ((a1 & 0x1000000000000000) == 0)
            {
              uint64_t v30 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
              if (!v30) {
                goto LABEL_61;
              }
            }
            uint64_t v31 = &v30[v29];
          }
          uint64_t v32 = *((unsigned __int16 *)v31 - 1);
          if (v32 != 2573 && (v32 & 0x80808080) == 0)
          {
            uint64_t v29 = 1;
LABEL_45:
            uint64_t v33 = v29 << 8;
            goto LABEL_51;
          }
        }
        uint64_t v29 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v28 >> 16);
      }
      uint64_t v33 = v29 << 8;
      if (v29 > 63) {
        uint64_t v33 = 0;
      }
LABEL_51:
      uint64_t v8 = v33 | v47 | (v28 - (v29 << 16)) & 0xFFFFFFFFFFFF0000;
      v34._Swift::UInt64 rawBits = v8;
      uint64_t v36 = String.subscript.getter(v34, a1, a2);
      uint64_t v37 = v35;
      if (v26 == v36 && v25 == v35)
      {
        swift_bridgeObjectRelease_n(v25, 2);
      }
      else
      {
        if ((~v25 & 0x6000000000000000) == 0
          && (v35 & 0x2000000000000000) != 0
          && (v35 & 0x4000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v25);
          uint64_t v39 = 0;
          uint64_t v25 = v37;
          goto LABEL_63;
        }
        uint64_t v38 = _stringCompareInternal(_:_:expecting:)(v26, v25, v36, v35, 0);
        swift_bridgeObjectRelease(v25);
        swift_bridgeObjectRelease(v37);
        if ((v38 & 1) == 0) {
          return 0;
        }
      }
      if (v11 < 0x4000) {
        goto LABEL_65;
      }
    }
    if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
      goto LABEL_69;
    }
    uint64_t v16 = 0;
    goto LABEL_28;
  }
LABEL_65:
  if (v8 >= 0x4000)
  {
    v41._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)v8)._rawBits;
    String.subscript.getter(v41, a1, a2);
    uint64_t v25 = v42;
    uint64_t v39 = 0;
    goto LABEL_63;
  }
  return 1;
}