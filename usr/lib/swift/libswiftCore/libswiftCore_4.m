Swift::String::Index __swiftcall Substring.UTF8View.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  Swift::UInt64 v8;
  unint64_t v9;
  uint64_t vars8;

  v4 = v3;
  v5 = v2;
  v7 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((_._rawBits & 0xC) == 4 << v7)
  {
    _._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
    if ((v4 & 0x1000000000000000) == 0)
    {
LABEL_5:
      v8 = offsetBy + (_._rawBits >> 16);
      if (__OFADD__(offsetBy, _._rawBits >> 16))
      {
        __break(1u);
      }
      else if ((v8 & 0x8000000000000000) == 0)
      {
        v9 = HIBYTE(v4) & 0xF;
        if ((v4 & 0x2000000000000000) == 0) {
          v9 = v5 & 0xFFFFFFFFFFFFLL;
        }
        if (v9 >= v8) {
          return (Swift::String::Index)((v8 << 16) | 4);
        }
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xA7uLL, 0);
    }
  }
  else if ((v3 & 0x1000000000000000) == 0)
  {
    goto LABEL_5;
  }

  return String.UTF8View._foreignIndex(_:offsetBy:)(_, offsetBy);
}

Swift::String::Index_optional __swiftcall Substring.UTF8View.index(_:offsetBy:limitedBy:)(Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  unint64_t v6 = v3;
  uint64_t v9 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((_._rawBits & 0xC) != 4 << v9)
  {
    if ((v4 & 0x1000000000000000) == 0) {
      goto LABEL_5;
    }
LABEL_19:
    Swift::String::Index_optional v13 = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
    v13.is_nil &= 1u;
    return v13;
  }
  _._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  if ((v5 & 0x1000000000000000) != 0) {
    goto LABEL_19;
  }
LABEL_5:
  Swift::UInt64 v10 = _._rawBits >> 16;
  int64_t v11 = (_._rawBits >> 16) + offsetBy;
  if (__OFADD__(_._rawBits >> 16, offsetBy))
  {
    __break(1u);
    goto LABEL_21;
  }
  Swift::UInt64 v12 = limitedBy._rawBits >> 16;
  if (offsetBy < 0)
  {
    if (v10 < v12 || v11 >= (uint64_t)v12) {
      goto LABEL_13;
    }
  }
  else if (v12 < v10 || (uint64_t)v12 >= v11)
  {
LABEL_13:
    if ((v11 & 0x8000000000000000) == 0)
    {
      unint64_t v14 = HIBYTE(v5) & 0xF;
      if ((v5 & 0x2000000000000000) == 0) {
        unint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
      }
      if (v14 >= v11)
      {
        v13.is_nil = 0;
        v13.value._rawBits = (v11 << 16) | 4;
        return v13;
      }
    }
LABEL_21:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xC0uLL, 0);
  }
  v13.value._rawBits = 0;
  v13.is_nil = 1;
  return v13;
}

Swift::Int __swiftcall Substring.UTF8View.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  Swift::UInt64 rawBits = from._rawBits;
  uint64_t v8 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4 << v8;
  if ((from._rawBits & 0xC) == 4 << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(from)._rawBits;
  }
  if ((to._rawBits & 0xC) == v9)
  {
    to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
    if ((v4 & 0x1000000000000000) == 0) {
      return (to._rawBits >> 16) - (rawBits >> 16);
    }
  }
  else if ((v4 & 0x1000000000000000) == 0)
  {
    return (to._rawBits >> 16) - (rawBits >> 16);
  }
  unint64_t v11 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    unint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < rawBits >> 16 || v11 < to._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xCFuLL, 0);
  }

  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, to);
}

uint64_t Substring.UTF8View.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t)@<X0>, Swift::UInt64 a2@<X2>, Swift::UInt64 a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  return _ss5SliceV32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys5UInt8Vqd__Isgyrzo_ABySS8UTF8ViewVGADsAI_pAMRszr__lIetMggrzo_Tpq5(a1, a2, a3, a4, a5, a6, a7);
}

unint64_t Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(unint64_t a1, unint64_t a2, unint64_t a3)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3);
}

unint64_t Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4);
}

Swift::String::Index __swiftcall Substring.UTF8View.index(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((before._rawBits & 0xC) != 4 << v5)
  {
    if (before._rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_8:
    unint64_t v7 = 152;
    goto LABEL_9;
  }
  before._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(before)._rawBits;
  if (!(before._rawBits >> 14)) {
    goto LABEL_8;
  }
LABEL_5:
  if ((v3 & 0x1000000000000000) == 0) {
    return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000) - 65532);
  }
  Swift::UInt64 v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    Swift::UInt64 v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 < before._rawBits >> 16)
  {
    unint64_t v7 = 157;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v7, 0);
  }

  return String.UTF8View._foreignIndex(before:)(before);
}

Swift::Void __swiftcall Substring.UTF8View.formIndex(before:)(Swift::String::Index *before)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  Swift::UInt64 rawBits = before->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) != 4 << v7)
  {
    if (rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_9:
    unint64_t v9 = 152;
    goto LABEL_10;
  }
  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if (!(rawBits >> 14)) {
    goto LABEL_9;
  }
LABEL_5:
  if ((v3 & 0x1000000000000000) != 0)
  {
    unint64_t v10 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000) == 0) {
      unint64_t v10 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v10 >= rawBits >> 16)
    {
      unint64_t v8 = String.UTF8View._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
      goto LABEL_7;
    }
    unint64_t v9 = 157;
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v9, 0);
  }
  unint64_t v8 = (rawBits & 0xFFFFFFFFFFFF0000) - 65532;
LABEL_7:
  before->_Swift::UInt64 rawBits = v8;
}

Swift::UInt64 Substring.UTF16View.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 v6 = specialized Substring.UTF8View.subscript.getter(a1, a2, a3, a4, a5, a6);
  swift_bridgeObjectRetain(v7);
  return v6;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(before:) in conformance Substring.UTF8View@<X0>(Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF8View.index(before:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

void protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring.UTF8View(Swift::String::Index *before)
{
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring.UTF8View@<X0>(Swift::Int offsetBy@<X1>, Swift::UInt64 *a2@<X0>, Swift::UInt64 *a3@<X8>)
{
  Swift::UInt64 rawBits = *a2;
  unint64_t v8 = *(void *)(v3 + 16);
  unint64_t v7 = *(void *)(v3 + 24);
  uint64_t v9 = (v8 >> 59) & 1;
  if ((v7 & 0x1000000000000000) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((rawBits & 0xC) != 4 << v9)
  {
    if ((v7 & 0x1000000000000000) == 0) {
      goto LABEL_5;
    }
LABEL_13:
    Swift::UInt64 result = String.UTF8View._foreignIndex(_:offsetBy:)((Swift::String::Index)rawBits, offsetBy)._rawBits;
    goto LABEL_11;
  }
  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if ((v7 & 0x1000000000000000) != 0) {
    goto LABEL_13;
  }
LABEL_5:
  unint64_t v10 = offsetBy + (rawBits >> 16);
  if (__OFADD__(offsetBy, rawBits >> 16))
  {
    __break(1u);
    goto LABEL_15;
  }
  if ((v10 & 0x8000000000000000) != 0) {
    goto LABEL_15;
  }
  unint64_t v11 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000) == 0) {
    unint64_t v11 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < v10) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xA7uLL, 0);
  Swift::UInt64 result = (v10 << 16) | 4;
LABEL_11:
  *a3 = result;
  return result;
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View@<X0>(Swift::Int offsetBy@<X1>, Swift::UInt64 *a2@<X0>, Swift::UInt64 *a3@<X2>, uint64_t a4@<X8>)
{
  Swift::UInt64 rawBits = *a2;
  v8._Swift::UInt64 rawBits = *a3;
  unint64_t v10 = *(void *)(v4 + 16);
  unint64_t v9 = *(void *)(v4 + 24);
  uint64_t v11 = (v10 >> 59) & 1;
  if ((v9 & 0x1000000000000000) == 0) {
    LOBYTE(v11) = 1;
  }
  if ((rawBits & 0xC) != 4 << v11)
  {
    if ((v9 & 0x1000000000000000) == 0) {
      goto LABEL_5;
    }
LABEL_20:
    Swift::String::Index_optional v15 = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)((Swift::String::Index)rawBits, offsetBy, v8);
    Swift::Bool is_nil = v15.is_nil;
    goto LABEL_18;
  }
  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if ((v9 & 0x1000000000000000) != 0) {
    goto LABEL_20;
  }
LABEL_5:
  Swift::UInt64 v12 = rawBits >> 16;
  int64_t v13 = (rawBits >> 16) + offsetBy;
  if (__OFADD__(rawBits >> 16, offsetBy))
  {
    __break(1u);
    goto LABEL_22;
  }
  Swift::UInt64 v14 = v8._rawBits >> 16;
  if (offsetBy < 0)
  {
    if (v12 < v14 || v13 >= (uint64_t)v14) {
      goto LABEL_13;
    }
  }
  else if (v14 < v12 || (uint64_t)v14 >= v13)
  {
LABEL_13:
    if ((v13 & 0x8000000000000000) == 0)
    {
      unint64_t v17 = HIBYTE(v9) & 0xF;
      if ((v9 & 0x2000000000000000) == 0) {
        unint64_t v17 = v10 & 0xFFFFFFFFFFFFLL;
      }
      if (v17 >= v13)
      {
        Swift::Bool is_nil = 0;
        v15.value._Swift::UInt64 rawBits = (v13 << 16) | 4;
        goto LABEL_18;
      }
    }
LABEL_22:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xC0uLL, 0);
  }
  v15.value._Swift::UInt64 rawBits = 0;
  Swift::Bool is_nil = 1;
LABEL_18:
  *(void *)a4 = v15.value._rawBits;
  *(unsigned char *)(a4 + 8) = is_nil;
  return v15.value._rawBits;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring.UTF8View(unsigned char *a1, Swift::UInt64 *a2))()
{
  *a1 = Substring.UTF8View.subscript.getter(*a2, *(void *)v2, *(void *)(v2 + 8), *(void *)(v2 + 16), *(void *)(v2 + 24));
  return EnumeratedSequence._base.modify;
}

unint64_t protocol witness for Collection.subscript.getter in conformance Substring.UTF16View@<X0>(Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  v4._Swift::UInt64 rawBits = a1[1];
  v5._Swift::UInt64 rawBits = *a1;
  *a2 = specialized Substring.UTF8View.subscript.getter(v5, v4, *(void *)v2, *(void *)(v2 + 8), *(void *)(v2 + 16), *(void *)(v2 + 24));
  a2[1] = v6;
  a2[2] = v8;
  a2[3] = v7;

  return swift_bridgeObjectRetain(v7);
}

Swift::Int protocol witness for Collection.count.getter in conformance Substring.UTF8View()
{
  v1._Swift::UInt64 rawBits = *v0;
  v2._Swift::UInt64 rawBits = v0[1];
  return specialized Collection.count.getter(v1, v2, v0[2], v0[3]);
}

Swift::String::Index protocol witness for Collection.index(_:offsetBy:) in conformance Substring.UTF8View@<X0>(Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF8View.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, void, uint64_t, uint64_t, void, void))Substring.UTF8View.index(_:offsetBy:limitedBy:), a6);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring.UTF8View(Swift::String::Index *a1, Swift::UInt64 *a2)
{
  Swift::UInt64 rawBits = a1->_rawBits;
  Swift::UInt64 v4 = *a2;
  unint64_t v5 = *(void *)(v2 + 16);
  unint64_t v6 = *(void *)(v2 + 24);
  uint64_t v7 = (v5 >> 59) & 1;
  if ((v6 & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = 4 << v7;
  if ((a1->_rawBits & 0xC) == 4 << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  }
  if ((v4 & 0xC) == v8)
  {
    Swift::UInt64 v4 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v4)._rawBits;
    if ((v6 & 0x1000000000000000) == 0) {
      return (v4 >> 16) - (rawBits >> 16);
    }
  }
  else if ((v6 & 0x1000000000000000) == 0)
  {
    return (v4 >> 16) - (rawBits >> 16);
  }
  unint64_t v10 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000) == 0) {
    unint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v10 < rawBits >> 16 || v10 < v4 >> 16) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0xCFuLL, 0);
  }

  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, (Swift::String::Index)v4);
}

Swift::String::Index protocol witness for Collection.index(after:) in conformance Substring.UTF8View@<X0>(Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF8View.index(after:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

Swift::UInt64 protocol witness for Collection.formIndex(after:) in conformance Substring.UTF8View(Swift::UInt64 *a1)
{
  unint64_t v4 = *(void *)(v1 + 16);
  unint64_t v3 = *(void *)(v1 + 24);
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = (v4 >> 59) & 1;
  if ((v3 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4 << v6)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if ((v3 & 0x1000000000000000) == 0) {
      goto LABEL_5;
    }
  }
  else if ((v3 & 0x1000000000000000) == 0)
  {
LABEL_5:
    Swift::UInt64 result = (rawBits & 0xFFFFFFFFFFFF0000) + 65540;
    goto LABEL_6;
  }
  unint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 <= rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, 0x90uLL, 0);
  }
  Swift::UInt64 result = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_6:
  *a1 = result;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring.UTF8View(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring(a1, a2, (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring.UTF8View@<X0>(uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return Substring.UTF8View.withContiguousStorageIfAvailable<A>(_:)(a1, *(void *)v3, *(void *)(v3 + 8), *(void *)(v3 + 16), *(void *)(v3 + 24), a2, a3);
}

Swift::UInt64 Substring.init(_:)(Swift::String::Index a1, Swift::String::Index a2)
{
  return specialized Substring.init(_:)(a1, a2);
}

uint64_t (*Substring.utf8.modify(void *a1))()
{
  uint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4);
  return Substring.utf8.modify;
}

uint64_t (*Substring.UTF16View._slice.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Substring.UTF16View.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v10 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000) == 0) {
    LOBYTE(v10) = 1;
  }
  if ((a1._rawBits & 0xC) == 4 << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (rawBits >> 14 < a2 >> 14 || rawBits >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/Substring.swift", 21, 2, 0x33FuLL, 0);
  }
  if ((a5 & 0x1000000000000000) == 0)
  {
    if (rawBits)
    {
      uint64_t v11 = rawBits >> 16;
      if ((a5 & 0x2000000000000000) == 0) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v11 = (_StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2 | 1) >> 16;
      if ((a5 & 0x2000000000000000) == 0)
      {
LABEL_10:
        if ((a4 & 0x1000000000000000) != 0) {
          Swift::UInt64 v12 = (void *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          Swift::UInt64 v12 = _StringObject.sharedUTF8.getter(a4, a5);
        }
LABEL_18:
        uint64_t v14 = _decodeScalar(_:startingAt:)((uint64_t)v12, a2, v11);
        if ((rawBits & 0xC000) == 0x4000)
        {
          if (!WORD1(v14)) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UTF16.swift", 17, 2, 0x5BuLL, 0);
          }
          return v14 & 0x3FF | 0xFFFFDC00;
        }
        if (WORD1(v14))
        {
          uint64_t v15 = (unsigned __int16)((v14 + 67043328) >> 10) + 55296;
          if ((v15 & 0x10000) == 0) {
            return v15;
          }
          __break(1u);
        }
        return v14;
      }
    }
    v16[0] = a4;
    v16[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    Swift::UInt64 v12 = v16;
    goto LABEL_18;
  }

  return String.UTF16View._foreignSubscript(position:)((Swift::String::Index)rawBits);
}

Swift::String::Index __swiftcall Substring.UTF16View.index(after:)(Swift::String::Index after)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((after._rawBits & 0xC) == 4 << v5) {
    after._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(after)._rawBits;
  }
  Swift::UInt64 v6 = after._rawBits >> 16;
  unint64_t v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 >= v7) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF16View.swift", 27, 2, 0x93uLL, 0);
  }
  if ((v3 & 0x1000000000000000) == 0)
  {
    uint64_t v8 = (v3 >> 62) & 1;
    if ((v3 & 0x2000000000000000) == 0) {
      LOBYTE(v8) = v4 < 0;
    }
    if (v8) {
      return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000) + 65549);
    }
    if ((after._rawBits & 0xC001) != 0)
    {
      if ((v3 & 0x2000000000000000) == 0) {
        goto LABEL_15;
      }
    }
    else
    {
      Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(after)._rawBits;
      after._Swift::UInt64 rawBits = rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
      Swift::UInt64 v6 = rawBits >> 16;
      if ((v3 & 0x2000000000000000) == 0)
      {
LABEL_15:
        if ((v4 & 0x1000000000000000) != 0)
        {
          LODWORD(v10) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v6);
          if ((v10 & 0x80) != 0)
          {
LABEL_26:
            LODWORD(v10) = __clz(v10 ^ 0xFF) - 24;
            if (v10 == 4)
            {
              if ((after._rawBits & 0xC000) == 0)
              {
                unsigned __int16 v14 = 16388;
                return (Swift::String::Index)(after._rawBits & 0xFFFFFFFFFFFF0000 | v14);
              }
              uint64_t v10 = 4;
            }
            else
            {
              uint64_t v10 = v10;
            }
LABEL_30:
            after._rawBits += v10 << 16;
            unsigned __int16 v14 = 5;
            return (Swift::String::Index)(after._rawBits & 0xFFFFFFFFFFFF0000 | v14);
          }
        }
        else
        {
          Swift::UInt64 v15 = after._rawBits;
          uint64_t v12 = v3;
          Swift::UInt64 v13 = v6;
          uint64_t v10 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v12);
          after._Swift::UInt64 rawBits = v15;
          LODWORD(v10) = *(unsigned __int8 *)(v10 + v13);
          if ((v10 & 0x80) != 0) {
            goto LABEL_26;
          }
        }
LABEL_24:
        uint64_t v10 = 1;
        goto LABEL_30;
      }
    }
    v16[0] = v4;
    v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v10) = *((unsigned __int8 *)v16 + v6);
    if ((v10 & 0x80) != 0) {
      goto LABEL_26;
    }
    goto LABEL_24;
  }

  return (Swift::String::Index)specialized String.UTF16View._foreignIndex(after:)(after._rawBits);
}

Swift::Void __swiftcall Substring.UTF16View.formIndex(after:)(Swift::String::Index *after)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 rawBits = after->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4 << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v8 = rawBits >> 16;
  unint64_t v9 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    unint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 >= v9) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF16View.swift", 27, 2, 0x93uLL, 0);
  }
  if ((v3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 v11 = specialized String.UTF16View._foreignIndex(after:)(rawBits);
    goto LABEL_29;
  }
  uint64_t v10 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000) == 0) {
    LOBYTE(v10) = v4 < 0;
  }
  if ((v10 & 1) == 0)
  {
    if ((rawBits & 0xC001) != 0)
    {
      if ((v3 & 0x2000000000000000) == 0)
      {
LABEL_15:
        if ((v4 & 0x1000000000000000) != 0)
        {
          LODWORD(v12) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v8);
          if ((v12 & 0x80) != 0) {
            goto LABEL_17;
          }
LABEL_26:
          uint64_t v12 = 1;
          goto LABEL_27;
        }
        Swift::UInt64 v17 = rawBits;
        uint64_t v15 = v3;
        Swift::UInt64 v16 = v8;
        uint64_t v12 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v15);
        Swift::UInt64 rawBits = v17;
        LODWORD(v12) = *(unsigned __int8 *)(v12 + v16);
        if ((v12 & 0x80) == 0) {
          goto LABEL_26;
        }
LABEL_17:
        LODWORD(v12) = __clz(v12 ^ 0xFF) - 24;
        if (v12 == 4)
        {
          if ((rawBits & 0xC000) == 0)
          {
            unsigned __int16 v13 = 16388;
LABEL_28:
            Swift::UInt64 v11 = rawBits & 0xFFFFFFFFFFFF0000 | v13;
            goto LABEL_29;
          }
          uint64_t v12 = 4;
        }
        else
        {
          uint64_t v12 = v12;
        }
LABEL_27:
        rawBits += v12 << 16;
        unsigned __int16 v13 = 5;
        goto LABEL_28;
      }
    }
    else
    {
      Swift::UInt64 v14 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v14 & 0xFFFFFFFFFFFFFFF2 | 1;
      Swift::UInt64 v8 = v14 >> 16;
      if ((v3 & 0x2000000000000000) == 0) {
        goto LABEL_15;
      }
    }
    v18[0] = v4;
    v18[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v12) = *((unsigned __int8 *)v18 + v8);
    if ((v12 & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }
  Swift::UInt64 v11 = (rawBits & 0xFFFFFFFFFFFF0000) + 65549;
LABEL_29:
  after->_Swift::UInt64 rawBits = v11;
}

Swift::String::Index __swiftcall Substring.UTF16View.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  return String.UTF16View.index(_:offsetBy:)(_, offsetBy);
}

Swift::String::Index_optional __swiftcall Substring.UTF16View.index(_:offsetBy:limitedBy:)(Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  Swift::String::Index_optional v3 = String.UTF16View.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
  v3.is_nil &= 1u;
  return v3;
}

Swift::Int __swiftcall Substring.UTF16View.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  return String.UTF16View.distance(from:to:)(from, to);
}

unint64_t Substring.UTF16View._failEarlyRangeCheck(_:bounds:)(unint64_t a1, unint64_t a2, unint64_t a3)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3);
}

unint64_t Substring.UTF16View._failEarlyRangeCheck(_:bounds:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4);
}

Swift::String::Index __swiftcall Substring.UTF16View.index(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((before._rawBits & 0xC) == 4 << v5)
  {
    before._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(before)._rawBits;
    if (before._rawBits < 0x4000) {
      goto LABEL_26;
    }
  }
  else if (before._rawBits < 0x4000)
  {
    goto LABEL_26;
  }
  unint64_t v6 = HIBYTE(v3) & 0xF;
  uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000) != 0) {
    uint64_t v8 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v8 < before._rawBits >> 14) {
LABEL_26:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF16View.swift", 27, 2, 0xAFuLL, 0);
  if ((v3 & 0x1000000000000000) != 0)
  {
    return (Swift::String::Index)specialized String.UTF16View._foreignIndex(before:)(before._rawBits);
  }
  else
  {
    uint64_t v9 = (v3 >> 62) & 1;
    if ((v3 & 0x2000000000000000) == 0) {
      LOBYTE(v9) = v4 < 0;
    }
    if (v9) {
      return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000) - 65523);
    }
    if ((before._rawBits & 0xC000) != 0) {
      return (Swift::String::Index)(before._rawBits & 0xFFFFFFFFFFFF0000 | 5);
    }
    if (before._rawBits)
    {
      Swift::UInt64 v11 = before._rawBits >> 16;
      if ((v3 & 0x2000000000000000) == 0) {
        goto LABEL_18;
      }
    }
    else
    {
      Swift::UInt64 rawBits = v4 & 0xFFFFFFFFFFFFLL;
      v15._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(before)._rawBits;
      unint64_t v6 = HIBYTE(v3) & 0xF;
      uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
      before._Swift::UInt64 rawBits = v15._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
      Swift::UInt64 v11 = before._rawBits >> 16;
      if ((v3 & 0x2000000000000000) == 0)
      {
LABEL_18:
        if ((v4 & 0x1000000000000000) != 0)
        {
          uint64_t v12 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if (before._rawBits >= 0x10000) {
            goto LABEL_20;
          }
        }
        else
        {
          Swift::UInt64 rawBits = before._rawBits;
          uint64_t v17 = v3;
          Swift::UInt64 v18 = v11;
          id v19 = _StringObject.sharedUTF8.getter(v4, v17);
          Swift::UInt64 v11 = v18;
          uint64_t v12 = (uint64_t)v19;
          before._Swift::UInt64 rawBits = rawBits;
          if (rawBits >= 0x10000)
          {
LABEL_20:
            uint64_t v13 = 0;
            uint64_t v14 = v11 + v12 - 1;
            while ((uint64_t)v11 <= v7)
            {
              if ((*(unsigned char *)(v14 + v13) & 0xC0) != 0x80) {
                goto LABEL_37;
              }
              if (-(uint64_t)v11 == --v13) {
                goto LABEL_36;
              }
            }
LABEL_40:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
          }
        }
LABEL_36:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
      }
    }
    v21[0] = v4;
    v21[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    if (before._rawBits < 0x10000) {
      goto LABEL_36;
    }
    uint64_t v13 = 0;
    while (1)
    {
      if (v11 > v6) {
        goto LABEL_40;
      }
      if ((*((unsigned char *)v21 + v11 + v13 - 1) & 0xC0) != 0x80) {
        break;
      }
      --v13;
      if (!(v11 + v13)) {
        goto LABEL_36;
      }
    }
LABEL_37:
    uint64_t v16 = ((v11 - (1 - v13)) << 16) | 5;
    if (v13 == -3) {
      return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000) - 245756);
    }
    else {
      return (Swift::String::Index)v16;
    }
  }
}

Swift::Void __swiftcall Substring.UTF16View.formIndex(before:)(Swift::String::Index *before)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 rawBits = before->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4 << v7)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if (rawBits < 0x4000) {
      goto LABEL_26;
    }
  }
  else if (rawBits < 0x4000)
  {
    goto LABEL_26;
  }
  unint64_t v8 = HIBYTE(v3) & 0xF;
  uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000) != 0) {
    uint64_t v10 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v10 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v10 < rawBits >> 14) {
LABEL_26:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF16View.swift", 27, 2, 0xAFuLL, 0);
  if ((v3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 v12 = specialized String.UTF16View._foreignIndex(before:)(rawBits);
    goto LABEL_38;
  }
  uint64_t v11 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000) == 0) {
    LOBYTE(v11) = v4 < 0;
  }
  if (v11)
  {
    Swift::UInt64 v12 = (rawBits & 0xFFFFFFFFFFFF0000) - 65523;
    goto LABEL_38;
  }
  if ((rawBits & 0xC000) != 0)
  {
    Swift::UInt64 v12 = rawBits & 0xFFFFFFFFFFFF0000 | 5;
    goto LABEL_38;
  }
  if (rawBits)
  {
    Swift::UInt64 v13 = rawBits >> 16;
    if ((v3 & 0x2000000000000000) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v22 = v4 & 0xFFFFFFFFFFFFLL;
    v17._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    unint64_t v8 = HIBYTE(v3) & 0xF;
    uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
    Swift::UInt64 rawBits = v17._rawBits & 0xFFFFFFFFFFFFFFF2 | 1;
    Swift::UInt64 v13 = rawBits >> 16;
    if ((v3 & 0x2000000000000000) == 0)
    {
LABEL_18:
      if ((v4 & 0x1000000000000000) != 0)
      {
        uint64_t v14 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if (rawBits >= 0x10000) {
          goto LABEL_20;
        }
      }
      else
      {
        unint64_t v22 = rawBits;
        uint64_t v19 = v3;
        Swift::UInt64 v20 = v13;
        id v21 = _StringObject.sharedUTF8.getter(v4, v19);
        Swift::UInt64 v13 = v20;
        uint64_t v14 = (uint64_t)v21;
        Swift::UInt64 rawBits = v22;
        if (v22 >= 0x10000)
        {
LABEL_20:
          uint64_t v15 = 0;
          uint64_t v16 = v13 + v14 - 1;
          while ((uint64_t)v13 <= v9)
          {
            if ((*(unsigned char *)(v16 + v15) & 0xC0) != 0x80) {
              goto LABEL_35;
            }
            if (-(uint64_t)v13 == --v15) {
              goto LABEL_34;
            }
          }
LABEL_39:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
        }
      }
LABEL_34:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
    }
  }
  v23[0] = v4;
  v23[1] = v3 & 0xFFFFFFFFFFFFFFLL;
  if (rawBits < 0x10000) {
    goto LABEL_34;
  }
  uint64_t v15 = 0;
  while (1)
  {
    if (v13 > v8) {
      goto LABEL_39;
    }
    if ((*((unsigned char *)v23 + v13 + v15 - 1) & 0xC0) != 0x80) {
      break;
    }
    --v15;
    if (!(v13 + v15)) {
      goto LABEL_34;
    }
  }
LABEL_35:
  uint64_t v18 = ((v13 - (1 - v15)) << 16) | 5;
  if (v15 == -3) {
    Swift::UInt64 v12 = (rawBits & 0xFFFFFFFFFFFF0000) - 245756;
  }
  else {
    Swift::UInt64 v12 = v18;
  }
LABEL_38:
  before->_Swift::UInt64 rawBits = v12;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(before:) in conformance Substring.UTF16View@<X0>(Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF16View.index(before:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

void protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring.UTF16View(Swift::String::Index *before)
{
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring.UTF16View@<X0>(Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View(a1, a2, a3, (uint64_t (*)(void, uint64_t, void, void, void))String.UTF16View.index(_:offsetBy:limitedBy:), a4);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring.UTF16View(Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.UTF16View.distance(from:to:)((Swift::String::Index)a1->_rawBits, (Swift::String::Index)a2->_rawBits);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring.UTF16View(_WORD *a1, Swift::UInt64 *a2))()
{
  v4._Swift::UInt64 rawBits = *a2;
  *a1 = Substring.UTF16View.subscript.getter(v4, *(void *)v2, *(void *)(v2 + 8), *(void *)(v2 + 16), *(void *)(v2 + 24));
  return EnumeratedSequence._base.modify;
}

Swift::String::Index protocol witness for Collection.index(after:) in conformance Substring.UTF16View@<X0>(Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF16View.index(after:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

unint64_t protocol witness for Collection.formIndex(after:) in conformance Substring.UTF16View(Swift::UInt64 *a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  unint64_t v3 = *(void *)(v1 + 24);
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = ((unint64_t)v4 >> 59) & 1;
  if ((v3 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4 << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v7 = rawBits >> 16;
  unint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= v8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF16View.swift", 27, 2, 0x93uLL, 0);
  }
  if ((v3 & 0x1000000000000000) != 0)
  {
    unint64_t result = specialized String.UTF16View._foreignIndex(after:)(rawBits);
    goto LABEL_29;
  }
  uint64_t v9 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000) == 0) {
    LOBYTE(v9) = v4 < 0;
  }
  if ((v9 & 1) == 0)
  {
    if ((rawBits & 0xC001) != 0)
    {
      if ((v3 & 0x2000000000000000) == 0)
      {
LABEL_15:
        if ((v4 & 0x1000000000000000) != 0)
        {
          LODWORD(v11) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v7);
          if ((v11 & 0x80) != 0) {
            goto LABEL_17;
          }
LABEL_26:
          uint64_t v11 = 1;
          goto LABEL_27;
        }
        Swift::UInt64 v14 = rawBits;
        uint64_t v11 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v3);
        Swift::UInt64 rawBits = v14;
        LODWORD(v11) = *(unsigned __int8 *)(v11 + v7);
        if ((v11 & 0x80) == 0) {
          goto LABEL_26;
        }
LABEL_17:
        LODWORD(v11) = __clz(v11 ^ 0xFF) - 24;
        if (v11 == 4)
        {
          if ((rawBits & 0xC000) == 0)
          {
            unsigned __int16 v12 = 16388;
LABEL_28:
            unint64_t result = rawBits & 0xFFFFFFFFFFFF0000 | v12;
            goto LABEL_29;
          }
          uint64_t v11 = 4;
        }
        else
        {
          uint64_t v11 = v11;
        }
LABEL_27:
        rawBits += v11 << 16;
        unsigned __int16 v12 = 5;
        goto LABEL_28;
      }
    }
    else
    {
      Swift::UInt64 v13 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v13 & 0xFFFFFFFFFFFFFFF2 | 1;
      Swift::UInt64 v7 = v13 >> 16;
      if ((v3 & 0x2000000000000000) == 0) {
        goto LABEL_15;
      }
    }
    v15[0] = v4;
    v15[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v11) = *((unsigned __int8 *)v15 + v7);
    if ((v11 & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }
  unint64_t result = (rawBits & 0xFFFFFFFFFFFF0000) + 65549;
LABEL_29:
  *a1 = result;
  return result;
}

Swift::Int protocol witness for Collection.count.getter in conformance Substring.UTF16View()
{
  return String.UTF16View.distance(from:to:)((Swift::String::Index)v0->_rawBits, v0[1]);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring.UTF16View(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring(a1, a2, (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))&specialized Sequence._copySequenceContents(initializing:));
}

Swift::UInt64 key path setter for Substring.utf8 : Substring(Swift::UInt64 *a1, Swift::UInt64 *a2)
{
  Swift::UInt64 v3 = *a1;
  Swift::UInt64 v4 = a1[1];
  uint64_t v5 = a2[3];
  swift_bridgeObjectRetain(a1[3]);
  swift_bridgeObjectRelease(v5);
  v6._Swift::UInt64 rawBits = v3;
  v7._Swift::UInt64 rawBits = v4;
  Swift::UInt64 result = specialized Substring.init(_:)(v6, v7);
  *a2 = result;
  a2[1] = v9;
  a2[2] = v10;
  a2[3] = v11;
  return result;
}

void Substring.utf8.setter(Swift::UInt64 a1, Swift::UInt64 a2, Swift::UInt64 a3, Swift::UInt64 a4)
{
  swift_bridgeObjectRelease(v4[3]);
  if ((a1 & 1) == 0)
  {
    a1 = a1 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)a1)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    a2 = a2 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)a2)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    goto LABEL_3;
  }
  if ((a2 & 1) == 0) {
    goto LABEL_5;
  }
LABEL_3:
  *Swift::UInt64 v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

uint64_t (*Substring.utf16.modify(void *a1))()
{
  Swift::UInt64 v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)Swift::UInt64 v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4);
  return Substring.utf8.modify;
}

void Substring.utf8.modify(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = (*a1)[3];
  uint64_t v3 = (*a1)[4];
  Swift::UInt64 v5 = **a1;
  Swift::UInt64 v6 = (*a1)[1];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = *(void *)(v3 + 24);
  if (a2)
  {
    swift_bridgeObjectRetain((*a1)[3]);
    swift_bridgeObjectRelease(v8);
    if (v5)
    {
      if (v6)
      {
LABEL_4:
        Swift::UInt64 v9 = (Swift::UInt64 *)v2[4];
        *Swift::UInt64 v9 = v5;
        v9[1] = v6;
        v9[2] = v7;
        v9[3] = v4;
        swift_bridgeObjectRelease(v2[3]);
        goto LABEL_8;
      }
    }
    else
    {
      Swift::UInt64 v5 = v5 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v5)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      if (v6) {
        goto LABEL_4;
      }
    }
    Swift::UInt64 v6 = v6 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v6)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    goto LABEL_4;
  }
  swift_bridgeObjectRelease(*(void *)(v3 + 24));
  if ((v5 & 1) == 0)
  {
    Swift::UInt64 v5 = v5 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v5)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (v6) {
      goto LABEL_7;
    }
LABEL_14:
    Swift::UInt64 v6 = v6 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v6)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    goto LABEL_7;
  }
  if ((v6 & 1) == 0) {
    goto LABEL_14;
  }
LABEL_7:
  Swift::UInt64 v10 = (Swift::UInt64 *)v2[4];
  *Swift::UInt64 v10 = v5;
  v10[1] = v6;
  v10[2] = v7;
  v10[3] = v4;
LABEL_8:

  free(v2);
}

uint64_t String.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  v7._Swift::UInt64 rawBits = a1._rawBits;
  if (!_StringGuts.isOnUnicodeScalarBoundary(_:)(a1) || !_StringGuts.isOnUnicodeScalarBoundary(_:)(a2))
  {
    swift_bridgeObjectRelease(a4);
    return 0;
  }
  if ((v7._rawBits & 1) == 0)
  {
    v7._Swift::UInt64 rawBits = v7._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v7)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (a2._rawBits) {
      goto LABEL_5;
    }
LABEL_9:
    a2._Swift::UInt64 rawBits = a2._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a2)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    goto LABEL_5;
  }
  if ((a2._rawBits & 1) == 0) {
    goto LABEL_9;
  }
LABEL_5:
  v8._Swift::UInt64 rawBits = v7._rawBits;
  v9._Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v10 = specialized String.init(_:)(v8, v9, a3, a4);
  swift_bridgeObjectRelease(a4);
  return v10;
}

{
  uint64_t v5;

  Swift::UInt64 v5 = specialized String.init(_:)(a1, a2, a3, a4);
  swift_bridgeObjectRelease(a4);
  return v5;
}

uint64_t Substring.UnicodeScalarView._slice.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a1;
}

void Substring.UnicodeScalarView._slice.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  swift_bridgeObjectRelease(v4[3]);
  *uint64_t v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

uint64_t (*Substring.UnicodeScalarView._slice.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 Substring.UnicodeScalarView.init(_:_bounds:)(int a1, int a2, Swift::String::Index a3, Swift::String::Index a4)
{
  Swift::UInt64 rawBits = a3._rawBits;
  if ((a3._rawBits & 1) == 0)
  {
    Swift::UInt64 rawBits = a3._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a3)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (a4._rawBits) {
      return rawBits;
    }
LABEL_5:
    _StringGuts.scalarAlignSlow(_:)(a4)._rawBits;
    return rawBits;
  }
  if ((a4._rawBits & 1) == 0) {
    goto LABEL_5;
  }
  return rawBits;
}

uint64_t Substring.UnicodeScalarView.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t Substring.UnicodeScalarView.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  v7._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(a1, a2, a3, a4, a5)._rawBits;
  if ((a5 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 v12 = v7._rawBits & 0xFFFFFFFFFFFF0000;
    return *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)v12);
  }
  else
  {
    Swift::UInt64 v9 = v7._rawBits >> 16;
    if ((a5 & 0x2000000000000000) != 0)
    {
      v13[0] = a4;
      v13[1] = a5 & 0xFFFFFFFFFFFFFFLL;
      return _decodeScalar(_:startingAt:)((uint64_t)v13, v8._rawBits, v9);
    }
    else
    {
      if ((a4 & 0x1000000000000000) != 0) {
        id v10 = (id)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        id v10 = _StringObject.sharedUTF8.getter(a4, a5);
      }
      return _decodeScalar(_:startingAt:)((uint64_t)v10, v8._rawBits, v9);
    }
  }
}

uint64_t Substring.UnicodeScalarView.indices.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a3;
}

Swift::String::Index __swiftcall Substring.UnicodeScalarView.index(after:)(Swift::String::Index after)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(after)._rawBits;
  if ((v3 & 0x1000000000000000) != 0)
  {
    return String.UnicodeScalarView._foreignIndex(after:)(v5);
  }
  else
  {
    Swift::UInt64 v6 = v5._rawBits >> 16;
    if ((v3 & 0x2000000000000000) != 0)
    {
      v12[0] = v4;
      v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int v8 = *((unsigned __int8 *)v12 + v6);
    }
    else
    {
      if ((v4 & 0x1000000000000000) != 0) {
        Swift::String::Index v7 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::String::Index v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      int v8 = v7[v6];
    }
    int v9 = (char)v8;
    unsigned int v10 = __clz(v8 ^ 0xFF) - 24;
    if (v9 >= 0) {
      LOBYTE(v10) = 1;
    }
    return (Swift::String::Index)(((v6 + v10) << 16) | 5);
  }
}

Swift::Void __swiftcall Substring.UnicodeScalarView.formIndex(after:)(Swift::String::Index *after)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)after->_rawBits)._rawBits;
  if ((v3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }
  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v3 & 0x2000000000000000) != 0)
    {
      v13[0] = v4;
      v13[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }
    else
    {
      if ((v4 & 0x1000000000000000) != 0) {
        int v8 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        int v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      int v9 = v8[v7];
    }
    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 rawBits = ((v7 + v11) << 16) | 5;
  }
  after->_Swift::UInt64 rawBits = rawBits;
}

Swift::String::Index __swiftcall Substring.UnicodeScalarView.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  result._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(_)._rawBits;
  if (offsetBy < 0)
  {
    uint64_t v14 = 0;
    while (1)
    {
      Swift::UInt64 v15 = result._rawBits >> 16;
      if (!(result._rawBits >> 16)) {
        break;
      }
      if ((v4 & 0x1000000000000000) != 0)
      {
        result._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(result)._rawBits;
      }
      else
      {
        if ((v4 & 0x2000000000000000) != 0)
        {
          uint64_t v23 = v5;
          uint64_t v24 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((unsigned char *)&v23 + v15 - 1) & 0xC0) == 0x80)
          {
            uint64_t v18 = 0;
            do
              int v19 = v22[v15 + v18--] & 0xC0;
            while (v19 == 128);
            uint64_t v20 = 1 - v18;
          }
          else
          {
            uint64_t v20 = 1;
          }
          v15 -= v20;
        }
        else
        {
          uint64_t v16 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000) == 0) {
            uint64_t v16 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          do
            int v17 = v16[--v15] & 0xC0;
          while (v17 == 128);
        }
        result._Swift::UInt64 rawBits = (v15 << 16) | 5;
      }
      if (--v14 <= offsetBy) {
        return result;
      }
    }
    unint64_t v21 = 206;
LABEL_40:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, v21, 0);
  }
  if (offsetBy)
  {
    if ((v4 & 0x2000000000000000) != 0) {
      Swift::UInt64 v8 = HIBYTE(v4) & 0xF;
    }
    else {
      Swift::UInt64 v8 = v5 & 0xFFFFFFFFFFFFLL;
    }
    while (1)
    {
      Swift::UInt64 v9 = result._rawBits >> 16;
      if (result._rawBits >> 16 >= v8) {
        break;
      }
      if ((v4 & 0x1000000000000000) != 0)
      {
        result._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(result)._rawBits;
        if (!--offsetBy) {
          return result;
        }
      }
      else
      {
        if ((v4 & 0x2000000000000000) != 0)
        {
          uint64_t v23 = v5;
          uint64_t v24 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v11 = *((unsigned __int8 *)&v23 + v9);
        }
        else
        {
          int v10 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000) == 0) {
            int v10 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v11 = v10[v9];
        }
        int v12 = (char)v11;
        unsigned int v13 = __clz(v11 ^ 0xFF) - 24;
        if (v12 >= 0) {
          LOBYTE(v13) = 1;
        }
        result._Swift::UInt64 rawBits = ((v9 + v13) << 16) | 5;
        if (!--offsetBy) {
          return result;
        }
      }
    }
    unint64_t v21 = 201;
    goto LABEL_40;
  }
  return result;
}

Swift::String::Index_optional __swiftcall Substring.UnicodeScalarView.index(_:offsetBy:limitedBy:)(Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  Swift::UInt64 rawBits = limitedBy._rawBits;
  uint64_t v10 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000) == 0) {
    LOBYTE(v10) = 1;
  }
  uint64_t v11 = 4 << v10;
  if ((limitedBy._rawBits & 0xC) == 4 << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(limitedBy)._rawBits;
  }
  Swift::UInt64 v12 = _._rawBits;
  if ((_._rawBits & 0xC) == v11) {
    Swift::UInt64 v12 = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  }
  v13._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(_)._rawBits;
  Swift::UInt64 v14 = rawBits >> 14;
  if ((offsetBy & 0x8000000000000000) == 0)
  {
    Swift::UInt64 v15 = v12 >> 14;
    if (offsetBy)
    {
      if ((v5 & 0x2000000000000000) != 0) {
        Swift::UInt64 v16 = HIBYTE(v5) & 0xF;
      }
      else {
        Swift::UInt64 v16 = v6 & 0xFFFFFFFFFFFFLL;
      }
      while (1)
      {
        if (v14 >= v15 && v13._rawBits >> 14 >= v14) {
          goto LABEL_52;
        }
        Swift::UInt64 v17 = v13._rawBits >> 16;
        if (v13._rawBits >> 16 >= v16) {
          break;
        }
        if ((v5 & 0x1000000000000000) != 0)
        {
          v13._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v13)._rawBits;
        }
        else
        {
          if ((v5 & 0x2000000000000000) != 0)
          {
            uint64_t v35 = v6;
            uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
            int v19 = *((unsigned __int8 *)&v35 + v17);
          }
          else
          {
            uint64_t v18 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
            if ((v6 & 0x1000000000000000) == 0) {
              uint64_t v18 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, v5);
            }
            int v19 = v18[v17];
          }
          int v20 = (char)v19;
          unsigned int v21 = __clz(v19 ^ 0xFF) - 24;
          if (v20 >= 0) {
            LOBYTE(v21) = 1;
          }
          v13._Swift::UInt64 rawBits = ((v17 + v21) << 16) | 5;
        }
        if (!--offsetBy) {
          goto LABEL_27;
        }
      }
      unint64_t v33 = 229;
LABEL_56:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, v33, 0);
    }
LABEL_27:
    if (v14 >= v15 && v14 < v13._rawBits >> 14) {
      goto LABEL_52;
    }
    goto LABEL_53;
  }
  Swift::Int v22 = 0;
  Swift::UInt64 v23 = v12 >> 14;
  uint64_t v24 = (char *)&v34 + 6;
  do
  {
    if (v23 >= v14 && v14 >= v13._rawBits >> 14) {
      goto LABEL_52;
    }
    Swift::UInt64 v25 = v13._rawBits >> 16;
    if (!(v13._rawBits >> 16))
    {
      unint64_t v33 = 236;
      goto LABEL_56;
    }
    if ((v5 & 0x1000000000000000) != 0)
    {
      v31 = v24;
      v13._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v13)._rawBits;
      uint64_t v24 = v31;
    }
    else
    {
      if ((v5 & 0x2000000000000000) != 0)
      {
        uint64_t v35 = v6;
        uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
        if ((*((unsigned char *)&v35 + v25 - 1) & 0xC0) == 0x80)
        {
          uint64_t v28 = 0;
          do
            int v29 = v24[v25 + v28--] & 0xC0;
          while (v29 == 128);
          uint64_t v30 = 1 - v28;
        }
        else
        {
          uint64_t v30 = 1;
        }
        v25 -= v30;
      }
      else
      {
        v26 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v6 & 0x1000000000000000) == 0)
        {
          v34 = v24;
          v26 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
          uint64_t v24 = v34;
        }
        do
          int v27 = v26[--v25] & 0xC0;
        while (v27 == 128);
      }
      v13._Swift::UInt64 rawBits = (v25 << 16) | 5;
    }
    --v22;
  }
  while (v22 > offsetBy);
  if (v23 < v14 || v13._rawBits >> 14 >= v14)
  {
LABEL_53:
    Swift::Bool v32 = 0;
    goto LABEL_57;
  }
LABEL_52:
  v13._Swift::UInt64 rawBits = 0;
  Swift::Bool v32 = 1;
LABEL_57:
  result.value = v13;
  result.Swift::Bool is_nil = v32;
  return result;
}

Swift::Int __swiftcall Substring.UnicodeScalarView.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(from)._rawBits;
  Swift::Int result = _StringGuts.validateInclusiveScalarIndex(_:)(to)._rawBits;
  Swift::UInt64 v9 = (unint64_t)result >> 14;
  if (v7._rawBits >> 14 < (unint64_t)result >> 14)
  {
    for (uint64_t i = 0; ; ++i)
    {
      Swift::Int v11 = i + 1;
      if (__OFADD__(i, 1)) {
        break;
      }
      if ((v4 & 0x1000000000000000) != 0)
      {
        Swift::Int result = String.UnicodeScalarView._foreignIndex(after:)(v7)._rawBits;
        v7._Swift::UInt64 rawBits = result;
      }
      else
      {
        Swift::UInt64 v12 = v7._rawBits >> 16;
        if ((v4 & 0x2000000000000000) != 0)
        {
          uint64_t v22 = v5;
          uint64_t v23 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v13 = *((unsigned __int8 *)&v22 + v12);
        }
        else
        {
          Swift::Int result = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((v5 & 0x1000000000000000) == 0) {
            Swift::Int result = (Swift::Int)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v13 = *(unsigned __int8 *)(result + v12);
        }
        int v14 = (char)v13;
        unsigned int v15 = __clz(v13 ^ 0xFF) - 24;
        if (v14 >= 0) {
          LOBYTE(v15) = 1;
        }
        v7._Swift::UInt64 rawBits = ((v12 + v15) << 16) | 5;
      }
      if (v9 <= v7._rawBits >> 14) {
        return v11;
      }
    }
    __break(1u);
LABEL_36:
    __break(1u);
    return result;
  }
  if (v9 < v7._rawBits >> 14)
  {
    Swift::Int v11 = 0;
    while (!__OFSUB__(v11--, 1))
    {
      if ((v4 & 0x1000000000000000) != 0)
      {
        Swift::Int result = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
        v7._Swift::UInt64 rawBits = result;
      }
      else
      {
        if ((v4 & 0x2000000000000000) != 0)
        {
          uint64_t v22 = v5;
          uint64_t v23 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((unsigned char *)&v22 + (v7._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v20 = 0;
            do
              int v21 = *((unsigned char *)&v22 + (v7._rawBits >> 16) + v20-- - 2) & 0xC0;
            while (v21 == 128);
            uint64_t v19 = 1 - v20;
          }
          else
          {
            uint64_t v19 = 1;
          }
        }
        else
        {
          Swift::Int result = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((v5 & 0x1000000000000000) == 0) {
            Swift::Int result = (Swift::Int)_StringObject.sharedUTF8.getter(v5, v4);
          }
          uint64_t v17 = 0;
          do
            int v18 = *(unsigned char *)(result + (v7._rawBits >> 16) - 1 + v17--) & 0xC0;
          while (v18 == 128);
          uint64_t v19 = -v17;
        }
        v7._Swift::UInt64 rawBits = (v7._rawBits - (v19 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
      }
      if (v9 >= v7._rawBits >> 14) {
        return v11;
      }
    }
    goto LABEL_36;
  }
  return 0;
}

unint64_t Substring.UnicodeScalarView._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  return result;
}

unint64_t Substring.UnicodeScalarView._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (result >> 14 < a3 >> 14 || a4 >> 14 < a2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  return result;
}

Swift::String::Index __swiftcall Substring.UnicodeScalarView.index(before:)(Swift::String::Index before)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(before)._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  Swift::UInt64 rawBits = v5._rawBits;
  if ((v3 & 0x1000000000000000) != 0)
  {
    return String.UnicodeScalarView._foreignIndex(before:)(v5);
  }
  else
  {
    if ((v3 & 0x2000000000000000) != 0)
    {
      v16[0] = v4;
      v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      Swift::Int v11 = (char *)v16 + (v5._rawBits >> 16);
      if ((*(v11 - 1) & 0xC0) == 0x80)
      {
        uint64_t v12 = 0;
        int v13 = v11 - 2;
        do
          int v14 = v13[v12--] & 0xC0;
        while (v14 == 128);
        uint64_t v10 = 1 - v12;
      }
      else
      {
        uint64_t v10 = 1;
      }
    }
    else
    {
      if ((v4 & 0x1000000000000000) != 0) {
        Swift::String::Index v7 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::String::Index v7 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      uint64_t v8 = 0;
      do
        int v9 = v7[(rawBits >> 16) - 1 + v8--] & 0xC0;
      while (v9 == 128);
      uint64_t v10 = -v8;
    }
    return (Swift::String::Index)((rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000 | 5);
  }
}

Swift::Void __swiftcall Substring.UnicodeScalarView.formIndex(before:)(Swift::String::Index *before)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v6._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)before->_rawBits)._rawBits;
  if (!(v6._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  Swift::UInt64 rawBits = v6._rawBits;
  if ((v3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 v16 = String.UnicodeScalarView._foreignIndex(before:)(v6)._rawBits;
  }
  else
  {
    if ((v3 & 0x2000000000000000) != 0)
    {
      v17[0] = v4;
      v17[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v12 = (char *)v17 + (v6._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0;
        int v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v11 = 1 - v13;
      }
      else
      {
        uint64_t v11 = 1;
      }
    }
    else
    {
      if ((v4 & 0x1000000000000000) != 0) {
        uint64_t v8 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      uint64_t v9 = 0;
      do
        int v10 = v8[(rawBits >> 16) - 1 + v9--] & 0xC0;
      while (v10 == 128);
      uint64_t v11 = -v9;
    }
    Swift::UInt64 v16 = (rawBits - (v11 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
  }
  before->_Swift::UInt64 rawBits = v16;
}

Swift::UInt64 Substring.UnicodeScalarView.subscript.getter(Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  swift_bridgeObjectRetain(a6);
  v12._Swift::UInt64 rawBits = a1;
  v13._Swift::UInt64 rawBits = a2;
  return _StringGuts.validateScalarRange(_:in:)(v12, v13, a3, a4, a5, a6);
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(before:) in conformance Substring.UnicodeScalarView@<X0>(Swift::String::Index *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  uint64_t v5 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24);
  v6._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if (!(v6._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  Swift::UInt64 rawBits = v6._rawBits;
  if ((v4 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(before:)(v6)._rawBits;
  }
  else
  {
    if ((v4 & 0x2000000000000000) != 0)
    {
      v17[0] = v5;
      v17[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v12 = (char *)v17 + (v6._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0;
        int v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v11 = 1 - v13;
      }
      else
      {
        uint64_t v11 = 1;
      }
    }
    else
    {
      if ((v5 & 0x1000000000000000) != 0) {
        uint64_t v8 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
      }
      uint64_t v9 = 0;
      do
        int v10 = v8[(rawBits >> 16) - 1 + v9--] & 0xC0;
      while (v10 == 128);
      uint64_t v11 = -v9;
    }
    Swift::UInt64 result = (rawBits - (v11 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
  }
  *a2 = result;
  return result;
}

void protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring.UnicodeScalarView(Swift::String::Index *before)
{
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring.UnicodeScalarView@<X0>(Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.UnicodeScalarView.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UnicodeScalarView@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View(a1, a2, a3, (uint64_t (*)(void, uint64_t, void, void, void))String.UnicodeScalarView.index(_:offsetBy:limitedBy:), a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, uint64_t, void, void, void)@<X5>, uint64_t a5@<X8>)
{
  uint64_t result = a4(*a1, a2, *a3, *(void *)(v5 + 16), *(void *)(v5 + 24));
  *(void *)a5 = result;
  *(unsigned char *)(a5 + 8) = v8 & 1;
  return result;
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring.UnicodeScalarView(Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.UnicodeScalarView.distance(from:to:)((Swift::String::Index)a1->_rawBits, (Swift::String::Index)a2->_rawBits);
}

void protocol witness for Collection.startIndex.getter in conformance Substring.UnicodeScalarView(void *a1@<X8>)
{
  *a1 = *v1;
}

void protocol witness for Collection.endIndex.getter in conformance Substring.UnicodeScalarView(void *a1@<X8>)
{
  *a1 = *(void *)(v1 + 8);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring.UnicodeScalarView(uint64_t *a1, Swift::UInt64 *a2))()
{
  v4._Swift::UInt64 rawBits = *a2;
  uint64_t v6 = v2[2];
  uint64_t v5 = v2[3];
  v7._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(v4, *v2, v2[1], v6, v5)._rawBits;
  if ((v5 & 0x1000000000000000) != 0)
  {
    int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v7._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
  }
  else
  {
    Swift::UInt64 v9 = v7._rawBits >> 16;
    if ((v5 & 0x2000000000000000) != 0)
    {
      *a1 = v6;
      a1[1] = v5 & 0xFFFFFFFFFFFFFFLL;
      id v10 = a1;
    }
    else if ((v6 & 0x1000000000000000) != 0)
    {
      id v10 = (id)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      id v10 = _StringObject.sharedUTF8.getter(v6, v5);
    }
    int value = _decodeScalar(_:startingAt:)((uint64_t)v10, v8._rawBits, v9);
  }
  *(_DWORD *)a1 = value;
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 protocol witness for Collection.subscript.getter in conformance Substring.UnicodeScalarView@<X0>(Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  Swift::UInt64 v4 = *a1;
  Swift::UInt64 v5 = a1[1];
  unint64_t v6 = *v2;
  unint64_t v7 = v2[1];
  unint64_t v9 = v2[2];
  unint64_t v8 = v2[3];
  swift_bridgeObjectRetain(v8);
  v10._Swift::UInt64 rawBits = v4;
  v11._Swift::UInt64 rawBits = v5;
  Swift::UInt64 result = _StringGuts.validateScalarRange(_:in:)(v10, v11, v6, v7, v9, v8);
  *a2 = result;
  a2[1] = v13;
  a2[2] = v9;
  a2[3] = v8;
  return result;
}

unint64_t protocol witness for Collection.indices.getter in conformance Substring.UTF8View@<X0>(uint64_t a1@<X8>)
{
  unint64_t v2 = *(void *)(v1 + 24);
  *(void *)a1 = *(void *)(v1 + 16);
  *(void *)(a1 + 8) = v2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)v1;
  return swift_bridgeObjectRetain(v2);
}

BOOL protocol witness for Collection.isEmpty.getter in conformance Substring.UnicodeScalarView()
{
  return (v0[1] ^ *v0) < 0x4000uLL;
}

Swift::String::Index protocol witness for Collection.count.getter in conformance Substring.UnicodeScalarView()
{
  v1._Swift::UInt64 rawBits = *(void *)v0;
  v2._Swift::UInt64 rawBits = *(void *)(v0 + 8);
  return specialized Collection.count.getter(v1, v2, *(void *)(v0 + 16), *(void *)(v0 + 24));
}

Swift::String::Index protocol witness for Collection.index(_:offsetBy:) in conformance Substring.UnicodeScalarView@<X0>(Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UnicodeScalarView.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UnicodeScalarView@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View(a1, a2, a3, a4, a5, (uint64_t (*)(void, uint64_t, void, uint64_t, uint64_t, void, void))Substring.UnicodeScalarView.index(_:offsetBy:limitedBy:), a6);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t (*a6)(void, uint64_t, void, uint64_t, uint64_t, void, void)@<X5>, uint64_t a7@<X8>)
{
  uint64_t result = a6(*a1, a2, *a3, a4, a5, *(void *)(v7 + 16), *(void *)(v7 + 24));
  *(void *)a7 = result;
  *(unsigned char *)(a7 + 8) = v10 & 1;
  return result;
}

Swift::UInt64 protocol witness for Collection.index(after:) in conformance Substring.UnicodeScalarView@<X0>(Swift::String::Index *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  uint64_t v5 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24);
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((v4 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }
  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v4 & 0x2000000000000000) != 0)
    {
      v13[0] = v5;
      v13[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }
    else
    {
      if ((v5 & 0x1000000000000000) != 0) {
        unint64_t v8 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
      }
      int v9 = v8[v7];
    }
    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 result = ((v7 + v11) << 16) | 5;
  }
  *a2 = result;
  return result;
}

Swift::UInt64 protocol witness for Collection.formIndex(after:) in conformance Substring.UnicodeScalarView(Swift::String::Index *a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((v3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v5)._rawBits;
  }
  else
  {
    Swift::UInt64 v6 = v5._rawBits >> 16;
    if ((v3 & 0x2000000000000000) != 0)
    {
      v12[0] = v4;
      v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int v8 = *((unsigned __int8 *)v12 + v6);
    }
    else
    {
      if ((v4 & 0x1000000000000000) != 0) {
        Swift::UInt64 v7 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      int v8 = v7[v6];
    }
    int v9 = (char)v8;
    unsigned int v10 = __clz(v8 ^ 0xFF) - 24;
    if (v9 >= 0) {
      LOBYTE(v10) = 1;
    }
    Swift::UInt64 result = ((v6 + v10) << 16) | 5;
  }
  a1->_Swift::UInt64 rawBits = result;
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance Substring.UnicodeScalarView@<Q0>(__n128 *a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  unint64_t v3 = v1[1].n128_u64[1];
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v2;
  a1[1].n128_u64[1] = v3;
  a1[2].n128_u64[0] = result.n128_u64[0];
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring.UnicodeScalarView(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring(a1, a2, (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring(uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, uint64_t))
{
  uint64_t v4 = v3[3];
  uint64_t v5 = a3(*v3, v3[1], v3[2], v4);
  swift_bridgeObjectRelease(v4);
  return v5;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, void, void, void, void))
{
  return a6(a1, a2, a3, *v6, v6[1], v6[2], v6[3]);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring.UnicodeScalarView@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys7UnicodeO6ScalarVqd__Isgyrzo_Ss0hI4ViewVABsAG_pAMRszr__lIetMggrzo_Tpq5Tm(a1, a2);
}

unint64_t key path setter for Substring.unicodeScalars : Substring(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease(*(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v5;
  *(void *)(a2 + 24) = v4;

  return swift_bridgeObjectRetain(v4);
}

void (*Substring.unicodeScalars.modify(void *a1))(uint64_t **a1, char a2)
{
  unint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)unint64_t v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4);
  return Substring.unicodeScalars.modify;
}

void Substring.unicodeScalars.modify(uint64_t **a1, char a2)
{
  unint64_t v2 = *a1;
  uint64_t v3 = (*a1)[3];
  unint64_t v4 = (uint64_t *)(*a1)[4];
  uint64_t v6 = **a1;
  uint64_t v5 = (*a1)[1];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = v4[3];
  if (a2)
  {
    swift_bridgeObjectRetain((*a1)[3]);
    swift_bridgeObjectRelease(v8);
    *unint64_t v4 = v6;
    v4[1] = v5;
    v4[2] = v7;
    v4[3] = v3;
    swift_bridgeObjectRelease(v2[3]);
  }
  else
  {
    swift_bridgeObjectRelease(v4[3]);
    *unint64_t v4 = v6;
    v4[1] = v5;
    v4[2] = v7;
    v4[3] = v3;
  }

  free(v2);
}

uint64_t specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(Swift::String::Index a1, Swift::String::Index a2)
{
  v3._Swift::UInt64 rawBits = a2._rawBits;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v2[2] >> 59) & 1;
  if ((v2[3] & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4 << v7;
  uint64_t v10 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v9 || (a2._rawBits & 1) == 0 || v10 == v9)
  {
    if (v10 == v9)
    {
      a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      v3._Swift::UInt64 rawBits = a1._rawBits;
      if (v8 != v9) {
        goto LABEL_12;
      }
    }
    else if (v8 != v9)
    {
LABEL_12:
      if (v4._rawBits >> 14 < v5 >> 14 || v3._rawBits >> 14 < v4._rawBits >> 14 || v6 >> 14 < v3._rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
      }
      if (v3._rawBits)
      {
        if (v4._rawBits) {
          goto LABEL_17;
        }
      }
      else
      {
        a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v3)._rawBits;
        v3._Swift::UInt64 rawBits = v3._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
        if (v4._rawBits) {
          goto LABEL_17;
        }
      }
      a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
      v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      goto LABEL_17;
    }
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
    v4._Swift::UInt64 rawBits = a1._rawBits;
    goto LABEL_12;
  }
  if (a1._rawBits >> 14 < v5 >> 14 || v6 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0xECuLL, 0);
  }
LABEL_17:
  MEMORY[0x1F4188790](a1._rawBits);
  return _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)(v4._rawBits, v3._rawBits, (uint64_t *)v2, v2 + 1, (uint64_t (*)(uint64_t *))partial apply for specialized closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

{
  unint64_t *v2;
  Swift::String::Index v3;
  Swift::String::Index v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3._Swift::UInt64 rawBits = a2._rawBits;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v2[2] >> 59) & 1;
  if ((v2[3] & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4 << v7;
  uint64_t v10 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v9 || (a2._rawBits & 1) == 0 || v10 == v9)
  {
    if (v10 == v9)
    {
      a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      v3._Swift::UInt64 rawBits = a1._rawBits;
      if (v8 != v9) {
        goto LABEL_12;
      }
    }
    else if (v8 != v9)
    {
LABEL_12:
      if (v4._rawBits >> 14 < v5 >> 14 || v3._rawBits >> 14 < v4._rawBits >> 14 || v6 >> 14 < v3._rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
      }
      if (v3._rawBits)
      {
        if (v4._rawBits) {
          goto LABEL_17;
        }
      }
      else
      {
        a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v3)._rawBits;
        v3._Swift::UInt64 rawBits = v3._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
        if (v4._rawBits) {
          goto LABEL_17;
        }
      }
      a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
      v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      goto LABEL_17;
    }
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
    v4._Swift::UInt64 rawBits = a1._rawBits;
    goto LABEL_12;
  }
  if (a1._rawBits >> 14 < v5 >> 14 || v6 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0xECuLL, 0);
  }
LABEL_17:
  MEMORY[0x1F4188790](a1._rawBits);
  return _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)(v4._rawBits, v3._rawBits, (uint64_t *)v2, v2 + 1, (uint64_t (*)(uint64_t *))partial apply for specialized closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

uint64_t Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(Swift::String::Index a1, Swift::String::Index a2)
{
  v3._Swift::UInt64 rawBits = a2._rawBits;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v2[2] >> 59) & 1;
  if ((v2[3] & 0x1000000000000000) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4 << v7;
  uint64_t v10 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v9 || (a2._rawBits & 1) == 0 || v10 == v9)
  {
    if (v10 == v9)
    {
      a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      v3._Swift::UInt64 rawBits = a1._rawBits;
      if (v8 != v9) {
        goto LABEL_12;
      }
    }
    else if (v8 != v9)
    {
LABEL_12:
      if (v4._rawBits >> 14 < v5 >> 14 || v3._rawBits >> 14 < v4._rawBits >> 14 || v6 >> 14 < v3._rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
      }
      if (v3._rawBits)
      {
        if (v4._rawBits) {
          goto LABEL_17;
        }
      }
      else
      {
        a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v3)._rawBits;
        v3._Swift::UInt64 rawBits = v3._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
        if (v4._rawBits) {
          goto LABEL_17;
        }
      }
      a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
      v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      goto LABEL_17;
    }
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
    v4._Swift::UInt64 rawBits = a1._rawBits;
    goto LABEL_12;
  }
  if (a1._rawBits >> 14 < v5 >> 14 || v6 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0xECuLL, 0);
  }
LABEL_17:
  MEMORY[0x1F4188790](a1._rawBits);
  return _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)(v4._rawBits, v3._rawBits, (uint64_t *)v2, v2 + 1, (uint64_t (*)(uint64_t *))partial apply for closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

double protocol witness for RangeReplaceableCollection.init() in conformance Substring.UnicodeScalarView@<D0>(uint64_t a1@<X8>)
{
  *(void *)&double result = 15;
  *(_OWORD *)a1 = xmmword_18162ACC0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0xE000000000000000;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring.UnicodeScalarView(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring.UnicodeScalarView(a1, a2, a3, a4, a5, a6, (void (*)(void, void, uint64_t, uint64_t, uint64_t))Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance Substring.UnicodeScalarView@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a2);
  *a3 = result;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance Substring.UnicodeScalarView@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append(_:) in conformance Substring.UnicodeScalarView()
{
  v1._Swift::UInt64 rawBits = *(void *)(v0 + 8);
  v2._Swift::UInt64 rawBits = v1._rawBits;
  return specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v1, v2);
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance Substring.UnicodeScalarView(uint64_t a1, Swift::UInt64 *a2)
{
  v3._Swift::UInt64 rawBits = *a2;
  v2._Swift::UInt64 rawBits = v3._rawBits;
  return specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v2, v3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring.UnicodeScalarView(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring.UnicodeScalarView(a1, a2, a3, a4, a5, a6, (void (*)(uint64_t, void))specialized RangeReplaceableCollection.insert<A>(contentsOf:at:));
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance Substring.UnicodeScalarView@<X0>(Swift::UInt64 *a1@<X0>, _DWORD *a2@<X8>)
{
  v3._Swift::UInt64 rawBits = *a1;
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(v3);
  *a2 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance Substring.UnicodeScalarView(Swift::UInt64 *a1)
{
  v1._Swift::UInt64 rawBits = a1[1];
  v2._Swift::UInt64 rawBits = *a1;
  return specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v2, v1);
}

uint64_t protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance Substring.UnicodeScalarView@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection<>._customRemoveLast()();
  *(_DWORD *)a1 = result;
  *(unsigned char *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance Substring.UnicodeScalarView@<X0>(_DWORD *a1@<X8>)
{
  unint64_t result = specialized RangeReplaceableCollection<>.removeFirst()();
  *a1 = result;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance Substring.UnicodeScalarView(uint64_t (*a1)(uint64_t *), uint64_t a2)
{
}

void specialized Substring.append<A>(contentsOf:)(uint64_t a1, unint64_t a2)
{
  v5._Swift::UInt64 rawBits = *v2;
  v6._Swift::UInt64 rawBits = v2[1];
  uint64_t v7 = v2[2];
  unint64_t v8 = v2[3];
  size_t v9 = HIBYTE(v8) & 0xF;
  uint64_t v10 = v7 & 0xFFFFFFFFFFFFLL;
  if ((v8 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v8) & 0xF;
  }
  else {
    uint64_t v11 = v7 & 0xFFFFFFFFFFFFLL;
  }
  if (v5._rawBits >> 16) {
    BOOL v12 = 0;
  }
  else {
    BOOL v12 = v6._rawBits >> 16 == v11;
  }
  if (v12)
  {
    unint64_t v14 = v2[3];
  }
  else
  {
    uint64_t v7 = specialized static String._copying(_:)(v5, v6, v2[2], v2[3]);
    unint64_t v14 = v13;
    swift_bridgeObjectRelease(v8);
    size_t v9 = HIBYTE(v14) & 0xF;
    uint64_t v10 = v7 & 0xFFFFFFFFFFFFLL;
    unint64_t v8 = v14;
  }
  uint64_t v106 = v7;
  unint64_t v107 = v8;
  *(_OWORD *)Swift::String::Index v2 = xmmword_18162ACC0;
  v2[2] = 0;
  v2[3] = 0xE000000000000000;
  if ((v14 & 0x2000000000000000) != 0) {
    size_t v15 = v9;
  }
  else {
    size_t v15 = v10;
  }
  if (!v15 && (v7 & ~v14 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(a2);
    swift_bridgeObjectRelease(v8);
    goto LABEL_107;
  }
  uint64_t v16 = a2 & 0x2000000000000000;
  uint64_t v17 = HIBYTE(a2) & 0xF;
  if ((v14 & 0x2000000000000000) != 0 && v16)
  {
    uint64_t v18 = v9 + v17;
    if (v9 + v17 <= 0xF)
    {
      if (v17)
      {
        char v58 = 0;
        unint64_t v59 = 0;
        do
        {
          unint64_t v60 = v9 + v59;
          unint64_t v61 = v59 + 1;
          if (v59 >= 8) {
            unint64_t v62 = a2;
          }
          else {
            unint64_t v62 = a1;
          }
          unint64_t v63 = v62 >> (v58 & 0x38);
          char v64 = (8 * v9 + v58) & 0x38;
          uint64_t v65 = (-255 << v64) - 1;
          unint64_t v66 = (unint64_t)v63 << v64;
          unint64_t v67 = v66 | v65 & v14;
          unint64_t v68 = v66 | v65 & v7;
          if (v60 < 8) {
            uint64_t v7 = v68;
          }
          else {
            unint64_t v14 = v67;
          }
          v58 += 8;
          unint64_t v59 = v61;
        }
        while (v17 != v61);
      }
      goto LABEL_92;
    }
    uint64_t v16 = 1;
  }
  uint64_t v98 = a1 & 0xFFFFFFFFFFFFLL;
  if (v16) {
    int64_t v19 = HIBYTE(a2) & 0xF;
  }
  else {
    int64_t v19 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v101 = v19;
  uint64_t v102 = v16;
  Swift::Int v100 = v15;
  if ((a2 & 0x1000000000000000) == 0)
  {
    uint64_t v99 = v10;
    if ((v14 & 0x1000000000000000) == 0) {
      goto LABEL_24;
    }
LABEL_102:
    Swift::Int v84 = String.UTF8View._foreignCount()();
    uint64_t v20 = v84 + v19;
    if (!__OFADD__(v84, v19)) {
      goto LABEL_25;
    }
LABEL_104:
    __break(1u);
    goto LABEL_105;
  }
  v76._Swift::UInt64 rawBits = (v19 << 16) | 1;
  v77._Swift::UInt64 rawBits = 1;
  Swift::UInt64 v78 = _StringGuts.validateScalarRange(_:)(v77, v76, a1, a2);
  Swift::UInt64 v80 = v79;
  if (v78 >= 0x10000) {
    Swift::UInt64 v81 = v78;
  }
  else {
    Swift::UInt64 v81 = v78 | 3;
  }
  swift_bridgeObjectRetain(a2);
  v82._Swift::UInt64 rawBits = v81;
  v83._Swift::UInt64 rawBits = v80;
  int64_t v19 = specialized Collection.count.getter(v82, v83, a1, a2);
  swift_bridgeObjectRelease(a2);
  size_t v15 = v100;
  uint64_t v99 = v10;
  if ((v14 & 0x1000000000000000) != 0) {
    goto LABEL_102;
  }
LABEL_24:
  uint64_t v20 = v15 + v19;
  if (__OFADD__(v15, v19)) {
    goto LABEL_104;
  }
LABEL_25:
  v103 = v2;
  unint64_t v21 = v8;
  uint64_t v22 = v7 & ~v14;
  if ((v22 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v14 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v7, v21);
    if (v24)
    {
      unint64_t v91 = 258;
LABEL_125:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v91, 0);
    }
    if (v20 > 15 || (v14 & 0x2000000000000000) == 0 && v23 >= v19) {
      goto LABEL_31;
    }
  }
  else if (v20 > 15)
  {
LABEL_31:
    int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(v7, v21);
    BOOL v28 = (v26 & 1) == 0 && v25 >= v19;
    if ((v22 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v14 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v28) {
        goto LABEL_79;
      }
    }
    else if (v28)
    {
      goto LABEL_61;
    }
    uint64_t v42 = 2 * _StringGuts.nativeCapacity.getter(v7, v21);
    if (v43) {
      uint64_t v42 = 0;
    }
    if (v42 > v20) {
      uint64_t v20 = v42;
    }
LABEL_61:
    uint64_t v44 = _StringGuts.uniqueNativeCapacity.getter();
    if (v45)
    {
      Swift::Int v46 = v100;
      if ((v14 & 0x1000000000000000) != 0) {
        Swift::Int v46 = String.UTF8View._foreignCount()();
      }
    }
    else
    {
      Swift::Int v46 = 2 * v44;
    }
    if (v46 <= v20) {
      int64_t v19 = v20;
    }
    else {
      int64_t v19 = v46;
    }
    if ((v14 & 0x1000000000000000) == 0)
    {
      if ((v14 & 0x2000000000000000) != 0)
      {
        uint64_t __src = v7;
        uint64_t v105 = v14 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v50 = v9 | 0xC000000000000000;
        if ((v14 & 0x4000000000000000) == 0) {
          unint64_t v50 = v9;
        }
        uint64_t v51 = v50 | 0x3000000000000000;
        int64_t v49 = _allocateStringStorage(codeUnitCapacity:)(v19);
        *(void *)(v49 + 16) = v52;
        *(void *)(v49 + 24) = v51;
        if (v52 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
          uint64_t v51 = *(void *)(v49 + 24);
        }
        *(unsigned char *)(v49 + 32 + (v51 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v9, (char *)(v49 + 32));
      }
      else
      {
        if ((v7 & 0x1000000000000000) != 0)
        {
          v47 = (char *)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v48 = v99;
        }
        else
        {
          v47 = (char *)_StringObject.sharedUTF8.getter(v7, v21);
        }
        int64_t v49 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(v47, v48, v19, v7 < 0);
      }
      uint64_t v53 = *(void *)(v49 + 24);
      swift_bridgeObjectRelease(v107);
      uint64_t v106 = v53;
      unint64_t v107 = v49;
LABEL_79:
      if ((a2 & 0x1000000000000000) == 0) {
        goto LABEL_80;
      }
      goto LABEL_106;
    }
LABEL_105:
    _StringGuts._foreignGrow(_:)(v19);
    if ((a2 & 0x1000000000000000) == 0)
    {
LABEL_80:
      Swift::String::Index v2 = v103;
      if (v102)
      {
        uint64_t __src = a1;
        uint64_t v105 = a2 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v54 = (a2 >> 62) & 1;
        v55 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(a2) & 0xF, (uint64_t)&__src, HIBYTE(a2) & 0xF);
        a2 = v107;
        uint64_t v56 = v107 & 0xFFFFFFFFFFFFFFFLL;
        closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v107 & 0xFFFFFFFFFFFFFFFLL, v55, v57, v54);
        a1 = *(void *)(v56 + 24);
      }
      else
      {
        if ((a1 & 0x1000000000000000) != 0)
        {
          uint64_t v70 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
          uint64_t v71 = a1 & 0xFFFFFFFFFFFFLL;
          uint64_t v72 = a1 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          id v89 = _StringObject.sharedUTF8.getter(a1, a2);
          if (v90 < v98) {
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
          }
          uint64_t v70 = (uint64_t)v89;
          uint64_t v72 = v90;
          Swift::String::Index v2 = v103;
          uint64_t v71 = a1 & 0xFFFFFFFFFFFFLL;
        }
        v73 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v71, v70, v72);
        a2 = v107;
        uint64_t v74 = v107 & 0xFFFFFFFFFFFFFFFLL;
        closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v107 & 0xFFFFFFFFFFFFFFFLL, v73, v75, a1 < 0);
        a1 = *(void *)(v74 + 24);
      }
      goto LABEL_107;
    }
LABEL_106:
    _StringGuts._foreignAppendInPlace(_:)(a1, a2, 0, v101);
    a1 = v106;
    a2 = v107;
    Swift::String::Index v2 = v103;
    goto LABEL_107;
  }
  unint64_t v8 = v21;
  if ((v14 & 0x2000000000000000) == 0)
  {
    if ((v14 & 0x1000000000000000) != 0)
    {
      uint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v21);
      unint64_t v14 = v92;
    }
    else
    {
      uint64_t v87 = v99;
      if ((v7 & 0x1000000000000000) != 0)
      {
        v88 = (unsigned __int8 *)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        v88 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v21);
        uint64_t v87 = v95;
      }
      swift_bridgeObjectRetain(v8);
      closure #1 in _StringGuts._convertedToSmall()(v88, v87, &__src);
      swift_bridgeObjectRelease(v8);
      uint64_t v7 = __src;
      unint64_t v14 = v105;
    }
  }
  swift_bridgeObjectRetain(a2);
  if (v102)
  {
    swift_bridgeObjectRelease(a2);
  }
  else if ((a2 & 0x1000000000000000) != 0)
  {
    a1 = _StringGuts._foreignConvertedToSmall()(a1, a2);
    unint64_t v94 = v93;
    swift_bridgeObjectRelease(a2);
    a2 = v94;
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      closure #1 in _StringGuts._convertedToSmall()((unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32), v98, &__src);
    }
    else
    {
      v96 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      closure #1 in _StringGuts._convertedToSmall()(v96, v97, &__src);
    }
    swift_bridgeObjectRelease(a2);
    a1 = __src;
    a2 = v105;
  }
  uint64_t v29 = HIBYTE(v14) & 0xF;
  uint64_t v30 = HIBYTE(a2) & 0xF;
  uint64_t v18 = v30 + v29;
  if ((unint64_t)(v30 + v29) > 0xF)
  {
    unint64_t v91 = 266;
    goto LABEL_125;
  }
  if (v30)
  {
    char v31 = 0;
    unint64_t v32 = 0;
    do
    {
      unint64_t v33 = v29 + v32;
      unint64_t v34 = v32 + 1;
      if (v32 >= 8) {
        unint64_t v35 = a2;
      }
      else {
        unint64_t v35 = a1;
      }
      unint64_t v36 = v35 >> (v31 & 0x38);
      char v37 = (8 * v29 + v31) & 0x38;
      uint64_t v38 = (-255 << v37) - 1;
      unint64_t v39 = (unint64_t)v36 << v37;
      unint64_t v40 = v39 | v38 & v14;
      unint64_t v41 = v39 | v38 & v7;
      if (v33 < 8) {
        uint64_t v7 = v41;
      }
      else {
        unint64_t v14 = v40;
      }
      v31 += 8;
      unint64_t v32 = v34;
    }
    while (v30 != v34);
  }
LABEL_92:
  swift_bridgeObjectRelease(v8);
  unint64_t v69 = 0xA000000000000000;
  if (!(v7 & 0x8080808080808080 | v14 & 0x80808080808080)) {
    unint64_t v69 = 0xE000000000000000;
  }
  a2 = v69 & 0xFF00000000000000 | (v18 << 56) | v14 & 0xFFFFFFFFFFFFFFLL;
  a1 = v7;
LABEL_107:
  uint64_t v85 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v85 = a1;
  }
  uint64_t v86 = 7;
  if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0) {
    uint64_t v86 = 11;
  }
  *Swift::String::Index v2 = 15;
  v2[1] = v86 | (v85 << 16);
  v2[2] = a1;
  v2[3] = a2;
}

void Substring.append<A>(contentsOf:)(unint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  Swift::String::Index v4 = v3;
  v8._Swift::UInt64 rawBits = *v3;
  v9._Swift::UInt64 rawBits = v3[1];
  unint64_t v10 = v3[2];
  unint64_t v11 = v3[3];
  uint64_t v12 = specialized String.init(_:)(v8, v9, v10, v11);
  Swift::UInt64 v14 = v13;
  swift_bridgeObjectRelease(v11);
  String.append<A>(contentsOf:)(a1, a2, a3);
  uint64_t v15 = HIBYTE(v14) & 0xF;
  if ((v14 & 0x2000000000000000) == 0) {
    uint64_t v15 = v12;
  }
  uint64_t v16 = 7;
  if (((v14 >> 60) & ((v12 & 0x800000000000000) == 0)) != 0) {
    uint64_t v16 = 11;
  }
  *Swift::String::Index v4 = 15;
  v4[1] = v16 | (v15 << 16);
  v4[2] = v12;
  v4[3] = v14;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring.UnicodeScalarView(a1, a2, a3, a4, a5, a6, (void (*)(void, void, uint64_t, uint64_t, uint64_t))Substring.replaceSubrange<A>(_:with:));
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring.UnicodeScalarView(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(void, void, uint64_t, uint64_t, uint64_t))
{
  a7(*a1, a1[1], a2, a3, a4);
  Swift::String::Index v9 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8);

  return v9(a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance Substring@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a1[1], a2);
  *a3 = result;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance Substring@<X0>(uint64_t *a1@<X0>, ValueMetadata *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = Substring.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

void protocol witness for RangeReplaceableCollection.append(_:) in conformance Substring(unint64_t *a1)
{
  unint64_t v2 = *a1;
  Swift::UInt64 v3 = a1[1];
  v4._Swift::UInt64 rawBits = *(void *)(v1 + 8);
  v5._Swift::UInt64 rawBits = v4._rawBits;
  specialized Substring._replaceSubrange<A>(_:with:)(v4, v5, v2, v3);

  swift_bridgeObjectRelease(v3);
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance Substring(unint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  Substring.append<A>(contentsOf:)(a1, a2, a3);
  Swift::String::Index v5 = (uint64_t (*)(unint64_t *, ValueMetadata *))*((void *)a2[-1].Description + 1);

  return v5(a1, a2);
}

void protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance Substring(unint64_t *a1, Swift::UInt64 *a2)
{
  unint64_t v2 = *a1;
  Swift::UInt64 v3 = a1[1];
  v5._Swift::UInt64 rawBits = *a2;
  v4._Swift::UInt64 rawBits = v5._rawBits;
  specialized Substring._replaceSubrange<A>(_:with:)(v4, v5, v2, v3);

  swift_bridgeObjectRelease(v3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring.UnicodeScalarView(a1, a2, a3, a4, a5, a6, (void (*)(uint64_t, void))specialized RangeReplaceableCollection.insert<A>(contentsOf:at:));
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring.UnicodeScalarView(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(uint64_t, void))
{
  a7(a1, *a2);
  Swift::String::Index v9 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8);

  return v9(a1, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance Substring@<X0>(Swift::UInt64 *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(*a1);
  *a2 = result;
  a2[1] = v4;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance Substring(Swift::UInt64 *a1)
{
  v1._Swift::UInt64 rawBits = a1[1];
  v2._Swift::UInt64 rawBits = *a1;
  specialized Substring._replaceSubrange<A>(_:with:)(v2, v1);
}

uint64_t protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance Substring@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection<>._customRemoveLast()();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance Substring@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection<>.removeFirst()();
  *a1 = result;
  a1[1] = v3;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance Substring(uint64_t (*a1)(void *), uint64_t a2)
{
}

void Substring.filter(_:)(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  if ((a3 ^ a4) >= 0x4000)
  {
    uint64_t v7 = &_swiftEmptyArrayStorage;
    Swift::UInt64 rawBits = a3;
    do
    {
      uint64_t v25 = (uint64_t)v7;
      while (1)
      {
        uint64_t v13 = Substring.subscript.getter(rawBits, a3, a4, a5, a6);
        uint64_t v15 = v14;
        unint64_t v16 = _StringGuts.validateCharacterIndex(_:in:)(rawBits, a3, a4, a5, a6);
        Swift::UInt64 rawBits = Substring._uncheckedIndex(after:)((Swift::String::Index)v16)._rawBits;
        char v17 = a1(v13, v15);
        if (v6)
        {
          swift_release(v25);
          swift_bridgeObjectRelease(v15);
          return;
        }
        if (v17) {
          break;
        }
        swift_bridgeObjectRelease(v15);
        if (!((rawBits ^ a4) >> 14))
        {
          uint64_t v7 = (__objc2_class **)v25;
          goto LABEL_16;
        }
      }
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v25);
      uint64_t v7 = (__objc2_class **)v25;
      BOOL v28 = (__objc2_class **)v25;
      if (!isUniquelyReferenced_nonNull_native)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v25 + 16) + 1, 1);
        uint64_t v7 = (__objc2_class **)v25;
      }
      unint64_t v20 = (unint64_t)v7[2];
      unint64_t v19 = (unint64_t)v7[3];
      unint64_t v21 = (__objc2_class *)(v20 + 1);
      if (v20 >= v19 >> 1)
      {
        char v24 = v7[2];
        char v26 = (__objc2_class *)(v20 + 1);
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v19 > 1), v20 + 1, 1);
        unint64_t v20 = (unint64_t)v24;
        unint64_t v21 = v26;
        uint64_t v7 = v28;
      }
      v7[2] = v21;
      uint64_t v22 = &v7[2 * v20];
      v22[4] = (__objc2_class *)v13;
      v22[5] = (__objc2_class *)v15;
    }
    while ((rawBits ^ a4) >= 0x4000);
  }
  else
  {
    uint64_t v7 = &_swiftEmptyArrayStorage;
  }
LABEL_16:
  if (&full type metadata for [Character] == &full type metadata for String)
  {
    __break(1u);
  }
  else if (&full type metadata for [Character] != &full type metadata for Substring)
  {
    uint64_t v23 = (uint64_t)v7;
    specialized String.append<A>(contentsOf:)((uint64_t)v7);
    swift_release(v23);
    return;
  }
  __break(1u);
}

void protocol witness for TextOutputStream._writeASCII(_:) in conformance Substring(uint8x16_t *a1, uint64_t a2)
{
  unint64_t v2 = specialized static String._uncheckedFromASCII(_:)(a1, a2);
  uint64_t v4 = v3;
  specialized Substring.append<A>(contentsOf:)(v2, v3);

  swift_bridgeObjectRelease(v4);
}

void Substring.write<A>(to:)(uint64_t a1, Swift::String::Index a2, Swift::String::Index a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = specialized String.init(_:)(a2, a3, a4, a5);
  uint64_t v12 = v11;
  (*(void (**)(uint64_t))(a7 + 24))(v10);

  swift_bridgeObjectRelease(v12);
}

void protocol witness for TextOutputStreamable.write<A>(to:) in conformance Substring(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6._Swift::UInt64 rawBits = *v3;
  v7._Swift::UInt64 rawBits = v3[1];
  Substring.write<A>(to:)(a1, v6, v7, v3[2], v3[3], a2, a3);
}

void *__SwiftNativeNSArrayWithContiguousStorage.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t __SwiftNativeNSArrayWithContiguousStorage.init()()
{
  return v0;
}

uint64_t __SwiftNativeNSArrayWithContiguousStorage.deinit()
{
  return v0;
}

void closure #1 in __SwiftNativeNSArrayWithContiguousStorage.count.getter(uint64_t a1@<X1>, void *a2@<X8>)
{
  *a2 = a1;
}

uint64_t closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a3 < 0 || a3 >= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Array index out of range", 24, 2, "Swift/SwiftNativeNSArray.swift", 30, 2, 0x50uLL, 0);
  }
  *a4 = *(void *)(result + 8 * a3);
  return result;
}

uint64_t @objc __SwiftNativeNSArrayWithContiguousStorage.objectAtSubscript(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[2] = a3;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void *, void *))(*(void *)a1 + 88))(&v6, a4, v5, &unk_1ECA00008);
  return v6;
}

id @objc _SwiftNSMutableArray.objectAtSubscript(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 16);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(a3, (v4 & 0xC000000000000001) == 0, v4);
  if ((v4 & 0xC000000000000001) != 0)
  {
    id v5 = specialized _ArrayBuffer._getElementSlowPath(_:)(a3, v4);
  }
  else
  {
    id v5 = *(id *)(v4 + 8 * a3 + 32);
    swift_unknownObjectRetain(v5);
  }
  swift_unknownObjectRelease(v5);
  return v5;
}

void _SwiftNSMutableArray.getObjects(_:range:)(void *__dst, uint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(v3 + 16);
  if ((v7 & 0x8000000000000000) == 0 && (v7 & 0x4000000000000000) == 0)
  {
    if (a2 < 0 || (uint64_t v8 = *(void *)((v7 & 0xFFFFFFFFFFFFFF8) + 0x10), v8 < a2))
    {
      unint64_t v11 = 188;
    }
    else
    {
      uint64_t v9 = a2 + a3;
      if (__OFADD__(a2, a3))
      {
        __break(1u);
        goto LABEL_21;
      }
      if ((v9 & 0x8000000000000000) == 0 && v8 >= v9)
      {
        if (!v8)
        {
LABEL_12:
          swift_bridgeObjectRetain(v7);
          goto LABEL_13;
        }
        if ((unint64_t)(a3 - 0x1000000000000000) >> 61 == 7)
        {
          size_t v10 = 8 * a3;
          if (((8 * a3) & 0x8000000000000000) == 0)
          {
            memmove(__dst, (const void *)((v7 & 0xFFFFFFFFFFFFFF8) + 8 * a2 + 32), v10);
            goto LABEL_12;
          }
LABEL_22:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
        }
LABEL_21:
        __break(1u);
        goto LABEL_22;
      }
      unint64_t v11 = 192;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Array index out of range", 24, 2, "Swift/SwiftNativeNSArray.swift", 30, 2, v11, 0);
  }
  unint64_t v12 = swift_bridgeObjectRetain(v7);
  uint64_t v13 = specialized _copyCollectionToContiguousArray<A>(_:)(v12);
  specialized closure #1 in Array.withContiguousStorageIfAvailable<A>(_:)((char *)v13 + 32, (uint64_t)v13[2], a2, a3, __dst);
  swift_release((uint64_t)v13);
LABEL_13:

  swift_bridgeObjectRelease(v7);
}

Swift::Void __swiftcall _SwiftNSMutableArray.exchange(at:with:)(Swift::Int at, Swift::Int with)
{
  if (at != with)
  {
    uint64_t v5 = *(void *)(v2 + 16);
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(at, (v5 & 0xC000000000000001) == 0, v5);
    if ((v5 & 0xC000000000000001) != 0)
    {
      id v6 = specialized _ArrayBuffer._getElementSlowPath(_:)(at, v5);
    }
    else
    {
      id v6 = *(id *)(v5 + 8 * at + 32);
      swift_unknownObjectRetain(v6);
    }
    uint64_t v7 = *(void *)(v2 + 16);
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(with, (v7 & 0xC000000000000001) == 0, v7);
    if ((v7 & 0xC000000000000001) != 0)
    {
      id v8 = specialized _ArrayBuffer._getElementSlowPath(_:)(with, v7);
    }
    else
    {
      id v8 = *(id *)(v7 + 8 * with + 32);
      swift_unknownObjectRetain(v8);
    }
    uint64_t v9 = *(void *)(v2 + 16);
    int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v9);
    *(void *)(v2 + 16) = v9;
    if (!isUniquelyReferenced_nonNull_bridgeObject || v9 < 0 || (v9 & 0x4000000000000000) != 0)
    {
      uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew()(v9);
      *(void *)(v2 + 16) = v9;
    }
    specialized Array._checkSubscript_mutating(_:)(at, v9);
    unint64_t v11 = *(void **)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8) + 8 * at + 0x20);
    *(void *)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8) + 8 * at + 0x20) = v8;
    swift_unknownObjectRelease(v11);
    uint64_t v12 = *(void *)(v2 + 16);
    if (v12 < 0 || (v12 & 0x4000000000000000) != 0)
    {
      uint64_t v12 = specialized _ArrayBuffer._consumeAndCreateNew()(*(void *)(v2 + 16));
      *(void *)(v2 + 16) = v12;
    }
    specialized Array._checkSubscript_mutating(_:)(with, v12);
    uint64_t v13 = *(void **)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8) + 8 * with + 0x20);
    *(void *)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8) + 8 * with + 0x20) = v6;
    swift_unknownObjectRelease(v13);
  }
}

void _SwiftNSMutableArray.replaceObjects(in:with:count:)(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = (uint64_t)&a1[a2];
  if (__OFADD__(a1, a2))
  {
    __break(1u);
    goto LABEL_13;
  }
  if (v5 < (uint64_t)a1) {
    goto LABEL_18;
  }
  if (a4 < 0) {
LABEL_13:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  unint64_t v11 = *(void *)(v4 + 16);
  size_t v10 = (uint64_t *)(v4 + 16);
  uint64_t v9 = v11;
  if (v11 >> 62)
  {
    if (v9 < 0) {
      uint64_t v15 = (void *)v9;
    }
    else {
      uint64_t v15 = (void *)(v9 & 0xFFFFFFFFFFFFFF8);
    }
    unint64_t v16 = (unint64_t)[v15 count];
    if ((v16 & 0x8000000000000000) == 0)
    {
      unint64_t v12 = v16;
      goto LABEL_6;
    }
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unint64_t v12 = *(void *)((v9 & 0xFFFFFFFFFFFFFF8) + 0x10);
LABEL_6:
  uint64_t v13 = specialized _copyCollectionToContiguousArray<A>(_:)(a3, a4);
  if (a1 || v5 != v12)
  {
    specialized Array.replaceSubrange<A>(_:with:)(a1, v5, (uint64_t)v13);
  }
  else
  {
    uint64_t v14 = *v10;
    *size_t v10 = (uint64_t)v13;
    swift_bridgeObjectRelease(v14);
  }
}

uint64_t _SwiftNSMutableArray.index(ofObjectIdenticalTo:)(id a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  if ((unint64_t)v3 >> 62)
  {
    if (v3 < 0) {
      uint64_t v9 = *(void **)(v1 + 16);
    }
    else {
      uint64_t v9 = (void *)(v3 & 0xFFFFFFFFFFFFFF8);
    }
    swift_bridgeObjectRetain(v3);
    id v4 = [v9 count];
    if (!v4) {
      goto LABEL_15;
    }
  }
  else
  {
    id v4 = *(id *)((v3 & 0xFFFFFFFFFFFFFF8) + 0x10);
    swift_bridgeObjectRetain(*(void *)(v1 + 16));
    if (!v4) {
      goto LABEL_15;
    }
  }
  if ((v3 & 0xC000000000000001) == 0)
  {
    if (!*(void *)((v3 & 0xFFFFFFFFFFFFFF8) + 0x10)) {
      goto LABEL_18;
    }
    if (*(id *)(v3 + 32) != a1) {
      goto LABEL_6;
    }
LABEL_25:
    swift_bridgeObjectRelease(v3);
    return 0;
  }
  id v10 = specialized _ArrayBuffer._getElementSlowPath(_:)(0, v3);
  swift_unknownObjectRelease(v10);
  if (v10 == a1) {
    goto LABEL_25;
  }
LABEL_6:
  if (v4 != (id)1)
  {
    uint64_t v5 = 5;
    while (1)
    {
      unint64_t v6 = v5 - 4;
      if ((v3 & 0xC000000000000001) != 0)
      {
        id v7 = specialized _ArrayBuffer._getElementSlowPath(_:)(v5 - 4, v3);
        swift_unknownObjectRelease(v7);
        if (v7 == a1) {
          goto LABEL_16;
        }
      }
      else
      {
        if (v6 >= *(void *)((v3 & 0xFFFFFFFFFFFFFF8) + 0x10)) {
          goto LABEL_18;
        }
        if (*(id *)(v3 + 8 * v5) == a1)
        {
LABEL_16:
          swift_bridgeObjectRelease(v3);
          return v6;
        }
      }
      id v8 = (id)(v5 - 3);
      if (__OFADD__(v6, 1)) {
        break;
      }
      ++v5;
      if (v8 == v4) {
        goto LABEL_15;
      }
    }
    __break(1u);
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
LABEL_15:
  swift_bridgeObjectRelease(v3);
  return 0x7FFFFFFFFFFFFFFFLL;
}

void _SwiftNSMutableArray.setObject(_:at:)(void *a1, unint64_t a2)
{
  unint64_t v7 = *(void *)(v2 + 16);
  uint64_t v5 = (uint64_t *)(v2 + 16);
  uint64_t v6 = v7;
  if (v7 >> 62)
  {
    if (v6 < 0) {
      unint64_t v11 = (void *)v6;
    }
    else {
      unint64_t v11 = (void *)(v6 & 0xFFFFFFFFFFFFFF8);
    }
    if (objc_msgSend(v11, sel_count) == (id)a2) {
      goto LABEL_3;
    }
    uint64_t v6 = *v5;
  }
  else if (*(void *)((v6 & 0xFFFFFFFFFFFFFF8) + 0x10) == a2)
  {
LABEL_3:
    swift_unknownObjectRetain(a1);
    specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
    uint64_t v8 = *v5 & 0xFFFFFFFFFFFFFF8;
    unint64_t v10 = *(void *)(v8 + 0x10);
    unint64_t v9 = *(void *)(v8 + 0x18);
    if (v10 >= v9 >> 1)
    {
      uint64_t v14 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v9 > 1, v10 + 1, 1, *v5);
      *uint64_t v5 = v14;
      uint64_t v8 = v14 & 0xFFFFFFFFFFFFFF8;
    }
    *(void *)(v8 + 16) = v10 + 1;
    *(void *)(v8 + 8 * v10 + 32) = a1;
    return;
  }
  swift_unknownObjectRetain(a1);
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v6);
  *uint64_t v5 = v6;
  if (!isUniquelyReferenced_nonNull_bridgeObject || v6 < 0 || (v6 & 0x4000000000000000) != 0)
  {
    uint64_t v6 = specialized _ArrayBuffer._consumeAndCreateNew()(v6);
    *uint64_t v5 = v6;
  }
  specialized Array._checkSubscript_mutating(_:)(a2, v6);
  uint64_t v13 = *(void **)((*v5 & 0xFFFFFFFFFFFFFF8) + 8 * a2 + 0x20);
  *(void *)((*v5 & 0xFFFFFFFFFFFFFF8) + 8 * a2 + 0x20) = a1;

  swift_unknownObjectRelease(v13);
}

void @objc _SwiftNSMutableArray.setObject(_:at:)(atomic_ullong *a1, uint64_t a2, void *a3, unint64_t a4)
{
  swift_unknownObjectRetain(a3);
  swift_retain(a1);
  _SwiftNSMutableArray.setObject(_:at:)(a3, a4);
  swift_release((uint64_t)a1);

  swift_unknownObjectRelease(a3);
}

void _SwiftNSMutableArray.__allocating_init()()
{
}

void _SwiftNSMutableArray.init()()
{
}

void _SwiftNSMutableArray.__ivar_destroyer()
{
  swift_bridgeObjectRelease(*(void *)(v0 + 16));
}

uint64_t _SwiftNSMutableArray.deinit()
{
  swift_bridgeObjectRelease(*(void *)(v0 + 16));
  return v0;
}

void _SwiftNSMutableArray.__deallocating_deinit()
{
  swift_bridgeObjectRelease(*(void *)(v0 + 16));

  swift_deallocClassInstance(v0);
}

atomic_ullong *__SwiftDeferredNSArray._nativeStorage.getter()
{
  return swift_retain(*(atomic_ullong **)(v0 + 24));
}

uint64_t __SwiftDeferredNSArray.init(_nativeStorage:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = a1;
  return v1;
}

uint64_t _SwiftDeferredNSSet.__ivar_destroyer()
{
  swift_unknownObjectRelease(*(id *)(v0 + 16));
  uint64_t v1 = *(void *)(v0 + 24);

  return swift_release(v1);
}

uint64_t __SwiftDeferredNSArray.deinit()
{
  uint64_t v1 = (void *)atomic_load((unint64_t *)(v0 + 16));
  if (v1)
  {
    uint64_t v2 = v1[2];
    swift_unknownObjectRetain(v1);
    if (v2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.deinitialize with negative count", 53, 2, "Swift/UnsafePointer.swift", 25, 2, 0x493uLL, 0);
    }
    swift_arrayDestroy((uint64_t)(v1 + 3), v2, (unint64_t *)qword_1ECA06328);
    swift_unknownObjectRelease(v1);
    uint64_t v3 = *(void **)(v0 + 16);
  }
  else
  {
    uint64_t v3 = 0;
  }
  swift_unknownObjectRelease(v3);
  swift_release(*(void *)(v0 + 24));
  return v0;
}

void __SwiftDeferredNSArray.__deallocating_deinit()
{
  uint64_t v1 = (void *)atomic_load((unint64_t *)(v0 + 16));
  if (v1)
  {
    uint64_t v2 = v1[2];
    swift_unknownObjectRetain(v1);
    if (v2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.deinitialize with negative count", 53, 2, "Swift/UnsafePointer.swift", 25, 2, 0x493uLL, 0);
    }
    swift_arrayDestroy((uint64_t)(v1 + 3), v2, (unint64_t *)qword_1ECA06328);
    swift_unknownObjectRelease(v1);
    uint64_t v3 = *(void **)(v0 + 16);
  }
  else
  {
    uint64_t v3 = 0;
  }
  swift_unknownObjectRelease(v3);
  swift_release(*(void *)(v0 + 24));

  swift_deallocClassInstance(v0);
}

uint64_t __SwiftDeferredNSArray.withUnsafeBufferOfObjects<A>(_:)(uint64_t (*a1)(unint64_t))
{
  uint64_t v2 = a1;
  unint64_t v3 = atomic_load((unint64_t *)(v1 + 16));
  if (v3)
  {
    if ((*(void *)(v3 + 16) & 0x8000000000000000) != 0) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v6 = v1;
    unint64_t v19 = a1;
    do
    {
      uint64_t v7 = *(void *)(v6 + 24);
      uint64_t v8 = (*(void *(**)(unint64_t *__return_ptr, uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, void *@<X8>), void, void *))(*(void *)v7 + 112))(&v17, protocol witness for LosslessStringConvertible.init(_:) in conformance String, 0, &unk_1ECA002E8);
      if (v18 != 1)
      {
        unint64_t v4 = v17;
        uint64_t v2 = v19;
        return v2(v4);
      }
      unint64_t v9 = (atomic_ullong *)(*(uint64_t (**)(void *))(*(void *)v7 + 120))(v8);
      uint64_t v10 = swift_retain_n((uint64_t)v9, 2);
      uint64_t v11 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v6 + 16), (unint64_t *)&v11, v10);
      BOOL v12 = v11 == 0;
      swift_release_n(v10, 2);
      if (!v12)
      {
        uint64_t v13 = type metadata accessor for __BridgingBufferStorage(0);
        uint64_t v14 = swift_retain(v9);
        uint64_t v15 = swift_dynamicCastClass((uint64_t)v14, v13);
        swift_release((uint64_t)v9);
        if (!v15) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
        }
        uint64_t v16 = v9[2];
        if (v16 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.deinitialize with negative count", 53, 2, "Swift/UnsafePointer.swift", 25, 2, 0x493uLL, 0);
        }
        swift_arrayDestroy((uint64_t)(v9 + 3), v16, (unint64_t *)qword_1ECA06328);
        swift_release((uint64_t)v9);
      }
      unint64_t v3 = atomic_load((unint64_t *)(v6 + 16));
    }
    while (!v3);
    uint64_t v2 = v19;
    if ((*(void *)(v3 + 16) & 0x8000000000000000) != 0) {
LABEL_15:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  unint64_t v4 = v3 + 24;
  return v2(v4);
}

void __SwiftDeferredNSArray.__allocating_init()()
{
}

void __SwiftDeferredNSArray.init()()
{
}

uint64_t __SwiftDeferredStaticNSArray.withUnsafeBufferOfObjects<A>(_:)(uint64_t a1)
{
  uint64_t v2 = (uint64_t (*)(unint64_t))a1;
  for (unint64_t i = atomic_load((unint64_t *)(v1 + 16)); !i; unint64_t i = atomic_load((unint64_t *)(v1 + 16)))
  {
    uint64_t v5 = (atomic_ullong *)__SwiftDeferredStaticNSArray.getNonVerbatimBridgingBuffer()(a1);
    uint64_t v6 = swift_retain_n((uint64_t)v5, 2);
    uint64_t v7 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(v1 + 16), (unint64_t *)&v7, v6);
    BOOL v8 = v7 == 0;
    a1 = swift_release_n(v6, 2);
    if (!v8)
    {
      uint64_t v9 = type metadata accessor for __BridgingBufferStorage(0);
      uint64_t v10 = swift_retain(v5);
      uint64_t v11 = swift_dynamicCastClass((uint64_t)v10, v9);
      swift_release((uint64_t)v5);
      if (!v11) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
      }
      uint64_t v12 = v5[2];
      if (v12 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.deinitialize with negative count", 53, 2, "Swift/UnsafePointer.swift", 25, 2, 0x493uLL, 0);
      }
      swift_arrayDestroy((uint64_t)(v5 + 3), v12, (unint64_t *)qword_1ECA06328);
      a1 = swift_release((uint64_t)v5);
    }
  }
  if ((*(void *)(i + 16) & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return v2(i + 24);
}

unint64_t *__SwiftDeferredStaticNSArray.getNonVerbatimBridgingBuffer()(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(*v1 + 120);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  unint64_t v20 = (id *)((char *)&v19 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v24 = v5;
  MEMORY[0x1F4188790](v4);
  uint64_t v7 = (id *)((char *)&v19 - v6);
  BOOL v8 = (atomic_ullong *)v1[3];
  unint64_t v9 = v8[2];
  uint64_t result = (unint64_t *)type metadata accessor for __BridgingBufferStorage(0);
  if (v9 >> 60)
  {
    __break(1u);
    goto LABEL_14;
  }
  if (__OFADD__(8 * v9, 24))
  {
LABEL_14:
    __break(1u);
    return result;
  }
  unint64_t v21 = swift_bufferAllocate(result, 8 * v9 + 24, 7uLL);
  uint64_t v22 = v8;
  void v21[2] = v9;
  swift_retain(v8);
  if (v9)
  {
    uint64_t v11 = v21 + 3;
    uint64_t v12 = v3 + 16;
    uint64_t v23 = *(void (**)(id *, char *, uint64_t *))(v3 + 16);
    uint64_t v13 = (char *)v22 + ((*(unsigned __int8 *)(v3 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
    uint64_t v14 = *(void *)(v3 + 72);
    unint64_t v19 = (void (**)(char *, id *, uint64_t *))(v12 + 16);
    uint64_t v15 = (void (**)(id *, uint64_t *))(v12 - 8);
    do
    {
      v23(v7, v13, v2);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
      {
        if (v24 != 8) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        uint64_t v16 = *v7;
        unint64_t v17 = *v15;
        swift_unknownObjectRetain(*v7);
        v17(v7, v2);
      }
      else
      {
        char v18 = v20;
        (*v19)((char *)v20, v7, v2);
        uint64_t v16 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v18, v2);
      }
      *v11++ = v16;
      v13 += v14;
      --v9;
    }
    while (v9);
  }
  swift_release((uint64_t)v22);
  return v21;
}

void __SwiftDeferredStaticNSArray.__deallocating_deinit()
{
  uint64_t v1 = (void *)atomic_load((unint64_t *)(v0 + 16));
  if (v1)
  {
    uint64_t v2 = v1[2];
    swift_unknownObjectRetain(v1);
    if (v2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.deinitialize with negative count", 53, 2, "Swift/UnsafePointer.swift", 25, 2, 0x493uLL, 0);
    }
    swift_arrayDestroy((uint64_t)(v1 + 3), v2, (unint64_t *)qword_1ECA06328);
    swift_unknownObjectRelease(v1);
    uint64_t v3 = *(void **)(v0 + 16);
  }
  else
  {
    uint64_t v3 = 0;
  }
  swift_unknownObjectRelease(v3);
  swift_release(*(void *)(v0 + 24));

  swift_deallocClassInstance(v0);
}

uint64_t __ContiguousArrayStorageBase.countAndCapacity.getter()
{
  return *(void *)(v0 + 16);
}

uint64_t __ContiguousArrayStorageBase.countAndCapacity.setter(uint64_t result, uint64_t a2)
{
  *(void *)(v2 + 16) = result;
  *(void *)(v2 + 24) = a2;
  return result;
}

uint64_t (*__ContiguousArrayStorageBase.countAndCapacity.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __ContiguousArrayStorageBase.index(ofObjectIdenticalTo:)(id a1)
{
  if (v1 < 0 || (v1 & 0x4000000000000000) != 0)
  {
    id v3 = [v1 count];
    if (!v3) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  else
  {
    id v3 = *(id *)(v1 + 16);
    if (!v3) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  if ((v1 & 0xC000000000000001) == 0)
  {
    if (!*(void *)(v1 + 16)) {
      goto LABEL_19;
    }
    if (*(id *)(v1 + 32) != a1) {
      goto LABEL_7;
    }
    return 0;
  }
  id v8 = specialized _ArrayBuffer._getElementSlowPath(_:)(0, v1);
  swift_unknownObjectRelease(v8);
  if (v8 == a1) {
    return 0;
  }
LABEL_7:
  if (v3 != (id)1)
  {
    uint64_t v4 = 1;
    for (uint64_t i = 5; ; ++i)
    {
      unint64_t v6 = i - 4;
      if ((v1 & 0xC000000000000001) != 0)
      {
        id v7 = specialized _ArrayBuffer._getElementSlowPath(_:)(i - 4, v1);
        swift_unknownObjectRelease(v7);
        if (v7 == a1) {
          return v4;
        }
      }
      else
      {
        if (v6 >= *(void *)(v1 + 16)) {
          goto LABEL_19;
        }
        if (*(id *)(v1 + 8 * i) == a1) {
          return i - 4;
        }
      }
      uint64_t v4 = i - 3;
      if (__OFADD__(v6, 1)) {
        break;
      }
      if ((id)v4 == v3) {
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    __break(1u);
LABEL_19:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t @objc _SwiftNSMutableArray.index(ofObjectIdenticalTo:)(atomic_ullong *a1, uint64_t a2, void *a3, uint64_t (*a4)(void *))
{
  swift_unknownObjectRetain(a3);
  swift_retain(a1);
  uint64_t v7 = a4(a3);
  swift_unknownObjectRelease(a3);
  swift_release((uint64_t)a1);
  return v7;
}

void __ContiguousArrayStorageBase.init()()
{
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.multipliedReportingOverflow(by:)(Swift::Int by)
{
  Swift::Int v2 = v1 * by;
  Swift::Bool v3 = (unsigned __int128)(v1 * (__int128)by) >> 64 != (v1 * by) >> 63;
  Swift::Int v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

void *static UnsafeMutableRawPointer.allocate(byteCount:alignment:)(size_t a1, uint64_t a2)
{
  if (a2 <= 16) {
    unint64_t v2 = -1;
  }
  else {
    unint64_t v2 = a2 - 1;
  }
  return swift_slowAlloc(a1, v2);
}

int64_t static UnsafeMutablePointer.allocate(capacity:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 - 8);
  uint64_t v4 = *(void *)(v3 + 72);
  int64_t result = v4 * a1;
  if ((unsigned __int128)(v4 * (__int128)a1) >> 64 == result >> 63)
  {
    unsigned int v6 = *(unsigned __int8 *)(v3 + 80);
    if (v6 > 0xF) {
      uint64_t v7 = v6 + 1;
    }
    else {
      uint64_t v7 = 0;
    }
    return (int64_t)swift_slowAlloc(result, v7 - 1);
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t _UIntBuffer._storage.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_UIntBuffer._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t _UIntBuffer._bitCount.getter(unint64_t a1)
{
  return HIDWORD(a1);
}

uint64_t _UIntBuffer._bitCount.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 4) = result;
  return result;
}

uint64_t (*_UIntBuffer._bitCount.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t _UIntBuffer.init(_storage:_bitCount:)(unsigned int a1, unsigned __int8 a2)
{
  return a1 | ((unint64_t)a2 << 32);
}

unint64_t _UIntBuffer.init(containing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + 8) + 120))(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v6 | ((unint64_t)(*(unsigned __int8 (**)(uint64_t, uint64_t))(a3 + 56))(a2, a3) << 32);
}

uint64_t _UIntBuffer.Iterator._impl.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t _UIntBuffer.Iterator._impl.setter(uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(unsigned char *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t (*_UIntBuffer.Iterator._impl.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UIntBuffer.Iterator.init(_:)(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t _UIntBuffer.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int v7 = *((unsigned __int8 *)v4 + 4);
  uint64_t v8 = *(void *)(a1 + 16);
  if (v7)
  {
    unsigned int v17 = *v5;
    unsigned int v9 = v17;
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v11 = *(void *)(v10 + 8);
    uint64_t v12 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v11 + 96);
    unint64_t v13 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
    v12(&v17, &type metadata for UInt32, v13, v8, v11);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56))(a4, 0, 1, v8);
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 56);
    *uint64_t v5 = v9 >> v14(v8, v10);
    uint64_t result = v14(v8, v10);
    *((unsigned char *)v5 + 4) = v7 - result;
  }
  else
  {
    uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56);
    return v16(a4, 1, 1, v8);
  }
  return result;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _UIntBuffer<A>.Iterator@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int v7 = *((unsigned __int8 *)v4 + 4);
  uint64_t v8 = *(void *)(a1 + 16);
  if (v7)
  {
    unsigned int v17 = *v5;
    unsigned int v9 = v17;
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v11 = *(void *)(v10 + 8);
    uint64_t v12 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v11 + 96);
    unint64_t v13 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
    v12(&v17, &type metadata for UInt32, v13, v8, v11);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56))(a4, 0, 1, v8);
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 56);
    *uint64_t v5 = v9 >> v14(v8, v10);
    uint64_t result = v14(v8, v10);
    *((unsigned char *)v5 + 4) = v7 - result;
  }
  else
  {
    uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56);
    return v16(a4, 1, 1, v8);
  }
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _UIntBuffer<A>.Iterator@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return Sequence<>.makeIterator()(a1, a2);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _UIntBuffer<A>.Iterator(uint64_t a1, uint64_t a2)
{
  return Sequence._copyToContiguousArray()(a1, a2);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _UIntBuffer<A>.Iterator()
{
  return Sequence._copyContents(initializing:)();
}

uint64_t _UIntBuffer.makeIterator()(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

void protocol witness for Sequence.makeIterator() in conformance _UIntBuffer<A>(uint64_t a1@<X8>)
{
  char v2 = *(unsigned char *)(v1 + 4);
  *(_DWORD *)a1 = *(_DWORD *)v1;
  *(unsigned char *)(a1 + 4) = v2;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _UIntBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _UIntBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a1, a3);
  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t _UIntBuffer.Index.bitOffset.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_UIntBuffer.Index.bitOffset.modify())()
{
  return EnumeratedSequence._base.modify;
}

BOOL static _UIntBuffer.Index.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

BOOL static _UIntBuffer.Index.< infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _UIntBuffer<A>.Index(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return static _UIntBuffer.Index.< infix(_:_:)(*a1, *a2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _UIntBuffer<A>.Index(char *a1, char *a2)
{
  return static _UIntBuffer.Index.== infix(_:_:)(*a1, *a2);
}

uint64_t _UIntBuffer.startIndex.getter()
{
  return 0;
}

unint64_t _UIntBuffer.endIndex.getter(unint64_t a1)
{
  return HIDWORD(a1);
}

uint64_t _UIntBuffer.index(after:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(unsigned int (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4) + a1;
}

uint64_t _UIntBuffer._elementWidth.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized _UIntBuffer._elementWidth.getter(a2, a3);
}

uint64_t _UIntBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v9 = a2 >> a1;
  uint64_t v5 = *(void *)(a4 + 8);
  unsigned int v6 = *(uint64_t (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
  unint64_t v7 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  return v6(&v9, &type metadata for UInt32, v7, a3, v5);
}

void protocol witness for Collection.startIndex.getter in conformance _UIntBuffer<A>(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

void protocol witness for Collection.endIndex.getter in conformance _UIntBuffer<A>(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 4);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _UIntBuffer<A>(void *a1, char *a2, uint64_t a3))()
{
  unint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = _UIntBuffer.subscript.read((uint64_t)v7, *a2, *v3, *(void *)(a3 + 16), *(void *)(a3 + 24));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*_UIntBuffer.subscript.read(uint64_t a1, char a2, unsigned int a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v10 = *(void *)(a4 - 8);
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = v10;
  uint64_t v11 = malloc(*(void *)(v10 + 64));
  *(void *)(a1 + 16) = v11;
  *(_DWORD *)(a1 + 24) = a3 >> a2;
  uint64_t v12 = *(void *)(a5 + 8);
  unint64_t v13 = *(void (**)(uint64_t, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v12 + 96);
  unint64_t v16 = lazy protocol witness table accessor for type UInt32 and conformance UInt32((uint64_t)v11, v14, v15);
  v13(a1 + 24, &type metadata for UInt32, v16, a4, v12);
  return _ArrayBuffer.subscript.read;
}

void protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance _UIntBuffer<A>(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 1;
}

uint64_t _UIntBuffer.index(_:offsetBy:)(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a1 + (*(unsigned int (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5) * a2;
}

uint64_t _UIntBuffer.distance(from:to:)(unsigned __int8 a1, unsigned __int8 a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5);
  if (!v7) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  return (uint64_t)(a2 - (unint64_t)a1) / v7;
}

uint64_t protocol witness for Collection.index(after:) in conformance _UIntBuffer<A>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  char v4 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a3 = result + v4;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance _UIntBuffer<A>(char *a1, uint64_t a2)
{
  char v3 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a1 = result + v3;
  return result;
}

uint64_t _UIntBuffer.index(before:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 - (*(unsigned int (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _UIntBuffer<A>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  char v4 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a3 = v4 - result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance _UIntBuffer<A>(char *a1, uint64_t a2)
{
  char v3 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a1 = v3 - result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _UIntBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _UIntBuffer<A>@<X0>(char *a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  char v6 = *a1;
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a3 + 24) + 56))();
  *a4 = v6 + result * a2;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _UIntBuffer<A>(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a2;
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(a3 + 24) + 56))();
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  return (v4 - v3) / v5;
}

uint64_t FixedWidthInteger._fullShiftLeft<A>(_:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v57 = a6;
  uint64_t v61 = a4;
  uint64_t v53 = a2;
  uint64_t v54 = a1;
  uint64_t v59 = *(void *)(a5 + 8);
  uint64_t v9 = *(void *)(*(void *)(v59 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v13 = (char *)&v43 - v12;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  unsigned int v17 = (char *)&v43 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v20 = (char *)&v43 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  char v58 = (char *)&v43 - v22;
  uint64_t v62 = *(void *)(a2 - 8);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v55 = (char *)&v43 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  unint64_t v60 = (char *)&v43 - v25;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v13, a3, v9);
  (*(void (**)(char *, char *, uint64_t))(a5 + 80))(v20, v17, a3);
  int v27 = *(uint64_t (**)(char *, uint64_t))(v14 + 8);
  uint64_t v28 = v27(v17, a3);
  v63[0] = 1;
  uint64_t v29 = v59;
  uint64_t v30 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v59 + 96);
  uint64_t v50 = v59 + 96;
  uint64_t v52 = v30;
  unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v28, v31, v32);
  v30(v63, &type metadata for Int, v51, a3, v29);
  size_t v48 = *(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 200);
  uint64_t v49 = a5;
  unint64_t v33 = v58;
  v48(v20, v17, a3, a5);
  Swift::Int v46 = (void (*)(char *, uint64_t))v27;
  uint64_t v47 = v14 + 8;
  v27(v17, a3);
  v27(v20, a3);
  uint64_t v34 = v61;
  uint64_t v35 = *(void *)(v61 + 8);
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v35 + 96);
  uint64_t v45 = v35;
  unint64_t v36 = v55;
  uint64_t v37 = v59;
  uint64_t v38 = v53;
  v44(v33, a3, v59, v53);
  char v43 = *(void (**)(void (*)(void, void), char *, uint64_t, uint64_t))(v34 + 216);
  v43((void (*)(void, void))v56, v36, v38, v34);
  uint64_t v56 = *(void (**)(char *, void))(v62 + 8);
  v62 += 8;
  v56(v36, v38);
  v63[0] = 1;
  v52(v63, &type metadata for Int, v51, a3, v37);
  unint64_t v39 = v58;
  v48(v54, v20, a3, v49);
  v46(v20, a3);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v44)(v39, a3, v37, v38, v45);
  unint64_t v40 = v60;
  v43((void (*)(void, void))v60, v36, v38, v61);
  unint64_t v41 = (uint64_t (*)(char *, uint64_t))v56;
  v56(v36, v38);
  return v41(v40, v38);
}

uint64_t FixedWidthInteger._fullShiftRight<A>(_:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v57 = a6;
  uint64_t v61 = a4;
  uint64_t v53 = a2;
  uint64_t v54 = a1;
  uint64_t v59 = *(void *)(a5 + 8);
  uint64_t v9 = *(void *)(*(void *)(v59 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v13 = (char *)&v43 - v12;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  unsigned int v17 = (char *)&v43 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v20 = (char *)&v43 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  char v58 = (char *)&v43 - v22;
  uint64_t v62 = *(void *)(a2 - 8);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v55 = (char *)&v43 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v23);
  unint64_t v60 = (char *)&v43 - v25;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0C0, 512, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v13, a3, v9);
  (*(void (**)(char *, char *, uint64_t))(a5 + 80))(v20, v17, a3);
  int v27 = *(uint64_t (**)(char *, uint64_t))(v14 + 8);
  uint64_t v28 = v27(v17, a3);
  v63[0] = 1;
  uint64_t v29 = v59;
  uint64_t v30 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v59 + 96);
  uint64_t v50 = v59 + 96;
  uint64_t v52 = v30;
  unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v28, v31, v32);
  v30(v63, &type metadata for Int, v51, a3, v29);
  size_t v48 = *(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 200);
  uint64_t v49 = a5;
  unint64_t v33 = v58;
  v48(v20, v17, a3, a5);
  Swift::Int v46 = (void (*)(char *, uint64_t))v27;
  uint64_t v47 = v14 + 8;
  v27(v17, a3);
  v27(v20, a3);
  uint64_t v34 = v61;
  uint64_t v35 = *(void *)(v61 + 8);
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v35 + 96);
  uint64_t v45 = v35;
  unint64_t v36 = v55;
  uint64_t v37 = v59;
  uint64_t v38 = v53;
  v44(v33, a3, v59, v53);
  char v43 = *(void (**)(void (*)(void, void), char *, uint64_t, uint64_t))(v34 + 200);
  v43((void (*)(void, void))v56, v36, v38, v34);
  uint64_t v56 = *(void (**)(char *, void))(v62 + 8);
  v62 += 8;
  v56(v36, v38);
  v63[0] = 1;
  v52(v63, &type metadata for Int, v51, a3, v37);
  unint64_t v39 = v58;
  v48(v54, v20, a3, v49);
  v46(v20, a3);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v44)(v39, a3, v37, v38, v45);
  unint64_t v40 = v60;
  v43((void (*)(void, void))v60, v36, v38, v61);
  unint64_t v41 = (uint64_t (*)(char *, uint64_t))v56;
  v56(v36, v38);
  return v41(v40, v38);
}

uint64_t static FixedWidthInteger._lowBits<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v78 = a1;
  uint64_t v79 = a5;
  uint64_t v77 = a4;
  uint64_t v71 = a6;
  uint64_t v70 = *(void *)(a5 + 8);
  uint64_t v65 = *(int ***)(*(void *)(v70 + 24) + 16);
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(0, v65, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v64 = (char *)&v58 - v10;
  uint64_t v81 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v13 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v74 = (char *)&v58 - v15;
  MEMORY[0x1F4188790](v14);
  Swift::String::Index v76 = (char *)&v58 - v16;
  uint64_t v17 = *(void *)(a4 + 8);
  uint64_t v18 = *(void *)(*(void *)(v17 + 24) + 16);
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)v18, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v20 = MEMORY[0x1F4188790](v19);
  uint64_t v22 = (char *)&v58 - v21;
  uint64_t v80 = *(void *)(a2 - 8);
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v66 = (char *)&v58 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int v27 = (char *)&v58 - v26;
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v62 = (char *)&v58 - v29;
  MEMORY[0x1F4188790](v28);
  unint64_t v69 = (char *)&v58 - v30;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v18, a2, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v19, AssociatedConformanceWitness);
  uint64_t v32 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 24);
  size_t v75 = v27;
  v32(v22, a2, v18);
  uint64_t v72 = v17;
  unint64_t v33 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 184);
  uint64_t v67 = v17 + 184;
  unint64_t v68 = v33;
  v33(v27, a2, v17);
  uint64_t v34 = *(void (**)(char *, uint64_t))(v80 + 8);
  v80 += 8;
  v73 = v34;
  v34(v27, a2);
  uint64_t v35 = v65;
  uint64_t v36 = AssociatedTypeWitness;
  uint64_t v37 = swift_getAssociatedConformanceWitness((uint64_t)v65, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v38 = v64;
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v37 + 8))(&qword_18162B0C0, 512, v36, v37);
  ((void (*)(char *, uint64_t, int **))v35[3])(v38, a3, v35);
  unint64_t v39 = v74;
  (*(void (**)(char *, char *, uint64_t))(v79 + 80))(v74, v13, a3);
  unint64_t v40 = *(uint64_t (**)(char *, uint64_t))(v81 + 8);
  v81 += 8;
  uint64_t v41 = v40(v13, a3);
  v82[0] = 1;
  uint64_t v42 = v70;
  char v64 = *(char **)(v70 + 96);
  char v43 = (void (*)(void *, ValueMetadata *, uint64_t, uint64_t, uint64_t))v64;
  uint64_t v65 = (int **)(v70 + 96);
  uint64_t AssociatedTypeWitness = lazy protocol witness table accessor for type Int and conformance Int(v41, v44, v45);
  v43(v82, &type metadata for Int, AssociatedTypeWitness, a3, v42);
  uint64_t v61 = *(void (**)(char *, char *, uint64_t))(v79 + 200);
  Swift::Int v46 = v76;
  v61(v39, v13, a3);
  unint64_t v60 = (void (*)(char *, uint64_t))v40;
  v40(v13, a3);
  v40(v39, a3);
  uint64_t v59 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v72 + 96);
  uint64_t v47 = v66;
  v59(v46, a3, v42, a2);
  char v58 = *(void (**)(char *, char *, uint64_t))(v77 + 216);
  size_t v48 = v62;
  v58(v62, v47, a2);
  uint64_t v49 = v73;
  v73(v47, a2);
  v49(v48, a2);
  v82[0] = 1;
  uint64_t v50 = v74;
  uint64_t v51 = v42;
  ((void (*)(void *, ValueMetadata *, uint64_t, uint64_t, uint64_t))v64)(v82, &type metadata for Int, AssociatedTypeWitness, a3, v42);
  uint64_t v52 = v76;
  ((void (*)(uint64_t, char *, uint64_t, uint64_t))v61)(v78, v50, a3, v79);
  v60(v50, a3);
  uint64_t v53 = v72;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v59)(v52, a3, v51, a2, v72);
  uint64_t v54 = v69;
  v55 = v75;
  ((void (*)(char *, char *, uint64_t, uint64_t))v58)(v75, v47, a2, v77);
  uint64_t v56 = v73;
  v73(v47, a2);
  v56(v55, a2);
  v68(v54, a2, v53);
  return ((uint64_t (*)(char *, uint64_t))v56)(v54, a2);
}

uint64_t Range._contains_(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v6, v6, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v70 = (char *)&v66 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v67 = (char *)&v66 - v10;
  uint64_t v11 = *(void *)(v6 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v77 = (char *)&v66 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v66 - v15;
  uint64_t v73 = *(void *)(a2 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v72 = (char *)&v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v71 = (char *)&v66 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  unint64_t v68 = (char *)&v66 - v22;
  MEMORY[0x1F4188790](v21);
  unint64_t v69 = (char *)&v66 - v23;
  uint64_t v25 = *(void *)(v24 + 32);
  unint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 40);
  char v26 = v66(v3, a1, v6, v25);
  size_t v75 = v16;
  uint64_t v76 = v25;
  uint64_t v79 = a2;
  if (v26)
  {
    uint64_t v27 = v11;
    uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
    v28(v16, v3, v6);
    uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 16);
  }
  else
  {
    uint64_t v30 = v3;
    uint64_t v31 = a1;
    uint64_t v32 = v30;
    uint64_t v33 = v30 + *(int *)(a2 + 36);
    uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 16);
    uint64_t v27 = v11;
    if (v29(v33, v31, v6, v25))
    {
      uint64_t v34 = v75;
      uint64_t v35 = v33;
    }
    else
    {
      uint64_t v34 = v75;
      uint64_t v35 = v31;
    }
    uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
    v28(v34, v35, v6);
    a1 = v31;
    uint64_t v25 = v76;
    uint64_t v3 = v32;
  }
  uint64_t v36 = *(int *)(v79 + 36);
  uint64_t v37 = v3;
  uint64_t v38 = v3 + v36;
  uint64_t v74 = a1;
  uint64_t v39 = a1 + v36;
  if (v29(v38, v39, v6, v25))
  {
    uint64_t v40 = v27;
    uint64_t v41 = v77;
    uint64_t v42 = v38;
  }
  else
  {
    uint64_t v40 = v27;
    if (v66(v37, v39, v6, v25))
    {
      uint64_t v41 = v77;
      uint64_t v42 = v37;
    }
    else
    {
      uint64_t v41 = v77;
      uint64_t v42 = v39;
    }
  }
  char v43 = (void (*)(char *, char *, uint64_t))v28;
  v28(v41, v42, v6);
  uint64_t v44 = TupleTypeMetadata2;
  uint64_t v45 = v67;
  Swift::Int v46 = &v67[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v47 = v40;
  size_t v48 = *(void (**)(char *, char *, uint64_t))(v40 + 32);
  v48(v67, v75, v6);
  v48(v46, v77, v6);
  uint64_t v49 = *((int *)v44 + 12);
  uint64_t v50 = v70;
  uint64_t v51 = &v70[v49];
  v43(v70, v45, v6);
  v43(v51, v46, v6);
  uint64_t v52 = v68;
  v48(v68, v50, v6);
  uint64_t v53 = *(void (**)(char *, uint64_t))(v47 + 8);
  v53(v51, v6);
  uint64_t v54 = &v50[*((int *)TupleTypeMetadata2 + 12)];
  v48(v50, v45, v6);
  v48(v54, v46, v6);
  uint64_t v55 = v79;
  v48(&v52[*(int *)(v79 + 36)], v54, v6);
  v53(v50, v6);
  uint64_t v56 = v73;
  uint64_t v57 = *(void (**)(char *, char *, uint64_t))(v73 + 32);
  char v58 = v69;
  v57(v69, v52, v55);
  uint64_t v59 = *(void *)(v76 + 8);
  uint64_t v60 = v74;
  uint64_t v77 = *(char **)(v59 + 8);
  LODWORD(TupleTypeMetadata2) = ((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v77)(v58, v74, v6, v59);
  uint64_t v61 = v71;
  v57(v71, v58, v55);
  uint64_t v62 = v72;
  (*(void (**)(char *, uint64_t, uint64_t))(v56 + 16))(v72, v60, v55);
  if (TupleTypeMetadata2) {
    char v63 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v77)(&v61[*(int *)(v55 + 36)], &v62[*(int *)(v55 + 36)], v6, v59);
  }
  else {
    char v63 = 0;
  }
  char v64 = *(void (**)(char *, uint64_t))(v56 + 8);
  v64(v62, v55);
  v64(v61, v55);
  return v63 & 1;
}

uint64_t _UIntBuffer.init()()
{
  return 0;
}

uint64_t _UIntBuffer.capacity.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized _UIntBuffer.capacity.getter(a2, a3);
}

uint64_t static UInt32.bitWidth.getter()
{
  return 32;
}

uint64_t _UIntBuffer.append(_:)(uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = v2;
  uint64_t v113 = a1;
  uint64_t v5 = a2[2];
  uint64_t v6 = a2[3];
  uint64_t v7 = *(void *)(v6 + 8);
  v118 = *(int ***)(*(void *)(v7 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v118, v5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v116 = &v105[-v9];
  uint64_t v125 = *(void *)(v5 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v107 = &v105[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  v110 = &v105[-v13];
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  v109 = &v105[-v15];
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  v115 = &v105[-v17];
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v121 = &v105[-v19];
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v122 = &v105[-v21];
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v124 = &v105[-v23];
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  char v26 = &v105[-v25];
  MEMORY[0x1F4188790](v24);
  uint64_t v28 = &v105[-v27];
  char v29 = *((unsigned char *)v2 + 4);
  int v126 = *v2;
  char v127 = v29;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, v30);
  uint64_t v32 = Collection.count.getter((uint64_t)a2, WitnessTable);
  if (__OFADD__(v32, 1))
  {
    __break(1u);
LABEL_36:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
  }
  if (specialized _UIntBuffer.capacity.getter(v5, v6) < v32 + 1) {
    goto LABEL_36;
  }
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v6 + 64);
  uint64_t v112 = v6;
  v33(v5, v6);
  v123 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  char v34 = v123(v5, v7);
  uint64_t v120 = v7 + 64;
  if (v34)
  {
    uint64_t v35 = v125;
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(v125 + 16))(v26, v28, v5);
    uint64_t v37 = AssociatedTypeWitness;
    uint64_t v36 = v118;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v118, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v39 = v116;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v37, AssociatedConformanceWitness);
    uint64_t v40 = v124;
    ((void (*)(unsigned char *, uint64_t, int **))v36[3])(v39, v5, v36);
    LOBYTE(v37) = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8) + 32))(v26, v40, v5);
    uint64_t v41 = *(void (**)(unsigned char *, uint64_t))(v35 + 8);
    v41(v40, v5);
    if ((v37 & 1) == 0) {
      goto LABEL_37;
    }
    v41(v26, v5);
  }
  uint64_t v43 = v7 + 128;
  uint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
  uint64_t v44 = v42(v5, v7);
  v119 = v3;
  v111 = v42;
  if (v44 >= 32)
  {
    uint64_t v45 = *(void (**)(unsigned char *))(v125 + 16);
    v114 = v28;
    v45(v122);
    unsigned int v128 = -1;
    char v46 = v123(v5, v7);
    uint64_t v47 = v42(v5, v7);
    if (v46)
    {
      if (v47 < 33)
      {
        uint64_t v108 = v7 + 128;
        uint64_t v50 = AssociatedTypeWitness;
        uint64_t v51 = v118;
        uint64_t v52 = swift_getAssociatedConformanceWitness((uint64_t)v118, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v53 = v116;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v52 + 8))(&qword_18162B0B8, 256, v50, v52);
        uint64_t v54 = v124;
        ((void (*)(unsigned char *, uint64_t, int **))v51[3])(v53, v5, v51);
        uint64_t v55 = (void (*)(unsigned char *, unsigned char *, uint64_t))v45;
        uint64_t v56 = v122;
        LOBYTE(v50) = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8)
                                                                           + 40))(v122, v54, v5);
        uint64_t v57 = *(void (**)(unsigned char *, uint64_t))(v125 + 8);
        v57(v54, v5);
        unsigned int v106 = v128;
        char v58 = v115;
        v55(v115, v56, v5);
        if (v50)
        {
          unsigned int v59 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
          v57(v58, v5);
          uint64_t v43 = v108;
          uint64_t v42 = v111;
          uint64_t v28 = v114;
          if (v106 < v59) {
            goto LABEL_30;
          }
        }
        else
        {
          v57(v58, v5);
          uint64_t v43 = v108;
          uint64_t v42 = v111;
          uint64_t v28 = v114;
        }
        goto LABEL_16;
      }
    }
    else if (v47 <= 32)
    {
      char v64 = v124;
      ((void (*)(unsigned char *, unsigned char *, uint64_t))v45)(v124, v122, v5);
      unsigned int v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
      uint64_t v57 = *(void (**)(unsigned char *, uint64_t))(v125 + 8);
      v57(v64, v5);
      uint64_t v42 = v111;
      uint64_t v28 = v114;
      if (v128 < v65) {
        goto LABEL_30;
      }
LABEL_16:
      v57(v122, v5);
      uint64_t v3 = v119;
      goto LABEL_17;
    }
    uint64_t v60 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v61 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v47, v48, v49);
    uint64_t v62 = v124;
    v60(&v128, &type metadata for UInt32, v61, v5, v7);
    char v63 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8) + 16))(v62, v122, v5);
    uint64_t v57 = *(void (**)(unsigned char *, uint64_t))(v125 + 8);
    v57(v62, v5);
    uint64_t v42 = v111;
    uint64_t v28 = v114;
    if (v63) {
      goto LABEL_30;
    }
    goto LABEL_16;
  }
LABEL_17:
  v114 = *(unsigned char **)(v7 + 120);
  v115 = (unsigned char *)(v7 + 120);
  int v66 = ((uint64_t (*)(uint64_t, uint64_t))v114)(v5, v7);
  uint64_t v67 = v125;
  v122 = *(unsigned char **)(v125 + 8);
  ((void (*)(unsigned char *, uint64_t))v122)(v28, v5);
  *v3 &= ~(v66 << *((unsigned char *)v3 + 4));
  uint64_t v69 = v67 + 16;
  unint64_t v68 = *(void (**)(unsigned char *, uint64_t, uint64_t))(v67 + 16);
  uint64_t v70 = v121;
  v68(v121, v113, v5);
  char v71 = v123(v5, v7);
  uint64_t v125 = v69;
  if ((v71 & 1) == 0) {
    goto LABEL_20;
  }
  uint64_t v108 = v43;
  uint64_t v72 = v109;
  v68(v109, (uint64_t)v70, v5);
  uint64_t v73 = AssociatedTypeWitness;
  uint64_t v74 = v118;
  uint64_t v75 = swift_getAssociatedConformanceWitness((uint64_t)v118, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v76 = v116;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v75 + 8))(&qword_18162B0B8, 256, v73, v75);
  uint64_t v77 = v124;
  ((void (*)(unsigned char *, uint64_t, int **))v74[3])(v76, v5, v74);
  uint64_t v113 = v7;
  LOBYTE(v73) = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8) + 32))(v72, v77, v5);
  uint64_t v78 = (void (*)(unsigned char *, uint64_t))v122;
  ((void (*)(unsigned char *, uint64_t))v122)(v77, v5);
  if ((v73 & 1) == 0) {
LABEL_37:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  v78(v72, v5);
  uint64_t v42 = v111;
  uint64_t v7 = v113;
LABEL_20:
  if (v42(v5, v7) >= 32)
  {
    uint64_t v79 = v70;
    uint64_t v80 = v110;
    v68(v110, (uint64_t)v79, v5);
    v129[0] = -1;
    uint64_t v81 = v80;
    LOBYTE(v80) = v123(v5, v7);
    uint64_t v82 = v42(v5, v7);
    if (v80)
    {
      uint64_t v85 = (void (*)(unsigned char *, uint64_t))v122;
      if (v82 < 33)
      {
        uint64_t v86 = AssociatedTypeWitness;
        uint64_t v87 = v118;
        uint64_t v88 = swift_getAssociatedConformanceWitness((uint64_t)v118, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        id v89 = v116;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v88 + 8))(&qword_18162B0B8, 256, v86, v88);
        uint64_t v90 = v124;
        ((void (*)(unsigned char *, uint64_t, int **))v87[3])(v89, v5, v87);
        LOBYTE(v86) = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8)
                                                                           + 40))(v81, v90, v5);
        v85(v90, v5);
        unsigned int v91 = v129[0];
        unint64_t v92 = v107;
        v68(v107, (uint64_t)v81, v5);
        if (v86)
        {
          unsigned int v93 = ((uint64_t (*)(uint64_t, uint64_t))v114)(v5, v7);
          v85(v92, v5);
          BOOL v94 = v91 >= v93;
          goto LABEL_29;
        }
        v85(v92, v5);
        uint64_t v70 = v121;
LABEL_33:
        v85(v81, v5);
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v85 = (void (*)(unsigned char *, uint64_t))v122;
      if (v82 <= 32)
      {
        uint64_t v99 = v124;
        v68(v124, (uint64_t)v81, v5);
        unsigned int v100 = ((uint64_t (*)(uint64_t, uint64_t))v114)(v5, v7);
        v85(v99, v5);
        BOOL v94 = v129[0] >= v100;
LABEL_29:
        uint64_t v70 = v121;
        if (!v94) {
          goto LABEL_30;
        }
        goto LABEL_33;
      }
    }
    uint64_t v95 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v96 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v82, v83, v84);
    uint64_t v97 = v124;
    v95(v129, &type metadata for UInt32, v96, v5, v7);
    uint64_t v81 = v110;
    char v98 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8) + 16))(v97, v110, v5);
    v85(v97, v5);
    uint64_t v70 = v121;
    if ((v98 & 1) == 0) {
      goto LABEL_33;
    }
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
LABEL_34:
  int v101 = ((uint64_t (*)(uint64_t, uint64_t))v114)(v5, v7);
  ((void (*)(unsigned char *, uint64_t))v122)(v70, v5);
  uint64_t v102 = v119;
  char v103 = *((unsigned char *)v119 + 4);
  *v119 |= v101 << v103;
  uint64_t result = (*(uint64_t (**)(uint64_t))(v112 + 56))(v5);
  *((unsigned char *)v102 + 4) = v103 + result;
  return result;
}

uint64_t _UIntBuffer.removeFirst()(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a1, a3);
  uint64_t v7 = Collection.isEmpty.getter((uint64_t)a1, WitnessTable);
  if (v7) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xC8uLL, 0);
  }
  unsigned int v19 = *v3;
  unsigned int v10 = v19;
  unint64_t v11 = a1[2];
  unint64_t v12 = a1[3];
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v14 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v13 + 96);
  unint64_t v15 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v7, v8, v9);
  v14(&v19, &type metadata for UInt32, v15, v11, v13);
  char v16 = *((unsigned char *)v4 + 4);
  uint64_t v17 = *(uint64_t (**)(unint64_t, unint64_t))(v12 + 56);
  *((unsigned char *)v4 + 4) = v16 - v17(v11, v12);
  uint64_t result = v17(v11, v12);
  *uint64_t v4 = v10 >> ((result + 1) >> 1) >> (result >> 1);
  return result;
}

uint64_t _UIntBuffer.replaceSubrange<A>(_:with:)(uint64_t a1, void (**a2)(char *, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (unint64_t *)a3;
  v197 = a2;
  unsigned int v8 = a1;
  uint64_t v157 = a1;
  uint64_t v9 = BYTE1(a1);
  uint64_t v10 = *(void *)(a3 + 16);
  uint64_t v11 = *(void *)(a3 + 24);
  unint64_t v12 = *(void **)(v11 + 8);
  v182 = *(int ***)(v12[3] + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v182, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v180 = (char *)&v154 - v14;
  uint64_t v15 = *(void *)(v10 - 8);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v159 = (char *)&v154 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v158 = (char *)&v154 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v176 = (char *)&v154 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v162 = (char *)&v154 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v183 = (char *)&v154 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v189 = (char *)&v154 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v163 = (char *)&v154 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v184 = (char *)&v154 - v31;
  MEMORY[0x1F4188790](v30);
  v190 = (char *)&v154 - v32;
  uint64_t v35 = type metadata accessor for Optional(0, v10, v33, v34);
  MEMORY[0x1F4188790](v35 - 1);
  v175 = (char *)&v154 - v36;
  uint64_t v37 = *(void *)(a5 + 8);
  v178 = swift_getAssociatedTypeWitness(0, (int **)v37, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v38 = MEMORY[0x1F4188790](v178);
  v177 = (char *)&v154 - v39;
  MEMORY[0x1F4188790](v38);
  uint64_t v44 = (char *)&v154 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v9 < v8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unsigned int v45 = *(unsigned __int8 *)(v160 + 4);
  if (v45 < v8 || v45 < v9) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xD4uLL, 0);
  }
  uint64_t v46 = v160;
  uint64_t v156 = v9;
  uint64_t v155 = v41;
  uint64_t v47 = v42;
  (*(void (**)(char *, void (**)(char *, uint64_t), uint64_t))(v40 + 16))(v44, v197, v42);
  (*(void (**)(uint64_t, uint64_t))(v37 + 32))(v47, v37);
  uint64_t v48 = v47;
  uint64_t v49 = v178;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v37, v48, (uint64_t)v178, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v51 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v52 = v175;
  uint64_t v173 = AssociatedConformanceWitness;
  uint64_t v172 = AssociatedConformanceWitness + 16;
  v171 = v51;
  ((void (*)(const char *))v51)(v49);
  uint64_t v53 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v15 + 48);
  uint64_t v170 = v15 + 48;
  v169 = v53;
  int v54 = v53(v52, 1, v10);
  v174 = v7;
  if (v54 != 1)
  {
    unsigned int v56 = 0;
    uint64_t v196 = 0;
    char v58 = *(void (**)(char *, char *, uint64_t))(v15 + 32);
    uint64_t v57 = v15 + 32;
    v168 = v58;
    uint64_t v167 = v11 + 64;
    v187 = v12 + 8;
    v193 = (void (**)(char *, char *, uint64_t))(v57 - 16);
    v179 = v182 + 3;
    v197 = (void (**)(char *, uint64_t))(v57 - 24);
    v195 = v12 + 16;
    v191 = v12 + 15;
    v161 = v12 + 12;
    uint64_t v164 = v11 + 56;
    unsigned int v59 = v184;
    uint64_t v166 = v11;
    uint64_t v165 = v57;
    v58(v190, v52, v10);
    while (1)
    {
      int v188 = v56;
      unsigned int v198 = v56;
      char v199 = v196;
      uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, v7, v60);
      uint64_t v76 = Collection.count.getter((uint64_t)v7, WitnessTable);
      if (__OFADD__(v76, 1))
      {
        __break(1u);
LABEL_52:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      }
      if (specialized _UIntBuffer.capacity.getter(v10, v11) < v76 + 1) {
        goto LABEL_52;
      }
      (*(void (**)(uint64_t, uint64_t))(v11 + 64))(v10, v11);
      uint64_t v77 = (uint64_t (*)(void, void))v12[8];
      if (v77(v10, v12))
      {
        uint64_t v78 = v77;
        uint64_t v79 = v59;
        uint64_t v80 = v163;
        (*v193)(v163, v79, v10);
        uint64_t v82 = AssociatedTypeWitness;
        uint64_t v81 = v182;
        uint64_t v83 = swift_getAssociatedConformanceWitness((uint64_t)v182, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v84 = v180;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v83 + 8))(&qword_18162B0B8, 256, v82, v83);
        uint64_t v85 = v189;
        ((void (*)(char *, uint64_t, int **))v81[3])(v84, v10, v81);
        LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8) + 32))(v80, v85, v10);
        uint64_t v86 = *v197;
        (*v197)(v85, v10);
        if ((v82 & 1) == 0) {
          goto LABEL_53;
        }
        v86(v80, v10);
        unsigned int v59 = v184;
        uint64_t v77 = v78;
      }
      v194 = (uint64_t (*)(uint64_t, void *))v12[16];
      if (v194(v10, v12) >= 32) {
        break;
      }
LABEL_30:
      int v66 = (uint64_t (*)(uint64_t, void *))v12[15];
      uint64_t v185 = v66(v10, v12);
      uint64_t v108 = *v197;
      (*v197)(v59, v10);
      char v109 = v77(v10, v12);
      v186 = v66;
      if (v109)
      {
        v110 = v77;
        v111 = v162;
        (*v193)(v162, v190, v10);
        uint64_t v113 = AssociatedTypeWitness;
        uint64_t v112 = v182;
        uint64_t v114 = swift_getAssociatedConformanceWitness((uint64_t)v182, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v115 = v180;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v114 + 8))(&qword_18162B0B8, 256, v113, v114);
        v116 = v189;
        ((void (*)(char *, uint64_t, int **))v112[3])(v115, v10, v112);
        LOBYTE(v113) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8) + 32))(v111, v116, v10);
        v108(v116, v10);
        if ((v113 & 1) == 0) {
LABEL_53:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
        v108(v111, v10);
        unsigned int v59 = v184;
        uint64_t v77 = v110;
        int v66 = v186;
      }
      v192 = v108;
      unsigned int v65 = v190;
      if (v194(v10, v12) >= 32)
      {
        v117 = *v193;
        (*v193)(v176, v65, v10);
        unsigned int v198 = -1;
        char v118 = v77(v10, v12);
        uint64_t v119 = v194(v10, v12);
        if (v118)
        {
          v122 = v192;
          if (v119 <= 32)
          {
            v123 = AssociatedTypeWitness;
            v124 = v182;
            uint64_t v125 = swift_getAssociatedConformanceWitness((uint64_t)v182, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            int v126 = v180;
            (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v125 + 8))(&qword_18162B0B8, 256, v123, v125);
            char v127 = v189;
            ((void (*)(char *, uint64_t, int **))v124[3])(v126, v10, v124);
            unsigned int v128 = v176;
            LOBYTE(v123) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8) + 40))(v176, v127, v10);
            v122(v127, v10);
            unsigned int v129 = v198;
            v130 = v158;
            v117(v158, v128, v10);
            if (v123)
            {
              v131 = v186;
              unsigned int v132 = v186(v10, v12);
              v122(v130, v10);
              BOOL v133 = v129 >= v132;
              int v66 = v131;
              char v64 = v176;
              unsigned int v65 = v190;
              if (!v133) {
                goto LABEL_54;
              }
            }
            else
            {
              v122(v130, v10);
              char v64 = v176;
              unsigned int v65 = v190;
              int v66 = v186;
            }
            goto LABEL_9;
          }
        }
        else
        {
          v122 = v192;
          if (v119 <= 32)
          {
            v134 = v189;
            char v64 = v176;
            v117(v189, v176, v10);
            int v66 = v186;
            unsigned int v135 = v186(v10, v12);
            v122(v134, v10);
            BOOL v133 = v198 >= v135;
            unsigned int v65 = v190;
            if (!v133) {
LABEL_54:
            }
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
            goto LABEL_9;
          }
        }
        unint64_t v61 = (void (*)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, void *))v12[12];
        unint64_t v62 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v119, v120, v121);
        char v63 = v189;
        v61(&v198, &type metadata for UInt32, v62, v10, v12);
        char v64 = v176;
        LOBYTE(v61) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8) + 16))(v63, v176, v10);
        v122(v63, v10);
        unsigned int v65 = v190;
        int v66 = v186;
        if (v61) {
          goto LABEL_54;
        }
LABEL_9:
        v122(v64, v10);
        unsigned int v59 = v184;
      }
      int v67 = v196;
      char v68 = v196 & 0x1F;
      int v69 = v188 & ~(v185 << v196);
      int v70 = v66(v10, v12);
      v192(v65, v10);
      int v71 = (v70 << v68) | v69;
      uint64_t v72 = v65;
      uint64_t v11 = v166;
      uint64_t v196 = v67 + (*(unsigned int (**)(uint64_t, uint64_t))(v166 + 56))(v10, v166);
      uint64_t v73 = v175;
      v171(v178, v173);
      unsigned int v56 = v71;
      int v74 = v169(v73, 1, v10);
      uint64_t v7 = v174;
      if (v74 == 1)
      {
        int v188 = v71;
        uint64_t v55 = v196;
        uint64_t v46 = v160;
        goto LABEL_44;
      }
      v168(v72, v73, v10);
    }
    uint64_t v87 = *v193;
    (*v193)(v183, v59, v10);
    unsigned int v198 = -1;
    char v88 = v77(v10, v12);
    uint64_t v89 = v194(v10, v12);
    unint64_t v92 = v77;
    if (v88)
    {
      if (v89 <= 32)
      {
        BOOL v94 = AssociatedTypeWitness;
        unsigned int v93 = v182;
        uint64_t v95 = swift_getAssociatedConformanceWitness((uint64_t)v182, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v96 = v180;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v95 + 8))(&qword_18162B0B8, 256, v94, v95);
        uint64_t v97 = v189;
        ((void (*)(char *, uint64_t, int **))v93[3])(v96, v10, v93);
        char v98 = v183;
        LOBYTE(v94) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8) + 40))(v183, v97, v10);
        uint64_t v99 = *v197;
        (*v197)(v97, v10);
        LODWORD(v192) = v198;
        unsigned int v100 = v159;
        v87(v159, v98, v10);
        if (v94)
        {
          unsigned int v101 = ((uint64_t (*)(uint64_t, void *))v12[15])(v10, v12);
          v99(v100, v10);
          unsigned int v59 = v184;
          if (v192 < v101) {
            goto LABEL_54;
          }
        }
        else
        {
          v99(v100, v10);
          unsigned int v59 = v184;
        }
LABEL_29:
        v99(v183, v10);
        uint64_t v77 = v92;
        goto LABEL_30;
      }
    }
    else if (v89 <= 32)
    {
      unsigned int v106 = v189;
      v87(v189, v183, v10);
      unsigned int v107 = ((uint64_t (*)(uint64_t, void *))v12[15])(v10, v12);
      uint64_t v99 = *v197;
      (*v197)(v106, v10);
      if (v198 < v107) {
        goto LABEL_54;
      }
      goto LABEL_29;
    }
    uint64_t v102 = (void (*)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, void *))v12[12];
    unint64_t v103 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v89, v90, v91);
    v104 = v189;
    v102(&v198, &type metadata for UInt32, v103, v10, v12);
    char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8) + 16))(v104, v183, v10);
    uint64_t v99 = *v197;
    (*v197)(v104, v10);
    if (v105) {
      goto LABEL_54;
    }
    goto LABEL_29;
  }
  uint64_t v55 = 0;
  int v188 = 0;
LABEL_44:
  uint64_t v136 = v156;
  unsigned __int8 v137 = v157;
  (*(void (**)(char *, const char *))(v155 + 8))(v177, v178);
  v138 = *(uint64_t (**)(uint64_t, uint64_t))(v11 + 56);
  uint64_t v139 = v138(v10, v11);
  if (!v139 || (uint64_t v140 = v139, (v141 = v138(v10, v11)) == 0)) {
LABEL_55:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  char v143 = *(unsigned char *)(v46 + 4);
  uint64_t v144 = v55 / v141 - (v136 - v137) / v140;
  unsigned int v198 = *(_DWORD *)v46;
  char v199 = v143;
  v145 = v174;
  uint64_t v146 = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, v174, v142);
  uint64_t v147 = Collection.count.getter((uint64_t)v145, v146);
  if (__OFADD__(v147, v144))
  {
    __break(1u);
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xDDuLL, 0);
  }
  if (specialized _UIntBuffer.capacity.getter(v10, v11) < v147 + v144) {
    goto LABEL_58;
  }
  uint64_t v148 = v138(v10, v11);
  if (!v148) {
    goto LABEL_55;
  }
  uint64_t v149 = v148;
  uint64_t v150 = v138(v10, v11);
  if (!v150) {
    goto LABEL_55;
  }
  uint64_t v151 = v137 / v149;
  uint64_t v152 = v156 / v150;
  uint64_t result = v138(v10, v11);
  *(_DWORD *)uint64_t v46 = (*(_DWORD *)v46 >> ((result * v152 + 1) >> 1) >> ((result * v152) >> 1) << (result * (v152 + v144))) | (v188 << (result * v151)) | ((1 << ((result * v151 + 1) >> 1) << ((result * v151) >> 1)) - 1) & *(_DWORD *)v46;
  *(unsigned char *)(v46 + 4) += result * v144;
  return result;
}

void protocol witness for RangeReplaceableCollection.init() in conformance _UIntBuffer<A>(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(unsigned char *)(a1 + 4) = 0;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  uint64_t v9 = v6;
  unint64_t v12 = (unsigned __int8 *)MEMORY[0x1F4188790](a1);
  uint64_t v16 = (char *)&v38 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = *v12;
  uint64_t v18 = v12[1];
  if (v18 < v17) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unsigned int v19 = *((unsigned __int8 *)v9 + 4);
  if (v17 > v19 || v18 > v19) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xD4uLL, 0);
  }
  uint64_t v42 = v14;
  uint64_t v43 = v13;
  (*(void (**)(char *))(v14 + 16))(v16);
  RangeReplaceableCollection.init<A>(_:)((uint64_t)v16, (uint64_t)a5, a3, a6, *(void *)(a4 + 8));
  int v21 = v49;
  LODWORD(v44) = v50;
  uint64_t v23 = a5[2];
  uint64_t v22 = a5[3];
  uint64_t v41 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
  uint64_t v24 = v41(v23, v22);
  if (!v24) {
LABEL_14:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  uint64_t v40 = a3;
  int v39 = v21;
  int v47 = v21;
  char v48 = v44;
  uint64_t v26 = (v18 - v17) / v24;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a5, v25);
  uint64_t v28 = Collection.count.getter((uint64_t)a5, WitnessTable) - v26;
  char v29 = *((unsigned char *)v9 + 4);
  unsigned int v45 = *v9;
  char v46 = v29;
  uint64_t v30 = Collection.count.getter((uint64_t)a5, WitnessTable);
  if (__OFADD__(v30, v28))
  {
    __break(1u);
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xDDuLL, 0);
  }
  if (_UIntBuffer.capacity.getter(v30, v23, v22) < v30 + v28) {
    goto LABEL_17;
  }
  uint64_t v44 = v28;
  (*(void (**)(uint64_t, uint64_t))(v42 + 8))(v43, v40);
  uint64_t v31 = v41;
  uint64_t v32 = v41(v23, v22);
  if (!v32) {
    goto LABEL_14;
  }
  uint64_t v33 = v32;
  uint64_t v34 = v31(v23, v22);
  if (!v34) {
    goto LABEL_14;
  }
  uint64_t v35 = v18 / v34;
  uint64_t result = v31(v23, v22);
  char v37 = v44;
  *uint64_t v9 = (*v9 >> ((result * v35 + 1) >> 1) >> ((result * v35) >> 1) << (result * (v35 + v44))) | (v39 << (result * (v17 / v33))) | ((1 << ((result * (v17 / v33) + 1) >> 1) << ((result * (v17 / v33)) >> 1)) - 1) & *v9;
  *((unsigned char *)v9 + 4) += result * v37;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append(_:) in conformance _UIntBuffer<A>(char *a1, unint64_t *a2)
{
  v115 = a1;
  uint64_t v4 = a2[2];
  uint64_t v5 = a2[3];
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v112 = *(int ***)(*(void *)(v6 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v112, v4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v110 = (char *)&v98 - v8;
  uint64_t v119 = *(void *)(v4 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v102 = (char *)&v98 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  char v105 = (char *)&v98 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v108 = (char *)&v98 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v103 = (char *)&v98 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unsigned int v19 = (char *)&v98 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v98 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = (char *)&v98 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)&v98 - v26;
  int v28 = *v2;
  char v118 = v2;
  char v29 = *((unsigned char *)v2 + 4);
  int v120 = v28;
  char v121 = v29;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, v30);
  uint64_t v32 = Collection.count.getter((uint64_t)a2, WitnessTable);
  if (__OFADD__(v32, 1))
  {
    __break(1u);
LABEL_36:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
  }
  unint64_t v33 = a2[4];
  if (_UIntBuffer.capacity.getter(v32, v4, v5) < v32 + 1) {
    goto LABEL_36;
  }
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v4, v5);
  v116 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 64);
  uint64_t v117 = v6 + 64;
  char v34 = v116(v4, v6);
  unint64_t v113 = v33;
  char v109 = v19;
  if (v34)
  {
    uint64_t v35 = v119;
    (*(void (**)(char *, char *, uint64_t))(v119 + 16))(v25, v27, v4);
    uint64_t v36 = AssociatedTypeWitness;
    char v37 = v112;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v112, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    int v39 = v110;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v36, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v37[3])(v39, v4, v37);
    LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 32))(v25, v22, v4);
    uint64_t v40 = *(void (**)(char *, uint64_t))(v35 + 8);
    v40(v22, v4);
    if ((v36 & 1) == 0) {
      goto LABEL_37;
    }
    v40(v25, v4);
    unsigned int v19 = v109;
  }
  uint64_t v106 = v5;
  uint64_t v41 = v6 + 128;
  uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 128);
  uint64_t v42 = v114(v4, v6);
  unsigned int v107 = v22;
  if (v42 >= 32)
  {
    unsigned int v101 = *(void (**)(char *, char *, uint64_t))(v119 + 16);
    v101(v19, v27, v4);
    unsigned int v122 = -1;
    char v43 = v116(v4, v6);
    uint64_t v44 = v114(v4, v6);
    if (v43)
    {
      if (v44 < 33)
      {
        uint64_t v104 = v6 + 128;
        int v47 = AssociatedTypeWitness;
        char v48 = v112;
        uint64_t v49 = swift_getAssociatedConformanceWitness((uint64_t)v112, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unsigned __int8 v50 = v19;
        uint64_t v51 = v110;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v49 + 8))(&qword_18162B0B8, 256, v47, v49);
        ((void (*)(char *, uint64_t, int **))v48[3])(v51, v4, v48);
        int v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 40))(v50, v22, v4);
        uint64_t v52 = *(void (**)(char *, uint64_t))(v119 + 8);
        v52(v22, v4);
        unsigned int v99 = v122;
        uint64_t v53 = v103;
        v101(v103, v50, v4);
        if (v100)
        {
          unsigned int v54 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(v4, v6);
          v52(v53, v4);
          uint64_t v41 = v104;
          if (v99 < v54) {
            goto LABEL_30;
          }
        }
        else
        {
          v52(v53, v4);
          uint64_t v41 = v104;
        }
        goto LABEL_16;
      }
    }
    else if (v44 <= 32)
    {
      v101(v22, v19, v4);
      unsigned int v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(v4, v6);
      uint64_t v52 = *(void (**)(char *, uint64_t))(v119 + 8);
      v52(v22, v4);
      if (v122 < v58) {
        goto LABEL_30;
      }
LABEL_16:
      v52(v109, v4);
      goto LABEL_17;
    }
    uint64_t v55 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
    unint64_t v56 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v44, v45, v46);
    v55(&v122, &type metadata for UInt32, v56, v4, v6);
    char v57 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 16))(v22, v19, v4);
    uint64_t v52 = *(void (**)(char *, uint64_t))(v119 + 8);
    v52(v22, v4);
    if (v57) {
      goto LABEL_30;
    }
    goto LABEL_16;
  }
LABEL_17:
  char v109 = *(char **)(v6 + 120);
  int v59 = ((uint64_t (*)(uint64_t, uint64_t))v109)(v4, v6);
  uint64_t v60 = *(void (**)(char *, uint64_t))(v119 + 8);
  v60(v27, v4);
  *v118 &= ~(v59 << *((unsigned char *)v118 + 4));
  char v61 = v116(v4, v6);
  unint64_t v62 = v115;
  if ((v61 & 1) == 0) {
    goto LABEL_20;
  }
  uint64_t v104 = v41;
  (*(void (**)(char *, char *, uint64_t))(v119 + 16))(v108, v115, v4);
  char v63 = AssociatedTypeWitness;
  char v64 = v112;
  uint64_t v65 = swift_getAssociatedConformanceWitness((uint64_t)v112, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int v66 = v110;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v65 + 8))(&qword_18162B0B8, 256, v63, v65);
  int v67 = v107;
  char v68 = v66;
  int v69 = v108;
  ((void (*)(char *, uint64_t, int **))v64[3])(v68, v4, v64);
  LOBYTE(v63) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 32))(v69, v67, v4);
  v60(v67, v4);
  if ((v63 & 1) == 0) {
LABEL_37:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  v60(v69, v4);
LABEL_20:
  int v70 = v114;
  if (v114(v4, v6) >= 32)
  {
    int v71 = *(char **)(v119 + 16);
    uint64_t v72 = v105;
    v119 += 16;
    uint64_t v108 = v71;
    ((void (*)(char *, char *, uint64_t))v71)(v105, v62, v4);
    v123[0] = -1;
    char v73 = v116(v4, v6);
    uint64_t v74 = v70(v4, v6);
    if (v73)
    {
      if (v74 < 33)
      {
        uint64_t v77 = AssociatedTypeWitness;
        uint64_t v78 = v112;
        uint64_t v79 = swift_getAssociatedConformanceWitness((uint64_t)v112, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v80 = v72;
        uint64_t v81 = v110;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v79 + 8))(&qword_18162B0B8, 256, v77, v79);
        uint64_t v82 = v107;
        uint64_t v83 = v81;
        uint64_t v72 = v80;
        ((void (*)(char *, uint64_t, int **))v78[3])(v83, v4, v78);
        LOBYTE(v77) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 40))(v80, v82, v4);
        v60(v82, v4);
        unsigned int v84 = v123[0];
        uint64_t v85 = v102;
        ((void (*)(char *, char *, uint64_t))v108)(v102, v80, v4);
        if (v77)
        {
          unsigned int v86 = ((uint64_t (*)(uint64_t, uint64_t))v109)(v4, v6);
          v60(v85, v4);
          BOOL v87 = v84 >= v86;
          goto LABEL_29;
        }
        v60(v85, v4);
        unint64_t v62 = v115;
LABEL_33:
        v60(v72, v4);
        goto LABEL_34;
      }
    }
    else if (v74 <= 32)
    {
      unint64_t v92 = v107;
      ((void (*)(char *, char *, uint64_t))v108)(v107, v72, v4);
      unsigned int v93 = ((uint64_t (*)(uint64_t, uint64_t))v109)(v4, v6);
      v60(v92, v4);
      BOOL v87 = v123[0] >= v93;
LABEL_29:
      unint64_t v62 = v115;
      if (!v87) {
        goto LABEL_30;
      }
      goto LABEL_33;
    }
    char v88 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
    unint64_t v89 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v74, v75, v76);
    uint64_t v90 = v107;
    v88(v123, &type metadata for UInt32, v89, v4, v6);
    char v91 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 16))(v90, v72, v4);
    v60(v90, v4);
    unint64_t v62 = v115;
    if ((v91 & 1) == 0) {
      goto LABEL_33;
    }
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
LABEL_34:
  int v94 = ((uint64_t (*)(uint64_t, uint64_t))v109)(v4, v6);
  v60(v62, v4);
  uint64_t v95 = v118;
  char v96 = *((unsigned char *)v118 + 4);
  *v118 |= v94 << v96;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(v4, v106);
  *((unsigned char *)v95 + 4) = result + v96;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance _UIntBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v3;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a1, a3);
  uint64_t v7 = Collection.isEmpty.getter((uint64_t)a1, WitnessTable);
  if (v7) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xC8uLL, 0);
  }
  unsigned int v19 = *v3;
  unsigned int v10 = v19;
  unint64_t v11 = a1[2];
  unint64_t v12 = a1[3];
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v14 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v13 + 96);
  unint64_t v15 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v7, v8, v9);
  v14(&v19, &type metadata for UInt32, v15, v11, v13);
  char v16 = *((unsigned char *)v5 + 4);
  uint64_t v17 = *(uint64_t (**)(unint64_t, unint64_t))(v12 + 56);
  *((unsigned char *)v5 + 4) = v16 - v17(v11, v12);
  uint64_t result = v17(v11, v12);
  *uint64_t v5 = v10 >> ((result + 1) >> 1) >> (result >> 1);
  return result;
}

uint64_t static _UnicodeEncoding.transcode<A>(_:from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return static _UnicodeEncoding.transcode<A>(_:from:)(a1, a2, a5, a3, a6, a4);
}

{
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t);
  uint64_t vars8;

  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a6 + 88))(a1, a4, a6);
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 96);

  return v9(v8, a3, a5);
}

uint64_t specialized static _UnicodeEncoding.transcode<A>(_:from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a4 + 88))(a1, a3, a4);
}

uint64_t static _UnicodeEncoding._isScalar(_:)()
{
  return 0;
}

uint64_t static _UnicodeEncoding._encode(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  unint64_t v11 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v12 = (uint64_t)*(v11 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  unint64_t v15 = (char *)&v20 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v20 - v16;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 96))(a1, a2, a3);
  (*(void (**)(char *, char *, Class *))(v12 + 32))(v15, v17, v11);
  uint64_t v18 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v18 + 48))(v15, 1, AssociatedTypeWitness) != 1) {
    return (*(uint64_t (**)(uint64_t, char *, const char *))(v18 + 32))(a4, v15, AssociatedTypeWitness);
  }
  (*(void (**)(uint64_t, uint64_t))(a3 + 80))(a2, a3);
  return (*(uint64_t (**)(char *, Class *))(v12 + 8))(v15, v11);
}

uint64_t static _UnicodeEncoding._transcode<A>(_:from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v22 = a5;
  uint64_t v23 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v14 = (uint64_t)*(v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v22 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  unsigned int v19 = (char *)&v22 - v18;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 104))(a1, a3, a3, v22, a2, a4);
  (*(void (**)(char *, char *, Class *))(v14 + 32))(v17, v19, v13);
  uint64_t v20 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v20 + 48))(v17, 1, AssociatedTypeWitness) != 1) {
    return (*(uint64_t (**)(uint64_t, char *, const char *))(v20 + 32))(v23, v17, AssociatedTypeWitness);
  }
  (*(void (**)(uint64_t, uint64_t))(a4 + 80))(a2, a4);
  return (*(uint64_t (**)(char *, Class *))(v14 + 8))(v17, v13);
}

uint64_t static _UnicodeEncoding._transcode<A, B>(_:from:into:)(uint64_t a1, uint64_t a2, void (*a3)(char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int **a8, int **a9, int **a10)
{
  unint64_t v92 = a8;
  unsigned int v84 = a3;
  uint64_t v85 = a5;
  uint64_t v89 = a1;
  uint64_t v86 = (uint64_t)a9;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a8, a5, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  char v61 = AssociatedTypeWitness;
  uint64_t v80 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  char v64 = (void (**)(char *, Class *))*(v80 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v80);
  uint64_t v79 = (char *)&v59 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v78 = (char *)&v59 - v18;
  uint64_t v65 = (void (**)(char *, char *, const char *))*((void *)AssociatedTypeWitness - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v77 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v76 = (char *)&v59 - v21;
  uint64_t v22 = a7;
  uint64_t v23 = swift_getAssociatedTypeWitness(0, a10, a7, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  char v68 = (void (**)(char *, uint64_t))*((void *)v23 - 1);
  MEMORY[0x1F4188790](v23);
  uint64_t v74 = (char *)&v59 - v25;
  uint64_t v75 = v24;
  uint64_t v90 = type metadata accessor for Unicode.ParseResult(0, v24, v26, v27);
  uint64_t v28 = MEMORY[0x1F4188790](v90);
  uint64_t v60 = (unsigned __int8 *)&v59 - v29;
  uint64_t v30 = a6;
  uint64_t v31 = *(void *)(a6 - 8);
  MEMORY[0x1F4188790](v28);
  unint64_t v33 = (char *)&v59 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v34 = swift_getAssociatedTypeWitness(0, a9, v30, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v63 = *((void *)v34 - 1);
  MEMORY[0x1F4188790](v34);
  uint64_t v36 = (char *)&v59 - v35;
  uint64_t v37 = v22;
  uint64_t v38 = swift_getAssociatedTypeWitness(0, a10, v22, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v62 = *((void *)v38 - 1);
  MEMORY[0x1F4188790](v38);
  uint64_t v40 = (char *)&v59 - v39;
  uint64_t v81 = a10;
  uint64_t v82 = v37;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a10, v37, (uint64_t)v38, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  uint64_t v42 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 24);
  char v91 = v40;
  v42(v38, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v33, v89, v30);
  char v43 = v61;
  uint64_t v44 = v86;
  (*(void (**)(uint64_t, uint64_t))(v86 + 32))(v30, v86);
  uint64_t v89 = AssociatedConformanceWitness;
  BOOL v87 = *(void (**)(char *, const char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 32);
  uint64_t v88 = AssociatedConformanceWitness + 32;
  uint64_t v86 = swift_getAssociatedConformanceWitness(v44, v30, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v83 = v92 + 10;
  uint64_t v45 = (void (**)(char *, const char *))(v65 + 1);
  int v70 = (void (**)(char *, unsigned __int8 *, uint64_t))(v68 + 4);
  int v69 = v92 + 13;
  uint64_t v46 = v60;
  ++v68;
  int v67 = (void (**)(char *, char *, Class *))(v64 + 4);
  int v66 = (unsigned int (**)(char *, uint64_t, const char *))(v65 + 6);
  v65 += 4;
  ++v64;
  char v73 = v34;
  uint64_t v72 = v36;
  int v71 = v38;
  while (1)
  {
    v87(v36, v34, v86, v38, v89);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v46, (uint64_t)v90);
    if (EnumCaseMultiPayload) {
      break;
    }
    unsigned __int8 v50 = v74;
    uint64_t v49 = v75;
    uint64_t v51 = v46;
    (*v70)(v74, v46, v75);
    uint64_t v52 = v92;
    uint64_t v53 = v78;
    uint64_t v54 = v85;
    ((void (*)(char *, uint64_t, uint64_t, int **, uint64_t, int **))v92[13])(v50, v82, v82, v81, v85, v92);
    (*v68)(v50, v49);
    uint64_t v55 = v79;
    unint64_t v56 = v80;
    (*v67)(v79, v53, v80);
    if ((*v66)(v55, 1, v43) == 1)
    {
      char v57 = v76;
      ((void (*)(uint64_t, int **))v52[10])(v54, v52);
      (*v64)(v55, v56);
      int v47 = v57;
    }
    else
    {
      int v47 = v76;
      (*v65)(v76, v55, v43);
    }
    char v34 = v73;
    uint64_t v46 = v51;
    uint64_t v36 = v72;
    uint64_t v38 = v71;
LABEL_4:
    v84(v47);
    (*v45)(v47, v43);
  }
  if (EnumCaseMultiPayload == 1)
  {
    int v47 = v77;
    ((void (*)(uint64_t))v92[10])(v85);
    goto LABEL_4;
  }
  (*(void (**)(char *, const char *))(v63 + 8))(v36, v34);
  return (*(uint64_t (**)(char *, const char *))(v62 + 8))(v91, v38);
}

unint64_t Unicode._GraphemeBreakProperty.init(from:)(unsigned int a1)
{
  if (a1 < 0x20) {
    return 1;
  }
  if (a1 < 0x7F) {
    return 0;
  }
  if (a1 == 8205) {
    return 12;
  }
  uint64_t v2 = 4;
  if (a1 - 4448 > 0xFFFFFF9F) {
    return v2;
  }
  if (a1 - 43389 > 0xFFFFFFE2) {
    return v2;
  }
  uint64_t v2 = 11;
  if (a1 - 4520 > 0xFFFFFFB7) {
    return v2;
  }
  if (a1 - 55239 > 0xFFFFFFE8) {
    return v2;
  }
  uint64_t v2 = 10;
  if (a1 - 4608 > 0xFFFFFFA7 || a1 - 55292 > 0xFFFFFFCE) {
    return v2;
  }
  if (a1 - 55204 >= 0xFFFFD45C)
  {
    HIDWORD(v4) = -1227133513 * ((unsigned __int16)a1 - 16);
    LODWORD(v4) = HIDWORD(v4);
    if ((v4 >> 2) < 0x9249249) {
      return 5;
    }
    else {
      return 6;
    }
  }
  else if (a1 - 127488 > 0xFFFFFFE5)
  {
    return 8;
  }
  else
  {
    if (a1 - 131070 <= 0xFFFFFC01)
    {
      if (a1 - 921600 <= 0xFFFFF1EF)
      {
        unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(a1);
        if (GraphemeBreakProperty <= 5) {
          return 0x30309070201uLL >> (8 * GraphemeBreakProperty);
        }
        return 0;
      }
      return 1;
    }
    return 3;
  }
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:)(Swift::UInt8 a1)
{
  *(_DWORD *)&a1 = a1;
  LOBYTE(result._value) = a1;
  return result;
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:)(Swift::UInt8 a1, Swift::UInt8 a2)
{
  return (Swift::Unicode::Scalar)(a2 & 0x3F | ((a1 & 0x1F) << 6));
}

Swift::UInt32 __swiftcall _continuationPayload(_:)(Swift::UInt8 a1)
{
  return a1 & 0x3F;
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:_:)(Swift::UInt8 a1, Swift::UInt8 a2, Swift::UInt8 a3)
{
  return (Swift::Unicode::Scalar)(((a1 & 0xF) << 12) | ((a2 & 0x3F) << 6) | a3 & 0x3F);
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:_:_:)(Swift::UInt8 a1, Swift::UInt8 a2, Swift::UInt8 a3, Swift::UInt8 a4)
{
  return (Swift::Unicode::Scalar)(((a1 & 0xF) << 18) | ((a2 & 0x3F) << 12) | ((a3 & 0x3F) << 6) | a4 & 0x3F);
}

Swift::String::Index __swiftcall _StringGuts.scalarAlignSlow(_:)(Swift::String::Index result)
{
  if ((result._rawBits & 0xC000) != 0) {
    return (Swift::String::Index)(result._rawBits & 0xFFFFFFFFFFFF0000);
  }
  Swift::UInt64 v5 = result._rawBits >> 16;
  if (!(result._rawBits >> 16)) {
    return (Swift::String::Index)(result._rawBits & 0xFFFFFFFFFFFF0000);
  }
  if ((v2 & 0x1000000000000000) == 0)
  {
    void v13[2] = v3;
    v13[3] = v4;
    if ((v2 & 0x2000000000000000) != 0)
    {
      v13[0] = v1;
      v13[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (v5 != (HIBYTE(v2) & 0xF) && (*((unsigned char *)v13 + v5) & 0xC0) == 0x80)
      {
        do
        {
          Swift::UInt64 v10 = v5 - 1;
          int v11 = *((unsigned char *)&v12 + v5-- + 7) & 0xC0;
        }
        while (v11 == 128);
        Swift::UInt64 v5 = v10;
      }
      return (Swift::String::Index)(v5 << 16);
    }
    if ((v1 & 0x1000000000000000) != 0)
    {
      uint64_t v6 = (unsigned char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (v5 != (v1 & 0xFFFFFFFFFFFFLL))
      {
        do
LABEL_8:
          int v7 = v6[v5--] & 0xC0;
        while (v7 == 128);
        ++v5;
      }
    }
    else
    {
      Swift::UInt64 v12 = result._rawBits >> 16;
      uint64_t v6 = _StringObject.sharedUTF8.getter(v1, v2);
      Swift::UInt64 v5 = v12;
      if (v12 != v9) {
        goto LABEL_8;
      }
    }
    return (Swift::String::Index)(v5 << 16);
  }
  uint64_t v8 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000) == 0) {
    uint64_t v8 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 != v8)
  {
    return _StringGuts.foreignScalarAlign(_:)(result);
  }
  return result;
}

Swift::String::Index __swiftcall _StringGuts.foreignScalarAlign(_:)(Swift::String::Index a1)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v4 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000) == 0) {
    uint64_t v4 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v4 != a1._rawBits >> 16 && _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)(a1) >> 10 == 55) {
    Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000) - 0x10000;
  }
  return (Swift::String::Index)(rawBits | 1);
}

uint64_t closure #1 in _StringGuts.fastUTF8ScalarLength(endingAt:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v4 = 1;
  uint64_t v5 = a3 - 1;
  while (1)
  {
    if (v5 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
    }
    if (a3 - 1 >= a2) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
    }
    if ((*(unsigned char *)(result + v5) & 0xC0) != 0x80) {
      break;
    }
    --v5;
    if (__OFADD__(v4++, 1))
    {
      __break(1u);
      break;
    }
  }
  *a4 = v4;
  return result;
}

uint64_t static Unicode.UTF16._decodeSurrogates(_:_:)(__int16 a1, __int16 a2)
{
  return (a2 & 0x3FF | ((unsigned __int16)(a1 & 0x3FF) << 10)) + 0x10000;
}

uint64_t static Unicode.UTF16._replacementCodeUnit.getter()
{
  return 65533;
}

Swift::String __swiftcall _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(Swift::Int startingAt, Swift::Int endingAt)
{
  uint64_t v4 = v2;
  Swift::Int v5 = startingAt;
  v43[1] = *MEMORY[0x1E4F143B8];
  int64_t v6 = endingAt - startingAt;
  BOOL v7 = __OFSUB__(endingAt, startingAt);
  if (startingAt - endingAt == 1)
  {
    Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(startingAt << 16))._0._value;
    uint64_t v9 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
    if ((v10 & 0x2000000000000000) != 0) {
      uint64_t v11 = HIBYTE(v10) & 0xF;
    }
    else {
      uint64_t v11 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (!v11) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from an empty String", 43, 2, "Swift/Character.swift", 21, 2, 0xAFuLL, 0);
    }
    unint64_t v12 = v9;
    unint64_t v13 = v10;
    swift_bridgeObjectRetain(v10);
    v14._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15)._rawBits;
    Swift::UInt64 rawBits = String._uncheckedIndex(after:)(v14)._rawBits;
    swift_bridgeObjectRelease(v13);
    if (rawBits >> 14 == 4 * v11)
    {
      if (!(v13 & 0x2000000000000000 | v12 & 0x1000000000000000))
      {
        unint64_t v12 = specialized static String._copying(_:)(v12, v13);
        unint64_t v17 = v16;
        swift_bridgeObjectRelease(v13);
        unint64_t v13 = v17;
      }
      goto LABEL_35;
    }
LABEL_36:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from a String containing more than one extended grapheme cluster", 87, 2, "Swift/Character.swift", 21, 2, 0xB1uLL, 0);
  }
  if (v6 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Allocation capacity must be greater than or equal to zero", 57, 2, "Swift/TemporaryAllocation.swift", 31, 2, 0x29uLL, 0);
  }
  if (v6 + 0x4000000000000000 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Allocation byte count too large", 31, 2, "Swift/TemporaryAllocation.swift", 31, 2, 0x2EuLL, 0);
  }
  Swift::Int v18 = endingAt;
  if (2 * v6 <= 1024 || (startingAt = swift_stdlib_isStackAllocationSafe(), (startingAt & 1) != 0))
  {
    MEMORY[0x1F4188790](startingAt);
    uint64_t v20 = (char *)v43 - v19;
    if (v5 <= v18)
    {
      if (v7)
      {
        __break(1u);
      }
      else
      {
        [v4 & 0xFFFFFFFFFFFFFFFLL sel_getCharacters_range_:v20 range:v5];
        v43[0] = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v6, 0, (uint64_t)&_swiftEmptyArrayStorage);
        specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)((uint64_t)v20, (uint64_t)&v20[2 * v6], 0, v43);
        uint64_t v21 = (uint8x16_t *)v43[0];
        uint64_t v22 = *(void *)(v43[0] + 16);
        swift_bridgeObjectRetain(v43[0]);
        unint64_t v12 = specialized static String._uncheckedFromUTF8(_:)(v21 + 2, v22);
        unint64_t v13 = v23;
        LOBYTE(v18) = 2;
        swift_bridgeObjectRelease_n((uint64_t)v21, 2);
        if ((v13 & 0x2000000000000000) != 0) {
          uint64_t v24 = HIBYTE(v13) & 0xF;
        }
        else {
          uint64_t v24 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (v24)
        {
          swift_bridgeObjectRetain(v13);
          v25._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15)._rawBits;
          Swift::UInt64 v26 = String._uncheckedIndex(after:)(v25)._rawBits;
          swift_bridgeObjectRelease(v13);
          if (v26 >> 14 != 4 * v24) {
            goto LABEL_36;
          }
          if (!(v13 & 0x2000000000000000 | v12 & 0x1000000000000000))
          {
            unint64_t v12 = specialized static String._copying(_:)(v12, v13);
            unint64_t v38 = v37;
            swift_bridgeObjectRelease(v13);
            unint64_t v13 = v38;
          }
          goto LABEL_35;
        }
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from an empty String", 43, 2, "Swift/Character.swift", 21, v18, 0xAFuLL, 0);
    }
LABEL_38:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v27 = swift_slowAlloc(2 * v6, 0xFFFFFFFFFFFFFFFFLL);
  if (v5 > v18) {
    goto LABEL_38;
  }
  if (v7)
  {
    __break(1u);
    goto LABEL_45;
  }
  uint64_t v28 = v27;
  [v4 sel_getCharacters_range_:v27 range:v5];
  v43[0] = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v6, 0, (uint64_t)&_swiftEmptyArrayStorage);
  specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)((uint64_t)v28, (uint64_t)v28 + 2 * v6, 0, v43);
  uint64_t v29 = (uint8x16_t *)v43[0];
  uint64_t v30 = *(void *)(v43[0] + 16);
  swift_bridgeObjectRetain(v43[0]);
  unint64_t v12 = specialized static String._uncheckedFromUTF8(_:)(v29 + 2, v30);
  unint64_t v13 = v31;
  char v3 = 2;
  swift_bridgeObjectRelease_n((uint64_t)v29, 2);
  if ((v13 & 0x2000000000000000) != 0) {
    uint64_t v32 = HIBYTE(v13) & 0xF;
  }
  else {
    uint64_t v32 = v12 & 0xFFFFFFFFFFFFLL;
  }
  if (!v32) {
LABEL_45:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from an empty String", 43, 2, "Swift/Character.swift", 21, v3, 0xAFuLL, 0);
  swift_bridgeObjectRetain(v13);
  v33._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15)._rawBits;
  Swift::UInt64 v34 = String._uncheckedIndex(after:)(v33)._rawBits;
  swift_bridgeObjectRelease(v13);
  if (v34 >> 14 != 4 * v32) {
    goto LABEL_36;
  }
  if (!(v13 & 0x2000000000000000 | v12 & 0x1000000000000000))
  {
    unint64_t v12 = specialized static String._copying(_:)(v12, v13);
    unint64_t v40 = v39;
    swift_bridgeObjectRelease(v13);
    unint64_t v13 = v40;
  }
  swift_slowDealloc(v28);
LABEL_35:
  uint64_t v35 = v12;
  uint64_t v36 = (void *)v13;
  result._object = v36;
  result._countAndFlagsBits = v35;
  return result;
}

uint64_t Unicode.ParseResult._valid.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](a1);
  int64_t v6 = (unsigned __int8 *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *))(v4 + 16))(v6);
  if (swift_getEnumCaseMultiPayload(v6, a1))
  {
    (*(void (**)(unsigned __int8 *, uint64_t))(v4 + 8))(v6, a1);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8) + 56))(a2, 1, 1);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v9 = *(void *)(v8 - 8);
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v9 + 32))(a2, v6, v8);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 56))(a2, 0, 1, v8);
  }
}

uint64_t Unicode.ParseResult._error.getter(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v4 = (unsigned __int8 *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *))(v2 + 16))(v4);
  if (swift_getEnumCaseMultiPayload(v4, a1) == 1) {
    return *(void *)v4;
  }
  (*(void (**)(unsigned __int8 *, uint64_t))(v2 + 8))(v4, a1);
  return 0;
}

uint64_t Unicode.Scalar.Properties._scalar.getter()
{
  return *v0;
}

uint64_t (*Unicode.Scalar.Properties._scalar.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t Unicode.Scalar.Properties.isAlphabetic.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 7) & 1;
}

unint64_t Unicode.Scalar.Properties.isASCIIHexDigit.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 6) & 1;
}

unint64_t Unicode.Scalar.Properties.isBidiControl.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 8) & 1;
}

unint64_t Unicode.Scalar.Properties.isBidiMirrored.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 9) & 1;
}

unint64_t Unicode.Scalar.Properties.isDash.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 12) & 1;
}

unint64_t Unicode.Scalar.Properties.isDefaultIgnorableCodePoint.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 13) & 1;
}

unint64_t Unicode.Scalar.Properties.isDeprecated.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 14) & 1;
}

unint64_t Unicode.Scalar.Properties.isDiacritic.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 15) & 1;
}

unint64_t Unicode.Scalar.Properties.isExtender.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 20) & 1;
}

unint64_t Unicode.Scalar.Properties.isFullCompositionExclusion.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 21) & 1;
}

unint64_t Unicode.Scalar.Properties.isGraphemeBase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 22) & 1;
}

unint64_t Unicode.Scalar.Properties.isGraphemeExtend.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 23) & 1;
}

unint64_t Unicode.Scalar.Properties.isHexDigit.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 24) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDContinue.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 25) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDStart.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 28) & 1;
}

unint64_t Unicode.Scalar.Properties.isIdeographic.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 29) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDSBinaryOperator.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 26) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDSTrinaryOperator.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 27) & 1;
}

unint64_t Unicode.Scalar.Properties.isJoinControl.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 30) & 1;
}

unint64_t Unicode.Scalar.Properties.isLogicalOrderException.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 31) & 1;
}

unint64_t Unicode.Scalar.Properties.isLowercase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 32) & 1;
}

unint64_t Unicode.Scalar.Properties.isMath.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 33) & 1;
}

unint64_t Unicode.Scalar.Properties.isNoncharacterCodePoint.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 34) & 1;
}

unint64_t Unicode.Scalar.Properties.isQuotationMark.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 37) & 1;
}

unint64_t Unicode.Scalar.Properties.isRadical.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 38) & 1;
}

unint64_t Unicode.Scalar.Properties.isSoftDotted.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 40) & 1;
}

unint64_t Unicode.Scalar.Properties.isTerminalPunctuation.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 41) & 1;
}

unint64_t Unicode.Scalar.Properties.isUnifiedIdeograph.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 42) & 1;
}

unint64_t Unicode.Scalar.Properties.isUppercase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 43) & 1;
}

unint64_t Unicode.Scalar.Properties.isWhitespace.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 45) & 1;
}

unint64_t Unicode.Scalar.Properties.isXIDContinue.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 46) & 1;
}

unint64_t Unicode.Scalar.Properties.isXIDStart.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 47) & 1;
}

unint64_t Unicode.Scalar.Properties.isSentenceTerminal.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 39) & 1;
}

unint64_t Unicode.Scalar.Properties.isVariationSelector.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 44) & 1;
}

unint64_t Unicode.Scalar.Properties.isPatternSyntax.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 35) & 1;
}

unint64_t Unicode.Scalar.Properties.isPatternWhitespace.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 36) & 1;
}

unint64_t Unicode.Scalar.Properties.isCased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 11) & 1;
}

unint64_t Unicode.Scalar.Properties.isCaseIgnorable.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 10) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenLowercased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 2) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenUppercased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 5) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenTitlecased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 4) & 1;
}

uint64_t Unicode.Scalar.Properties.changesWhenCaseFolded.getter()
{
  return _swift_stdlib_getBinaryProperties(*v0) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenCaseMapped.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 1) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenNFKCCaseFolded.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 3) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmoji.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 16) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiPresentation.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 19) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiModifier.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 17) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiModifierBase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 18) & 1;
}

uint64_t Unicode.Scalar.Properties._getMapping(_:)(unsigned __int8 a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *v1;
  v8[0] = 0;
  int v3 = a1;
  Specialint Mapping = (uint8x16_t *)_swift_stdlib_getSpecialMapping(v2, a1, v8);
  if (SpecialMapping && v8[0])
  {
    if (v8[0] < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(SpecialMapping, v8[0], 0);
  }
  else
  {
    int Mapping = _swift_stdlib_getMapping(v2, v3);
    if (Mapping)
    {
      uint64_t v7 = v2 + Mapping;
      if (v7 < 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
      }
      if (HIDWORD(v7)) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
      }
    }
    else
    {
      LODWORD(v7) = v2;
    }
    return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v7);
  }
}

uint64_t Unicode.Scalar.Properties.titlecaseMapping.getter()
{
  return Unicode.Scalar.Properties._getMapping(_:)(2u);
}

uint64_t Unicode.Scalar.Properties.age.getter()
{
  LODWORD(result) = _swift_stdlib_getAge(*v0);
  if (result == 0xFFFF) {
    return 0;
  }
  else {
    return result;
  }
}

Swift::Unicode::GeneralCategory __swiftcall Unicode.GeneralCategory.init(rawValue:)(Swift::Unicode::GeneralCategory rawValue)
{
  if (rawValue >= Swift_Unicode_GeneralCategory_unknownDefault)
  {
    Swift::Unicode::GeneralCategory v2 = rawValue;
    unint64_t countAndFlagsBits = 0xD000000000000019;
    unint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(27);
    uint64_t v6 = v5;
    v29._unint64_t countAndFlagsBits = v4;
    v29._unint64_t object = (void *)v5;
    uint64_t v7 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000) == 0) {
      uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v7 || (v4 & ~v5 & 0x2000000000000000) != 0)
    {
      if ((v5 & 0x2000000000000000) == 0
        || (0x80000001816E2E80 & 0x2000000000000000) == 0
        || (unint64_t v9 = specialized _SmallString.init(_:appending:)(v4, v5, 0xD000000000000019, 0x80000001816E2E80 | 0x8000000000000000), (v11 & 1) != 0))
      {
        if ((0x80000001816E2E80 & 0x2000000000000000) != 0) {
          unint64_t v12 = (0x80000001816E2E80 >> 56) & 0xF;
        }
        else {
          unint64_t v12 = 25;
        }
        _StringGuts.append(_:)(0xD000000000000019, 0x80000001816E2E80 | 0x8000000000000000, 0, v12);
        swift_bridgeObjectRelease(0x80000001816E2E80 | 0x8000000000000000);
        unint64_t object = (unint64_t)v29._object;
        unint64_t countAndFlagsBits = v29._countAndFlagsBits;
LABEL_17:
        Swift::String v13 = _uint64ToString(_:radix:uppercase:)(v2, 10, 0);
        unint64_t v14 = v13._countAndFlagsBits;
        unint64_t v15 = (unint64_t)v13._object;
        uint64_t v16 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000) == 0) {
          uint64_t v16 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        if (!v16 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(object);
          Swift::String v29 = v13;
          goto LABEL_31;
        }
        if ((object & 0x2000000000000000) != 0)
        {
          if (((uint64_t)v13._object & 0x2000000000000000) != 0)
          {
            unint64_t v18 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v13._countAndFlagsBits, (unint64_t)v13._object);
            if ((v20 & 1) == 0)
            {
              unint64_t v21 = v18;
              uint64_t v22 = v19;
              swift_bridgeObjectRelease(object);
              swift_bridgeObjectRelease((uint64_t)v13._object);
              v29._unint64_t countAndFlagsBits = v21;
              v29._unint64_t object = v22;
              unint64_t v15 = (unint64_t)v22;
              unint64_t v14 = v21;
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }
        else if (((uint64_t)v13._object & 0x2000000000000000) != 0)
        {
LABEL_29:
          uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
          goto LABEL_30;
        }
        uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_30:
        _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
        swift_bridgeObjectRelease((uint64_t)v13._object);
        unint64_t v15 = (unint64_t)v29._object;
        unint64_t v14 = v29._countAndFlagsBits;
LABEL_31:
        uint64_t v23 = HIBYTE(v15) & 0xF;
        if ((v15 & 0x2000000000000000) == 0) {
          uint64_t v23 = v14 & 0xFFFFFFFFFFFFLL;
        }
        if (v23 || (v14 & ~v15 & 0x2000000000000000) != 0)
        {
          if ((v15 & 0x2000000000000000) == 0
            || (unint64_t v26 = specialized _SmallString.init(_:appending:)(v14, v15, 0, 0xE000000000000000), (v28 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            unint64_t v25 = (unint64_t)v29._object;
            uint64_t v24 = v29._countAndFlagsBits;
          }
          else
          {
            uint64_t v24 = v26;
            unint64_t v25 = v27;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(0xE000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v15);
          uint64_t v24 = 0;
          unint64_t v25 = 0xE000000000000000;
        }
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v24, v25, "Swift/UnicodeScalarProperties.swift", 35, 2, 0x45EuLL, 0);
      }
      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x80000001816E2E80 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v5);
      unint64_t object = 0x80000001816E2E80 | 0x8000000000000000;
    }
    v29._unint64_t countAndFlagsBits = countAndFlagsBits;
    v29._unint64_t object = (void *)object;
    goto LABEL_17;
  }
  *uint64_t v1 = rawValue;
  return rawValue;
}

uint64_t Unicode.Scalar.Properties.generalCategory.getter()
{
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(*v0);

  return Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
}

Swift::String __swiftcall Unicode.Scalar.Properties._hangulName()()
{
  int v48 = *v0;
  uint64_t v1 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
  inited = swift_initStackObject((uint64_t)v1, v52);
  *((_OWORD *)inited + 1) = xmmword_18162AEF0;
  inited[4] = 71;
  inited[5] = 0xE100000000000000;
  inited[6] = 18247;
  inited[7] = 0xE200000000000000;
  inited[8] = 78;
  inited[9] = 0xE100000000000000;
  inited[10] = 68;
  inited[11] = 0xE100000000000000;
  inited[12] = 17476;
  inited[13] = 0xE200000000000000;
  inited[14] = 82;
  inited[15] = 0xE100000000000000;
  inited[16] = 77;
  inited[17] = 0xE100000000000000;
  inited[18] = 66;
  inited[19] = 0xE100000000000000;
  inited[20] = 16962;
  inited[21] = 0xE200000000000000;
  inited[22] = 83;
  inited[23] = 0xE100000000000000;
  inited[24] = 21331;
  inited[25] = 0xE200000000000000;
  inited[26] = 0;
  inited[27] = 0xE000000000000000;
  inited[28] = 74;
  inited[29] = 0xE100000000000000;
  inited[30] = 19018;
  inited[31] = 0xE200000000000000;
  inited[32] = 67;
  inited[33] = 0xE100000000000000;
  inited[34] = 75;
  inited[35] = 0xE100000000000000;
  inited[36] = 84;
  inited[37] = 0xE100000000000000;
  inited[38] = 80;
  inited[39] = 0xE100000000000000;
  inited[40] = 72;
  inited[41] = 0xE100000000000000;
  int v3 = swift_initStackObject((uint64_t)v1, v51);
  *((_OWORD *)v3 + 1) = xmmword_18162AF00;
  v3[4] = 65;
  v3[5] = 0xE100000000000000;
  v3[6] = 17729;
  v3[7] = 0xE200000000000000;
  v3[8] = 16729;
  v3[9] = 0xE200000000000000;
  v3[10] = 4538713;
  v3[11] = 0xE300000000000000;
  v3[12] = 20293;
  v3[13] = 0xE200000000000000;
  v3[14] = 69;
  v3[15] = 0xE100000000000000;
  v3[16] = 5195097;
  v3[17] = 0xE300000000000000;
  v3[18] = 17753;
  v3[19] = 0xE200000000000000;
  v3[20] = 79;
  v3[21] = 0xE100000000000000;
  v3[22] = 16727;
  v3[23] = 0xE200000000000000;
  v3[24] = 4538711;
  v3[25] = 0xE300000000000000;
  v3[26] = 17743;
  v3[27] = 0xE200000000000000;
  v3[28] = 20313;
  v3[29] = 0xE200000000000000;
  v3[30] = 85;
  v3[31] = 0xE100000000000000;
  v3[32] = 5195095;
  v3[33] = 0xE300000000000000;
  v3[34] = 17751;
  v3[35] = 0xE200000000000000;
  v3[36] = 18775;
  v3[37] = 0xE200000000000000;
  v3[38] = 21849;
  v3[39] = 0xE200000000000000;
  v3[40] = 21829;
  v3[41] = 0xE200000000000000;
  v3[42] = 18777;
  v3[43] = 0xE200000000000000;
  v3[44] = 73;
  v3[45] = 0xE100000000000000;
  unint64_t v4 = swift_allocObject(v1, 0x1E0uLL, 7uLL);
  *((_OWORD *)v4 + 1) = xmmword_18162AF10;
  v4[4] = 0;
  v4[5] = 0xE000000000000000;
  v4[6] = 71;
  v4[7] = 0xE100000000000000;
  v4[8] = 18247;
  v4[9] = 0xE200000000000000;
  v4[10] = 21319;
  v4[11] = 0xE200000000000000;
  v4[12] = 78;
  v4[13] = 0xE100000000000000;
  v4[14] = 19022;
  v4[15] = 0xE200000000000000;
  v4[16] = 18510;
  v4[17] = 0xE200000000000000;
  v4[18] = 68;
  v4[19] = 0xE100000000000000;
  v4[20] = 76;
  v4[21] = 0xE100000000000000;
  v4[22] = 18252;
  v4[23] = 0xE200000000000000;
  v4[24] = 19788;
  v4[25] = 0xE200000000000000;
  v4[26] = 16972;
  v4[27] = 0xE200000000000000;
  v4[28] = 21324;
  v4[29] = 0xE200000000000000;
  v4[30] = 21580;
  v4[31] = 0xE200000000000000;
  v4[32] = 20556;
  v4[33] = 0xE200000000000000;
  v4[34] = 18508;
  v4[35] = 0xE200000000000000;
  v4[36] = 77;
  v4[37] = 0xE100000000000000;
  v4[38] = 66;
  v4[39] = 0xE100000000000000;
  v4[40] = 21314;
  v4[41] = 0xE200000000000000;
  v4[42] = 83;
  v4[43] = 0xE100000000000000;
  v4[44] = 21331;
  v4[45] = 0xE200000000000000;
  v4[46] = 18254;
  v4[47] = 0xE200000000000000;
  v4[48] = 74;
  v4[49] = 0xE100000000000000;
  v4[50] = 67;
  v4[51] = 0xE100000000000000;
  v4[52] = 75;
  v4[53] = 0xE100000000000000;
  v4[54] = 84;
  unint64_t v5 = (v48 - 44032) % 0x24Cu / 0x1C;
  v4[55] = 0xE100000000000000;
  v4[56] = 80;
  v4[57] = 0xE100000000000000;
  v4[58] = 72;
  unint64_t v6 = (v48 - 44032) % 0x1Cu;
  v4[59] = 0xE100000000000000;
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)((v48 - 44032) / 0x24CuLL, 1, (uint64_t)inited);
  uint64_t v7 = &inited[2 * ((v48 - 44032) / 0x24CuLL) + 4];
  unint64_t v8 = *v7;
  unint64_t v9 = v7[1];
  swift_bridgeObjectRetain(v9);
  swift_bridgeObjectRelease((uint64_t)inited);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v5, 1, (uint64_t)v3);
  unint64_t v10 = &v3[2 * v5 + 4];
  unint64_t v11 = *v10;
  unint64_t v12 = v10[1];
  swift_bridgeObjectRetain(v12);
  swift_bridgeObjectRelease((uint64_t)v3);
  unint64_t v13 = specialized static String.+ infix(_:_:)(v8, v9, v11, v12);
  unint64_t v15 = v14;
  swift_bridgeObjectRelease(v12);
  swift_bridgeObjectRelease(v9);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v6, 1, (uint64_t)v4);
  uint64_t v16 = &v4[2 * v6 + 4];
  unint64_t v17 = *v16;
  unint64_t v18 = v16[1];
  swift_setDeallocating((uint64_t)v4);
  swift_bridgeObjectRetain(v18);
  swift_arrayDestroy((uint64_t)(v4 + 4), 28, (unint64_t *)&type metadata for String);
  swift_deallocClassInstance((uint64_t)v4);
  unint64_t v19 = specialized static String.+ infix(_:_:)(v13, v15, v17, v18);
  unint64_t v21 = v20;
  swift_bridgeObjectRelease(v18);
  swift_bridgeObjectRelease(v15);
  unint64_t v22 = specialized static String._createEmpty(withInitialCapacity:)(18);
  uint64_t v24 = v23;
  unint64_t v49 = v22;
  unint64_t v50 = v23;
  uint64_t v25 = HIBYTE(v23) & 0xF;
  if ((v23 & 0x2000000000000000) == 0) {
    uint64_t v25 = v22 & 0xFFFFFFFFFFFFLL;
  }
  if (!v25 && (v22 & ~v23 & 0x2000000000000000) == 0)
  {
    unint64_t v29 = 0xD000000000000010;
    swift_bridgeObjectRelease(v23);
    unint64_t v30 = 0x80000001816E2E60 | 0x8000000000000000;
    goto LABEL_14;
  }
  if ((v23 & 0x2000000000000000) != 0 && (0x80000001816E2E60 & 0x2000000000000000) != 0)
  {
    unint64_t v26 = specialized _SmallString.init(_:appending:)(v22, v23, 0xD000000000000010, 0x80000001816E2E60 | 0x8000000000000000);
    if ((v28 & 1) == 0)
    {
      unint64_t v29 = v26;
      unint64_t v30 = v27;
      swift_bridgeObjectRelease(v24);
      swift_bridgeObjectRelease(0x80000001816E2E60 | 0x8000000000000000);
LABEL_14:
      unint64_t v49 = v29;
      unint64_t v50 = v30;
      goto LABEL_15;
    }
  }
  if ((0x80000001816E2E60 & 0x2000000000000000) != 0) {
    unint64_t v31 = (0x80000001816E2E60 >> 56) & 0xF;
  }
  else {
    unint64_t v31 = 16;
  }
  _StringGuts.append(_:)(0xD000000000000010, 0x80000001816E2E60 | 0x8000000000000000, 0, v31);
  swift_bridgeObjectRelease(0x80000001816E2E60 | 0x8000000000000000);
  unint64_t v29 = v49;
  unint64_t v30 = v50;
LABEL_15:
  uint64_t v32 = HIBYTE(v30) & 0xF;
  if ((v30 & 0x2000000000000000) == 0) {
    uint64_t v32 = v29 & 0xFFFFFFFFFFFFLL;
  }
  if (v32 || (v29 & ~v30 & 0x2000000000000000) != 0)
  {
    if ((v30 & 0x2000000000000000) != 0)
    {
      if ((v21 & 0x2000000000000000) != 0)
      {
        unint64_t v34 = specialized _SmallString.init(_:appending:)(v29, v30, v19, v21);
        if ((v36 & 1) == 0)
        {
          unint64_t v37 = v34;
          unint64_t v38 = v35;
          swift_bridgeObjectRelease(v30);
          swift_bridgeObjectRelease(v21);
          unint64_t v49 = v37;
          unint64_t v50 = v38;
          unint64_t v21 = v38;
          unint64_t v19 = v37;
          goto LABEL_28;
        }
        goto LABEL_26;
      }
    }
    else if ((v21 & 0x2000000000000000) != 0)
    {
LABEL_26:
      uint64_t v33 = HIBYTE(v21) & 0xF;
      goto LABEL_27;
    }
    uint64_t v33 = v19 & 0xFFFFFFFFFFFFLL;
LABEL_27:
    _StringGuts.append(_:)(v19, v21, 0, v33);
    swift_bridgeObjectRelease(v21);
    unint64_t v19 = v49;
    unint64_t v21 = v50;
    goto LABEL_28;
  }
  swift_bridgeObjectRelease(v30);
  unint64_t v49 = v19;
  unint64_t v50 = v21;
LABEL_28:
  uint64_t v39 = HIBYTE(v21) & 0xF;
  if ((v21 & 0x2000000000000000) == 0) {
    uint64_t v39 = v19 & 0xFFFFFFFFFFFFLL;
  }
  if (v39 || (v19 & ~v21 & 0x2000000000000000) != 0)
  {
    if ((v21 & 0x2000000000000000) == 0
      || (unint64_t v40 = specialized _SmallString.init(_:appending:)(v19, v21, 0, 0xE000000000000000), (v42 & 1) != 0))
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease(0xE000000000000000);
      unint64_t v43 = v49;
      unint64_t v44 = v50;
    }
    else
    {
      unint64_t v43 = v40;
      unint64_t v44 = v41;
      swift_bridgeObjectRelease(v21);
      swift_bridgeObjectRelease(0xE000000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v21);
    unint64_t v43 = 0;
    unint64_t v44 = 0xE000000000000000;
  }
  uint64_t v45 = v43;
  uint64_t v46 = (void *)v44;
  result._unint64_t object = v46;
  result._unint64_t countAndFlagsBits = v45;
  return result;
}

Swift::String_optional __swiftcall Unicode.Scalar.Properties._fastScalarName()()
{
  unsigned int v1 = *v0;
  Swift::String v2 = _uint64ToString(_:radix:uppercase:)(*v0, 16, 1);
  unint64_t object = (unint64_t)v2._object;
  if (v1 - 55204 >= 0xFFFFD45C)
  {
    swift_bridgeObjectRelease((uint64_t)v2._object);
    Swift::String v8 = Unicode.Scalar.Properties._hangulName()();
    uint64_t countAndFlagsBits = v8._countAndFlagsBits;
    uint64_t v7 = v8._object;
    goto LABEL_118;
  }
  if (v1 - 918000 >= 0xFFFFFF10)
  {
    swift_bridgeObjectRelease((uint64_t)v2._object);
    unint64_t v9 = specialized static String._createEmpty(withInitialCapacity:)(21);
    uint64_t v11 = v10;
    v88._uint64_t countAndFlagsBits = v9;
    v88._unint64_t object = (void *)v10;
    uint64_t v12 = HIBYTE(v10) & 0xF;
    if ((v10 & 0x2000000000000000) == 0) {
      uint64_t v12 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (v12 || (v9 & ~v10 & 0x2000000000000000) != 0)
    {
      if ((v10 & 0x2000000000000000) == 0
        || (0x80000001816E2DA0 & 0x2000000000000000) == 0
        || (unint64_t v13 = specialized _SmallString.init(_:appending:)(v9, v10, 0xD000000000000013, 0x80000001816E2DA0 | 0x8000000000000000), (v15 & 1) != 0))
      {
        if ((0x80000001816E2DA0 & 0x2000000000000000) != 0) {
          unint64_t v18 = (0x80000001816E2DA0 >> 56) & 0xF;
        }
        else {
          unint64_t v18 = 19;
        }
        _StringGuts.append(_:)(0xD000000000000013, 0x80000001816E2DA0 | 0x8000000000000000, 0, v18);
        swift_bridgeObjectRelease(0x80000001816E2DA0 | 0x8000000000000000);
        unint64_t v17 = (unint64_t)v88._object;
        unint64_t v16 = v88._countAndFlagsBits;
LABEL_53:
        Swift::String v36 = _uint64ToString(_:radix:uppercase:)(v1 - 917743, 10, 0);
        uint64_t v4 = v36._countAndFlagsBits;
        unint64_t object = (unint64_t)v36._object;
        uint64_t v37 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000) == 0) {
          uint64_t v37 = v16 & 0xFFFFFFFFFFFFLL;
        }
        if (v37 || (v16 & ~v17 & 0x2000000000000000) != 0)
        {
          if ((v17 & 0x2000000000000000) == 0) {
            goto LABEL_99;
          }
          if (((uint64_t)v36._object & 0x2000000000000000) == 0) {
            goto LABEL_102;
          }
          unint64_t v38 = v16;
          goto LABEL_105;
        }
        goto LABEL_103;
      }
      unint64_t v16 = v13;
      unint64_t v17 = v14;
      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(0x80000001816E2DA0 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v10);
      unint64_t v16 = 0xD000000000000013;
      unint64_t v17 = 0x80000001816E2DA0 | 0x8000000000000000;
    }
    v88._uint64_t countAndFlagsBits = v16;
    v88._unint64_t object = (void *)v17;
    goto LABEL_53;
  }
  uint64_t v4 = v2._countAndFlagsBits;
  int32x4_t v5 = vdupq_n_s32(v1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v5, (int32x4_t)xmmword_18162AF20), (uint32x4_t)xmmword_18162AF40), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v5, (int32x4_t)xmmword_18162AF30), (uint32x4_t)xmmword_18162AF50)))) & 1) != 0|| v1 - 205744 >= 0xFFFFEFA0)
  {
    unint64_t v19 = specialized static String._createEmpty(withInitialCapacity:)(24);
    uint64_t v21 = v20;
    v88._uint64_t countAndFlagsBits = v19;
    v88._unint64_t object = (void *)v20;
    uint64_t v22 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000) == 0) {
      uint64_t v22 = v19 & 0xFFFFFFFFFFFFLL;
    }
    if (v22 || (v19 & ~v20 & 0x2000000000000000) != 0)
    {
      if ((v20 & 0x2000000000000000) == 0
        || (0x80000001816E2DC0 & 0x2000000000000000) == 0
        || (unint64_t v23 = specialized _SmallString.init(_:appending:)(v19, v20, 0xD000000000000016, 0x80000001816E2DC0 | 0x8000000000000000), (v25 & 1) != 0))
      {
        if ((0x80000001816E2DC0 & 0x2000000000000000) != 0) {
          unint64_t v27 = (0x80000001816E2DC0 >> 56) & 0xF;
        }
        else {
          unint64_t v27 = 22;
        }
        _StringGuts.append(_:)(0xD000000000000016, 0x80000001816E2DC0 | 0x8000000000000000, 0, v27);
        swift_bridgeObjectRelease(0x80000001816E2DC0 | 0x8000000000000000);
        unint64_t v17 = (unint64_t)v88._object;
        unint64_t v26 = v88._countAndFlagsBits;
LABEL_73:
        uint64_t v50 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000) == 0) {
          uint64_t v50 = v26 & 0xFFFFFFFFFFFFLL;
        }
        if (v50 || (v26 & ~v17 & 0x2000000000000000) != 0) {
          goto LABEL_98;
        }
        goto LABEL_103;
      }
      unint64_t v26 = v23;
      unint64_t v17 = v24;
      swift_bridgeObjectRelease(v21);
      swift_bridgeObjectRelease(0x80000001816E2DC0 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v20);
      unint64_t v26 = 0xD000000000000016;
      unint64_t v17 = 0x80000001816E2DC0 | 0x8000000000000000;
    }
    v88._uint64_t countAndFlagsBits = v26;
    v88._unint64_t object = (void *)v17;
    goto LABEL_73;
  }
  if (v1 - 64110 > 0xFFFFFE91 || v1 - 64218 > 0xFFFFFF95 || v1 - 195102 >= 0xFFFFFDE2)
  {
    unint64_t v28 = specialized static String._createEmpty(withInitialCapacity:)(30);
    uint64_t v30 = v29;
    v88._uint64_t countAndFlagsBits = v28;
    v88._unint64_t object = (void *)v29;
    uint64_t v31 = HIBYTE(v29) & 0xF;
    if ((v29 & 0x2000000000000000) == 0) {
      uint64_t v31 = v28 & 0xFFFFFFFFFFFFLL;
    }
    if (v31 || (v28 & ~v29 & 0x2000000000000000) != 0)
    {
      if ((v29 & 0x2000000000000000) == 0
        || (0x80000001816E2DE0 & 0x2000000000000000) == 0
        || (unint64_t v32 = specialized _SmallString.init(_:appending:)(v28, v29, 0xD00000000000001CLL, 0x80000001816E2DE0 | 0x8000000000000000), (v34 & 1) != 0))
      {
        if ((0x80000001816E2DE0 & 0x2000000000000000) != 0) {
          unint64_t v35 = (0x80000001816E2DE0 >> 56) & 0xF;
        }
        else {
          unint64_t v35 = 28;
        }
        _StringGuts.append(_:)(0xD00000000000001CLL, 0x80000001816E2DE0 | 0x8000000000000000, 0, v35);
        swift_bridgeObjectRelease(0x80000001816E2DE0 | 0x8000000000000000);
        unint64_t v17 = (unint64_t)v88._object;
        unint64_t v26 = v88._countAndFlagsBits;
LABEL_94:
        uint64_t v58 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000) == 0) {
          uint64_t v58 = v26 & 0xFFFFFFFFFFFFLL;
        }
        if (v58 || (v26 & ~v17 & 0x2000000000000000) != 0)
        {
LABEL_98:
          if ((v17 & 0x2000000000000000) == 0)
          {
LABEL_99:
            if ((object & 0x2000000000000000) != 0)
            {
LABEL_107:
              uint64_t v59 = HIBYTE(object) & 0xF;
              goto LABEL_108;
            }
LABEL_102:
            uint64_t v59 = v4 & 0xFFFFFFFFFFFFLL;
LABEL_108:
            _StringGuts.append(_:)(v4, object, 0, v59);
            swift_bridgeObjectRelease(object);
            unint64_t object = (unint64_t)v88._object;
            uint64_t v4 = v88._countAndFlagsBits;
LABEL_109:
            uint64_t v65 = HIBYTE(object) & 0xF;
            if ((object & 0x2000000000000000) == 0) {
              uint64_t v65 = v4 & 0xFFFFFFFFFFFFLL;
            }
            if (v65 || (v4 & ~object & 0x2000000000000000) != 0)
            {
              if ((object & 0x2000000000000000) != 0)
              {
                unint64_t v66 = specialized _SmallString.init(_:appending:)(v4, object, 0, 0xE000000000000000);
                if ((v68 & 1) == 0)
                {
                  uint64_t countAndFlagsBits = v66;
                  uint64_t v7 = v67;
                  swift_bridgeObjectRelease(0xE000000000000000);
                  swift_bridgeObjectRelease(object);
                  goto LABEL_118;
                }
              }
              _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
LABEL_117:
              swift_bridgeObjectRelease(0xE000000000000000);
              uint64_t v7 = v88._object;
              uint64_t countAndFlagsBits = v88._countAndFlagsBits;
              goto LABEL_118;
            }
LABEL_154:
            swift_bridgeObjectRelease(object);
            uint64_t countAndFlagsBits = 0;
            uint64_t v7 = (void *)0xE000000000000000;
            goto LABEL_118;
          }
          if (((uint64_t)v2._object & 0x2000000000000000) == 0) {
            goto LABEL_102;
          }
          unint64_t v38 = v26;
LABEL_105:
          unint64_t v60 = specialized _SmallString.init(_:appending:)(v38, v17, v4, object);
          if ((v62 & 1) == 0)
          {
            unint64_t v63 = v60;
            char v64 = v61;
            swift_bridgeObjectRelease(v17);
            swift_bridgeObjectRelease(object);
            v88._uint64_t countAndFlagsBits = v63;
            v88._unint64_t object = v64;
            unint64_t object = (unint64_t)v64;
            uint64_t v4 = v63;
            goto LABEL_109;
          }
          goto LABEL_107;
        }
LABEL_103:
        swift_bridgeObjectRelease(v17);
        v88._uint64_t countAndFlagsBits = v4;
        v88._unint64_t object = (void *)object;
        goto LABEL_109;
      }
      unint64_t v26 = v32;
      unint64_t v17 = v33;
      swift_bridgeObjectRelease(0x80000001816E2DE0 | 0x8000000000000000);
      swift_bridgeObjectRelease(v30);
    }
    else
    {
      swift_bridgeObjectRelease(v29);
      unint64_t v26 = 0xD00000000000001CLL;
      unint64_t v17 = 0x80000001816E2DE0 | 0x8000000000000000;
    }
    v88._uint64_t countAndFlagsBits = v26;
    v88._unint64_t object = (void *)v17;
    goto LABEL_94;
  }
  if (v1 - 100344 > 0xFFFFE807 || v1 - 101641 >= 0xFFFFFFF7)
  {
    unint64_t v39 = specialized static String._createEmpty(withInitialCapacity:)(19);
    uint64_t v41 = v40;
    v88._uint64_t countAndFlagsBits = v39;
    v88._unint64_t object = (void *)v40;
    uint64_t v42 = HIBYTE(v40) & 0xF;
    if ((v40 & 0x2000000000000000) == 0) {
      uint64_t v42 = v39 & 0xFFFFFFFFFFFFLL;
    }
    if (v42 || (v39 & ~v40 & 0x2000000000000000) != 0)
    {
      unint64_t v43 = "TANGUT IDEOGRAPH-";
      if ((v40 & 0x2000000000000000) == 0
        || (0x80000001816E2E00 & 0x2000000000000000) == 0
        || (unint64_t v44 = specialized _SmallString.init(_:appending:)(v39, v40, 0xD000000000000011, 0x80000001816E2E00 | 0x8000000000000000), (v46 & 1) != 0))
      {
        unint64_t v47 = 0x80000001816E2E00 | 0x8000000000000000;
        if ((0x80000001816E2E00 & 0x2000000000000000) != 0) {
          unint64_t v48 = (0x80000001816E2E00 >> 56) & 0xF;
        }
        else {
          unint64_t v48 = 17;
        }
        uint64_t v49 = 0xD000000000000011;
        goto LABEL_91;
      }
      goto LABEL_85;
    }
    swift_bridgeObjectRelease(v40);
    int v71 = "TANGUT IDEOGRAPH-";
    unint64_t v55 = 0xD000000000000011;
LABEL_133:
    unint64_t v78 = (unint64_t)(v71 + 0x7FFFFFFFFFFFFFE0);
    goto LABEL_134;
  }
  if (v1 - 101590 >= 0xFFFFFE2A)
  {
    unint64_t v51 = specialized static String._createEmpty(withInitialCapacity:)(32);
    uint64_t v41 = v52;
    v88._uint64_t countAndFlagsBits = v51;
    v88._unint64_t object = (void *)v52;
    uint64_t v53 = HIBYTE(v52) & 0xF;
    if ((v52 & 0x2000000000000000) == 0) {
      uint64_t v53 = v51 & 0xFFFFFFFFFFFFLL;
    }
    if (v53 || (v51 & ~v52 & 0x2000000000000000) != 0)
    {
      unint64_t v43 = "KHITAN SMALL SCRIPT CHARACTER-";
      if ((v52 & 0x2000000000000000) == 0
        || (0x80000001816E2E20 & 0x2000000000000000) == 0
        || (unint64_t v44 = specialized _SmallString.init(_:appending:)(v51, v52, 0xD00000000000001ELL, 0x80000001816E2E20 | 0x8000000000000000), (v54 & 1) != 0))
      {
        unint64_t v47 = 0x80000001816E2E20 | 0x8000000000000000;
        if ((0x80000001816E2E20 & 0x2000000000000000) != 0) {
          unint64_t v48 = (0x80000001816E2E20 >> 56) & 0xF;
        }
        else {
          unint64_t v48 = 30;
        }
        uint64_t v49 = 0xD00000000000001ELL;
        goto LABEL_91;
      }
LABEL_85:
      unint64_t v55 = v44;
      unint64_t v56 = v45;
      unint64_t v57 = (unint64_t)(v43 + 0x7FFFFFFFFFFFFFE0);
LABEL_86:
      swift_bridgeObjectRelease(v57 | 0x8000000000000000);
      swift_bridgeObjectRelease(v41);
LABEL_135:
      v88._uint64_t countAndFlagsBits = v55;
      v88._unint64_t object = (void *)v56;
LABEL_136:
      uint64_t v79 = HIBYTE(v56) & 0xF;
      if ((v56 & 0x2000000000000000) == 0) {
        uint64_t v79 = v55 & 0xFFFFFFFFFFFFLL;
      }
      if (!v79 && (v55 & ~v56 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v56);
        Swift::String v88 = v2;
LABEL_149:
        uint64_t v86 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000) == 0) {
          uint64_t v86 = v4 & 0xFFFFFFFFFFFFLL;
        }
        if (v86 || (v4 & ~object & 0x2000000000000000) != 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000);
          goto LABEL_117;
        }
        goto LABEL_154;
      }
      if ((v56 & 0x2000000000000000) != 0)
      {
        if (((uint64_t)v2._object & 0x2000000000000000) != 0)
        {
          unint64_t v81 = specialized _SmallString.init(_:appending:)(v55, v56, v2._countAndFlagsBits, (unint64_t)v2._object);
          if ((v83 & 1) == 0)
          {
            unint64_t v84 = v81;
            uint64_t v85 = v82;
            swift_bridgeObjectRelease(v56);
            swift_bridgeObjectRelease((uint64_t)v2._object);
            v88._uint64_t countAndFlagsBits = v84;
            v88._unint64_t object = v85;
            unint64_t object = (unint64_t)v85;
            uint64_t v4 = v84;
            goto LABEL_149;
          }
          goto LABEL_147;
        }
      }
      else if (((uint64_t)v2._object & 0x2000000000000000) != 0)
      {
LABEL_147:
        uint64_t v80 = ((unint64_t)v2._object >> 56) & 0xF;
        goto LABEL_148;
      }
      uint64_t v80 = v2._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_148:
      _StringGuts.append(_:)(v2._countAndFlagsBits, (unint64_t)v2._object, 0, v80);
      swift_bridgeObjectRelease((uint64_t)v2._object);
      unint64_t object = (unint64_t)v88._object;
      uint64_t v4 = v88._countAndFlagsBits;
      goto LABEL_149;
    }
    swift_bridgeObjectRelease(v52);
    int v71 = "KHITAN SMALL SCRIPT CHARACTER-";
    unint64_t v55 = 0xD00000000000001ELL;
    goto LABEL_133;
  }
  if (v1 >= 0x1B170 && v1 <= 0x1B2FB)
  {
    unint64_t v72 = specialized static String._createEmpty(withInitialCapacity:)(18);
    uint64_t v41 = v73;
    v88._uint64_t countAndFlagsBits = v72;
    v88._unint64_t object = (void *)v73;
    uint64_t v74 = HIBYTE(v73) & 0xF;
    if ((v73 & 0x2000000000000000) == 0) {
      uint64_t v74 = v72 & 0xFFFFFFFFFFFFLL;
    }
    if (v74 || (v72 & ~v73 & 0x2000000000000000) != 0)
    {
      if ((v73 & 0x2000000000000000) != 0 && (0x80000001816E2E40 & 0x2000000000000000) != 0)
      {
        unint64_t v75 = specialized _SmallString.init(_:appending:)(v72, v73, 0xD000000000000010, 0x80000001816E2E40 | 0x8000000000000000);
        if ((v77 & 1) == 0)
        {
          unint64_t v55 = v75;
          unint64_t v56 = v76;
          unint64_t v57 = 0x80000001816E2E40;
          goto LABEL_86;
        }
      }
      unint64_t v47 = 0x80000001816E2E40 | 0x8000000000000000;
      if ((0x80000001816E2E40 & 0x2000000000000000) != 0) {
        unint64_t v48 = (0x80000001816E2E40 >> 56) & 0xF;
      }
      else {
        unint64_t v48 = 16;
      }
      uint64_t v49 = 0xD000000000000010;
LABEL_91:
      _StringGuts.append(_:)(v49, v47, 0, v48);
      swift_bridgeObjectRelease(v47);
      unint64_t v56 = (unint64_t)v88._object;
      unint64_t v55 = v88._countAndFlagsBits;
      goto LABEL_136;
    }
    unint64_t v55 = 0xD000000000000010;
    swift_bridgeObjectRelease(v73);
    unint64_t v78 = 0x80000001816E2E40;
LABEL_134:
    unint64_t v56 = v78 | 0x8000000000000000;
    goto LABEL_135;
  }
  swift_bridgeObjectRelease((uint64_t)v2._object);
  uint64_t countAndFlagsBits = 0;
  uint64_t v7 = 0;
LABEL_118:
  uint64_t v69 = countAndFlagsBits;
  int v70 = v7;
  result.value._unint64_t object = v70;
  result.value._uint64_t countAndFlagsBits = v69;
  return result;
}

uint64_t Unicode.Scalar.Properties.name.getter()
{
  unsigned int v1 = *v0;
  Swift::String_optional v3 = Unicode.Scalar.Properties._fastScalarName()();
  uint64_t result = v3.value._countAndFlagsBits;
  if (!v3.value._object)
  {
    uint64_t result = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(88, v1);
    uint64_t v5 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000) == 0) {
      uint64_t v5 = result & 0xFFFFFFFFFFFFLL;
    }
    if (!v5)
    {
      swift_bridgeObjectRelease(v4);
      return 0;
    }
  }
  return result;
}

char *Unicode.Scalar.Properties.nameAlias.getter()
{
  uint64_t result = _swift_stdlib_getNameAlias(*v0);
  if (result)
  {
    Swift::String v2 = (uint64_t *)result;
    size_t v3 = _swift_stdlib_strlen(result);
    if ((v3 & 0x8000000000000000) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    return (char *)_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n(v2, v3);
  }
  return result;
}

Swift::Unicode::CanonicalCombiningClass __swiftcall Unicode.CanonicalCombiningClass.init(rawValue:)(Swift::Unicode::CanonicalCombiningClass rawValue)
{
  v1->rawValue = rawValue.rawValue;
  return rawValue;
}

void static Unicode.CanonicalCombiningClass.notReordered.getter(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

void static Unicode.CanonicalCombiningClass.overlay.getter(unsigned char *a1@<X8>)
{
  *a1 = 1;
}

void static Unicode.CanonicalCombiningClass.nukta.getter(unsigned char *a1@<X8>)
{
  *a1 = 7;
}

void static Unicode.CanonicalCombiningClass.kanaVoicing.getter(unsigned char *a1@<X8>)
{
  *a1 = 8;
}

void static Unicode.CanonicalCombiningClass.virama.getter(unsigned char *a1@<X8>)
{
  *a1 = 9;
}

void static Unicode.CanonicalCombiningClass.attachedBelowLeft.getter(unsigned char *a1@<X8>)
{
  *a1 = -56;
}

void static Unicode.CanonicalCombiningClass.attachedBelow.getter(unsigned char *a1@<X8>)
{
  *a1 = -54;
}

void static Unicode.CanonicalCombiningClass.attachedAbove.getter(unsigned char *a1@<X8>)
{
  *a1 = -42;
}

void static Unicode.CanonicalCombiningClass.attachedAboveRight.getter(unsigned char *a1@<X8>)
{
  *a1 = -40;
}

void static Unicode.CanonicalCombiningClass.belowLeft.getter(unsigned char *a1@<X8>)
{
  *a1 = -38;
}

void static Unicode.CanonicalCombiningClass.below.getter(unsigned char *a1@<X8>)
{
  *a1 = -36;
}

void static Unicode.CanonicalCombiningClass.belowRight.getter(unsigned char *a1@<X8>)
{
  *a1 = -34;
}

void static Unicode.CanonicalCombiningClass.left.getter(unsigned char *a1@<X8>)
{
  *a1 = -32;
}

void static Unicode.CanonicalCombiningClass.right.getter(unsigned char *a1@<X8>)
{
  *a1 = -30;
}

void static Unicode.CanonicalCombiningClass.aboveLeft.getter(unsigned char *a1@<X8>)
{
  *a1 = -28;
}

void static Unicode.CanonicalCombiningClass.above.getter(unsigned char *a1@<X8>)
{
  *a1 = -26;
}

void static Unicode.CanonicalCombiningClass.aboveRight.getter(unsigned char *a1@<X8>)
{
  *a1 = -24;
}

void static Unicode.CanonicalCombiningClass.doubleBelow.getter(unsigned char *a1@<X8>)
{
  *a1 = -23;
}

void static Unicode.CanonicalCombiningClass.doubleAbove.getter(unsigned char *a1@<X8>)
{
  *a1 = -22;
}

void static Unicode.CanonicalCombiningClass.iotaSubscript.getter(unsigned char *a1@<X8>)
{
  *a1 = -16;
}

uint64_t Unicode.CanonicalCombiningClass.rawValue.getter()
{
  return *v0;
}

BOOL static Unicode.CanonicalCombiningClass.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

BOOL static Unicode.CanonicalCombiningClass.< infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

uint64_t Unicode.CanonicalCombiningClass.hashValue.getter()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 1);
}

uint64_t UInt8.hashValue.getter(unsigned __int8 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 1);
}

void Unicode.CanonicalCombiningClass.hash(into:)()
{
  Hasher._combine(_:)(*v0);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 < *a1;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Unicode.CanonicalCombiningClass()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Unicode.CanonicalCombiningClass()
{
  return Hasher._finalize()();
}

unsigned __int8 *protocol witness for RawRepresentable.init(rawValue:) in conformance Unicode.CanonicalCombiningClass@<X0>(unsigned __int8 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance Unicode.CanonicalCombiningClass(unsigned char *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t Unicode.Scalar.Properties.canonicalCombiningClass.getter@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = *v1;
  if (result >= 0xC0)
  {
    uint64_t result = _swift_stdlib_getNormData(result);
    unsigned int v4 = result >> 3;
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  *a1 = v4;
  return result;
}

Swift::Unicode::NumericType __swiftcall Unicode.NumericType.init(rawValue:)(Swift::Unicode::NumericType rawValue)
{
  if (rawValue >= Swift_Unicode_NumericType_unknownDefault)
  {
    Swift::Unicode::NumericType v2 = rawValue;
    unint64_t countAndFlagsBits = 0xD000000000000015;
    unint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(23);
    uint64_t v6 = v5;
    v29._unint64_t countAndFlagsBits = v4;
    v29._unint64_t object = (void *)v5;
    uint64_t v7 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000) == 0) {
      uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v7 || (v4 & ~v5 & 0x2000000000000000) != 0)
    {
      if ((v5 & 0x2000000000000000) == 0
        || (0x80000001816E2D50 & 0x2000000000000000) == 0
        || (unint64_t v9 = specialized _SmallString.init(_:appending:)(v4, v5, 0xD000000000000015, 0x80000001816E2D50 | 0x8000000000000000), (v11 & 1) != 0))
      {
        if ((0x80000001816E2D50 & 0x2000000000000000) != 0) {
          unint64_t v12 = (0x80000001816E2D50 >> 56) & 0xF;
        }
        else {
          unint64_t v12 = 21;
        }
        _StringGuts.append(_:)(0xD000000000000015, 0x80000001816E2D50 | 0x8000000000000000, 0, v12);
        swift_bridgeObjectRelease(0x80000001816E2D50 | 0x8000000000000000);
        unint64_t object = (unint64_t)v29._object;
        unint64_t countAndFlagsBits = v29._countAndFlagsBits;
LABEL_17:
        Swift::String v13 = _uint64ToString(_:radix:uppercase:)(v2, 10, 0);
        unint64_t v14 = v13._countAndFlagsBits;
        unint64_t v15 = (unint64_t)v13._object;
        uint64_t v16 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000) == 0) {
          uint64_t v16 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        if (!v16 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(object);
          Swift::String v29 = v13;
          goto LABEL_31;
        }
        if ((object & 0x2000000000000000) != 0)
        {
          if (((uint64_t)v13._object & 0x2000000000000000) != 0)
          {
            unint64_t v18 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v13._countAndFlagsBits, (unint64_t)v13._object);
            if ((v20 & 1) == 0)
            {
              unint64_t v21 = v18;
              uint64_t v22 = v19;
              swift_bridgeObjectRelease(object);
              swift_bridgeObjectRelease((uint64_t)v13._object);
              v29._unint64_t countAndFlagsBits = v21;
              v29._unint64_t object = v22;
              unint64_t v15 = (unint64_t)v22;
              unint64_t v14 = v21;
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }
        else if (((uint64_t)v13._object & 0x2000000000000000) != 0)
        {
LABEL_29:
          uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
          goto LABEL_30;
        }
        uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_30:
        _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
        swift_bridgeObjectRelease((uint64_t)v13._object);
        unint64_t v15 = (unint64_t)v29._object;
        unint64_t v14 = v29._countAndFlagsBits;
LABEL_31:
        uint64_t v23 = HIBYTE(v15) & 0xF;
        if ((v15 & 0x2000000000000000) == 0) {
          uint64_t v23 = v14 & 0xFFFFFFFFFFFFLL;
        }
        if (v23 || (v14 & ~v15 & 0x2000000000000000) != 0)
        {
          if ((v15 & 0x2000000000000000) == 0
            || (unint64_t v26 = specialized _SmallString.init(_:appending:)(v14, v15, 0, 0xE000000000000000), (v28 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            unint64_t v25 = (unint64_t)v29._object;
            uint64_t v24 = v29._countAndFlagsBits;
          }
          else
          {
            uint64_t v24 = v26;
            unint64_t v25 = v27;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(0xE000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v15);
          uint64_t v24 = 0;
          unint64_t v25 = 0xE000000000000000;
        }
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v24, v25, "Swift/UnicodeScalarProperties.swift", 35, 2, 0x5D0uLL, 0);
      }
      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x80000001816E2D50 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v5);
      unint64_t object = 0x80000001816E2D50 | 0x8000000000000000;
    }
    v29._unint64_t countAndFlagsBits = countAndFlagsBits;
    v29._unint64_t object = (void *)object;
    goto LABEL_17;
  }
  *unsigned int v1 = 2 - rawValue;
  return rawValue;
}

uint64_t Unicode.Scalar.Properties.numericType.getter@<X0>(char *a1@<X8>)
{
  uint64_t result = _swift_stdlib_getNumericType(*v1);
  if (result == 255)
  {
    char v4 = 3;
  }
  else
  {
    uint64_t result = Unicode.NumericType.init(rawValue:)(result);
    char v4 = v5;
  }
  *a1 = v4;
  return result;
}

uint64_t Unicode.Scalar.Properties.numericValue.getter()
{
  unsigned int v1 = *v0;
  int NumericType = _swift_stdlib_getNumericType(v1);
  if (NumericType == 255) {
    return 0;
  }
  Unicode.NumericType.init(rawValue:)(NumericType);
  return _swift_stdlib_getNumericValue(v1);
}

unint64_t Character._firstScalar.getter(uint64_t a1, unint64_t a2)
{
  unint64_t result = specialized Collection.first.getter(a1, a2);
  if ((result & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  return result;
}

BOOL Character._isSingleScalar.getter(uint64_t a1, unint64_t a2)
{
  v4._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)15)._rawBits;
  if ((a2 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v4)._rawBits;
  }
  else
  {
    Swift::UInt64 v5 = v4._rawBits >> 16;
    if ((a2 & 0x2000000000000000) != 0)
    {
      v13[0] = a1;
      v13[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      int v7 = *((unsigned __int8 *)v13 + v5);
    }
    else
    {
      if ((a1 & 0x1000000000000000) != 0) {
        uint64_t v6 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v6 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      }
      int v7 = v6[v5];
    }
    int v8 = (char)v7;
    unsigned int v9 = __clz(v7 ^ 0xFF) - 24;
    if (v8 >= 0) {
      LOBYTE(v9) = 1;
    }
    Swift::UInt64 rawBits = ((v5 + v9) << 16) | 5;
  }
  uint64_t v11 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v11 = a1 & 0xFFFFFFFFFFFFLL;
  }
  return rawBits >> 14 == 4 * v11;
}

BOOL Character.isASCII.getter(uint64_t a1, unint64_t a2)
{
  return (Character.asciiValue.getter(a1, a2) & 0x100) == 0;
}

uint64_t Character.asciiValue.getter(uint64_t a1, unint64_t a2)
{
  if (a1 == 2573 && a2 == 0xE200000000000000
    || (~a2 & 0x6000000000000000) != 0
    && (_stringCompareInternal(_:_:expecting:)(a1, a2, 2573, 0xE200000000000000, 0) & 1) != 0)
  {
    int v4 = 0;
    LOBYTE(v5) = 10;
    return v5 | (v4 << 8);
  }
  if (!Character._isSingleScalar.getter(a1, a2)) {
    goto LABEL_12;
  }
  unint64_t v6 = specialized Collection.first.getter(a1, a2);
  if ((v6 & 0x100000000) != 0) {
    goto LABEL_15;
  }
  if ((v6 & 0xFFFFFF80) != 0)
  {
LABEL_12:
    LOBYTE(v5) = 0;
    int v4 = 1;
    return v5 | (v4 << 8);
  }
  unint64_t v5 = specialized Collection.first.getter(a1, a2);
  if ((v5 & 0x100000000) != 0) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  if ((v5 & 0xFFFFFF00) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
  int v4 = 0;
  return v5 | (v4 << 8);
}

unint64_t Character.isWhitespace.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 45) & 1;
}

uint64_t Character.isNewline.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  BOOL v3 = (v2 - 8232) < 2 || v2 == 133;
  return (v2 - 14) >= 0xFFFFFFFC || v3;
}

BOOL Character.isNumber.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  int NumericType = _swift_stdlib_getNumericType(v2);
  int v4 = NumericType;
  if (NumericType != 255) {
    Unicode.NumericType.init(rawValue:)(NumericType);
  }
  return v4 != 255;
}

BOOL Character.isWholeNumber.getter(uint64_t a1, unint64_t a2)
{
  if (!Character._isSingleScalar.getter(a1, a2)) {
    return 0;
  }
  unint64_t v4 = specialized Collection.first.getter(a1, a2);
  if ((v4 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  int v5 = v4;
  int NumericType = _swift_stdlib_getNumericType(v4);
  if (NumericType == 255) {
    return 0;
  }
  Unicode.NumericType.init(rawValue:)(NumericType);
  double NumericValue = _swift_stdlib_getNumericValue(v5);
  BOOL v8 = NumericValue > -9.22337204e18;
  if (NumericValue >= 9.22337204e18) {
    BOOL v8 = 0;
  }
  return NumericValue == trunc(NumericValue) && v8;
}

uint64_t Character.wholeNumberValue.getter(uint64_t a1, unint64_t a2)
{
  if (!Character._isSingleScalar.getter(a1, a2)) {
    return 0;
  }
  unint64_t v4 = specialized Collection.first.getter(a1, a2);
  if ((v4 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  int v5 = v4;
  int NumericType = _swift_stdlib_getNumericType(v4);
  if (NumericType == 255) {
    return 0;
  }
  Unicode.NumericType.init(rawValue:)(NumericType);
  double NumericValue = _swift_stdlib_getNumericValue(v5);
  BOOL v8 = NumericValue > -9.22337204e18;
  if (NumericValue >= 9.22337204e18) {
    BOOL v8 = 0;
  }
  if ((v8 & (NumericValue == trunc(NumericValue))) != 0) {
    return (uint64_t)NumericValue;
  }
  else {
    return 0;
  }
}

Swift::Int_optional __swiftcall Int.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -9.22337204e18;
  if (exactly >= 9.22337204e18) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (trunc(exactly) == exactly);
  if (v2) {
    Swift::Int v3 = (uint64_t)exactly;
  }
  else {
    Swift::Int v3 = 0;
  }
  char v4 = v2 ^ 1;
  result.Swift::UInt32 value = v3;
  result.Swift::Bool is_nil = v4;
  return result;
}

BOOL Character.isHexDigit.getter(uint64_t a1, unint64_t a2)
{
  Character.hexDigitValue.getter(a1, a2);
  return (v2 & 1) == 0;
}

uint64_t Character.hexDigitValue.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    }
    if ((v4 - 58) >= 0xFFFFFFF6)
    {
      return (v4 - 48);
    }
    else if ((v4 - 71) >= 0xFFFFFFFA)
    {
      return (v4 - 55);
    }
    else if ((v4 - 103) >= 0xFFFFFFFA)
    {
      return (v4 - 87);
    }
    else
    {
      unsigned int v5 = v4 - 65335;
      if ((v4 - 65351) < 0xFFFFFFFA) {
        unsigned int v5 = 0;
      }
      if ((v4 - 65319) >= 0xFFFFFFFA) {
        unsigned int v6 = v4 - 65303;
      }
      else {
        unsigned int v6 = v5;
      }
      if ((v4 - 65306) >= 0xFFFFFFF6) {
        return (v4 - 65296);
      }
      else {
        return v6;
      }
    }
  }
  else
  {
    return 0;
  }
}

unint64_t Character.isLetter.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 7) & 1;
}

uint64_t Character._isUppercased.getter(uint64_t a1, unint64_t a2)
{
  return Character._isUppercased.getter(a1, a2, (uint64_t (*)(void))String.uppercased());
}

uint64_t Character._isLowercased.getter(uint64_t a1, unint64_t a2)
{
  return Character._isUppercased.getter(a1, a2, (uint64_t (*)(void))String.lowercased());
}

uint64_t Character._isUppercased.getter(uint64_t a1, unint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3();
  if (v5 == a1 && v6 == a2)
  {
    char v9 = 1;
    uint64_t v8 = a2;
  }
  else
  {
    uint64_t v8 = v6;
    if ((~a2 & 0x6000000000000000) == 0 && (v6 & 0x2000000000000000) != 0 && (v6 & 0x4000000000000000) != 0) {
      char v9 = 0;
    }
    else {
      char v9 = _stringCompareInternal(_:_:expecting:)(a1, a2, v5, v6, 0);
    }
  }
  swift_bridgeObjectRelease(v8);
  return v9 & 1;
}

uint64_t Character.isUppercase.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    }
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x80000000000) != 0) {
      return 1;
    }
  }
  if ((Character._isUppercased.getter(a1, a2) & 1) == 0) {
    return 0;
  }

  return Character.isCased.getter(a1, a2);
}

uint64_t Character.isCased.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    }
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x800) != 0) {
      goto LABEL_6;
    }
  }
  if ((Character._isUppercased.getter(a1, a2) & 1) == 0) {
LABEL_6:
  }
    char v5 = 1;
  else {
    char v5 = Character._isLowercased.getter(a1, a2) ^ 1;
  }
  return v5 & 1;
}

uint64_t Character.isLowercase.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    }
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x100000000) != 0) {
      return 1;
    }
  }
  if ((Character._isLowercased.getter(a1, a2) & 1) == 0) {
    return 0;
  }

  return Character.isCased.getter(a1, a2);
}

BOOL Character.isSymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 - 18 < 4;
}

unint64_t Character.isMathSymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 33) & 1;
}

BOOL Character.isCurrencySymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 == 19;
}

BOOL Character.isPunctuation.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  }
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 - 11 < 7;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._NFD.Iterator.next()()
{
  unint64_t v0 = specialized Unicode._InternalNFD.Iterator.next()();
  uint64_t v1 = v0;
  if ((v0 & 0x1000000000000) != 0) {
    uint64_t v1 = 0;
  }
  return (Swift::Unicode::Scalar_optional)(v1 | ((HIWORD(v0) & 1) << 32));
}

unint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._NFD.Iterator@<X0>(uint64_t a1@<X8>)
{
  unint64_t result = specialized Unicode._InternalNFD.Iterator.next()();
  if ((result & 0x1000000000000) != 0) {
    int v3 = 0;
  }
  else {
    int v3 = result;
  }
  *(_DWORD *)a1 = v3;
  *(unsigned char *)(a1 + 4) = BYTE6(result) & 1;
  return result;
}

unint64_t Unicode._NFD.makeIterator()@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *((void *)v1 + 2);
  unint64_t v2 = *((void *)v1 + 3);
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a1 + 8) = 0;
  long long v4 = *v1;
  *(void *)(a1 + 16) = *(void *)v1;
  *(_OWORD *)(a1 + 24) = v4;
  *(void *)(a1 + 40) = v3;
  *(void *)(a1 + 48) = v2;
  return swift_bridgeObjectRetain(v2);
}

__n128 protocol witness for Sequence.makeIterator() in conformance Unicode._NFD@<Q0>(uint64_t a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  unint64_t v3 = v1[1].n128_u64[1];
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a1 + 8) = 0;
  __n128 result = *v1;
  *(void *)(a1 + 16) = v1->n128_u64[0];
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 40) = v2;
  *(void *)(a1 + 48) = v3;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFD(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFD(a1, a2, (uint64_t (*)(void, void, void, uint64_t))specialized _copySequenceToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFD(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._NFC.Iterator.next()()
{
  unint64_t v0 = specialized Unicode._InternalNFC.Iterator.next()();
  return (Swift::Unicode::Scalar_optional)(v0 | ((HIDWORD(v0) & 1) << 32));
}

unint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._NFC.Iterator@<X0>(uint64_t a1@<X8>)
{
  unint64_t result = specialized Unicode._InternalNFC.Iterator.next()();
  *(_DWORD *)a1 = result;
  *(unsigned char *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t Unicode._NFC.makeIterator()@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *((void *)v1 + 2);
  unint64_t v2 = *((void *)v1 + 3);
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(unsigned char *)(a1 + 16) = 1;
  *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
  *(unsigned char *)(a1 + 32) = 0;
  long long v4 = *v1;
  *(void *)(a1 + 40) = *(void *)v1;
  *(_OWORD *)(a1 + 48) = v4;
  *(void *)(a1 + 64) = v3;
  *(void *)(a1 + 72) = v2;
  return swift_bridgeObjectRetain(v2);
}

__n128 protocol witness for Sequence.makeIterator() in conformance Unicode._NFC@<Q0>(__n128 *a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  unint64_t v3 = v1[1].n128_u64[1];
  a1->n128_u64[0] = (unint64_t)&_swiftEmptyArrayStorage;
  a1->n128_u8[8] = 0;
  a1->n128_u32[3] = 0;
  a1[1].n128_u8[0] = 1;
  a1[1].n128_u64[1] = (unint64_t)&_swiftEmptyArrayStorage;
  a1[2].n128_u8[0] = 0;
  __n128 result = *v1;
  a1[2].n128_u64[1] = v1->n128_u64[0];
  a1[3] = result;
  a1[4].n128_u64[0] = v2;
  a1[4].n128_u64[1] = v3;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFC(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFD(a1, a2, (uint64_t (*)(void, void, void, uint64_t))specialized _copySequenceToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFD(uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, uint64_t))
{
  uint64_t v4 = v3[3];
  uint64_t v5 = a3(*v3, v3[1], v3[2], v4);
  swift_bridgeObjectRelease(v4);
  return v5;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFD(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, void, void, void, void))
{
  return a6(a1, a2, a3, *v6, v6[1], v6[2], v6[3]);
}

unint64_t String._nfd.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, Swift::UInt64 *a3@<X8>)
{
  *a3 = specialized Collection.subscript.getter(a1, a2);
  a3[1] = v4;
  a3[2] = v6;
  a3[3] = v5;

  return swift_bridgeObjectRetain(v5);
}

unint64_t Substring._nfd.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return swift_bridgeObjectRetain(a4);
}

uint64_t Unicode.Scalar.Properties._script.getter()
{
  return _swift_stdlib_getScript(*v0);
}

void *Unicode.Scalar.Properties._scriptExtensions.getter()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *v0;
  unsigned __int8 v13 = 0;
  ScriptExtensions = _swift_stdlib_getScriptExtensions(v1, &v13);
  if (ScriptExtensions)
  {
    unint64_t v3 = ScriptExtensions;
    uint64_t v4 = v13;
    unint64_t v5 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v13, 0, (uint64_t)&_swiftEmptyArrayStorage);
    Swift::UInt64 v6 = v5;
    if (v4)
    {
      int v7 = v5[2];
      do
      {
        char v9 = *v3++;
        char v8 = v9;
        unint64_t v10 = v6[3];
        if ((unint64_t)v7 >= v10 >> 1) {
          Swift::UInt64 v6 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v10 > 1), (int64_t)&v7->isa + 1, 1, (uint64_t)v6);
        }
        v6[2] = (char *)&v7->isa + 1;
        *((unsigned char *)&v7->info + (void)v6) = v8;
        int v7 = (__objc2_class *)((char *)v7 + 1);
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    uint64_t v11 = (unint64_t *)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
    Swift::UInt64 v6 = swift_allocObject(v11, 0x21uLL, 7uLL);
    *((_OWORD *)v6 + 1) = xmmword_18162AC80;
    *((unsigned char *)v6 + 32) = _swift_stdlib_getScript(v1);
  }
  return v6;
}

unint64_t Unicode.Scalar.Properties._caseFolded.getter()
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v1 = *v0;
  uint64_t v16 = -1;
  int v17 = -1;
  _swift_stdlib_getCaseMapping(v1, (int *)&v16);
  uint64_t v2 = 0;
  unint64_t v3 = 0;
  unint64_t v4 = 0xE000000000000000;
  do
  {
    unsigned int v5 = *(_DWORD *)((char *)&v16 + v2);
    if (v5 == -1) {
      break;
    }
    if (HIWORD(v5) > 0x10u || (v5 & 0xFFFFF800) == 55296) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnicodeSPI.swift", 22, 2, 0xCFuLL, 0);
    }
    unint64_t v18 = v3;
    unint64_t v19 = v4;
    uint64_t v8 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v5);
    unint64_t v9 = v7;
    if ((v4 & 0x2000000000000000) == 0)
    {
      if ((v7 & 0x2000000000000000) != 0) {
LABEL_14:
      }
        uint64_t v10 = HIBYTE(v9) & 0xF;
      else {
LABEL_11:
      }
        uint64_t v10 = v8 & 0xFFFFFFFFFFFFLL;
      _StringGuts.append(_:)(v8, v9, 0, v10);
      swift_bridgeObjectRelease(v9);
      unint64_t v3 = v18;
      unint64_t v4 = v19;
      goto LABEL_16;
    }
    if ((v7 & 0x2000000000000000) == 0) {
      goto LABEL_11;
    }
    unint64_t v11 = specialized _SmallString.init(_:appending:)(v3, v4, v8, v7);
    if (v13) {
      goto LABEL_14;
    }
    unint64_t v3 = v11;
    unint64_t v14 = v12;
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(v4);
    unint64_t v4 = v14;
LABEL_16:
    v2 += 4;
    swift_bridgeObjectRelease(0xE000000000000000);
  }
  while (v2 != 12);
  return v3;
}

Swift::String::Index __swiftcall String._wordIndex(after:)(Swift::String::Index after)
{
  unint64_t v3 = _StringGuts.validateWordIndex(_:)(after._rawBits, v1, v2, (uint64_t (*)(void))_StringGuts.validateSubscalarIndex(_:));
  return (Swift::String::Index)(_StringGuts.nextWordIndex(startingAt:)(v3 >> 16) << 16);
}

Swift::String::Index __swiftcall String._wordIndex(before:)(Swift::String::Index before)
{
  unint64_t v3 = _StringGuts.validateWordIndex(_:)(before._rawBits, v1, v2, (uint64_t (*)(void))_StringGuts.validateInclusiveSubscalarIndex(_:));
  if (!(v3 >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/UnicodeSPI.swift", 22, 2, 0xEAuLL, 0);
  }
  return (Swift::String::Index)(_StringGuts.previousWordIndex(endingAt:)(v3 >> 16) << 16);
}

Swift::String::Index __swiftcall String._nearestWordIndex(atOrBelow:)(Swift::String::Index atOrBelow)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveSubscalarIndex(_:)(atOrBelow)._rawBits;
  Swift::UInt64 rawBits = v5._rawBits;
  if (v5._rawBits)
  {
    if (v5._rawBits < 0x10000) {
      return (Swift::String::Index)rawBits;
    }
  }
  else
  {
    Swift::UInt64 rawBits = v5._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v5)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (rawBits < 0x10000) {
      return (Swift::String::Index)rawBits;
    }
  }
  Swift::UInt64 v7 = rawBits >> 16;
  uint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 != v8)
  {
    Swift::Int v9 = _StringGuts.previousWordIndex(endingAt:)(rawBits >> 16);
    if (v7 != _StringGuts.nextWordIndex(startingAt:)(v9)) {
      return (Swift::String::Index)(v9 << 16);
    }
  }
  return (Swift::String::Index)rawBits;
}

id key path getter for Unmanaged._value : <A>Unmanaged<A>@<X0>(void **a1@<X0>, void *a2@<X8>)
{
  unint64_t v2 = *a1;
  *a2 = v2;
  return swift_unknownObjectRetain(v2);
}

void Unmanaged._value.setter(void *a1)
{
  swift_unknownObjectRelease(a1);
  *uint64_t v1 = a1;
}

void (*Unmanaged._value.modify(void **a1))(uint64_t a1)
{
  unint64_t v3 = *v1;
  *a1 = *v1;
  a1[1] = v1;
  swift_unknownObjectRetain(v3);
  return Unmanaged._value.modify;
}

void Unmanaged._value.modify(uint64_t a1)
{
  id v1 = *(id *)a1;
  unint64_t v2 = *(void **)(a1 + 8);
  swift_unknownObjectRelease(*(id *)a1);
  *unint64_t v2 = v1;
}

void *Unmanaged.init(_private:)(void *a1)
{
  return a1;
}

id Unmanaged.autorelease()(void *a1)
{
  id v1 = swift_unknownObjectRetain(a1);
  swift_unknownObjectRelease(v1);
  return v1;
}

Swift::Int UnsafePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter(a1, a2, (uint64_t (*)(void))type metadata accessor for UnsafePointer, protocol conformance descriptor for UnsafePointer<A>);
}

Swift::Int _sSPyxGSHsRi_zrlSH9hashValueSivgTW(uint64_t a1)
{
  return UnsafePointer.hashValue.getter(*v1, *(void *)(a1 + 16));
}

void _sSPyxGSHsRi_zrlSH4hash4intoys6HasherVz_tFTW(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafePointer<A>, a2, a3);

  _Pointer.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int _sSPyxGSHsRi_zrlSH13_rawHashValue4seedS2i_tFTW(Swift::Int a1, unint64_t *a2, uint64_t a3)
{
  swift_getWitnessTable(protocol conformance descriptor for UnsafePointer<A>, a2, a3);

  return _Pointer._rawHashValue(seed:)(a1);
}

uint64_t _sSPyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafePointer<A>, a1, a3);

  return _Pointer.debugDescription.getter((uint64_t)a1, WitnessTable);
}

uint64_t _sSPyxGs17CustomReflectablesRi_zrlsABP12customMirrors0D0VvgTW@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  swift_getWitnessTable(protocol conformance descriptor for UnsafePointer<A>, a1, a2);

  return _Pointer.customMirror.getter((Class *)a1, a3);
}

uint64_t UnsafePointer.subscript.unsafeAddressor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 + *(void *)(*(void *)(a3 - 8) + 72) * a1;
}

uint64_t UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5)
{
  return UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(a1, a2, a3, a4, a5);
}

{
  return a3(a5);
}

Swift::Int UnsafeMutablePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter(a1, a2, (uint64_t (*)(void))type metadata accessor for UnsafeMutablePointer, protocol conformance descriptor for UnsafeMutablePointer<A>);
}

Swift::Int AutoreleasingUnsafeMutablePointer.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(void), int *a4)
{
  Swift::String::Index v5 = (unint64_t *)a3(0);
  swift_getWitnessTable(a4, v5, v6);
  return _Pointer._rawHashValue(seed:)(0);
}

Swift::Int _sSpyxGSHsRi_zrlSH9hashValueSivgTW(uint64_t a1)
{
  return UnsafeMutablePointer.hashValue.getter(*v1, *(void *)(a1 + 16));
}

void _sSpyxGSHsRi_zrlSH4hash4intoys6HasherVz_tFTW(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutablePointer<A>, a2, a3);

  _Pointer.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int _sSpyxGSHsRi_zrlSH13_rawHashValue4seedS2i_tFTW(Swift::Int a1, unint64_t *a2, uint64_t a3)
{
  swift_getWitnessTable(protocol conformance descriptor for UnsafeMutablePointer<A>, a2, a3);

  return _Pointer._rawHashValue(seed:)(a1);
}

void *protocol witness for Strideable.advanced(by:) in conformance AutoreleasingUnsafeMutablePointer<A>@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = *v3 + *(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 72) * *result;
  return result;
}

uint64_t _sSpyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutablePointer<A>, a1, a3);

  return _Pointer.debugDescription.getter((uint64_t)a1, WitnessTable);
}

uint64_t _sSpyxGs17CustomReflectablesRi_zrlsABP12customMirrors0D0VvgTW@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  swift_getWitnessTable(protocol conformance descriptor for UnsafeMutablePointer<A>, a1, a2);

  return _Pointer.customMirror.getter((Class *)a1, a3);
}

uint64_t UnsafePointer.pointee.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16))(a3, a1, a2);
}

uint64_t key path getter for UnsafeMutablePointer.pointee : <A>UnsafeMutablePointer<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(a3 + a2 - 8) - 8) + 16))(a4, *a1);
}

uint64_t key path setter for UnsafeMutablePointer.pointee : <A>UnsafeMutablePointer<A>(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)(*(void *)(a4 + a3 - 8) - 8) + 24))(*a2, a1);
}

uint64_t UnsafeMutablePointer.pointee.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 40))(a2, a1);
}

uint64_t (*UnsafeMutablePointer.pointee.modify())()
{
  return EnumeratedSequence._base.modify;
}

void *specialized UnsafeMutablePointer.initialize(repeating:count:)(void *__c, size_t __len, void *__b)
{
  if ((__len & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize(repeating:count:): negative count", 65, 2, "Swift/UnsafePointer.swift", 25, 2, 0x371uLL, 0);
  }
  if (__len)
  {
    return memset(__b, (int)__c, __len);
  }
  return __c;
}

uint64_t UnsafeMutablePointer.initialize(repeating:count:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize(repeating:count:): negative count", 65, 2, "Swift/UnsafePointer.swift", 25, 2, 0x371uLL, 0);
  }
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(a4 - 8);
    Swift::Int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 16);
    uint64_t v10 = *(void *)(v8 + 72);
    do
    {
      __n128 result = v9(a3, v7, a4);
      a3 += v10;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t UnsafeMutablePointer.initialize(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a2, a1);
}

char *UnsafeMutablePointer.moveAssign(from:count:)(char *__src, uint64_t a2, char *__dst, unint64_t *a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.moveUpdate(from:) with negative count", 58, 2, "Swift/UnsafePointer.swift", 25, 2, 0x46AuLL, 0);
  }
  uint64_t v4 = *(void *)(*(a4 - 1) + 72) * a2;
  Swift::String::Index v5 = &__dst[v4];
  uint64_t v6 = &__src[v4];
  if (v5 > __src && v6 > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "moveUpdate overlapping range", 28, 2, "Swift/UnsafePointer.swift", 25, 2, 0x46CuLL, 0);
  }

  return swift_arrayAssignWithTake(__dst, __src, a2, a4);
}

uint64_t UnsafeMutablePointer.withMemoryRebound<A, B>(to:capacity:_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5)
{
  return UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(a1, a2, a3, a4, a5);
}

uint64_t UnsafePointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, a2 + *(void *)(*(void *)(a3 - 8) + 72) * a1);
}

uint64_t key path getter for UnsafeMutablePointer.subscript(_:) : <A>UnsafeMutablePointer<A>A@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(*(void *)((char *)a2 + a3 - 8) - 8);
  return (*(uint64_t (**)(uint64_t, void))(v4 + 16))(a4, *a1 + *(void *)(v4 + 72) * *a2);
}

uint64_t key path setter for UnsafeMutablePointer.subscript(_:) : <A>UnsafeMutablePointer<A>A(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)((char *)a3 + a4 - 8) - 8);
  return (*(uint64_t (**)(void, uint64_t, void))(v4 + 24))(*a2 + *(void *)(v4 + 72) * *a3, a1, *(void *)((char *)a3 + a4 - 8));
}

uint64_t UnsafeMutablePointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 40))(a3 + *(void *)(*(void *)(a4 - 8) + 72) * a2, a1, a4);
}

uint64_t (*UnsafeMutablePointer.subscript.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t static UnsafePointer._max.getter(uint64_t a1)
{
  return -*(void *)(*(void *)(a1 - 8) + 72);
}

uint64_t UnsafeRawPointer.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeRawPointer()
{
  return _rawPointerToString(_:)(*v0)._countAndFlagsBits;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UnsafeRawPointer@<X0>(uint64_t a1@<X8>)
{
  return specialized _Pointer.customMirror.getter(*v1, (swift *)&type metadata for UnsafeRawPointer, a1);
}

Swift::Void __swiftcall UnsafeRawPointer.deallocate()()
{
  swift_slowDealloc(v0);
}

void *protocol witness for Strideable.distance(to:) in conformance UnsafeRawPointer@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result - *v2;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance UnsafeRawPointer@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 + *result;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UnsafeRawPointer(void *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  *a1 = *a4 + *a6;
  return 0;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeMutableRawPointer()
{
  return specialized _Pointer.debugDescription.getter(*v0);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UnsafeMutableRawPointer@<X0>(uint64_t a1@<X8>)
{
  return specialized _Pointer.customMirror.getter(*v1, (swift *)&type metadata for UnsafeMutableRawPointer, a1);
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.initializeMemory: negative count", 56, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x456uLL, 0);
  }
  uint64_t v6 = a3;
  if (a3)
  {
    uint64_t v9 = *(void *)(a5 - 8);
    uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 16);
    uint64_t v11 = a4;
    do
    {
      v10(v11, a2, a5);
      v11 += *(void *)(v9 + 72);
      --v6;
    }
    while (v6);
  }
  return a4;
}

char *UnsafeMutableRawPointer.moveInitializeMemory<A>(as:from:count:)(int a1, char *a2, uint64_t a3, char *__dst, unint64_t *a5)
{
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.moveInitializeMemory with negative count", 64, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4C8uLL, 0);
  }
  if (__dst < a2 || &a2[*(void *)(*(a5 - 1) + 72) * a3] <= __dst) {
    swift_arrayInitWithTakeFrontToBack(__dst, a2, a3, a5);
  }
  else {
    swift_arrayInitWithTakeBackToFront(__dst, a2, a3, (uint64_t)a5);
  }
  return __dst;
}

void *UnsafeMutableRawPointer.storeBytes<A>(of:toByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(a1, a2, a5, a4, a5);
}

void *UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a5 - 8);
  size_t v7 = *(void *)(v6 + 64);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (void *)(v10 + v9);
  if ((*(unsigned char *)(v6 + 80) & (v10 + v9)) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "storeBytes to misaligned raw pointer", 36, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x5DEuLL, 0);
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))((char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v8, a5);
  (*(void (**)(char *, uint64_t))(v6 + 8))((char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), a5);
  if ((v7 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  return memcpy(v11, (char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
}

void _UTFParser<>.parseScalar<A>(from:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  uint64_t v280 = a6;
  uint64_t v265 = a5;
  uint64_t v264 = a3;
  uint64_t v263 = a1;
  v241 = a7;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a2, (uint64_t)&protocol requirements base descriptor for _UTFParser, associated type descriptor for _UTFParser.Encoding);
  uint64_t AssociatedConformanceWitness = (int **)swift_getAssociatedConformanceWitness(a4, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UTFParser, associated conformance descriptor for _UTFParser._UTFParser.Encoding: _UnicodeEncoding);
  v240 = swift_getAssociatedTypeWitness(0, AssociatedConformanceWitness, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v234 = *((void *)v240 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v240);
  v235 = &v230[-v13];
  uint64_t v233 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v12);
  v232 = &v230[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
  unint64_t v15 = swift_getAssociatedTypeWitness(255, AssociatedConformanceWitness, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.CodeUnit);
  v257 = AssociatedConformanceWitness;
  v259 = AssociatedTypeWitness;
  uint64_t v272 = swift_getAssociatedConformanceWitness((uint64_t)AssociatedConformanceWitness, (uint64_t)AssociatedTypeWitness, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger);
  uint64_t v16 = *(void *)(v272 + 8);
  v266 = *(int ***)(*(void *)(v16 + 24) + 16);
  v262 = swift_getAssociatedTypeWitness(0, v266, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v262);
  v261 = &v230[-v17];
  v279 = (unint64_t *)type metadata accessor for CollectionOfOne(0, (uint64_t)v15, v18, v19);
  MEMORY[0x1F4188790](v279);
  v278 = &v230[-v20];
  v239 = type metadata accessor for Optional(0, (uint64_t)v15, v21, v22);
  uint64_t v238 = (uint64_t)*(v239 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v239);
  unint64_t v25 = &v230[-((v24 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  char v28 = &v230[-v27];
  uint64_t v282 = *((void *)v15 - 1);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  v237 = &v230[-((v30 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v236 = &v230[-v32];
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v245 = &v230[-v34];
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  v243 = &v230[-v36];
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  v270 = &v230[-v38];
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  v253 = &v230[-v40];
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v244 = &v230[-v42];
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  v271 = &v230[-v44];
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  unint64_t v281 = (unint64_t)&v230[-v46];
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  uint64_t v49 = (uint64_t (*)(const char *, uint64_t))&v230[-v48];
  uint64_t v50 = MEMORY[0x1F4188790](v47);
  v276 = &v230[-v51];
  MEMORY[0x1F4188790](v50);
  uint64_t v53 = &v230[-v52];
  char v54 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 40);
  uint64_t v55 = a4;
  uint64_t v273 = a4 + 40;
  v256 = v54;
  uint64_t v56 = v54(a2, a4);
  uint64_t v274 = v7;
  uint64_t v258 = a2;
  v252 = v25;
  if ((v56 & 0xFF00000000) != 0)
  {
    v277 = v49;
    v190 = swift_checkMetadataState(0, (uint64_t)v259);
    uint64_t v191 = a4;
    uint64_t v192 = v256(a2, a4);
    int v286 = v192;
    v193 = *(void (**)(int *, ValueMetadata *))(v16 + 96);
    unint64_t v196 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v192, v194, v195);
    v197 = v276;
    v267 = (void (*)(int *, void))v196;
    uint64_t v269 = (uint64_t)v193;
    v193(&v286, &type metadata for UInt32);
    uint64_t v66 = (uint64_t)v257;
    unsigned int v198 = v257[14];
    v275 = v190;
    char v199 = ((uint64_t (*)(unsigned char *, uint64_t *, int **))v198)(v197, v190, v257);
    uint64_t v200 = v282;
    uint64_t v201 = v282 + 8;
    v283 = *(void (**)(unsigned char *, const char *))(v282 + 8);
    v283(v197, v15);
    if (v199)
    {
      v202 = (void (*)(uint64_t, uint64_t))v256;
      int v286 = v256(v258, v191);
      ((void (*)(int *, ValueMetadata *, void (*)(int *, void), const char *, uint64_t))v269)(&v286, &type metadata for UInt32, v267, v15, v16);
      uint64_t v203 = v258;
      v202(v258, v191);
      LOBYTE(v284) = 0;
      v204 = (void (*)(int *, void))(*(uint64_t (**)(int *, uint64_t, uint64_t))(v191 + 56))(&v286, v203, v191);
      uint64_t v205 = swift_getAssociatedConformanceWitness(v66, (uint64_t)v275, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
      v206 = (unint64_t *)type metadata accessor for _UIntBuffer(0, (uint64_t)v15, v272, v205);
      uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, v206, v207);
      v209 = v277;
      RangeReplaceableCollection.remove(at:)((uint64_t)&v284, (uint64_t)v206, WitnessTable, (uint64_t)v277);
      v283(v209, v15);
      v204(&v286, 0);
      v210 = v278;
      (*(void (**)(unsigned char *, unsigned char *, const char *))(v282 + 32))(v278, v197, v15);
      v211 = v279;
      uint64_t v212 = v280;
      v213 = *(void (**)(unsigned char *, unint64_t *, uint64_t, const char *, uint64_t))(v280 + 56);
      uint64_t v215 = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v279, v214);
      v216 = v241;
      v217 = v211;
      v218 = v240;
      v213(v210, v217, v215, v240, v212);
      char v61 = type metadata accessor for Unicode.ParseResult(0, (uint64_t)v218, v219, v220);
      char v62 = v216;
LABEL_53:
      unsigned int v63 = 0;
      goto LABEL_54;
    }
    uint64_t v280 = v201;
    v254 = *(void (**)(uint64_t, uint64_t))(v265 + 16);
    unint64_t v260 = (v265 + 16) & 0xFFFFFFFFFFFFLL | 0xFE64000000000000;
    uint64_t v78 = v191;
    uint64_t v81 = v272;
    unint64_t v25 = v252;
    uint64_t v85 = v200;
  }
  else
  {
    unint64_t v57 = *(void (**)(uint64_t, uint64_t))(v265 + 16);
    unint64_t v260 = v265 + 16;
    v254 = v57;
    ((void (*)(uint64_t))v57)(v264);
    uint64_t v58 = v282;
    if ((*(unsigned int (**)(unsigned char *, uint64_t, const char *))(v282 + 48))(v28, 1, v15) == 1)
    {
      (*(void (**)(unsigned char *, Class *))(v238 + 8))(v28, v239);
LABEL_4:
      char v61 = type metadata accessor for Unicode.ParseResult(0, (uint64_t)v240, v59, v60);
      char v62 = v241;
      unsigned int v63 = 2;
      goto LABEL_54;
    }
    char v64 = *(void (**)(unsigned char *, unsigned char *, const char *))(v58 + 32);
    v64(v53, v28, v15);
    uint64_t v65 = swift_checkMetadataState(0, (uint64_t)v259);
    uint64_t v66 = (uint64_t)v257;
    if (((uint64_t (*)(unsigned char *, uint64_t *, int **))v257[14])(v53, v65, v257))
    {
      int v67 = v278;
      v64(v278, v53, v15);
      char v68 = v279;
      uint64_t v69 = v280;
      int v70 = *(void (**)(unsigned char *, unint64_t *, uint64_t, const char *, uint64_t))(v280 + 56);
      uint64_t v72 = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v279, v71);
      unint64_t v73 = v241;
      uint64_t v74 = v68;
      unint64_t v75 = v240;
      v70(v67, v74, v72, v240, v69);
      char v61 = type metadata accessor for Unicode.ParseResult(0, (uint64_t)v75, v76, v77);
      char v62 = v73;
      goto LABEL_53;
    }
    unint64_t v260 = v260 & 0xFFFFFFFFFFFFLL | 0xFE64000000000000;
    uint64_t v78 = v55;
    uint64_t v79 = (void (*)(int *, void))(*(uint64_t (**)(int *, uint64_t, uint64_t))(v55 + 56))(&v286, v258, v55);
    uint64_t v80 = swift_getAssociatedConformanceWitness(v66, (uint64_t)v65, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
    uint64_t v81 = v272;
    uint64_t v82 = (unint64_t *)type metadata accessor for _UIntBuffer(0, (uint64_t)v15, v272, v80);
    _UIntBuffer.append(_:)((uint64_t)v53, v82);
    uint64_t v83 = v282;
    unint64_t v84 = *(void (**)(unsigned char *, const char *))(v282 + 8);
    uint64_t v280 = v282 + 8;
    v283 = v84;
    v84(v53, v15);
    v79(&v286, 0);
    uint64_t v85 = v83;
  }
  v250 = (unsigned int (**)(unsigned char *, uint64_t, const char *))(v85 + 48);
  v249 = (void (**)(unint64_t, unsigned char *, const char *))(v85 + 32);
  uint64_t v268 = v78;
  uint64_t v251 = v78 + 56;
  uint64_t v248 = v81 + 64;
  v279 = (unint64_t *)(v16 + 64);
  uint64_t v282 = v85 + 16;
  v255 = v266 + 3;
  v278 = (unsigned char *)(v16 + 128);
  v275 = (uint64_t *)(v16 + 120);
  uint64_t v242 = v16 + 96;
  uint64_t v247 = v81 + 56;
  uint64_t v86 = v274;
  uint64_t v87 = v258;
  uint64_t v246 = v16;
  while (1)
  {
    v254(v264, v265);
    if ((*v250)(v25, 1, v15) == 1) {
      break;
    }
    (*v249)(v281, v25, v15);
    uint64_t v88 = (*(uint64_t (**)(int *, uint64_t))(v268 + 56))(&v286, v87);
    uint64_t v90 = v89;
    char v91 = *(unsigned char *)(v89 + 4);
    unsigned int v284 = *(_DWORD *)v89;
    char v285 = v91;
    uint64_t v92 = swift_getAssociatedConformanceWitness(v66, (uint64_t)v259, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
    uint64_t v93 = v272;
    int v94 = (unint64_t *)type metadata accessor for _UIntBuffer(0, (uint64_t)v15, v272, v92);
    uint64_t v96 = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, v94, v95);
    uint64_t v97 = Collection.count.getter((uint64_t)v94, v96);
    if (__OFADD__(v97, 1))
    {
      __break(1u);
LABEL_58:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    }
    if (specialized _UIntBuffer.capacity.getter((uint64_t)v15, v93) < v97 + 1) {
      goto LABEL_58;
    }
    v267 = (void (*)(int *, void))v88;
    uint64_t v98 = v271;
    (*(void (**)(const char *, uint64_t))(v93 + 64))(v15, v93);
    v277 = *(uint64_t (**)(const char *, uint64_t))(v16 + 64);
    char v99 = v277(v15, v16);
    int v100 = v276;
    unsigned int v101 = v253;
    if (v99)
    {
      uint64_t v102 = v244;
      (*(void (**)(unsigned char *, unsigned char *, const char *))v282)(v244, v98, v15);
      unint64_t v103 = v266;
      uint64_t v104 = v262;
      uint64_t v105 = swift_getAssociatedConformanceWitness((uint64_t)v266, (uint64_t)v15, (uint64_t)v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v106 = v261;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v105 + 8))(&qword_18162B0B8, 256, v104, v105);
      ((void (*)(unsigned char *, const char *, int **))v103[3])(v106, v15, v103);
      LOBYTE(v104) = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32) + 8)
                                                                               + 32))(v102, v100, v15);
      unsigned int v107 = v283;
      v283(v100, v15);
      if ((v104 & 1) == 0) {
        goto LABEL_59;
      }
      v107(v102, v15);
      uint64_t v98 = v271;
    }
    uint64_t v108 = *(uint64_t (**)(const char *, uint64_t))(v16 + 128);
    if (v108(v15, v16) >= 32)
    {
      char v109 = *(void (**)(unsigned char *, unsigned char *, const char *))v282;
      (*(void (**)(unsigned char *, unsigned char *, const char *))v282)(v101, v98, v15);
      unsigned int v284 = -1;
      char v110 = v277(v15, v16);
      uint64_t v111 = v108(v15, v16);
      if (v110)
      {
        if (v111 <= 32)
        {
          char v121 = v266;
          unsigned int v122 = v262;
          uint64_t v123 = swift_getAssociatedConformanceWitness((uint64_t)v266, (uint64_t)v15, (uint64_t)v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v124 = v261;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v123 + 8))(&qword_18162B0B8, 256, v122, v123);
          uint64_t v125 = v124;
          int v100 = v276;
          ((void (*)(unsigned char *, const char *, int **))v121[3])(v125, v15, v121);
          LODWORD(v269) = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32)
                                                                                                + 8)
                                                                                    + 40))(v101, v100, v15);
          v283(v100, v15);
          unsigned int v231 = v284;
          int v126 = v237;
          v109(v237, v101, v15);
          if (v269)
          {
            unsigned int v127 = (*(uint64_t (**)(const char *, uint64_t))(v16 + 120))(v15, v16);
            unsigned int v128 = v126;
            unsigned int v129 = v283;
            v283(v128, v15);
            BOOL v155 = v231 >= v127;
            uint64_t v117 = v129;
            if (!v155) {
              goto LABEL_60;
            }
          }
          else
          {
            uint64_t v117 = v283;
            v283(v126, v15);
          }
        }
        else
        {
          uint64_t v114 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, const char *, uint64_t))(v16 + 96);
          unint64_t v115 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v111, v112, v113);
          v114(&v284, &type metadata for UInt32, v115, v15, v16);
          char v116 = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32) + 8)
                                                                           + 16))(v100, v101, v15);
          uint64_t v117 = v283;
          v283(v100, v15);
          if (v116) {
            goto LABEL_60;
          }
        }
      }
      else if (v111 <= 32)
      {
        v109(v100, v101, v15);
        unsigned int v130 = (*(uint64_t (**)(const char *, uint64_t))(v16 + 120))(v15, v16);
        uint64_t v117 = v283;
        v283(v100, v15);
        if (v284 < v130) {
          goto LABEL_60;
        }
      }
      else
      {
        char v118 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, const char *, uint64_t))(v16 + 96);
        unint64_t v119 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v111, v112, v113);
        v118(&v284, &type metadata for UInt32, v119, v15, v16);
        char v120 = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32) + 8)
                                                                         + 16))(v100, v101, v15);
        uint64_t v117 = v283;
        v283(v100, v15);
        if (v120) {
          goto LABEL_60;
        }
      }
      v117(v101, v15);
      uint64_t v98 = v271;
    }
    uint64_t v269 = *(void *)(v16 + 120);
    int v131 = ((uint64_t (*)(const char *, uint64_t))v269)(v15, v16);
    unsigned int v132 = v283;
    v283(v98, v15);
    *(_DWORD *)v90 &= ~(v131 << *(unsigned char *)(v90 + 4));
    BOOL v133 = *(void (**)(unsigned char *, unsigned char *, const char *))v282;
    v134 = v270;
    (*(void (**)(unsigned char *, unint64_t, const char *))v282)(v270, v281, v15);
    if (v277(v15, v16))
    {
      unsigned int v135 = v243;
      v133(v243, v134, v15);
      uint64_t v136 = v266;
      unsigned __int8 v137 = v262;
      uint64_t v138 = swift_getAssociatedConformanceWitness((uint64_t)v266, (uint64_t)v15, (uint64_t)v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v139 = v261;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v138 + 8))(&qword_18162B0B8, 256, v137, v138);
      uint64_t v140 = v139;
      int v100 = v276;
      ((void (*)(unsigned char *, const char *, int **))v136[3])(v140, v15, v136);
      LOBYTE(v137) = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32) + 8)
                                                                               + 32))(v135, v100, v15);
      v132(v100, v15);
      if ((v137 & 1) == 0) {
LABEL_59:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
      v132(v135, v15);
      v134 = v270;
    }
    if (v108(v15, v16) >= 32)
    {
      uint64_t v141 = v245;
      v133(v245, v134, v15);
      unsigned int v284 = -1;
      char v142 = v277(v15, v16);
      uint64_t v143 = v108(v15, v16);
      if (v142)
      {
        if (v143 <= 32)
        {
          uint64_t v146 = v266;
          uint64_t v147 = v262;
          uint64_t v148 = swift_getAssociatedConformanceWitness((uint64_t)v266, (uint64_t)v15, (uint64_t)v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v149 = v141;
          uint64_t v150 = v261;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v148 + 8))(&qword_18162B0B8, 256, v147, v148);
          ((void (*)(unsigned char *, const char *, int **))v146[3])(v150, v15, v146);
          LOBYTE(v147) = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32)
                                                                                               + 8)
                                                                                   + 40))(v149, v100, v15);
          uint64_t v151 = v283;
          v283(v100, v15);
          unsigned int v152 = v284;
          v153 = v236;
          v133(v236, v149, v15);
          if (v147)
          {
            unsigned int v154 = ((uint64_t (*)(const char *, uint64_t))v269)(v15, v16);
            v151(v153, v15);
            BOOL v155 = v152 >= v154;
            uint64_t v141 = v245;
LABEL_42:
            v134 = v270;
            if (!v155) {
LABEL_60:
            }
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
          }
          else
          {
            v151(v153, v15);
            uint64_t v141 = v245;
            v134 = v270;
          }
LABEL_45:
          v151(v141, v15);
          goto LABEL_46;
        }
      }
      else if (v143 <= 32)
      {
        v133(v100, v141, v15);
        unsigned int v159 = ((uint64_t (*)(const char *, uint64_t))v269)(v15, v16);
        uint64_t v151 = v283;
        v283(v100, v15);
        BOOL v155 = v284 >= v159;
        goto LABEL_42;
      }
      uint64_t v156 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, const char *, uint64_t))(v16 + 96);
      unint64_t v157 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v143, v144, v145);
      v156(&v284, &type metadata for UInt32, v157, v15, v16);
      char v158 = (*(uint64_t (**)(unsigned char *, unsigned char *, const char *))(*(void *)(*(void *)(v16 + 32) + 8) + 16))(v100, v141, v15);
      uint64_t v151 = v283;
      v283(v100, v15);
      v134 = v270;
      if (v158) {
        goto LABEL_60;
      }
      goto LABEL_45;
    }
LABEL_46:
    uint64_t v160 = v283;
    v283((unsigned char *)v281, v15);
    int v161 = ((uint64_t (*)(const char *, uint64_t))v269)(v15, v16);
    v160(v134, v15);
    char v162 = *(unsigned char *)(v90 + 4);
    *(_DWORD *)v90 |= v161 << v162;
    uint64_t v163 = v272;
    uint64_t v164 = *(uint64_t (**)(const char *, uint64_t))(v272 + 56);
    *(unsigned char *)(v90 + 4) = v162 + v164(v15, v272);
    v267(&v286, 0);
    uint64_t v165 = v258;
    uint64_t v166 = v268;
    uint64_t v167 = (void (*)(uint64_t, uint64_t))v256;
    uint64_t v269 = v256(v258, v268);
    v277 = v164;
    uint64_t v168 = v164(v15, v163);
    if (!v168 || (v169 = v168, v167(v165, v166), (uint64_t v170 = v277(v15, v163)) == 0))
    {
      unint64_t v189 = 14377;
      goto LABEL_56;
    }
    uint64_t v87 = v165;
    uint64_t v66 = (uint64_t)v257;
    uint64_t v86 = v274;
    uint64_t v16 = v246;
    unint64_t v25 = v252;
    if (BYTE4(v269) / v169 >= 32 / v170) {
      goto LABEL_51;
    }
  }
  (*(void (**)(unsigned char *, Class *))(v238 + 8))(v25, v239);
  if ((v256(v87, v268) & 0xFF00000000) == 0) {
    goto LABEL_4;
  }
LABEL_51:
  uint64_t v171 = v233;
  uint64_t v172 = *(void (**)(unsigned char *, uint64_t, uint64_t))(v233 + 16);
  uint64_t v173 = v232;
  v172(v232, v86, v87);
  uint64_t v174 = v268;
  LODWORD(v283) = (*(uint64_t (**)(uint64_t, uint64_t))(v268 + 24))(v87, v268);
  uint64_t v282 = v283 >> 8;
  uint64_t v175 = BYTE1(v283);
  v176 = *(void (**)(unsigned char *, uint64_t))(v171 + 8);
  v176(v173, v87);
  v172(v173, v86, v87);
  v177 = *(void (**)(uint64_t, uint64_t, uint64_t))(v174 + 32);
  LODWORD(v280) = v175;
  v177(v175, v87, v174);
  v176(v173, v87);
  v178 = v256;
  unsigned int v179 = v256(v87, v174);
  LOBYTE(v172) = v282;
  unint64_t v281 = (unint64_t)v179 >> v282;
  v180 = *(uint64_t (**)(int *, uint64_t, uint64_t))(v174 + 56);
  v181 = (void (*)(int *, void))v180(&v286, v87, v174);
  _DWORD *v182 = v281;
  v181(&v286, 0);
  LOBYTE(v178) = ((unint64_t)v178(v87, v174) >> 32) - (_BYTE)v172;
  v183 = (void (*)(int *, void))v180(&v286, v87, v174);
  *(unsigned char *)(v184 + 4) = (_BYTE)v178;
  v183(&v286, 0);
  if (v283)
  {
    uint64_t v185 = v241;
    v186 = v240;
    (*(void (**)(void *, unsigned char *, const char *))(v234 + 32))(v241, v235, v240);
    char v61 = type metadata accessor for Unicode.ParseResult(0, (uint64_t)v186, v187, v188);
    char v62 = v185;
    goto LABEL_53;
  }
  unsigned int v221 = v280;
  unint64_t v222 = (*(uint64_t (**)(const char *))(v272 + 56))(v15);
  unsigned __int8 v223 = specialized numericCast<A, B>(_:)(v222);
  if (!v223)
  {
    unint64_t v189 = 480;
LABEL_56:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, v189, 0);
  }
  unsigned __int8 v224 = v223;
  v225 = v240;
  (*(void (**)(unsigned char *, const char *))(v234 + 8))(v235, v240);
  uint64_t v226 = v221 / v224;
  v227 = v241;
  void *v241 = v226;
  char v61 = type metadata accessor for Unicode.ParseResult(0, (uint64_t)v225, v228, v229);
  char v62 = v227;
  unsigned int v63 = 1;
LABEL_54:
  swift_storeEnumTagMultiPayload(v62, (uint64_t)v61, v63);
}

uint64_t static UInt8.% infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  }
  return a1 % a2;
}

uint64_t static UInt8./ infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  }
  return a1 / a2;
}

uint64_t static Unicode.UTF8.encodedReplacementCharacter.getter()
{
  return 12501232;
}

uint64_t static _ValidUTF8Buffer.encodedReplacementCharacter.getter()
{
  return 12501232;
}

BOOL static Unicode.UTF8._isScalar(_:)(char a1)
{
  return (a1 & 0x80) == 0;
}

uint64_t static Unicode.UTF8.decode(_:)(unsigned int a1)
{
  uint64_t v1 = 4 - (__clz(a1) >> 3);
  unsigned int v2 = a1 - 1;
  if (v1 != 1) {
    unsigned int v2 = ((a1 - 16843009) >> 10) & 0xFC0 | ((a1 - 16843009) >> 24) & 0x3F | ((((a1 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((a1 - 16843009) & 7) << 18);
  }
  if (v1 == 2) {
    unsigned int v2 = (((a1 - 257) & 0x1F) << 6) | ((a1 - 257) >> 8) & 0x3F;
  }
  if (v1 == 3) {
    return ((a1 - 65793) >> 2) & 0xFC0 | ((a1 - 65793) >> 16) & 0x3F | (((a1 - 65793) & 0xF) << 12);
  }
  else {
    return v2;
  }
}

uint64_t static UInt32.&>> infix(_:_:)(unsigned int a1, char a2)
{
  return a1 >> a2;
}

Swift::_ValidUTF8Buffer __swiftcall _ValidUTF8Buffer.init(_containing:)(Swift::UInt8 _containing)
{
  return (Swift::_ValidUTF8Buffer)(_containing + 1);
}

_DWORD *static UInt32.&>>= infix(_:_:)(_DWORD *result, char a2)
{
  *result >>= a2;
  return result;
}

uint64_t static Unicode.UTF8.transcode<A>(_:from:)(unsigned int *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  if (a3 != &type metadata for Unicode.UTF16)
  {
    if (a3 != &type metadata for Unicode.UTF8) {
      goto LABEL_15;
    }
    if (swift_getAssociatedTypeWitness(0, (int **)a4, (uint64_t)&type metadata for Unicode.UTF8, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar) == (const char *)&type metadata for _ValidUTF8Buffer)return *a1; {
LABEL_9:
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
  }
  uint64_t v7 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
  if (swift_getAssociatedTypeWitness(0, (int **)a4, (uint64_t)&type metadata for Unicode.UTF16, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar) != v7)goto LABEL_9; {
  unsigned int v8 = *a1;
  }
  unsigned int v9 = (unsigned __int16)*a1;
  if (v9 <= 0x7F) {
    return (v8 + 1);
  }
  int v12 = (*a1 & 0x3F) << 8;
  if (v9 <= 0x7FF)
  {
    int v13 = v12 | (v9 >> 6);
    return (v13 + 33217);
  }
  if ((*a1 & 0xF800) != 0xD800) {
    return (((v12 | (v9 >> 6) & 0x3F) << 8) | ((unsigned __int16)v8 >> 12)) + 8487393;
  }
LABEL_15:
  unsigned int v14 = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
  if (v14 <= 0x7F) {
    return v14 + 1;
  }
  int v15 = (v14 & 0x3F) << 8;
  if (v14 <= 0x7FF)
  {
    int v13 = v15 | (v14 >> 6);
    return (v13 + 33217);
  }
  int v16 = (v15 | (v14 >> 6) & 0x3F) << 8;
  unsigned int v17 = (((v16 | (v14 >> 12) & 0x3F) << 8) | (v14 >> 18)) - 2122219023;
  unsigned int v10 = (v16 | (v14 >> 12)) + 8487393;
  if (HIWORD(v14)) {
    return v17;
  }
  return v10;
}

BOOL static UInt16.< infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 < a2;
}

_WORD *static UInt16.&>>= infix(_:_:)(_WORD *result, char a2)
{
  *__n128 result = (unsigned __int16)*result >> (a2 & 0xF);
  return result;
}

uint64_t static UInt16.&>> infix(_:_:)(unsigned __int16 a1, char a2)
{
  return a1 >> (a2 & 0xF);
}

uint64_t Unicode.UTF8.ForwardParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t Unicode.UTF8.ForwardParser._buffer.setter(uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(unsigned char *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t (*Unicode.UTF8.ForwardParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.UTF8.ForwardParser.init()()
{
  return 0;
}

uint64_t Unicode.UTF8.ReverseParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF8.ReverseParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF8(_DWORD *a1@<X8>)
{
  *a1 = 12501232;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF8(unsigned int *a1)
{
  uint64_t v1 = 4 - (__clz(*a1) >> 3);
  unsigned int v2 = *a1 - 1;
  if (v1 != 1) {
    unsigned int v2 = ((*a1 - 16843009) >> 10) & 0xFC0 | ((*a1 - 16843009) >> 24) & 0x3F | ((((*a1 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((*a1 - 16843009) & 7) << 18);
  }
  if (v1 == 2) {
    unsigned int v2 = (((*a1 - 257) & 0x1F) << 6) | ((*a1 - 257) >> 8) & 0x3F;
  }
  if (v1 == 3) {
    return ((*a1 - 65793) >> 2) & 0xFC0 | ((*a1 - 65793) >> 16) & 0x3F | (((*a1 - 65793) & 0xF) << 12);
  }
  else {
    return v2;
  }
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF8@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  if (result > 0x7F)
  {
    int v3 = (result & 0x3F) << 8;
    if (result >= 0x800)
    {
      unsigned int v4 = (v3 | (result >> 6) & 0x3F) << 8;
      unsigned int v5 = (((v4 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
      unsigned int v2 = (v4 | (result >> 12)) + 8487393;
      if (WORD1(result)) {
        unsigned int v2 = v5;
      }
    }
    else
    {
      unsigned int v2 = (v3 | (result >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v2 = result + 1;
  }
  *(_DWORD *)a2 = v2;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

ValueMetadata *protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF8@<X0>(int *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if (a2 != &type metadata for Unicode.UTF16)
  {
    if (a2 != v4) {
      goto LABEL_15;
    }
    __n128 result = (ValueMetadata *)swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if (result == &type metadata for _ValidUTF8Buffer)
    {
      int v13 = *a1;
      goto LABEL_5;
    }
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
  }
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
  __n128 result = (ValueMetadata *)swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)&type metadata for Unicode.UTF16, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  if (result != (ValueMetadata *)v9) {
    goto LABEL_9;
  }
  int v11 = *a1;
  unsigned int v12 = (unsigned __int16)*a1;
  if (v12 <= 0x7F)
  {
    int v13 = (v11 + 1);
    goto LABEL_5;
  }
  int v14 = (*a1 & 0x3F) << 8;
  if (v12 < 0x800)
  {
    unsigned int v15 = v14 | (v12 >> 6);
LABEL_12:
    int v13 = v15 + 33217;
    goto LABEL_5;
  }
  if ((*a1 & 0xF800) != 0xD800)
  {
    int v13 = (((v14 | (v12 >> 6) & 0x3F) << 8) | ((unsigned __int16)v11 >> 12)) + 8487393;
    goto LABEL_5;
  }
LABEL_15:
  __n128 result = (ValueMetadata *)(*(uint64_t (**)(int *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
  if (result <= 0x7F)
  {
    int v13 = result + 1;
    goto LABEL_5;
  }
  int v16 = (result & 0x3F) << 8;
  if (result <= 0x7FF)
  {
    unsigned int v15 = v16 | (result >> 6);
    goto LABEL_12;
  }
  unsigned int v17 = (v16 | (result >> 6) & 0x3F) << 8;
  unsigned int v18 = (((v17 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
  int v13 = (v17 | (result >> 12)) + 8487393;
  if (result >> 16) {
    int v13 = v18;
  }
LABEL_5:
  *(_DWORD *)a4 = v13;
  *(unsigned char *)(a4 + 4) = 0;
  return result;
}

uint64_t protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.UTF8(unsigned __int8 *a1)
{
  return (*a1 >> 7) ^ 1u;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF8.ReverseParser._parseMultipleCodeUnits()()
{
  if ((v0 & 0xE0C0) == 0xC080)
  {
    if ((v0 & 0x1E00) != 0)
    {
LABEL_11:
      Swift::Bool v2 = 1;
      goto LABEL_12;
    }
  }
  else if ((v0 & 0xF0C0C0) == 0xE08080)
  {
    if ((v0 & 0xF2000) != 0 && (v0 & 0xF2000) != 0xD2000) {
      goto LABEL_11;
    }
  }
  else if ((v0 & 0xF8C0C0C0) == 0xF0808080 && ((v0 & 0x7300000u) - 67108865) >> 26 == 63)
  {
    goto LABEL_11;
  }
  Unicode.UTF8.ReverseParser._invalidLength()();
  Swift::Bool v2 = 0;
LABEL_12:
  result.bitCount = v1;
  result.isValid = v2;
  return result;
}

uint64_t static UInt8.* infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result = a1 * a2;
  if ((result & 0xFF00) != 0) {
    __break(1u);
  }
  return result;
}

Swift::UInt8 __swiftcall Unicode.UTF8.ReverseParser._invalidLength()()
{
  if ((v0 & 0xF0C0) != 0xE080)
  {
    if ((v0 & 0xF8C0) == 0xF080)
    {
      if ((v0 & 0x730u) - 1025 >= 0xFFFFFC00) {
        return 2;
      }
    }
    else if ((v0 & 0xF8C0C0) == 0xF08080 && (v0 & 0x73000u) - 262145 > 0xFFFBFFFF)
    {
      return 3;
    }
    return 1;
  }
  if ((v0 & 0xF20) == 0xD20 || (v0 & 0xF20) == 0) {
    return 1;
  }
  else {
    return 2;
  }
}

Swift::_ValidUTF8Buffer __swiftcall Unicode.UTF8.ReverseParser._bufferedScalar(bitCount:)(Swift::UInt8 bitCount)
{
  return (Swift::_ValidUTF8Buffer)((bswap32(v1) + 16843009) >> -bitCount);
}

uint64_t UInt32.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1);
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF8.ReverseParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v9)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  char v17;
  Swift::UInt8 v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t (*v21)();
  void v22[4];

  uint64_t v5 = v4;
  if (*(unsigned char *)(v4 + 4))
  {
    uint64_t v20 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0x80) != 0)
    {
      uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      uint64_t result = v9(v22, a2, a3);
      goto LABEL_9;
    }
    lazy protocol witness table accessor for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser(a1, a2, a3);
    uint64_t v21 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    uint64_t result = (void *)((uint64_t (*)(void *, void))v21)(v22, 0);
    unsigned int v12 = 0;
    int v11 = (v20 + 1);
  }
  else
  {
    uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    uint64_t result = v9(v22, a2, a3);
    if ((v22[0] & 0x100) != 0)
    {
LABEL_3:
      int v11 = 0;
      unsigned int v12 = 2;
      goto LABEL_27;
    }
    if ((v22[0] & 0x80) == 0)
    {
      unsigned int v12 = 0;
      int v11 = LOBYTE(v22[0]) + 1;
      goto LABEL_27;
    }
    int v13 = *(unsigned __int8 *)(v4 + 4);
    if (v13 >= 0x20) {
LABEL_29:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-255 << v13) - 1) | (LOBYTE(v22[0]) << v13);
    *(unsigned char *)(v4 + 4) = v13 + 8;
    while (1)
    {
      uint64_t result = v9(v22, a2, a3);
LABEL_9:
      if ((v22[0] & 0x100) != 0) {
        break;
      }
      int v14 = *(unsigned __int8 *)(v4 + 4);
      if (v14 > 0x1F) {
        goto LABEL_29;
      }
      unsigned int v15 = *(_DWORD *)v4 & ((-255 << v14) - 1) | (LOBYTE(v22[0]) << v14);
      *(_DWORD *)uint64_t v4 = v15;
      int v16 = v14 + 8;
      *(unsigned char *)(v4 + 4) = v14 + 8;
      if (v14 >= 0x18) {
        goto LABEL_15;
      }
    }
    int v16 = *(unsigned char *)(v4 + 4);
    if (!v16) {
      goto LABEL_3;
    }
    unsigned int v15 = *(_DWORD *)v4;
LABEL_15:
    if ((v15 & 0xE0C0) == 0xC080)
    {
      if ((v15 & 0x1E00) != 0)
      {
        unsigned int v17 = 16;
LABEL_18:
        unsigned int v12 = 0;
        *(_DWORD *)uint64_t v4 = (unint64_t)v15 >> v17;
        *(unsigned char *)(v4 + 4) = v16 - v17;
        int v11 = (bswap32(v15) + 16843009) >> (-v17 & 0x18);
        goto LABEL_27;
      }
    }
    else if ((v15 & 0xF0C0C0) == 0xE08080)
    {
      if ((v15 & 0xF2000) != 0 && (v15 & 0xF2000) != 0xD2000)
      {
        unsigned int v17 = 24;
        goto LABEL_18;
      }
    }
    else if ((v15 & 0xF8C0C0C0) == 0xF0808080 && ((v15 & 0x7300000) - 67108865) >> 26 == 63)
    {
      unsigned int v17 = 32;
      goto LABEL_18;
    }
    unsigned int v18 = Unicode.UTF8.ReverseParser._invalidLength()();
    uint64_t v19 = 8 * v18;
    *(_DWORD *)uint64_t v5 = v15 >> (8 * (v18 & 0x1F));
    *(unsigned char *)(v5 + 4) = v16 - 8 * v18;
    uint64_t result = (void *)specialized numericCast<A, B>(_:)(8uLL);
    if (!(_BYTE)result) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
    }
    unsigned int v12 = 1;
    int v11 = v19 / result;
  }
LABEL_27:
  *(void *)a4 = v11;
  *(unsigned char *)(a4 + 8) = v12;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF8.ReverseParser()
{
  int v1 = *v0;
  if ((*v0 & 0xE0C0) != 0xC080)
  {
    if ((v1 & 0xF0C0C0) == 0xE08080)
    {
      if ((v1 & 0xF2000) != 0 && (v1 & 0xF2000) != 0xD2000)
      {
        int v2 = 24;
        int v3 = 1;
        return v3 | (v2 << 8);
      }
    }
    else if ((v1 & 0xF8C0C0C0) == 0xF0808080 && ((v1 & 0x7300000u) - 67108865) >> 26 == 63)
    {
      int v2 = 32;
      int v3 = 1;
      return v3 | (v2 << 8);
    }
LABEL_10:
    int v4 = Unicode.UTF8.ReverseParser._invalidLength()();
    int v3 = 0;
    int v2 = 8 * v4;
    return v3 | (v2 << 8);
  }
  if ((v1 & 0x1E00) == 0) {
    goto LABEL_10;
  }
  int v2 = 16;
  int v3 = 1;
  return v3 | (v2 << 8);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF8.ReverseParser@<X0>(uint64_t result@<X0>, unsigned int *a2@<X8>)
{
  *a2 = (bswap32(*v2) + 16843009) >> -(char)result;
  return result;
}

uint64_t (*protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser())()
{
  return EnumeratedSequence._base.modify;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF8.ForwardParser._parseMultipleCodeUnits()()
{
  if ((v0 & 0xC0E0) != 0x80C0)
  {
    if ((v0 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v0 & 0x200F) != 0 && (v0 & 0x200F) != 0x200D) {
        goto LABEL_3;
      }
    }
    else if ((v0 & 0xC0C0C0F8) == 0x808080F0 && (v0 & 0x3007) != 0 && __rev16(v0 & 0x3007) < 0x401)
    {
      goto LABEL_3;
    }
LABEL_11:
    Unicode.UTF8.ForwardParser._invalidLength()();
    Swift::Bool v1 = 0;
    goto LABEL_12;
  }
  if ((v0 & 0x1E) == 0) {
    goto LABEL_11;
  }
LABEL_3:
  Swift::Bool v1 = 1;
LABEL_12:
  result.bitCount = v2;
  result.isValid = v1;
  return result;
}

Swift::UInt8 __swiftcall Unicode.UTF8.ForwardParser._invalidLength()()
{
  int v1 = v0;
  if ((v0 & 0xC0F0) == 0x80E0)
  {
    if ((v0 & 0x200F) == 0x200D || (v0 & 0x200F) == 0) {
      return 1;
    }
    else {
      return 2;
    }
  }
  else if ((v0 & 0xC0F8) == 0x80F0)
  {
    Swift::UInt8 result = 1;
    if ((v1 & 0x3007) != 0)
    {
      unsigned int v4 = __rev16(v1 & 0x3007);
      if ((v1 & 0xC00000) == 0x800000) {
        Swift::UInt8 v5 = 3;
      }
      else {
        Swift::UInt8 v5 = 2;
      }
      if (v4 <= 0x400) {
        return v5;
      }
      else {
        return 1;
      }
    }
  }
  else
  {
    return 1;
  }
  return result;
}

Swift::_ValidUTF8Buffer __swiftcall Unicode.UTF8.ForwardParser._bufferedScalar(bitCount:)(Swift::UInt8 bitCount)
{
  return (Swift::_ValidUTF8Buffer)(((1 << ((bitCount + 1) >> 1) << (bitCount >> 1)) - 1) & (v1 + 16843009));
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF8.ForwardParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v9)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  unsigned int v17;
  Swift::UInt8 v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t (*v21)();
  void v22[4];

  uint64_t v5 = v4;
  if (*(unsigned char *)(v4 + 4))
  {
    uint64_t v20 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0x80) != 0)
    {
      uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      Swift::UInt8 result = v9(v22, a2, a3);
      goto LABEL_9;
    }
    lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(a1, a2, a3);
    uint64_t v21 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    Swift::UInt8 result = (void *)((uint64_t (*)(void *, void))v21)(v22, 0);
    unsigned int v12 = 0;
    int v11 = (v20 + 1);
  }
  else
  {
    uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    Swift::UInt8 result = v9(v22, a2, a3);
    if ((v22[0] & 0x100) != 0)
    {
LABEL_3:
      int v11 = 0;
      unsigned int v12 = 2;
      goto LABEL_29;
    }
    if ((v22[0] & 0x80) == 0)
    {
      unsigned int v12 = 0;
      int v11 = LOBYTE(v22[0]) + 1;
      goto LABEL_29;
    }
    int v13 = *(unsigned __int8 *)(v4 + 4);
    if (v13 >= 0x20) {
LABEL_30:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-255 << v13) - 1) | (LOBYTE(v22[0]) << v13);
    *(unsigned char *)(v4 + 4) = v13 + 8;
    while (1)
    {
      Swift::UInt8 result = v9(v22, a2, a3);
LABEL_9:
      if ((v22[0] & 0x100) != 0) {
        break;
      }
      int v14 = *(unsigned __int8 *)(v4 + 4);
      if (v14 > 0x1F) {
        goto LABEL_30;
      }
      unsigned int v15 = *(_DWORD *)v4 & ((-255 << v14) - 1) | (LOBYTE(v22[0]) << v14);
      *(_DWORD *)uint64_t v4 = v15;
      int v16 = v14 + 8;
      *(unsigned char *)(v4 + 4) = v14 + 8;
      if (v14 >= 0x18) {
        goto LABEL_15;
      }
    }
    int v16 = *(unsigned char *)(v4 + 4);
    if (!v16) {
      goto LABEL_3;
    }
    unsigned int v15 = *(_DWORD *)v4;
LABEL_15:
    if ((v15 & 0xC0E0) == 0x80C0)
    {
      if ((v15 & 0x1E) != 0)
      {
        unsigned int v17 = 16;
LABEL_18:
        unsigned int v12 = 0;
        *(_DWORD *)uint64_t v4 = (unint64_t)v15 >> v17;
        *(unsigned char *)(v4 + 4) = v16 - v17;
        int v11 = ((1 << (v17 >> 1) << (v17 >> 1)) - 1) & (v15 + 16843009);
        goto LABEL_29;
      }
    }
    else if ((v15 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v15 & 0x200F) != 0 && (v15 & 0x200F) != 0x200D)
      {
        unsigned int v17 = 24;
        goto LABEL_18;
      }
    }
    else if ((v15 & 0xC0C0C0F8) == 0x808080F0 && (v15 & 0x3007) != 0 && __rev16(v15 & 0x3007) <= 0x400)
    {
      unsigned int v17 = 32;
      goto LABEL_18;
    }
    unsigned int v18 = Unicode.UTF8.ForwardParser._invalidLength()();
    uint64_t v19 = 8 * v18;
    *(_DWORD *)uint64_t v5 = v15 >> (8 * (v18 & 0x1F));
    *(unsigned char *)(v5 + 4) = v16 - 8 * v18;
    Swift::UInt8 result = (void *)specialized numericCast<A, B>(_:)(8uLL);
    if (!(_BYTE)result) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
    }
    unsigned int v12 = 1;
    int v11 = v19 / result;
  }
LABEL_29:
  *(void *)a4 = v11;
  *(unsigned char *)(a4 + 8) = v12;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF8.ForwardParser()
{
  int v1 = *v0;
  if ((*v0 & 0xC0E0) != 0x80C0)
  {
    if ((v1 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v1 & 0x200F) != 0 && (*v0 & 0x200F) != 0x200D)
      {
        int v2 = 24;
        int v3 = 1;
        return v3 | (v2 << 8);
      }
    }
    else if ((v1 & 0xC0C0C0F8) == 0x808080F0 && (v1 & 0x3007) != 0 && __rev16(*v0 & 0x3007) <= 0x400)
    {
      int v2 = 32;
      int v3 = 1;
      return v3 | (v2 << 8);
    }
LABEL_12:
    int v4 = Unicode.UTF8.ForwardParser._invalidLength()();
    int v3 = 0;
    int v2 = 8 * v4;
    return v3 | (v2 << 8);
  }
  if ((v1 & 0x1E) == 0) {
    goto LABEL_12;
  }
  int v2 = 16;
  int v3 = 1;
  return v3 | (v2 << 8);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF8.ForwardParser@<X0>(uint64_t result@<X0>, int *a2@<X8>)
{
  *a2 = (*v2 + 16843009) & ((1 << ((result + 1) >> 1) << (result >> 1)) - 1);
  return result;
}

unint64_t protocol witness for _UTFParser._buffer.getter in conformance Unicode.UTF8.ForwardParser()
{
  return *v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32);
}

uint64_t protocol witness for _UTFParser._buffer.setter in conformance Unicode.UTF8.ForwardParser(uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(unsigned char *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t static UInt16.+ infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result = a1 + a2;
  if ((result & 0x10000) != 0) {
    __break(1u);
  }
  return result;
}

void *static Unicode.UTF16._copy<A, B>(source:destination:count:)(char *a1, char *a2, unint64_t a3)
{
  uint64_t v5 = a1;
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t result = (void *)MEMORY[0x1F4188790](v8 - 8);
  unsigned int v17 = (char *)v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v19 = *(void *)(v18 + 72);
  uint64_t v21 = *(void *)(v20 + 72);
  if (v19 == v21)
  {
    if ((a3 & 0x8000000000000000) != 0 || (v19 & 0x8000000000000000) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    if (is_mul_ok(a3, v19))
    {
      return memcpy(a2, v5, a3 * v19);
    }
    __break(1u);
LABEL_15:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((a3 & 0x8000000000000000) != 0) {
    goto LABEL_15;
  }
  uint64_t v31 = v13;
  uint64_t v32 = v14;
  if (a3)
  {
    uint64_t v22 = v11;
    uint64_t v23 = v12;
    uint64_t v24 = *(void (**)(char *, char *, uint64_t))(v9 + 16);
    uint64_t v28 = v31 + 8;
    uint64_t v29 = v24;
    v26[1] = v32 + 16;
    uint64_t v27 = (void (**)(char *, uint64_t))(v9 + 8);
    v26[0] = v15 + 40;
    unint64_t v30 = v19;
    do
    {
      v29(v17, v5, v22);
      uint64_t v25 = (*(uint64_t (**)(char *, uint64_t))(v31 + 8))(v17, v22);
      (*v27)(v17, v22);
      (*(void (**)(uint64_t, uint64_t))(v32 + 16))(v25, v23);
      uint64_t result = (void *)(*(uint64_t (**)(char *, char *, uint64_t))v26[0])(a2, v7, v23);
      a2 += v21;
      v5 += v30;
      --a3;
    }
    while (a3);
  }
  return result;
}

unint64_t static UInt.* infix(_:_:)(unint64_t result, unint64_t a2)
{
  if (is_mul_ok(result, a2)) {
    result *= a2;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Unicode.UTF16.transcodedLength<A, B>(of:decodedAs:repairingIllFormedSequences:)(ValueMetadata *a1, ValueMetadata *a2, int a3, uint64_t a4, uint64_t a5, ValueMetadata *a6, int **a7)
{
  uint64_t v7 = a7;
  uint64_t v219 = a4;
  int v204 = a3;
  v216 = a1;
  v217 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a7, a5, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v181 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v187 = (char *)&v164 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v166 = v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v191 = (char *)&v164 - v14;
  v210 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v15, v16);
  uint64_t v180 = (uint64_t)*(v210 - 1);
  MEMORY[0x1F4188790](v210);
  v209 = (char *)&v164 - v17;
  uint64_t v212 = (ValueMetadata *)AssociatedTypeWitness;
  unint64_t v196 = type metadata accessor for Unicode.ParseResult(0, (uint64_t)AssociatedTypeWitness, v18, v19);
  uint64_t v179 = (uint64_t)*(v196 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v196);
  uint64_t v194 = (unsigned __int8 *)&v164 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v193 = (unsigned __int8 *)&v164 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v195 = (unsigned __int8 *)&v164 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v214 = (char *)&v164 - v26;
  uint64_t v27 = swift_getAssociatedTypeWitness(255, (int **)a6, a4, (uint64_t)&protocol requirements base descriptor for IteratorProtocol, associated type descriptor for IteratorProtocol.Element);
  uint64_t v169 = type metadata accessor for Optional(0, (uint64_t)v27, v28, v29);
  uint64_t v168 = (uint64_t)*(v169 - 1);
  MEMORY[0x1F4188790](v169);
  v206 = (void (**)(char *, uint64_t, uint64_t, ValueMetadata *))((char *)&v164 - v30);
  uint64_t v31 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v7, a5, (uint64_t)v27, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)+ 8);
  v186 = *(int ***)(*(void *)(v31 + 24) + 16);
  uint64_t v185 = swift_getAssociatedTypeWitness(0, v186, (uint64_t)v27, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v32 = MEMORY[0x1F4188790](v185);
  uint64_t v184 = (char *)&v164 - v33;
  uint64_t v205 = (void (**)(char *, Class *))*((void *)v27 - 1);
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v167 = (char *)&v164 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v170 = (char *)&v164 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v182 = (char *)&v164 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  uint64_t v42 = (char *)&v164 - v41;
  uint64_t v43 = MEMORY[0x1F4188790](v40);
  uint64_t v45 = (void (**)(unsigned __int8 *, uint64_t))((char *)&v164 - v44);
  MEMORY[0x1F4188790](v43);
  uint64_t v207 = (void (*)(char *, uint64_t, ValueMetadata *, ValueMetadata *, uint64_t))((char *)&v164 - v46);
  uint64_t v47 = swift_getAssociatedTypeWitness(0, v7, a5, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v178 = *((void *)v47 - 1);
  uint64_t v48 = MEMORY[0x1F4188790](v47);
  uint64_t v50 = (char *)&v164 - v49;
  MEMORY[0x1F4188790](v48);
  uint64_t v177 = v52;
  uint64_t v53 = *(void (**)(void))(v52 + 16);
  v218 = (char *)&v164 - ((v51 + 15) & 0xFFFFFFFFFFFFFFF0);
  v53();
  uint64_t v188 = (ValueMetadata *)a5;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, a5, (uint64_t)v47, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  uint64_t v55 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 24);
  uint64_t v215 = v50;
  v216 = (ValueMetadata *)v47;
  v55(v47, AssociatedConformanceWitness);
  uint64_t v56 = v179;
  uint64_t v57 = v180;
  uint64_t v58 = v181;
  uint64_t v59 = 0;
  uint64_t v60 = v217;
  v217 = a6;
  uint64_t v165 = v7;
  uint64_t v211 = AssociatedConformanceWitness;
  if (v60 != &type metadata for Unicode.UTF8)
  {
LABEL_2:
    int v61 = 0;
    uint64_t v207 = *(void (**)(char *, uint64_t, ValueMetadata *, ValueMetadata *, uint64_t))(AssociatedConformanceWitness
                                                                                             + 32);
    v208 = (void (**)(uint64_t, char *, const char *))(AssociatedConformanceWitness + 32);
    char v62 = (void (**)(unsigned __int8 *, char *, uint64_t))(v56 + 16);
    v213 = (void (**)(unsigned __int8 *, uint64_t))(v56 + 8);
    uint64_t v205 = (void (**)(char *, Class *))(v57 + 8);
    v206 = (void (**)(char *, uint64_t, uint64_t, ValueMetadata *))(v58 + 56);
    uint64_t v203 = (void (**)(char *, unsigned __int8 *, ValueMetadata *))(v58 + 32);
    unsigned int v63 = (void (**)(unsigned __int8 *, char *, uint64_t))(v56 + 32);
    Kind = (void (*)(uint64_t, ValueMetadata *))(v7 + 11);
    uint64_t v201 = (void (**)(void))(v58 + 8);
    uint64_t v64 = (uint64_t)v196;
    uint64_t v65 = v194;
    uint64_t v66 = v195;
    int v67 = v214;
    v202 = (void (**)(unsigned __int8 *, char *, uint64_t))(v56 + 32);
    v207(v218, v219, v217, v216, v211);
    while (1)
    {
      char v68 = *v62;
      (*v62)(v66, v67, v64);
      if (swift_getEnumCaseMultiPayload(v66, v64))
      {
        uint64_t v69 = *v213;
        (*v213)(v66, v64);
        int v70 = v209;
        (*v206)(v209, 1, 1, v212);
        (*v205)(v70, v210);
      }
      else
      {
        uint64_t v71 = *v203;
        uint64_t v72 = v209;
        unint64_t v73 = v212;
        (*v203)(v209, v66, v212);
        (*v206)(v72, 0, 1, v73);
        uint64_t v74 = v72;
        uint64_t v64 = (uint64_t)v196;
        (*v205)(v74, v210);
        unint64_t v75 = v193;
        v68(v193, v67, v64);
        if (!swift_getEnumCaseMultiPayload(v75, v64))
        {
          uint64_t v77 = v187;
          v71(v187, v75, v73);
          (*v213)((unsigned __int8 *)v67, v64);
          v71(v191, (unsigned __int8 *)v77, v73);
          if (v188 == &type metadata for Unicode.UTF8)
          {
            uint64_t v66 = v195;
            if (v73 != &type metadata for _ValidUTF8Buffer) {
              goto LABEL_85;
            }
            unsigned int v78 = *(_DWORD *)v191;
            (*v201)();
            unsigned int v79 = __clz(v78) >> 3;
            if (v79 == 3)
            {
              unsigned int v80 = (v78 - 1) & 0x7F;
              unsigned int v81 = 16;
              goto LABEL_17;
            }
            unsigned int v84 = v78 - 16843009;
            int v85 = (v84 << 6) | (v84 >> 8) & 0x3F;
            uint64_t v65 = v194;
            unsigned int v63 = v202;
            if (v79 == 2)
            {
              unsigned int v80 = (v84 << 6) & 0x7FF | (v84 >> 8) & 0x3F;
              unsigned int v81 = 16;
              goto LABEL_19;
            }
            int v87 = HIWORD(v84) & 0x3F | (v85 << 6);
            if (v79 == 1)
            {
              unsigned int v80 = ((v78 - 16843009) >> 16) & 0x3F | (unsigned __int16)((_WORD)v85 << 6);
              goto LABEL_34;
            }
            unsigned int v80 = (v87 << 6) & 0x1FFFC0 | HIBYTE(v84) & 0x3F;
            if (v80 < 0x10000)
            {
LABEL_34:
              unsigned int v81 = 16;
            }
            else
            {
              unsigned int v80 = (((v87 << 6) & 0x3C0 | HIBYTE(v84) & 0x3F) << 16) | (((v87 << 6) + 983040) >> 10) & 0x3FF | 0xDC00D800;
              unsigned int v81 = 32;
            }
            uint64_t v64 = (uint64_t)v196;
            uint64_t v65 = v194;
            uint64_t v66 = v195;
          }
          else
          {
            uint64_t v66 = v195;
            if (v188 == &type metadata for Unicode.UTF16)
            {
              uint64_t v65 = v194;
              unsigned int v63 = v202;
              if (v166 != 5) {
                goto LABEL_87;
              }
              unsigned int v80 = *(_DWORD *)v191;
              unsigned int v81 = v191[4];
              (*v201)();
              goto LABEL_19;
            }
            uint64_t v86 = v191;
            unsigned int v80 = ((uint64_t (*)(char *))v165[11])(v191);
            ((void (*)(char *, ValueMetadata *))*v201)(v86, v212);
            if (v80 < 0x10000)
            {
              unsigned int v81 = 16;
            }
            else
            {
              unsigned int v80 = ((v80 + 983040) >> 10) & 0x3FF | ((v80 & 0x3FF) << 16) | 0xDC00D800;
              unsigned int v81 = 32;
            }
LABEL_17:
            uint64_t v65 = v194;
          }
          unsigned int v63 = v202;
LABEL_19:
          uint64_t v82 = v81 >> 4;
          BOOL v76 = __OFADD__(v59, v82);
          v59 += v82;
          if (v76)
          {
            __break(1u);
LABEL_87:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
          }
          if (v81)
          {
            do
            {
              int v83 = (unsigned __int16)v80;
              v80 >>= 16;
              v81 -= 16;
              v61 |= v83;
            }
            while ((_BYTE)v81);
            int v67 = v214;
          }
          else
          {
            int v67 = v214;
          }
          goto LABEL_4;
        }
        uint64_t v69 = *v213;
        (*v213)(v75, v64);
        uint64_t v65 = v194;
        uint64_t v66 = v195;
        unsigned int v63 = v202;
      }
      int v67 = v214;
      (*v63)(v65, v214, v64);
      if (swift_getEnumCaseMultiPayload(v65, v64) != 1)
      {
        v69(v65, v64);
        (*(void (**)(char *, ValueMetadata *))(v178 + 8))(v215, v216);
        (*(void (**)(char *, uint64_t))(v177 + 8))(v218, v219);
        return v59;
      }
      if ((v204 & 1) == 0)
      {
        (*(void (**)(char *, ValueMetadata *))(v178 + 8))(v215, v216);
        (*(void (**)(char *, uint64_t))(v177 + 8))(v218, v219);
        return 0;
      }
      BOOL v76 = __OFADD__(v59++, 1);
      if (v76)
      {
        __break(1u);
LABEL_84:
        __break(1u);
LABEL_85:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
      }
      v61 |= 0xFFFDu;
LABEL_4:
      v207(v218, v219, v217, v216, v211);
    }
  }
  v213 = v45;
  uint64_t v192 = v42;
  uint64_t v88 = v186;
  uint64_t v89 = v185;
  uint64_t v90 = swift_getAssociatedConformanceWitness((uint64_t)v186, (uint64_t)v27, (uint64_t)v185, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v91 = *(void (**)(uint64_t *, uint64_t))(v90 + 8);
  uint64_t v92 = v184;
  uint64_t v176 = v90;
  uint64_t v175 = v90 + 8;
  uint64_t v174 = v91;
  ((void (*)(uint64_t *, uint64_t, const char *))v91)(&qword_18162B0B8, 256, v89);
  uint64_t v93 = v88[3];
  uint64_t v94 = (uint64_t)v207;
  uint64_t v173 = v88 + 3;
  uint64_t v172 = v93;
  ((void (*)(char *, const char *, int **))v93)(v92, v27, v88);
  uint64_t v59 = 0;
  Kind = (void (*)(uint64_t, ValueMetadata *))a6[1].Kind;
  uint64_t v201 = (void (**)(void))&a6[1];
  char v199 = (unsigned int (**)(char *, uint64_t, const char *))(v205 + 6);
  uint64_t v95 = (void (**)(uint64_t, const char *))(v205 + 1);
  uint64_t v164 = v95;
  v208 = (void (**)(uint64_t, char *, const char *))(v205 + 4);
  v202 = (void (**)(unsigned __int8 *, char *, uint64_t))(v205 + 2);
  uint64_t v203 = (void (**)(char *, unsigned __int8 *, ValueMetadata *))(v31 + 64);
  uint64_t v205 = (void (**)(char *, Class *))(v31 + 128);
  uint64_t v190 = v31 + 96;
  uint64_t v189 = v31 + 120;
  uint64_t v171 = v31;
  v197 = v95;
  while (1)
  {
    uint64_t v98 = (char *)v206;
    Kind(v219, a6);
    if ((*v199)(v98, 1, v27) == 1) {
      break;
    }
    char v99 = *v95;
    (*v95)(v94, v27);
    int v100 = *v208;
    (*v208)(v94, v98, v27);
    unsigned int v101 = v213;
    unsigned int v198 = *v202;
    v198((unsigned __int8 *)v213, (char *)v94, (uint64_t)v27);
    uint64_t v102 = *(uint64_t (**)(const char *, uint64_t))(v31 + 64);
    if (v102(v27, v31))
    {
      uint64_t v103 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 128))(v27, v31);
      if (v103 < 64)
      {
        uint64_t v96 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 120))(v27, v31);
        uint64_t v97 = v101;
        goto LABEL_41;
      }
      uint64_t v220 = 128;
      uint64_t v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v31 + 96);
      unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
      uint64_t v108 = v192;
      v106(&v220, &type metadata for Int, v107, v27, v31);
      char v109 = (*(uint64_t (**)(void (**)(unsigned __int8 *, uint64_t), char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v101, v108, v27);
LABEL_50:
      char v116 = v109;
      uint64_t v95 = v197;
      v99((uint64_t)v108, v27);
      uint64_t v117 = (char *)v101;
LABEL_56:
      v99((uint64_t)v117, v27);
      a6 = v217;
      uint64_t v94 = (uint64_t)v207;
      if ((v116 & 1) == 0) {
        goto LABEL_61;
      }
      goto LABEL_42;
    }
    char v110 = v102(v27, v31);
    uint64_t v111 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 128))(v27, v31);
    if ((v110 & 1) == 0)
    {
      if (v111 < 64)
      {
        char v118 = v213;
        uint64_t v96 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 120))(v27, v31);
        uint64_t v97 = v118;
LABEL_41:
        uint64_t v95 = v197;
        v99((uint64_t)v97, v27);
        a6 = v217;
        uint64_t v94 = (uint64_t)v207;
        if (v96 >= 128) {
          goto LABEL_61;
        }
        goto LABEL_42;
      }
      uint64_t v220 = 128;
      uint64_t v125 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v31 + 96);
      unint64_t v126 = lazy protocol witness table accessor for type Int and conformance Int(v111, v112, v113);
      unsigned int v127 = v192;
      v125(&v220, &type metadata for Int, v126, v27, v31);
      unsigned int v128 = v213;
      char v116 = (*(uint64_t (**)(void (**)(unsigned __int8 *, uint64_t), char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v213, v127, v27);
      unsigned int v129 = v128;
      uint64_t v95 = v197;
      v99((uint64_t)v129, v27);
      uint64_t v117 = v127;
      goto LABEL_56;
    }
    if (v111 > 64)
    {
      uint64_t v220 = 128;
      uint64_t v114 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v31 + 96);
      unint64_t v115 = lazy protocol witness table accessor for type Int and conformance Int(v111, v112, v113);
      uint64_t v108 = v192;
      v114(&v220, &type metadata for Int, v115, v27, v31);
      unsigned int v101 = v213;
      char v109 = (*(uint64_t (**)(void (**)(unsigned __int8 *, uint64_t), char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v213, v108, v27);
      goto LABEL_50;
    }
    unint64_t v119 = v184;
    v174(&qword_18162B0B8, 256);
    char v120 = v192;
    char v121 = v119;
    uint64_t v31 = v171;
    ((void (*)(char *, const char *, int **))v172)(v121, v27, v186);
    unsigned int v122 = (char *)v213;
    int v183 = (*(uint64_t (**)(void (**)(unsigned __int8 *, uint64_t), char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v213, v120, v27);
    uint64_t v123 = v197;
    v99((uint64_t)v120, v27);
    v124 = v182;
    v100((uint64_t)v182, v122, v27);
    uint64_t v94 = (uint64_t)v207;
    if (v183)
    {
      v99((uint64_t)v124, v27);
      a6 = v217;
      uint64_t v95 = v123;
    }
    else
    {
      uint64_t v130 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 120))(v27, v31);
      v99((uint64_t)v124, v27);
      BOOL v131 = v130 < 128;
      a6 = v217;
      uint64_t v95 = v123;
      if (!v131) {
        goto LABEL_61;
      }
    }
LABEL_42:
    BOOL v76 = __OFADD__(v59++, 1);
    if (v76) {
      goto LABEL_84;
    }
  }
  (*(void (**)(char *, Class *))(v168 + 8))(v98, v169);
  unsigned int v198 = *v202;
LABEL_61:
  unsigned int v132 = v170;
  v198((unsigned __int8 *)v170, (char *)v94, (uint64_t)v27);
  BOOL v133 = *(uint64_t (**)(const char *, uint64_t))(v31 + 64);
  if ((v133(v27, v31) & 1) == 0)
  {
    char v141 = v133(v27, v31);
    uint64_t v142 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 128))(v27, v31);
    uint64_t v145 = v192;
    if (v141)
    {
      if (v142 > 64)
      {
        uint64_t v220 = 128;
        uint64_t v146 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v31 + 96);
        unint64_t v147 = lazy protocol witness table accessor for type Int and conformance Int(v142, v143, v144);
        v146(&v220, &type metadata for Int, v147, v27, v31);
        char v148 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v132, v145, v27);
        uint64_t v140 = *v95;
        (*v95)((uint64_t)v145, v27);
        v140((uint64_t)v132, v27);
        if (v148) {
          goto LABEL_80;
        }
LABEL_76:
        unsigned __int8 v159 = specialized numericCast<A, B>(_:)(v94, (uint64_t)v27, v31);
        if (v216 != &type metadata for Unicode.UTF8.ForwardParser) {
          goto LABEL_85;
        }
        int v160 = v159;
        v140(v94, v27);
        uint64_t v161 = v178;
        char v162 = v215;
        (*(void (**)(char *, ValueMetadata *))(v178 + 8))(v215, &type metadata for Unicode.UTF8.ForwardParser);
        LODWORD(v220) = v160;
        BYTE4(v220) = 8;
        (*(void (**)(char *, uint64_t *, ValueMetadata *))(v161 + 16))(v162, &v220, &type metadata for Unicode.UTF8.ForwardParser);
        uint64_t v7 = v165;
        uint64_t AssociatedConformanceWitness = v211;
        uint64_t v58 = v181;
        uint64_t v57 = v180;
        uint64_t v56 = v179;
        goto LABEL_2;
      }
      v153 = v184;
      v174(&qword_18162B0B8, 256);
      ((void (*)(char *, const char *, int **))v172)(v153, v27, v186);
      char v154 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v132, v145, v27);
      uint64_t v140 = *v95;
      (*v95)((uint64_t)v145, v27);
      BOOL v155 = v167;
      (*v208)((uint64_t)v167, v132, v27);
      if (v154)
      {
        v140((uint64_t)v155, v27);
        goto LABEL_80;
      }
      uint64_t v152 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 120))(v27, v31);
      v140((uint64_t)v155, v27);
    }
    else
    {
      if (v142 >= 64)
      {
        uint64_t v220 = 128;
        uint64_t v156 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v31 + 96);
        unint64_t v157 = lazy protocol witness table accessor for type Int and conformance Int(v142, v143, v144);
        v156(&v220, &type metadata for Int, v157, v27, v31);
        char v158 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v132, v145, v27);
        uint64_t v140 = *v95;
        (*v95)((uint64_t)v132, v27);
        v140((uint64_t)v145, v27);
        if ((v158 & 1) == 0) {
          goto LABEL_76;
        }
        goto LABEL_80;
      }
      uint64_t v152 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 120))(v27, v31);
      uint64_t v140 = *v95;
      (*v95)((uint64_t)v132, v27);
    }
    if (v152 >= 128) {
      goto LABEL_76;
    }
    goto LABEL_80;
  }
  v134 = v95;
  uint64_t v135 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 128))(v27, v31);
  uint64_t v138 = v192;
  if (v135 >= 64)
  {
    uint64_t v220 = 128;
    uint64_t v149 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v31 + 96);
    unint64_t v150 = lazy protocol witness table accessor for type Int and conformance Int(v135, v136, v137);
    v149(&v220, &type metadata for Int, v150, v27, v31);
    char v151 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(*(void *)(v31 + 32) + 8) + 16))(v132, v138, v27);
    uint64_t v140 = *v134;
    (*v134)((uint64_t)v138, v27);
    v140((uint64_t)v132, v27);
    if ((v151 & 1) == 0) {
      goto LABEL_76;
    }
  }
  else
  {
    uint64_t v139 = (*(uint64_t (**)(const char *, uint64_t))(v31 + 120))(v27, v31);
    uint64_t v140 = *v134;
    (*v134)((uint64_t)v132, v27);
    if (v139 >= 128) {
      goto LABEL_76;
    }
  }
LABEL_80:
  v140(v94, v27);
  (*(void (**)(char *, ValueMetadata *))(v178 + 8))(v215, v216);
  (*(void (**)(char *, uint64_t))(v177 + 8))(v218, v219);
  return v59;
}

unint64_t static Unicode.UTF16.transcode<A>(_:from:)(unsigned int *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  if (a3 == &type metadata for Unicode.UTF8)
  {
    if (swift_getAssociatedTypeWitness(0, (int **)a4, (uint64_t)&type metadata for Unicode.UTF8, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar) != (const char *)&type metadata for _ValidUTF8Buffer)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0); {
    unsigned int v5 = *a1;
    }
    unsigned int v6 = __clz(*a1) >> 3;
    if (v6 == 3) {
      return ((_BYTE)v5 - 1) & 0x7F | 0x1000000000;
    }
    unsigned int v9 = v5 - 16843009;
    int v10 = (v9 << 6) | (v9 >> 8) & 0x3F;
    int v11 = HIWORD(v9) & 0x3F | (v10 << 6);
    if (((v11 << 6) & 0x1F0000) != 0) {
      uint64_t v12 = (((v11 << 6) + 983040) >> 10) & 0x3FF | (((v11 << 6) & 0x3C0 | HIBYTE(v9) & 0x3F) << 16) | 0x20DC00D800;
    }
    else {
      uint64_t v12 = (v11 << 6) & 0x1FFFC0 | HIBYTE(v9) & 0x3F | 0x1000000000;
    }
    uint64_t v13 = (unsigned __int16)v11 | 0x1000000000;
    if (v6 == 1) {
      uint64_t v12 = v13;
    }
    uint64_t v14 = v10 & 0x7FF | 0x1000000000;
    BOOL v15 = v6 == 2;
    goto LABEL_16;
  }
  if (a3 != &type metadata for Unicode.UTF16)
  {
    unsigned int v16 = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
    uint64_t v12 = ((v16 & 0x3FF) << 16) | ((v16 + 983040) >> 10) & 0x3FF | 0x20DC00D800;
    uint64_t v14 = v16 | 0x1000000000;
    BOOL v15 = HIWORD(v16) == 0;
LABEL_16:
    if (v15) {
      return v14;
    }
    else {
      return v12;
    }
  }
  if (*(void *)(*((void *)swift_getAssociatedTypeWitness(0, (int **)a4, (uint64_t)&type metadata for Unicode.UTF16, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar)- 1)+ 64) != 5)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0); {
  return *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
  }
}

uint64_t static Unicode.UTF16.encodedReplacementCharacter.getter()
{
  return 0x100000FFFDLL;
}

BOOL static Unicode.UTF16._isScalar(_:)(unsigned __int16 a1)
{
  return a1 >> 11 != 27;
}

uint64_t static Unicode.UTF16.decode(_:)(uint64_t result)
{
  if ((result & 0xFF00000000) == 0x1000000000) {
    return (unsigned __int16)result;
  }
  else {
    return (WORD1(result) & 0x3FF | ((result & 0x3FF) << 10)) + 0x10000;
  }
}

uint64_t static Unicode.UTF16.encode(_:)(unsigned int a1)
{
  uint64_t v1 = 0x1000000000;
  LODWORD(v2) = ((a1 & 0x3FF) << 16) | ((a1 + 983040) >> 10) & 0x3FF;
  if (a1 >= 0x10000) {
    uint64_t v2 = v2;
  }
  else {
    uint64_t v2 = a1;
  }
  if (a1 >= 0x10000) {
    uint64_t v1 = 0x20DC00D800;
  }
  return v1 | v2;
}

uint64_t Unicode.UTF16.ForwardParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF16.ForwardParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.UTF16.ReverseParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF16.ReverseParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF16(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 65533;
  *(unsigned char *)(a1 + 4) = 16;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF16(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 4) == 16) {
    return (unsigned __int16)*(_DWORD *)a1;
  }
  else {
    return (HIWORD(*(_DWORD *)a1) & 0x3FF | ((*(_DWORD *)a1 & 0x3FFu) << 10)) + 0x10000;
  }
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF16@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = 0x1000000000;
  int v3 = ((result & 0x3FF) << 16) | ((result + 983040) >> 10) & 0x3FF;
  if (result >= 0x10000) {
    uint64_t v2 = 0x20DC00D800;
  }
  else {
    int v3 = result;
  }
  *(unsigned char *)(a2 + 4) = BYTE4(v2);
  *(_DWORD *)a2 = v2 | v3;
  *(unsigned char *)(a2 + 5) = 0;
  return result;
}

ValueMetadata *protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF16@<X0>(unsigned int *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if (a2 == &type metadata for Unicode.UTF8)
  {
    uint64_t result = (ValueMetadata *)swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)&type metadata for Unicode.UTF8, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if (result != &type metadata for _ValidUTF8Buffer) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
    }
    unsigned int v8 = *a1;
    unsigned int v9 = __clz(*a1) >> 3;
    if (v9 == 3)
    {
      unint64_t v10 = ((_BYTE)v8 - 1) & 0x7F | 0x1000000000;
    }
    else
    {
      unsigned int v13 = v8 - 16843009;
      uint64_t v14 = (v13 << 6) & 0x7FF | (v13 >> 8) & 0x3F | 0x1000000000;
      int v15 = HIWORD(v13) & 0x3F | (((v13 << 6) | (v13 >> 8) & 0x3F) << 6);
      if (((v15 << 6) & 0x1F0000) != 0) {
        uint64_t v16 = (((v15 << 6) + 983040) >> 10) & 0x3FF | (((v15 << 6) & 0x3C0 | HIBYTE(v13) & 0x3F) << 16) | 0x20DC00D800;
      }
      else {
        uint64_t v16 = (v15 << 6) & 0x1FFFC0 | HIBYTE(v13) & 0x3F | 0x1000000000;
      }
      if (v9 == 1) {
        uint64_t v16 = (unsigned __int16)v15 | 0x1000000000;
      }
      if (v9 == 2) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v10 = v16;
      }
    }
  }
  else if (a2 == v4)
  {
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
    uint64_t v12 = *((void *)AssociatedTypeWitness - 1);
    uint64_t result = (ValueMetadata *)(AssociatedTypeWitness - 8);
    if (*(void *)(v12 + 64) != 5) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
    }
    unint64_t v10 = *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
  }
  else
  {
    uint64_t result = (ValueMetadata *)(*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
    unint64_t v10 = result | 0x1000000000;
    if (result >= 0x10000) {
      unint64_t v10 = (((unsigned __int16)result & 0x3FF) << 16) | ((result + 983040) >> 10) & 0x3FF | 0x20DC00D800;
    }
  }
  *(_DWORD *)a4 = v10;
  *(_WORD *)(a4 + 4) = BYTE4(v10);
  return result;
}

BOOL protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.UTF16(_WORD *a1)
{
  return (*a1 & 0xF800) != 55296;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF16.ReverseParser._parseMultipleCodeUnits()()
{
  Swift::Bool v1 = (v0 & 0xFC00FC00) == 3623934976;
  result.isValid = v1;
  return result;
}

unint64_t Unicode.UTF16.ReverseParser._bufferedScalar(bitCount:)(unint64_t result, int a2)
{
  int v2 = 32 - result;
  if ((v2 & 0xFFFFFF00) != 0)
  {
    __break(1u);
  }
  else
  {
    HIDWORD(v3) = a2;
    LODWORD(v3) = a2;
    return ((v3 >> 16) >> v2) | ((unint64_t)result << 32);
  }
  return result;
}

uint64_t static UInt8.- infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result = a1 - a2;
  if ((result & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  return result;
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF16.ReverseParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v8)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t (*v22)();
  void v23[4];

  if (*(unsigned char *)(v4 + 4))
  {
    if ((*(_DWORD *)v4 & 0xF800) == 0xD800)
    {
      unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      uint64_t result = v8(v23, a2, a3);
      goto LABEL_8;
    }
    uint64_t v21 = (unsigned __int16)*(_DWORD *)v4;
    lazy protocol witness table accessor for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser(a1, a2, a3);
    uint64_t v22 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    uint64_t result = (void *)((uint64_t (*)(void *, void))v22)(v23, 0);
    int v11 = 0;
    unint64_t v10 = v21 | 0x1000000000;
  }
  else
  {
    unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    uint64_t result = v8(v23, a2, a3);
    if ((v23[0] & 0x10000) != 0)
    {
LABEL_3:
      unint64_t v10 = 0;
      int v11 = 2;
    }
    else if ((v23[0] & 0xF800) == 0xD800)
    {
      uint64_t v12 = *(unsigned __int8 *)(v4 + 4);
      if (v12 >= 0x20) {
LABEL_25:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-65535 << v12) - 1) | (LOWORD(v23[0]) << v12);
      *(unsigned char *)(v4 + 4) = v12 + 16;
      while (1)
      {
        uint64_t result = v8(v23, a2, a3);
LABEL_8:
        if ((v23[0] & 0x10000) != 0) {
          break;
        }
        unsigned int v13 = *(unsigned __int8 *)(v4 + 4);
        if (v13 > 0x1F) {
          goto LABEL_25;
        }
        uint64_t v14 = *(_DWORD *)v4 & ((-65535 << v13) - 1) | (LOWORD(v23[0]) << v13);
        *(_DWORD *)uint64_t v4 = v14;
        int v15 = v13 + 16;
        *(unsigned char *)(v4 + 4) = v13 + 16;
        if (v13 >= 0x10) {
          goto LABEL_15;
        }
      }
      int v15 = *(unsigned char *)(v4 + 4);
      if (!v15) {
        goto LABEL_3;
      }
      uint64_t v14 = *(_DWORD *)v4;
LABEL_15:
      uint64_t v16 = v14 & 0xFC00FC00;
      if ((v14 & 0xFC00FC00) == 0xD800DC00) {
        uint64_t v17 = 32;
      }
      else {
        uint64_t v17 = 16;
      }
      *(unsigned char *)(v4 + 4) = v15 - v17;
      uint64_t v18 = v16 == -671032320;
      if (v16 == -671032320) {
        uint64_t v19 = 32;
      }
      else {
        uint64_t v19 = 16;
      }
      *(_DWORD *)uint64_t v4 = (unint64_t)v14 >> v19;
      if (v18)
      {
        int v11 = 0;
        HIDWORD(v20) = v14;
        LODWORD(v20) = v14;
        unint64_t v10 = (v20 >> 16) | (unint64_t)(v19 << 32);
      }
      else
      {
        uint64_t result = (void *)specialized numericCast<A, B>(_:)(0x10uLL);
        if (!(_BYTE)result) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
        }
        int v11 = 1;
        unint64_t v10 = 0x10u / result;
      }
    }
    else
    {
      int v11 = 0;
      unint64_t v10 = LOWORD(v23[0]) | 0x1000000000;
    }
  }
  *(void *)a4 = v10;
  *(unsigned char *)(a4 + 8) = v11;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF16.ReverseParser()
{
  if ((*v0 & 0xFC00FC00) == 0xD800DC00) {
    int v1 = 0x2000;
  }
  else {
    int v1 = 4096;
  }
  return v1 | ((*v0 & 0xFC00FC00) == -671032320);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF16.ReverseParser@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  int v3 = 32 - result;
  if ((v3 & 0xFFFFFF00) != 0)
  {
    __break(1u);
  }
  else
  {
    HIDWORD(v4) = *v2;
    LODWORD(v4) = *v2;
    *(_DWORD *)a2 = (v4 >> 16) >> v3;
    *(unsigned char *)(a2 + 4) = result;
  }
  return result;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF16.ForwardParser._parseMultipleCodeUnits()()
{
  Swift::Bool v1 = (v0 & 0xFC00FC00) == 3691042816;
  result.isValid = v1;
  return result;
}

unint64_t Unicode.UTF16.ForwardParser._bufferedScalar(bitCount:)(unsigned __int8 a1, unsigned int a2)
{
  return a2 | ((unint64_t)a1 << 32);
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF16.ForwardParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v8)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  char v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)();
  void v24[4];

  if (*(unsigned char *)(v4 + 4))
  {
    if ((*(_DWORD *)v4 & 0xF800) == 0xD800)
    {
      unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      Swift::tuple_isValid_Bool_bitCount_UInt8 result = v8(v24, a2, a3);
      goto LABEL_8;
    }
    uint64_t v22 = (unsigned __int16)*(_DWORD *)v4;
    lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser(a1, a2, a3);
    uint64_t v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    Swift::tuple_isValid_Bool_bitCount_UInt8 result = (void *)((uint64_t (*)(void *, void))v23)(v24, 0);
    int v11 = 0;
    unint64_t v10 = v22 | 0x1000000000;
  }
  else
  {
    unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    Swift::tuple_isValid_Bool_bitCount_UInt8 result = v8(v24, a2, a3);
    if ((v24[0] & 0x10000) != 0)
    {
LABEL_3:
      unint64_t v10 = 0;
      int v11 = 2;
    }
    else if ((v24[0] & 0xF800) == 0xD800)
    {
      uint64_t v12 = *(unsigned __int8 *)(v4 + 4);
      if (v12 >= 0x20) {
LABEL_25:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-65535 << v12) - 1) | (LOWORD(v24[0]) << v12);
      *(unsigned char *)(v4 + 4) = v12 + 16;
      while (1)
      {
        Swift::tuple_isValid_Bool_bitCount_UInt8 result = v8(v24, a2, a3);
LABEL_8:
        if ((v24[0] & 0x10000) != 0) {
          break;
        }
        unsigned int v13 = *(unsigned __int8 *)(v4 + 4);
        if (v13 > 0x1F) {
          goto LABEL_25;
        }
        uint64_t v14 = *(_DWORD *)v4 & ((-65535 << v13) - 1) | (LOWORD(v24[0]) << v13);
        *(_DWORD *)uint64_t v4 = v14;
        int v15 = v13 + 16;
        *(unsigned char *)(v4 + 4) = v13 + 16;
        if (v13 >= 0x10) {
          goto LABEL_15;
        }
      }
      int v15 = *(unsigned char *)(v4 + 4);
      if (!v15) {
        goto LABEL_3;
      }
      uint64_t v14 = *(_DWORD *)v4;
LABEL_15:
      uint64_t v16 = v14 & 0xFC00FC00;
      if ((v14 & 0xFC00FC00) == 0xDC00D800) {
        uint64_t v17 = 32;
      }
      else {
        uint64_t v17 = 16;
      }
      uint64_t v18 = v15 - v17;
      uint64_t v19 = v14;
      *(unsigned char *)(v4 + 4) = v18;
      uint64_t v20 = v16 == -603924480;
      if (v16 == -603924480) {
        uint64_t v21 = 32;
      }
      else {
        uint64_t v21 = 16;
      }
      *(_DWORD *)uint64_t v4 = (unint64_t)v14 >> v21;
      if (v20)
      {
        int v11 = 0;
        unint64_t v10 = v19 | (v21 << 32);
      }
      else
      {
        Swift::tuple_isValid_Bool_bitCount_UInt8 result = (void *)specialized numericCast<A, B>(_:)(0x10uLL);
        if (!(_BYTE)result) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
        }
        int v11 = 1;
        unint64_t v10 = 0x10u / result;
      }
    }
    else
    {
      int v11 = 0;
      unint64_t v10 = LOWORD(v24[0]) | 0x1000000000;
    }
  }
  *(void *)a4 = v10;
  *(unsigned char *)(a4 + 8) = v11;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF16.ForwardParser()
{
  if ((*v0 & 0xFC00FC00) == 0xDC00D800) {
    int v1 = 0x2000;
  }
  else {
    int v1 = 4096;
  }
  return v1 | ((*v0 & 0xFC00FC00) == -603924480);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF16.ForwardParser@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *v2;
  *(unsigned char *)(a2 + 4) = result;
  return result;
}

Swift::Int _MergeError.hashValue.getter()
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance _MergeError()
{
  return Hasher._finalize()();
}

uint64_t static Unicode.UTF32.encodedReplacementCharacter.getter()
{
  return 65533;
}

uint64_t static Unicode.UTF32._isScalar(_:)()
{
  return 1;
}

uint64_t static Unicode.UTF32.encode(_:)(uint64_t result)
{
  return result;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF32(_DWORD *a1@<X8>)
{
  *a1 = 65533;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF32(unsigned int *a1)
{
  return *a1;
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF32@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = result;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

uint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result = specialized static _UnicodeEncoding.transcode<A>(_:from:)(a1, a2, a3, a4);
  *(_DWORD *)a5 = result;
  *(unsigned char *)(a5 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t Unicode.UTF32.Parser.parseScalar<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v5, a2, a3);
  if ((v5 & 0x100000000) != 0) {
    return 0;
  }
  if (WORD1(v5) > 0x10u || v5 >> 11 == 27) {
    return 1;
  }
  else {
    return v5;
  }
}

uint64_t protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF32.Parser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = Unicode.UTF32.Parser.parseScalar<A>(from:)(a1, a2, a3);
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v6;
  return result;
}

uint64_t static UnicodeDecodingResult.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (a2 & 0x100000000) == 0 && a1 == a2;
  unsigned int v4 = BYTE4(a2) & (a2 != 0);
  if (!a1) {
    unsigned int v4 = BYTE4(a2) & (a2 == 0);
  }
  if ((a1 & 0x100000000) != 0) {
    return v4;
  }
  else {
    return v3;
  }
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance UnicodeDecodingResult(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 4);
  unsigned int v3 = (*(_DWORD *)a1 == *(_DWORD *)a2) & ~v2;
  if (*(_DWORD *)a2) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = *(unsigned __int8 *)(a2 + 4);
  }
  if (!*(_DWORD *)a2) {
    unsigned int v2 = 0;
  }
  if (*(_DWORD *)a1) {
    unsigned int v5 = v2;
  }
  else {
    unsigned int v5 = v4;
  }
  if (*(unsigned char *)(a1 + 4) == 1) {
    return v5;
  }
  else {
    return v3;
  }
}

uint64_t static UnicodeCodec._nullCodeUnitOffset(in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static UnicodeCodec._nullCodeUnitOffset(in:)(a1, a2, a3);
}

{
  int **v5;
  const char *AssociatedTypeWitness;
  uint64_t v7;
  int **v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t *, uint64_t);
  uint64_t v19;
  void (*v20)(char *, uint64_t, uint64_t *);
  uint64_t (**v21)(char *, uint64_t *);
  uint64_t v22;
  uint64_t result;
  uint64_t (*v25)(uint64_t *, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  void (*v30)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v31;
  char *v32;
  char v33;
  uint64_t (*v34)(char *, uint64_t *);
  char *v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t AssociatedConformanceWitness;
  char *v40;
  char *v41;
  uint64_t (*v42)(char *, uint64_t *);
  char *v43;
  void (*v44)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t);
  unint64_t v45;
  char *v46;
  uint64_t v47;
  void (**v48)(char *, char *, uint64_t *);
  int **v49;
  char *v50;
  char *v51;
  const char *v52;
  int **v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(char *, uint64_t, uint64_t *);
  uint64_t (*v61)(uint64_t *, uint64_t);
  uint64_t v62;

  unsigned int v5 = *(int ***)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v7 = *(void *)(swift_getAssociatedConformanceWitness((uint64_t)v5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)+ 8);
  unsigned int v8 = *(int ***)(*(void *)(v7 + 24) + 16);
  uint64_t v52 = swift_getAssociatedTypeWitness(0, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v52);
  uint64_t v51 = (char *)&v47 - v9;
  unint64_t v10 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  int v11 = MEMORY[0x1F4188790](v10);
  uint64_t v50 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  unsigned int v13 = MEMORY[0x1F4188790](v11);
  uint64_t v56 = (char *)&v47 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v47 - v15;
  uint64_t v17 = 0;
  uint64_t v18 = *(uint64_t (**)(uint64_t *, uint64_t))(v7 + 64);
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t *))(v19 + 16);
  v19 += 16;
  uint64_t v60 = v20;
  int v61 = v18;
  uint64_t v58 = *(void *)(v19 + 56);
  uint64_t v59 = v7 + 128;
  uint64_t v21 = (uint64_t (**)(char *, uint64_t *))(v19 - 8);
  char v54 = v7 + 120;
  uint64_t v55 = v7 + 96;
  uint64_t v53 = v8;
  uint64_t v48 = (void (**)(char *, char *, uint64_t *))(v19 + 16);
  uint64_t v49 = v8 + 3;
  uint64_t v57 = v7 + 64;
  uint64_t v47 = v19;
  v20((char *)&v47 - v15, a1, v10);
  while (1)
  {
    uint64_t v25 = v61;
    if (v61(v10, v7))
    {
      uint64_t v26 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 128))(v10, v7);
      if (v26 < 64)
      {
        uint64_t v22 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 120))(v10, v7);
        uint64_t result = (*v21)(v16, v10);
        if (!v22) {
          return v17;
        }
        goto LABEL_3;
      }
      goto LABEL_10;
    }
    uint64_t v29 = v25(v10, v7);
    uint64_t v26 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 128))(v10, v7);
    if (v29)
    {
      if (v26 > 64)
      {
LABEL_10:
        char v62 = 0;
        uint64_t v30 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v7 + 96);
        uint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v26, v27, v28);
        uint64_t v32 = v56;
        v30(&v62, &type metadata for Int, v31, v10, v7);
        uint64_t v33 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(v16, v32, v10);
        uint64_t v34 = *v21;
        (*v21)(v32, v10);
        uint64_t v35 = v16;
        goto LABEL_18;
      }
      uint64_t v37 = v52;
      uint64_t v38 = (uint64_t)v53;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v53, (uint64_t)v10, (uint64_t)v52, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v40 = v51;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v37, AssociatedConformanceWitness);
      uint64_t v41 = v56;
      (*(void (**)(char *, uint64_t *, uint64_t))(v38 + 24))(v40, v10, v38);
      LOBYTE(v37) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v7 + 32) + 8) + 32))(v16, v41, v10);
      uint64_t v42 = *v21;
      (*v21)(v41, v10);
      uint64_t v43 = v50;
      (*v48)(v50, v16, v10);
      if ((v37 & 1) == 0)
      {
        uint64_t result = v42(v43, v10);
        goto LABEL_3;
      }
      uint64_t v36 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 120))(v10, v7);
      uint64_t result = v42(v43, v10);
LABEL_16:
      if (!v36) {
        return v17;
      }
      goto LABEL_3;
    }
    if (v26 < 64)
    {
      uint64_t v36 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 120))(v10, v7);
      uint64_t result = (*v21)(v16, v10);
      goto LABEL_16;
    }
    char v62 = 0;
    uint64_t v44 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v7 + 96);
    uint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v26, v27, v28);
    uint64_t v46 = v56;
    v44(&v62, &type metadata for Int, v45, v10, v7);
    uint64_t v33 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v7 + 16) + 8) + 8))(v16, v46, v10);
    uint64_t v34 = *v21;
    (*v21)(v16, v10);
    uint64_t v35 = v46;
LABEL_18:
    uint64_t result = v34(v35, v10);
    if (v33) {
      return v17;
    }
LABEL_3:
    a1 += v58;
    if (__OFADD__(v17++, 1)) {
      break;
    }
    v60(v16, a1, v10);
  }
  __break(1u);
  return result;
}

uint64_t Unicode.UTF8.init()()
{
  return 0;
}

unint64_t Unicode.UTF8.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v8)(void *__return_ptr, uint64_t, uint64_t);
  char v9;
  unsigned int v10;
  unsigned __int8 v11;
  unsigned int v12;
  unsigned int v13;
  char v14;
  unsigned int v15;
  char v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t (*v23)();
  void v24[4];
  int v25;
  char v26;

  LODWORD(v6) = *v3;
  unsigned int v7 = *((unsigned __int8 *)v3 + 4);
  uint64_t v25 = *v3;
  uint64_t v26 = v7;
  if (v7)
  {
    if ((v6 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(a1, a2, a3);
      uint64_t v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(void *, void))v23)(v24, 0);
      uint64_t v12 = (v6 + 1);
      goto LABEL_31;
    }
    unsigned int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v24, a2, a3);
LABEL_7:
    if ((v24[0] & 0x100) != 0)
    {
      unsigned int v13 = v6;
      uint64_t v14 = v7;
    }
    else
    {
      if (v7 >= 0x20) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      }
      unsigned int v13 = v6 & ((-255 << v7) - 1) | (LOBYTE(v24[0]) << v7);
      uint64_t v14 = v7 + 8;
      if (v7 <= 0x17)
      {
        v8(v24, a2, a3);
        if ((v24[0] & 0x100) == 0)
        {
          unsigned int v13 = v13 & ((-65280 << v7) - 1) | (LOBYTE(v24[0]) << v14);
          uint64_t v14 = v7 + 16;
          if (v7 <= 0xF)
          {
            v8(v24, a2, a3);
            if ((v24[0] & 0x100) == 0)
            {
              unsigned int v13 = v13 & ((-16711680 << v7) - 1) | (LOBYTE(v24[0]) << v14);
              uint64_t v14 = v7 + 24;
              if (v7 <= 7)
              {
                v8(v24, a2, a3);
                if ((v24[0] & 0x100) == 0)
                {
                  unsigned int v13 = v13 & ((0x1000000 << v7) - 1) | (LOBYTE(v24[0]) << v14);
                  uint64_t v14 = v7 + 32;
                }
              }
            }
          }
        }
      }
    }
    if ((v13 & 0xC0E0) == 0x80C0)
    {
      if ((v13 & 0x1E) != 0)
      {
        int v15 = 16;
        uint64_t v16 = 1;
LABEL_29:
        unint64_t v10 = 1;
        unint64_t v6 = (unint64_t)v13 >> (v15 & 0x38);
        uint64_t v25 = v6;
        unsigned int v9 = v14 - v15;
        uint64_t v26 = v14 - v15;
        if ((v16 & 1) == 0)
        {
          int v11 = 1;
          goto LABEL_38;
        }
        uint64_t v12 = ((1 << ((v15 >> 1) & 0x1C) << ((v15 >> 1) & 0x1C)) - 1) & (v13 + 16843009);
        goto LABEL_31;
      }
    }
    else if ((v13 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v13 & 0x200F) != 0 && (v13 & 0x200F) != 0x200D)
      {
        int v15 = 24;
        uint64_t v16 = 1;
        goto LABEL_29;
      }
    }
    else if ((v13 & 0xC0C0C0F8) == 0x808080F0 && (v13 & 0x3007) != 0 && __rev16(v13 & 0x3007) <= 0x400)
    {
      int v15 = 32;
      uint64_t v16 = 1;
      goto LABEL_29;
    }
    uint64_t v17 = Unicode.UTF8.ForwardParser._invalidLength()();
    uint64_t v16 = 0;
    int v15 = 8 * v17;
    goto LABEL_29;
  }
  unsigned int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
  v8(v24, a2, a3);
  if ((v24[0] & 0x100) != 0)
  {
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    int v11 = 1;
    goto LABEL_38;
  }
  if ((v24[0] & 0x80) != 0)
  {
    LODWORD(v6) = v6 & 0xFFFFFF00 | LOBYTE(v24[0]);
    unsigned int v7 = 8;
    v8(v24, a2, a3);
    goto LABEL_7;
  }
  uint64_t v12 = LOBYTE(v24[0]) + 1;
LABEL_31:
  int v11 = 0;
  uint64_t v18 = 4 - (__clz(v12) >> 3);
  uint64_t v19 = ((v12 - 65793) >> 2) & 0xFC0 | ((v12 - 65793) >> 16) & 0x3F | (((v12 - 65793) & 0xF) << 12);
  uint64_t v20 = (((v12 - 257) & 0x1F) << 6) | ((v12 - 257) >> 8) & 0x3F;
  uint64_t v21 = ((v12 - 16843009) >> 10) & 0xFC0 | ((v12 - 16843009) >> 24) & 0x3F | ((((v12 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v12 - 16843009) & 7) << 18);
  unint64_t v10 = v12 - 1;
  if (v18 != 1) {
    unint64_t v10 = v21;
  }
  if (v18 == 2) {
    unint64_t v10 = v20;
  }
  if (v18 == 3) {
    unint64_t v10 = v19;
  }
  LODWORD(v6) = v25;
  unsigned int v9 = v26;
LABEL_38:
  *unsigned int v3 = v6;
  *((unsigned char *)v3 + 4) = v9;
  LOBYTE(v24[0]) = v11;
  return v10 | ((unint64_t)v11 << 32);
}

unint64_t static Unicode.UTF8._decodeOne(_:)(int a1)
{
  if ((a1 & 0x80) == 0)
  {
    unsigned __int8 v2 = 0;
    unsigned int v3 = a1;
    LOBYTE(v4) = 1;
    return ((unint64_t)v4 << 40) | ((unint64_t)v2 << 32) | v3;
  }
  if ((a1 & 0xC0E0) == 0x80C0)
  {
    if ((a1 & 0x1E) != 0)
    {
      LODWORD(v4) = 16;
      char v5 = 1;
      goto LABEL_15;
    }
  }
  else if ((a1 & 0xC0C0F0) == 0x8080E0)
  {
    if ((a1 & 0x200F) != 0 && (a1 & 0x200F) != 0x200D)
    {
      LODWORD(v4) = 24;
      char v5 = 1;
      goto LABEL_15;
    }
  }
  else if ((a1 & 0xC0C0C0F8) == 0x808080F0 && (a1 & 0x3007) != 0 && __rev16(a1 & 0x3007) <= 0x400)
  {
    LODWORD(v4) = 32;
    char v5 = 1;
    goto LABEL_15;
  }
  int v6 = Unicode.UTF8.ForwardParser._invalidLength()();
  char v5 = 0;
  LODWORD(v4) = 8 * v6;
LABEL_15:
  if (v5)
  {
    unsigned __int8 v2 = 0;
    unsigned int v7 = ((1 << ((v4 >> 1) & 0x1C) << ((v4 >> 1) & 0x1C)) - 1) & (a1 + 16843009);
    uint64_t v4 = 4 - (__clz(v7) >> 3);
    unsigned int v8 = ((v7 - 65793) >> 2) & 0xFC0 | ((v7 - 65793) >> 16) & 0x3F | (((v7 - 65793) & 0xF) << 12);
    unsigned int v9 = (((v7 - 257) & 0x1F) << 6) | ((v7 - 257) >> 8) & 0x3F;
    unsigned int v10 = ((v7 - 16843009) >> 10) & 0xFC0 | ((v7 - 16843009) >> 24) & 0x3F | ((((v7 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v7 - 16843009) & 7) << 18);
    unsigned int v3 = v7 - 1;
    if (v4 != 1) {
      unsigned int v3 = v10;
    }
    if (v4 == 2) {
      unsigned int v3 = v9;
    }
    if (v4 == 3) {
      unsigned int v3 = v8;
    }
  }
  else
  {
    unsigned int v3 = 0;
    LOBYTE(v4) = v4 >> 3;
    unsigned __int8 v2 = 1;
  }
  return ((unint64_t)v4 << 40) | ((unint64_t)v2 << 32) | v3;
}

uint64_t static Unicode.UTF8.encode(_:into:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 < 0x80) {
    return a2();
  }
  int v4 = (a1 & 0x3F) << 8;
  int v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
  int v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
  int v7 = (v5 | (a1 >> 12)) + 8487393;
  if (HIWORD(a1)) {
    int v7 = v6;
  }
  unsigned int v8 = a1 <= 0x7FF ? (v4 | (a1 >> 6)) + 33217 : v7;
  ((void (*)(void))a2)(v8 - 1);
  uint64_t result = ((uint64_t (*)(void))a2)((v8 >> 8) - 1);
  if (v8 >= 0x10000)
  {
    uint64_t result = ((uint64_t (*)(void))a2)(HIWORD(v8) - 1);
    if (HIBYTE(v8)) {
      return a2();
    }
  }
  return result;
}

unint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v9)(void *__return_ptr, uint64_t, uint64_t);
  char v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t (*v24)();
  void v25[4];
  int v26;
  char v27;

  int v4 = v3;
  LODWORD(v7) = *v3;
  unsigned int v8 = *((unsigned __int8 *)v3 + 4);
  uint64_t v26 = *v3;
  uint64_t v27 = v8;
  if (v8)
  {
    if ((v7 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(a1, a2, a3);
      uint64_t v24 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(void *, void))v24)(v25, 0);
      unsigned int v13 = (v7 + 1);
      goto LABEL_31;
    }
    unsigned int v9 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v9(v25, a2, a3);
  }
  else
  {
    unsigned int v9 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v9(v25, a2, a3);
    if ((v25[0] & 0x100) != 0)
    {
      unsigned int v10 = 0;
      int v11 = 0;
      uint64_t v12 = 1;
      goto LABEL_38;
    }
    if ((v25[0] & 0x80) == 0)
    {
      unsigned int v13 = LOBYTE(v25[0]) + 1;
LABEL_31:
      uint64_t v12 = 0;
      uint64_t v19 = 4 - (__clz(v13) >> 3);
      uint64_t v20 = ((v13 - 65793) >> 2) & 0xFC0 | ((v13 - 65793) >> 16) & 0x3F | (((v13 - 65793) & 0xF) << 12);
      uint64_t v21 = (((v13 - 257) & 0x1F) << 6) | ((v13 - 257) >> 8) & 0x3F;
      uint64_t v22 = ((v13 - 16843009) >> 10) & 0xFC0 | ((v13 - 16843009) >> 24) & 0x3F | ((((v13 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v13 - 16843009) & 7) << 18);
      int v11 = v13 - 1;
      if (v19 != 1) {
        int v11 = v22;
      }
      if (v19 == 2) {
        int v11 = v21;
      }
      if (v19 == 3) {
        int v11 = v20;
      }
      LODWORD(v7) = v26;
      unsigned int v10 = v27;
      goto LABEL_38;
    }
    LODWORD(v7) = v7 & 0xFFFFFF00 | LOBYTE(v25[0]);
    unsigned int v8 = 8;
    v9(v25, a2, a3);
  }
  if ((v25[0] & 0x100) != 0)
  {
    uint64_t v14 = v7;
    int v15 = v8;
  }
  else
  {
    if (v8 >= 0x20) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    }
    uint64_t v14 = v7 & ((-255 << v8) - 1) | (LOBYTE(v25[0]) << v8);
    int v15 = v8 + 8;
    if (v8 <= 0x17)
    {
      v9(v25, a2, a3);
      if ((v25[0] & 0x100) == 0)
      {
        uint64_t v14 = v14 & ((-65280 << v8) - 1) | (LOBYTE(v25[0]) << v15);
        int v15 = v8 + 16;
        if (v8 <= 0xF)
        {
          v9(v25, a2, a3);
          if ((v25[0] & 0x100) == 0)
          {
            uint64_t v14 = v14 & ((-16711680 << v8) - 1) | (LOBYTE(v25[0]) << v15);
            int v15 = v8 + 24;
            if (v8 <= 7)
            {
              v9(v25, a2, a3);
              if ((v25[0] & 0x100) == 0)
              {
                uint64_t v14 = v14 & ((0x1000000 << v8) - 1) | (LOBYTE(v25[0]) << v15);
                int v15 = v8 + 32;
              }
            }
          }
        }
      }
    }
  }
  if ((v14 & 0xC0E0) == 0x80C0)
  {
    if ((v14 & 0x1E) != 0)
    {
      uint64_t v16 = 16;
      uint64_t v17 = 1;
      goto LABEL_29;
    }
  }
  else if ((v14 & 0xC0C0F0) == 0x8080E0)
  {
    if ((v14 & 0x200F) != 0 && (v14 & 0x200F) != 0x200D)
    {
      uint64_t v16 = 24;
      uint64_t v17 = 1;
      goto LABEL_29;
    }
  }
  else if ((v14 & 0xC0C0C0F8) == 0x808080F0 && (v14 & 0x3007) != 0 && __rev16(v14 & 0x3007) <= 0x400)
  {
    uint64_t v16 = 32;
    uint64_t v17 = 1;
    goto LABEL_29;
  }
  uint64_t v18 = Unicode.UTF8.ForwardParser._invalidLength()();
  uint64_t v17 = 0;
  uint64_t v16 = 8 * v18;
LABEL_29:
  unint64_t v7 = (unint64_t)v14 >> (v16 & 0x38);
  uint64_t v26 = v7;
  unsigned int v10 = v15 - v16;
  uint64_t v27 = v15 - v16;
  if (v17)
  {
    unsigned int v13 = ((1 << ((v16 >> 1) & 0x1C) << ((v16 >> 1) & 0x1C)) - 1) & (v14 + 16843009);
    goto LABEL_31;
  }
  if (!specialized numericCast<A, B>(_:)(8uLL)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  }
  int v11 = 1;
  uint64_t v12 = 1;
LABEL_38:
  *int v4 = v7;
  *((unsigned char *)v4 + 4) = v10;
  LOBYTE(v25[0]) = v12;
  return v11 | ((unint64_t)v12 << 32);
}

uint64_t protocol witness for static UnicodeCodec.encode(_:into:) in conformance Unicode.UTF8(unsigned int a1, uint64_t (*a2)(char *))
{
  if (a1 >= 0x80)
  {
    int v5 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v6 = (v5 | (a1 >> 6) & 0x3F) << 8;
      int v7 = (((v6 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      int v8 = (v6 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v3 = v7;
      }
      else {
        unsigned int v3 = v8;
      }
    }
    else
    {
      unsigned int v3 = (v5 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    unsigned int v3 = a1 + 1;
  }
  char v12 = v3 - 1;
  uint64_t result = a2(&v12);
  if (v3 >= 0x100)
  {
    char v11 = BYTE1(v3) - 1;
    uint64_t result = a2(&v11);
    if (HIWORD(v3))
    {
      char v10 = BYTE2(v3) - 1;
      uint64_t result = a2(&v10);
      if (HIBYTE(v3))
      {
        char v9 = HIBYTE(v3) - 1;
        return a2(&v9);
      }
    }
  }
  return result;
}

uint64_t Unicode.UTF16.init()()
{
  return 0;
}

unint64_t Unicode.UTF16.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v8)(void *__return_ptr, uint64_t, uint64_t);
  char v9;
  unsigned int v10;
  unsigned __int8 v11;
  char v12;
  unsigned int v13;
  char v14;
  BOOL v15;
  char v16;
  unint64_t v17;
  uint64_t (*v19)();
  void v20[4];
  unsigned int v21;
  char v22;

  unsigned int v6 = *(_DWORD *)v3;
  unsigned int v7 = *(unsigned __int8 *)(v3 + 4);
  uint64_t v21 = *(_DWORD *)v3;
  uint64_t v22 = v7;
  if (v7)
  {
    if ((v6 & 0xF800) != 0xD800)
    {
      lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser(a1, a2, a3);
      uint64_t v19 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(void *, void))v19)(v20, 0);
      char v11 = 0;
      char v10 = (unsigned __int16)v6;
      unsigned int v6 = v21;
      char v9 = v22;
      goto LABEL_23;
    }
    int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v20, a2, a3);
  }
  else
  {
    int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v20, a2, a3);
    if ((v20[0] & 0x10000) != 0)
    {
      char v9 = 0;
      char v10 = 0;
      char v11 = 1;
      goto LABEL_23;
    }
    char v10 = LOWORD(v20[0]);
    if ((v20[0] & 0xF800) != 0xD800)
    {
      char v9 = 0;
      char v11 = 0;
      goto LABEL_23;
    }
    unsigned int v6 = v6 & 0xFFFF0000 | LOWORD(v20[0]);
    unsigned int v7 = 16;
    v8(v20, a2, a3);
  }
  if ((v20[0] & 0x10000) != 0)
  {
    char v12 = v7;
  }
  else
  {
    if (v7 >= 0x20) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    }
    unsigned int v6 = v6 & ((-65535 << v7) - 1) | (LOWORD(v20[0]) << v7);
    char v12 = v7 + 16;
    if (v7 <= 0xF)
    {
      v8(v20, a2, a3);
      if ((v20[0] & 0x10000) == 0)
      {
        unsigned int v6 = v6 & ((0x10000 << v7) - 1) | (LOWORD(v20[0]) << v12);
        char v12 = v7 + 32;
      }
    }
  }
  unsigned int v13 = v6 & 0xFC00FC00;
  if ((v6 & 0xFC00FC00) == 0xDC00D800) {
    uint64_t v14 = 32;
  }
  else {
    uint64_t v14 = 16;
  }
  char v9 = v12 - v14;
  int v15 = v13 == -603924480;
  if (v13 == -603924480) {
    uint64_t v16 = 32;
  }
  else {
    uint64_t v16 = 16;
  }
  uint64_t v17 = (unint64_t)v6 >> v16;
  char v10 = (HIWORD(v6) & 0x3FF | ((v6 & 0x3FF) << 10)) + 0x10000;
  if (v15)
  {
    char v11 = 0;
  }
  else
  {
    char v10 = 1;
    char v11 = 1;
  }
  unsigned int v6 = v17;
LABEL_23:
  *(_DWORD *)uint64_t v3 = v6;
  *(unsigned char *)(v3 + 4) = v9;
  LOBYTE(v20[0]) = v11;
  return v10 | ((unint64_t)v11 << 32);
}

uint64_t Unicode.UTF16._decodeOne<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = Unicode.UTF16.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t static Unicode.UTF16.encode(_:into:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 >= 0x10000) {
    ((void (*)(void))a2)(((a1 + 983040) >> 10) & 0x3FF | ((a1 & 0x3FF) << 16) | 0xDC00D800);
  }
  return a2();
}

uint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = Unicode.UTF16.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

_WORD *protocol witness for static UnicodeCodec._nullCodeUnitOffset(in:) in conformance Unicode.UTF16(_WORD *result)
{
  if (!*result) {
    return 0;
  }
  for (uint64_t i = 0; ; ++i)
  {
    uint64_t v2 = i + 1;
    if (__OFADD__(i, 1)) {
      break;
    }
    if (!result[v2]) {
      return (_WORD *)v2;
    }
  }
  __break(1u);
  return result;
}

unint64_t Unicode.UTF32.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v8, a2, a3);
  uint64_t v3 = v8;
  BOOL v4 = WORD1(v8) > 0x10u || v8 >> 11 == 27;
  char v5 = v4;
  if (v4) {
    uint64_t v3 = 1;
  }
  if ((v8 & 0x100000000) != 0)
  {
    uint64_t v3 = 0;
    unsigned __int8 v6 = 1;
  }
  else
  {
    unsigned __int8 v6 = v5;
  }
  return v3 | ((unint64_t)v6 << 32);
}

uint64_t static Unicode.UTF32.encode(_:into:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = Unicode.UTF32.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t protocol witness for static UnicodeCodec.encode(_:into:) in conformance Unicode.UTF32(int a1, uint64_t (*a2)(int *))
{
  int v3 = a1;
  return a2(&v3);
}

_DWORD *protocol witness for static UnicodeCodec._nullCodeUnitOffset(in:) in conformance Unicode.UTF32(_DWORD *result)
{
  if (!*result) {
    return 0;
  }
  for (uint64_t i = 0; ; ++i)
  {
    uint64_t v2 = i + 1;
    if (__OFADD__(i, 1)) {
      break;
    }
    if (!result[v2]) {
      return (_DWORD *)v2;
    }
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static _StringElement._toUTF16CodeUnit(_:) in conformance UInt16(unsigned __int16 *a1)
{
  return *a1;
}

uint64_t protocol witness for static _StringElement._fromUTF16CodeUnit(_:) in conformance UInt16@<X0>(uint64_t result@<X0>, _WORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t static UInt8._toUTF16CodeUnit(_:)(uint64_t result)
{
  return result;
}

BOOL hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(unsigned int a1)
{
  int32x4_t v1 = vdupq_n_s32(a1);
  uint64_t v2 = 1;
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v1, (int32x4_t)xmmword_18162AF60), (uint32x4_t)xmmword_18162AF80), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v1, (int32x4_t)xmmword_18162AF70), (uint32x4_t)xmmword_18162AF90)))) & 1) == 0)return a1 < 0x300 || a1 - 65281 < 0x9D; {
  return v2;
  }
}

Swift::String::Index __swiftcall _StringGuts._slowRoundDownToNearestCharacter(_:)(Swift::String::Index a1)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  int64_t v6 = a1._rawBits >> 16;
  if (a1._rawBits < 0x20000)
  {
    Swift::Int v9 = 0;
    goto LABEL_15;
  }
  if ((v2 & 0x1000000000000000) != 0) {
    goto LABEL_43;
  }
  if ((v2 & 0x2000000000000000) != 0)
  {
    uint64_t v23 = v1;
    uint64_t v24 = v2 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = (char *)&v23 + v6;
  }
  else
  {
    if ((v1 & 0x1000000000000000) != 0)
    {
      unsigned int v7 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      unsigned int v7 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
      if (!v7) {
LABEL_48:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    }
    uint64_t v8 = &v7[v6];
  }
  int v10 = *((unsigned __int16 *)v8 - 1);
  if (v10 != 2573 && (v10 & 0x80808080) == 0)
  {
    Swift::Int v9 = v6 - 1;
    if (__OFSUB__(v6, 1)) {
      goto LABEL_45;
    }
    goto LABEL_15;
  }
  while (1)
  {
LABEL_43:
    Swift::Int v22 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v6);
    Swift::Int v9 = v6 - v22;
    if (__OFSUB__(v6, v22))
    {
LABEL_45:
      __break(1u);
      goto LABEL_46;
    }
LABEL_15:
    if ((v3 & 0x1000000000000000) != 0) {
      goto LABEL_40;
    }
    if ((v3 & 0x2000000000000000) == 0) {
      break;
    }
    uint64_t v23 = v4;
    uint64_t v24 = v3 & 0xFFFFFFFFFFFFFFLL;
    if (v9 + 1 != (HIBYTE(v3) & 0xF))
    {
      int v15 = *(unsigned __int16 *)((char *)&v23 + v9);
      if (v15 == 2573 || (v15 & 0x80808080) != 0) {
        goto LABEL_40;
      }
    }
LABEL_30:
    Swift::Int v17 = 1;
    int64_t v18 = v9 + 1;
    if (!__OFADD__(v9, 1)) {
      goto LABEL_31;
    }
LABEL_42:
    __break(1u);
  }
  if ((v4 & 0x1000000000000000) != 0)
  {
    char v12 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = v4 & 0xFFFFFFFFFFFFLL;
    goto LABEL_19;
  }
LABEL_46:
  char v12 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
LABEL_19:
  if (v9 + 1 == v13) {
    goto LABEL_30;
  }
  if (!v12) {
    goto LABEL_48;
  }
  int v14 = *(unsigned __int16 *)&v12[v9];
  if (v14 != 2573 && (v14 & 0x80808080) == 0) {
    goto LABEL_30;
  }
LABEL_40:
  Swift::Int v17 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9);
  int64_t v18 = v9 + v17;
  if (__OFADD__(v9, v17)) {
    goto LABEL_42;
  }
LABEL_31:
  if (v6 >= v18) {
    return (Swift::String::Index)(a1._rawBits | 3);
  }
  Swift::Int v19 = v17 << 8;
  if (v17 > 63) {
    Swift::Int v19 = 0;
  }
  Swift::Int v20 = v19 | (v9 << 16);
  if ((v3 & 0x1000000000000000) == 0 || (v4 & 0x800000000000000) != 0) {
    return (Swift::String::Index)(v20 | 7);
  }
  else {
    return (Swift::String::Index)(v20 | 0xB);
  }
}

uint64_t _StringGuts._slowRoundDownToNearestCharacter(_:in:)(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  char v7 = a2;
  unint64_t v8 = a1;
  Swift::Int v9 = a1 >> 16;
  uint64_t v10 = _StringGuts._opaqueCharacterStride(endingAt:in:)(a1 >> 16, a2 >> 16, a3, a4, a5);
  Swift::Int v11 = v9 - v10;
  if (__OFSUB__(v9, v10)) {
    goto LABEL_29;
  }
  if ((a5 & 0x1000000000000000) != 0) {
    goto LABEL_26;
  }
  if ((a5 & 0x2000000000000000) != 0)
  {
    v22[0] = a4;
    v22[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    if (v11 + 1 != (HIBYTE(a5) & 0xF))
    {
      int v14 = *(unsigned __int16 *)((char *)v22 + v11);
      goto LABEL_11;
    }
    goto LABEL_16;
  }
  if ((a4 & 0x1000000000000000) == 0) {
    goto LABEL_30;
  }
  char v12 = (char *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v13 = a4 & 0xFFFFFFFFFFFFLL;
  while (1)
  {
    if (v11 + 1 != v13)
    {
      if (!v12) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
      }
      int v14 = *(unsigned __int16 *)&v12[v11];
LABEL_11:
      if (v14 == 2573 || (v14 & 0x8080) != 0) {
        break;
      }
    }
LABEL_16:
    Swift::Int v16 = 1;
    Swift::Int v17 = v11 + 1;
    if (!__OFADD__(v11, 1)) {
      goto LABEL_17;
    }
LABEL_28:
    __break(1u);
LABEL_29:
    __break(1u);
LABEL_30:
    char v12 = (char *)_StringObject.sharedUTF8.getter(a4, a5);
  }
LABEL_26:
  Swift::Int v16 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v11);
  Swift::Int v17 = v11 + v16;
  if (__OFADD__(v11, v16)) {
    goto LABEL_28;
  }
LABEL_17:
  if (v9 < v17)
  {
    Swift::Int v18 = v16 << 8;
    if (v16 > 63) {
      Swift::Int v18 = 0;
    }
    unint64_t v19 = v7 & 2 | (unint64_t)(v11 << 16) | v18;
    if ((a5 & 0x1000000000000000) == 0 || (a4 & 0x800000000000000) != 0) {
      uint64_t v20 = 5;
    }
    else {
      uint64_t v20 = 9;
    }
    return v19 | v20;
  }
  return v8;
}

Swift::UInt64 _StringGuts._foreignOpaqueCharacterStride(startingAt:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a3 & 0x2000000000000000) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  }
  int v38 = 0;
  if (v3 <= a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGraphemeBreaking.swift", 34, 2, 0x280uLL, 0);
  }
  v7._Swift::UInt64 rawBits = a1 << 16;
  v8._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  uint64_t v35 = a1;
  if ((a3 & 0x1000000000000000) != 0)
  {
    v12._Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v8._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
    v34._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits;
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v34)._rawBits;
  }
  else
  {
    Swift::UInt64 v10 = v8._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v36 = a2;
      uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
      v12._Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)&v36, v9._rawBits, v10);
      v13._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits >> 16;
      uint64_t v36 = a2;
      uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
      int v15 = *((unsigned __int8 *)&v36 + v13._rawBits);
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0) {
        id v11 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        id v11 = _StringObject.sharedUTF8.getter(a2, a3);
      }
      v12._Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)v11, v9._rawBits, v10);
      v13._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits >> 16;
      if ((a2 & 0x1000000000000000) != 0) {
        int v14 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        int v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      int v15 = v14[v13._rawBits];
    }
    int v16 = (char)v15;
    unsigned int v17 = __clz(v15 ^ 0xFF) - 24;
    if (v16 >= 0) {
      LOBYTE(v17) = 1;
    }
    Swift::UInt64 rawBits = ((v13._rawBits + v17) << 16) | 5;
  }
  do
  {
    Swift::UInt64 v22 = rawBits >> 16;
    if (rawBits >> 16 >= v3) {
      break;
    }
    v23._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits;
    if ((a3 & 0x1000000000000000) != 0)
    {
      v19._Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v23._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
      v20._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits;
      Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v20)._rawBits;
    }
    else
    {
      Swift::UInt64 v25 = v23._rawBits >> 16;
      if ((a3 & 0x2000000000000000) != 0)
      {
        uint64_t v36 = a2;
        uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
        v19._Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)&v36, v24._rawBits, v25);
        Swift::UInt64 v29 = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits >> 16;
        uint64_t v36 = a2;
        uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
        int v30 = *((unsigned __int8 *)&v36 + v29);
      }
      else
      {
        id v26 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a2 & 0x1000000000000000) == 0) {
          id v26 = _StringObject.sharedUTF8.getter(a2, a3);
        }
        v19._Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)v26, v24._rawBits, v25);
        v27._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits;
        uint64_t v28 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a2 & 0x1000000000000000) == 0) {
          uint64_t v28 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
        }
        Swift::UInt64 v29 = v27._rawBits >> 16;
        int v30 = v28[v27._rawBits >> 16];
      }
      int v31 = (char)v30;
      unsigned int v32 = __clz(v30 ^ 0xFF) - 24;
      if (v31 >= 0) {
        LOBYTE(v32) = 1;
      }
      Swift::UInt64 rawBits = ((v29 + v32) << 16) | 5;
    }
    Swift::Bool v21 = _GraphemeBreakingState.shouldBreak(between:and:)(v12, v19);
    v12._Swift::UInt32 value = v19._value;
  }
  while (!v21);
  return v22 - v35;
}

Swift::UInt64 _StringGuts._foreignOpaqueCharacterStride(endingAt:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 < 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGraphemeBreaking.swift", 34, 2, 0x2A1uLL, 0);
  }
  v7._Swift::UInt64 rawBits = a1 << 16;
  swift_bridgeObjectRetain(a3);
  v8._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v7)._rawBits;
  if (!(v8._rawBits >> 14)) {
    goto LABEL_46;
  }
  Swift::UInt64 rawBits = v8._rawBits;
  if ((a3 & 0x1000000000000000) == 0)
  {
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v40 = a2;
      uint64_t v41 = a3 & 0xFFFFFFFFFFFFFFLL;
      int v14 = (char *)&v40 + (v8._rawBits >> 16);
      if ((*(v14 - 1) & 0xC0) == 0x80)
      {
        uint64_t v15 = 0;
        int v16 = v14 - 2;
        do
          int v17 = v16[v15--] & 0xC0;
        while (v17 == 128);
        uint64_t v13 = 1 - v15;
      }
      else
      {
        uint64_t v13 = 1;
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0)
      {
        Swift::UInt64 v10 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        Swift::UInt64 v10 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
        if (!v10)
        {
LABEL_49:
          swift_bridgeObjectRelease(a3);
          __break(1u);
          goto LABEL_50;
        }
      }
      uint64_t v11 = 0;
      do
        int v12 = v10[(rawBits >> 16) - 1 + v11--] & 0xC0;
      while (v12 == 128);
      uint64_t v13 = -v11;
    }
    unint64_t v3 = (rawBits - (v13 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
    Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v3)._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v40 = a2;
      uint64_t v41 = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::Unicode::Scalar v19 = &v40;
      goto LABEL_19;
    }
    if ((a2 & 0x1000000000000000) != 0)
    {
      Swift::Unicode::Scalar v19 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
LABEL_19:
      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v19, v18._rawBits, rawBits);
      goto LABEL_20;
    }
LABEL_50:
    Swift::Unicode::Scalar v19 = _StringObject.sharedUTF8.getter(a2, a3);
    goto LABEL_19;
  }
  unint64_t v3 = String.UnicodeScalarView._foreignIndex(before:)(v8)._rawBits;
  v38._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v3)._rawBits;
  unsigned int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v38._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
LABEL_20:
  unsigned int v21 = value;
  Swift::UInt64 rawBits = v3 >> 16;
  if (v3 >= 0x10000)
  {
    uint64_t v39 = (char *)&v39 + 6;
    while (1)
    {
      v23._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(rawBits << 16))._rawBits;
      if (!(v23._rawBits >> 14)) {
        break;
      }
      unint64_t v3 = v23._rawBits;
      if ((a3 & 0x1000000000000000) != 0)
      {
        v28._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v23)._rawBits;
        v29._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v28)._rawBits;
        unsigned int v30 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v29._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
      }
      else
      {
        if ((a3 & 0x2000000000000000) != 0)
        {
          uint64_t v40 = a2;
          uint64_t v41 = a3 & 0xFFFFFFFFFFFFFFLL;
          if ((*((unsigned char *)&v40 + (v23._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v31 = 0;
            do
              int v32 = v39[(v23._rawBits >> 16) + v31--] & 0xC0;
            while (v32 == 128);
            uint64_t v27 = 1 - v31;
          }
          else
          {
            uint64_t v27 = 1;
          }
        }
        else
        {
          Swift::String::Index v24 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000) == 0)
          {
            Swift::String::Index v24 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
            if (!v24) {
              goto LABEL_49;
            }
          }
          uint64_t v25 = 0;
          do
            int v26 = v24[(v3 >> 16) - 1 + v25--] & 0xC0;
          while (v26 == 128);
          uint64_t v27 = -v25;
        }
        v28._Swift::UInt64 rawBits = (v3 - (v27 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
        v34._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v28)._rawBits >> 16;
        if ((a3 & 0x2000000000000000) != 0)
        {
          uint64_t v40 = a2;
          uint64_t v41 = a3 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v35 = &v40;
        }
        else
        {
          uint64_t v35 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000) == 0) {
            uint64_t v35 = _StringObject.sharedUTF8.getter(a2, a3);
          }
        }
        unsigned int v30 = _decodeScalar(_:startingAt:)((uint64_t)v35, v33._rawBits, v34._rawBits);
      }
      unsigned int v36 = v30;
      swift_bridgeObjectRetain(a3);
      char v37 = specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(v36, v21, rawBits, a2, a3);
      swift_bridgeObjectRelease(a3);
      if ((v37 & 1) == 0)
      {
        Swift::UInt64 rawBits = v28._rawBits >> 16;
        unsigned int v21 = v36;
        if (v28._rawBits >> 16) {
          continue;
        }
      }
      goto LABEL_21;
    }
LABEL_46:
    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
LABEL_21:
  swift_bridgeObjectRelease(a3);
  return a1 - rawBits;
}

uint64_t closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 1) {
    return 0;
  }
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  if ((a3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v5)._rawBits;
    v20._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)rawBits)._rawBits;
    LODWORD(result) = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v20._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
  }
  else
  {
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v24 = a2;
      uint64_t v25 = a3 & 0xFFFFFFFFFFFFFFLL;
      int v12 = (char *)&v24 + (v5._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0;
        int v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v10 = 1 - v13;
      }
      else
      {
        uint64_t v10 = 1;
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0)
      {
        id v6 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        Swift::UInt64 v21 = v5._rawBits;
        id v6 = _StringObject.sharedUTF8.getter(a2, a3);
        v5._Swift::UInt64 rawBits = v21;
      }
      uint64_t v7 = 0;
      Swift::UInt64 v8 = (Swift::UInt64)v6 + (v5._rawBits >> 16) - 1;
      do
        int v9 = *(unsigned char *)(v8 + v7--) & 0xC0;
      while (v9 == 128);
      uint64_t v10 = -v7;
    }
    v17._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v5._rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000 | 5))._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      uint64_t v24 = a2;
      uint64_t v25 = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v18 = &v24;
    }
    else if ((a2 & 0x1000000000000000) != 0)
    {
      Swift::String::Index v18 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v22 = a3;
      Swift::UInt64 v23 = v17._rawBits;
      Swift::String::Index v18 = _StringObject.sharedUTF8.getter(a2, v22);
      v17._Swift::UInt64 rawBits = v23;
    }
    LODWORD(result) = _decodeScalar(_:startingAt:)((uint64_t)v18, v16._rawBits, v17._rawBits);
  }
  return result;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _GraphemeBreakingState(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2 | a1[1] ^ a2[1] | a1[2] ^ a2[2] | a2[3] ^ a1[3]) & 1) == 0;
}

uint64_t _GraphemeBreakingState.description.getter(int a1)
{
  LODWORD(v1) = a1;
  uint64_t v2 = 91;
  unint64_t v3 = 0xE100000000000000;
  uint64_t v103 = 91;
  unint64_t v104 = 0xE100000000000000;
  if ((a1 & 1) == 0)
  {
    if ((a1 & 0x100) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v4 = HIBYTE(v3) & 3;
    if (v4)
    {
      swift_bridgeObjectRelease(v3);
      swift_bridgeObjectRelease(0xE100000000000000);
      uint64_t v2 = (69 << (8 * v4)) | ((-255 << (8 * v4)) - 1) & v2;
      unint64_t v3 = (v4 << 56) - 0x1F00000000000000;
      uint64_t v103 = v2;
      unint64_t v104 = v3;
      if ((v1 & 0x10000) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v2 = 69;
      uint64_t v103 = 69;
      unint64_t v104 = 0xE100000000000000;
      swift_bridgeObjectRelease(v3);
      unint64_t v3 = 0xE100000000000000;
      if ((v1 & 0x10000) == 0) {
        goto LABEL_14;
      }
    }
    goto LABEL_10;
  }
  swift_bridgeObjectRelease_n(0xE100000000000000, 2);
  uint64_t v2 = 22107;
  unint64_t v3 = 0xE200000000000000;
  uint64_t v103 = 22107;
  unint64_t v104 = 0xE200000000000000;
  if ((v1 & 0x100) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v1 & 0x10000) == 0) {
    goto LABEL_14;
  }
LABEL_10:
  unint64_t v5 = HIBYTE(v3) & 0xF;
  if (!v5 && (v3 & 0x2000000000000000) != 0)
  {
    uint64_t v103 = 73;
    unint64_t v104 = 0xE100000000000000;
    uint64_t v6 = v3;
    goto LABEL_13;
  }
  if ((v3 & 0x2000000000000000) == 0 || v5 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v3 & 0x1000000000000000) != 0) {
      goto LABEL_110;
    }
    if ((v3 & 0x2000000000000000) != 0) {
      uint64_t v48 = HIBYTE(v3) & 0xF;
    }
    else {
      uint64_t v48 = v2;
    }
    BOOL v24 = __OFADD__(v48, 1);
    int64_t v49 = v48 + 1;
    if (!v24) {
      goto LABEL_65;
    }
LABEL_112:
    __break(1u);
    goto LABEL_113;
  }
  uint64_t v17 = 8 * (HIBYTE(v3) & 7);
  uint64_t v18 = (-255 << v17) - 1;
  uint64_t v19 = 73 << v17;
  unint64_t v20 = v19 | v18 & v3;
  uint64_t v21 = v19 | v18 & v2;
  if (v5 >= 8) {
    unint64_t v22 = v20;
  }
  else {
    unint64_t v22 = v3;
  }
  if (v5 < 8) {
    uint64_t v2 = v21;
  }
  swift_bridgeObjectRelease(v3);
  swift_bridgeObjectRelease(0xE100000000000000);
  unint64_t v23 = 0xA000000000000000;
  if (((v2 | v22) & 0x80808080808080) == 0) {
    unint64_t v23 = 0xE000000000000000;
  }
  uint64_t v103 = v2;
  unint64_t v104 = (v23 & 0xFF00000000000000 | (v5 << 56) | v22 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
  unint64_t v7 = v104;
  if ((v1 & 0x1000000) != 0) {
    goto LABEL_15;
  }
  while (1)
  {
LABEL_68:
    unint64_t v52 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000) != 0) {
      uint64_t v53 = HIBYTE(v7) & 0xF;
    }
    else {
      uint64_t v53 = v2 & 0xFFFFFFFFFFFFLL;
    }
    if (!v53 && (v2 & ~v7 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v7);
      return 93;
    }
    if ((v7 & 0x2000000000000000) != 0 && v52 != 15) {
      break;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v7 & 0x1000000000000000) != 0)
    {
      Swift::Int v98 = String.UTF8View._foreignCount()();
      int64_t v55 = v98 + 1;
      if (!__OFADD__(v98, 1))
      {
LABEL_81:
        if ((v2 & ~v7 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v56 = _StringGuts.nativeUnusedCapacity.getter(v2, v7);
          if (v57)
          {
LABEL_114:
            unint64_t v101 = 258;
            goto LABEL_115;
          }
          BOOL v59 = (v7 & 0x2000000000000000) == 0 && v56 > 0;
          if (v55 <= 15 && !v59)
          {
LABEL_92:
            swift_bridgeObjectRelease_n(0xE100000000000000, 5);
            swift_bridgeObjectRetain(v7);
            unint64_t v60 = _StringGuts._convertedToSmall()(v2, v7);
            unint64_t v62 = v61;
            swift_bridgeObjectRelease(v7);
            v63._Swift::UInt64 rawBits = 1;
            v64._Swift::UInt64 rawBits = 65537;
            v65._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v63, v64, 0x5DuLL, 0xE100000000000000);
            if (v65._rawBits < 0x10000) {
              v65._rawBits |= 3;
            }
            unint64_t v67 = specialized String.init(_:)(v65, v66, 0x5DuLL, 0xE100000000000000);
            unint64_t v69 = v68;
            swift_bridgeObjectRelease(0xE100000000000000);
            unint64_t v70 = _StringGuts._convertedToSmall()(v67, v69);
            unint64_t v72 = v71;
            swift_bridgeObjectRelease(v69);
            unint64_t v73 = specialized _SmallString.init(_:appending:)(v60, v62, v70, v72);
            if ((v74 & 1) == 0)
            {
              uint64_t v54 = v73;
              swift_bridgeObjectRelease(0xE100000000000000);
              swift_bridgeObjectRelease(v104);
              return v54;
            }
LABEL_113:
            unint64_t v101 = 266;
LABEL_115:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v101, 0);
          }
        }
        else if (v55 <= 15)
        {
          goto LABEL_92;
        }
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v55, 1);
        swift_bridgeObjectRelease_n(0xE100000000000000, 6);
        long long v102 = xmmword_18162ACA0;
        unint64_t v75 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v102, 1);
        _StringGuts.appendInPlace(_:isASCII:)(v75, v76, 1);
        swift_bridgeObjectRelease(0xE100000000000000);
        return v103;
      }
    }
    else
    {
      BOOL v24 = __OFADD__(v53, 1);
      int64_t v55 = v53 + 1;
      if (!v24) {
        goto LABEL_81;
      }
    }
    __break(1u);
LABEL_107:
    Swift::Int v99 = String.UTF8View._foreignCount()();
    int64_t v1 = v99 + 1;
    if (__OFADD__(v99, 1))
    {
      while (1)
      {
        __break(1u);
LABEL_110:
        Swift::Int v100 = String.UTF8View._foreignCount()();
        BOOL v24 = __OFADD__(v100, 1);
        int64_t v49 = v100 + 1;
        if (v24) {
          goto LABEL_112;
        }
LABEL_65:
        if (v49 <= 15)
        {
          uint64_t v78 = v104;
          swift_bridgeObjectRelease_n(0xE100000000000000, 5);
          unint64_t v79 = v103;
          swift_bridgeObjectRetain(v78);
          unint64_t v80 = _StringGuts._convertedToSmall()(v79, v78);
          unint64_t v82 = v81;
          swift_bridgeObjectRelease(v78);
          v83._Swift::UInt64 rawBits = 1;
          v84._Swift::UInt64 rawBits = 65537;
          v85._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v83, v84, 0x49uLL, 0xE100000000000000);
          if (v85._rawBits < 0x10000) {
            v85._rawBits |= 3;
          }
          unint64_t v87 = specialized String.init(_:)(v85, v86, 0x49uLL, 0xE100000000000000);
          unint64_t v89 = v88;
          swift_bridgeObjectRelease(0xE100000000000000);
          unint64_t v90 = _StringGuts._convertedToSmall()(v87, v89);
          unint64_t v92 = v91;
          swift_bridgeObjectRelease(v89);
          unint64_t v93 = specialized _SmallString.init(_:appending:)(v80, v82, v90, v92);
          if (v95) {
            goto LABEL_113;
          }
          unint64_t v96 = v93;
          uint64_t v97 = v94;
          swift_bridgeObjectRelease(0xE100000000000000);
          uint64_t v6 = v104;
          uint64_t v103 = v96;
          unint64_t v104 = v97;
        }
        else
        {
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v49, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v102 = xmmword_18162AFA0;
          uint64_t v50 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v102, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v50, v51, 1);
          uint64_t v6 = 0xE100000000000000;
        }
LABEL_13:
        swift_bridgeObjectRelease(v6);
LABEL_14:
        uint64_t v2 = v103;
        unint64_t v7 = v104;
        if ((v1 & 0x1000000) == 0) {
          goto LABEL_68;
        }
LABEL_15:
        unint64_t v8 = HIBYTE(v7) & 0xF;
        if ((v7 & 0x2000000000000000) != 0) {
          uint64_t v9 = HIBYTE(v7) & 0xF;
        }
        else {
          uint64_t v9 = v2 & 0xFFFFFFFFFFFFLL;
        }
        if (!v9 && (v2 & ~v7 & 0x2000000000000000) == 0)
        {
          uint64_t v2 = 82;
          uint64_t v103 = 82;
          unint64_t v104 = 0xE100000000000000;
          swift_bridgeObjectRelease(v7);
          unint64_t v7 = 0xE100000000000000;
          goto LABEL_68;
        }
        if ((v7 & 0x2000000000000000) != 0 && v8 != 15) {
          break;
        }
        swift_bridgeObjectRetain_n(0xE100000000000000, 6);
        if ((v7 & 0x1000000000000000) != 0) {
          goto LABEL_107;
        }
        BOOL v24 = __OFADD__(v9, 1);
        int64_t v1 = v9 + 1;
        if (!v24) {
          goto LABEL_43;
        }
      }
      uint64_t v10 = 8 * (HIBYTE(v7) & 7);
      uint64_t v11 = (-255 << v10) - 1;
      uint64_t v12 = 82 << v10;
      unint64_t v13 = v12 | v11 & v7;
      uint64_t v14 = v12 | v11 & v2;
      if (v8 >= 8) {
        unint64_t v15 = v13;
      }
      else {
        unint64_t v15 = v7;
      }
      if (v8 < 8) {
        uint64_t v2 = v14;
      }
      swift_bridgeObjectRelease(v7);
      swift_bridgeObjectRelease(0xE100000000000000);
      unint64_t v16 = 0xA000000000000000;
      if (!(v2 & 0x8080808080808080 | v15 & 0x80808080808080)) {
        unint64_t v16 = 0xE000000000000000;
      }
      unint64_t v7 = (v16 & 0xFF00000000000000 | (v8 << 56) | v15 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
      uint64_t v103 = v2;
      unint64_t v104 = v7;
    }
    else
    {
LABEL_43:
      if ((v2 & ~v7 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(v2, v7);
        if (v26) {
          goto LABEL_114;
        }
        BOOL v28 = (v7 & 0x2000000000000000) == 0 && v25 > 0;
        if (v1 > 15 || v28) {
          goto LABEL_59;
        }
LABEL_54:
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        swift_bridgeObjectRetain(v7);
        unint64_t v29 = _StringGuts._convertedToSmall()(v2, v7);
        unint64_t v31 = v30;
        swift_bridgeObjectRelease(v7);
        v32._Swift::UInt64 rawBits = 1;
        v33._Swift::UInt64 rawBits = 65537;
        v34._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v32, v33, 0x52uLL, 0xE100000000000000);
        if (v34._rawBits < 0x10000) {
          v34._rawBits |= 3;
        }
        unint64_t v36 = specialized String.init(_:)(v34, v35, 0x52uLL, 0xE100000000000000);
        unint64_t v38 = v37;
        swift_bridgeObjectRelease(0xE100000000000000);
        unint64_t v39 = _StringGuts._convertedToSmall()(v36, v38);
        unint64_t v41 = v40;
        swift_bridgeObjectRelease(v38);
        unint64_t v42 = specialized _SmallString.init(_:appending:)(v29, v31, v39, v41);
        if (v44) {
          goto LABEL_113;
        }
        uint64_t v2 = v42;
        unint64_t v7 = v43;
        swift_bridgeObjectRelease(0xE100000000000000);
        uint64_t v45 = v104;
        uint64_t v103 = v2;
        unint64_t v104 = v7;
        swift_bridgeObjectRelease(v45);
      }
      else
      {
        if (v1 <= 15) {
          goto LABEL_54;
        }
LABEL_59:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v1, 1);
        swift_bridgeObjectRelease_n(0xE100000000000000, 6);
        long long v102 = xmmword_18162AFB0;
        uint64_t v46 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v102, 1);
        _StringGuts.appendInPlace(_:isASCII:)(v46, v47, 1);
        swift_bridgeObjectRelease(0xE100000000000000);
        uint64_t v2 = v103;
        unint64_t v7 = v104;
      }
    }
  }
  if (v52 >= 8) {
    uint64_t v54 = v2;
  }
  else {
    uint64_t v54 = (93 << (8 * (HIBYTE(v7) & 7u))) | ((-255 << (8 * (HIBYTE(v7) & 7u))) - 1) & v2;
  }
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v54;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _GraphemeBreakingState()
{
  if (v0[3]) {
    int v1 = 0x1000000;
  }
  else {
    int v1 = 0;
  }
  if (v0[2]) {
    int v2 = 0x10000;
  }
  else {
    int v2 = 0;
  }
  if (v0[1]) {
    int v3 = 256;
  }
  else {
    int v3 = 0;
  }
  return _GraphemeBreakingState.description.getter(v3 | *v0 | v2 | v1);
}

uint64_t static Unicode._CharacterRecognizer.quickBreak(between:and:)(unsigned int a1, unsigned int a2)
{
  if (a1 == 13 && a2 == 10) {
    return 0;
  }
  if (hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(a1)
    && hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(a2))
  {
    return 1;
  }
  return 2;
}

Swift::Unicode::_CharacterRecognizer __swiftcall Unicode._CharacterRecognizer.init()()
{
  void *v0 = 0;
  return result;
}

Swift::Bool __swiftcall Unicode._CharacterRecognizer.hasBreak(before:)(Swift::Unicode::Scalar before)
{
  int v2 = v1;
  v5._unsigned int value = v1->_value;
  uint64_t v4 = v1 + 1;
  Swift::Bool v6 = _GraphemeBreakingState.shouldBreak(between:and:)(v5, before);
  if (v6) {
    v4->_unsigned int value = 0;
  }
  v2->_unsigned int value = before._value;
  return v6;
}

uint64_t Unicode._CharacterRecognizer._firstBreak(inUncheckedUnsafeUTF8Buffer:startingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= a2) {
    return 0;
  }
  uint64_t v4 = a3;
  v7._unsigned int value = *v3;
  while (1)
  {
    int v8 = *(unsigned __int8 *)(a1 + v4);
    if (*(char *)(a1 + v4) < 0)
    {
      switch(__clz(v8 ^ 0xFF))
      {
        case 0x1Au:
          int v8 = *(unsigned char *)(v4 + a1 + 1) & 0x3F | ((v8 & 0x1F) << 6);
          uint64_t v9 = 2;
          break;
        case 0x1Bu:
          int v8 = ((v8 & 0xF) << 12) | ((*(unsigned char *)(v4 + a1 + 1) & 0x3F) << 6) | *(unsigned char *)(v4 + a1 + 2) & 0x3F;
          uint64_t v9 = 3;
          break;
        case 0x1Cu:
          int v8 = ((v8 & 0xF) << 18) | ((*(unsigned char *)(v4 + a1 + 1) & 0x3F) << 12) | ((*(unsigned char *)(v4 + a1 + 2) & 0x3F) << 6) | *(unsigned char *)(v4 + a1 + 3) & 0x3F;
          uint64_t v9 = 4;
          break;
        default:
          goto LABEL_4;
      }
    }
    else
    {
LABEL_4:
      uint64_t v9 = 1;
    }
    if (_GraphemeBreakingState.shouldBreak(between:and:)(v7, (Swift::Unicode::Scalar)v8)) {
      break;
    }
    v4 += v9;
    v7._unsigned int value = v8;
    if (v4 >= a2)
    {
      uint64_t v4 = 0;
      *int v3 = v8;
      return v4;
    }
  }
  *int v3 = v8;
  v3[1] = 0;
  return v4;
}

uint64_t Unicode._CharacterRecognizer.description.getter()
{
  Swift::UInt64 _ = *(unsigned int *)v0;
  LODWORD(v1) = v0[4];
  LODWORD(v2) = v0[5];
  int v3 = v0[6];
  LODWORD(v4) = v0[7];
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(6);
  uint64_t v7 = v5;
  unint64_t v8 = v6;
  v258._uint64_t countAndFlagsBits = v5;
  v258._unint64_t object = (void *)v6;
  uint64_t v9 = HIBYTE(v6) & 0xF;
  uint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 || (v5 & ~v6 & 0x2000000000000000) != 0)
  {
    if ((v6 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0xE000000000000000);
      unint64_t v34 = 0xA000000000000000;
      if (!(v8 & 0x80808080808080 | v7 & 0x8080808080808080)) {
        unint64_t v34 = 0xE000000000000000;
      }
      v258._uint64_t countAndFlagsBits = v7;
      v258._unint64_t object = (void *)(v34 & 0xFF00000000000000 | (v9 << 56) | v8 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_29;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6);
    Swift::Int v12 = v10;
    if ((v8 & 0x1000000000000000) != 0)
    {
      Swift::Int v12 = String.UTF8View._foreignCount()();
      if ((v7 & ~v8 & 0x2000000000000000) == 0) {
        goto LABEL_26;
      }
    }
    else if ((v7 & ~v8 & 0x2000000000000000) == 0)
    {
      goto LABEL_26;
    }
    if (swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v13 = _StringGuts.nativeUnusedCapacity.getter(v7, v8);
      if ((v14 & 1) == 0)
      {
        if (v12 <= 15 && (v13 & 0x8000000000000000) != 0)
        {
LABEL_13:
          swift_bridgeObjectRelease_n(0xE000000000000000, 5);
          if ((v8 & 0x1000000000000000) == 0)
          {
            if ((v7 & 0x1000000000000000) != 0)
            {
              unint64_t v15 = (unsigned __int8 *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }
            else
            {
              unint64_t v15 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v8);
              uint64_t v10 = v248;
            }
            swift_bridgeObjectRetain(v8);
            closure #1 in _StringGuts._convertedToSmall()(v15, v10, &v257);
            swift_bridgeObjectRelease(v8);
            unint64_t v17 = *((void *)&v257 + 1);
            unint64_t v16 = v257;
            goto LABEL_17;
          }
          goto LABEL_255;
        }
LABEL_27:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v12, 0);
        swift_bridgeObjectRelease_n(0xE000000000000000, 6);
        long long v257 = 0uLL;
        Swift::String::Index v35 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v257, 0);
        _StringGuts.appendInPlace(_:isASCII:)(v35, v36, 1);
        uint64_t v33 = 0xE000000000000000;
        goto LABEL_28;
      }
      goto LABEL_262;
    }
LABEL_26:
    if (v12 <= 15) {
      goto LABEL_13;
    }
    goto LABEL_27;
  }
  v258._uint64_t countAndFlagsBits = 0;
  v258._unint64_t object = (void *)0xE000000000000000;
  uint64_t v33 = v6;
  while (1)
  {
LABEL_28:
    swift_bridgeObjectRelease(v33);
LABEL_29:
    if (v4) {
      int v37 = 0x1000000;
    }
    else {
      int v37 = 0;
    }
    if (v3) {
      int v38 = 0x10000;
    }
    else {
      int v38 = 0;
    }
    if (v2) {
      int v39 = 256;
    }
    else {
      int v39 = 0;
    }
    uint64_t v40 = _GraphemeBreakingState.description.getter(v39 | v1 | v38 | v37);
    uint64_t v42 = v40;
    unint64_t v43 = v41;
    uint64_t countAndFlagsBits = v258._countAndFlagsBits;
    unint64_t object = (unint64_t)v258._object;
    unint64_t v46 = ((unint64_t)v258._object >> 56) & 0xF;
    unint64_t v47 = v258._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v258._object & 0x2000000000000000) != 0) {
      unint64_t v47 = ((unint64_t)v258._object >> 56) & 0xF;
    }
    if (!v47 && (v258._countAndFlagsBits & ~(uint64_t)v258._object & 0x2000000000000000) == 0)
    {
      v258._uint64_t countAndFlagsBits = v40;
      v258._unint64_t object = (void *)v41;
      swift_bridgeObjectRelease(object);
      goto LABEL_88;
    }
    uint64_t v48 = v41 & 0x2000000000000000;
    uint64_t v49 = HIBYTE(v41) & 0xF;
    if (((uint64_t)v258._object & 0x2000000000000000) != 0 && v48)
    {
      unint64_t v50 = v46 + v49;
      if (v46 + v49 <= 0xF)
      {
        if (v49)
        {
          char v81 = 0;
          unint64_t v82 = 0;
          do
          {
            unint64_t v83 = v46 + v82;
            unint64_t v84 = v82 + 1;
            if (v82 >= 8) {
              unint64_t v85 = v41;
            }
            else {
              unint64_t v85 = v40;
            }
            unint64_t v86 = v85 >> (v81 & 0x38);
            char v87 = (8 * v46 + v81) & 0x38;
            uint64_t v88 = (-255 << v87) - 1;
            unint64_t v89 = (unint64_t)v86 << v87;
            unint64_t v90 = v89 | v88 & object;
            unint64_t v91 = v89 | v88 & countAndFlagsBits;
            if (v83 < 8) {
              uint64_t countAndFlagsBits = v91;
            }
            else {
              unint64_t object = v90;
            }
            v81 += 8;
            unint64_t v82 = v84;
          }
          while (v49 != v84);
        }
        swift_bridgeObjectRelease(v41);
        unint64_t v92 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | object & 0x80808080808080)) {
          unint64_t v92 = 0xE000000000000000;
        }
        unint64_t v93 = (void *)(v92 & 0xFF00000000000000 | (v50 << 56) | object & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v258._object);
        v258._uint64_t countAndFlagsBits = countAndFlagsBits;
        v258._unint64_t object = v93;
        goto LABEL_88;
      }
      uint64_t v48 = 1;
    }
    if (v48) {
      uint64_t v51 = HIBYTE(v41) & 0xF;
    }
    else {
      uint64_t v51 = v40 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v41, 2);
    if ((v43 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v43, 5);
      v211._Swift::UInt64 rawBits = 1;
      v212._Swift::UInt64 rawBits = (v51 << 16) | 1;
      v213._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v211, v212, v42, v43);
      if (v213._rawBits < 0x10000) {
        v213._rawBits |= 3;
      }
      Swift::Int v52 = specialized Collection.count.getter(v213, v214, v42, v43);
      swift_bridgeObjectRelease(v43);
      uint64_t countAndFlagsBits = v258._countAndFlagsBits;
      unint64_t object = (unint64_t)v258._object;
      if (((uint64_t)v258._object & 0x1000000000000000) != 0)
      {
LABEL_226:
        Swift::Int v215 = String.UTF8View._foreignCount()();
        int64_t v53 = v215 + v52;
        if (!__OFADD__(v215, v52)) {
          goto LABEL_56;
        }
        goto LABEL_54;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v43, 4);
      Swift::Int v52 = v51;
      if ((object & 0x1000000000000000) != 0) {
        goto LABEL_226;
      }
    }
    if ((object & 0x2000000000000000) == 0)
    {
      int64_t v53 = (countAndFlagsBits & 0xFFFFFFFFFFFFLL) + v52;
      if (!__OFADD__(countAndFlagsBits & 0xFFFFFFFFFFFFLL, v52)) {
        goto LABEL_56;
      }
      goto LABEL_54;
    }
    while (1)
    {
      uint64_t v54 = HIBYTE(object) & 0xF;
      int64_t v53 = v54 + v52;
      if (!__OFADD__(v54, v52)) {
        break;
      }
LABEL_54:
      __break(1u);
    }
LABEL_56:
    if ((countAndFlagsBits & ~object & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v55 = (unint64_t)v258._object;
      int64_t v56 = _StringGuts.nativeUnusedCapacity.getter(v258._countAndFlagsBits, (uint64_t)v258._object);
      if (v57) {
        goto LABEL_262;
      }
      if (v53 <= 15 && ((v55 & 0x2000000000000000) != 0 || v56 < v52))
      {
LABEL_66:
        swift_bridgeObjectRelease_n(v43, 5);
        unint64_t v60 = v258._countAndFlagsBits;
        unint64_t v61 = v258._object;
        swift_bridgeObjectRetain((unint64_t)v258._object);
        unint64_t v62 = _StringGuts._convertedToSmall()(v60, (unint64_t)v61);
        unint64_t v64 = v63;
        swift_bridgeObjectRelease((uint64_t)v61);
        v65._Swift::UInt64 rawBits = (v51 << 16) | 1;
        v66._Swift::UInt64 rawBits = 1;
        v67._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v66, v65, v42, v43);
        if (v67._rawBits < 0x10000) {
          v67._rawBits |= 3;
        }
        unint64_t v69 = specialized String.init(_:)(v67, v68, v42, v43);
        unint64_t v71 = v70;
        swift_bridgeObjectRelease(v43);
        unint64_t v72 = _StringGuts._convertedToSmall()(v69, v71);
        unint64_t v74 = v73;
        swift_bridgeObjectRelease(v71);
        unint64_t v75 = specialized _SmallString.init(_:appending:)(v62, v64, v72, v74);
        if (v77) {
          goto LABEL_261;
        }
        uint64_t v78 = v75;
        unint64_t v79 = v76;
        swift_bridgeObjectRelease(v43);
        unint64_t v80 = v258._object;
        v258._uint64_t countAndFlagsBits = v78;
        v258._unint64_t object = v79;
        swift_bridgeObjectRelease((uint64_t)v80);
        goto LABEL_88;
      }
    }
    else if (v53 <= 15)
    {
      goto LABEL_66;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v53, v52);
    swift_bridgeObjectRelease_n(v43, 4);
    if ((v43 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v43);
      _StringGuts._foreignAppendInPlace(_:)(v42, v43, 0, v51);
    }
    else
    {
      if (v48)
      {
        swift_bridgeObjectRelease_n(v43, 2);
        *(void *)&long long v257 = v42;
        *((void *)&v257 + 1) = v43 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v58 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v43) & 0xF, (uint64_t)&v257, HIBYTE(v43) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v58, v59, (v43 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(v43);
        goto LABEL_88;
      }
      if ((v42 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v43);
        id v94 = (id)((v43 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v95 = v42 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v94 = _StringObject.sharedUTF8.getter(v42, v43);
        uint64_t v95 = v249;
        swift_bridgeObjectRelease(v43);
        if (v95 < (v42 & 0xFFFFFFFFFFFFLL)) {
          goto LABEL_260;
        }
      }
      unint64_t v96 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v42 & 0xFFFFFFFFFFFFLL, (uint64_t)v94, v95);
      _StringGuts.appendInPlace(_:isASCII:)(v96, v97, v42 < 0);
    }
    swift_bridgeObjectRelease_n(v43, 2);
LABEL_88:
    uint64_t v99 = v258._countAndFlagsBits;
    uint64_t v98 = (uint64_t)v258._object;
    unint64_t v100 = ((unint64_t)v258._object >> 56) & 0xF;
    if (((uint64_t)v258._object & 0x2000000000000000) != 0) {
      unint64_t v101 = ((unint64_t)v258._object >> 56) & 0xF;
    }
    else {
      unint64_t v101 = v258._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v101 && (v258._countAndFlagsBits & ~(uint64_t)v258._object & 0x2000000000000000) == 0)
    {
      v258._uint64_t countAndFlagsBits = 11093;
      v258._unint64_t object = (void *)0xE200000000000000;
      uint64_t v114 = v98;
      goto LABEL_115;
    }
    if (((uint64_t)v258._object & 0x2000000000000000) == 0 || v100 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v98 & 0x1000000000000000) != 0)
      {
        Swift::Int v221 = String.UTF8View._foreignCount()();
        int64_t v108 = v221 + 2;
        if (__OFADD__(v221, 2))
        {
LABEL_237:
          __break(1u);
LABEL_238:
          Swift::Int v201 = String.UTF8View._foreignCount()();
          if ((v99 & ~v98 & 0x2000000000000000) == 0) {
            goto LABEL_239;
          }
LABEL_213:
          if (!swift_isUniquelyReferenced_nonNull_native(v98 & 0xFFFFFFFFFFFFFFFLL)) {
            goto LABEL_239;
          }
          unint64_t v203 = (unint64_t)v258._object;
          unint64_t v204 = _StringGuts.nativeUnusedCapacity.getter(v258._countAndFlagsBits, (uint64_t)v258._object);
          if (v205)
          {
LABEL_262:
            unint64_t v251 = 258;
LABEL_263:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v251, 0);
          }
          if (v201 <= 15 && ((v203 & 0x2000000000000000) != 0 || (v204 & 0x8000000000000000) != 0)) {
            goto LABEL_240;
          }
LABEL_218:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v201, 0);
          swift_bridgeObjectRelease_n(0xE000000000000000, 6);
          long long v257 = 0uLL;
          v206 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v257, 0);
          _StringGuts.appendInPlace(_:isASCII:)(v206, v207, 1);
          uint64_t v208 = 0xE000000000000000;
          goto LABEL_244;
        }
      }
      else
      {
        BOOL v107 = __OFADD__(v101, 2);
        int64_t v108 = v101 + 2;
        if (v107) {
          goto LABEL_237;
        }
      }
      if ((v99 & ~v98 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v98 & 0xFFFFFFFFFFFFFFFLL))
      {
        unint64_t v109 = (unint64_t)v258._object;
        int64_t v110 = _StringGuts.nativeUnusedCapacity.getter(v258._countAndFlagsBits, (uint64_t)v258._object);
        if (v111) {
          goto LABEL_262;
        }
        if (v108 > 15 || (v109 & 0x2000000000000000) == 0 && v110 > 1) {
          goto LABEL_106;
        }
      }
      else if (v108 > 15)
      {
LABEL_106:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v108, 2);
        swift_bridgeObjectRelease_n(0xE200000000000000, 6);
        long long v257 = xmmword_18162AFC0;
        uint64_t v112 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v257, 2);
        _StringGuts.appendInPlace(_:isASCII:)(v112, v113, 1);
        uint64_t v114 = 0xE200000000000000;
LABEL_115:
        swift_bridgeObjectRelease(v114);
        Swift::UInt64 v106 = _;
        goto LABEL_120;
      }
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      unint64_t v115 = v258._countAndFlagsBits;
      char v116 = v258._object;
      swift_bridgeObjectRetain((unint64_t)v258._object);
      unint64_t v117 = _StringGuts._convertedToSmall()(v115, (unint64_t)v116);
      unint64_t v119 = v118;
      swift_bridgeObjectRelease((uint64_t)v116);
      v120._Swift::UInt64 rawBits = 1;
      v121._Swift::UInt64 rawBits = 131073;
      v122._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v120, v121, 0x2B55uLL, 0xE200000000000000);
      if (v122._rawBits < 0x10000) {
        v122._rawBits |= 3;
      }
      unint64_t v124 = specialized String.init(_:)(v122, v123, 0x2B55uLL, 0xE200000000000000);
      unint64_t v126 = v125;
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v127 = _StringGuts._convertedToSmall()(v124, v126);
      unint64_t v129 = v128;
      swift_bridgeObjectRelease(v126);
      unint64_t v130 = specialized _SmallString.init(_:appending:)(v117, v119, v127, v129);
      if (v132) {
        goto LABEL_261;
      }
      uint64_t v133 = v130;
      v134 = v131;
      swift_bridgeObjectRelease(0xE200000000000000);
      uint64_t v114 = (uint64_t)v258._object;
      v258._uint64_t countAndFlagsBits = v133;
      v258._unint64_t object = v134;
      goto LABEL_115;
    }
    unint64_t v102 = 8 * (((unint64_t)v258._object >> 56) & 7);
    uint64_t v103 = (-255 << v102) - 1;
    uint64_t v104 = 85 << v102;
    char v105 = v100 + 1;
    if (v100 >= 8)
    {
      uint64_t v98 = v104 | v103 & (uint64_t)v258._object;
      Swift::UInt64 v106 = _;
    }
    else
    {
      uint64_t v99 = v104 | v103 & v258._countAndFlagsBits;
      Swift::UInt64 v106 = _;
      if (v100 != 7)
      {
        uint64_t v99 = (43 << (8 * (v105 & 7u))) | ((-255 << (8 * (v105 & 7u))) - 1) & v99;
        goto LABEL_117;
      }
      char v105 = 8;
    }
    uint64_t v98 = (43 << (8 * (v105 & 7u))) | ((-255 << (8 * (v105 & 7u))) - 1) & v98;
LABEL_117:
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v135 = 0xA000000000000000;
    if (!(v99 & 0x8080808080808080 | v98 & 0x80808080808080)) {
      unint64_t v135 = 0xE000000000000000;
    }
    uint64_t v136 = (void *)((v135 & 0xFF00000000000000 | (v100 << 56) | v98 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000);
    swift_bridgeObjectRelease((uint64_t)v258._object);
    v258._uint64_t countAndFlagsBits = v99;
    v258._unint64_t object = v136;
LABEL_120:
    Swift::String v137 = _uint64ToString(_:radix:uppercase:)(v106, 16, 1);
    uint64_t v7 = v137._countAndFlagsBits;
    uint64_t v138 = v258._countAndFlagsBits;
    unint64_t v139 = (unint64_t)v258._object;
    unint64_t v140 = ((unint64_t)v258._object >> 56) & 0xF;
    unint64_t v141 = v258._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v258._object & 0x2000000000000000) != 0) {
      unint64_t v141 = ((unint64_t)v258._object >> 56) & 0xF;
    }
    if (!v141 && (v258._countAndFlagsBits & ~(uint64_t)v258._object & 0x2000000000000000) == 0)
    {
      Swift::String v258 = v137;
      uint64_t v176 = v139;
LABEL_188:
      swift_bridgeObjectRelease(v176);
      goto LABEL_205;
    }
    uint64_t v4 = (uint64_t)v137._object & 0x2000000000000000;
    unint64_t v142 = ((unint64_t)v137._object >> 56) & 0xF;
    if (((uint64_t)v258._object & 0x2000000000000000) != 0 && v4)
    {
      unint64_t v143 = v140 + v142;
      if (v140 + v142 <= 0xF)
      {
        if (v142)
        {
          char v183 = 0;
          unint64_t v184 = 0;
          do
          {
            unint64_t v185 = v140 + v184;
            unint64_t v186 = v184 + 1;
            if (v184 >= 8) {
              unint64_t v187 = (unint64_t)v137._object;
            }
            else {
              unint64_t v187 = v137._countAndFlagsBits;
            }
            unint64_t v188 = v187 >> (v183 & 0x38);
            char v189 = (8 * v140 + v183) & 0x38;
            uint64_t v190 = (-255 << v189) - 1;
            unint64_t v191 = (unint64_t)v188 << v189;
            unint64_t v192 = v191 | v190 & v139;
            unint64_t v193 = v191 | v190 & v138;
            if (v185 < 8) {
              uint64_t v138 = v193;
            }
            else {
              unint64_t v139 = v192;
            }
            v183 += 8;
            unint64_t v184 = v186;
          }
          while (v142 != v186);
        }
        swift_bridgeObjectRelease((uint64_t)v137._object);
        unint64_t v194 = 0xA000000000000000;
        if (!(v138 & 0x8080808080808080 | v139 & 0x80808080808080)) {
          unint64_t v194 = 0xE000000000000000;
        }
        uint64_t v195 = (void *)(v194 & 0xFF00000000000000 | (v143 << 56) | v139 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v258._object);
        v258._uint64_t countAndFlagsBits = v138;
        v258._unint64_t object = v195;
        goto LABEL_205;
      }
      uint64_t v4 = 1;
    }
    if (v4) {
      uint64_t v144 = ((unint64_t)v137._object >> 56) & 0xF;
    }
    else {
      uint64_t v144 = v137._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v137._object, 2);
    if (((uint64_t)v137._object & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v137._object, 5);
      v216._Swift::UInt64 rawBits = 1;
      v217._Swift::UInt64 rawBits = (v144 << 16) | 1;
      v218._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v216, v217, v137._countAndFlagsBits, (unint64_t)v137._object);
      if (v218._rawBits < 0x10000) {
        v218._rawBits |= 3;
      }
      Swift::Int v145 = specialized Collection.count.getter(v218, v219, v137._countAndFlagsBits, (unint64_t)v137._object);
      swift_bridgeObjectRelease((uint64_t)v137._object);
      uint64_t v138 = v258._countAndFlagsBits;
      unint64_t v139 = (unint64_t)v258._object;
      if (((uint64_t)v258._object & 0x1000000000000000) != 0)
      {
LABEL_232:
        Swift::Int v220 = String.UTF8View._foreignCount()();
        Swift::Int v2 = v220 + v145;
        if (!__OFADD__(v220, v145)) {
          goto LABEL_138;
        }
        goto LABEL_136;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v137._object, 4);
      Swift::Int v145 = v144;
      if ((v139 & 0x1000000000000000) != 0) {
        goto LABEL_232;
      }
    }
    if ((v139 & 0x2000000000000000) == 0)
    {
      Swift::Int v2 = (v138 & 0xFFFFFFFFFFFFLL) + v145;
      if (!__OFADD__(v138 & 0xFFFFFFFFFFFFLL, v145)) {
        goto LABEL_138;
      }
      goto LABEL_136;
    }
    while (1)
    {
      uint64_t v146 = HIBYTE(v139) & 0xF;
      Swift::Int v2 = v146 + v145;
      if (!__OFADD__(v146, v145)) {
        break;
      }
LABEL_136:
      __break(1u);
    }
LABEL_138:
    if ((v138 & ~v139 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v139 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v1 = v258._countAndFlagsBits;
      unint64_t v8 = (unint64_t)v258._object;
      int64_t v147 = _StringGuts.nativeUnusedCapacity.getter(v258._countAndFlagsBits, (uint64_t)v258._object);
      if (v148) {
        goto LABEL_262;
      }
      if (v2 <= 15 && ((v8 & 0x2000000000000000) != 0 || v147 < v145))
      {
LABEL_157:
        swift_bridgeObjectRelease_n((uint64_t)v137._object, 5);
        uint64_t v153 = v258._countAndFlagsBits;
        unint64_t v152 = (unint64_t)v258._object;
        if (((uint64_t)v258._object & 0x2000000000000000) == 0)
        {
          if (((uint64_t)v258._object & 0x1000000000000000) != 0)
          {
            uint64_t v153 = _StringGuts._foreignConvertedToSmall()(v258._countAndFlagsBits, (unint64_t)v258._object);
            unint64_t v152 = v252;
          }
          else
          {
            if ((v258._countAndFlagsBits & 0x1000000000000000) != 0)
            {
              v243 = (unsigned __int8 *)(((uint64_t)v258._object & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v244 = v258._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              v243 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v258._countAndFlagsBits, (uint64_t)v258._object);
              uint64_t v244 = v253;
            }
            swift_bridgeObjectRetain(v152);
            closure #1 in _StringGuts._convertedToSmall()(v243, v244, &v257);
            swift_bridgeObjectRelease(v152);
            unint64_t v152 = *((void *)&v257 + 1);
            uint64_t v153 = v257;
          }
        }
        v154._Swift::UInt64 rawBits = (v144 << 16) | 1;
        v155._Swift::UInt64 rawBits = 1;
        v156._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v155, v154, v137._countAndFlagsBits, (unint64_t)v137._object);
        if (v156._rawBits < 0x10000) {
          v156._rawBits |= 3;
        }
        unint64_t v158 = specialized String.init(_:)(v156, v157, v137._countAndFlagsBits, (unint64_t)v137._object);
        unint64_t v160 = v159;
        swift_bridgeObjectRelease((uint64_t)v137._object);
        if ((v160 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v160);
        }
        else if ((v160 & 0x1000000000000000) != 0)
        {
          unint64_t v158 = _StringGuts._foreignConvertedToSmall()(v158, v160);
          unint64_t v255 = v254;
          swift_bridgeObjectRelease(v160);
          unint64_t v160 = v255;
        }
        else
        {
          if ((v158 & 0x1000000000000000) != 0)
          {
            v245 = (unsigned __int8 *)((v160 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v246 = v158 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            v245 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v158, v160);
          }
          closure #1 in _StringGuts._convertedToSmall()(v245, v246, &v257);
          swift_bridgeObjectRelease(v160);
          unint64_t v160 = *((void *)&v257 + 1);
          unint64_t v158 = v257;
        }
        uint64_t v161 = HIBYTE(v152) & 0xF;
        uint64_t v162 = HIBYTE(v160) & 0xF;
        uint64_t v163 = v162 + v161;
        if ((unint64_t)(v162 + v161) <= 0xF)
        {
          if (v162)
          {
            char v164 = 0;
            unint64_t v165 = 0;
            do
            {
              unint64_t v166 = v161 + v165;
              unint64_t v167 = v165 + 1;
              if (v165 >= 8) {
                unint64_t v168 = v160;
              }
              else {
                unint64_t v168 = v158;
              }
              unint64_t v169 = v168 >> (v164 & 0x38);
              char v170 = (8 * v161 + v164) & 0x38;
              uint64_t v171 = (-255 << v170) - 1;
              unint64_t v172 = (unint64_t)v169 << v170;
              unint64_t v173 = v172 | v171 & v152;
              unint64_t v174 = v172 | v171 & v153;
              if (v166 < 8) {
                uint64_t v153 = v174;
              }
              else {
                unint64_t v152 = v173;
              }
              v164 += 8;
              unint64_t v165 = v167;
            }
            while (v162 != v167);
          }
          swift_bridgeObjectRelease((uint64_t)v137._object);
          unint64_t v175 = 0xA000000000000000;
          if (!(v153 & 0x8080808080808080 | v152 & 0x80808080808080)) {
            unint64_t v175 = 0xE000000000000000;
          }
          uint64_t v176 = (uint64_t)v258._object;
          v258._uint64_t countAndFlagsBits = v153;
          v258._unint64_t object = (void *)(v175 & 0xFF00000000000000 | (v163 << 56) | v152 & 0xFFFFFFFFFFFFFFLL);
          goto LABEL_188;
        }
LABEL_261:
        unint64_t v251 = 266;
        goto LABEL_263;
      }
    }
    else
    {
      if (v2 < 16) {
        goto LABEL_157;
      }
      uint64_t v1 = v258._countAndFlagsBits;
      unint64_t v8 = (unint64_t)v258._object;
    }
    int64_t v149 = _StringGuts.nativeUnusedCapacity.getter(v1, v8);
    BOOL v151 = (v150 & 1) != 0 || v149 < v145;
    int v3 = !v151;
    if ((v1 & ~v8 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v3) {
        goto LABEL_183;
      }
    }
    else if (v3)
    {
      goto LABEL_182;
    }
    uint64_t v177 = _StringGuts.nativeCapacity.getter(v258._countAndFlagsBits, (uint64_t)v258._object);
    uint64_t v179 = (v178 & 1) != 0 ? 0 : v177;
    if (v179 + 0x4000000000000000 >= 0) {
      break;
    }
    __break(1u);
LABEL_255:
    unint64_t v16 = _StringGuts._foreignConvertedToSmall()(v7, v8);
    unint64_t v17 = v247;
LABEL_17:
    v18._Swift::UInt64 rawBits = 1;
    v19._Swift::UInt64 rawBits = 1;
    v20._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v18, v19, 0, 0xE000000000000000);
    if (v20._rawBits < 0x10000) {
      v20._rawBits |= 3;
    }
    unint64_t v22 = specialized String.init(_:)(v20, v21, 0, 0xE000000000000000);
    unint64_t v24 = v23;
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v25 = _StringGuts._convertedToSmall()(v22, v24);
    unint64_t v27 = v26;
    swift_bridgeObjectRelease(v24);
    unint64_t v28 = specialized _SmallString.init(_:appending:)(v16, v17, v25, v27);
    if (v30) {
      goto LABEL_261;
    }
    uint64_t v31 = v28;
    Swift::String::Index v32 = v29;
    swift_bridgeObjectRelease(0xE000000000000000);
    uint64_t v33 = (uint64_t)v258._object;
    v258._uint64_t countAndFlagsBits = v31;
    v258._unint64_t object = v32;
  }
  uint64_t v180 = 2 * v179;
  if (v180 > v2) {
    Swift::Int v2 = v180;
  }
LABEL_182:
  _StringGuts.grow(_:)(v2);
LABEL_183:
  swift_bridgeObjectRelease_n((uint64_t)v137._object, 4);
  if (((uint64_t)v137._object & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v137._object);
    _StringGuts._foreignAppendInPlace(_:)(v137._countAndFlagsBits, (unint64_t)v137._object, 0, v144);
  }
  else
  {
    if (v4)
    {
      swift_bridgeObjectRelease_n((uint64_t)v137._object, 2);
      *(void *)&long long v257 = v137._countAndFlagsBits;
      *((void *)&v257 + 1) = (uint64_t)v137._object & 0xFFFFFFFFFFFFFFLL;
      uint64_t v181 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v137._object >> 56) & 0xF, (uint64_t)&v257, ((unint64_t)v137._object >> 56) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v181, v182, ((uint64_t)v137._object & 0x4000000000000000) != 0);
      uint64_t v176 = (uint64_t)v137._object;
      goto LABEL_188;
    }
    if ((v137._countAndFlagsBits & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v137._object);
      id v196 = (id)(((uint64_t)v137._object & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v197 = v137._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      id v196 = _StringObject.sharedUTF8.getter(v137._countAndFlagsBits, (uint64_t)v137._object);
      uint64_t v197 = v250;
      swift_bridgeObjectRelease((uint64_t)v137._object);
      if (v197 < (v137._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
LABEL_260:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    unsigned int v198 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v137._countAndFlagsBits & 0xFFFFFFFFFFFFLL, (uint64_t)v196, v197);
    _StringGuts.appendInPlace(_:isASCII:)(v198, v199, v137._countAndFlagsBits < 0);
  }
  swift_bridgeObjectRelease_n((uint64_t)v137._object, 2);
LABEL_205:
  uint64_t v99 = v258._countAndFlagsBits;
  uint64_t v98 = (uint64_t)v258._object;
  unint64_t v200 = ((unint64_t)v258._object >> 56) & 0xF;
  Swift::Int v201 = v258._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v258._object & 0x2000000000000000) != 0) {
    unint64_t v202 = ((unint64_t)v258._object >> 56) & 0xF;
  }
  else {
    unint64_t v202 = v258._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v202 && (v258._countAndFlagsBits & ~(uint64_t)v258._object & 0x2000000000000000) == 0)
  {
    v258._uint64_t countAndFlagsBits = 0;
    v258._unint64_t object = (void *)0xE000000000000000;
    uint64_t v208 = v98;
    goto LABEL_244;
  }
  if (((uint64_t)v258._object & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v209 = 0xA000000000000000;
    if (!(v98 & 0x80808080808080 | v99 & 0x8080808080808080)) {
      unint64_t v209 = 0xE000000000000000;
    }
    v210 = (void *)(v209 & 0xFF00000000000000 | (v200 << 56) | v98 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v258._object);
    v258._uint64_t countAndFlagsBits = v99;
    v258._unint64_t object = v210;
    return v258._countAndFlagsBits;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6);
  if ((v98 & 0x1000000000000000) != 0) {
    goto LABEL_238;
  }
  if ((v99 & ~v98 & 0x2000000000000000) != 0) {
    goto LABEL_213;
  }
LABEL_239:
  if (v201 > 15) {
    goto LABEL_218;
  }
LABEL_240:
  swift_bridgeObjectRelease_n(0xE000000000000000, 5);
  unint64_t v222 = v258._countAndFlagsBits;
  unsigned __int8 v223 = v258._object;
  swift_bridgeObjectRetain((unint64_t)v258._object);
  unint64_t v224 = _StringGuts._convertedToSmall()(v222, (unint64_t)v223);
  unint64_t v226 = v225;
  swift_bridgeObjectRelease((uint64_t)v223);
  v227._Swift::UInt64 rawBits = 1;
  v228._Swift::UInt64 rawBits = 1;
  v229._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v227, v228, 0, 0xE000000000000000);
  if (v229._rawBits < 0x10000) {
    v229._rawBits |= 3;
  }
  unint64_t v231 = specialized String.init(_:)(v229, v230, 0, 0xE000000000000000);
  unint64_t v233 = v232;
  swift_bridgeObjectRelease(0xE000000000000000);
  unint64_t v234 = _StringGuts._convertedToSmall()(v231, v233);
  unint64_t v236 = v235;
  swift_bridgeObjectRelease(v233);
  unint64_t v237 = specialized _SmallString.init(_:appending:)(v224, v226, v234, v236);
  if (v239) {
    goto LABEL_261;
  }
  uint64_t v240 = v237;
  v241 = v238;
  swift_bridgeObjectRelease(0xE000000000000000);
  uint64_t v208 = (uint64_t)v258._object;
  v258._uint64_t countAndFlagsBits = v240;
  v258._unint64_t object = v241;
LABEL_244:
  swift_bridgeObjectRelease(v208);
  return v258._countAndFlagsBits;
}

uint64_t _ValidUTF8Buffer._biasedBits.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _ValidUTF8Buffer.Iterator._biasedBits.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer.Iterator._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt8_optional __swiftcall _ValidUTF8Buffer.Iterator.next()()
{
  unsigned int v1 = *v0;
  if (*v0)
  {
    unsigned __int8 v2 = v1 - 1;
    unsigned int *v0 = v1 >> 8;
  }
  else
  {
    unsigned __int8 v2 = 0;
  }
  return (Swift::UInt8_optional)(v2 | ((v1 == 0) << 8));
}

void protocol witness for IteratorProtocol.next() in conformance _ValidUTF8Buffer.Iterator(unsigned char *a1@<X8>)
{
  unsigned int v2 = *v1;
  if (*v1)
  {
    char v3 = v2 - 1;
    *unsigned int v1 = v2 >> 8;
  }
  else
  {
    char v3 = 0;
  }
  *a1 = v3;
  a1[1] = v2 == 0;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _ValidUTF8Buffer.Iterator()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _ValidUTF8Buffer.Iterator(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _ValidUTF8Buffer.Iterator@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySuqd__Isgyrzo_s4Int8V5WordsVABsAG_pAKRszr__lIetMgyrzo_Tpq5Tm(a1, a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _ValidUTF8Buffer()
{
  return 4 - (__clz(*v0) >> 3);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _ValidUTF8Buffer()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t _ValidUTF8Buffer.Index._biasedBits.setter(uint64_t result)
{
  *unsigned int v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer.Index._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

BOOL static _ValidUTF8Buffer.Index.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

BOOL static _ValidUTF8Buffer.Index.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _ValidUTF8Buffer.Index(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _ValidUTF8Buffer.Index(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _ValidUTF8Buffer.Index(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

uint64_t _ValidUTF8Buffer.endIndex.getter()
{
  return 0;
}

uint64_t static Int.&>> infix(_:_:)(uint64_t a1, char a2)
{
  return a1 >> a2;
}

BOOL _ValidUTF8Buffer.isEmpty.getter(int a1)
{
  return a1 == 0;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(after:)(Swift::_ValidUTF8Buffer::Index after)
{
  if (!after._biasedBits) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x69uLL, 0);
  }
  return (Swift::_ValidUTF8Buffer::Index)(after._biasedBits >> 8);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _ValidUTF8Buffer(unsigned char *a1, unsigned char *a2))()
{
  *a1 = *a2 - 1;
  return EnumeratedSequence._base.modify;
}

_DWORD *protocol witness for Collection.subscript.getter in conformance _ValidUTF8Buffer@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v3 = *v2;
  if (*v2 < *result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  int v4 = result[1];
  *a2 = *result;
  a2[1] = v4;
  a2[2] = v3;
  return result;
}

void protocol witness for Collection.indices.getter in conformance _ValidUTF8Buffer(uint64_t a1@<X8>)
{
  unsigned int v2 = *v1;
  *(_DWORD *)a1 = *v1;
  *(void *)(a1 + 4) = v2;
}

void protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance _ValidUTF8Buffer(uint64_t a1@<X8>)
{
  *(_WORD *)(a1 + 4) = 256;
  *(_DWORD *)a1 = 0;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer(a1, a2, (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, a3);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer(a1, a2, a3, a4, (uint64_t)closure #1 in Sequence<>.contains(_:)specialized partial apply, (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply);
}

Swift::Int __swiftcall _ValidUTF8Buffer.distance(from:to:)(Swift::_ValidUTF8Buffer::Index from, Swift::_ValidUTF8Buffer::Index to)
{
  unsigned int v3 = v2;
  Swift::UInt32 biasedBits = from._biasedBits;
  if (from._biasedBits)
  {
    Swift::UInt32 v10 = from._biasedBits;
    MEMORY[0x1F4188790](*(void *)&from._biasedBits);
    uint64_t v9 = &v10;
    *(void *)&from._Swift::UInt32 biasedBits = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v8, v3 | ((unint64_t)v3 << 32), 0);
    if ((from._biasedBits & 1) == 0)
    {
      LODWORD(v9) = 0;
      unint64_t v7 = 130;
      goto LABEL_8;
    }
  }
  if (to._biasedBits)
  {
    Swift::UInt32 v10 = to._biasedBits;
    MEMORY[0x1F4188790](*(void *)&from._biasedBits);
    uint64_t v9 = &v10;
    if ((specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v8, v3 | ((unint64_t)v3 << 32), 0) & 1) == 0)
    {
      LODWORD(v9) = 0;
      unint64_t v7 = 131;
LABEL_8:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v7, (int)v9);
    }
  }
  return (uint64_t)(__clz(biasedBits) - (unint64_t)__clz(to._biasedBits)) >> 3;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ValidUTF8Buffer(unsigned int *a1, uint64_t *a2)
{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2);
}

_DWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ValidUTF8Buffer(_DWORD *result, _DWORD *a2)
{
  if (*a2 < *result || *result < a2[1]) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

{
  if (*a2 < *result || result[1] < a2[1]) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  return result;
}

_DWORD *protocol witness for Collection.index(after:) in conformance _ValidUTF8Buffer@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  if (!*result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x69uLL, 0);
  }
  *a2 = *result >> 8;
  return result;
}

_DWORD *protocol witness for Collection.formIndex(after:) in conformance _ValidUTF8Buffer(_DWORD *result)
{
  if (!*result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x69uLL, 0);
  }
  *result >>= 8;
  return result;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(before:)(Swift::_ValidUTF8Buffer::Index before)
{
  char v2 = __clz(before._biasedBits);
  if ((v2 & 0x38) == 0x20) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x77uLL, 0);
  }
  return (Swift::_ValidUTF8Buffer::Index)(v1 >> (~v2 & 0x18));
}

Swift::_ValidUTF8Buffer::Index protocol witness for BidirectionalCollection.index(before:) in conformance _ValidUTF8Buffer@<W0>(Swift::_ValidUTF8Buffer::Index *a1@<X0>, Swift::_ValidUTF8Buffer::Index *a2@<X8>)
{
  result._Swift::UInt32 biasedBits = _ValidUTF8Buffer.index(before:)((Swift::_ValidUTF8Buffer::Index)a1->_biasedBits)._biasedBits;
  a2->_Swift::UInt32 biasedBits = result._biasedBits;
  return result;
}

unsigned int *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _ValidUTF8Buffer(unsigned int *result)
{
  char v2 = __clz(*result);
  if ((v2 & 0x38) == 0x20) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x77uLL, 0);
  }
  *Swift::_ValidUTF8Buffer::Index result = *v1 >> (~v2 & 0x18);
  return result;
}

Swift::Bool __swiftcall _ValidUTF8Buffer._isValid(_:)(Swift::_ValidUTF8Buffer::Index a1)
{
  if (a1._biasedBits)
  {
    Swift::UInt32 biasedBits = a1._biasedBits;
    MEMORY[0x1F4188790](*(void *)&a1._biasedBits);
    v3[2] = &biasedBits;
    return specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v3, v1 | ((unint64_t)v1 << 32), 0) & 1;
  }
  else
  {
    return 1;
  }
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned int (*a3)(int *)@<X5>, unsigned int *a4@<X8>)
{
  unsigned int v8 = *(_DWORD *)result;
  uint64_t v9 = *v4;
  if (v9)
  {
    unsigned int v18 = v9;
    MEMORY[0x1F4188790](result);
    unint64_t v17 = &v18;
    Swift::_ValidUTF8Buffer::Index result = specialized Sequence.contains(where:)(v10, (uint64_t)v16, v9 | (v9 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v17) = 0;
      unint64_t v15 = 130;
      goto LABEL_14;
    }
  }
  if (v8)
  {
    unsigned int v18 = v8;
    MEMORY[0x1F4188790](result);
    unint64_t v17 = &v18;
    Swift::_ValidUTF8Buffer::Index result = specialized Sequence.contains(where:)(a3, (uint64_t)v16, v9 | (v9 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v17) = 0;
      unint64_t v15 = 131;
LABEL_14:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v15, (int)v17);
    }
  }
  unint64_t v11 = __clz(v9);
  uint64_t v12 = __clz(v8);
  BOOL v13 = __OFADD__(a2, (uint64_t)(v11 - v12) >> 3);
  unint64_t v14 = a2 + ((uint64_t)(v11 - v12) >> 3);
  if (v13)
  {
    __break(1u);
    goto LABEL_10;
  }
  if ((v14 & 0x8000000000000000) != 0)
  {
LABEL_10:
    LODWORD(v17) = 0;
    unint64_t v15 = 142;
    goto LABEL_14;
  }
  if (4 - (v11 >> 3) < v14)
  {
    LODWORD(v17) = 0;
    unint64_t v15 = 143;
    goto LABEL_14;
  }
  *a4 = v9 >> (4 * (v14 & 7)) >> (4 * (v14 & 7));
  return result;
}

unint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance _ValidUTF8Buffer@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3, *v4);
  *(_DWORD *)a4 = result;
  *(unsigned char *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int (*a6)(int *))
{
  unsigned int v8 = *(_DWORD *)a1;
  unsigned int v9 = *a2;
  unint64_t v10 = *v6 | ((unint64_t)*v6 << 32);
  if (*(_DWORD *)a1)
  {
    unsigned int v16 = *(_DWORD *)a1;
    MEMORY[0x1F4188790](a1);
    unint64_t v15 = &v16;
    a1 = specialized Sequence.contains(where:)(v11, (uint64_t)v14, v10, 0);
    if ((a1 & 1) == 0)
    {
      LODWORD(v15) = 0;
      unint64_t v13 = 130;
      goto LABEL_8;
    }
  }
  if (v9)
  {
    unsigned int v16 = v9;
    MEMORY[0x1F4188790](a1);
    unint64_t v15 = &v16;
    if ((specialized Sequence.contains(where:)(a6, (uint64_t)v14, v10, 0) & 1) == 0)
    {
      LODWORD(v15) = 0;
      unint64_t v13 = 131;
LABEL_8:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v13, (int)v15);
    }
  }
  return (uint64_t)(__clz(v8) - (unint64_t)__clz(v9)) >> 3;
}

Swift::_ValidUTF8Buffer __swiftcall _ValidUTF8Buffer.init()()
{
  return 0;
}

uint64_t _ValidUTF8Buffer.capacity.getter()
{
  return 4;
}

uint64_t static _ValidUTF8Buffer.capacity.getter()
{
  return 4;
}

uint64_t static UInt8.bitWidth.getter()
{
  return 8;
}

Swift::Void __swiftcall _ValidUTF8Buffer.append(_:)(Swift::UInt8 a1)
{
  if (HIBYTE(*v1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
  }
  *v1 |= (a1 + 1) << (-(__clz(*v1) & 0x18) & 0x18);
}

Swift::UInt8 __swiftcall _ValidUTF8Buffer.removeFirst()()
{
  unsigned int v1 = *v0;
  if (!*v0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xB1uLL, 0);
  }
  Swift::UInt8 result = v1 - 1;
  unsigned int *v0 = v1 >> 8;
  return result;
}

uint64_t _ValidUTF8Buffer.replaceSubrange<A>(_:with:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v21)(uint64_t *__return_ptr, const char *, uint64_t);
  char v22;
  uint64_t result;
  unint64_t v24;
  BOOL v25;
  unsigned int v26;
  const char *v27;
  unint64_t v28;
  char v29[8];
  unint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  uint64_t v36;

  uint64_t v33 = *(void *)(a3 - 8);
  unint64_t v34 = a2;
  MEMORY[0x1F4188790](a1);
  unint64_t v7 = (char *)&v32 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *(void *)(v8 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v12 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v13 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v15 = (char *)&v32 - v14;
  Swift::String::Index v35 = v3;
  Swift::String::Index v32 = v12;
  if (a1)
  {
    LODWORD(v36) = a1;
    MEMORY[0x1F4188790](v13);
    uint64_t v31 = &v36;
    uint64_t v13 = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v29, v16 | (v16 << 32), 0);
    if ((v13 & 1) == 0)
    {
      LODWORD(v31) = 0;
      unint64_t v28 = 193;
      goto LABEL_27;
    }
  }
  if (HIDWORD(a1))
  {
    LODWORD(v36) = HIDWORD(a1);
    MEMORY[0x1F4188790](v13);
    uint64_t v31 = &v36;
    if ((specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v29, v17 | (v17 << 32), 0) & 1) == 0)
    {
      LODWORD(v31) = 0;
      unint64_t v28 = 194;
      goto LABEL_27;
    }
  }
  unsigned int v18 = *v35;
  if (*v35 < a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  unsigned int v19 = 0;
  if (v18 != a1)
  {
    unint64_t v26 = *v35;
    while (v18 >= v26 && v26 > a1)
    {
      if (HIBYTE(v19)) {
        goto LABEL_26;
      }
      v19 |= v26 << (-(__clz(v19) & 0x18) & 0x18);
      v26 >>= 8;
      if (v26 == a1) {
        goto LABEL_8;
      }
    }
    goto LABEL_24;
  }
LABEL_8:
  (*(void (**)(char *, uint64_t, uint64_t))(v33 + 16))(v7, v34, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 32))(a3, v9);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  Swift::String::Index v21 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v21(&v36, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v36 & 0x100) == 0)
  {
    unint64_t v22 = v36;
    while (!HIBYTE(v19))
    {
      v19 |= (v22 + 1) << (-(__clz(v19) & 0x18) & 0x18);
      v21(&v36, AssociatedTypeWitness, AssociatedConformanceWitness);
      unint64_t v22 = v36;
      if (BYTE1(v36) == 1) {
        goto LABEL_12;
      }
    }
LABEL_26:
    LODWORD(v31) = 0;
    unint64_t v28 = 167;
LABEL_27:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v28, (int)v31);
  }
LABEL_12:
  Swift::UInt8 result = (*(uint64_t (**)(char *, const char *))(v32 + 8))(v15, AssociatedTypeWitness);
  if (*v35 < HIDWORD(a1))
  {
    LODWORD(v31) = 0;
    char v30 = 730;
    v29[0] = 2;
    unint64_t v27 = "Range out of bounds";
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v27, 19, 2, "Swift/Collection.swift", 22, v29[0], v30, (int)v31);
  }
  if (HIDWORD(a1))
  {
    unint64_t v24 = HIDWORD(a1);
    while (v24 <= HIDWORD(a1))
    {
      if (HIBYTE(v19)) {
        goto LABEL_26;
      }
      v19 |= v24 << (-(__clz(v19) & 0x18) & 0x18);
      unint64_t v25 = v24 > 0xFF;
      LODWORD(v24) = v24 >> 8;
      if (!v25) {
        goto LABEL_18;
      }
    }
LABEL_24:
    LODWORD(v31) = 0;
    char v30 = 714;
    v29[0] = 2;
    unint64_t v27 = "Index out of bounds";
    goto LABEL_25;
  }
LABEL_18:
  *Swift::String::Index v35 = v19;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance _ValidUTF8Buffer(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  void (*v24)(uint64_t *__return_ptr, const char *, uint64_t);
  char v25;
  uint64_t result;
  unsigned int *v27;
  unsigned int v28;
  BOOL v29;
  unint64_t v30;
  char v31[8];
  uint64_t *v32;
  uint64_t v33;
  unsigned int *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  size_t v36 = a2;
  int v38 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  Swift::String::Index v35 = (char *)&v33 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(void *)(v6 + 8);
  int v37 = v8;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v33 - v12;
  uint64_t v15 = *a1;
  uint64_t v14 = a1[1];
  unint64_t v16 = *v3 | ((unint64_t)*v3 << 32);
  if (v15)
  {
    LODWORD(v39) = v15;
    MEMORY[0x1F4188790](v11);
    Swift::String::Index v32 = &v39;
    uint64_t v11 = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v31, v16, 0);
    if ((v11 & 1) == 0)
    {
      LODWORD(v32) = 0;
      char v30 = 193;
      goto LABEL_23;
    }
  }
  if (v14)
  {
    LODWORD(v39) = v14;
    MEMORY[0x1F4188790](v11);
    Swift::String::Index v32 = &v39;
    if ((specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v31, v16, 0) & 1) == 0)
    {
      LODWORD(v32) = 0;
      char v30 = 194;
      goto LABEL_23;
    }
  }
  uint64_t v17 = *v3;
  if (v17 < v15) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v33 = v10;
  unint64_t v34 = v3;
  unsigned int v18 = 0;
  if (v17 != v15)
  {
    unsigned int v19 = v17;
    while (1)
    {
      char v20 = specialized Slice.subscript.getter(v19, v17 | (v15 << 32));
      if (!v19) {
        break;
      }
      if (HIBYTE(v18)) {
        goto LABEL_21;
      }
      v19 >>= 8;
      v18 |= (v20 + 1) << (-(__clz(v18) & 0x18) & 0x18);
      if (v19 == v15) {
        goto LABEL_11;
      }
    }
    LODWORD(v32) = 0;
    char v30 = 105;
LABEL_23:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v30, (int)v32);
  }
LABEL_11:
  uint64_t v21 = v37;
  uint64_t v22 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v38 + 16))(v35, v36, v37);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v21, v7);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v21, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v24 = *(void (**)(uint64_t *__return_ptr, const char *, uint64_t))(AssociatedConformanceWitness + 16);
  v24(&v39, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v39 & 0x100) == 0)
  {
    unint64_t v25 = v39;
    while (!HIBYTE(v18))
    {
      v18 |= (v25 + 1) << (-(__clz(v18) & 0x18) & 0x18);
      v24(&v39, AssociatedTypeWitness, AssociatedConformanceWitness);
      unint64_t v25 = v39;
      if (BYTE1(v39) == 1) {
        goto LABEL_15;
      }
    }
    goto LABEL_21;
  }
LABEL_15:
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v22, v21);
  Swift::UInt8 result = (*(uint64_t (**)(char *, const char *))(v33 + 8))(v13, AssociatedTypeWitness);
  unint64_t v27 = v34;
  if (*v34 < v14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  if (v14)
  {
    unint64_t v28 = v14;
    while (1)
    {
      Swift::UInt8 result = specialized Slice.subscript.getter(v28, v14);
      if (HIBYTE(v18)) {
        break;
      }
      v18 |= (result + 1) << (-(__clz(v18) & 0x18) & 0x18);
      unint64_t v29 = v28 > 0xFF;
      v28 >>= 8;
      if (!v29) {
        goto LABEL_20;
      }
    }
LABEL_21:
    LODWORD(v32) = 0;
    char v30 = 167;
    goto LABEL_23;
  }
LABEL_20:
  *unint64_t v27 = v18;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance _ValidUTF8Buffer@<X0>(char *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance _ValidUTF8Buffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  return result;
}

unsigned char *protocol witness for RangeReplaceableCollection.append(_:) in conformance _ValidUTF8Buffer(unsigned char *result)
{
  if (HIBYTE(*v1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
  }
  *v1 |= (*result + 1) << (-(__clz(*v1) & 0x18) & 0x18);
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance _ValidUTF8Buffer(unsigned __int8 *a1, unsigned int *a2)
{
  return specialized RangeReplaceableCollection.insert(_:at:)(*a1, *a2);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance _ValidUTF8Buffer(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(a1, *a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance _ValidUTF8Buffer@<X0>(unsigned int *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance _ValidUTF8Buffer(uint64_t *a1)
{
  return specialized RangeReplaceableCollection.removeSubrange(_:)(*a1);
}

void protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance _ValidUTF8Buffer(_WORD *a1@<X8>)
{
  *a1 = 256;
}

void protocol witness for RangeReplaceableCollection.removeFirst() in conformance _ValidUTF8Buffer(unsigned char *a1@<X8>)
{
  unsigned int v2 = *v1;
  if (!*v1) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xB1uLL, 0);
  }
  *unsigned int v1 = v2 >> 8;
  *a1 = v2 - 1;
}

uint64_t protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance _ValidUTF8Buffer(uint64_t a1)
{
  return specialized RangeReplaceableCollection.removeAll(where:)(a1);
}

Swift::Void __swiftcall _ValidUTF8Buffer.append(contentsOf:)(Swift::_ValidUTF8Buffer contentsOf)
{
  unint64_t v2 = 4 - (__clz(*v1) >> 3);
  if (v2 > __clz(contentsOf._biasedBits) >> 3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xCFuLL, 0);
  }
  *v1 |= contentsOf._biasedBits << (8 * (v2 & 3));
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(_:)(a1, a2, a3, (uint64_t (*)(void, uint64_t, void))type metadata accessor for Range, a4);
}

uint64_t ClosedRange<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(_:)(a1, a2, a3, (uint64_t (*)(void, uint64_t, void))type metadata accessor for ClosedRange, a4);
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(void, uint64_t, void)@<X4>, uint64_t a5@<X8>)
{
  uint64_t v7 = a4(0, a2, *(void *)(a3 + 8));
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32);

  return v8(a5, a1, v7);
}

void String.characters.setter(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease(v2[1]);
  *unint64_t v2 = a1;
  v2[1] = a2;
}

void (*String.characters.modify(void *a1))(uint64_t *a1, char a2)
{
  a1[2] = v1;
  unint64_t v3 = v1[1];
  *a1 = *v1;
  a1[1] = v3;
  swift_bridgeObjectRetain(v3);
  return String.utf16.modify;
}

uint64_t String.withMutableCharacters<A>(_:)(uint64_t (*a1)(uint64_t))
{
  return a1(v1);
}

uint64_t Substring.characters.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a1;
}

unint64_t key path getter for Substring.utf8 : Substring@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v2 = *(void *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v3;
  *(void *)(a2 + 24) = v2;
  return swift_bridgeObjectRetain(v2);
}

__n128 key path setter for Substring.characters : Substring(__n128 *a1, __n128 *a2)
{
  __n128 v7 = *a1;
  unint64_t v4 = a1[1].n128_u64[0];
  unint64_t v3 = a1[1].n128_u64[1];
  uint64_t v5 = a2[1].n128_i64[1];
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v5);
  __n128 result = v7;
  *a2 = v7;
  a2[1].n128_u64[0] = v4;
  a2[1].n128_u64[1] = v3;
  return result;
}

void Substring.unicodeScalars.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  swift_bridgeObjectRelease(v4[3]);
  *unint64_t v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

void (*Substring.characters.modify(void *a1))(uint64_t **a1, char a2)
{
  unint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)unint64_t v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4);
  return Substring.unicodeScalars.modify;
}

uint64_t Substring.withMutableCharacters<A>(_:)(uint64_t (*a1)(uint64_t))
{
  return a1(v1);
}

uint64_t Substring.customPlaygroundQuickLook.getter@<X0>(Swift::String::Index a1@<X0>, Swift::String::Index a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result = specialized String.init(_:)(a1, a2, a3, a4);
  *(void *)a5 = result;
  *(void *)(a5 + 8) = v7;
  *(unsigned char *)(a5 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Substring@<X0>(uint64_t a1@<X8>)
{
  v3._Swift::UInt64 rawBits = *v1;
  v4._Swift::UInt64 rawBits = v1[1];
  uint64_t result = specialized String.init(_:)(v3, v4, v1[2], v1[3]);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v6;
  *(unsigned char *)(a1 + 32) = 0;
  return result;
}

uint64_t Collection.index<A>(_:offsetBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v98 = a3;
  uint64_t v96 = a7;
  uint64_t v97 = a1;
  unint64_t v90 = *(int ***)(*(void *)(a6 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v90, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v88 = (char *)&v87 - v12;
  uint64_t v13 = *(void *)(a4 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  unint64_t v91 = (char *)&v87 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v95 = (char *)&v87 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v100 = (char *)&v87 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  id v94 = (char *)&v87 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  unint64_t v93 = (char *)&v87 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v26 = (char *)&v87 - v25;
  MEMORY[0x1F4188790](v24);
  unint64_t v28 = (char *)&v87 - v27;
  uint64_t v102 = v13;
  unint64_t v29 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v29((char *)&v87 - v27, a2, a4);
  unint64_t v101 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  LOBYTE(a2) = v101(a4, a6);
  uint64_t v103 = (void (*)(char *, char *, uint64_t))v29;
  v29(v26, (uint64_t)v28, a4);
  uint64_t v99 = a5;
  if ((a2 & 1) == 0)
  {
    uint64_t v104 = *(void (**)(char *, uint64_t))(v13 + 8);
    v104(v26, a4);
    uint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v43 = v42(a4, a6);
    goto LABEL_22;
  }
  unint64_t v92 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
  uint64_t v30 = v92(a4, a6);
  Swift::String::Index v32 = *(void (**)(char *, uint64_t))(v13 + 8);
  uint64_t v31 = v13 + 8;
  uint64_t v104 = v32;
  v32(v26, a4);
  if (v30 > 64)
  {
    uint64_t v87 = v31;
    uint64_t v33 = v93;
    v103(v93, v28, a4);
    v106[0] = 0x8000000000000000;
    unint64_t v34 = v101;
    if (v101(a4, a6))
    {
      uint64_t v35 = v92(a4, a6);
      if (v35 < 64)
      {
        int v38 = v94;
        v103(v94, v33, a4);
        uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
        uint64_t v40 = v104;
        v104(v38, a4);
        unint64_t v41 = v33;
        goto LABEL_16;
      }
      unint64_t v91 = *(char **)(a6 + 96);
      unint64_t v53 = lazy protocol witness table accessor for type Int and conformance Int(v35, v36, v37);
      unint64_t v50 = v94;
      ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v91)(v106, &type metadata for Int, v53, a4, a6);
      uint64_t v51 = v33;
      char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v33, v50, a4);
      goto LABEL_11;
    }
    char v44 = v34(a4, a6);
    uint64_t v45 = v92(a4, a6);
    if (v44)
    {
      if (v45 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        char v57 = v90;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v90, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v60 = v88;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        unint64_t v61 = v94;
        ((void (*)(char *, uint64_t, int **))v57[3])(v60, a4, v57);
        unint64_t v62 = v93;
        LODWORD(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8)
                                                                          + 16))(v93, v61, a4);
        uint64_t v40 = v104;
        v104(v61, a4);
        unint64_t v63 = v91;
        v103(v91, v62, a4);
        if (v90)
        {
          v40(v63, a4);
          goto LABEL_38;
        }
        uint64_t v64 = v106[0];
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
        v40(v63, a4);
        unint64_t v41 = v93;
        if (v65 < v64) {
          goto LABEL_38;
        }
LABEL_20:
        v40(v41, a4);
        goto LABEL_21;
      }
      uint64_t v48 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      unint64_t v49 = lazy protocol witness table accessor for type Int and conformance Int(v45, v46, v47);
      unint64_t v50 = v94;
      v48(v106, &type metadata for Int, v49, a4, a6);
      uint64_t v51 = v93;
      char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v93, v50, a4);
LABEL_11:
      char v54 = v52;
      unint64_t v55 = v50;
      uint64_t v40 = v104;
      v104(v55, a4);
      unint64_t v41 = v51;
      if (v54) {
        goto LABEL_38;
      }
      goto LABEL_20;
    }
    if (v45 < 64)
    {
      int64_t v56 = v94;
      v103(v94, v93, a4);
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      uint64_t v40 = v104;
      v104(v56, a4);
      unint64_t v41 = v93;
LABEL_16:
      if (v39 < v106[0]) {
LABEL_38:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_20;
    }
    v104(v93, a4);
  }
LABEL_21:
  uint64_t v42 = v92;
  uint64_t v43 = v92(a4, a6);
LABEL_22:
  uint64_t v66 = v43;
  Swift::String::Index v67 = v100;
  v103(v100, v28, a4);
  if (v66 < 65)
  {
    Swift::String::Index v68 = v42;
    uint64_t v78 = v42(a4, a6);
    v104(v67, a4);
    if (v78 != 64) {
      goto LABEL_35;
    }
    unint64_t v69 = v101;
    if (v101(a4, a6)) {
      goto LABEL_35;
    }
  }
  else
  {
    Swift::String::Index v68 = v42;
    v104(v67, a4);
    unint64_t v69 = v101;
  }
  unint64_t v70 = v95;
  v103(v95, v28, a4);
  v106[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v71 = v69(a4, a6);
  uint64_t v72 = v68(a4, a6);
  if ((v71 & 1) == 0)
  {
    if (v72 > 63)
    {
      uint64_t v105 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v75 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
      char v77 = &v105;
      goto LABEL_33;
    }
LABEL_31:
    unint64_t v79 = v94;
    v103(v94, v70, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    unint64_t v80 = v79;
    char v81 = v104;
    v104(v80, a4);
    v81(v70, a4);
    goto LABEL_35;
  }
  if (v72 <= 64) {
    goto LABEL_31;
  }
  unint64_t v75 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  char v77 = v106;
LABEL_33:
  unint64_t v82 = v94;
  v75(v77, &type metadata for Int, v76, a4, a6);
  char v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v82, v70, a4);
  unint64_t v84 = v104;
  v104(v82, a4);
  if (v83) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v84(v95, a4);
LABEL_35:
  uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
  v104(v28, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v99 + 136))(v97, v85, v98);
}

uint64_t Collection.formIndex<A>(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int **a5, uint64_t a6)
{
  unint64_t v91 = *(int ***)(*(void *)(a6 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v91, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v88 = (char *)&v87 - v12;
  unint64_t v100 = a5;
  uint64_t v99 = a3;
  uint64_t v13 = swift_getAssociatedTypeWitness(0, a5, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v97 = *((void *)v13 - 1);
  uint64_t v98 = v13;
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v96 = (char *)&v87 - v15;
  uint64_t v16 = *(void *)(a4 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  unint64_t v89 = (char *)&v87 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  unint64_t v93 = (char *)&v87 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v102 = (char *)&v87 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  id v94 = (char *)&v87 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v95 = (char *)&v87 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v29 = (char *)&v87 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v31 = (char *)&v87 - v30;
  uint64_t v104 = v16;
  Swift::String::Index v32 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v32((char *)&v87 - v30, a2, a4);
  uint64_t v103 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  LOBYTE(a2) = v103(a4, a6);
  uint64_t v105 = (void (*)(char *, char *, uint64_t))v32;
  v32(v29, (uint64_t)v31, a4);
  uint64_t v101 = a1;
  if ((a2 & 1) == 0)
  {
    Swift::UInt64 v106 = *(void (**)(char *, uint64_t))(v16 + 8);
    v106(v29, a4);
    uint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    goto LABEL_22;
  }
  unint64_t v92 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
  uint64_t v33 = v92(a4, a6);
  Swift::UInt64 v106 = *(void (**)(char *, uint64_t))(v16 + 8);
  v106(v29, a4);
  if (v33 > 64)
  {
    v105(v95, v31, a4);
    v108[0] = 0x8000000000000000;
    unint64_t v34 = v103;
    if (v103(a4, a6))
    {
      uint64_t v35 = v92(a4, a6);
      if (v35 < 64)
      {
        int v38 = v94;
        v105(v94, v95, a4);
        uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
        uint64_t v40 = v106;
        v106(v38, a4);
        unint64_t v41 = v95;
        if (v39 < v108[0]) {
          goto LABEL_38;
        }
        goto LABEL_20;
      }
LABEL_10:
      unint64_t v91 = *(int ***)(a6 + 96);
      unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v35, v36, v37);
      uint64_t v45 = v94;
      ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v91)(v108, &type metadata for Int, v44, a4, a6);
      unint64_t v41 = v95;
      char v46 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v95, v45, a4);
      uint64_t v47 = v45;
      uint64_t v40 = v106;
      v106(v47, a4);
      if (v46) {
        goto LABEL_38;
      }
LABEL_20:
      v40(v41, a4);
      goto LABEL_21;
    }
    char v43 = v34(a4, a6);
    uint64_t v35 = v92(a4, a6);
    if (v43)
    {
      if (v35 > 64) {
        goto LABEL_10;
      }
      char v52 = AssociatedTypeWitness;
      unint64_t v53 = v91;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v91, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v55 = v88;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v52, AssociatedConformanceWitness);
      int64_t v56 = v53;
      char v57 = v53[3];
      uint64_t v58 = v94;
      ((void (*)(char *, uint64_t, int **))v57)(v55, a4, v56);
      LODWORD(v91) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v95, v58, a4);
      uint64_t v40 = v106;
      v106(v58, a4);
      size_t v59 = v89;
      v105(v89, v95, a4);
      if (v91)
      {
        v40(v59, a4);
        goto LABEL_38;
      }
      unint64_t v91 = (int **)v108[0];
      uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v40(v59, a4);
      BOOL v61 = v60 < (uint64_t)v91;
      unint64_t v41 = v95;
      if (!v61) {
        goto LABEL_20;
      }
LABEL_38:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    }
    if (v35 < 64)
    {
      uint64_t v48 = v94;
      unint64_t v49 = v95;
      v105(v94, v95, a4);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      uint64_t v51 = v48;
      unint64_t v41 = v49;
      uint64_t v40 = v106;
      v106(v51, a4);
      if (v50 >= v108[0]) {
        goto LABEL_20;
      }
      goto LABEL_38;
    }
    v106(v95, a4);
  }
LABEL_21:
  uint64_t v42 = v92;
LABEL_22:
  uint64_t v62 = v42(a4, a6);
  unint64_t v63 = v102;
  v105(v102, v31, a4);
  if (v62 < 65)
  {
    uint64_t v64 = v42;
    uint64_t v74 = v42(a4, a6);
    v106(v63, a4);
    if (v74 != 64 || (v103(a4, a6) & 1) != 0) {
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v64 = v42;
    v106(v63, a4);
  }
  uint64_t v65 = v93;
  v105(v93, v31, a4);
  v108[0] = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v66 = v65;
  LOBYTE(v65) = v103(a4, a6);
  uint64_t v67 = v64(a4, a6);
  if ((v65 & 1) == 0)
  {
    if (v67 > 63)
    {
      uint64_t v107 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v70 = v66;
      char v71 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      uint64_t v73 = &v107;
      goto LABEL_33;
    }
LABEL_31:
    unint64_t v75 = v94;
    v105(v94, v66, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    unint64_t v76 = v75;
    char v77 = v106;
    v106(v76, a4);
    v77(v66, a4);
    goto LABEL_35;
  }
  if (v67 <= 64) {
    goto LABEL_31;
  }
  unint64_t v70 = v66;
  char v71 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
  uint64_t v73 = v108;
LABEL_33:
  uint64_t v78 = v94;
  v71(v73, &type metadata for Int, v72, a4, a6);
  char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8) + 16))(v78, v70, a4);
  unint64_t v80 = v106;
  v106(v78, a4);
  if (v79) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v80(v70, a4);
LABEL_35:
  uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
  v106(v31, a4);
  uint64_t v82 = v101;
  char v83 = v96;
  ((void (*)(uint64_t, uint64_t, uint64_t))v100[17])(v101, v81, v99);
  uint64_t v85 = v97;
  unint64_t v84 = v98;
  (*(void (**)(uint64_t, const char *))(v97 + 8))(v82, v98);
  return (*(uint64_t (**)(uint64_t, char *, const char *))(v85 + 32))(v82, v83, v84);
}

uint64_t Collection.index<A>(_:offsetBy:limitedBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v100 = a4;
  uint64_t v98 = a1;
  uint64_t v99 = a3;
  uint64_t v97 = a8;
  unint64_t v91 = *(int ***)(*(void *)(a7 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v91, a5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v89 = (char *)v88 - v13;
  uint64_t v14 = *(void *)(a5 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  unint64_t v92 = (char *)v88 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v96 = (char *)v88 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v102 = (char *)v88 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v95 = (char *)v88 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  id v94 = (char *)v88 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v27 = (char *)v88 - v26;
  MEMORY[0x1F4188790](v25);
  unint64_t v29 = (char *)v88 - v28;
  uint64_t v104 = v14;
  uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  v30((char *)v88 - v28, a2, a5);
  uint64_t v103 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 64);
  LOBYTE(a2) = v103(a5, a7);
  uint64_t v105 = (void (*)(char *, char *, uint64_t))v30;
  v30(v27, (uint64_t)v29, a5);
  uint64_t v101 = a6;
  if ((a2 & 1) == 0)
  {
    Swift::UInt64 v106 = *(void (**)(char *, uint64_t))(v14 + 8);
    v106(v27, a5);
    char v43 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
    uint64_t v44 = v43(a5, a7);
    goto LABEL_22;
  }
  unint64_t v93 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
  uint64_t v31 = v93(a5, a7);
  uint64_t v33 = *(void (**)(char *, uint64_t))(v14 + 8);
  uint64_t v32 = v14 + 8;
  Swift::UInt64 v106 = v33;
  v33(v27, a5);
  if (v31 > 64)
  {
    v88[1] = v32;
    unint64_t v34 = v94;
    v105(v94, v29, a5);
    v108[0] = 0x8000000000000000;
    uint64_t v35 = v103;
    if (v103(a5, a7))
    {
      uint64_t v36 = v93(a5, a7);
      if (v36 < 64)
      {
        uint64_t v39 = v95;
        v105(v95, v34, a5);
        uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
        unint64_t v41 = v106;
        v106(v39, a5);
        uint64_t v42 = v34;
        goto LABEL_16;
      }
      unint64_t v92 = *(char **)(a7 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
      uint64_t v51 = v95;
      ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v92)(v108, &type metadata for Int, v54, a5, a7);
      char v52 = v34;
      char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8) + 16))(v34, v51, a5);
      goto LABEL_11;
    }
    char v45 = v35(a5, a7);
    uint64_t v46 = v93(a5, a7);
    if (v45)
    {
      if (v46 <= 64)
      {
        size_t v59 = AssociatedTypeWitness;
        uint64_t v58 = v91;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v91, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        BOOL v61 = v89;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v59, AssociatedConformanceWitness);
        uint64_t v62 = v95;
        ((void (*)(char *, uint64_t, int **))v58[3])(v61, a5, v58);
        unint64_t v63 = v94;
        LODWORD(v91) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8)
                                                                          + 16))(v94, v62, a5);
        unint64_t v41 = v106;
        v106(v62, a5);
        uint64_t v64 = v92;
        v105(v92, v63, a5);
        if (v91)
        {
          v41(v64, a5);
          goto LABEL_38;
        }
        uint64_t v65 = v108[0];
        uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
        v41(v64, a5);
        uint64_t v42 = v94;
        if (v66 < v65) {
          goto LABEL_38;
        }
LABEL_20:
        v41(v42, a5);
        goto LABEL_21;
      }
      unint64_t v49 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
      uint64_t v51 = v95;
      v49(v108, &type metadata for Int, v50, a5, a7);
      char v52 = v94;
      char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8) + 16))(v94, v51, a5);
LABEL_11:
      char v55 = v53;
      int64_t v56 = v51;
      unint64_t v41 = v106;
      v106(v56, a5);
      uint64_t v42 = v52;
      if (v55) {
        goto LABEL_38;
      }
      goto LABEL_20;
    }
    if (v46 < 64)
    {
      char v57 = v95;
      v105(v95, v94, a5);
      uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      unint64_t v41 = v106;
      v106(v57, a5);
      uint64_t v42 = v94;
LABEL_16:
      if (v40 < v108[0]) {
LABEL_38:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_20;
    }
    v106(v94, a5);
  }
LABEL_21:
  char v43 = v93;
  uint64_t v44 = v93(a5, a7);
LABEL_22:
  uint64_t v67 = v44;
  uint64_t v68 = v102;
  v105(v102, v29, a5);
  if (v67 < 65)
  {
    uint64_t v69 = v43;
    uint64_t v79 = v43(a5, a7);
    v106(v68, a5);
    if (v79 != 64) {
      goto LABEL_35;
    }
    unint64_t v70 = v103;
    if (v103(a5, a7)) {
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v69 = v43;
    v106(v68, a5);
    unint64_t v70 = v103;
  }
  char v71 = v96;
  v105(v96, v29, a5);
  v108[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v72 = v70(a5, a7);
  uint64_t v73 = v69(a5, a7);
  if ((v72 & 1) == 0)
  {
    if (v73 > 63)
    {
      uint64_t v107 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v76 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      unint64_t v77 = lazy protocol witness table accessor for type Int and conformance Int(v73, v74, v75);
      uint64_t v78 = &v107;
      goto LABEL_33;
    }
LABEL_31:
    unint64_t v80 = v95;
    v105(v95, v71, a5);
    (*(void (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
    uint64_t v81 = v80;
    uint64_t v82 = v106;
    v106(v81, a5);
    v82(v71, a5);
    goto LABEL_35;
  }
  if (v73 <= 64) {
    goto LABEL_31;
  }
  unint64_t v76 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
  unint64_t v77 = lazy protocol witness table accessor for type Int and conformance Int(v73, v74, v75);
  uint64_t v78 = v108;
LABEL_33:
  char v83 = v95;
  v76(v78, &type metadata for Int, v77, a5, a7);
  char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8) + 16))(v83, v71, a5);
  uint64_t v85 = v106;
  v106(v83, a5);
  if (v84) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v85(v96, a5);
LABEL_35:
  uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v106(v29, a5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v101 + 144))(v98, v86, v99, v100);
}

BOOL Collection.formIndex<A>(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int **a6, uint64_t a7)
{
  uint64_t v106 = a3;
  uint64_t v95 = *(int ***)(*(void *)(a7 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v95, a5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v93 = (char *)&v91 - v13;
  uint64_t v104 = a6;
  uint64_t v103 = a4;
  uint64_t v105 = swift_getAssociatedTypeWitness(255, a6, a4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v16 = type metadata accessor for Optional(0, (uint64_t)v105, v14, v15);
  uint64_t v97 = (uint64_t)*(v16 - 1);
  uint64_t v98 = v16;
  uint64_t v17 = MEMORY[0x1F4188790](v16);
  uint64_t v102 = (char *)&v91 - v18;
  uint64_t v19 = *(void *)(a5 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  unint64_t v92 = (char *)&v91 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v99 = (char *)&v91 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  int64_t v108 = (char *)&v91 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v100 = (char *)&v91 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v101 = (char *)&v91 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v32 = (char *)&v91 - v31;
  MEMORY[0x1F4188790](v30);
  unint64_t v34 = (char *)&v91 - v33;
  uint64_t v110 = v19;
  uint64_t v35 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v35((char *)&v91 - v33, a2, a5);
  unint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 64);
  LOBYTE(a2) = v109(a5, a7);
  char v111 = (void (*)(char *, char *, uint64_t))v35;
  v35(v32, (uint64_t)v34, a5);
  uint64_t v107 = a1;
  if ((a2 & 1) == 0)
  {
    uint64_t v112 = *(void (**)(char *, uint64_t))(v19 + 8);
    v112(v32, a5);
    uint64_t v46 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
    uint64_t v47 = v46(a5, a7);
    goto LABEL_20;
  }
  uint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
  uint64_t v36 = v96(a5, a7);
  uint64_t v112 = *(void (**)(char *, uint64_t))(v19 + 8);
  v112(v32, a5);
  if (v36 > 64)
  {
    v111(v101, v34, a5);
    v114[0] = 0x8000000000000000;
    uint64_t v37 = v109;
    if (v109(a5, a7))
    {
      uint64_t v38 = v96(a5, a7);
      if (v38 < 64)
      {
        unint64_t v41 = v100;
        v111(v100, v101, a5);
        uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
        char v43 = v41;
        uint64_t v44 = v112;
        v112(v43, a5);
        char v45 = v101;
        if (v42 < v114[0]) {
          goto LABEL_39;
        }
        goto LABEL_18;
      }
LABEL_10:
      uint64_t v95 = *(int ***)(a7 + 96);
      unint64_t v49 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
      unint64_t v50 = v100;
      ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v95)(v114, &type metadata for Int, v49, a5, a7);
      char v51 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8) + 16))(v101, v50, a5);
      uint64_t v44 = v112;
      v112(v50, a5);
      char v45 = v101;
      if (v51) {
        goto LABEL_39;
      }
      goto LABEL_18;
    }
    char v48 = v37(a5, a7);
    uint64_t v38 = v96(a5, a7);
    if (v48)
    {
      if (v38 <= 64)
      {
        char v55 = v95;
        int64_t v56 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v95, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v58 = v93;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        size_t v59 = v55;
        uint64_t v60 = v55[3];
        BOOL v61 = v100;
        ((void (*)(char *, uint64_t, int **))v60)(v58, a5, v59);
        uint64_t v62 = v101;
        LODWORD(v95) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8)
                                                                          + 16))(v101, v61, a5);
        unint64_t v63 = v61;
        uint64_t v44 = v112;
        v112(v63, a5);
        uint64_t v64 = v92;
        v111(v92, v62, a5);
        if (v95)
        {
          v44(v64, a5);
          goto LABEL_39;
        }
        uint64_t v95 = (int **)v114[0];
        uint64_t AssociatedTypeWitness = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
        v44(v64, a5);
        char v45 = v101;
        if ((uint64_t)AssociatedTypeWitness < (uint64_t)v95) {
          goto LABEL_39;
        }
        goto LABEL_18;
      }
      goto LABEL_10;
    }
    if (v38 < 64)
    {
      char v52 = v100;
      v111(v100, v101, a5);
      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      unint64_t v54 = v52;
      uint64_t v44 = v112;
      v112(v54, a5);
      char v45 = v101;
      if (v53 < v114[0]) {
LABEL_39:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_18:
      v44(v45, a5);
      goto LABEL_19;
    }
    v112(v101, a5);
  }
LABEL_19:
  uint64_t v46 = v96;
  uint64_t v47 = v96(a5, a7);
LABEL_20:
  uint64_t v65 = v47;
  uint64_t v66 = v108;
  v111(v108, v34, a5);
  if (v65 < 65)
  {
    uint64_t v67 = v46;
    uint64_t v76 = v46(a5, a7);
    v112(v66, a5);
    if (v76 != 64 || (v109(a5, a7) & 1) != 0) {
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v67 = v46;
    v112(v66, a5);
  }
  uint64_t v68 = v99;
  v111(v99, v34, a5);
  v114[0] = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v69 = v68;
  LOBYTE(v68) = v109(a5, a7);
  uint64_t v70 = v67(a5, a7);
  if ((v68 & 1) == 0)
  {
    if (v70 > 63)
    {
      uint64_t v113 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      uint64_t v75 = &v113;
      goto LABEL_31;
    }
LABEL_29:
    unint64_t v77 = v100;
    v111(v100, v69, a5);
    (*(void (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
    uint64_t v78 = v77;
    uint64_t v79 = v112;
    v112(v78, a5);
    v79(v69, a5);
    goto LABEL_33;
  }
  if (v70 <= 64) {
    goto LABEL_29;
  }
  uint64_t v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
  unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
  uint64_t v75 = v114;
LABEL_31:
  unint64_t v80 = v100;
  v73(v75, &type metadata for Int, v74, a5, a7);
  char v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8) + 16))(v80, v69, a5);
  uint64_t v82 = v112;
  v112(v80, a5);
  if (v81) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v82(v69, a5);
LABEL_33:
  uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v112(v34, a5);
  char v84 = v102;
  uint64_t v85 = v106;
  uint64_t v86 = v107;
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v104[18])(v107, v83, v106, v103);
  uint64_t v87 = v105;
  uint64_t v88 = *((void *)v105 - 1);
  (*(void (**)(uint64_t, const char *))(v88 + 8))(v86, v105);
  int v89 = (*(uint64_t (**)(char *, uint64_t, const char *))(v88 + 48))(v84, 1, v87);
  if (v89 == 1)
  {
    (*(void (**)(char *, Class *))(v97 + 8))(v84, v98);
    (*(void (**)(uint64_t, uint64_t, const char *))(v88 + 16))(v86, v85, v87);
  }
  else
  {
    (*(void (**)(uint64_t, char *, const char *))(v88 + 32))(v86, v84, v87);
  }
  return v89 != 1;
}

uint64_t Collection.distance<A>(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 152))(a1, a2, a3, a5);
  uint64_t v8 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 88);
  unint64_t v11 = lazy protocol witness table accessor for type Int and conformance Int(v13, v9, v10);
  return v8(&v13, &type metadata for Int, v11, a4, a6);
}

Swift::UnsafeMutableRawPointer __swiftcall UnsafeMutablePointer.deinitialize()()
{
  v2._rawValue = (Builtin::RawPointer)v0;
  swift_arrayDestroy(v0, 1, v1);
  return v2;
}

Swift::Void __swiftcall UnsafeMutablePointer.deallocate(capacity:)(Swift::Int capacity)
{
  swift_slowDealloc(v1);
}

uint64_t UnsafeMutablePointer.initialize<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v26 = a2;
  uint64_t v29 = a3;
  uint64_t v8 = type metadata accessor for Optional(0, a3, a3, a4);
  uint64_t v27 = (uint64_t)*(v8 - 1);
  uint64_t v28 = v8;
  uint64_t v9 = MEMORY[0x1F4188790](v8);
  unint64_t v11 = (char *)&v26 - v10;
  uint64_t v12 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v26 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = *(void *)(a5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v15, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v17 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v19 = (char *)&v26 - v18;
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 112))(a4, a5);
  if (v20 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  uint64_t v21 = v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, a1, a4);
  uint64_t v22 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 64))(v19, v26, v21, a4, v15);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v15, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16))(AssociatedTypeWitness, AssociatedConformanceWitness);
  int v24 = (*(uint64_t (**)(char *, uint64_t))(*(void *)(v29 - 8) + 48))(v11, 1);
  (*(void (**)(char *, Class *))(v27 + 8))(v11, v28);
  if (v24 != 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "rhs underreported its count", 27, 2, "Swift/MigrationSupport.swift", 28, 2, 0x17BuLL, 0);
  }
  if (v22 != v21) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "rhs overreported its count", 26, 2, "Swift/MigrationSupport.swift", 28, 2, 0x17CuLL, 0);
  }
  return (*(uint64_t (**)(char *, const char *))(v17 + 8))(v19, AssociatedTypeWitness);
}

uint64_t UnsafeRawPointer.summary.getter(Swift::UInt64 a1)
{
  unint64_t v1 = 0xD000000000000013;
  if (!a1) {
    return 0xD000000000000015;
  }
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(22);
  uint64_t v5 = v4;
  uint64_t v27 = v3;
  unint64_t v28 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v6 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v4);
    unint64_t v10 = 0x80000001816E2CC0;
    goto LABEL_16;
  }
  if ((v4 & 0x2000000000000000) != 0
    && ((unint64_t)"UnsafeMutableRawPointer(nil)" & 0x2000000000000000) != 0)
  {
    unint64_t v7 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD000000000000013, 0x80000001816E2CC0);
    if ((v9 & 1) == 0)
    {
      unint64_t v1 = v7;
      unint64_t v10 = v8;
      swift_bridgeObjectRelease(v5);
LABEL_16:
      uint64_t v27 = v1;
      unint64_t v28 = v10;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"UnsafeMutableRawPointer(nil)" & 0x2000000000000000) != 0) {
    unint64_t v11 = (0x80000001816E2CC0 >> 56) & 0xF;
  }
  else {
    unint64_t v11 = 19;
  }
  _StringGuts.append(_:)(0xD000000000000013, 0x80000001816E2CC0, 0, v11);
  unint64_t v1 = v27;
  unint64_t v10 = v28;
LABEL_17:
  Swift::String v13 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  unint64_t countAndFlagsBits = v13._countAndFlagsBits;
  unint64_t object = (unint64_t)v13._object;
  uint64_t v16 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000) == 0) {
    uint64_t v16 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v1 & ~v10 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v10);
    uint64_t v27 = v13._countAndFlagsBits;
    goto LABEL_30;
  }
  if ((v10 & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v13._object & 0x2000000000000000) != 0) {
      goto LABEL_28;
    }
LABEL_25:
    uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
    swift_bridgeObjectRelease((uint64_t)v13._object);
    unint64_t countAndFlagsBits = v27;
    unint64_t object = v28;
    goto LABEL_30;
  }
  if (((uint64_t)v13._object & 0x2000000000000000) == 0) {
    goto LABEL_25;
  }
  unint64_t v18 = specialized _SmallString.init(_:appending:)(v1, v10, v13._countAndFlagsBits, (unint64_t)v13._object);
  if (v20)
  {
LABEL_28:
    uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
    goto LABEL_29;
  }
  unint64_t v21 = v18;
  unint64_t v22 = v19;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease((uint64_t)v13._object);
  uint64_t v27 = v21;
  unint64_t object = v22;
  unint64_t countAndFlagsBits = v21;
LABEL_30:
  uint64_t v23 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0) {
    uint64_t v23 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v23 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (unint64_t v24 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x29uLL, 0xE100000000000000),
          (v25 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      return v27;
    }
    else
    {
      unint64_t v12 = v24;
      swift_bridgeObjectRelease(object);
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    return 41;
  }
  return v12;
}

uint64_t UnsafeRawPointer.customPlaygroundQuickLook.getter@<X0>(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = UnsafeRawPointer.summary.getter(a1);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(unsigned char *)(a2 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer(UnsafeRawPointer.summary.getter, a1);
}

uint64_t UnsafeMutableRawPointer.summary.getter(Swift::UInt64 a1)
{
  unint64_t v1 = 0xD00000000000001ALL;
  if (!a1) {
    return 0xD00000000000001CLL;
  }
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(29);
  uint64_t v5 = v4;
  uint64_t v27 = v3;
  unint64_t v28 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v6 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v4);
    unint64_t v10 = 0x80000001816E2C80;
    goto LABEL_16;
  }
  if ((v4 & 0x2000000000000000) != 0 && ((unint64_t)"UnsafePointer(nil)" & 0x2000000000000000) != 0)
  {
    unint64_t v7 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD00000000000001ALL, 0x80000001816E2C80);
    if ((v9 & 1) == 0)
    {
      unint64_t v1 = v7;
      unint64_t v10 = v8;
      swift_bridgeObjectRelease(v5);
LABEL_16:
      uint64_t v27 = v1;
      unint64_t v28 = v10;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"UnsafePointer(nil)" & 0x2000000000000000) != 0) {
    unint64_t v11 = (0x80000001816E2C80 >> 56) & 0xF;
  }
  else {
    unint64_t v11 = 26;
  }
  _StringGuts.append(_:)(0xD00000000000001ALL, 0x80000001816E2C80, 0, v11);
  unint64_t v1 = v27;
  unint64_t v10 = v28;
LABEL_17:
  Swift::String v13 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  unint64_t countAndFlagsBits = v13._countAndFlagsBits;
  unint64_t object = (unint64_t)v13._object;
  uint64_t v16 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000) == 0) {
    uint64_t v16 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v1 & ~v10 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v10);
    uint64_t v27 = v13._countAndFlagsBits;
    goto LABEL_30;
  }
  if ((v10 & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v13._object & 0x2000000000000000) != 0) {
      goto LABEL_28;
    }
LABEL_25:
    uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
    swift_bridgeObjectRelease((uint64_t)v13._object);
    unint64_t countAndFlagsBits = v27;
    unint64_t object = v28;
    goto LABEL_30;
  }
  if (((uint64_t)v13._object & 0x2000000000000000) == 0) {
    goto LABEL_25;
  }
  unint64_t v18 = specialized _SmallString.init(_:appending:)(v1, v10, v13._countAndFlagsBits, (unint64_t)v13._object);
  if (v20)
  {
LABEL_28:
    uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
    goto LABEL_29;
  }
  unint64_t v21 = v18;
  unint64_t v22 = v19;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease((uint64_t)v13._object);
  uint64_t v27 = v21;
  unint64_t object = v22;
  unint64_t countAndFlagsBits = v21;
LABEL_30:
  uint64_t v23 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0) {
    uint64_t v23 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v23 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (unint64_t v24 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x29uLL, 0xE100000000000000),
          (v25 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      return v27;
    }
    else
    {
      unint64_t v12 = v24;
      swift_bridgeObjectRelease(object);
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    return 41;
  }
  return v12;
}

uint64_t UnsafeMutableRawPointer.customPlaygroundQuickLook.getter@<X0>(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = UnsafeMutableRawPointer.summary.getter(a1);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(unsigned char *)(a2 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeMutableRawPointer@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer(UnsafeMutableRawPointer.summary.getter, a1);
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer@<X0>(uint64_t (*a1)(void)@<X2>, uint64_t a2@<X8>)
{
  uint64_t result = a1(*v2);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v5;
  *(unsigned char *)(a2 + 32) = 0;
  return result;
}

void UnsafePointer.customPlaygroundQuickLook.getter(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t countAndFlagsBits = 0xD000000000000010;
  if (!a1)
  {
    unint64_t v14 = 0xD000000000000012;
    unint64_t v15 = 0x80000001816E2C60;
    goto LABEL_38;
  }
  unint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(19);
  uint64_t v7 = v6;
  v30._unint64_t countAndFlagsBits = v5;
  v30._unint64_t object = (void *)v6;
  uint64_t v8 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000) == 0) {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v8 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    unint64_t object = 0x80000001816E2C40;
    goto LABEL_16;
  }
  if ((v6 & 0x2000000000000000) != 0 && ((unint64_t)"UnsafeMutablePointer(nil)" & 0x2000000000000000) != 0)
  {
    unint64_t v9 = specialized _SmallString.init(_:appending:)(v5, v6, 0xD000000000000010, 0x80000001816E2C40);
    if ((v11 & 1) == 0)
    {
      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v7);
LABEL_16:
      v30._unint64_t countAndFlagsBits = countAndFlagsBits;
      v30._unint64_t object = (void *)object;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"UnsafeMutablePointer(nil)" & 0x2000000000000000) != 0) {
    unint64_t v13 = (0x80000001816E2C40 >> 56) & 0xF;
  }
  else {
    unint64_t v13 = 16;
  }
  _StringGuts.append(_:)(0xD000000000000010, 0x80000001816E2C40, 0, v13);
  unint64_t object = (unint64_t)v30._object;
  unint64_t countAndFlagsBits = v30._countAndFlagsBits;
LABEL_17:
  Swift::String v16 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  unint64_t v17 = v16._countAndFlagsBits;
  unint64_t v18 = (unint64_t)v16._object;
  uint64_t v19 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0) {
    uint64_t v19 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v19 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(object);
    Swift::String v30 = v16;
    goto LABEL_30;
  }
  if ((object & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v16._object & 0x2000000000000000) != 0) {
      goto LABEL_28;
    }
LABEL_25:
    uint64_t v20 = v16._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v16._countAndFlagsBits, (unint64_t)v16._object, 0, v20);
    swift_bridgeObjectRelease((uint64_t)v16._object);
    unint64_t v18 = (unint64_t)v30._object;
    unint64_t v17 = v30._countAndFlagsBits;
    goto LABEL_30;
  }
  if (((uint64_t)v16._object & 0x2000000000000000) == 0) {
    goto LABEL_25;
  }
  unint64_t v21 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v16._countAndFlagsBits, (unint64_t)v16._object);
  if (v23)
  {
LABEL_28:
    uint64_t v20 = ((unint64_t)v16._object >> 56) & 0xF;
    goto LABEL_29;
  }
  unint64_t v24 = v21;
  char v25 = v22;
  swift_bridgeObjectRelease((uint64_t)v16._object);
  swift_bridgeObjectRelease(object);
  v30._unint64_t countAndFlagsBits = v24;
  v30._unint64_t object = v25;
  unint64_t v18 = (unint64_t)v25;
  unint64_t v17 = v24;
LABEL_30:
  uint64_t v26 = HIBYTE(v18) & 0xF;
  if ((v18 & 0x2000000000000000) == 0) {
    uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
  }
  if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
  {
    if ((v18 & 0x2000000000000000) == 0
      || (unint64_t v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0x29uLL, 0xE100000000000000), (v29 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      unint64_t v15 = (unint64_t)v30._object;
      unint64_t v14 = v30._countAndFlagsBits;
    }
    else
    {
      unint64_t v14 = v27;
      unint64_t v15 = v28;
      swift_bridgeObjectRelease(v18);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v18);
    unint64_t v15 = 0xE100000000000000;
    unint64_t v14 = 41;
  }
LABEL_38:
  *(void *)a2 = v14;
  *(void *)(a2 + 8) = v15;
  *(unsigned char *)(a2 + 32) = 0;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafePointer<A>(uint64_t a1@<X8>)
{
  UnsafePointer.customPlaygroundQuickLook.getter(*v1, a1);
}

void UnsafeMutablePointer.customPlaygroundQuickLook.getter(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t countAndFlagsBits = 0xD000000000000017;
  if (!a1)
  {
    unint64_t v14 = 0xD000000000000019;
    unint64_t v15 = 0x80000001816E2C20;
    goto LABEL_38;
  }
  unint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(26);
  uint64_t v7 = v6;
  v30._unint64_t countAndFlagsBits = v5;
  v30._unint64_t object = (void *)v6;
  uint64_t v8 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000) == 0) {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v8 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    unint64_t object = 0x80000001816E2C00;
    goto LABEL_16;
  }
  if ((v6 & 0x2000000000000000) != 0 && ((unint64_t)"Swift/Diffing.swift" & 0x2000000000000000) != 0)
  {
    unint64_t v9 = specialized _SmallString.init(_:appending:)(v5, v6, 0xD000000000000017, 0x80000001816E2C00);
    if ((v11 & 1) == 0)
    {
      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v7);
LABEL_16:
      v30._unint64_t countAndFlagsBits = countAndFlagsBits;
      v30._unint64_t object = (void *)object;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"Swift/Diffing.swift" & 0x2000000000000000) != 0) {
    unint64_t v13 = (0x80000001816E2C00 >> 56) & 0xF;
  }
  else {
    unint64_t v13 = 23;
  }
  _StringGuts.append(_:)(0xD000000000000017, 0x80000001816E2C00, 0, v13);
  unint64_t object = (unint64_t)v30._object;
  unint64_t countAndFlagsBits = v30._countAndFlagsBits;
LABEL_17:
  Swift::String v16 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  unint64_t v17 = v16._countAndFlagsBits;
  unint64_t v18 = (unint64_t)v16._object;
  uint64_t v19 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0) {
    uint64_t v19 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v19 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(object);
    Swift::String v30 = v16;
    goto LABEL_30;
  }
  if ((object & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v16._object & 0x2000000000000000) != 0) {
      goto LABEL_28;
    }
LABEL_25:
    uint64_t v20 = v16._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v16._countAndFlagsBits, (unint64_t)v16._object, 0, v20);
    swift_bridgeObjectRelease((uint64_t)v16._object);
    unint64_t v18 = (unint64_t)v30._object;
    unint64_t v17 = v30._countAndFlagsBits;
    goto LABEL_30;
  }
  if (((uint64_t)v16._object & 0x2000000000000000) == 0) {
    goto LABEL_25;
  }
  unint64_t v21 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v16._countAndFlagsBits, (unint64_t)v16._object);
  if (v23)
  {
LABEL_28:
    uint64_t v20 = ((unint64_t)v16._object >> 56) & 0xF;
    goto LABEL_29;
  }
  unint64_t v24 = v21;
  char v25 = v22;
  swift_bridgeObjectRelease((uint64_t)v16._object);
  swift_bridgeObjectRelease(object);
  v30._unint64_t countAndFlagsBits = v24;
  v30._unint64_t object = v25;
  unint64_t v18 = (unint64_t)v25;
  unint64_t v17 = v24;
LABEL_30:
  uint64_t v26 = HIBYTE(v18) & 0xF;
  if ((v18 & 0x2000000000000000) == 0) {
    uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
  }
  if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
  {
    if ((v18 & 0x2000000000000000) == 0
      || (unint64_t v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0x29uLL, 0xE100000000000000), (v29 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      unint64_t v15 = (unint64_t)v30._object;
      unint64_t v14 = v30._countAndFlagsBits;
    }
    else
    {
      unint64_t v14 = v27;
      unint64_t v15 = v28;
      swift_bridgeObjectRelease(v18);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v18);
    unint64_t v15 = 0xE100000000000000;
    unint64_t v14 = 41;
  }
LABEL_38:
  *(void *)a2 = v14;
  *(void *)(a2 + 8) = v15;
  *(unsigned char *)(a2 + 32) = 0;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeMutablePointer<A>(uint64_t a1@<X8>)
{
  UnsafeMutablePointer.customPlaygroundQuickLook.getter(*v1, a1);
}

void *static UnsafeMutableRawPointer.allocate(bytes:alignedTo:)(size_t a1, uint64_t a2)
{
  if (a2 <= 16) {
    unint64_t v2 = -1;
  }
  else {
    unint64_t v2 = a2 - 1;
  }
  return swift_slowAlloc(a1, v2);
}

Swift::Void __swiftcall UnsafeMutableRawPointer.deallocate(bytes:alignedTo:)(Swift::Int bytes, Swift::Int alignedTo)
{
  swift_slowDealloc(v2);
}

Swift::Void __swiftcall UnsafeMutableRawPointer.copyBytes(from:count:)(Swift::UnsafeRawPointer from, Swift::Int count)
{
  if (count < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
  }
  memmove(v2, from._rawValue, count);
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:at:count:to:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(*(void *)(a6 - 8) + 72);
  if ((unsigned __int128)(a2 * (__int128)v6) >> 64 == (a2 * v6) >> 63) {
    return UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(result, a4, a3, a5 + a2 * v6, a6);
  }
  __break(1u);
  return result;
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:from:)(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v37 = a3;
  uint64_t v44 = a2;
  uint64_t v6 = *(void *)(a5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v35 - v9;
  unint64_t v13 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1F4188790](v13 - 1);
  Swift::String v16 = (char *)&v35 - v15;
  uint64_t v17 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v35 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = swift_getAssociatedTypeWitness(0, (int **)v6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v36 = *((void *)v20 - 1);
  MEMORY[0x1F4188790](v20);
  unint64_t v22 = (char *)&v35 - v21;
  (*(void (**)(char *, const char *, uint64_t))(v17 + 16))(v19, v44, a4);
  (*(void (**)(uint64_t, uint64_t))(v6 + 32))(a4, v6);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a4, (uint64_t)v20, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v25 = AssociatedConformanceWitness + 16;
  unint64_t v24 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  char v43 = v22;
  uint64_t v44 = v20;
  unint64_t v41 = v24;
  uint64_t v42 = AssociatedConformanceWitness;
  ((void (*)(const char *))v24)(v20);
  uint64_t v26 = v25;
  uint64_t v28 = v8 + 48;
  unint64_t v27 = *(unsigned int (**)(char *, uint64_t, const char *))(v8 + 48);
  if (v27(v16, 1, AssociatedTypeWitness) != 1)
  {
    char v29 = *(void (**)(char *, char *, const char *))(v8 + 32);
    uint64_t v39 = v8 + 16;
    uint64_t v40 = v29;
    uint64_t v38 = v8 + 8;
    uint64_t v30 = v37;
    do
    {
      v40(v10, v16, AssociatedTypeWitness);
      (*(void (**)(uint64_t, char *, const char *))(v8 + 16))(v30, v10, AssociatedTypeWitness);
      uint64_t v31 = v28;
      uint64_t v32 = v26;
      uint64_t v33 = *(void *)(v8 + 72);
      (*(void (**)(char *, const char *))(v8 + 8))(v10, AssociatedTypeWitness);
      v30 += v33;
      v41(v44, v42);
      uint64_t v26 = v32;
      uint64_t v28 = v31;
    }
    while (v27(v16, 1, AssociatedTypeWitness) != 1);
  }
  (*(void (**)(char *, const char *))(v36 + 8))(v43, v44);
  return v37;
}

void *static UnsafeMutableRawBufferPointer.allocate(count:)(size_t a1)
{
  uint64_t result = swift_slowAlloc(a1, 0xFFFFFFFFFFFFFFFFLL);
  if ((a1 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  return result;
}

void *static UnsafeMutableRawBufferPointer.allocate(byteCount:alignment:)(size_t a1, uint64_t a2)
{
  if (a2 <= 16) {
    unint64_t v3 = -1;
  }
  else {
    unint64_t v3 = a2 - 1;
  }
  uint64_t result = swift_slowAlloc(a1, v3);
  if ((a1 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeMutableRawBufferPointer.copyMemory(from:)(Swift::UnsafeRawBufferPointer from)
{
  if (from._position.value._rawValue) {
    int64_t v4 = (char *)from._end.value._rawValue - (char *)from._position.value._rawValue;
  }
  else {
    int64_t v4 = 0;
  }
  if (!v1)
  {
    if (v4 < 1) {
      return;
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.copyMemory source has too many elements", 69, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1E7uLL, 0);
  }
  if (v2 - (uint64_t)v1 < v4) {
    goto LABEL_12;
  }
  if (from._position.value._rawValue)
  {
    memmove(v1, from._position.value._rawValue, (char *)from._end.value._rawValue - (char *)from._position.value._rawValue);
  }
}

void Sequence.flatMap<A>(_:)(void (*a1)(void), uint64_t a2, uint64_t a3, uint64_t *a4, int **a5)
{
}

__objc2_class **Collection.flatMap(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v55 = a1;
  uint64_t v7 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v61 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v51 - v8;
  unint64_t v13 = type metadata accessor for Optional(0, v10, v11, v12);
  uint64_t v14 = MEMORY[0x1F4188790](v13 - 1);
  char v51 = (char *)&v51 - v15;
  uint64_t v16 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v51 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v53 = *((void *)v19 - 1);
  MEMORY[0x1F4188790](v19);
  uint64_t v21 = (char *)&v51 - v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))(v18, v4, a3);
  unint64_t v22 = AssociatedTypeWitness;
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(a3, v7);
  uint64_t v23 = v7;
  unint64_t v24 = v51;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v23, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v26 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v63 = v21;
  uint64_t v64 = v19;
  uint64_t v62 = v26;
  v26(v19, AssociatedConformanceWitness);
  uint64_t v27 = v61;
  uint64_t v28 = v61 + 48;
  char v29 = *(uint64_t (**)(char *, uint64_t, const char *))(v61 + 48);
  if (v29(v24, 1, v22) == 1)
  {
    uint64_t v30 = &_swiftEmptyArrayStorage;
LABEL_3:
    (*(void (**)(char *, const char *))(v53 + 8))(v63, v64);
  }
  else
  {
    int64_t v56 = v29;
    uint64_t v57 = v28;
    uint64_t v58 = AssociatedConformanceWitness + 16;
    uint64_t v59 = AssociatedConformanceWitness;
    uint64_t v32 = *(void *)(v27 + 32);
    uint64_t v31 = v27 + 32;
    uint64_t v60 = (void (**)(char *, const char *))(v31 - 24);
    uint64_t v61 = v32;
    uint64_t v30 = &_swiftEmptyArrayStorage;
    uint64_t v54 = a2;
    uint64_t v33 = v55;
    uint64_t v34 = v65;
    while (1)
    {
      uint64_t v37 = v31;
      ((void (*)(char *, char *, const char *))v61)(v9, v24, v22);
      uint64_t v38 = v33(v9);
      uint64_t v40 = v22;
      if (v34) {
        break;
      }
      uint64_t v41 = v38;
      uint64_t v42 = v39;
      uint64_t v65 = 0;
      char v43 = v9;
      uint64_t v44 = v9;
      char v45 = v40;
      (*v60)(v44, v40);
      if (v42)
      {
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v30)) {
          uint64_t v30 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v30[2]->isa + 1, 1, (uint64_t)v30);
        }
        uint64_t v35 = v62;
        unint64_t v47 = (unint64_t)v30[2];
        unint64_t v46 = (unint64_t)v30[3];
        if (v47 >= v46 >> 1)
        {
          unint64_t v49 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v46 > 1), v47 + 1, 1, (uint64_t)v30);
          uint64_t v35 = v62;
          uint64_t v30 = v49;
        }
        v30[2] = (__objc2_class *)(v47 + 1);
        char v48 = &v30[2 * v47];
        v48[4] = (__objc2_class *)v41;
        v48[5] = v42;
        uint64_t v33 = v55;
      }
      else
      {
        uint64_t v35 = v62;
      }
      v35(v64, v59);
      unint64_t v22 = v45;
      int v36 = v56(v24, 1, v45);
      uint64_t v31 = v37;
      uint64_t v9 = v43;
      uint64_t v34 = v65;
      if (v36 == 1) {
        goto LABEL_3;
      }
    }
    (*v60)(v9, v22);
    (*(void (**)(char *, const char *))(v53 + 8))(v63, v64);
    swift_bridgeObjectRelease((uint64_t)v30);
  }
  return v30;
}

uint64_t Collection.index(where:)@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return Collection.firstIndex(where:)(a1, a2, a3, a4, a5);
}

uint64_t _PlaygroundQuickLook.init(reflecting:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v41);
  uint64_t v4 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CustomPlaygroundQuickLookable);
  if ((swift_dynamicCast((char *)&v38, v41, qword_1ECA06310, v4, 6uLL) & 1) != 0
    || (uint64_t v40 = 0,
        long long v38 = 0u,
        long long v39 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v38, &demangling cache variable for type metadata for _CustomPlaygroundQuickLookable?), outlined init with copy of Any((uint64_t)a1, (uint64_t)v41), unint64_t v5 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for __DefaultCustomPlaygroundQuickLookable), (swift_dynamicCast((char *)&v38, v41, qword_1ECA06310, v5, 6uLL) & 1) != 0))
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    outlined init with take of MirrorPath(&v38, (uint64_t)&v42);
    uint64_t v6 = *((void *)&v43 + 1);
    uint64_t v7 = v44;
    __swift_project_boxed_opaque_existential_0Tm(&v42, *((uint64_t *)&v43 + 1));
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v42);
  }
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v38, &demangling cache variable for type metadata for __DefaultCustomPlaygroundQuickLookable?);
  id v9 = swift_reflectionMirror_quickLookObject((swift::SwiftError **)a1, (uint64_t *)qword_1ECA06310);
  if (!v9)
  {
    long long v42 = 0u;
    long long v43 = 0u;
    LOBYTE(v44) = -1;
    goto LABEL_29;
  }
  uint64_t v10 = v9;
  swift_unknownObjectRetain_n((uint64_t)v9, 2);
  unsigned __int8 v11 = specialized String.withCString<A>(_:)(0x7265626D754E534EuLL, 0xE800000000000000, v10);
  swift_bridgeObjectRelease(0xE800000000000000);
  swift_unknownObjectRelease(v10);
  swift_unknownObjectRetain(v10);
  if ((v11 & 1) == 0)
  {
    unsigned __int8 v16 = specialized String.withCString<A>(_:)(0xD000000000000012, 0x80000001816DF940 | 0x8000000000000000, v10);
    swift_bridgeObjectRelease(0x80000001816DF940 | 0x8000000000000000);
    swift_unknownObjectRelease(v10);
    if (v16)
    {
      *((void *)&v43 + 1) = swift_getObjectType((unint64_t)v10);
      *(void *)&long long v42 = v10;
      char v17 = 9;
    }
    else
    {
      swift_unknownObjectRetain(v10);
      unsigned __int8 v18 = specialized String.withCString<A>(_:)(0x6567616D49534EuLL, 0xE700000000000000, v10);
      swift_bridgeObjectRelease(0xE700000000000000);
      swift_unknownObjectRelease(v10);
      if (v18) {
        goto LABEL_20;
      }
      swift_unknownObjectRetain(v10);
      unsigned __int8 v19 = specialized String.withCString<A>(_:)(0x6567616D494955uLL, 0xE700000000000000, v10);
      swift_bridgeObjectRelease(0xE700000000000000);
      swift_unknownObjectRelease(v10);
      if (v19) {
        goto LABEL_20;
      }
      Swift::String v20 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NSImageView", 0xBuLL, 1);
      swift_unknownObjectRetain(v10);
      unsigned __int8 v21 = specialized String.withCString<A>(_:)(v20._countAndFlagsBits, (unint64_t)v20._object, v10);
      swift_bridgeObjectRelease((uint64_t)v20._object);
      swift_unknownObjectRelease(v10);
      if (v21) {
        goto LABEL_20;
      }
      Swift::String v22 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UIImageView", 0xBuLL, 1);
      swift_unknownObjectRetain(v10);
      unsigned __int8 v23 = specialized String.withCString<A>(_:)(v22._countAndFlagsBits, (unint64_t)v22._object, v10);
      swift_bridgeObjectRelease((uint64_t)v22._object);
      swift_unknownObjectRelease(v10);
      if (v23) {
        goto LABEL_20;
      }
      swift_unknownObjectRetain(v10);
      unsigned __int8 v24 = specialized String.withCString<A>(_:)(0x6567616D494943uLL, 0xE700000000000000, v10);
      swift_bridgeObjectRelease(0xE700000000000000);
      swift_unknownObjectRelease(v10);
      if ((v24 & 1) != 0
        || (swift_unknownObjectRetain(v10),
            unsigned __int8 v25 = specialized String.withCString<A>(_:)(0xD000000000000010, 0x80000001816DF970 | 0x8000000000000000, v10), swift_bridgeObjectRelease(0x80000001816DF970 | 0x8000000000000000), swift_unknownObjectRelease(v10), (v25 & 1) != 0))
      {
LABEL_20:
        *((void *)&v43 + 1) = swift_getObjectType((unint64_t)v10);
        *(void *)&long long v42 = v10;
        char v17 = 5;
      }
      else
      {
        swift_unknownObjectRetain(v10);
        unsigned __int8 v31 = specialized String.withCString<A>(_:)(0x726F6C6F43534EuLL, 0xE700000000000000, v10);
        swift_bridgeObjectRelease(0xE700000000000000);
        swift_unknownObjectRelease(v10);
        if ((v31 & 1) != 0
          || (swift_unknownObjectRetain(v10),
              unsigned __int8 v32 = specialized String.withCString<A>(_:)(0x726F6C6F434955uLL, 0xE700000000000000, v10), swift_bridgeObjectRelease(0xE700000000000000), swift_unknownObjectRelease(v10), (v32 & 1) != 0))
        {
          *((void *)&v43 + 1) = swift_getObjectType((unint64_t)v10);
          *(void *)&long long v42 = v10;
          char v17 = 7;
        }
        else
        {
          Swift::String v33 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NSBezierPath", 0xCuLL, 1);
          swift_unknownObjectRetain(v10);
          unsigned __int8 v34 = specialized String.withCString<A>(_:)(v33._countAndFlagsBits, (unint64_t)v33._object, v10);
          swift_bridgeObjectRelease((uint64_t)v33._object);
          swift_unknownObjectRelease(v10);
          if ((v34 & 1) == 0)
          {
            Swift::String v35 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UIBezierPath", 0xCuLL, 1);
            swift_unknownObjectRetain(v10);
            unsigned __int8 v36 = specialized String.withCString<A>(_:)(v35._countAndFlagsBits, (unint64_t)v35._object, v10);
            swift_bridgeObjectRelease((uint64_t)v35._object);
            swift_unknownObjectRelease(v10);
            if ((v36 & 1) == 0)
            {
              swift_unknownObjectRetain(v10);
              unsigned __int8 v37 = specialized String.withCString<A>(_:)(0x676E69727453534EuLL, 0xE800000000000000, v10);
              swift_bridgeObjectRelease(0xE800000000000000);
              swift_unknownObjectRelease(v10);
              if (v37)
              {
                long long v38 = 0uLL;
                _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v10, (uint64_t)&type metadata for String, &v38);
                if (!*((void *)&v38 + 1)) {
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
                }
                long long v42 = v38;
                LOBYTE(v44) = 0;
              }
              else
              {
                long long v42 = 0u;
                long long v43 = 0u;
                LOBYTE(v44) = -1;
              }
              swift_unknownObjectRelease(v10);
              goto LABEL_22;
            }
          }
          *((void *)&v43 + 1) = swift_getObjectType((unint64_t)v10);
          *(void *)&long long v42 = v10;
          char v17 = 8;
        }
      }
    }
    LOBYTE(v44) = v17;
LABEL_22:
    swift_unknownObjectRelease(v10);
    goto LABEL_27;
  }
  int v12 = *(unsigned __int8)[v10 objCType];
  if ((v12 & 0x80) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  switch(v12)
  {
    case 'Q':
      id v28 = [v10 unsignedLongLongValue];
      swift_unknownObjectRelease(v10);
      *(void *)&long long v42 = v28;
      char v15 = 2;
      break;
    case 'f':
      [v10 sel_floatValue];
      int v27 = v26;
      swift_unknownObjectRelease(v10);
      LODWORD(v42) = v27;
      char v15 = 3;
      break;
    case 'd':
      [v10 sel_doubleValue];
      uint64_t v14 = v13;
      swift_unknownObjectRelease(v10);
      *(void *)&long long v42 = v14;
      char v15 = 4;
      break;
    default:
      id v29 = [v10 sel_longLongValue];
      swift_unknownObjectRelease(v10);
      *(void *)&long long v42 = v29;
      char v15 = 1;
      break;
  }
  LOBYTE(v44) = v15;
  swift_unknownObjectRelease_n((uint64_t)v10, 2);
LABEL_27:
  if (v44 != 255)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    return outlined init with take of _PlaygroundQuickLook(&v42, a2);
  }
LABEL_29:
  outlined destroy of _PlaygroundQuickLook?((uint64_t)&v42);
  *(void *)&long long v42 = 0;
  *((void *)&v42 + 1) = 0xE000000000000000;
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)a1, (uint64_t)&v42, qword_1ECA06310, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  uint64_t v30 = *((void *)&v42 + 1);
  *(void *)a2 = v42;
  *(void *)(a2 + 8) = v30;
  *(unsigned char *)(a2 + 32) = 0;
  return result;
}

uint64_t _availabilityNextMajorVersion.getter()
{
  return 14;
}

uint64_t static _SwiftStdlibVersion.current.getter()
{
  return 393216;
}

uint64_t _SwiftStdlibVersion.description.getter(unsigned int a1)
{
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(8);
  unint64_t countAndFlagsBits = v3;
  unint64_t object = v4;
  v287._unint64_t countAndFlagsBits = v3;
  v287._unint64_t object = (void *)v4;
  uint64_t v7 = HIBYTE(v4) & 0xF;
  uint64_t v8 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000) != 0) {
    uint64_t v9 = HIBYTE(v4) & 0xF;
  }
  else {
    uint64_t v9 = v3 & 0xFFFFFFFFFFFFLL;
  }
  unsigned int v285 = a1;
  if (!v9 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    v287._unint64_t countAndFlagsBits = 0;
    v287._unint64_t object = (void *)0xE000000000000000;
    uint64_t v39 = v4;
    goto LABEL_59;
  }
  if ((v4 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v4);
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v40 = 0xA000000000000000;
    if (!(object & 0x80808080808080 | countAndFlagsBits & 0x8080808080808080)) {
      unint64_t v40 = 0xE000000000000000;
    }
    v287._unint64_t countAndFlagsBits = countAndFlagsBits;
    v287._unint64_t object = (void *)(v40 & 0xFF00000000000000 | (v7 << 56) | object & 0xFFFFFFFFFFFFFFLL);
    goto LABEL_60;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6);
  uint64_t v10 = v8;
  if ((object & 0x1000000000000000) != 0)
  {
    uint64_t v10 = String.UTF8View._foreignCount()();
    unint64_t v11 = countAndFlagsBits & ~object;
    if ((v11 & 0x2000000000000000) == 0)
    {
LABEL_39:
      if (v10 <= 15) {
        goto LABEL_13;
      }
      goto LABEL_40;
    }
  }
  else
  {
    unint64_t v11 = countAndFlagsBits & ~object;
    if ((v11 & 0x2000000000000000) == 0) {
      goto LABEL_39;
    }
  }
  if (!swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL)) {
    goto LABEL_39;
  }
  unint64_t v12 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
  if (v13) {
    goto LABEL_284;
  }
  if (v10 <= 15 && (v12 & 0x8000000000000000) != 0)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE000000000000000, 5);
    if ((object & 0x1000000000000000) == 0)
    {
      if ((countAndFlagsBits & 0x1000000000000000) != 0)
      {
        uint64_t v14 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        uint64_t v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
        uint64_t v8 = v279;
      }
      swift_bridgeObjectRetain(object);
      closure #1 in _StringGuts._convertedToSmall()(v14, v8, &v286);
      swift_bridgeObjectRelease(object);
      unint64_t v16 = *((void *)&v286 + 1);
      unint64_t v15 = v286;
      goto LABEL_17;
    }
    goto LABEL_271;
  }
LABEL_40:
  int64_t v41 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
  uint64_t v44 = (v42 & 1) == 0 && v41 >= 0;
  if ((v11 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v44) {
      goto LABEL_58;
    }
  }
  else if (v44)
  {
LABEL_57:
    _StringGuts.grow(_:)(v10);
LABEL_58:
    swift_bridgeObjectRelease_n(0xE000000000000000, 6);
    long long v286 = 0uLL;
    unint64_t v49 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v286, 0);
    _StringGuts.appendInPlace(_:isASCII:)(v49, v50, 1);
    uint64_t v39 = 0xE000000000000000;
    goto LABEL_59;
  }
  uint64_t v45 = _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
  if (v46) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = v45;
  }
  if (v47 + 0x4000000000000000 >= 0)
  {
    uint64_t v48 = 2 * v47;
    if (v48 > v10) {
      uint64_t v10 = v48;
    }
    goto LABEL_57;
  }
  __break(1u);
LABEL_279:
  id v102 = _StringObject.sharedUTF8.getter(v44, countAndFlagsBits);
  uint64_t v103 = v280;
  swift_bridgeObjectRelease(countAndFlagsBits);
  if (v103 < v1) {
    goto LABEL_282;
  }
LABEL_109:
  a1 = v285;
  uint64_t v104 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v1, (uint64_t)v102, v103);
  _StringGuts.appendInPlace(_:isASCII:)(v104, v105, v44 < 0);
  swift_bridgeObjectRelease_n(countAndFlagsBits, 2);
  while (1)
  {
    unint64_t countAndFlagsBits = v287._countAndFlagsBits;
    unint64_t object = (unint64_t)v287._object;
    unint64_t v106 = ((unint64_t)v287._object >> 56) & 0xF;
    if (((uint64_t)v287._object & 0x2000000000000000) != 0) {
      unint64_t v107 = ((unint64_t)v287._object >> 56) & 0xF;
    }
    else {
      unint64_t v107 = v287._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v107 && (v287._countAndFlagsBits & ~(uint64_t)v287._object & 0x2000000000000000) == 0)
    {
      v287._unint64_t countAndFlagsBits = 46;
      v287._unint64_t object = (void *)0xE100000000000000;
      uint64_t v122 = object;
      goto LABEL_138;
    }
    if (((uint64_t)v287._object & 0x2000000000000000) == 0 || v106 == 15)
    {
      swift_bridgeObjectRetain_n(0xE100000000000000, 6);
      if ((object & 0x1000000000000000) == 0)
      {
        BOOL v115 = __OFADD__(v107, 1);
        int64_t v116 = v107 + 1;
        if (v115) {
          goto LABEL_267;
        }
LABEL_125:
        if ((countAndFlagsBits & ~object & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
        {
          unint64_t v117 = (unint64_t)v287._object;
          int64_t v118 = _StringGuts.nativeUnusedCapacity.getter(v287._countAndFlagsBits, (uint64_t)v287._object);
          if (v119) {
            goto LABEL_284;
          }
          if (v116 > 15 || (v117 & 0x2000000000000000) == 0 && v118 > 0) {
            goto LABEL_131;
          }
        }
        else if (v116 > 15)
        {
LABEL_131:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v116, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v286 = xmmword_18162AFD0;
          Swift::String::Index v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v286, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v120, v121, 1);
          uint64_t v122 = 0xE100000000000000;
LABEL_138:
          swift_bridgeObjectRelease(v122);
          goto LABEL_139;
        }
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        unint64_t v123 = v287._countAndFlagsBits;
        unint64_t v124 = v287._object;
        swift_bridgeObjectRetain((unint64_t)v287._object);
        unint64_t v125 = _StringGuts._convertedToSmall()(v123, (unint64_t)v124);
        unint64_t v127 = v126;
        swift_bridgeObjectRelease((uint64_t)v124);
        v128._Swift::UInt64 rawBits = 1;
        v129._Swift::UInt64 rawBits = 65537;
        v130._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v128, v129, 0x2EuLL, 0xE100000000000000);
        if (v130._rawBits < 0x10000) {
          v130._rawBits |= 3;
        }
        unint64_t v132 = specialized String.init(_:)(v130, v131, 0x2EuLL, 0xE100000000000000);
        unint64_t v134 = v133;
        swift_bridgeObjectRelease(0xE100000000000000);
        unint64_t v135 = _StringGuts._convertedToSmall()(v132, v134);
        unint64_t v137 = v136;
        swift_bridgeObjectRelease(v134);
        unint64_t v138 = specialized _SmallString.init(_:appending:)(v125, v127, v135, v137);
        if (v140) {
          goto LABEL_283;
        }
        uint64_t v141 = v138;
        unint64_t v142 = v139;
        swift_bridgeObjectRelease(0xE100000000000000);
        uint64_t v122 = (uint64_t)v287._object;
        v287._unint64_t countAndFlagsBits = v141;
        v287._unint64_t object = v142;
        goto LABEL_138;
      }
      Swift::Int v273 = String.UTF8View._foreignCount()();
      int64_t v116 = v273 + 1;
      if (!__OFADD__(v273, 1)) {
        goto LABEL_125;
      }
LABEL_267:
      __break(1u);
LABEL_268:
      Swift::Int v274 = String.UTF8View._foreignCount()();
      int64_t v207 = v274 + 1;
      if (__OFADD__(v274, 1)) {
        goto LABEL_270;
      }
LABEL_204:
      if ((countAndFlagsBits & ~object & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        unint64_t v208 = (unint64_t)v287._object;
        int64_t v209 = _StringGuts.nativeUnusedCapacity.getter(v287._countAndFlagsBits, (uint64_t)v287._object);
        if ((v210 & 1) == 0)
        {
          if (v207 > 15 || (v208 & 0x2000000000000000) == 0 && v209 > 0) {
            goto LABEL_210;
          }
          goto LABEL_212;
        }
LABEL_284:
        unint64_t v282 = 258;
      }
      else
      {
        if (v207 > 15)
        {
LABEL_210:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v207, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v286 = xmmword_18162AFD0;
          Swift::String::Index v211 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v286, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v211, v212, 1);
          uint64_t v213 = 0xE100000000000000;
          goto LABEL_217;
        }
LABEL_212:
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        unint64_t v214 = v287._countAndFlagsBits;
        Swift::Int v215 = v287._object;
        swift_bridgeObjectRetain((unint64_t)v287._object);
        unint64_t v216 = _StringGuts._convertedToSmall()(v214, (unint64_t)v215);
        unint64_t v218 = v217;
        swift_bridgeObjectRelease((uint64_t)v215);
        v219._Swift::UInt64 rawBits = 1;
        v220._Swift::UInt64 rawBits = 65537;
        v221._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v219, v220, 0x2EuLL, 0xE100000000000000);
        if (v221._rawBits < 0x10000) {
          v221._rawBits |= 3;
        }
        unint64_t v223 = specialized String.init(_:)(v221, v222, 0x2EuLL, 0xE100000000000000);
        unint64_t v225 = v224;
        swift_bridgeObjectRelease(0xE100000000000000);
        unint64_t v226 = _StringGuts._convertedToSmall()(v223, v225);
        unint64_t v228 = v227;
        swift_bridgeObjectRelease(v225);
        unint64_t v229 = specialized _SmallString.init(_:appending:)(v216, v218, v226, v228);
        if ((v231 & 1) == 0)
        {
          uint64_t v232 = v229;
          unint64_t v233 = v230;
          swift_bridgeObjectRelease(0xE100000000000000);
          uint64_t v213 = (uint64_t)v287._object;
          v287._unint64_t countAndFlagsBits = v232;
          v287._unint64_t object = v233;
          goto LABEL_217;
        }
LABEL_283:
        unint64_t v282 = 266;
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v282, 0);
    }
    unint64_t v108 = 8 * (((unint64_t)v287._object >> 56) & 7);
    uint64_t v109 = (-255 << v108) - 1;
    uint64_t v110 = 46 << v108;
    uint64_t v111 = v110 | v109 & (uint64_t)v287._object;
    uint64_t v112 = v110 | v109 & v287._countAndFlagsBits;
    if (v106 < 8) {
      unint64_t countAndFlagsBits = v112;
    }
    else {
      unint64_t object = v111;
    }
    swift_bridgeObjectRelease(0xE100000000000000);
    unint64_t v113 = 0xA000000000000000;
    if (!(countAndFlagsBits & 0x8080808080808080 | object & 0x80808080808080)) {
      unint64_t v113 = 0xE000000000000000;
    }
    uint64_t v114 = (void *)((v113 & 0xFF00000000000000 | (v106 << 56) | object & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000);
    swift_bridgeObjectRelease((uint64_t)v287._object);
    v287._unint64_t countAndFlagsBits = countAndFlagsBits;
    v287._unint64_t object = v114;
LABEL_139:
    Swift::String v143 = _uint64ToString(_:radix:uppercase:)(BYTE1(a1), 10, 0);
    uint64_t v144 = v287._countAndFlagsBits;
    unint64_t v145 = (unint64_t)v287._object;
    unint64_t v146 = ((unint64_t)v287._object >> 56) & 0xF;
    unint64_t v147 = v287._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v287._object & 0x2000000000000000) != 0) {
      unint64_t v147 = ((unint64_t)v287._object >> 56) & 0xF;
    }
    if (!v147 && (v287._countAndFlagsBits & ~(uint64_t)v287._object & 0x2000000000000000) == 0)
    {
      Swift::String v287 = v143;
      swift_bridgeObjectRelease(v145);
      goto LABEL_189;
    }
    uint64_t v148 = (uint64_t)v143._object & 0x2000000000000000;
    unint64_t v149 = ((unint64_t)v143._object >> 56) & 0xF;
    if (((uint64_t)v287._object & 0x2000000000000000) != 0 && v148)
    {
      unint64_t v150 = v146 + v149;
      if (v146 + v149 <= 0xF)
      {
        if (v149)
        {
          char v181 = 0;
          unint64_t v182 = 0;
          do
          {
            unint64_t v183 = v146 + v182;
            unint64_t v184 = v182 + 1;
            if (v182 >= 8) {
              unint64_t v185 = (unint64_t)v143._object;
            }
            else {
              unint64_t v185 = v143._countAndFlagsBits;
            }
            unint64_t v186 = v185 >> (v181 & 0x38);
            char v187 = (8 * v146 + v181) & 0x38;
            uint64_t v188 = (-255 << v187) - 1;
            unint64_t v189 = (unint64_t)v186 << v187;
            unint64_t v190 = v189 | v188 & v145;
            unint64_t v191 = v189 | v188 & v144;
            if (v183 < 8) {
              uint64_t v144 = v191;
            }
            else {
              unint64_t v145 = v190;
            }
            v181 += 8;
            unint64_t v182 = v184;
          }
          while (v149 != v184);
        }
        swift_bridgeObjectRelease((uint64_t)v143._object);
        unint64_t v192 = 0xA000000000000000;
        if (!(v144 & 0x8080808080808080 | v145 & 0x80808080808080)) {
          unint64_t v192 = 0xE000000000000000;
        }
        unint64_t v193 = (void *)(v192 & 0xFF00000000000000 | (v150 << 56) | v145 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v287._object);
        v287._unint64_t countAndFlagsBits = v144;
        v287._unint64_t object = v193;
        goto LABEL_189;
      }
      uint64_t v148 = 1;
    }
    uint64_t v151 = v148 ? ((unint64_t)v143._object >> 56) & 0xF : v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 2);
    if (((uint64_t)v143._object & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v143._object, 5);
      v268._Swift::UInt64 rawBits = 1;
      v269._Swift::UInt64 rawBits = (v151 << 16) | 1;
      v270._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v268, v269, v143._countAndFlagsBits, (unint64_t)v143._object);
      if (v270._rawBits < 0x10000) {
        v270._rawBits |= 3;
      }
      Swift::Int v152 = specialized Collection.count.getter(v270, v271, v143._countAndFlagsBits, (unint64_t)v143._object);
      swift_bridgeObjectRelease((uint64_t)v143._object);
      uint64_t v144 = v287._countAndFlagsBits;
      unint64_t v145 = (unint64_t)v287._object;
      if (((uint64_t)v287._object & 0x1000000000000000) != 0)
      {
LABEL_262:
        Swift::Int v272 = String.UTF8View._foreignCount()();
        int64_t v153 = v272 + v152;
        if (__OFADD__(v272, v152)) {
          goto LABEL_155;
        }
        goto LABEL_157;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v143._object, 4);
      Swift::Int v152 = v151;
      if ((v145 & 0x1000000000000000) != 0) {
        goto LABEL_262;
      }
    }
    if ((v145 & 0x2000000000000000) != 0) {
      goto LABEL_156;
    }
    int64_t v153 = (v144 & 0xFFFFFFFFFFFFLL) + v152;
    if (__OFADD__(v144 & 0xFFFFFFFFFFFFLL, v152))
    {
      do
      {
LABEL_155:
        __break(1u);
LABEL_156:
        uint64_t v154 = HIBYTE(v145) & 0xF;
        int64_t v153 = v154 + v152;
      }
      while (__OFADD__(v154, v152));
    }
LABEL_157:
    if ((v144 & ~v145 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v145 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v155 = (unint64_t)v287._object;
      int64_t v156 = _StringGuts.nativeUnusedCapacity.getter(v287._countAndFlagsBits, (uint64_t)v287._object);
      if (v157) {
        goto LABEL_284;
      }
      if (v153 <= 15 && ((v155 & 0x2000000000000000) != 0 || v156 < v152))
      {
LABEL_167:
        swift_bridgeObjectRelease_n((uint64_t)v143._object, 5);
        unint64_t v161 = v287._countAndFlagsBits;
        uint64_t v162 = v287._object;
        swift_bridgeObjectRetain((unint64_t)v287._object);
        unint64_t v163 = _StringGuts._convertedToSmall()(v161, (unint64_t)v162);
        unint64_t v165 = v164;
        swift_bridgeObjectRelease((uint64_t)v162);
        v166._Swift::UInt64 rawBits = (v151 << 16) | 1;
        v167._Swift::UInt64 rawBits = 1;
        v168._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v167, v166, v143._countAndFlagsBits, (unint64_t)v143._object);
        if (v168._rawBits < 0x10000) {
          v168._rawBits |= 3;
        }
        unint64_t v170 = specialized String.init(_:)(v168, v169, v143._countAndFlagsBits, (unint64_t)v143._object);
        unint64_t v172 = v171;
        swift_bridgeObjectRelease((uint64_t)v143._object);
        unint64_t v173 = _StringGuts._convertedToSmall()(v170, v172);
        unint64_t v175 = v174;
        swift_bridgeObjectRelease(v172);
        unint64_t v176 = specialized _SmallString.init(_:appending:)(v163, v165, v173, v175);
        if (v178) {
          goto LABEL_283;
        }
        uint64_t v179 = v176;
        uint64_t v180 = v177;
        swift_bridgeObjectRelease((uint64_t)v143._object);
        unint64_t v160 = v287._object;
        v287._unint64_t countAndFlagsBits = v179;
        v287._unint64_t object = v180;
        goto LABEL_171;
      }
    }
    else if (v153 <= 15)
    {
      goto LABEL_167;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v153, v152);
    swift_bridgeObjectRelease_n((uint64_t)v143._object, 4);
    if (((uint64_t)v143._object & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v143._object);
      _StringGuts._foreignAppendInPlace(_:)(v143._countAndFlagsBits, (unint64_t)v143._object, 0, v151);
      swift_bridgeObjectRelease_n((uint64_t)v143._object, 2);
      a1 = v285;
    }
    else
    {
      if (v148)
      {
        swift_bridgeObjectRelease_n((uint64_t)v143._object, 2);
        *(void *)&long long v286 = v143._countAndFlagsBits;
        *((void *)&v286 + 1) = (uint64_t)v143._object & 0xFFFFFFFFFFFFFFLL;
        unint64_t v158 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v143._object >> 56) & 0xF, (uint64_t)&v286, ((unint64_t)v143._object >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v158, v159, ((uint64_t)v143._object & 0x4000000000000000) != 0);
        unint64_t v160 = v143._object;
LABEL_171:
        swift_bridgeObjectRelease((uint64_t)v160);
        a1 = v285;
        goto LABEL_189;
      }
      if ((v143._countAndFlagsBits & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease((uint64_t)v143._object);
        id v194 = (id)(((uint64_t)v143._object & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v195 = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v194 = _StringObject.sharedUTF8.getter(v143._countAndFlagsBits, (uint64_t)v143._object);
        uint64_t v195 = v281;
        swift_bridgeObjectRelease((uint64_t)v143._object);
        if (v195 < (v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
LABEL_282:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
      }
      a1 = v285;
      id v196 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL, (uint64_t)v194, v195);
      _StringGuts.appendInPlace(_:isASCII:)(v196, v197, v143._countAndFlagsBits < 0);
      swift_bridgeObjectRelease_n((uint64_t)v143._object, 2);
    }
LABEL_189:
    unint64_t countAndFlagsBits = v287._countAndFlagsBits;
    unint64_t object = (unint64_t)v287._object;
    unint64_t v198 = ((unint64_t)v287._object >> 56) & 0xF;
    unint64_t v199 = ((uint64_t)v287._object & 0x2000000000000000) != 0
         ? ((unint64_t)v287._object >> 56) & 0xF
         : v287._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v199 && (v287._countAndFlagsBits & ~(uint64_t)v287._object & 0x2000000000000000) == 0) {
      break;
    }
    if (((uint64_t)v287._object & 0x2000000000000000) != 0 && v198 != 15)
    {
      unint64_t v200 = 8 * (((unint64_t)v287._object >> 56) & 7);
      uint64_t v201 = (-255 << v200) - 1;
      uint64_t v202 = 46 << v200;
      uint64_t v203 = v202 | v201 & (uint64_t)v287._object;
      uint64_t v204 = v202 | v201 & v287._countAndFlagsBits;
      if (v198 < 8) {
        unint64_t countAndFlagsBits = v204;
      }
      else {
        unint64_t object = v203;
      }
      swift_bridgeObjectRelease(0xE100000000000000);
      unint64_t v205 = 0xA000000000000000;
      if (!(countAndFlagsBits & 0x8080808080808080 | object & 0x80808080808080)) {
        unint64_t v205 = 0xE000000000000000;
      }
      v206 = (void *)((v205 & 0xFF00000000000000 | (v198 << 56) | object & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000);
      swift_bridgeObjectRelease((uint64_t)v287._object);
      v287._unint64_t countAndFlagsBits = countAndFlagsBits;
      v287._unint64_t object = v206;
      goto LABEL_218;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((object & 0x1000000000000000) != 0) {
      goto LABEL_268;
    }
    BOOL v115 = __OFADD__(v199, 1);
    int64_t v207 = v199 + 1;
    if (!v115) {
      goto LABEL_204;
    }
LABEL_270:
    __break(1u);
LABEL_271:
    unint64_t v15 = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
    unint64_t v16 = v275;
LABEL_17:
    v17._Swift::UInt64 rawBits = 1;
    v18._Swift::UInt64 rawBits = 1;
    v19._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v17, v18, 0, 0xE000000000000000);
    if (v19._rawBits < 0x10000) {
      v19._rawBits |= 3;
    }
    unint64_t v21 = specialized String.init(_:)(v19, v20, 0, 0xE000000000000000);
    unint64_t v23 = v22;
    swift_bridgeObjectRelease(0xE000000000000000);
    if ((v23 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v23);
    }
    else
    {
      unint64_t v276 = v15;
      if ((v23 & 0x1000000000000000) != 0)
      {
        unint64_t v21 = _StringGuts._foreignConvertedToSmall()(v21, v23);
        unint64_t v284 = v283;
        swift_bridgeObjectRelease(v23);
        unint64_t v23 = v284;
      }
      else
      {
        if ((v21 & 0x1000000000000000) != 0)
        {
          v277 = (unsigned __int8 *)((v23 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v278 = v21 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v277 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v21, v23);
        }
        closure #1 in _StringGuts._convertedToSmall()(v277, v278, &v286);
        swift_bridgeObjectRelease(v23);
        unint64_t v23 = *((void *)&v286 + 1);
        unint64_t v21 = v286;
      }
      unint64_t v15 = v276;
      a1 = v285;
    }
    uint64_t v24 = HIBYTE(v16) & 0xF;
    uint64_t v25 = HIBYTE(v23) & 0xF;
    uint64_t v26 = v25 + v24;
    if ((unint64_t)(v25 + v24) > 0xF) {
      goto LABEL_283;
    }
    if (v25)
    {
      char v27 = 0;
      unint64_t v28 = 0;
      do
      {
        unint64_t v29 = v24 + v28;
        unint64_t v30 = v28 + 1;
        if (v28 >= 8) {
          unint64_t v31 = v23;
        }
        else {
          unint64_t v31 = v21;
        }
        unint64_t v32 = v31 >> (v27 & 0x38);
        char v33 = (8 * v24 + v27) & 0x38;
        uint64_t v34 = (-255 << v33) - 1;
        unint64_t v35 = (unint64_t)v32 << v33;
        unint64_t v36 = v35 | v34 & v16;
        unint64_t v37 = v35 | v34 & v15;
        if (v29 < 8) {
          unint64_t v15 = v37;
        }
        else {
          unint64_t v16 = v36;
        }
        v27 += 8;
        unint64_t v28 = v30;
      }
      while (v25 != v30);
    }
    swift_bridgeObjectRelease(0xE000000000000000);
    unint64_t v38 = 0xA000000000000000;
    if (!(v15 & 0x8080808080808080 | v16 & 0x80808080808080)) {
      unint64_t v38 = 0xE000000000000000;
    }
    uint64_t v39 = (uint64_t)v287._object;
    v287._unint64_t countAndFlagsBits = v15;
    v287._unint64_t object = (void *)(v38 & 0xFF00000000000000 | (v26 << 56) | v16 & 0xFFFFFFFFFFFFFFLL);
LABEL_59:
    swift_bridgeObjectRelease(v39);
LABEL_60:
    Swift::String v51 = _uint64ToString(_:radix:uppercase:)(HIWORD(a1), 10, 0);
    uint64_t v44 = v51._countAndFlagsBits;
    unint64_t countAndFlagsBits = (unint64_t)v51._object;
    uint64_t v52 = v287._countAndFlagsBits;
    unint64_t v53 = (unint64_t)v287._object;
    unint64_t v54 = ((unint64_t)v287._object >> 56) & 0xF;
    unint64_t v55 = v287._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v287._object & 0x2000000000000000) != 0) {
      unint64_t v55 = ((unint64_t)v287._object >> 56) & 0xF;
    }
    if (v55 || (v287._countAndFlagsBits & ~(uint64_t)v287._object & 0x2000000000000000) != 0)
    {
      uint64_t v56 = (uint64_t)v51._object & 0x2000000000000000;
      unint64_t v57 = ((unint64_t)v51._object >> 56) & 0xF;
      if (((uint64_t)v287._object & 0x2000000000000000) == 0 || !v56) {
        goto LABEL_68;
      }
      unint64_t v58 = v54 + v57;
      if (v54 + v57 <= 0xF)
      {
        if (v57)
        {
          char v89 = 0;
          unint64_t v90 = 0;
          do
          {
            unint64_t v91 = v54 + v90;
            unint64_t v92 = v90 + 1;
            if (v90 >= 8) {
              unint64_t v93 = (unint64_t)v51._object;
            }
            else {
              unint64_t v93 = v51._countAndFlagsBits;
            }
            unint64_t v94 = v93 >> (v89 & 0x38);
            char v95 = (8 * v54 + v89) & 0x38;
            uint64_t v96 = (-255 << v95) - 1;
            unint64_t v97 = (unint64_t)v94 << v95;
            unint64_t v98 = v97 | v96 & v53;
            unint64_t v99 = v97 | v96 & v52;
            if (v91 < 8) {
              uint64_t v52 = v99;
            }
            else {
              unint64_t v53 = v98;
            }
            v89 += 8;
            unint64_t v90 = v92;
          }
          while (v57 != v92);
        }
        swift_bridgeObjectRelease((uint64_t)v51._object);
        unint64_t v100 = 0xA000000000000000;
        if (!(v52 & 0x8080808080808080 | v53 & 0x80808080808080)) {
          unint64_t v100 = 0xE000000000000000;
        }
        uint64_t v101 = (void *)(v100 & 0xFF00000000000000 | (v58 << 56) | v53 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v287._object);
        v287._unint64_t countAndFlagsBits = v52;
        v287._unint64_t object = v101;
      }
      else
      {
        uint64_t v56 = 1;
LABEL_68:
        uint64_t v1 = v51._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (v56) {
          uint64_t v59 = ((unint64_t)v51._object >> 56) & 0xF;
        }
        else {
          uint64_t v59 = v51._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n((uint64_t)v51._object, 2);
        if (((uint64_t)v51._object & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRetain_n((uint64_t)v51._object, 5);
          v263._Swift::UInt64 rawBits = 1;
          v264._Swift::UInt64 rawBits = (v59 << 16) | 1;
          v265._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v263, v264, v51._countAndFlagsBits, (unint64_t)v51._object);
          if (v265._rawBits < 0x10000) {
            v265._rawBits |= 3;
          }
          Swift::Int v60 = specialized Collection.count.getter(v265, v266, v51._countAndFlagsBits, (unint64_t)v51._object);
          swift_bridgeObjectRelease((uint64_t)v51._object);
          uint64_t v52 = v287._countAndFlagsBits;
          unint64_t v53 = (unint64_t)v287._object;
          if (((uint64_t)v287._object & 0x1000000000000000) != 0)
          {
LABEL_256:
            Swift::Int v267 = String.UTF8View._foreignCount()();
            int64_t v61 = v267 + v60;
            if (!__OFADD__(v267, v60)) {
              goto LABEL_78;
            }
            goto LABEL_76;
          }
        }
        else
        {
          swift_bridgeObjectRetain_n((uint64_t)v51._object, 4);
          Swift::Int v60 = v59;
          if ((v53 & 0x1000000000000000) != 0) {
            goto LABEL_256;
          }
        }
        if ((v53 & 0x2000000000000000) == 0)
        {
          int64_t v61 = (v52 & 0xFFFFFFFFFFFFLL) + v60;
          if (!__OFADD__(v52 & 0xFFFFFFFFFFFFLL, v60)) {
            goto LABEL_78;
          }
          goto LABEL_76;
        }
        while (1)
        {
          uint64_t v62 = HIBYTE(v53) & 0xF;
          int64_t v61 = v62 + v60;
          if (!__OFADD__(v62, v60)) {
            break;
          }
LABEL_76:
          __break(1u);
        }
LABEL_78:
        if ((v52 & ~v53 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v53 & 0xFFFFFFFFFFFFFFFLL))
        {
          unint64_t v63 = (unint64_t)v287._object;
          int64_t v64 = _StringGuts.nativeUnusedCapacity.getter(v287._countAndFlagsBits, (uint64_t)v287._object);
          if (v65) {
            goto LABEL_284;
          }
          if (v61 <= 15 && ((v63 & 0x2000000000000000) != 0 || v64 < v60)) {
            goto LABEL_88;
          }
LABEL_84:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v61, v60);
          swift_bridgeObjectRelease_n((uint64_t)v51._object, 4);
          if (((uint64_t)v51._object & 0x1000000000000000) == 0)
          {
            if (v56)
            {
              swift_bridgeObjectRelease_n((uint64_t)v51._object, 2);
              *(void *)&long long v286 = v51._countAndFlagsBits;
              *((void *)&v286 + 1) = (uint64_t)v51._object & 0xFFFFFFFFFFFFFFLL;
              uint64_t v66 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v51._object >> 56) & 0xF, (uint64_t)&v286, ((unint64_t)v51._object >> 56) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v66, v67, ((uint64_t)v51._object & 0x4000000000000000) != 0);
              uint64_t v68 = v51._object;
              goto LABEL_92;
            }
            if ((v51._countAndFlagsBits & 0x1000000000000000) == 0) {
              goto LABEL_279;
            }
            swift_bridgeObjectRelease((uint64_t)v51._object);
            id v102 = (id)(((uint64_t)v51._object & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v103 = v51._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            goto LABEL_109;
          }
          swift_bridgeObjectRelease((uint64_t)v51._object);
          _StringGuts._foreignAppendInPlace(_:)(v51._countAndFlagsBits, (unint64_t)v51._object, 0, v59);
          swift_bridgeObjectRelease_n((uint64_t)v51._object, 2);
          a1 = v285;
        }
        else
        {
          if (v61 > 15) {
            goto LABEL_84;
          }
LABEL_88:
          swift_bridgeObjectRelease_n((uint64_t)v51._object, 5);
          unint64_t v69 = v287._countAndFlagsBits;
          uint64_t v70 = v287._object;
          swift_bridgeObjectRetain((unint64_t)v287._object);
          unint64_t v71 = _StringGuts._convertedToSmall()(v69, (unint64_t)v70);
          unint64_t v73 = v72;
          swift_bridgeObjectRelease((uint64_t)v70);
          v74._Swift::UInt64 rawBits = (v59 << 16) | 1;
          v75._Swift::UInt64 rawBits = 1;
          v76._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v75, v74, v51._countAndFlagsBits, (unint64_t)v51._object);
          if (v76._rawBits < 0x10000) {
            v76._rawBits |= 3;
          }
          unint64_t v78 = specialized String.init(_:)(v76, v77, v51._countAndFlagsBits, (unint64_t)v51._object);
          unint64_t v80 = v79;
          swift_bridgeObjectRelease((uint64_t)v51._object);
          unint64_t v81 = _StringGuts._convertedToSmall()(v78, v80);
          unint64_t v83 = v82;
          swift_bridgeObjectRelease(v80);
          unint64_t v84 = specialized _SmallString.init(_:appending:)(v71, v73, v81, v83);
          if (v86) {
            goto LABEL_283;
          }
          uint64_t v87 = v84;
          uint64_t v88 = v85;
          swift_bridgeObjectRelease((uint64_t)v51._object);
          uint64_t v68 = v287._object;
          v287._unint64_t countAndFlagsBits = v87;
          v287._unint64_t object = v88;
LABEL_92:
          swift_bridgeObjectRelease((uint64_t)v68);
          a1 = v285;
        }
      }
    }
    else
    {
      Swift::String v287 = v51;
      swift_bridgeObjectRelease(v53);
    }
  }
  v287._unint64_t countAndFlagsBits = 46;
  v287._unint64_t object = (void *)0xE100000000000000;
  uint64_t v213 = object;
LABEL_217:
  swift_bridgeObjectRelease(v213);
LABEL_218:
  Swift::String v234 = _uint64ToString(_:radix:uppercase:)(a1, 10, 0);
  uint64_t v236 = v287._countAndFlagsBits;
  unint64_t v235 = (unint64_t)v287._object;
  unint64_t v237 = ((unint64_t)v287._object >> 56) & 0xF;
  unint64_t v238 = v287._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v287._object & 0x2000000000000000) != 0) {
    unint64_t v238 = ((unint64_t)v287._object >> 56) & 0xF;
  }
  if (!v238 && (v287._countAndFlagsBits & ~(uint64_t)v287._object & 0x2000000000000000) == 0)
  {
    Swift::String v287 = v234;
    uint64_t v240 = v235;
    goto LABEL_228;
  }
  if (((uint64_t)v287._object & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v234._object & 0x2000000000000000) != 0)
    {
      uint64_t v239 = ((unint64_t)v234._object >> 56) & 0xF;
      goto LABEL_227;
    }
LABEL_226:
    uint64_t v239 = v234._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_227;
  }
  if (((uint64_t)v234._object & 0x2000000000000000) == 0) {
    goto LABEL_226;
  }
  uint64_t v239 = ((unint64_t)v234._object >> 56) & 0xF;
  unint64_t v249 = v237 + v239;
  if (v237 + v239 > 0xF)
  {
LABEL_227:
    _StringGuts.append(_:)(v234._countAndFlagsBits, (unint64_t)v234._object, 0, v239);
    uint64_t v240 = (uint64_t)v234._object;
LABEL_228:
    swift_bridgeObjectRelease(v240);
    goto LABEL_229;
  }
  if (v239)
  {
    char v250 = 0;
    unint64_t v251 = 0;
    do
    {
      unint64_t v252 = v237 + v251;
      unint64_t v253 = v251 + 1;
      if (v251 >= 8) {
        unint64_t v254 = (unint64_t)v234._object;
      }
      else {
        unint64_t v254 = v234._countAndFlagsBits;
      }
      unint64_t v255 = v254 >> (v250 & 0x38);
      char v256 = (8 * v237 + v250) & 0x38;
      uint64_t v257 = (-255 << v256) - 1;
      unint64_t v258 = (unint64_t)v255 << v256;
      unint64_t v259 = v258 | v257 & v235;
      unint64_t v260 = v258 | v257 & v236;
      if (v252 < 8) {
        uint64_t v236 = v260;
      }
      else {
        unint64_t v235 = v259;
      }
      v250 += 8;
      unint64_t v251 = v253;
    }
    while (v239 != v253);
  }
  swift_bridgeObjectRelease((uint64_t)v234._object);
  unint64_t v261 = 0xA000000000000000;
  if (!(v236 & 0x8080808080808080 | v235 & 0x80808080808080)) {
    unint64_t v261 = 0xE000000000000000;
  }
  v262 = (void *)(v261 & 0xFF00000000000000 | (v249 << 56) | v235 & 0xFFFFFFFFFFFFFFLL);
  swift_bridgeObjectRelease((uint64_t)v287._object);
  v287._unint64_t countAndFlagsBits = v236;
  v287._unint64_t object = v262;
LABEL_229:
  v241 = v287._object;
  unint64_t v242 = ((unint64_t)v287._object >> 56) & 0xF;
  if (((uint64_t)v287._object & 0x2000000000000000) == 0) {
    unint64_t v242 = v287._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v242 || (v287._countAndFlagsBits & ~(uint64_t)v287._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v287._object & 0x2000000000000000) == 0
      || (unint64_t v243 = specialized _SmallString.init(_:appending:)(v287._countAndFlagsBits, (unint64_t)v287._object, 0, 0xE000000000000000), (v245 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE000000000000000);
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease_n(0xE000000000000000, 2);
    }
    else
    {
      uint64_t v246 = v243;
      unint64_t v247 = v244;
      swift_bridgeObjectRelease(0xE000000000000000);
      swift_bridgeObjectRelease((uint64_t)v287._object);
      v287._unint64_t countAndFlagsBits = v246;
      v287._unint64_t object = v247;
    }
  }
  else
  {
    v287._unint64_t countAndFlagsBits = 0;
    v287._unint64_t object = (void *)0xE000000000000000;
    swift_bridgeObjectRelease((uint64_t)v241);
  }
  return v287._countAndFlagsBits;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _SwiftStdlibVersion()
{
  return _SwiftStdlibVersion.description.getter(*v0);
}

unint64_t CollectionDifference.insertions.getter()
{
  return swift_bridgeObjectRetain(*v0);
}

unint64_t CollectionDifference.removals.getter()
{
  return swift_bridgeObjectRetain(*(void *)(v0 + 8));
}

void CollectionDifference.init<A>(_:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  if (static CollectionDifference._validateChanges<A>(_:)(a1, a2, a3, a4))
  {
    CollectionDifference.init<A>(_validatedChanges:)(a1, a2, a3, a4, (__objc2_class ***)&v11);
    long long v10 = v11;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8))(a1, a3);
    long long v10 = 0uLL;
  }
  *a5 = v10;
}

uint64_t static CollectionDifference._validateChanges<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v141 = a2;
  uint64_t v7 = type metadata accessor for CollectionDifference.Change(0, a2, a3, a4);
  uint64_t v142 = (uint64_t)*(v7 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v7);
  Swift::String::Index v128 = (unsigned __int8 *)&v117 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v133 = (char *)&v117 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v135 = (unsigned __int8 *)&v117 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  unint64_t v138 = (uint64_t *)((char *)&v117 - v15);
  MEMORY[0x1F4188790](v14);
  char v140 = (char *)&v117 - v16;
  Swift::String::Index v19 = type metadata accessor for Optional(0, (uint64_t)v7, v17, v18);
  uint64_t v20 = MEMORY[0x1F4188790](v19 - 1);
  unint64_t v22 = (char *)&v117 - v21;
  uint64_t v23 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v20);
  uint64_t v25 = (char *)&v117 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v26, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v129 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v29 = (char *)&v117 - v28;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 104))(a3, a4))
  {
    char v30 = 1;
    return v30 & 1;
  }
  uint64_t v144 = &_swiftEmptySetSingleton;
  unint64_t v145 = &_swiftEmptySetSingleton;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v25, a1, a3);
  (*(void (**)(uint64_t, uint64_t))(v26 + 32))(a3, v26);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v26, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v32 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  char v33 = v29;
  uint64_t v126 = AssociatedConformanceWitness + 16;
  uint64_t v127 = AssociatedConformanceWitness;
  unint64_t v125 = v32;
  ((void (*)(const char *))v32)(AssociatedTypeWitness);
  uint64_t v34 = v142;
  unint64_t v35 = *(unsigned int (**)(char *, uint64_t, Class *))(v142 + 48);
  uint64_t v124 = v142 + 48;
  unint64_t v123 = v35;
  unint64_t v36 = AssociatedTypeWitness;
  if (v35(v22, 1, v7) == 1)
  {
    unint64_t v136 = &_swiftEmptyDictionarySingleton;
    unint64_t v137 = &_swiftEmptyDictionarySingleton;
LABEL_5:
    (*(void (**)(char *, const char *))(v129 + 8))(v33, v36);
    swift_bridgeObjectRelease((uint64_t)v144);
    swift_bridgeObjectRelease((uint64_t)v145);
    unint64_t v37 = v136;
    unint64_t v38 = v137;
    char v30 = specialized static Dictionary<>.== infix(_:_:)((unint64_t)v136, (uint64_t)v137);
    swift_bridgeObjectRelease((uint64_t)v38);
    swift_bridgeObjectRelease((uint64_t)v37);
    return v30 & 1;
  }
  unint64_t v40 = *(void (**)(unsigned __int8 *, char *, Class *))(v34 + 32);
  uint64_t v39 = v34 + 32;
  Swift::String::Index v130 = v40;
  int64_t v41 = (void (**)(char *, char *, Class *))(v39 - 16);
  uint64_t v122 = v141 - 8;
  unint64_t v117 = (void (**)(char *, uint64_t))(v39 - 24);
  unint64_t v136 = &_swiftEmptyDictionarySingleton;
  unint64_t v137 = &_swiftEmptyDictionarySingleton;
  char v42 = v140;
  uint64_t v142 = v39;
  Swift::String::Index v120 = v36;
  char v119 = v29;
  unint64_t v132 = (void (**)(char *, char *, Class *))(v39 - 16);
  int64_t v118 = v22;
  size_t v121 = v7;
  v40((unsigned __int8 *)v140, v22, v7);
  while (1)
  {
    uint64_t v44 = v7;
    uint64_t v45 = *v41;
    char v46 = v138;
    (*v41)((char *)v138, v42, v44);
    uint64_t v47 = *v46;
    uint64_t v48 = v141;
    unint64_t v49 = (char *)v46
        + *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v141, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0)+ 12);
    size_t v50 = *(void (**)(char *, uint64_t))(*(void *)(v48 - 8) + 8);
    uint64_t v51 = (uint64_t)v121;
    v50(v49, v48);
    if (v47 < 0)
    {
      (*v117)(v42, v51);
LABEL_59:
      (*(void (**)(char *, const char *))(v129 + 8))(v119, v120);
      swift_bridgeObjectRelease((uint64_t)v144);
      swift_bridgeObjectRelease((uint64_t)v145);
      goto LABEL_53;
    }
    uint64_t v134 = v47;
    uint64_t v52 = v42;
    uint64_t v53 = v48;
    unint64_t v54 = v135;
    Swift::String::Index v131 = v45;
    v45((char *)v135, v52, (Class *)v51);
    uint64_t v55 = v51;
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v54, v51);
    unint64_t v57 = &v54[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v53, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0)+ 12)];
    unint64_t v139 = (void (*)(unsigned __int8 *, uint64_t))v50;
    if (EnumCaseMultiPayload == 1)
    {
      unint64_t v58 = v144;
      uint64_t v59 = (Class *)v55;
      uint64_t v60 = v53;
      uint64_t v61 = v134;
      if (v144[2])
      {
        uint64_t v62 = specialized static Hasher._hash(seed:_:)((uint64_t)v144[5], v134);
        uint64_t v63 = -1 << *((unsigned char *)v58 + 32);
        unint64_t v64 = v62 & ~v63;
        if ((*(unint64_t *)((char *)v58 + ((v64 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) >> v64))
        {
          uint64_t v65 = ~v63;
          while (*((void *)&v58[6]->isa + v64) != v61)
          {
            unint64_t v64 = (v64 + 1) & v65;
            if (((*(unint64_t *)((char *)v58 + ((v64 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) >> v64) & 1) == 0) {
              goto LABEL_23;
            }
          }
          goto LABEL_52;
        }
      }
    }
    else
    {
      uint64_t v66 = v145;
      uint64_t v59 = (Class *)v55;
      uint64_t v60 = v53;
      uint64_t v61 = v134;
      if (v145[2])
      {
        uint64_t v67 = specialized static Hasher._hash(seed:_:)((uint64_t)v145[5], v134);
        uint64_t v68 = -1 << *((unsigned char *)v66 + 32);
        unint64_t v69 = v67 & ~v68;
        if ((*(unint64_t *)((char *)v66 + ((v69 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) >> v69))
        {
          uint64_t v70 = ~v68;
          while (*((void *)&v66[6]->isa + v69) != v61)
          {
            unint64_t v69 = (v69 + 1) & v70;
            if (((*(unint64_t *)((char *)v66 + ((v69 >> 3) & 0xFFFFFFFFFFFFFF8) + 56) >> v69) & 1) == 0) {
              goto LABEL_23;
            }
          }
LABEL_52:
          (*v117)(v140, (uint64_t)v59);
          (*(void (**)(char *, const char *))(v129 + 8))(v119, v120);
          swift_bridgeObjectRelease((uint64_t)v144);
          swift_bridgeObjectRelease((uint64_t)v145);
          v139(v57, v60);
LABEL_53:
          uint64_t v114 = v137;
LABEL_54:
          swift_bridgeObjectRelease((uint64_t)v114);
          BOOL v115 = v136;
          goto LABEL_55;
        }
      }
    }
LABEL_23:
    specialized Set._Variant.insert(_:)((uint64_t *)&v143, v61);
    unint64_t v71 = (void (*)(char *, uint64_t))v139;
    v139(v57, v60);
    unint64_t v72 = v133;
    char v42 = v140;
    uint64_t v7 = v59;
    v131(v133, v140, v59);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v60, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    Swift::String::Index v74 = &v72[*((int *)TupleTypeMetadata3 + 12)];
    Swift::String::Index v75 = &v72[*((int *)TupleTypeMetadata3 + 16)];
    uint64_t v76 = *(void *)v75;
    LODWORD(v72) = v75[8];
    v71(v74, v60);
    if (v72 == 1)
    {
      (*v117)(v42, (uint64_t)v7);
      unint64_t v36 = v120;
      long long v43 = v118;
      int64_t v41 = v132;
      goto LABEL_8;
    }
    if (v76 < 0)
    {
      (*v117)(v42, (uint64_t)v7);
      goto LABEL_59;
    }
    Swift::String::Index v77 = v128;
    v130(v128, v42, v7);
    int v78 = swift_getEnumCaseMultiPayload(v77, (uint64_t)v7);
    unint64_t v79 = &v77[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v60, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0)+ 12)];
    if (v78 == 1) {
      break;
    }
    unint64_t v92 = v137;
    if (v137[2])
    {
      specialized __RawDictionaryStorage.find<A>(_:)(v76);
      unint64_t v92 = v137;
      if (v93)
      {
        (*(void (**)(char *, const char *))(v129 + 8))(v119, v120);
        swift_bridgeObjectRelease((uint64_t)v144);
        swift_bridgeObjectRelease((uint64_t)v145);
        v139(v79, v60);
        uint64_t v114 = v92;
        goto LABEL_54;
      }
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v92);
    uint64_t v95 = v76;
    char v96 = isUniquelyReferenced_nonNull_native;
    Swift::String v143 = v92;
    uint64_t v97 = v95;
    unint64_t v99 = specialized __RawDictionaryStorage.find<A>(_:)(v95);
    unint64_t v100 = v137[2];
    BOOL v101 = (v98 & 1) == 0;
    uint64_t v102 = (uint64_t)v100 + v101;
    if (__OFADD__(v100, v101)) {
      goto LABEL_63;
    }
    char v103 = v98;
    if ((uint64_t)v137[3] >= v102)
    {
      if ((v96 & 1) == 0) {
        specialized _NativeDictionary.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
      }
    }
    else
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v102, v96);
      unint64_t v104 = specialized __RawDictionaryStorage.find<A>(_:)(v97);
      if ((v103 & 1) != (v105 & 1)) {
        goto LABEL_66;
      }
      unint64_t v99 = v104;
    }
    char v42 = v140;
    unint64_t v106 = v143;
    unint64_t v137 = v143;
    if ((v103 & 1) == 0)
    {
      v143[(v99 >> 6) + 8] = (__objc2_class *)((unint64_t)v143[(v99 >> 6) + 8] | (1 << v99));
      uint64_t v112 = 8 * v99;
      *(__objc2_class **)((char *)&v106[6]->isa + v112) = (__objc2_class *)v97;
      *(__objc2_class **)((char *)&v106[7]->isa + v112) = (__objc2_class *)v61;
      unint64_t v113 = v106[2];
      BOOL v110 = __OFADD__(v113, 1);
      uint64_t v111 = (__objc2_class *)((char *)&v113->isa + 1);
      if (v110) {
        goto LABEL_65;
      }
      goto LABEL_50;
    }
    unint64_t v107 = v79;
    *((void *)&v143[7]->isa + v99) = v61;
LABEL_51:
    unint64_t v36 = v120;
    long long v43 = v118;
    int64_t v41 = v132;
    swift_bridgeObjectRelease(0x8000000000000000);
    v139(v107, v141);
LABEL_8:
    char v33 = v119;
    v125(v36, v127);
    if (v123(v43, 1, v7) == 1) {
      goto LABEL_5;
    }
    v130((unsigned __int8 *)v42, v43, v7);
  }
  unint64_t v80 = v136;
  if (!v136[2] || (specialized __RawDictionaryStorage.find<A>(_:)(v61), unint64_t v80 = v136, (v81 & 1) == 0))
  {
    uint64_t v82 = v76;
    char v83 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v80);
    Swift::String v143 = v80;
    unint64_t v85 = specialized __RawDictionaryStorage.find<A>(_:)(v61);
    char v86 = v136[2];
    BOOL v87 = (v84 & 1) == 0;
    uint64_t v88 = (uint64_t)v86 + v87;
    if (__OFADD__(v86, v87))
    {
      __break(1u);
LABEL_63:
      __break(1u);
LABEL_64:
      __break(1u);
LABEL_65:
      __break(1u);
LABEL_66:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for Int);
    }
    char v89 = v84;
    if ((uint64_t)v136[3] >= v88)
    {
      if ((v83 & 1) == 0) {
        specialized _NativeDictionary.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
      }
    }
    else
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v88, v83);
      unint64_t v90 = specialized __RawDictionaryStorage.find<A>(_:)(v61);
      if ((v89 & 1) != (v91 & 1)) {
        goto LABEL_66;
      }
      unint64_t v85 = v90;
    }
    char v42 = v140;
    unint64_t v106 = v143;
    unint64_t v136 = v143;
    if ((v89 & 1) == 0)
    {
      v143[(v85 >> 6) + 8] = (__objc2_class *)((unint64_t)v143[(v85 >> 6) + 8] | (1 << v85));
      uint64_t v108 = 8 * v85;
      *(__objc2_class **)((char *)&v106[6]->isa + v108) = (__objc2_class *)v61;
      *(__objc2_class **)((char *)&v106[7]->isa + v108) = (__objc2_class *)v82;
      uint64_t v109 = v106[2];
      BOOL v110 = __OFADD__(v109, 1);
      uint64_t v111 = (__objc2_class *)((char *)&v109->isa + 1);
      if (v110) {
        goto LABEL_64;
      }
LABEL_50:
      unint64_t v107 = v79;
      void v106[2] = v111;
      goto LABEL_51;
    }
    unint64_t v107 = v79;
    *((void *)&v143[7]->isa + v85) = v82;
    goto LABEL_51;
  }
  (*(void (**)(char *, const char *))(v129 + 8))(v119, v120);
  swift_bridgeObjectRelease((uint64_t)v144);
  swift_bridgeObjectRelease((uint64_t)v145);
  v139(v79, v60);
  swift_bridgeObjectRelease((uint64_t)v137);
  BOOL v115 = v80;
LABEL_55:
  swift_bridgeObjectRelease((uint64_t)v115);
  char v30 = 0;
  return v30 & 1;
}

void CollectionDifference.init<A>(_validatedChanges:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, __objc2_class ***a5@<X8>)
{
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, a2, a3, a4);
  uint64_t v11 = *(v10 - 1);
  uint64_t v73 = *(void *)(v11 + 64);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (unsigned __int8 *)&v71 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v80 = a2;
  uint64_t v81 = a3;
  uint64_t v82 = a4;
  uint64_t v74 = v16;
  uint64_t v75 = a1;
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))((char *)&v71 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a3);
  uint64_t v83 = (*(uint64_t (**)(uint64_t))(*(void *)(a4 + 8) + 56))(a3);
  Swift::String::Index v19 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v10, v17, v18);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v19, v20);
  uint64_t v23 = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v19, v22);
  MutableCollection<>.sort(by:)((uint64_t)partial apply for closure #1 in CollectionDifference.init<A>(_validatedChanges:), (uint64_t)v79, (uint64_t)v19, WitnessTable, v23);
  uint64_t v24 = v83;
  uint64_t v76 = a3;
  if (Array._getCount()())
  {
    Swift::Int v25 = Array._getCount()();
    if (v25 < 0) {
LABEL_36:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
    Swift::Int v26 = v25;
    if (v25)
    {
      unint64_t v72 = a5;
      uint64_t v27 = 0;
      Swift::String::Index v77 = (void (**)(unsigned __int8 *, uint64_t *, uint64_t *))(v11 + 16);
      unint64_t v78 = v24 & 0xC000000000000001;
      do
      {
        if (__OFADD__(v27, v26))
        {
          __break(1u);
          goto LABEL_38;
        }
        uint64_t v30 = (v27 + v26) / 2;
        BOOL v29 = v78 == 0;
        char v31 = v29 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v30, v31 & 1);
        if (v31)
        {
          (*(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v11 + 16))(v14, v24+ ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))+ *(void *)(v11 + 72) * v30, v10);
        }
        else
        {
          id v32 = _ArrayBuffer._getElementSlowPath(_:)(v30, v24, v10);
          char v33 = v32;
          if (v73 != 8)
          {
            swift_unknownObjectRelease(v32);
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
          }
          uint64_t v83 = (uint64_t)v32;
          (*v77)(v14, &v83, v10);
          swift_unknownObjectRelease(v33);
        }
        if (swift_getEnumCaseMultiPayload(v14, (uint64_t)v10) == 1)
        {
          if (v26 <= v30) {
            goto LABEL_36;
          }
          uint64_t v27 = v30 + 1;
        }
        else
        {
          Swift::Int v26 = (v27 + v26) / 2;
          if (v30 < v27) {
            goto LABEL_36;
          }
        }
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a2, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
        (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)(a2 - 8) + 8))(&v14[*((int *)TupleTypeMetadata3 + 12)], a2);
      }
      while (v27 != v26);
      a5 = v72;
      if (v26 < 0) {
LABEL_38:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
  }
  else
  {
    Swift::Int v26 = 0;
  }
  Array._checkIndex(_:)(0);
  Array._checkIndex(_:)(v26);
  swift_retain((atomic_ullong *)v24);
  unint64_t v36 = (void *)_ArrayBuffer.subscript.getter(0, v26, v24, v10);
  uint64_t v38 = v37;
  uint64_t v39 = v34;
  unint64_t v40 = v35;
  if ((v35 & 1) == 0) {
    goto LABEL_19;
  }
  uint64_t v45 = a5;
  uint64_t v46 = type metadata accessor for __ContiguousArrayStorageBase();
  uint64_t v47 = swift_unknownObjectRetain_n((uint64_t)v36, 2);
  uint64_t v48 = (__objc2_class **)swift_dynamicCastClass(v47, v46);
  if (!v48)
  {
    swift_unknownObjectRelease(v36);
    uint64_t v48 = &_swiftEmptyArrayStorage;
  }
  unint64_t v49 = v48[2];
  size_t v50 = (void *)swift_release((uint64_t)v48);
  if (__OFSUB__(v40 >> 1, v39))
  {
    __break(1u);
    goto LABEL_40;
  }
  size_t v50 = v36;
  if (v49 != (__objc2_class *)((v40 >> 1) - v39))
  {
LABEL_40:
    swift_unknownObjectRelease(v50);
    a5 = v45;
LABEL_19:
    uint64_t v83 = (uint64_t)v36;
    uint64_t v84 = v38;
    uint64_t v85 = v39;
    unint64_t v86 = v40;
    int64_t v41 = (unint64_t *)type metadata accessor for ArraySlice(0, (uint64_t)v10, v34, v35);
    uint64_t v43 = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, v41, v42);
    uint64_t v44 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v83, (uint64_t)v41, v43);
    swift_unknownObjectRelease(v36);
    goto LABEL_26;
  }
  uint64_t v44 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v36, v46);
  swift_unknownObjectRelease(v36);
  a5 = v45;
  if (!v44)
  {
    swift_unknownObjectRelease(v36);
    uint64_t v44 = &_swiftEmptyArrayStorage;
  }
LABEL_26:
  Swift::Int v51 = Array._getCount()();
  if (v51 < v26) {
    goto LABEL_38;
  }
  Swift::Int v52 = v51;
  (*(void (**)(uint64_t, uint64_t))(v74 + 8))(v75, v76);
  Array._checkIndex(_:)(v52);
  swift_release(v24);
  uint64_t v53 = (void *)_ArrayBuffer.subscript.getter(v26, v52, v24, v10);
  uint64_t v55 = v54;
  uint64_t v57 = v56;
  unint64_t v59 = v58;
  swift_release(v24);
  if ((v59 & 1) == 0) {
    goto LABEL_28;
  }
  uint64_t v66 = type metadata accessor for __ContiguousArrayStorageBase();
  uint64_t v67 = swift_unknownObjectRetain_n((uint64_t)v53, 3);
  uint64_t v68 = (__objc2_class **)swift_dynamicCastClass(v67, v66);
  if (!v68)
  {
    swift_unknownObjectRelease(v53);
    uint64_t v68 = &_swiftEmptyArrayStorage;
  }
  unint64_t v69 = v68[2];
  uint64_t v70 = swift_release((uint64_t)v68);
  if (__OFSUB__(v59 >> 1, v57))
  {
    __break(1u);
    goto LABEL_42;
  }
  uint64_t v70 = (uint64_t)v53;
  if (v69 != (__objc2_class *)((v59 >> 1) - v57))
  {
LABEL_42:
    swift_unknownObjectRelease_n(v70, 2);
LABEL_28:
    uint64_t v83 = (uint64_t)v53;
    uint64_t v84 = v55;
    uint64_t v85 = v57;
    unint64_t v86 = v59;
    uint64_t v62 = (unint64_t *)type metadata accessor for ArraySlice(0, (uint64_t)v10, v60, v61);
    uint64_t v64 = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, v62, v63);
    uint64_t v65 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v83, (uint64_t)v62, v64);
    swift_unknownObjectRelease(v53);
    goto LABEL_35;
  }
  uint64_t v65 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v53, v66);
  swift_unknownObjectRelease_n((uint64_t)v53, 2);
  if (!v65)
  {
    swift_unknownObjectRelease(v53);
    uint64_t v65 = &_swiftEmptyArrayStorage;
  }
LABEL_35:
  *a5 = v65;
  a5[1] = v44;
}

BOOL closure #1 in CollectionDifference.init<A>(_validatedChanges:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v45 = a2;
  uint64_t v6 = type metadata accessor for CollectionDifference.Change(0, a3, a3, a4);
  uint64_t v7 = (uint64_t)*(v6 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v44 = (char *)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  unint64_t v40 = (char *)&v40 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v40 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v40 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v6, (uint64_t)v6, 0, 0);
  uint64_t v18 = *(TupleTypeMetadata2 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v21 = (unsigned __int8 *)&v40 - v20;
  int64_t v41 = (Class *)v19;
  uint64_t v42 = a1;
  uint64_t v22 = (unsigned __int8 *)&v40 + *(int *)(v19 + 48) - v20;
  uint64_t v43 = v7;
  uint64_t v23 = *(void (**)(char *, uint64_t, Class *))(v7 + 16);
  uint64_t v24 = a1;
  uint64_t v25 = v45;
  v23((char *)&v40 - v20, v24, v6);
  v23((char *)v22, v25, v6);
  if (swift_getEnumCaseMultiPayload(v21, (uint64_t)v6) != 1)
  {
    v23(v14, (uint64_t)v21, v6);
    uint64_t v30 = *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0)+ 12);
    uint64_t v27 = &v14[v30];
    if (swift_getEnumCaseMultiPayload(v22, (uint64_t)v6) == 1)
    {
      char v31 = *(void (**)(unsigned __int8 *, uint64_t))(*(void *)(a3 - 8) + 8);
      v31(&v22[v30], a3);
      v31((unsigned __int8 *)v27, a3);
      BOOL v29 = 0;
      uint64_t v18 = v43;
      goto LABEL_7;
    }
LABEL_6:
    id v32 = *(void (**)(char *, uint64_t))(*(void *)(a3 - 8) + 8);
    v32(v27, a3);
    char v33 = v40;
    v23(v40, v42, v6);
    uint64_t v34 = *(void *)v33;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    v32(&v33[*((int *)TupleTypeMetadata3 + 12)], a3);
    unint64_t v36 = v44;
    v23(v44, v45, v6);
    uint64_t v37 = *(void *)v36;
    uint64_t v38 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    v32(&v36[*((int *)v38 + 12)], a3);
    BOOL v29 = v34 < v37;
    uint64_t v6 = v41;
    goto LABEL_7;
  }
  v23(v16, (uint64_t)v21, v6);
  uint64_t v26 = *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0)+ 12);
  uint64_t v27 = &v16[v26];
  if (swift_getEnumCaseMultiPayload(v22, (uint64_t)v6) == 1) {
    goto LABEL_6;
  }
  uint64_t v28 = *(void (**)(unsigned __int8 *, uint64_t))(*(void *)(a3 - 8) + 8);
  v28(&v22[v26], a3);
  v28((unsigned __int8 *)v27, a3);
  BOOL v29 = 1;
  uint64_t v18 = v43;
LABEL_7:
  (*(void (**)(unsigned __int8 *, Class *))(v18 + 8))(v21, v6);
  return v29;
}

void CollectionDifference.inverse()(unint64_t *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  uint64_t v56 = a1;
  uint64_t v57 = a1[2];
  uint64_t v6 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v57, a2, a3);
  uint64_t v7 = *(v6 - 1);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v54 = (unsigned __int8 *)&v46 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v55 = (char *)&v46 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v53 = (uint64_t)&v46 - v13;
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v46 - v14;
  uint64_t v16 = v4[1];
  v60[0] = *v4;
  v60[1] = v16;
  Swift::Int v17 = Array._getCount()();
  Swift::Int v18 = Array._getCount()();
  Swift::Int v21 = v17 + v18;
  if (__OFADD__(v17, v18))
  {
    __break(1u);
    goto LABEL_12;
  }
  if (!v21)
  {
    _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
    uint64_t v42 = &_swiftEmptyArrayStorage;
    goto LABEL_10;
  }
  unint64_t v59 = &_swiftEmptyArrayStorage;
  Swift::Int v52 = type metadata accessor for ContiguousArray(0, (uint64_t)v6, v19, v20);
  ContiguousArray.reserveCapacity(_:)(v21);
  if (v21 < 0) {
LABEL_12:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  Swift::Int v24 = 0;
  unint64_t v49 = (void (**)(unsigned __int8 *, char *, uint64_t *))(v7 + 16);
  size_t v50 = (void (**)(char *, uint64_t, uint64_t *))(v7 + 32);
  uint64_t v48 = v57 - 8;
  uint64_t v46 = a4;
  uint64_t v47 = (void (**)(char *, uint64_t *))(v7 + 8);
  Swift::Int v51 = v21;
  uint64_t v25 = v55;
  uint64_t v26 = v57;
  while (v21 != v24)
  {
    Swift::Int v27 = v24 + 1;
    uint64_t v28 = v53;
    CollectionDifference.subscript.getter(v24, (uint64_t)v56, v22, v23, v53);
    (*v50)(v25, v28, v6);
    BOOL v29 = v54;
    (*v49)(v54, v25, v6);
    unsigned int v30 = swift_getEnumCaseMultiPayload(v29, (uint64_t)v6) != 1;
    uint64_t v31 = *(void *)v29;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v26, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    uint64_t v33 = *((int *)TupleTypeMetadata3 + 12);
    uint64_t v34 = &v29[v33];
    uint64_t v35 = &v29[*((int *)TupleTypeMetadata3 + 16)];
    uint64_t v36 = *(void *)v35;
    LOBYTE(v29) = v35[8];
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(*(void *)(v26 - 8) + 32))(&v15[v33], v34, v26);
    uint64_t v37 = &v15[*((int *)TupleTypeMetadata3 + 16)];
    *(void *)uint64_t v15 = v31;
    Swift::Int v21 = v51;
    *(void *)uint64_t v37 = v36;
    v37[8] = (char)v29;
    swift_storeEnumTagMultiPayload(v15, (uint64_t)v6, v30);
    (*v47)(v25, v6);
    ContiguousArray.append(_:)((uint64_t)v15, (uint64_t)v52);
    Swift::Int v24 = v27;
    if (v27 == 0x8000000000000000)
    {
      __break(1u);
      break;
    }
  }
  Swift::Int v58 = v21;
  uint64_t v38 = v56;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionDifference<A>, v56, v22);
  _expectEnd<A>(of:is:)((uint64_t)v60, (uint64_t)&v58, (uint64_t)v38, WitnessTable);
  uint64_t v42 = v59;
  a4 = v46;
LABEL_10:
  v60[0] = v42;
  uint64_t v43 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v6, v40, v41);
  uint64_t v45 = swift_getWitnessTable(protocol conformance descriptor for [A], v43, v44);
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)v60, v57, (uint64_t)v43, v45, a4);
}

BOOL static CollectionDifference.CodingKeys.== infix(_:_:)(int a1, int a2)
{
  return ((a2 ^ a1) & 1) == 0;
}

void CollectionDifference.CodingKeys.hash(into:)(uint64_t a1, char a2)
{
}

uint64_t CollectionDifference.CodingKeys.init(stringValue:)(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6F69747265736E69 && a2 == 0xEA0000000000736ELL) {
    goto LABEL_10;
  }
  if ((~a2 & 0x6000000000000000) == 0)
  {
    if (a1 != 0x736C61766F6D6572 || a2 != 0xE800000000000000)
    {
      swift_bridgeObjectRelease(a2);
      swift_bridgeObjectRelease(0xE800000000000000);
      return 2;
    }
    goto LABEL_13;
  }
  if (_stringCompareInternal(_:_:expecting:)(0x6F69747265736E69, 0xEA0000000000736ELL, a1, a2, 0))
  {
LABEL_10:
    swift_bridgeObjectRelease(a2);
    return 0;
  }
  if (a1 == 0x736C61766F6D6572 && a2 == 0xE800000000000000)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE800000000000000, 2);
    return 1;
  }
  char v6 = _stringCompareInternal(_:_:expecting:)(0x736C61766F6D6572, 0xE800000000000000, a1, a2, 0);
  swift_bridgeObjectRelease(a2);
  swift_bridgeObjectRelease(0xE800000000000000);
  if (v6) {
    return 1;
  }
  else {
    return 2;
  }
}

Swift::Int CollectionDifference.CodingKeys.hashValue.getter(char a1)
{
  return Hasher._finalize()();
}

uint64_t CollectionDifference.CodingKeys.stringValue.getter(char a1)
{
  if (a1) {
    return 0x736C61766F6D6572;
  }
  else {
    return 0x6F69747265736E69;
  }
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.CodingKeys(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return static CollectionDifference.CodingKeys.== infix(_:_:)(*a1, *a2);
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return CollectionDifference.CodingKeys.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
  CollectionDifference.CodingKeys.hash(into:)(a1, *v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v3[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v3[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v4 = 0u;
  long long v5 = 0u;
  CollectionDifference.CodingKeys.hash(into:)((uint64_t)v3, *v1);
  return Hasher._finalize()();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return CollectionDifference.CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance CollectionDifference<A>.CodingKeys@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = CollectionDifference.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CodingKey.intValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return 0;
}

void protocol witness for CodingKey.init(intValue:) in conformance CollectionDifference<A>.CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance CollectionDifference<A>.CodingKeys(uint64_t *a1)
{
  return CodingKey.description.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.CodingKeys);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
  return CodingKey.debugDescription.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.CodingKeys);
}

uint64_t CollectionDifference.startIndex.getter()
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
}

Swift::Int CollectionDifference.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  type metadata accessor for CollectionDifference.Change(0, *(void *)(a1 + 16), a3, a4);
  Swift::Int v4 = Array._getCount()();
  Swift::Int v5 = Array._getCount()();
  BOOL v6 = __OFADD__(v4, v5);
  Swift::Int result = v4 + v5;
  if (v6) {
    __break(1u);
  }
  return result;
}

uint64_t CollectionDifference.index(after:)(uint64_t a1)
{
  return specialized CollectionDifference.index(after:)(a1);
}

void CollectionDifference.subscript.getter(Swift::Int a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  Swift::Int v8 = *v5;
  Swift::Int v9 = v5[1];
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, *(void *)(a2 + 16), a3, a4);
  Swift::Int v11 = Array._getCount()();
  if (v11 > a1)
  {
    Swift::Int v8 = v11 - (a1 + 1);
    if (!__OFSUB__(v11, a1 + 1))
    {
      char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      char v13 = ((v9 & 0xC000000000000001) == 0) | ~isClassOrObjCExistentialType;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v8, (v9 & 0xC000000000000001) == 0 || (isClassOrObjCExistentialType & 1) == 0);
      if (v13)
      {
        uint64_t v14 = *(v10 - 1);
        uint64_t v15 = *(void (**)(uint64_t, unint64_t, uint64_t *))(v14 + 16);
        unint64_t v16 = v9
            + ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80))
            + *(void *)(v14 + 72) * v8;
LABEL_8:
        v15(a5, v16, v10);
        return;
      }
      goto LABEL_13;
    }
    __break(1u);
LABEL_12:
    __break(1u);
LABEL_13:
    unint64_t v20 = v8;
    uint64_t v21 = v9;
    goto LABEL_15;
  }
  Swift::Int v9 = a1 - v11;
  if (__OFSUB__(a1, v11)) {
    goto LABEL_12;
  }
  char v17 = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
  char v18 = ((v8 & 0xC000000000000001) == 0) | ~v17;
  Array._checkSubscript(_:wasNativeTypeChecked:)(v9, (v8 & 0xC000000000000001) == 0 || (v17 & 1) == 0);
  if (v18)
  {
    uint64_t v19 = *(v10 - 1);
    uint64_t v15 = *(void (**)(uint64_t, unint64_t, uint64_t *))(v19 + 16);
    unint64_t v16 = v8
        + ((*(unsigned __int8 *)(v19 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80))
        + *(void *)(v19 + 72) * v9;
    goto LABEL_8;
  }
  unint64_t v20 = v9;
  uint64_t v21 = v8;
LABEL_15:
  id v22 = _ArrayBuffer._getElementSlowPath(_:)(v20, v21, v10);
  uint64_t v23 = v22;
  uint64_t v24 = *(v10 - 1);
  if (*(void *)(v24 + 64) != 8)
  {
    swift_unknownObjectRelease(v22);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  id v25 = v22;
  (*(void (**)(uint64_t, id *, uint64_t *))(v24 + 16))(a5, &v25, v10);
  swift_unknownObjectRelease(v23);
}

uint64_t CollectionDifference.index(before:)(uint64_t a1)
{
  BOOL v1 = __OFSUB__(a1, 1);
  uint64_t result = a1 - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

void *CollectionDifference.formIndex(_:offsetBy:)(void *result, uint64_t a2)
{
  if (__OFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

uint64_t CollectionDifference.distance(from:to:)(uint64_t a1, uint64_t a2)
{
  return Array.distance(from:to:)(a1, a2);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance CollectionDifference<A>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
  *a1 = result;
  return result;
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance CollectionDifference<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, Swift::Int *a5@<X8>)
{
  Swift::Int result = CollectionDifference.endIndex.getter(a1, a2, a3, a4);
  *a5 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance CollectionDifference<A>(Class ***a1, Swift::Int *a2, uint64_t a3))()
{
  BOOL v6 = (Class **)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (Class *)CollectionDifference.subscript.read(v6, *a2, a3, v7);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*CollectionDifference.subscript.read(Class **a1, Swift::Int a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v7 = type metadata accessor for CollectionDifference.Change(0, *(void *)(a3 + 16), a3, a4);
  *a1 = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  a1[1] = (Class *)v8;
  Swift::Int v9 = (Class *)malloc(*(void *)(v8 + 64));
  a1[2] = v9;
  CollectionDifference.subscript.getter(a2, a3, v10, v11, (uint64_t)v9);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance CollectionDifference<A>(uint64_t *a1, uint64_t *a2)
{
  return Array.distance(from:to:)(*a1, *a2);
}

uint64_t protocol witness for Collection.index(after:) in conformance CollectionDifference<A>@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized CollectionDifference.index(after:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance CollectionDifference<A>(uint64_t *a1)
{
  uint64_t result = specialized CollectionDifference.index(after:)(*a1);
  *a1 = result;
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance CollectionDifference<A>@<Q0>(__n128 *a1@<X8>)
{
  uint64_t v3 = protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v3;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance CollectionDifference<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionDifference<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance CollectionDifference<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionDifference<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

BOOL static CollectionDifference.Index.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.Index(uint64_t *a1, uint64_t *a2)
{
  return static CollectionDifference.Index.== infix(_:_:)(*a1, *a2);
}

BOOL static CollectionDifference.Index.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance CollectionDifference<A>.Index(uint64_t *a1, uint64_t *a2)
{
  return static CollectionDifference.Index.< infix(_:_:)(*a1, *a2);
}

void CollectionDifference.Index.hash(into:)(int a1, Swift::UInt a2)
{
}

Swift::Int CollectionDifference.Index.hashValue.getter(Swift::UInt a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance CollectionDifference<A>.Index()
{
  return CollectionDifference.Index.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.Index(int a1)
{
  CollectionDifference.Index.hash(into:)(a1, *v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CollectionDifference<A>.Index(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v3[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v3[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v4 = 0u;
  long long v5 = 0u;
  CollectionDifference.Index.hash(into:)((int)v3, *v1);
  return Hasher._finalize()();
}

uint64_t static CollectionDifference.Change<A>.== infix(_:_:)(char *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v71 = a4;
  unint64_t v78 = a1;
  unint64_t v79 = a2;
  uint64_t v77 = *(void *)(a3 - 8);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  unint64_t v72 = (char *)&v70 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v73 = (char *)&v70 - v8;
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v70 - v10;
  MEMORY[0x1F4188790](v9);
  char v13 = (char *)&v70 - v12;
  unint64_t v16 = type metadata accessor for CollectionDifference.Change(0, v14, v14, v15);
  uint64_t v17 = (uint64_t)*(v16 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v20 = (char **)((char *)&v70 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v18);
  id v22 = (uint64_t *)((char *)&v70 - v21);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v16, (uint64_t)v16, 0, 0);
  uint64_t v75 = *(TupleTypeMetadata2 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v26 = (unsigned __int8 *)&v70 - v25;
  uint64_t v76 = (Class *)v24;
  Swift::Int v27 = (unsigned __int8 *)&v70 + *(int *)(v24 + 48) - v25;
  uint64_t v74 = v17;
  uint64_t v28 = *(void (**)(char *, char *, Class *))(v17 + 16);
  v28((char *)&v70 - v25, v78, v16);
  v28((char *)v27, (char *)v79, v16);
  if (swift_getEnumCaseMultiPayload(v26, (uint64_t)v16) == 1)
  {
    unint64_t v79 = v26;
    v28((char *)v20, (char *)v26, v16);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    uint64_t v30 = *((int *)TupleTypeMetadata3 + 12);
    uint64_t v31 = (char *)v20 + v30;
    uint64_t v32 = *((int *)TupleTypeMetadata3 + 16);
    uint64_t v33 = *(Class **)((char *)v20 + v32);
    int v34 = *((unsigned __int8 *)v20 + v32 + 8);
    uint64_t v35 = a3;
    if (swift_getEnumCaseMultiPayload(v27, (uint64_t)v16) == 1)
    {
      uint64_t v70 = v33;
      LODWORD(v75) = v34;
      unint64_t v78 = *v20;
      uint64_t v36 = *(char **)v27;
      uint64_t v37 = &v27[v30];
      uint64_t v76 = *(Class **)&v27[v32];
      unsigned __int8 v38 = v27[v32 + 8];
      uint64_t v39 = v77;
      uint64_t v40 = *(void (**)(char *, char *, uint64_t))(v77 + 32);
      uint64_t v41 = v73;
      v40(v73, v31, v35);
      uint64_t v42 = v72;
      v40(v72, (char *)v37, v35);
      if (v78 == v36)
      {
        uint64_t v43 = v76;
        char v44 = v38;
        char v45 = (*(uint64_t (**)(char *, char *, uint64_t))(v71 + 8))(v41, v42, v35);
        uint64_t v46 = *(void (**)(char *, uint64_t))(v39 + 8);
        v46(v42, v35);
        v46(v41, v35);
        if (v45)
        {
          if ((v75 & 1) == 0)
          {
            BOOL v47 = v70 == v43;
            goto LABEL_21;
          }
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v66 = *(void (**)(char *, uint64_t))(v39 + 8);
        v66(v42, v35);
        v66(v41, v35);
      }
      goto LABEL_18;
    }
    uint64_t v53 = v77;
    uint64_t v26 = v79;
  }
  else
  {
    uint64_t v73 = v11;
    unint64_t v78 = v13;
    v28((char *)v22, (char *)v26, v16);
    uint64_t v48 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    uint64_t v49 = *((int *)v48 + 12);
    uint64_t v31 = (char *)v22 + v49;
    uint64_t v50 = *((int *)v48 + 16);
    Swift::Int v51 = *(Class **)((char *)v22 + v50);
    int v52 = *((unsigned __int8 *)v22 + v50 + 8);
    if (swift_getEnumCaseMultiPayload(v27, (uint64_t)v16) != 1)
    {
      LODWORD(v72) = v52;
      uint64_t v70 = v51;
      unint64_t v79 = v26;
      uint64_t v57 = (char *)*v22;
      Swift::Int v58 = *(char **)v27;
      uint64_t v76 = *(Class **)&v27[v50];
      LODWORD(v75) = v27[v50 + 8];
      uint64_t v60 = v77;
      unint64_t v59 = v78;
      uint64_t v61 = *(void (**)(char *, char *, uint64_t))(v77 + 32);
      v61(v78, v31, a3);
      uint64_t v62 = v73;
      v61(v73, (char *)&v27[v49], a3);
      if (v57 == v58)
      {
        uint64_t v63 = v76;
        char v44 = v75;
        char v64 = (*(uint64_t (**)(char *, char *, uint64_t))(v71 + 8))(v59, v62, a3);
        uint64_t v65 = *(void (**)(char *, uint64_t))(v60 + 8);
        v65(v62, a3);
        v65(v59, a3);
        if (v64)
        {
          if ((v72 & 1) == 0)
          {
            BOOL v47 = v70 == v63;
LABEL_21:
            if (v47) {
              char v69 = v44;
            }
            else {
              char v69 = 1;
            }
            uint64_t v56 = v74;
            uint64_t v26 = v79;
            if (v69) {
              goto LABEL_25;
            }
LABEL_15:
            uint64_t v55 = 1;
            goto LABEL_19;
          }
LABEL_14:
          uint64_t v56 = v74;
          uint64_t v26 = v79;
          if ((v44 & 1) == 0)
          {
LABEL_25:
            uint64_t v55 = 0;
            goto LABEL_19;
          }
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v67 = *(void (**)(char *, uint64_t))(v60 + 8);
        v67(v62, a3);
        v67(v59, a3);
      }
LABEL_18:
      uint64_t v55 = 0;
      uint64_t v56 = v74;
      uint64_t v26 = v79;
      goto LABEL_19;
    }
    uint64_t v53 = v77;
    uint64_t v35 = a3;
  }
  uint64_t v54 = v75;
  unint64_t v16 = v76;
  (*(void (**)(char *, uint64_t))(v53 + 8))(v31, v35);
  uint64_t v55 = 0;
  uint64_t v56 = v54;
LABEL_19:
  (*(void (**)(unsigned __int8 *, Class *))(v56 + 8))(v26, v16);
  return v55;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> CollectionDifference<A>.Change(char *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  return static CollectionDifference.Change<A>.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8));
}

uint64_t static CollectionDifference<A>.== infix(_:_:)(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = a3;
  uint64_t v65 = a4;
  uint64_t v6 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, a3, a3, a4);
  uint64_t v7 = *(v6 - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v57 = (unsigned __int8 *)&v56 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v63 = (char *)&v56 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (unsigned __int8 *)&v56 - v13;
  MEMORY[0x1F4188790](v12);
  unint64_t v16 = (char *)&v56 - v15;
  uint64_t v18 = *a1;
  uint64_t v17 = a1[1];
  uint64_t v20 = *a2;
  uint64_t v19 = a2[1];
  uint64_t v58 = v17;
  uint64_t v59 = v19;
  Swift::Int v21 = Array._getCount()();
  if (v21 != Array._getCount()()) {
    return 0;
  }
  uint64_t v56 = v8;
  if (v21)
  {
    uint64_t v22 = _ArrayBuffer.identity.getter(v18, v6);
    if (v22 != _ArrayBuffer.identity.getter(v20, v6))
    {
      unint64_t v62 = v21;
      if (v21 < 0) {
        goto LABEL_36;
      }
      unint64_t v23 = 0;
      uint64_t v66 = (void (**)(char *, id *, uint64_t *))(v7 + 16);
      unint64_t v60 = v20 & 0xC000000000000001;
      unint64_t v61 = v18 & 0xC000000000000001;
      uint64_t v24 = (void (**)(unsigned __int8 *, uint64_t *))(v7 + 8);
      while (v62 != v23)
      {
        BOOL v25 = v61 == 0;
        char v26 = v25 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v26 & 1);
        if (v26)
        {
          Swift::Int v27 = *(void (**)(char *, id *, uint64_t *))(v7 + 16);
          v27(v16, (id *)(v18+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(void *)(v7 + 72) * v23), v6);
        }
        else
        {
          id v32 = _ArrayBuffer._getElementSlowPath(_:)(v23, v18, v6);
          uint64_t v33 = v32;
          if (v56 != 8) {
            goto LABEL_37;
          }
          id v67 = v32;
          Swift::Int v27 = *v66;
          (*v66)(v16, &v67, v6);
          swift_unknownObjectRelease(v33);
        }
        BOOL v28 = v60 == 0;
        char v29 = v28 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v29 & 1);
        if (v29)
        {
          v27((char *)v14, (id *)(v20+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(void *)(v7 + 72) * v23), v6);
        }
        else
        {
          id v34 = _ArrayBuffer._getElementSlowPath(_:)(v23, v20, v6);
          uint64_t v33 = v34;
          if (v56 != 8)
          {
LABEL_37:
            swift_unknownObjectRelease(v33);
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
          }
          id v67 = v34;
          v27((char *)v14, &v67, v6);
          swift_unknownObjectRelease(v33);
        }
        char v30 = static CollectionDifference.Change<A>.== infix(_:_:)(v16, v14, v64, v65);
        uint64_t v31 = *v24;
        (*v24)(v14, v6);
        v31((unsigned __int8 *)v16, v6);
        ++v23;
        if ((v30 & 1) == 0) {
          return 0;
        }
      }
    }
  }
  uint64_t v35 = v58;
  Swift::Int v36 = Array._getCount()();
  if (v36 != Array._getCount()()) {
    return 0;
  }
  if (!v36) {
    return 1;
  }
  uint64_t v37 = _ArrayBuffer.identity.getter(v35, v6);
  if (v37 == _ArrayBuffer.identity.getter(v59, v6)) {
    return 1;
  }
  if (v36 < 0) {
LABEL_36:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  unint64_t v38 = 0;
  uint64_t v66 = (void (**)(char *, id *, uint64_t *))(v35 & 0xC000000000000001);
  uint64_t v39 = (void (**)(char *, id *, uint64_t *))(v7 + 16);
  unint64_t v62 = v59 & 0xC000000000000001;
  uint64_t v40 = (void (**)(unsigned __int8 *, uint64_t *))(v7 + 8);
  do
  {
    BOOL v41 = v36 == v38;
    if (v36 == v38) {
      break;
    }
    BOOL v42 = v66 == 0;
    char v43 = v42 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v38, v43 & 1);
    if (v43)
    {
      char v44 = *(void (**)(char *, id *, uint64_t *))(v7 + 16);
      v44(v63, (id *)(v35+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(void *)(v7 + 72) * v38), v6);
    }
    else
    {
      id v53 = _ArrayBuffer._getElementSlowPath(_:)(v38, v35, v6);
      uint64_t v33 = v53;
      if (v56 != 8) {
        goto LABEL_37;
      }
      id v67 = v53;
      char v44 = *v39;
      (*v39)(v63, &v67, v6);
      swift_unknownObjectRelease(v33);
    }
    uint64_t v45 = v59;
    BOOL v46 = v62 == 0;
    char v47 = v46 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v38, v47 & 1);
    if (v47)
    {
      uint64_t v48 = v57;
      v44((char *)v57, (id *)(v45+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(void *)(v7 + 72) * v38), v6);
    }
    else
    {
      id v54 = _ArrayBuffer._getElementSlowPath(_:)(v38, v45, v6);
      uint64_t v33 = v54;
      if (v56 != 8) {
        goto LABEL_37;
      }
      id v67 = v54;
      uint64_t v48 = v57;
      v44((char *)v57, &v67, v6);
      swift_unknownObjectRelease(v33);
    }
    uint64_t v49 = v63;
    char v50 = static CollectionDifference.Change<A>.== infix(_:_:)(v63, v48, v64, v65);
    Swift::Int v51 = v48;
    int v52 = *v40;
    (*v40)(v51, v6);
    v52((unsigned __int8 *)v49, v6);
    ++v38;
    uint64_t v35 = v58;
  }
  while ((v50 & 1) != 0);
  return v41;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> CollectionDifference<A>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return static CollectionDifference<A>.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8));
}

void CollectionDifference.Change<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v25 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v25 - v13;
  MEMORY[0x1F4188790](v12);
  unint64_t v16 = (unsigned __int8 *)&v25 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v17 + 16))(v16, v3, a2);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v16, a2);
  Swift::UInt v19 = *(void *)v16;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
  Swift::Int v21 = &v16[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v22 = &v16[*((int *)TupleTypeMetadata3 + 16)];
  Swift::UInt v25 = *(void *)v22;
  int v26 = v22[8];
  unint64_t v23 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v8 + 32);
  uint64_t v24 = (void (**)(char *, uint64_t))(v8 + 8);
  if (EnumCaseMultiPayload == 1)
  {
    v23(v11, v21, v7);
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v7, a3);
    (*v24)(v11, v7);
  }
  else
  {
    v23(v14, v21, v7);
    Hasher._combine(_:)(0);
    Hasher._combine(_:)(v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v7, a3);
    (*v24)(v14, v7);
  }
  if (v26)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v25);
  }
}

Swift::Int CollectionDifference.Change<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter(a1, a2, (void (*)(void *, uint64_t, uint64_t))CollectionDifference.Change<A>.hash(into:));
}

Swift::Int DiscontiguousSlice<>.hashValue.getter(uint64_t a1, uint64_t a2, void (*a3)(void *, uint64_t, uint64_t))
{
  v4[0] = 0;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v4[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v4[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v5 = 0u;
  long long v6 = 0u;
  a3(v4, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2)
{
  return CollectionDifference.Change<A>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index(a1, a2, a3, (void (*)(void *, uint64_t, uint64_t))CollectionDifference.Change<A>.hash(into:));
}

void CollectionDifference<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v91 = a3;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v71 = *(void *)(v5 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v73 = (char *)&v69 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  unint64_t v72 = (char *)&v69 - v9;
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v75 = (char *)&v69 - v11;
  MEMORY[0x1F4188790](v10);
  uint64_t v74 = (char *)&v69 - v12;
  uint64_t v15 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v5, v13, v14);
  uint64_t v92 = *(v15 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  uint64_t v85 = (unsigned __int8 *)&v69 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v90 = (char *)&v69 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v84 = (char *)&v69 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (unsigned __int8 *)&v69 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  Swift::Int v27 = (char *)&v69 - v26;
  uint64_t v70 = v28;
  MEMORY[0x1F4188790](v25);
  BOOL v87 = (char *)&v69 - v29;
  uint64_t v30 = *v3;
  uint64_t v88 = v3[1];
  Swift::UInt v31 = Array._getCount()();
  Hasher._combine(_:)(v31);
  unint64_t v86 = (void (**)(char *, unsigned __int8 *, uint64_t *))Array._getCount()();
  if (v86)
  {
    unint64_t v32 = 0;
    uint64_t v82 = (void (**)(char *, unsigned __int8 *, uint64_t))(v92 + 16);
    uint64_t v83 = (void (**)(char *, char *, uint64_t *))(v30 & 0xC000000000000001);
    unint64_t v79 = (void (**)(char *, char *, uint64_t *))(v92 + 32);
    uint64_t v77 = v91 + 24;
    unint64_t v78 = (void (**)(char *, unsigned __int8 *, uint64_t))(v71 + 32);
    uint64_t v76 = (void (**)(char *, uint64_t))(v71 + 8);
    uint64_t v80 = (void (**)(char *, uint64_t))v30;
    uint64_t v81 = v27;
    do
    {
      BOOL v33 = v83 == 0;
      char v34 = v33 | ~_swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v32, v34 & 1);
      if (v34)
      {
        (*(void (**)(char *, unint64_t, uint64_t *))(v92 + 16))(v27, v30+ ((*(unsigned __int8 *)(v92 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v92 + 80))+ *(void *)(v92 + 72) * v32, v15);
        uint64_t v35 = (void (**)(char *, unsigned __int8 *, uint64_t *))(v32 + 1);
        if (__OFADD__(v32, 1)) {
          goto LABEL_15;
        }
      }
      else
      {
        id v48 = _ArrayBuffer._getElementSlowPath(_:)(v32, v30, v15);
        uint64_t v49 = v48;
        if (v70 != 8)
        {
LABEL_32:
          swift_unknownObjectRelease(v48);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        *(void *)char v93 = v48;
        (*v82)(v27, v93, (uint64_t)v15);
        swift_unknownObjectRelease(v49);
        uint64_t v35 = (void (**)(char *, unsigned __int8 *, uint64_t *))(v32 + 1);
        if (__OFADD__(v32, 1))
        {
LABEL_15:
          __break(1u);
          break;
        }
      }
      Swift::Int v36 = *v79;
      uint64_t v37 = v87;
      (*v79)(v87, v27, v15);
      v36((char *)v24, v37, v15);
      LODWORD(v37) = swift_getEnumCaseMultiPayload(v24, (uint64_t)v15);
      Swift::UInt v38 = *(void *)v24;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
      uint64_t v40 = &v24[*((int *)TupleTypeMetadata3 + 12)];
      BOOL v41 = &v24[*((int *)TupleTypeMetadata3 + 16)];
      Swift::UInt v89 = *(void *)v41;
      int v42 = v41[8];
      char v43 = *v78;
      if (v37 == 1)
      {
        uint64_t v44 = v5;
        uint64_t v45 = v75;
        v43(v75, v40, v44);
        Hasher._combine(_:)(1uLL);
        Hasher._combine(_:)(v38);
        (*(void (**)(uint64_t, uint64_t))(v91 + 24))(a1, v44);
        BOOL v46 = v45;
        uint64_t v5 = v44;
        (*v76)(v46, v44);
        if (v42) {
          goto LABEL_11;
        }
      }
      else
      {
        char v47 = v74;
        v43(v74, v40, v5);
        Hasher._combine(_:)(0);
        Hasher._combine(_:)(v38);
        (*(void (**)(uint64_t, uint64_t))(v91 + 24))(a1, v5);
        (*v76)(v47, v5);
        if (v42)
        {
LABEL_11:
          Hasher._combine(_:)(0);
          goto LABEL_4;
        }
      }
      Hasher._combine(_:)(1u);
      Hasher._combine(_:)(v89);
LABEL_4:
      uint64_t v30 = (uint64_t)v80;
      Swift::Int v27 = v81;
      ++v32;
    }
    while (v35 != v86);
  }
  uint64_t v50 = v88;
  Swift::UInt v51 = Array._getCount()();
  Hasher._combine(_:)(v51);
  Swift::UInt v89 = Array._getCount()();
  if (!v89) {
    return;
  }
  unint64_t v52 = 0;
  unint64_t v86 = (void (**)(char *, unsigned __int8 *, uint64_t *))(v92 + 16);
  BOOL v87 = (char *)(v50 & 0xC000000000000001);
  uint64_t v83 = (void (**)(char *, char *, uint64_t *))(v92 + 32);
  uint64_t v81 = (char *)(v91 + 24);
  uint64_t v82 = (void (**)(char *, unsigned __int8 *, uint64_t))(v71 + 32);
  uint64_t v80 = (void (**)(char *, uint64_t))(v71 + 8);
  while (1)
  {
    BOOL v53 = v87 == 0;
    char v54 = v53 | ~_swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v52, v54 & 1);
    if ((v54 & 1) == 0) {
      break;
    }
    (*(void (**)(char *, unint64_t, uint64_t *))(v92 + 16))(v90, v50+ ((*(unsigned __int8 *)(v92 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v92 + 80))+ *(void *)(v92 + 72) * v52, v15);
    unint64_t v55 = v52 + 1;
    if (__OFADD__(v52, 1)) {
      goto LABEL_30;
    }
LABEL_22:
    uint64_t v56 = v84;
    uint64_t v57 = *v83;
    (*v83)(v84, v90, v15);
    uint64_t v58 = v85;
    v57((char *)v85, v56, v15);
    LODWORD(v56) = swift_getEnumCaseMultiPayload(v58, (uint64_t)v15);
    Swift::UInt v59 = *(void *)v58;
    unint64_t v60 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
    unint64_t v61 = &v58[*((int *)v60 + 12)];
    unint64_t v62 = &v58[*((int *)v60 + 16)];
    Swift::UInt v63 = *(void *)v62;
    int v64 = v62[8];
    uint64_t v65 = *v82;
    if (v56 == 1)
    {
      uint64_t v66 = v73;
      v65(v73, v61, v5);
      Swift::UInt v67 = 1;
    }
    else
    {
      uint64_t v66 = v72;
      v65(v72, v61, v5);
      Swift::UInt v67 = 0;
    }
    Hasher._combine(_:)(v67);
    Hasher._combine(_:)(v59);
    (*(void (**)(uint64_t, uint64_t))(v91 + 24))(a1, v5);
    (*v80)(v66, v5);
    if (v64)
    {
      Hasher._combine(_:)(0);
    }
    else
    {
      Hasher._combine(_:)(1u);
      Hasher._combine(_:)(v63);
    }
    uint64_t v50 = v88;
    ++v52;
    if (v55 == v89) {
      return;
    }
  }
  id v48 = _ArrayBuffer._getElementSlowPath(_:)(v52, v50, v15);
  uint64_t v68 = v48;
  if (v70 != 8) {
    goto LABEL_32;
  }
  *(void *)char v93 = v48;
  (*v86)(v90, v93, v15);
  swift_unknownObjectRelease(v68);
  unint64_t v55 = v52 + 1;
  if (!__OFADD__(v52, 1)) {
    goto LABEL_22;
  }
LABEL_30:
  __break(1u);
}

Swift::Int CollectionDifference<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  long long v7 = *v2;
  v4[0] = 0;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v4[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v4[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v5 = 0u;
  long long v6 = 0u;
  CollectionDifference<A>.hash(into:)((uint64_t)v4, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> CollectionDifference<A>(uint64_t a1, uint64_t a2)
{
  return CollectionDifference<A>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 - 8);
  v5[0] = 0;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v5[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v5[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v6 = 0u;
  long long v7 = 0u;
  CollectionDifference<A>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

void CollectionDifference<A>.inferringMoves()(unint64_t *a1@<X0>, __objc2_class **a2@<X1>, __objc2_class ***a3@<X8>)
{
  uint64_t v8 = *v3;
  uint64_t v7 = v3[1];
  uint64_t v9 = a1[2];
  uint64_t v10 = closure #1 in CollectionDifference<A>.inferringMoves()(v8, v7, v9, a2);
  uint64_t v11 = closure #2 in CollectionDifference<A>.inferringMoves()(v8, v7, v9, a2);
  v24[0] = v8;
  v24[1] = v7;
  void v23[2] = v9;
  v23[3] = a2;
  v23[4] = v10;
  v23[5] = v11;
  uint64_t v14 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v9, v12, v13);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionDifference<A>, a1, v15);
  uint64_t v17 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOqd__Isgnrzr_xAbGSlRzAGRsd_0_r_0_lIetMgnozo_Tp5((void (*)(char *))partial apply for closure #3 in CollectionDifference<A>.inferringMoves(), (uint64_t)v23, (uint64_t)a1, v14, WitnessTable);
  swift_bridgeObjectRelease((uint64_t)v11);
  swift_bridgeObjectRelease((uint64_t)v10);
  v24[0] = v17;
  uint64_t v20 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v14, v18, v19);
  uint64_t v22 = swift_getWitnessTable(protocol conformance descriptor for [A], v20, v21);
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)v24, v9, (uint64_t)v20, v22, a3);
}

__objc2_class **closure #1 in CollectionDifference<A>.inferringMoves()(uint64_t a1, uint64_t a2, uint64_t a3, __objc2_class **a4)
{
  uint64_t v5 = a3;
  uint64_t v99 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v117 = (char *)&v95 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v8, v8, v9);
  uint64_t v109 = *(v10 - 1);
  uint64_t v11 = *(void *)(v109 + 64);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  BOOL v101 = (char *)&v95 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v108 = (char *)&v95 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  int64_t v116 = (char *)&v95 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v95 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v95 - v20;
  Swift::Int v22 = Array._getCount()();
  Swift::Int v23 = Array._getCount()();
  if (v23 >= v22) {
    Swift::Int v23 = v22;
  }
  if (v23) {
    uint64_t v24 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v23, v5, (uint64_t)a4);
  }
  else {
    uint64_t v24 = &_swiftEmptyDictionarySingleton;
  }
  Swift::Int v25 = Array._getCount()();
  Swift::Int v107 = v25;
  if (v25)
  {
    uint64_t v96 = v11;
    unint64_t v26 = 0;
    unint64_t v106 = a2 & 0xC000000000000001;
    BOOL v115 = (void (**)(char *, __objc2_class ***, uint64_t *))(v109 + 16);
    uint64_t v112 = (void (**)(uint64_t, char *, uint64_t))(v99 + 32);
    unint64_t v113 = (void (**)(char *, char *, uint64_t *))(v109 + 32);
    uint64_t v97 = (void (**)(char *, uint64_t *))(v109 + 8);
    BOOL v110 = (void (**)(char *, unint64_t))(v99 + 8);
    unint64_t v111 = v5;
    char v105 = a4;
    char v98 = v10;
    char v103 = v19;
    uint64_t v104 = a2;
    uint64_t v102 = v21;
    do
    {
      BOOL v28 = v106 == 0;
      char v29 = v28 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v29 & 1);
      if (v29)
      {
        uint64_t v30 = *(void (**)(char *, __objc2_class ***, uint64_t *))(v109 + 16);
        v30(v19, (__objc2_class ***)(a2+ ((*(unsigned __int8 *)(v109 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v109 + 80))+ *(void *)(v109 + 72) * v26), v10);
      }
      else
      {
        id v80 = _ArrayBuffer._getElementSlowPath(_:)(v26, a2, v10);
        uint64_t v81 = v80;
        if (v96 != 8)
        {
          swift_unknownObjectRelease(v80);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        int64_t v118 = (__objc2_class **)v80;
        uint64_t v30 = *v115;
        (*v115)(v19, &v118, v10);
        swift_unknownObjectRelease(v81);
      }
      Swift::UInt v31 = *v113;
      (*v113)(v21, v19, v10);
      if (__OFADD__(v26, 1))
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v111);
      }
      unint64_t v114 = v26 + 1;
      uint64_t v32 = (uint64_t)a4;
      BOOL v33 = v116;
      v31(v116, v21, v10);
      char v34 = v108;
      uint64_t v35 = (__objc2_class ***)v33;
      uint64_t v36 = v32;
      v30(v108, v35, v10);
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
      Swift::UInt v38 = *v112;
      (*v112)((uint64_t)v117, &v34[*((int *)TupleTypeMetadata3 + 12)], v5);
      if (v24[2])
      {
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v117, v5, v32);
        if (v39)
        {
          unint64_t v100 = (void (*)(char *, char *, unint64_t))v38;
          (*v97)(v116, v10);
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v24);
          int64_t v118 = v24;
          unint64_t v41 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v117, v5, v32);
          char v43 = v24[2];
          BOOL v44 = (v42 & 1) == 0;
          uint64_t v45 = (uint64_t)v43 + v44;
          a2 = v104;
          if (__OFADD__(v43, v44)) {
            goto LABEL_45;
          }
          char v46 = v42;
          if ((uint64_t)v24[3] >= v45)
          {
            unint64_t v53 = v41;
            uint64_t v21 = v102;
            uint64_t v19 = v103;
            if (isUniquelyReferenced_nonNull_native)
            {
              a4 = v105;
              if ((v42 & 1) == 0) {
                goto LABEL_38;
              }
            }
            else
            {
              a4 = v105;
              uint64_t v83 = type metadata accessor for _NativeDictionary(0, v111, (uint64_t)&unk_1ECA01F50, (uint64_t)v105);
              specialized _NativeDictionary.copy()((uint64_t)v83);
              if ((v46 & 1) == 0) {
                goto LABEL_38;
              }
            }
          }
          else
          {
            uint64_t v47 = v111;
            uint64_t v48 = (uint64_t)v105;
            uint64_t v49 = type metadata accessor for _NativeDictionary(0, v111, (uint64_t)&unk_1ECA01F50, (uint64_t)v105);
            uint64_t v50 = v45;
            a4 = (__objc2_class **)v48;
            specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v50, isUniquelyReferenced_nonNull_native, (uint64_t)v49);
            unint64_t v51 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v117, v47, v48);
            uint64_t v21 = v102;
            uint64_t v19 = v103;
            if ((v46 & 1) != (v52 & 1)) {
              goto LABEL_47;
            }
            unint64_t v53 = v51;
            uint64_t v10 = v98;
            if ((v46 & 1) == 0)
            {
LABEL_38:
              uint64_t v24 = v118;
              v118[(v53 >> 6) + 8] = (__objc2_class *)((unint64_t)v118[(v53 >> 6) + 8] | (1 << v53));
              uint64_t v5 = v111;
              v100((char *)v24[6] + *(void *)(v99 + 72) * v53, v117, v111);
              uint64_t v84 = (uint64_t)v24[7] + 16 * v53;
              *(void *)uint64_t v84 = 0;
              *(unsigned char *)(v84 + 8) = 1;
              uint64_t v85 = v24[2];
              BOOL v77 = __OFADD__(v85, 1);
              unint64_t v86 = (__objc2_class *)((char *)&v85->isa + 1);
              if (v77) {
                goto LABEL_46;
              }
              void v24[2] = v86;
              goto LABEL_40;
            }
          }
          uint64_t v5 = v111;
          (*v110)(v117, v111);
          uint64_t v24 = v118;
          uint64_t v79 = (uint64_t)v118[7] + 16 * v53;
          *(void *)uint64_t v79 = 0;
          *(unsigned char *)(v79 + 8) = 1;
LABEL_40:
          swift_bridgeObjectRelease(0x8000000000000000);
          goto LABEL_10;
        }
      }
      char v54 = (uint64_t *)v101;
      v31(v101, v116, v10);
      uint64_t v55 = *v54;
      uint64_t v56 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
      uint64_t v57 = *v110;
      (*v110)((char *)v54 + *((int *)v56 + 12), v5);
      BOOL v58 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v24);
      int64_t v118 = v24;
      unint64_t v59 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v117, v5, v36);
      unint64_t v61 = v24[2];
      BOOL v62 = (v60 & 1) == 0;
      uint64_t v63 = (uint64_t)v61 + v62;
      if (__OFADD__(v61, v62)) {
        goto LABEL_43;
      }
      char v64 = v60;
      if ((uint64_t)v24[3] >= v63)
      {
        unint64_t v74 = v59;
        if (v58)
        {
          a4 = v105;
          if ((v60 & 1) == 0) {
            goto LABEL_28;
          }
        }
        else
        {
          a4 = v105;
          uint64_t v82 = type metadata accessor for _NativeDictionary(0, v111, (uint64_t)&unk_1ECA01F50, (uint64_t)v105);
          specialized _NativeDictionary.copy()((uint64_t)v82);
          if ((v64 & 1) == 0) {
            goto LABEL_28;
          }
        }
      }
      else
      {
        unint64_t v100 = (void (*)(char *, char *, unint64_t))v26;
        uint64_t v65 = v55;
        uint64_t v66 = v38;
        uint64_t v67 = (uint64_t)v117;
        uint64_t v68 = v111;
        uint64_t v69 = (uint64_t)v105;
        uint64_t v70 = type metadata accessor for _NativeDictionary(0, v111, (uint64_t)&unk_1ECA01F50, (uint64_t)v105);
        uint64_t v71 = v63;
        a4 = (__objc2_class **)v69;
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v71, v58, (uint64_t)v70);
        unint64_t v72 = __RawDictionaryStorage.find<A>(_:)(v67, v68, v69);
        if ((v64 & 1) != (v73 & 1)) {
          goto LABEL_47;
        }
        unint64_t v74 = v72;
        uint64_t v10 = v98;
        Swift::UInt v38 = v66;
        uint64_t v55 = v65;
        unint64_t v26 = (unint64_t)v100;
        if ((v64 & 1) == 0)
        {
LABEL_28:
          uint64_t v24 = v118;
          v118[(v74 >> 6) + 8] = (__objc2_class *)((unint64_t)v118[(v74 >> 6) + 8] | (1 << v74));
          uint64_t v5 = v111;
          v38((uint64_t)v24[6] + *(void *)(v99 + 72) * v74, v117, v111);
          uint64_t v75 = (uint64_t)v24[7] + 16 * v74;
          *(void *)uint64_t v75 = v55;
          *(unsigned char *)(v75 + 8) = 0;
          uint64_t v76 = v24[2];
          BOOL v77 = __OFADD__(v76, 1);
          unint64_t v78 = (__objc2_class *)((char *)&v76->isa + 1);
          if (v77) {
            goto LABEL_44;
          }
          void v24[2] = v78;
          goto LABEL_9;
        }
      }
      uint64_t v5 = v111;
      v57(v117, v111);
      uint64_t v24 = v118;
      uint64_t v27 = (uint64_t)v118[7] + 16 * v74;
      *(void *)uint64_t v27 = v55;
      *(unsigned char *)(v27 + 8) = 0;
LABEL_9:
      swift_bridgeObjectRelease(0x8000000000000000);
      uint64_t v19 = v103;
      a2 = v104;
      uint64_t v21 = v102;
LABEL_10:
      ++v26;
    }
    while (v114 != v107);
  }
  uint64_t v87 = MEMORY[0x1F4188790](v25);
  MEMORY[0x1F4188790](v87);
  uint64_t v91 = v5;
  uint64_t v92 = a4;
  char v93 = partial apply for closure #1 in closure #1 in CollectionDifference<A>.inferringMoves();
  uint64_t v94 = v88;
  swift_bridgeObjectRetain((unint64_t)v24);
  Swift::UInt v89 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5((uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool), (uint64_t)(&v95 - 6), (uint64_t)v24, v5, a4);
  swift_bridgeObjectRelease((uint64_t)v24);
  swift_bridgeObjectRelease((uint64_t)v24);
  return v89;
}

__objc2_class **closure #2 in CollectionDifference<A>.inferringMoves()(uint64_t a1, uint64_t a2, uint64_t a3, __objc2_class **a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = a1;
  uint64_t v100 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  int64_t v118 = (char *)&v96 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v8, v8, v9);
  uint64_t v110 = *(v10 - 1);
  uint64_t v11 = *(void *)(v110 + 64);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v102 = (char *)&v96 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v109 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v117 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v96 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v96 - v20;
  Swift::Int v22 = Array._getCount()();
  Swift::Int v23 = Array._getCount()();
  if (v23 >= v22) {
    Swift::Int v23 = v22;
  }
  if (v23) {
    uint64_t v24 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v23, v5, (uint64_t)a4);
  }
  else {
    uint64_t v24 = &_swiftEmptyDictionarySingleton;
  }
  Swift::Int v25 = Array._getCount()();
  Swift::Int v108 = v25;
  if (v25)
  {
    uint64_t v97 = v11;
    unint64_t v26 = 0;
    unint64_t v107 = v6 & 0xC000000000000001;
    int64_t v116 = (void (**)(char *, __objc2_class ***, uint64_t *))(v110 + 16);
    unint64_t v113 = (void (**)(uint64_t, char *, uint64_t))(v100 + 32);
    unint64_t v114 = (void (**)(char *, char *, uint64_t *))(v110 + 32);
    char v98 = (void (**)(char *, uint64_t *))(v110 + 8);
    unint64_t v111 = (void (**)(char *, unint64_t))(v100 + 8);
    unint64_t v112 = v5;
    unint64_t v106 = a4;
    uint64_t v99 = v10;
    uint64_t v103 = v6;
    uint64_t v104 = v21;
    char v105 = v19;
    do
    {
      BOOL v28 = v107 == 0;
      char v29 = v28 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v29 & 1);
      if (v29)
      {
        unint64_t v30 = v6
            + ((*(unsigned __int8 *)(v110 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v110 + 80))
            + *(void *)(v110 + 72) * v26;
        Swift::UInt v31 = *(void (**)(char *, __objc2_class ***, uint64_t *))(v110 + 16);
        v31(v19, (__objc2_class ***)v30, v10);
      }
      else
      {
        id v81 = _ArrayBuffer._getElementSlowPath(_:)(v26, v6, v10);
        uint64_t v82 = v81;
        if (v97 != 8)
        {
          swift_unknownObjectRelease(v81);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        char v119 = (__objc2_class **)v81;
        Swift::UInt v31 = *v116;
        (*v116)(v19, &v119, v10);
        swift_unknownObjectRelease(v82);
      }
      uint64_t v32 = *v114;
      (*v114)(v21, v19, v10);
      if (__OFADD__(v26, 1))
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v112);
      }
      unint64_t v115 = v26 + 1;
      uint64_t v33 = (uint64_t)a4;
      char v34 = v117;
      v32(v117, v21, v10);
      uint64_t v35 = v109;
      uint64_t v36 = (__objc2_class ***)v34;
      uint64_t v37 = v33;
      v31(v109, v36, v10);
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
      char v39 = *v113;
      (*v113)((uint64_t)v118, &v35[*((int *)TupleTypeMetadata3 + 12)], v5);
      if (v24[2])
      {
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v118, v5, v33);
        if (v40)
        {
          (*v98)(v117, v10);
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v24);
          char v119 = v24;
          unint64_t v42 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v118, v5, v33);
          BOOL v44 = v24[2];
          BOOL v45 = (v43 & 1) == 0;
          uint64_t v46 = (uint64_t)v44 + v45;
          if (__OFADD__(v44, v45)) {
            goto LABEL_45;
          }
          char v47 = v43;
          if ((uint64_t)v24[3] >= v46)
          {
            unint64_t v54 = v42;
            uint64_t v21 = v104;
            uint64_t v19 = v105;
            if (isUniquelyReferenced_nonNull_native)
            {
              a4 = v106;
              if ((v43 & 1) == 0) {
                goto LABEL_38;
              }
            }
            else
            {
              a4 = v106;
              uint64_t v84 = type metadata accessor for _NativeDictionary(0, v112, (uint64_t)&unk_1ECA01F50, (uint64_t)v106);
              specialized _NativeDictionary.copy()((uint64_t)v84);
              if ((v47 & 1) == 0) {
                goto LABEL_38;
              }
            }
          }
          else
          {
            uint64_t v48 = v112;
            uint64_t v49 = (uint64_t)v106;
            uint64_t v50 = type metadata accessor for _NativeDictionary(0, v112, (uint64_t)&unk_1ECA01F50, (uint64_t)v106);
            uint64_t v51 = v46;
            a4 = (__objc2_class **)v49;
            specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v51, isUniquelyReferenced_nonNull_native, (uint64_t)v50);
            unint64_t v52 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v118, v48, v49);
            uint64_t v21 = v104;
            uint64_t v19 = v105;
            if ((v47 & 1) != (v53 & 1)) {
              goto LABEL_47;
            }
            unint64_t v54 = v52;
            uint64_t v10 = v99;
            if ((v47 & 1) == 0)
            {
LABEL_38:
              uint64_t v24 = v119;
              v119[(v54 >> 6) + 8] = (__objc2_class *)((unint64_t)v119[(v54 >> 6) + 8] | (1 << v54));
              uint64_t v5 = v112;
              v39((uint64_t)v24[6] + *(void *)(v100 + 72) * v54, v118, v112);
              uint64_t v85 = (uint64_t)v24[7] + 16 * v54;
              *(void *)uint64_t v85 = 0;
              *(unsigned char *)(v85 + 8) = 1;
              unint64_t v86 = v24[2];
              BOOL v78 = __OFADD__(v86, 1);
              uint64_t v87 = (__objc2_class *)((char *)&v86->isa + 1);
              if (v78) {
                goto LABEL_46;
              }
              void v24[2] = v87;
              goto LABEL_40;
            }
          }
          uint64_t v5 = v112;
          (*v111)(v118, v112);
          uint64_t v24 = v119;
          uint64_t v80 = (uint64_t)v119[7] + 16 * v54;
          *(void *)uint64_t v80 = 0;
          *(unsigned char *)(v80 + 8) = 1;
LABEL_40:
          swift_bridgeObjectRelease(0x8000000000000000);
          uint64_t v6 = v103;
          goto LABEL_10;
        }
      }
      uint64_t v55 = (uint64_t *)v102;
      v32(v102, v117, v10);
      uint64_t v56 = *v55;
      uint64_t v57 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
      BOOL v58 = *v111;
      (*v111)((char *)v55 + *((int *)v57 + 12), v5);
      BOOL v59 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v24);
      char v119 = v24;
      unint64_t v60 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v118, v5, v37);
      BOOL v62 = v24[2];
      BOOL v63 = (v61 & 1) == 0;
      uint64_t v64 = (uint64_t)v62 + v63;
      if (__OFADD__(v62, v63)) {
        goto LABEL_43;
      }
      char v65 = v61;
      if ((uint64_t)v24[3] >= v64)
      {
        unint64_t v75 = v60;
        if (v59)
        {
          a4 = v106;
          if ((v61 & 1) == 0) {
            goto LABEL_28;
          }
        }
        else
        {
          a4 = v106;
          uint64_t v83 = type metadata accessor for _NativeDictionary(0, v112, (uint64_t)&unk_1ECA01F50, (uint64_t)v106);
          specialized _NativeDictionary.copy()((uint64_t)v83);
          if ((v65 & 1) == 0) {
            goto LABEL_28;
          }
        }
      }
      else
      {
        unint64_t v101 = v26;
        uint64_t v66 = v56;
        uint64_t v67 = v39;
        uint64_t v68 = (uint64_t)v118;
        uint64_t v69 = v112;
        uint64_t v70 = (uint64_t)v106;
        uint64_t v71 = type metadata accessor for _NativeDictionary(0, v112, (uint64_t)&unk_1ECA01F50, (uint64_t)v106);
        uint64_t v72 = v64;
        a4 = (__objc2_class **)v70;
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v72, v59, (uint64_t)v71);
        unint64_t v73 = __RawDictionaryStorage.find<A>(_:)(v68, v69, v70);
        if ((v65 & 1) != (v74 & 1)) {
          goto LABEL_47;
        }
        unint64_t v75 = v73;
        uint64_t v10 = v99;
        char v39 = v67;
        uint64_t v56 = v66;
        unint64_t v26 = v101;
        if ((v65 & 1) == 0)
        {
LABEL_28:
          uint64_t v24 = v119;
          v119[(v75 >> 6) + 8] = (__objc2_class *)((unint64_t)v119[(v75 >> 6) + 8] | (1 << v75));
          uint64_t v5 = v112;
          v39((uint64_t)v24[6] + *(void *)(v100 + 72) * v75, v118, v112);
          uint64_t v76 = (uint64_t)v24[7] + 16 * v75;
          *(void *)uint64_t v76 = v56;
          *(unsigned char *)(v76 + 8) = 0;
          BOOL v77 = v24[2];
          BOOL v78 = __OFADD__(v77, 1);
          uint64_t v79 = (__objc2_class *)((char *)&v77->isa + 1);
          if (v78) {
            goto LABEL_44;
          }
          void v24[2] = v79;
          goto LABEL_9;
        }
      }
      uint64_t v5 = v112;
      v58(v118, v112);
      uint64_t v24 = v119;
      uint64_t v27 = (uint64_t)v119[7] + 16 * v75;
      *(void *)uint64_t v27 = v56;
      *(unsigned char *)(v27 + 8) = 0;
LABEL_9:
      swift_bridgeObjectRelease(0x8000000000000000);
      uint64_t v6 = v103;
      uint64_t v21 = v104;
      uint64_t v19 = v105;
LABEL_10:
      ++v26;
    }
    while (v115 != v108);
  }
  uint64_t v88 = MEMORY[0x1F4188790](v25);
  MEMORY[0x1F4188790](v88);
  uint64_t v92 = v5;
  char v93 = a4;
  uint64_t v94 = partial apply for closure #1 in closure #2 in CollectionDifference<A>.inferringMoves();
  uint64_t v95 = v89;
  swift_bridgeObjectRetain((unint64_t)v24);
  unint64_t v90 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5((uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool), (uint64_t)(&v96 - 6), (uint64_t)v24, v5, a4);
  swift_bridgeObjectRelease((uint64_t)v24);
  swift_bridgeObjectRelease((uint64_t)v24);
  return v90;
}

void closure #3 in CollectionDifference<A>.inferringMoves()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t v54 = a5;
  uint64_t v57 = a2;
  uint64_t v58 = a3;
  BOOL v59 = a6;
  uint64_t v8 = *(void *)(a4 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v52 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v52 - v12;
  uint64_t v16 = type metadata accessor for CollectionDifference.Change(0, v15, v14, v15);
  uint64_t v17 = (uint64_t)*(v16 - 1);
  MEMORY[0x1F4188790](v16);
  uint64_t v19 = (unsigned __int8 *)&v52 - v18;
  uint64_t v55 = *(void (**)(char *, uint64_t, Class *))(v17 + 16);
  uint64_t v56 = a1;
  v55((char *)&v52 - v18, a1, v16);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v19, (uint64_t)v16);
  uint64_t v53 = *(void *)v19;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a4, (uint64_t)&unk_1ECA01F50, "offset element associatedWith ", 0);
  Swift::Int v22 = &v19[*((int *)TupleTypeMetadata3 + 12)];
  Swift::Int v23 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v8 + 32);
  if (EnumCaseMultiPayload != 1)
  {
    uint64_t v38 = v57;
    char v39 = *(void (**)(char *, char *, uint64_t))(v8 + 32);
    v23(v11, v22, a4);
    if (*(void *)(v58 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)v11, a4, v54);
      if (v40)
      {
        if (*(void *)(v38 + 16))
        {
          unint64_t v41 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v11, a4, v54);
          if (v42)
          {
            uint64_t v43 = *(void *)(v38 + 56) + 16 * v41;
            uint64_t v44 = *(void *)v43;
            char v45 = *(unsigned char *)(v43 + 8);
            uint64_t v46 = v59;
            char v47 = (char *)v59 + *((int *)TupleTypeMetadata3 + 12);
            uint64_t v48 = (char *)v59 + *((int *)TupleTypeMetadata3 + 16);
            *BOOL v59 = v53;
            v39(v47, v11, a4);
            *(void *)uint64_t v48 = v44;
            v48[8] = v45;
            uint64_t v35 = v46;
            uint64_t v36 = (uint64_t)v16;
            unsigned int v37 = 0;
            goto LABEL_12;
          }
        }
        goto LABEL_17;
      }
    }
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, a4);
LABEL_15:
    v55((char *)v59, v56, v16);
    return;
  }
  uint64_t v24 = v58;
  Swift::Int v25 = *(void (**)(char *, char *, uint64_t))(v8 + 32);
  v23(v13, v22, a4);
  if (!*(void *)(v57 + 16) || (__RawDictionaryStorage.find<A>(_:)((uint64_t)v13, a4, v54), (v26 & 1) == 0))
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v13, a4);
    goto LABEL_15;
  }
  if (*(void *)(v24 + 16))
  {
    unint64_t v27 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, a4, v54);
    if (v28)
    {
      uint64_t v29 = *(void *)(v24 + 56) + 16 * v27;
      uint64_t v30 = *(void *)v29;
      char v31 = *(unsigned char *)(v29 + 8);
      uint64_t v32 = v59;
      uint64_t v33 = (char *)v59 + *((int *)TupleTypeMetadata3 + 12);
      char v34 = (char *)v59 + *((int *)TupleTypeMetadata3 + 16);
      *BOOL v59 = v53;
      v25(v33, v13, a4);
      *(void *)char v34 = v30;
      v34[8] = v31;
      uint64_t v35 = v32;
      uint64_t v36 = (uint64_t)v16;
      unsigned int v37 = 1;
LABEL_12:
      swift_storeEnumTagMultiPayload(v35, v36, v37);
      return;
    }
  }
  uint64_t v11 = v13;
LABEL_17:
  uint64_t v49 = (char *)v59;
  uint64_t v51 = v55;
  uint64_t v50 = v56;
  (*(void (**)(char *, uint64_t))(v8 + 8))(v11, a4);
  v51(v49, v50, v16);
}

unint64_t CollectionDifference.Change<A>._CodingKeys.init(rawValue:)(Swift::String string)
{
  unint64_t object = string._object;
  v2._unint64_t countAndFlagsBits = string._countAndFlagsBits;
  v2._unint64_t object = object;
  unint64_t v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&outlined read-only object #0 of CollectionDifference.Change<A>._CodingKeys.init(rawValue:), v2);
  swift_bridgeObjectRelease((uint64_t)object);
  if (v3 >= 4) {
    return 4;
  }
  else {
    return v3;
  }
}

unint64_t CollectionDifference.Change<A>._CodingKeys.rawValue.getter(char a1)
{
  unint64_t result = 0xD000000000000010;
  switch(a1)
  {
    case 1:
      unint64_t result = 0x746E656D656C65;
      break;
    case 2:
      return result;
    case 3:
      unint64_t result = 0x65766F6D65527369;
      break;
    default:
      unint64_t result = 0x74657366666FLL;
      break;
  }
  return result;
}

unint64_t CollectionDifference.Change<A>._CodingKeys.stringValue.getter(char a1)
{
  unint64_t result = 0xD000000000000010;
  switch(a1)
  {
    case 1:
      unint64_t result = 0x746E656D656C65;
      break;
    case 2:
      return result;
    case 3:
      unint64_t result = 0x65766F6D65527369;
      break;
    default:
      unint64_t result = 0x74657366666FLL;
      break;
  }
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return == infix<A>(_:_:)(a1, a2, a3, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, (uint64_t)&protocol witness table for String);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return RawRepresentable<>.hash(into:)(a1, a2, a3, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, (uint64_t)&protocol witness table for String);
}

unint64_t protocol witness for RawRepresentable.init(rawValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>(Swift::String *a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t result = CollectionDifference.Change<A>._CodingKeys.init(rawValue:)(*a1);
  *a2 = result;
  return result;
}

unint64_t protocol witness for RawRepresentable.rawValue.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>(unint64_t *a1@<X8>)
{
  unint64_t result = CollectionDifference.Change<A>._CodingKeys.rawValue.getter(*v1);
  *a1 = result;
  a1[1] = v4;
  return result;
}

unint64_t protocol witness for CodingKey.stringValue.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys()
{
  return CollectionDifference.Change<A>._CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = CollectionDifference.Change<A>._CodingKeys.init(stringValue:)();
  *a1 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 4;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t *a1)
{
  return CodingKey.description.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t a1)
{
  return CodingKey.debugDescription.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
}

uint64_t CollectionDifference.Change<A>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = a5;
  uint64_t v39 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = type metadata accessor for CollectionDifference.Change(0, v11, v12, v13);
  uint64_t v37 = (uint64_t)*(v14 - 1);
  MEMORY[0x1F4188790](v14);
  uint64_t v16 = (uint64_t *)((char *)&v34 - v15);
  uint64_t v17 = a1[3];
  uint64_t v18 = a1[4];
  char v40 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v17);
  uint64_t v19 = type metadata accessor for CollectionDifference.Change<A>._CodingKeys(0, a2, a3, a4);
  uint64_t v20 = v41;
  (*(void (**)(uint64_t *__return_ptr, Class *, Class *, _UNKNOWN **, uint64_t, uint64_t))(v18 + 24))(&v42, v19, v19, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, v17, v18);
  if (!v20)
  {
    uint64_t v36 = v16;
    unint64_t v41 = v10;
    uint64_t v21 = v42;
    LOBYTE(v42) = 0;
    uint64_t v35 = (*(uint64_t (**)(uint64_t *, Class *, _UNKNOWN **))(*(void *)v21 + 152))(&v42, v19, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    LOBYTE(v42) = 1;
    Swift::Int v22 = *(void (**)(uint64_t, uint64_t *, uint64_t, Class *, uint64_t, _UNKNOWN **))(*(void *)v21 + 248);
    v22(a2, &v42, a2, v19, a3, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    char v44 = 2;
    unint64_t v23 = lazy protocol witness table accessor for type Int? and conformance <A> A?();
    ((void (*)(uint64_t *__return_ptr, unint64_t *, char *, unint64_t *, Class *, unint64_t, _UNKNOWN **))v22)(&v42, qword_1ECA01F50, &v44, qword_1ECA01F50, v19, v23, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    uint64_t v24 = v42;
    char v25 = v43;
    LOBYTE(v42) = 3;
    char v26 = (*(uint64_t (**)(uint64_t *, Class *, _UNKNOWN **))(*(void *)v21 + 120))(&v42, v19, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    uint64_t v27 = v39;
    char v29 = v26;
    swift_release(v21);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a2, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
    char v31 = v36;
    uint64_t v32 = (char *)v36 + *((int *)TupleTypeMetadata3 + 12);
    uint64_t v33 = (char *)v36 + *((int *)TupleTypeMetadata3 + 16);
    *uint64_t v36 = v35;
    (*(void (**)(char *, char *, uint64_t))(v27 + 32))(v32, v41, a2);
    *(void *)uint64_t v33 = v24;
    v33[8] = v25;
    swift_storeEnumTagMultiPayload(v31, (uint64_t)v14, v29 & 1);
    (*(void (**)(uint64_t, uint64_t *, Class *))(v37 + 32))(v38, v31, v14);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v40);
}

uint64_t CollectionDifference.Change<A>.encode(to:)(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *, char *, uint64_t), uint64_t a4)
{
  uint64_t v58 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v60 = *(void *)(v7 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v54 = (char *)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v52 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v53 = (char *)&v51 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v56 = (char *)&v51 - v17;
  uint64_t v18 = (void *)MEMORY[0x1F4188790](v16);
  uint64_t v20 = (unsigned __int8 *)&v51 - v19;
  uint64_t v22 = v18[3];
  uint64_t v21 = v18[4];
  __swift_project_boxed_opaque_existential_0Tm(v18, v22);
  uint64_t v55 = a4;
  unint64_t v23 = type metadata accessor for CollectionDifference.Change<A>._CodingKeys(0, v7, (uint64_t)v58, a4);
  (*(void (**)(uint64_t *__return_ptr, Class *, Class *, _UNKNOWN **, uint64_t, uint64_t))(v21 + 24))(&v64, v23, v23, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, v22, v21);
  uint64_t v24 = *(void (**)(uint64_t *, char *, uint64_t))(v11 + 16);
  uint64_t v57 = v11 + 16;
  uint64_t v58 = v24;
  char v25 = v4;
  v24((uint64_t *)v20, v4, a2);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v20, a2);
  uint64_t v27 = &v20[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0)+ 12)];
  LOBYTE(v61) = 3;
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v28 = v64;
    char v29 = *(void (**)(uint64_t, uint64_t *, Class *, _UNKNOWN **))(*(void *)v64 + 104);
    uint64_t v30 = 1;
  }
  else
  {
    uint64_t v28 = v64;
    char v29 = *(void (**)(uint64_t, uint64_t *, Class *, _UNKNOWN **))(*(void *)v64 + 104);
    uint64_t v30 = 0;
  }
  char v31 = v59;
  v29(v30, &v61, v23, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
  if (v31)
  {
    swift_release(v28);
    return (*(uint64_t (**)(unsigned __int8 *, uint64_t))(v60 + 8))(v27, v7);
  }
  else
  {
    uint64_t v33 = (uint64_t *)v56;
    uint64_t v34 = *(void (**)(unsigned __int8 *, uint64_t))(v60 + 8);
    v34(v27, v7);
    uint64_t v56 = v25;
    v58(v33, v25, a2);
    uint64_t v35 = *v33;
    uint64_t v36 = (char *)v33
        + *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0)+ 12);
    BOOL v59 = v34;
    v34((unsigned __int8 *)v36, v7);
    LOBYTE(v61) = 0;
    uint64_t v37 = v64;
    (*(void (**)(uint64_t, uint64_t *, Class *, _UNKNOWN **))(*(void *)v64 + 136))(v35, &v61, v23, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    uint64_t v38 = v53;
    uint64_t v39 = v56;
    v58((uint64_t *)v53, v56, a2);
    char v40 = &v38[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0)+ 12)];
    unint64_t v41 = v54;
    (*(void (**)(char *, char *, uint64_t))(v60 + 32))(v54, v40, v7);
    LOBYTE(v61) = 1;
    (*(void (**)(char *, uint64_t *, uint64_t, Class *, uint64_t, _UNKNOWN **))(*(void *)v37 + 232))(v41, &v61, v7, v23, v55, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    v59((unsigned __int8 *)v41, v7);
    uint64_t v42 = v52;
    v58((uint64_t *)v52, v39, a2);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
    char v44 = &v42[*((int *)TupleTypeMetadata3 + 12)];
    char v45 = &v42[*((int *)TupleTypeMetadata3 + 16)];
    uint64_t v46 = *(void *)v45;
    char v47 = v45[8];
    v59((unsigned __int8 *)v44, v7);
    char v63 = 2;
    uint64_t v61 = v46;
    char v62 = v47;
    uint64_t v48 = v64;
    uint64_t v49 = *(void (**)(uint64_t *, char *, unint64_t *, Class *, unint64_t, _UNKNOWN **))(*(void *)v64 + 232);
    unint64_t v50 = lazy protocol witness table accessor for type Int? and conformance <A> A?();
    v49(&v61, &v63, qword_1ECA01F50, v23, v50, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    return swift_release(v48);
  }
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CollectionDifference.Change<A>.encode(to:)(a1, a2, *(void (**)(uint64_t *, char *, uint64_t))(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for Decodable.init(from:) in conformance <A> CollectionDifference<A>.Change@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return CollectionDifference.Change<A>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

void CollectionDifference<A>.encode(to:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = *v4;
  unint64_t v26 = v4[1];
  uint64_t v10 = a1[3];
  uint64_t v9 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v10);
  uint64_t v11 = *(void *)(a2 + 16);
  uint64_t v14 = type metadata accessor for CollectionDifference.CodingKeys(0, v11, v12, v13);
  (*(void (**)(uint64_t *__return_ptr, Class *, Class *, _UNKNOWN **, uint64_t, uint64_t))(v9 + 24))(&v32, v14, v14, &protocol witness table for CollectionDifference<A>.CodingKeys, v10, v9);
  unint64_t v31 = v8;
  char v30 = 0;
  uint64_t v15 = v32;
  uint64_t v16 = v11;
  uint64_t v17 = *(void (**)(unint64_t *, char *, unint64_t *, Class *, uint64_t, _UNKNOWN **))(*(void *)v32 + 232);
  uint64_t v20 = (unint64_t *)type metadata accessor for CollectionDifference.Change(255, v16, v18, v19);
  unint64_t v23 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v20, v21, v22);
  v29[0] = a3;
  v29[1] = a4;
  swift_bridgeObjectRetain(v8);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for <A> CollectionDifference<A>.Change, v20, (uint64_t)v29);
  uint64_t v24 = swift_getWitnessTable(protocol conformance descriptor for <A> [A], v23, (uint64_t)&WitnessTable);
  v17(&v31, &v30, v23, v14, v24, &protocol witness table for CollectionDifference<A>.CodingKeys);
  if (v27)
  {
    swift_release(v15);
    uint64_t v25 = v8;
  }
  else
  {
    swift_bridgeObjectRelease(v8);
    unint64_t v31 = v26;
    char v30 = 1;
    swift_bridgeObjectRetain(v26);
    v17(&v31, &v30, v23, v14, v24, &protocol witness table for CollectionDifference<A>.CodingKeys);
    swift_release(v15);
    uint64_t v25 = v26;
  }
  swift_bridgeObjectRelease(v25);
}

void CollectionDifference<A>.init(from:)(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  void (*v22)(unint64_t *__return_ptr, unint64_t *, char *, unint64_t *, Class *, uint64_t, _UNKNOWN **);
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t WitnessTable;
  void v28[2];
  char v29;
  unint64_t v30;

  uint64_t v11 = a1[3];
  uint64_t v10 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v11);
  uint64_t v14 = type metadata accessor for CollectionDifference.CodingKeys(0, a2, v12, v13);
  (*(void (**)(unint64_t *__return_ptr, Class *, Class *, _UNKNOWN **, uint64_t, uint64_t))(v10 + 24))(&v30, v14, v14, &protocol witness table for CollectionDifference<A>.CodingKeys, v11, v10);
  if (v5)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  else
  {
    uint64_t v17 = v30;
    char v29 = 0;
    uint64_t v18 = (unint64_t *)type metadata accessor for CollectionDifference.Change(255, a2, v15, v16);
    uint64_t v21 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v18, v19, v20);
    uint64_t v22 = *(void (**)(unint64_t *__return_ptr, unint64_t *, char *, unint64_t *, Class *, uint64_t, _UNKNOWN **))(*(void *)v17 + 248);
    v28[0] = a3;
    v28[1] = a4;
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for <A> CollectionDifference<A>.Change, v18, (uint64_t)v28);
    unint64_t v23 = swift_getWitnessTable(protocol conformance descriptor for <A> [A], v21, (uint64_t)&WitnessTable);
    v22(&v30, v21, &v29, v21, v14, v23, &protocol witness table for CollectionDifference<A>.CodingKeys);
    uint64_t v24 = v30;
    char v29 = 1;
    swift_bridgeObjectRetain(v30);
    v22(&v30, v21, &v29, v21, v14, v23, &protocol witness table for CollectionDifference<A>.CodingKeys);
    swift_release(v17);
    uint64_t v25 = v30;
    *a5 = v24;
    a5[1] = v25;
    swift_bridgeObjectRetain(v25);
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    swift_bridgeObjectRelease(v25);
    swift_bridgeObjectRelease(v24);
  }
}

void protocol witness for Encodable.encode(to:) in conformance <A> CollectionDifference<A>(void *a1, uint64_t a2, uint64_t a3)
{
}

void protocol witness for Decodable.init(from:) in conformance <A> CollectionDifference<A>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
}

uint64_t (*CollectionOfOne._element.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.Iterator._elements.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = type metadata accessor for Optional(0, *(void *)(a1 + 16), a2, a3);
  uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v6 - 1) + 2);

  return v7(a4, v4, v6);
}

uint64_t CollectionOfOne.Iterator._elements.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for Optional(0, *(void *)(a2 + 16), a3, a4);
  uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v6 - 1) + 5);

  return v7(v4, a1, v6);
}

uint64_t (*CollectionOfOne.Iterator._elements.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.Iterator.init(_elements:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56))(a3, 1, 1, a2);
  unint64_t v8 = type metadata accessor for Optional(0, a2, v6, v7);
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, Class *))*((void *)*(v8 - 1) + 5);

  return v9(a3, a1, v8);
}

uint64_t CollectionOfOne.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = type metadata accessor for Optional(0, v6, a2, a3);
  (*((void (**)(uint64_t, uint64_t, Class *))*(v7 - 1) + 4))(a4, v4, v7);
  unint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56);

  return v8(v4, 1, 1, v6);
}

uint64_t CollectionOfOne.startIndex.getter()
{
  return 0;
}

uint64_t CollectionOfOne.endIndex.getter()
{
  return 1;
}

Swift::Int __swiftcall CollectionOfOne.index(after:)(Swift::Int after)
{
  if (after) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x66uLL, 0);
  }
  return 1;
}

Swift::Int __swiftcall CollectionOfOne.index(before:)(Swift::Int before)
{
  if (before != 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x70uLL, 0);
  }
  return 0;
}

uint64_t CollectionOfOne.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = type metadata accessor for Optional(0, v6, a2, a3);
  uint64_t v8 = (uint64_t)*(v7 - 1);
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v14 - v9;
  uint64_t v11 = *(void *)(v6 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))((char *)&v14 - v9, v4, v6);
  uint64_t v12 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 56);
  v12(v10, 0, 1, v6);
  v12(a4, 1, 1, v6);
  return (*(uint64_t (**)(char *, char *, Class *))(v8 + 40))(a4, v10, v7);
}

uint64_t CollectionOfOne.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x83uLL, 0);
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 16);

  return v4(a3, v3);
}

uint64_t key path getter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v5 = CollectionOfOne.subscript.read((uint64_t)v7, *a1);
  (*(void (**)(uint64_t))(*(void *)(v4 - 8) + 16))(a3);
  return ((uint64_t (*)(unsigned char *, void))v5)(v7, 0);
}

uint64_t (*CollectionOfOne.subscript.read(uint64_t a1, uint64_t a2))()
{
  if (a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x83uLL, 0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t key path setter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = *(uint64_t *)((char *)a3 + a4 - 8);
  uint64_t v6 = CollectionOfOne.subscript.modify((uint64_t)v9, *a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24))(v7, a1, v5);
  return ((uint64_t (*)(unsigned char *, void))v6)(v9, 0);
}

{
  unint64_t *v6;
  uint64_t v7;
  uint64_t WitnessTable;
  uint64_t v9;
  Class *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  uint64_t v6 = (unint64_t *)type metadata accessor for CollectionOfOne(255, *(uint64_t *)((char *)a3 + a4 - 8), (uint64_t)a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, v6, v7);
  uint64_t v10 = type metadata accessor for Slice(0, (uint64_t)v6, WitnessTable, v9);
  MEMORY[0x1F4188790](v10);
  uint64_t v12 = (uint64_t *)((char *)&v17 - v11);
  uint64_t v14 = *a3;
  uint64_t v13 = a3[1];
  (*(void (**)(char *, uint64_t))(v15 + 16))((char *)&v17 - v11, a1);
  return CollectionOfOne.subscript.setter(v12, v14, v13, v6);
}

uint64_t (*CollectionOfOne.subscript.modify(uint64_t a1, uint64_t a2))()
{
  if (a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x87uLL, 0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x87uLL, 0);
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8) + 40);

  return v4(v3, a1);
}

uint64_t CollectionOfOne.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, char *a4@<X8>)
{
  v14[0] = a1;
  v14[1] = a2;
  long long v13 = xmmword_18162ACB0;
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a3, (uint64_t)a3);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v14, (uint64_t)&v13, (uint64_t)a3, WitnessTable);
  uint64_t v11 = type metadata accessor for Slice(0, (uint64_t)a3, (uint64_t)WitnessTable, v10);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(*(a3 - 1) + 16))(&a4[*((int *)v11 + 10)], v4, a3);
  *(void *)a4 = a1;
  *((void *)a4 + 1) = a2;
  return result;
}

uint64_t key path getter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  uint64_t v7 = (unint64_t *)type metadata accessor for CollectionOfOne(0, *(uint64_t *)((char *)a1 + a2 - 8), a2, a3);
  return CollectionOfOne.subscript.getter(v5, v6, v7, a4);
}

uint64_t CollectionOfOne.subscript.setter(void *a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v5 = v4;
  v21[0] = a2;
  v21[1] = a3;
  long long v20 = xmmword_18162ACB0;
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a4, a3);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v21, (uint64_t)&v20, (uint64_t)a4, WitnessTable);
  uint64_t v11 = a1[1];
  v21[0] = *a1;
  *(void *)&long long v20 = v11;
  long long v13 = type metadata accessor for Slice(0, (uint64_t)a4, (uint64_t)WitnessTable, v12);
  uint64_t v14 = (char *)a1 + *((int *)v13 + 10);
  uint64_t v16 = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a4, v15);
  uint64_t v17 = RandomAccessCollection<>.distance(from:to:)((uint64_t)v21, (uint64_t)&v20, (uint64_t)a4, v16, (uint64_t)&protocol witness table for Int);
  if (__OFSUB__(a3, a2))
  {
    __break(1u);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "CollectionOfOne can't be resized", 32, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x95uLL, 0);
  }
  if (a3 - a2 != v17) {
    goto LABEL_8;
  }
  if (v17 != 1) {
    return (*((uint64_t (**)(void *, Class *))*(v13 - 1) + 1))(a1, v13);
  }
  uint64_t v18 = *(a4 - 1);
  (*(void (**)(uint64_t, unint64_t *))(v18 + 8))(v5, a4);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t *))(v18 + 32))(v5, v14, a4);
}

void (*CollectionOfOne.subscript.modify(void *a1, uint64_t a2, uint64_t a3, unint64_t *a4))(uint64_t *a1, char a2)
{
  uint64_t v5 = v4;
  uint64_t v10 = malloc(0x60uLL);
  *a1 = v10;
  v10[6] = a4;
  v10[7] = v5;
  v10[4] = a2;
  v10[5] = a3;
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a4, v11);
  uint64_t v14 = type metadata accessor for Slice(0, (uint64_t)a4, (uint64_t)WitnessTable, v13);
  v10[8] = v14;
  uint64_t v15 = (uint64_t)*(v14 - 1);
  v10[9] = v15;
  size_t v16 = *(void *)(v15 + 64);
  v10[10] = malloc(v16);
  uint64_t v17 = (char *)malloc(v16);
  v10[11] = v17;
  *uint64_t v10 = a2;
  v10[1] = a3;
  *((_OWORD *)v10 + 1) = xmmword_18162ACB0;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v10, (uint64_t)(v10 + 2), (uint64_t)a4, WitnessTable);
  (*(void (**)(char *, uint64_t, unint64_t *))(*(a4 - 1) + 16))(&v17[*((int *)v14 + 10)], v5, a4);
  *(void *)uint64_t v17 = a2;
  *((void *)v17 + 1) = a3;
  return CollectionOfOne.subscript.modify;
}

void CollectionOfOne.subscript.modify(uint64_t *a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void **)(*a1 + 80);
  uint64_t v4 = *(void **)(*a1 + 88);
  if (a2)
  {
    uint64_t v5 = *(void *)(v2 + 64);
    uint64_t v6 = *(void *)(v2 + 72);
    uint64_t v7 = *(unint64_t **)(v2 + 48);
    uint64_t v9 = *(void *)(v2 + 32);
    uint64_t v8 = *(void *)(v2 + 40);
    (*(void (**)(void, void *, uint64_t))(v6 + 16))(*(void *)(*a1 + 80), v4, v5);
    CollectionOfOne.subscript.setter(v3, v9, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }
  else
  {
    CollectionOfOne.subscript.setter(*(void **)(*a1 + 88), *(void *)(v2 + 32), *(void *)(v2 + 40), *(unint64_t **)(v2 + 48));
  }
  free(v4);
  free(v3);

  free((void *)v2);
}

uint64_t CollectionOfOne.count.getter()
{
  return 1;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance CollectionOfOne<A>(uint64_t a1, void *a2, uint64_t a3)
{
  if (*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x87uLL, 0);
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8) + 40);

  return v4(v3, a1);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>(void *a1, uint64_t *a2))()
{
  uint64_t v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = CollectionOfOne.subscript.modify((uint64_t)v4, *a2);
  return protocol witness for MutableCollection.subscript.modify in conformance [A];
}

void protocol witness for MutableCollection.subscript.modify in conformance [A](void *a1)
{
  BOOL v1 = (void *)*a1;
  (*(void (**)(void))(*a1 + 32))(*a1);

  free(v1);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance CollectionOfOne<A>(void *a1, uint64_t *a2, unint64_t *a3)
{
  return CollectionOfOne.subscript.setter(a1, *a2, a2[1], a3);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>(void *a1, uint64_t *a2, unint64_t *a3))(uint64_t *a1, char a2)
{
  uint64_t v7 = malloc(0x60uLL);
  *a1 = v7;
  v7[4] = v3;
  v7[5] = a3;
  uint64_t WitnessTable = (int **)swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a3, v8);
  uint64_t v11 = type metadata accessor for Slice(0, (uint64_t)a3, (uint64_t)WitnessTable, v10);
  v7[6] = v11;
  uint64_t v12 = (uint64_t)*(v11 - 1);
  v7[7] = v12;
  size_t v13 = *(void *)(v12 + 64);
  v7[8] = malloc(v13);
  uint64_t v14 = (char *)malloc(v13);
  uint64_t v16 = *a2;
  uint64_t v15 = a2[1];
  v7[9] = v14;
  v7[10] = v16;
  v7[11] = v15;
  *uint64_t v7 = v16;
  v7[1] = v15;
  *((_OWORD *)v7 + 1) = xmmword_18162ACB0;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v7, (uint64_t)(v7 + 2), (uint64_t)a3, WitnessTable);
  (*(void (**)(char *, uint64_t, unint64_t *))(*(a3 - 1) + 16))(&v14[*((int *)v11 + 10)], v3, a3);
  *(void *)uint64_t v14 = v16;
  *((void *)v14 + 1) = v15;
  return protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>(uint64_t *a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*a1 + 80);
  uint64_t v4 = *(void *)(*a1 + 88);
  uint64_t v5 = *(void **)(*a1 + 64);
  uint64_t v6 = *(void **)(*a1 + 72);
  if (a2)
  {
    uint64_t v7 = *(void *)(v2 + 48);
    uint64_t v8 = *(void *)(v2 + 56);
    uint64_t v9 = *(unint64_t **)(v2 + 40);
    (*(void (**)(void, void *, uint64_t))(v8 + 16))(*(void *)(*a1 + 64), v6, v7);
    CollectionOfOne.subscript.setter(v5, v3, v4, v9);
    (*(void (**)(void *, uint64_t))(v8 + 8))(v6, v7);
  }
  else
  {
    CollectionOfOne.subscript.setter(*(void **)(*a1 + 72), v3, v4, *(unint64_t **)(v2 + 40));
  }
  free(v6);
  free(v5);

  free((void *)v2);
}

void *protocol witness for MutableCollection.partition(by:) in conformance CollectionOfOne<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a3, (uint64_t)a3);
  return MutableCollection<>.partition(by:)(a1, a2, (uint64_t)a3, WitnessTable, a4, a5);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance CollectionOfOne<A>@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*result != 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x70uLL, 0);
  }
  *a2 = 0;
  return result;
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance CollectionOfOne<A>(void *result)
{
  if (*result != 1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x70uLL, 0);
  }
  *uint64_t result = 0;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance CollectionOfOne<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance CollectionOfOne<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

void protocol witness for Collection.endIndex.getter in conformance CollectionOfOne<A>(void *a1@<X8>)
{
  *a1 = 1;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance CollectionOfOne<A>(void *a1, uint64_t *a2))()
{
  uint64_t v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = CollectionOfOne.subscript.read((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for Collection.subscript.getter in conformance CollectionOfOne<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, char *a3@<X8>)
{
  return CollectionOfOne.subscript.getter(*a1, a1[1], a2, a3);
}

uint64_t protocol witness for Collection.indices.getter in conformance CollectionOfOne<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for Collection.index(after:) in conformance CollectionOfOne<A>@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x66uLL, 0);
  }
  *a2 = 1;
  return result;
}

void *protocol witness for Collection.formIndex(after:) in conformance CollectionOfOne<A>(void *result)
{
  if (*result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x66uLL, 0);
  }
  *uint64_t result = 1;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance CollectionOfOne<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance CollectionOfOne<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a1, a3);

  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t CollectionOfOne.debugDescription.getter(uint64_t a1)
{
  unint64_t v3 = v1;
  unint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (uint64_t)&v179 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = specialized static String._createEmpty(withInitialCapacity:)(19);
  uint64_t v10 = v8;
  uint64_t v11 = v9;
  unint64_t v182 = v8;
  unint64_t v183 = v9;
  uint64_t v12 = HIBYTE(v9) & 0xF;
  uint64_t v13 = v8 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0x2000000000000000) != 0) {
    uint64_t v14 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v14 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (!v14 && (v8 & ~v9 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v9);
    unint64_t v58 = 0x80000001816DFA10 | 0x8000000000000000;
    unint64_t v182 = 0xD000000000000010;
LABEL_85:
    unint64_t v183 = v58;
    goto LABEL_86;
  }
  if ((v9 & 0x2000000000000000) != 0 && (0x80000001816DFA10 & 0x2000000000000000) != 0)
  {
    unint64_t v2 = v12 + ((0x80000001816DFA10 >> 56) & 0xF);
    if (v2 <= 0xF)
    {
      unint64_t v35 = (0x80000001816DFA10 >> 56) & 0xF;
      if (v35)
      {
        char v59 = 0;
        uint64_t v60 = 0;
        unint64_t v36 = v9;
        do
        {
          uint64_t v61 = v12 + v60;
          uint64_t v62 = v60 + 1;
          unint64_t v63 = 0x80000001816DFA10 | 0x8000000000000000;
          if (v60 < 8) {
            unint64_t v63 = 0xD000000000000010;
          }
          unint64_t v64 = v63 >> (v59 & 0x38);
          char v65 = (8 * v12 + v59) & 0x38;
          uint64_t v66 = (-255 << v65) - 1;
          unint64_t v67 = (unint64_t)v64 << v65;
          unint64_t v68 = v67 | v66 & v36;
          unint64_t v69 = v67 | v66 & v10;
          if (v61 < 8) {
            uint64_t v10 = v69;
          }
          else {
            unint64_t v36 = v68;
          }
          v59 += 8;
          uint64_t v60 = v62;
        }
        while (v35 != v62);
      }
      else
      {
        unint64_t v36 = v9;
      }
      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(0x80000001816DFA10 | 0x8000000000000000);
      unint64_t v70 = 0xA000000000000000;
      if (!(v10 & 0x8080808080808080 | v36 & 0x80808080808080)) {
        unint64_t v70 = 0xE000000000000000;
      }
      unint64_t v58 = v70 & 0xFF00000000000000 | (v2 << 56) | v36 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v182 = v10;
      goto LABEL_85;
    }
  }
  unint64_t v180 = v3;
  uint64_t v15 = (const char *)(0x80000001816DFA10 | 0x8000000000000000);
  if ((0x80000001816DFA10 & 0x2000000000000000) != 0) {
    unint64_t v2 = (0x80000001816DFA10 >> 56) & 0xF;
  }
  else {
    unint64_t v2 = 16;
  }
  swift_bridgeObjectRetain_n(0x80000001816DFA10 | 0x8000000000000000, 2);
  if ((0x80000001816DFA10 & 0x1000000000000000) != 0) {
    goto LABEL_208;
  }
  swift_bridgeObjectRetain_n(0x80000001816DFA10 | 0x8000000000000000, 4);
  Swift::Int v16 = v2;
  if ((v11 & 0x1000000000000000) != 0) {
    goto LABEL_211;
  }
LABEL_14:
  BOOL v17 = __OFADD__(v14, v16);
  Swift::Int v18 = v14 + v16;
  if (v17)
  {
LABEL_213:
    __break(1u);
    goto LABEL_214;
  }
LABEL_15:
  uint64_t v19 = v10 & ~v11;
  if ((v19 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
    if (v21) {
      goto LABEL_236;
    }
    if (v18 <= 15)
    {
      if ((v11 & 0x2000000000000000) != 0) {
        goto LABEL_56;
      }
      if (v20 < v16) {
        goto LABEL_48;
      }
    }
  }
  else if (v18 <= 15)
  {
    if ((v11 & 0x2000000000000000) != 0)
    {
LABEL_56:
      uint64_t v15 = "CollectionOfOne(";
      swift_bridgeObjectRelease_n(0x80000001816DFA10 | 0x8000000000000000, 5);
      unint64_t v34 = v11;
      goto LABEL_57;
    }
LABEL_48:
    uint64_t v15 = "CollectionOfOne(";
    swift_bridgeObjectRelease_n(0x80000001816DFA10 | 0x8000000000000000, 5);
    if ((v11 & 0x1000000000000000) == 0)
    {
      if ((v10 & 0x1000000000000000) != 0)
      {
        uint64_t v33 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        uint64_t v33 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v11);
        uint64_t v13 = v170;
      }
      swift_bridgeObjectRetain(v11);
      closure #1 in _StringGuts._convertedToSmall()(v33, v13, &v181);
      swift_bridgeObjectRelease(v11);
      unint64_t v34 = *((void *)&v181 + 1);
      uint64_t v10 = v181;
      goto LABEL_57;
    }
    goto LABEL_231;
  }
  int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
  BOOL v25 = (v23 & 1) == 0 && v22 >= v16;
  if ((v19 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v3 = v180;
    uint64_t v15 = "CollectionOfOne(";
    if (v25) {
      goto LABEL_41;
    }
  }
  else
  {
    unint64_t v3 = v180;
    uint64_t v15 = "CollectionOfOne(";
    if (v25) {
      goto LABEL_40;
    }
  }
  uint64_t v26 = _StringGuts.nativeCapacity.getter(v10, v11);
  if (v27) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = v26;
  }
  if (v28 + 0x4000000000000000 >= 0)
  {
    uint64_t v29 = 2 * v28;
    if (v29 > v18) {
      Swift::Int v18 = v29;
    }
LABEL_40:
    _StringGuts.grow(_:)(v18);
LABEL_41:
    unint64_t v30 = 0x80000001816DFA10 | 0x8000000000000000;
    swift_bridgeObjectRelease_n(0x80000001816DFA10 | 0x8000000000000000, 4);
    if ((0x80000001816DFA10 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(0x80000001816DFA10 | 0x8000000000000000);
      _StringGuts._foreignAppendInPlace(_:)(0xD000000000000010, 0x80000001816DFA10 | 0x8000000000000000, 0, v2);
    }
    else
    {
      if ((0x80000001816DFA10 & 0x2000000000000000) != 0) {
        uint64_t v10 = (v30 >> 62) & 1;
      }
      else {
        uint64_t v10 = 1;
      }
      swift_bridgeObjectRelease(0x80000001816DFA10 | 0x8000000000000000);
      if ((0x80000001816DFA10 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(0x80000001816DFA10 | 0x8000000000000000);
        *(void *)&long long v181 = 0xD000000000000010;
        *((void *)&v181 + 1) = 0x80000001816DFA10 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v122 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v2, (uint64_t)&v181, (0x80000001816DFA10 >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v122, v123, v10);
        swift_bridgeObjectRelease(0x80000001816DFA10 | 0x8000000000000000);
        goto LABEL_86;
      }
      unint64_t v30 = 0x80000001816DFA10 | 0x8000000000000000;
      unint64_t v31 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v2, (0x80000001816DFA10 & 0xFFFFFFFFFFFFFFFLL) + 32, 16);
      _StringGuts.appendInPlace(_:isASCII:)(v31, v32, v10);
    }
    swift_bridgeObjectRelease_n(v30, 2);
    goto LABEL_86;
  }
  while (1)
  {
    __break(1u);
LABEL_231:
    uint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, v11);
    unint64_t v34 = v169;
LABEL_57:
    v37._Swift::UInt64 rawBits = (v2 << 16) | 1;
    v38._Swift::UInt64 rawBits = 1;
    v39._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v38, v37, 0xD000000000000010, (unint64_t)(v15 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    if (v39._rawBits < 0x10000) {
      v39._rawBits |= 3;
    }
    unint64_t v41 = specialized String.init(_:)(v39, v40, 0xD000000000000010, (unint64_t)(v15 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    unint64_t v2 = v42;
    swift_bridgeObjectRelease((unint64_t)(v15 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    if ((v2 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v2);
    }
    else if ((v2 & 0x1000000000000000) != 0)
    {
      unint64_t v41 = _StringGuts._foreignConvertedToSmall()(v41, v2);
      unint64_t v176 = v175;
      swift_bridgeObjectRelease(v2);
      unint64_t v2 = v176;
    }
    else
    {
      if ((v41 & 0x1000000000000000) != 0)
      {
        Swift::String::Index v166 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v167 = v41 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        Swift::String::Index v166 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v41, v2);
      }
      closure #1 in _StringGuts._convertedToSmall()(v166, v167, &v181);
      swift_bridgeObjectRelease(v2);
      unint64_t v2 = *((void *)&v181 + 1);
      unint64_t v41 = v181;
    }
    uint64_t v43 = HIBYTE(v34) & 0xF;
    uint64_t v44 = HIBYTE(v2) & 0xF;
    uint64_t v45 = v44 + v43;
    if ((unint64_t)(v44 + v43) > 0xF) {
      goto LABEL_235;
    }
    if (v44)
    {
      char v46 = 0;
      unint64_t v47 = 0;
      do
      {
        unint64_t v48 = v43 + v47;
        unint64_t v49 = v47 + 1;
        if (v47 >= 8) {
          unint64_t v50 = v2;
        }
        else {
          unint64_t v50 = v41;
        }
        unint64_t v51 = v50 >> (v46 & 0x38);
        char v52 = (8 * v43 + v46) & 0x38;
        uint64_t v53 = (-255 << v52) - 1;
        unint64_t v54 = (unint64_t)v51 << v52;
        unint64_t v55 = v54 | v53 & v34;
        unint64_t v56 = v54 | v53 & v10;
        if (v48 < 8) {
          uint64_t v10 = v56;
        }
        else {
          unint64_t v34 = v55;
        }
        v46 += 8;
        unint64_t v47 = v49;
      }
      while (v44 != v49);
    }
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease((unint64_t)(v15 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    unint64_t v57 = 0xA000000000000000;
    if (!(v10 & 0x8080808080808080 | v34 & 0x80808080808080)) {
      unint64_t v57 = 0xE000000000000000;
    }
    unint64_t v182 = v10;
    unint64_t v183 = v57 & 0xFF00000000000000 | (v45 << 56) | v34 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v3 = v180;
LABEL_86:
    (*(void (**)(uint64_t, unint64_t, unint64_t))(v5 + 16))(v7, v3, v4);
    *(void *)&long long v181 = 0;
    *((void *)&v181 + 1) = 0xE000000000000000;
    _debugPrint_unlocked<A, B>(_:_:)(v7, (uint64_t)&v181, (Class *)v4, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
    (*(void (**)(uint64_t, unint64_t))(v5 + 8))(v7, v4);
    unint64_t v4 = *((void *)&v181 + 1);
    uint64_t v5 = v181;
    uint64_t v7 = v182;
    uint64_t v11 = v183;
    unint64_t v71 = HIBYTE(v183) & 0xF;
    uint64_t v14 = v182 & 0xFFFFFFFFFFFFLL;
    if ((v183 & 0x2000000000000000) != 0) {
      unint64_t v72 = HIBYTE(v183) & 0xF;
    }
    else {
      unint64_t v72 = v182 & 0xFFFFFFFFFFFFLL;
    }
    if (!v72 && (v182 & ~v183 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v183);
      unint64_t v182 = v5;
      unint64_t v183 = v4;
      goto LABEL_171;
    }
    uint64_t v13 = *((void *)&v181 + 1) & 0x2000000000000000;
    unint64_t v2 = HIBYTE(*((void *)&v181 + 1)) & 0xFLL;
    if ((v183 & 0x2000000000000000) != 0 && v13)
    {
      uint64_t v10 = v71 + v2;
      if (v71 + v2 <= 0xF)
      {
        if (v2)
        {
          char v110 = 0;
          unint64_t v111 = 0;
          unint64_t v112 = v183;
          do
          {
            unint64_t v113 = v71 + v111;
            unint64_t v114 = v111 + 1;
            if (v111 >= 8) {
              unint64_t v115 = *((void *)&v181 + 1);
            }
            else {
              unint64_t v115 = v181;
            }
            unint64_t v116 = v115 >> (v110 & 0x38);
            char v117 = (8 * v71 + v110) & 0x38;
            uint64_t v118 = (-255 << v117) - 1;
            unint64_t v119 = (unint64_t)v116 << v117;
            unint64_t v120 = v119 | v118 & v112;
            unint64_t v121 = v119 | v118 & v7;
            if (v113 < 8) {
              uint64_t v7 = v121;
            }
            else {
              unint64_t v112 = v120;
            }
            v110 += 8;
            unint64_t v111 = v114;
          }
          while (v2 != v114);
        }
        else
        {
          unint64_t v112 = v183;
        }
        swift_bridgeObjectRelease(v183);
        swift_bridgeObjectRelease(v4);
        unint64_t v129 = 0xA000000000000000;
        if (!(v7 & 0x8080808080808080 | v112 & 0x80808080808080)) {
          unint64_t v129 = 0xE000000000000000;
        }
        unint64_t v103 = v129 & 0xFF00000000000000 | (v10 << 56) | v112 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_170;
      }
      uint64_t v13 = 1;
    }
    uint64_t v179 = v181 & 0xFFFFFFFFFFFFLL;
    uint64_t v10 = v13 ? HIBYTE(*((void *)&v181 + 1)) & 0xFLL : v181 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(*((uint64_t *)&v181 + 1), 2);
    if ((v4 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v4, 5);
      v153._Swift::UInt64 rawBits = 1;
      v154._Swift::UInt64 rawBits = (v10 << 16) | 1;
      v155._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v153, v154, v5, v4);
      if (v155._rawBits < 0x10000) {
        v155._rawBits |= 3;
      }
      uint64_t v15 = (const char *)specialized Collection.count.getter(v155, v156, v5, v4);
      swift_bridgeObjectRelease(v4);
      if ((v11 & 0x1000000000000000) == 0)
      {
LABEL_100:
        BOOL v17 = __OFADD__(v72, v15);
        Swift::Int v73 = (Swift::Int)&v15[v72];
        if (v17) {
          goto LABEL_207;
        }
        goto LABEL_101;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v4, 4);
      uint64_t v15 = (const char *)v10;
      if ((v11 & 0x1000000000000000) == 0) {
        goto LABEL_100;
      }
    }
    Swift::Int v157 = String.UTF8View._foreignCount()();
    Swift::Int v73 = (Swift::Int)&v15[v157];
    if (__OFADD__(v157, v15))
    {
LABEL_207:
      __break(1u);
LABEL_208:
      swift_bridgeObjectRetain_n((uint64_t)v15, 5);
      v158._Swift::UInt64 rawBits = 1;
      v159._Swift::UInt64 rawBits = (v2 << 16) | 1;
      v160._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v158, v159, 0xD000000000000010, (unint64_t)v15);
      if (v160._rawBits < 0x10000) {
        v160._rawBits |= 3;
      }
      Swift::Int v16 = specialized Collection.count.getter(v160, v161, 0xD000000000000010, (unint64_t)v15);
      swift_bridgeObjectRelease((uint64_t)v15);
      if ((v11 & 0x1000000000000000) == 0) {
        goto LABEL_14;
      }
LABEL_211:
      Swift::Int v162 = String.UTF8View._foreignCount()();
      Swift::Int v18 = v162 + v16;
      if (__OFADD__(v162, v16)) {
        goto LABEL_213;
      }
      goto LABEL_15;
    }
LABEL_101:
    unint64_t v180 = v5;
    uint64_t v74 = v10;
    uint64_t v75 = v7 & ~v11;
    if ((v75 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v73 > 15) {
        goto LABEL_107;
      }
LABEL_118:
      swift_bridgeObjectRelease_n(v4, 5);
      if ((v11 & 0x2000000000000000) != 0)
      {
LABEL_119:
        unint64_t v2 = v11;
      }
      else if ((v11 & 0x1000000000000000) != 0)
      {
        uint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v11);
        unint64_t v2 = v177;
      }
      else
      {
        if ((v7 & 0x1000000000000000) != 0)
        {
          Swift::String::Index v168 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          Swift::String::Index v168 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v11);
          uint64_t v14 = v178;
        }
        swift_bridgeObjectRetain(v11);
        closure #1 in _StringGuts._convertedToSmall()(v168, v14, &v181);
        swift_bridgeObjectRelease(v11);
        unint64_t v2 = *((void *)&v181 + 1);
        uint64_t v7 = v181;
      }
      v82._Swift::UInt64 rawBits = (v74 << 16) | 1;
      v83._Swift::UInt64 rawBits = 1;
      unint64_t v84 = v180;
      v85._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v83, v82, v180, v4);
      if (v85._rawBits < 0x10000) {
        v85._rawBits |= 3;
      }
      uint64_t v10 = specialized String.init(_:)(v85, v86, v84, v4);
      uint64_t v5 = v87;
      swift_bridgeObjectRelease(v4);
      if ((v5 & 0x2000000000000000) == 0) {
        goto LABEL_217;
      }
      swift_bridgeObjectRelease(v5);
      goto LABEL_124;
    }
    int64_t v76 = _StringGuts.nativeUnusedCapacity.getter(v7, v11);
    if (v77) {
      goto LABEL_236;
    }
    if (v73 > 15) {
      goto LABEL_107;
    }
    if ((v11 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease_n(v4, 5);
      goto LABEL_119;
    }
    if (v76 < (uint64_t)v15) {
      goto LABEL_118;
    }
LABEL_107:
    int64_t v78 = _StringGuts.nativeUnusedCapacity.getter(v7, v11);
    BOOL v80 = (v79 & 1) != 0 || v78 < (uint64_t)v15;
    BOOL v81 = !v80;
    if ((v75 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v10 = v74;
      uint64_t v5 = v180;
      if (v81) {
        goto LABEL_145;
      }
    }
    else
    {
      uint64_t v10 = v74;
      uint64_t v5 = v180;
      if (v81) {
        goto LABEL_144;
      }
    }
    uint64_t v104 = _StringGuts.nativeCapacity.getter(v7, v11);
    uint64_t v106 = (v105 & 1) != 0 ? 0 : v104;
    if (v106 + 0x4000000000000000 >= 0) {
      break;
    }
    __break(1u);
  }
  uint64_t v107 = 2 * v106;
  if (v107 > v73) {
    Swift::Int v73 = v107;
  }
LABEL_144:
  _StringGuts.grow(_:)(v73);
LABEL_145:
  swift_bridgeObjectRelease_n(v4, 4);
  if ((v4 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v4);
    _StringGuts._foreignAppendInPlace(_:)(v5, v4, 0, v10);
  }
  else
  {
    if (v13)
    {
      swift_bridgeObjectRelease_n(v4, 2);
      *(void *)&long long v181 = v5;
      *((void *)&v181 + 1) = v4 & 0xFFFFFFFFFFFFFFLL;
      Swift::Int v108 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v4) & 0xF, (uint64_t)&v181, HIBYTE(v4) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v108, v109, (v4 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v4);
      goto LABEL_171;
    }
    if ((v5 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v4);
      id v124 = (id)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v125 = v179;
      uint64_t v126 = v179;
    }
    else
    {
      id v124 = _StringObject.sharedUTF8.getter(v5, v4);
      uint64_t v126 = v171;
      swift_bridgeObjectRelease(v4);
      if (v126 < v179) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
      }
      uint64_t v125 = v179;
      uint64_t v5 = v180;
    }
    uint64_t v127 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v125, (uint64_t)v124, v126);
    _StringGuts.appendInPlace(_:isASCII:)(v127, v128, v5 < 0);
  }
  swift_bridgeObjectRelease_n(v4, 2);
  while (1)
  {
LABEL_171:
    uint64_t v11 = v182;
    unint64_t v4 = v183;
    uint64_t v5 = HIBYTE(v183) & 0xF;
    if ((v183 & 0x2000000000000000) != 0) {
      unint64_t v130 = HIBYTE(v183) & 0xF;
    }
    else {
      unint64_t v130 = v182 & 0xFFFFFFFFFFFFLL;
    }
    if (!v130 && (v182 & ~v183 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v183);
      return 41;
    }
    if ((v183 & 0x2000000000000000) != 0 && v5 != 15) {
      break;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v4 & 0x1000000000000000) != 0)
    {
LABEL_214:
      Swift::Int v163 = String.UTF8View._foreignCount()();
      uint64_t v7 = v163 + 1;
      if (!__OFADD__(v163, 1))
      {
LABEL_183:
        if ((v11 & ~v4 & 0x2000000000000000) == 0
          || !swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v7 <= 15) {
            goto LABEL_194;
          }
          goto LABEL_199;
        }
        int64_t v131 = _StringGuts.nativeUnusedCapacity.getter(v11, v4);
        if ((v132 & 1) == 0)
        {
          BOOL v134 = (v4 & 0x2000000000000000) == 0 && v131 > 0;
          if (v7 <= 15 && !v134)
          {
LABEL_194:
            swift_bridgeObjectRelease_n(0xE100000000000000, 5);
            swift_bridgeObjectRetain(v4);
            unint64_t v135 = _StringGuts._convertedToSmall()(v11, v4);
            unint64_t v137 = v136;
            swift_bridgeObjectRelease(v4);
            v138._Swift::UInt64 rawBits = 1;
            v139._Swift::UInt64 rawBits = 65537;
            v140._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v138, v139, 0x29uLL, 0xE100000000000000);
            if (v140._rawBits < 0x10000) {
              v140._rawBits |= 3;
            }
            unint64_t v142 = specialized String.init(_:)(v140, v141, 0x29uLL, 0xE100000000000000);
            unint64_t v144 = v143;
            swift_bridgeObjectRelease(0xE100000000000000);
            unint64_t v145 = _StringGuts._convertedToSmall()(v142, v144);
            unint64_t v147 = v146;
            swift_bridgeObjectRelease(v144);
            unint64_t v148 = specialized _SmallString.init(_:appending:)(v135, v137, v145, v147);
            if ((v149 & 1) == 0)
            {
              uint64_t v11 = v148;
              swift_bridgeObjectRelease(v4);
              swift_bridgeObjectRelease(0xE100000000000000);
              return v11;
            }
LABEL_235:
            unint64_t v172 = 266;
LABEL_237:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v172, 0);
          }
LABEL_199:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v7, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v181 = xmmword_18162ADC0;
          unint64_t v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v181, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v150, v151, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v182;
        }
LABEL_236:
        unint64_t v172 = 258;
        goto LABEL_237;
      }
    }
    else
    {
      BOOL v17 = __OFADD__(v130, 1);
      uint64_t v7 = v130 + 1;
      if (!v17) {
        goto LABEL_183;
      }
    }
    __break(1u);
LABEL_217:
    if ((v5 & 0x1000000000000000) != 0)
    {
      uint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, v5);
      uint64_t v174 = v173;
      swift_bridgeObjectRelease(v5);
      uint64_t v5 = v174;
    }
    else
    {
      if ((v10 & 0x1000000000000000) != 0)
      {
        unint64_t v164 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v165 = v10 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        unint64_t v164 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v5);
      }
      closure #1 in _StringGuts._convertedToSmall()(v164, v165, &v181);
      swift_bridgeObjectRelease(v5);
      uint64_t v5 = *((void *)&v181 + 1);
      uint64_t v10 = v181;
    }
LABEL_124:
    uint64_t v88 = HIBYTE(v2) & 0xF;
    uint64_t v89 = HIBYTE(v5) & 0xF;
    uint64_t v90 = v89 + v88;
    if ((unint64_t)(v89 + v88) > 0xF) {
      goto LABEL_235;
    }
    if (v89)
    {
      char v91 = 0;
      unint64_t v92 = 0;
      do
      {
        unint64_t v93 = v88 + v92;
        unint64_t v94 = v92 + 1;
        if (v92 >= 8) {
          unint64_t v95 = v5;
        }
        else {
          unint64_t v95 = v10;
        }
        unint64_t v96 = v95 >> (v91 & 0x38);
        char v97 = (8 * v88 + v91) & 0x38;
        uint64_t v98 = (-255 << v97) - 1;
        unint64_t v99 = (unint64_t)v96 << v97;
        unint64_t v100 = v99 | v98 & v2;
        unint64_t v101 = v99 | v98 & v7;
        if (v93 < 8) {
          uint64_t v7 = v101;
        }
        else {
          unint64_t v2 = v100;
        }
        v91 += 8;
        unint64_t v92 = v94;
      }
      while (v89 != v94);
    }
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(v4);
    unint64_t v102 = 0xA000000000000000;
    if (!(v7 & 0x8080808080808080 | v2 & 0x80808080808080)) {
      unint64_t v102 = 0xE000000000000000;
    }
    unint64_t v103 = v102 & 0xFF00000000000000 | (v90 << 56) | v2 & 0xFFFFFFFFFFFFFFLL;
LABEL_170:
    unint64_t v182 = v7;
    unint64_t v183 = v103;
  }
  if ((unint64_t)v5 < 8) {
    uint64_t v11 = (41 << (8 * (HIBYTE(v183) & 7u))) | ((-255 << (8 * (HIBYTE(v183) & 7u))) - 1) & v182;
  }
  swift_bridgeObjectRelease(v183);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v11;
}

uint64_t CollectionOfOne.customMirror.getter@<X0>(swift *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *((void *)a1 - 1);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v28 = (unint64_t *)((char *)&v29[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v29[-1] - v9;
  (*(void (**)(char *, uint64_t, swift *))(v6 + 16))((char *)&v29[-1] - v9, v3, a1);
  uint64_t v11 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  uint64_t v12 = swift_allocObject(v11, 0x50uLL, 7uLL);
  *((_OWORD *)v12 + 1) = xmmword_18162AC80;
  v12[4] = 0x746E656D656C65;
  v12[5] = 0xE700000000000000;
  uint64_t v13 = *((void *)a1 + 2);
  v12[9] = v13;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 6);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 16))(boxed_opaque_existential_0Tm, v3, v13);
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v15 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v10, (uint64_t)v29, a1);
  uint64_t v17 = v16;
  Swift::Int v18 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v19 = swift_allocObject(v18, 0x48uLL, 7uLL);
  v19[6] = v12;
  v19[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v19[8] = 0;
  int64_t v20 = (unint64_t *)canonical specialized generic type metadata accessor for _IndexBox<Int>();
  char v21 = swift_allocObject(v20, 0x18uLL, 7uLL);
  void v21[2] = 0;
  uint64_t v22 = v12[2];
  char v23 = swift_allocObject(v20, 0x18uLL, 7uLL);
  void v23[2] = v22;
  v19[2] = v21;
  v19[3] = &protocol witness table for _IndexBox<A>;
  v19[4] = v23;
  v19[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v24 = v28;
  (*(void (**)(unint64_t *, char *, swift *))(v6 + 32))(v28, v10, a1);
  BOOL v25 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v29, v24, (Class *)a1, v25, 6uLL);
  char v27 = result;
  if (result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v29);
  }
  *(void *)a2 = a1;
  *(void *)(a2 + 8) = v19;
  *(unsigned char *)(a2 + 16) = 8;
  *(void *)(a2 + 24) = v15;
  *(void *)(a2 + 32) = v17;
  *(unsigned char *)(a2 + 40) = v27;
  return result;
}

Swift::Int CollectionDifference._fastEnumeratedApply(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = v4;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v8, a3, a4);
  uint64_t v82 = *(v9 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  uint64_t v12 = (unsigned __int8 *)&v60 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  char v65 = (char *)&v60 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v64 = (char *)&v60 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v67 = (char **)((char *)&v60 - v18);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v66 = (char *)&v60 - v20;
  uint64_t v61 = v21;
  MEMORY[0x1F4188790](v19);
  uint64_t v75 = (char *)&v60 - v22;
  uint64_t v24 = *v6;
  uint64_t v23 = v6[1];
  Swift::Int v77 = Array._getCount()();
  Swift::Int result = Array._getCount()();
  Swift::Int v76 = result;
  int64_t v26 = 0;
  int64_t v27 = 0;
  uint64_t v73 = v23;
  unint64_t v74 = v24 & 0xC000000000000001;
  unint64_t v71 = v23 & 0xC000000000000001;
  BOOL v80 = (void (**)(unsigned __int8 *, uint64_t, uint64_t *))(v82 + 32);
  BOOL v81 = (void (**)(char *, char **, uint64_t *))(v82 + 16);
  uint64_t v78 = v8 - 8;
  uint64_t v79 = v24;
  uint64_t v62 = v12;
  uint64_t v63 = a1;
  while (1)
  {
    if (v27 >= v77)
    {
      if (v26 >= v76) {
        return result;
      }
      uint64_t v50 = v24;
      BOOL v51 = v74 == 0;
      char v52 = v51 | ~_swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v52 & 1);
      if (v52)
      {
        uint64_t v49 = (uint64_t)v75;
        (*(void (**)(char *, unint64_t, uint64_t *))(v82 + 16))(v75, v50+ ((*(unsigned __int8 *)(v82 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v82 + 80))+ *(void *)(v82 + 72) * v26, v9);
        goto LABEL_18;
      }
      unint64_t v54 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v26, v50, v9);
      uint64_t v23 = (uint64_t)v54;
      if (v61 != 8) {
        goto LABEL_47;
      }
      Swift::String::Index v83 = v54;
      uint64_t v49 = (uint64_t)v75;
      (*v81)(v75, &v83, v9);
LABEL_38:
      swift_unknownObjectRelease((id)v23);
      goto LABEL_18;
    }
    BOOL v30 = v71 == 0;
    BOOL v31 = !_swift_isClassOrObjCExistentialType((uint64_t)v9, v9) || v30;
    Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v31);
    if (v26 >= v76)
    {
      if (v31)
      {
        uint64_t v49 = (uint64_t)v75;
        (*(void (**)(char *, unint64_t, uint64_t *))(v82 + 16))(v75, v23+ ((*(unsigned __int8 *)(v82 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v82 + 80))+ *(void *)(v82 + 72) * v27, v9);
      }
      else
      {
        unint64_t v57 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v23, v9);
        if (v61 != 8) {
          goto LABEL_48;
        }
        Swift::String::Index v83 = v57;
        unint64_t v58 = *v81;
        uint64_t v49 = (uint64_t)v75;
        unint64_t v72 = (void (*)(char *, char **, uint64_t *))v57;
        v58(v75, &v83, v9);
        swift_unknownObjectRelease(v72);
      }
    }
    else
    {
      if (v31)
      {
        unint64_t v32 = v23
            + ((*(unsigned __int8 *)(v82 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v82 + 80))
            + *(void *)(v82 + 72) * v27;
        uint64_t v33 = v66;
        unint64_t v72 = *(void (**)(char *, char **, uint64_t *))(v82 + 16);
        v72(v66, (char **)v32, v9);
      }
      else
      {
        unint64_t v55 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v23, v9);
        uint64_t v23 = (uint64_t)v55;
        if (v61 != 8) {
          goto LABEL_47;
        }
        Swift::String::Index v83 = v55;
        uint64_t v33 = v66;
        unint64_t v72 = *v81;
        v72(v66, &v83, v9);
        swift_unknownObjectRelease((id)v23);
      }
      BOOL v34 = v74 == 0;
      unint64_t v35 = v67;
      unint64_t v69 = *v80;
      v69((unsigned __int8 *)v67, (uint64_t)v33, v9);
      unint64_t v70 = *v35;
      unint64_t v36 = (char *)v35
          + *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v8, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0)+ 12);
      Swift::String::Index v37 = *(void (**)(char *, uint64_t))(*(void *)(v8 - 8) + 8);
      v37(v36, v8);
      char v38 = v34 | ~_swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
      uint64_t v39 = v79;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v38 & 1);
      unint64_t v68 = v37;
      if (v38)
      {
        Swift::String::Index v40 = v64;
        v72(v64, (char **)(v39+ ((*(unsigned __int8 *)(v82 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v82 + 80))+ *(void *)(v82 + 72) * v26), v9);
      }
      else
      {
        unint64_t v56 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v26, v39, v9);
        uint64_t v23 = (uint64_t)v56;
        if (v61 != 8) {
          goto LABEL_47;
        }
        Swift::String::Index v83 = v56;
        Swift::String::Index v40 = v64;
        v72(v64, &v83, v9);
        swift_unknownObjectRelease((id)v23);
      }
      uint64_t v23 = v73;
      unint64_t v41 = (uint64_t *)v65;
      v69((unsigned __int8 *)v65, (uint64_t)v40, v9);
      uint64_t v42 = *v41;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v8, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
      v68((char *)v41 + *((int *)TupleTypeMetadata3 + 12), v8);
      uint64_t v44 = &v70[-v27];
      if (__OFSUB__(v70, v27)) {
        goto LABEL_45;
      }
      BOOL v28 = __OFSUB__(v42, v26);
      uint64_t v45 = v42 - v26;
      if (v28) {
        goto LABEL_46;
      }
      BOOL v46 = !_swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
      if (v45 < (uint64_t)v44)
      {
        BOOL v47 = v46 || v74 == 0;
        uint64_t v48 = v79;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v46 || v74 == 0);
        uint64_t v12 = v62;
        if (v47)
        {
          uint64_t v49 = (uint64_t)v75;
          v72(v75, (char **)(v48+ ((*(unsigned __int8 *)(v82 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v82 + 80))+ *(void *)(v82 + 72) * v26), v9);
LABEL_18:
          uint64_t v23 = v73;
          goto LABEL_23;
        }
        char v59 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v26, v48, v9);
        uint64_t v23 = (uint64_t)v59;
        if (v61 != 8) {
          goto LABEL_47;
        }
        Swift::String::Index v83 = v59;
        uint64_t v49 = (uint64_t)v75;
        v72(v75, &v83, v9);
        goto LABEL_38;
      }
      BOOL v53 = v46 || v71 == 0;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v46 || v71 == 0);
      uint64_t v12 = v62;
      if (v53)
      {
        uint64_t v49 = (uint64_t)v75;
        v72(v75, (char **)(v23+ ((*(unsigned __int8 *)(v82 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v82 + 80))+ *(void *)(v82 + 72) * v27), v9);
      }
      else
      {
        unint64_t v57 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v23, v9);
        if (v61 != 8) {
          goto LABEL_48;
        }
        Swift::String::Index v83 = v57;
        uint64_t v49 = (uint64_t)v75;
        unint64_t v70 = v57;
        v72(v75, &v83, v9);
        swift_unknownObjectRelease(v70);
      }
    }
LABEL_23:
    partial apply for closure #1 in RangeReplaceableCollection.applying(_:)(v49);
    if (v5) {
      return (*(uint64_t (**)(uint64_t, uint64_t *))(v82 + 8))(v49, v9);
    }
    (*v80)(v12, v49, v9);
    if (swift_getEnumCaseMultiPayload(v12, (uint64_t)v9) == 1)
    {
      BOOL v28 = __OFADD__(v27++, 1);
      uint64_t v24 = v79;
      if (v28) {
        goto LABEL_44;
      }
    }
    else
    {
      BOOL v28 = __OFADD__(v26++, 1);
      uint64_t v24 = v79;
      if (v28)
      {
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        unint64_t v57 = (char *)v23;
LABEL_48:
        swift_unknownObjectRelease(v57);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
    }
    uint64_t v29 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v8, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
    Swift::Int result = (*(uint64_t (**)(unsigned __int8 *, uint64_t))(*(void *)(v8 - 8) + 8))(&v12[*((int *)v29 + 12)], v8);
  }
}

uint64_t protocol witness for Error._domain.getter in conformance _ApplicationError(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError(a1, a2, &demangling cache variable for type metadata for _ApplicationError.Type);
}

uint64_t RangeReplaceableCollection.applying(_:)@<X0>(long long *a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v120 = a4;
  unint64_t v121 = a1;
  uint64_t v8 = *((void *)a3 + 1);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v10 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v107 = (char *)&v91 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v91 - v12;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v106 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v105 = (uint64_t)*(v106 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v106);
  unint64_t v115 = (char *)&v91 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  unint64_t v103 = (char *)&v91 - v17;
  uint64_t v104 = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1F4188790](v104);
  unint64_t v101 = (char *)&v91 - v18;
  uint64_t v118 = AssociatedConformanceWitness;
  unint64_t v113 = type metadata accessor for PartialRangeFrom(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v19);
  uint64_t v112 = (uint64_t)*(v113 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v113);
  unint64_t v111 = (char *)&v91 - v21;
  uint64_t v122 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  size_t v109 = (char *)&v91 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  Swift::Int v108 = (char *)&v91 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  char v110 = (char *)&v91 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  char v117 = (char *)&v91 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  unint64_t v114 = (char *)&v91 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  BOOL v34 = (char *)&v91 - v33;
  uint64_t v35 = MEMORY[0x1F4188790](v32);
  Swift::String::Index v37 = (char *)&v91 - v36;
  uint64_t v38 = MEMORY[0x1F4188790](v35);
  Swift::String::Index v40 = (char *)&v91 - v39;
  uint64_t v119 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v38);
  uint64_t v42 = (char *)&v91 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*((void (**)(uint64_t, long long *))a3 + 3))(a2, a3);
  uint64_t v134 = 0;
  uint64_t v135 = 0;
  uint64_t v133 = 0;
  (*(void (**)(uint64_t, uint64_t))(v8 + 64))(a2, v8);
  long long v132 = *v121;
  uint64_t v124 = a2;
  uint64_t v125 = a3;
  unint64_t v121 = a3;
  uint64_t v126 = &v133;
  uint64_t v127 = v42;
  uint64_t v43 = v42;
  uint64_t v128 = v5;
  unint64_t v129 = v40;
  unint64_t v130 = &v135;
  int64_t v131 = &v134;
  uint64_t v44 = swift_getAssociatedTypeWitness(255, *(int ***)(v8 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  BOOL v47 = type metadata accessor for CollectionDifference(0, (uint64_t)v44, v45, v46);
  CollectionDifference._fastEnumeratedApply(_:)((uint64_t)v123, (uint64_t)v47, v48, v49);
  uint64_t v98 = v34;
  uint64_t v50 = *(void (**)(uint64_t, uint64_t))(v8 + 72);
  uint64_t v99 = v5;
  uint64_t v100 = v8;
  char v97 = v50;
  v50(a2, v8);
  LOBYTE(AssociatedConformanceWitness) = (*(uint64_t (**)(char *, char *, const char *))(v118 + 16))(v40, v37, AssociatedTypeWitness);
  BOOL v51 = v122 + 1;
  char v52 = (void (*)(char *, const char *))v122[1];
  v52(v37, AssociatedTypeWitness);
  if (AssociatedConformanceWitness)
  {
    char v91 = v42;
    BOOL v53 = v122 + 2;
    unint64_t v54 = (void (*)(char *, char *, const char *))v122[2];
    unint64_t v55 = v98;
    unint64_t v92 = v40;
    v54(v98, v40, AssociatedTypeWitness);
    unint64_t v56 = v114;
    unint64_t v96 = v53;
    unint64_t v95 = v54;
    v54(v114, v55, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, const char *))(*(void *)(v118 + 8) + 8))(v56, v56, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range cannot have an unordered lower bound.", 43, 2, "Swift/Range.swift", 17, 2, 0x34FuLL, 0); {
    v52(v56, AssociatedTypeWitness);
    }
    unint64_t v57 = (char *)v122[4];
    unint64_t v94 = v51;
    unint64_t v58 = v111;
    v122 += 4;
    unint64_t v114 = v57;
    ((void (*)(char *, char *, const char *))v57)(v111, v55, AssociatedTypeWitness);
    char v59 = v117;
    uint64_t v60 = v95;
    v95(v117, v58, AssociatedTypeWitness);
    unint64_t v93 = v52;
    uint64_t v61 = v110;
    v97(a2, v100);
    uint64_t v62 = v108;
    v60(v108, v59, AssociatedTypeWitness);
    uint64_t v63 = v109;
    v60(v109, v61, AssociatedTypeWitness);
    char v64 = (*(uint64_t (**)(char *, char *, const char *))(v118 + 24))(v62, v63, AssociatedTypeWitness);
    char v65 = v113;
    uint64_t v66 = v112;
    if ((v64 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    unint64_t v67 = v63;
    unint64_t v68 = v93;
    v93(v67, AssociatedTypeWitness);
    v68(v62, AssociatedTypeWitness);
    (*(void (**)(char *, Class *))(v66 + 8))(v58, v65);
    unint64_t v69 = TupleTypeMetadata2;
    unint64_t v70 = v102;
    unint64_t v71 = &v102[*((int *)TupleTypeMetadata2 + 12)];
    unint64_t v72 = (void (*)(char *, char *, const char *))v114;
    ((void (*)(char *, char *, const char *))v114)(v102, v117, AssociatedTypeWitness);
    uint64_t v118 = (uint64_t)v71;
    v72(v71, v61, AssociatedTypeWitness);
    uint64_t v73 = v107;
    unint64_t v74 = &v107[*((int *)v69 + 12)];
    uint64_t v75 = v95;
    v95(v107, v70, AssociatedTypeWitness);
    v75(v74, v71, AssociatedTypeWitness);
    v72(v115, v73, AssociatedTypeWitness);
    Swift::Int v76 = v93;
    v93(v74, AssociatedTypeWitness);
    Swift::Int v77 = &v73[*((int *)TupleTypeMetadata2 + 12)];
    v72(v73, v70, AssociatedTypeWitness);
    v72(v77, (char *)v118, AssociatedTypeWitness);
    uint64_t v78 = v106;
    uint64_t v79 = v115;
    v72(&v115[*((int *)v106 + 9)], v77, AssociatedTypeWitness);
    v76(v73, AssociatedTypeWitness);
    uint64_t v80 = v105;
    BOOL v81 = v103;
    (*(void (**)(char *, char *, Class *))(v105 + 32))(v103, v79, v78);
    uint64_t v82 = v100;
    Swift::String::Index v83 = v101;
    (*(void (**)(char *, uint64_t, uint64_t))(v100 + 88))(v81, a2, v100);
    (*(void (**)(char *, Class *))(v80 + 8))(v81, v78);
    unint64_t v84 = v121;
    Swift::String::Index v85 = (void (*)(char *, const char *, void, uint64_t, long long *))*((void *)v121 + 9);
    Swift::String::Index v86 = v104;
    uint64_t v87 = swift_getAssociatedConformanceWitness(v82, a2, (uint64_t)v104, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v43 = v91;
    v85(v83, v86, *(void *)(v87 + 8), a2, v84);
    char v52 = v76;
    Swift::String::Index v40 = v92;
  }
  v52(v40, AssociatedTypeWitness);
  uint64_t v89 = v119;
  uint64_t v88 = v120;
  (*(void (**)(uint64_t, char *, uint64_t))(v119 + 16))(v120, v43, a2);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v89 + 56))(v88, 0, 1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(v89 + 8))(v43, a2);
}

uint64_t append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v77 = a6;
  uint64_t v86 = a4;
  uint64_t v88 = a2;
  uint64_t v76 = a1;
  uint64_t v8 = *(void *)(a6 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v73 = (char *)&v66 - v9;
  uint64_t v10 = swift_getAssociatedTypeWitness(255, (int **)v8, a5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v10, (uint64_t)v10, "lower upper ", 0);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v72 = (char *)&v66 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  unint64_t v69 = (char *)&v66 - v13;
  uint64_t AssociatedConformanceWitness = (uint64_t (**)(char *, char *, const char *))swift_getAssociatedConformanceWitness(v8, a5, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0, (uint64_t)v10, (uint64_t)AssociatedConformanceWitness, v14);
  uint64_t v70 = (uint64_t)*(v15 - 1);
  unint64_t v71 = v15;
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  unint64_t v68 = (char *)&v66 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  unint64_t v67 = (char *)&v66 - v18;
  uint64_t v21 = type metadata accessor for Optional(0, (uint64_t)v10, v19, v20);
  uint64_t v78 = (uint64_t)*(v21 - 1);
  uint64_t v79 = v21;
  uint64_t v22 = MEMORY[0x1F4188790](v21);
  uint64_t v24 = (char *)&v66 - v23;
  uint64_t v25 = *((void *)v10 - 1);
  uint64_t v26 = MEMORY[0x1F4188790](v22);
  BOOL v81 = (char *)&v66 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v80 = (char *)&v66 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  Swift::String::Index v85 = (char *)&v66 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  BOOL v34 = (char *)&v66 - v33;
  MEMORY[0x1F4188790](v32);
  uint64_t v35 = *(void (**)(void))(v25 + 16);
  uint64_t v87 = (char *)&v66 - v36;
  unint64_t v84 = v35;
  v35();
  (*(void (**)(uint64_t, uint64_t))(v8 + 72))(a5, v8);
  Swift::String::Index v37 = *(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v8 + 144);
  uint64_t v38 = v86;
  uint64_t v86 = a5;
  uint64_t v75 = v8;
  v37(a3, v38, v34, a5, v8);
  uint64_t v39 = *(uint64_t (***)(char *, char *, const char *))(v25 + 8);
  ((void (*)(uint64_t, const char *))v39)(a3, v10);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v25 + 48))(v24, 1, v10) == 1)
  {
    (*(void (**)(char *, Class *))(v78 + 8))(v24, v79);
    (*(void (**)(uint64_t, char *, const char *))(v25 + 32))(a3, v34, v10);
    ((void (*)(char *, const char *))v39)(v87, v10);
    swift_allocError((uint64_t)&unk_1ECA028B8, (uint64_t)&protocol witness table for _ApplicationError, 0, 0);
    return swift_willThrow();
  }
  else
  {
    ((void (*)(char *, const char *))v39)(v34, v10);
    uint64_t v79 = *(Class **)(v25 + 32);
    ((void (*)(uint64_t, char *, const char *))v79)(a3, v24, v10);
    uint64_t v41 = v84;
    uint64_t v42 = v85;
    ((void (*)(char *, uint64_t, const char *))v84)(v85, a3, v10);
    uint64_t v43 = v80;
    ((void (*)(char *, char *, const char *))v41)(v80, v87, v10);
    uint64_t v44 = v81;
    ((void (*)(char *, char *, const char *))v41)(v81, v42, v10);
    if ((AssociatedConformanceWitness[3](v43, v44, v10) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    ((void (*)(char *, const char *))v39)(v44, v10);
    ((void (*)(char *, const char *))v39)(v43, v10);
    uint64_t v45 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v46 = TupleTypeMetadata2;
    BOOL v47 = v69;
    uint64_t AssociatedConformanceWitness = v39;
    uint64_t v48 = &v69[v45];
    uint64_t v49 = v79;
    ((void (*)(char *, char *, const char *))v79)(v69, v87, v10);
    BOOL v81 = v48;
    ((void (*)(char *, char *, const char *))v49)(v48, v85, v10);
    uint64_t v50 = *((int *)v46 + 12);
    BOOL v51 = v72;
    uint64_t v87 = (char *)(v25 + 8);
    char v52 = &v72[v50];
    BOOL v53 = v84;
    ((void (*)(char *, char *, const char *))v84)(v72, v47, v10);
    ((void (*)(char *, char *, const char *))v53)(v52, v48, v10);
    unint64_t v54 = v68;
    ((void (*)(char *, char *, const char *))v49)(v68, v51, v10);
    ((void (*)(char *, const char *))AssociatedConformanceWitness)(v52, v10);
    unint64_t v55 = &v51[*((int *)TupleTypeMetadata2 + 12)];
    ((void (*)(char *, char *, const char *))v49)(v51, v47, v10);
    ((void (*)(char *, char *, const char *))v49)(v55, v81, v10);
    unint64_t v56 = v71;
    ((void (*)(char *, char *, const char *))v49)(&v54[*((int *)v71 + 9)], v55, v10);
    ((void (*)(char *, const char *))AssociatedConformanceWitness)(v51, v10);
    uint64_t v57 = v70;
    unint64_t v58 = v67;
    (*(void (**)(char *, char *, Class *))(v70 + 32))(v67, v54, v56);
    uint64_t v59 = v75;
    uint64_t v60 = v73;
    uint64_t v61 = v86;
    (*(void (**)(char *, uint64_t, uint64_t))(v75 + 88))(v58, v86, v75);
    (*(void (**)(char *, Class *))(v57 + 8))(v58, v56);
    uint64_t v62 = v77;
    uint64_t v63 = *(uint64_t (**)(char *, const char *, void, uint64_t, uint64_t))(v77 + 72);
    char v64 = AssociatedTypeWitness;
    uint64_t v65 = swift_getAssociatedConformanceWitness(v59, v61, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    return v63(v60, v64, *(void *)(v65 + 8), v61, v62);
  }
}

uint64_t *closure #1 in RangeReplaceableCollection.applying(_:)(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(char *, unsigned __int8 *, const char *), unsigned __int8 *a7, uint64_t a8, uint64_t a9)
{
  unint64_t v67 = a7;
  uint64_t v66 = a6;
  uint64_t v72 = a5;
  uint64_t v69 = a3;
  uint64_t v70 = a4;
  uint64_t v12 = *(void *)(a9 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v12 + 8), a8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v15 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v60 = (char *)v59 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (unsigned __int8 *)v59 - v17;
  uint64_t v61 = v12;
  uint64_t v71 = a8;
  uint64_t v19 = swift_getAssociatedTypeWitness(0, (int **)v12, a8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v64 = *((void *)v19 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](v19);
  uint64_t v62 = (char *)v59 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  uint64_t v63 = (char *)v59 - v22;
  uint64_t v25 = type metadata accessor for CollectionDifference.Change(0, (uint64_t)AssociatedTypeWitness, v23, v24);
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = (unsigned __int8 *)v59 - v26;
  (*(void (**)(char *, uint64_t, Class *))(v28 + 16))((char *)v59 - v26, a1, v25);
  LODWORD(a1) = swift_getEnumCaseMultiPayload(v27, (uint64_t)v25);
  uint64_t v29 = *(void *)v27;
  Swift::Int result = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, (uint64_t)AssociatedTypeWitness, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
  uint64_t v31 = &v27[*((int *)result + 12)];
  if (a1 != 1)
  {
    uint64_t v65 = a2;
    uint64_t v45 = *(uint64_t (**)(unsigned __int8 *, unsigned __int8 *, const char *))(v14 + 32);
    Swift::Int result = (uint64_t *)v45(v18, v31, AssociatedTypeWitness);
    uint64_t v46 = v29 + *(void *)v66;
    if (!__OFADD__(v29, *(void *)v66))
    {
      BOOL v47 = __OFSUB__(v46, *(void *)v67);
      uint64_t v48 = v46 - *(void *)v67;
      if (!v47)
      {
        uint64_t v49 = *v65;
        uint64_t v50 = v48 - *v65;
        if (!__OFSUB__(v48, *v65))
        {
          uint64_t v66 = (void (*)(char *, unsigned __int8 *, const char *))v45;
          uint64_t v51 = v71;
          uint64_t v52 = v68;
          append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(v69, v70, v72, v48 - v49, v71, a9);
          if (v52)
          {
            uint64_t v44 = v18;
            return (uint64_t *)(*(uint64_t (**)(unsigned __int8 *, const char *))(v14 + 8))(v44, AssociatedTypeWitness);
          }
          BOOL v53 = v60;
          v66(v60, v18, AssociatedTypeWitness);
          Swift::Int result = (uint64_t *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(a9 + 64))(v53, v51, a9);
          if (!__OFADD__(*v65, v50))
          {
            *v65 += v50;
            if (!__OFADD__(*(void *)v67, 1))
            {
              ++*(void *)v67;
              return result;
            }
            goto LABEL_26;
          }
LABEL_25:
          __break(1u);
LABEL_26:
          __break(1u);
LABEL_27:
          __break(1u);
          goto LABEL_28;
        }
LABEL_24:
        __break(1u);
        goto LABEL_25;
      }
LABEL_23:
      __break(1u);
      goto LABEL_24;
    }
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  uint64_t v32 = v29 - *a2;
  if (__OFSUB__(v29, *a2))
  {
    __break(1u);
    goto LABEL_22;
  }
  unint64_t v67 = &v27[*((int *)result + 12)];
  uint64_t v33 = v72;
  uint64_t v34 = v71;
  uint64_t v35 = v68;
  append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(v69, v70, v72, v32, v71, a9);
  if (v35)
  {
LABEL_6:
    uint64_t v44 = v67;
    return (uint64_t *)(*(uint64_t (**)(unsigned __int8 *, const char *))(v14 + 8))(v44, AssociatedTypeWitness);
  }
  uint64_t v69 = v32;
  v59[1] = 0;
  uint64_t v65 = a2;
  uint64_t v36 = v63;
  uint64_t v37 = v64;
  uint64_t v38 = *(char **)(v64 + 16);
  uint64_t v68 = v64 + 16;
  uint64_t v60 = v38;
  ((void (*)(char *, uint64_t, const char *))v38)(v63, v33, v19);
  uint64_t v39 = v61;
  Swift::String::Index v40 = v62;
  (*(void (**)(uint64_t, uint64_t))(v61 + 72))(v34, v61);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v39, v34, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v42 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v36, v40, v19);
  uint64_t v43 = *(void (**)(char *, const char *))(v37 + 8);
  v43(v40, v19);
  Swift::Int result = (uint64_t *)((uint64_t (*)(char *, const char *))v43)(v36, v19);
  if (v42)
  {
    swift_allocError((uint64_t)&unk_1ECA028B8, (uint64_t)&protocol witness table for _ApplicationError, 0, 0);
    swift_willThrow();
    goto LABEL_6;
  }
  uint64_t v54 = v69 + 1;
  if (__OFADD__(v69, 1)) {
    goto LABEL_27;
  }
  BOOL v47 = __OFADD__(*v65, v54);
  uint64_t v55 = *v65 + v54;
  uint64_t v56 = v72;
  if (v47)
  {
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }
  *uint64_t v65 = v55;
  uint64_t v57 = v62;
  ((void (*)(char *, uint64_t, const char *))v60)(v62, v56, v19);
  unint64_t v58 = v63;
  (*(void (**)(char *, uint64_t, uint64_t))(v39 + 184))(v57, v71, v39);
  v43(v57, v19);
  Swift::Int result = (uint64_t *)(*(uint64_t (**)(uint64_t, char *, const char *))(v64 + 40))(v72, v58, v19);
  if (__OFADD__(*(void *)v66, 1))
  {
LABEL_29:
    __break(1u);
    return result;
  }
  ++*(void *)v66;
  return (uint64_t *)(*(uint64_t (**)(unsigned __int8 *, const char *))(v14 + 8))(v67, AssociatedTypeWitness);
}

uint64_t BidirectionalCollection.difference<A>(from:by:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  void v17[2] = a5;
  v17[3] = a4;
  v17[4] = a7;
  v17[5] = a6;
  v17[7] = a2;
  v17[8] = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(*(void *)(a6 + 8) + 8), a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v15 = type metadata accessor for CollectionDifference(0, (uint64_t)AssociatedTypeWitness, v13, v14);
  return _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)(a1, (void (*)(unint64_t, void))partial apply for closure #1 in _myers<A, B>(from:to:using:), (uint64_t)v17, a5, (uint64_t)v15, *(void *)(a7 + 8), a8);
}

uint64_t BidirectionalCollection<>.difference<A>(from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a4 + 8) + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t v27 = a4;
  uint64_t v28 = a5;
  uint64_t v29 = a6;
  uint64_t v30 = AssociatedTypeWitness;
  v20[2] = a3;
  v20[3] = a2;
  v20[4] = a5;
  v20[5] = a4;
  uint64_t v21 = v7;
  uint64_t v22 = partial apply for implicit closure #1 in BidirectionalCollection<>.difference<A>(from:);
  uint64_t v23 = &v24;
  uint64_t v18 = type metadata accessor for CollectionDifference(0, (uint64_t)AssociatedTypeWitness, v16, v17);
  return _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)(a1, (void (*)(unint64_t, void))partial apply for closure #1 in _myers<A, B>(from:to:using:), (uint64_t)v20, a3, (uint64_t)v18, *(void *)(a5 + 8), a7);
}

__objc2_class **_descent #1 <A, B>(from:to:) in _myers<A, B>(from:to:using:)(uint64_t a1, __objc2_class *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(char *, char *), uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v76 = a6;
  uint64_t v78 = a3;
  uint64_t v79 = a5;
  uint64_t v81 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a8 + 8) + 8), a7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v83 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v77 = (char *)&v57 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v57 - v14;
  uint64_t v69 = a2;
  unint64_t v16 = (unint64_t)a2 + a4;
  if (__OFADD__(a2, a4)) {
    goto LABEL_92;
  }
  uint64_t v8 = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(2);
  uint64_t v8[2] = (__objc2_class *)2;
  v8[4] = 0;
  v8[5] = 0;
  if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v8))
  {
LABEL_93:
    uint64_t v8 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v8);
    if (v8[2]) {
      goto LABEL_4;
    }
LABEL_94:
    unint64_t v55 = 688;
LABEL_85:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, v55, 0);
  }
  if (!v8[2]) {
    goto LABEL_94;
  }
LABEL_4:
  v8[4] = 0;
  if ((v16 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v80 = v83 + 16;
  unint64_t v74 = (__objc2_class *)((char *)v69 - 1);
  uint64_t v75 = (void (**)(char *, const char *))(v83 + 8);
  uint64_t v60 = -a4;
  uint64_t v20 = &_swiftEmptyArrayStorage;
  unint64_t v57 = v16;
  uint64_t v59 = a4;
  while (1)
  {
    unint64_t v16 = v18;
    swift_bridgeObjectRetain((unint64_t)v8);
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v20)) {
      uint64_t v20 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v20[2]->isa + 1, 1, (uint64_t)v20);
    }
    unint64_t v22 = (unint64_t)v20[2];
    unint64_t v21 = (unint64_t)v20[3];
    uint64_t v63 = v20;
    if (v22 >= v21 >> 1) {
      uint64_t v63 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v21 > 1), v22 + 1, 1, (uint64_t)v63);
    }
    uint64_t v23 = v63;
    void v63[2] = (__objc2_class *)(v22 + 1);
    v23[v22 + 4] = (__objc2_class *)v8;
    if (__OFADD__(v19, 1)) {
      goto LABEL_91;
    }
    uint64_t v58 = v19 + 1;
    Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)(v19 + 1));
    uint64_t v25 = (uint64_t)result;
    uint64_t v67 = 0;
    unint64_t v68 = 0;
    unint64_t v26 = -v19;
    uint64_t v70 = v8 + 4;
    uint64_t v65 = v19 - 1;
    unint64_t v66 = -v19;
    uint64_t v27 = -v19;
    unint64_t v28 = v16;
    uint64_t v62 = v8;
    uint64_t v61 = v19;
    while (v27 < v19)
    {
      uint64_t v29 = v27 + 2;
      if (__OFADD__(v27, 2))
      {
        HIDWORD(v67) = 0;
        unint64_t v68 = 0x8000000000000000;
        uint64_t v29 = 0x7FFFFFFFFFFFFFFFLL;
        if (v27 != v26)
        {
          uint64_t v31 = 0x7FFFFFFFFFFFFFFDLL;
LABEL_33:
          unint64_t v33 = v31 - 1;
          goto LABEL_35;
        }
        unint64_t v30 = 0x7FFFFFFFFFFFFFFELL;
        goto LABEL_28;
      }
      if (v27 == v26)
      {
        unint64_t v68 = 0;
        if (v26 >= 0x7FFFFFFFFFFFFFFFLL) {
          unint64_t v30 = ~v27;
        }
        else {
          unint64_t v30 = v26;
        }
        HIDWORD(v67) = 1;
        goto LABEL_28;
      }
      unint64_t v68 = 0;
      uint64_t v31 = v27 - 1;
      HIDWORD(v67) = 1;
      if (v27 - 1 >= 1) {
        goto LABEL_33;
      }
LABEL_34:
      BOOL v34 = __OFSUB__(0, v31);
      unint64_t v33 = -v31;
      if (v34) {
        goto LABEL_90;
      }
LABEL_35:
      if ((v33 & 0x8000000000000000) != 0 || (uint64_t v35 = v8[2], v33 >= (unint64_t)v35))
      {
LABEL_84:
        unint64_t v55 = 675;
        goto LABEL_85;
      }
      uint64_t v36 = v70[v33];
      if (v27 == v19)
      {
        uint64_t v32 = (__objc2_class *)((char *)&v36->isa + 1);
      }
      else
      {
        if ((unint64_t)v27 > 0x7FFFFFFFFFFFFFFELL)
        {
          unint64_t v37 = -(v27 + 1);
          if (__OFSUB__(0, v27 + 1))
          {
            __break(1u);
            return result;
          }
        }
        else
        {
          unint64_t v37 = v27;
        }
        if ((v37 & 0x8000000000000000) != 0 || v37 >= (unint64_t)v35) {
          goto LABEL_84;
        }
        uint64_t v32 = v70[v37];
        if ((uint64_t)v36 >= (uint64_t)v32) {
          uint64_t v32 = (__objc2_class *)((char *)&v36->isa + 1);
        }
      }
LABEL_46:
      uint64_t v38 = (uint64_t)v32 - v27;
      uint64_t v71 = v29;
      if ((uint64_t)v32 >= (uint64_t)v69)
      {
        char v48 = 0;
        if (v27 > 0) {
          goto LABEL_56;
        }
      }
      else if (v38 >= a4)
      {
        char v48 = 1;
        if (v27 > 0) {
          goto LABEL_56;
        }
      }
      else
      {
        uint64_t v82 = -v27;
        uint64_t v64 = v27;
        uint64_t v72 = v60 - v27;
        uint64_t v73 = v32;
        uint64_t v39 = v32;
        while (1)
        {
          if (((unint64_t)v32 & 0x8000000000000000) != 0
            || (uint64_t v40 = *(void *)(v83 + 72),
                uint64_t v41 = *(void (**)(char *, uint64_t, const char *))(v83 + 16),
                v41(v15, v81 + v40 * (void)v39, AssociatedTypeWitness),
                v38 < 0))
          {
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
          }
          char v42 = AssociatedTypeWitness;
          uint64_t v43 = v15;
          uint64_t v44 = v77;
          v41(v77, v78 + v40 * ((void)v39 + v82), v42);
          char v45 = v79(v43, v44);
          uint64_t v46 = *v75;
          BOOL v47 = v44;
          uint64_t v15 = v43;
          uint64_t AssociatedTypeWitness = v42;
          (*v75)(v47, v42);
          v46(v15, v42);
          if ((v45 & 1) == 0)
          {
            uint64_t v27 = v64;
            uint64_t v38 = (uint64_t)v39 - v64;
            char v48 = 1;
            uint64_t v32 = v39;
            uint64_t v8 = v62;
            uint64_t v19 = v61;
            a4 = v59;
            if (v64 >= 1) {
              goto LABEL_56;
            }
            goto LABEL_58;
          }
          if (v74 == v39) {
            break;
          }
          uint64_t v39 = (__objc2_class *)((char *)v39 + 1);
          uint64_t v32 = v73;
          if (!(__objc2_class *)((char *)v39 + v72))
          {
            char v48 = 1;
            a4 = v59;
            uint64_t v38 = v59;
            uint64_t v32 = v39;
            uint64_t v27 = v64;
            BOOL v49 = v64 <= 0;
            goto LABEL_71;
          }
        }
        char v48 = 0;
        uint64_t v27 = v64;
        uint64_t v38 = (uint64_t)&v39->isa - v64 + 1;
        uint64_t v32 = v69;
        BOOL v49 = v64 <= 0;
        a4 = v59;
LABEL_71:
        uint64_t v8 = v62;
        uint64_t v19 = v61;
        if (!v49)
        {
LABEL_56:
          uint64_t v17 = v38;
          uint64_t v50 = v32;
          unint64_t v16 = v27 - 1;
          goto LABEL_60;
        }
      }
LABEL_58:
      unint64_t v16 = -v27;
      if (__OFSUB__(0, v27))
      {
        __break(1u);
LABEL_90:
        __break(1u);
LABEL_91:
        __break(1u);
LABEL_92:
        __break(1u);
        goto LABEL_93;
      }
      uint64_t v17 = v38;
      uint64_t v50 = v32;
LABEL_60:
      Swift::Int result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(v25);
      if (result)
      {
        unint64_t v28 = (unint64_t)v50;
        if ((v16 & 0x8000000000000000) != 0) {
          goto LABEL_94;
        }
      }
      else
      {
        Swift::Int result = specialized _ArrayBuffer._consumeAndCreateNew()(v25);
        uint64_t v25 = (uint64_t)result;
        unint64_t v28 = (unint64_t)v50;
        if ((v16 & 0x8000000000000000) != 0) {
          goto LABEL_94;
        }
      }
      if (v16 >= *(void *)(v25 + 16)) {
        goto LABEL_94;
      }
      *(void *)(v25 + 8 * v16 + 32) = v28;
      if (v17 < a4) {
        char v51 = 1;
      }
      else {
        char v51 = v48;
      }
      uint64_t v27 = v71;
      unint64_t v26 = v66;
      if ((v51 & 1) == 0)
      {
        swift_bridgeObjectRelease(v25);
        uint64_t v56 = (uint64_t)v8;
        goto LABEL_86;
      }
    }
    if (!((v27 != v19) | v67 & 1) && BYTE4(v67) & 1 | (v68 != 0x8000000000000000))
    {
      if (v19)
      {
        LODWORD(v67) = 1;
        uint64_t v29 = v19;
        uint64_t v31 = v65;
        if (v19 > 1) {
          goto LABEL_33;
        }
        goto LABEL_34;
      }
      unint64_t v30 = 0;
      uint64_t v29 = 0;
      LODWORD(v67) = 1;
LABEL_28:
      if ((v30 & 0x8000000000000000) != 0 || v30 >= (unint64_t)v8[2]) {
        goto LABEL_84;
      }
      uint64_t v32 = v70[v30];
      goto LABEL_46;
    }
    int64_t v52 = v28;
    swift_bridgeObjectRelease((uint64_t)v8);
    if (v17 >= a4 && v52 >= (uint64_t)v69) {
      break;
    }
    unint64_t v18 = v52;
    uint64_t v8 = (__objc2_class **)v25;
    BOOL v54 = v19 == v57;
    uint64_t v19 = v58;
    uint64_t v56 = v25;
    uint64_t v20 = v63;
    if (v54) {
      goto LABEL_87;
    }
  }
  uint64_t v56 = v25;
LABEL_86:
  uint64_t v20 = v63;
LABEL_87:
  swift_bridgeObjectRelease(v56);
  return v20;
}

void _formChanges #1 <A, B>(from:to:using:) in _myers<A, B>(from:to:using:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v45 = a2;
  uint64_t v46 = a4;
  uint64_t v43 = a1;
  uint64_t v44 = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(*(void *)(a7 + 8) + 8), a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for CollectionDifference.Change(0, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  uint64_t v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  unint64_t v16 = (char *)&v43 - v15;
  uint64_t v50 = &_swiftEmptyArrayStorage;
  unint64_t v17 = *(void *)(a5 + 16);
  BOOL v49 = type metadata accessor for Array(0, (uint64_t)v11, v18, v19);
  Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(v17, 0);
  if (v17 >= 2)
  {
    BOOL v47 = AssociatedTypeWitness - 8;
    uint64_t v48 = a5 + 24;
    unint64_t v20 = 1 - v17;
    uint64_t v21 = v45;
    uint64_t v22 = v46;
    while (1)
    {
      unint64_t v26 = v17 - 1;
      uint64_t v27 = *(void *)(v48 + 8 * v17);
      unint64_t v28 = v21 - v22;
      if (v20 == v21 - v22) {
        goto LABEL_6;
      }
      uint64_t v29 = v28 - 1;
      if (v26 != v28)
      {
        if (v29 < 1)
        {
          unint64_t v39 = 1 - v28;
          if (__OFSUB__(0, v29)) {
            goto LABEL_45;
          }
        }
        else
        {
          unint64_t v39 = v28 - 2;
        }
        if ((v39 & 0x8000000000000000) != 0) {
          goto LABEL_40;
        }
        unint64_t v40 = *(void *)(v27 + 16);
        if (v39 >= v40) {
          goto LABEL_40;
        }
        uint64_t v41 = *(void *)(v27 + 32 + 8 * v39);
        if (v28 > 0x7FFFFFFFFFFFFFFELL)
        {
          unint64_t v42 = -(uint64_t)(v28 + 1);
          if (__OFSUB__(0, v28 + 1)) {
            goto LABEL_44;
          }
        }
        else
        {
          unint64_t v42 = v21 - v22;
        }
        if ((v42 & 0x8000000000000000) != 0 || v42 >= v40) {
LABEL_40:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        if (v41 < *(void *)(v27 + 32 + 8 * v42)) {
LABEL_6:
        }
          uint64_t v29 = v28 + 1;
      }
      unint64_t v30 = v29 - 1;
      if (v29 < 1)
      {
        unint64_t v30 = -v29;
        if (__OFSUB__(0, v29)) {
          break;
        }
      }
      if ((v30 & 0x8000000000000000) != 0 || v30 >= *(void *)(v27 + 16)) {
        goto LABEL_40;
      }
      uint64_t v31 = *(void *)(v27 + 8 * v30 + 32);
      uint64_t v32 = v31 - v29;
      unint64_t v33 = ~v31 + v29 + v22;
      if (v33 >= v21 + ~v31) {
        unint64_t v33 = v21 + ~v31;
      }
      uint64_t v34 = v22 + ~v33;
      if (v31 < v21 && v32 < v22) {
        uint64_t v36 = v34;
      }
      else {
        uint64_t v36 = v22;
      }
      if (v36 == v32)
      {
        *(void *)uint64_t v14 = v31;
        if (v31 < 0) {
          goto LABEL_41;
        }
        if (v31 >= v45) {
          goto LABEL_42;
        }
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, (uint64_t)AssociatedTypeWitness, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
        uint64_t v38 = &v14[*((int *)TupleTypeMetadata3 + 16)];
        (*(void (**)(char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(&v14[*((int *)TupleTypeMetadata3 + 12)], v43 + *(void *)(*((void *)AssociatedTypeWitness - 1) + 72) * v31, AssociatedTypeWitness);
        *(void *)uint64_t v38 = 0;
        v38[8] = 1;
        swift_storeEnumTagMultiPayload(v14, (uint64_t)v11, 1u);
        uint64_t v25 = (uint64_t)v14;
      }
      else
      {
        *(void *)unint64_t v16 = v32;
        if (v32 < 0) {
LABEL_41:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
        if (v32 >= v46) {
LABEL_42:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
        uint64_t v23 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, (uint64_t)AssociatedTypeWitness, (uint64_t)qword_1ECA01F50, "offset element associatedWith ", 0);
        char v24 = &v16[*((int *)v23 + 16)];
        (*(void (**)(char *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(&v16[*((int *)v23 + 12)], v44 + *(void *)(*((void *)AssociatedTypeWitness - 1) + 72) * v32, AssociatedTypeWitness);
        *(void *)char v24 = 0;
        v24[8] = 1;
        swift_storeEnumTagMultiPayload(v16, (uint64_t)v11, 0);
        uint64_t v25 = (uint64_t)v16;
      }
      Array.append(_:)(v25, (uint64_t)v49);
      ++v20;
      --v17;
      uint64_t v21 = v31;
      uint64_t v22 = v32;
      if (v26 + 1 <= 2) {
        return;
      }
    }
    __break(1u);
LABEL_44:
    __break(1u);
LABEL_45:
    __break(1u);
  }
}

uint64_t _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)@<X0>(uint64_t a1@<X0>, void (*a2)(unint64_t, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v41 = a7;
  uint64_t v43 = a1;
  uint64_t v37 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v36 = (char *)&v33 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v16 = type metadata accessor for Optional(0, v15, v13, v14);
  uint64_t v38 = (uint64_t)*(v16 - 1);
  unint64_t v39 = v16;
  uint64_t v17 = MEMORY[0x1F4188790](v16);
  uint64_t v19 = (char *)&v33 - v18;
  uint64_t v40 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v33 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = *(void *)(a6 + 8);
  uint64_t v23 = a2;
  uint64_t v24 = a3;
  uint64_t v25 = v42;
  uint64_t result = (*(uint64_t (**)(void (*)(unint64_t, void), uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 72))(a2, a3, a5, a4, v22);
  if (!v25)
  {
    uint64_t v28 = v38;
    uint64_t v27 = v39;
    uint64_t v42 = 0;
    uint64_t v34 = v23;
    uint64_t v35 = v24;
    uint64_t v29 = v40;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v40 + 48))(v19, 1, a5) == 1)
    {
      (*(void (**)(char *, Class *))(v28 + 8))(v19, v27);
      (*(void (**)(char *, uint64_t, uint64_t))(v37 + 16))(v36, v43, a4);
      uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v22 + 56))(a4, v22);
      uint64_t v31 = *((void *)swift_getAssociatedTypeWitness(0, (int **)v22, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element)- 1);
      v34(v30 + ((*(unsigned __int8 *)(v31 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v31 + 80)), *(void *)(v30 + 16));
      return swift_release(v30);
    }
    else
    {
      uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v29 + 32);
      v32(v21, v19, a5);
      return ((uint64_t (*)(uint64_t, char *, uint64_t))v32)(v41, v21, a5);
    }
  }
  return result;
}

void closure #1 in _myers<A, B>(from:to:using:)(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, _OWORD *a6@<X8>)
{
  void (*v21)(void *__return_ptr, double (*)@<D0>(uint64_t@<X0>, uint64_t@<X1>, _OWORD *@<X8>), unsigned char *, Class *, uint64_t, uint64_t);
  const char *AssociatedTypeWitness;
  uint64_t v23;
  uint64_t v24;
  Class *v25;
  void *v26;
  uint64_t v27;
  _OWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __objc2_class *v32;
  uint64_t (*v33)(char *, char *);
  uint64_t v34;
  void *v35;
  unsigned char v36[16];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __objc2_class *v42;
  uint64_t (*v43)(char *, char *);
  uint64_t v44;
  void v45[2];
  _OWORD *v46;

  uint64_t v46 = a6;
  uint64_t v30 = *(void *)(a4 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v37 = v13;
  uint64_t v38 = v14;
  unint64_t v39 = v15;
  uint64_t v40 = v16;
  uint64_t v31 = v10;
  uint64_t v32 = v17;
  uint64_t v41 = v10;
  uint64_t v42 = v17;
  uint64_t v33 = v18;
  uint64_t v34 = v19;
  uint64_t v43 = v18;
  uint64_t v44 = v19;
  uint64_t v20 = *(void *)(*(void *)(v16 + 8) + 8);
  uint64_t v21 = *(void (**)(void *__return_ptr, double (*)@<D0>(uint64_t@<X0>, uint64_t@<X1>, _OWORD *@<X8>), unsigned char *, Class *, uint64_t, uint64_t))(v20 + 72);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(*(void *)(v15 + 8) + 8), v13, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v25 = type metadata accessor for CollectionDifference(0, (uint64_t)AssociatedTypeWitness, v23, v24);
  unint64_t v26 = v35;
  v21(v45, partial apply for closure #1 in closure #1 in _myers<A, B>(from:to:using:), v36, v25, a4, v20);
  if (v26)
  {
    swift_errorRelease(v26);
    __break(1u);
  }
  else if (v45[0])
  {
    uint64_t v27 = v45[1];
    uint64_t v28 = v46;
    *(void *)uint64_t v46 = v45[0];
    *((void *)v28 + 1) = v27;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v30 + 16))(v12, a2, a4);
    uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v20 + 56))(a4, v20);
    closure #1 in closure #1 in _myers<A, B>(from:to:using:)(v29+ ((*(unsigned __int8 *)(*((void *)AssociatedTypeWitness - 1) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*((void *)AssociatedTypeWitness - 1) + 80)), *(void *)(v29 + 16), v31, v32, v33, v34, a3, a5, v46);
    swift_release(v29);
  }
}

double closure #1 in closure #1 in _myers<A, B>(from:to:using:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __objc2_class *a4@<X3>, uint64_t (*a5)(char *, char *)@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _OWORD *a9@<X8>)
{
  uint64_t v16 = _descent #1 <A, B>(from:to:) in _myers<A, B>(from:to:using:)(a3, a4, a1, a2, a5, a6, a7, a8);
  _formChanges #1 <A, B>(from:to:using:) in _myers<A, B>(from:to:using:)(a3, (uint64_t)a4, a1, a2, (uint64_t)v16, a7, a8);
  uint64_t v18 = v17;
  swift_bridgeObjectRelease((uint64_t)v16);
  uint64_t v30 = v18;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a8 + 8) + 8), a7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v22 = type metadata accessor for CollectionDifference.Change(255, (uint64_t)AssociatedTypeWitness, v20, v21);
  uint64_t v25 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v22, v23, v24);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v25, v26);
  if ((static CollectionDifference._validateChanges<A>(_:)((uint64_t)&v30, (uint64_t)AssociatedTypeWitness, (uint64_t)v25, WitnessTable) & 1) == 0)
  {
    swift_bridgeObjectRelease(v18);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Diffing.swift", 19, 2, 0x16BuLL, 0);
  }
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)&v30, (uint64_t)AssociatedTypeWitness, (uint64_t)v25, WitnessTable, (__objc2_class ***)&v29);
  double result = *(double *)&v29;
  *a9 = v29;
  return result;
}

uint64_t Duration._low.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Duration._low.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Duration._high.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t (*Duration._high.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Duration __swiftcall Duration.init(secondsComponent:attosecondsComponent:)(Swift::Int64 secondsComponent, Swift::Int64 attosecondsComponent)
{
  Swift::UInt64 v2 = specialized static Duration.+ infix(_:_:)(1000000000000000000 * secondsComponent, ((secondsComponent >> 63) & 0xF21F494C589C0000)+ (((unint64_t)secondsComponent * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64), attosecondsComponent, attosecondsComponent >> 63);
  result._high = v3;
  result._low = v2;
  return result;
}

uint64_t static Duration.seconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v99 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v97 = (char *)&v96 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v100 = (char *)&v96 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v101 = (char *)&v96 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v105 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v104 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  Swift::Int v108 = (char *)&v96 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v96 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v96 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v96 - v26;
  v114[0] = 64;
  uint64_t v28 = *(void (**)(uint64_t, void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v25, v29, v30);
  v28(a1, v114, &type metadata for Int, v31, a2, a3);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v33 = v32(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v111 = v8 + 16;
  uint64_t v112 = v27;
  uint64_t v107 = v34;
  v34(v24, v27, a2);
  uint64_t v103 = a1;
  BOOL v35 = (v33 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v106 = v8;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v8 + 8);
  v36(v24, a2);
  uint64_t v37 = v107;
  v107(v21, v112, a2);
  uint64_t v109 = v8 + 8;
  char v110 = v36;
  unint64_t v102 = v32;
  if (!v35)
  {
    v36(v21, a2);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    goto LABEL_9;
  }
  v114[0] = 0x8000000000000000;
  if ((v32(a2, a3) & 1) == 0)
  {
    char v46 = v32(a2, a3);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v47 = v44(a2, a3);
    if (v46)
    {
      unint64_t v96 = v44;
      if (v47 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v99;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v97;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        uint64_t v62 = v108;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a2, v59);
        LOBYTE(v58) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v62, a2);
        uint64_t v42 = v110;
        v110(v62, a2);
        uint64_t v63 = v100;
        (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v100, v21, a2);
        if (v58)
        {
LABEL_42:
          v42(v63, a2);
          goto LABEL_43;
        }
        uint64_t v64 = v114[0];
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v42(v63, a2);
        BOOL v43 = v65 < v64;
        uint64_t v37 = v107;
        goto LABEL_21;
      }
      uint64_t v50 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v47, v48, v49);
      int64_t v52 = v108;
      v50(v114, &type metadata for Int64, v51, a2, a3);
      char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v52, a2);
      uint64_t v42 = v110;
      v110(v52, a2);
      v42(v21, a2);
      uint64_t v37 = v107;
      goto LABEL_14;
    }
    if (v47 < 64)
    {
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v42 = v110;
      v110(v21, a2);
      uint64_t v37 = v107;
      uint64_t v45 = v105;
      if (v57 >= v114[0]) {
        goto LABEL_22;
      }
LABEL_43:
      v42(v112, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0x71uLL, 0);
    }
    v110(v21, a2);
    uint64_t v37 = v107;
LABEL_9:
    uint64_t v45 = v105;
    goto LABEL_22;
  }
  unint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v38 = v96(a2, a3);
  if (v38 >= 64)
  {
    BOOL v54 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v55 = lazy protocol witness table accessor for type Int64 and conformance Int64(v38, v39, v40);
    uint64_t v56 = v108;
    v54(v114, &type metadata for Int64, v55, a2, a3);
    uint64_t v37 = v107;
    char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v56, a2);
    uint64_t v42 = v110;
    v110(v56, a2);
    v42(v21, a2);
LABEL_14:
    uint64_t v45 = v105;
    uint64_t v44 = v96;
    if ((v53 & 1) == 0) {
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v42 = v110;
  v110(v21, a2);
  BOOL v43 = v41 < v114[0];
LABEL_21:
  uint64_t v45 = v105;
  uint64_t v44 = v96;
  if (v43) {
    goto LABEL_43;
  }
LABEL_22:
  unint64_t v66 = v112;
  uint64_t v67 = v44(a2, a3);
  unint64_t v68 = v104;
  v37(v104, v66, a2);
  if (v67 >= 65)
  {
    v110(v68, a2);
    v37(v45, v112, a2);
    uint64_t v69 = v106;
    goto LABEL_26;
  }
  uint64_t v70 = v44(a2, a3);
  v110(v68, a2);
  uint64_t v69 = v106;
  if (v70 != 64)
  {
    v37(v45, v112, a2);
    goto LABEL_32;
  }
  char v71 = v102(a2, a3);
  v37(v45, v112, a2);
  if (v71)
  {
LABEL_32:
    uint64_t v82 = v45;
    goto LABEL_33;
  }
LABEL_26:
  v114[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v72 = v102(a2, a3);
  uint64_t v73 = v44(a2, a3);
  if (v72)
  {
    if (v73 > 64)
    {
      uint64_t v76 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v77 = lazy protocol witness table accessor for type Int64 and conformance Int64(v73, v74, v75);
      uint64_t v78 = v108;
      v76(v114, &type metadata for Int64, v77, a2, a3);
      char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v78, v45, a2);
      uint64_t v42 = v110;
      v110(v78, a2);
      uint64_t v80 = v45;
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  if (v73 <= 63)
  {
LABEL_30:
    uint64_t v81 = v108;
    (*(void (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v82 = v81;
LABEL_33:
    uint64_t v42 = v110;
    v110(v82, a2);
    goto LABEL_36;
  }
  uint64_t v113 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v83 = v108;
  uint64_t v84 = (*(uint64_t (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
  Swift::String::Index v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v88 = lazy protocol witness table accessor for type Int64 and conformance Int64(v84, v86, v87);
  uint64_t v89 = v101;
  v85(&v113, &type metadata for Int64, v88, a2, a3);
  char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v89, v83, a2);
  uint64_t v42 = v110;
  v110(v89, a2);
  uint64_t v80 = v83;
LABEL_35:
  v42(v80, a2);
  if (v79) {
    goto LABEL_43;
  }
LABEL_36:
  uint64_t v90 = v112;
  char v91 = (void (*)(char *, uint64_t, uint64_t))v37;
  unint64_t v92 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v93 = v92(a2, a3);
  v42(v90, a2);
  uint64_t v63 = v108;
  v91(v108, v103, a2);
  uint64_t v94 = v92(a2, a3);
  v42(v63, a2);
  if ((unsigned __int128)(v93 * (__int128)1000000000000000000) >> 64 != (1000000000000000000 * v93) >> 63)
  {
    __break(1u);
    goto LABEL_41;
  }
  if (__OFADD__(1000000000000000000 * v93, ((unint64_t)v94 * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64))
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  return 1000000000000000000 * v94;
}

uint64_t Duration.components.getter(unint64_t a1, unint64_t a2)
{
  v4.low = 0x73AFF322E62439FDLL;
  v4.high = 0x9392EE8E921D5D0;
  *(_OWORD *)(&v5 - 1) = (unsigned __int128)_Int128.multipliedFullWidth(by:)(v4);
  uint64_t v7 = (__int128)__PAIR128__(v5, v6) >> 55;
  uint64_t v8 = v7 + (a2 >> 63);
  if (__CFADD__(v7, a2 >> 63)) {
    Swift::Int64 v9 = (v5 >> 55) + 1;
  }
  else {
    Swift::Int64 v9 = v5 >> 55;
  }
  v10.low = v7 + (a2 >> 63);
  v10.high = v9;
  *(_OWORD *)&unint64_t v11 = (unsigned __int128)_Int128.multipliedReportingOverflow(by:)(v10);
  unint64_t v13 = v12;
  uint64_t v14 = a1 - v11;
  BOOL v15 = v8 >= 0;
  if (v9 != -1) {
    BOOL v15 = v9 < -1;
  }
  if (v15) {
    goto LABEL_17;
  }
  BOOL v16 = v8 < 0;
  if (v9) {
    BOOL v16 = v9 > 0;
  }
  if (v16) {
LABEL_18:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  uint64_t v17 = (__PAIR128__(a2, a1) - __PAIR128__(v13, v11)) >> 64;
  BOOL v18 = v14 >= 0;
  if (v17 != -1) {
    BOOL v18 = v17 < -1;
  }
  if (v18) {
LABEL_17:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  BOOL v19 = v17 == 0;
  BOOL v20 = v17 > 0;
  if (v19) {
    BOOL v20 = v14 < 0;
  }
  if (v20) {
    goto LABEL_18;
  }
  return v8;
}

double static Double.- infix(_:_:)(double a1, double a2)
{
  return a1 - a2;
}

double Double.init<A>(_:)(char *a1, uint64_t a2, uint64_t (**a3)(void, void))
{
  if (a3[16](a2, a3) <= 64)
  {
    char v7 = a3[8](a2, a3);
    uint64_t v8 = a3[15](a2, a3);
    (*(void (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    if (v7) {
      return (double)v8;
    }
    else {
      return (double)(unint64_t)v8;
    }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    return v9;
  }
}

uint64_t static Duration.seconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0xDE0B6B3A7640000uLL, a1);
}

uint64_t static Duration.milliseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v99 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v97 = (char *)&v96 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v100 = (char *)&v96 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v101 = (char *)&v96 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v105 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v104 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  Swift::Int v108 = (char *)&v96 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v96 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v96 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v96 - v26;
  v114[0] = 64;
  uint64_t v28 = *(void (**)(uint64_t, void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v25, v29, v30);
  v28(a1, v114, &type metadata for Int, v31, a2, a3);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v33 = v32(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v111 = v8 + 16;
  uint64_t v112 = v27;
  uint64_t v107 = v34;
  v34(v24, v27, a2);
  uint64_t v103 = a1;
  BOOL v35 = (v33 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v106 = v8;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v8 + 8);
  v36(v24, a2);
  uint64_t v37 = v107;
  v107(v21, v112, a2);
  uint64_t v109 = v8 + 8;
  char v110 = v36;
  unint64_t v102 = v32;
  if (!v35)
  {
    v36(v21, a2);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    goto LABEL_9;
  }
  v114[0] = 0x8000000000000000;
  if ((v32(a2, a3) & 1) == 0)
  {
    char v46 = v32(a2, a3);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v47 = v44(a2, a3);
    if (v46)
    {
      unint64_t v96 = v44;
      if (v47 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v99;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v97;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        uint64_t v62 = v108;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a2, v59);
        LOBYTE(v58) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v62, a2);
        uint64_t v42 = v110;
        v110(v62, a2);
        uint64_t v63 = v100;
        (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v100, v21, a2);
        if (v58)
        {
LABEL_42:
          v42(v63, a2);
          goto LABEL_43;
        }
        uint64_t v64 = v114[0];
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v42(v63, a2);
        BOOL v43 = v65 < v64;
        uint64_t v37 = v107;
        goto LABEL_21;
      }
      uint64_t v50 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v47, v48, v49);
      int64_t v52 = v108;
      v50(v114, &type metadata for Int64, v51, a2, a3);
      char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v52, a2);
      uint64_t v42 = v110;
      v110(v52, a2);
      v42(v21, a2);
      uint64_t v37 = v107;
      goto LABEL_14;
    }
    if (v47 < 64)
    {
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v42 = v110;
      v110(v21, a2);
      uint64_t v37 = v107;
      uint64_t v45 = v105;
      if (v57 >= v114[0]) {
        goto LABEL_22;
      }
LABEL_43:
      v42(v112, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0x9FuLL, 0);
    }
    v110(v21, a2);
    uint64_t v37 = v107;
LABEL_9:
    uint64_t v45 = v105;
    goto LABEL_22;
  }
  unint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v38 = v96(a2, a3);
  if (v38 >= 64)
  {
    BOOL v54 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v55 = lazy protocol witness table accessor for type Int64 and conformance Int64(v38, v39, v40);
    uint64_t v56 = v108;
    v54(v114, &type metadata for Int64, v55, a2, a3);
    uint64_t v37 = v107;
    char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v56, a2);
    uint64_t v42 = v110;
    v110(v56, a2);
    v42(v21, a2);
LABEL_14:
    uint64_t v45 = v105;
    uint64_t v44 = v96;
    if ((v53 & 1) == 0) {
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v42 = v110;
  v110(v21, a2);
  BOOL v43 = v41 < v114[0];
LABEL_21:
  uint64_t v45 = v105;
  uint64_t v44 = v96;
  if (v43) {
    goto LABEL_43;
  }
LABEL_22:
  unint64_t v66 = v112;
  uint64_t v67 = v44(a2, a3);
  unint64_t v68 = v104;
  v37(v104, v66, a2);
  if (v67 >= 65)
  {
    v110(v68, a2);
    v37(v45, v112, a2);
    uint64_t v69 = v106;
    goto LABEL_26;
  }
  uint64_t v70 = v44(a2, a3);
  v110(v68, a2);
  uint64_t v69 = v106;
  if (v70 != 64)
  {
    v37(v45, v112, a2);
    goto LABEL_32;
  }
  char v71 = v102(a2, a3);
  v37(v45, v112, a2);
  if (v71)
  {
LABEL_32:
    uint64_t v82 = v45;
    goto LABEL_33;
  }
LABEL_26:
  v114[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v72 = v102(a2, a3);
  uint64_t v73 = v44(a2, a3);
  if (v72)
  {
    if (v73 > 64)
    {
      uint64_t v76 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v77 = lazy protocol witness table accessor for type Int64 and conformance Int64(v73, v74, v75);
      uint64_t v78 = v108;
      v76(v114, &type metadata for Int64, v77, a2, a3);
      char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v78, v45, a2);
      uint64_t v42 = v110;
      v110(v78, a2);
      uint64_t v80 = v45;
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  if (v73 <= 63)
  {
LABEL_30:
    uint64_t v81 = v108;
    (*(void (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v82 = v81;
LABEL_33:
    uint64_t v42 = v110;
    v110(v82, a2);
    goto LABEL_36;
  }
  uint64_t v113 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v83 = v108;
  uint64_t v84 = (*(uint64_t (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
  Swift::String::Index v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v88 = lazy protocol witness table accessor for type Int64 and conformance Int64(v84, v86, v87);
  uint64_t v89 = v101;
  v85(&v113, &type metadata for Int64, v88, a2, a3);
  char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v89, v83, a2);
  uint64_t v42 = v110;
  v110(v89, a2);
  uint64_t v80 = v83;
LABEL_35:
  v42(v80, a2);
  if (v79) {
    goto LABEL_43;
  }
LABEL_36:
  uint64_t v90 = v112;
  char v91 = (void (*)(char *, uint64_t, uint64_t))v37;
  unint64_t v92 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v93 = v92(a2, a3);
  v42(v90, a2);
  uint64_t v63 = v108;
  v91(v108, v103, a2);
  uint64_t v94 = v92(a2, a3);
  v42(v63, a2);
  if ((unsigned __int128)(v93 * (__int128)1000000000000000) >> 64 != (1000000000000000 * v93) >> 63)
  {
    __break(1u);
    goto LABEL_41;
  }
  if (__OFADD__(1000000000000000 * v93, ((unint64_t)v94 * (unsigned __int128)0x38D7EA4C68000uLL) >> 64))
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  return 1000000000000000 * v94;
}

uint64_t static Duration.milliseconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0x38D7EA4C68000uLL, a1);
}

uint64_t static Duration.microseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v99 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v97 = (char *)&v96 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v100 = (char *)&v96 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v101 = (char *)&v96 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v105 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v104 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  Swift::Int v108 = (char *)&v96 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v96 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v96 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v96 - v26;
  v114[0] = 64;
  uint64_t v28 = *(void (**)(uint64_t, void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v25, v29, v30);
  v28(a1, v114, &type metadata for Int, v31, a2, a3);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v33 = v32(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v111 = v8 + 16;
  uint64_t v112 = v27;
  uint64_t v107 = v34;
  v34(v24, v27, a2);
  uint64_t v103 = a1;
  BOOL v35 = (v33 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v106 = v8;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v8 + 8);
  v36(v24, a2);
  uint64_t v37 = v107;
  v107(v21, v112, a2);
  uint64_t v109 = v8 + 8;
  char v110 = v36;
  unint64_t v102 = v32;
  if (!v35)
  {
    v36(v21, a2);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    goto LABEL_9;
  }
  v114[0] = 0x8000000000000000;
  if ((v32(a2, a3) & 1) == 0)
  {
    char v46 = v32(a2, a3);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v47 = v44(a2, a3);
    if (v46)
    {
      unint64_t v96 = v44;
      if (v47 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v99;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v97;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        uint64_t v62 = v108;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a2, v59);
        LOBYTE(v58) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v62, a2);
        uint64_t v42 = v110;
        v110(v62, a2);
        uint64_t v63 = v100;
        (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v100, v21, a2);
        if (v58)
        {
LABEL_42:
          v42(v63, a2);
          goto LABEL_43;
        }
        uint64_t v64 = v114[0];
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v42(v63, a2);
        BOOL v43 = v65 < v64;
        uint64_t v37 = v107;
        goto LABEL_21;
      }
      uint64_t v50 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v47, v48, v49);
      int64_t v52 = v108;
      v50(v114, &type metadata for Int64, v51, a2, a3);
      char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v52, a2);
      uint64_t v42 = v110;
      v110(v52, a2);
      v42(v21, a2);
      uint64_t v37 = v107;
      goto LABEL_14;
    }
    if (v47 < 64)
    {
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v42 = v110;
      v110(v21, a2);
      uint64_t v37 = v107;
      uint64_t v45 = v105;
      if (v57 >= v114[0]) {
        goto LABEL_22;
      }
LABEL_43:
      v42(v112, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0xBCuLL, 0);
    }
    v110(v21, a2);
    uint64_t v37 = v107;
LABEL_9:
    uint64_t v45 = v105;
    goto LABEL_22;
  }
  unint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v38 = v96(a2, a3);
  if (v38 >= 64)
  {
    BOOL v54 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v55 = lazy protocol witness table accessor for type Int64 and conformance Int64(v38, v39, v40);
    uint64_t v56 = v108;
    v54(v114, &type metadata for Int64, v55, a2, a3);
    uint64_t v37 = v107;
    char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v56, a2);
    uint64_t v42 = v110;
    v110(v56, a2);
    v42(v21, a2);
LABEL_14:
    uint64_t v45 = v105;
    uint64_t v44 = v96;
    if ((v53 & 1) == 0) {
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v42 = v110;
  v110(v21, a2);
  BOOL v43 = v41 < v114[0];
LABEL_21:
  uint64_t v45 = v105;
  uint64_t v44 = v96;
  if (v43) {
    goto LABEL_43;
  }
LABEL_22:
  unint64_t v66 = v112;
  uint64_t v67 = v44(a2, a3);
  unint64_t v68 = v104;
  v37(v104, v66, a2);
  if (v67 >= 65)
  {
    v110(v68, a2);
    v37(v45, v112, a2);
    uint64_t v69 = v106;
    goto LABEL_26;
  }
  uint64_t v70 = v44(a2, a3);
  v110(v68, a2);
  uint64_t v69 = v106;
  if (v70 != 64)
  {
    v37(v45, v112, a2);
    goto LABEL_32;
  }
  char v71 = v102(a2, a3);
  v37(v45, v112, a2);
  if (v71)
  {
LABEL_32:
    uint64_t v82 = v45;
    goto LABEL_33;
  }
LABEL_26:
  v114[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v72 = v102(a2, a3);
  uint64_t v73 = v44(a2, a3);
  if (v72)
  {
    if (v73 > 64)
    {
      uint64_t v76 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v77 = lazy protocol witness table accessor for type Int64 and conformance Int64(v73, v74, v75);
      uint64_t v78 = v108;
      v76(v114, &type metadata for Int64, v77, a2, a3);
      char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v78, v45, a2);
      uint64_t v42 = v110;
      v110(v78, a2);
      uint64_t v80 = v45;
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  if (v73 <= 63)
  {
LABEL_30:
    uint64_t v81 = v108;
    (*(void (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v82 = v81;
LABEL_33:
    uint64_t v42 = v110;
    v110(v82, a2);
    goto LABEL_36;
  }
  uint64_t v113 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v83 = v108;
  uint64_t v84 = (*(uint64_t (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
  Swift::String::Index v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v88 = lazy protocol witness table accessor for type Int64 and conformance Int64(v84, v86, v87);
  uint64_t v89 = v101;
  v85(&v113, &type metadata for Int64, v88, a2, a3);
  char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v89, v83, a2);
  uint64_t v42 = v110;
  v110(v89, a2);
  uint64_t v80 = v83;
LABEL_35:
  v42(v80, a2);
  if (v79) {
    goto LABEL_43;
  }
LABEL_36:
  uint64_t v90 = v112;
  char v91 = (void (*)(char *, uint64_t, uint64_t))v37;
  unint64_t v92 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v93 = v92(a2, a3);
  v42(v90, a2);
  uint64_t v63 = v108;
  v91(v108, v103, a2);
  uint64_t v94 = v92(a2, a3);
  v42(v63, a2);
  if ((unsigned __int128)(v93 * (__int128)1000000000000) >> 64 != (1000000000000 * v93) >> 63)
  {
    __break(1u);
    goto LABEL_41;
  }
  if (__OFADD__(1000000000000 * v93, ((unint64_t)v94 * (unsigned __int128)0xE8D4A51000uLL) >> 64))
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  return 1000000000000 * v94;
}

uint64_t static Duration.microseconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0xE8D4A51000uLL, a1);
}

uint64_t static Duration.nanoseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v99 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v97 = (char *)&v96 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v100 = (char *)&v96 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v101 = (char *)&v96 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v105 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v104 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  Swift::Int v108 = (char *)&v96 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v96 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)&v96 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v96 - v26;
  v114[0] = 64;
  uint64_t v28 = *(void (**)(uint64_t, void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v25, v29, v30);
  v28(a1, v114, &type metadata for Int, v31, a2, a3);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v33 = v32(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v111 = v8 + 16;
  uint64_t v112 = v27;
  uint64_t v107 = v34;
  v34(v24, v27, a2);
  uint64_t v103 = a1;
  BOOL v35 = (v33 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v106 = v8;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v8 + 8);
  v36(v24, a2);
  uint64_t v37 = v107;
  v107(v21, v112, a2);
  uint64_t v109 = v8 + 8;
  char v110 = v36;
  unint64_t v102 = v32;
  if (!v35)
  {
    v36(v21, a2);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    goto LABEL_9;
  }
  v114[0] = 0x8000000000000000;
  if ((v32(a2, a3) & 1) == 0)
  {
    char v46 = v32(a2, a3);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v47 = v44(a2, a3);
    if (v46)
    {
      unint64_t v96 = v44;
      if (v47 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v99;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v97;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        uint64_t v62 = v108;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a2, v59);
        LOBYTE(v58) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v62, a2);
        uint64_t v42 = v110;
        v110(v62, a2);
        uint64_t v63 = v100;
        (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v100, v21, a2);
        if (v58)
        {
LABEL_42:
          v42(v63, a2);
          goto LABEL_43;
        }
        uint64_t v64 = v114[0];
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v42(v63, a2);
        BOOL v43 = v65 < v64;
        uint64_t v37 = v107;
        goto LABEL_21;
      }
      uint64_t v50 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v47, v48, v49);
      int64_t v52 = v108;
      v50(v114, &type metadata for Int64, v51, a2, a3);
      char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v52, a2);
      uint64_t v42 = v110;
      v110(v52, a2);
      v42(v21, a2);
      uint64_t v37 = v107;
      goto LABEL_14;
    }
    if (v47 < 64)
    {
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v42 = v110;
      v110(v21, a2);
      uint64_t v37 = v107;
      uint64_t v45 = v105;
      if (v57 >= v114[0]) {
        goto LABEL_22;
      }
LABEL_43:
      v42(v112, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0xD9uLL, 0);
    }
    v110(v21, a2);
    uint64_t v37 = v107;
LABEL_9:
    uint64_t v45 = v105;
    goto LABEL_22;
  }
  unint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v38 = v96(a2, a3);
  if (v38 >= 64)
  {
    BOOL v54 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v55 = lazy protocol witness table accessor for type Int64 and conformance Int64(v38, v39, v40);
    uint64_t v56 = v108;
    v54(v114, &type metadata for Int64, v55, a2, a3);
    uint64_t v37 = v107;
    char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v21, v56, a2);
    uint64_t v42 = v110;
    v110(v56, a2);
    v42(v21, a2);
LABEL_14:
    uint64_t v45 = v105;
    uint64_t v44 = v96;
    if ((v53 & 1) == 0) {
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v42 = v110;
  v110(v21, a2);
  BOOL v43 = v41 < v114[0];
LABEL_21:
  uint64_t v45 = v105;
  uint64_t v44 = v96;
  if (v43) {
    goto LABEL_43;
  }
LABEL_22:
  unint64_t v66 = v112;
  uint64_t v67 = v44(a2, a3);
  unint64_t v68 = v104;
  v37(v104, v66, a2);
  if (v67 >= 65)
  {
    v110(v68, a2);
    v37(v45, v112, a2);
    uint64_t v69 = v106;
    goto LABEL_26;
  }
  uint64_t v70 = v44(a2, a3);
  v110(v68, a2);
  uint64_t v69 = v106;
  if (v70 != 64)
  {
    v37(v45, v112, a2);
    goto LABEL_32;
  }
  char v71 = v102(a2, a3);
  v37(v45, v112, a2);
  if (v71)
  {
LABEL_32:
    uint64_t v82 = v45;
    goto LABEL_33;
  }
LABEL_26:
  v114[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v72 = v102(a2, a3);
  uint64_t v73 = v44(a2, a3);
  if (v72)
  {
    if (v73 > 64)
    {
      uint64_t v76 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v77 = lazy protocol witness table accessor for type Int64 and conformance Int64(v73, v74, v75);
      uint64_t v78 = v108;
      v76(v114, &type metadata for Int64, v77, a2, a3);
      char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v78, v45, a2);
      uint64_t v42 = v110;
      v110(v78, a2);
      uint64_t v80 = v45;
      goto LABEL_35;
    }
    goto LABEL_30;
  }
  if (v73 <= 63)
  {
LABEL_30:
    uint64_t v81 = v108;
    (*(void (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v82 = v81;
LABEL_33:
    uint64_t v42 = v110;
    v110(v82, a2);
    goto LABEL_36;
  }
  uint64_t v113 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v83 = v108;
  uint64_t v84 = (*(uint64_t (**)(char *, char *, uint64_t))(v69 + 32))(v108, v45, a2);
  Swift::String::Index v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v88 = lazy protocol witness table accessor for type Int64 and conformance Int64(v84, v86, v87);
  uint64_t v89 = v101;
  v85(&v113, &type metadata for Int64, v88, a2, a3);
  char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v89, v83, a2);
  uint64_t v42 = v110;
  v110(v89, a2);
  uint64_t v80 = v83;
LABEL_35:
  v42(v80, a2);
  if (v79) {
    goto LABEL_43;
  }
LABEL_36:
  uint64_t v90 = v112;
  char v91 = (void (*)(char *, uint64_t, uint64_t))v37;
  unint64_t v92 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v93 = v92(a2, a3);
  v42(v90, a2);
  uint64_t v63 = v108;
  v91(v108, v103, a2);
  uint64_t v94 = v92(a2, a3);
  v42(v63, a2);
  if ((unsigned __int128)(v93 * (__int128)1000000000) >> 64 != (1000000000 * v93) >> 63)
  {
    __break(1u);
    goto LABEL_41;
  }
  if (__OFADD__(1000000000 * v93, ((unint64_t)v94 * (unsigned __int128)0x3B9ACA00uLL) >> 64))
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  return 1000000000 * v94;
}

uint64_t Duration.init(from:)(uint64_t *a1)
{
  return specialized Duration.init(from:)(a1);
}

uint64_t Duration.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 32))(v13, v6, v7);
  unint64_t v8 = v14;
  uint64_t v9 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v9 + 96))(a3, v8, v9);
  if (!v3)
  {
    unint64_t v10 = v14;
    uint64_t v11 = v15;
    __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v11 + 144))(a2, v10, v11);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v13);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Duration(void *a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 32))(v12, v5, v6);
  unint64_t v7 = v13;
  uint64_t v8 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v8 + 96))(v4, v7, v8);
  if (!v2)
  {
    unint64_t v9 = v13;
    uint64_t v10 = v14;
    __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v10 + 144))(v3, v9, v10);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Duration@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized Duration.init(from:)(a1);
  if (!v2)
  {
    *a2 = result;
    a2[1] = v5;
  }
  return result;
}

void Duration.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
}

Swift::Int Duration.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Duration()
{
  Swift::UInt64 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Duration()
{
  Swift::UInt64 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Duration()
{
  Swift::UInt64 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL static Duration.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4 && a1 == a3;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  return a1[1] == a2[1] && *a1 == *a2;
}

BOOL static Duration.< infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2 == a4) {
    return a1 < a3;
  }
  else {
    return a2 < a4;
  }
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 < v3;
  if (v4) {
    return *a1 < *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 >= v2;
  if (v4) {
    return *a2 >= *a1;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 >= v3;
  if (v4) {
    return *a1 >= *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 < v2;
  if (v4) {
    return *a2 < *a1;
  }
  else {
    return v5;
  }
}

uint64_t static Duration.zero.getter()
{
  return 0;
}

uint64_t protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, specialized static Duration.+ infix(_:_:), a3);
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Duration(void *a1, uint64_t *a2)
{
  return specialized static Duration.+= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Duration@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, (uint64_t (*)(void, void, void, void))specialized static Duration.- infix(_:_:), a3);
}

uint64_t protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t (*a3)(void, void, void, void)@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = a3(*a1, a1[1], *a2, a2[1]);
  *a4 = result;
  a4[1] = v6;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Duration(unint64_t *a1, uint64_t a2)
{
  return specialized static Duration.-= infix(_:_:)(a1, *(void *)a2, *(void *)(a2 + 8));
}

uint64_t static Duration./= infix(_:_:)(uint64_t a1, double a2)
{
  uint64_t result = specialized static Duration./ infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), a2);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v4;
  return result;
}

unint64_t specialized static Duration./ infix<A>(_:_:)(uint64_t a1, uint64_t a2, Swift::_Int128 dividingBy)
{
  if ((dividingBy.low & 0x8000000000000000) != 0)
  {
    if (dividingBy.low == -1 && a2 == 0x8000000000000000 && !a1) {
LABEL_10:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  else if (!dividingBy.low)
  {
    goto LABEL_10;
  }
  Swift::UInt64 low = dividingBy.low;
  uint64_t v4 = (uint64_t)dividingBy.low >> 63;
  return (unint64_t)_Int128.quotientAndRemainder(dividingBy:)(*(Swift::_Int128 *)&low);
}

unint64_t static Duration./ infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a4 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (uint64_t (*)(char *, uint64_t))((char *)&v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15((char *)&v28 - v13, v16, v17);
  v15((char *)v12, (uint64_t)v14, a4);
  uint64_t v18 = _Int128.init<A>(exactly:)(v12, a4, a5);
  if (v20) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000028, 0x80000001816DFAC0, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
  }
  Swift::UInt64 v21 = v18;
  Swift::Int64 v22 = v19;
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a4);
  if (v22 != -1)
  {
    if (v22) {
      BOOL v23 = 0;
    }
    else {
      BOOL v23 = v21 == 0;
    }
    if (!v23) {
      goto LABEL_7;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  if (v21 == -1 && a2 == 0x8000000000000000 && a1 == 0) {
    goto LABEL_16;
  }
LABEL_7:
  v24.Swift::UInt64 low = v21;
  v24.high = v22;
  return (unint64_t)_Int128.quotientAndRemainder(dividingBy:)(v24);
}

unint64_t static Duration./= infix<A>(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result = static Duration./ infix<A>(_:_:)(*a1, a1[1], a2, a3, a4);
  *a1 = result;
  a1[1] = v6;
  return result;
}

double static Duration./ infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v8, a1, a2);
  double v6 = v8;
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v8, a3, a4);
  return v6 / v8;
}

uint64_t static Duration.* infix(_:_:)(unint64_t a1, uint64_t a2, double a3)
{
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v59, a1, a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v59, v59 * a3);
  if (v61)
  {
    *(double *)&unint64_t v5 = COERCE_DOUBLE(specialized static String._createEmpty(withInitialCapacity:)(80));
    unint64_t v7 = v6;
    double v59 = *(double *)&v5;
    unint64_t v60 = v6;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v9 < 0) {
      goto LABEL_66;
    }
    uint64_t v10 = (uint8x16_t *)TypeName;
    int64_t v11 = v9;
    int64_t v12 = validateUTF8(_:)(TypeName, v9);
    if (v14) {
      unint64_t v15 = repairUTF8(_:firstKnownBrokenRange:)(v10->i8, v11, v12, v13);
    }
    else {
      unint64_t v15 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v10, v11, v12 & 1);
    }
    unint64_t v17 = v15;
    unint64_t v18 = v16;
    uint64_t v19 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000) == 0) {
      uint64_t v19 = v5 & 0xFFFFFFFFFFFFLL;
    }
    if (!v19 && (v5 & ~v7 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v7);
      double v59 = *(double *)&v17;
      unint64_t v60 = v18;
      goto LABEL_21;
    }
    if ((v7 & 0x2000000000000000) != 0)
    {
      if ((v16 & 0x2000000000000000) != 0)
      {
        unint64_t v21 = specialized _SmallString.init(_:appending:)(v5, v7, v15, v16);
        if ((v23 & 1) == 0)
        {
          double v24 = *(double *)&v21;
          unint64_t v25 = v22;
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v18);
          double v59 = v24;
          unint64_t v60 = v25;
          unint64_t v18 = v25;
          *(double *)&unint64_t v17 = v24;
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else if ((v16 & 0x2000000000000000) != 0)
    {
LABEL_19:
      uint64_t v20 = HIBYTE(v18) & 0xF;
      goto LABEL_20;
    }
    uint64_t v20 = v15 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v17, v18, 0, v20);
    swift_bridgeObjectRelease(v18);
    *(double *)&unint64_t v17 = v59;
    unint64_t v18 = v60;
LABEL_21:
    uint64_t v26 = HIBYTE(v18) & 0xF;
    if ((v18 & 0x2000000000000000) == 0) {
      uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
    }
    if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
    {
      if ((v18 & 0x2000000000000000) != 0
        && (0x80000001816DE7E0 & 0x2000000000000000) != 0
        && (unint64_t v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000), (v29 & 1) == 0))
      {
        double v30 = *(double *)&v27;
        unint64_t v31 = v28;
        swift_bridgeObjectRelease(v18);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
        double v59 = v30;
        unint64_t v60 = v31;
      }
      else
      {
        if ((0x80000001816DE7E0 & 0x2000000000000000) != 0) {
          unint64_t v32 = (0x80000001816DE7E0 >> 56) & 0xF;
        }
        else {
          unint64_t v32 = 30;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000, 0, v32);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v18);
      double v59 = -2.31584178e77;
      unint64_t v60 = 0x80000001816DE7E0 | 0x8000000000000000;
    }
    char v33 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v34 & 0x8000000000000000) == 0)
    {
      BOOL v35 = (uint8x16_t *)v33;
      int64_t v36 = v34;
      int64_t v37 = validateUTF8(_:)(v33, v34);
      if (v39) {
        unint64_t v40 = repairUTF8(_:firstKnownBrokenRange:)(v35->i8, v36, v37, v38);
      }
      else {
        unint64_t v40 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v35, v36, v37 & 1);
      }
      unint64_t v42 = v40;
      unint64_t v43 = v41;
      uint64_t v44 = v60;
      unint64_t v45 = HIBYTE(v60) & 0xF;
      if ((v60 & 0x2000000000000000) == 0) {
        unint64_t v45 = *(void *)&v59 & 0xFFFFFFFFFFFFLL;
      }
      if (!v45 && (*(void *)&v59 & ~v60 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v60);
        double v59 = *(double *)&v42;
        unint64_t v60 = v43;
        goto LABEL_52;
      }
      if ((v60 & 0x2000000000000000) != 0)
      {
        if ((v41 & 0x2000000000000000) != 0)
        {
          unint64_t v47 = specialized _SmallString.init(_:appending:)(*(unint64_t *)&v59, v60, v40, v41);
          if ((v49 & 1) == 0)
          {
            double v50 = *(double *)&v47;
            unint64_t v51 = v48;
            swift_bridgeObjectRelease(v44);
            swift_bridgeObjectRelease(v43);
            double v59 = v50;
            unint64_t v60 = v51;
            unint64_t v43 = v51;
            *(double *)&unint64_t v42 = v50;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
      }
      else if ((v41 & 0x2000000000000000) != 0)
      {
LABEL_50:
        uint64_t v46 = HIBYTE(v43) & 0xF;
        goto LABEL_51;
      }
      uint64_t v46 = v40 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v42, v43, 0, v46);
      swift_bridgeObjectRelease(v43);
      *(double *)&unint64_t v42 = v59;
      unint64_t v43 = v60;
LABEL_52:
      uint64_t v52 = HIBYTE(v43) & 0xF;
      if ((v43 & 0x2000000000000000) == 0) {
        uint64_t v52 = v42 & 0xFFFFFFFFFFFFLL;
      }
      if (v52 || (v42 & ~v43 & 0x2000000000000000) != 0)
      {
        if ((v43 & 0x2000000000000000) != 0
          && (0x80000001816DE800 & 0x2000000000000000) != 0
          && (unint64_t v55 = specialized _SmallString.init(_:appending:)(v42, v43, 0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000), (v57 & 1) == 0))
        {
          uint64_t v54 = v55;
          unint64_t v53 = v56;
          swift_bridgeObjectRelease(v43);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
        }
        else
        {
          if ((0x80000001816DE800 & 0x2000000000000000) != 0) {
            unint64_t v58 = (0x80000001816DE800 >> 56) & 0xF;
          }
          else {
            unint64_t v58 = 46;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000, 0, v58);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
          uint64_t v54 = *(void *)&v59;
          unint64_t v53 = v60;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v43);
        unint64_t v53 = 0x80000001816DE800 | 0x8000000000000000;
        uint64_t v54 = 0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v54, v53, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_66:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return *(void *)&v59;
}

unint64_t static Duration.* infix<A>(_:_:)(unint64_t a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a4 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  int64_t v12 = (uint64_t (*)(char *, uint64_t))((char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v10);
  char v14 = (char *)&v24 - v13;
  unint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15((char *)&v24 - v13, v16, v17);
  v15((char *)v12, (uint64_t)v14, a4);
  uint64_t v18 = _Int128.init<A>(exactly:)(v12, a4, a5);
  if (v20) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000028, 0x80000001816DFAC0, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
  }
  unint64_t v21 = v18;
  unint64_t v22 = v19;
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a4);
  return specialized static _Int128.* infix(_:_:)(a1, a2, v21, v22);
}

unint64_t static Duration.*= infix<A>(_:_:)(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (uint64_t (*)(char *, uint64_t))((char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v11 = (unint64_t *)MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v24 - v12;
  unint64_t v14 = *v11;
  int64_t v15 = v11[1];
  uint64_t v16 = *(void (**)(char *))(v7 + 16);
  v16((char *)&v24 - v12);
  ((void (*)(uint64_t (*)(char *, uint64_t), char *, uint64_t))v16)(v10, v13, a3);
  uint64_t v17 = _Int128.init<A>(exactly:)(v10, a3, a4);
  if (v19) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000028, 0x80000001816DFAC0, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
  }
  unint64_t v20 = v17;
  unint64_t v21 = v18;
  (*(void (**)(char *, uint64_t))(v7 + 8))(v13, a3);
  unint64_t result = specialized static _Int128.* infix(_:_:)(v14, v15, v20, v21);
  *a1 = result;
  a1[1] = v23;
  return result;
}

unint64_t Duration.description.getter(unint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)__src, a1, a2);
  if ((~COERCE__INT64(*(double *)__src / 1.0e18) & 0x7FF0000000000000) != 0
    || (COERCE_UNSIGNED_INT64(*(double *)__src / 1.0e18) & 0xFFFFFFFFFFFFFLL) == 0)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    int64_t v3 = swift_float64ToString(&v19, 32, 0);
    __src[0] = v19;
    __src[1] = v20;
    if (v3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    size_t v4 = v3;
    if (v3)
    {
      if ((unint64_t)v3 <= 0xF)
      {
        uint64_t v9 = v3 - 8;
        uint64_t v10 = 8;
        if (v3 < 8) {
          uint64_t v10 = v3;
        }
        unint64_t v8 = LOBYTE(__src[0]);
        if (v10 != 1)
        {
          unint64_t v8 = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
          if (v10 != 2)
          {
            v8 |= (unint64_t)BYTE2(__src[0]) << 16;
            if (v10 != 3)
            {
              v8 |= (unint64_t)BYTE3(__src[0]) << 24;
              if (v10 != 4)
              {
                v8 |= (unint64_t)BYTE4(__src[0]) << 32;
                if (v10 != 5)
                {
                  v8 |= (unint64_t)BYTE5(__src[0]) << 40;
                  if (v10 != 6)
                  {
                    v8 |= (unint64_t)BYTE6(__src[0]) << 48;
                    if (v10 != 7) {
                      v8 |= (unint64_t)BYTE7(__src[0]) << 56;
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v11 = 0;
        if (v4 >= 9)
        {
          uint64_t v12 = 0;
          uint64_t v13 = (unsigned __int8 *)__src + 8;
          unint64_t v14 = v9 & ~(v9 >> 63);
          do
          {
            if (v14 <= v4 - 9) {
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
            }
            unsigned int v15 = *v13++;
            v11 |= (unint64_t)v15 << v12;
            v12 += 8;
            --v9;
          }
          while (v9);
        }
        unint64_t v16 = 0xA000000000000000;
        if (((v11 | v8) & 0x8080808080808080) == 0) {
          unint64_t v16 = 0xE000000000000000;
        }
        int64_t v7 = v16 | (v4 << 56) | v11;
      }
      else
      {
        unint64_t v5 = v3 | 0xF000000000000000;
        int64_t v7 = _allocateStringStorage(codeUnitCapacity:)(v3);
        *(void *)(v7 + 16) = v6;
        *(void *)(v7 + 24) = v5;
        if (v6 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
          unint64_t v5 = *(void *)(v7 + 24);
        }
        *(unsigned char *)(v7 + 32 + (v5 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v4, (char *)(v7 + 32));
        unint64_t v8 = *(void *)(v7 + 24);
      }
    }
    else
    {
      unint64_t v8 = 0;
      int64_t v7 = 0xE000000000000000;
    }
  }
  else
  {
    int64_t v7 = 0xE300000000000000;
    unint64_t v8 = 7233902;
  }
  unint64_t v17 = specialized static String.+ infix(_:_:)(v8, v7, 0x73646E6F63657320uLL, 0xE800000000000000);
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000);
  return v17;
}

unint64_t Double.description.getter(double a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0 && (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0) {
    return 7233902;
  }
  long long v14 = 0u;
  long long v15 = 0u;
  int64_t v2 = swift_float64ToString(&v14, 32, 0);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  size_t v3 = v2;
  if (!v2) {
    return 0;
  }
  if ((unint64_t)v2 <= 0xF)
  {
    uint64_t v7 = v2 - 8;
    uint64_t v8 = 8;
    if (v2 < 8) {
      uint64_t v8 = v2;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v9 = 0;
    if (v3 >= 9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    unint64_t v4 = v2 | 0xF000000000000000;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v4 = *(void *)(v5 + 24);
    }
    *(unsigned char *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Duration()
{
  return Duration.description.getter(*(void *)v0, *(void *)(v0 + 8));
}

unint64_t protocol witness for static DurationProtocol./ infix(_:_:) in conformance Duration@<X0>(Swift::_Int128 dividingBy@<0:X1, 8:X2>, uint64_t *a2@<X0>, uint64_t a3@<X3>, unint64_t *a4@<X8>)
{
  Swift::UInt64 low = dividingBy.low;
  unint64_t result = specialized static Duration./ infix<A>(_:_:)(*a2, a2[1], *(Swift::_Int128 *)(&a3 - 1));
  *a4 = result;
  a4[1] = v7;
  return result;
}

uint64_t specialized static DurationProtocol./= infix(_:_:)(void *a1, Swift::_Int128 dividingBy)
{
  if ((dividingBy.low & 0x8000000000000000) != 0)
  {
    if (dividingBy.low == -1 && a1[1] == 0x8000000000000000 && *a1 == 0) {
LABEL_10:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  else if (!dividingBy.low)
  {
    goto LABEL_10;
  }
  v4.Swift::UInt64 low = dividingBy.low;
  v4.high = (uint64_t)dividingBy.low >> 63;
  *(_OWORD *)&uint64_t result = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(v4);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t static DurationProtocol./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v9 + 24))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

{
  return static DurationProtocol./= infix(_:_:)(a1, a2, a3);
}

unint64_t protocol witness for static DurationProtocol.* infix(_:_:) in conformance Duration@<X0>(uint64_t a1@<X0>, int64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized static _Int128.* infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), a2, a2 >> 63);
  *a3 = result;
  a3[1] = v5;
  return result;
}

unint64_t protocol witness for static DurationProtocol.*= infix(_:_:) in conformance Duration(uint64_t a1, int64_t a2)
{
  unint64_t result = specialized static _Int128.* infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), a2, a2 >> 63);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v4;
  return result;
}

uint64_t static DurationProtocol.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v9 + 40))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

{
  return static DurationProtocol.*= infix(_:_:)(a1, a2, a3);
}

double protocol witness for static DurationProtocol./ infix(_:_:) in conformance Duration(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v6, *(void *)a1, *(void *)(a1 + 8));
  double v4 = v6;
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v6, v2, v3);
  return v4 / v6;
}

uint64_t specialized static BinaryFloatingPoint<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v134 = a2;
  uint64_t v116 = a6;
  uint64_t v10 = *(void *)(a4 + 16);
  uint64_t v11 = *(void *)(*(void *)(v10 + 16) + 8);
  unint64_t v130 = *(int ***)(v11 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v130, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v128 = (char *)&v96 - v12;
  uint64_t v137 = a5;
  uint64_t v126 = *(void *)(a5 + 8);
  uint64_t v105 = *(void *)(v126 + 24);
  unsigned int v13 = *(int ***)(v105 + 16);
  uint64_t v135 = a4;
  long long v14 = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  unint64_t v115 = v13;
  uint64_t v103 = swift_getAssociatedTypeWitness(0, v13, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v103);
  unint64_t v102 = (char *)&v96 - v15;
  int64_t v131 = swift_checkMetadataState(0, (uint64_t)v14);
  uint64_t v133 = *(v131 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v131);
  unint64_t v101 = (char *)&v96 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v104 = (char *)&v96 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  unint64_t v114 = (char *)&v96 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  long long v132 = (char *)&v96 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v117 = (uint64_t)&v96 - v25;
  uint64_t v136 = *(void *)(a3 - 8);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v127 = (char *)&v96 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v122 = (char *)&v96 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  unint64_t v121 = (char *)&v96 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  size_t v123 = (char *)&v96 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v125 = (char *)&v96 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v124 = (char *)&v96 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  unint64_t v40 = (char *)&v96 - v39;
  MEMORY[0x1F4188790](v38);
  unint64_t v42 = (char *)&v96 - v41;
  uint64_t v44 = type metadata accessor for Range(0, a3, *(void *)(*(void *)(v10 + 24) + 8), v43);
  uint64_t v45 = (uint64_t)*(v44 - 1);
  MEMORY[0x1F4188790](v44);
  unint64_t v47 = (char *)&v96 - v46;
  (*(void (**)(char *, uint64_t, Class *))(v45 + 16))((char *)&v96 - v46, a1, v44);
  unint64_t v48 = &v47[*((int *)v44 + 9)];
  uint64_t v49 = *(void *)(*(void *)(v10 + 8) + 8);
  double v50 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v49 + 8);
  uint64_t v119 = v49 + 8;
  uint64_t v120 = v49;
  uint64_t v118 = v50;
  if (((uint64_t (*)(char *, char *, uint64_t))v50)(v47, v48, a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't get random value with an empty range", 42, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x34uLL, 0);
  }
  (*(void (**)(char *, Class *))(v45 + 8))(v47, v44);
  uint64_t v51 = a1;
  uint64_t v52 = a1 + *((int *)v44 + 9);
  uint64_t v53 = *(void *)(v11 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v53 + 40))(v52, a1, a3, v53);
  uint64_t v54 = v136;
  (*(void (**)(char *, char *, uint64_t))(v136 + 16))(v40, v42, a3);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v10 + 376))(a3, v10) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x3EuLL, 0);
  }
  uint64_t v109 = v53;
  char v110 = v42;
  uint64_t v111 = v10;
  uint64_t v112 = v11;
  uint64_t v113 = v51;
  uint64_t v55 = v54 + 8;
  unint64_t v56 = *(void (**)(char *, uint64_t))(v54 + 8);
  v56(v40, a3);
  uint64_t v57 = (uint64_t)v131;
  uint64_t v58 = (*(uint64_t (**)(uint64_t *))(v137 + 56))(v131);
  uint64_t v59 = v135;
  unint64_t v60 = *(uint64_t (**)(uint64_t, uint64_t))(v135 + 104);
  uint64_t result = v60(a3, v135);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v108 = v52;
  uint64_t v107 = v56;
  uint64_t v106 = v55;
  if (v58 == result + 1)
  {
    uint64_t v62 = v117;
    specialized static FixedWidthInteger._random<A>(using:)(v57, v137, v117);
    uint64_t v63 = v126;
    uint64_t v65 = v132;
    uint64_t v64 = v133;
    goto LABEL_9;
  }
  uint64_t result = v60(a3, v59);
  uint64_t v66 = result + 1;
  if (__OFADD__(result, 1))
  {
LABEL_16:
    __break(1u);
    return result;
  }
  uint64_t v67 = (uint64_t)v115;
  unint64_t v68 = v103;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, v57, (uint64_t)v103, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v99 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
  uint64_t v100 = AssociatedConformanceWitness + 8;
  uint64_t v69 = v102;
  v99(&qword_18162B0C0, 512, v68, AssociatedConformanceWitness);
  char v97 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v67 + 24);
  uint64_t v70 = (uint64_t)v114;
  uint64_t v71 = v97(v69, v57, v67);
  uint64_t v138 = v66;
  uint64_t v63 = v126;
  char v72 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v126 + 256);
  unint64_t v75 = lazy protocol witness table accessor for type Int and conformance Int(v71, v73, v74);
  v72(v70, &v138, &type metadata for Int, v75, v57, v63);
  uint64_t v76 = *(void (**)(uint64_t, uint64_t))(v133 + 8);
  v76(v70, v57);
  specialized static FixedWidthInteger._random<A>(using:)(v57, v137, v70);
  v99(&qword_18162B0C0, 512, v68, AssociatedConformanceWitness);
  unint64_t v77 = v101;
  v97(v69, v57, (uint64_t)v115);
  uint64_t v65 = v132;
  uint64_t v78 = v104;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v105 + 8) + 40))(v132, v77, v57);
  v76((uint64_t)v77, v57);
  v76((uint64_t)v65, v57);
  uint64_t v62 = v117;
  char v79 = v114;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v63 + 192))(v114, v78, v57, v63);
  v76((uint64_t)v78, v57);
  v76((uint64_t)v79, v57);
  uint64_t v64 = v133;
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v64 + 32))(v65, v62, v57);
  uint64_t v80 = v111;
  uint64_t v81 = v125;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v111 + 72))(v65, v57, v63, a3, v111);
  uint64_t v82 = v121;
  (*(void (**)(uint64_t, uint64_t))(v80 + 144))(a3, v80);
  uint64_t v83 = AssociatedTypeWitness;
  uint64_t v84 = v130;
  uint64_t v85 = swift_getAssociatedConformanceWitness((uint64_t)v130, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v86 = v128;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v85 + 8))(&unk_18162B0D0, 768, v83, v85);
  uint64_t v87 = v122;
  ((void (*)(char *, uint64_t, int **))v84[3])(v86, a3, v84);
  unint64_t v88 = v123;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v80 + 192))(v82, v87, a3, v80);
  uint64_t v89 = v107;
  v107(v87, a3);
  v89(v82, a3);
  uint64_t v90 = v112;
  char v91 = *(void (**)(char *, char *, uint64_t, uint64_t))(v112 + 64);
  unint64_t v92 = v124;
  v91(v81, v88, a3, v112);
  v89(v88, a3);
  v89(v81, a3);
  uint64_t v93 = v110;
  v91(v110, v92, a3, v90);
  v89(v92, a3);
  v89(v93, a3);
  uint64_t v94 = v127;
  uint64_t v95 = v113;
  (*(void (**)(char *, uint64_t, uint64_t))(v109 + 24))(v81, v113, a3);
  v89(v81, a3);
  if ((v118(v94, v108, a3, v120) & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v136 + 32))(v116, v94, a3);
  }
  v89(v94, a3);
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(v95, v134, a3, v135, v137);
}

{
  uint64_t v9;
  uint64_t v10;
  int **v11;
  const char *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  Class *v41;
  uint64_t v42;
  void (*v43)(void);
  uint64_t v44;
  uint64_t v45;
  uint64_t (*v46)(uint64_t, uint64_t, uint64_t);
  void (*v47)(char *, uint64_t);
  uint64_t v48;
  uint64_t v49;
  uint64_t (*v50)(uint64_t, uint64_t);
  uint64_t result;
  char *v52;
  char v53;
  char *v54;
  void *v55;
  char v56;
  void (*v57)(char *, uint64_t *);
  uint64_t v58;
  const char *v59;
  char *v60;
  char *v61;
  uint64_t v62;
  void (*v63)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, void *);
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  void (*v67)(char *, uint64_t *);
  char *v68;
  char *v69;
  char v70;
  uint64_t v71;
  void (*v72)(char *, uint64_t);
  char *v73;
  const char *v74;
  int **v75;
  uint64_t v76;
  char *v77;
  char *v78;
  char *v79;
  void *v80;
  void (*v81)(char *, char *, uint64_t, void *);
  char *v82;
  char *v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t (*v87)(char *, uint64_t *, uint64_t);
  uint64_t v88;
  uint64_t AssociatedConformanceWitness;
  void (*v90)(uint64_t *, uint64_t, const char *, uint64_t);
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  const char *v96;
  uint64_t v97;
  uint64_t (*v98)(uint64_t, uint64_t, uint64_t);
  uint64_t v99;
  char *v100;
  char *v101;
  uint64_t v102;
  char *v103;
  char *v104;
  char *v105;
  const char *AssociatedTypeWitness;
  int **v107;
  void (*v108)(char *, uint64_t);
  char *v109;
  uint64_t v110;
  char *v111;
  int **v112;
  char *v113;
  char *v114;
  uint64_t v115;
  char *v116;
  void *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void *v121;
  uint64_t v122;
  uint64_t __buf;

  unint64_t v115 = a2;
  uint64_t v118 = a6;
  uint64_t v9 = *(void *)(a4 + 16);
  unint64_t v121 = *(void **)(*(void *)(v9 + 16) + 8);
  uint64_t v122 = a1;
  uint64_t v107 = (int **)v121[2];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v107, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v105 = (char *)&v85 - v10;
  uint64_t v120 = a5;
  uint64_t v117 = *(void **)(a5 + 8);
  char v97 = v117[3];
  uint64_t v11 = *(int ***)(v97 + 16);
  uint64_t v12 = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v112 = v11;
  uint64_t v96 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v96);
  uint64_t v95 = (char *)&v85 - v13;
  long long v14 = swift_checkMetadataState(0, (uint64_t)v12);
  uint64_t v119 = *(v14 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v14);
  uint64_t v94 = (char *)&v85 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v111 = (char *)&v85 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  unint64_t v114 = (char *)&v85 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v113 = (char *)&v85 - v22;
  uint64_t v23 = *(void *)(a3 - 8);
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  unint64_t v101 = (char *)&v85 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v100 = (char *)&v85 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v103 = (char *)&v85 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v32 = (char *)&v85 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  uint64_t v104 = (char *)&v85 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v37 = (char *)&v85 - v36;
  MEMORY[0x1F4188790](v35);
  uint64_t v39 = (char *)&v85 - v38;
  uint64_t v41 = type metadata accessor for ClosedRange(0, a3, *(void *)(*(void *)(v9 + 24) + 8), v40);
  unint64_t v42 = v121[1];
  uint64_t v43 = *(void (**)(void))(v42 + 40);
  uint64_t v99 = v122 + *((int *)v41 + 9);
  unint64_t v102 = v42;
  v43();
  uint64_t v44 = v23;
  uint64_t v46 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v23 + 16);
  uint64_t v45 = v23 + 16;
  uint64_t v116 = v39;
  uint64_t v98 = v46;
  v46((uint64_t)v37, (uint64_t)v39, a3);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 376))(a3, v9) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0xA2uLL, 0);
  }
  unint64_t v92 = v45;
  uint64_t v109 = v32;
  uint64_t v93 = v9;
  unint64_t v47 = *(void (**)(char *, uint64_t))(v44 + 8);
  char v110 = v44 + 8;
  uint64_t v108 = v47;
  v47(v37, a3);
  unint64_t v48 = v120;
  uint64_t v49 = (*(uint64_t (**)(uint64_t *, uint64_t))(v120 + 56))(v14, v120);
  double v50 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 104);
  uint64_t result = v50(a3, a4);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_15;
  }
  if (v49 != result + 1)
  {
    uint64_t result = v50(a3, a4);
    if (!__OFADD__(result, 1))
    {
      uint64_t v58 = (uint64_t)v112;
      uint64_t v59 = v96;
      uint64_t v86 = result + 1;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v112, (uint64_t)v14, (uint64_t)v96, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v90 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      unint64_t v60 = v95;
      v90(&qword_18162B0C0, 512, v59, AssociatedConformanceWitness);
      uint64_t v87 = *(uint64_t (**)(char *, uint64_t *, uint64_t))(v58 + 24);
      unint64_t v88 = v58 + 24;
      char v91 = a4;
      uint64_t v54 = v114;
      char v61 = v60;
      uint64_t v62 = v87(v60, v14, v58);
      __buf = v86;
      uint64_t v55 = v117;
      uint64_t v63 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, void *))v117[32];
      uint64_t v66 = lazy protocol witness table accessor for type Int and conformance Int(v62, v64, v65);
      v63(v54, &__buf, &type metadata for Int, v66, v14, v55);
      uint64_t v67 = *(void (**)(char *, uint64_t *))(v119 + 8);
      v67(v54, v14);
      v90(&qword_18162B0C0, 512, v59, AssociatedConformanceWitness);
      unint64_t v68 = v94;
      v87(v61, v14, (uint64_t)v112);
      uint64_t v69 = v111;
      (*(void (**)(char *, char *, uint64_t *))(*(void *)(v97 + 8) + 24))(v111, v68, v14);
      v67(v68, v14);
      swift_getAssociatedConformanceWitness(v91, a3, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v52 = v113;
      specialized RandomNumberGenerator.next<A>(upperBound:)(v54, (uint64_t)v14, v120, v113);
      v67(v54, v14);
      uint64_t v70 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v55[2] + 8) + 8))(v52, v69, v14);
      v67(v69, v14);
      if (v70)
      {
        v67(v52, v14);
        goto LABEL_10;
      }
      goto LABEL_11;
    }
LABEL_15:
    __break(1u);
    return result;
  }
  uint64_t v52 = v113;
  specialized static FixedWidthInteger._random<A>(using:)((uint64_t)v14, v48, (uint64_t)v113);
  __buf = 0;
  swift_stdlib_random(&__buf, 8uLL);
  uint64_t v53 = __buf;
  uint64_t v54 = v114;
  (*(void (**)(uint64_t *, uint64_t))(v48 + 64))(v14, v48);
  uint64_t v55 = v117;
  unint64_t v56 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v117[2] + 8) + 8))(v52, v54, v14);
  uint64_t v57 = *(void (**)(char *, uint64_t *))(v119 + 8);
  v57(v54, v14);
  if (v56 & 1) != 0 && (v53)
  {
    v57(v52, v14);
LABEL_10:
    v108(v116, a3);
    return v98(v118, v99, a3);
  }
LABEL_11:
  (*(void (**)(char *, char *, uint64_t *))(v119 + 32))(v54, v52, v14);
  uint64_t v71 = v93;
  (*(void (**)(char *, uint64_t *, void *, uint64_t, uint64_t))(v93 + 72))(v54, v14, v55, a3, v93);
  char v72 = v108;
  uint64_t v73 = v100;
  (*(void (**)(uint64_t, uint64_t))(v71 + 144))(a3, v71);
  uint64_t v74 = AssociatedTypeWitness;
  unint64_t v75 = v107;
  uint64_t v76 = swift_getAssociatedConformanceWitness((uint64_t)v107, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v77 = v105;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v76 + 8))(&unk_18162B0D0, 768, v74, v76);
  uint64_t v78 = v101;
  ((void (*)(char *, uint64_t, int **))v75[3])(v77, a3, v75);
  char v79 = v103;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v71 + 192))(v73, v78, a3, v71);
  v72(v78, a3);
  v72(v73, a3);
  uint64_t v80 = v121;
  uint64_t v81 = (void (*)(char *, char *, uint64_t, void *))v121[8];
  uint64_t v82 = v104;
  uint64_t v83 = v109;
  v81(v109, v79, a3, v121);
  v72(v79, a3);
  v72(v83, a3);
  uint64_t v84 = v116;
  v81(v116, v82, a3, v80);
  v72(v82, a3);
  v72(v84, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v102 + 24))(v83, v122, a3);
  return ((uint64_t (*)(char *, uint64_t))v72)(v83, a3);
}

uint64_t static BinaryFloatingPoint<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v136 = a4;
  uint64_t v137 = a6;
  uint64_t v135 = a2;
  uint64_t v132 = a8;
  uint64_t v12 = *(void **)(a5 + 16);
  Swift::String::Index v141 = *(void **)(v12[2] + 8);
  int64_t v131 = (int **)v141[2];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v131, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v129 = (char *)&v101 - v13;
  uint64_t v142 = a7;
  uint64_t v127 = *(void *)(a7 + 8);
  uint64_t v109 = *(void *)(v127 + 24);
  long long v14 = *(int ***)(v109 + 16);
  uint64_t v139 = a5;
  uint64_t v15 = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v118 = (uint64_t)v14;
  uint64_t v107 = swift_getAssociatedTypeWitness(0, v14, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v107);
  uint64_t v116 = (char *)&v101 - v16;
  uint64_t v17 = swift_checkMetadataState(0, (uint64_t)v15);
  uint64_t v134 = *(v17 - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v17);
  uint64_t v106 = (char *)&v101 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v108 = (char *)&v101 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v117 = (char *)&v101 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v133 = (char *)&v101 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v119 = (uint64_t)&v101 - v27;
  uint64_t v138 = *(void *)(a3 - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v128 = (char *)&v101 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  size_t v123 = (char *)&v101 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v122 = (char *)&v101 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v124 = (char *)&v101 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v126 = (char *)&v101 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v125 = (char *)&v101 - v39;
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  unint64_t v42 = (char *)&v101 - v41;
  MEMORY[0x1F4188790](v40);
  uint64_t v44 = (char *)&v101 - v43;
  uint64_t v46 = type metadata accessor for Range(0, a3, *(void *)(v12[3] + 8), v45);
  uint64_t v47 = (uint64_t)*(v46 - 1);
  MEMORY[0x1F4188790](v46);
  uint64_t v49 = (char *)&v101 - v48;
  (*(void (**)(char *, uint64_t, Class *))(v47 + 16))((char *)&v101 - v48, a1, v46);
  double v50 = &v49[*((int *)v46 + 9)];
  Swift::String::Index v140 = v12;
  uint64_t v51 = *(void *)(v12[1] + 8);
  uint64_t v52 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 8);
  uint64_t v121 = v51 + 8;
  uint64_t v120 = v52;
  if (v52(v49, (uint64_t)v50, a3, v51)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't get random value with an empty range", 42, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x34uLL, 0);
  }
  uint64_t v115 = v51;
  (*(void (**)(char *, Class *))(v47 + 8))(v49, v46);
  uint64_t v53 = a1 + *((int *)v46 + 9);
  uint64_t v54 = v141[1];
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v54 + 40))(v53, a1, a3, v54);
  uint64_t v55 = v138;
  (*(void (**)(char *, char *, uint64_t))(v138 + 16))(v42, v44, a3);
  if ((((uint64_t (*)(uint64_t))v140[47])(a3) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x3EuLL, 0);
  }
  uint64_t v113 = v54;
  uint64_t v114 = a1;
  uint64_t v58 = *(void (**)(char *, uint64_t))(v55 + 8);
  uint64_t v57 = v55 + 8;
  unint64_t v56 = v58;
  v58(v42, a3);
  uint64_t v59 = (*(uint64_t (**)(uint64_t *))(v142 + 56))(v17);
  unint64_t v60 = *(uint64_t (**)(uint64_t))(v139 + 104);
  uint64_t result = v60(a3);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v111 = v53;
  uint64_t v112 = v44;
  char v110 = v56;
  if (v59 == result + 1)
  {
    uint64_t v62 = v119;
    static FixedWidthInteger._random<A>(using:)(v135, (uint64_t)v17, v136, v142, v137, v119);
    uint64_t v63 = v127;
    uint64_t v65 = v133;
    uint64_t v64 = v134;
    goto LABEL_9;
  }
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v60)(a3, v139);
  uint64_t v66 = result + 1;
  if (__OFADD__(result, 1))
  {
LABEL_16:
    __break(1u);
    return result;
  }
  uint64_t v67 = v118;
  unint64_t v68 = v107;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v118, (uint64_t)v17, (uint64_t)v107, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v104 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
  uint64_t v105 = AssociatedConformanceWitness + 8;
  uint64_t v69 = v116;
  v104(&qword_18162B0C0, 512, v68, AssociatedConformanceWitness);
  unint64_t v102 = *(uint64_t (**)(char *, uint64_t *, uint64_t))(v67 + 24);
  uint64_t v70 = (uint64_t)v117;
  uint64_t v71 = v102(v69, v17, v67);
  uint64_t v143 = v66;
  uint64_t v72 = v127;
  uint64_t v73 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v127 + 256);
  unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v71, v74, v75);
  v73(v70, &v143, &type metadata for Int, v76, v17, v72);
  unint64_t v77 = *(void (**)(uint64_t, uint64_t *))(v134 + 8);
  v77(v70, v17);
  static FixedWidthInteger._random<A>(using:)(v135, (uint64_t)v17, v136, v142, v137, v70);
  uint64_t v78 = v116;
  v104(&qword_18162B0C0, 512, v68, AssociatedConformanceWitness);
  char v79 = v106;
  v102(v78, v17, v118);
  uint64_t v65 = v133;
  uint64_t v80 = v108;
  (*(void (**)(char *, char *, uint64_t *))(*(void *)(v109 + 8) + 40))(v133, v79, v17);
  v77((uint64_t)v79, v17);
  v77((uint64_t)v65, v17);
  uint64_t v81 = v72;
  uint64_t v82 = *(void (**)(char *, char *, uint64_t *))(v72 + 192);
  uint64_t v62 = v119;
  uint64_t v83 = v117;
  uint64_t v118 = v57;
  uint64_t v84 = v81;
  v82(v117, v80, v17);
  v77((uint64_t)v80, v17);
  uint64_t v63 = v84;
  v77((uint64_t)v83, v17);
  uint64_t v64 = v134;
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t *))(v64 + 32))(v65, v62, v17);
  uint64_t v85 = v140;
  uint64_t v86 = v126;
  ((void (*)(char *, uint64_t *, uint64_t, uint64_t, void *))v140[9])(v65, v17, v63, a3, v140);
  uint64_t v87 = v122;
  ((void (*)(uint64_t, void *))v85[18])(a3, v85);
  unint64_t v88 = AssociatedTypeWitness;
  uint64_t v89 = v131;
  uint64_t v90 = swift_getAssociatedConformanceWitness((uint64_t)v131, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v91 = v129;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v90 + 8))(&unk_18162B0D0, 768, v88, v90);
  unint64_t v92 = v123;
  ((void (*)(char *, uint64_t, int **))v89[3])(v91, a3, v89);
  uint64_t v93 = v124;
  ((void (*)(char *, char *, uint64_t, void *))v85[24])(v87, v92, a3, v85);
  uint64_t v94 = v110;
  v110(v92, a3);
  v94(v87, a3);
  uint64_t v95 = v141;
  uint64_t v96 = (void (*)(char *, char *, uint64_t, void *))v141[8];
  char v97 = v125;
  v96(v86, v93, a3, v141);
  v94(v93, a3);
  v94(v86, a3);
  uint64_t v98 = v112;
  v96(v112, v97, a3, v95);
  v94(v97, a3);
  v94(v98, a3);
  uint64_t v99 = v128;
  uint64_t v100 = v114;
  (*(void (**)(char *, uint64_t, uint64_t))(v113 + 24))(v86, v114, a3);
  v94(v86, a3);
  if ((v120(v99, v111, a3, v115) & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v138 + 32))(v132, v99, a3);
  }
  v94(v99, a3);
  return static BinaryFloatingPoint<>.random<A>(in:using:)(v100, v135, a3, v136, v139, v137, v142);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int **v15;
  const char *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  Class *v44;
  uint64_t v45;
  void (*v46)(void);
  uint64_t (*v47)(uint64_t, uint64_t, uint64_t);
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t result;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  char *v57;
  void *v58;
  char v59;
  void (*v60)(char *, uint64_t *);
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  void (*v67)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, void *);
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  void (*v74)(char *, uint64_t *);
  char v75;
  uint64_t v76;
  char *v77;
  char *v78;
  const char *v79;
  int **v80;
  uint64_t v81;
  char *v82;
  char *v83;
  void (*v84)(char *, uint64_t);
  char *v85;
  uint64_t v86;
  void (*v87)(char *, char *, uint64_t, uint64_t);
  char *v88;
  char *v89;
  void v90[2];
  void (*v91)(char *, uint64_t *);
  uint64_t (*v92)(char *, uint64_t *, uint64_t);
  uint64_t AssociatedConformanceWitness;
  void (*v94)(uint64_t *, uint64_t, const char *, uint64_t);
  uint64_t v95;
  uint64_t v96;
  char *v97;
  char *v98;
  const char *v99;
  uint64_t v100;
  uint64_t (*v101)(uint64_t, uint64_t, uint64_t);
  uint64_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  const char *AssociatedTypeWitness;
  int **v111;
  uint64_t v112;
  void (*v113)(char *, uint64_t);
  uint64_t v114;
  char *v115;
  int **v116;
  char *v117;
  char *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  char *v122;
  void *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;

  uint64_t v120 = a2;
  uint64_t v121 = a6;
  uint64_t v119 = a4;
  uint64_t v124 = a8;
  uint64_t v12 = *(void *)(a5 + 16);
  uint64_t v13 = *(void *)(*(void *)(v12 + 16) + 8);
  uint64_t v111 = *(int ***)(v13 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)v90 - v14;
  uint64_t v126 = a7;
  size_t v123 = *(void **)(a7 + 8);
  uint64_t v100 = v123[3];
  uint64_t v15 = *(int ***)(v100 + 16);
  uint64_t v16 = swift_getAssociatedTypeWitness(255, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v116 = v15;
  uint64_t v99 = swift_getAssociatedTypeWitness(0, v15, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v99);
  uint64_t v98 = (char *)v90 - v17;
  uint64_t v18 = swift_checkMetadataState(0, (uint64_t)v16);
  uint64_t v125 = *(v18 - 1);
  uint64_t v19 = MEMORY[0x1F4188790](v18);
  char v97 = (char *)v90 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v115 = (char *)v90 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v118 = (char *)v90 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v117 = (char *)v90 - v26;
  uint64_t v27 = *(void *)(a3 - 8);
  uint64_t v28 = MEMORY[0x1F4188790](v25);
  uint64_t v104 = (char *)v90 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v103 = (char *)v90 - v31;
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v106 = (char *)v90 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v108 = (char *)v90 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v107 = (char *)v90 - v37;
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  uint64_t v40 = (char *)v90 - v39;
  MEMORY[0x1F4188790](v38);
  unint64_t v42 = (char *)v90 - v41;
  uint64_t v44 = type metadata accessor for ClosedRange(0, a3, *(void *)(*(void *)(v12 + 24) + 8), v43);
  uint64_t v45 = *(void *)(v13 + 8);
  uint64_t v46 = *(void (**)(void))(v45 + 40);
  unint64_t v102 = a1 + *((int *)v44 + 9);
  uint64_t v112 = a1;
  uint64_t v105 = v45;
  v46();
  uint64_t v48 = v27 + 16;
  uint64_t v47 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  uint64_t v122 = v42;
  uint64_t v101 = v47;
  v47((uint64_t)v40, (uint64_t)v42, a3);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v12 + 376))(a3, v12) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0xA2uLL, 0);
  }
  uint64_t v95 = v12;
  uint64_t v96 = v13;
  uint64_t v113 = *(void (**)(char *, uint64_t))(v27 + 8);
  uint64_t v114 = v27 + 8;
  v113(v40, a3);
  uint64_t v49 = v126;
  double v50 = (*(uint64_t (**)(uint64_t *, uint64_t))(v126 + 56))(v18, v126);
  uint64_t v51 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 104);
  uint64_t result = v51(a3, a5);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_14;
  }
  if (v50 != result + 1)
  {
    uint64_t result = v51(a3, a5);
    if (!__OFADD__(result, 1))
    {
      v90[1] = v48;
      char v61 = (uint64_t)v116;
      uint64_t v62 = v99;
      uint64_t v63 = result + 1;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v116, (uint64_t)v18, (uint64_t)v99, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v94 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v64 = v98;
      v94(&qword_18162B0C0, 512, v62, AssociatedConformanceWitness);
      uint64_t v65 = v61;
      unint64_t v92 = *(uint64_t (**)(char *, uint64_t *, uint64_t))(v61 + 24);
      uint64_t v57 = v118;
      uint64_t v66 = v92(v64, v18, v65);
      uint64_t v127 = v63;
      uint64_t v58 = v123;
      char v91 = (void (*)(char *, uint64_t *))(v123 + 32);
      uint64_t v67 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t *, void *))v123[32];
      uint64_t v70 = lazy protocol witness table accessor for type Int and conformance Int(v66, v68, v69);
      v67(v57, &v127, &type metadata for Int, v70, v18, v58);
      char v91 = *(void (**)(char *, uint64_t *))(v125 + 8);
      v91(v57, v18);
      v94(&qword_18162B0C0, 512, v62, AssociatedConformanceWitness);
      uint64_t v71 = v97;
      v92(v64, v18, (uint64_t)v116);
      uint64_t v72 = v115;
      (*(void (**)(char *, char *, uint64_t *))(*(void *)(v100 + 8) + 24))(v115, v71, v18);
      uint64_t v73 = v71;
      uint64_t v74 = v91;
      v91(v73, v18);
      uint64_t v53 = v117;
      RandomNumberGenerator.next<A>(upperBound:)(v57, v119, (uint64_t)v18, v121, v126, v117);
      v74(v57, v18);
      uint64_t v75 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v58[2] + 8) + 8))(v53, v72, v18);
      v74(v72, v18);
      if (v75)
      {
        v74(v53, v18);
        v113(v122, a3);
        return v101(v124, v102, a3);
      }
      goto LABEL_10;
    }
LABEL_14:
    __break(1u);
    return result;
  }
  uint64_t v53 = v117;
  uint64_t v54 = v119;
  uint64_t v55 = v121;
  static FixedWidthInteger._random<A>(using:)(v120, (uint64_t)v18, v119, v49, v121, (uint64_t)v117);
  unint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v55 + 8))(v54, v55);
  uint64_t v57 = v118;
  (*(void (**)(uint64_t *, uint64_t))(v49 + 64))(v18, v49);
  uint64_t v58 = v123;
  uint64_t v59 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(v123[2] + 8) + 8))(v53, v57, v18);
  unint64_t v60 = *(void (**)(char *, uint64_t *))(v125 + 8);
  v60(v57, v18);
  if (v59 & 1) != 0 && (v56)
  {
    v60(v53, v18);
    v113(v122, a3);
    return v101(v124, v102, a3);
  }
LABEL_10:
  (*(void (**)(char *, char *, uint64_t *))(v125 + 32))(v57, v53, v18);
  unint64_t v76 = v95;
  unint64_t v77 = v108;
  (*(void (**)(char *, uint64_t *, void *, uint64_t, uint64_t))(v95 + 72))(v57, v18, v58, a3, v95);
  uint64_t v78 = v103;
  (*(void (**)(uint64_t, uint64_t))(v76 + 144))(a3, v76);
  char v79 = AssociatedTypeWitness;
  uint64_t v80 = v111;
  uint64_t v81 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v82 = v109;
  (*(void (**)(void *, uint64_t, const char *, uint64_t))(v81 + 8))(&unk_18162B0D0, 768, v79, v81);
  uint64_t v83 = v104;
  ((void (*)(char *, uint64_t, int **))v80[3])(v82, a3, v80);
  uint64_t v84 = v113;
  uint64_t v85 = v106;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v76 + 192))(v78, v83, a3, v76);
  v84(v83, a3);
  v84(v78, a3);
  uint64_t v86 = v96;
  uint64_t v87 = *(void (**)(char *, char *, uint64_t, uint64_t))(v96 + 64);
  unint64_t v88 = v107;
  v87(v77, v85, a3, v96);
  v84(v85, a3);
  v84(v77, a3);
  uint64_t v89 = v122;
  v87(v122, v88, a3, v86);
  v84(v88, a3);
  v84(v89, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v105 + 24))(v77, v112, a3);
  return ((uint64_t (*)(char *, uint64_t))v84)(v77, a3);
}

uint64_t static BinaryFloatingPoint<>.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5);
}

{
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5);
}

uint64_t Int128._value.setter(uint64_t result, uint64_t a2)
{
  *unint64_t v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*Int128._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int128._high.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t static Int128.zero.getter()
{
  return 0;
}

uint64_t static Int128.min.getter()
{
  return 0;
}

uint64_t static Int128.max.getter()
{
  return -1;
}

uint64_t Int128.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x80) {
    return *(void *)a1;
  }
  else {
    return 0;
  }
}

uint64_t Int128.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v110 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v108 = (char *)&v108 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  uint64_t v111 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v108 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v108 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v115 = (char *)&v108 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v117 = (char *)&v108 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v118 = (char *)&v108 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  size_t v123 = (char *)&v108 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v108 - v23;
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (char *)&v108 - v26;
  v126[0] = 64;
  uint64_t v28 = *(void (**)(uint64_t, void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v25, v29, v30);
  uint64_t v120 = (char *)a1;
  v28(a1, v126, &type metadata for Int, v31, a2, a3);
  uint64_t v121 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  uint64_t v122 = a3 + 64;
  LOBYTE(a1) = v121(a2, a3);
  uint64_t v32 = (uint64_t (*)(uint64_t, uint64_t))(v8 + 16);
  uint64_t v33 = v27;
  uint64_t v34 = v27;
  uint64_t v35 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  v35(v24, v34, a2);
  uint64_t v112 = v13;
  BOOL v36 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v113 = v8;
  uint64_t v37 = v8 + 8;
  uint64_t v38 = v24;
  uint64_t v39 = *(void (**)(char *, uint64_t))(v8 + 8);
  v39(v38, a2);
  uint64_t v40 = v123;
  v35(v123, v33, a2);
  uint64_t v124 = v39;
  uint64_t v116 = v35;
  if (!v36)
  {
    v39(v40, a2);
    unint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    goto LABEL_9;
  }
  v126[0] = 0x8000000000000000;
  uint64_t v41 = v121;
  if (v121(a2, a3))
  {
    unint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v44 = v123;
    uint64_t v45 = v42(a2, a3);
    if (v45 < 64)
    {
      uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v49 = v44;
      uint64_t v50 = a2;
LABEL_29:
      v39(v49, v50);
      if (v48 < v126[0]) {
        goto LABEL_38;
      }
      goto LABEL_9;
    }
    char v110 = *(int ***)(a3 + 96);
    unint64_t v81 = lazy protocol witness table accessor for type Int64 and conformance Int64(v45, v46, v47);
    uint64_t v111 = v42;
    uint64_t v82 = v118;
    ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v110)(v126, &type metadata for Int64, v81, a2, a3);
    uint64_t v39 = v124;
    char v78 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v44, v82, a2);
    uint64_t v83 = v82;
    unint64_t v42 = v111;
    v39(v83, a2);
    goto LABEL_24;
  }
  char v71 = v41(a2, a3);
  unint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v43 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
  uint64_t v72 = v42(a2, a3);
  if ((v71 & 1) == 0)
  {
    if (v72 >= 64)
    {
      v124(v123, a2);
      goto LABEL_9;
    }
    uint64_t v84 = v123;
    uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v49 = v84;
    uint64_t v50 = a2;
    uint64_t v39 = v124;
    goto LABEL_29;
  }
  if (v72 > 64)
  {
    uint64_t v75 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v76 = lazy protocol witness table accessor for type Int64 and conformance Int64(v72, v73, v74);
    v75(v126, &type metadata for Int64, v76, a2, a3);
    uint64_t v44 = v123;
    unint64_t v77 = v118;
    char v78 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v123, v118, a2);
    char v79 = v77;
    uint64_t v39 = v124;
    v124(v79, a2);
LABEL_24:
    v39(v44, a2);
    if (v78) {
      goto LABEL_38;
    }
    goto LABEL_9;
  }
  uint64_t v95 = AssociatedTypeWitness;
  uint64_t v96 = v110;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v98 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v95, AssociatedConformanceWitness);
  uint64_t v99 = v96;
  uint64_t v100 = v96[3];
  uint64_t v101 = v118;
  ((void (*)(char *, uint64_t, int **))v100)(v98, a2, v99);
  LOBYTE(v95) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v123, v101, a2);
  unint64_t v102 = v101;
  uint64_t v39 = v124;
  v124(v102, a2);
  uint64_t v103 = (char *)v111;
  (*(void (**)(void))(v113 + 32))();
  if (v95)
  {
    v39(v103, a2);
    goto LABEL_38;
  }
  uint64_t v104 = v126[0];
  uint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v124(v103, a2);
  BOOL v106 = v105 < v104;
  uint64_t v39 = v124;
  if (v106) {
    goto LABEL_38;
  }
LABEL_9:
  uint64_t v51 = v42(a2, a3);
  uint64_t v52 = v117;
  uint64_t v53 = a3;
  uint64_t v54 = v42;
  uint64_t v55 = v116;
  v116(v117, v33, a2);
  uint64_t v114 = v37;
  uint64_t v119 = v33;
  if (v51 < 65)
  {
    uint64_t v111 = v32;
    uint64_t v59 = v54(a2, v53);
    v124(v52, a2);
    if (v59 == 64)
    {
      size_t v123 = (char *)v43;
      unint64_t v56 = v54;
      char v60 = v121(a2, v53);
      uint64_t v57 = v115;
      v55(v115, v119, a2);
      uint64_t v58 = v53;
      if ((v60 & 1) == 0) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v57 = v115;
      v55(v115, v119, a2);
      uint64_t v58 = v53;
    }
    uint64_t v39 = v124;
    v124(v57, a2);
    uint64_t v33 = v119;
    goto LABEL_33;
  }
  size_t v123 = (char *)v43;
  unint64_t v56 = v54;
  v124(v52, a2);
  uint64_t v57 = v115;
  v55(v115, v33, a2);
  uint64_t v58 = v53;
LABEL_13:
  v126[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v61 = v121(a2, v58);
  uint64_t v62 = v56(a2, v58);
  if (v61)
  {
    uint64_t v33 = v119;
    if (v62 > 64)
    {
      uint64_t v65 = v57;
      uint64_t v66 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v58 + 96);
      unint64_t v67 = lazy protocol witness table accessor for type Int64 and conformance Int64(v62, v63, v64);
      unint64_t v68 = v118;
      v66(v126, &type metadata for Int64, v67, a2, v58);
      char v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v58 + 32) + 8) + 16))(v68, v65, a2);
      uint64_t v39 = v124;
      v124(v68, a2);
      uint64_t v70 = v65;
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v33 = v119;
    if (v62 > 63)
    {
      uint64_t v125 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v85 = v118;
      uint64_t v86 = (*(uint64_t (**)(char *, char *, uint64_t))(v113 + 32))(v118, v57, a2);
      uint64_t v87 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v58 + 96);
      unint64_t v90 = lazy protocol witness table accessor for type Int64 and conformance Int64(v86, v88, v89);
      char v91 = v112;
      v87(&v125, &type metadata for Int64, v90, a2, v58);
      char v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v58 + 32) + 8) + 16))(v91, v85, a2);
      uint64_t v39 = v124;
      v124(v91, a2);
      uint64_t v70 = v85;
LABEL_32:
      v39(v70, a2);
      if ((v69 & 1) == 0) {
        goto LABEL_33;
      }
LABEL_38:
      v39(v33, a2);
      uint64_t v94 = 0;
      uint64_t v93 = v120;
      goto LABEL_39;
    }
  }
  uint64_t v80 = v118;
  (*(void (**)(char *, char *, uint64_t))(v113 + 32))(v118, v57, a2);
  (*(void (**)(uint64_t, uint64_t))(v58 + 120))(a2, v58);
  uint64_t v39 = v124;
  v124(v80, a2);
LABEL_33:
  unint64_t v92 = *(void (**)(uint64_t, uint64_t))(v58 + 120);
  v92(a2, v58);
  v39(v33, a2);
  uint64_t v93 = v120;
  uint64_t v94 = ((uint64_t (*)(uint64_t, uint64_t))v92)(a2, v58);
LABEL_39:
  v39(v93, a2);
  return v94;
}

uint64_t Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized Int128.init<A>(_:));
}

{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized Int128.init<A>(_:));
}

uint64_t Int128.init<A>(clamping:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  uint64_t v9 = Int128.init<A>(exactly:)((uint64_t)v8, a2, a3);
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)(*(void *)(a3 + 24) + 8) + 16))(a2);
    char v12 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(a1, v8, a2);
    uint64_t v13 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
    v13(a1, a2);
    v13((uint64_t)v8, a2);
    if (v12) {
      return 0;
    }
    else {
      return -1;
    }
  }
  else
  {
    uint64_t v11 = v9;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }
  return v11;
}

uint64_t UInt128.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = specialized UInt128.init<A>(truncatingIfNeeded:)(a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v5;
}

uint64_t *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int128@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 8 <= 0x80)
  {
    uint64_t v3 = *result;
    if (a2 >> 8 > 0x40)
    {
      uint64_t v4 = result[1];
      *a3 = v3;
      a3[1] = v4;
    }
    else
    {
      *(_OWORD *)a3 = v3;
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t Int128.init<A>(exactly:)(char *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v77 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(*(void *)(v77 + 16) + 8);
  uint64_t v64 = *(int ***)(v6 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v64, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v61 = (char *)&v58 - v7;
  unint64_t v76 = a3;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  char v12 = (char *)&v58 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v10);
  uint64_t v63 = (char *)&v58 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v74 = (char *)&v58 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v58 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v58 - v21;
  uint64_t v23 = *(void (**)(uint64_t, char *, uint64_t))(v6 + 56);
  char v78 = a1;
  uint64_t v75 = v6;
  uint64_t v65 = v23;
  ((void (*)(uint64_t, uint64_t))v23)(a2, v6);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
  uint64_t v25 = *(void (**)(double))(AssociatedConformanceWitness + 8);
  uint64_t v72 = v9;
  uint64_t v66 = AssociatedConformanceWitness;
  char v69 = v25;
  uint64_t v70 = AssociatedConformanceWitness + 8;
  ((void (*)(const char *, double))v25)(v9, 1.84467441e19);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 24);
  char v71 = v12;
  uint64_t v73 = v8;
  unint64_t v68 = v26;
  v26(v12, a2, v8);
  uint64_t v27 = *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(*(void *)(*(void *)(v77 + 24) + 8) + 16);
  uint64_t v60 = *(void *)(*(void *)(v77 + 24) + 8);
  uint64_t v59 = v27;
  LOBYTE(a1) = ((uint64_t (*)(char *, char *, uint64_t))v27)(v22, v20, a2);
  uint64_t v67 = v13;
  uint64_t v28 = *(void (**)(char *, uint64_t))(v13 + 8);
  v28(v20, a2);
  v28(v22, a2);
  if ((a1 & 1) == 0)
  {
    uint64_t v34 = v71;
    v69(5.42101086e-20);
    v68(v34, a2, v73);
    uint64_t v65 = *(void (**)(uint64_t, char *, uint64_t))(v75 + 64);
    v65((uint64_t)v78, v20, a2);
    v28(v20, a2);
    LOBYTE(v79) = 3;
    uint64_t v35 = v74;
    (*(void (**)(uint64_t *, uint64_t))(v77 + 304))(&v79, a2);
    v28(v22, a2);
    uint64_t v36 = (*(uint64_t (**)(char *, char *, uint64_t))(v67 + 16))(v22, v35, a2);
    unint64_t v39 = lazy protocol witness table accessor for type Int64 and conformance Int64(v36, v37, v38);
    FixedWidthInteger.init<A>(exactly:)((uint64_t)v22, (uint64_t)&type metadata for Int64, a2, v39, v76, (uint64_t)&v79);
    if (v80 == 1)
    {
      v28(v78, a2);
      v28(v74, a2);
    }
    else
    {
      uint64_t v46 = v28;
      uint64_t v77 = v79;
      uint64_t v47 = v71;
      v69(1.84467441e19);
      uint64_t v48 = v63;
      v68(v47, a2, v73);
      uint64_t v50 = v74;
      uint64_t v49 = v75;
      ((void (*)(char *, char *, uint64_t, uint64_t))v65)(v48, v74, a2, v75);
      v46(v48, a2);
      v46(v50, a2);
      uint64_t v51 = *(void (**)(uint64_t, char *, uint64_t))(*(void *)(v49 + 8) + 40);
      uint64_t v52 = v78;
      v51((uint64_t)v78, v20, a2);
      v46(v52, a2);
      uint64_t v53 = ((uint64_t (*)(char *, uint64_t))v46)(v20, a2);
      unint64_t v56 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v53, v54, v55);
      FixedWidthInteger.init<A>(exactly:)((uint64_t)v22, (uint64_t)&type metadata for UInt64, a2, v56, v76, (uint64_t)&v79);
      if (v80 != 1) {
        return v79;
      }
    }
    return 0;
  }
  uint64_t v29 = (void (*)(uint64_t, uint64_t))v28;
  uint64_t v30 = ((uint64_t (*)(uint64_t, uint64_t))v65)(a2, v75);
  unint64_t v33 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v30, v31, v32);
  FixedWidthInteger.init<A>(exactly:)((uint64_t)v22, (uint64_t)&type metadata for UInt64, a2, v33, v76, (uint64_t)&v79);
  if (v80 == 1)
  {
    v28(v78, a2);
    return 0;
  }
  uint64_t v40 = v79;
  uint64_t v41 = v64;
  unint64_t v42 = AssociatedTypeWitness;
  uint64_t v43 = swift_getAssociatedConformanceWitness((uint64_t)v64, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v44 = v61;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v43 + 8))(&qword_18162B0B8, 256, v42, v43);
  ((void (*)(char *, uint64_t, int **))v41[3])(v44, a2, v41);
  uint64_t v45 = v78;
  LOBYTE(v42) = v59((uint64_t)v78, v22, a2, v60);
  v29((uint64_t)v45, a2);
  v29((uint64_t)v22, a2);
  if (v42) {
    return -v40;
  }
  return v40;
}

uint64_t Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t v6 = a4();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v6;
}

BOOL static Int128.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Int128(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL static Int128.< infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return (__int128)__PAIR128__(a2, a1) < (__int128)__PAIR128__(a4, a3);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a2 < *a1;
}

void Int128.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
}

Swift::Int Int128.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Int128()
{
  return Int128.hashValue.getter(*v0, v0[1]);
}

uint64_t Int128.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t Int128.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 - a1;
}

uint64_t Int128.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (a1 ^ (a2 >> 63)) - (a2 >> 63);
  if ((a4 ^ a2) >= 0) {
    return ((a3 ^ (a4 >> 63)) - (a4 >> 63)) * v4;
  }
  else {
    return -(((a3 ^ (a4 >> 63)) - (a4 >> 63)) * v4);
  }
}

uint64_t Int128.magnitude.getter(uint64_t a1, uint64_t a2)
{
  return (a1 ^ (a2 >> 63)) - (a2 >> 63);
}

uint64_t UInt128.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a1;
}

uint64_t UInt128.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 9 <= 0x40 && (a2 & 1) == 0) {
    return *(void *)a1;
  }
  else {
    return 0;
  }
}

uint64_t Int128.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL && (a3 | a4 ^ 0x8000000000000000) == 0) {
    return 0;
  }
  else {
    return __divti3();
  }
}

uint64_t Int128.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  }
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL && (a3 | a4 ^ 0x8000000000000000) == 0) {
    return 0;
  }
  else {
    return __modti3();
  }
}

unint64_t static Int128.+ infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4 = __OFADD__(__CFADD__(a1, a3), a2);
  unsigned long long v6 = __PAIR128__(a2, a1) + a3;
  unint64_t result = a1 + a3;
  if (v4 | __OFADD__(a4, *((void *)&v6 + 1))) {
    char v7 = 1;
  }
  else {
    char v7 = 0;
  }
  if (v7) {
    __break(1u);
  }
  return result;
}

unint64_t static Int128.- infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL1 v4 = a1 >= a3;
  unint64_t result = a1 - a3;
  if (__OFSUB__(a2, a4, v4)) {
    __break(1u);
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  long long v3 = *(_OWORD *)result + *(_OWORD *)a2;
  if (__OFADD__(__CFADD__(*result, *a2), result[1]) | __OFADD__(a2[1], *((void *)&v3 + 1))) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int128(void *result, unint64_t *a2)
{
  unint64_t v2 = a2[1];
  long long v3 = *(_OWORD *)result + *a2;
  char v4 = __OFADD__(__CFADD__(*result, *a2), result[1]) | __OFADD__(v2, *((void *)&v3 + 1));
  unint64_t v5 = v2 + *((void *)&v3 + 1);
  if (v4) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if (v6)
  {
    __break(1u);
  }
  else
  {
    *unint64_t result = v3;
    result[1] = v5;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int128(_OWORD *result, _OWORD *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

uint64_t static Int128.* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned long long v4 = __PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
     - __PAIR128__(a2 >> 63, a2 >> 63);
  unsigned long long v5 = __PAIR128__(a4 ^ (unint64_t)(a4 >> 63), a3 ^ (unint64_t)(a4 >> 63))
     - __PAIR128__(a4 >> 63, a4 >> 63);
  if ((__PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
      - __PAIR128__(a2 >> 63, a2 >> 63)) >> 64)
    BOOL v6 = *((void *)&v5 + 1) == 0;
  else {
    BOOL v6 = 1;
  }
  char v9 = !v6
    || (((__PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
        - __PAIR128__(a2 >> 63, a2 >> 63)) >> 64)
      * ((a3 ^ (unint64_t)(a4 >> 63)) - (a4 >> 63))) >> 64 != 0
    || (((__PAIR128__(a4 ^ (unint64_t)(a4 >> 63), a3 ^ (unint64_t)(a4 >> 63))
        - __PAIR128__(a4 >> 63, a4 >> 63)) >> 64)
      * ((a1 ^ (unint64_t)(a2 >> 63)) - (a2 >> 63))) >> 64 != 0;
  if (__CFADD__(((unint64_t)v4 * (unsigned __int128)(unint64_t)v5) >> 64, *((void *)&v5 + 1) * v4 + *((void *)&v4 + 1) * v5))
  {
    char v10 = 1;
  }
  else
  {
    char v10 = v9;
  }
  uint64_t result = v4 * v5;
  if (((a4 ^ a2) & 0x8000000000000000) == 0)
  {
    if ((((v5 * v4) >> 64) & 0x8000000000000000) != 0) {
      char v12 = 1;
    }
    else {
      char v12 = v10;
    }
    if ((v12 & 1) == 0) {
      return result;
    }
LABEL_26:
    __break(1u);
    return result;
  }
  uint64_t result = -result;
  if (result) {
    char v13 = 1;
  }
  else {
    char v13 = v10;
  }
  if (v13) {
    goto LABEL_26;
  }
  return result;
}

uint64_t static Int128.*= infix(_:_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned long long v3 = abs128(*(_OWORD *)result);
  unsigned long long v4 = __PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (unint64_t)(a3 >> 63))
     - __PAIR128__(a3 >> 63, a3 >> 63);
  if (*((void *)&v3 + 1)) {
    BOOL v5 = *((void *)&v4 + 1) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)((a2 ^ (unint64_t)(a3 >> 63)) - (a3 >> 63))) >> 64 != 0
    || (((__PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (unint64_t)(a3 >> 63))
        - __PAIR128__(a3 >> 63, a3 >> 63)) >> 64)
      * (unint64_t)v3) >> 64 != 0;
  uint64_t v9 = (v4 * v3) >> 64;
  if (__CFADD__(((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64, *((void *)&v4 + 1) * v3 + *((void *)&v3 + 1) * v4))
  {
    char v8 = 1;
  }
  uint64_t v10 = v3 * v4;
  if (((*(void *)(result + 8) ^ a3) & 0x8000000000000000) == 0)
  {
    if (v8)
    {
      __break(1u);
      goto LABEL_24;
    }
    if ((v9 & 0x8000000000000000) == 0)
    {
LABEL_22:
      *(void *)uint64_t result = v10;
      *(void *)(result + 8) = v9;
      return result;
    }
    __break(1u);
  }
  if (v8)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  BOOL v11 = v10 == 0;
  uint64_t v10 = -v10;
  uint64_t v9 = -(v9 + !v11);
  if (!v10) {
    goto LABEL_22;
  }
LABEL_25:
  __break(1u);
  return result;
}

uint64_t static Int128./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  if (a1 | a2 ^ 0x8000000000000000 || (a3 & a4) != 0xFFFFFFFFFFFFFFFFLL) {
    return __divti3();
  }
  else {
    return 0;
  }
}

uint64_t static Int128./= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || v6 | v7 ^ 0x8000000000000000)
  {
    uint64_t result = __divti3();
  }
  else
  {
    uint64_t result = 0;
    unint64_t v10 = 0x8000000000000000;
  }
  *a1 = result;
  a1[1] = v10;
  return result;
}

uint64_t static Int128.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  }
  if (a1 | a2 ^ 0x8000000000000000 || (a3 & a4) != 0xFFFFFFFFFFFFFFFFLL) {
    return __modti3();
  }
  else {
    return 0;
  }
}

uint64_t static Int128.%= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  }
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || v6 | v7 ^ 0x8000000000000000)
  {
    uint64_t result = __modti3();
  }
  else
  {
    uint64_t result = 0;
    uint64_t v10 = 0;
  }
  *a1 = result;
  a1[1] = v10;
  return result;
}

uint64_t protocol witness for static SignedNumeric.- prefix(_:) in conformance Int128@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -*(_OWORD *)result >> 64;
  if (__OFSUB__(0, *(void *)(result + 8), *(void *)result == 0))
  {
    __break(1u);
  }
  else
  {
    *a2 = -*(void *)result;
    a2[1] = v2;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int128()
{
  uint64_t v1 = -*(_OWORD *)v0 >> 64;
  if (__OFSUB__(0, *(void *)(v0 + 8), *(void *)v0 == 0))
  {
    __break(1u);
  }
  else
  {
    *(void *)uint64_t v0 = -*(void *)v0;
    *(void *)(v0 + 8) = v1;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))Int128.init<A>(exactly:), a1);
}

void protocol witness for Numeric.magnitude.getter in conformance Int128(_OWORD *a1@<X8>)
{
  *a1 = abs128(*v1);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance Int128@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unsigned long long v3 = abs128(*(_OWORD *)result);
  unsigned long long v4 = abs128(*(_OWORD *)a2);
  if (*((void *)&v3 + 1)) {
    BOOL v5 = *((void *)&v4 + 1) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v4) >> 64 != 0
    || (*((unint64_t *)&v4 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0;
  uint64_t v9 = (v4 * v3) >> 64;
  if (__CFADD__(((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64, *((void *)&v4 + 1) * v3 + *((void *)&v3 + 1) * v4))
  {
    char v10 = 1;
  }
  else
  {
    char v10 = v8;
  }
  uint64_t v11 = v3 * v4;
  if (((*(void *)(a2 + 8) ^ *(void *)(result + 8)) & 0x8000000000000000) != 0)
  {
    BOOL v12 = v11 == 0;
    uint64_t v11 = -v11;
    uint64_t v9 = -(v9 + !v12);
    if (v11) {
      char v10 = 1;
    }
    if ((v10 & 1) == 0) {
      goto LABEL_20;
    }
  }
  else
  {
    if (v9 < 0) {
      char v10 = 1;
    }
    if ((v10 & 1) == 0)
    {
LABEL_20:
      *a3 = v11;
      a3[1] = v9;
      return result;
    }
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance Int128(uint64_t result, uint64_t a2)
{
  unsigned long long v2 = abs128(*(_OWORD *)result);
  unsigned long long v3 = abs128(*(_OWORD *)a2);
  if (*((void *)&v2 + 1)) {
    BOOL v4 = *((void *)&v3 + 1) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  char v7 = !v4
    || (*((unint64_t *)&v2 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v2) >> 64 != 0;
  uint64_t v8 = (v3 * v2) >> 64;
  if (__CFADD__(((unint64_t)v2 * (unsigned __int128)(unint64_t)v3) >> 64, *((void *)&v3 + 1) * v2 + *((void *)&v2 + 1) * v3))
  {
    char v9 = 1;
  }
  else
  {
    char v9 = v7;
  }
  uint64_t v10 = v2 * v3;
  if (((*(void *)(result + 8) ^ *(void *)(a2 + 8)) & 0x8000000000000000) == 0)
  {
    if (v9)
    {
      __break(1u);
      goto LABEL_24;
    }
    if ((v8 & 0x8000000000000000) == 0)
    {
LABEL_22:
      *(void *)uint64_t result = v10;
      *(void *)(result + 8) = v8;
      return result;
    }
    __break(1u);
  }
  if (v9)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  BOOL v11 = v10 == 0;
  uint64_t v10 = -v10;
  uint64_t v8 = -(v8 + !v11);
  if (!v10) {
    goto LABEL_22;
  }
LABEL_25:
  __break(1u);
  return result;
}

void *static Int128.&= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1] & a3;
  *result &= a2;
  result[1] = v3;
  return result;
}

void *static Int128.|= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1] | a3;
  *result |= a2;
  result[1] = v3;
  return result;
}

void *static Int128.^= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1] ^ a3;
  *result ^= a2;
  result[1] = v3;
  return result;
}

uint64_t *static Int128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = ((2 * v2) << ~a2) | ((unint64_t)*result >> a2);
  uint64_t v4 = v2 >> a2;
  if ((a2 & 0x40) != 0) {
    uint64_t v3 = v2 >> a2;
  }
  uint64_t v5 = v2 >> 63;
  if ((a2 & 0x40) == 0) {
    uint64_t v5 = v4;
  }
  *uint64_t result = v3;
  result[1] = v5;
  return result;
}

void *static Int128.&<<= infix(_:_:)(void *result, char a2)
{
  uint64_t v2 = (result[1] << a2) | (*result >> 1 >> ~a2);
  uint64_t v3 = *result << a2;
  if ((a2 & 0x40) != 0)
  {
    uint64_t v2 = *result << a2;
    uint64_t v3 = 0;
  }
  *uint64_t result = v3;
  result[1] = v2;
  return result;
}

unint64_t Int128.trailingZeroBitCount.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v2 = __clz(__rbit64(a1));
  unint64_t v3 = __clz(__rbit64(a2)) + 64;
  if (a1) {
    return v2;
  }
  else {
    return v3;
  }
}

unint64_t Int64.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

unint64_t UInt64.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))Int128.init<A>(exactly:), a1);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized Int128.init<A>(_:), a3);
}

{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized Int128.init<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(void)@<X5>, uint64_t *a4@<X8>)
{
  uint64_t v7 = a3();
  uint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = specialized UInt128.init<A>(truncatingIfNeeded:)(a1, a2, a3);
  uint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = Int128.init<A>(clamping:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

void protocol witness for BinaryInteger.words.getter in conformance Int128(void *a1@<X8>)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
}

uint64_t protocol witness for BinaryInteger.bitWidth.getter in conformance Int128()
{
  return 128;
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int128()
{
  unint64_t v1 = __clz(__rbit64(*v0));
  unint64_t v2 = __clz(__rbit64(v0[1])) + 64;
  if (*v0) {
    return v1;
  }
  else {
    return v2;
  }
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int128@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (*(_OWORD *)a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  if (*a1 | a1[1] ^ 0x8000000000000000) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1;
  }
  if (v4)
  {
    uint64_t result = 0;
    unint64_t v6 = 0x8000000000000000;
  }
  else
  {
    uint64_t result = __divti3();
  }
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  if ((*(void *)a2 & *(void *)(a2 + 8)) == -1 && (*a1 | a1[1] ^ 0x8000000000000000) == 0)
  {
    uint64_t result = 0;
    unint64_t v5 = 0x8000000000000000;
  }
  else
  {
    uint64_t result = __divti3();
  }
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int128@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (*(_OWORD *)a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  }
  if (*a1 | a1[1] ^ 0x8000000000000000) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1;
  }
  if (v4)
  {
    uint64_t result = 0;
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t result = __modti3();
  }
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  }
  if ((*(void *)a2 & *(void *)(a2 + 8)) == -1 && (*a1 | a1[1] ^ 0x8000000000000000) == 0)
  {
    uint64_t result = 0;
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t result = __modti3();
  }
  *a1 = result;
  a1[1] = v5;
  return result;
}

void *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = ~result[1];
  *a2 = ~*result;
  a2[1] = v2;
  return result;
}

void *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2[1] & result[1];
  *a3 = *a2 & *result;
  a3[1] = v3;
  return result;
}

void *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int128(void *result, void *a2)
{
  uint64_t v2 = result[1] & a2[1];
  *result &= *a2;
  result[1] = v2;
  return result;
}

void *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2[1] | result[1];
  *a3 = *a2 | *result;
  a3[1] = v3;
  return result;
}

void *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int128(void *result, void *a2)
{
  uint64_t v2 = result[1] | a2[1];
  *result |= *a2;
  result[1] = v2;
  return result;
}

void *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2[1] ^ result[1];
  *a3 = *a2 ^ *result;
  a3[1] = v3;
  return result;
}

void *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int128(void *result, void *a2)
{
  uint64_t v2 = result[1] ^ a2[1];
  *result ^= *a2;
  result[1] = v2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v126 = a5;
  uint64_t v118 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v118, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v116 = (char *)v113 - v10;
  BOOL v11 = *(void **)(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)v113 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v114 = (char *)v113 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  size_t v123 = (char *)v113 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v121 = (char *)v113 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v115 = (char *)v113 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v122 = (char *)v113 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v127 = (char *)v113 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v28 = (char *)v113 - v27;
  uint64_t v124 = a1[1];
  unint64_t v120 = *a1;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v129 = a4 + 64;
  unint64_t v130 = v29;
  if ((v29(a3, a4) & 1) == 0)
  {
    char v33 = v130(a3, a4);
    uint64_t v128 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v30 = v128(a3, a4);
    if ((v33 & 1) == 0)
    {
      if (v30 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v30 <= 64)
    {
      uint64_t v65 = AssociatedTypeWitness;
      uint64_t v66 = v118;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v118, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v68 = v116;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v65, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v66[3])(v68, a3, v66);
      LOBYTE(v65) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      char v69 = (void (*)(char *, uint64_t))v11[1];
      v69(v28, a3);
      uint64_t v125 = v11;
      ((void (*)(char *, uint64_t, uint64_t))v11[2])(v14, a2, a3);
      if (v65)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
        goto LABEL_26;
      }
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
      BOOL v11 = v125;
      if (v70 < -128) {
        goto LABEL_26;
      }
      goto LABEL_10;
    }
LABEL_6:
    v132[0] = -128;
    uint64_t v34 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v35 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v34(v132, &type metadata for Int, v35, a3, a4);
    char v36 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v11[1])(v28, a3);
    if (v36) {
      goto LABEL_26;
    }
    goto LABEL_10;
  }
  uint64_t v128 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v30 = v128(a3, a4);
  if (v30 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  ((void (*)(char *, uint64_t, uint64_t))v11[2])(v28, a2, a3);
  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v11[1])(v28, a3);
  if (v38 < -128) {
    goto LABEL_26;
  }
LABEL_10:
  char v39 = v130(a3, a4);
  uint64_t v119 = a4 + 128;
  uint64_t v40 = v128(a3, a4);
  if (v39)
  {
    if (v40 > 64) {
      goto LABEL_12;
    }
LABEL_15:
    ((void (*)(char *, uint64_t, uint64_t))v11[2])(v28, a2, a3);
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v125 = (void *)v11[1];
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v125)(v28, a3);
    if (v46 > 128) {
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  if (v40 <= 63) {
    goto LABEL_15;
  }
LABEL_12:
  v132[0] = 128;
  uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
  v43(v132, &type metadata for Int, v44, a3, a4);
  char v45 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
  uint64_t v125 = (void *)v11[1];
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v125)(v28, a3);
  if (v45) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v49 = v28;
  uint64_t v50 = (char *)(v11 + 2);
  uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v11[2];
  uint64_t v52 = v127;
  v51(v127, a2, a3);
  char v53 = v130(a3, a4);
  uint64_t v54 = v122;
  uint64_t v55 = v52;
  v113[1] = v50;
  unint64_t v56 = (void (*)(char *, char *, uint64_t))v51;
  v51(v122, (uint64_t)v55, a3);
  if ((v53 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v125)(v54, a3);
    uint64_t v58 = v49;
    goto LABEL_41;
  }
  uint64_t v57 = v128(a3, a4);
  ((void (*)(char *, uint64_t))v125)(v54, a3);
  uint64_t v58 = v49;
  if (v57 <= 64) {
    goto LABEL_41;
  }
  uint64_t v59 = v115;
  v56(v115, v127, a3);
  v132[0] = 0x8000000000000000;
  uint64_t v60 = v130;
  if (v130(a3, a4))
  {
    uint64_t v61 = v128(a3, a4);
    if (v61 < 64)
    {
      uint64_t v64 = v58;
LABEL_36:
      v56(v64, v59, a3);
      uint64_t v82 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      unint64_t v81 = (void (*)(char *, uint64_t))v125;
      ((void (*)(char *, uint64_t))v125)(v58, a3);
      if (v82 < v132[0]) {
LABEL_64:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_40;
    }
    char v78 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v79 = lazy protocol witness table accessor for type Int and conformance Int(v61, v62, v63);
    v78(v132, &type metadata for Int, v79, a3, a4);
    char v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v59, v58, a3);
    goto LABEL_31;
  }
  char v71 = v60(a3, a4);
  uint64_t v72 = v128(a3, a4);
  if ((v71 & 1) == 0)
  {
    if (v72 >= 64)
    {
      ((void (*)(char *, uint64_t))v125)(v115, a3);
      goto LABEL_41;
    }
    uint64_t v64 = v58;
    uint64_t v59 = v115;
    goto LABEL_36;
  }
  if (v72 > 64)
  {
    uint64_t v75 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
    v75(v132, &type metadata for Int, v76, a3, a4);
    uint64_t v59 = v115;
    char v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v115, v58, a3);
LABEL_31:
    char v80 = v77;
    unint64_t v81 = (void (*)(char *, uint64_t))v125;
    ((void (*)(char *, uint64_t))v125)(v58, a3);
    if (v80) {
      goto LABEL_64;
    }
    goto LABEL_40;
  }
  uint64_t v84 = AssociatedTypeWitness;
  uint64_t v83 = v118;
  uint64_t v85 = swift_getAssociatedConformanceWitness((uint64_t)v118, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v86 = v116;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v85 + 8))(&qword_18162B0B8, 256, v84, v85);
  ((void (*)(char *, uint64_t, int **))v83[3])(v86, a3, v83);
  uint64_t v87 = v115;
  char v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v115, v58, a3);
  unint64_t v81 = (void (*)(char *, uint64_t))v125;
  ((void (*)(char *, uint64_t))v125)(v58, a3);
  uint64_t v89 = v114;
  v56(v114, v87, a3);
  if (v88)
  {
    v81(v89, a3);
    goto LABEL_64;
  }
  uint64_t v90 = v132[0];
  uint64_t v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v89, a3);
  BOOL v92 = v91 < v90;
  uint64_t v59 = v115;
  if (v92) {
    goto LABEL_64;
  }
LABEL_40:
  v81(v59, a3);
LABEL_41:
  uint64_t v93 = v127;
  uint64_t v94 = v128;
  uint64_t v95 = v128(a3, a4);
  uint64_t v96 = v121;
  v56(v121, v93, a3);
  if (v95 < 65)
  {
    uint64_t v104 = v94(a3, a4);
    ((void (*)(char *, uint64_t))v125)(v96, a3);
    if (v104 != 64 || (v130(a3, a4) & 1) != 0) {
      goto LABEL_54;
    }
  }
  else
  {
    ((void (*)(char *, uint64_t))v125)(v96, a3);
  }
  v56(v123, v127, a3);
  v132[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v97 = v130(a3, a4);
  uint64_t v98 = v128(a3, a4);
  if ((v97 & 1) == 0)
  {
    if (v98 > 63)
    {
      uint64_t v131 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v101 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
      uint64_t v103 = &v131;
      goto LABEL_52;
    }
LABEL_50:
    uint64_t v105 = v123;
    v56(v58, v123, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL v106 = (void (*)(char *, uint64_t))v125;
    ((void (*)(char *, uint64_t))v125)(v58, a3);
    v106(v105, a3);
    goto LABEL_54;
  }
  if (v98 <= 64) {
    goto LABEL_50;
  }
  uint64_t v101 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
  uint64_t v103 = v132;
LABEL_52:
  v101(v103, &type metadata for Int, v102, a3, a4);
  char v107 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v58, v123, a3);
  ((void (*)(char *, uint64_t))v125)(v58, a3);
  if (v107) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  ((void (*)(char *, uint64_t))v125)(v123, a3);
LABEL_54:
  uint64_t v108 = v127;
  unint64_t v109 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v125)(v108, a3);
  if ((v109 & 0x8000000000000000) == 0)
  {
    if (v109 < 0x80)
    {
      uint64_t v47 = ((2 * v124) << ~(_BYTE)v109) | (v120 >> v109);
      uint64_t v48 = v124 >> v109;
      BOOL v110 = (v109 & 0x40) == 0;
      if ((v109 & 0x40) != 0) {
        uint64_t v47 = v124 >> v109;
      }
      uint64_t v111 = v124 >> 63;
      goto LABEL_59;
    }
LABEL_16:
    uint64_t v47 = v124 >> 63;
    uint64_t v48 = v124 >> 63;
    goto LABEL_61;
  }
  if (v109 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_26:
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    goto LABEL_61;
  }
  uint64_t v111 = v120 << -(char)v109;
  BOOL v110 = (-(uint64_t)v109 & 0x40) == 0;
  if ((-(uint64_t)v109 & 0x40) != 0) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = v120 << -(char)v109;
  }
  uint64_t v48 = (v124 << -(char)v109) | (v120 >> 1 >> (v109 - 1));
LABEL_59:
  if (!v110) {
    uint64_t v48 = v111;
  }
LABEL_61:
  uint64_t v112 = v126;
  *uint64_t v126 = v47;
  v112[1] = v48;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v125 = a1;
  uint64_t v117 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v117, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v115 = (char *)&v111 - v8;
  uint64_t v127 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  BOOL v11 = (char *)&v111 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v114 = (char *)&v111 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v121 = (char *)&v111 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v119 = (char *)&v111 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v111 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  unint64_t v120 = (char *)&v111 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  size_t v123 = (char *)&v111 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v111 - v25;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v126 = a4 + 64;
  if ((v27(a3, a4) & 1) == 0)
  {
    char v31 = v27(a3, a4);
    uint64_t v124 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v28 = v124(a3, a4);
    if ((v31 & 1) == 0)
    {
      if (v28 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v28 <= 64)
    {
      uint64_t v111 = v20;
      uint64_t v112 = v27;
      uint64_t v62 = AssociatedTypeWitness;
      uint64_t v61 = v117;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v117, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v64 = v115;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v62, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v61[3])(v64, a3, v61);
      LOBYTE(v62) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v65 = v127;
      uint64_t v66 = *(void (**)(char *, uint64_t))(v127 + 8);
      v66(v26, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v65 + 16))(v11, a2, a3);
      if (v62)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v66)(v11, a3);
        goto LABEL_26;
      }
      uint64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v66)(v11, a3);
      uint64_t v20 = v111;
      uint64_t v27 = v112;
      if (v67 < -128) {
        goto LABEL_26;
      }
      goto LABEL_10;
    }
LABEL_6:
    v129[0] = -128;
    uint64_t v32 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
    v32(v129, &type metadata for Int, v33, a3, a4);
    char v34 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v127 + 8))(v26, a3);
    if (v34) {
      goto LABEL_26;
    }
    goto LABEL_10;
  }
  uint64_t v124 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v28 = v124(a3, a4);
  if (v28 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  uint64_t v36 = v127;
  (*(void (**)(char *, uint64_t, uint64_t))(v127 + 16))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v36 + 8))(v26, a3);
  if (v37 < -128) {
    goto LABEL_26;
  }
LABEL_10:
  char v38 = v27(a3, a4);
  uint64_t v118 = a4 + 128;
  uint64_t v39 = v124(a3, a4);
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
  }
  else if (v39 >= 64)
  {
LABEL_12:
    v129[0] = 128;
    uint64_t v42 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
    v42(v129, &type metadata for Int, v43, a3, a4);
    char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    uint64_t v45 = v127;
    uint64_t v122 = *(uint64_t (**)(char *, uint64_t))(v127 + 8);
    uint64_t result = v122(v26, a3);
    if ((v44 & 1) == 0) {
      goto LABEL_13;
    }
LABEL_20:
    uint64_t v58 = v125[1];
    goto LABEL_21;
  }
  uint64_t v45 = v127;
  (*(void (**)(char *, uint64_t, uint64_t))(v127 + 16))(v26, a2, a3);
  uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v122 = *(uint64_t (**)(char *, uint64_t))(v45 + 8);
  uint64_t result = v122(v26, a3);
  if (v57 > 128) {
    goto LABEL_20;
  }
LABEL_13:
  uint64_t v111 = v20;
  uint64_t v46 = *(void (**)(char *, uint64_t, uint64_t))(v45 + 16);
  uint64_t v47 = v123;
  v46(v123, a2, a3);
  char v48 = v27(a3, a4);
  uint64_t v49 = v120;
  uint64_t v113 = (void (*)(char *, char *, uint64_t))v46;
  v46(v120, (uint64_t)v47, a3);
  uint64_t v112 = v27;
  if ((v48 & 1) == 0)
  {
    v122(v49, a3);
    goto LABEL_41;
  }
  uint64_t v50 = v124(a3, a4);
  v122(v49, a3);
  if (v50 <= 64) {
    goto LABEL_41;
  }
  uint64_t v51 = v111;
  v113(v111, v123, a3);
  v129[0] = 0x8000000000000000;
  uint64_t v52 = v112;
  if (v112(a3, a4))
  {
    uint64_t v53 = v124(a3, a4);
    if (v53 < 64)
    {
      unint64_t v56 = v26;
LABEL_36:
      v113(v56, v51, a3);
      uint64_t v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      char v78 = (void (*)(char *, uint64_t))v122;
      v122(v26, a3);
      if (v79 < v129[0]) {
LABEL_63:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_40;
    }
    uint64_t v75 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    v75(v129, &type metadata for Int, v76, a3, a4);
    char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v51, v26, a3);
    goto LABEL_31;
  }
  char v68 = v52(a3, a4);
  uint64_t v69 = v124(a3, a4);
  if ((v68 & 1) == 0)
  {
    if (v69 >= 64)
    {
      v122(v111, a3);
      goto LABEL_41;
    }
    unint64_t v56 = v26;
    uint64_t v51 = v111;
    goto LABEL_36;
  }
  if (v69 > 64)
  {
    uint64_t v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v69, v70, v71);
    v72(v129, &type metadata for Int, v73, a3, a4);
    uint64_t v51 = v111;
    char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v111, v26, a3);
LABEL_31:
    char v77 = v74;
    char v78 = (void (*)(char *, uint64_t))v122;
    v122(v26, a3);
    if (v77) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
  unint64_t v81 = AssociatedTypeWitness;
  char v80 = v117;
  uint64_t v82 = swift_getAssociatedConformanceWitness((uint64_t)v117, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v83 = v115;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v82 + 8))(&qword_18162B0B8, 256, v81, v82);
  ((void (*)(char *, uint64_t, int **))v80[3])(v83, a3, v80);
  uint64_t v84 = v111;
  char v85 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v111, v26, a3);
  char v78 = (void (*)(char *, uint64_t))v122;
  v122(v26, a3);
  uint64_t v86 = v114;
  v113(v114, v84, a3);
  if (v85)
  {
    v78(v86, a3);
    goto LABEL_63;
  }
  uint64_t v87 = v129[0];
  uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v78(v86, a3);
  BOOL v89 = v88 < v87;
  uint64_t v51 = v111;
  if (v89) {
    goto LABEL_63;
  }
LABEL_40:
  v78(v51, a3);
LABEL_41:
  uint64_t v90 = v123;
  uint64_t v91 = v124;
  uint64_t v92 = v124(a3, a4);
  uint64_t v93 = v119;
  v113(v119, v90, a3);
  if (v92 < 65)
  {
    uint64_t v102 = v91(a3, a4);
    v122(v93, a3);
    if (v102 != 64) {
      goto LABEL_54;
    }
    uint64_t v94 = v112;
    if (v112(a3, a4)) {
      goto LABEL_54;
    }
  }
  else
  {
    v122(v93, a3);
    uint64_t v94 = v112;
  }
  v113(v121, v123, a3);
  v129[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v95 = v94(a3, a4);
  uint64_t v96 = v124(a3, a4);
  if ((v95 & 1) == 0)
  {
    if (v96 >= 64)
    {
      uint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v99 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
      uint64_t v101 = &v128;
      goto LABEL_52;
    }
LABEL_51:
    uint64_t v103 = v121;
    v113(v26, v121, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v104 = (void (*)(char *, uint64_t))v122;
    v122(v26, a3);
    v104(v103, a3);
    goto LABEL_54;
  }
  if (v96 <= 64) {
    goto LABEL_51;
  }
  uint64_t v99 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
  uint64_t v101 = v129;
LABEL_52:
  v99(v101, &type metadata for Int, v100, a3, a4);
  char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, v121, a3);
  v122(v26, a3);
  if (v105) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v122(v121, a3);
LABEL_54:
  BOOL v106 = v123;
  unint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v122(v106, a3);
  unint64_t v108 = *v125;
  uint64_t v58 = v125[1];
  if ((v107 & 0x8000000000000000) == 0)
  {
    if (v107 < 0x80)
    {
      uint64_t v59 = ((2 * v58) << ~(_BYTE)v107) | (v108 >> v107);
      uint64_t v109 = v58 >> v107;
      if ((v107 & 0x40) != 0) {
        uint64_t v59 = v58 >> v107;
      }
      uint64_t v60 = v58 >> 63;
      if ((v107 & 0x40) == 0) {
        uint64_t v60 = v109;
      }
      goto LABEL_60;
    }
LABEL_21:
    uint64_t v59 = v58 >> 63;
    uint64_t v60 = v58 >> 63;
    goto LABEL_60;
  }
  if (v107 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_26:
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    goto LABEL_60;
  }
  if ((-(uint64_t)v107 & 0x40) != 0) {
    uint64_t v59 = 0;
  }
  else {
    uint64_t v59 = v108 << -(char)v107;
  }
  uint64_t v60 = (v58 << -(char)v107) | (v108 >> 1 >> (v107 - 1));
  if ((-(uint64_t)v107 & 0x40) != 0) {
    uint64_t v60 = v108 << -(char)v107;
  }
LABEL_60:
  BOOL v110 = v125;
  *uint64_t v125 = v59;
  v110[1] = v60;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int128@<X0>(unint64_t *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v137 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v135 = (char *)&v126 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v126 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v132 = (char *)&v126 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v139 = (char *)&v126 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v126 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v133 = (char *)&v126 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  Swift::String::Index v140 = (char *)&v126 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v144 = (char *)&v126 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)&v126 - v29;
  uint64_t v142 = a1[1];
  unint64_t v138 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v146 = a4 + 64;
  char v32 = v31(a3, a4);
  uint64_t v143 = a5;
  if (v32)
  {
    unint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v148[0] = -128;
      unint64_t v145 = v33;
      uint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v47(v148, &type metadata for Int, v48, a3, a4);
      unint64_t v33 = v145;
      char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(a2, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v49) {
        goto LABEL_30;
      }
    }
    else
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 < -128) {
        goto LABEL_30;
      }
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    Swift::String::Index v141 = a2;
    unint64_t v145 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      uint64_t v134 = v31;
      if (v41 <= 64)
      {
        uint64_t v51 = AssociatedTypeWitness;
        uint64_t v52 = v137;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v135;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v141;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v141, v30, a3);
        uint64_t v56 = v12;
        uint64_t v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v131 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          goto LABEL_30;
        }
        uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        uint64_t v12 = v131;
        char v31 = v134;
        unint64_t v33 = v145;
        a2 = v141;
        if (v90 < -128) {
          goto LABEL_30;
        }
      }
      else
      {
        v148[0] = -128;
        char v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        v44(v148, &type metadata for Int, v45, a3, a4);
        a2 = v141;
        char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                  + 16))(v141, v30, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
        char v31 = v134;
        unint64_t v33 = v145;
        if (v46) {
          goto LABEL_30;
        }
      }
    }
    else if (v41 >= 64)
    {
      unint64_t v33 = v145;
      a2 = v141;
    }
    else
    {
      a2 = v141;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v141, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      unint64_t v33 = v145;
      if (v50 < -128) {
        goto LABEL_30;
      }
    }
  }
  char v58 = v31(a3, a4);
  uint64_t v59 = a4 + 128;
  uint64_t v60 = (uint64_t (*)(uint64_t, uint64_t))a4;
  uint64_t v61 = (char *)a2;
  uint64_t v62 = v59;
  uint64_t v134 = v60;
  uint64_t v63 = ((uint64_t (*)(uint64_t))v33)(a3);
  uint64_t v127 = v22;
  uint64_t v128 = v62;
  if (v58)
  {
    if (v63 > 64) {
      goto LABEL_19;
    }
  }
  else if (v63 > 63)
  {
LABEL_19:
    v148[0] = 128;
    uint64_t v66 = v134;
    uint64_t v67 = v31;
    char v68 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v134 + 12);
    unint64_t v69 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68(v148, &type metadata for Int, v69, a3, (uint64_t (**)(uint64_t, void))v66);
    char v31 = v67;
    uint64_t v70 = v61;
    uint64_t v71 = v66;
    char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v66 + 4) + 8) + 16))(v30, v70, a3);
    unint64_t v73 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v73(v30, a3);
    if ((v72 & 1) == 0) {
      goto LABEL_20;
    }
LABEL_27:
    uint64_t v87 = 0;
    uint64_t v88 = 0;
    BOOL v89 = v143;
    goto LABEL_61;
  }
  uint64_t v70 = v61;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v61, a3);
  uint64_t v71 = v134;
  uint64_t v86 = (*((uint64_t (**)(uint64_t, void))v134 + 15))(a3, v134);
  unint64_t v73 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v73(v30, a3);
  if (v86 > 128) {
    goto LABEL_27;
  }
LABEL_20:
  Swift::String::Index v141 = v73;
  unint64_t v145 = v33;
  char v74 = v31;
  uint64_t v76 = v12 + 16;
  uint64_t v75 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v77 = v12;
  char v78 = v144;
  v75(v144, v70, a3);
  uint64_t v79 = v74;
  LOBYTE(v74) = v74(a3, (uint64_t)v71);
  char v80 = v140;
  uint64_t v129 = v75;
  uint64_t v130 = v76;
  v75(v140, v78, a3);
  uint64_t v131 = v77;
  if ((v74 & 1) == 0)
  {
    v141(v80, a3);
    goto LABEL_44;
  }
  uint64_t v81 = v145(a3, (uint64_t)v71);
  v141(v80, a3);
  if (v81 <= 64) {
    goto LABEL_44;
  }
  uint64_t v82 = v133;
  v129(v133, v144, a3);
  v148[0] = 0x8000000000000000;
  if (v79(a3, (uint64_t)v71))
  {
    uint64_t v83 = v145(a3, (uint64_t)v71);
    if (v83 < 64)
    {
LABEL_37:
      v129(v30, v82, a3);
      uint64_t v96 = (*((uint64_t (**)(uint64_t, void))v71 + 15))(a3, v71);
      char v95 = (void (*)(char *, uint64_t))v141;
      v141(v30, a3);
      if (v96 < v148[0]) {
        goto LABEL_64;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v91 = v79(a3, (uint64_t)v71);
    uint64_t v83 = v145(a3, (uint64_t)v71);
    if ((v91 & 1) == 0)
    {
      if (v83 >= 64)
      {
        v141(v82, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v83 <= 64)
    {
      uint64_t v134 = v79;
      uint64_t v98 = AssociatedTypeWitness;
      uint64_t v97 = v137;
      uint64_t v99 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v100 = v135;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v99 + 8))(&qword_18162B0B8, 256, v98, v99);
      ((void (*)(char *, uint64_t, int **))v97[3])(v100, a3, v97);
      uint64_t v101 = v133;
      char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v71 + 4) + 8) + 16))(v133, v30, a3);
      uint64_t v103 = (void (*)(char *, uint64_t))v141;
      v141(v30, a3);
      uint64_t v104 = v132;
      v129(v132, v101, a3);
      if (v102)
      {
        v103(v104, a3);
        goto LABEL_64;
      }
      uint64_t v105 = v148[0];
      uint64_t v106 = (*((uint64_t (**)(uint64_t, void))v71 + 15))(a3, v71);
      v103(v104, a3);
      BOOL v107 = v106 < v105;
      uint64_t v82 = v133;
      uint64_t v79 = v134;
      char v95 = v103;
      if (v107) {
LABEL_64:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  uint64_t v92 = (uint64_t (*)(uint64_t, void))*((void *)v71 + 12);
  unint64_t v93 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v92)(v148, &type metadata for Int, v93, a3, v134);
  uint64_t v82 = v133;
  uint64_t v71 = v134;
  char v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v134 + 4) + 8) + 16))(v133, v30, a3);
  char v95 = (void (*)(char *, uint64_t))v141;
  v141(v30, a3);
  if (v94) {
    goto LABEL_64;
  }
LABEL_43:
  v95(v82, a3);
LABEL_44:
  unint64_t v108 = v144;
  uint64_t v109 = v145;
  uint64_t v110 = v145(a3, (uint64_t)v71);
  uint64_t v111 = v127;
  v129(v127, v108, a3);
  if (v110 < 65)
  {
    uint64_t v120 = v109(a3, (uint64_t)v71);
    v141(v111, a3);
    uint64_t v112 = v139;
    if (v120 != 64 || (v79(a3, (uint64_t)v71) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v141(v111, a3);
    uint64_t v112 = v139;
  }
  v129(v112, v144, a3);
  v148[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v113 = v79(a3, (uint64_t)v71);
  uint64_t v114 = v145(a3, (uint64_t)v71);
  if ((v113 & 1) == 0)
  {
    if (v114 > 63)
    {
      uint64_t v147 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v117 = (uint64_t (*)(uint64_t, void))*((void *)v71 + 12);
      unint64_t v118 = lazy protocol witness table accessor for type Int and conformance Int(v114, v115, v116);
      uint64_t v119 = &v147;
      goto LABEL_55;
    }
LABEL_53:
    v129(v30, v112, a3);
    (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v71 + 15))(a3, v71);
    uint64_t v121 = (void (*)(char *, uint64_t))v141;
    v141(v30, a3);
    v121(v112, a3);
    goto LABEL_57;
  }
  if (v114 <= 64) {
    goto LABEL_53;
  }
  uint64_t v117 = (uint64_t (*)(uint64_t, void))*((void *)v71 + 12);
  unint64_t v118 = lazy protocol witness table accessor for type Int and conformance Int(v114, v115, v116);
  uint64_t v119 = v148;
LABEL_55:
  ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v117)(v119, &type metadata for Int, v118, a3, v71);
  char v122 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v71 + 4) + 8) + 16))(v30, v112, a3);
  size_t v123 = (void (*)(char *, uint64_t))v141;
  v141(v30, a3);
  if (v122) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v123(v112, a3);
LABEL_57:
  uint64_t v124 = v144;
  unint64_t v125 = (*((uint64_t (**)(uint64_t, void))v71 + 15))(a3, v71);
  uint64_t result = v141(v124, a3);
  if ((v125 & 0x8000000000000000) == 0)
  {
    BOOL v89 = v143;
    if (v125 >= 0x80)
    {
      uint64_t v87 = 0;
      uint64_t v88 = 0;
    }
    else
    {
      uint64_t v88 = (v142 << v125) | (v138 >> 1 >> ~(_BYTE)v125);
      uint64_t v87 = v138 << v125;
      if ((v125 & 0x40) != 0)
      {
        uint64_t v88 = v138 << v125;
        uint64_t v87 = 0;
      }
    }
    goto LABEL_61;
  }
  if (v125 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_30:
    BOOL v89 = v143;
    uint64_t v87 = v142 >> 63;
    uint64_t v88 = v142 >> 63;
    goto LABEL_61;
  }
  uint64_t v88 = v142 >> 63;
  if ((-(uint64_t)v125 & 0x40) == 0) {
    uint64_t v88 = v142 >> -(char)v125;
  }
  uint64_t v87 = ((2 * v142) << (v125 - 1)) | (v138 >> -(char)v125);
  if ((-(uint64_t)v125 & 0x40) != 0) {
    uint64_t v87 = v142 >> -(char)v125;
  }
  BOOL v89 = v143;
LABEL_61:
  *BOOL v89 = v87;
  v89[1] = v88;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v124 = a1;
  uint64_t v115 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v113 = (char *)&v109 - v8;
  uint64_t v125 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v109 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v112 = (char *)&v109 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v119 = (char *)&v109 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v117 = (char *)&v109 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v109 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  unint64_t v118 = (char *)&v109 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v121 = (char *)&v109 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v109 - v25;
  size_t v123 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if (v123(a3, a4))
  {
    char v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v27 = v122(a3, a4);
    if (v27 < 64) {
      goto LABEL_9;
    }
    goto LABEL_6;
  }
  char v30 = v123(a3, a4);
  char v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v27 = v122(a3, a4);
  if ((v30 & 1) == 0)
  {
    if (v27 >= 64) {
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v35 = v125;
    (*(void (**)(char *, uint64_t, uint64_t))(v125 + 16))(v26, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v35 + 8))(v26, a3);
    if (v36 >= -128) {
      goto LABEL_10;
    }
LABEL_26:
    uint64_t v66 = v124[1];
    goto LABEL_27;
  }
  if (v27 > 64)
  {
LABEL_6:
    v127[0] = -128;
    char v31 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v32 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    v31(v127, &type metadata for Int, v32, a3, a4);
    char v33 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v125 + 8))(v26, a3);
    if ((v33 & 1) == 0) {
      goto LABEL_10;
    }
    goto LABEL_26;
  }
  uint64_t v109 = v20;
  uint64_t v59 = AssociatedTypeWitness;
  uint64_t v60 = v115;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v62 = v113;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v59, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t, int **))v60[3])(v62, a3, v60);
  LOBYTE(v59) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
  uint64_t v63 = v125;
  uint64_t v64 = *(void (**)(char *, uint64_t))(v125 + 8);
  v64(v26, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v63 + 16))(v11, a2, a3);
  if (v59)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v11, a3);
    goto LABEL_26;
  }
  uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v11, a3);
  uint64_t v20 = v109;
  if (v65 < -128) {
    goto LABEL_26;
  }
LABEL_10:
  char v37 = v123(a3, a4);
  uint64_t v116 = a4 + 128;
  uint64_t v38 = v122(a3, a4);
  if (v37)
  {
    if (v38 > 64) {
      goto LABEL_12;
    }
LABEL_15:
    uint64_t v44 = v125;
    (*(void (**)(char *, uint64_t, uint64_t))(v125 + 16))(v26, a2, a3);
    uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v120 = *(uint64_t (**)(char *, uint64_t))(v44 + 8);
    uint64_t result = v120(v26, a3);
    if (v45 > 128) {
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  if (v38 < 64) {
    goto LABEL_15;
  }
LABEL_12:
  v127[0] = 128;
  uint64_t v41 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v42 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
  v41(v127, &type metadata for Int, v42, a3, a4);
  char v43 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
  uint64_t v44 = v125;
  uint64_t v120 = *(uint64_t (**)(char *, uint64_t))(v125 + 8);
  uint64_t result = v120(v26, a3);
  if (v43) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v109 = v20;
  unint64_t v48 = *(void (**)(char *, uint64_t, uint64_t))(v44 + 16);
  char v49 = v121;
  v48(v121, a2, a3);
  char v50 = v123(a3, a4);
  uint64_t v51 = v118;
  uint64_t v110 = (void (*)(char *, char *, uint64_t))v48;
  uint64_t v111 = v44 + 16;
  v48(v118, (uint64_t)v49, a3);
  if ((v50 & 1) == 0)
  {
    v120(v51, a3);
    goto LABEL_42;
  }
  uint64_t v52 = v122(a3, a4);
  v120(v51, a3);
  if (v52 <= 64) {
    goto LABEL_42;
  }
  uint64_t v53 = v109;
  v110(v109, v121, a3);
  v127[0] = 0x8000000000000000;
  uint64_t v54 = v123;
  if (v123(a3, a4))
  {
    uint64_t v55 = v122(a3, a4);
    if (v55 < 64)
    {
      char v58 = v26;
LABEL_37:
      v110(v58, v53, a3);
      uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v77 = (void (*)(char *, uint64_t))v120;
      v120(v26, a3);
      if (v78 < v127[0]) {
LABEL_62:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_41;
    }
    char v74 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v75 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
    v74(v127, &type metadata for Int, v75, a3, a4);
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v53, v26, a3);
    goto LABEL_32;
  }
  char v67 = v54(a3, a4);
  uint64_t v68 = v122(a3, a4);
  if ((v67 & 1) == 0)
  {
    if (v68 >= 64)
    {
      v120(v109, a3);
      goto LABEL_42;
    }
    char v58 = v26;
    uint64_t v53 = v109;
    goto LABEL_37;
  }
  if (v68 > 64)
  {
    uint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    v71(v127, &type metadata for Int, v72, a3, a4);
    uint64_t v53 = v109;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v109, v26, a3);
LABEL_32:
    char v76 = v73;
    uint64_t v77 = (void (*)(char *, uint64_t))v120;
    v120(v26, a3);
    if (v76) {
      goto LABEL_62;
    }
    goto LABEL_41;
  }
  char v80 = AssociatedTypeWitness;
  uint64_t v79 = v115;
  uint64_t v81 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v82 = v113;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v81 + 8))(&qword_18162B0B8, 256, v80, v81);
  ((void (*)(char *, uint64_t, int **))v79[3])(v82, a3, v79);
  uint64_t v83 = v109;
  LOBYTE(v79) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v109, v26, a3);
  uint64_t v77 = (void (*)(char *, uint64_t))v120;
  v120(v26, a3);
  uint64_t v84 = v112;
  v110(v112, v83, a3);
  if (v79)
  {
    v77(v84, a3);
    goto LABEL_62;
  }
  uint64_t v85 = v127[0];
  uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v77(v84, a3);
  BOOL v87 = v86 < v85;
  uint64_t v53 = v109;
  if (v87) {
    goto LABEL_62;
  }
LABEL_41:
  v77(v53, a3);
LABEL_42:
  BOOL v89 = v122;
  uint64_t v88 = v123;
  uint64_t v90 = v121;
  uint64_t v91 = v122(a3, a4);
  uint64_t v92 = v117;
  v110(v117, v90, a3);
  if (v91 < 65)
  {
    uint64_t v100 = v89(a3, a4);
    v120(v92, a3);
    if (v100 != 64 || (v88(a3, a4) & 1) != 0) {
      goto LABEL_55;
    }
  }
  else
  {
    v120(v92, a3);
  }
  v110(v119, v121, a3);
  v127[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v93 = v88(a3, a4);
  uint64_t v94 = v122(a3, a4);
  if ((v93 & 1) == 0)
  {
    if (v94 >= 64)
    {
      uint64_t v126 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
      uint64_t v99 = &v126;
      goto LABEL_53;
    }
LABEL_52:
    uint64_t v101 = v119;
    v110(v26, v119, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v102 = (void (*)(char *, uint64_t))v120;
    v120(v26, a3);
    v102(v101, a3);
    goto LABEL_55;
  }
  if (v94 <= 64) {
    goto LABEL_52;
  }
  uint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
  uint64_t v99 = v127;
LABEL_53:
  v97(v99, &type metadata for Int, v98, a3, a4);
  char v103 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, v119, a3);
  v120(v26, a3);
  if (v103) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v120(v119, a3);
LABEL_55:
  uint64_t v104 = v121;
  unint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v120(v104, a3);
  unint64_t v106 = *v124;
  uint64_t v66 = v124[1];
  if ((v105 & 0x8000000000000000) == 0)
  {
    if (v105 < 0x80)
    {
      uint64_t v47 = (v66 << v105) | (v106 >> 1 >> ~(_BYTE)v105);
      uint64_t v46 = v106 << v105;
      if ((v105 & 0x40) != 0)
      {
        uint64_t v47 = v106 << v105;
        uint64_t v46 = 0;
      }
      goto LABEL_59;
    }
LABEL_16:
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    goto LABEL_59;
  }
  if (v105 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_27:
    uint64_t v46 = v66 >> 63;
    uint64_t v47 = v46;
    goto LABEL_59;
  }
  uint64_t v108 = v66 >> -(char)v105;
  uint64_t v47 = v66 >> 63;
  if ((-(uint64_t)v105 & 0x40) == 0) {
    uint64_t v47 = v66 >> -(char)v105;
  }
  uint64_t v46 = ((2 * v66) << (v105 - 1)) | (v106 >> -(char)v105);
  if ((-(uint64_t)v105 & 0x40) != 0) {
    uint64_t v46 = v108;
  }
LABEL_59:
  BOOL v107 = v124;
  uint64_t *v124 = v46;
  v107[1] = v47;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int128(uint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for BinaryInteger.isMultiple(of:) in conformance Int128(uint64_t *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

void protocol witness for BinaryInteger.signum() in conformance Int128(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(uint64_t *)(v1 + 8) >> 63;
  *a1 = v2 | (*(_OWORD *)v1 != 0);
  a1[1] = v2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int128()
{
  return specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, *v0, v0[1]);
}

unint64_t *protocol witness for Strideable.distance(to:) in conformance Int128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  uint64_t v4 = result[1];
  unint64_t v6 = *v2;
  uint64_t v5 = v2[1];
  if ((v5 ^ v4) < 0)
  {
    unsigned long long v12 = __PAIR128__(v5 ^ (unint64_t)(v5 >> 63), v6 ^ (v5 >> 63)) - __PAIR128__(v5 >> 63, v5 >> 63);
    uint64_t v14 = (v3 ^ (v4 >> 63)) - (v4 >> 63);
    uint64_t v13 = (__PAIR128__(v4 ^ (unint64_t)(v4 >> 63), v3 ^ (v4 >> 63)) - __PAIR128__(v4 >> 63, v4 >> 63)) >> 64;
    uint64_t v15 = (__PAIR128__(v5 ^ (unint64_t)(v5 >> 63), v6 ^ (v5 >> 63))
         - __PAIR128__(v5 >> 63, v5 >> 63)
         + (unint64_t)v14) >> 64;
    unint64_t v8 = (v6 ^ (v5 >> 63)) - (v5 >> 63) + v14;
    char v16 = __CFADD__(__CFADD__((void)v12, v14), *((void *)&v12 + 1)) | __CFADD__(v13, v15);
    uint64_t v17 = v13 + v15;
    if (v16) {
      char v18 = 1;
    }
    else {
      char v18 = 0;
    }
    if ((v18 & 1) == 0)
    {
      if (v17 | (v8 >> 63)) {
        goto LABEL_18;
      }
      if (v5 >= 0) {
        unint64_t v8 = -(uint64_t)v8;
      }
      goto LABEL_15;
    }
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  BOOL v10 = __OFSUB__(__PAIR128__(v4, v3), __PAIR128__(v5, v6));
  unint64_t v9 = v3 - v6;
  uint64_t v7 = (__PAIR128__(v4, v3) - __PAIR128__(v5, v6)) >> 64;
  unint64_t v8 = v3 - v6;
  char v11 = v10;
  if (v11)
  {
    __break(1u);
    goto LABEL_17;
  }
  if (__CFADD__(v9, 0x8000000000000000) + v7) {
LABEL_18:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
LABEL_15:
  *a2 = v8;
  return result;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance Int128@<X0>(uint64_t *result@<X0>, _OWORD *a2@<X8>)
{
  long long v3 = *(_OWORD *)v2 + *result;
  if (__OFADD__(__CFADD__(*v2, *result), v2[1]) | __OFADD__(*result >> 63, *((void *)&v3 + 1))) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4) {
    __break(1u);
  }
  else {
    *a2 = v3;
  }
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int128(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance Int128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t static Int128.bitWidth.getter()
{
  return 128;
}

uint64_t Int128.nonzeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  uint64_t v3 = v2.u32[0];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v4.i16[0] = vaddlv_u8(v4);
  return v3 + v4.u32[0];
}

uint64_t Int64.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t UInt64.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t Int128.leadingZeroBitCount.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

BOOL static Int64.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

unint64_t UInt64.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

unint64_t Int64.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

unint64_t Int128.byteSwapped.getter(uint64_t a1, unint64_t a2)
{
  return bswap64(a2);
}

unint64_t Int64.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

unint64_t UInt64.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

uint64_t static Int128.&* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int128(void *a1@<X8>)
{
  *a1 = -1;
  a1[1] = 0x7FFFFFFFFFFFFFFFLL;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int128(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0x8000000000000000;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int128(_OWORD *a1, void *a2)
{
  long long v3 = *(_OWORD *)v2 + *(_OWORD *)a2;
  if (__OFADD__(__CFADD__(*v2, *a2), v2[1]) | __OFADD__(a2[1], *((void *)&v3 + 1))) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = 0;
  }
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  BOOL v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int128(void *a1, uint64_t a2)
{
  unsigned long long v3 = abs128(*(_OWORD *)v2);
  unsigned long long v4 = abs128(*(_OWORD *)a2);
  if (*((void *)&v3 + 1)) {
    BOOL v5 = *((void *)&v4 + 1) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  uint64_t v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v4) >> 64 != 0
    || (*((unint64_t *)&v4 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0;
  if (__CFADD__(((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64, *((void *)&v4 + 1) * v3 + *((void *)&v3 + 1) * v4))
  {
    int v9 = 1;
  }
  else
  {
    int v9 = v8;
  }
  uint64_t v10 = *(void *)(v2 + 8) ^ *(void *)(a2 + 8);
  uint64_t v11 = -(v3 * v4);
  uint64_t v12 = (unsigned __int128)-(__int128)__PAIR128__(v8, (void)v3 * (void)v4) >> 64;
  BOOL v13 = v10 < 0;
  if (v10 >= 0) {
    uint64_t v14 = (v4 * v3) >> 64;
  }
  else {
    uint64_t v14 = v12;
  }
  if (v13)
  {
    BOOL v15 = (void)v3 * (void)v4 != 0;
  }
  else
  {
    uint64_t v11 = v3 * v4;
    BOOL v15 = (((v4 * v3) >> 64) & 0x8000000000000000) != 0;
  }
  *a1 = v11;
  a1[1] = v14;
  return v9 | v15;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  }
  BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1 && (*v2 | v2[1] ^ 0x8000000000000000) == 0;
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0x8000000000000000;
  }
  else
  {
    uint64_t v6 = __divti3();
  }
  *a1 = v6;
  a1[1] = v7;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  }
  BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1 && (*v2 | v2[1] ^ 0x8000000000000000) == 0;
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = __modti3();
  }
  *a1 = v6;
  a1[1] = v7;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int128(uint64_t *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t result = specialized FixedWidthInteger.multipliedFullWidth(by:)(a2, *(void *)a3, *(void *)(a3 + 8), *(void *)v3, *(void *)(v3 + 8));
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int128(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t result = specialized SignedInteger<>.dividingFullWidth(_:)(a2, *(void *)a3, *(void *)(a3 + 8), *a4, a4[1], *v4, v4[1]);
  *a1 = result;
  a1[1] = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.init(_truncatingBits:) in conformance Int128@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  a2[1] = 0;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int128()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(v0[1]);
  v1.i16[0] = vaddlv_u8(v1);
  uint64_t v2 = v1.u32[0];
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(*v0);
  v3.i16[0] = vaddlv_u8(v3);
  return v2 + v3.u32[0];
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int128()
{
  unint64_t v1 = v0[1];
  unint64_t v2 = __clz(v1);
  unint64_t v3 = __clz(*v0) + 64;
  if (v1) {
    return v2;
  }
  else {
    return v3;
  }
}

unint64_t *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int128@<X0>(unint64_t *result@<X0>, void *a2@<X8>)
{
  unint64_t v2 = bswap64(*result);
  *a2 = bswap64(result[1]);
  a2[1] = v2;
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int128(void *a1@<X8>)
{
  unint64_t v2 = bswap64(*v1);
  *a1 = bswap64(v1[1]);
  a1[1] = v2;
}

void *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = result[1];
  uint64_t v4 = ((2 * v3) << ~*a2) | (*result >> *a2);
  uint64_t v5 = v3 >> *a2;
  if ((*a2 & 0x40) != 0) {
    uint64_t v4 = v3 >> *a2;
  }
  uint64_t v6 = v3 >> 63;
  if ((*a2 & 0x40) == 0) {
    uint64_t v6 = v5;
  }
  *a3 = v4;
  a3[1] = v6;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int128(uint64_t *result, void *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = v2 >> *a2;
  if ((*a2 & 0x40) != 0) {
    uint64_t v4 = v2 >> *a2;
  }
  else {
    uint64_t v4 = ((2 * v2) << ~*a2) | ((unint64_t)*result >> *a2);
  }
  uint64_t v5 = v2 >> 63;
  if ((*a2 & 0x40) == 0) {
    uint64_t v5 = v3;
  }
  *uint64_t result = v4;
  result[1] = v5;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int128@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (result[1] << *a2) | (*result >> 1 >> ~*a2);
  uint64_t v4 = *result << *a2;
  if ((*a2 & 0x40) != 0)
  {
    uint64_t v3 = *result << *a2;
    uint64_t v4 = 0;
  }
  *a3 = v4;
  a3[1] = v3;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int128(void *result, void *a2)
{
  uint64_t v2 = *result << *a2;
  if ((*a2 & 0x40) != 0) {
    uint64_t v3 = *result << *a2;
  }
  else {
    uint64_t v3 = (result[1] << *a2) | (*result >> 1 >> ~*a2);
  }
  if ((*a2 & 0x40) != 0) {
    uint64_t v2 = 0;
  }
  *uint64_t result = v2;
  result[1] = v3;
  return result;
}

_OWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (*a2 * *result) >> 64;
  *a3 = *(void *)a2 * *(void *)result;
  a3[1] = v3;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t Mirror.subjectType.getter()
{
  return *(void *)v0;
}

atomic_ullong *Mirror.children.getter()
{
  return swift_retain(*(atomic_ullong **)(v0 + 8));
}

void Mirror.displayStyle.getter(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 16);
}

double (*static Mirror._superclassIterator<A>(_:_:)(uint64_t a1, uint64_t a2, swift *a3))@<D0>(uint64_t a1@<X8>)
{
  uint64_t v5 = *((void *)a3 - 1);
  uint64_t v6 = *(void *)(v5 + 64);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v8;
  int v9 = (atomic_ullong *)v8[1];
  if (swift_isClassType(v11)) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  BOOL v13 = implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
  if (v12)
  {
    unint64_t Superclass = _swift_class_getSuperclass(v12);
    BOOL v13 = implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
    if (Superclass)
    {
      unint64_t v15 = Superclass;
      BOOL v13 = implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
      if (v10)
      {
        if (v10 != 1)
        {
          (*(void (**)(char *, uint64_t, swift *))(v5 + 16))((char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a3);
          uint64_t v21 = *(unsigned __int8 *)(v5 + 80);
          uint64_t v22 = (v21 + 48) & ~v21;
          uint64_t v23 = (char *)swift_allocObject(qword_1ECA02778, v22 + v6, v21 | 7);
          *((void *)v23 + 2) = a3;
          *((void *)v23 + 3) = v10;
          *((void *)v23 + 4) = v9;
          *((void *)v23 + 5) = v15;
          (*(void (**)(char *, char *, swift *))(v5 + 32))(&v23[v22], v7, a3);
          swift_retain(v9);
          return (double (*)@<D0>(uint64_t@<X8>))partial apply for closure #2 in static Mirror._superclassIterator<A>(_:_:);
        }
      }
      else
      {
        (*(void (**)(char *, uint64_t, swift *))(v5 + 16))((char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a3);
        uint64_t v17 = *(unsigned __int8 *)(v5 + 80);
        uint64_t v18 = (v17 + 24) & ~v17;
        unint64_t v19 = (v6 + v18 + 7) & 0xFFFFFFFFFFFFFFF8;
        uint64_t v20 = (char *)swift_allocObject(qword_1ECA027A0, v19 + 8, v17 | 7);
        *((void *)v20 + 2) = a3;
        (*(void (**)(char *, char *, swift *))(v5 + 32))(&v20[v18], v7, a3);
        *(void *)&v20[v19] = v15;
        return partial apply for closure #1 in static Mirror._superclassIterator<A>(_:_:);
      }
    }
  }
  return (double (*)@<D0>(uint64_t@<X8>))v13;
}

uint64_t closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = a4 + 2;
  *a4 = 0;
  a4[1] = 0;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  a4[5] = AssociatedTypeWitness;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v6);
  int v9 = *(uint64_t (**)(void *, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v9(boxed_opaque_existential_0Tm, a1, AssociatedTypeWitness);
}

uint64_t closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = a2 + 2;
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  outlined init with copy of Any((uint64_t)(a1 + 2), (uint64_t)v9);
  *a2 = v6;
  a2[1] = v5;
  outlined init with copy of Any(v4, (uint64_t)v8);
  outlined init with take of Any(v8, v3);
  swift_bridgeObjectRetain(v5);
  return __swift_destroy_boxed_opaque_existential_1Tm(v9);
}

double implicit closure #1 in static Mirror._superclassIterator<A>(_:_:)@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *(_OWORD *)((char *)a1 + 25) = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

atomic_ullong *protocol witness for CustomReflectable.customMirror.getter in conformance Mirror._Dummy@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = *(atomic_ullong **)(v1 + 8);
  char v3 = *(unsigned char *)(v1 + 16);
  uint64_t v4 = *(void *)(v1 + 24);
  unint64_t v5 = *(atomic_ullong **)(v1 + 32);
  char v6 = *(unsigned char *)(v1 + 40);
  *(void *)a1 = *(void *)v1;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 32) = v5;
  *(unsigned char *)(a1 + 40) = v6;
  swift_retain(v2);

  return swift_retain(v5);
}

uint64_t Mirror.descendant(_:_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v7 = *v3;
  char v6 = (atomic_ullong *)v3[1];
  char v8 = *((unsigned char *)v3 + 16);
  uint64_t v10 = v3[3];
  int v9 = (atomic_ullong *)v3[4];
  char v11 = *((unsigned char *)v3 + 40);
  char v73 = &type metadata for Mirror._Dummy;
  uint64_t v12 = swift_allocObject(qword_1EC9F2B68, 0x39uLL, 7uLL);
  *(void *)&long long v72 = v12;
  void v12[2] = v7;
  uint64_t v12[3] = v6;
  *((unsigned char *)v12 + 32) = v8;
  v12[5] = v10;
  v12[6] = v9;
  *((unsigned char *)v12 + 56) = v11;
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<MirrorPath>);
  inited = swift_initStackObject(v13, v71);
  *((_OWORD *)inited + 1) = xmmword_18162AC80;
  outlined init with copy of MirrorPath(a1, (uint64_t)(inited + 4));
  *(void *)&long long v64 = inited;
  swift_retain(v6);
  swift_retain(v9);
  swift_bridgeObjectRetain(a2);
  specialized Array.append<A>(contentsOf:)(a2, &demangling cache variable for type metadata for _ContiguousArrayStorage<MirrorPath>, &demangling cache variable for type metadata for MirrorPath);
  uint64_t v15 = (uint64_t)inited;
  uint64_t v59 = inited[2];
  if (!v59)
  {
LABEL_33:
    swift_bridgeObjectRelease(v15);
    outlined init with copy of Any((uint64_t)&v72, (uint64_t)a3);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v72);
  }
  unint64_t v16 = 0;
  uint64_t v58 = v64 + 32;
  uint64_t v57 = v64;
  while (2)
  {
    if (v16 >= *(void *)(v15 + 16)) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    }
    outlined init with copy of MirrorPath(v58 + 40 * v16, (uint64_t)v70);
    outlined init with take of MirrorPath(v70, (uint64_t)v69);
    outlined init with copy of Any((uint64_t)&v72, (uint64_t)v68);
    outlined init with copy of Any((uint64_t)v68, (uint64_t)v67);
    uint64_t v17 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
    if (swift_dynamicCast((char *)&v64, v67, qword_1ECA06310, v17, 6uLL))
    {
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v68);
      outlined init with take of MirrorPath(&v64, (uint64_t)v63);
      uint64_t v19 = *(void *)&v63[32];
      uint64_t v18 = *(void *)&v63[24];
      __swift_project_boxed_opaque_existential_0Tm(v63, *(uint64_t *)&v63[24]);
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(v19 + 8))(&v64, v18, v19);
      uint64_t v20 = (atomic_ullong *)*((void *)&v64 + 1);
      uint64_t v21 = v66;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v63);
    }
    else
    {
      *(void *)&long long v66 = 0;
      long long v64 = 0u;
      long long v65 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v64, &demangling cache variable for type metadata for CustomReflectable?);
      memset(v63, 0, 41);
      Mirror.init(internalReflecting:subjectType:customAncestor:)(v68, 0, (uint64_t)v63, (uint64_t)&v64);
      uint64_t v20 = (atomic_ullong *)*((void *)&v64 + 1);
      uint64_t v21 = v66;
    }
    swift_release(v21);
    outlined init with copy of MirrorPath((uint64_t)v69, (uint64_t)&v64);
    uint64_t v22 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for MirrorPath);
    unint64_t v60 = v16;
    if ((swift_dynamicCast(v63, (unint64_t *)&v64, v22, (const char *)&type metadata for String, 6uLL) & 1) == 0)
    {
      outlined init with copy of MirrorPath((uint64_t)v69, (uint64_t)&v64);
      if (!swift_dynamicCast(v63, (unint64_t *)&v64, v22, (const char *)&type metadata for Int, 6uLL))
      {
        swift_release((uint64_t)v20);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Someone added a conformance to MirrorPath; that privilege is reserved to the standard library",
          93,
          2,
          "Swift/Mirror.swift",
          18,
          2,
          0x1CBuLL,
          0);
      }
      __swift_destroy_boxed_opaque_existential_1Tm(v69);
      uint64_t v39 = *(void *)v63;
      uint64_t v41 = (void *)v20[2];
      atomic_ullong v40 = v20[3];
      unint64_t v42 = (void *)v20[4];
      atomic_ullong v43 = v20[5];
      uint64_t v44 = *(uint64_t (**)(void *, atomic_ullong, uint64_t, void *, atomic_ullong))(*v20 + 288);
      swift_retain(v20);
      swift_unknownObjectRetain(v41);
      swift_unknownObjectRetain(v42);
      uint64_t v24 = (void *)v44(v41, v40, v39, v42, v43);
      atomic_ullong v25 = v45;
      swift_unknownObjectRelease(v41);
      swift_unknownObjectRelease(v42);
      swift_release((uint64_t)v20);
      if (!v24)
      {
        uint64_t v24 = (void *)v20[4];
        atomic_ullong v25 = v20[5];
        swift_unknownObjectRetain(v24);
      }
      goto LABEL_30;
    }
    unint64_t v23 = *(void *)&v63[8];
    uint64_t v61 = *(void *)v63;
    uint64_t v24 = (void *)v20[2];
    atomic_ullong v25 = v20[3];
    swift_unknownObjectRetain(v24);
LABEL_9:
    uint64_t v62 = *(uint64_t (**)(unint64_t, atomic_ullong))(v25 + 8);
    while (1)
    {
      unint64_t v26 = v20[4];
      atomic_ullong v27 = v20[5];
      unint64_t ObjectType = swift_getObjectType((unint64_t)v24);
      uint64_t v29 = v62(ObjectType, v25);
      unint64_t v30 = swift_getObjectType(v26);
      if (v29 != (*(uint64_t (**)(unint64_t, atomic_ullong))(v27 + 8))(v30, v27))
      {
        swift_release((uint64_t)v20);
LABEL_37:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Base index types differ", 23, 2, "Swift/ExistentialCollection.swift", 33, 2, 0x747uLL, 0);
      }
      unint64_t v31 = swift_getObjectType((unint64_t)v24);
      if ((*(uint64_t (**)(unint64_t, atomic_ullong, unint64_t, atomic_ullong))(v25 + 24))(v26, v27, v31, v25))
      {
        swift_bridgeObjectRelease(v23);
        __swift_destroy_boxed_opaque_existential_1Tm(v69);
        swift_unknownObjectRelease(v24);
        uint64_t v24 = (void *)v20[4];
        atomic_ullong v25 = v20[5];
        swift_unknownObjectRetain(v24);
        goto LABEL_29;
      }
      (*(void (**)(long long *__return_ptr, void *, atomic_ullong))(*v20 + 256))(&v64, v24, v25);
      *(_OWORD *)uint64_t v63 = v64;
      *(_OWORD *)&v63[16] = v65;
      *(_OWORD *)&v63[32] = v66;
      if (!*((void *)&v64 + 1))
      {
LABEL_18:
        outlined destroy of _HasContiguousBytes?((uint64_t)v63, &demangling cache variable for type metadata for (label: String?, value: Any));
        goto LABEL_20;
      }
      if (*(void *)v63 == v61 && *((void *)&v64 + 1) == v23) {
        break;
      }
      if ((~*((void *)&v64 + 1) & 0x6000000000000000) == 0
        && (v23 & 0x2000000000000000) != 0
        && (v23 & 0x4000000000000000) != 0)
      {
        goto LABEL_18;
      }
      char v32 = _stringCompareInternal(_:_:expecting:)(*(uint64_t *)v63, *((unint64_t *)&v64 + 1), v61, v23, 0);
      outlined destroy of _HasContiguousBytes?((uint64_t)v63, &demangling cache variable for type metadata for (label: String?, value: Any));
      if (v32) {
        goto LABEL_28;
      }
LABEL_20:
      int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v24);
      atomic_ullong v34 = *v20;
      if (!isUniquelyReferenced_nonNull)
      {
        uint64_t v37 = (*(uint64_t (**)(void *, atomic_ullong))(v34 + 264))(v24, v25);
        atomic_ullong v25 = v38;
        swift_unknownObjectRelease(v24);
        uint64_t v24 = (void *)v37;
        goto LABEL_9;
      }
      uint64_t v35 = *(void (**)(id, atomic_ullong))(v34 + 272);
      id v36 = swift_unknownObjectRetain(v24);
      v35(v36, v25);
      swift_unknownObjectRelease(v24);
    }
    outlined destroy of _HasContiguousBytes?((uint64_t)v63, &demangling cache variable for type metadata for (label: String?, value: Any));
LABEL_28:
    swift_bridgeObjectRelease(v23);
    __swift_destroy_boxed_opaque_existential_1Tm(v69);
LABEL_29:
    uint64_t v15 = v57;
LABEL_30:
    uint64_t v46 = (void *)v20[4];
    atomic_ullong v47 = v20[5];
    unint64_t v48 = swift_getObjectType((unint64_t)v24);
    char v49 = *(uint64_t (**)(unint64_t, atomic_ullong))(v25 + 8);
    swift_unknownObjectRetain(v46);
    uint64_t v50 = v49(v48, v25);
    unint64_t v51 = swift_getObjectType((unint64_t)v46);
    if (v50 != (*(uint64_t (**)(unint64_t, atomic_ullong))(v47 + 8))(v51, v47)) {
      goto LABEL_37;
    }
    unint64_t v52 = swift_getObjectType((unint64_t)v24);
    uint64_t v53 = *(uint64_t (**)(void *, atomic_ullong, unint64_t, atomic_ullong))(v25 + 24);
    swift_unknownObjectRetain(v24);
    char v54 = v53(v46, v47, v52, v25);
    swift_unknownObjectRelease(v46);
    swift_unknownObjectRelease(v24);
    if ((v54 & 1) == 0)
    {
      unint64_t v16 = v60 + 1;
      (*(void (**)(long long *__return_ptr, void *, atomic_ullong))(*v20 + 256))(&v64, v24, v25);
      swift_release((uint64_t)v20);
      swift_unknownObjectRelease(v24);
      swift_bridgeObjectRelease(*((uint64_t *)&v64 + 1));
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v72);
      outlined init with take of Any(&v65, &v72);
      if (v60 + 1 == v59) {
        goto LABEL_33;
      }
      continue;
    }
    break;
  }
  swift_bridgeObjectRelease(v15);
  swift_release((uint64_t)v20);
  swift_unknownObjectRelease(v24);
  *a3 = 0u;
  a3[1] = 0u;
  return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v72);
}

uint64_t String.init<A>(describing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v5;
}

{
  void v6[2];

  v6[0] = 0;
  v6[1] = 0xE000000000000000;
  (*(void (**)(void *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(a3 + 8))(v6, &type metadata for String, &protocol witness table for String, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v6[0];
}

{
  uint64_t v5;

  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  return v5;
}

uint64_t Mirror.description.getter()
{
  uint64_t v2 = *v1;
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(13);
  unint64_t v5 = (unint64_t)v4;
  v317._uint64_t countAndFlagsBits = v3;
  v317._unint64_t object = v4;
  Swift::String v6 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Mirror for ", 0xBuLL, 1);
  uint64_t countAndFlagsBits = v6._countAndFlagsBits;
  unint64_t object = v6._object;
  uint64_t v9 = HIBYTE(v5) & 0xF;
  uint64_t v10 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v11 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v11 && (v3 & ~v5 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v5);
    Swift::String v317 = v6;
    goto LABEL_90;
  }
  uint64_t v314 = (uint64_t)v2;
  uint64_t v12 = (uint64_t)v6._object & 0x2000000000000000;
  uint64_t v13 = ((unint64_t)v6._object >> 56) & 0xF;
  if ((v5 & 0x2000000000000000) != 0 && v12)
  {
    unint64_t v0 = v13 + v9;
    if ((unint64_t)(v13 + v9) <= 0xF)
    {
      if (v13)
      {
        char v56 = 0;
        unint64_t v57 = 0;
        unint64_t v58 = v5;
        do
        {
          unint64_t v59 = v9 + v57;
          unint64_t v60 = v57 + 1;
          if (v57 >= 8) {
            unint64_t v61 = (unint64_t)v6._object;
          }
          else {
            unint64_t v61 = v6._countAndFlagsBits;
          }
          unint64_t v62 = v61 >> (v56 & 0x38);
          char v63 = (8 * v9 + v56) & 0x38;
          uint64_t v64 = (-255 << v63) - 1;
          unint64_t v65 = (unint64_t)v62 << v63;
          unint64_t v66 = v65 | v64 & v58;
          unint64_t v67 = v65 | v64 & v3;
          if (v59 < 8) {
            unint64_t v3 = v67;
          }
          else {
            unint64_t v58 = v66;
          }
          v56 += 8;
          unint64_t v57 = v60;
        }
        while (v13 != v60);
      }
      else
      {
        unint64_t v58 = v5;
      }
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v6._object);
      unint64_t v73 = 0xA000000000000000;
      if (!(v3 & 0x8080808080808080 | v58 & 0x80808080808080)) {
        unint64_t v73 = 0xE000000000000000;
      }
      uint64_t v55 = (void *)(v73 & 0xFF00000000000000 | (v0 << 56) | v58 & 0xFFFFFFFFFFFFFFLL);
LABEL_88:
      v317._uint64_t countAndFlagsBits = v3;
      v317._unint64_t object = v55;
      goto LABEL_89;
    }
    uint64_t v12 = 1;
  }
  if (v12) {
    uint64_t v14 = ((unint64_t)v6._object >> 56) & 0xF;
  }
  else {
    uint64_t v14 = v6._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n((uint64_t)v6._object, 2);
  uint64_t v313 = v14;
  if (((uint64_t)v6._object & 0x1000000000000000) == 0)
  {
    swift_bridgeObjectRetain_n((uint64_t)v6._object, 4);
    if ((v5 & 0x1000000000000000) == 0) {
      goto LABEL_15;
    }
LABEL_274:
    Swift::Int v295 = String.UTF8View._foreignCount()();
    Swift::Int v16 = v295 + v14;
    if (!__OFADD__(v295, v14)) {
      goto LABEL_16;
    }
LABEL_276:
    __break(1u);
    goto LABEL_277;
  }
  swift_bridgeObjectRetain_n((uint64_t)v6._object, 5);
  v291._Swift::UInt64 rawBits = 1;
  v292._Swift::UInt64 rawBits = (v14 << 16) | 1;
  v293._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v291, v292, v6._countAndFlagsBits, (unint64_t)v6._object);
  if (v293._rawBits < 0x10000) {
    v293._rawBits |= 3;
  }
  uint64_t v14 = specialized Collection.count.getter(v293, v294, v6._countAndFlagsBits, (unint64_t)v6._object);
  swift_bridgeObjectRelease((uint64_t)v6._object);
  if ((v5 & 0x1000000000000000) != 0) {
    goto LABEL_274;
  }
LABEL_15:
  BOOL v15 = __OFADD__(v11, v14);
  Swift::Int v16 = v11 + v14;
  if (v15) {
    goto LABEL_276;
  }
LABEL_16:
  unint64_t v17 = v3 & ~v5;
  if ((v17 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v16 > 15) {
      goto LABEL_24;
    }
    if ((v5 & 0x2000000000000000) == 0)
    {
LABEL_46:
      swift_bridgeObjectRelease_n((uint64_t)v6._object, 5);
      if ((v5 & 0x1000000000000000) == 0)
      {
        if ((v3 & 0x1000000000000000) != 0)
        {
          unint64_t v30 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          unint64_t v30 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v5);
          uint64_t v10 = v307;
        }
        uint64_t v31 = v313;
        swift_bridgeObjectRetain(v5);
        closure #1 in _StringGuts._convertedToSmall()(v30, v10, &v315);
        swift_bridgeObjectRelease(v5);
        unint64_t v3 = v315;
        unint64_t v32 = v316;
        goto LABEL_53;
      }
      unint64_t v3 = _StringGuts._foreignConvertedToSmall()(v3, v5);
      unint64_t v32 = v306;
LABEL_52:
      uint64_t v31 = v313;
LABEL_53:
      v33._Swift::UInt64 rawBits = (v31 << 16) | 1;
      v34._Swift::UInt64 rawBits = 1;
      v35._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v34, v33, v6._countAndFlagsBits, (unint64_t)v6._object);
      if (v35._rawBits < 0x10000) {
        v35._rawBits |= 3;
      }
      unint64_t v37 = specialized String.init(_:)(v35, v36, v6._countAndFlagsBits, (unint64_t)v6._object);
      unint64_t v39 = v38;
      swift_bridgeObjectRelease((uint64_t)v6._object);
      if ((v39 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v39);
      }
      else if ((v39 & 0x1000000000000000) != 0)
      {
        unint64_t v37 = _StringGuts._foreignConvertedToSmall()(v37, v39);
        unint64_t v312 = v311;
        swift_bridgeObjectRelease(v39);
        unint64_t v39 = v312;
      }
      else
      {
        if ((v37 & 0x1000000000000000) != 0)
        {
          v304 = (unsigned __int8 *)((v39 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v305 = v37 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v304 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v37, v39);
        }
        closure #1 in _StringGuts._convertedToSmall()(v304, v305, &v315);
        swift_bridgeObjectRelease(v39);
        unint64_t v37 = v315;
        unint64_t v39 = v316;
      }
      uint64_t v40 = HIBYTE(v32) & 0xF;
      uint64_t v41 = HIBYTE(v39) & 0xF;
      uint64_t v42 = v41 + v40;
      if ((unint64_t)(v41 + v40) > 0xF) {
        goto LABEL_301;
      }
      if (v41)
      {
        char v43 = 0;
        unint64_t v44 = 0;
        do
        {
          unint64_t v45 = v40 + v44;
          unint64_t v46 = v44 + 1;
          if (v44 >= 8) {
            unint64_t v47 = v39;
          }
          else {
            unint64_t v47 = v37;
          }
          unint64_t v48 = v47 >> (v43 & 0x38);
          char v49 = (8 * v40 + v43) & 0x38;
          uint64_t v50 = (-255 << v49) - 1;
          unint64_t v51 = (unint64_t)v48 << v49;
          unint64_t v52 = v51 | v50 & v32;
          unint64_t v53 = v51 | v50 & v3;
          if (v45 < 8) {
            unint64_t v3 = v53;
          }
          else {
            unint64_t v32 = v52;
          }
          v43 += 8;
          unint64_t v44 = v46;
        }
        while (v41 != v46);
      }
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v6._object);
      unint64_t v54 = 0xA000000000000000;
      if (!(v3 & 0x8080808080808080 | v32 & 0x80808080808080)) {
        unint64_t v54 = 0xE000000000000000;
      }
      uint64_t v55 = (void *)(v54 & 0xFF00000000000000 | (v42 << 56) | v32 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_88;
    }
    goto LABEL_51;
  }
  int64_t v18 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  if (v19) {
    goto LABEL_302;
  }
  if (v16 > 15) {
    goto LABEL_24;
  }
  if ((v5 & 0x2000000000000000) != 0)
  {
LABEL_51:
    swift_bridgeObjectRelease_n((uint64_t)v6._object, 5);
    unint64_t v32 = v5;
    goto LABEL_52;
  }
  if (v18 < v14) {
    goto LABEL_46;
  }
LABEL_24:
  int64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  BOOL v23 = (v21 & 1) == 0 && v20 >= v14;
  if ((v17 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v23)
    {
LABEL_41:
      _StringGuts.grow(_:)(v16);
      goto LABEL_42;
    }
LABEL_35:
    uint64_t v24 = _StringGuts.nativeCapacity.getter(v3, v5);
    if (v25) {
      uint64_t v26 = 0;
    }
    else {
      uint64_t v26 = v24;
    }
    if (v26 + 0x4000000000000000 < 0) {
      goto LABEL_293;
    }
    uint64_t v27 = 2 * v26;
    if (v27 > v16) {
      Swift::Int v16 = v27;
    }
    goto LABEL_41;
  }
  if (!v23) {
    goto LABEL_35;
  }
LABEL_42:
  swift_bridgeObjectRelease_n((uint64_t)v6._object, 4);
  if (((uint64_t)v6._object & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v6._object);
    _StringGuts._foreignAppendInPlace(_:)(v6._countAndFlagsBits, (unint64_t)v6._object, 0, v313);
    swift_bridgeObjectRelease_n((uint64_t)v6._object, 2);
    goto LABEL_89;
  }
  if (v12)
  {
    swift_bridgeObjectRelease_n((uint64_t)v6._object, 2);
    uint64_t v315 = v6._countAndFlagsBits;
    unint64_t v316 = (uint64_t)v6._object & 0xFFFFFFFFFFFFFFLL;
    uint64_t v28 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v6._object >> 56) & 0xF, (uint64_t)&v315, ((unint64_t)v6._object >> 56) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v28, v29, ((uint64_t)v6._object & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease((uint64_t)v6._object);
LABEL_89:
    uint64_t v2 = (Class *)v314;
    goto LABEL_90;
  }
  if ((v6._countAndFlagsBits & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v6._object);
    id v68 = (id)(((uint64_t)v6._object & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v69 = v6._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    uint64_t v70 = v6._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    uint64_t v2 = (Class *)v314;
  }
  else
  {
    id v68 = _StringObject.sharedUTF8.getter(v6._countAndFlagsBits, (uint64_t)v6._object);
    uint64_t v70 = v308;
    swift_bridgeObjectRelease((uint64_t)v6._object);
    if (v70 < (v6._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
      goto LABEL_300;
    }
    uint64_t v2 = (Class *)v314;
    uint64_t v69 = v6._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v71 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v69, (uint64_t)v68, v70);
  _StringGuts.appendInPlace(_:isASCII:)(v71, v72, v6._countAndFlagsBits < 0);
  swift_bridgeObjectRelease_n((uint64_t)v6._object, 2);
LABEL_90:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v75 < 0) {
    goto LABEL_270;
  }
  size_t v76 = v75;
  if (!v75)
  {
    uint64_t countAndFlagsBits = 0;
    unint64_t v0 = 0xE000000000000000;
LABEL_198:
    unint64_t object = 0;
    goto LABEL_199;
  }
  uint64_t v77 = (uint64_t *)TypeName;
  uint64_t v78 = TypeName;
  if ((v75 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0) {
      goto LABEL_112;
    }
    uint64_t v78 = TypeName + 1;
    while (v78 < (uint8x16_t *)&TypeName->i8[v75 & 0xFFFFFFFFFFFFFFF0])
    {
      uint64_t v79 = v78->i64[0];
      uint64_t v80 = v78->i64[1];
      ++v78;
      if (((v80 | v79) & 0x8080808080808080) != 0) {
        goto LABEL_112;
      }
    }
  }
  if (v78 < (uint8x16_t *)&TypeName->i8[v75 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v78->i64[0] & 0x8080808080808080) != 0) {
      goto LABEL_112;
    }
    uint64_t v78 = (uint8x16_t *)((char *)v78 + 8);
  }
  if (v78 < (uint8x16_t *)&TypeName->i8[v75 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v78->i32[0] & 0x80808080) != 0) {
      goto LABEL_112;
    }
    uint64_t v78 = (uint8x16_t *)((char *)v78 + 4);
  }
  if (v78 >= (uint8x16_t *)&TypeName->i8[v75 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_108:
    if (v78 >= (uint8x16_t *)&TypeName->i8[v75] || (v78->i8[0] & 0x80000000) == 0)
    {
      if (v75 > 15)
      {
        char v81 = 1;
LABEL_152:
        unint64_t v0 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v75, v75, v81 & 1);
        unint64_t object = 0;
        uint64_t countAndFlagsBits = *(void *)(v0 + 24);
        goto LABEL_199;
      }
LABEL_162:
      unint64_t v119 = v75 - 8;
      unint64_t v120 = 8;
      if (v75 < 8) {
        unint64_t v120 = v75;
      }
      if ((v120 & 0x8000000000000000) == 0)
      {
        if (v120 >= 8)
        {
          if (v120 >= 0x10)
          {
            unint64_t v121 = v120 & 0xFFFFFFFFFFFFFFF0;
            uint16x8_t v146 = vmovl_high_u8(*TypeName);
            int8x16_t v147 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v146.i8);
            uint16x8_t v148 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            int8x16_t v149 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v148.i8);
            int8x16_t v150 = (int8x16_t)vmovl_high_u16(v146);
            int8x8_t v151 = (int8x8_t)vextq_s8(v150, v150, 8uLL).u64[0];
            int8x16_t v152 = (int8x16_t)vmovl_high_u16(v148);
            int8x8_t v153 = (int8x8_t)vextq_s8(v152, v152, 8uLL).u64[0];
            *(int8x8_t *)v152.i8 = vorr_s8(*(int8x8_t *)v152.i8, *(int8x8_t *)v150.i8);
            v154.i64[0] = v152.u32[0];
            v154.i64[1] = v152.u32[1];
            int8x16_t v155 = (int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162AD00);
            *(int8x8_t *)v150.i8 = vorr_s8(*(int8x8_t *)v149.i8, *(int8x8_t *)v147.i8);
            v154.i64[0] = v150.u32[0];
            v154.i64[1] = v150.u32[1];
            int8x16_t v156 = vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162ACF0), v155);
            *(int8x8_t *)v150.i8 = vorr_s8(v153, v151);
            v154.i64[0] = v150.u32[0];
            v154.i64[1] = v150.u32[1];
            int8x16_t v157 = (int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162ACE0);
            *(int8x8_t *)v147.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v149, v149, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v147, v147, 8uLL));
            v154.i64[0] = v147.u32[0];
            v154.i64[1] = v147.u32[1];
            int8x16_t v158 = vorrq_s8(v156, vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162ACD0), v157));
            uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v158.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v158, v158, 8uLL));
            if (v120 == (v120 & 0xFFFFFFFFFFFFFFF0)) {
              goto LABEL_179;
            }
            unint64_t v122 = 8 * v121;
            if ((v120 & 8) == 0) {
              goto LABEL_177;
            }
          }
          else
          {
            uint64_t countAndFlagsBits = 0;
            unint64_t v122 = 0;
            unint64_t v121 = 0;
          }
          unint64_t v123 = v121;
          int64x2_t v124 = vdupq_n_s64(v122);
          unint64_t v121 = v120 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v122 = 8 * (v120 & 0xFFFFFFFFFFFFFFF8);
          int8x16_t v125 = 0uLL;
          int8x16_t v126 = (int8x16_t)(unint64_t)countAndFlagsBits;
          int64x2_t v127 = vaddq_s64(v124, (int64x2_t)xmmword_18162ACE0);
          int64x2_t v128 = vaddq_s64(v124, (int64x2_t)xmmword_18162AD00);
          int64x2_t v129 = vaddq_s64(v124, (int64x2_t)xmmword_18162ACD0);
          int64x2_t v130 = vaddq_s64(v124, (int64x2_t)xmmword_18162ACF0);
          uint64_t v131 = (uint8x8_t *)&TypeName->i8[v123];
          int8x16_t v132 = (int8x16_t)vdupq_n_s64(0x38uLL);
          unint64_t v133 = v123 - (v120 & 0xFFFFFFFFFFFFFFF8);
          int64x2_t v134 = vdupq_n_s64(0x40uLL);
          int8x16_t v135 = 0uLL;
          int8x16_t v136 = 0uLL;
          do
          {
            uint8x8_t v137 = *v131++;
            uint16x8_t v138 = vmovl_u8(v137);
            uint32x4_t v139 = vmovl_high_u16(v138);
            v140.i64[0] = v139.u32[2];
            v140.i64[1] = v139.u32[3];
            uint64x2_t v141 = v140;
            v140.i64[0] = v139.u32[0];
            v140.i64[1] = v139.u32[1];
            uint64x2_t v142 = v140;
            uint32x4_t v143 = vmovl_u16(*(uint16x4_t *)v138.i8);
            v140.i64[0] = v143.u32[2];
            v140.i64[1] = v143.u32[3];
            uint64x2_t v144 = v140;
            v140.i64[0] = v143.u32[0];
            v140.i64[1] = v143.u32[1];
            int8x16_t v136 = vorrq_s8((int8x16_t)vshlq_u64(v141, (uint64x2_t)vandq_s8((int8x16_t)v127, v132)), v136);
            int8x16_t v135 = vorrq_s8((int8x16_t)vshlq_u64(v142, (uint64x2_t)vandq_s8((int8x16_t)v128, v132)), v135);
            int8x16_t v125 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v129, v132)), v125);
            int8x16_t v126 = vorrq_s8((int8x16_t)vshlq_u64(v140, (uint64x2_t)vandq_s8((int8x16_t)v130, v132)), v126);
            int64x2_t v128 = vaddq_s64(v128, v134);
            int64x2_t v129 = vaddq_s64(v129, v134);
            int64x2_t v130 = vaddq_s64(v130, v134);
            int64x2_t v127 = vaddq_s64(v127, v134);
            v133 += 8;
          }
          while (v133);
          int8x16_t v145 = vorrq_s8(vorrq_s8(v126, v135), vorrq_s8(v125, v136));
          uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v145.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v145, v145, 8uLL));
          if (v120 == v121)
          {
LABEL_179:
            if (v75 < 9)
            {
              int8x8_t v163 = 0;
LABEL_195:
              unint64_t v227 = 0xA000000000000000;
              if (((*(void *)&v163 | countAndFlagsBits) & 0x8080808080808080) == 0) {
                unint64_t v227 = 0xE000000000000000;
              }
              unint64_t v0 = v227 | (v75 << 56) | *(void *)&v163;
              goto LABEL_198;
            }
            if (v119 < 8)
            {
              unint64_t v162 = 0;
              int8x8_t v163 = 0;
              unint64_t v164 = 0;
LABEL_193:
              uint64_t v224 = v75 - v162 - 8;
              unint64_t v225 = &TypeName->u8[v162 + 8];
              do
              {
                unsigned int v226 = *v225++;
                *(void *)&v163 |= (unint64_t)v226 << (v164 & 0x38);
                v164 += 8;
                --v224;
              }
              while (v224);
              goto LABEL_195;
            }
            if (v119 >= 0x10)
            {
              uint64_t v188 = (uint8x16_t *)&TypeName->u64[1];
              unint64_t v162 = v119 & 0xFFFFFFFFFFFFFFF0;
              int64x2_t v189 = (int64x2_t)xmmword_18162AD80;
              int64x2_t v190 = (int64x2_t)xmmword_18162AD90;
              int64x2_t v191 = (int64x2_t)xmmword_18162ADA0;
              int64x2_t v192 = (int64x2_t)xmmword_18162ADB0;
              int64x2_t v193 = (int64x2_t)xmmword_18162ACE0;
              int64x2_t v194 = (int64x2_t)xmmword_18162AD00;
              int8x16_t v195 = (int8x16_t)vdupq_n_s64(0x38uLL);
              int64x2_t v196 = vdupq_n_s64(0x80uLL);
              int64x2_t v197 = (int64x2_t)xmmword_18162ACD0;
              unint64_t v164 = 8 * (v119 & 0xFFFFFFFFFFFFFFF0);
              int8x16_t v198 = 0uLL;
              int8x16_t v199 = 0uLL;
              int64x2_t v200 = (int64x2_t)xmmword_18162ACF0;
              unint64_t v201 = v119 & 0xFFFFFFFFFFFFFFF0;
              int8x16_t v202 = 0uLL;
              int8x16_t v203 = 0uLL;
              int8x16_t v204 = 0uLL;
              int8x16_t v205 = 0uLL;
              int8x16_t v206 = 0uLL;
              int8x16_t v207 = 0uLL;
              do
              {
                uint8x16_t v208 = *v188++;
                uint16x8_t v209 = vmovl_u8(*(uint8x8_t *)v208.i8);
                uint32x4_t v210 = vmovl_high_u16(v209);
                v211.i64[0] = v210.u32[2];
                v211.i64[1] = v210.u32[3];
                uint64x2_t v212 = v211;
                uint16x8_t v213 = vmovl_high_u8(v208);
                uint32x4_t v214 = vmovl_u16(*(uint16x4_t *)v213.i8);
                v211.i64[0] = v214.u32[2];
                v211.i64[1] = v214.u32[3];
                uint64x2_t v215 = v211;
                v211.i64[0] = v214.u32[0];
                v211.i64[1] = v214.u32[1];
                uint64x2_t v216 = v211;
                v211.i64[0] = v210.u32[0];
                v211.i64[1] = v210.u32[1];
                uint64x2_t v217 = v211;
                uint32x4_t v218 = vmovl_u16(*(uint16x4_t *)v209.i8);
                v211.i64[0] = v218.u32[2];
                v211.i64[1] = v218.u32[3];
                uint64x2_t v219 = v211;
                uint32x4_t v220 = vmovl_high_u16(v213);
                v211.i64[0] = v220.u32[0];
                v211.i64[1] = v220.u32[1];
                uint64x2_t v221 = v211;
                v211.i64[0] = v218.u32[0];
                v211.i64[1] = v218.u32[1];
                uint64x2_t v222 = v211;
                v211.i64[0] = v220.u32[2];
                v211.i64[1] = v220.u32[3];
                int8x16_t v203 = vorrq_s8((int8x16_t)vshlq_u64(v212, (uint64x2_t)vandq_s8((int8x16_t)v193, v195)), v203);
                int8x16_t v205 = vorrq_s8((int8x16_t)vshlq_u64(v215, (uint64x2_t)vandq_s8((int8x16_t)v191, v195)), v205);
                int8x16_t v204 = vorrq_s8((int8x16_t)vshlq_u64(v216, (uint64x2_t)vandq_s8((int8x16_t)v192, v195)), v204);
                int8x16_t v202 = vorrq_s8((int8x16_t)vshlq_u64(v217, (uint64x2_t)vandq_s8((int8x16_t)v194, v195)), v202);
                int8x16_t v199 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v197, v195)), v199);
                int8x16_t v206 = vorrq_s8((int8x16_t)vshlq_u64(v221, (uint64x2_t)vandq_s8((int8x16_t)v190, v195)), v206);
                int8x16_t v198 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v200, v195)), v198);
                int8x16_t v207 = vorrq_s8((int8x16_t)vshlq_u64(v211, (uint64x2_t)vandq_s8((int8x16_t)v189, v195)), v207);
                int64x2_t v194 = vaddq_s64(v194, v196);
                int64x2_t v197 = vaddq_s64(v197, v196);
                int64x2_t v200 = vaddq_s64(v200, v196);
                int64x2_t v193 = vaddq_s64(v193, v196);
                int64x2_t v192 = vaddq_s64(v192, v196);
                int64x2_t v191 = vaddq_s64(v191, v196);
                int64x2_t v190 = vaddq_s64(v190, v196);
                int64x2_t v189 = vaddq_s64(v189, v196);
                v201 -= 16;
              }
              while (v201);
              int8x16_t v223 = vorrq_s8(vorrq_s8(vorrq_s8(v198, v204), vorrq_s8(v202, v206)), vorrq_s8(vorrq_s8(v199, v205), vorrq_s8(v203, v207)));
              int8x8_t v163 = vorr_s8(*(int8x8_t *)v223.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v223, v223, 8uLL));
              if (v119 == v162) {
                goto LABEL_195;
              }
              if ((v119 & 8) == 0) {
                goto LABEL_193;
              }
            }
            else
            {
              int8x8_t v163 = 0;
              unint64_t v164 = 0;
              unint64_t v162 = 0;
            }
            unint64_t v165 = v162;
            unint64_t v162 = v119 & 0xFFFFFFFFFFFFFFF8;
            int64x2_t v166 = vdupq_n_s64(v164);
            unint64_t v164 = 8 * (v119 & 0xFFFFFFFFFFFFFFF8);
            int8x16_t v167 = (int8x16_t)(unint64_t)v163;
            int8x16_t v168 = 0uLL;
            int64x2_t v169 = vaddq_s64(v166, (int64x2_t)xmmword_18162ACE0);
            int64x2_t v170 = vaddq_s64(v166, (int64x2_t)xmmword_18162AD00);
            int64x2_t v171 = vaddq_s64(v166, (int64x2_t)xmmword_18162ACD0);
            int64x2_t v172 = vaddq_s64(v166, (int64x2_t)xmmword_18162ACF0);
            uint64_t v173 = (uint8x8_t *)((char *)&TypeName->u64[1] + v165);
            int8x16_t v174 = (int8x16_t)vdupq_n_s64(0x38uLL);
            unint64_t v175 = v165 - (v119 & 0xFFFFFFFFFFFFFFF8);
            int64x2_t v176 = vdupq_n_s64(0x40uLL);
            int8x16_t v177 = 0uLL;
            int8x16_t v178 = 0uLL;
            do
            {
              uint8x8_t v179 = *v173++;
              uint16x8_t v180 = vmovl_u8(v179);
              uint32x4_t v181 = vmovl_high_u16(v180);
              v182.i64[0] = v181.u32[2];
              v182.i64[1] = v181.u32[3];
              uint64x2_t v183 = v182;
              v182.i64[0] = v181.u32[0];
              v182.i64[1] = v181.u32[1];
              uint64x2_t v184 = v182;
              uint32x4_t v185 = vmovl_u16(*(uint16x4_t *)v180.i8);
              v182.i64[0] = v185.u32[2];
              v182.i64[1] = v185.u32[3];
              uint64x2_t v186 = v182;
              v182.i64[0] = v185.u32[0];
              v182.i64[1] = v185.u32[1];
              int8x16_t v178 = vorrq_s8((int8x16_t)vshlq_u64(v183, (uint64x2_t)vandq_s8((int8x16_t)v169, v174)), v178);
              int8x16_t v177 = vorrq_s8((int8x16_t)vshlq_u64(v184, (uint64x2_t)vandq_s8((int8x16_t)v170, v174)), v177);
              int8x16_t v168 = vorrq_s8((int8x16_t)vshlq_u64(v186, (uint64x2_t)vandq_s8((int8x16_t)v171, v174)), v168);
              int8x16_t v167 = vorrq_s8((int8x16_t)vshlq_u64(v182, (uint64x2_t)vandq_s8((int8x16_t)v172, v174)), v167);
              int64x2_t v170 = vaddq_s64(v170, v176);
              int64x2_t v171 = vaddq_s64(v171, v176);
              int64x2_t v172 = vaddq_s64(v172, v176);
              int64x2_t v169 = vaddq_s64(v169, v176);
              v175 += 8;
            }
            while (v175);
            int8x16_t v187 = vorrq_s8(vorrq_s8(v167, v177), vorrq_s8(v168, v178));
            int8x8_t v163 = vorr_s8(*(int8x8_t *)v187.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v187, v187, 8uLL));
            if (v119 == v162) {
              goto LABEL_195;
            }
            goto LABEL_193;
          }
        }
        else
        {
          unint64_t v121 = 0;
          uint64_t countAndFlagsBits = 0;
          unint64_t v122 = 0;
        }
LABEL_177:
        Swift::String::Index v159 = &TypeName->u8[v121];
        unint64_t v160 = v120 - v121;
        do
        {
          unsigned int v161 = *v159++;
          countAndFlagsBits |= (unint64_t)v161 << (v122 & 0x38);
          v122 += 8;
          --v160;
        }
        while (v160);
        goto LABEL_179;
      }
LABEL_294:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_112;
  }
  if ((v78->i16[0] & 0x8080) == 0)
  {
    uint64_t v78 = (uint8x16_t *)((char *)v78 + 2);
    goto LABEL_108;
  }
LABEL_112:
  uint64_t v82 = 0;
  uint64_t v83 = (uint8x16_t *)((char *)TypeName + v75);
  char v81 = 1;
  uint64_t v84 = TypeName;
  uint64_t v85 = TypeName;
  while (1)
  {
    int v88 = v85->i8[0];
    uint64_t v85 = (uint8x16_t *)((char *)v85 + 1);
    unsigned __int8 v87 = v88;
    if (v88 < 0) {
      break;
    }
    uint64_t v86 = 1;
LABEL_114:
    v82 += v86;
    uint64_t v84 = v85;
    if (v85 == v83)
    {
      if (v75 > 15) {
        goto LABEL_152;
      }
      goto LABEL_162;
    }
  }
  if ((v87 + 62) > 0x32u) {
    goto LABEL_153;
  }
  if (v87 <= 0xDFu)
  {
    if (v85 == v83 || (v85->i8[0] & 0xC0) != 0x80) {
      goto LABEL_153;
    }
    char v81 = 0;
    uint64_t v85 = (uint8x16_t *)&v84->i16[1];
    uint64_t v86 = 2;
    goto LABEL_114;
  }
  if (v87 == 224)
  {
    if (v85 == v83 || (v84->i8[1] & 0xE0) != 0xA0) {
      goto LABEL_153;
    }
    goto LABEL_132;
  }
  if (v87 <= 0xECu)
  {
LABEL_126:
    if (v85 == v83) {
      goto LABEL_153;
    }
    LOBYTE(v89) = v84->i8[1];
LABEL_131:
    if ((v89 & 0xC0) != 0x80) {
      goto LABEL_153;
    }
LABEL_132:
    if (&v84->i16[1] == (__int16 *)v83 || (v84->i8[2] & 0xC0) != 0x80) {
      goto LABEL_153;
    }
    char v81 = 0;
    uint64_t v85 = (uint8x16_t *)((char *)v84->i32 + 3);
    uint64_t v86 = 3;
    goto LABEL_114;
  }
  if (v87 == 237)
  {
    if (v85 == v83) {
      goto LABEL_153;
    }
    unsigned int v89 = v84->u8[1];
    if (v89 > 0x9F) {
      goto LABEL_153;
    }
    goto LABEL_131;
  }
  if (v87 <= 0xEFu) {
    goto LABEL_126;
  }
  if (v87 == 240)
  {
    if (v85 == v83 || (v84->i8[1] + 64) < 0xD0u) {
      goto LABEL_153;
    }
    goto LABEL_146;
  }
  if ((v87 + 15) <= 2u)
  {
    if (v85 == v83) {
      goto LABEL_153;
    }
    LOBYTE(v90) = v84->i8[1];
LABEL_145:
    if ((v90 & 0xC0) != 0x80) {
      goto LABEL_153;
    }
LABEL_146:
    if (&v84->i16[1] == (__int16 *)v83
      || (v84->i8[2] & 0xC0) != 0x80
      || (uint8x16_t *)((char *)v84->i32 + 3) == v83
      || (v84->i8[3] & 0xC0) != 0x80)
    {
      goto LABEL_153;
    }
    char v81 = 0;
    uint64_t v85 = (uint8x16_t *)((char *)v84->i64 + 4);
    uint64_t v86 = 4;
    goto LABEL_114;
  }
  if (v85 != v83)
  {
    unsigned int v90 = v84->u8[1];
    if (v90 <= 0x8F) {
      goto LABEL_145;
    }
  }
LABEL_153:
  uint64_t v91 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v91);
  uint64_t v92 = specialized Collection.subscript.getter(v82, (uint64_t)v77, v76);
  uint64_t v97 = findInvalidRange #1 (_:) in validateUTF8(_:)(v92, v93, v94, v95);
  uint64_t v315 = 0;
  unint64_t v316 = 0xE000000000000000;
  if (__OFADD__(v76, 15))
  {
    __break(1u);
LABEL_293:
    __break(1u);
    goto LABEL_294;
  }
  uint64_t v98 = v96;
  _StringGuts.reserveCapacity(_:)(v76 + 15);
  unint64_t object = 0;
  while (1)
  {
    uint64_t v99 = specialized Collection.subscript.getter(v97, (uint64_t)v77, v76);
    uint64_t v103 = v315 & 0xFFFFFFFFFFFFLL;
    if ((v316 & 0x2000000000000000) != 0) {
      uint64_t v103 = HIBYTE(v316) & 0xF;
    }
    BOOL v15 = __OFADD__(v103, v76);
    size_t v104 = v103 + v76;
    if (v15)
    {
      __break(1u);
LABEL_269:
      __break(1u);
LABEL_270:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    uint64_t v105 = v99;
    if (__OFADD__(v104, 3)) {
      goto LABEL_269;
    }
    uint64_t v106 = v100;
    uint64_t v107 = v101;
    uint64_t v108 = v102;
    _StringGuts.reserveCapacity(_:)(v104 + 3);
    uint64_t v109 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v105, v106, v107, v108);
    _StringGuts.appendInPlace(_:isASCII:)(v109, v110, 0);
    size_t v318 = 3;
    uint64_t v319 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v319, &v318, &v315);
    uint64_t v111 = specialized Collection.subscript.getter(v98, (uint64_t)v77, v76);
    uint64_t v77 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v111, v112, v113, v114);
    size_t v76 = v115;
    uint64_t v116 = validateUTF8(_:)(v77, v115);
    if ((v118 & 1) == 0) {
      break;
    }
    uint64_t v97 = v116;
    uint64_t v98 = v117;
    if (!v76) {
      goto LABEL_168;
    }
  }
  _StringGuts.appendInPlace(_:isASCII:)((char *)v77, v76, 0);
LABEL_168:
  uint64_t countAndFlagsBits = v315;
  unint64_t v0 = v316;
LABEL_199:
  unint64_t v3 = v317._countAndFlagsBits;
  unint64_t v5 = (unint64_t)v317._object;
  unint64_t v228 = ((unint64_t)v317._object >> 56) & 0xF;
  if (((uint64_t)v317._object & 0x2000000000000000) != 0) {
    uint64_t v10 = ((unint64_t)v317._object >> 56) & 0xF;
  }
  else {
    uint64_t v10 = v317._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v10 && (v317._countAndFlagsBits & ~(uint64_t)v317._object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v317._object);
    v317._uint64_t countAndFlagsBits = countAndFlagsBits;
    v317._unint64_t object = (void *)v0;
    goto LABEL_250;
  }
  uint64_t v14 = v0 & 0x2000000000000000;
  uint64_t v13 = HIBYTE(v0) & 0xF;
  if (((uint64_t)v317._object & 0x2000000000000000) != 0 && v14)
  {
    unint64_t v229 = v228 + v13;
    if (v228 + v13 <= 0xF)
    {
      if (v13)
      {
        char v257 = 0;
        unint64_t v258 = 0;
        unint64_t v259 = (unint64_t)v317._object;
        do
        {
          unint64_t v260 = v228 + v258;
          unint64_t v261 = v258 + 1;
          if (v258 >= 8) {
            unint64_t v262 = v0;
          }
          else {
            unint64_t v262 = countAndFlagsBits;
          }
          unint64_t v263 = v262 >> (v257 & 0x38);
          char v264 = (8 * v228 + v257) & 0x38;
          uint64_t v265 = (-255 << v264) - 1;
          unint64_t v266 = (unint64_t)v263 << v264;
          unint64_t v267 = v266 | v265 & v259;
          unint64_t v268 = v266 | v265 & v3;
          if (v260 < 8) {
            unint64_t v3 = v268;
          }
          else {
            unint64_t v259 = v267;
          }
          v257 += 8;
          unint64_t v258 = v261;
        }
        while (v13 != v261);
      }
      else
      {
        unint64_t v259 = (unint64_t)v317._object;
      }
      swift_bridgeObjectRelease((uint64_t)v317._object);
      swift_bridgeObjectRelease(v0);
      unint64_t v272 = 0xA000000000000000;
      if (!(v3 & 0x8080808080808080 | v259 & 0x80808080808080)) {
        unint64_t v272 = 0xE000000000000000;
      }
      v317._uint64_t countAndFlagsBits = v3;
      v317._unint64_t object = (void *)(v272 & 0xFF00000000000000 | (v229 << 56) | v259 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_250;
    }
    uint64_t v14 = 1;
  }
  uint64_t v314 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v14) {
    uint64_t v12 = HIBYTE(v0) & 0xF;
  }
  else {
    uint64_t v12 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v0, 2);
  if ((v0 & 0x1000000000000000) == 0)
  {
    swift_bridgeObjectRetain_n(v0, 4);
    Swift::Int v230 = v12;
    if ((v5 & 0x1000000000000000) == 0) {
      goto LABEL_213;
    }
LABEL_280:
    Swift::Int v300 = String.UTF8View._foreignCount()();
    int64_t v231 = v300 + v230;
    if (!__OFADD__(v300, v230)) {
      goto LABEL_214;
    }
LABEL_282:
    __break(1u);
    goto LABEL_283;
  }
LABEL_277:
  swift_bridgeObjectRetain_n(v0, 5);
  v296._Swift::UInt64 rawBits = 1;
  v297._Swift::UInt64 rawBits = (v12 << 16) | 1;
  v298._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v296, v297, countAndFlagsBits, v0);
  if (v298._rawBits < 0x10000) {
    v298._rawBits |= 3;
  }
  Swift::Int v230 = specialized Collection.count.getter(v298, v299, countAndFlagsBits, v0);
  swift_bridgeObjectRelease(v0);
  if ((v5 & 0x1000000000000000) != 0) {
    goto LABEL_280;
  }
LABEL_213:
  BOOL v15 = __OFADD__(v10, v230);
  int64_t v231 = v10 + v230;
  if (v15) {
    goto LABEL_282;
  }
LABEL_214:
  if ((v3 & ~v5 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v231 > 15) {
      goto LABEL_226;
    }
LABEL_221:
    swift_bridgeObjectRelease_n(v0, 5);
    swift_bridgeObjectRetain(v5);
    unint64_t v235 = _StringGuts._convertedToSmall()(v3, v5);
    unint64_t v237 = v236;
    swift_bridgeObjectRelease(v5);
    v238._Swift::UInt64 rawBits = (v12 << 16) | 1;
    v239._Swift::UInt64 rawBits = 1;
    v240._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v239, v238, countAndFlagsBits, v0);
    if (v240._rawBits < 0x10000) {
      v240._rawBits |= 3;
    }
    unint64_t v242 = specialized String.init(_:)(v240, v241, countAndFlagsBits, v0);
    unint64_t v244 = v243;
    swift_bridgeObjectRelease(v0);
    unint64_t v245 = _StringGuts._convertedToSmall()(v242, v244);
    unint64_t v247 = v246;
    swift_bridgeObjectRelease(v244);
    unint64_t v248 = specialized _SmallString.init(_:appending:)(v235, v237, v245, v247);
    if ((v250 & 1) == 0)
    {
      uint64_t v251 = v248;
      unint64_t v252 = v249;
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease(v0);
      v317._uint64_t countAndFlagsBits = v251;
      v317._unint64_t object = v252;
      goto LABEL_250;
    }
    goto LABEL_301;
  }
  int64_t v232 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  if (v233)
  {
LABEL_302:
    unint64_t v310 = 258;
LABEL_303:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v310, 0);
  }
  uint64_t v234 = (v5 >> 61) & 1;
  if (v232 < v230) {
    LODWORD(v234) = 1;
  }
  if (v231 <= 15 && v234) {
    goto LABEL_221;
  }
LABEL_226:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v231, v230);
  swift_bridgeObjectRelease_n(v0, 4);
  if ((v0 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v0);
    _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, v0, 0, v12);
    goto LABEL_245;
  }
  if (!v14)
  {
    if ((countAndFlagsBits & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v0);
      unint64_t v255 = (Swift::String *)((v0 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v269 = v314;
      int64_t v253 = v314;
      goto LABEL_244;
    }
    unint64_t v255 = (Swift::String *)_StringObject.sharedUTF8.getter(countAndFlagsBits, v0);
    int64_t v253 = v309;
    swift_bridgeObjectRelease(v0);
    if (v253 >= v314) {
      goto LABEL_308;
    }
LABEL_300:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
  }
  swift_bridgeObjectRelease_n(v0, 2);
  int64_t v253 = (v0 >> 62) & 1;
  uint64_t v315 = countAndFlagsBits;
  unint64_t v316 = v0 & 0xFFFFFFFFFFFFFFLL;
  unint64_t v254 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v13, (uint64_t)&v315, v13);
  unint64_t v255 = &v317;
  _StringGuts.appendInPlace(_:isASCII:)(v254, v256, (v0 & 0x4000000000000000) != 0);
  if (object) {
    goto LABEL_306;
  }
  swift_bridgeObjectRelease(v0);
  while (1)
  {
LABEL_250:
    unint64_t v5 = v317._countAndFlagsBits;
    unint64_t v0 = (unint64_t)v317._object;
    uint64_t countAndFlagsBits = ((unint64_t)v317._object >> 56) & 0xF;
    int64_t v253 = v317._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v317._object & 0x2000000000000000) != 0) {
      unint64_t v273 = ((unint64_t)v317._object >> 56) & 0xF;
    }
    else {
      unint64_t v273 = v317._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v273 && (v317._countAndFlagsBits & ~(uint64_t)v317._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v317._object);
      return 0;
    }
    if (((uint64_t)v317._object & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v317._object);
      swift_bridgeObjectRelease(0xE000000000000000);
      return v5;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6);
    if ((v0 & 0x1000000000000000) == 0) {
      break;
    }
LABEL_283:
    int64_t v253 = String.UTF8View._foreignCount()();
    if ((v5 & ~v0 & 0x2000000000000000) != 0) {
      goto LABEL_258;
    }
LABEL_284:
    if (v253 <= 15) {
      goto LABEL_262;
    }
LABEL_285:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v253, 0);
    swift_bridgeObjectRelease_n(0xE000000000000000, 6);
    uint64_t v315 = 0;
    unint64_t v316 = 0;
    v301 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v315, 0);
    unint64_t v255 = &v317;
    _StringGuts.appendInPlace(_:isASCII:)(v301, v302, 1);
    if (!object)
    {
      swift_bridgeObjectRelease(0xE000000000000000);
      return v317._countAndFlagsBits;
    }
LABEL_306:
    swift_errorRelease(object);
    __break(1u);
    do
    {
      swift_errorRelease(object);
      swift_bridgeObjectRelease(v0);
      __break(1u);
LABEL_308:
      uint64_t v269 = v314;
LABEL_244:
      Swift::String::Index v270 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v269, (uint64_t)v255, v253);
      unint64_t v255 = &v317;
      _StringGuts.appendInPlace(_:isASCII:)(v270, v271, countAndFlagsBits < 0);
    }
    while (object);
LABEL_245:
    swift_bridgeObjectRelease_n(v0, 2);
  }
  if ((v5 & ~v0 & 0x2000000000000000) == 0) {
    goto LABEL_284;
  }
LABEL_258:
  if (!swift_isUniquelyReferenced_nonNull_native(v0 & 0xFFFFFFFFFFFFFFFLL)) {
    goto LABEL_284;
  }
  unint64_t v274 = _StringGuts.nativeUnusedCapacity.getter(v5, v0);
  if (v275) {
    goto LABEL_302;
  }
  if (v253 > 15 || (v274 & 0x8000000000000000) == 0) {
    goto LABEL_285;
  }
LABEL_262:
  swift_bridgeObjectRelease_n(0xE000000000000000, 5);
  swift_bridgeObjectRetain(v0);
  unint64_t v276 = _StringGuts._convertedToSmall()(v5, v0);
  unint64_t v278 = v277;
  swift_bridgeObjectRelease(v0);
  v279._Swift::UInt64 rawBits = 1;
  v280._Swift::UInt64 rawBits = 1;
  v281._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v279, v280, 0, 0xE000000000000000);
  if (v281._rawBits < 0x10000) {
    v281._rawBits |= 3;
  }
  unint64_t v283 = specialized String.init(_:)(v281, v282, 0, 0xE000000000000000);
  unint64_t v285 = v284;
  swift_bridgeObjectRelease(0xE000000000000000);
  unint64_t v286 = _StringGuts._convertedToSmall()(v283, v285);
  unint64_t v288 = v287;
  swift_bridgeObjectRelease(v285);
  unint64_t v289 = specialized _SmallString.init(_:appending:)(v276, v278, v286, v288);
  if (v290)
  {
LABEL_301:
    unint64_t v310 = 266;
    goto LABEL_303;
  }
  unint64_t v5 = v289;
  swift_bridgeObjectRelease(v0);
  swift_bridgeObjectRelease(0xE000000000000000);
  return v5;
}

uint64_t Mirror.customMirror.getter@<X0>(uint64_t a1@<X8>)
{
  long long v3 = v1[1];
  long long v5 = *v1;
  v6[0] = v3;
  *(_OWORD *)((char *)v6 + 9) = *(long long *)((char *)v1 + 25);
  outlined retain of Mirror((uint64_t)&v5);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)(&v5, (uint64_t)&_swiftEmptyArrayStorage, 8, 0, 0, a1);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Mirror@<X0>(uint64_t a1@<X8>)
{
  long long v3 = v1[1];
  long long v5 = *v1;
  v6[0] = v3;
  *(_OWORD *)((char *)v6 + 9) = *(long long *)((char *)v1 + 25);
  outlined retain of Mirror((uint64_t)&v5);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)(&v5, (uint64_t)&_swiftEmptyArrayStorage, 8, 0, 0, a1);
}

uint64_t static CommandLine._argc.getter()
{
  return static CommandLine._argc;
}

uint64_t static CommandLine._argc.setter(uint64_t result)
{
  static CommandLine._argc = result;
  return result;
}

uint64_t (*static CommandLine._argc.modify())()
{
  return EnumeratedSequence._base.modify;
}

char **one-time initialization function for _unsafeArgv()
{
  double result = _swift_stdlib_getUnsafeArgvArgc(&static CommandLine._argc);
  static CommandLine._unsafeArgv = (uint64_t)result;
  return result;
}

void static CommandLine._unsafeArgv.setter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  }
  static CommandLine._unsafeArgv = a1;
}

uint64_t (*static CommandLine._unsafeArgv.modify(uint64_t a1, uint64_t a2, void *a3))()
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t static CommandLine.argc.getter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  }
  uint64_t result = 0;
  while (*(void *)(static CommandLine._unsafeArgv + 8 * result))
  {
    if (++result == 0x80000000)
    {
      __break(1u);
      return result;
    }
  }
  return result;
}

_DWORD *static Int32.+= infix(_:_:)(_DWORD *result, int a2)
{
  if (__OFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

uint64_t static CommandLine._unsafeArgv.getter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  }
  return static CommandLine._unsafeArgv;
}

__objc2_class **one-time initialization function for _arguments(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  }
  uint64_t v3 = 0;
  while (*(void *)(static CommandLine._unsafeArgv + 8 * v3))
  {
    if (++v3 == 0x80000000)
    {
      __break(1u);
      break;
    }
  }
  uint64_t result = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg549_ss11CommandLineO10_argumentsSaySSGvpZfiSSSiXEfU_Tf1cn_n(0, v3);
  static CommandLine._arguments = (uint64_t)result;
  return result;
}

unint64_t static CommandLine.arguments.getter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _arguments != -1) {
    swift_once(&one-time initialization token for _arguments, (dispatch_function_t)one-time initialization function for _arguments, a3);
  }
  unint64_t v3 = static CommandLine._arguments;

  return swift_bridgeObjectRetain(v3);
}

void static CommandLine.arguments.setter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _arguments != -1) {
    swift_once(&one-time initialization token for _arguments, (dispatch_function_t)one-time initialization function for _arguments, a3);
  }
  uint64_t v4 = static CommandLine._arguments;
  static CommandLine._arguments = a1;

  swift_bridgeObjectRelease(v4);
}

void (*static CommandLine.arguments.modify(void *a1, uint64_t a2, void *a3))(uint64_t *a1)
{
  if (one-time initialization token for _arguments != -1) {
    swift_once(&one-time initialization token for _arguments, (dispatch_function_t)one-time initialization function for _arguments, a3);
  }
  unint64_t v4 = static CommandLine._arguments;
  *a1 = static CommandLine._arguments;
  swift_bridgeObjectRetain(v4);
  return static CommandLine.arguments.modify;
}

void static CommandLine.arguments.modify(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = static CommandLine._arguments;
  static CommandLine._arguments = v1;
  swift_bridgeObjectRelease(v2);
}

void _SliceBuffer.owner.setter(void *a1)
{
  swift_unknownObjectRelease(*v1);
  *uint64_t v1 = a1;
}

uint64_t (*_SliceBuffer.owner.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _SliceBuffer.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t _SliceBuffer.startIndex.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*_SliceBuffer.startIndex.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer.endIndexAndFlags.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t _SliceBuffer.endIndexAndFlags.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*_SliceBuffer.endIndexAndFlags.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer._hasNativeBuffer.getter(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  return a4 & 1;
}

__objc2_class **_SliceBuffer.nativeBuffer.getter(void *a1)
{
  uint64_t v2 = type metadata accessor for __ContiguousArrayStorageBase();
  id v3 = swift_unknownObjectRetain(a1);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v3, v2);
  if (!result)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyArrayStorage;
  }
  return result;
}

Swift::Bool __swiftcall _SliceBuffer.isUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull(*v0);
}

uint64_t _SliceBuffer.endIndex.setter(uint64_t result)
{
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  *(void *)(v1 + 24) = *(void *)(v1 + 24) & 1 | (2 * result);
  return result;
}

__objc2_class **_SliceBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:)(uint64_t a1, uint64_t a2)
{
  if (!swift_isUniquelyReferenced_nonNull(*v2)) {
    return 0;
  }
  unint64_t v6 = v2[2];
  unint64_t v5 = v2[3];
  unint64_t v7 = (v5 >> 1) - v6;
  if (__OFSUB__(v5 >> 1, v6))
  {
    __break(1u);
    goto LABEL_23;
  }
  unint64_t v8 = v2[1];
  if ((v5 & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v9 = (void *)*v2;
  uint64_t v10 = type metadata accessor for __ContiguousArrayStorageBase();
  id v11 = swift_unknownObjectRetain(v9);
  uint64_t v12 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v11, v10);
  if (!v12)
  {
    swift_unknownObjectRelease(v9);
    uint64_t v12 = &_swiftEmptyArrayStorage;
  }
  uint64_t v13 = *(void *)(*(void *)(a2 + 16) - 8);
  uint64_t v14 = v12[2];
  if ((__objc2_class **)(v8 + *(void *)(v13 + 72) * v6 + *(void *)(v13 + 72) * v7) != (__objc2_class **)((char *)v12 + ((*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80)) + *(void *)(v13 + 72) * (void)v14))
  {
    swift_release((uint64_t)v12);
LABEL_8:
    int64_t v15 = v7;
    goto LABEL_10;
  }
  unint64_t v16 = (unint64_t)v12[3];
  swift_release((uint64_t)v12);
  unint64_t v17 = (v16 >> 1) - (void)v14;
  BOOL v18 = __OFADD__(v7, v17);
  int64_t v15 = v7 + v17;
  if (v18)
  {
    __break(1u);
    goto LABEL_27;
  }
LABEL_10:
  if (v15 < a1) {
    return 0;
  }
  int64_t v20 = (void *)*v2;
  uint64_t v21 = type metadata accessor for __ContiguousArrayStorageBase();
  id v22 = swift_unknownObjectRetain(v20);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v22, v21);
  if (!result)
  {
    swift_unknownObjectRelease(v20);
    uint64_t result = &_swiftEmptyArrayStorage;
  }
  uint64_t v41 = result;
  uint64_t v25 = *(void *)(a2 + 16);
  uint64_t v26 = *(void *)(v25 - 8);
  uint64_t v27 = *(void *)(v26 + 72);
  if (!v27) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  int64_t v28 = v8
      + v27 * v6
      - ((void)result
       + ((*(unsigned __int8 *)(v26 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v26 + 80)));
  if (v27 == -1 && v28 == 0x8000000000000000) {
LABEL_27:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  uint64_t v30 = v28 / v27;
  uint64_t v31 = v7 + v30;
  if (__OFADD__(v7, v30))
  {
    __break(1u);
    goto LABEL_25;
  }
  uint64_t v21 = (uint64_t)result[2];
  if (v31 < v21)
  {
LABEL_25:
    unint64_t v32 = (unint64_t *)type metadata accessor for _ContiguousArrayBuffer(0, v25, v23, v24);
    Swift::String::Index v35 = (unint64_t *)type metadata accessor for EmptyCollection(0, v25, v33, v34);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _ContiguousArrayBuffer<A>, v32, v36);
    unint64_t v39 = (int **)swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, v35, v38);
    _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(v31, v21, 0, v40, (uint64_t)v32, (uint64_t)v35, WitnessTable, v39);
    return v41;
  }
  return result;
}

char *_SliceBuffer._copyContents(initializing:)@<X0>(char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, unint64_t *a7@<X6>, void *a8@<X8>)
{
  if (a2 < 1) {
    goto LABEL_15;
  }
  if (__OFSUB__(a6 >> 1, a5))
  {
    __break(1u);
    goto LABEL_18;
  }
  if ((uint64_t)((a6 >> 1) - a5) >= a2) {
    uint64_t v13 = a2;
  }
  else {
    uint64_t v13 = (a6 >> 1) - a5;
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/SliceBuffer.swift", 23, 2, 0x112uLL, 0);
  }
  uint64_t v14 = *(void *)(*(a7 - 1) + 72);
  if (v13 < 0) {
LABEL_18:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  int64_t v15 = (char *)(a4 + v14 * a5);
  uint64_t v16 = v14 * v13;
  unint64_t v17 = &result[v16];
  BOOL v18 = &v15[v16];
  if (v15 < v17 && v18 > result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  uint64_t result = swift_arrayInitWithCopy(result, v15, v13, a7);
  uint64_t v20 = a5 + v13;
  if (__OFADD__(a5, v13))
  {
    __break(1u);
LABEL_15:
    uint64_t v13 = 0;
    uint64_t v20 = a5;
  }
  *a8 = a3;
  a8[1] = a4;
  a8[2] = a5;
  a8[3] = a6;
  a8[4] = v20;
  a8[5] = v13;
  return result;
}

uint64_t key path getter for _SliceBuffer.count : <A>_SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = _SliceBuffer.count.getter(a1, a2, *(void *)(a1 + 16), *(void *)(a1 + 24));
  *a3 = result;
  return result;
}

__objc2_class **key path setter for _SliceBuffer.count : <A>_SliceBuffer<A>(__objc2_class ***a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  type metadata accessor for _SliceBuffer(0, *(void *)(a4 + a3 - 8), a3, a4);
  return _SliceBuffer.count.setter(v4);
}

__objc2_class **(*_SliceBuffer.count.modify(__objc2_class **(*result)(__objc2_class **result, char a2), uint64_t a2))(__objc2_class **result, char a2)
{
  *((void *)result + 1) = a2;
  *((void *)result + 2) = v2;
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24) >> 1;
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5)
  {
    __break(1u);
  }
  else
  {
    *(void *)uint64_t result = v6;
    return _SliceBuffer.count.modify;
  }
  return result;
}

__objc2_class **_SliceBuffer.count.modify(__objc2_class **result, char a2)
{
  uint64_t v2 = result[2];
  if (a2) {
    return _SliceBuffer.count.setter(&(*result)->isa);
  }
  cache = v2->cache;
  unint64_t v4 = (unint64_t)v2->vtable >> 1;
  BOOL v5 = __OFSUB__(v4, cache);
  unint64_t v6 = v4 - (void)cache;
  if (v5)
  {
    __break(1u);
    goto LABEL_13;
  }
  unint64_t v7 = (char *)*result - v6;
  if (__OFSUB__(*result, v6))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (!v7) {
    return result;
  }
  isa = v2->isa;
  uint64_t v9 = type metadata accessor for __ContiguousArrayStorageBase();
  id v10 = swift_unknownObjectRetain(isa);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v10, v9);
  if (!result)
  {
    swift_unknownObjectRelease(isa);
    uint64_t result = &_swiftEmptyArrayStorage;
  }
  id v11 = result[2];
  BOOL v5 = __OFADD__(v11, v7);
  uint64_t v12 = (__objc2_class *)&v7[(void)v11];
  if (v5) {
    goto LABEL_14;
  }
  result[2] = v12;
  swift_release((uint64_t)result);
  uint64_t result = (__objc2_class **)&v7[v4];
  if (__OFADD__(v4, v7))
  {
LABEL_15:
    __break(1u);
    return result;
  }
  return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
}

uint64_t _SliceBuffer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, a2 + *(void *)(*(void *)(a3 - 8) + 72) * a1, a3);
}

uint64_t key path getter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return _SliceBuffer.subscript.getter(*a2, *(void *)(a1 + 8), *(uint64_t *)((char *)a2 + a3 - 8), a4);
}

uint64_t key path setter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v7 = (char *)&v15 - v6;
  uint64_t v9 = *v8;
  (*(void (**)(char *))(v10 + 16))((char *)&v15 - v6);
  return _SliceBuffer.subscript.setter((uint64_t)v7, v9, v11, *(void *)(a2 + 8), v12, v13, v5);
}

uint64_t _SliceBuffer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a7 - 8) + 40))(a4 + *(void *)(*(void *)(a7 - 8) + 72) * a2, a1, a7);
}

void (*_SliceBuffer.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7))(uint64_t a1)
{
  uint64_t v11 = malloc(0x30uLL);
  *a1 = v11;
  v11[1] = a4;
  v11[2] = a7;
  *uint64_t v11 = a2;
  uint64_t v12 = *(void *)(a7 - 8);
  uint64_t v13 = v12;
  v11[3] = v12;
  v11[4] = malloc(*(void *)(v12 + 64));
  uint64_t v14 = *(void (**)(void))(v13 + 16);
  v11[5] = *(void *)(v13 + 72);
  v14();
  return _SliceBuffer.subscript.modify;
}

void _SliceBuffer.subscript.modify(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 32);
  (*(void (**)(void, void *, void))(*(void *)(*(void *)a1 + 24) + 40))(*(void *)(*(void *)a1 + 8) + **(void **)a1 * *(void *)(*(void *)a1 + 40), v2, *(void *)(*(void *)a1 + 16));
  free(v2);

  free(v1);
}

id key path getter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = (void *)specialized _SliceBuffer.subscript.getter(*a2, a2[1], *a1);
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;

  return swift_unknownObjectRetain(v4);
}

void key path setter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A(void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  type metadata accessor for _SliceBuffer(0, *(void *)(a4 + a3 - 8), a3, a4);
  swift_unknownObjectRetain(v4);
  specialized _SliceBuffer.subscript.setter();
}

void _SliceBuffer.subscript.setter()
{
}

void (*_SliceBuffer.subscript.modify(void *a1, uint64_t a2, uint64_t a3))(id *a1, char a2)
{
  uint64_t v7 = *(void *)(v3 + 8);
  id v8 = swift_unknownObjectRetain(*(id *)v3);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v8, v7, a2, a3);
  *a1 = v9;
  a1[1] = v10;
  a1[2] = v11;
  a1[3] = v12;
  return _SliceBuffer.subscript.modify;
}

void _SliceBuffer.subscript.modify(id *a1, char a2)
{
}

void _ArrayBuffer.subscript.modify(id *a1, char a2, const char *a3, uint64_t a4, unint64_t a5)
{
  if ((a2 & 1) == 0) {
    swift_unknownObjectRelease(*a1);
  }
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0x6C706D6920746F6ELL, 0xEF6465746E656D65, a3, a4, 2, a5, 0);
}

unint64_t key path getter for _SliceBuffer.endIndex : <A>_SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t result = _SliceBuffer.endIndex.getter(a1, a2, a3, *(void *)(a1 + 24));
  *a4 = result;
  return result;
}

uint64_t key path setter for _SliceBuffer.endIndex : <A>_SliceBuffer<A>(uint64_t *a1)
{
  return _SliceBuffer.endIndex.setter(*a1);
}

uint64_t (*_SliceBuffer.endIndex.modify(void *a1, uint64_t a2))(uint64_t *a1, char a2)
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 24) >> 1;
  return _SliceBuffer.endIndex.modify;
}

uint64_t _SliceBuffer.endIndex.modify(uint64_t *a1, char a2)
{
  uint64_t result = *a1;
  if (a2) {
    return _SliceBuffer.endIndex.setter(result);
  }
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  *(void *)(a1[2] + 24) = *(void *)(a1[2] + 24) & 1 | (2 * result);
  return result;
}

uint64_t _SliceBuffer.withUnsafeMutableBufferPointer<A>(_:)(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3[2];
  uint64_t v5 = v3[3] >> 1;
  if (__OFSUB__(v5, v4))
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (v5 - v4 < 0) {
    goto LABEL_5;
  }
  return a1(v3[1] + *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 72) * v4);
}

double protocol witness for _ArrayBufferProtocol.init() in conformance _SliceBuffer<A>@<D0>(uint64_t a1@<X8>)
{
  _SliceBuffer.init()();
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(void *)(a1 + 8) = v2;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_18162ACB0;
  return result;
}

uint64_t protocol witness for _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = _SliceBuffer.init(_buffer:shiftedToStartIndex:)(a1, a2);
  *a3 = result;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

char *protocol witness for _ArrayBufferProtocol._copyContents(subRange:initializing:) in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return _SliceBuffer._copyContents(subRange:initializing:)(a1, a2, a3, *(void **)v7, *(void *)(v7 + 8), a6, a7, *(unint64_t **)(a4 + 16));
}

__objc2_class **protocol witness for _ArrayBufferProtocol.requestNativeBuffer() in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return _SliceBuffer.requestNativeBuffer()(*(void **)v2, a2, *(void *)(v2 + 16), *(void *)(v2 + 24));
}

uint64_t protocol witness for _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:) in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return _SliceBuffer.replaceSubrange<A>(_:with:elementsOf:)(a1, a2, a3, a4, a7, a5, a6);
}

id protocol witness for _ArrayBufferProtocol.subscript.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)specialized _SliceBuffer.subscript.getter(a1, a2, *v2);
  return swift_unknownObjectRetain(v3);
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:) in conformance _SliceBuffer<A>(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.withUnsafeBufferPointer<A>(_:)(a1, a2, a3, *(void *)(v4 + 8), *(void *)(v4 + 16), *(void *)(v4 + 24), *(void *)(a4 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:) in conformance _SliceBuffer<A>(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.withUnsafeMutableBufferPointer<A>(_:)(a1, a2, a4);
}

__objc2_class **(*protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>(__objc2_class **(*result)(__objc2_class **result, char a2), uint64_t a2))(__objc2_class **result, char a2)
{
  *((void *)result + 1) = v2;
  *((void *)result + 2) = a2;
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24) >> 1;
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5)
  {
    __break(1u);
  }
  else
  {
    *(void *)uint64_t result = v6;
    return protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>;
  }
  return result;
}

__objc2_class **protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>(__objc2_class **result, char a2)
{
  if (a2) {
    return _SliceBuffer.count.setter(&(*result)->isa);
  }
  uint64_t v2 = result[1];
  cache = v2->cache;
  unint64_t v4 = (unint64_t)v2->vtable >> 1;
  BOOL v5 = __OFSUB__(v4, cache);
  unint64_t v6 = v4 - (void)cache;
  if (v5)
  {
    __break(1u);
    goto LABEL_13;
  }
  uint64_t v7 = (char *)*result - v6;
  if (__OFSUB__(*result, v6))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (!v7) {
    return result;
  }
  isa = v2->isa;
  uint64_t v9 = type metadata accessor for __ContiguousArrayStorageBase();
  id v10 = swift_unknownObjectRetain(isa);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v10, v9);
  if (!result)
  {
    swift_unknownObjectRelease(isa);
    uint64_t result = &_swiftEmptyArrayStorage;
  }
  uint64_t v11 = result[2];
  BOOL v5 = __OFADD__(v11, v7);
  uint64_t v12 = (__objc2_class *)&v7[(void)v11];
  if (v5) {
    goto LABEL_14;
  }
  result[2] = v12;
  swift_release((uint64_t)result);
  uint64_t result = (__objc2_class **)&v7[v4];
  if (__OFADD__(v4, v7))
  {
LABEL_15:
    __break(1u);
    return result;
  }
  return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
}

uint64_t protocol witness for _ArrayBufferProtocol.capacity.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for _ArrayProtocol.capacity.getter in conformance ArraySlice<A>(a1, a2, _SliceBuffer.capacity.getter);
}

id protocol witness for _ArrayBufferProtocol.owner.getter in conformance _SliceBuffer<A>()
{
  return swift_unknownObjectRetain(*v0);
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddress.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.firstElementAddress.getter(a1, *(void *)(v4 + 8), *(void *)(v4 + 16), a4, *(void *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddressIfContiguous.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.firstElementAddressIfContiguous.getter(a1, *(void *)(v4 + 8), *(void *)(v4 + 16), a4, *(void *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.subscriptBaseAddress.getter in conformance _SliceBuffer<A>()
{
  return *(void *)(v0 + 8);
}

uint64_t protocol witness for _ArrayBufferProtocol.identity.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ArraySlice._baseAddress.getter(a1, *(void *)(v4 + 8), *(void *)(v4 + 16), a4, *(void *)(a1 + 16));
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return _SliceBuffer.subscript.setter(a1, *a2, a3, *(void *)(v6 + 8), a5, a6, *(void *)(a3 + 16));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(void *a1, uint64_t *a2, uint64_t a3))(void **a1)
{
  uint64_t v7 = malloc(0x30uLL);
  *a1 = v7;
  uint64_t v8 = *(void *)(a3 + 16);
  *uint64_t v7 = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = v9;
  v7[1] = v9;
  uint64_t v11 = malloc(*(void *)(v9 + 64));
  uint64_t v12 = *a2;
  v7[2] = v11;
  v7[3] = v12;
  v7[4] = *(void *)(v3 + 8);
  uint64_t v13 = *(void (**)(void))(v10 + 16);
  v7[5] = *(void *)(v10 + 72);
  v13();
  return protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)(*a1)[2];
  (*(void (**)(void, void *, void))((*a1)[1] + 40))((*a1)[4] + (*a1)[3] * (*a1)[5], v2, **a1);
  free(v2);

  free(v1);
}

void protocol witness for MutableCollection.subscript.setter in conformance _SliceBuffer<A>()
{
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(void *a1, uint64_t *a2))(id *a1, char a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = *(void *)(v2 + 8);
  id v7 = swift_unknownObjectRetain(*(id *)v2);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v7, v6, v4, v5);
  *a1 = v8;
  a1[1] = v9;
  a1[2] = v10;
  a1[3] = v11;
  return protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(id *a1, char a2)
{
}

void protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>(id *a1, char a2, const char *a3, unint64_t a4)
{
  if ((a2 & 1) == 0) {
    swift_unknownObjectRelease(*a1);
  }
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0x6C706D6920746F6ELL, 0xEF6465746E656D65, a3, 23, 2, a4, 0);
}

void *protocol witness for MutableCollection.partition(by:) in conformance _SliceBuffer<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a3, (uint64_t)a3);
  return MutableCollection<>.partition(by:)(a1, a2, (uint64_t)a3, WitnessTable, a4, a5);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a2, a3);

  return RandomAccessCollection<>.index(before:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a4, a3);

  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, (uint64_t)a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a3, (uint64_t)a3);

  return RandomAccessCollection<>.distance(from:to:)(a1, a2, (uint64_t)a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

unint64_t protocol witness for Collection.endIndex.getter in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t result = _SliceBuffer.endIndex.getter(a1, a2, a3, *(void *)(v4 + 24));
  *a4 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _SliceBuffer<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  id v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = _SliceBuffer.subscript.read(v7, *a2, *v3, v3[1], v3[2], v3[3], *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*_SliceBuffer.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7))()
{
  uint64_t v7 = *(void *)(a7 - 8);
  uint64_t v8 = v7;
  *a1 = a7;
  a1[1] = v7;
  a1[2] = malloc(*(void *)(v7 + 64));
  (*(void (**)(void))(v8 + 16))();
  return _ArrayBuffer.subscript.read;
}

id protocol witness for Collection.subscript.getter in conformance _SliceBuffer<A>@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (void *)specialized _SliceBuffer.subscript.getter(*a1, a1[1], *v2);
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;

  return swift_unknownObjectRetain(v4);
}

uint64_t protocol witness for Collection.indices.getter in conformance _SliceBuffer<A>@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a2);

  return RandomAccessCollection<>.indices.getter((uint64_t)a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.count.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return _SliceBuffer.count.getter(a1, a2, *(void *)(v2 + 16), *(void *)(v2 + 24));
}

uint64_t protocol witness for Collection.index(after:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a2, a3);

  return RandomAccessCollection<>.index(after:)(a1, (uint64_t)a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance _SliceBuffer<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(a1, a2, a3, (void *(*)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(void *a1, unint64_t *a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, unint64_t *, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  unint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _SliceBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for _ArrayProtocol.capacity.getter in conformance ArraySlice<A>(a1, a2, (uint64_t (*)(void, void, void, void, void))_SliceBuffer._copyToContiguousArray());
}

uint64_t protocol witness for _ArrayProtocol.capacity.getter in conformance ArraySlice<A>(uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, void, void))
{
  return a3(*v3, v3[1], v3[2], v3[3], *(void *)(a1 + 16));
}

__objc2_class **_SliceBuffer._copyToContiguousArray()(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  if ((a4 & 1) == 0)
  {
    uint64_t v10 = (a4 >> 1) - a3;
    if (!__OFSUB__(a4 >> 1, a3))
    {
      if (v10 > 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
    __break(1u);
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }
  uint64_t v21 = type metadata accessor for __ContiguousArrayStorageBase();
  id v22 = swift_unknownObjectRetain(a1);
  uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v22, v21);
  if (!v15)
  {
    swift_unknownObjectRelease(a1);
    uint64_t v15 = &_swiftEmptyArrayStorage;
  }
  BOOL v23 = __OFSUB__(a4 >> 1, a3);
  uint64_t v10 = (a4 >> 1) - a3;
  if (v23) {
    goto LABEL_20;
  }
  if ((__objc2_class *)v10 != v15[2])
  {
    swift_release((uint64_t)v15);
    if (v10 > 0)
    {
LABEL_4:
      uint64_t v11 = getContiguousArrayStorageType<A>(for:)((uint64_t)a5, a5);
      uint64_t v12 = *(a5 - 1);
      uint64_t v13 = *(void *)(v12 + 72);
      uint64_t v14 = *(unsigned __int8 *)(v12 + 80);
      uint64_t v15 = (__objc2_class **)swift_allocObject((unint64_t *)v11, ((v14 + *((unsigned int *)v11 + 12)) & ~v14) + v13 * v10, v14 | *((unsigned __int16 *)v11 + 26));
      size_t v16 = _swift_stdlib_malloc_size(v15);
      if (v13)
      {
        int64_t v17 = v16 - ((v14 + 32) & ~v14);
        if (v17 == 0x8000000000000000 && v13 == -1) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
        }
        uint64_t v19 = v17 / v13;
        swift_retain((atomic_ullong *)v15);
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
        void v15[2] = (__objc2_class *)v10;
        v15[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v19));
        swift_unknownObjectRelease(a1);
        swift_release((uint64_t)v15);
        goto LABEL_17;
      }
LABEL_21:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    }
LABEL_16:
    swift_unknownObjectRelease(a1);
    uint64_t v12 = *(a5 - 1);
    uint64_t v15 = &_swiftEmptyArrayStorage;
LABEL_17:
    UnsafeMutablePointer.initialize(from:count:)((char *)(a2 + *(void *)(v12 + 72) * a3), v10, (char *)v15 + ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80)), (unint64_t *)a5);
    return v15;
  }
  swift_unknownObjectRelease(a1);
  return v15;
}

__n128 protocol witness for Sequence._copyContents(initializing:) in conformance _SliceBuffer<A>(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  _SliceBuffer._copyContents(initializing:)(a2, a3, *(void *)v4, *(void *)(v4 + 8), *(void *)(v4 + 16), *(void *)(v4 + 24), *(unint64_t **)(a4 + 16), v8);
  uint64_t v6 = v9;
  __n128 result = (__n128)v8[1];
  *(_OWORD *)a1 = v8[0];
  *(__n128 *)(a1 + 16) = result;
  *(void *)(a1 + 32) = v6;
  return result;
}

Swift::Int __swiftcall StaticBigInt.signum()()
{
  if (v0) {
    return -1;
  }
  else {
    return (v0 & 0xFFFFFFFFFFFFFF00) != 256;
  }
}

uint64_t StaticBigInt._isNegative.getter(uint64_t a1, char a2)
{
  return a2 & 1;
}

unint64_t StaticBigInt.bitWidth.getter(uint64_t a1, unint64_t a2)
{
  return a2 >> 8;
}

uint64_t StaticBigInt.subscript.getter(unint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a1 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/StaticBigInt.swift", 24, 2, 0x7BuLL, 0);
  }
  if (a1 >> 57 || (uint64_t)(a1 << 6) >= (uint64_t)(a3 >> 8)) {
    return -(uint64_t)(a3 & 1);
  }
  else {
    return *(void *)(a2 + 8 * a1);
  }
}

uint64_t StaticBigInt.debugDescription.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2) {
    unint64_t v2 = 7876653;
  }
  else {
    unint64_t v2 = 7876651;
  }
  unint64_t v3 = ((a2 >> 8) + 2) >> 2;
  uint64_t v4 = v3 + 3;
  unint64_t v5 = a2 >> 9;
  if (a2 >> 9 >= 0x19)
  {
    unint64_t v10 = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(v3 + 3, v3 + 3, a2 & 1, a1, a2);
    unint64_t v14 = v21;
  }
  else
  {
    uint8x16_t v23 = (uint8x16_t)xmmword_18162AE10;
    closure #1 in StaticBigInt.debugDescription.getter((uint64_t)&v23, v4, v4, a2 & 1, a1, a2);
    char v6 = 8;
    if (v4 >= 8) {
      char v7 = 8;
    }
    else {
      char v7 = v4;
    }
    if (v4 > 8) {
      char v6 = v4;
    }
    unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v7) & 0x38);
    unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v6) & 0x38);
    if (v5 <= 0xA) {
      unint64_t v9 = 0;
    }
    unint64_t v10 = v23.i64[0] & v8;
    uint64_t v11 = v23.i64[1] & v9;
    BOOL v12 = ((v11 | v23.i64[0] & v8) & 0x8080808080808080) == 0;
    unint64_t v13 = 0xA000000000000000;
    if (v12) {
      unint64_t v13 = 0xE000000000000000;
    }
    unint64_t v14 = v13 | (v4 << 56) | v11;
    if ((v14 & 0x4000000000000000) == 0)
    {
      v23.i64[0] = v10;
      v23.i64[1] = v11 & 0xFFFFFFFFFFFFFFLL;
      closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v23, HIBYTE(v14) & 0xF, v22);
      unint64_t v10 = v22[0];
      unint64_t v14 = v22[1];
    }
  }
  v23.i64[0] = v10;
  v23.i64[1] = v14;
  swift_bridgeObjectRetain(v14);
  Swift::UInt64 v15 = specialized Collection.firstIndex(where:)(v10, v14);
  char v17 = v16;
  swift_bridgeObjectRelease(v14);
  if (v17)
  {
    swift_bridgeObjectRelease(0xE300000000000000);
    swift_bridgeObjectRelease(v14);
    return 813183019;
  }
  else
  {
    v18._Swift::UInt64 rawBits = 15;
    v19._Swift::UInt64 rawBits = v15;
    specialized String.replaceSubrange<A>(_:with:)(v18, v19, v2, 0xE300000000000000);
    swift_bridgeObjectRelease(0xE300000000000000);
    return v23.i64[0];
  }
}

uint64_t closure #1 in StaticBigInt.debugDescription.getter(uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8 = specialized Collection.prefix(_:)(a3, a1, a2);
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  specialized Slice.initialize<A>(repeating:)((void *)0x30, v8, v9, v11);
  unint64_t v13 = 0;
  unint64_t v14 = a6 >> 8;
  BOOL v15 = a4;
  while (v13 < v14)
  {
    unint64_t v17 = -(uint64_t)(a6 & 1);
    if ((v13 & 0x7FFFFFFFFFFFFFC0) < v14) {
      unint64_t v17 = *(void *)(a5 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8));
    }
    unint64_t v18 = v17 >> (v13 & 0x20);
    if (v15)
    {
      BOOL v19 = !a4;
      a4 = a4 && ~v18 == -1;
      if (v19) {
        LODWORD(v18) = ~v18;
      }
      else {
        LODWORD(v18) = -(int)v18;
      }
    }
    Swift::String v20 = _uint64ToString(_:radix:uppercase:)(v18, 16, 1);
    if (((uint64_t)v20._object & 0x1000000000000000) != 0)
    {
      unint64_t v21 = String.UTF8View._foreignCount()();
      if ((v21 & 0x8000000000000000) != 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't take a suffix of negative length from a collection", 56, 2, "Swift/BidirectionalCollection.swift", 35, 2, 0x19BuLL, 0);
      }
    }
    else if (((uint64_t)v20._object & 0x2000000000000000) != 0)
    {
      unint64_t v21 = ((unint64_t)v20._object >> 56) & 0xF;
    }
    else
    {
      unint64_t v21 = v20._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v22 = v8 - v10;
    if (__OFSUB__(v8, v10))
    {
      unint64_t v28 = 271;
      goto LABEL_42;
    }
    uint64_t v23 = -(uint64_t)v21;
    if (v22 > 0 || (uint64_t v24 = v8, v22 <= v23))
    {
      uint64_t v24 = v10 - v21;
      if (__OFADD__(v10, v23))
      {
LABEL_39:
        unint64_t v28 = 279;
        goto LABEL_42;
      }
    }
    if (v10 < v24) {
      goto LABEL_36;
    }
    if (v24 < v8)
    {
      unint64_t v28 = 571;
      goto LABEL_42;
    }
    if (v12) {
      uint64_t v25 = (char *)(v12 + v24);
    }
    else {
      uint64_t v25 = 0;
    }
    if (v10 - v24 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    }
    if (v10 != v24 && !v25) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer has a nil start and nonzero count", 60, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x49uLL, 0);
    }
    specialized UnsafeMutableBufferPointer.update<A>(fromContentsOf:)(v20._countAndFlagsBits, (unint64_t)v20._object, v25, v10 - v24);
    swift_bridgeObjectRelease((uint64_t)v20._object);
    uint64_t v26 = v8;
    if ((unint64_t)(v22 + 7) >= 8)
    {
      uint64_t v26 = v10 - 8;
      if (__OFSUB__(v10, 8)) {
        goto LABEL_39;
      }
      if (v26 < v8) {
LABEL_36:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    v13 += 32;
    BOOL v16 = v10 < v26;
    uint64_t v10 = v26;
    if (v16)
    {
      unint64_t v28 = 572;
LABEL_42:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v28, 0);
    }
  }
  return a3;
}

void *specialized Slice.initialize<A>(repeating:)(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    unint64_t v5 = (void *)(a4 + a2);
  }
  else {
    unint64_t v5 = 0;
  }
  int64_t v6 = a3 - a2;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (v6)
  {
    if (!v5) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer has a nil start and nonzero count", 60, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x49uLL, 0);
    }
  }
  else if (!v5)
  {
    return result;
  }

  return specialized UnsafeMutablePointer.initialize(repeating:count:)(result, v6, v5);
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.addingReportingOverflow(_:)(Swift::UInt32 a1)
{
  Swift::UInt32 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance StaticBigInt()
{
  return StaticBigInt.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t StaticBigInt.customMirror.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, a2, 8, 0, 0, a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance StaticBigInt@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, v1[1], 8, 0, 0, a1);
}

uint64_t UInt128._value.setter(uint64_t result, uint64_t a2)
{
  *Swift::UInt32 v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*UInt128._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t static UInt128.zero.getter()
{
  return 0;
}

uint64_t static UInt128.min.getter()
{
  return 0;
}

uint64_t static UInt128.max.getter()
{
  return -1;
}

uint64_t UInt128.init<A>(exactly:)(uint64_t a1, uint64_t a2, void *a3)
{
  id v68 = *(int ***)(a3[3] + 16);
  uint64_t AssociatedTypeWitness = (uint64_t)swift_getAssociatedTypeWitness(0, v68, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v67 = (char *)&v62 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  char v63 = (char *)&v62 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v70 = (char *)&v62 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  BOOL v15 = (char *)&v62 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  unint64_t v18 = (char *)&v62 - v17;
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  unint64_t v21 = (char *)&v62 - v20;
  unint64_t v75 = 64;
  uint64_t v22 = (void (*)(uint64_t, unint64_t *, ValueMetadata *, unint64_t, uint64_t, void *))a3[30];
  unint64_t v25 = lazy protocol witness table accessor for type Int and conformance Int(v19, v23, v24);
  uint64_t v26 = (char *)a1;
  v22(a1, &v75, &type metadata for Int, v25, a2, a3);
  unint64_t v65 = (uint64_t (*)(uint64_t, void *))a3[8];
  LOBYTE(a1) = v65(a2, a3);
  uint64_t v73 = v8;
  char v74 = v21;
  uint64_t v69 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  v69(v18, v21, a2);
  uint64_t v71 = v26;
  if (a1)
  {
    uint64_t v27 = v68;
    uint64_t v28 = AssociatedTypeWitness;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v68, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v30 = v67;
    (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v28, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v27[3])(v30, a2, v27);
    char v31 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3[4] + 8) + 16))(v18, v15, a2);
    unint64_t v32 = *(void (**)(char *, uint64_t))(v73 + 8);
    v32(v15, a2);
    v32(v18, a2);
    if (v31)
    {
      v32(v74, a2);
      uint64_t v33 = v71;
LABEL_19:
      v32(v33, a2);
      return 0;
    }
    uint64_t v64 = v15;
    uint64_t v34 = a3;
    unint64_t v66 = v32;
    uint64_t v35 = v28;
  }
  else
  {
    uint64_t v64 = v15;
    uint64_t v34 = a3;
    unint64_t v66 = *(void (**)(char *, uint64_t))(v73 + 8);
    v66(v18, a2);
    uint64_t v35 = AssociatedTypeWitness;
  }
  uint64_t v36 = (uint64_t (*)(uint64_t, void *))v34[16];
  unint64_t v37 = v74;
  uint64_t v38 = v36(a2, v34);
  unint64_t v39 = v70;
  v69(v70, v37, a2);
  if (v38 <= 63)
  {
    unint64_t v32 = v66;
    v66(v39, a2);
    uint64_t v33 = v71;
    goto LABEL_8;
  }
  unint64_t v75 = -1;
  char v43 = v65(a2, v34);
  uint64_t v44 = v36(a2, v34);
  if ((v43 & 1) == 0)
  {
    uint64_t v33 = v71;
    if (v44 < 65)
    {
      unint64_t v59 = v64;
      (*(void (**)(char *, char *, uint64_t))(v73 + 32))(v64, v39, a2);
      unint64_t v60 = ((uint64_t (*)(uint64_t, void *))v34[15])(a2, v34);
      unint64_t v32 = v66;
      v66(v59, a2);
      if (v75 >= v60) {
        goto LABEL_8;
      }
      goto LABEL_18;
    }
LABEL_15:
    uint64_t v55 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, void *))v34[12];
    unint64_t v56 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v44, v45, v46);
    unint64_t v57 = v64;
    v55(&v75, &type metadata for UInt64, v56, a2, v34);
    char v58 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v34[4] + 8) + 16))(v57, v39, a2);
    unint64_t v32 = v66;
    v66(v57, a2);
    v32(v39, a2);
    if ((v58 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_18:
    v32(v74, a2);
    goto LABEL_19;
  }
  uint64_t v33 = v71;
  if (v44 >= 65) {
    goto LABEL_15;
  }
  unint64_t v47 = v68;
  uint64_t v48 = swift_getAssociatedConformanceWitness((uint64_t)v68, a2, v35, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v49 = v67;
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v48 + 8))(&qword_18162B0B8, 256, v35, v48);
  uint64_t v50 = v64;
  ((void (*)(char *, uint64_t, int **))v47[3])(v49, a2, v47);
  LODWORD(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v34[4] + 8) + 40))(v39, v50, a2);
  uint64_t v51 = v73;
  unint64_t v32 = v66;
  v66(v50, a2);
  unint64_t v52 = v75;
  unint64_t v53 = v63;
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v63, v39, a2);
  if ((AssociatedTypeWitness & 1) == 0)
  {
    v32(v53, a2);
    goto LABEL_8;
  }
  unint64_t v54 = ((uint64_t (*)(uint64_t, void *))v34[15])(a2, v34);
  v32(v53, a2);
  if (v52 < v54) {
    goto LABEL_18;
  }
LABEL_8:
  uint64_t v40 = (void (*)(uint64_t, void *))v34[15];
  uint64_t v41 = v74;
  v40(a2, v34);
  v32(v41, a2);
  uint64_t v42 = ((uint64_t (*)(uint64_t, void *))v40)(a2, v34);
  v32(v33, a2);
  return v42;
}

uint64_t UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized UInt128.init<A>(_:));
}

{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized UInt128.init<A>(_:));
}

uint64_t UInt128.init<A>(clamping:)(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  uint64_t v9 = UInt128.init<A>(exactly:)((uint64_t)v8, a2, a3);
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)(a3[3] + 8) + 16))(a2);
    char v12 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(a3[4] + 8) + 16))(a1, v8, a2);
    uint64_t v13 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
    v13(a1, a2);
    v13((uint64_t)v8, a2);
    return (v12 & 1) - 1;
  }
  else
  {
    uint64_t v11 = v9;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }
  return v11;
}

uint64_t *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt128@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 9 > 0x40 || (a2 & 1) != 0)
  {
    uint64_t v4 = 0;
LABEL_7:
    *a3 = v4;
    a3[1] = 0;
    return result;
  }
  uint64_t v4 = *result;
  if (a2 >> 9 <= 0x20) {
    goto LABEL_7;
  }
  uint64_t v5 = result[1];
  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t UInt128.init<A>(exactly:)(char *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v10 = (char *)&v45 - v9;
  uint64_t v11 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  char v58 = (char *)&v45 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v45 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v45 - v18;
  MEMORY[0x1F4188790](v17);
  unint64_t v59 = (char *)&v45 - v20;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
  uint64_t v22 = *(void (**)(double))(AssociatedConformanceWitness + 8);
  uint64_t v55 = AssociatedTypeWitness;
  uint64_t v51 = AssociatedConformanceWitness + 8;
  uint64_t v52 = AssociatedConformanceWitness;
  uint64_t v50 = v22;
  ((void (*)(const char *, double))v22)(AssociatedTypeWitness, 5.42101086e-20);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 24);
  unint64_t v54 = v10;
  uint64_t v56 = v6;
  uint64_t v48 = v23;
  uint64_t v49 = v6 + 24;
  v23(v10, a2, v6);
  uint64_t v24 = *(void *)(a3 + 16);
  uint64_t v25 = *(void *)(*(void *)(v24 + 16) + 8);
  uint64_t v26 = *(void (**)(char *, char *, uint64_t, uint64_t))(v25 + 64);
  unint64_t v60 = a1;
  uint64_t v53 = v25;
  unint64_t v47 = v26;
  ((void (*)(char *, char *, uint64_t))v26)(a1, v16, a2);
  uint64_t v27 = *(void (**)(char *, uint64_t))(v11 + 8);
  uint64_t v46 = v16;
  v27(v16, a2);
  LOBYTE(v61) = 4;
  uint64_t v28 = *(void (**)(uint64_t *, uint64_t, uint64_t))(v24 + 304);
  size_t v29 = v59;
  uint64_t v30 = v24;
  unint64_t v31 = a3;
  v28(&v61, a2, v30);
  unint64_t v32 = v19;
  v27(v19, a2);
  uint64_t v33 = (*(uint64_t (**)(char *, char *, uint64_t))(v11 + 16))(v19, v29, a2);
  unint64_t v36 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v33, v34, v35);
  unint64_t v57 = v31;
  FixedWidthInteger.init<A>(exactly:)((uint64_t)v19, (uint64_t)&type metadata for UInt64, a2, v36, v31, (uint64_t)&v61);
  if (v62 == 1)
  {
    v27(v60, a2);
    v27(v29, a2);
    return 0;
  }
  uint64_t v45 = v61;
  if (v61)
  {
    unint64_t v37 = v54;
    uint64_t v38 = v29;
    v50(1.84467441e19);
    unint64_t v39 = v46;
    v48(v37, a2, v56);
    uint64_t v40 = v53;
    v47(v39, v38, a2, v53);
    v27(v39, a2);
    v27(v38, a2);
    uint64_t v41 = *(void (**)(uint64_t, char *, uint64_t))(*(void *)(v40 + 8) + 40);
    uint64_t v42 = (uint64_t)v58;
    char v43 = v60;
    v41((uint64_t)v60, v32, a2);
    v27(v43, a2);
    v27(v32, a2);
  }
  else
  {
    v27(v29, a2);
    uint64_t v42 = (uint64_t)v58;
    (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v58, v60, a2);
  }
  FixedWidthInteger.init<A>(exactly:)(v42, (uint64_t)&type metadata for UInt64, a2, v36, v57, (uint64_t)&v61);
  if (v62 == 1) {
    return 0;
  }
  return v61;
}

BOOL static UInt128.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

BOOL static UInt128.< infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return __PAIR128__(a2, a1) < __PAIR128__(a4, a3);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a2 < *a1;
}

void UInt128.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
}

Swift::Int UInt128.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance UInt128()
{
  return UInt128.hashValue.getter(*v0, v0[1]);
}

uint64_t UInt128.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t UInt128.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 - a1;
}

uint64_t UInt128.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  return __udivti3();
}

uint64_t UInt128.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  }
  return __umodti3();
}

uint64_t static UInt128.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = __CFADD__(a1, a3);
  uint64_t result = a1 + a3;
  if (__CFADD__(v4, a2) | __CFADD__(a4, v4 + a2)) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if (v6) {
    __break(1u);
  }
  return result;
}

unint64_t static UInt128.- infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL1 v4 = a1 >= a3;
  unint64_t result = a1 - a3;
  if (!__CFSUB__(a2, a4, v4)) {
    __break(1u);
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt128@<X0>(void *result@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  long long v3 = *(_OWORD *)result + *(_OWORD *)a2;
  if (__CFADD__(__CFADD__(*result, *a2), result[1]) | __CFADD__(a2[1], *((void *)&v3 + 1))) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt128(void *result, unint64_t *a2)
{
  unint64_t v2 = a2[1];
  long long v3 = *(_OWORD *)result + *a2;
  char v4 = __CFADD__(__CFADD__(*result, *a2), result[1]) | __CFADD__(v2, *((void *)&v3 + 1));
  unint64_t v5 = v2 + *((void *)&v3 + 1);
  if (v4) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if (v6)
  {
    __break(1u);
  }
  else
  {
    *unint64_t result = v3;
    result[1] = v5;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt128(_OWORD *result, _OWORD *a2)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

unint64_t static UInt128.* infix(_:_:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a2) {
    BOOL v4 = a4 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  char v7 = !v4 || (a2 * (unsigned __int128)a3) >> 64 != 0 || (a4 * (unsigned __int128)result) >> 64 != 0;
  if (__CFADD__((result * (unsigned __int128)a3) >> 64, a4 * result + a2 * a3)) {
    char v7 = 1;
  }
  if (v7) {
    __break(1u);
  }
  else {
    result *= a3;
  }
  return result;
}

unint64_t *static UInt128.*= infix(_:_:)(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  if (v4) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v8 = !v5 || (v4 * (unsigned __int128)a2) >> 64 != 0 || (a3 * (unsigned __int128)*result) >> 64 != 0;
  unint64_t v9 = a3 * v3 + v4 * a2;
  uint64_t v10 = (v3 * (unsigned __int128)a2) >> 64;
  BOOL v11 = __CFADD__(v10, v9);
  unint64_t v12 = v10 + v9;
  if (v11) {
    char v8 = 1;
  }
  if (v8)
  {
    __break(1u);
  }
  else
  {
    *unint64_t result = v3 * a2;
    result[1] = v12;
  }
  return result;
}

uint64_t static UInt128./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  return __udivti3();
}

uint64_t static UInt128./= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  uint64_t result = __udivti3();
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t static UInt128.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  }
  return __umodti3();
}

uint64_t static UInt128.%= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  }
  uint64_t result = __umodti3();
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))UInt128.init<A>(exactly:), a1);
}

unint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  if (v4) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  char v10 = !v7 || (v4 * (unsigned __int128)*a2) >> 64 != 0 || (v6 * (unsigned __int128)*result) >> 64 != 0;
  unint64_t v11 = v6 * v3 + v4 * v5;
  uint64_t v12 = (v3 * (unsigned __int128)v5) >> 64;
  BOOL v13 = __CFADD__(v12, v11);
  uint64_t v14 = v12 + v11;
  if (v13) {
    char v15 = 1;
  }
  else {
    char v15 = v10;
  }
  if (v15)
  {
    __break(1u);
  }
  else
  {
    *a3 = v3 * v5;
    a3[1] = v14;
  }
  return result;
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt128(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = a2[1];
  unint64_t v4 = *result;
  unint64_t v5 = result[1];
  if (v5) {
    BOOL v6 = v3 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  char v9 = !v6 || (v5 * (unsigned __int128)*a2) >> 64 != 0 || (v3 * (unsigned __int128)*result) >> 64 != 0;
  unint64_t v10 = v3 * v4 + v5 * v2;
  uint64_t v11 = (v4 * (unsigned __int128)v2) >> 64;
  BOOL v12 = __CFADD__(v11, v10);
  unint64_t v13 = v11 + v10;
  if (v12) {
    char v14 = 1;
  }
  else {
    char v14 = v9;
  }
  if (v14)
  {
    __break(1u);
  }
  else
  {
    *uint64_t result = v4 * v2;
    result[1] = v13;
  }
  return result;
}

uint64_t *static UInt128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  unint64_t v2 = result[1];
  uint64_t v3 = ((2 * v2) << ~a2) | ((unint64_t)*result >> a2);
  uint64_t v4 = v2 >> a2;
  if ((a2 & 0x40) != 0)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
  }
  *uint64_t result = v3;
  result[1] = v4;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))UInt128.init<A>(exactly:), a1);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int128@<X0>(uint64_t (*a1)(void)@<X5>, uint64_t a2@<X8>)
{
  uint64_t result = a1();
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(unsigned char *)(a2 + 16) = v5 & 1;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized UInt128.init<A>(_:), a3);
}

{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized UInt128.init<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = UInt128.init<A>(clamping:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt128@<X0>(_OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  if (*a1 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  uint64_t result = __udivti3();
  *a2 = result;
  a2[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  uint64_t result = __udivti3();
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt128@<X0>(_OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  if (*a1 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  }
  uint64_t result = __umodti3();
  *a2 = result;
  a2[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  }
  uint64_t result = __umodti3();
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  int64x2_t v124 = a5;
  uint64_t v114 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v112 = (char *)v109 - v10;
  uint64_t v11 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  char v14 = (char *)v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  size_t v110 = (char *)v109 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v119 = (char *)v109 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  char v118 = (char *)v109 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v111 = (char *)v109 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v120 = (char *)v109 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v125 = (char *)v109 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v28 = (char *)v109 - v27;
  unint64_t v29 = a1[1];
  unint64_t v116 = *a1;
  unint64_t v117 = v29;
  uint64_t v31 = a4 + 64;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v30(a3, a4) & 1) == 0)
  {
    char v35 = v30(a3, a4);
    int8x16_t v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v32 = v126(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v32 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v32 <= 64)
    {
      uint64_t v121 = a4 + 64;
      unint64_t v123 = v30;
      unint64_t v65 = AssociatedTypeWitness;
      unint64_t v66 = v114;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      id v68 = v112;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v65, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v66[3])(v68, a3, v66);
      LOBYTE(v65) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      uint64_t v69 = (void (*)(char *, uint64_t))*((void *)v11 + 1);
      v69(v28, a3);
      unint64_t v122 = v11;
      (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v14, a2, a3);
      if (v65)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
        goto LABEL_25;
      }
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
      uint64_t v11 = v122;
      uint64_t v30 = v123;
      uint64_t v31 = v121;
      if (v70 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v128[0] = -128;
    unint64_t v36 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
    v36(v128, &type metadata for Int, v37, a3, a4);
    char v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
    if (v38) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  int8x16_t v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v32 = v126(a3, a4);
  if (v32 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
  uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
  if (v40 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  char v41 = v30(a3, a4);
  uint64_t v115 = a4 + 128;
  uint64_t v42 = v126(a3, a4);
  unint64_t v123 = v30;
  uint64_t v121 = v31;
  if (v41)
  {
    if (v42 > 64) {
      goto LABEL_12;
    }
  }
  else if (v42 > 63)
  {
LABEL_12:
    v128[0] = 128;
    uint64_t v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v45(v128, &type metadata for Int, v46, a3, a4);
    char v47 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
    uint64_t v48 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
    uint64_t result = v48(v28, a3);
    if (v47) {
      goto LABEL_25;
    }
    goto LABEL_16;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
  uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v48 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
  uint64_t result = v48(v28, a3);
  if (v49 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v50 = v28;
  unint64_t v122 = v48;
  uint64_t v51 = (char *)v11 + 16;
  uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))*((void *)v11 + 2);
  uint64_t v53 = v125;
  v52(v125, a2, a3);
  char v54 = v123(a3, a4);
  uint64_t v55 = v120;
  uint64_t v56 = v53;
  v109[1] = v51;
  unint64_t v57 = (void (*)(char *, char *, uint64_t))v52;
  v52(v120, (uint64_t)v56, a3);
  if ((v54 & 1) == 0)
  {
    v122(v55, a3);
    unint64_t v59 = v50;
    goto LABEL_37;
  }
  uint64_t v58 = v126(a3, a4);
  v122(v55, a3);
  unint64_t v59 = v50;
  unint64_t v60 = v123;
  if (v58 <= 64) {
    goto LABEL_37;
  }
  uint64_t v61 = v111;
  v57(v111, v125, a3);
  v128[0] = 0x8000000000000000;
  if (v60(a3, a4))
  {
    uint64_t v62 = v126(a3, a4);
    if (v62 >= 64)
    {
LABEL_28:
      char v74 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v75 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
      v74(v128, &type metadata for Int, v75, a3, a4);
      uint64_t v61 = v111;
      char v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v111, v59, a3);
      uint64_t v77 = (void (*)(char *, uint64_t))v122;
      v122(v59, a3);
      if (v76) {
        goto LABEL_64;
      }
      goto LABEL_36;
    }
LABEL_32:
    v57(v59, v61, a3);
    uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v77 = (void (*)(char *, uint64_t))v122;
    v122(v59, a3);
    if (v78 < v128[0]) {
LABEL_64:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v73 = v60(a3, a4);
  uint64_t v62 = v126(a3, a4);
  if ((v73 & 1) == 0)
  {
    if (v62 >= 64)
    {
      v122(v61, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v62 > 64) {
    goto LABEL_28;
  }
  uint64_t v80 = AssociatedTypeWitness;
  uint64_t v79 = v114;
  uint64_t v81 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v82 = v112;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v81 + 8))(&qword_18162B0B8, 256, v80, v81);
  ((void (*)(char *, uint64_t, int **))v79[3])(v82, a3, v79);
  uint64_t v83 = v111;
  char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v111, v59, a3);
  uint64_t v85 = (void (*)(char *, uint64_t))v122;
  v122(v59, a3);
  uint64_t v86 = v110;
  v57(v110, v83, a3);
  if (v84)
  {
    v85(v86, a3);
    goto LABEL_64;
  }
  uint64_t v87 = v128[0];
  uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v85(v86, a3);
  BOOL v89 = v88 < v87;
  uint64_t v61 = v111;
  uint64_t v77 = v85;
  if (v89) {
    goto LABEL_64;
  }
LABEL_36:
  v77(v61, a3);
LABEL_37:
  unsigned int v90 = v125;
  uint64_t v91 = v126;
  uint64_t v92 = v126(a3, a4);
  uint64_t v93 = v118;
  v57(v118, v90, a3);
  if (v92 < 65)
  {
    uint64_t v102 = v91(a3, a4);
    v122(v93, a3);
    uint64_t v94 = v119;
    if (v102 != 64 || (v123(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v122(v93, a3);
    uint64_t v94 = v119;
  }
  v57(v94, v125, a3);
  v128[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v95 = v123(a3, a4);
  uint64_t v96 = v126(a3, a4);
  if ((v95 & 1) == 0)
  {
    if (v96 > 63)
    {
      uint64_t v127 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v99 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
      uint64_t v101 = &v127;
      goto LABEL_48;
    }
LABEL_46:
    v57(v59, v94, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v103 = (void (*)(char *, uint64_t))v122;
    v122(v59, a3);
    v103(v94, a3);
    goto LABEL_50;
  }
  if (v96 <= 64) {
    goto LABEL_46;
  }
  uint64_t v99 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
  uint64_t v101 = v128;
LABEL_48:
  v99(v101, &type metadata for Int, v100, a3, a4);
  char v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v59, v94, a3);
  uint64_t v105 = (void (*)(char *, uint64_t))v122;
  v122(v59, a3);
  if (v104) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v105(v94, a3);
LABEL_50:
  uint64_t v106 = v125;
  unint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v122(v106, a3);
  if ((v107 & 0x8000000000000000) == 0)
  {
    if (v107 < 0x80)
    {
      uint64_t v71 = ((2 * v117) << ~(_BYTE)v107) | (v116 >> v107);
      uint64_t v72 = v117 >> v107;
      if ((v107 & 0x40) != 0)
      {
        uint64_t v71 = v117 >> v107;
        uint64_t v72 = 0;
      }
      goto LABEL_54;
    }
LABEL_25:
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    goto LABEL_54;
  }
  if (v107 <= 0xFFFFFFFFFFFFFF80) {
    goto LABEL_25;
  }
  if ((-(uint64_t)v107 & 0x40) != 0) {
    uint64_t v71 = 0;
  }
  else {
    uint64_t v71 = v116 << -(char)v107;
  }
  uint64_t v72 = (v117 << -(char)v107) | (v116 >> 1 >> (v107 - 1));
  if ((-(uint64_t)v107 & 0x40) != 0) {
    uint64_t v72 = v116 << -(char)v107;
  }
LABEL_54:
  uint64_t v108 = v124;
  uint64_t *v124 = v71;
  v108[1] = v72;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  int8x16_t v135 = a1;
  int64x2_t v129 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v129, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int8x16_t v125 = (char *)&v121 - v8;
  uint64_t v136 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v121 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  int64x2_t v124 = (char *)&v121 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v127 = (char *)&v121 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  int64x2_t v130 = (char *)&v121 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  int64x2_t v128 = (char *)&v121 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v131 = (char *)&v121 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  unint64_t v133 = (char *)&v121 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v121 - v24;
  uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  char v27 = v26(a3, v4);
  uint64_t v137 = v4;
  if (v27)
  {
    uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v29 = v28(a3, v4);
    if (v29 >= 64)
    {
      v139[0] = -128;
      unint64_t v46 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
      v46(v139, &type metadata for Int, v47, a3, v137);
      uint64_t v4 = v137;
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v137 + 32) + 8) + 16))(a2, v25, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v136 + 8))(v25, a3);
      if (v48) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v32 = v136;
      (*(void (**)(char *, uint64_t, uint64_t))(v136 + 16))(v25, a2, a3);
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v32 + 8))(v25, a3);
      if (v33 < -128) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    char v35 = v26(a3, v4);
    unint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v37 = v4;
    uint64_t v38 = a2;
    int64x2_t v134 = v36;
    uint64_t v39 = v36(a3, v37);
    if (v35)
    {
      if (v39 <= 64)
      {
        int8x16_t v132 = v26;
        uint64_t v51 = v129;
        uint64_t v52 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v129, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v54 = v125;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v52, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v51[3])(v54, a3, v51);
        uint64_t v55 = v137;
        a2 = v38;
        LOBYTE(v52) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v137 + 32) + 8)
                                                                          + 16))(v38, v25, a3);
        uint64_t v56 = v136;
        unint64_t v57 = *(void (**)(char *, uint64_t))(v136 + 8);
        v57(v25, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v56 + 16))(v11, a2, a3);
        if (v52)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v11, a3);
          goto LABEL_23;
        }
        uint64_t v82 = (*(uint64_t (**)(uint64_t, uint64_t))(v55 + 120))(a3, v55);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v11, a3);
        uint64_t v26 = v132;
        uint64_t v28 = v134;
        uint64_t v4 = v55;
        if (v82 < -128) {
          goto LABEL_23;
        }
      }
      else
      {
        v139[0] = -128;
        uint64_t v42 = v137;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v43(v139, &type metadata for Int, v44, a3, v42);
        uint64_t v4 = v42;
        char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(a2, v25, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v136 + 8))(v25, a3);
        uint64_t v28 = v134;
        if (v45) {
          goto LABEL_23;
        }
      }
    }
    else if (v39 < 64)
    {
      uint64_t v49 = v136;
      (*(void (**)(char *, uint64_t, uint64_t))(v136 + 16))(v25, a2, a3);
      uint64_t v4 = v137;
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(v137 + 120))(a3, v137);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v49 + 8))(v25, a3);
      uint64_t v28 = v134;
      if (v50 < -128) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v28 = v134;
      uint64_t v4 = v137;
    }
  }
  int64x2_t v134 = v28;
  char v58 = v26(a3, v4);
  uint64_t v123 = v4 + 128;
  uint64_t v59 = v28(a3, v4);
  int8x16_t v132 = v26;
  if (v58)
  {
    if (v59 > 64) {
      goto LABEL_19;
    }
LABEL_22:
    uint64_t v67 = v136;
    (*(void (**)(char *, uint64_t, uint64_t))(v136 + 16))(v25, a2, a3);
    uint64_t v65 = v137;
    uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(v137 + 120))(a3, v137);
    id v68 = *(uint64_t (**)(char *, uint64_t))(v67 + 8);
    uint64_t result = v68(v25, a3);
    if (v69 > 128) {
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  if (v59 < 64) {
    goto LABEL_22;
  }
LABEL_19:
  v139[0] = 128;
  uint64_t v62 = v137;
  uint64_t v63 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
  unint64_t v64 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
  v63(v139, &type metadata for Int, v64, a3, v62);
  uint64_t v65 = v62;
  char v66 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v62 + 32) + 8) + 16))(v25, a2, a3);
  uint64_t v67 = v136;
  id v68 = *(uint64_t (**)(char *, uint64_t))(v136 + 8);
  uint64_t result = v68(v25, a3);
  if (v66) {
    goto LABEL_23;
  }
LABEL_24:
  uint64_t v121 = (void (*)(char *, uint64_t))v68;
  uint64_t v72 = *(void (**)(char *, uint64_t, uint64_t))(v67 + 16);
  char v73 = v133;
  v72(v133, a2, a3);
  char v74 = v132(a3, v65);
  unint64_t v75 = v131;
  unint64_t v122 = (void (*)(char *, char *, uint64_t))v72;
  v72(v131, (uint64_t)v73, a3);
  if ((v74 & 1) == 0)
  {
    v121(v75, a3);
    goto LABEL_43;
  }
  char v76 = v129;
  uint64_t v77 = v134(a3, v65);
  v121(v75, a3);
  if (v77 <= 64) {
    goto LABEL_43;
  }
  v122(v128, v133, a3);
  v139[0] = 0x8000000000000000;
  uint64_t v78 = v132;
  if (v132(a3, v65))
  {
    uint64_t v79 = v134(a3, v65);
    if (v79 < 64)
    {
LABEL_38:
      v122(v25, v128, a3);
      uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(a3, v65);
      uint64_t v87 = v121;
      v121(v25, a3);
      if (v88 < v139[0]) {
LABEL_70:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_42;
    }
LABEL_34:
    char v84 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v65 + 96);
    unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
    v84(v139, &type metadata for Int, v85, a3, v137);
    uint64_t v65 = v137;
    char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v137 + 32) + 8) + 16))(v128, v25, a3);
    uint64_t v87 = v121;
    v121(v25, a3);
    if (v86) {
      goto LABEL_70;
    }
    goto LABEL_42;
  }
  char v83 = v78(a3, v65);
  uint64_t v79 = v134(a3, v65);
  if ((v83 & 1) == 0)
  {
    if (v79 >= 64)
    {
      v121(v128, a3);
      goto LABEL_43;
    }
    goto LABEL_38;
  }
  if (v79 > 64) {
    goto LABEL_34;
  }
  BOOL v89 = v76;
  unsigned int v90 = AssociatedTypeWitness;
  uint64_t v91 = swift_getAssociatedConformanceWitness((uint64_t)v76, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v92 = v125;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v91 + 8))(&qword_18162B0B8, 256, v90, v91);
  ((void (*)(char *, uint64_t, int **))v89[3])(v92, a3, v89);
  uint64_t v93 = v128;
  LOBYTE(v89) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v65 + 32) + 8) + 16))(v128, v25, a3);
  uint64_t v87 = v121;
  v121(v25, a3);
  uint64_t v94 = v124;
  v122(v124, v93, a3);
  if (v89)
  {
    v87(v94, a3);
    goto LABEL_70;
  }
  uint64_t v95 = v65;
  uint64_t v96 = v139[0];
  uint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(v95 + 120))(a3, v95);
  v87(v94, a3);
  BOOL v98 = v97 < v96;
  uint64_t v65 = v95;
  if (v98) {
    goto LABEL_70;
  }
LABEL_42:
  v87(v128, a3);
LABEL_43:
  uint64_t v99 = v133;
  unint64_t v100 = v134;
  uint64_t v101 = v134(a3, v65);
  uint64_t v102 = v130;
  v122(v130, v99, a3);
  if (v101 >= 65)
  {
    uint64_t v103 = v121;
    v121(v102, a3);
    goto LABEL_45;
  }
  uint64_t v114 = v100(a3, v65);
  uint64_t v103 = v121;
  v121(v102, a3);
  if (v114 == 64 && (v132(a3, v65) & 1) == 0)
  {
LABEL_45:
    char v104 = v127;
    v122(v127, v133, a3);
    v139[0] = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v105 = v137;
    uint64_t v106 = v104;
    LOBYTE(v104) = v132(a3, v137);
    uint64_t v107 = v134(a3, v105);
    if (v104)
    {
      if (v107 > 64)
      {
        uint64_t v110 = v137;
        uint64_t v111 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
        unint64_t v112 = lazy protocol witness table accessor for type Int and conformance Int(v107, v108, v109);
        uint64_t v113 = v139;
        goto LABEL_54;
      }
    }
    else if (v107 >= 64)
    {
      uint64_t v138 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v110 = v137;
      uint64_t v111 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
      unint64_t v112 = lazy protocol witness table accessor for type Int and conformance Int(v107, v108, v109);
      uint64_t v113 = &v138;
LABEL_54:
      v111(v113, &type metadata for Int, v112, a3, v110);
      char v115 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v110 + 32) + 8) + 16))(v25, v106, a3);
      v103(v25, a3);
      if (v115) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_55;
    }
    v122(v25, v106, a3);
    (*(void (**)(uint64_t))(v137 + 120))(a3);
    v103(v25, a3);
LABEL_55:
    v103(v106, a3);
  }
  unint64_t v116 = v133;
  unint64_t v117 = (*(uint64_t (**)(uint64_t))(v137 + 120))(a3);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v103)(v116, a3);
  unint64_t v119 = *v135;
  unint64_t v118 = v135[1];
  if ((v117 & 0x8000000000000000) == 0)
  {
    if (v117 < 0x80)
    {
      uint64_t v70 = ((2 * v118) << ~(_BYTE)v117) | (v119 >> v117);
      uint64_t v71 = v118 >> v117;
      if ((v117 & 0x40) != 0)
      {
        uint64_t v70 = v71;
        uint64_t v71 = 0;
      }
      goto LABEL_60;
    }
LABEL_23:
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    goto LABEL_60;
  }
  if (v117 < 0xFFFFFFFFFFFFFF81) {
    goto LABEL_23;
  }
  if ((-(uint64_t)v117 & 0x40) != 0) {
    uint64_t v70 = 0;
  }
  else {
    uint64_t v70 = v119 << -(char)v117;
  }
  uint64_t v71 = (v118 << -(char)v117) | (v119 >> 1 >> (v117 - 1));
  if ((-(uint64_t)v117 & 0x40) != 0) {
    uint64_t v71 = v119 << -(char)v117;
  }
LABEL_60:
  unint64_t v120 = v135;
  *int8x16_t v135 = v70;
  v120[1] = v71;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  int64x2_t v124 = a5;
  uint64_t v114 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v112 = (char *)v109 - v10;
  uint64_t v11 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v110 = (char *)v109 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v119 = (char *)v109 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  unint64_t v118 = (char *)v109 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v111 = (char *)v109 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v120 = (char *)v109 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v125 = (char *)v109 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v28 = (char *)v109 - v27;
  unint64_t v29 = *a1;
  unint64_t v116 = a1[1];
  unint64_t v117 = v29;
  uint64_t v31 = a4 + 64;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v30(a3, a4) & 1) == 0)
  {
    char v35 = v30(a3, a4);
    int8x16_t v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v32 = v126(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v32 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v32 <= 64)
    {
      uint64_t v121 = a4 + 64;
      uint64_t v123 = v30;
      uint64_t v65 = AssociatedTypeWitness;
      char v66 = v114;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      id v68 = v112;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v65, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v66[3])(v68, a3, v66);
      LOBYTE(v65) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      uint64_t v69 = (void (*)(char *, uint64_t))*((void *)v11 + 1);
      v69(v28, a3);
      unint64_t v122 = v11;
      (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v14, a2, a3);
      if (v65)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
        goto LABEL_25;
      }
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
      uint64_t v11 = v122;
      uint64_t v30 = v123;
      uint64_t v31 = v121;
      if (v70 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v128[0] = -128;
    unint64_t v36 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
    v36(v128, &type metadata for Int, v37, a3, a4);
    char v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
    if (v38) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  int8x16_t v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v32 = v126(a3, a4);
  if (v32 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
  uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
  if (v40 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  char v41 = v30(a3, a4);
  uint64_t v115 = a4 + 128;
  uint64_t v42 = v126(a3, a4);
  uint64_t v123 = v30;
  uint64_t v121 = v31;
  if (v41)
  {
    if (v42 > 64) {
      goto LABEL_12;
    }
  }
  else if (v42 > 63)
  {
LABEL_12:
    v128[0] = 128;
    char v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v45(v128, &type metadata for Int, v46, a3, a4);
    char v47 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
    char v48 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
    uint64_t result = v48(v28, a3);
    if (v47) {
      goto LABEL_25;
    }
    goto LABEL_16;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
  uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v48 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
  uint64_t result = v48(v28, a3);
  if (v49 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v50 = v28;
  unint64_t v122 = v48;
  uint64_t v51 = (char *)v11 + 16;
  uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))*((void *)v11 + 2);
  uint64_t v53 = v125;
  v52(v125, a2, a3);
  char v54 = v123(a3, a4);
  uint64_t v55 = v120;
  uint64_t v56 = v53;
  v109[1] = v51;
  unint64_t v57 = (void (*)(char *, char *, uint64_t))v52;
  v52(v120, (uint64_t)v56, a3);
  if ((v54 & 1) == 0)
  {
    v122(v55, a3);
    uint64_t v59 = v50;
    goto LABEL_37;
  }
  uint64_t v58 = v126(a3, a4);
  v122(v55, a3);
  uint64_t v59 = v50;
  uint64_t v60 = v123;
  if (v58 <= 64) {
    goto LABEL_37;
  }
  uint64_t v61 = v111;
  v57(v111, v125, a3);
  v128[0] = 0x8000000000000000;
  if (v60(a3, a4))
  {
    uint64_t v62 = v126(a3, a4);
    if (v62 >= 64)
    {
LABEL_28:
      char v74 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v75 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
      v74(v128, &type metadata for Int, v75, a3, a4);
      uint64_t v61 = v111;
      char v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v111, v59, a3);
      uint64_t v77 = (void (*)(char *, uint64_t))v122;
      v122(v59, a3);
      if (v76) {
        goto LABEL_68;
      }
      goto LABEL_36;
    }
LABEL_32:
    v57(v59, v61, a3);
    uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v77 = (void (*)(char *, uint64_t))v122;
    v122(v59, a3);
    if (v78 < v128[0]) {
LABEL_68:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v73 = v60(a3, a4);
  uint64_t v62 = v126(a3, a4);
  if ((v73 & 1) == 0)
  {
    if (v62 >= 64)
    {
      v122(v61, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v62 > 64) {
    goto LABEL_28;
  }
  uint64_t v80 = AssociatedTypeWitness;
  uint64_t v79 = v114;
  uint64_t v81 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v82 = v112;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v81 + 8))(&qword_18162B0B8, 256, v80, v81);
  ((void (*)(char *, uint64_t, int **))v79[3])(v82, a3, v79);
  char v83 = v111;
  char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v111, v59, a3);
  unint64_t v85 = (void (*)(char *, uint64_t))v122;
  v122(v59, a3);
  char v86 = v110;
  v57(v110, v83, a3);
  if (v84)
  {
    v85(v86, a3);
    goto LABEL_68;
  }
  uint64_t v87 = v128[0];
  uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v85(v86, a3);
  BOOL v89 = v88 < v87;
  uint64_t v61 = v111;
  uint64_t v77 = v85;
  if (v89) {
    goto LABEL_68;
  }
LABEL_36:
  v77(v61, a3);
LABEL_37:
  unsigned int v90 = v125;
  uint64_t v91 = v126;
  uint64_t v92 = v126(a3, a4);
  uint64_t v93 = v118;
  v57(v118, v90, a3);
  if (v92 < 65)
  {
    uint64_t v102 = v91(a3, a4);
    v122(v93, a3);
    uint64_t v94 = v119;
    if (v102 != 64 || (v123(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v122(v93, a3);
    uint64_t v94 = v119;
  }
  v57(v94, v125, a3);
  v128[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v95 = v123(a3, a4);
  uint64_t v96 = v126(a3, a4);
  if ((v95 & 1) == 0)
  {
    if (v96 > 63)
    {
      uint64_t v127 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v99 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
      uint64_t v101 = &v127;
      goto LABEL_48;
    }
LABEL_46:
    v57(v59, v94, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v103 = (void (*)(char *, uint64_t))v122;
    v122(v59, a3);
    v103(v94, a3);
    goto LABEL_50;
  }
  if (v96 <= 64) {
    goto LABEL_46;
  }
  uint64_t v99 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
  uint64_t v101 = v128;
LABEL_48:
  v99(v101, &type metadata for Int, v100, a3, a4);
  char v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v59, v94, a3);
  uint64_t v105 = (void (*)(char *, uint64_t))v122;
  v122(v59, a3);
  if (v104) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v105(v94, a3);
LABEL_50:
  uint64_t v106 = v125;
  unint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v122(v106, a3);
  if ((v107 & 0x8000000000000000) == 0)
  {
    if (v107 <= 0x7F)
    {
      if ((v107 & 0x40) != 0) {
        uint64_t v72 = v117 << v107;
      }
      else {
        uint64_t v72 = (v116 << v107) | (v117 >> 1 >> ~(_BYTE)v107);
      }
      if ((v107 & 0x40) != 0) {
        uint64_t v71 = 0;
      }
      else {
        uint64_t v71 = v117 << v107;
      }
      goto LABEL_58;
    }
LABEL_25:
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    goto LABEL_58;
  }
  if (v107 <= 0xFFFFFFFFFFFFFF80) {
    goto LABEL_25;
  }
  if ((-(uint64_t)v107 & 0x40) != 0) {
    uint64_t v72 = 0;
  }
  else {
    uint64_t v72 = v116 >> -(char)v107;
  }
  uint64_t v71 = ((2 * v116) << (v107 - 1)) | (v117 >> -(char)v107);
  if ((-(uint64_t)v107 & 0x40) != 0) {
    uint64_t v71 = v116 >> -(char)v107;
  }
LABEL_58:
  uint64_t v108 = v124;
  uint64_t *v124 = v71;
  v108[1] = v72;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  int8x16_t v135 = a1;
  int64x2_t v129 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v129, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int8x16_t v125 = (char *)&v121 - v8;
  uint64_t v136 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v121 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  int64x2_t v124 = (char *)&v121 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v127 = (char *)&v121 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  int64x2_t v130 = (char *)&v121 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  int64x2_t v128 = (char *)&v121 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v131 = (char *)&v121 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  unint64_t v133 = (char *)&v121 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v121 - v24;
  uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  char v27 = v26(a3, v4);
  uint64_t v137 = v4;
  if (v27)
  {
    uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v29 = v28(a3, v4);
    if (v29 >= 64)
    {
      v139[0] = -128;
      unint64_t v46 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
      v46(v139, &type metadata for Int, v47, a3, v137);
      uint64_t v4 = v137;
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v137 + 32) + 8) + 16))(a2, v25, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v136 + 8))(v25, a3);
      if (v48) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v32 = v136;
      (*(void (**)(char *, uint64_t, uint64_t))(v136 + 16))(v25, a2, a3);
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v32 + 8))(v25, a3);
      if (v33 < -128) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    char v35 = v26(a3, v4);
    unint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v37 = v4;
    uint64_t v38 = a2;
    int64x2_t v134 = v36;
    uint64_t v39 = v36(a3, v37);
    if (v35)
    {
      if (v39 <= 64)
      {
        int8x16_t v132 = v26;
        uint64_t v51 = v129;
        uint64_t v52 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v129, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v54 = v125;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v52, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v51[3])(v54, a3, v51);
        uint64_t v55 = v137;
        a2 = v38;
        LOBYTE(v52) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v137 + 32) + 8)
                                                                          + 16))(v38, v25, a3);
        uint64_t v56 = v136;
        unint64_t v57 = *(void (**)(char *, uint64_t))(v136 + 8);
        v57(v25, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v56 + 16))(v11, a2, a3);
        if (v52)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v11, a3);
          goto LABEL_23;
        }
        uint64_t v82 = (*(uint64_t (**)(uint64_t, uint64_t))(v55 + 120))(a3, v55);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v11, a3);
        uint64_t v26 = v132;
        uint64_t v28 = v134;
        uint64_t v4 = v55;
        if (v82 < -128) {
          goto LABEL_23;
        }
      }
      else
      {
        v139[0] = -128;
        uint64_t v42 = v137;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v43(v139, &type metadata for Int, v44, a3, v42);
        uint64_t v4 = v42;
        char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v42 + 32) + 8) + 16))(a2, v25, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v136 + 8))(v25, a3);
        uint64_t v28 = v134;
        if (v45) {
          goto LABEL_23;
        }
      }
    }
    else if (v39 < 64)
    {
      uint64_t v49 = v136;
      (*(void (**)(char *, uint64_t, uint64_t))(v136 + 16))(v25, a2, a3);
      uint64_t v4 = v137;
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(v137 + 120))(a3, v137);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v49 + 8))(v25, a3);
      uint64_t v28 = v134;
      if (v50 < -128) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v28 = v134;
      uint64_t v4 = v137;
    }
  }
  int64x2_t v134 = v28;
  char v58 = v26(a3, v4);
  uint64_t v123 = v4 + 128;
  uint64_t v59 = v28(a3, v4);
  int8x16_t v132 = v26;
  if (v58)
  {
    if (v59 > 64) {
      goto LABEL_19;
    }
LABEL_22:
    uint64_t v67 = v136;
    (*(void (**)(char *, uint64_t, uint64_t))(v136 + 16))(v25, a2, a3);
    uint64_t v65 = v137;
    uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(v137 + 120))(a3, v137);
    id v68 = *(uint64_t (**)(char *, uint64_t))(v67 + 8);
    uint64_t result = v68(v25, a3);
    if (v69 > 128) {
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  if (v59 < 64) {
    goto LABEL_22;
  }
LABEL_19:
  v139[0] = 128;
  uint64_t v62 = v137;
  uint64_t v63 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
  unint64_t v64 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
  v63(v139, &type metadata for Int, v64, a3, v62);
  uint64_t v65 = v62;
  char v66 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v62 + 32) + 8) + 16))(v25, a2, a3);
  uint64_t v67 = v136;
  id v68 = *(uint64_t (**)(char *, uint64_t))(v136 + 8);
  uint64_t result = v68(v25, a3);
  if (v66) {
    goto LABEL_23;
  }
LABEL_24:
  uint64_t v121 = (void (*)(char *, uint64_t))v68;
  uint64_t v72 = *(void (**)(char *, uint64_t, uint64_t))(v67 + 16);
  char v73 = v133;
  v72(v133, a2, a3);
  char v74 = v132(a3, v65);
  unint64_t v75 = v131;
  unint64_t v122 = (void (*)(char *, char *, uint64_t))v72;
  v72(v131, (uint64_t)v73, a3);
  if ((v74 & 1) == 0)
  {
    v121(v75, a3);
    goto LABEL_43;
  }
  char v76 = v129;
  uint64_t v77 = v134(a3, v65);
  v121(v75, a3);
  if (v77 <= 64) {
    goto LABEL_43;
  }
  v122(v128, v133, a3);
  v139[0] = 0x8000000000000000;
  uint64_t v78 = v132;
  if (v132(a3, v65))
  {
    uint64_t v79 = v134(a3, v65);
    if (v79 < 64)
    {
LABEL_38:
      v122(v25, v128, a3);
      uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(a3, v65);
      uint64_t v87 = v121;
      v121(v25, a3);
      if (v88 < v139[0]) {
LABEL_70:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_42;
    }
LABEL_34:
    char v84 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v65 + 96);
    unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
    v84(v139, &type metadata for Int, v85, a3, v137);
    uint64_t v65 = v137;
    char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v137 + 32) + 8) + 16))(v128, v25, a3);
    uint64_t v87 = v121;
    v121(v25, a3);
    if (v86) {
      goto LABEL_70;
    }
    goto LABEL_42;
  }
  char v83 = v78(a3, v65);
  uint64_t v79 = v134(a3, v65);
  if ((v83 & 1) == 0)
  {
    if (v79 >= 64)
    {
      v121(v128, a3);
      goto LABEL_43;
    }
    goto LABEL_38;
  }
  if (v79 > 64) {
    goto LABEL_34;
  }
  BOOL v89 = v76;
  unsigned int v90 = AssociatedTypeWitness;
  uint64_t v91 = swift_getAssociatedConformanceWitness((uint64_t)v76, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v92 = v125;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v91 + 8))(&qword_18162B0B8, 256, v90, v91);
  ((void (*)(char *, uint64_t, int **))v89[3])(v92, a3, v89);
  uint64_t v93 = v128;
  LOBYTE(v89) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v65 + 32) + 8) + 16))(v128, v25, a3);
  uint64_t v87 = v121;
  v121(v25, a3);
  uint64_t v94 = v124;
  v122(v124, v93, a3);
  if (v89)
  {
    v87(v94, a3);
    goto LABEL_70;
  }
  uint64_t v95 = v65;
  uint64_t v96 = v139[0];
  uint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(v95 + 120))(a3, v95);
  v87(v94, a3);
  BOOL v98 = v97 < v96;
  uint64_t v65 = v95;
  if (v98) {
    goto LABEL_70;
  }
LABEL_42:
  v87(v128, a3);
LABEL_43:
  uint64_t v99 = v133;
  unint64_t v100 = v134;
  uint64_t v101 = v134(a3, v65);
  uint64_t v102 = v130;
  v122(v130, v99, a3);
  if (v101 >= 65)
  {
    uint64_t v103 = v121;
    v121(v102, a3);
    goto LABEL_45;
  }
  uint64_t v114 = v100(a3, v65);
  uint64_t v103 = v121;
  v121(v102, a3);
  if (v114 == 64 && (v132(a3, v65) & 1) == 0)
  {
LABEL_45:
    char v104 = v127;
    v122(v127, v133, a3);
    v139[0] = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v105 = v137;
    uint64_t v106 = v104;
    LOBYTE(v104) = v132(a3, v137);
    uint64_t v107 = v134(a3, v105);
    if (v104)
    {
      if (v107 > 64)
      {
        uint64_t v110 = v137;
        uint64_t v111 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
        unint64_t v112 = lazy protocol witness table accessor for type Int and conformance Int(v107, v108, v109);
        uint64_t v113 = v139;
        goto LABEL_54;
      }
    }
    else if (v107 >= 64)
    {
      uint64_t v138 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v110 = v137;
      uint64_t v111 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v137 + 96);
      unint64_t v112 = lazy protocol witness table accessor for type Int and conformance Int(v107, v108, v109);
      uint64_t v113 = &v138;
LABEL_54:
      v111(v113, &type metadata for Int, v112, a3, v110);
      char v115 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v110 + 32) + 8) + 16))(v25, v106, a3);
      v103(v25, a3);
      if (v115) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_55;
    }
    v122(v25, v106, a3);
    (*(void (**)(uint64_t))(v137 + 120))(a3);
    v103(v25, a3);
LABEL_55:
    v103(v106, a3);
  }
  unint64_t v116 = v133;
  unint64_t v117 = (*(uint64_t (**)(uint64_t))(v137 + 120))(a3);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v103)(v116, a3);
  unint64_t v118 = *v135;
  unint64_t v119 = v135[1];
  if ((v117 & 0x8000000000000000) == 0)
  {
    if (v117 < 0x80)
    {
      uint64_t v71 = (v119 << v117) | (v118 >> 1 >> ~(_BYTE)v117);
      uint64_t v70 = v118 << v117;
      if ((v117 & 0x40) != 0)
      {
        uint64_t v71 = v70;
        uint64_t v70 = 0;
      }
      goto LABEL_60;
    }
LABEL_23:
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    goto LABEL_60;
  }
  if (v117 <= 0xFFFFFFFFFFFFFF80) {
    goto LABEL_23;
  }
  if ((-(uint64_t)v117 & 0x40) != 0) {
    uint64_t v71 = 0;
  }
  else {
    uint64_t v71 = v119 >> -(char)v117;
  }
  uint64_t v70 = ((2 * v119) << (v117 - 1)) | (v118 >> -(char)v117);
  if ((-(uint64_t)v117 & 0x40) != 0) {
    uint64_t v70 = v119 >> -(char)v117;
  }
LABEL_60:
  unint64_t v120 = v135;
  *int8x16_t v135 = v70;
  v120[1] = v71;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt128(uint64_t *a1, _OWORD *a2, unint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt128(uint64_t *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

void protocol witness for BinaryInteger.signum() in conformance UInt128(void *a1@<X8>)
{
  *a1 = *v1 != 0;
  a1[1] = 0;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt128()
{
  return specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, *v0, v0[1]);
}

unint64_t *protocol witness for Strideable.distance(to:) in conformance UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  unint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  if (*(_OWORD *)result >= *(_OWORD *)v2)
  {
    BOOL v7 = v3 >= v6;
    unint64_t v9 = v3 - v6;
    if (!((v4 - (v5 + !v7)) | (v9 >> 63))) {
      goto LABEL_5;
    }
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
  }
  BOOL v7 = v6 >= v3;
  unint64_t v8 = v6 - v3;
  if ((v5 - (v4 + !v7)) | (v8 >> 63)) {
    goto LABEL_6;
  }
  unint64_t v9 = -(uint64_t)v8;
LABEL_5:
  *a2 = v9;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v5 = *v2;
  unint64_t v4 = v2[1];
  if ((*result & 0x8000000000000000) == 0)
  {
    BOOL v6 = __CFADD__(v5, v3);
    v3 += v5;
    uint64_t v7 = v6;
    BOOL v6 = __CFADD__(v6, v4);
    v4 += v7;
    unint64_t v5 = v6;
    if ((v5 & 1) == 0) {
      goto LABEL_11;
    }
    __break(1u);
  }
  unint64_t v8 = -(uint64_t)v3;
  BOOL v6 = v5 >= v8;
  unint64_t v3 = v5 - v8;
  BOOL v9 = v6;
  BOOL v6 = v4 >= !v6;
  v4 -= !v9;
  char v10 = !v6;
  if ((v10 & 1) == 0)
  {
LABEL_11:
    *a2 = v3;
    a2[1] = v4;
    return result;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt128(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance Int128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int128(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, a4[1], *a5, a5[1], *a6);
}

uint64_t UInt128.Words.count.getter()
{
  return 2;
}

uint64_t UInt128.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt128.Words.endIndex.getter()
{
  return 2;
}

uint64_t UInt128.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall UInt128.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall UInt128.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t UInt128.Words.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/UInt128.swift", 19, 2, 0x1F9uLL, 0);
  }
  v4[0] = a2;
  v4[1] = a3;
  return v4[a1];
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance UInt128.Words@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2);
  *a3 = result;
  return result;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt128.Words@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v6 & 1;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance UInt128.Words(unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt128.Words(uint64_t *a1, unint64_t *a2))()
{
  *a1 = UInt128.Words.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt128.Words@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0 || (uint64_t v3 = result[1], v3 >= 3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  uint64_t v4 = *v2;
  uint64_t v5 = v2[1];
  *a2 = *result;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  return result;
}

double protocol witness for Collection.indices.getter in conformance UInt128.Words@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = xmmword_18162AFE0;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance UInt128.Words(void *a1@<X8>)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  a1[2] = 0;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt128.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt128.Words(void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

uint64_t static UInt128.bitWidth.getter()
{
  return 128;
}

unint64_t UInt128.byteSwapped.getter(uint64_t a1, unint64_t a2)
{
  return bswap64(a2);
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt128(void *a1@<X8>)
{
  *a1 = -1;
  a1[1] = -1;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt128(_OWORD *a1, void *a2)
{
  long long v3 = *(_OWORD *)v2 + *(_OWORD *)a2;
  if (__CFADD__(__CFADD__(*v2, *a2), v2[1]) | __CFADD__(a2[1], *((void *)&v3 + 1))) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = 0;
  }
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  BOOL v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt128(void *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  unint64_t v3 = a2[1];
  unint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  if (v5) {
    BOOL v7 = v3 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  unsigned int v10 = !v7 || (v5 * (unsigned __int128)*a2) >> 64 != 0 || (v3 * (unsigned __int128)*v2) >> 64 != 0;
  unint64_t v11 = v3 * v6 + v5 * v4;
  uint64_t v12 = (v6 * (unsigned __int128)v4) >> 64;
  BOOL v13 = __CFADD__(v12, v11);
  uint64_t v14 = v12 + v11;
  if (v13) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = v10;
  }
  *a1 = v6 * v4;
  a1[1] = v14;
  return v15;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  }
  *a1 = __udivti3();
  a1[1] = v3;
  return 0;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  }
  *a1 = __umodti3();
  a1[1] = v3;
  return 0;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt128(uint64_t *a1, _OWORD *a2, unint64_t *a3)
{
  uint64_t result = specialized FixedWidthInteger.multipliedFullWidth(by:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt128(uint64_t *a1, uint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result = specialized UnsignedInteger<>.dividingFullWidth(_:)(a2, *a3, a3[1], *a4, a4[1], *v4, v4[1]);
  *a1 = result;
  a1[1] = v7;
  return result;
}

void *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt128@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v3 = result[1];
  uint64_t v4 = ((2 * v3) << ~*a2) | (*result >> *a2);
  uint64_t v5 = v3 >> *a2;
  if ((*a2 & 0x40) != 0)
  {
    uint64_t v4 = v5;
    uint64_t v5 = 0;
  }
  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt128(uint64_t *result, void *a2)
{
  unint64_t v2 = result[1];
  uint64_t v3 = (2 * v2) << ~*a2;
  uint64_t v4 = v2 >> *a2;
  if ((*a2 & 0x40) != 0) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3 | ((unint64_t)*result >> *a2);
  }
  if ((*a2 & 0x40) != 0) {
    uint64_t v4 = 0;
  }
  *uint64_t result = v5;
  result[1] = v4;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, uint64_t (*a4)(void *, uint64_t, uint64_t)@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    swift_bridgeObjectRelease(a2);
    goto LABEL_10;
  }
  uint64_t v10 = a3();
  if ((v12 & 0x100) != 0)
  {
    uint64_t v13 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    uint64_t v14 = v16;
    char v18 = v17;
    swift_bridgeObjectRelease(a2);
    if ((v18 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_10:
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    char v19 = 1;
    goto LABEL_11;
  }
  uint64_t v13 = v10;
  uint64_t v14 = v11;
  char v15 = v12;
  swift_bridgeObjectRelease(a2);
  if (v15) {
    goto LABEL_10;
  }
LABEL_8:
  char v19 = 0;
LABEL_11:
  *(void *)a5 = v13;
  *(void *)(a5 + 8) = v14;
  *(unsigned char *)(a5 + 16) = v19;
}

atomic_ullong *sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v26 = a2;
  char v27 = (atomic_ullong *)a3;
  unint64_t v8 = type metadata accessor for Optional(255, a4, a3, a4);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v8, (uint64_t)&type metadata for Bool, 0, 0);
  uint64_t v10 = *(TupleTypeMetadata2 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v13 = (char *)&v26 - v12;
  uint64_t v14 = (uint64_t)*(v8 - 1);
  MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v26 - v15;
  uint64_t v17 = *(void *)(a4 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))((char *)&v26 - v15, a1, a4);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v17 + 56))(v16, 0, 1, a4);
  uint64_t v18 = *((int *)TupleTypeMetadata2 + 12);
  (*(void (**)(char *, char *, Class *))(v14 + 32))(v13, v16, v8);
  v13[v18] = 1;
  char v19 = (uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X8>))swift_allocObject(qword_1EC9F2B90, 0x28uLL, 7uLL);
  uint64_t v20 = v26;
  uint64_t v21 = v27;
  *((void *)v19 + 2) = a4;
  *((void *)v19 + 3) = v20;
  *((void *)v19 + 4) = v21;
  (*(void (**)(uint64_t, char *, uint64_t *))(v10 + 32))(a5, v13, TupleTypeMetadata2);
  uint64_t v23 = type metadata accessor for UnfoldSequence(0, a4, (uint64_t)TupleTypeMetadata2, v22);
  *(unsigned char *)(a5 + *((int *)v23 + 10)) = 0;
  uint64_t v24 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(a5 + *((int *)v23 + 9));
  *uint64_t v24 = partial apply for closure #1 in sequence<A>(first:next:);
  v24[1] = v19;
  return swift_retain(v21);
}

uint64_t closure #1 in sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, void (*a2)(uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v27[1] = a3;
  uint64_t v28 = a2;
  uint64_t v31 = a5;
  uint64_t v29 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  v27[0] = (char *)v27 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = v7;
  BOOL v9 = type metadata accessor for Optional(255, v7, v8, v7);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)v9, (uint64_t)&type metadata for Bool, 0, 0);
  uint64_t v11 = TupleTypeMetadata2 - 1;
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v14 = (char *)v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)v27 - v15;
  uint64_t v17 = *((int *)v11 + 14);
  uint64_t v18 = (uint64_t)*(v9 - 1);
  (*(void (**)(char *, uint64_t, Class *))(v18 + 16))((char *)v27 - v15, a1, v9);
  int v19 = *(unsigned __int8 *)(a1 + v17);
  v16[v17] = v19;
  uint64_t v20 = *((int *)v11 + 14);
  uint64_t v21 = *(void (**)(char *, char *, Class *))(v18 + 32);
  v21(v14, v16, v9);
  v14[v20] = v19;
  if (v19 == 1)
  {
    uint64_t result = ((uint64_t (*)(uint64_t, char *, Class *))v21)(v31, v14, v9);
    *(unsigned char *)(a1 + v17) = 0;
  }
  else
  {
    uint64_t v24 = v30;
    uint64_t v23 = v31;
    uint64_t v25 = v29;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v29 + 48))(v14, 1, v30) == 1)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 56))(v23, 1, 1, v24);
    }
    else
    {
      uint64_t v26 = v27[0];
      (*(void (**)(void, char *, uint64_t))(v25 + 32))(v27[0], v14, v24);
      v28(v26);
      (*(void (**)(uint64_t, uint64_t))(v25 + 8))(v26, v24);
      return (*(uint64_t (**)(uint64_t, uint64_t, Class *))(v18 + 24))(a1, v23, v9);
    }
  }
  return result;
}

atomic_ullong *sequence<A, B>(state:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16))(a6, a1, a5);
  uint64_t v12 = type metadata accessor for UnfoldSequence(0, a4, a5, v11);
  *(unsigned char *)(a6 + *((int *)v12 + 10)) = 0;
  uint64_t v13 = (void *)(a6 + *((int *)v12 + 9));
  *uint64_t v13 = a2;
  v13[1] = a3;

  return swift_retain(a3);
}

uint64_t UnfoldSequence.init(_state:_next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v11 = type metadata accessor for UnfoldSequence(0, a4, a5, a4);
  *(unsigned char *)(a6 + *((int *)v11 + 10)) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32))(a6, a1, a5);
  uint64_t v13 = (void *)(a6 + *((int *)v11 + 9));
  *uint64_t v13 = a2;
  v13[1] = a3;
  return result;
}

uint64_t UnfoldSequence._state.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8) + 16))(a2, v2);
}

uint64_t UnfoldSequence._state.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 24) - 8) + 40))(v2, a1);
}

uint64_t (*UnfoldSequence._state.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence._predicate.getter(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(v1 + *(int *)(a1 + 36));
  uint64_t v3 = *v2;
  swift_retain((atomic_ullong *)v2[1]);
  return v3;
}

uint64_t UnfoldSequence._done.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 40));
}

uint64_t UnfoldSequence._done.setter(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(v2 + *(int *)(a2 + 40)) = result;
  return result;
}

uint64_t (*UnfoldSequence._done.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnfoldSequence.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v8 = *(void *)(a1 + 16);
  BOOL v9 = type metadata accessor for Optional(0, v8, a2, a3);
  uint64_t v10 = (uint64_t)*(v9 - 1);
  MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v20 - v11;
  uint64_t v13 = *(int *)(a1 + 40);
  if (*(unsigned char *)(v5 + v13))
  {
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56);
    return v14(a4, 1, 1, v8);
  }
  else
  {
    uint64_t v16 = v5 + *(int *)(a1 + 36);
    uint64_t v18 = *(void (**)(uint64_t))v16;
    uint64_t v17 = *(atomic_ullong **)(v16 + 8);
    swift_retain(v17);
    v18(v5);
    swift_release((uint64_t)v17);
    uint64_t v19 = *(void *)(v8 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v12, 1, v8) == 1)
    {
      (*(void (**)(char *, Class *))(v10 + 8))(v12, v9);
      *(unsigned char *)(v5 + v13) = 1;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 56))(a4, 1, 1, v8);
    }
    else
    {
      (*(void (**)(uint64_t, char *, uint64_t))(v19 + 32))(a4, v12, v8);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v19 + 56))(a4, 0, 1, v8);
    }
  }
}

uint64_t UnsafeMutableRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    uint64_t result = a3 + a1;
  }
  else {
    uint64_t result = 0;
  }
  uint64_t v5 = a2 - a1;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  }
  if (v5)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer has a nil start and nonzero count", 63, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x69uLL, 0);
    }
  }
  return result;
}

void *UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v28)(void *__return_ptr, uint64_t *, uint64_t);
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  void v43[2];
  uint64_t v44;

  uint64_t v9 = *(void *)(a4 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v38 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v15 = type metadata accessor for EnumeratedSequence(0, v14, v13, v14);
  MEMORY[0x1F4188790](v15 - 1);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v19 = type metadata accessor for EnumeratedSequence.Iterator(0, a4, v13, v18);
  uint64_t v42 = (uint64_t)*(v19 - 1);
  uint64_t result = (void *)MEMORY[0x1F4188790](v19);
  uint64_t v22 = (char *)&v38 - v21;
  if (a2)
  {
    uint64_t v41 = result;
    MEMORY[0x1F4188790](result);
    *(&v38 - 6) = a4;
    *(&v38 - 5) = a5;
    uint64_t v34 = a1;
    char v35 = a2;
    uint64_t v40 = v23;
    unint64_t v36 = v23;
    uint64_t v37 = a2;
    uint64_t result = (*(void *(**)(uint64_t *__return_ptr, void))(v13 + 72))(&v44, partial apply for closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:));
    if (v44)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v17, a1, a4);
      (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v11, v17, a4);
      (*(void (**)(uint64_t, uint64_t))(v13 + 32))(a4, v13);
      uint64_t v24 = v41;
      uint64_t v25 = *((int *)v41 + 9);
      *(void *)&v22[v25] = 0;
      uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v13, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v28 = *(void (**)(void *__return_ptr, uint64_t *, uint64_t))(AssociatedConformanceWitness + 16);
      uint64_t v29 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v28(v43, v29, AssociatedConformanceWitness);
      uint64_t v30 = 0;
      if ((v43[0] & 0x100) == 0)
      {
        uint64_t v39 = v25;
        uint64_t v31 = 0;
        uint64_t v32 = v40 - a2;
        do
        {
          uint64_t v30 = v31 + 1;
          if (__OFADD__(v31, 1))
          {
            __break(1u);
LABEL_12:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.copyBytes source has too many elements", 68, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x20FuLL, 0);
          }
          if (v31 >= v32) {
            goto LABEL_12;
          }
          *(unsigned char *)(a2 + v31) = v43[0];
          uint64_t v33 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
          v28(v43, v33, AssociatedConformanceWitness);
          ++v31;
        }
        while (BYTE1(v43[0]) != 1);
        uint64_t v24 = v41;
        uint64_t v25 = v39;
      }
      *(void *)&v22[v25] = v30;
      return (void *)(*(uint64_t (**)(char *, void *))(v42 + 8))(v22, v24);
    }
  }
  return result;
}

uint64_t UnsafeMutableRawBufferPointer.initializeMemory<A>(as:repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v6 = *(void *)(*(void *)(a5 - 8) + 72);
    if (!v6) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    }
    uint64_t v7 = a4 - a3;
    if (a4 - a3 == 0x8000000000000000 && v6 == -1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    }
    uint64_t v8 = v7 / v6;
    UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(a1, a2, v7 / v6, a3, a5);
    if (v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    }
  }
  return a3;
}

uint64_t UnsafeMutableRawBufferPointer.initializeMemory<A>(as:from:)(uint64_t a1, uint64_t a2, unsigned int (**a3)(char *, uint64_t, const char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v66 = a5;
  uint64_t v67 = a3;
  uint64_t v62 = a4;
  uint64_t v58 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a7, a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v12 = type metadata accessor for Optional(0, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v54 = (uint64_t)*(v12 - 1);
  uint64_t v55 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  unint64_t v64 = (char *)&v53 - v14;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v59 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v15 = v59;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)&v53 - v17;
  uint64_t v18 = *(void *)(a6 - 8);
  uint64_t v19 = MEMORY[0x1F4188790](v16);
  uint64_t v60 = (char *)&v53 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v53 - v22;
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v53 - v24;
  uint64_t v70 = swift_getAssociatedTypeWitness(0, (int **)a7, a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v57 = *((void *)v70 - 1);
  MEMORY[0x1F4188790](v70);
  char v27 = (char *)&v53 - v26;
  uint64_t v61 = (void (**)(char *, char *, const char *))v18;
  uint64_t v28 = *(void (**)(char *, unsigned int (**)(char *, uint64_t, const char *), uint64_t))(v18 + 16);
  uint64_t v29 = v67;
  v28(v25, v67, a6);
  uint64_t v30 = *(void (**)(uint64_t, uint64_t))(a7 + 32);
  uint64_t v69 = v27;
  v30(a6, a7);
  uint64_t v31 = *(void *)(v15 + 72);
  uint64_t v56 = v28;
  v28(v23, v29, a6);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 40);
  uint64_t v68 = a7;
  uint64_t v33 = v32(a6, a7);
  uint64_t v34 = v62;
  if (v62)
  {
    char v35 = v61;
    if (!v31) {
      goto LABEL_28;
    }
    if (v66 - v62 == 0x8000000000000000 && v31 == -1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    }
    if ((v66 - v62) / v31 >= v33) {
      goto LABEL_6;
    }
LABEL_20:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "insufficient space to accommodate source.underestimatedCount elements", 69, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x2A5uLL, 0);
  }
  char v35 = v61;
  if (!v31) {
    goto LABEL_28;
  }
  if (v33 > 0) {
    goto LABEL_20;
  }
LABEL_6:
  unint64_t v36 = v35[1];
  ((void (*)(char *, uint64_t))v36)(v23, a6);
  if (!v34)
  {
    char v48 = v60;
    v56(v60, v67, a6);
    if (!v32(a6, v68))
    {
      ((void (*)(char *, uint64_t))v36)(v48, a6);
      (*(void (**)(uint64_t, char *, const char *))(v57 + 32))(v58, v69, v70);
      return 0;
    }
LABEL_31:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "no memory available to initialize from source", 45, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x2A9uLL, 0);
  }
  if ((*(unsigned char *)(v59 + 80) & v34) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "buffer base address must be properly aligned to access S.Element", 64, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x2AEuLL, 0);
  }
  if (__OFSUB__(0, v31))
  {
    __break(1u);
    goto LABEL_31;
  }
  uint64_t v37 = v34;
  uint64_t v38 = 0;
  unint64_t v39 = v66 - v31 + 1;
  uint64_t v61 = (void (**)(char *, char *, const char *))(v59 + 32);
  uint64_t v60 = (char *)(v59 + 16);
  uint64_t v40 = (void (**)(char *, const char *))(v59 + 8);
  v66 -= v34;
  uint64_t v67 = (unsigned int (**)(char *, uint64_t, const char *))(v59 + 48);
  uint64_t v41 = v64;
  while (1)
  {
    BOOL v42 = v39 >= v37 + v38;
    if (v31 > 0) {
      BOOL v42 = v37 + v38 >= v39;
    }
    if (v42) {
      goto LABEL_25;
    }
    uint64_t v43 = v70;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v68, a6, (uint64_t)v70, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16))(v43, AssociatedConformanceWitness);
    char v45 = v65;
    if ((*v67)(v41, 1, v65) == 1) {
      break;
    }
    unint64_t v46 = v63;
    (*v61)(v63, v41, v45);
    (*(void (**)(uint64_t, char *, const char *))v60)(v37 + v38, v46, v45);
    (*v40)(v46, v45);
    uint64_t v47 = v38 + v31;
    if (__OFADD__(v38, v31))
    {
      __break(1u);
LABEL_28:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    }
    if ((v47 & 0x8000000000000000) == 0)
    {
      v38 += v31;
      if (v66 >= v47) {
        continue;
      }
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  (*(void (**)(char *, Class *))(v54 + 8))(v41, v55);
LABEL_25:
  uint64_t v50 = v57;
  uint64_t v52 = v69;
  uint64_t v51 = v70;
  (*(void (**)(uint64_t, char *, const char *))(v57 + 16))(v58, v69, v70);
  (*(void (**)(char *, const char *))(v50 + 8))(v52, v51);
  if (v38 / v31 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  return v37;
}

uint64_t UnsafeMutableRawBufferPointer.bindMemory<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeRawBufferPointer.bindMemory<A>(to:)(a1, a2, a3, a4, "UnsafeMutableBufferPointer with negative count", 46, 0x47uLL);
}

uint64_t UnsafeRawBufferPointer.bindMemory<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7)
{
  if (a2)
  {
    uint64_t v7 = *(void *)(*(void *)(a4 - 8) + 72);
    if (!v7) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    }
    if (a3 - a2 == 0x8000000000000000 && v7 == -1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    }
    if ((a3 - a2) / v7 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a5, a6, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a7, 0);
    }
  }
  return a2;
}

uint64_t UnsafeMutableRawBufferPointer.load<A>(fromByteOffset:as:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.load with negative offset", 55, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x156uLL, 0);
  }
  uint64_t v5 = *(void *)(a4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  BOOL v7 = __OFADD__(a1, v6);
  uint64_t v8 = a1 + v6;
  if (v7)
  {
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
  }
  if (!a2)
  {
    if (v8 < 1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x159uLL, 0);
    }
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.load out of bounds", 48, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x157uLL, 0);
  }
  if (a3 - a2 < v8) {
    goto LABEL_14;
  }
  if ((*(unsigned char *)(v5 + 80) & (a2 + a1)) != 0) {
    goto LABEL_11;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t))(v5 + 16);

  return v9(a5);
}

uint64_t UnsafeRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    goto LABEL_12;
  }
  if (a3)
  {
    if (a4 - a3 >= a2) {
      goto LABEL_4;
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid slice", 13, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x5E5uLL, 0);
  }
  if (a2 >= 1) {
    goto LABEL_12;
  }
LABEL_4:
  if (a3) {
    uint64_t result = a3 + a1;
  }
  else {
    uint64_t result = 0;
  }
  uint64_t v6 = a2 - a1;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v6)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
    }
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.initialize(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.initialize(repeating:)(a1, a2, a3, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))UnsafeMutablePointer.initialize(repeating:count:));
}

Swift::Int __swiftcall Int.advanced(by:)(Swift::Int by)
{
  BOOL v2 = __OFADD__(v1, by);
  Swift::Int result = v1 + by;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.assign(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.initialize(repeating:)(a1, a2, a3, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))UnsafeMutablePointer.assign(repeating:count:));
}

uint64_t UnsafeMutableBufferPointer.initialize(repeating:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (a2) {
    return a5(result, a3, a2);
  }
  return result;
}

uint64_t specialized UnsafeMutableBufferPointer.update<A>(fromContentsOf:)(uint64_t a1, unint64_t a2, char *__dst, uint64_t a4)
{
  if ((a2 & 0x1000000000000000) != 0)
  {
    if ((a2 & 0x2000000000000000) != 0) {
      Swift::UInt64 v10 = HIBYTE(a2) & 0xF;
    }
    else {
      Swift::UInt64 v10 = a1 & 0xFFFFFFFFFFFFLL;
    }
    if (a4)
    {
      int64_t v8 = 0;
      if (!v10) {
        return v8;
      }
      uint64_t v11 = 4 << ((a1 & 0x800000000000000) != 0);
      Swift::UInt64 rawBits = 15;
      uint64_t v13 = a4 & ~(a4 >> 63);
      while (1)
      {
        if ((rawBits & 0xC) == v11)
        {
          v16._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if (v10 <= v16._rawBits >> 16)
          {
LABEL_33:
            unint64_t v17 = 228;
LABEL_34:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v17, 0);
          }
          Swift::UInt8 v14 = String.UTF8View._foreignSubscript(position:)(v16);
          Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if (rawBits >> 16 >= v10)
          {
            unint64_t v17 = 144;
            goto LABEL_34;
          }
        }
        else
        {
          if (rawBits >> 16 >= v10) {
            goto LABEL_33;
          }
          Swift::UInt8 v14 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }
        v15._Swift::UInt64 rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
        if (v13 == v8) {
          break;
        }
        Swift::UInt64 rawBits = v15._rawBits;
        __dst[v8++] = v14;
        if (4 * v10 == v15._rawBits >> 14) {
          return v8;
        }
      }
      unint64_t v19 = 941;
    }
    else
    {
      if (!v10) {
        return 0;
      }
      unint64_t v19 = 930;
    }
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "buffer cannot contain every element from source.", 48, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v19, 0);
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      BOOL v7 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      int64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) <= a4) {
        goto LABEL_5;
      }
      goto LABEL_29;
    }
    BOOL v7 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
    if (v7)
    {
      int64_t v8 = v18;
      if (v18 <= a4)
      {
LABEL_5:
        if (__dst) {
          goto LABEL_10;
        }
        return v8;
      }
      goto LABEL_29;
    }
    return 0;
  }
  int64_t v8 = HIBYTE(a2) & 0xF;
  __src[0] = a1;
  __src[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (v8 > a4)
  {
LABEL_29:
    unint64_t v19 = 918;
    goto LABEL_30;
  }
  if (__dst)
  {
    BOOL v7 = (char *)__src;
LABEL_10:
    specialized UnsafeMutablePointer.moveInitialize(from:count:)(v7, v8, __dst, "UnsafeMutablePointer.update with negative count", 47, 0x3DEuLL);
  }
  return v8;
}

uint64_t _sSrsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_Sryqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSryxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5(uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return a1(0, 0, &v13);
  }
  uint64_t v6 = *(void *)(a6 - 8);
  if ((*(unsigned char *)(v6 + 80) & a3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "baseAddress must be a properly aligned pointer for types Element and T", 70, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x4D3uLL, 0);
  }
  uint64_t v7 = *(void *)(v6 + 72);
  uint64_t v8 = *(void *)(*(void *)(a5 - 8) + 72);
  if (v7 != v8)
  {
    uint64_t v9 = a4 * v8;
    if ((unsigned __int128)(a4 * (__int128)v8) >> 64 == (a4 * v8) >> 63)
    {
      if (v7)
      {
        if (v9 == 0x8000000000000000 && v7 == -1) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
        }
        if (v8 >= v7)
        {
          if (v8 != 0x8000000000000000 || v7 != -1)
          {
            uint64_t v11 = v8 % v7;
            goto LABEL_19;
          }
        }
        else
        {
          if (!v8) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x390EuLL, 0);
          }
          if (v7 != 0x8000000000000000 || v8 != -1)
          {
            uint64_t v11 = v7 % v8;
LABEL_19:
            if (v11) {
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Buffer must contain a whole number of Element instances", 55, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x4DDuLL, 0);
            }
            a4 = v9 / v7;
            goto LABEL_21;
          }
        }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3913uLL, 0);
      }
    }
    else
    {
      __break(1u);
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
LABEL_21:
  if (a4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  return a1(a3, a4, &v13);
}

uint64_t UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v5;
  uint64_t result;

  Swift::Int result = a1(a2, a3);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56))(a5, 0, 1, a4);
  }
  return result;
}

void withVaList<A>(_:_:)(uint64_t a1, void (*a2)(void *))
{
  uint64_t v4 = type metadata accessor for __VaListBuilder();
  inited = swift_initStackObject(v4, v17);
  inited[2] = 8;
  inited[3] = 0;
  inited[4] = 0;
  inited[5] = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = a1 + 32;
    do
    {
      outlined init with copy of MirrorPath(v7, (uint64_t)v16);
      outlined init with take of MirrorPath(v16, (uint64_t)v13);
      uint64_t v8 = v14;
      uint64_t v9 = v15;
      __swift_project_boxed_opaque_existential_0Tm(v13, v14);
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 8))(v8, v9);
      __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v10);
      swift_bridgeObjectRelease(v10);
      __swift_destroy_boxed_opaque_existential_1Tm(v13);
      v7 += 40;
      --v6;
    }
    while (v6);
    uint64_t v11 = (void *)inited[5];
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = &static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
  a2(v12);
  swift_setDeallocating((uint64_t)inited);
  if (v11)
  {
    if ((unint64_t)(inited[4] - 0x1000000000000000) >> 61 == 7) {
      swift_slowDealloc(v11);
    }
    else {
      __break(1u);
    }
  }
}

void *__VaListBuilder.__allocating_init()()
{
  Swift::Int result = swift_allocObject(v0, 0x30uLL, 7uLL);
  result[2] = 8;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  return result;
}

void __VaListBuilder.append(_:)(void *a1)
{
  uint64_t v1 = a1[3];
  uint64_t v2 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v3);

  swift_bridgeObjectRelease(v3);
}

uint64_t _withVaList<A>(_:_:)(uint64_t a1, uint64_t (*a2)(void *))
{
  if (*(void *)(a1 + 40)) {
    uint64_t v2 = *(void **)(a1 + 40);
  }
  else {
    uint64_t v2 = &static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
  return a2(v2);
}

Swift::CVaListPointer __swiftcall __VaListBuilder.va_list()()
{
  if (v0[5]._value._rawValue) {
    return (Swift::CVaListPointer)v0[5]._value._rawValue;
  }
  else {
    return (Swift::CVaListPointer)&static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
}

Swift::CVaListPointer __swiftcall getVaList(_:)(Swift::OpaquePointer a1)
{
  uint64_t v2 = (unint64_t *)type metadata accessor for __VaListBuilder();
  uint64_t v3 = (Swift::CVaListPointer *)swift_allocObject(v2, 0x30uLL, 7uLL);
  v3[2]._value._rawValue = (Builtin::RawPointer)8;
  v3[3]._value._rawValue = 0;
  v3[4]._value._rawValue = 0;
  v3[5]._value._rawValue = 0;
  uint64_t v4 = *((void *)a1._rawValue + 2);
  if (v4)
  {
    uint64_t v5 = (char *)a1._rawValue + 32;
    do
    {
      outlined init with copy of MirrorPath((uint64_t)v5, (uint64_t)v14);
      outlined init with take of MirrorPath(v14, (uint64_t)v11);
      uint64_t v6 = v12;
      uint64_t v7 = v13;
      __swift_project_boxed_opaque_existential_0Tm(v11, v12);
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
      __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v8);
      swift_bridgeObjectRelease(v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v11);
      v5 += 40;
      --v4;
    }
    while (v4);
  }
  uint64_t v9 = v3;
  if (v3[5]._value._rawValue) {
    return (Swift::CVaListPointer)v3[5]._value._rawValue;
  }
  else {
    return (Swift::CVaListPointer)&static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
}

__objc2_class **_encodeBitsAsWords<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 - 8);
  size_t v5 = *(void *)(v4 + 64);
  MEMORY[0x1F4188790](a1);
  if (__OFADD__(v5, 8))
  {
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v6 = v5 + 14;
  if ((uint64_t)(v5 + 8) >= 1) {
    uint64_t v6 = v5 + 7;
  }
  uint64_t v7 = specialized Array.init(repeating:count:)(0, (__objc2_class *)(v6 >> 3));
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a2);
  (*(void (**)(char *, uint64_t))(v4 + 8))((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), a2);
  if ((v5 & 0x8000000000000000) != 0) {
LABEL_7:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  memcpy(v7 + 4, (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  return v7;
}

__objc2_class **Bool._cVarArgEncoding.getter(char a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1 & 1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Bool()
{
  return Bool._cVarArgEncoding.getter(*v0);
}

uint64_t Int64._cVarArgAlignment.getter()
{
  return 8;
}

uint64_t protocol witness for _CVarArgAligned._cVarArgAlignment.getter in conformance Int64()
{
  return 8;
}

__objc2_class **Int16._cVarArgEncoding.getter(__int16 a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int16()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **Int8._cVarArgEncoding.getter(char a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int8()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **Int._cVarArgEncoding.getter(__objc2_class *a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = a1;
  return result;
}

uint64_t UInt64._cVarArgAlignment.getter()
{
  return 8;
}

__objc2_class **Int32._cVarArgEncoding.getter(int a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int32()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **UInt16._cVarArgEncoding.getter(unsigned __int16 a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance UInt16()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **UInt8._cVarArgEncoding.getter(unsigned __int8 a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance UInt8()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **OpaquePointer._cVarArgEncoding.getter(__objc2_class *a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  result[4] = v1;
  return result;
}

__objc2_class **UnsafePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter(a1, a2, (uint64_t (*)(void))type metadata accessor for UnsafePointer);
}

__objc2_class **_sSPyxGs7CVarArgsRi_zrlsABP05_cVarB8EncodingSaySiGvgTW(uint64_t a1)
{
  return UnsafePointer._cVarArgEncoding.getter(*v1, *(void *)(a1 + 16));
}

__objc2_class **UnsafeMutablePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter(a1, a2, (uint64_t (*)(void))type metadata accessor for UnsafeMutablePointer);
}

__objc2_class **_sSpyxGs7CVarArgsRi_zrlsABP05_cVarB8EncodingSaySiGvgTW(uint64_t a1)
{
  return UnsafeMutablePointer._cVarArgEncoding.getter(*v1, *(void *)(a1 + 16));
}

__objc2_class **AutoreleasingUnsafeMutablePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter(a1, a2, (uint64_t (*)(void))type metadata accessor for AutoreleasingUnsafeMutablePointer);
}

__objc2_class **UnsafePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a1;
  uint64_t v3 = a3(0);
  return _encodeBitsAsWords<A>(_:)((uint64_t)&v5, v3);
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance AutoreleasingUnsafeMutablePointer<A>(uint64_t a1)
{
  return AutoreleasingUnsafeMutablePointer._cVarArgEncoding.getter(*v1, *(void *)(a1 + 16));
}

double Float._cVarArgEncoding.getter(float a1)
{
  uint64_t v2 = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  v2[2] = (__objc2_class *)1;
  double result = a1;
  *((double *)v2 + 4) = a1;
  return result;
}

Swift::Double __swiftcall Double.init(_:)(Swift::Float a1)
{
  return a1;
}

uint64_t Float._cVarArgAlignment.getter()
{
  return 8;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Float()
{
  double v1 = *v0;
  double result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((double *)result + 4) = v1;
  return result;
}

__objc2_class **Double._cVarArgEncoding.getter(double a1)
{
  double result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  *((double *)result + 4) = a1;
  return result;
}

uint64_t Double._cVarArgAlignment.getter()
{
  return 8;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Double()
{
  double v1 = *v0;
  double result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  result[4] = v1;
  return result;
}

void *__VaListBuilder.init()()
{
  double result = v0;
  v0[2] = 8;
  v0[3] = 0;
  v0[4] = 0;
  v0[5] = 0;
  return result;
}

Swift::Void __swiftcall __VaListBuilder.appendWords(_:)(Swift::OpaquePointer a1)
{
  uint64_t v2 = v1[3];
  uint64_t v3 = *((void *)a1._rawValue + 2);
  uint64_t v4 = v2 + v3;
  if (__OFADD__(v2, v3))
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  uint64_t v6 = v1[4];
  if (v6 < v4)
  {
    if (v6 + 0x4000000000000000 < 0)
    {
LABEL_18:
      __break(1u);
LABEL_19:
      __break(1u);
      goto LABEL_20;
    }
    uint64_t v7 = (char *)v1[5];
    if (2 * v6 > v4) {
      uint64_t v4 = 2 * v6;
    }
    v1[4] = v4;
    if ((unint64_t)(v4 - 0x1000000000000000) >> 61 != 7) {
      goto LABEL_19;
    }
    uint64_t v8 = (char *)swift_slowAlloc(8 * v4, 7uLL);
    v1[5] = v8;
    if (v7)
    {
      specialized UnsafeMutablePointer.moveInitialize(from:count:)(v7, v2, v8);
      if ((unint64_t)(v6 - 0x1000000000000000) >> 61 != 7)
      {
LABEL_20:
        __break(1u);
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/VarArgs.swift", 19, 2, 0x29EuLL, 0);
      }
      swift_slowDealloc(v7);
    }
  }
  uint64_t v9 = v1[5];
  if (!v9) {
    goto LABEL_21;
  }
  if (v3)
  {
    uint64_t v10 = (uint64_t *)((char *)a1._rawValue + 32);
    uint64_t v11 = v1[3];
    while (1)
    {
      uint64_t v12 = *v10++;
      *(void *)(v9 + 8 * v11) = v12;
      uint64_t v13 = v1[3];
      BOOL v14 = __OFADD__(v13, 1);
      uint64_t v11 = v13 + 1;
      if (v14) {
        break;
      }
      v1[3] = v11;
      if (!--v3) {
        return;
      }
    }
    __break(1u);
    goto LABEL_17;
  }
}

unint64_t __VaListBuilder.allocStorage(wordCount:)(unint64_t result)
{
  if ((result - 0x1000000000000000) >> 61 == 7) {
    return (unint64_t)swift_slowAlloc(8 * result, 7uLL);
  }
  __break(1u);
  return result;
}

void __VaListBuilder.deallocStorage(wordCount:storage:)(uint64_t a1, void *a2)
{
  if ((unint64_t)(a1 - 0x1000000000000000) >> 61 == 7) {
    swift_slowDealloc(a2);
  }
  else {
    __break(1u);
  }
}

Swift::tuple_Builtin_Word_Builtin_Word __swiftcall __VaListBuilder.rawSizeAndAlignment(_:)(Swift::Int a1)
{
  if ((unint64_t)(a1 - 0x1000000000000000) >> 61 == 7)
  {
    a1 *= 8;
    Builtin::Word v1 = 8;
  }
  else
  {
    __break(1u);
  }
  result._1 = v1;
  result._0 = a1;
  return result;
}

void *__VaListBuilder.deinit()
{
  Swift::tuple_Builtin_Word_Builtin_Word result = *(void **)(v0 + 40);
  if (!result) {
    return (void *)v0;
  }
  if ((unint64_t)(*(void *)(v0 + 32) - 0x1000000000000000) >> 61 == 7)
  {
    swift_slowDealloc(result);
    return (void *)v0;
  }
  __break(1u);
  return result;
}

void __VaListBuilder.__deallocating_deinit()
{
  Builtin::Word v1 = *(void **)(v0 + 40);
  if (v1)
  {
    if ((unint64_t)(*(void *)(v0 + 32) - 0x1000000000000000) >> 61 != 7)
    {
      __break(1u);
      return;
    }
    swift_slowDealloc(v1);
  }

  swift_deallocClassInstance(v0);
}

uint64_t __VaListBuilder.requiredAlignmentInBytes.getter()
{
  return 8;
}

uint64_t __VaListBuilder.count.getter()
{
  return *(void *)(v0 + 24);
}

uint64_t __VaListBuilder.count.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*__VaListBuilder.count.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __VaListBuilder.allocated.getter()
{
  return *(void *)(v0 + 32);
}

uint64_t __VaListBuilder.allocated.setter(uint64_t result)
{
  *(void *)(v1 + 32) = result;
  return result;
}

uint64_t (*__VaListBuilder.allocated.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __VaListBuilder.storage.getter()
{
  return *(void *)(v0 + 40);
}

uint64_t __VaListBuilder.storage.setter(uint64_t result)
{
  *(void *)(v1 + 40) = result;
  return result;
}

uint64_t (*__VaListBuilder.storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.init(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 32))(a7, a1);
  v15[0] = a3;
  v15[1] = a4;
  void v15[2] = a5;
  v15[3] = a6;
  uint64_t v13 = type metadata accessor for Zip2Sequence(0, (uint64_t)v15);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32))(a7 + *((int *)v13 + 13), a2, a4);
}

uint64_t Zip2Sequence._sequence2.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8) + 16))(a2, v2 + *(int *)(a1 + 52));
}

uint64_t LazyMapSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 32), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v5(a2, v2, AssociatedTypeWitness);
}

uint64_t LazyMapSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 32), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40);

  return v5(v2, a1, AssociatedTypeWitness);
}

uint64_t (*Zip2Sequence.Iterator._baseStream1.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator._baseStream2.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 52);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a1 + 40), *(void *)(a1 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16);

  return v6(a2, v4, AssociatedTypeWitness);
}

uint64_t Zip2Sequence.Iterator._baseStream2.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 52);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 40), *(void *)(a2 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40);

  return v6(v4, a1, AssociatedTypeWitness);
}

uint64_t (*Zip2Sequence.Iterator._baseStream2.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator._reachedEnd.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 56));
}

uint64_t Zip2Sequence.Iterator._reachedEnd.setter(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(v2 + *(int *)(a2 + 56)) = result;
  return result;
}

uint64_t (*Zip2Sequence.Iterator._reachedEnd.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator.init(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int **a5@<X4>, int **a6@<X5>, uint64_t a7@<X8>)
{
  v19[0] = a3;
  v19[1] = a4;
  v19[2] = a5;
  v19[3] = a6;
  BOOL v14 = type metadata accessor for Zip2Sequence.Iterator(0, (uint64_t)v19);
  *(unsigned char *)(a7 + *((int *)v14 + 14)) = 0;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a7, a1, AssociatedTypeWitness);
  uint64_t v16 = a7 + *((int *)v14 + 13);
  unint64_t v17 = swift_getAssociatedTypeWitness(0, a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)v17 - 1) + 32))(v16, a2, v17);
}

uint64_t Zip2Sequence.underestimatedCount.getter(void *a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(a1[4] + 40))(a1[2]);
  uint64_t result = (*(uint64_t (**)(void))(a1[5] + 40))(a1[3]);
  if (result >= v2) {
    return v2;
  }
  return result;
}

uint64_t SIMD.indices.getter(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(void))(*(void *)(a2 + 48) + 40))() < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return 0;
}

uint64_t SIMD.init(repeating:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v16 - v9;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a2, v7);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a2, v7);
  if (v11 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v18 = a4;
  uint64_t v19 = a2;
  if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = *(void (**)(char *, uint64_t, const char *))(v17 + 16);
    do
    {
      uint64_t v14 = v11;
      v13(v10, a1, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v10, v12, v19, v7);
      uint64_t v11 = v14;
      ++v12;
    }
    while (v14 != v12);
  }
  return (*(uint64_t (**)(uint64_t, const char *))(v17 + 8))(a1, AssociatedTypeWitness);
}

uint64_t static SIMD.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v47 = (char *)v40 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v46 = (char *)v40 - v12;
  uint64_t v13 = *(void *)(a3 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)v40 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)v40 - v17;
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v51 = a1;
  uint64_t v49 = v7;
  uint64_t v20 = v19(a3, v7);
  if (v20 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v21 = v20;
  if (v20)
  {
    uint64_t v22 = 0;
    uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
    uint64_t v23 = v13 + 16;
    uint64_t v24 = v25;
    uint64_t v50 = (void (**)(char *, uint64_t))(v23 - 8);
    v40[0] = v8 + 8;
    v40[1] = v49 + 56;
    char v26 = 1;
    uint64_t v44 = v23;
    uint64_t v45 = a2;
    uint64_t v42 = v20;
    uint64_t v43 = v18;
    uint64_t v41 = v25;
    uint64_t v52 = v16;
    v25(v18, v51, a3);
    while (1)
    {
      v24(v16, a2, a3);
      if (v26)
      {
        uint64_t v28 = v49;
        uint64_t v29 = *(void (**)(uint64_t, uint64_t, uint64_t))(v49 + 56);
        uint64_t v30 = v46;
        v29(v22, a3, v49);
        uint64_t v31 = *v50;
        (*v50)(v18, a3);
        uint64_t v32 = v47;
        v29(v22, a3, v28);
        v31(v52, a3);
        uint64_t v33 = v28;
        uint64_t v21 = v42;
        uint64_t v34 = AssociatedTypeWitness;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v33, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
        char v26 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 8))(v30, v32, v34);
        unint64_t v36 = *(void (**)(char *, const char *))v40[0];
        uint64_t v37 = v32;
        uint64_t v18 = v43;
        (*(void (**)(char *, const char *))v40[0])(v37, v34);
        uint64_t v38 = v34;
        uint64_t v16 = v52;
        uint64_t v24 = v41;
        v36(v30, v38);
        a2 = v45;
      }
      else
      {
        char v27 = *v50;
        (*v50)(v16, a3);
        v27(v18, a3);
        char v26 = 0;
      }
      if (v21 == ++v22) {
        break;
      }
      v24(v18, v51, a3);
    }
  }
  else
  {
    char v26 = 1;
  }
  return v26 & 1;
}

uint64_t SIMD.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v16 - v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a2, v5);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v11 = result;
  uint64_t v17 = a1;
  if (result)
  {
    uint64_t result = 0;
    uint64_t v16 = *(void (**)(uint64_t))(v5 + 56);
    uint64_t v12 = (void (**)(char *, const char *))(v7 + 8);
    do
    {
      uint64_t v13 = result + 1;
      uint64_t v14 = v11;
      v16(result);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      (*(void (**)(uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v17, AssociatedTypeWitness, AssociatedConformanceWitness);
      (*v12)(v9, AssociatedTypeWitness);
      uint64_t v11 = v14;
      uint64_t result = v13;
    }
    while (v14 != v13);
  }
  return result;
}

uint64_t SIMD.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v42 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v30 - v11;
  uint64_t v13 = a1[3];
  uint64_t v14 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v39, v13, v14);
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v35 = a2;
  uint64_t v36 = v6;
  uint64_t v37 = v9;
  uint64_t v16 = v15(a2, v9);
  if (v16 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v17 = v16;
  if (v16)
  {
    uint64_t v18 = 0;
    uint64_t v32 = *(void (**)(uint64_t, uint64_t, uint64_t))(v37 + 56);
    uint64_t v33 = v37 + 56;
    uint64_t v31 = (void (**)(char *, uint64_t))(v42 + 8);
    uint64_t v34 = AssociatedTypeWitness;
    while (1)
    {
      uint64_t v42 = v5;
      uint64_t v19 = v35;
      uint64_t v20 = v12;
      uint64_t v21 = v37;
      v32(v18, v35, v37);
      unint64_t v22 = v40;
      uint64_t v23 = v41;
      __swift_mutable_project_boxed_opaque_existential_1(v39, v40);
      uint64_t v38 = *(void (**)(char *, uint64_t, uint64_t, unint64_t, uint64_t))(v23 + 160);
      uint64_t v24 = v21;
      uint64_t v12 = v20;
      uint64_t v25 = v19;
      uint64_t v26 = (uint64_t)v34;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v24, v25, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Encodable);
      uint64_t v28 = v42;
      v38(v20, v26, AssociatedConformanceWitness, v22, v23);
      uint64_t v5 = v28;
      if (v28) {
        break;
      }
      ++v18;
      (*v31)(v20, v26);
      if (v17 == v18) {
        return __swift_destroy_boxed_opaque_existential_1Tm(v39);
      }
    }
    (*v31)(v20, v26);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v39);
}

uint64_t SIMD.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v76 = a4;
  uint64_t v6 = *(int ***)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v74 - v8;
  uint64_t v10 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v74 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  ((void (*)(uint64_t, int **))v6[6])(a2, v6);
  uint64_t v13 = a1[3];
  uint64_t v14 = a1[4];
  uint64_t v78 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  uint64_t v15 = v88;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v85, v13, v14);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, a2);
LABEL_3:
    uint64_t v16 = v78;
LABEL_57:
    uint64_t v32 = v16;
    return __swift_destroy_boxed_opaque_existential_1Tm(v32);
  }
  uint64_t v82 = (uint64_t)v9;
  unint64_t v17 = v86;
  uint64_t v18 = v87;
  __swift_project_boxed_opaque_existential_0Tm(v85, v86);
  uint64_t v19 = (*(uint64_t (**)(unint64_t, uint64_t))(v18 + 16))(v17, v18);
  LOBYTE(v18) = v20;
  uint64_t v21 = v6[5];
  uint64_t v81 = v6;
  uint64_t v77 = v21;
  uint64_t v22 = ((uint64_t (*)(uint64_t))v21)(a2);
  uint64_t v75 = v10;
  uint64_t v79 = v12;
  if ((v18 & 1) != 0 || v19 != v22)
  {
    uint64_t v33 = a2;
    uint64_t v88 = swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
    uint64_t v35 = v34;
    uint64_t v36 = v78;
    uint64_t v37 = v78[3];
    uint64_t v38 = v78[4];
    __swift_project_boxed_opaque_existential_0Tm(v78, v37);
    uint64_t v82 = (*(uint64_t (**)(uint64_t, uint64_t))(v38 + 8))(v37, v38);
    unint64_t v39 = specialized static String._createEmpty(withInitialCapacity:)(41);
    uint64_t v41 = v40;
    unint64_t v83 = v39;
    char v84 = (void *)v40;
    uint64_t v42 = HIBYTE(v40) & 0xF;
    if ((v40 & 0x2000000000000000) == 0) {
      uint64_t v42 = v39 & 0xFFFFFFFFFFFFLL;
    }
    if (v42 || (v39 & ~v40 & 0x2000000000000000) != 0)
    {
      if ((v40 & 0x2000000000000000) == 0
        || (0x80000001816DFE30 & 0x2000000000000000) == 0
        || (unint64_t v43 = specialized _SmallString.init(_:appending:)(v39, v40, 0xD00000000000001DLL, 0x80000001816DFE30 | 0x8000000000000000), (v45 & 1) != 0))
      {
        char v48 = v36;
        if ((0x80000001816DFE30 & 0x2000000000000000) != 0) {
          unint64_t v49 = (0x80000001816DFE30 >> 56) & 0xF;
        }
        else {
          unint64_t v49 = 29;
        }
        _StringGuts.append(_:)(0xD00000000000001DLL, 0x80000001816DFE30 | 0x8000000000000000, 0, v49);
        swift_bridgeObjectRelease(0x80000001816DFE30 | 0x8000000000000000);
        unint64_t v46 = v83;
        unint64_t v47 = (unint64_t)v84;
LABEL_27:
        uint64_t v50 = v79;
        uint64_t v51 = ((uint64_t (*)(uint64_t, int **))v77)(v33, v81);
        (*(void (**)(char *, uint64_t))(v75 + 8))(v50, v33);
        unint64_t v53 = _int64ToString(_:radix:uppercase:)(v51, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v54 = v52;
        uint64_t v55 = HIBYTE(v47) & 0xF;
        if ((v47 & 0x2000000000000000) == 0) {
          uint64_t v55 = v46 & 0xFFFFFFFFFFFFLL;
        }
        if (!v55 && (v46 & ~v47 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v47);
          unint64_t v83 = v53;
          char v84 = (void *)v54;
LABEL_40:
          Swift::String v62 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements.", 0xAuLL, 1);
          uint64_t countAndFlagsBits = v62._countAndFlagsBits;
          unint64_t object = v62._object;
          uint64_t v65 = HIBYTE(v54) & 0xF;
          if ((v54 & 0x2000000000000000) == 0) {
            uint64_t v65 = v53 & 0xFFFFFFFFFFFFLL;
          }
          if (v65 || (v53 & ~v54 & 0x2000000000000000) != 0)
          {
            if ((v54 & 0x2000000000000000) == 0)
            {
              if (((uint64_t)v62._object & 0x2000000000000000) != 0) {
                goto LABEL_51;
              }
LABEL_48:
              uint64_t v66 = v62._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_52:
              uint64_t v72 = v82;
              _StringGuts.append(_:)(v62._countAndFlagsBits, (unint64_t)v62._object, 0, v66);
              swift_bridgeObjectRelease((uint64_t)v62._object);
              uint64_t countAndFlagsBits = v83;
              unint64_t object = v84;
              uint64_t v16 = v48;
LABEL_56:
              *(void *)uint64_t v35 = v72;
              *(void *)(v35 + 8) = countAndFlagsBits;
              *(void *)(v35 + 16) = object;
              *(void *)(v35 + 24) = 0;
              *(unsigned char *)(v35 + 72) = 3;
              swift_willThrow();
              __swift_destroy_boxed_opaque_existential_1Tm(v85);
              goto LABEL_57;
            }
            if (((uint64_t)v62._object & 0x2000000000000000) == 0) {
              goto LABEL_48;
            }
            unint64_t v67 = specialized _SmallString.init(_:appending:)(v53, v54, v62._countAndFlagsBits, (unint64_t)v62._object);
            if (v69)
            {
LABEL_51:
              uint64_t v66 = ((unint64_t)v62._object >> 56) & 0xF;
              goto LABEL_52;
            }
            unint64_t v70 = v67;
            uint64_t v71 = v68;
            swift_bridgeObjectRelease(v54);
            swift_bridgeObjectRelease((uint64_t)v62._object);
            unint64_t object = v71;
            uint64_t countAndFlagsBits = v70;
          }
          else
          {
            swift_bridgeObjectRelease(v54);
          }
          uint64_t v16 = v48;
          uint64_t v72 = v82;
          goto LABEL_56;
        }
        if ((v47 & 0x2000000000000000) != 0)
        {
          if ((v52 & 0x2000000000000000) != 0)
          {
            unint64_t v57 = specialized _SmallString.init(_:appending:)(v46, v47, v53, v52);
            if ((v59 & 1) == 0)
            {
              unint64_t v60 = v57;
              unint64_t v61 = v58;
              swift_bridgeObjectRelease(v47);
              swift_bridgeObjectRelease(v54);
              unint64_t v83 = v60;
              char v84 = (void *)v61;
              unint64_t v54 = v61;
              unint64_t v53 = v60;
              goto LABEL_40;
            }
            goto LABEL_38;
          }
        }
        else if ((v52 & 0x2000000000000000) != 0)
        {
LABEL_38:
          uint64_t v56 = HIBYTE(v54) & 0xF;
          goto LABEL_39;
        }
        uint64_t v56 = v53 & 0xFFFFFFFFFFFFLL;
LABEL_39:
        _StringGuts.append(_:)(v53, v54, 0, v56);
        swift_bridgeObjectRelease(v54);
        unint64_t v53 = v83;
        unint64_t v54 = (unint64_t)v84;
        goto LABEL_40;
      }
      unint64_t v46 = v43;
      unint64_t v47 = v44;
      char v48 = v36;
      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0x80000001816DFE30 | 0x8000000000000000);
    }
    else
    {
      char v48 = v36;
      unint64_t v46 = 0xD00000000000001DLL;
      swift_bridgeObjectRelease(v40);
      unint64_t v47 = 0x80000001816DFE30 | 0x8000000000000000;
    }
    unint64_t v83 = v46;
    char v84 = (void *)v47;
    goto LABEL_27;
  }
  uint64_t v23 = ((uint64_t (*)(uint64_t, int **))v77)(a2, v81);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v24 = v23;
  if (v23)
  {
    uint64_t v25 = 0;
    uint64_t v26 = (uint64_t)v81;
    uint64_t v77 = (int *)(v81 + 8);
    while (1)
    {
      uint64_t v88 = 0;
      unint64_t v28 = v86;
      uint64_t v27 = v87;
      __swift_mutable_project_boxed_opaque_existential_1(v85, v86);
      uint64_t v81 = *(int ***)(v27 + 176);
      uint64_t v29 = AssociatedTypeWitness;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v26, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Decodable);
      uint64_t v31 = v88;
      ((void (*)(const char *, const char *, uint64_t, unint64_t, uint64_t))v81)(v29, v29, AssociatedConformanceWitness, v28, v27);
      if (v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v26 + 64))(v82, v25++, a2, v26);
      if (v24 == v25) {
        goto LABEL_11;
      }
    }
    (*(void (**)(char *, uint64_t))(v75 + 8))(v79, a2);
    __swift_destroy_boxed_opaque_existential_1Tm(v85);
    goto LABEL_3;
  }
LABEL_11:
  __swift_destroy_boxed_opaque_existential_1Tm(v85);
  (*(void (**)(uint64_t, char *, uint64_t))(v75 + 32))(v76, v79, a2);
  uint64_t v32 = v78;
  return __swift_destroy_boxed_opaque_existential_1Tm(v32);
}

unint64_t SIMD.description.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2;
  uint64_t v7 = specialized static String._createEmpty(withInitialCapacity:)(3);
  Swift::Int v9 = v7;
  unint64_t v10 = v8;
  uint64_t v324 = v7;
  unint64_t v325 = v8;
  uint64_t v11 = HIBYTE(v8) & 0xF;
  uint64_t v12 = v7 & 0xFFFFFFFFFFFFLL;
  if ((v8 & 0x2000000000000000) != 0) {
    uint64_t v13 = HIBYTE(v8) & 0xF;
  }
  else {
    uint64_t v13 = v7 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 || (v7 & ~v8 & 0x2000000000000000) != 0)
  {
    if ((v8 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v8);
      swift_bridgeObjectRelease(0xE000000000000000);
      unint64_t v44 = 0xA000000000000000;
      if (!(v10 & 0x80808080808080 | v9 & 0x8080808080808080)) {
        unint64_t v44 = 0xE000000000000000;
      }
      unint64_t v43 = v44 & 0xFF00000000000000 | (v11 << 56) | v10 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v324 = v9;
      goto LABEL_38;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6);
    uint64_t v14 = v12;
    if ((v10 & 0x1000000000000000) != 0)
    {
      uint64_t v14 = String.UTF8View._foreignCount()();
      unint64_t v15 = v9 & ~v10;
      if ((v15 & 0x2000000000000000) == 0) {
        goto LABEL_40;
      }
    }
    else
    {
      unint64_t v15 = v9 & ~v10;
      if ((v15 & 0x2000000000000000) == 0) {
        goto LABEL_40;
      }
    }
    if (swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v16 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
      if (v17) {
        goto LABEL_283;
      }
      if (v14 <= 15 && (v16 & 0x8000000000000000) != 0)
      {
LABEL_13:
        swift_bridgeObjectRelease_n(0xE000000000000000, 5);
        if ((v10 & 0x1000000000000000) == 0)
        {
          if ((v9 & 0x1000000000000000) != 0)
          {
            uint64_t v18 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            uint64_t v18 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v10);
            uint64_t v12 = v310;
          }
          swift_bridgeObjectRetain(v10);
          closure #1 in _StringGuts._convertedToSmall()(v18, v12, &v323);
          swift_bridgeObjectRelease(v10);
          unint64_t v20 = *((void *)&v323 + 1);
          unint64_t v19 = v323;
          goto LABEL_17;
        }
        goto LABEL_273;
      }
LABEL_41:
      int64_t v45 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
      BOOL v48 = (v46 & 1) == 0 && v45 >= 0;
      if ((v15 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v48) {
          goto LABEL_59;
        }
      }
      else if (v48)
      {
LABEL_58:
        _StringGuts.grow(_:)(v14);
LABEL_59:
        swift_bridgeObjectRelease_n(0xE000000000000000, 6);
        long long v323 = 0uLL;
        unint64_t v53 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v323, 0);
        _StringGuts.appendInPlace(_:isASCII:)(v53, v54, 1);
        swift_bridgeObjectRelease(0xE000000000000000);
        goto LABEL_60;
      }
      uint64_t v49 = _StringGuts.nativeCapacity.getter(v9, v10);
      if (v50) {
        uint64_t v51 = 0;
      }
      else {
        uint64_t v51 = v49;
      }
      if (v51 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_280;
      }
      uint64_t v52 = 2 * v51;
      if (v52 > v14) {
        uint64_t v14 = v52;
      }
      goto LABEL_58;
    }
LABEL_40:
    if (v14 <= 15) {
      goto LABEL_13;
    }
    goto LABEL_41;
  }
  swift_bridgeObjectRelease(v8);
  unint64_t v43 = 0xE000000000000000;
  uint64_t v324 = 0;
LABEL_38:
  while (2)
  {
    unint64_t v325 = v43;
LABEL_60:
    TypeName = (uint8x16_t *)swift_getTypeName((Class *)a1, 0);
    if (v56 < 0)
    {
      LODWORD(v318) = 0;
      unint64_t v317 = 1343;
      LOBYTE(v316) = 2;
      Swift::String::Index v299 = "UnsafeBufferPointer with negative count";
      uint64_t v300 = 39;
      goto LABEL_262;
    }
    size_t v57 = v56;
    uint64_t v320 = v4;
    uint64_t v321 = a2;
    uint64_t v322 = a1;
    if (!v56)
    {
      uint64_t v4 = 0;
      unint64_t v3 = 0xE000000000000000;
LABEL_168:
      BOOL v48 = 0;
      goto LABEL_169;
    }
    unint64_t v58 = (uint64_t *)TypeName;
    char v59 = TypeName;
    if ((v56 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0) {
        goto LABEL_82;
      }
      char v59 = TypeName + 1;
      while (v59 < (uint8x16_t *)&TypeName->i8[v56 & 0xFFFFFFFFFFFFFFF0])
      {
        uint64_t v60 = v59->i64[0];
        uint64_t v61 = v59->i64[1];
        ++v59;
        if (((v61 | v60) & 0x8080808080808080) != 0) {
          goto LABEL_82;
        }
      }
    }
    if (v59 < (uint8x16_t *)&TypeName->i8[v56 & 0xFFFFFFFFFFFFFFF8])
    {
      if ((v59->i64[0] & 0x8080808080808080) != 0) {
        goto LABEL_82;
      }
      char v59 = (uint8x16_t *)((char *)v59 + 8);
    }
    if (v59 < (uint8x16_t *)&TypeName->i8[v56 & 0xFFFFFFFFFFFFFFFCLL])
    {
      if ((v59->i32[0] & 0x80808080) != 0) {
        goto LABEL_82;
      }
      char v59 = (uint8x16_t *)((char *)v59 + 4);
    }
    if (v59 >= (uint8x16_t *)&TypeName->i8[v56 & 0xFFFFFFFFFFFFFFFELL])
    {
LABEL_78:
      if (v59 >= (uint8x16_t *)&TypeName->i8[v56] || (v59->i8[0] & 0x80000000) == 0)
      {
        if (v56 > 15)
        {
          char v62 = 1;
LABEL_122:
          unint64_t v3 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v56, v56, v62 & 1);
          BOOL v48 = 0;
          uint64_t v4 = *(void *)(v3 + 24);
          goto LABEL_169;
        }
LABEL_132:
        unint64_t v99 = v56 - 8;
        unint64_t v100 = 8;
        if (v56 < 8) {
          unint64_t v100 = v56;
        }
        if ((v100 & 0x8000000000000000) == 0)
        {
          if (v100 >= 8)
          {
            if (v100 >= 0x10)
            {
              unint64_t v101 = v100 & 0xFFFFFFFFFFFFFFF0;
              uint16x8_t v126 = vmovl_high_u8(*TypeName);
              int8x16_t v127 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v126.i8);
              uint16x8_t v128 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
              int8x16_t v129 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v128.i8);
              int8x16_t v130 = (int8x16_t)vmovl_high_u16(v126);
              int8x8_t v131 = (int8x8_t)vextq_s8(v130, v130, 8uLL).u64[0];
              int8x16_t v132 = (int8x16_t)vmovl_high_u16(v128);
              int8x8_t v133 = (int8x8_t)vextq_s8(v132, v132, 8uLL).u64[0];
              *(int8x8_t *)v132.i8 = vorr_s8(*(int8x8_t *)v132.i8, *(int8x8_t *)v130.i8);
              v134.i64[0] = v132.u32[0];
              v134.i64[1] = v132.u32[1];
              int8x16_t v135 = (int8x16_t)vshlq_u64(v134, (uint64x2_t)xmmword_18162AD00);
              *(int8x8_t *)v130.i8 = vorr_s8(*(int8x8_t *)v129.i8, *(int8x8_t *)v127.i8);
              v134.i64[0] = v130.u32[0];
              v134.i64[1] = v130.u32[1];
              int8x16_t v136 = vorrq_s8((int8x16_t)vshlq_u64(v134, (uint64x2_t)xmmword_18162ACF0), v135);
              *(int8x8_t *)v130.i8 = vorr_s8(v133, v131);
              v134.i64[0] = v130.u32[0];
              v134.i64[1] = v130.u32[1];
              int8x16_t v137 = (int8x16_t)vshlq_u64(v134, (uint64x2_t)xmmword_18162ACE0);
              *(int8x8_t *)v127.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v129, v129, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v127, v127, 8uLL));
              v134.i64[0] = v127.u32[0];
              v134.i64[1] = v127.u32[1];
              int8x16_t v138 = vorrq_s8(v136, vorrq_s8((int8x16_t)vshlq_u64(v134, (uint64x2_t)xmmword_18162ACD0), v137));
              uint64_t v4 = (uint64_t)vorr_s8(*(int8x8_t *)v138.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v138, v138, 8uLL));
              if (v100 == (v100 & 0xFFFFFFFFFFFFFFF0)) {
                goto LABEL_149;
              }
              unint64_t v102 = 8 * v101;
              if ((v100 & 8) == 0) {
                goto LABEL_147;
              }
            }
            else
            {
              uint64_t v4 = 0;
              unint64_t v102 = 0;
              unint64_t v101 = 0;
            }
            unint64_t v103 = v101;
            int64x2_t v104 = vdupq_n_s64(v102);
            unint64_t v101 = v100 & 0xFFFFFFFFFFFFFFF8;
            unint64_t v102 = 8 * (v100 & 0xFFFFFFFFFFFFFFF8);
            int8x16_t v105 = 0uLL;
            int8x16_t v106 = (int8x16_t)(unint64_t)v4;
            int64x2_t v107 = vaddq_s64(v104, (int64x2_t)xmmword_18162ACE0);
            int64x2_t v108 = vaddq_s64(v104, (int64x2_t)xmmword_18162AD00);
            int64x2_t v109 = vaddq_s64(v104, (int64x2_t)xmmword_18162ACD0);
            int64x2_t v110 = vaddq_s64(v104, (int64x2_t)xmmword_18162ACF0);
            uint64_t v111 = (uint8x8_t *)&TypeName->i8[v103];
            int8x16_t v112 = (int8x16_t)vdupq_n_s64(0x38uLL);
            unint64_t v113 = v103 - (v100 & 0xFFFFFFFFFFFFFFF8);
            int64x2_t v114 = vdupq_n_s64(0x40uLL);
            int8x16_t v115 = 0uLL;
            int8x16_t v116 = 0uLL;
            do
            {
              uint8x8_t v117 = *v111++;
              uint16x8_t v118 = vmovl_u8(v117);
              uint32x4_t v119 = vmovl_high_u16(v118);
              v120.i64[0] = v119.u32[2];
              v120.i64[1] = v119.u32[3];
              uint64x2_t v121 = v120;
              v120.i64[0] = v119.u32[0];
              v120.i64[1] = v119.u32[1];
              uint64x2_t v122 = v120;
              uint32x4_t v123 = vmovl_u16(*(uint16x4_t *)v118.i8);
              v120.i64[0] = v123.u32[2];
              v120.i64[1] = v123.u32[3];
              uint64x2_t v124 = v120;
              v120.i64[0] = v123.u32[0];
              v120.i64[1] = v123.u32[1];
              int8x16_t v116 = vorrq_s8((int8x16_t)vshlq_u64(v121, (uint64x2_t)vandq_s8((int8x16_t)v107, v112)), v116);
              int8x16_t v115 = vorrq_s8((int8x16_t)vshlq_u64(v122, (uint64x2_t)vandq_s8((int8x16_t)v108, v112)), v115);
              int8x16_t v105 = vorrq_s8((int8x16_t)vshlq_u64(v124, (uint64x2_t)vandq_s8((int8x16_t)v109, v112)), v105);
              int8x16_t v106 = vorrq_s8((int8x16_t)vshlq_u64(v120, (uint64x2_t)vandq_s8((int8x16_t)v110, v112)), v106);
              int64x2_t v108 = vaddq_s64(v108, v114);
              int64x2_t v109 = vaddq_s64(v109, v114);
              int64x2_t v110 = vaddq_s64(v110, v114);
              int64x2_t v107 = vaddq_s64(v107, v114);
              v113 += 8;
            }
            while (v113);
            int8x16_t v125 = vorrq_s8(vorrq_s8(v106, v115), vorrq_s8(v105, v116));
            uint64_t v4 = (uint64_t)vorr_s8(*(int8x8_t *)v125.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v125, v125, 8uLL));
            if (v100 == v101)
            {
LABEL_149:
              if (v56 < 9)
              {
                int8x8_t v143 = 0;
LABEL_165:
                unint64_t v207 = 0xA000000000000000;
                if (((*(void *)&v143 | v4) & 0x8080808080808080) == 0) {
                  unint64_t v207 = 0xE000000000000000;
                }
                unint64_t v3 = v207 | (v56 << 56) | *(void *)&v143;
                goto LABEL_168;
              }
              if (v99 < 8)
              {
                unint64_t v142 = 0;
                int8x8_t v143 = 0;
                unint64_t v144 = 0;
LABEL_163:
                uint64_t v204 = v56 - v142 - 8;
                int8x16_t v205 = &TypeName->u8[v142 + 8];
                do
                {
                  unsigned int v206 = *v205++;
                  *(void *)&v143 |= (unint64_t)v206 << (v144 & 0x38);
                  v144 += 8;
                  --v204;
                }
                while (v204);
                goto LABEL_165;
              }
              if (v99 >= 0x10)
              {
                int8x16_t v168 = (uint8x16_t *)&TypeName->u64[1];
                unint64_t v142 = v99 & 0xFFFFFFFFFFFFFFF0;
                int64x2_t v169 = (int64x2_t)xmmword_18162AD80;
                int64x2_t v170 = (int64x2_t)xmmword_18162AD90;
                int64x2_t v171 = (int64x2_t)xmmword_18162ADA0;
                int64x2_t v172 = (int64x2_t)xmmword_18162ADB0;
                int64x2_t v173 = (int64x2_t)xmmword_18162ACE0;
                int64x2_t v174 = (int64x2_t)xmmword_18162AD00;
                int8x16_t v175 = (int8x16_t)vdupq_n_s64(0x38uLL);
                int64x2_t v176 = vdupq_n_s64(0x80uLL);
                int64x2_t v177 = (int64x2_t)xmmword_18162ACD0;
                unint64_t v144 = 8 * (v99 & 0xFFFFFFFFFFFFFFF0);
                int8x16_t v178 = 0uLL;
                int8x16_t v179 = 0uLL;
                int64x2_t v180 = (int64x2_t)xmmword_18162ACF0;
                unint64_t v181 = v99 & 0xFFFFFFFFFFFFFFF0;
                int8x16_t v182 = 0uLL;
                int8x16_t v183 = 0uLL;
                int8x16_t v184 = 0uLL;
                int8x16_t v185 = 0uLL;
                int8x16_t v186 = 0uLL;
                int8x16_t v187 = 0uLL;
                do
                {
                  uint8x16_t v188 = *v168++;
                  uint16x8_t v189 = vmovl_u8(*(uint8x8_t *)v188.i8);
                  uint32x4_t v190 = vmovl_high_u16(v189);
                  v191.i64[0] = v190.u32[2];
                  v191.i64[1] = v190.u32[3];
                  uint64x2_t v192 = v191;
                  uint16x8_t v193 = vmovl_high_u8(v188);
                  uint32x4_t v194 = vmovl_u16(*(uint16x4_t *)v193.i8);
                  v191.i64[0] = v194.u32[2];
                  v191.i64[1] = v194.u32[3];
                  uint64x2_t v195 = v191;
                  v191.i64[0] = v194.u32[0];
                  v191.i64[1] = v194.u32[1];
                  uint64x2_t v196 = v191;
                  v191.i64[0] = v190.u32[0];
                  v191.i64[1] = v190.u32[1];
                  uint64x2_t v197 = v191;
                  uint32x4_t v198 = vmovl_u16(*(uint16x4_t *)v189.i8);
                  v191.i64[0] = v198.u32[2];
                  v191.i64[1] = v198.u32[3];
                  uint64x2_t v199 = v191;
                  uint32x4_t v200 = vmovl_high_u16(v193);
                  v191.i64[0] = v200.u32[0];
                  v191.i64[1] = v200.u32[1];
                  uint64x2_t v201 = v191;
                  v191.i64[0] = v198.u32[0];
                  v191.i64[1] = v198.u32[1];
                  uint64x2_t v202 = v191;
                  v191.i64[0] = v200.u32[2];
                  v191.i64[1] = v200.u32[3];
                  int8x16_t v183 = vorrq_s8((int8x16_t)vshlq_u64(v192, (uint64x2_t)vandq_s8((int8x16_t)v173, v175)), v183);
                  int8x16_t v185 = vorrq_s8((int8x16_t)vshlq_u64(v195, (uint64x2_t)vandq_s8((int8x16_t)v171, v175)), v185);
                  int8x16_t v184 = vorrq_s8((int8x16_t)vshlq_u64(v196, (uint64x2_t)vandq_s8((int8x16_t)v172, v175)), v184);
                  int8x16_t v182 = vorrq_s8((int8x16_t)vshlq_u64(v197, (uint64x2_t)vandq_s8((int8x16_t)v174, v175)), v182);
                  int8x16_t v179 = vorrq_s8((int8x16_t)vshlq_u64(v199, (uint64x2_t)vandq_s8((int8x16_t)v177, v175)), v179);
                  int8x16_t v186 = vorrq_s8((int8x16_t)vshlq_u64(v201, (uint64x2_t)vandq_s8((int8x16_t)v170, v175)), v186);
                  int8x16_t v178 = vorrq_s8((int8x16_t)vshlq_u64(v202, (uint64x2_t)vandq_s8((int8x16_t)v180, v175)), v178);
                  int8x16_t v187 = vorrq_s8((int8x16_t)vshlq_u64(v191, (uint64x2_t)vandq_s8((int8x16_t)v169, v175)), v187);
                  int64x2_t v174 = vaddq_s64(v174, v176);
                  int64x2_t v177 = vaddq_s64(v177, v176);
                  int64x2_t v180 = vaddq_s64(v180, v176);
                  int64x2_t v173 = vaddq_s64(v173, v176);
                  int64x2_t v172 = vaddq_s64(v172, v176);
                  int64x2_t v171 = vaddq_s64(v171, v176);
                  int64x2_t v170 = vaddq_s64(v170, v176);
                  int64x2_t v169 = vaddq_s64(v169, v176);
                  v181 -= 16;
                }
                while (v181);
                int8x16_t v203 = vorrq_s8(vorrq_s8(vorrq_s8(v178, v184), vorrq_s8(v182, v186)), vorrq_s8(vorrq_s8(v179, v185), vorrq_s8(v183, v187)));
                int8x8_t v143 = vorr_s8(*(int8x8_t *)v203.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v203, v203, 8uLL));
                if (v99 == v142) {
                  goto LABEL_165;
                }
                if ((v99 & 8) == 0) {
                  goto LABEL_163;
                }
              }
              else
              {
                int8x8_t v143 = 0;
                unint64_t v144 = 0;
                unint64_t v142 = 0;
              }
              unint64_t v145 = v142;
              unint64_t v142 = v99 & 0xFFFFFFFFFFFFFFF8;
              int64x2_t v146 = vdupq_n_s64(v144);
              unint64_t v144 = 8 * (v99 & 0xFFFFFFFFFFFFFFF8);
              int8x16_t v147 = (int8x16_t)(unint64_t)v143;
              int8x16_t v148 = 0uLL;
              int64x2_t v149 = vaddq_s64(v146, (int64x2_t)xmmword_18162ACE0);
              int64x2_t v150 = vaddq_s64(v146, (int64x2_t)xmmword_18162AD00);
              int64x2_t v151 = vaddq_s64(v146, (int64x2_t)xmmword_18162ACD0);
              int64x2_t v152 = vaddq_s64(v146, (int64x2_t)xmmword_18162ACF0);
              int8x8_t v153 = (uint8x8_t *)((char *)&TypeName->u64[1] + v145);
              int8x16_t v154 = (int8x16_t)vdupq_n_s64(0x38uLL);
              unint64_t v155 = v145 - (v99 & 0xFFFFFFFFFFFFFFF8);
              int64x2_t v156 = vdupq_n_s64(0x40uLL);
              int8x16_t v157 = 0uLL;
              int8x16_t v158 = 0uLL;
              do
              {
                uint8x8_t v159 = *v153++;
                uint16x8_t v160 = vmovl_u8(v159);
                uint32x4_t v161 = vmovl_high_u16(v160);
                v162.i64[0] = v161.u32[2];
                v162.i64[1] = v161.u32[3];
                uint64x2_t v163 = v162;
                v162.i64[0] = v161.u32[0];
                v162.i64[1] = v161.u32[1];
                uint64x2_t v164 = v162;
                uint32x4_t v165 = vmovl_u16(*(uint16x4_t *)v160.i8);
                v162.i64[0] = v165.u32[2];
                v162.i64[1] = v165.u32[3];
                uint64x2_t v166 = v162;
                v162.i64[0] = v165.u32[0];
                v162.i64[1] = v165.u32[1];
                int8x16_t v158 = vorrq_s8((int8x16_t)vshlq_u64(v163, (uint64x2_t)vandq_s8((int8x16_t)v149, v154)), v158);
                int8x16_t v157 = vorrq_s8((int8x16_t)vshlq_u64(v164, (uint64x2_t)vandq_s8((int8x16_t)v150, v154)), v157);
                int8x16_t v148 = vorrq_s8((int8x16_t)vshlq_u64(v166, (uint64x2_t)vandq_s8((int8x16_t)v151, v154)), v148);
                int8x16_t v147 = vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)vandq_s8((int8x16_t)v152, v154)), v147);
                int64x2_t v150 = vaddq_s64(v150, v156);
                int64x2_t v151 = vaddq_s64(v151, v156);
                int64x2_t v152 = vaddq_s64(v152, v156);
                int64x2_t v149 = vaddq_s64(v149, v156);
                v155 += 8;
              }
              while (v155);
              int8x16_t v167 = vorrq_s8(vorrq_s8(v147, v157), vorrq_s8(v148, v158));
              int8x8_t v143 = vorr_s8(*(int8x8_t *)v167.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v167, v167, 8uLL));
              if (v99 == v142) {
                goto LABEL_165;
              }
              goto LABEL_163;
            }
          }
          else
          {
            unint64_t v101 = 0;
            uint64_t v4 = 0;
            unint64_t v102 = 0;
          }
LABEL_147:
          uint32x4_t v139 = &TypeName->u8[v101];
          unint64_t v140 = v100 - v101;
          do
          {
            unsigned int v141 = *v139++;
            v4 |= (unint64_t)v141 << (v102 & 0x38);
            v102 += 8;
            --v140;
          }
          while (v140);
          goto LABEL_149;
        }
LABEL_260:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      }
      goto LABEL_82;
    }
    if ((v59->i16[0] & 0x8080) == 0)
    {
      char v59 = (uint8x16_t *)((char *)v59 + 2);
      goto LABEL_78;
    }
LABEL_82:
    unint64_t v10 = 0;
    uint64_t v63 = (uint8x16_t *)((char *)TypeName + v56);
    char v62 = 1;
    unint64_t v64 = TypeName;
    uint64_t v65 = TypeName;
    while (1)
    {
      int v68 = v65->i8[0];
      uint64_t v65 = (uint8x16_t *)((char *)v65 + 1);
      unsigned __int8 v67 = v68;
      if (v68 < 0) {
        break;
      }
      uint64_t v66 = 1;
LABEL_84:
      v10 += v66;
      unint64_t v64 = v65;
      if (v65 == v63)
      {
        if (v56 > 15) {
          goto LABEL_122;
        }
        goto LABEL_132;
      }
    }
    if ((v67 + 62) > 0x32u) {
      goto LABEL_123;
    }
    if (v67 <= 0xDFu)
    {
      if (v65 == v63 || (v65->i8[0] & 0xC0) != 0x80) {
        goto LABEL_123;
      }
      char v62 = 0;
      uint64_t v65 = (uint8x16_t *)&v64->i16[1];
      uint64_t v66 = 2;
      goto LABEL_84;
    }
    if (v67 == 224)
    {
      if (v65 == v63 || (v64->i8[1] & 0xE0) != 0xA0) {
        goto LABEL_123;
      }
      goto LABEL_102;
    }
    if (v67 <= 0xECu)
    {
LABEL_96:
      if (v65 == v63) {
        goto LABEL_123;
      }
      LOBYTE(v69) = v64->i8[1];
LABEL_101:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_123;
      }
LABEL_102:
      if (&v64->i16[1] == (__int16 *)v63 || (v64->i8[2] & 0xC0) != 0x80) {
        goto LABEL_123;
      }
      char v62 = 0;
      uint64_t v65 = (uint8x16_t *)((char *)v64->i32 + 3);
      uint64_t v66 = 3;
      goto LABEL_84;
    }
    if (v67 == 237)
    {
      if (v65 == v63) {
        goto LABEL_123;
      }
      unsigned int v69 = v64->u8[1];
      if (v69 > 0x9F) {
        goto LABEL_123;
      }
      goto LABEL_101;
    }
    if (v67 <= 0xEFu) {
      goto LABEL_96;
    }
    if (v67 == 240)
    {
      if (v65 == v63 || (v64->i8[1] + 64) < 0xD0u) {
        goto LABEL_123;
      }
      goto LABEL_116;
    }
    if ((v67 + 15) <= 2u)
    {
      if (v65 == v63) {
        goto LABEL_123;
      }
      LOBYTE(v70) = v64->i8[1];
LABEL_115:
      if ((v70 & 0xC0) != 0x80) {
        goto LABEL_123;
      }
LABEL_116:
      if (&v64->i16[1] == (__int16 *)v63
        || (v64->i8[2] & 0xC0) != 0x80
        || (uint8x16_t *)((char *)v64->i32 + 3) == v63
        || (v64->i8[3] & 0xC0) != 0x80)
      {
        goto LABEL_123;
      }
      char v62 = 0;
      uint64_t v65 = (uint8x16_t *)((char *)v64->i64 + 4);
      uint64_t v66 = 4;
      goto LABEL_84;
    }
    if (v65 != v63)
    {
      unsigned int v70 = v64->u8[1];
      if (v70 <= 0x8F) {
        goto LABEL_115;
      }
    }
LABEL_123:
    Swift::Int v9 = (Swift::Int)swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease((id)v9);
    uint64_t v71 = specialized Collection.subscript.getter(v10, (uint64_t)v58, v57);
    uint64_t v76 = findInvalidRange #1 (_:) in validateUTF8(_:)(v71, v72, v73, v74);
    *(void *)&long long v323 = 0;
    *((void *)&v323 + 1) = 0xE000000000000000;
    if (__OFADD__(v57, 15)) {
      goto LABEL_272;
    }
    uint64_t v77 = v75;
    _StringGuts.reserveCapacity(_:)(v57 + 15);
    BOOL v48 = 0;
    while (2)
    {
      uint64_t v78 = specialized Collection.subscript.getter(v76, (uint64_t)v58, v57);
      uint64_t v82 = v323 & 0xFFFFFFFFFFFFLL;
      if ((*((void *)&v323 + 1) & 0x2000000000000000) != 0) {
        uint64_t v82 = HIBYTE(*((void *)&v323 + 1)) & 0xFLL;
      }
      BOOL v83 = __OFADD__(v82, v57);
      size_t v84 = v82 + v57;
      if (v83)
      {
        __break(1u);
LABEL_259:
        __break(1u);
        goto LABEL_260;
      }
      uint64_t v85 = v78;
      if (__OFADD__(v84, 3)) {
        goto LABEL_259;
      }
      uint64_t v86 = v79;
      uint64_t v87 = v80;
      uint64_t v88 = v81;
      _StringGuts.reserveCapacity(_:)(v84 + 3);
      BOOL v89 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v85, v86, v87, v88);
      _StringGuts.appendInPlace(_:isASCII:)(v89, v90, 0);
      size_t v326 = 3;
      uint64_t v327 = 12435439;
      specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v327, &v326, &v323);
      uint64_t v91 = specialized Collection.subscript.getter(v77, (uint64_t)v58, v57);
      unint64_t v58 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v91, v92, v93, v94);
      size_t v57 = v95;
      uint64_t v96 = validateUTF8(_:)(v58, v95);
      if (v98)
      {
        uint64_t v76 = v96;
        uint64_t v77 = v97;
        if (!v57) {
          goto LABEL_138;
        }
        continue;
      }
      break;
    }
    _StringGuts.appendInPlace(_:isASCII:)((char *)v58, v57, 0);
LABEL_138:
    unint64_t v3 = *((void *)&v323 + 1);
    uint64_t v4 = v323;
    a1 = v322;
LABEL_169:
    unint64_t v208 = v324;
    unint64_t v10 = v325;
    unint64_t v209 = HIBYTE(v325) & 0xF;
    if ((v325 & 0x2000000000000000) != 0) {
      unint64_t v210 = HIBYTE(v325) & 0xF;
    }
    else {
      unint64_t v210 = v324 & 0xFFFFFFFFFFFFLL;
    }
    if (!v210 && (v324 & ~v325 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v325);
      uint64_t v324 = v4;
      unint64_t v325 = v3;
      goto LABEL_220;
    }
    a1 = v3 & 0x2000000000000000;
    a2 = HIBYTE(v3) & 0xF;
    if ((v325 & 0x2000000000000000) == 0 || !a1) {
      goto LABEL_178;
    }
    unint64_t v211 = v209 + a2;
    if (v209 + a2 <= 0xF)
    {
      a1 = v322;
      if (a2)
      {
        char v237 = 0;
        unint64_t v238 = 0;
        unint64_t v239 = v325;
        do
        {
          unint64_t v240 = v209 + v238;
          unint64_t v241 = v238 + 1;
          if (v238 >= 8) {
            unint64_t v242 = v3;
          }
          else {
            unint64_t v242 = v4;
          }
          unint64_t v243 = v242 >> (v237 & 0x38);
          char v244 = (8 * v209 + v237) & 0x38;
          uint64_t v245 = (-255 << v244) - 1;
          unint64_t v246 = (unint64_t)v243 << v244;
          unint64_t v247 = v246 | v245 & v239;
          unint64_t v248 = v246 | v245 & v208;
          if (v240 < 8) {
            unint64_t v208 = v248;
          }
          else {
            unint64_t v239 = v247;
          }
          v237 += 8;
          unint64_t v238 = v241;
        }
        while (a2 != v241);
      }
      else
      {
        unint64_t v239 = v325;
      }
      swift_bridgeObjectRelease(v325);
      swift_bridgeObjectRelease(v3);
      unint64_t v254 = 0xA000000000000000;
      if (!(v208 & 0x8080808080808080 | v239 & 0x80808080808080)) {
        unint64_t v254 = 0xE000000000000000;
      }
      uint64_t v324 = v208;
      unint64_t v325 = v254 & 0xFF00000000000000 | (v211 << 56) | v239 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_220;
    }
    a1 = 1;
LABEL_178:
    uint64_t v319 = v4 & 0xFFFFFFFFFFFFLL;
    if (a1) {
      uint64_t v212 = HIBYTE(v3) & 0xF;
    }
    else {
      uint64_t v212 = v4 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v3, 2);
    if ((v3 & 0x1000000000000000) == 0)
    {
      swift_bridgeObjectRetain_n(v3, 4);
      Swift::Int v9 = v212;
      if ((v10 & 0x1000000000000000) == 0) {
        goto LABEL_183;
      }
LABEL_266:
      Swift::Int v305 = String.UTF8View._foreignCount()();
      int64_t v213 = v305 + v9;
      if (!__OFADD__(v305, v9)) {
        goto LABEL_184;
      }
LABEL_268:
      __break(1u);
LABEL_269:
      Swift::Int v306 = String.UTF8View._foreignCount()();
      int64_t v265 = v306 + 1;
      if (!__OFADD__(v306, 1)) {
        goto LABEL_238;
      }
LABEL_271:
      __break(1u);
LABEL_272:
      __break(1u);
LABEL_273:
      unint64_t v19 = _StringGuts._foreignConvertedToSmall()(v9, v10);
      unint64_t v20 = v307;
LABEL_17:
      v21._Swift::UInt64 rawBits = 1;
      v22._Swift::UInt64 rawBits = 1;
      v23._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v21, v22, 0, 0xE000000000000000);
      if (v23._rawBits < 0x10000) {
        v23._rawBits |= 3;
      }
      unint64_t v25 = specialized String.init(_:)(v23, v24, 0, 0xE000000000000000);
      unint64_t v27 = v26;
      swift_bridgeObjectRelease(0xE000000000000000);
      if ((v27 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v27);
      }
      else if ((v27 & 0x1000000000000000) != 0)
      {
        unint64_t v25 = _StringGuts._foreignConvertedToSmall()(v25, v27);
        unint64_t v314 = v313;
        swift_bridgeObjectRelease(v27);
        unint64_t v27 = v314;
      }
      else
      {
        if ((v25 & 0x1000000000000000) != 0)
        {
          uint64_t v308 = (unsigned __int8 *)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v309 = v25 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          uint64_t v308 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v25, v27);
        }
        closure #1 in _StringGuts._convertedToSmall()(v308, v309, &v323);
        swift_bridgeObjectRelease(v27);
        unint64_t v27 = *((void *)&v323 + 1);
        unint64_t v25 = v323;
      }
      uint64_t v28 = HIBYTE(v20) & 0xF;
      uint64_t v29 = HIBYTE(v27) & 0xF;
      uint64_t v30 = v29 + v28;
      if ((unint64_t)(v29 + v28) <= 0xF)
      {
        if (v29)
        {
          char v31 = 0;
          unint64_t v32 = 0;
          do
          {
            unint64_t v33 = v28 + v32;
            unint64_t v34 = v32 + 1;
            if (v32 >= 8) {
              unint64_t v35 = v27;
            }
            else {
              unint64_t v35 = v25;
            }
            unint64_t v36 = v35 >> (v31 & 0x38);
            char v37 = (8 * v28 + v31) & 0x38;
            uint64_t v38 = (-255 << v37) - 1;
            unint64_t v39 = (unint64_t)v36 << v37;
            unint64_t v40 = v39 | v38 & v20;
            unint64_t v41 = v39 | v38 & v19;
            if (v33 < 8) {
              unint64_t v19 = v41;
            }
            else {
              unint64_t v20 = v40;
            }
            v31 += 8;
            unint64_t v32 = v34;
          }
          while (v29 != v34);
        }
        swift_bridgeObjectRelease(v10);
        swift_bridgeObjectRelease(0xE000000000000000);
        unint64_t v42 = 0xA000000000000000;
        if (!(v19 & 0x8080808080808080 | v20 & 0x80808080808080)) {
          unint64_t v42 = 0xE000000000000000;
        }
        unint64_t v43 = v42 & 0xFF00000000000000 | (v30 << 56) | v20 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v324 = v19;
        continue;
      }
LABEL_282:
      unint64_t v312 = 266;
LABEL_284:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v312, 0);
    }
    break;
  }
  swift_bridgeObjectRetain_n(v3, 5);
  v301._Swift::UInt64 rawBits = 1;
  v302._Swift::UInt64 rawBits = (v212 << 16) | 1;
  v303._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v301, v302, v4, v3);
  if (v303._rawBits < 0x10000) {
    v303._rawBits |= 3;
  }
  Swift::Int v9 = specialized Collection.count.getter(v303, v304, v4, v3);
  swift_bridgeObjectRelease(v3);
  if ((v10 & 0x1000000000000000) != 0) {
    goto LABEL_266;
  }
LABEL_183:
  BOOL v83 = __OFADD__(v210, v9);
  int64_t v213 = v210 + v9;
  if (v83) {
    goto LABEL_268;
  }
LABEL_184:
  if ((v208 & ~v10 & 0x2000000000000000) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v213 <= 15) {
      goto LABEL_191;
    }
LABEL_197:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v213, v9);
    swift_bridgeObjectRelease_n(v3, 4);
    if ((v3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v3);
      _StringGuts._foreignAppendInPlace(_:)(v4, v3, 0, v212);
      swift_bridgeObjectRelease_n(v3, 2);
      uint64_t v4 = v320;
      a2 = v321;
      a1 = v322;
      goto LABEL_221;
    }
    if (a1)
    {
      swift_bridgeObjectRelease_n(v3, 2);
      *(void *)&long long v323 = v4;
      *((void *)&v323 + 1) = v3 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v235 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v3) & 0xF, (uint64_t)&v323, HIBYTE(v3) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v235, v236, (v3 & 0x4000000000000000) != 0);
      a1 = v322;
      swift_bridgeObjectRelease(v3);
LABEL_220:
      uint64_t v4 = v320;
      a2 = v321;
      goto LABEL_221;
    }
    if ((v4 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v3);
      id v249 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v250 = v319;
      uint64_t v251 = (uint64_t *)v319;
      a2 = v321;
      a1 = v322;
      goto LABEL_214;
    }
LABEL_280:
    id v249 = _StringObject.sharedUTF8.getter(v4, v3);
    uint64_t v251 = v311;
    swift_bridgeObjectRelease(v3);
    if ((uint64_t)v251 >= v319)
    {
      while (1)
      {
        a2 = v321;
        a1 = v322;
        uint64_t v250 = v319;
LABEL_214:
        unint64_t v252 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v250, (uint64_t)v249, (uint64_t)v251);
        uint64_t v251 = &v324;
        _StringGuts.appendInPlace(_:isASCII:)(v252, v253, v4 < 0);
        if (!v48) {
          break;
        }
        swift_errorRelease((id)v48);
        swift_bridgeObjectRelease(v3);
        __break(1u);
      }
      swift_bridgeObjectRelease_n(v3, 2);
      goto LABEL_195;
    }
    LODWORD(v318) = 0;
    unint64_t v317 = 1861;
    LOBYTE(v316) = 2;
    Swift::String::Index v299 = "";
    uint64_t v300 = 0;
LABEL_262:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v299, v300, 2, "Swift/UnsafeBufferPointer.swift", 31, v316, v317, v318);
  }
  int64_t v214 = _StringGuts.nativeUnusedCapacity.getter(v208, v10);
  if (v215) {
    goto LABEL_283;
  }
  uint64_t v216 = (v10 >> 61) & 1;
  if (v214 < v9) {
    LODWORD(v216) = 1;
  }
  if (v213 > 15 || !v216) {
    goto LABEL_197;
  }
LABEL_191:
  swift_bridgeObjectRelease_n(v3, 5);
  swift_bridgeObjectRetain(v10);
  unint64_t v217 = _StringGuts._convertedToSmall()(v208, v10);
  unint64_t v219 = v218;
  swift_bridgeObjectRelease(v10);
  v220._Swift::UInt64 rawBits = (v212 << 16) | 1;
  v221._Swift::UInt64 rawBits = 1;
  v222._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v221, v220, v4, v3);
  if (v222._rawBits < 0x10000) {
    v222._rawBits |= 3;
  }
  unint64_t v224 = specialized String.init(_:)(v222, v223, v4, v3);
  unint64_t v226 = v225;
  swift_bridgeObjectRelease(v3);
  unint64_t v227 = _StringGuts._convertedToSmall()(v224, v226);
  unint64_t v229 = v228;
  swift_bridgeObjectRelease(v226);
  unint64_t v230 = specialized _SmallString.init(_:appending:)(v217, v219, v227, v229);
  a2 = v321;
  a1 = v322;
  if (v232) {
    goto LABEL_282;
  }
  unint64_t v233 = v230;
  unint64_t v234 = v231;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(v3);
  uint64_t v324 = v233;
  unint64_t v325 = v234;
LABEL_195:
  uint64_t v4 = v320;
LABEL_221:
  Swift::Int v9 = v324;
  unint64_t v10 = v325;
  unint64_t v255 = HIBYTE(v325) & 0xF;
  if ((v325 & 0x2000000000000000) != 0) {
    unint64_t v256 = HIBYTE(v325) & 0xF;
  }
  else {
    unint64_t v256 = v324 & 0xFFFFFFFFFFFFLL;
  }
  if (!v256 && (v324 & ~v325 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v325);
    Swift::Int v9 = 40;
    uint64_t v324 = 40;
    unint64_t v264 = 0xE100000000000000;
    goto LABEL_256;
  }
  if ((v325 & 0x2000000000000000) != 0 && v255 != 15)
  {
    unint64_t v257 = 8 * (HIBYTE(v325) & 7);
    uint64_t v258 = (-255 << v257) - 1;
    uint64_t v259 = 40 << v257;
    uint64_t v260 = v259 | v258 & v325;
    Swift::Int v261 = v259 | v258 & v324;
    if (v255 >= 8) {
      unint64_t v262 = v260;
    }
    else {
      unint64_t v262 = v325;
    }
    if (v255 < 8) {
      Swift::Int v9 = v261;
    }
    swift_bridgeObjectRelease(v325);
    swift_bridgeObjectRelease(0xE100000000000000);
    unint64_t v263 = 0xA000000000000000;
    if (!(v9 & 0x8080808080808080 | v262 & 0x80808080808080)) {
      unint64_t v263 = 0xE000000000000000;
    }
    unint64_t v264 = (v263 & 0xFF00000000000000 | (v255 << 56) | v262 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
    uint64_t v324 = v9;
    unint64_t v325 = v264;
    goto LABEL_256;
  }
  swift_bridgeObjectRetain_n(0xE100000000000000, 6);
  if ((v10 & 0x1000000000000000) != 0) {
    goto LABEL_269;
  }
  BOOL v83 = __OFADD__(v256, 1);
  int64_t v265 = v256 + 1;
  if (v83) {
    goto LABEL_271;
  }
LABEL_238:
  if ((v9 & ~v10 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v266 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
    if ((v267 & 1) == 0)
    {
      BOOL v269 = (v10 & 0x2000000000000000) == 0 && v266 > 0;
      if (v265 <= 15 && !v269) {
        goto LABEL_249;
      }
LABEL_254:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v265, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 6);
      long long v323 = xmmword_18162AFF0;
      unint64_t v286 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v323, 1);
      _StringGuts.appendInPlace(_:isASCII:)(v286, v287, 1);
      swift_bridgeObjectRelease(0xE100000000000000);
      Swift::Int v9 = v324;
      unint64_t v264 = v325;
      goto LABEL_256;
    }
LABEL_283:
    unint64_t v312 = 258;
    goto LABEL_284;
  }
  if (v265 > 15) {
    goto LABEL_254;
  }
LABEL_249:
  swift_bridgeObjectRelease_n(0xE100000000000000, 5);
  swift_bridgeObjectRetain(v10);
  unint64_t v270 = _StringGuts._convertedToSmall()(v9, v10);
  unint64_t v272 = v271;
  swift_bridgeObjectRelease(v10);
  v273._Swift::UInt64 rawBits = 1;
  v274._Swift::UInt64 rawBits = 65537;
  v275._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v273, v274, 0x28uLL, 0xE100000000000000);
  if (v275._rawBits < 0x10000) {
    v275._rawBits |= 3;
  }
  unint64_t v277 = specialized String.init(_:)(v275, v276, 0x28uLL, 0xE100000000000000);
  unint64_t v279 = v278;
  swift_bridgeObjectRelease(0xE100000000000000);
  unint64_t v280 = _StringGuts._convertedToSmall()(v277, v279);
  unint64_t v282 = v281;
  swift_bridgeObjectRelease(v279);
  unint64_t v283 = specialized _SmallString.init(_:appending:)(v270, v272, v280, v282);
  if (v285) {
    goto LABEL_282;
  }
  Swift::Int v9 = v283;
  unint64_t v264 = v284;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(0xE100000000000000);
  uint64_t v324 = v9;
LABEL_256:
  uint64_t v288 = (*(uint64_t (**)(uint64_t))(*(void *)(a2 + 48) + 40))(a1);
  if (v288 < 0) {
    goto LABEL_260;
  }
  MEMORY[0x1F4188790](v288);
  uint64_t v316 = a1;
  unint64_t v317 = a2;
  uint64_t v318 = v4;
  char v290 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg5((void (*)(void *__return_ptr, uint64_t *))partial apply for closure #1 in SIMD.description.getter, (uint64_t)&v315, 0, v289);
  unint64_t v291 = specialized BidirectionalCollection<>.joined(separator:)(8236, 0xE200000000000000, v290);
  unint64_t v293 = v292;
  swift_bridgeObjectRelease((uint64_t)v290);
  swift_bridgeObjectRelease(0xE200000000000000);
  unint64_t v294 = specialized static String.+ infix(_:_:)(v9, v264, v291, v293);
  unint64_t v296 = v295;
  swift_bridgeObjectRelease(v264);
  swift_bridgeObjectRelease(v293);
  unint64_t v297 = specialized static String.+ infix(_:_:)(v294, v296, 0x29uLL, 0xE100000000000000);
  swift_bridgeObjectRelease(v296);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v297;
}

void closure #1 in SIMD.description.getter(uint64_t *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X8>)
{
  uint64_t v28 = a4;
  uint64_t v6 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = (Class *)swift_getAssociatedTypeWitness(0, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = (uint64_t)*(AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v27 - v9;
  uint64_t v11 = *a1;
  uint64_t v12 = specialized static String._createEmpty(withInitialCapacity:)(2);
  uint64_t v14 = v12;
  unint64_t v15 = v13;
  uint64_t v29 = v12;
  unint64_t v30 = v13;
  uint64_t v16 = HIBYTE(v13) & 0xF;
  uint64_t v17 = v12 & 0xFFFFFFFFFFFFLL;
  if ((v13 & 0x2000000000000000) != 0) {
    uint64_t v17 = HIBYTE(v13) & 0xF;
  }
  if (v17 || (v12 & ~v13 & 0x2000000000000000) != 0)
  {
    if ((v13 & 0x2000000000000000) == 0)
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      goto LABEL_12;
    }
    swift_bridgeObjectRelease(v13);
    unint64_t v18 = 0xA000000000000000;
    if (!(v15 & 0x80808080808080 | v14 & 0x8080808080808080)) {
      unint64_t v18 = 0xE000000000000000;
    }
    unint64_t v19 = v18 & 0xFF00000000000000 | (v16 << 56) | v15 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v29 = v14;
  }
  else
  {
    swift_bridgeObjectRelease(v13);
    unint64_t v19 = 0xE000000000000000;
    uint64_t v29 = 0;
  }
  unint64_t v30 = v19;
LABEL_12:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56))(v11, a2, v6);
  _print_unlocked<A, B>(_:_:)((uint64_t)v10, (uint64_t)&v29, AssociatedTypeWitness, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  (*(void (**)(char *, Class *))(v8 + 8))(v10, AssociatedTypeWitness);
  uint64_t v21 = v29;
  unint64_t v20 = v30;
  unint64_t v22 = HIBYTE(v30) & 0xF;
  unint64_t v23 = v29 & 0xFFFFFFFFFFFFLL;
  if ((v30 & 0x2000000000000000) != 0) {
    unint64_t v23 = HIBYTE(v30) & 0xF;
  }
  if (v23 || (v29 & ~v30 & 0x2000000000000000) != 0)
  {
    if ((v30 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v30);
      unint64_t v25 = 0xA000000000000000;
      if (!(v20 & 0x80808080808080 | v21 & 0x8080808080808080)) {
        unint64_t v25 = 0xE000000000000000;
      }
      unint64_t v24 = v25 & 0xFF00000000000000 | (v22 << 56) | v20 & 0xFFFFFFFFFFFFFFLL;
    }
    else
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      uint64_t v21 = v29;
      unint64_t v24 = v30;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v30);
    uint64_t v21 = 0;
    unint64_t v24 = 0xE000000000000000;
  }
  unint64_t v26 = v28;
  *uint64_t v28 = v21;
  v26[1] = v24;
}

uint64_t static SIMD..== infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = a3;
  uint64_t v59 = a1;
  uint64_t v60 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v9 = *(void *)(swift_getAssociatedConformanceWitness(a4, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  unint64_t v10 = swift_getAssociatedTypeWitness(255, (int **)v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  char v62 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, v6, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  uint64_t v51 = swift_getAssociatedTypeWitness(0, v62, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v51);
  char v50 = (char *)&v42 - v11;
  unint64_t v53 = swift_checkMetadataState(0, (uint64_t)v10);
  MEMORY[0x1F4188790](v53);
  uint64_t v49 = (char *)&v42 - v12;
  uint64_t v13 = *(void *)(a4 + 48);
  size_t v54 = swift_getAssociatedTypeWitness(0, (int **)v13, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v14 = *((void *)v54 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v54);
  unint64_t v58 = (char *)&v42 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  size_t v57 = (char *)&v42 - v17;
  unint64_t v18 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  (*(void (**)(uint64_t *, uint64_t))(v9 + 48))(v18, v9);
  unint64_t v19 = *(uint64_t (**)(uint64_t *, uint64_t))(v9 + 40);
  uint64_t v61 = a5;
  uint64_t v55 = v19;
  uint64_t v56 = v9 + 40;
  uint64_t result = v19(v18, v9);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    unint64_t v21 = 0;
    unint64_t v22 = *(void (**)(void, void, void))(v13 + 56);
    unint64_t v23 = (void (**)(char *, const char *))(v14 + 8);
    uint64_t v44 = v9 + 64;
    int64_t v45 = v62 + 3;
    uint64_t v47 = v13 + 56;
    uint64_t v48 = result;
    char v46 = v22;
    uint64_t v52 = v18;
    unint64_t v24 = v57;
    while (1)
    {
      unint64_t v25 = v22;
      v22(v21, v6, v13);
      uint64_t v26 = v9;
      uint64_t v27 = v58;
      v25(v21, v6, v13);
      uint64_t v28 = v54;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, v6, (uint64_t)v54, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v30 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v24, v27, v28);
      char v31 = *v23;
      unint64_t v32 = v27;
      uint64_t v9 = v26;
      (*v23)(v32, v28);
      unint64_t v33 = v52;
      v31(v24, v28);
      unint64_t v34 = v55(v33, v9);
      if ((v34 & 0x8000000000000000) != 0) {
        break;
      }
      if (v21 >= v34) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v43 = v6;
      unint64_t v35 = v51;
      uint64_t v36 = swift_getAssociatedConformanceWitness((uint64_t)v62, (uint64_t)v53, (uint64_t)v51, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v37 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v36 + 8);
      uint64_t v42 = v13;
      uint64_t v38 = v50;
      if (v30)
      {
        unint64_t v39 = (uint64_t *)&unk_18162B0C8;
        uint64_t v40 = 257;
      }
      else
      {
        unint64_t v39 = &qword_18162B0B8;
        uint64_t v40 = 256;
      }
      v37(v39, v40, v35, v36);
      unint64_t v41 = v49;
      ((void (*)(char *))v62[3])(v38);
      (*(void (**)(char *, unint64_t, uint64_t *, uint64_t))(v9 + 64))(v41, v21++, v33, v9);
      uint64_t result = v48;
      uint64_t v13 = v42;
      uint64_t v6 = v43;
      unint64_t v22 = v46;
      if (v48 == v21) {
        return result;
      }
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  const char *AssociatedTypeWitness;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t);
  uint64_t v34;
  uint64_t *v35;
  int **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  void (*v41)(void, void, void);
  char *v42;
  void (*v43)(unint64_t, uint64_t, uint64_t);
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t AssociatedConformanceWitness;
  int **v49;
  char v50;
  void (*v51)(char *, uint64_t);
  uint64_t *v52;
  unint64_t v53;
  const char *v54;
  uint64_t v55;
  char *v56;
  uint64_t *v57;
  uint64_t v58;
  char *v59;
  void v61[3];
  void (*v62)(void, void, void);
  uint64_t v63;
  uint64_t v64;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t *v68;
  uint64_t *v69;
  const char *v70;
  void (*v71)(char *, uint64_t);
  char *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  int **v76;
  int **v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  uint64_t v83;

  uint64_t v75 = a2;
  uint64_t v80 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v76 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v9 = swift_getAssociatedTypeWitness(255, v76, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v77 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  unsigned __int8 v67 = swift_getAssociatedTypeWitness(0, v77, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v67);
  uint64_t v66 = (char *)v61 - v10;
  unsigned int v69 = swift_checkMetadataState(0, (uint64_t)v9);
  MEMORY[0x1F4188790](v69);
  uint64_t v65 = (char *)v61 - v11;
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v73 = (char *)v61 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v19 = (char *)v61 - v18;
  unint64_t v20 = MEMORY[0x1F4188790](v17);
  unint64_t v22 = (char *)v61 - v21;
  uint64_t v74 = *(void *)(a3 - 8);
  unint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v25 = (int *)((char *)v61 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v23);
  uint64_t v78 = v26;
  uint64_t v79 = (char *)v61 - v27;
  uint64_t v81 = v14;
  uint64_t v28 = *(void (**)(char *, uint64_t))(v14 + 16);
  v28(v22, a1);
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unsigned int v70 = AssociatedTypeWitness;
  uint64_t v82 = v25;
  BOOL v83 = a3;
  char v30 = v78;
  if (v29)
  {
    char v31 = 0;
    do
    {
      unint64_t v32 = v29;
      ((void (*)(char *, char *, uint64_t))v28)(v19, v22, v30);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v19, v31, v83, v12);
      uint64_t v29 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  unint64_t v33 = *(void (**)(char *, uint64_t))(v81 + 8);
  v81 += 8;
  uint64_t v71 = v33;
  uint64_t v72 = v19;
  v33(v22, v30);
  unint64_t v34 = v83;
  (*(void (**)(char *, int *, uint64_t))(v74 + 32))(v79, v82, v83);
  unint64_t v35 = swift_checkMetadataState(0, (uint64_t)v70);
  uint64_t v36 = v76;
  ((void (*)(uint64_t *, int **))v76[6])(v35, v76);
  uint64_t v82 = v36[5];
  unsigned int v70 = (const char *)(v36 + 5);
  char v37 = ((uint64_t (*)(uint64_t *, int **))v82)(v35, v36);
  if (v37 < 0) {
    goto LABEL_16;
  }
  uint64_t v38 = v34;
  if (v37)
  {
    unint64_t v39 = v12;
    uint64_t v40 = 0;
    unint64_t v41 = *(void (**)(void, void, void))(v12 + 56);
    v61[2] = v77 + 3;
    v61[1] = v36 + 8;
    uint64_t v63 = v12 + 56;
    unint64_t v64 = v37;
    char v62 = v41;
    int v68 = v35;
    uint64_t v42 = v72;
    while (1)
    {
      uint64_t v43 = v41;
      v41(v40, v38, v39);
      uint64_t v44 = v73;
      v43(v40, v38, v39);
      int64_t v45 = v39;
      char v46 = v38;
      uint64_t v47 = v78;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v39, v38, v78, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v49 = v36;
      char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v42, v44, v47);
      uint64_t v51 = v71;
      v71(v44, v47);
      uint64_t v52 = v68;
      v51(v42, v47);
      unint64_t v53 = ((uint64_t (*)(uint64_t *, int **))v82)(v52, v49);
      if ((v53 & 0x8000000000000000) != 0) {
        break;
      }
      if (v40 >= v53) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      size_t v54 = v67;
      uint64_t v55 = swift_getAssociatedConformanceWitness((uint64_t)v77, (uint64_t)v69, (uint64_t)v67, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v50)
      {
        uint64_t v56 = v66;
        size_t v57 = (uint64_t *)&unk_18162B0C8;
        unint64_t v58 = 257;
      }
      else
      {
        uint64_t v56 = v66;
        size_t v57 = &qword_18162B0B8;
        unint64_t v58 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v55 + 8))(v57, v58, v54, v55);
      unint64_t v39 = v45;
      uint64_t v59 = v65;
      ((void (*)(char *))v77[3])(v56);
      uint64_t v36 = v76;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v76[8])(v59, v40++, v52, v76);
      uint64_t v38 = v46;
      unint64_t v41 = v62;
      if (v64 == v40) {
        return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
}

{
  const char *AssociatedTypeWitness;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t);
  uint64_t v34;
  uint64_t *v35;
  int **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  char *v42;
  char *v43;
  void (*v44)(unint64_t, uint64_t, uint64_t);
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t AssociatedConformanceWitness;
  int **v50;
  char v51;
  void (*v52)(char *, uint64_t);
  char *v53;
  uint64_t *v54;
  unint64_t v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  uint64_t *v59;
  uint64_t v60;
  char *v61;
  void v63[3];
  uint64_t v64;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t *v68;
  uint64_t *v69;
  const char *v70;
  void (*v71)(char *, uint64_t);
  char *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  int **v76;
  int **v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  uint64_t v83;

  uint64_t v75 = a1;
  uint64_t v80 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v76 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v9 = swift_getAssociatedTypeWitness(255, v76, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v77 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  unsigned __int8 v67 = swift_getAssociatedTypeWitness(0, v77, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v67);
  uint64_t v66 = (char *)v63 - v10;
  unsigned int v69 = swift_checkMetadataState(0, (uint64_t)v9);
  MEMORY[0x1F4188790](v69);
  uint64_t v65 = (char *)v63 - v11;
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v73 = (char *)v63 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v19 = (char *)v63 - v18;
  unint64_t v20 = MEMORY[0x1F4188790](v17);
  unint64_t v22 = (char *)v63 - v21;
  uint64_t v74 = *(void *)(a3 - 8);
  unint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v25 = (int *)((char *)v63 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v23);
  uint64_t v78 = v26;
  uint64_t v79 = (char *)v63 - v27;
  uint64_t v81 = v14;
  uint64_t v28 = *(void (**)(char *, uint64_t))(v14 + 16);
  v28(v22, a2);
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unsigned int v70 = AssociatedTypeWitness;
  uint64_t v82 = v25;
  BOOL v83 = a3;
  char v30 = v78;
  if (v29)
  {
    char v31 = 0;
    do
    {
      unint64_t v32 = v29;
      ((void (*)(char *, char *, uint64_t))v28)(v19, v22, v30);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v19, v31, v83, v12);
      uint64_t v29 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  unint64_t v33 = *(void (**)(char *, uint64_t))(v81 + 8);
  v81 += 8;
  uint64_t v71 = v33;
  uint64_t v72 = v19;
  v33(v22, v30);
  unint64_t v34 = v83;
  (*(void (**)(char *, int *, uint64_t))(v74 + 32))(v79, v82, v83);
  unint64_t v35 = swift_checkMetadataState(0, (uint64_t)v70);
  uint64_t v36 = v76;
  ((void (*)(uint64_t *, int **))v76[6])(v35, v76);
  uint64_t v82 = v36[5];
  unsigned int v70 = (const char *)(v36 + 5);
  char v37 = ((uint64_t (*)(uint64_t *, int **))v82)(v35, v36);
  if (v37 < 0) {
    goto LABEL_16;
  }
  uint64_t v38 = v34;
  if (v37)
  {
    unint64_t v39 = v12;
    uint64_t v40 = 0;
    unint64_t v41 = *(void (**)(unint64_t, uint64_t, uint64_t))(v12 + 56);
    v63[1] = v77 + 3;
    v63[0] = v36 + 8;
    void v63[2] = v12 + 56;
    unint64_t v64 = v37;
    int v68 = v35;
    while (1)
    {
      uint64_t v42 = v72;
      v41(v40, v38, v39);
      uint64_t v43 = v73;
      uint64_t v44 = v41;
      v41(v40, v38, v39);
      int64_t v45 = v39;
      char v46 = v39;
      uint64_t v47 = v38;
      uint64_t v48 = v78;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, v38, v78, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v50 = v36;
      uint64_t v51 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v42, v43, v48);
      uint64_t v52 = v71;
      v71(v43, v48);
      unint64_t v53 = v42;
      size_t v54 = v68;
      v52(v53, v48);
      uint64_t v55 = ((uint64_t (*)(uint64_t *, int **))v82)(v54, v50);
      if ((v55 & 0x8000000000000000) != 0) {
        break;
      }
      if (v40 >= v55) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v56 = v67;
      size_t v57 = swift_getAssociatedConformanceWitness((uint64_t)v77, (uint64_t)v69, (uint64_t)v67, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v51)
      {
        unint64_t v58 = v66;
        uint64_t v59 = (uint64_t *)&unk_18162B0C8;
        uint64_t v60 = 257;
      }
      else
      {
        unint64_t v58 = v66;
        uint64_t v59 = &qword_18162B0B8;
        uint64_t v60 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v57 + 8))(v59, v60, v56, v57);
      unint64_t v41 = v44;
      uint64_t v61 = v65;
      ((void (*)(char *))v77[3])(v58);
      uint64_t v36 = v76;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v76[8])(v61, v40++, v54, v76);
      uint64_t v38 = v47;
      unint64_t v39 = v45;
      if (v64 == v40) {
        return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
}

uint64_t SIMDMask.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 48) + 48))();
}

uint64_t SIMDMask.subscript.setter(int a1, uint64_t a2, void *a3)
{
  uint64_t v4 = v3;
  uint64_t v25 = a2;
  int v23 = a1;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a3[4] + 8) + 24) + 16);
  uint64_t v6 = a3[2];
  uint64_t v7 = *(void *)(a3[3] + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, (int **)v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v9);
  uint64_t v11 = &v22[-v10];
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  MEMORY[0x1F4188790](v12);
  uint64_t v14 = &v22[-v13];
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v24 = v4;
  uint64_t v16 = v15(v6, v7);
  if (v16 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v17 = v25;
  if (v25 < 0 || v16 <= v25) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, (uint64_t)v12, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v23)
  {
    unint64_t v19 = (uint64_t *)&unk_18162B0C8;
    uint64_t v20 = 257;
  }
  else
  {
    unint64_t v19 = &qword_18162B0B8;
    uint64_t v20 = 256;
  }
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v19, v20, v9, AssociatedConformanceWitness);
  (*(void (**)(unsigned char *, uint64_t *, uint64_t))(v5 + 24))(v11, v12, v5);
  return (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v14, v17, v6, v7);
}

uint64_t static SIMD..!= infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = a3;
  uint64_t v59 = a1;
  uint64_t v60 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v9 = *(void *)(swift_getAssociatedConformanceWitness(a4, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v10 = swift_getAssociatedTypeWitness(255, (int **)v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  char v62 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, v6, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  uint64_t v51 = swift_getAssociatedTypeWitness(0, v62, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v51);
  char v50 = (char *)&v42 - v11;
  unint64_t v53 = swift_checkMetadataState(0, (uint64_t)v10);
  MEMORY[0x1F4188790](v53);
  uint64_t v49 = (char *)&v42 - v12;
  uint64_t v13 = *(void *)(a4 + 48);
  size_t v54 = swift_getAssociatedTypeWitness(0, (int **)v13, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v14 = *((void *)v54 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v54);
  unint64_t v58 = (char *)&v42 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  size_t v57 = (char *)&v42 - v17;
  unint64_t v18 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  (*(void (**)(uint64_t *, uint64_t))(v9 + 48))(v18, v9);
  unint64_t v19 = *(uint64_t (**)(uint64_t *, uint64_t))(v9 + 40);
  uint64_t v61 = a5;
  uint64_t v55 = v19;
  uint64_t v56 = v9 + 40;
  uint64_t result = v19(v18, v9);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    unint64_t v21 = 0;
    unint64_t v22 = *(void (**)(void, void, void))(v13 + 56);
    int v23 = (void (**)(char *, const char *))(v14 + 8);
    uint64_t v44 = v9 + 64;
    int64_t v45 = v62 + 3;
    uint64_t v47 = v13 + 56;
    uint64_t v48 = result;
    char v46 = v22;
    uint64_t v52 = v18;
    uint64_t v24 = v57;
    while (1)
    {
      uint64_t v25 = v22;
      v22(v21, v6, v13);
      uint64_t v26 = v9;
      uint64_t v27 = v58;
      v25(v21, v6, v13);
      uint64_t v28 = v54;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, v6, (uint64_t)v54, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v30 = (*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v24, v27, v28);
      char v31 = *v23;
      unint64_t v32 = v27;
      uint64_t v9 = v26;
      (*v23)(v32, v28);
      unint64_t v33 = v52;
      v31(v24, v28);
      unint64_t v34 = v55(v33, v9);
      if ((v34 & 0x8000000000000000) != 0) {
        break;
      }
      if (v21 >= v34) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v43 = v6;
      unint64_t v35 = v51;
      uint64_t v36 = swift_getAssociatedConformanceWitness((uint64_t)v62, (uint64_t)v53, (uint64_t)v51, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v37 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v36 + 8);
      uint64_t v42 = v13;
      uint64_t v38 = v50;
      if (v30)
      {
        unint64_t v39 = &qword_18162B0B8;
        uint64_t v40 = 256;
      }
      else
      {
        unint64_t v39 = (uint64_t *)&unk_18162B0C8;
        uint64_t v40 = 257;
      }
      v37(v39, v40, v35, v36);
      unint64_t v41 = v49;
      ((void (*)(char *))v62[3])(v38);
      (*(void (**)(char *, unint64_t, uint64_t *, uint64_t))(v9 + 64))(v41, v21++, v33, v9);
      uint64_t result = v48;
      uint64_t v13 = v42;
      uint64_t v6 = v43;
      unint64_t v22 = v46;
      if (v48 == v21) {
        return result;
      }
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  const char *AssociatedTypeWitness;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t);
  uint64_t v34;
  uint64_t *v35;
  int **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  void (*v41)(void, void, void);
  char *v42;
  void (*v43)(unint64_t, uint64_t, uint64_t);
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t AssociatedConformanceWitness;
  int **v49;
  char v50;
  void (*v51)(char *, uint64_t);
  uint64_t *v52;
  unint64_t v53;
  const char *v54;
  uint64_t v55;
  char *v56;
  uint64_t *v57;
  uint64_t v58;
  char *v59;
  void v61[3];
  void (*v62)(void, void, void);
  uint64_t v63;
  uint64_t v64;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t *v68;
  uint64_t *v69;
  const char *v70;
  void (*v71)(char *, uint64_t);
  char *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  int **v76;
  int **v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  uint64_t v83;

  uint64_t v75 = a2;
  uint64_t v80 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v76 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v9 = swift_getAssociatedTypeWitness(255, v76, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v77 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  unsigned __int8 v67 = swift_getAssociatedTypeWitness(0, v77, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v67);
  uint64_t v66 = (char *)v61 - v10;
  unsigned int v69 = swift_checkMetadataState(0, (uint64_t)v9);
  MEMORY[0x1F4188790](v69);
  uint64_t v65 = (char *)v61 - v11;
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v73 = (char *)v61 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v19 = (char *)v61 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  unint64_t v22 = (char *)v61 - v21;
  uint64_t v74 = *(void *)(a3 - 8);
  int v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = (int *)((char *)v61 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v23);
  uint64_t v78 = v26;
  uint64_t v79 = (char *)v61 - v27;
  uint64_t v81 = v14;
  uint64_t v28 = *(void (**)(char *, uint64_t))(v14 + 16);
  v28(v22, a1);
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unsigned int v70 = AssociatedTypeWitness;
  uint64_t v82 = v25;
  BOOL v83 = a3;
  char v30 = v78;
  if (v29)
  {
    char v31 = 0;
    do
    {
      unint64_t v32 = v29;
      ((void (*)(char *, char *, uint64_t))v28)(v19, v22, v30);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v19, v31, v83, v12);
      uint64_t v29 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  unint64_t v33 = *(void (**)(char *, uint64_t))(v81 + 8);
  v81 += 8;
  uint64_t v71 = v33;
  uint64_t v72 = v19;
  v33(v22, v30);
  unint64_t v34 = v83;
  (*(void (**)(char *, int *, uint64_t))(v74 + 32))(v79, v82, v83);
  unint64_t v35 = swift_checkMetadataState(0, (uint64_t)v70);
  uint64_t v36 = v76;
  ((void (*)(uint64_t *, int **))v76[6])(v35, v76);
  uint64_t v82 = v36[5];
  unsigned int v70 = (const char *)(v36 + 5);
  char v37 = ((uint64_t (*)(uint64_t *, int **))v82)(v35, v36);
  if (v37 < 0) {
    goto LABEL_16;
  }
  uint64_t v38 = v34;
  if (v37)
  {
    unint64_t v39 = v12;
    uint64_t v40 = 0;
    unint64_t v41 = *(void (**)(void, void, void))(v12 + 56);
    v61[2] = v77 + 3;
    v61[1] = v36 + 8;
    uint64_t v63 = v12 + 56;
    unint64_t v64 = v37;
    char v62 = v41;
    int v68 = v35;
    uint64_t v42 = v72;
    while (1)
    {
      uint64_t v43 = v41;
      v41(v40, v38, v39);
      uint64_t v44 = v73;
      v43(v40, v38, v39);
      int64_t v45 = v39;
      char v46 = v38;
      uint64_t v47 = v78;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v39, v38, v78, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v49 = v36;
      char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v42, v44, v47);
      uint64_t v51 = v71;
      v71(v44, v47);
      uint64_t v52 = v68;
      v51(v42, v47);
      unint64_t v53 = ((uint64_t (*)(uint64_t *, int **))v82)(v52, v49);
      if ((v53 & 0x8000000000000000) != 0) {
        break;
      }
      if (v40 >= v53) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      size_t v54 = v67;
      uint64_t v55 = swift_getAssociatedConformanceWitness((uint64_t)v77, (uint64_t)v69, (uint64_t)v67, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v50)
      {
        uint64_t v56 = v66;
        size_t v57 = &qword_18162B0B8;
        unint64_t v58 = 256;
      }
      else
      {
        uint64_t v56 = v66;
        size_t v57 = (uint64_t *)&unk_18162B0C8;
        unint64_t v58 = 257;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v55 + 8))(v57, v58, v54, v55);
      unint64_t v39 = v45;
      uint64_t v59 = v65;
      ((void (*)(char *))v77[3])(v56);
      uint64_t v36 = v76;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v76[8])(v59, v40++, v52, v76);
      uint64_t v38 = v46;
      unint64_t v41 = v62;
      if (v64 == v40) {
        return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
}

{
  const char *AssociatedTypeWitness;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t);
  uint64_t v34;
  uint64_t *v35;
  int **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  char *v42;
  char *v43;
  void (*v44)(unint64_t, uint64_t, uint64_t);
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t AssociatedConformanceWitness;
  int **v50;
  char v51;
  void (*v52)(char *, uint64_t);
  char *v53;
  uint64_t *v54;
  unint64_t v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  uint64_t *v59;
  uint64_t v60;
  char *v61;
  void v63[3];
  uint64_t v64;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t *v68;
  uint64_t *v69;
  const char *v70;
  void (*v71)(char *, uint64_t);
  char *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  int **v76;
  int **v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  uint64_t v83;

  uint64_t v75 = a1;
  uint64_t v80 = a5;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v76 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v9 = swift_getAssociatedTypeWitness(255, v76, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v77 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  unsigned __int8 v67 = swift_getAssociatedTypeWitness(0, v77, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v67);
  uint64_t v66 = (char *)v63 - v10;
  unsigned int v69 = swift_checkMetadataState(0, (uint64_t)v9);
  MEMORY[0x1F4188790](v69);
  uint64_t v65 = (char *)v63 - v11;
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v73 = (char *)v63 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v19 = (char *)v63 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  unint64_t v22 = (char *)v63 - v21;
  uint64_t v74 = *(void *)(a3 - 8);
  int v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = (int *)((char *)v63 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v23);
  uint64_t v78 = v26;
  uint64_t v79 = (char *)v63 - v27;
  uint64_t v81 = v14;
  uint64_t v28 = *(void (**)(char *, uint64_t))(v14 + 16);
  v28(v22, a2);
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unsigned int v70 = AssociatedTypeWitness;
  uint64_t v82 = v25;
  BOOL v83 = a3;
  char v30 = v78;
  if (v29)
  {
    char v31 = 0;
    do
    {
      unint64_t v32 = v29;
      ((void (*)(char *, char *, uint64_t))v28)(v19, v22, v30);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v19, v31, v83, v12);
      uint64_t v29 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  unint64_t v33 = *(void (**)(char *, uint64_t))(v81 + 8);
  v81 += 8;
  uint64_t v71 = v33;
  uint64_t v72 = v19;
  v33(v22, v30);
  unint64_t v34 = v83;
  (*(void (**)(char *, int *, uint64_t))(v74 + 32))(v79, v82, v83);
  unint64_t v35 = swift_checkMetadataState(0, (uint64_t)v70);
  uint64_t v36 = v76;
  ((void (*)(uint64_t *, int **))v76[6])(v35, v76);
  uint64_t v82 = v36[5];
  unsigned int v70 = (const char *)(v36 + 5);
  char v37 = ((uint64_t (*)(uint64_t *, int **))v82)(v35, v36);
  if (v37 < 0) {
    goto LABEL_16;
  }
  uint64_t v38 = v34;
  if (v37)
  {
    unint64_t v39 = v12;
    uint64_t v40 = 0;
    unint64_t v41 = *(void (**)(unint64_t, uint64_t, uint64_t))(v12 + 56);
    v63[1] = v77 + 3;
    v63[0] = v36 + 8;
    void v63[2] = v12 + 56;
    unint64_t v64 = v37;
    int v68 = v35;
    while (1)
    {
      uint64_t v42 = v72;
      v41(v40, v38, v39);
      uint64_t v43 = v73;
      uint64_t v44 = v41;
      v41(v40, v38, v39);
      int64_t v45 = v39;
      char v46 = v39;
      uint64_t v47 = v38;
      uint64_t v48 = v78;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, v38, v78, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v50 = v36;
      uint64_t v51 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v42, v43, v48);
      uint64_t v52 = v71;
      v71(v43, v48);
      unint64_t v53 = v42;
      size_t v54 = v68;
      v52(v53, v48);
      uint64_t v55 = ((uint64_t (*)(uint64_t *, int **))v82)(v54, v50);
      if ((v55 & 0x8000000000000000) != 0) {
        break;
      }
      if (v40 >= v55) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v56 = v67;
      size_t v57 = swift_getAssociatedConformanceWitness((uint64_t)v77, (uint64_t)v69, (uint64_t)v67, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v51)
      {
        unint64_t v58 = v66;
        uint64_t v59 = &qword_18162B0B8;
        uint64_t v60 = 256;
      }
      else
      {
        unint64_t v58 = v66;
        uint64_t v59 = (uint64_t *)&unk_18162B0C8;
        uint64_t v60 = 257;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v57 + 8))(v59, v60, v56, v57);
      unint64_t v41 = v44;
      uint64_t v61 = v65;
      ((void (*)(char *))v77[3])(v58);
      uint64_t v36 = v76;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v76[8])(v61, v40++, v54, v76);
      uint64_t v38 = v47;
      unint64_t v39 = v45;
      if (v64 == v40) {
        return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v79, v38);
}

uint64_t SIMD.replace(with:where:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v88 = a2;
  uint64_t v80 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  BOOL v89 = *(int ***)(AssociatedConformanceWitness + 48);
  uint64_t v8 = swift_getAssociatedTypeWitness(255, v89, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  uint64_t v10 = *(void *)(v9 + 8);
  BOOL v83 = *(int ***)(*(void *)(v10 + 24) + 16);
  unsigned __int8 v67 = swift_getAssociatedTypeWitness(0, v83, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v67);
  uint64_t v66 = (char *)&v60 - v11;
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)v8);
  uint64_t v13 = *(v12 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v65 = (char *)&v60 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v79 = (char *)&v60 - v17;
  MEMORY[0x1F4188790](v16);
  size_t v84 = (char *)&v60 - v18;
  uint64_t v19 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  uint64_t v87 = AssociatedTypeWitness;
  v90[0] = AssociatedTypeWitness;
  v90[1] = AssociatedConformanceWitness;
  v90[2] = v9;
  v90[3] = v19;
  uint64_t v20 = type metadata accessor for SIMDMask(0, (uint64_t)v90);
  uint64_t v21 = (uint64_t)*(v20 - 1);
  MEMORY[0x1F4188790](v20);
  uint64_t v86 = (char *)&v60 - v22;
  uint64_t v23 = *(void *)(a4 + 48);
  uint64_t v24 = swift_getAssociatedTypeWitness(0, (int **)v23, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1F4188790](v24 - 8);
  uint64_t v81 = a3;
  uint64_t v82 = (char *)&v60 - v25;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 40))(a3, v23);
  if (result < 0) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (result)
  {
    unint64_t v27 = 0;
    uint64_t v28 = *(void (**)(void, void, void))(v21 + 16);
    uint64_t v29 = v89 + 5;
    uint64_t v85 = v21 + 16;
    uint64_t v75 = v89 + 7;
    uint64_t v76 = (void (**)(char *, Class *))(v21 + 8);
    uint64_t v74 = v10 + 64;
    uint64_t v73 = v10 + 128;
    unsigned int v70 = (void (**)(char *, uint64_t *))(v13 + 8);
    uint64_t v64 = v10 + 120;
    char v62 = v83 + 3;
    uint64_t v61 = (void (**)(char *, char *, uint64_t *))(v13 + 32);
    uint64_t v63 = v10 + 96;
    uint64_t v72 = v23 + 56;
    uint64_t v71 = v23 + 64;
    uint64_t v77 = v28;
    uint64_t v78 = result;
    while (1)
    {
      char v30 = v86;
      v28(v86, v88, v20);
      char v31 = v87;
      unint64_t v32 = ((uint64_t (*)(const char *))v89[5])(v87);
      if ((v32 & 0x8000000000000000) != 0) {
        goto LABEL_24;
      }
      if (v27 >= v32) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
      }
      unint64_t v33 = *v76;
      int v68 = v20;
      v33(v30, v20);
      unint64_t v34 = v84;
      ((void (*)(unint64_t, const char *))v89[7])(v27, v31);
      unint64_t v35 = *(uint64_t (**)(uint64_t *, uint64_t))(v10 + 64);
      char v36 = v35(v12, v10);
      unsigned int v69 = v29;
      if (v36) {
        break;
      }
      char v43 = v35(v12, v10);
      uint64_t v44 = (*(uint64_t (**)(uint64_t *, uint64_t))(v10 + 128))(v12, v10);
      if (v43)
      {
        if (v44 <= 64)
        {
          char v50 = v83;
          uint64_t v51 = v67;
          uint64_t v52 = swift_getAssociatedConformanceWitness((uint64_t)v83, (uint64_t)v12, (uint64_t)v67, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v53 = v66;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v52 + 8))(&qword_18162B0B8, 256, v51, v52);
          size_t v54 = v79;
          ((void (*)(char *, uint64_t *, int **))v50[3])(v53, v12, v50);
          uint64_t v55 = v84;
          LOBYTE(v51) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v10 + 32) + 8)
                                                                             + 16))(v84, v54, v12);
          uint64_t v56 = *v70;
          (*v70)(v54, v12);
          size_t v57 = v65;
          (*v61)(v65, v55, v12);
          if (v51)
          {
            v56(v57, v12);
            uint64_t v20 = v68;
            goto LABEL_19;
          }
          (*(void (**)(uint64_t *, uint64_t))(v10 + 120))(v12, v10);
          v56(v57, v12);
          goto LABEL_16;
        }
        v90[0] = 0;
        uint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v10 + 96);
        unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v44, v45, v46);
        uint64_t v42 = v79;
        v47(v90, &type metadata for Int, v48, v12, v10);
        unint64_t v34 = v84;
        (*(void (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v10 + 32) + 8) + 16))(v84, v42, v12);
        goto LABEL_12;
      }
      if (v44 < 64)
      {
LABEL_15:
        (*(void (**)(uint64_t *, uint64_t))(v10 + 120))(v12, v10);
        (*v70)(v34, v12);
LABEL_16:
        uint64_t v20 = v68;
        goto LABEL_19;
      }
      (*v70)(v34, v12);
      uint64_t v20 = v68;
LABEL_19:
      uint64_t v58 = v81;
      uint64_t v59 = v82;
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v23 + 56))(v27, v81, v23);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v23 + 64))(v59, v27++, v58, v23);
      uint64_t v28 = v77;
      uint64_t result = v78;
      uint64_t v29 = v69;
      if (v78 == v27) {
        return result;
      }
    }
    uint64_t v37 = (*(uint64_t (**)(uint64_t *, uint64_t))(v10 + 128))(v12, v10);
    if (v37 < 64) {
      goto LABEL_15;
    }
    v90[0] = 0;
    uint64_t v40 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v10 + 96);
    unint64_t v41 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
    uint64_t v42 = v79;
    v40(v90, &type metadata for Int, v41, v12, v10);
    (*(void (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v10 + 32) + 8) + 16))(v34, v42, v12);
LABEL_12:
    uint64_t v49 = *v70;
    (*v70)(v42, v12);
    v49(v34, v12);
    uint64_t v20 = v68;
    goto LABEL_19;
  }
  return result;
}

unint64_t SIMDMask.subscript.getter(uint64_t a1, void *a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2[4] + 8);
  uint64_t v7 = *(int ***)(*(void *)(v6 + 24) + 16);
  uint64_t v8 = a2[2];
  uint64_t v9 = *(void *)(a2[3] + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  unint64_t v48 = v7;
  uint64_t v46 = swift_getAssociatedTypeWitness(0, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v46);
  uint64_t v45 = (char *)&v44 - v11;
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v50 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v47 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v49 = (char *)&v44 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v44 - v18;
  uint64_t v20 = *(a2 - 1);
  MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, void *))(v20 + 16))(v22, v3, a2);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v8, v9);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a1 < 0 || v23 <= a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  }
  (*(void (**)(char *, void *))(v20 + 8))(v22, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56))(a1, v8, v9);
  uint64_t v24 = *(uint64_t (**)(uint64_t *, uint64_t))(v6 + 64);
  if (v24(v12, v6))
  {
    uint64_t v25 = (*(uint64_t (**)(uint64_t *, uint64_t))(v6 + 128))(v12, v6);
    if (v25 < 64)
    {
LABEL_6:
      unint64_t v28 = (*(uint64_t (**)(uint64_t *, uint64_t))(v6 + 120))(v12, v6);
      (*(void (**)(char *, uint64_t *))(v50 + 8))(v19, v12);
      unint64_t v29 = v28 >> 63;
      return v29 & 1;
    }
    goto LABEL_10;
  }
  char v30 = v24(v12, v6);
  uint64_t v25 = (*(uint64_t (**)(uint64_t *, uint64_t))(v6 + 128))(v12, v6);
  if ((v30 & 1) == 0)
  {
    if (v25 >= 64)
    {
      (*(void (**)(char *, uint64_t *))(v50 + 8))(v19, v12);
      LOBYTE(v29) = 0;
      return v29 & 1;
    }
    goto LABEL_6;
  }
  if (v25 > 64)
  {
LABEL_10:
    uint64_t v51 = 0;
    char v31 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v6 + 96);
    unint64_t v32 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
    unint64_t v33 = v49;
    v31(&v51, &type metadata for Int, v32, v12, v6);
    LOBYTE(v29) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v6 + 32) + 8) + 16))(v19, v33, v12);
    unint64_t v34 = *(void (**)(char *, uint64_t *))(v50 + 8);
    v34(v33, v12);
    v34(v19, v12);
    return v29 & 1;
  }
  uint64_t v35 = (uint64_t)v48;
  char v36 = v46;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v48, (uint64_t)v12, (uint64_t)v46, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v38 = v45;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v36, AssociatedConformanceWitness);
  uint64_t v39 = v49;
  (*(void (**)(char *, uint64_t *, uint64_t))(v35 + 24))(v38, v12, v35);
  LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v6 + 32) + 8) + 16))(v19, v39, v12);
  uint64_t v40 = v50;
  unint64_t v41 = *(void (**)(char *, uint64_t *))(v50 + 8);
  v41(v39, v12);
  uint64_t v42 = v47;
  (*(void (**)(char *, char *, uint64_t *))(v40 + 32))(v47, v19, v12);
  if (v36) {
    LOBYTE(v29) = 1;
  }
  else {
    unint64_t v29 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v6 + 120))(v12, v6) >> 63;
  }
  v41(v42, v12);
  return v29 & 1;
}

uint64_t SIMD.init(arrayLiteral:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v14 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a3 + 48), a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v10, v11);
  return SIMD.init<A>(_:)((uint64_t)&v14, a2, (uint64_t)v10, a3, WitnessTable, a4);
}

uint64_t SIMD.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v41 = a1;
  uint64_t v10 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v10, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v45 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v42 = (char *)&v37 - v12;
  uint64_t v46 = v13;
  uint64_t v16 = type metadata accessor for Optional(0, v13, v14, v15);
  uint64_t v17 = MEMORY[0x1F4188790](v16 - 1);
  uint64_t v19 = (char *)&v37 - v18;
  uint64_t v20 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v37 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = swift_getAssociatedTypeWitness(0, (int **)a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v40 = *((void *)v23 - 1);
  MEMORY[0x1F4188790](v23);
  uint64_t v25 = (char *)&v37 - v24;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t))(v10 + 48);
  uint64_t v47 = a6;
  uint64_t v48 = a2;
  v26(a2, v10);
  uint64_t v38 = v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v22, v41, a3);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(a5 + 32);
  uint64_t v49 = v25;
  v27(a3, a5);
  uint64_t v39 = a3;
  uint64_t v50 = v23;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, (uint64_t)v23, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v29 = 0;
  char v43 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v44 = AssociatedConformanceWitness;
  char v30 = (unsigned int (**)(char *, uint64_t, uint64_t))(v45 + 48);
  char v31 = (void (**)(char *, char *, uint64_t))(v45 + 32);
  uint64_t v45 = v10 + 40;
  unint64_t v32 = v42;
  uint64_t v33 = v48;
  while (1)
  {
    v43(v50, v44);
    uint64_t v34 = v46;
    if ((*v30)(v19, 1, v46) == 1) {
      break;
    }
    (*v31)(v32, v19, v34);
    if (v29 == (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 40))(v33, v10)) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Too many elements in sequence.", 30, 2, "Swift/SIMDVector.swift", 22, 2, 0xF9uLL, 0);
    }
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 64))(v32, v29, v33, v10);
    if (__OFADD__(v29++, 1))
    {
      __break(1u);
      break;
    }
  }
  (*(void (**)(char *, const char *))(v40 + 8))(v49, v50);
  if (v29 < (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 40))(v48, v10)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough elements in sequence.", 32, 2, "Swift/SIMDVector.swift", 22, 2, 0xFFuLL, 0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v38 + 8))(v41, v39);
}

uint64_t SIMD2.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
}

uint64_t SIMD2.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD2.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x2CuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD3.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t SIMD3.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD3.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x58BuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD4.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t SIMD4.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD4.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC9uLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD8.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD8Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
}

uint64_t SIMD8.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD8.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1BBuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD16.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD16Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
}

uint64_t SIMD16.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD16.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x283uLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD32.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD32Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
}

uint64_t SIMD32.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD32.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x35BuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD64.init()(uint64_t a1, int **a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD64Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
}

uint64_t SIMD2.init()(uint64_t a1, int **a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a2, a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a2, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  return (*(uint64_t (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD64.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD64.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x453uLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t static SIMD<>..<= infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v67 = a5;
  uint64_t v61 = a1;
  uint64_t v62 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, (int **)v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v65 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  uint64_t v52 = swift_getAssociatedTypeWitness(0, v65, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v52);
  uint64_t v51 = (char *)v47 - v12;
  uint64_t v55 = swift_checkMetadataState(0, (uint64_t)v11);
  MEMORY[0x1F4188790](v55);
  uint64_t v50 = (char *)v47 - v13;
  uint64_t v14 = *(int ***)(a4 + 48);
  uint64_t v15 = v10;
  uint64_t v66 = v14;
  uint64_t v63 = a3;
  uint64_t v56 = swift_getAssociatedTypeWitness(0, v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v16 = *((void *)v56 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v56);
  uint64_t v60 = (char *)v47 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v58 = (char *)v47 - v19;
  uint64_t v20 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  (*(void (**)(uint64_t *, uint64_t))(v10 + 48))(v20, v10);
  uint64_t v21 = *(uint64_t (**)(uint64_t *, uint64_t))(v10 + 40);
  uint64_t v64 = a6;
  uint64_t v59 = v21;
  uint64_t v57 = v10 + 40;
  uint64_t result = v21(v20, v10);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    unint64_t v23 = 0;
    uint64_t v24 = v66[7];
    uint64_t v25 = v67 + 24;
    uint64_t v26 = (void (**)(char *, const char *))(v16 + 8);
    v47[1] = v65 + 3;
    v47[0] = v15 + 64;
    uint64_t v48 = v24;
    uint64_t v49 = result;
    v47[2] = v66 + 7;
    uint64_t v53 = v15;
    size_t v54 = v20;
    while (1)
    {
      uint64_t v27 = v58;
      uint64_t v28 = v63;
      uint64_t v29 = v66;
      char v30 = v26;
      uint64_t v31 = v25;
      unint64_t v32 = v24;
      ((void (*)(unint64_t, uint64_t, int **))v24)(v23, v63, v66);
      uint64_t v33 = v60;
      ((void (*)(unint64_t, uint64_t, int **))v32)(v23, v28, v29);
      uint64_t v25 = v31;
      uint64_t v26 = v30;
      uint64_t v34 = v56;
      char v35 = (*(uint64_t (**)(char *, char *, const char *))(v67 + 24))(v27, v33, v56);
      char v36 = *v30;
      (*v30)(v33, v34);
      uint64_t v37 = v27;
      uint64_t v38 = v53;
      uint64_t v39 = v54;
      v36(v37, v34);
      unint64_t v40 = v59(v39, v38);
      if ((v40 & 0x8000000000000000) != 0) {
        break;
      }
      if (v23 >= v40) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v41 = v52;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v65, (uint64_t)v55, (uint64_t)v52, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v43 = v51;
      if (v35)
      {
        uint64_t v44 = (uint64_t *)&unk_18162B0C8;
        uint64_t v45 = 257;
      }
      else
      {
        uint64_t v44 = &qword_18162B0B8;
        uint64_t v45 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v44, v45, v41, AssociatedConformanceWitness);
      uint64_t v46 = v50;
      ((void (*)(char *))v65[3])(v43);
      (*(void (**)(char *, unint64_t, uint64_t *, uint64_t))(v38 + 64))(v46, v23++, v39, v38);
      uint64_t v24 = v48;
      uint64_t result = v49;
      if (v49 == v23) {
        return result;
      }
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  const char *AssociatedTypeWitness;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(char *, uint64_t);
  uint64_t v37;
  uint64_t *v38;
  int **v39;
  uint64_t *v40;
  int **v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  void (*v46)(void, void, void);
  char *v47;
  uint64_t v48;
  void (*v49)(unint64_t, uint64_t, uint64_t);
  char *v50;
  uint64_t v51;
  uint64_t v52;
  int **v53;
  char v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t *v57;
  unint64_t v58;
  const char *v59;
  uint64_t AssociatedConformanceWitness;
  char *v61;
  uint64_t *v62;
  uint64_t v63;
  char *v64;
  void v66[2];
  void (*v67)(void, void, void);
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  const char *v76;
  void (*v77)(char *, uint64_t);
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int **v84;
  int **v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;

  uint64_t v80 = a2;
  uint64_t v88 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  size_t v84 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, v84, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v85 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  uint64_t v72 = swift_getAssociatedTypeWitness(0, v85, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v72);
  uint64_t v71 = (char *)v66 - v12;
  uint64_t v75 = swift_checkMetadataState(0, (uint64_t)v11);
  MEMORY[0x1F4188790](v75);
  unsigned int v70 = (char *)v66 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v16 = *((void *)v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v79 = (char *)v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)v66 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)v66 - v23;
  uint64_t v81 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (int *)((char *)v66 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v25);
  uint64_t v87 = (char *)v66 - v28;
  BOOL v89 = v16;
  uint64_t v82 = *(void *)(v16 + 16);
  BOOL v83 = v29;
  ((void (*)(char *, uint64_t))v82)(v24, a1);
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  char v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (v30 < 0) {
    goto LABEL_16;
  }
  uint64_t v76 = AssociatedTypeWitness;
  uint64_t v86 = a5;
  size_t v90 = v27;
  uint64_t v91 = a3;
  unint64_t v32 = (void (*)(char *, char *, uint64_t))v82;
  uint64_t v31 = v83;
  if (v30)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v30;
      char v35 = v31;
      v32(v21, v24, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 64))(v21, v33, v91, v14);
      char v30 = v34;
      uint64_t v31 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v82 = v14;
  char v36 = *(void (**)(char *, uint64_t))(v89 + 8);
  v89 += 8;
  uint64_t v77 = v36;
  uint64_t v78 = v21;
  uint64_t v37 = v31;
  v36(v24, v31);
  (*(void (**)(char *, int *, uint64_t))(v81 + 32))(v87, v90, v91);
  uint64_t v38 = swift_checkMetadataState(0, (uint64_t)v76);
  uint64_t v39 = v84;
  ((void (*)(uint64_t *, int **))v84[6])(v38, v84);
  unint64_t v40 = v38;
  uint64_t v41 = v39;
  size_t v90 = v39[5];
  uint64_t v76 = (const char *)(v39 + 5);
  uint64_t v42 = ((uint64_t (*)(uint64_t *, int **))v90)(v38, v39);
  if (v42 < 0) {
    goto LABEL_16;
  }
  char v43 = v37;
  uint64_t v44 = v82;
  if (v42)
  {
    uint64_t v45 = 0;
    uint64_t v46 = *(void (**)(void, void, void))(v82 + 56);
    v66[1] = v85 + 3;
    v66[0] = v41 + 8;
    unsigned int v69 = v42;
    int v68 = v82 + 56;
    uint64_t v74 = v40;
    uint64_t v67 = v46;
    uint64_t v73 = v86 + 24;
    uint64_t v47 = v78;
    while (1)
    {
      uint64_t v48 = v91;
      uint64_t v49 = v46;
      v46(v45, v91, v44);
      uint64_t v50 = v79;
      uint64_t v51 = v48;
      uint64_t v52 = v86;
      v49(v45, v51, v44);
      uint64_t v53 = v41;
      size_t v54 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v52 + 24))(v47, v50, v43, v52);
      uint64_t v55 = v50;
      uint64_t v56 = v77;
      v77(v55, v43);
      v56(v47, v43);
      uint64_t v57 = v74;
      uint64_t v58 = ((uint64_t (*)(uint64_t *, int **))v90)(v74, v53);
      if ((v58 & 0x8000000000000000) != 0) {
        break;
      }
      if (v45 >= v58) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v59 = v72;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, (uint64_t)v75, (uint64_t)v72, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v54)
      {
        uint64_t v61 = v71;
        uint64_t v62 = (uint64_t *)&unk_18162B0C8;
        uint64_t v63 = 257;
      }
      else
      {
        uint64_t v61 = v71;
        uint64_t v62 = &qword_18162B0B8;
        uint64_t v63 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v62, v63, v59, AssociatedConformanceWitness);
      uint64_t v64 = v70;
      ((void (*)(char *))v85[3])(v61);
      uint64_t v41 = v84;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v84[8])(v64, v45++, v57, v84);
      uint64_t v44 = v82;
      char v43 = v83;
      uint64_t v46 = v67;
      if (v69 == v45) {
        return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
}

{
  const char *AssociatedTypeWitness;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(char *, uint64_t);
  uint64_t v37;
  uint64_t *v38;
  int **v39;
  uint64_t *v40;
  int **v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  void (*v46)(void, void, void);
  char *v47;
  uint64_t v48;
  void (*v49)(unint64_t, uint64_t, uint64_t);
  char *v50;
  uint64_t v51;
  uint64_t v52;
  int **v53;
  char v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t *v57;
  unint64_t v58;
  const char *v59;
  uint64_t AssociatedConformanceWitness;
  char *v61;
  uint64_t *v62;
  uint64_t v63;
  char *v64;
  void v66[2];
  void (*v67)(void, void, void);
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  const char *v76;
  void (*v77)(char *, uint64_t);
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int **v84;
  int **v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;

  uint64_t v80 = a1;
  uint64_t v88 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  size_t v84 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, v84, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v85 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  uint64_t v72 = swift_getAssociatedTypeWitness(0, v85, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v72);
  uint64_t v71 = (char *)v66 - v12;
  uint64_t v75 = swift_checkMetadataState(0, (uint64_t)v11);
  MEMORY[0x1F4188790](v75);
  unsigned int v70 = (char *)v66 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v16 = *((void *)v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v79 = (char *)v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)v66 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)v66 - v23;
  uint64_t v81 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (int *)((char *)v66 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v25);
  uint64_t v87 = (char *)v66 - v28;
  BOOL v89 = v16;
  uint64_t v82 = *(void *)(v16 + 16);
  BOOL v83 = v29;
  ((void (*)(char *, uint64_t))v82)(v24, a2);
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  char v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (v30 < 0) {
    goto LABEL_16;
  }
  uint64_t v76 = AssociatedTypeWitness;
  uint64_t v86 = a5;
  size_t v90 = v27;
  uint64_t v91 = a3;
  unint64_t v32 = (void (*)(char *, char *, uint64_t))v82;
  uint64_t v31 = v83;
  if (v30)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v30;
      char v35 = v31;
      v32(v21, v24, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 64))(v21, v33, v91, v14);
      char v30 = v34;
      uint64_t v31 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v82 = v14;
  char v36 = *(void (**)(char *, uint64_t))(v89 + 8);
  v89 += 8;
  uint64_t v77 = v36;
  uint64_t v78 = v21;
  uint64_t v37 = v31;
  v36(v24, v31);
  (*(void (**)(char *, int *, uint64_t))(v81 + 32))(v87, v90, v91);
  uint64_t v38 = swift_checkMetadataState(0, (uint64_t)v76);
  uint64_t v39 = v84;
  ((void (*)(uint64_t *, int **))v84[6])(v38, v84);
  unint64_t v40 = v38;
  uint64_t v41 = v39;
  size_t v90 = v39[5];
  uint64_t v76 = (const char *)(v39 + 5);
  uint64_t v42 = ((uint64_t (*)(uint64_t *, int **))v90)(v38, v39);
  if (v42 < 0) {
    goto LABEL_16;
  }
  char v43 = v37;
  uint64_t v44 = v82;
  if (v42)
  {
    uint64_t v45 = 0;
    uint64_t v46 = *(void (**)(void, void, void))(v82 + 56);
    v66[1] = v85 + 3;
    v66[0] = v41 + 8;
    unsigned int v69 = v42;
    int v68 = v82 + 56;
    uint64_t v74 = v40;
    uint64_t v67 = v46;
    uint64_t v73 = v86 + 24;
    uint64_t v47 = v78;
    while (1)
    {
      uint64_t v48 = v91;
      uint64_t v49 = v46;
      v46(v45, v91, v44);
      uint64_t v50 = v79;
      uint64_t v51 = v48;
      uint64_t v52 = v86;
      v49(v45, v51, v44);
      uint64_t v53 = v41;
      size_t v54 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v52 + 24))(v47, v50, v43, v52);
      uint64_t v55 = v50;
      uint64_t v56 = v77;
      v77(v55, v43);
      v56(v47, v43);
      uint64_t v57 = v74;
      uint64_t v58 = ((uint64_t (*)(uint64_t *, int **))v90)(v74, v53);
      if ((v58 & 0x8000000000000000) != 0) {
        break;
      }
      if (v45 >= v58) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v59 = v72;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, (uint64_t)v75, (uint64_t)v72, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v54)
      {
        uint64_t v61 = v71;
        uint64_t v62 = (uint64_t *)&unk_18162B0C8;
        uint64_t v63 = 257;
      }
      else
      {
        uint64_t v61 = v71;
        uint64_t v62 = &qword_18162B0B8;
        uint64_t v63 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v62, v63, v59, AssociatedConformanceWitness);
      uint64_t v64 = v70;
      ((void (*)(char *))v85[3])(v61);
      uint64_t v41 = v84;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v84[8])(v64, v45++, v57, v84);
      uint64_t v44 = v82;
      char v43 = v83;
      uint64_t v46 = v67;
      if (v69 == v45) {
        return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
}

uint64_t SIMD.replace(with:where:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v121 = a2;
  uint64x2_t v122 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  int8x16_t v116 = *(int ***)(AssociatedConformanceWitness + 48);
  uint64_t v8 = swift_getAssociatedTypeWitness(255, v116, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  uint64_t v112 = *(void *)(v9 + 8);
  int8x16_t v105 = *(int ***)(*(void *)(v112 + 24) + 16);
  uint64_t v97 = swift_getAssociatedTypeWitness(0, v105, (uint64_t)v8, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v97);
  uint64_t v96 = (char *)v95 - v10;
  uint64_t v11 = swift_checkMetadataState(0, (uint64_t)v8);
  int64x2_t v104 = (char *)*(v11 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v11);
  char v98 = (char *)v95 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  unint64_t v102 = (char *)v95 - v15;
  MEMORY[0x1F4188790](v14);
  int64x2_t v114 = (char *)v95 - v17;
  uint64_t v115 = v16;
  uint64_t v18 = swift_getAssociatedConformanceWitness(a4, a3, v16, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  uint64x2_t v120 = AssociatedTypeWitness;
  v124[0] = AssociatedTypeWitness;
  v124[1] = AssociatedConformanceWitness;
  v124[2] = v9;
  v124[3] = v18;
  uint32x4_t v119 = type metadata accessor for SIMDMask(0, (uint64_t)v124);
  uint64_t v107 = (uint64_t)*(v119 - 1);
  MEMORY[0x1F4188790](v119);
  uint16x8_t v118 = (char *)v95 - v19;
  uint64_t v20 = *(char **)(a4 + 48);
  uint64_t v21 = swift_getAssociatedTypeWitness(0, (int **)v20, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v22 = (char *)*((void *)v21 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)v95 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v28 = (char *)v95 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v113 = *(void *)(a3 - 8);
  uint64_t v30 = MEMORY[0x1F4188790]((char *)v95 - v29);
  unint64_t v32 = (char *)v95 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  uint8x8_t v117 = (char *)v95 - v34;
  uint64_t v35 = v33;
  int64x2_t v108 = (void (*)(uint64_t, char *, const char *))*((void *)v22 + 2);
  int64x2_t v109 = (int **)(v22 + 16);
  v108(v33, v122, v21);
  (*((void (**)(uint64_t, char *))v20 + 6))(a3, v20);
  char v36 = v32;
  int64x2_t v110 = (void (**)(char *, Class *))*((void *)v20 + 5);
  uint64_t v111 = (void (*)(void, void, void))(v20 + 40);
  uint64_t v37 = ((uint64_t (*)(uint64_t, char *))v110)(a3, v20);
  if (v37 < 0) {
    goto LABEL_28;
  }
  uint64_t v38 = v37;
  int8x16_t v106 = v22;
  unint64_t v103 = v25;
  uint64x2_t v122 = v36;
  uint64_t v123 = a3;
  uint64_t v39 = (void (*)(char *, uint64_t, const char *))v108;
  if (v37)
  {
    uint64_t v40 = 0;
    do
    {
      v39(v28, v35, v21);
      (*((void (**)(char *, uint64_t, uint64_t, char *))v20 + 8))(v28, v40++, v123, v20);
    }
    while (v38 != v40);
  }
  (*((void (**)(uint64_t, const char *))v106 + 1))(v35, v21);
  uint64_t v41 = v123;
  (*(void (**)(char *, char *, uint64_t))(v113 + 32))(v117, v122, v123);
  uint64x2_t v122 = v20;
  uint64_t v42 = ((uint64_t (*)(uint64_t, char *))v110)(v41, v20);
  if (v42 < 0) {
LABEL_28:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v43 = v42;
  uint64_t v44 = v41;
  uint64_t v46 = v115;
  uint64_t v45 = v116;
  uint64_t v47 = v114;
  if (v42)
  {
    unint64_t v48 = 0;
    uint64_t v50 = v107 + 16;
    uint64_t v49 = *(void (**)(void, void, void))(v107 + 16);
    uint64_t v51 = v116 + 5;
    int64x2_t v109 = v116 + 7;
    int64x2_t v110 = (void (**)(char *, Class *))(v107 + 8);
    int64x2_t v108 = (void (*)(uint64_t, char *, const char *))(v112 + 64);
    uint64_t v107 = v112 + 128;
    unint64_t v101 = (void (**)(char *, uint64_t))(v104 + 8);
    v95[3] = v112 + 120;
    v95[1] = v105 + 3;
    v95[0] = v104 + 32;
    v95[2] = v112 + 96;
    int64x2_t v104 = v122 + 56;
    int8x16_t v106 = v122 + 64;
    uint64_t v111 = v49;
    while (1)
    {
      v49(v118, v121, v119);
      unint64_t v52 = ((uint64_t (*)(const char *, int **))v45[5])(v120, v45);
      if ((v52 & 0x8000000000000000) != 0) {
        goto LABEL_28;
      }
      if (v48 >= v52) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
      }
      unint64_t v99 = v51;
      uint64_t v53 = v50;
      (*v110)(v118, v119);
      ((void (*)(unint64_t, const char *, int **))v45[7])(v48, v120, v45);
      uint64_t v54 = v112;
      uint64_t v55 = v47;
      uint64_t v56 = *(uint64_t (**)(uint64_t, uint64_t))(v112 + 64);
      char v57 = v56(v46, v112);
      uint64_t v100 = v43;
      if ((v57 & 1) == 0) {
        break;
      }
      uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v54 + 128))(v46, v54);
      if (v58 >= 64)
      {
        v124[0] = 0;
        uint64_t v75 = v54;
        uint64_t v76 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v54 + 96);
        unint64_t v77 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
        uint64_t v78 = v102;
        v76(v124, &type metadata for Int, v77, v115, v75);
        uint64_t v79 = *(void *)(v75 + 32);
        uint64_t v46 = v115;
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v79 + 8) + 16))(v114, v78, v115);
        uint64_t v80 = *v101;
        uint64_t v81 = v78;
        uint64_t v47 = v114;
        (*v101)(v81, v46);
        v80(v47, v46);
        uint64_t v50 = v53;
LABEL_17:
        uint64_t v61 = v122;
        goto LABEL_25;
      }
      uint64_t v47 = v55;
      (*(void (**)(uint64_t, uint64_t))(v54 + 120))(v46, v54);
      (*v101)(v55, v46);
      uint64_t v50 = v53;
      uint64_t v61 = v122;
LABEL_25:
      uint64_t v93 = v103;
      uint64_t v44 = v123;
      (*((void (**)(unint64_t, uint64_t, char *))v61 + 7))(v48, v123, v61);
      (*((void (**)(char *, unint64_t, uint64_t, char *))v61 + 8))(v93, v48++, v44, v61);
      uint64_t v43 = v100;
      uint64_t v45 = v116;
      uint64_t v49 = v111;
      uint64_t v51 = v99;
      if (v100 == v48) {
        return (*(uint64_t (**)(char *, uint64_t))(v113 + 8))(v117, v44);
      }
    }
    char v62 = v56(v46, v54);
    uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v54 + 128))(v46, v54);
    if ((v62 & 1) == 0)
    {
      uint64_t v47 = v55;
      uint64_t v50 = v53;
      if (v63 < 64) {
        (*(void (**)(uint64_t, uint64_t))(v54 + 120))(v46, v54);
      }
      (*v101)(v47, v46);
      uint64_t v61 = v122;
      goto LABEL_25;
    }
    uint64_t v66 = v98;
    uint64_t v50 = v53;
    if (v63 <= 64)
    {
      uint64_t v82 = v105;
      BOOL v83 = v97;
      uint64_t v84 = swift_getAssociatedConformanceWitness((uint64_t)v105, v46, (uint64_t)v97, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v85 = v96;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v84 + 8))(&qword_18162B0B8, 256, v83, v84);
      uint64_t v86 = v102;
      uint64_t v87 = v85;
      uint64_t v46 = v115;
      ((void (*)(char *, uint64_t, int **))v82[3])(v87, v115, v82);
      uint64_t v88 = v114;
      LOBYTE(v83) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v54 + 32) + 8) + 16))(v114, v86, v46);
      uint64_t v89 = v54;
      size_t v90 = *v101;
      uint64_t v91 = v86;
      uint64_t v47 = v88;
      (*v101)(v91, v46);
      uint64_t v92 = v66;
      (*(void (**)(char *, char *, uint64_t))v95[0])(v66, v47, v46);
      uint64_t v61 = v122;
      if ((v83 & 1) == 0) {
        (*(void (**)(uint64_t, uint64_t))(v89 + 120))(v46, v89);
      }
      v90(v92, v46);
      goto LABEL_25;
    }
    v124[0] = 0;
    uint64_t v67 = v54;
    int v68 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v54 + 96);
    unint64_t v69 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    unsigned int v70 = v102;
    v68(v124, &type metadata for Int, v69, v46, v67);
    uint64_t v71 = *(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8) + 16);
    uint64_t v72 = v114;
    v71(v114, v70, v46);
    uint64_t v73 = *v101;
    uint64_t v74 = v70;
    uint64_t v47 = v72;
    (*v101)(v74, v46);
    v73(v72, v46);
    goto LABEL_17;
  }
  return (*(uint64_t (**)(char *, uint64_t))(v113 + 8))(v117, v44);
}

uint64_t SIMD.replacing(with:where:)@<X0>(int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v116 = a2;
  uint64_t v117 = a5;
  int8x16_t v125 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  uint64_t v115 = *(int ***)(AssociatedConformanceWitness + 48);
  uint64_t v9 = swift_getAssociatedTypeWitness(255, v115, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  uint64x2_t v122 = *(void **)(v10 + 8);
  int64x2_t v104 = *(int ***)(v122[3] + 16);
  char v98 = swift_getAssociatedTypeWitness(0, v104, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v98);
  uint64_t v97 = &v92[-v11];
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)v9);
  unint64_t v103 = (void *)*(v12 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  unint64_t v99 = &v92[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = &v92[-v16];
  MEMORY[0x1F4188790](v15);
  int64x2_t v114 = &v92[-v17];
  uint64_t v112 = v18;
  uint64_t v19 = swift_getAssociatedConformanceWitness(a4, a3, v18, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  uint64_t v121 = AssociatedTypeWitness;
  v126[0] = AssociatedTypeWitness;
  v126[1] = AssociatedConformanceWitness;
  void v126[2] = v10;
  v126[3] = v19;
  uint64x2_t v120 = type metadata accessor for SIMDMask(0, (uint64_t)v126);
  uint64_t v105 = (uint64_t)*(v120 - 1);
  MEMORY[0x1F4188790](v120);
  uint32x4_t v119 = &v92[-v20];
  uint64_t v21 = *(void *)(a4 + 48);
  uint64_t v22 = swift_getAssociatedTypeWitness(0, (int **)v21, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v23 = *((void *)v22 - 1);
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v26 = &v92[-((v25 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v27 = MEMORY[0x1F4188790](v24);
  uint64_t v29 = &v92[-v28];
  MEMORY[0x1F4188790](v27);
  uint64_t v113 = *(void *)(a3 - 8);
  uint64_t v31 = MEMORY[0x1F4188790](&v92[-v30]);
  uint64_t v33 = &v92[-((v32 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v34 = MEMORY[0x1F4188790](v31);
  uint16x8_t v118 = &v92[-v35];
  int64x2_t v110 = (void (**)(unsigned char *, Class *))v23;
  char v36 = *(void (**)(unsigned char *, uint64_t, Class *))(v23 + 16);
  uint64_t v37 = v34;
  uint64_t v39 = v38;
  uint64_t v107 = (void *)(v23 + 16);
  int8x16_t v106 = v36;
  ((void (*)(uint64_t, int **))v36)(v34, v125);
  (*(void (**)(uint64_t, uint64_t))(v21 + 48))(a3, v21);
  uint64_t v40 = *(uint64_t (**)(int **, uint64_t))(v21 + 40);
  uint64_t v41 = v33;
  uint64_t v123 = v21;
  int64x2_t v109 = (int **)(v21 + 40);
  int64x2_t v108 = v40;
  uint64_t v42 = v40((int **)a3, v21);
  if (v42 < 0) {
    goto LABEL_27;
  }
  uint64_t v43 = v42;
  unint64_t v102 = v26;
  uint64_t v124 = (uint64_t)v41;
  int8x16_t v125 = (int **)a3;
  uint64_t v44 = v123;
  uint64_t v45 = v106;
  if (v42)
  {
    uint64_t v46 = 0;
    do
    {
      v45(v29, v37, v39);
      (*(void (**)(unsigned char *, uint64_t, int **, uint64_t))(v44 + 64))(v29, v46++, v125, v44);
    }
    while (v43 != v46);
  }
  v110[1]((unsigned char *)v37, v39);
  uint64_t v47 = v113;
  unint64_t v48 = v125;
  (*(void (**)(unsigned char *, uint64_t, int **))(v113 + 32))(v118, v124, v125);
  (*(void (**)(uint64_t, void, int **))(v47 + 16))(v117, v111, v48);
  uint64_t v49 = v108(v48, v44);
  if (v49 < 0) {
LABEL_27:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v50 = v115;
  uint64_t v51 = v116;
  uint64_t v52 = v112;
  uint64_t v53 = v114;
  if (v49)
  {
    unint64_t v54 = 0;
    uint64_t v56 = v105 + 16;
    uint64_t v55 = *(void (**)(void, void, void))(v105 + 16);
    char v57 = v115 + 5;
    int64x2_t v109 = v115 + 7;
    int64x2_t v110 = (void (**)(unsigned char *, Class *))(v105 + 8);
    int64x2_t v108 = (uint64_t (*)(int **, uint64_t))(v122 + 8);
    uint64_t v107 = v122 + 16;
    uint64_t v100 = (void (**)(unsigned char *, uint64_t))(v103 + 1);
    uint64_t v96 = v122 + 15;
    uint64_t v95 = v104 + 3;
    uint64_t v94 = (void (**)(unsigned char *, unsigned char *, uint64_t))(v103 + 4);
    unint64_t v103 = v122 + 12;
    uint64_t v105 = v123 + 56;
    int8x16_t v106 = (void (*)(unsigned char *, uint64_t, Class *))(v123 + 64);
    uint64_t v124 = v49;
    uint64_t v111 = v55;
    while (1)
    {
      v55(v119, v51, v120);
      unint64_t v58 = ((uint64_t (*)(const char *, int **))v50[5])(v121, v50);
      if ((v58 & 0x8000000000000000) != 0) {
        goto LABEL_27;
      }
      if (v54 >= v58) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
      }
      int8x16_t v125 = v57;
      uint64_t v59 = v56;
      (*v110)(v119, v120);
      ((void (*)(unint64_t, const char *, int **))v50[7])(v54, v121, v50);
      uint64_t v60 = v122;
      uint64_t v61 = v53;
      char v62 = (uint64_t (*)(uint64_t, void *))v122[8];
      if ((v62(v52, v122) & 1) == 0) {
        break;
      }
      uint64_t v63 = ((uint64_t (*)(uint64_t, void *))v60[16])(v52, v60);
      if (v63 >= 64)
      {
        v126[0] = 0;
        uint64_t v75 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, void *))v122[12];
        unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
        unint64_t v77 = v101;
        v75(v126, &type metadata for Int, v76, v52, v122);
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v122[4] + 8) + 16))(v114, v77, v52);
        uint64_t v78 = *v100;
        uint64_t v79 = v77;
        uint64_t v53 = v114;
        (*v100)(v79, v52);
        v78(v53, v52);
        uint64_t v56 = v59;
LABEL_17:
        uint64_t v66 = v123;
        goto LABEL_24;
      }
      uint64_t v53 = v61;
      ((void (*)(uint64_t, void *))v60[15])(v52, v60);
      (*v100)(v61, v52);
      uint64_t v56 = v59;
      uint64_t v66 = v123;
LABEL_24:
      size_t v90 = v102;
      (*(void (**)(unint64_t, int **, uint64_t))(v66 + 56))(v54, v48, v66);
      (*(void (**)(unsigned char *, unint64_t, int **, uint64_t))(v66 + 64))(v90, v54++, v48, v66);
      char v57 = v125;
      uint64_t v50 = v115;
      uint64_t v51 = v116;
      uint64_t v55 = v111;
      if (v124 == v54) {
        return (*(uint64_t (**)(unsigned char *, int **))(v113 + 8))(v118, v48);
      }
    }
    char v67 = v62(v52, v60);
    uint64_t v68 = ((uint64_t (*)(uint64_t, void *))v60[16])(v52, v60);
    uint64_t v53 = v61;
    if ((v67 & 1) == 0)
    {
      uint64_t v56 = v59;
      if (v68 < 64) {
        ((void (*)(uint64_t, void *))v60[15])(v52, v60);
      }
      (*v100)(v53, v52);
      uint64_t v66 = v123;
      goto LABEL_24;
    }
    uint64_t v56 = v59;
    if (v68 <= 64)
    {
      uint64_t v80 = v104;
      uint64_t v81 = v98;
      uint64_t v82 = v99;
      uint64_t v83 = swift_getAssociatedConformanceWitness((uint64_t)v104, v52, (uint64_t)v98, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v84 = v97;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v83 + 8))(&qword_18162B0B8, 256, v81, v83);
      uint64_t v85 = v101;
      uint64_t v86 = v84;
      uint64_t v52 = v112;
      ((void (*)(unsigned char *, uint64_t, int **))v80[3])(v86, v112, v80);
      int v93 = (*(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v60[4] + 8) + 16))(v114, v85, v52);
      uint64_t v87 = *v100;
      uint64_t v88 = v85;
      uint64_t v53 = v114;
      (*v100)(v88, v52);
      uint64_t v89 = v82;
      (*v94)(v82, v53, v52);
      uint64_t v66 = v123;
      if ((v93 & 1) == 0) {
        ((void (*)(uint64_t, void *))v60[15])(v52, v60);
      }
      v87(v89, v52);
      goto LABEL_24;
    }
    v126[0] = 0;
    uint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, void *))v122[12];
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    uint64_t v73 = v101;
    v71(v126, &type metadata for Int, v72, v52, v122);
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v122[4] + 8) + 16))(v53, v73, v52);
    uint64_t v74 = *v100;
    (*v100)(v73, v52);
    v74(v53, v52);
    goto LABEL_17;
  }
  return (*(uint64_t (**)(unsigned char *, int **))(v113 + 8))(v118, v48);
}

uint64_t static SIMD<>..> infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v67 = a5;
  uint64_t v61 = a1;
  uint64_t v62 = a2;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, (int **)v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v65 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  uint64_t v52 = swift_getAssociatedTypeWitness(0, v65, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v52);
  uint64_t v51 = (char *)v47 - v12;
  uint64_t v55 = swift_checkMetadataState(0, (uint64_t)v11);
  MEMORY[0x1F4188790](v55);
  uint64_t v50 = (char *)v47 - v13;
  uint64_t v14 = *(int ***)(a4 + 48);
  uint64_t v15 = v10;
  uint64_t v66 = v14;
  uint64_t v63 = a3;
  uint64_t v56 = swift_getAssociatedTypeWitness(0, v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v16 = *((void *)v56 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v56);
  uint64_t v60 = (char *)v47 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  unint64_t v58 = (char *)v47 - v19;
  uint64_t v20 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  (*(void (**)(uint64_t *, uint64_t))(v10 + 48))(v20, v10);
  uint64_t v21 = *(uint64_t (**)(uint64_t *, uint64_t))(v10 + 40);
  uint64_t v64 = a6;
  uint64_t v59 = v21;
  uint64_t v57 = v10 + 40;
  uint64_t result = v21(v20, v10);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    unint64_t v23 = 0;
    uint64_t v24 = v66[7];
    uint64_t v25 = v67 + 16;
    uint64_t v26 = (void (**)(char *, const char *))(v16 + 8);
    v47[1] = v65 + 3;
    v47[0] = v15 + 64;
    unint64_t v48 = v24;
    uint64_t v49 = result;
    v47[2] = v66 + 7;
    uint64_t v53 = v15;
    unint64_t v54 = v20;
    while (1)
    {
      uint64_t v27 = v58;
      uint64_t v28 = v63;
      uint64_t v29 = v66;
      uint64_t v30 = v26;
      uint64_t v31 = v25;
      uint64_t v32 = v24;
      ((void (*)(unint64_t, uint64_t, int **))v24)(v23, v63, v66);
      uint64_t v33 = v60;
      ((void (*)(unint64_t, uint64_t, int **))v32)(v23, v28, v29);
      uint64_t v25 = v31;
      uint64_t v26 = v30;
      uint64_t v34 = v56;
      char v35 = (*(uint64_t (**)(char *, char *, const char *))(v67 + 16))(v27, v33, v56);
      char v36 = *v30;
      (*v30)(v33, v34);
      uint64_t v37 = v27;
      uint64_t v38 = v53;
      uint64_t v39 = v54;
      v36(v37, v34);
      unint64_t v40 = v59(v39, v38);
      if ((v40 & 0x8000000000000000) != 0) {
        break;
      }
      if (v23 >= v40) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v41 = v52;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v65, (uint64_t)v55, (uint64_t)v52, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v43 = v51;
      if (v35)
      {
        uint64_t v44 = (uint64_t *)&unk_18162B0C8;
        uint64_t v45 = 257;
      }
      else
      {
        uint64_t v44 = &qword_18162B0B8;
        uint64_t v45 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v44, v45, v41, AssociatedConformanceWitness);
      uint64_t v46 = v50;
      ((void (*)(char *))v65[3])(v43);
      (*(void (**)(char *, unint64_t, uint64_t *, uint64_t))(v38 + 64))(v46, v23++, v39, v38);
      uint64_t v24 = v48;
      uint64_t result = v49;
      if (v49 == v23) {
        return result;
      }
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  const char *AssociatedTypeWitness;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(char *, uint64_t);
  uint64_t v37;
  uint64_t *v38;
  int **v39;
  uint64_t *v40;
  int **v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  void (*v46)(void, void, void);
  char *v47;
  uint64_t v48;
  void (*v49)(unint64_t, uint64_t, uint64_t);
  char *v50;
  uint64_t v51;
  uint64_t v52;
  int **v53;
  char v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t *v57;
  unint64_t v58;
  const char *v59;
  uint64_t AssociatedConformanceWitness;
  char *v61;
  uint64_t *v62;
  uint64_t v63;
  char *v64;
  void v66[2];
  void (*v67)(void, void, void);
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  const char *v76;
  void (*v77)(char *, uint64_t);
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int **v84;
  int **v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;

  uint64_t v80 = a2;
  uint64_t v88 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v84 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, v84, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v85 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  unint64_t v72 = swift_getAssociatedTypeWitness(0, v85, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v72);
  uint64_t v71 = (char *)v66 - v12;
  uint64_t v75 = swift_checkMetadataState(0, (uint64_t)v11);
  MEMORY[0x1F4188790](v75);
  uint64_t v70 = (char *)v66 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v16 = *((void *)v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v79 = (char *)v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)v66 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)v66 - v23;
  uint64_t v81 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (int *)((char *)v66 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v25);
  uint64_t v87 = (char *)v66 - v28;
  uint64_t v89 = v16;
  uint64_t v82 = *(void *)(v16 + 16);
  uint64_t v83 = v29;
  ((void (*)(char *, uint64_t))v82)(v24, a1);
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (v30 < 0) {
    goto LABEL_16;
  }
  unint64_t v76 = AssociatedTypeWitness;
  uint64_t v86 = a5;
  size_t v90 = v27;
  uint64_t v91 = a3;
  uint64_t v32 = (void (*)(char *, char *, uint64_t))v82;
  uint64_t v31 = v83;
  if (v30)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v30;
      char v35 = v31;
      v32(v21, v24, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 64))(v21, v33, v91, v14);
      uint64_t v30 = v34;
      uint64_t v31 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v82 = v14;
  char v36 = *(void (**)(char *, uint64_t))(v89 + 8);
  v89 += 8;
  unint64_t v77 = v36;
  uint64_t v78 = v21;
  uint64_t v37 = v31;
  v36(v24, v31);
  (*(void (**)(char *, int *, uint64_t))(v81 + 32))(v87, v90, v91);
  uint64_t v38 = swift_checkMetadataState(0, (uint64_t)v76);
  uint64_t v39 = v84;
  ((void (*)(uint64_t *, int **))v84[6])(v38, v84);
  unint64_t v40 = v38;
  uint64_t v41 = v39;
  size_t v90 = v39[5];
  unint64_t v76 = (const char *)(v39 + 5);
  uint64_t v42 = ((uint64_t (*)(uint64_t *, int **))v90)(v38, v39);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v37;
  uint64_t v44 = v82;
  if (v42)
  {
    uint64_t v45 = 0;
    uint64_t v46 = *(void (**)(void, void, void))(v82 + 56);
    v66[1] = v85 + 3;
    v66[0] = v41 + 8;
    uint64_t v69 = v42;
    uint64_t v68 = v82 + 56;
    uint64_t v74 = v40;
    uint64_t v67 = v46;
    uint64_t v73 = v86 + 16;
    uint64_t v47 = v78;
    while (1)
    {
      unint64_t v48 = v91;
      uint64_t v49 = v46;
      v46(v45, v91, v44);
      uint64_t v50 = v79;
      uint64_t v51 = v48;
      uint64_t v52 = v86;
      v49(v45, v51, v44);
      uint64_t v53 = v41;
      unint64_t v54 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v52 + 16))(v47, v50, v43, v52);
      uint64_t v55 = v50;
      uint64_t v56 = v77;
      v77(v55, v43);
      v56(v47, v43);
      uint64_t v57 = v74;
      unint64_t v58 = ((uint64_t (*)(uint64_t *, int **))v90)(v74, v53);
      if ((v58 & 0x8000000000000000) != 0) {
        break;
      }
      if (v45 >= v58) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v59 = v72;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, (uint64_t)v75, (uint64_t)v72, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v54)
      {
        uint64_t v61 = v71;
        uint64_t v62 = (uint64_t *)&unk_18162B0C8;
        uint64_t v63 = 257;
      }
      else
      {
        uint64_t v61 = v71;
        uint64_t v62 = &qword_18162B0B8;
        uint64_t v63 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v62, v63, v59, AssociatedConformanceWitness);
      uint64_t v64 = v70;
      ((void (*)(char *))v85[3])(v61);
      uint64_t v41 = v84;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v84[8])(v64, v45++, v57, v84);
      uint64_t v44 = v82;
      uint64_t v43 = v83;
      uint64_t v46 = v67;
      if (v69 == v45) {
        return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
}

{
  const char *AssociatedTypeWitness;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(char *, uint64_t);
  uint64_t v37;
  uint64_t *v38;
  int **v39;
  uint64_t *v40;
  int **v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  void (*v46)(void, void, void);
  char *v47;
  uint64_t v48;
  void (*v49)(unint64_t, uint64_t, uint64_t);
  char *v50;
  uint64_t v51;
  uint64_t v52;
  int **v53;
  char v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t *v57;
  unint64_t v58;
  const char *v59;
  uint64_t AssociatedConformanceWitness;
  char *v61;
  uint64_t *v62;
  uint64_t v63;
  char *v64;
  void v66[2];
  void (*v67)(void, void, void);
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  const char *v76;
  void (*v77)(char *, uint64_t);
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int **v84;
  int **v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;

  uint64_t v80 = a1;
  uint64_t v88 = a6;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  uint64_t v84 = *(int ***)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, v84, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v85 = *(int ***)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMD, associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  unint64_t v72 = swift_getAssociatedTypeWitness(0, v85, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v72);
  uint64_t v71 = (char *)v66 - v12;
  uint64_t v75 = swift_checkMetadataState(0, (uint64_t)v11);
  MEMORY[0x1F4188790](v75);
  uint64_t v70 = (char *)v66 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = swift_getAssociatedTypeWitness(0, (int **)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v16 = *((void *)v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v79 = (char *)v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)v66 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v24 = (char *)v66 - v23;
  uint64_t v81 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v27 = (int *)((char *)v66 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v25);
  uint64_t v87 = (char *)v66 - v28;
  uint64_t v89 = v16;
  uint64_t v82 = *(void *)(v16 + 16);
  uint64_t v83 = v29;
  ((void (*)(char *, uint64_t))v82)(v24, a2);
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (v30 < 0) {
    goto LABEL_16;
  }
  unint64_t v76 = AssociatedTypeWitness;
  uint64_t v86 = a5;
  size_t v90 = v27;
  uint64_t v91 = a3;
  uint64_t v32 = (void (*)(char *, char *, uint64_t))v82;
  uint64_t v31 = v83;
  if (v30)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v30;
      char v35 = v31;
      v32(v21, v24, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 64))(v21, v33, v91, v14);
      uint64_t v30 = v34;
      uint64_t v31 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v82 = v14;
  char v36 = *(void (**)(char *, uint64_t))(v89 + 8);
  v89 += 8;
  unint64_t v77 = v36;
  uint64_t v78 = v21;
  uint64_t v37 = v31;
  v36(v24, v31);
  (*(void (**)(char *, int *, uint64_t))(v81 + 32))(v87, v90, v91);
  uint64_t v38 = swift_checkMetadataState(0, (uint64_t)v76);
  uint64_t v39 = v84;
  ((void (*)(uint64_t *, int **))v84[6])(v38, v84);
  unint64_t v40 = v38;
  uint64_t v41 = v39;
  size_t v90 = v39[5];
  unint64_t v76 = (const char *)(v39 + 5);
  uint64_t v42 = ((uint64_t (*)(uint64_t *, int **))v90)(v38, v39);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v37;
  uint64_t v44 = v82;
  if (v42)
  {
    uint64_t v45 = 0;
    uint64_t v46 = *(void (**)(void, void, void))(v82 + 56);
    v66[1] = v85 + 3;
    v66[0] = v41 + 8;
    uint64_t v69 = v42;
    uint64_t v68 = v82 + 56;
    uint64_t v74 = v40;
    uint64_t v67 = v46;
    uint64_t v73 = v86 + 16;
    uint64_t v47 = v78;
    while (1)
    {
      unint64_t v48 = v91;
      uint64_t v49 = v46;
      v46(v45, v91, v44);
      uint64_t v50 = v79;
      uint64_t v51 = v48;
      uint64_t v52 = v86;
      v49(v45, v51, v44);
      uint64_t v53 = v41;
      unint64_t v54 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v52 + 16))(v47, v50, v43, v52);
      uint64_t v55 = v50;
      uint64_t v56 = v77;
      v77(v55, v43);
      v56(v47, v43);
      uint64_t v57 = v74;
      unint64_t v58 = ((uint64_t (*)(uint64_t *, int **))v90)(v74, v53);
      if ((v58 & 0x8000000000000000) != 0) {
        break;
      }
      if (v45 >= v58) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v59 = v72;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, (uint64_t)v75, (uint64_t)v72, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      if (v54)
      {
        uint64_t v61 = v71;
        uint64_t v62 = (uint64_t *)&unk_18162B0C8;
        uint64_t v63 = 257;
      }
      else
      {
        uint64_t v61 = v71;
        uint64_t v62 = &qword_18162B0B8;
        uint64_t v63 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v62, v63, v59, AssociatedConformanceWitness);
      uint64_t v64 = v70;
      ((void (*)(char *))v85[3])(v61);
      uint64_t v41 = v84;
      ((void (*)(char *, unint64_t, uint64_t *, int **))v84[8])(v64, v45++, v57, v84);
      uint64_t v44 = v82;
      uint64_t v43 = v83;
      uint64_t v46 = v67;
      if (v69 == v45) {
        return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v81 + 8))(v87, v91);
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t))static FixedWidthInteger.random<A>(in:using:), a8);
}

{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t))static FixedWidthInteger.random<A>(in:using:), a8);
}

uint64_t static SIMD<>.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, (uint64_t)specialized static FixedWidthInteger.random<A>(in:using:), a5);
}

{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, (uint64_t)specialized static FixedWidthInteger.random<A>(in:using:), a5);
}

uint64_t specialized static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  v25[0] = a6;
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v15 = (char *)v25 - v14;
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v25[2] = a7;
  uint64_t v26 = a3;
  uint64_t v17 = (void (*)(void, void, void, void))v25[0];
  if (result)
  {
    uint64_t v18 = a2;
    uint64_t v19 = a5;
    uint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0;
    v25[1] = v12 + 64;
    do
    {
      uint64_t v22 = result;
      uint64_t v23 = v19;
      uint64_t v24 = v17;
      v17(a1, v18, v20, v19);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v15, v21, v26, v12);
      uint64_t v19 = v23;
      uint64_t result = v22;
      uint64_t v17 = v24;
      ++v21;
    }
    while (v22 != v21);
  }
  return result;
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, void (*a8)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t)@<X7>, uint64_t a9@<X8>)
{
  uint64_t v32 = a7;
  uint64_t v33 = a8;
  uint64_t v31 = a6;
  uint64_t v14 = *(void *)(a5 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v31 - v16;
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a9;
  uint64_t v37 = a3;
  uint64_t v20 = v31;
  uint64_t v19 = v32;
  uint64_t v21 = v33;
  uint64_t v38 = v14;
  if (result)
  {
    uint64_t v22 = a4;
    uint64_t v23 = a2;
    uint64_t v24 = AssociatedTypeWitness;
    uint64_t v25 = 0;
    uint64_t v34 = v38 + 64;
    uint64_t v35 = result;
    do
    {
      uint64_t v26 = a1;
      uint64_t v27 = v23;
      uint64_t v28 = v22;
      uint64_t v29 = a1;
      uint64_t v30 = v19;
      v21(v26, v23, v24, v22, v19, v20);
      (*(void (**)(char *, uint64_t, uint64_t))(v38 + 64))(v17, v25, v37);
      uint64_t v19 = v30;
      a1 = v29;
      uint64_t v23 = v27;
      uint64_t result = v35;
      uint64_t v22 = v28;
      ++v25;
    }
    while (v35 != v25);
  }
  return result;
}

uint64_t static SIMD<>.zero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 48) + 48))();
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, a8, a9, (void (*)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t))static BinaryFloatingPoint<>.random<A>(in:using:));
}

{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, a8, a9, (void (*)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t))static BinaryFloatingPoint<>.random<A>(in:using:));
}

uint64_t static SIMD<>.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))specialized static BinaryFloatingPoint<>.random<A>(in:using:), a6);
}

{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))specialized static BinaryFloatingPoint<>.random<A>(in:using:), a6);
}

uint64_t specialized static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void (*a7)(uint64_t, uint64_t, const char *, uint64_t, uint64_t)@<X6>, uint64_t a8@<X8>)
{
  uint64_t v27 = a7;
  uint64_t v28 = a6;
  uint64_t v13 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v13, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v27 - v15;
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v30 = a8;
  uint64_t v31 = a3;
  uint64_t v18 = a5;
  uint64_t v19 = v27;
  uint64_t v20 = v28;
  uint64_t v32 = v13;
  if (result)
  {
    uint64_t v21 = a2;
    uint64_t v22 = a1;
    uint64_t v23 = 0;
    uint64_t v29 = v32 + 64;
    do
    {
      uint64_t v24 = result;
      uint64_t v25 = v21;
      uint64_t v26 = v18;
      v19(v22, v21, AssociatedTypeWitness, v18, v20);
      (*(void (**)(char *, uint64_t, uint64_t))(v32 + 64))(v16, v23, v31);
      uint64_t v21 = v25;
      uint64_t result = v24;
      uint64_t v18 = v26;
      ++v23;
    }
    while (v24 != v23);
  }
  return result;
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, void (*a10)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v34 = a7;
  uint64_t v35 = a8;
  uint64_t v33 = a6;
  uint64_t v15 = *(void *)(a5 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v15, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v18 = (char *)&v32 - v17;
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  uint64_t v19 = a9;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v22 = v34;
  uint64_t v21 = v35;
  uint64_t v23 = v33;
  uint64_t v39 = v19;
  uint64_t v40 = a3;
  uint64_t v41 = v15;
  if (result)
  {
    uint64_t v24 = a4;
    uint64_t v25 = a1;
    uint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0;
    uint64_t v37 = a10;
    uint64_t v38 = result;
    uint64_t v36 = v41 + 64;
    do
    {
      uint64_t v28 = v24;
      uint64_t v29 = v22;
      uint64_t v30 = v21;
      uint64_t v31 = v25;
      v37(v25, a2, v26, v24, v22, v23, v21);
      (*(void (**)(char *, uint64_t, uint64_t))(v41 + 64))(v18, v27, v40);
      uint64_t v25 = v31;
      uint64_t v22 = v29;
      uint64_t v24 = v28;
      uint64_t result = v38;
      uint64_t v21 = v30;
      ++v27;
    }
    while (v38 != v27);
  }
  return result;
}

uint64_t EnumeratedSequence._base.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 40))(v2, a1);
}

uint64_t (*SIMDMask._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMDMask.scalarCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 48) + 40))(*(void *)(a1 + 16));
}

uint64_t SIMDMask.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a3, a1, a2);
}

uint64_t key path getter for SIMDMask.subscript(_:) : <A>SIMDMask<A>A@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  uint64_t v53 = a4;
  uint64_t v6 = (char *)a2 + a3;
  uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 32);
  uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 24);
  uint64_t v9 = *(void *)(v7 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  long long v55 = *((_OWORD *)v6 - 1);
  uint64_t v11 = *(void *)(v55 + 8);
  uint64_t v50 = *(int ***)(*(void *)(v11 + 24) + 16);
  uint64_t v49 = swift_getAssociatedTypeWitness(0, v50, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v49);
  unint64_t v48 = (char *)&v47 - v12;
  uint64_t v13 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v54 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v51 = (char *)&v47 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v52 = (char *)&v47 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v19 = (char *)&v47 - v18;
  v56[0] = v8;
  v56[1] = v7;
  long long v57 = v55;
  uint64_t v20 = type metadata accessor for SIMDMask(0, (uint64_t)v56);
  uint64_t v21 = (uint64_t)*(v20 - 1);
  MEMORY[0x1F4188790](v20);
  uint64_t v23 = (char *)&v47 - v22;
  uint64_t v24 = *a2;
  (*(void (**)(char *, uint64_t, Class *))(v21 + 16))((char *)&v47 - v22, a1, v20);
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v8, v9);
  if (v25 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (v24 < 0 || v24 >= v25) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  }
  (*(void (**)(char *, Class *))(v21 + 8))(v23, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56))(v24, v8, v9);
  uint64_t v26 = *(uint64_t (**)(uint64_t *, uint64_t))(v11 + 64);
  if (v26(v13, v11))
  {
    uint64_t v27 = (*(uint64_t (**)(uint64_t *, uint64_t))(v11 + 128))(v13, v11);
    if (v27 < 64)
    {
LABEL_6:
      unint64_t v30 = (*(uint64_t (**)(uint64_t *, uint64_t))(v11 + 120))(v13, v11);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t *))(v54 + 8))(v19, v13);
      unint64_t v32 = v30 >> 63;
LABEL_16:
      uint64_t v46 = v53;
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  char v33 = v26(v13, v11);
  uint64_t v27 = (*(uint64_t (**)(uint64_t *, uint64_t))(v11 + 128))(v13, v11);
  if ((v33 & 1) == 0)
  {
    if (v27 >= 64)
    {
      uint64_t result = (*(uint64_t (**)(char *, uint64_t *))(v54 + 8))(v19, v13);
      LOBYTE(v32) = 0;
      goto LABEL_16;
    }
    goto LABEL_6;
  }
  if (v27 > 64)
  {
LABEL_10:
    v56[0] = 0;
    uint64_t v34 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v11 + 96);
    unint64_t v35 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    uint64_t v36 = v52;
    v34(v56, &type metadata for Int, v35, v13, v11);
    LOBYTE(v32) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v11 + 32) + 8) + 16))(v19, v36, v13);
    uint64_t v37 = *(void (**)(char *, uint64_t *))(v54 + 8);
    v37(v36, v13);
    uint64_t result = ((uint64_t (*)(char *, uint64_t *))v37)(v19, v13);
    goto LABEL_16;
  }
  uint64_t v39 = v49;
  uint64_t v38 = v50;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v50, (uint64_t)v13, (uint64_t)v49, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v41 = v48;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
  uint64_t v42 = v52;
  ((void (*)(char *, uint64_t *, int **))v38[3])(v41, v13, v38);
  LOBYTE(v38) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v11 + 32) + 8) + 16))(v19, v42, v13);
  uint64_t v43 = v54;
  uint64_t v44 = *(void (**)(char *, uint64_t *))(v54 + 8);
  v44(v42, v13);
  uint64_t v45 = v51;
  (*(void (**)(char *, char *, uint64_t *))(v43 + 32))(v51, v19, v13);
  if (v38) {
    LOBYTE(v32) = 1;
  }
  else {
    unint64_t v32 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v11 + 120))(v13, v11) >> 63;
  }
  uint64_t v46 = v53;
  uint64_t result = ((uint64_t (*)(char *, uint64_t *))v44)(v45, v13);
LABEL_17:
  *uint64_t v46 = v32 & 1;
  return result;
}

uint64_t key path setter for SIMDMask.subscript(_:) : <A>SIMDMask<A>A(unsigned __int8 *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = *(uint64_t *)((char *)a3 + a4 - 32);
  uint64_t v8 = *(int ***)(*(void *)(*(void *)(*(uint64_t *)((char *)a3 + a4 - 16) + 8) + 24) + 16);
  uint64_t v9 = *(void *)(*(uint64_t *)((char *)a3 + a4 - 24) + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v9, v7, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v26[0] = (uint64_t)v8;
  uint64_t v11 = swift_getAssociatedTypeWitness(0, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v11);
  uint64_t v13 = (char *)v26 - v12;
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  MEMORY[0x1F4188790](v14);
  uint64_t v16 = (char *)v26 - v15;
  uint64_t v17 = *a3;
  int v18 = *a1;
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v26[1] = a2;
  uint64_t v20 = v19(v7, v9);
  if (v20 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (v17 < 0 || v17 >= v20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
  }
  uint64_t v21 = v26[0];
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v26[0], (uint64_t)v14, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v18)
  {
    uint64_t v23 = (uint64_t *)&unk_18162B0C8;
    uint64_t v24 = 257;
  }
  else
  {
    uint64_t v23 = &qword_18162B0B8;
    uint64_t v24 = 256;
  }
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v23, v24, v11, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t *, uint64_t))(v21 + 24))(v13, v14, v21);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v16, v17, v7, v9);
}

void (*SIMDMask.subscript.modify(void *a1, uint64_t a2, void *a3))(uint64_t a1, char a2)
{
  uint64_t v4 = v3;
  uint64_t v8 = malloc(0x90uLL);
  *a1 = v8;
  _OWORD v8[2] = a2;
  v8[3] = v4;
  uint64_t v49 = *(void *)(a3[4] + 8);
  uint64_t v9 = *(int ***)(*(void *)(v49 + 24) + 16);
  v8[4] = v9;
  uint64_t v10 = a3[2];
  uint64_t v11 = *(void *)(a3[3] + 48);
  v8[5] = v11;
  v8[6] = v10;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v11, v10, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v46 = (uint64_t)v9;
  uint64_t v13 = swift_getAssociatedTypeWitness(0, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v8[7] = v13;
  uint64_t v44 = (uint64_t)v13;
  uint64_t v43 = malloc(*(void *)(*((void *)v13 - 1) + 64));
  unsigned char v8[8] = v43;
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v8[9] = v14;
  uint64_t v48 = *(v14 - 1);
  size_t v15 = *(void *)(v48 + 64);
  v8[10] = malloc(v15);
  v8[11] = malloc(v15);
  uint64_t v45 = malloc(v15);
  v8[12] = v45;
  uint64_t v47 = malloc(v15);
  v8[13] = v47;
  uint64_t v16 = malloc(v15);
  uint64_t v17 = *(a3 - 1);
  int v18 = v16;
  v8[14] = v16;
  uint64_t v19 = v17;
  uint64_t v20 = malloc(*(void *)(v17 + 64));
  v8[15] = v20;
  (*(void (**)(void))(v19 + 16))();
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(v11 + 40);
  v8[16] = v21;
  uint64_t v22 = v21(v10, v11);
  if (v22 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a2 < 0 || v22 <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  }
  (*(void (**)(void *, void *))(v19 + 8))(v20, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 56))(a2, v10, v11);
  uint64_t v23 = *(uint64_t (**)(uint64_t *, uint64_t))(v49 + 64);
  if (v23(v14, v49))
  {
    uint64_t v24 = (*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 128))(v14, v49);
    if (v24 < 64)
    {
LABEL_6:
      unint64_t v27 = (*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 120))(v14, v49);
      (*(void (**)(void *, uint64_t *))(v48 + 8))(v18, v14);
      unint64_t v28 = v27 >> 63;
LABEL_18:
      uint64_t v41 = v8 + 17;
      goto LABEL_19;
    }
    v8[1] = 0;
    uint64_t v36 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v49 + 96);
    unint64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v24, v25, v26);
    v36(v8 + 1, &type metadata for Int, v37, v14, v49);
    LOBYTE(v28) = (*(uint64_t (**)(void *, void *, uint64_t *))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v18, v47, v14);
    unint64_t v35 = *(void (**)(void *, uint64_t *))(v48 + 8);
    v35(v47, v14);
LABEL_12:
    v35(v18, v14);
    goto LABEL_18;
  }
  char v29 = v23(v14, v49);
  uint64_t v30 = (*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 128))(v14, v49);
  if ((v29 & 1) == 0)
  {
    if (v30 >= 64)
    {
      (*(void (**)(void *, uint64_t *))(v48 + 8))(v18, v14);
      LOBYTE(v28) = 0;
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  if (v30 > 64)
  {
    *uint64_t v8 = 0;
    char v33 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v49 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v33(v8, &type metadata for Int, v34, v14, v49);
    LOBYTE(v28) = (*(uint64_t (**)(void *, void *, uint64_t *))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v18, v47, v14);
    unint64_t v35 = *(void (**)(void *, uint64_t *))(v48 + 8);
    v35(v47, v14);
    goto LABEL_12;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, (uint64_t)v14, v44, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v44, AssociatedConformanceWitness);
  (*(void (**)(void *, uint64_t *, uint64_t))(v46 + 24))(v43, v14, v46);
  char v39 = (*(uint64_t (**)(void *, void *, uint64_t *))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v18, v47, v14);
  uint64_t v40 = *(void (**)(void *, uint64_t *))(v48 + 8);
  v40(v47, v14);
  (*(void (**)(void *, void *, uint64_t *))(v48 + 32))(v45, v18, v14);
  if (v39) {
    LOBYTE(v28) = 1;
  }
  else {
    unint64_t v28 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 120))(v14, v49) >> 63;
  }
  uint64_t v41 = v8 + 17;
  v40(v45, v14);
LABEL_19:
  *uint64_t v41 = v28 & 1;
  return SIMDMask.subscript.modify;
}

void SIMDMask.subscript.modify(uint64_t a1, char a2)
{
  uint64_t v3 = *(void **)a1;
  int v4 = *(unsigned __int8 *)(*(void *)a1 + 136);
  unint64_t v5 = (*(uint64_t (**)(void))(*(void *)a1 + 128))(*(void *)(*(void *)a1 + 48));
  if ((a2 & 1) == 0)
  {
    if ((v5 & 0x8000000000000000) == 0)
    {
      unint64_t v6 = v3[2];
      if (v5 > v6)
      {
        unint64_t v28 = (void *)v3[14];
        char v29 = (void *)v3[15];
        uint64_t v7 = (void *)v3[11];
        uint64_t v26 = (void *)v3[12];
        unint64_t v27 = (void *)v3[13];
        uint64_t v19 = v3[9];
        uint64_t v9 = (void *)v3[10];
        uint64_t v20 = v3[7];
        uint64_t v11 = (void *)v3[8];
        uint64_t v12 = v3[5];
        uint64_t v21 = v3[4];
        uint64_t v25 = v3[6];
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v21, v19, v20, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        if (v4) {
          uint64_t v23 = 257;
        }
        else {
          uint64_t v23 = 256;
        }
        if (v4) {
          uint64_t v24 = (uint64_t *)&unk_18162B0C8;
        }
        else {
          uint64_t v24 = &qword_18162B0B8;
        }
        (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(v24, v23, v20, AssociatedConformanceWitness);
        (*(void (**)(void *, uint64_t, uint64_t))(v21 + 24))(v11, v19, v21);
        uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
        int v18 = v7;
        goto LABEL_21;
      }
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
    }
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((v5 & 0x8000000000000000) != 0) {
    goto LABEL_24;
  }
  unint64_t v6 = v3[2];
  if (v5 <= v6) {
    goto LABEL_13;
  }
  unint64_t v28 = (void *)v3[14];
  char v29 = (void *)v3[15];
  uint64_t v7 = (void *)v3[11];
  uint64_t v26 = (void *)v3[12];
  unint64_t v27 = (void *)v3[13];
  uint64_t v8 = v3[9];
  uint64_t v9 = (void *)v3[10];
  uint64_t v10 = v3[7];
  uint64_t v11 = (void *)v3[8];
  uint64_t v12 = v3[5];
  uint64_t v13 = v3[4];
  uint64_t v25 = v3[6];
  uint64_t v14 = swift_getAssociatedConformanceWitness(v13, v8, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v4) {
    uint64_t v15 = 257;
  }
  else {
    uint64_t v15 = 256;
  }
  if (v4) {
    uint64_t v16 = (uint64_t *)&unk_18162B0C8;
  }
  else {
    uint64_t v16 = &qword_18162B0B8;
  }
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v14 + 8))(v16, v15, v10, v14);
  (*(void (**)(void *, uint64_t, uint64_t))(v13 + 24))(v11, v8, v13);
  uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
  int v18 = v9;
LABEL_21:
  v17(v18, v6, v25, v12);
  free(v29);
  free(v28);
  free(v27);
  free(v26);
  free(v7);
  free(v9);
  free(v11);

  free(v3);
}

Swift::Int SIMDMask.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMDMask<A>, a3);
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMDMask<A>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 48) + 40))(*(void *)(a1 + 16));
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMDMask<A>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 48) + 48))(*(void *)(a1 + 16));
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMDMask<A>@<X0>(uint64_t a1@<X0>, void *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v5 = v3;
  uint64_t v51 = a3;
  uint64_t v7 = *(void *)(a2[4] + 8);
  uint64_t v8 = *(int ***)(*(void *)(v7 + 24) + 16);
  uint64_t v9 = a2[2];
  uint64_t v10 = *(void *)(a2[3] + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v10, v9, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = v8;
  uint64_t v47 = swift_getAssociatedTypeWitness(0, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v47);
  uint64_t v46 = (char *)&v46 - v12;
  uint64_t v13 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v52 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  uint64_t v48 = (char *)&v46 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v50 = (char *)&v46 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v46 - v19;
  uint64_t v21 = *(a2 - 1);
  MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v46 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, void *))(v21 + 16))(v23, v5, a2);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 40))(v9, v10);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a1 < 0 || v24 <= a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  }
  (*(void (**)(char *, void *))(v21 + 8))(v23, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a1, v9, v10);
  uint64_t v25 = *(uint64_t (**)(uint64_t *, uint64_t))(v7 + 64);
  if (v25(v13, v7))
  {
    uint64_t v26 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 128))(v13, v7);
    if (v26 < 64)
    {
LABEL_6:
      unint64_t v29 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 120))(v13, v7);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t *))(v52 + 8))(v20, v13);
      unint64_t v31 = v29 >> 63;
LABEL_16:
      uint64_t v45 = v51;
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  char v32 = v25(v13, v7);
  uint64_t v26 = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 128))(v13, v7);
  if ((v32 & 1) == 0)
  {
    if (v26 >= 64)
    {
      uint64_t result = (*(uint64_t (**)(char *, uint64_t *))(v52 + 8))(v20, v13);
      LOBYTE(v31) = 0;
      goto LABEL_16;
    }
    goto LABEL_6;
  }
  if (v26 > 64)
  {
LABEL_10:
    uint64_t v53 = 0;
    char v33 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v7 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v26, v27, v28);
    unint64_t v35 = v50;
    v33(&v53, &type metadata for Int, v34, v13, v7);
    LOBYTE(v31) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v7 + 32) + 8) + 16))(v20, v35, v13);
    uint64_t v36 = *(void (**)(char *, uint64_t *))(v52 + 8);
    v36(v35, v13);
    uint64_t result = ((uint64_t (*)(char *, uint64_t *))v36)(v20, v13);
    goto LABEL_16;
  }
  uint64_t v37 = (uint64_t)v49;
  uint64_t v38 = v47;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v49, (uint64_t)v13, (uint64_t)v47, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v40 = v46;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v38, AssociatedConformanceWitness);
  uint64_t v41 = v50;
  (*(void (**)(char *, uint64_t *, uint64_t))(v37 + 24))(v40, v13, v37);
  LOBYTE(v37) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v7 + 32) + 8) + 16))(v20, v41, v13);
  uint64_t v42 = v52;
  uint64_t v43 = *(void (**)(char *, uint64_t *))(v52 + 8);
  v43(v41, v13);
  uint64_t v44 = v48;
  (*(void (**)(char *, char *, uint64_t *))(v42 + 32))(v48, v20, v13);
  if (v37) {
    LOBYTE(v31) = 1;
  }
  else {
    unint64_t v31 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 120))(v13, v7) >> 63;
  }
  uint64_t v45 = v51;
  uint64_t result = ((uint64_t (*)(char *, uint64_t *))v43)(v44, v13);
LABEL_17:
  *uint64_t v45 = v31 & 1;
  return result;
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMDMask<A>(unsigned __int8 *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a3[4] + 8) + 24) + 16);
  uint64_t v7 = a3[2];
  uint64_t v8 = *(void *)(a3[3] + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v8, v7, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = swift_getAssociatedTypeWitness(0, (int **)v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v10);
  uint64_t v12 = (char *)&v23 - v11;
  uint64_t v13 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  MEMORY[0x1F4188790](v13);
  uint64_t v15 = (char *)&v23 - v14;
  int v16 = *a1;
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v24 = v3;
  uint64_t v18 = v17(v7, v8);
  if (v18 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a2 < 0 || v18 <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, (uint64_t)v13, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v16)
  {
    uint64_t v20 = (uint64_t *)&unk_18162B0C8;
    uint64_t v21 = 257;
  }
  else
  {
    uint64_t v20 = &qword_18162B0B8;
    uint64_t v21 = 256;
  }
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v20, v21, v10, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t *, uint64_t))(v6 + 24))(v12, v13, v6);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v15, a2, v7, v8);
}

void (*protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>(void *a1, uint64_t a2, void *a3))(uint64_t a1, char a2)
{
  uint64_t v5 = v3;
  uint64_t v8 = malloc(0x90uLL);
  *a1 = v8;
  _OWORD v8[2] = a2;
  v8[3] = v5;
  uint64_t v49 = *(void *)(a3[4] + 8);
  uint64_t v9 = *(int ***)(*(void *)(v49 + 24) + 16);
  v8[4] = v9;
  uint64_t v10 = a3[2];
  uint64_t v11 = *(void *)(a3[3] + 48);
  v8[5] = v11;
  v8[6] = v10;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v11, v10, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v46 = (uint64_t)v9;
  uint64_t v13 = swift_getAssociatedTypeWitness(0, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v8[7] = v13;
  uint64_t v44 = (uint64_t)v13;
  uint64_t v43 = malloc(*(void *)(*((void *)v13 - 1) + 64));
  unsigned char v8[8] = v43;
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v8[9] = v14;
  uint64_t v48 = *(v14 - 1);
  size_t v15 = *(void *)(v48 + 64);
  uint64_t v45 = malloc(v15);
  v8[10] = v45;
  v8[11] = malloc(v15);
  v8[12] = malloc(v15);
  uint64_t v47 = malloc(v15);
  v8[13] = v47;
  int v16 = malloc(v15);
  uint64_t v17 = *(a3 - 1);
  uint64_t v18 = v16;
  v8[14] = v16;
  uint64_t v19 = v17;
  uint64_t v20 = malloc(*(void *)(v17 + 64));
  v8[15] = v20;
  (*(void (**)(void))(v19 + 16))();
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(v11 + 40);
  v8[16] = v21;
  uint64_t v22 = v21(v10, v11);
  if (v22 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a2 < 0 || v22 <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  }
  (*(void (**)(void *, void *))(v19 + 8))(v20, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 56))(a2, v10, v11);
  uint64_t v23 = *(uint64_t (**)(uint64_t *, uint64_t))(v49 + 64);
  if (v23(v14, v49))
  {
    uint64_t v24 = (*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 128))(v14, v49);
    if (v24 < 64)
    {
LABEL_6:
      unint64_t v27 = (*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 120))(v14, v49);
      (*(void (**)(void *, uint64_t *))(v48 + 8))(v18, v14);
      unint64_t v28 = v27 >> 63;
LABEL_18:
      uint64_t v41 = v8 + 17;
      goto LABEL_19;
    }
    v8[1] = 0;
    uint64_t v36 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v49 + 96);
    unint64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v24, v25, v26);
    v36(v8 + 1, &type metadata for Int, v37, v14, v49);
    LOBYTE(v28) = (*(uint64_t (**)(void *, void *, uint64_t *))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v18, v47, v14);
    unint64_t v35 = *(void (**)(void *, uint64_t *))(v48 + 8);
    v35(v47, v14);
LABEL_12:
    v35(v18, v14);
    goto LABEL_18;
  }
  char v29 = v23(v14, v49);
  uint64_t v30 = (*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 128))(v14, v49);
  if ((v29 & 1) == 0)
  {
    if (v30 >= 64)
    {
      (*(void (**)(void *, uint64_t *))(v48 + 8))(v18, v14);
      LOBYTE(v28) = 0;
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  if (v30 > 64)
  {
    *uint64_t v8 = 0;
    char v33 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v49 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v33(v8, &type metadata for Int, v34, v14, v49);
    LOBYTE(v28) = (*(uint64_t (**)(void *, void *, uint64_t *))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v18, v47, v14);
    unint64_t v35 = *(void (**)(void *, uint64_t *))(v48 + 8);
    v35(v47, v14);
    goto LABEL_12;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, (uint64_t)v14, v44, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v44, AssociatedConformanceWitness);
  (*(void (**)(void *, uint64_t *, uint64_t))(v46 + 24))(v43, v14, v46);
  char v39 = (*(uint64_t (**)(void *, void *, uint64_t *))(*(void *)(*(void *)(v49 + 32) + 8) + 16))(v18, v47, v14);
  uint64_t v40 = *(void (**)(void *, uint64_t *))(v48 + 8);
  v40(v47, v14);
  (*(void (**)(void *, void *, uint64_t *))(v48 + 32))(v45, v18, v14);
  if (v39) {
    LOBYTE(v28) = 1;
  }
  else {
    unint64_t v28 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v49 + 120))(v14, v49) >> 63;
  }
  uint64_t v41 = v8 + 17;
  v40(v45, v14);
LABEL_19:
  *uint64_t v41 = v28 & 1;
  return protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>;
}

void protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>(uint64_t a1, char a2)
{
  uint64_t v3 = *(void **)a1;
  int v4 = *(unsigned __int8 *)(*(void *)a1 + 136);
  unint64_t v5 = (*(uint64_t (**)(void))(*(void *)a1 + 128))(*(void *)(*(void *)a1 + 48));
  if ((a2 & 1) == 0)
  {
    if ((v5 & 0x8000000000000000) == 0)
    {
      unint64_t v6 = v3[2];
      if (v5 > v6)
      {
        unint64_t v28 = (void *)v3[14];
        char v29 = (void *)v3[15];
        uint64_t v7 = (void *)v3[12];
        uint64_t v8 = (void *)v3[11];
        uint64_t v26 = (void *)v3[10];
        unint64_t v27 = (void *)v3[13];
        uint64_t v10 = (void *)v3[8];
        uint64_t v19 = v3[9];
        uint64_t v20 = v3[7];
        uint64_t v21 = v3[4];
        uint64_t v12 = v3[5];
        uint64_t v25 = v3[6];
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v21, v19, v20, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        if (v4) {
          uint64_t v23 = 257;
        }
        else {
          uint64_t v23 = 256;
        }
        if (v4) {
          uint64_t v24 = (uint64_t *)&unk_18162B0C8;
        }
        else {
          uint64_t v24 = &qword_18162B0B8;
        }
        (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 8))(v24, v23, v20, AssociatedConformanceWitness);
        (*(void (**)(void *, uint64_t, uint64_t))(v21 + 24))(v10, v19, v21);
        uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
        uint64_t v18 = v7;
        goto LABEL_21;
      }
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
    }
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((v5 & 0x8000000000000000) != 0) {
    goto LABEL_24;
  }
  unint64_t v6 = v3[2];
  if (v5 <= v6) {
    goto LABEL_13;
  }
  unint64_t v28 = (void *)v3[14];
  char v29 = (void *)v3[15];
  uint64_t v7 = (void *)v3[12];
  uint64_t v8 = (void *)v3[11];
  uint64_t v26 = (void *)v3[10];
  unint64_t v27 = (void *)v3[13];
  uint64_t v10 = (void *)v3[8];
  uint64_t v9 = v3[9];
  uint64_t v11 = v3[7];
  uint64_t v13 = v3[4];
  uint64_t v12 = v3[5];
  uint64_t v25 = v3[6];
  uint64_t v14 = swift_getAssociatedConformanceWitness(v13, v9, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v4) {
    uint64_t v15 = 257;
  }
  else {
    uint64_t v15 = 256;
  }
  if (v4) {
    int v16 = (uint64_t *)&unk_18162B0C8;
  }
  else {
    int v16 = &qword_18162B0B8;
  }
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v14 + 8))(v16, v15, v11, v14);
  (*(void (**)(void *, uint64_t, uint64_t))(v13 + 24))(v10, v9, v13);
  uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
  uint64_t v18 = v8;
LABEL_21:
  v17(v18, v6, v25, v12);
  free(v29);
  free(v28);
  free(v27);
  free(v7);
  free(v8);
  free(v26);
  free(v10);

  free(v3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMDMask<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMDMask<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMDMask<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMDMask<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMDMask<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMDMask<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMDMask<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMDMask<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMDMask<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMDMask<A>(char *a1, uint64_t a2, void *a3)
{
  unint64_t v140 = a2;
  uint64_t v144 = *(void *)(a3[4] + 8);
  unint64_t v5 = *(int ***)(*(void *)(v144 + 24) + 16);
  uint64_t v6 = a3[2];
  uint64_t v7 = *(void *)(a3[3] + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  int8x16_t v138 = v5;
  int8x16_t v129 = swift_getAssociatedTypeWitness(0, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v129);
  uint16x8_t v128 = (char *)&v115 - v9;
  uint64_t v10 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v11 = *(v10 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint16x8_t v126 = (char *)&v115 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  int8x8_t v133 = (char *)&v115 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  int8x16_t v127 = (char *)&v115 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  int8x16_t v135 = (char *)&v115 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  int8x8_t v143 = (char *)&v115 - v21;
  uint64_t v22 = *(a3 - 1);
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  int8x16_t v136 = (char *)&v115 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v148 = (char *)&v115 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  int64x2_t v151 = (char *)&v115 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)&v115 - v29;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  int64x2_t v149 = a1;
  uint64_t v145 = v6;
  int64x2_t v146 = v31;
  uint64_t v152 = v7;
  uint64_t v147 = v7 + 40;
  uint64_t v32 = v31(v6, v7);
  if (v32 < 0) {
LABEL_49:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v32)
  {
    int64x2_t v150 = v30;
    unint64_t v33 = 0;
    uint64_t v36 = *(void (**)(char *, uint64_t, void *))(v22 + 16);
    uint64_t v34 = v22 + 16;
    unint64_t v35 = (void (*)(char *, char *, void *))v36;
    unint64_t v142 = (void (**)(char *, void *))(v34 - 8);
    uint64_t v132 = v152 + 56;
    uint64_t v131 = v144 + 64;
    uint64_t v130 = v144 + 128;
    uint64x2_t v134 = (void (**)(char *, uint64_t *))(v11 + 8);
    uint64_t v125 = v144 + 120;
    uint64_t v123 = v138 + 3;
    uint64x2_t v122 = (void (**)(char *, char *, uint64_t *))(v11 + 32);
    uint64_t v124 = v144 + 96;
    char v37 = 1;
    uint64_t v38 = v140;
    char v39 = v143;
    uint32x4_t v139 = v36;
    uint64_t v141 = v34;
    uint64_t v137 = v32;
    while (1)
    {
      uint64_t v40 = v10;
      uint64_t v41 = v150;
      v35(v150, (char *)v149, a3);
      uint64_t v42 = v151;
      v35(v151, (char *)v38, a3);
      if (v37) {
        break;
      }
      unint64_t v58 = *v142;
      (*v142)(v42, a3);
      v58(v41, a3);
      char v37 = 0;
      uint64_t v59 = v137;
      uint64_t v10 = v40;
LABEL_11:
      ++v33;
      unint64_t v35 = (void (*)(char *, char *, void *))v139;
      if (v59 == v33) {
        return v37 & 1;
      }
    }
    v35(v148, v41, a3);
    uint64_t v43 = v145;
    unint64_t v44 = v146(v145, v152);
    if ((v44 & 0x8000000000000000) != 0) {
      goto LABEL_49;
    }
    if (v33 >= v44) {
      goto LABEL_46;
    }
    uint64_t v45 = v35;
    uint64_t v46 = *v142;
    (*v142)(v148, a3);
    uint64_t v47 = v150;
    uint32x4_t v119 = *(void (**)(unint64_t, uint64_t))(v152 + 56);
    v119(v33, v43);
    uint64_t v121 = v46;
    v46(v47, a3);
    uint64_t v48 = v144;
    uint64_t v10 = v40;
    uint64_t v49 = *(uint64_t (**)(uint64_t *, uint64_t))(v144 + 64);
    char v50 = v49(v10, v144);
    uint64x2_t v120 = v49;
    if (v50)
    {
      uint16x8_t v118 = *(uint64_t (**)(uint64_t *, uint64_t))(v48 + 128);
      uint64_t v51 = v118(v10, v48);
      if (v51 >= 64)
      {
        uint64_t v153 = 0;
        uint64_t v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v48 + 96);
        unint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v51, v52, v53);
        uint64_t v69 = v135;
        v67(&v153, &type metadata for Int, v68, v10, v48);
        uint64_t v43 = v145;
        uint64_t v57 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v48 + 32) + 8) + 16))(v143, v69, v10);
        uint64_t v56 = *v134;
        uint64_t v70 = v69;
        uint64_t v71 = (void (*)(char *, char *, void *))v139;
        uint64_t v54 = v143;
        (*v134)(v70, v10);
        v56(v54, v10);
        v71(v136, v151, a3);
        goto LABEL_26;
      }
      uint64_t v54 = v39;
      unint64_t v55 = (*(uint64_t (**)(uint64_t *, uint64_t))(v48 + 120))(v10, v48);
      uint64_t v56 = *v134;
      (*v134)(v39, v10);
      uint64_t v57 = v55 >> 63;
    }
    else
    {
      char v60 = v49(v10, v48);
      uint16x8_t v118 = *(uint64_t (**)(uint64_t *, uint64_t))(v48 + 128);
      uint64_t v61 = v118(v10, v48);
      if (v60)
      {
        if (v61 > 64)
        {
          uint64_t v153 = 0;
          uint64_t v64 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v48 + 96);
          unint64_t v65 = lazy protocol witness table accessor for type Int and conformance Int(v61, v62, v63);
          uint64_t v66 = v135;
          v64(&v153, &type metadata for Int, v65, v10, v48);
          uint64_t v54 = v143;
          uint64_t v57 = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v48 + 32) + 8) + 16))(v143, v66, v10);
          uint64_t v56 = *v134;
          (*v134)(v66, v10);
          v56(v54, v10);
          uint64_t v43 = v145;
          v139(v136, (uint64_t)v151, a3);
          goto LABEL_26;
        }
        uint64_t v73 = (uint64_t)v138;
        uint64_t v74 = v129;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v138, (uint64_t)v10, (uint64_t)v129, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v76 = v128;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v74, AssociatedConformanceWitness);
        unint64_t v77 = v135;
        (*(void (**)(char *, uint64_t *, uint64_t))(v73 + 24))(v76, v10, v73);
        uint64_t v54 = v143;
        LOBYTE(v74) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v48 + 32) + 8)
                                                                           + 16))(v143, v77, v10);
        uint64_t v56 = *v134;
        (*v134)(v77, v10);
        uint64_t v78 = v127;
        (*v122)(v127, v54, v10);
        if (v74) {
          uint64_t v57 = 1;
        }
        else {
          uint64_t v57 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v48 + 120))(v10, v48) >> 63;
        }
        uint64_t v79 = v78;
        uint64_t v43 = v145;
        uint64_t v45 = (void (*)(char *, char *, void *))v139;
        v56(v79, v10);
      }
      else
      {
        uint64_t v54 = v39;
        if (v61 >= 64)
        {
          uint64_t v56 = *v134;
          (*v134)(v39, v10);
          uint64_t v57 = 0;
        }
        else
        {
          unint64_t v72 = (*(uint64_t (**)(uint64_t *, uint64_t))(v48 + 120))(v10, v48);
          uint64_t v56 = *v134;
          (*v134)(v39, v10);
          uint64_t v57 = v72 >> 63;
        }
        uint64_t v43 = v145;
      }
    }
    v45(v136, v151, a3);
LABEL_26:
    unint64_t v80 = v146(v43, v152);
    if ((v80 & 0x8000000000000000) != 0) {
      goto LABEL_49;
    }
    if (v33 >= v80) {
LABEL_46:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
    uint64_t v116 = v56;
    uint64_t v117 = v57;
    char v39 = v54;
    uint64_t v81 = v121;
    v121(v136, a3);
    uint64_t v82 = v133;
    uint64_t v83 = v151;
    ((void (*)(unint64_t, uint64_t, uint64_t))v119)(v33, v43, v152);
    v81(v83, a3);
    uint64_t v84 = v120;
    if (v120(v10, v48))
    {
      uint64_t v85 = v118(v10, v48);
      uint64_t v88 = v116;
      if (v85 >= 64)
      {
        uint64_t v153 = 0;
        uint64_t v100 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v48 + 96);
        unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
        unint64_t v102 = v82;
        unint64_t v103 = v135;
        v100(&v153, &type metadata for Int, v101, v10, v48);
        LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v48 + 32) + 8)
                                                                           + 16))(v102, v103, v10);
        char v39 = v143;
        v88(v103, v10);
        v88(v102, v10);
      }
      else
      {
        unint64_t v89 = (*(uint64_t (**)(uint64_t *, uint64_t))(v48 + 120))(v10, v48);
        v88(v82, v10);
        unint64_t v90 = v89 >> 63;
      }
      uint64_t v38 = v140;
    }
    else
    {
      char v91 = v84(v10, v48);
      uint64_t v92 = v118(v10, v48);
      uint64_t v95 = v116;
      if ((v91 & 1) == 0)
      {
        uint64_t v59 = v137;
        if (v92 < 64)
        {
          int64x2_t v104 = v133;
          unint64_t v105 = (*(uint64_t (**)(uint64_t *, uint64_t))(v48 + 120))(v10, v48);
          v95(v104, v10);
          unint64_t v90 = v105 >> 63;
        }
        else
        {
          v116(v133, v10);
          LOBYTE(v90) = 0;
        }
        uint64_t v38 = v140;
        goto LABEL_37;
      }
      if (v92 <= 64)
      {
        uint64_t v106 = (uint64_t)v138;
        uint64_t v107 = v129;
        uint64_t v108 = swift_getAssociatedConformanceWitness((uint64_t)v138, (uint64_t)v10, (uint64_t)v129, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        int64x2_t v109 = v128;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v108 + 8))(&qword_18162B0B8, 256, v107, v108);
        int64x2_t v110 = v135;
        uint64_t v111 = v133;
        (*(void (**)(char *, uint64_t *, uint64_t))(v106 + 24))(v109, v10, v106);
        LOBYTE(v107) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v48 + 32) + 8)
                                                                            + 16))(v111, v110, v10);
        v95(v110, v10);
        uint64_t v112 = v126;
        (*v122)(v126, v111, v10);
        if (v107) {
          LOBYTE(v90) = 1;
        }
        else {
          unint64_t v90 = (unint64_t)(*(uint64_t (**)(uint64_t *, uint64_t))(v48 + 120))(v10, v48) >> 63;
        }
        uint64_t v113 = v112;
        uint64_t v38 = v140;
        char v39 = v143;
        uint64_t v59 = v137;
        v95(v113, v10);
        goto LABEL_37;
      }
      uint64_t v153 = 0;
      uint64_t v96 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v48 + 96);
      unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      char v98 = v82;
      unint64_t v99 = v135;
      v96(&v153, &type metadata for Int, v97, v10, v48);
      LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t *))(*(void *)(*(void *)(v48 + 32) + 8)
                                                                         + 16))(v98, v99, v10);
      v95(v99, v10);
      v95(v98, v10);
      uint64_t v38 = v140;
      char v39 = v143;
    }
    uint64_t v59 = v137;
LABEL_37:
    char v37 = v117 ^ v90 ^ 1;
    goto LABEL_11;
  }
  char v37 = 1;
  return v37 & 1;
}

uint64_t specialized static SIMDMask.random<A>(using:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(int ***)(*(void *)(*(void *)(a3 + 8) + 24) + 16);
  uint64_t v7 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v7, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  unint64_t v35 = v6;
  uint64_t v34 = swift_getAssociatedTypeWitness(0, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v34);
  uint64_t v10 = (char *)&v27 - v9;
  uint64_t v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  MEMORY[0x1F4188790](v11);
  unint64_t v33 = (char *)&v27 - v12;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a1, v7);
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t result = v13(a1, v7);
  if (result < 0) {
    goto LABEL_12;
  }
  uint64_t v15 = result;
  uint64_t v32 = v10;
  if (result)
  {
    unint64_t v16 = 0;
    uint64_t v30 = v7 + 64;
    uint64_t v31 = v35 + 3;
    while (1)
    {
      uint64_t __buf = 0;
      swift_stdlib_random(&__buf, 8uLL);
      int v17 = __buf;
      unint64_t v18 = v13(a1, v7);
      if ((v18 & 0x8000000000000000) != 0) {
        break;
      }
      if (v16 >= v18) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v28 = v13;
      uint64_t v19 = v34;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v35, (uint64_t)v11, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v21 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v29 = a4;
      uint64_t v22 = v32;
      if ((v17 & 0x20000) != 0)
      {
        uint64_t v23 = &qword_18162B0B8;
        uint64_t v24 = 256;
      }
      else
      {
        uint64_t v23 = (uint64_t *)&unk_18162B0C8;
        uint64_t v24 = 257;
      }
      v21(v23, v24, v19, AssociatedConformanceWitness);
      uint64_t v25 = v33;
      ((void (*)(char *, uint64_t *))v35[3])(v22, v11);
      uint64_t v26 = v25;
      a4 = v29;
      uint64_t result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v7 + 64))(v26, v16++, a1, v7);
      uint64_t v13 = v28;
      if (v15 == v16) {
        return result;
      }
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

uint64_t static SIMDMask.random<A>(using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v9 = a2;
  uint64_t v12 = *(int ***)(*(void *)(*(void *)(a6 + 8) + 24) + 16);
  uint64_t v13 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v13, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v52 = v12;
  uint64_t v48 = swift_getAssociatedTypeWitness(0, v12, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v48);
  unint64_t v16 = (char *)&v39 - v15;
  int v17 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  MEMORY[0x1F4188790](v17);
  uint64_t v47 = (char *)&v39 - v18;
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(v9, v13);
  char v50 = *(uint64_t (**)(uint64_t, uint64_t))(v13 + 40);
  uint64_t v51 = a7;
  uint64_t v49 = v13 + 40;
  uint64_t result = v50(v9, v13);
  if (result < 0) {
    goto LABEL_12;
  }
  uint64_t v46 = v16;
  if (result)
  {
    unint64_t v20 = 0;
    uint64_t v21 = a5 + 8;
    uint64_t v22 = *(uint64_t (**)(void, void))(a5 + 8);
    uint64_t v42 = v13 + 64;
    uint64_t v43 = v52 + 3;
    uint64_t v44 = a1;
    uint64_t v45 = result;
    while (1)
    {
      uint64_t v23 = a3;
      uint64_t v24 = a3;
      uint64_t v25 = a5;
      uint64_t v26 = v21;
      uint64_t v27 = v22;
      int v28 = v22(v24, a5);
      unint64_t v29 = v50(v9, v13);
      if ((v29 & 0x8000000000000000) != 0) {
        break;
      }
      if (v20 >= v29) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v41 = v17;
      uint64_t v30 = v48;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v52, (uint64_t)v17, (uint64_t)v48, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v32 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v40 = v9;
      unint64_t v33 = v46;
      if ((v28 & 0x20000) != 0)
      {
        uint64_t v34 = &qword_18162B0B8;
        uint64_t v35 = 256;
      }
      else
      {
        uint64_t v34 = (uint64_t *)&unk_18162B0C8;
        uint64_t v35 = 257;
      }
      v32(v34, v35, v30, AssociatedConformanceWitness);
      uint64_t v36 = v47;
      char v37 = v33;
      int v17 = v41;
      ((void (*)(char *, uint64_t *))v52[3])(v37, v41);
      uint64_t v38 = v36;
      uint64_t v9 = v40;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v13 + 64))(v38, v20++, v40, v13);
      uint64_t result = v45;
      a5 = v25;
      a3 = v23;
      uint64_t v21 = v26;
      uint64_t v22 = v27;
      if (v45 == v20) {
        return result;
      }
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

uint64_t static SIMDMask.random()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return specialized static SIMDMask.random<A>(using:)(a1, a2, a3, a4);
}

uint64_t SIMD<>.leadingZeroBitCount.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v7 = a1;
  uint64_t v9 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  unint64_t v16 = (char *)&v34 - v15;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(v7, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v7, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (result)
  {
    uint64_t v18 = v11;
    uint64_t v19 = AssociatedTypeWitness;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v36 = a3 + 152;
    char v37 = v21;
    uint64_t v38 = v9 + 56;
    uint64_t v39 = result;
    uint64_t v34 = v9 + 64;
    uint64_t v35 = (uint64_t (**)(char *, const char *))(v18 + 8);
    uint64_t v40 = v9;
    uint64_t v41 = v14;
    do
    {
      uint64_t v42 = v20 + 1;
      v37(v20, v7, v9);
      uint64_t v22 = (*(uint64_t (**)(const char *, uint64_t))(a3 + 152))(v19, a3);
      uint64_t v23 = (*v35)(v14, v19);
      uint64_t v43 = v22;
      uint64_t v24 = v16;
      uint64_t v25 = *(void *)(a3 + 8);
      uint64_t v26 = a4;
      uint64_t v27 = v7;
      uint64_t v28 = v5;
      unint64_t v29 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v25 + 88);
      unint64_t v32 = lazy protocol witness table accessor for type Int and conformance Int(v23, v30, v31);
      uint64_t v33 = v25;
      unint64_t v16 = v24;
      v29(&v43, &type metadata for Int, v32, v19, v33);
      uint64_t v5 = v28;
      uint64_t v7 = v27;
      a4 = v26;
      uint64_t v9 = v40;
      uint64_t v14 = v41;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v40 + 64))(v16, v20, v7, v40);
      uint64_t result = v39;
      uint64_t v20 = v42;
    }
    while (v39 != v42);
  }
  return result;
}

uint64_t SIMD<>.trailingZeroBitCount.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)v28 - v13;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a1, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a1, v7);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = AssociatedTypeWitness;
  if (result)
  {
    uint64_t v16 = 0;
    int v17 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    unint64_t v29 = (uint64_t (**)(char *, const char *))(v9 + 8);
    uint64_t v30 = v17;
    uint64_t v31 = v7 + 56;
    uint64_t v32 = a4;
    v28[1] = v7 + 64;
    uint64_t v34 = v7;
    uint64_t v35 = v12;
    uint64_t v33 = result;
    do
    {
      uint64_t v37 = v16 + 1;
      v30(v16, a1, v7);
      uint64_t v18 = a3;
      uint64_t v19 = *(void *)(a3 + 8);
      uint64_t v20 = v36;
      uint64_t v21 = (*(uint64_t (**)(const char *, uint64_t))(v19 + 144))(v36, v19);
      uint64_t v22 = (*v29)(v12, v20);
      uint64_t v38 = v21;
      uint64_t v23 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v19 + 88);
      unint64_t v26 = lazy protocol witness table accessor for type Int and conformance Int(v22, v24, v25);
      uint64_t v27 = v19;
      a3 = v18;
      v23(&v38, &type metadata for Int, v26, v20, v27);
      uint64_t v7 = v34;
      uint64_t v12 = v35;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v14, v16, a1, v34);
      uint64_t result = v33;
      uint64_t v16 = v37;
    }
    while (v33 != v37);
  }
  return result;
}

uint64_t SIMD<>.nonzeroBitCount.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v7 = a1;
  uint64_t v9 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v34 - v15;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(v7, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v7, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (result)
  {
    uint64_t v18 = v11;
    uint64_t v19 = AssociatedTypeWitness;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v36 = a3 + 144;
    uint64_t v37 = v21;
    uint64_t v38 = v9 + 56;
    uint64_t v39 = result;
    uint64_t v34 = v9 + 64;
    uint64_t v35 = (uint64_t (**)(char *, const char *))(v18 + 8);
    uint64_t v40 = v9;
    uint64_t v41 = v14;
    do
    {
      uint64_t v42 = v20 + 1;
      v37(v20, v7, v9);
      uint64_t v22 = (*(uint64_t (**)(const char *, uint64_t))(a3 + 144))(v19, a3);
      uint64_t v23 = (*v35)(v14, v19);
      uint64_t v43 = v22;
      uint64_t v24 = v16;
      uint64_t v25 = *(void *)(a3 + 8);
      uint64_t v26 = a4;
      uint64_t v27 = v7;
      uint64_t v28 = v5;
      unint64_t v29 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, const char *, uint64_t))(v25 + 88);
      unint64_t v32 = lazy protocol witness table accessor for type Int and conformance Int(v23, v30, v31);
      uint64_t v33 = v25;
      uint64_t v16 = v24;
      v29(&v43, &type metadata for Int, v32, v19, v33);
      uint64_t v5 = v28;
      uint64_t v7 = v27;
      a4 = v26;
      uint64_t v9 = v40;
      uint64_t v14 = v41;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v40 + 64))(v16, v20, v7, v40);
      uint64_t result = v39;
      uint64_t v20 = v42;
    }
    while (v39 != v42);
  }
  return result;
}

uint64_t static SIMD<>.~ prefix(_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)v26 - v13;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a1, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a1, v7);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v31 = v14;
  uint64_t v32 = a3;
  if (result)
  {
    uint64_t v16 = v9;
    int v17 = AssociatedTypeWitness;
    uint64_t v18 = a1;
    uint64_t v19 = a4;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v27 = (void (**)(char *, const char *))(v16 + 8);
    uint64_t v28 = v21;
    uint64_t v29 = v7 + 56;
    uint64_t v30 = result;
    v26[1] = v7 + 64;
    do
    {
      v28(v20, v18, v7);
      uint64_t v22 = v18;
      uint64_t v23 = v19;
      uint64_t v24 = v31;
      (*(void (**)(char *, const char *))(*(void *)(v32 + 8) + 184))(v12, v17);
      (*v27)(v12, v17);
      uint64_t v25 = v24;
      uint64_t v19 = v23;
      uint64_t v18 = v22;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v25, v20, v22, v7);
      uint64_t result = v30;
      ++v20;
    }
    while (v30 != v20);
  }
  return result;
}

uint64_t static SIMD<>.& infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(v37 + 8) + 192))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t static SIMD<>.^ infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(v37 + 8) + 224))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t static SIMD<>.| infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(v37 + 8) + 208))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t static SIMD<>.&<< infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v35 = a1;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v27 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v27 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v27 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a2, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a2, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a4;
  uint64_t v33 = v17;
  uint64_t v34 = a5;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = v36 + 216;
    uint64_t v30 = v21;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v27[1] = v8 + 64;
    uint64_t v28 = (void (**)(char *, const char *))(v37 + 8);
    do
    {
      uint64_t v37 = v20 + 1;
      uint64_t v22 = v30;
      v30(v20, v19, v8);
      v22(v20, v19, v8);
      uint64_t v23 = v19;
      uint64_t v24 = v33;
      (*(void (**)(char *, char *, const char *))(v36 + 216))(v15, v12, AssociatedTypeWitness);
      uint64_t v25 = *v28;
      (*v28)(v12, AssociatedTypeWitness);
      v25(v15, AssociatedTypeWitness);
      uint64_t v26 = v24;
      uint64_t v19 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v26, v20, v23, v8);
      uint64_t result = v32;
      uint64_t v20 = v37;
    }
    while (v32 != v37);
  }
  return result;
}

uint64_t static SIMD<>.&>> infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v35 = a1;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v27 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v27 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v27 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a2, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a2, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a4;
  uint64_t v33 = v17;
  uint64_t v34 = a5;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = v36 + 200;
    uint64_t v30 = v21;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v27[1] = v8 + 64;
    uint64_t v28 = (void (**)(char *, const char *))(v37 + 8);
    do
    {
      uint64_t v37 = v20 + 1;
      uint64_t v22 = v30;
      v30(v20, v19, v8);
      v22(v20, v19, v8);
      uint64_t v23 = v19;
      uint64_t v24 = v33;
      (*(void (**)(char *, char *, const char *))(v36 + 200))(v15, v12, AssociatedTypeWitness);
      uint64_t v25 = *v28;
      (*v28)(v12, AssociatedTypeWitness);
      v25(v15, AssociatedTypeWitness);
      uint64_t v26 = v24;
      uint64_t v19 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v26, v20, v23, v8);
      uint64_t result = v32;
      uint64_t v20 = v37;
    }
    while (v32 != v37);
  }
  return result;
}

uint64_t static SIMD<>.&+ infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v38 = a1;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v40 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v31 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v31 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v31 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a2, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a2, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v39 = a4;
  uint64_t v36 = v17;
  uint64_t v37 = a5;
  uint64_t v35 = AssociatedTypeWitness;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = v15;
    uint64_t v21 = v12;
    uint64_t v22 = 0;
    uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31[2] = v39 + 80;
    uint64_t v32 = v23;
    uint64_t v33 = v8 + 56;
    uint64_t v34 = result;
    v31[0] = v8 + 64;
    v31[1] = v40 + 8;
    uint64_t v24 = (void (**)(char *, const char *))(v40 + 8);
    do
    {
      uint64_t v40 = v22 + 1;
      uint64_t v25 = v32;
      v32(v22, v19, v8);
      v25(v22, v19, v8);
      uint64_t v26 = v19;
      uint64_t v27 = v35;
      uint64_t v28 = v36;
      (*(void (**)(char *, char *, const char *))(v39 + 80))(v36, v21, v35);
      uint64_t v29 = *v24;
      (*v24)(v21, v27);
      v29(v20, v27);
      uint64_t v30 = v28;
      uint64_t v19 = v26;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v30, v22, v26, v8);
      uint64_t result = v34;
      uint64_t v22 = v40;
    }
    while (v34 != v40);
  }
  return result;
}

uint64_t static SIMD<>.&* infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v38 = a1;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v40 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v31 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v31 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v31 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a2, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a2, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v39 = a4;
  uint64_t v36 = v17;
  uint64_t v37 = a5;
  uint64_t v35 = AssociatedTypeWitness;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = v15;
    uint64_t v21 = v12;
    uint64_t v22 = 0;
    uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31[2] = v39 + 96;
    uint64_t v32 = v23;
    uint64_t v33 = v8 + 56;
    uint64_t v34 = result;
    v31[0] = v8 + 64;
    v31[1] = v40 + 8;
    uint64_t v24 = (void (**)(char *, const char *))(v40 + 8);
    do
    {
      uint64_t v40 = v22 + 1;
      uint64_t v25 = v32;
      v32(v22, v19, v8);
      v25(v22, v19, v8);
      uint64_t v26 = v19;
      uint64_t v27 = v35;
      uint64_t v28 = v36;
      (*(void (**)(char *, char *, const char *))(v39 + 96))(v36, v20, v35);
      uint64_t v29 = *v24;
      (*v24)(v21, v27);
      v29(v20, v27);
      uint64_t v30 = v28;
      uint64_t v19 = v26;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v30, v22, v26, v8);
      uint64_t result = v34;
      uint64_t v22 = v40;
    }
    while (v34 != v40);
  }
  return result;
}

uint64_t static SIMD<>./ infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(v37 + 8) + 152))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t, uint64_t, uint64_t);
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, const char *);
  char *v26;
  void v27[2];
  void (**v28)(char *, const char *);
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  uint64_t v35 = a1;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v27 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v27 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v27 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a2, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a2, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a4;
  uint64_t v33 = v17;
  uint64_t v34 = a5;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = v36 + 192;
    uint64_t v30 = v21;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v27[1] = v8 + 64;
    uint64_t v28 = (void (**)(char *, const char *))(v37 + 8);
    do
    {
      uint64_t v37 = v20 + 1;
      uint64_t v22 = v30;
      v30(v20, v19, v8);
      v22(v20, v19, v8);
      uint64_t v23 = v19;
      uint64_t v24 = v33;
      (*(void (**)(char *, char *, const char *))(v36 + 192))(v15, v12, AssociatedTypeWitness);
      uint64_t v25 = *v28;
      (*v28)(v12, AssociatedTypeWitness);
      v25(v15, AssociatedTypeWitness);
      uint64_t v26 = v24;
      uint64_t v19 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v26, v20, v23, v8);
      uint64_t result = v32;
      uint64_t v20 = v37;
    }
    while (v32 != v37);
  }
  return result;
}

uint64_t static SIMD<>.% infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(v37 + 8) + 168))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t static SIMD<>.+ infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(*(void *)(v37 + 16) + 8) + 8)
                                                           + 24))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t static SIMD<>.- infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(*(void *)(v37 + 16) + 8) + 8)
                                                           + 40))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t static SIMD<>.* infix(_:_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v38 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v28 - v14;
  MEMORY[0x1F4188790](v13);
  int v17 = (char *)v28 - v16;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v5, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v5, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a5;
  uint64_t v36 = a1;
  uint64_t v33 = v12;
  uint64_t v34 = v17;
  if (result)
  {
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = (void (**)(char *, const char *))(v38 + 8);
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v32 = result;
    v28[1] = v8 + 64;
    uint64_t v21 = v33;
    do
    {
      uint64_t v38 = v19 + 1;
      uint64_t v22 = v15;
      uint64_t v23 = v30;
      v30(v19, v5, v8);
      v23(v19, v5, v8);
      uint64_t v24 = v5;
      uint64_t v25 = v34;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(v37 + 16) + 8) + 64))(v22, v21, AssociatedTypeWitness);
      uint64_t v26 = *v29;
      (*v29)(v21, AssociatedTypeWitness);
      v26(v22, AssociatedTypeWitness);
      uint64_t v27 = v25;
      uint64_t v5 = v24;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v27, v19, v24, v8);
      uint64_t v15 = v22;
      uint64_t result = v32;
      uint64_t v19 = v38;
    }
    while (v32 != v38);
  }
  return result;
}

uint64_t SIMD<>.addingProduct(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v46 = a1;
  uint64_t v47 = a2;
  uint64_t v48 = a5;
  uint64_t v6 = a3;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v38 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v38 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v38 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v38 - v19;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(v6, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(v6, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v44 = v12;
  uint64_t v45 = a6;
  if (result)
  {
    uint64_t v22 = AssociatedTypeWitness;
    uint64_t v23 = v15;
    uint64_t v24 = v20;
    uint64_t v25 = v18;
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v40 = v48 + 256;
    uint64_t v41 = v27;
    uint64_t v42 = v8 + 56;
    uint64_t v43 = result;
    uint64_t v38 = v8 + 64;
    uint64_t v39 = (void (**)(char *, const char *))(v49 + 8);
    char v50 = v22;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v41;
      v41(v26, v6, v8);
      v28(v26, v6, v8);
      uint64_t v29 = v6;
      uint64_t v30 = v24;
      uint64_t v31 = v25;
      uint64_t v32 = v23;
      uint64_t v33 = v8;
      uint64_t v34 = v44;
      v28(v26, v29, v33);
      (*(void (**)(char *, char *, const char *))(v48 + 256))(v32, v34, v50);
      uint64_t v35 = *v39;
      uint64_t v36 = v34;
      uint64_t v8 = v33;
      uint64_t v23 = v32;
      uint64_t v25 = v31;
      uint64_t v24 = v30;
      uint64_t v6 = v29;
      uint64_t v37 = v50;
      (*v39)(v36, v50);
      v35(v23, v37);
      v35(v25, v37);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v24, v26, v6, v8);
      uint64_t result = v43;
      uint64_t v26 = v49;
    }
    while (v43 != v49);
  }
  return result;
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  char *v33;
  void (*v34)(char *, uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  char *v46;
  void (*v47)(uint64_t, uint64_t);
  char *v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  uint64_t v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  void (*v57)(char *, uint64_t);
  uint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t (*v66)(uint64_t, uint64_t);
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  char *v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;

  uint64_t v71 = a2;
  uint64_t v73 = a5;
  uint64_t v74 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v70 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v61 = (char *)&v59 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  char v60 = (char *)&v59 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v63 = (char *)&v59 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)&v59 - v19);
  uint64_t v22 = (char *)&v59 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = (char *)&v59 - v24;
  unint64_t v76 = v10;
  uint64_t v26 = v23;
  uint64_t v28 = v27;
  uint64_t v67 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v67(v23, a1);
  uint64_t v29 = *(char **)(v8 + 48);
  unint64_t v72 = v8 + 48;
  uint64_t v69 = v29;
  ((void (*)(uint64_t, uint64_t))v29)(a3, v8);
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  unint64_t v68 = v8 + 40;
  uint64_t v66 = v30;
  uint64_t v31 = v30(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v75 = v25;
  unint64_t v77 = v22;
  uint64_t v78 = a3;
  uint64_t v32 = v28;
  uint64_t v33 = v63;
  uint64_t v34 = (void (*)(char *, uint64_t, uint64_t))v67;
  if (v31)
  {
    uint64_t v35 = 0;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      v34(v33, v26, v32);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35, v78, v8);
      uint64_t v31 = v36;
      uint64_t v32 = v37;
      ++v35;
    }
    while (v36 != v35);
  }
  uint64_t v38 = v76 + 8;
  uint64_t v39 = *(void (**)(uint64_t, uint64_t))(v76 + 8);
  uint64_t v40 = v32;
  v39(v26, v32);
  uint64_t v41 = v78;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v75, v77, v78);
  ((void (*)(uint64_t, uint64_t))v69)(v41, v8);
  uint64_t v42 = v66(v41, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v43 = v8;
  unint64_t v76 = v38;
  uint64_t v45 = v60;
  uint64_t v44 = v61;
  unint64_t v72 = v43;
  uint64_t v46 = v63;
  if (v42)
  {
    uint64_t v47 = v39;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v72 + 56);
    char v50 = v72;
    unint64_t v65 = v73 + 256;
    uint64_t v66 = v49;
    unint64_t v68 = v72 + 56;
    uint64_t v69 = (char *)v42;
    uint64_t v64 = v72 + 64;
    uint64_t v67 = v47;
    uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v49;
    do
    {
      unint64_t v77 = v48 + 1;
      v51(v48, v41, v50);
      v51(v48, v41, v50);
      uint64_t v52 = v46;
      uint64_t v53 = v45;
      uint64_t v54 = v44;
      unint64_t v55 = v70;
      v51(v48, v78, v50);
      (*(void (**)(char *, char *, uint64_t))(v73 + 256))(v54, v55, v40);
      uint64_t v56 = v55;
      uint64_t v44 = v54;
      uint64_t v45 = v53;
      uint64_t v46 = v52;
      uint64_t v57 = (void (*)(char *, uint64_t))v67;
      uint64_t v41 = v78;
      v67((uint64_t)v56, v40);
      v57(v44, v40);
      v57(v45, v40);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v41, v50);
      uint64_t v48 = v77;
    }
    while (v69 != v77);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v75, v41);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  char *v33;
  void (*v34)(char *, uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  char *v46;
  void (*v47)(uint64_t, uint64_t);
  char *v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  uint64_t v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  void (*v57)(char *, uint64_t);
  uint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t (*v66)(uint64_t, uint64_t);
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  char *v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;

  uint64_t v71 = a1;
  uint64_t v73 = a5;
  uint64_t v74 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v70 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v61 = (char *)&v59 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  char v60 = (char *)&v59 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v63 = (char *)&v59 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)&v59 - v19);
  uint64_t v22 = (char *)&v59 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v25 = (char *)&v59 - v24;
  unint64_t v76 = v10;
  uint64_t v26 = v23;
  uint64_t v28 = v27;
  uint64_t v67 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v67(v23, a2);
  uint64_t v29 = *(char **)(v8 + 48);
  unint64_t v72 = v8 + 48;
  uint64_t v69 = v29;
  ((void (*)(uint64_t, uint64_t))v29)(a3, v8);
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  unint64_t v68 = v8 + 40;
  uint64_t v66 = v30;
  uint64_t v31 = v30(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v75 = v25;
  unint64_t v77 = v22;
  uint64_t v78 = a3;
  uint64_t v32 = v28;
  uint64_t v33 = v63;
  uint64_t v34 = (void (*)(char *, uint64_t, uint64_t))v67;
  if (v31)
  {
    uint64_t v35 = 0;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      v34(v33, v26, v32);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35, v78, v8);
      uint64_t v31 = v36;
      uint64_t v32 = v37;
      ++v35;
    }
    while (v36 != v35);
  }
  uint64_t v38 = v76 + 8;
  uint64_t v39 = *(void (**)(uint64_t, uint64_t))(v76 + 8);
  uint64_t v40 = v32;
  v39(v26, v32);
  uint64_t v41 = v78;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v75, v77, v78);
  ((void (*)(uint64_t, uint64_t))v69)(v41, v8);
  uint64_t v42 = v66(v41, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v43 = v8;
  unint64_t v76 = v38;
  uint64_t v45 = v60;
  uint64_t v44 = v61;
  unint64_t v72 = v43;
  uint64_t v46 = v63;
  if (v42)
  {
    uint64_t v47 = v39;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v72 + 56);
    char v50 = v72;
    unint64_t v65 = v73 + 256;
    uint64_t v66 = v49;
    unint64_t v68 = v72 + 56;
    uint64_t v69 = (char *)v42;
    uint64_t v64 = v72 + 64;
    uint64_t v67 = v47;
    uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v49;
    do
    {
      unint64_t v77 = v48 + 1;
      v51(v48, v41, v50);
      v51(v48, v41, v50);
      uint64_t v52 = v46;
      uint64_t v53 = v45;
      uint64_t v54 = v44;
      unint64_t v55 = v70;
      v51(v48, v78, v50);
      (*(void (**)(char *, char *, uint64_t))(v73 + 256))(v54, v55, v40);
      uint64_t v56 = v55;
      uint64_t v44 = v54;
      uint64_t v45 = v53;
      uint64_t v46 = v52;
      uint64_t v57 = (void (*)(char *, uint64_t))v67;
      uint64_t v41 = v78;
      v67((uint64_t)v56, v40);
      v57(v44, v40);
      v57(v45, v40);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v41, v50);
      uint64_t v48 = v77;
    }
    while (v69 != v77);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v75, v41);
}

uint64_t SIMD<>.squareRoot()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v27 - v14;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a1, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a1, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v33 = a4;
  uint64_t v34 = a3;
  uint64_t v32 = AssociatedTypeWitness;
  if (result)
  {
    uint64_t v17 = v4;
    uint64_t v18 = a1;
    uint64_t v19 = 0;
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v29 = v34 + 240;
    uint64_t v30 = v20;
    uint64_t v31 = v8 + 56;
    uint64_t v27 = v8 + 64;
    uint64_t v28 = (void (**)(char *, const char *))(v10 + 8);
    do
    {
      uint64_t v21 = result;
      uint64_t v22 = v17;
      v30(v19, v18, v8);
      uint64_t v23 = v18;
      uint64_t v24 = v15;
      uint64_t v25 = v32;
      (*(void (**)(const char *))(v34 + 240))(v32);
      uint64_t v26 = v25;
      uint64_t v15 = v24;
      uint64_t v18 = v23;
      (*v28)(v13, v26);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v15, v19, v23, v8);
      uint64_t v17 = v22;
      uint64_t result = v21;
      ++v19;
    }
    while (v21 != v19);
  }
  return result;
}

uint64_t SIMD<>.rounded(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v11 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v13 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v15 = (char *)v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)v29 - v16;
  (*(void (**)(uint64_t, uint64_t))(v11 + 48))(a2, v11);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 40))(a2, v11);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a1;
  uint64_t v37 = a4;
  uint64_t v34 = AssociatedTypeWitness;
  uint64_t v35 = a5;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = 0;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 56);
    uint64_t v31 = v37 + 304;
    uint64_t v32 = v21;
    uint64_t v22 = (void (**)(char *, const char *))(v33 + 8);
    uint64_t v33 = v11 + 56;
    v29[1] = v11 + 64;
    uint64_t v30 = v22;
    do
    {
      uint64_t v23 = result;
      uint64_t v24 = v6;
      v32(v20, v19, v11);
      uint64_t v25 = v17;
      uint64_t v26 = v19;
      uint64_t v27 = v34;
      (*(void (**)(uint64_t, const char *))(v37 + 304))(v36, v34);
      uint64_t v28 = v27;
      uint64_t v19 = v26;
      uint64_t v17 = v25;
      (*v30)(v15, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 64))(v25, v20, v19, v11);
      uint64_t v6 = v24;
      uint64_t result = v23;
      ++v20;
    }
    while (v23 != v20);
  }
  return result;
}

uint64_t static SIMDMask..! prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v38 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v38 - v14;
  uint64_t v16 = *(void *)(a2 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v13);
  uint64_t v19 = (char *)&v38 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = MEMORY[0x1F4188790]((char *)&v38 - v20);
  uint64_t v40 = (char *)&v38 - v22;
  uint64_t v23 = v21;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 16))(v21, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a2, v8);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a2, v8);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v38 = v16;
  uint64_t v39 = a5;
  uint64_t v25 = a2;
  uint64_t v45 = v15;
  uint64_t v47 = v19;
  uint64_t v26 = v23;
  if (v24)
  {
    uint64_t v27 = 0;
    uint64_t v28 = *(void (**)(uint64_t))(v8 + 56);
    uint64_t v29 = v45;
    uint64_t v42 = (void (**)(char *, const char *))(v44 + 8);
    uint64_t v43 = v28;
    uint64_t v44 = v8 + 56;
    uint64_t v41 = v8 + 64;
    do
    {
      uint64_t v30 = v24;
      uint64_t v31 = v25;
      v43(v27);
      (*(void (**)(char *, const char *))(*(void *)(v46 + 8) + 184))(v12, AssociatedTypeWitness);
      (*v42)(v12, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v29, v27, v31, v8);
      uint64_t v25 = v31;
      uint64_t v24 = v30;
      ++v27;
    }
    while (v30 != v27);
  }
  uint64_t v32 = v38;
  uint64_t v33 = v26;
  uint64_t v34 = v25;
  (*(void (**)(uint64_t))(v38 + 8))(v33);
  uint64_t v35 = *(void (**)(char *, char *, uint64_t))(v32 + 32);
  uint64_t v36 = v40;
  v35(v40, v47, v34);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v39, v36, v34);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v59 = a5;
  uint64_t v62 = a2;
  uint64_t v53 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v57 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v50 = (char *)&v48 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  char v60 = (char *)&v48 - v15;
  uint64_t v16 = *(void *)(a3 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v48 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v48 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = MEMORY[0x1F4188790]((char *)&v48 - v23);
  uint64_t v52 = (char *)&v48 - v25;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 16);
  uint64_t v63 = v24;
  v26(v24, a1, a3);
  uint64_t v27 = v22;
  v26((uint64_t)v22, (uint64_t)v62, a3);
  uint64_t v28 = v19;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (v29 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v49 = v16;
  uint64_t v30 = a3;
  uint64_t v31 = v50;
  uint64_t v32 = v51;
  uint64_t v61 = v27;
  uint64_t v62 = v28;
  if (v29)
  {
    uint64_t v33 = v8;
    uint64_t v34 = 0;
    uint64_t v35 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    unint64_t v55 = (void (**)(char *, const char *))(v57 + 8);
    uint64_t v56 = v35;
    uint64_t v57 = v8 + 56;
    uint64_t v58 = v29;
    uint64_t v54 = v8 + 64;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      uint64_t v38 = v56;
      v56(v34, v30, v33);
      v38(v34, v30, v33);
      uint64_t v32 = v37;
      uint64_t v31 = v36;
      uint64_t v39 = v30;
      uint64_t v40 = v60;
      (*(void (**)(char *, char *, const char *))(*(void *)(v59 + 8) + 192))(v36, v32, AssociatedTypeWitness);
      uint64_t v41 = *v55;
      (*v55)(v32, AssociatedTypeWitness);
      v41(v36, AssociatedTypeWitness);
      uint64_t v42 = v40;
      uint64_t v30 = v39;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v42, v34++, v39, v33);
    }
    while (v58 != v34);
  }
  uint64_t v43 = v49;
  uint64_t v44 = *(void (**)(char *, uint64_t))(v49 + 8);
  v44(v61, v30);
  v44((char *)v63, v30);
  uint64_t v45 = *(void (**)(char *, char *, uint64_t))(v43 + 32);
  uint64_t v46 = v52;
  v45(v52, v62, v30);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v45)(v53, v46, v30);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v59 = a5;
  uint64_t v62 = a2;
  uint64_t v53 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v57 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v50 = (char *)&v48 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  char v60 = (char *)&v48 - v15;
  uint64_t v16 = *(void *)(a3 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v48 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v48 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = MEMORY[0x1F4188790]((char *)&v48 - v23);
  uint64_t v52 = (char *)&v48 - v25;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 16);
  uint64_t v63 = v24;
  v26(v24, a1, a3);
  uint64_t v27 = v22;
  v26((uint64_t)v22, (uint64_t)v62, a3);
  uint64_t v28 = v19;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (v29 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v49 = v16;
  uint64_t v30 = a3;
  uint64_t v31 = v50;
  uint64_t v32 = v51;
  uint64_t v61 = v27;
  uint64_t v62 = v28;
  if (v29)
  {
    uint64_t v33 = v8;
    uint64_t v34 = 0;
    uint64_t v35 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    unint64_t v55 = (void (**)(char *, const char *))(v57 + 8);
    uint64_t v56 = v35;
    uint64_t v57 = v8 + 56;
    uint64_t v58 = v29;
    uint64_t v54 = v8 + 64;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      uint64_t v38 = v56;
      v56(v34, v30, v33);
      v38(v34, v30, v33);
      uint64_t v32 = v37;
      uint64_t v31 = v36;
      uint64_t v39 = v30;
      uint64_t v40 = v60;
      (*(void (**)(char *, char *, const char *))(*(void *)(v59 + 8) + 224))(v36, v32, AssociatedTypeWitness);
      uint64_t v41 = *v55;
      (*v55)(v32, AssociatedTypeWitness);
      v41(v36, AssociatedTypeWitness);
      uint64_t v42 = v40;
      uint64_t v30 = v39;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v42, v34++, v39, v33);
    }
    while (v58 != v34);
  }
  uint64_t v43 = v49;
  uint64_t v44 = *(void (**)(char *, uint64_t))(v49 + 8);
  v44(v61, v30);
  v44((char *)v63, v30);
  uint64_t v45 = *(void (**)(char *, char *, uint64_t))(v43 + 32);
  uint64_t v46 = v52;
  v45(v52, v62, v30);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v45)(v53, v46, v30);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v59 = a5;
  uint64_t v62 = a2;
  uint64_t v53 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v57 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v50 = (char *)&v48 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  char v60 = (char *)&v48 - v15;
  uint64_t v16 = *(void *)(a3 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v48 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v48 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v24 = MEMORY[0x1F4188790]((char *)&v48 - v23);
  uint64_t v52 = (char *)&v48 - v25;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 16);
  uint64_t v63 = v24;
  v26(v24, a1, a3);
  uint64_t v27 = v22;
  v26((uint64_t)v22, (uint64_t)v62, a3);
  uint64_t v28 = v19;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (v29 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v49 = v16;
  uint64_t v30 = a3;
  uint64_t v31 = v50;
  uint64_t v32 = v51;
  uint64_t v61 = v27;
  uint64_t v62 = v28;
  if (v29)
  {
    uint64_t v33 = v8;
    uint64_t v34 = 0;
    uint64_t v35 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    unint64_t v55 = (void (**)(char *, const char *))(v57 + 8);
    uint64_t v56 = v35;
    uint64_t v57 = v8 + 56;
    uint64_t v58 = v29;
    uint64_t v54 = v8 + 64;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      uint64_t v38 = v56;
      v56(v34, v30, v33);
      v38(v34, v30, v33);
      uint64_t v32 = v37;
      uint64_t v31 = v36;
      uint64_t v39 = v30;
      uint64_t v40 = v60;
      (*(void (**)(char *, char *, const char *))(*(void *)(v59 + 8) + 208))(v36, v32, AssociatedTypeWitness);
      uint64_t v41 = *v55;
      (*v55)(v32, AssociatedTypeWitness);
      v41(v36, AssociatedTypeWitness);
      uint64_t v42 = v40;
      uint64_t v30 = v39;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v42, v34++, v39, v33);
    }
    while (v58 != v34);
  }
  uint64_t v43 = v49;
  uint64_t v44 = *(void (**)(char *, uint64_t))(v49 + 8);
  v44(v61, v30);
  v44((char *)v63, v30);
  uint64_t v45 = *(void (**)(char *, char *, uint64_t))(v43 + 32);
  uint64_t v46 = v52;
  v45(v52, v62, v30);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v45)(v53, v46, v30);
}

uint64_t static SIMD<>.& infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v69 = a5;
  uint64_t v70 = a2;
  uint64_t v72 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v59 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)&v59 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v59 - v18);
  uint64_t v21 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  unint64_t v76 = (char *)&v59 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  unint64_t v65 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v65(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v71 = v8 + 48;
  unint64_t v68 = v27;
  v27(a3, v8);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v67 = v8 + 40;
  uint64_t v28 = v66(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  char v60 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v63;
  uint64_t v31 = v24;
  uint64_t v73 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v65;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v73, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v73;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  uint64_t v42 = v76;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v76, v75, v37);
  v68(v37, v33);
  uint64_t v43 = v66(v37, v33);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v74 = v39;
  uint64_t v44 = v60;
  uint64_t v45 = v61;
  uint64_t v71 = v33;
  unint64_t v68 = v38;
  uint64_t v46 = v63;
  if (v43)
  {
    uint64_t v47 = v41;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v71 + 56);
    unint64_t v65 = (void (*)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v66 = v49;
    uint64_t v64 = v71 + 64;
    uint64_t v67 = v43;
    uint64_t v50 = v71;
    do
    {
      uint64_t v75 = v48 + 1;
      uint64_t v51 = v44;
      uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))v66;
      ((void (*)(char *, uint64_t, uint64_t))v66)(v48, v37, v50);
      v52(v48, v37, v50);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 192))(v51, v45, v47);
      uint64_t v53 = v45;
      uint64_t v54 = v45;
      uint64_t v55 = v37;
      uint64_t v56 = v46;
      uint64_t v57 = (void (*)(char *, uint64_t))v68;
      v68((uint64_t)v53, v47);
      v57(v51, v47);
      uint64_t v46 = v56;
      uint64_t v37 = v55;
      uint64_t v45 = v54;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v37, v50);
      uint64_t v44 = v51;
      uint64_t v42 = v76;
      uint64_t v48 = v75;
    }
    while ((char *)v67 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v42, v37);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  unint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  unint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    unint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v68 + 8) + 192))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.^ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v69 = a5;
  uint64_t v70 = a2;
  uint64_t v72 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v59 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)&v59 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v59 - v18);
  uint64_t v21 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  unint64_t v76 = (char *)&v59 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  unint64_t v65 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v65(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v71 = v8 + 48;
  unint64_t v68 = v27;
  v27(a3, v8);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v67 = v8 + 40;
  uint64_t v28 = v66(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  char v60 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v63;
  uint64_t v31 = v24;
  uint64_t v73 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v65;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v73, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v73;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  uint64_t v42 = v76;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v76, v75, v37);
  v68(v37, v33);
  uint64_t v43 = v66(v37, v33);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v74 = v39;
  uint64_t v44 = v60;
  uint64_t v45 = v61;
  uint64_t v71 = v33;
  unint64_t v68 = v38;
  uint64_t v46 = v63;
  if (v43)
  {
    uint64_t v47 = v41;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v71 + 56);
    unint64_t v65 = (void (*)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v66 = v49;
    uint64_t v64 = v71 + 64;
    uint64_t v67 = v43;
    uint64_t v50 = v71;
    do
    {
      uint64_t v75 = v48 + 1;
      uint64_t v51 = v44;
      uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))v66;
      ((void (*)(char *, uint64_t, uint64_t))v66)(v48, v37, v50);
      v52(v48, v37, v50);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 224))(v51, v45, v47);
      uint64_t v53 = v45;
      uint64_t v54 = v45;
      uint64_t v55 = v37;
      uint64_t v56 = v46;
      uint64_t v57 = (void (*)(char *, uint64_t))v68;
      v68((uint64_t)v53, v47);
      v57(v51, v47);
      uint64_t v46 = v56;
      uint64_t v37 = v55;
      uint64_t v45 = v54;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v37, v50);
      uint64_t v44 = v51;
      uint64_t v42 = v76;
      uint64_t v48 = v75;
    }
    while ((char *)v67 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v42, v37);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  unint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  unint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    unint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v68 + 8) + 224))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.| infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v69 = a5;
  uint64_t v70 = a2;
  uint64_t v72 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v59 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)&v59 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v59 - v18);
  uint64_t v21 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  unint64_t v76 = (char *)&v59 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  unint64_t v65 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v65(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v71 = v8 + 48;
  unint64_t v68 = v27;
  v27(a3, v8);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v67 = v8 + 40;
  uint64_t v28 = v66(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  char v60 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v63;
  uint64_t v31 = v24;
  uint64_t v73 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v65;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v73, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v73;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  uint64_t v42 = v76;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v76, v75, v37);
  v68(v37, v33);
  uint64_t v43 = v66(v37, v33);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v74 = v39;
  uint64_t v44 = v60;
  uint64_t v45 = v61;
  uint64_t v71 = v33;
  unint64_t v68 = v38;
  uint64_t v46 = v63;
  if (v43)
  {
    uint64_t v47 = v41;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v71 + 56);
    unint64_t v65 = (void (*)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v66 = v49;
    uint64_t v64 = v71 + 64;
    uint64_t v67 = v43;
    uint64_t v50 = v71;
    do
    {
      uint64_t v75 = v48 + 1;
      uint64_t v51 = v44;
      uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))v66;
      ((void (*)(char *, uint64_t, uint64_t))v66)(v48, v37, v50);
      v52(v48, v37, v50);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 208))(v51, v45, v47);
      uint64_t v53 = v45;
      uint64_t v54 = v45;
      uint64_t v55 = v37;
      uint64_t v56 = v46;
      uint64_t v57 = (void (*)(char *, uint64_t))v68;
      v68((uint64_t)v53, v47);
      v57(v51, v47);
      uint64_t v46 = v56;
      uint64_t v37 = v55;
      uint64_t v45 = v54;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v37, v50);
      uint64_t v44 = v51;
      uint64_t v42 = v76;
      uint64_t v48 = v75;
    }
    while ((char *)v67 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v42, v37);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  unint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  unint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    unint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v68 + 8) + 208))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.&<< infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v67 = a2;
  uint64_t v68 = a5;
  uint64_t v69 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v58 = (char *)&v56 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v56 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v70 = (char *)&v56 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v56 - v18);
  uint64_t v21 = (void (*)(char *, uint64_t))((char *)&v56 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  char v60 = (char *)&v56 - v23;
  uint64_t v72 = v10;
  uint64_t v24 = v10 + 16;
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v26 = v22;
  uint64_t v28 = v27;
  uint64_t v59 = v24;
  uint64_t v62 = v25;
  ((void (*)(uint64_t, uint64_t))v25)(v22, a1);
  unint64_t v65 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v66 = v8 + 48;
  v65(a3, v8);
  uint64_t v29 = v21;
  uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v64 = v8 + 40;
  uint64_t v30 = v63(a3, v8);
  if (v30 < 0) {
    goto LABEL_10;
  }
  uint64_t v31 = v30;
  uint64_t v57 = v15;
  uint64_t v32 = v70;
  uint64_t v71 = v29;
  uint64_t v73 = a3;
  uint64_t v33 = v62;
  if (v30)
  {
    uint64_t v34 = 0;
    do
    {
      v33(v32, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v32, v34++, v73, v8);
    }
    while (v31 != v34);
  }
  uint64_t v36 = v72 + 8;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v72 + 8);
  uint64_t v37 = v28;
  v35(v26, v28);
  uint64_t v38 = v60;
  uint64_t v39 = v73;
  (*(void (**)(char *, void (*)(char *, uint64_t), uint64_t))(v61 + 32))(v60, v71, v73);
  v65(v39, v8);
  uint64_t v40 = v63(v39, v8);
  if (v40 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v41 = v35;
  uint64_t v42 = v39;
  uint64_t v71 = (void (*)(char *, uint64_t))v41;
  uint64_t v72 = v36;
  uint64_t v44 = v57;
  uint64_t v43 = v58;
  uint64_t v45 = v8;
  uint64_t v46 = v38;
  if (v40)
  {
    uint64_t v47 = 0;
    uint64_t v48 = *(void (**)(uint64_t, uint64_t))(v45 + 56);
    uint64_t v64 = v45 + 56;
    unint64_t v65 = v48;
    uint64_t v62 = (void (*)(char *, uint64_t, uint64_t))(v45 + 64);
    uint64_t v63 = (uint64_t (*)(uint64_t, uint64_t))(v68 + 216);
    uint64_t v66 = v40;
    do
    {
      uint64_t v73 = v47 + 1;
      uint64_t v49 = (void (*)(uint64_t, uint64_t, uint64_t))v65;
      ((void (*)(uint64_t, uint64_t, uint64_t))v65)(v47, v42, v45);
      v49(v47, v42, v45);
      uint64_t v50 = v70;
      (*(void (**)(char *, char *, uint64_t))(v68 + 216))(v44, v43, v37);
      uint64_t v51 = v43;
      uint64_t v52 = v43;
      uint64_t v53 = v42;
      uint64_t v54 = v71;
      v71(v51, v37);
      v54(v44, v37);
      uint64_t v42 = v53;
      uint64_t v43 = v52;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 64))(v50, v47, v42, v45);
      uint64_t v47 = v73;
    }
    while (v66 != v73);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v46, v42);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(char *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  void (*v33)(char *, uint64_t, uint64_t);
  uint64_t v34;
  void (*v35)(uint64_t, uint64_t);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  void (*v46)(uint64_t, uint64_t, uint64_t);
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  void (*v51)(char *, uint64_t);
  uint64_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(char *, uint64_t, uint64_t);
  uint64_t (*v60)(uint64_t, uint64_t);
  void (*v61)(uint64_t, uint64_t, uint64_t);
  void (*v62)(uint64_t, uint64_t);
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  void (*v67)(char *, uint64_t);
  char *v68;
  uint64_t v69;
  uint64_t v70;

  uint64_t v64 = a5;
  unint64_t v65 = a6;
  uint64_t v56 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v53 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v66 = (char *)&v53 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v58 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v53 - v18);
  uint64_t v21 = (void (*)(char *, uint64_t))((char *)&v53 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v68 = (char *)&v53 - v23;
  uint64_t v69 = v10;
  uint64_t v24 = v10 + 16;
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v26 = v22;
  uint64_t v28 = v27;
  uint64_t v57 = v24;
  uint64_t v59 = v25;
  ((void (*)(uint64_t, uint64_t))v25)(v22, a2);
  uint64_t v62 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v63 = v8 + 48;
  v62(a3, v8);
  uint64_t v29 = v21;
  char v60 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v61 = (void (*)(uint64_t, uint64_t, uint64_t))(v8 + 40);
  uint64_t v30 = v60(a3, v8);
  if (v30 < 0) {
    goto LABEL_10;
  }
  uint64_t v31 = v30;
  uint64_t v54 = v15;
  uint64_t v32 = v66;
  uint64_t v67 = v29;
  uint64_t v70 = a3;
  uint64_t v33 = v59;
  if (v30)
  {
    uint64_t v34 = 0;
    do
    {
      v33(v32, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v32, v34++, v70, v8);
    }
    while (v31 != v34);
  }
  uint64_t v36 = v69 + 8;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v69 + 8);
  uint64_t v37 = v28;
  v35(v26, v28);
  uint64_t v38 = v70;
  (*(void (**)(char *, void (*)(char *, uint64_t), uint64_t))(v58 + 32))(v68, v67, v70);
  v62(v38, v8);
  uint64_t v39 = v60(v38, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v40 = v35;
  uint64_t v41 = v38;
  uint64_t v69 = v36;
  uint64_t v42 = v55;
  uint64_t v43 = v54;
  uint64_t v67 = (void (*)(char *, uint64_t))v40;
  if (v39)
  {
    uint64_t v44 = 0;
    uint64_t v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    char v60 = (uint64_t (*)(uint64_t, uint64_t))(v64 + 216);
    uint64_t v61 = v45;
    uint64_t v62 = (void (*)(uint64_t, uint64_t))(v8 + 56);
    uint64_t v63 = v39;
    uint64_t v59 = (void (*)(char *, uint64_t, uint64_t))(v8 + 64);
    do
    {
      uint64_t v70 = v44 + 1;
      uint64_t v46 = v61;
      v61(v44, v41, v8);
      v46(v44, v41, v8);
      uint64_t v47 = v66;
      (*(void (**)(char *, char *, uint64_t))(v64 + 216))(v43, v42, v37);
      uint64_t v48 = v42;
      uint64_t v49 = v42;
      uint64_t v50 = v41;
      uint64_t v51 = v67;
      v67(v48, v37);
      v51(v43, v37);
      uint64_t v41 = v50;
      uint64_t v42 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v47, v44, v41, v8);
      uint64_t v44 = v70;
    }
    while (v63 != v70);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v58 + 8))(v68, v41);
}

uint64_t static SIMD<>.&>> infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v67 = a2;
  uint64_t v68 = a5;
  uint64_t v69 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v58 = (char *)&v56 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v56 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v70 = (char *)&v56 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v56 - v18);
  uint64_t v21 = (void (*)(char *, uint64_t))((char *)&v56 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  char v60 = (char *)&v56 - v23;
  uint64_t v72 = v10;
  uint64_t v24 = v10 + 16;
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v26 = v22;
  uint64_t v28 = v27;
  uint64_t v59 = v24;
  uint64_t v62 = v25;
  ((void (*)(uint64_t, uint64_t))v25)(v22, a1);
  unint64_t v65 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v66 = v8 + 48;
  v65(a3, v8);
  uint64_t v29 = v21;
  uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v64 = v8 + 40;
  uint64_t v30 = v63(a3, v8);
  if (v30 < 0) {
    goto LABEL_10;
  }
  uint64_t v31 = v30;
  uint64_t v57 = v15;
  uint64_t v32 = v70;
  uint64_t v71 = v29;
  uint64_t v73 = a3;
  uint64_t v33 = v62;
  if (v30)
  {
    uint64_t v34 = 0;
    do
    {
      v33(v32, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v32, v34++, v73, v8);
    }
    while (v31 != v34);
  }
  uint64_t v36 = v72 + 8;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v72 + 8);
  uint64_t v37 = v28;
  v35(v26, v28);
  uint64_t v38 = v60;
  uint64_t v39 = v73;
  (*(void (**)(char *, void (*)(char *, uint64_t), uint64_t))(v61 + 32))(v60, v71, v73);
  v65(v39, v8);
  uint64_t v40 = v63(v39, v8);
  if (v40 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v41 = v35;
  uint64_t v42 = v39;
  uint64_t v71 = (void (*)(char *, uint64_t))v41;
  uint64_t v72 = v36;
  uint64_t v44 = v57;
  uint64_t v43 = v58;
  uint64_t v45 = v8;
  uint64_t v46 = v38;
  if (v40)
  {
    uint64_t v47 = 0;
    uint64_t v48 = *(void (**)(uint64_t, uint64_t))(v45 + 56);
    uint64_t v64 = v45 + 56;
    unint64_t v65 = v48;
    uint64_t v62 = (void (*)(char *, uint64_t, uint64_t))(v45 + 64);
    uint64_t v63 = (uint64_t (*)(uint64_t, uint64_t))(v68 + 200);
    uint64_t v66 = v40;
    do
    {
      uint64_t v73 = v47 + 1;
      uint64_t v49 = (void (*)(uint64_t, uint64_t, uint64_t))v65;
      ((void (*)(uint64_t, uint64_t, uint64_t))v65)(v47, v42, v45);
      v49(v47, v42, v45);
      uint64_t v50 = v70;
      (*(void (**)(char *, char *, uint64_t))(v68 + 200))(v44, v43, v37);
      uint64_t v51 = v43;
      uint64_t v52 = v43;
      uint64_t v53 = v42;
      uint64_t v54 = v71;
      v71(v51, v37);
      v54(v44, v37);
      uint64_t v42 = v53;
      uint64_t v43 = v52;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 64))(v50, v47, v42, v45);
      uint64_t v47 = v73;
    }
    while (v66 != v73);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v46, v42);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(char *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  void (*v33)(char *, uint64_t, uint64_t);
  uint64_t v34;
  void (*v35)(uint64_t, uint64_t);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  void (*v46)(uint64_t, uint64_t, uint64_t);
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  void (*v51)(char *, uint64_t);
  uint64_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(char *, uint64_t, uint64_t);
  uint64_t (*v60)(uint64_t, uint64_t);
  void (*v61)(uint64_t, uint64_t, uint64_t);
  void (*v62)(uint64_t, uint64_t);
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  void (*v67)(char *, uint64_t);
  char *v68;
  uint64_t v69;
  uint64_t v70;

  uint64_t v64 = a5;
  unint64_t v65 = a6;
  uint64_t v56 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v53 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v66 = (char *)&v53 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v58 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v53 - v18);
  uint64_t v21 = (void (*)(char *, uint64_t))((char *)&v53 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v68 = (char *)&v53 - v23;
  uint64_t v69 = v10;
  uint64_t v24 = v10 + 16;
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v26 = v22;
  uint64_t v28 = v27;
  uint64_t v57 = v24;
  uint64_t v59 = v25;
  ((void (*)(uint64_t, uint64_t))v25)(v22, a2);
  uint64_t v62 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v63 = v8 + 48;
  v62(a3, v8);
  uint64_t v29 = v21;
  char v60 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v61 = (void (*)(uint64_t, uint64_t, uint64_t))(v8 + 40);
  uint64_t v30 = v60(a3, v8);
  if (v30 < 0) {
    goto LABEL_10;
  }
  uint64_t v31 = v30;
  uint64_t v54 = v15;
  uint64_t v32 = v66;
  uint64_t v67 = v29;
  uint64_t v70 = a3;
  uint64_t v33 = v59;
  if (v30)
  {
    uint64_t v34 = 0;
    do
    {
      v33(v32, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v32, v34++, v70, v8);
    }
    while (v31 != v34);
  }
  uint64_t v36 = v69 + 8;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v69 + 8);
  uint64_t v37 = v28;
  v35(v26, v28);
  uint64_t v38 = v70;
  (*(void (**)(char *, void (*)(char *, uint64_t), uint64_t))(v58 + 32))(v68, v67, v70);
  v62(v38, v8);
  uint64_t v39 = v60(v38, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v40 = v35;
  uint64_t v41 = v38;
  uint64_t v69 = v36;
  uint64_t v42 = v55;
  uint64_t v43 = v54;
  uint64_t v67 = (void (*)(char *, uint64_t))v40;
  if (v39)
  {
    uint64_t v44 = 0;
    uint64_t v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    char v60 = (uint64_t (*)(uint64_t, uint64_t))(v64 + 200);
    uint64_t v61 = v45;
    uint64_t v62 = (void (*)(uint64_t, uint64_t))(v8 + 56);
    uint64_t v63 = v39;
    uint64_t v59 = (void (*)(char *, uint64_t, uint64_t))(v8 + 64);
    do
    {
      uint64_t v70 = v44 + 1;
      uint64_t v46 = v61;
      v61(v44, v41, v8);
      v46(v44, v41, v8);
      uint64_t v47 = v66;
      (*(void (**)(char *, char *, uint64_t))(v64 + 200))(v43, v42, v37);
      uint64_t v48 = v42;
      uint64_t v49 = v42;
      uint64_t v50 = v41;
      uint64_t v51 = v67;
      v67(v48, v37);
      v51(v43, v37);
      uint64_t v41 = v50;
      uint64_t v42 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v47, v44, v41, v8);
      uint64_t v44 = v70;
    }
    while (v63 != v70);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v58 + 8))(v68, v41);
}

uint64_t static SIMD<>.&+ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v63 = a2;
  uint64_t v64 = a5;
  uint64_t v65 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v53 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v53 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v56 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)&v53 - v19);
  uint64_t v22 = (void (*)(uint64_t, const char *))((char *)&v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v55 = (char *)&v53 - v24;
  uint64_t v67 = v10;
  uint64_t v25 = *(char **)(v10 + 16);
  uint64_t v57 = v23;
  uint64_t v62 = v25;
  ((void (*)(uint64_t, uint64_t, const char *))v25)(v23, a1, AssociatedTypeWitness);
  char v60 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v61 = v8 + 48;
  v60(a3, v8);
  uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v59 = v8 + 40;
  uint64_t v26 = v58(a3, v8);
  if (v26 < 0) {
    goto LABEL_10;
  }
  uint64_t v53 = v15;
  uint64_t v68 = a3;
  uint64_t v27 = v57;
  uint64_t v66 = v22;
  uint64_t v28 = v62;
  if (v26)
  {
    uint64_t v29 = 0;
    do
    {
      uint64_t v30 = v26;
      ((void (*)(char *, uint64_t, const char *))v28)(v18, v27, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v18, v29, v68, v8);
      uint64_t v26 = v30;
      ++v29;
    }
    while (v30 != v29);
  }
  uint64_t v62 = v18;
  uint64_t v31 = v67 + 8;
  uint64_t v32 = v27;
  uint64_t v33 = *(void (**)(uint64_t, const char *))(v67 + 8);
  v33(v32, AssociatedTypeWitness);
  uint64_t v34 = v55;
  uint64_t v35 = v68;
  (*(void (**)(char *, void (*)(uint64_t, const char *), uint64_t))(v56 + 32))(v55, v66, v68);
  v60(v35, v8);
  uint64_t v36 = v35;
  uint64_t v37 = v58(v35, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v38 = v8;
  uint64_t v39 = AssociatedTypeWitness;
  uint64_t v66 = v33;
  uint64_t v67 = v31;
  uint64_t v40 = v53;
  uint64_t v41 = v54;
  uint64_t v42 = v34;
  if (v37)
  {
    uint64_t v43 = 0;
    uint64_t v44 = *(void (**)(uint64_t, uint64_t))(v38 + 56);
    uint64_t v59 = v38 + 56;
    char v60 = v44;
    uint64_t v57 = v38 + 64;
    uint64_t v58 = (uint64_t (*)(uint64_t, uint64_t))(v64 + 80);
    uint64_t v61 = v37;
    do
    {
      uint64_t v68 = v43 + 1;
      uint64_t v45 = v40;
      uint64_t v46 = (void (*)(uint64_t, uint64_t, uint64_t))v60;
      ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v43, v36, v38);
      v46(v43, v36, v38);
      uint64_t v47 = v62;
      (*(void (**)(char *, char *, const char *))(v64 + 80))(v62, v41, v39);
      uint64_t v48 = v41;
      uint64_t v49 = v41;
      uint64_t v50 = v36;
      uint64_t v51 = (void (*)(char *, const char *))v66;
      v66((uint64_t)v48, v39);
      v51(v45, v39);
      uint64_t v36 = v50;
      uint64_t v41 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v38 + 64))(v47, v43, v36, v38);
      uint64_t v40 = v45;
      uint64_t v43 = v68;
    }
    while (v61 != v68);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v56 + 8))(v42, v36);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t, const char *);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(uint64_t, uint64_t);
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  char *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *);
  void v52[2];
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(uint64_t, const char *);
  char *v64;
  uint64_t v65;
  uint64_t v66;

  uint64_t v61 = a5;
  uint64_t v62 = a6;
  v52[1] = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v53 = (char *)v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)v52 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)v52 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)v52 - v19);
  uint64_t v22 = (void (*)(uint64_t, const char *))((char *)v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v64 = (char *)v52 - v24;
  uint64_t v65 = v10;
  uint64_t v25 = *(char **)(v10 + 16);
  uint64_t v55 = v23;
  char v60 = v25;
  ((void (*)(uint64_t, uint64_t, const char *))v25)(v23, a2, AssociatedTypeWitness);
  uint64_t v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v59 = v8 + 48;
  v58(a3, v8);
  uint64_t v26 = v8;
  uint64_t v56 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v57 = v8 + 40;
  uint64_t v27 = v56(a3, v8);
  if (v27 < 0) {
    goto LABEL_10;
  }
  v52[0] = v15;
  uint64_t v66 = a3;
  uint64_t v28 = AssociatedTypeWitness;
  uint64_t v29 = v55;
  uint64_t v63 = v22;
  uint64_t v30 = v60;
  if (v27)
  {
    uint64_t v31 = 0;
    do
    {
      uint64_t v32 = v27;
      ((void (*)(char *, uint64_t, const char *))v30)(v18, v29, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v26 + 64))(v18, v31, v66, v26);
      uint64_t v27 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  char v60 = v18;
  uint64_t v33 = v65 + 8;
  uint64_t v34 = v29;
  uint64_t v35 = *(void (**)(uint64_t, const char *))(v65 + 8);
  v35(v34, AssociatedTypeWitness);
  uint64_t v36 = v66;
  (*(void (**)(char *, void (*)(uint64_t, const char *), uint64_t))(v54 + 32))(v64, v63, v66);
  v58(v36, v26);
  uint64_t v37 = v36;
  uint64_t v38 = v56(v36, v26);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v39 = v53;
  uint64_t v65 = v33;
  uint64_t v40 = v52[0];
  uint64_t v63 = v35;
  if (v38)
  {
    uint64_t v41 = v26;
    uint64_t v42 = 0;
    uint64_t v43 = *(void (**)(uint64_t, uint64_t))(v26 + 56);
    uint64_t v57 = v26 + 56;
    uint64_t v58 = v43;
    uint64_t v55 = v26 + 64;
    uint64_t v56 = (uint64_t (*)(uint64_t, uint64_t))(v61 + 80);
    uint64_t v59 = v38;
    do
    {
      uint64_t v66 = v42 + 1;
      uint64_t v44 = v40;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v58;
      ((void (*)(uint64_t, uint64_t, uint64_t))v58)(v42, v37, v41);
      v45(v42, v37, v41);
      uint64_t v46 = v60;
      (*(void (**)(char *, char *, const char *))(v61 + 80))(v60, v39, v28);
      uint64_t v47 = v39;
      uint64_t v48 = v39;
      uint64_t v49 = v37;
      uint64_t v50 = v63;
      v63((uint64_t)v47, v28);
      v50(v44, v28);
      uint64_t v37 = v49;
      uint64_t v39 = v48;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v41 + 64))(v46, v42, v37, v41);
      uint64_t v40 = v44;
      uint64_t v42 = v66;
    }
    while (v59 != v66);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v54 + 8))(v64, v37);
}

uint64_t static SIMD<>.&- infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v63 = a2;
  uint64_t v64 = a5;
  uint64_t v65 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v53 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v53 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v56 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)&v53 - v19);
  uint64_t v22 = (void (*)(uint64_t, const char *))((char *)&v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v55 = (char *)&v53 - v24;
  uint64_t v67 = v10;
  uint64_t v25 = *(char **)(v10 + 16);
  uint64_t v57 = v23;
  uint64_t v62 = v25;
  ((void (*)(uint64_t, uint64_t, const char *))v25)(v23, a1, AssociatedTypeWitness);
  char v60 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v61 = v8 + 48;
  v60(a3, v8);
  uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v59 = v8 + 40;
  uint64_t v26 = v58(a3, v8);
  if (v26 < 0) {
    goto LABEL_10;
  }
  uint64_t v53 = v15;
  uint64_t v68 = a3;
  uint64_t v27 = v57;
  uint64_t v66 = v22;
  uint64_t v28 = v62;
  if (v26)
  {
    uint64_t v29 = 0;
    do
    {
      uint64_t v30 = v26;
      ((void (*)(char *, uint64_t, const char *))v28)(v18, v27, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v18, v29, v68, v8);
      uint64_t v26 = v30;
      ++v29;
    }
    while (v30 != v29);
  }
  uint64_t v62 = v18;
  uint64_t v31 = v67 + 8;
  uint64_t v32 = v27;
  uint64_t v33 = *(void (**)(uint64_t, const char *))(v67 + 8);
  v33(v32, AssociatedTypeWitness);
  uint64_t v34 = v55;
  uint64_t v35 = v68;
  (*(void (**)(char *, void (*)(uint64_t, const char *), uint64_t))(v56 + 32))(v55, v66, v68);
  v60(v35, v8);
  uint64_t v36 = v35;
  uint64_t v37 = v58(v35, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v38 = v8;
  uint64_t v39 = AssociatedTypeWitness;
  uint64_t v66 = v33;
  uint64_t v67 = v31;
  uint64_t v40 = v53;
  uint64_t v41 = v54;
  uint64_t v42 = v34;
  if (v37)
  {
    uint64_t v43 = 0;
    uint64_t v44 = *(void (**)(uint64_t, uint64_t))(v38 + 56);
    uint64_t v59 = v38 + 56;
    char v60 = v44;
    uint64_t v57 = v38 + 64;
    uint64_t v58 = (uint64_t (*)(uint64_t, uint64_t))(v64 + 88);
    uint64_t v61 = v37;
    do
    {
      uint64_t v68 = v43 + 1;
      uint64_t v45 = v40;
      uint64_t v46 = (void (*)(uint64_t, uint64_t, uint64_t))v60;
      ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v43, v36, v38);
      v46(v43, v36, v38);
      uint64_t v47 = v62;
      (*(void (**)(char *, char *, const char *))(v64 + 88))(v62, v41, v39);
      uint64_t v48 = v41;
      uint64_t v49 = v41;
      uint64_t v50 = v36;
      uint64_t v51 = (void (*)(char *, const char *))v66;
      v66((uint64_t)v48, v39);
      v51(v45, v39);
      uint64_t v36 = v50;
      uint64_t v41 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v38 + 64))(v47, v43, v36, v38);
      uint64_t v40 = v45;
      uint64_t v43 = v68;
    }
    while (v61 != v68);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v56 + 8))(v42, v36);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t, const char *);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(uint64_t, uint64_t);
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  char *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *);
  void v52[2];
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(uint64_t, const char *);
  char *v64;
  uint64_t v65;
  uint64_t v66;

  uint64_t v61 = a5;
  uint64_t v62 = a6;
  v52[1] = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v53 = (char *)v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)v52 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)v52 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)v52 - v19);
  uint64_t v22 = (void (*)(uint64_t, const char *))((char *)v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v64 = (char *)v52 - v24;
  uint64_t v65 = v10;
  uint64_t v25 = *(char **)(v10 + 16);
  uint64_t v55 = v23;
  char v60 = v25;
  ((void (*)(uint64_t, uint64_t, const char *))v25)(v23, a2, AssociatedTypeWitness);
  uint64_t v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v59 = v8 + 48;
  v58(a3, v8);
  uint64_t v26 = v8;
  uint64_t v56 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v57 = v8 + 40;
  uint64_t v27 = v56(a3, v8);
  if (v27 < 0) {
    goto LABEL_10;
  }
  v52[0] = v15;
  uint64_t v66 = a3;
  uint64_t v28 = AssociatedTypeWitness;
  uint64_t v29 = v55;
  uint64_t v63 = v22;
  uint64_t v30 = v60;
  if (v27)
  {
    uint64_t v31 = 0;
    do
    {
      uint64_t v32 = v27;
      ((void (*)(char *, uint64_t, const char *))v30)(v18, v29, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v26 + 64))(v18, v31, v66, v26);
      uint64_t v27 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  char v60 = v18;
  uint64_t v33 = v65 + 8;
  uint64_t v34 = v29;
  uint64_t v35 = *(void (**)(uint64_t, const char *))(v65 + 8);
  v35(v34, AssociatedTypeWitness);
  uint64_t v36 = v66;
  (*(void (**)(char *, void (*)(uint64_t, const char *), uint64_t))(v54 + 32))(v64, v63, v66);
  v58(v36, v26);
  uint64_t v37 = v36;
  uint64_t v38 = v56(v36, v26);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v39 = v53;
  uint64_t v65 = v33;
  uint64_t v40 = v52[0];
  uint64_t v63 = v35;
  if (v38)
  {
    uint64_t v41 = v26;
    uint64_t v42 = 0;
    uint64_t v43 = *(void (**)(uint64_t, uint64_t))(v26 + 56);
    uint64_t v57 = v26 + 56;
    uint64_t v58 = v43;
    uint64_t v55 = v26 + 64;
    uint64_t v56 = (uint64_t (*)(uint64_t, uint64_t))(v61 + 88);
    uint64_t v59 = v38;
    do
    {
      uint64_t v66 = v42 + 1;
      uint64_t v44 = v40;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v58;
      ((void (*)(uint64_t, uint64_t, uint64_t))v58)(v42, v37, v41);
      v45(v42, v37, v41);
      uint64_t v46 = v60;
      (*(void (**)(char *, char *, const char *))(v61 + 88))(v60, v39, v28);
      uint64_t v47 = v39;
      uint64_t v48 = v39;
      uint64_t v49 = v37;
      uint64_t v50 = v63;
      v63((uint64_t)v47, v28);
      v50(v44, v28);
      uint64_t v37 = v49;
      uint64_t v39 = v48;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v41 + 64))(v46, v42, v37, v41);
      uint64_t v40 = v44;
      uint64_t v42 = v66;
    }
    while (v59 != v66);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v54 + 8))(v64, v37);
}

uint64_t static SIMD<>.&* infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v63 = a2;
  uint64_t v64 = a5;
  uint64_t v65 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v53 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v53 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v56 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)&v53 - v19);
  uint64_t v22 = (void (*)(uint64_t, const char *))((char *)&v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v55 = (char *)&v53 - v24;
  uint64_t v67 = v10;
  uint64_t v25 = *(char **)(v10 + 16);
  uint64_t v57 = v23;
  uint64_t v62 = v25;
  ((void (*)(uint64_t, uint64_t, const char *))v25)(v23, a1, AssociatedTypeWitness);
  char v60 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v61 = v8 + 48;
  v60(a3, v8);
  uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v59 = v8 + 40;
  uint64_t v26 = v58(a3, v8);
  if (v26 < 0) {
    goto LABEL_10;
  }
  uint64_t v53 = v15;
  uint64_t v68 = a3;
  uint64_t v27 = v57;
  uint64_t v66 = v22;
  uint64_t v28 = v62;
  if (v26)
  {
    uint64_t v29 = 0;
    do
    {
      uint64_t v30 = v26;
      ((void (*)(char *, uint64_t, const char *))v28)(v18, v27, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v18, v29, v68, v8);
      uint64_t v26 = v30;
      ++v29;
    }
    while (v30 != v29);
  }
  uint64_t v62 = v18;
  uint64_t v31 = v67 + 8;
  uint64_t v32 = v27;
  uint64_t v33 = *(void (**)(uint64_t, const char *))(v67 + 8);
  v33(v32, AssociatedTypeWitness);
  uint64_t v34 = v55;
  uint64_t v35 = v68;
  (*(void (**)(char *, void (*)(uint64_t, const char *), uint64_t))(v56 + 32))(v55, v66, v68);
  v60(v35, v8);
  uint64_t v36 = v35;
  uint64_t v37 = v58(v35, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v38 = v8;
  uint64_t v39 = AssociatedTypeWitness;
  uint64_t v66 = v33;
  uint64_t v67 = v31;
  uint64_t v40 = v53;
  uint64_t v41 = v54;
  uint64_t v42 = v34;
  if (v37)
  {
    uint64_t v43 = 0;
    uint64_t v44 = *(void (**)(uint64_t, uint64_t))(v38 + 56);
    uint64_t v59 = v38 + 56;
    char v60 = v44;
    uint64_t v57 = v38 + 64;
    uint64_t v58 = (uint64_t (*)(uint64_t, uint64_t))(v64 + 96);
    uint64_t v61 = v37;
    do
    {
      uint64_t v68 = v43 + 1;
      uint64_t v45 = v40;
      uint64_t v46 = (void (*)(uint64_t, uint64_t, uint64_t))v60;
      ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v43, v36, v38);
      v46(v43, v36, v38);
      uint64_t v47 = v62;
      (*(void (**)(char *, char *, const char *))(v64 + 96))(v62, v45, v39);
      uint64_t v48 = v41;
      uint64_t v49 = v41;
      uint64_t v50 = v36;
      uint64_t v51 = (void (*)(char *, const char *))v66;
      v66((uint64_t)v48, v39);
      v51(v45, v39);
      uint64_t v36 = v50;
      uint64_t v41 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v38 + 64))(v47, v43, v36, v38);
      uint64_t v40 = v45;
      uint64_t v43 = v68;
    }
    while (v61 != v68);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v56 + 8))(v42, v36);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t, const char *);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(uint64_t, uint64_t);
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  char *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *);
  void v52[2];
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(uint64_t, const char *);
  char *v64;
  uint64_t v65;
  uint64_t v66;

  uint64_t v61 = a5;
  uint64_t v62 = a6;
  v52[1] = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v53 = (char *)v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)v52 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)v52 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790]((char *)v52 - v19);
  uint64_t v22 = (void (*)(uint64_t, const char *))((char *)v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v64 = (char *)v52 - v24;
  uint64_t v65 = v10;
  uint64_t v25 = *(char **)(v10 + 16);
  uint64_t v55 = v23;
  char v60 = v25;
  ((void (*)(uint64_t, uint64_t, const char *))v25)(v23, a2, AssociatedTypeWitness);
  uint64_t v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v59 = v8 + 48;
  v58(a3, v8);
  uint64_t v26 = v8;
  uint64_t v56 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v57 = v8 + 40;
  uint64_t v27 = v56(a3, v8);
  if (v27 < 0) {
    goto LABEL_10;
  }
  v52[0] = v15;
  uint64_t v66 = a3;
  uint64_t v28 = AssociatedTypeWitness;
  uint64_t v29 = v55;
  uint64_t v63 = v22;
  uint64_t v30 = v60;
  if (v27)
  {
    uint64_t v31 = 0;
    do
    {
      uint64_t v32 = v27;
      ((void (*)(char *, uint64_t, const char *))v30)(v18, v29, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v26 + 64))(v18, v31, v66, v26);
      uint64_t v27 = v32;
      ++v31;
    }
    while (v32 != v31);
  }
  char v60 = v18;
  uint64_t v33 = v65 + 8;
  uint64_t v34 = v29;
  uint64_t v35 = *(void (**)(uint64_t, const char *))(v65 + 8);
  v35(v34, AssociatedTypeWitness);
  uint64_t v36 = v66;
  (*(void (**)(char *, void (*)(uint64_t, const char *), uint64_t))(v54 + 32))(v64, v63, v66);
  v58(v36, v26);
  uint64_t v37 = v36;
  uint64_t v38 = v56(v36, v26);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v39 = v53;
  uint64_t v65 = v33;
  uint64_t v40 = v52[0];
  uint64_t v63 = v35;
  if (v38)
  {
    uint64_t v41 = v26;
    uint64_t v42 = 0;
    uint64_t v43 = *(void (**)(uint64_t, uint64_t))(v26 + 56);
    uint64_t v57 = v26 + 56;
    uint64_t v58 = v43;
    uint64_t v55 = v26 + 64;
    uint64_t v56 = (uint64_t (*)(uint64_t, uint64_t))(v61 + 96);
    uint64_t v59 = v38;
    do
    {
      uint64_t v66 = v42 + 1;
      uint64_t v44 = v40;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v58;
      ((void (*)(uint64_t, uint64_t, uint64_t))v58)(v42, v37, v41);
      v45(v42, v37, v41);
      uint64_t v46 = v60;
      (*(void (**)(char *, uint64_t, const char *))(v61 + 96))(v60, v44, v28);
      uint64_t v47 = v39;
      uint64_t v48 = v39;
      uint64_t v49 = v37;
      uint64_t v50 = v63;
      v63((uint64_t)v47, v28);
      v50(v44, v28);
      uint64_t v37 = v49;
      uint64_t v39 = v48;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v41 + 64))(v46, v42, v37, v41);
      uint64_t v40 = v44;
      uint64_t v42 = v66;
    }
    while (v59 != v66);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v54 + 8))(v64, v37);
}

uint64_t static SIMD<>./ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v69 = a5;
  uint64_t v70 = a2;
  uint64_t v72 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v59 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)&v59 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v59 - v18);
  uint64_t v21 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  unint64_t v76 = (char *)&v59 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v65 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v65(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v71 = v8 + 48;
  uint64_t v68 = v27;
  v27(a3, v8);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v67 = v8 + 40;
  uint64_t v28 = v66(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  char v60 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v63;
  uint64_t v31 = v24;
  uint64_t v73 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v65;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v73, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v73;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  uint64_t v42 = v76;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v76, v75, v37);
  v68(v37, v33);
  uint64_t v43 = v66(v37, v33);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v74 = v39;
  uint64_t v44 = v60;
  uint64_t v45 = v61;
  uint64_t v71 = v33;
  uint64_t v68 = v38;
  uint64_t v46 = v63;
  if (v43)
  {
    uint64_t v47 = v41;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v65 = (void (*)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v66 = v49;
    uint64_t v64 = v71 + 64;
    uint64_t v67 = v43;
    uint64_t v50 = v71;
    do
    {
      uint64_t v75 = v48 + 1;
      uint64_t v51 = v44;
      uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))v66;
      ((void (*)(char *, uint64_t, uint64_t))v66)(v48, v37, v50);
      v52(v48, v37, v50);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 152))(v51, v45, v47);
      uint64_t v53 = v45;
      uint64_t v54 = v45;
      uint64_t v55 = v37;
      uint64_t v56 = v46;
      uint64_t v57 = (void (*)(char *, uint64_t))v68;
      v68((uint64_t)v53, v47);
      v57(v51, v47);
      uint64_t v46 = v56;
      uint64_t v37 = v55;
      uint64_t v45 = v54;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v37, v50);
      uint64_t v44 = v51;
      uint64_t v42 = v76;
      uint64_t v48 = v75;
    }
    while ((char *)v67 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v42, v37);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  uint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v68 + 8) + 152))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(char *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  void (*v33)(char *, uint64_t, uint64_t);
  uint64_t v34;
  void (*v35)(uint64_t, uint64_t);
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  void (*v48)(uint64_t, uint64_t);
  void (*v49)(uint64_t, uint64_t, uint64_t);
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, uint64_t);
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  void (*v62)(char *, uint64_t, uint64_t);
  uint64_t (*v63)(uint64_t, uint64_t);
  uint64_t v64;
  void (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  void (*v71)(char *, uint64_t);
  uint64_t v72;
  uint64_t v73;

  uint64_t v67 = a2;
  uint64_t v68 = a5;
  uint64_t v69 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v58 = (char *)&v56 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v56 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v70 = (char *)&v56 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v56 - v18);
  uint64_t v21 = (void (*)(char *, uint64_t))((char *)&v56 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  char v60 = (char *)&v56 - v23;
  uint64_t v72 = v10;
  uint64_t v24 = v10 + 16;
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v26 = v22;
  uint64_t v28 = v27;
  uint64_t v59 = v24;
  uint64_t v62 = v25;
  ((void (*)(uint64_t, uint64_t))v25)(v22, a1);
  uint64_t v65 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v66 = v8 + 48;
  v65(a3, v8);
  uint64_t v29 = v21;
  uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v64 = v8 + 40;
  uint64_t v30 = v63(a3, v8);
  if (v30 < 0) {
    goto LABEL_10;
  }
  uint64_t v31 = v30;
  uint64_t v57 = v15;
  uint64_t v32 = v70;
  uint64_t v71 = v29;
  uint64_t v73 = a3;
  uint64_t v33 = v62;
  if (v30)
  {
    uint64_t v34 = 0;
    do
    {
      v33(v32, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v32, v34++, v73, v8);
    }
    while (v31 != v34);
  }
  uint64_t v36 = v72 + 8;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v72 + 8);
  uint64_t v37 = v28;
  v35(v26, v28);
  uint64_t v38 = v60;
  uint64_t v39 = v73;
  (*(void (**)(char *, void (*)(char *, uint64_t), uint64_t))(v61 + 32))(v60, v71, v73);
  v65(v39, v8);
  uint64_t v40 = v63(v39, v8);
  if (v40 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v41 = v35;
  uint64_t v42 = v39;
  uint64_t v71 = (void (*)(char *, uint64_t))v41;
  uint64_t v72 = v36;
  uint64_t v44 = v57;
  uint64_t v43 = v58;
  uint64_t v45 = v8;
  uint64_t v46 = v38;
  if (v40)
  {
    uint64_t v47 = 0;
    uint64_t v48 = *(void (**)(uint64_t, uint64_t))(v45 + 56);
    uint64_t v64 = v45 + 56;
    uint64_t v65 = v48;
    uint64_t v62 = (void (*)(char *, uint64_t, uint64_t))(v45 + 64);
    uint64_t v63 = (uint64_t (*)(uint64_t, uint64_t))(v68 + 192);
    uint64_t v66 = v40;
    do
    {
      uint64_t v73 = v47 + 1;
      uint64_t v49 = (void (*)(uint64_t, uint64_t, uint64_t))v65;
      ((void (*)(uint64_t, uint64_t, uint64_t))v65)(v47, v42, v45);
      v49(v47, v42, v45);
      uint64_t v50 = v70;
      (*(void (**)(char *, char *, uint64_t))(v68 + 192))(v44, v43, v37);
      uint64_t v51 = v43;
      uint64_t v52 = v43;
      uint64_t v53 = v42;
      uint64_t v54 = v71;
      v71(v51, v37);
      v54(v44, v37);
      uint64_t v42 = v53;
      uint64_t v43 = v52;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 64))(v50, v47, v42, v45);
      uint64_t v47 = v73;
    }
    while (v66 != v73);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v46, v42);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(char *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  void (*v33)(char *, uint64_t, uint64_t);
  uint64_t v34;
  void (*v35)(uint64_t, uint64_t);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  void (*v46)(uint64_t, uint64_t, uint64_t);
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  void (*v51)(char *, uint64_t);
  uint64_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(char *, uint64_t, uint64_t);
  uint64_t (*v60)(uint64_t, uint64_t);
  void (*v61)(uint64_t, uint64_t, uint64_t);
  void (*v62)(uint64_t, uint64_t);
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  void (*v67)(char *, uint64_t);
  char *v68;
  uint64_t v69;
  uint64_t v70;

  uint64_t v64 = a5;
  uint64_t v65 = a6;
  uint64_t v56 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v53 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v66 = (char *)&v53 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v58 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v53 - v18);
  uint64_t v21 = (void (*)(char *, uint64_t))((char *)&v53 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v68 = (char *)&v53 - v23;
  uint64_t v69 = v10;
  uint64_t v24 = v10 + 16;
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v26 = v22;
  uint64_t v28 = v27;
  uint64_t v57 = v24;
  uint64_t v59 = v25;
  ((void (*)(uint64_t, uint64_t))v25)(v22, a2);
  uint64_t v62 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v63 = v8 + 48;
  v62(a3, v8);
  uint64_t v29 = v21;
  char v60 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v61 = (void (*)(uint64_t, uint64_t, uint64_t))(v8 + 40);
  uint64_t v30 = v60(a3, v8);
  if (v30 < 0) {
    goto LABEL_10;
  }
  uint64_t v31 = v30;
  uint64_t v54 = v15;
  uint64_t v32 = v66;
  uint64_t v67 = v29;
  uint64_t v70 = a3;
  uint64_t v33 = v59;
  if (v30)
  {
    uint64_t v34 = 0;
    do
    {
      v33(v32, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v32, v34++, v70, v8);
    }
    while (v31 != v34);
  }
  uint64_t v36 = v69 + 8;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v69 + 8);
  uint64_t v37 = v28;
  v35(v26, v28);
  uint64_t v38 = v70;
  (*(void (**)(char *, void (*)(char *, uint64_t), uint64_t))(v58 + 32))(v68, v67, v70);
  v62(v38, v8);
  uint64_t v39 = v60(v38, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v40 = v35;
  uint64_t v41 = v38;
  uint64_t v69 = v36;
  uint64_t v42 = v55;
  uint64_t v43 = v54;
  uint64_t v67 = (void (*)(char *, uint64_t))v40;
  if (v39)
  {
    uint64_t v44 = 0;
    uint64_t v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    char v60 = (uint64_t (*)(uint64_t, uint64_t))(v64 + 192);
    uint64_t v61 = v45;
    uint64_t v62 = (void (*)(uint64_t, uint64_t))(v8 + 56);
    uint64_t v63 = v39;
    uint64_t v59 = (void (*)(char *, uint64_t, uint64_t))(v8 + 64);
    do
    {
      uint64_t v70 = v44 + 1;
      uint64_t v46 = v61;
      v61(v44, v41, v8);
      v46(v44, v41, v8);
      uint64_t v47 = v66;
      (*(void (**)(char *, char *, uint64_t))(v64 + 192))(v43, v42, v37);
      uint64_t v48 = v42;
      uint64_t v49 = v42;
      uint64_t v50 = v41;
      uint64_t v51 = v67;
      v67(v48, v37);
      v51(v43, v37);
      uint64_t v41 = v50;
      uint64_t v42 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v47, v44, v41, v8);
      uint64_t v44 = v70;
    }
    while (v63 != v70);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v58 + 8))(v68, v41);
}

uint64_t static SIMD<>.% infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v69 = a5;
  uint64_t v70 = a2;
  uint64_t v72 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v59 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v59 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)&v59 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v62 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v59 - v18);
  uint64_t v21 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  unint64_t v76 = (char *)&v59 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v65 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v65(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v71 = v8 + 48;
  uint64_t v68 = v27;
  v27(a3, v8);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v67 = v8 + 40;
  uint64_t v28 = v66(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  char v60 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v63;
  uint64_t v31 = v24;
  uint64_t v73 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v65;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v73, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v73;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  uint64_t v42 = v76;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v76, v75, v37);
  v68(v37, v33);
  uint64_t v43 = v66(v37, v33);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v74 = v39;
  uint64_t v44 = v60;
  uint64_t v45 = v61;
  uint64_t v71 = v33;
  uint64_t v68 = v38;
  uint64_t v46 = v63;
  if (v43)
  {
    uint64_t v47 = v41;
    uint64_t v48 = 0;
    uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v65 = (void (*)(uint64_t, uint64_t))(v71 + 56);
    uint64_t v66 = v49;
    uint64_t v64 = v71 + 64;
    uint64_t v67 = v43;
    uint64_t v50 = v71;
    do
    {
      uint64_t v75 = v48 + 1;
      uint64_t v51 = v44;
      uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))v66;
      ((void (*)(char *, uint64_t, uint64_t))v66)(v48, v37, v50);
      v52(v48, v37, v50);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 168))(v51, v45, v47);
      uint64_t v53 = v45;
      uint64_t v54 = v45;
      uint64_t v55 = v37;
      uint64_t v56 = v46;
      uint64_t v57 = (void (*)(char *, uint64_t))v68;
      v68((uint64_t)v53, v47);
      v57(v51, v47);
      uint64_t v46 = v56;
      uint64_t v37 = v55;
      uint64_t v45 = v54;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v50 + 64))(v46, v48, v37, v50);
      uint64_t v44 = v51;
      uint64_t v42 = v76;
      uint64_t v48 = v75;
    }
    while ((char *)v67 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v42, v37);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  uint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v68 + 8) + 168))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.&= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(v47 + 8) + 192))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.^= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(v47 + 8) + 224))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.|= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(v47 + 8) + 208))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.&<<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  uint64_t v38 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v35 = (char *)&v34 - v23;
  uint64_t v36 = v22;
  uint64_t v37 = v21 + 32;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v34 = a1;
  uint64_t v45 = v17;
  uint64_t v48 = v20;
  uint64_t v25 = v35;
  if (v24)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = v47 + 216;
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v24;
    uint64_t v39 = v7 + 64;
    uint64_t v40 = (void (**)(char *, const char *))(v49 + 8);
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(v47 + 216))(v14, v11, AssociatedTypeWitness);
      uint64_t v32 = *v40;
      (*v40)(v11, AssociatedTypeWitness);
      v32(v14, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v48, v5);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, const char *);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  void (*v37)(char *, char *, const char *);
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  void (*v42)(char *, const char *);
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  void (*v54)(char *, uint64_t, uint64_t);
  char *v55;
  uint64_t v56;
  void (*v57)(char *, const char *);
  void (*v58)(char *, uint64_t);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  void (*v66)(void);
  uint64_t v67;
  void (*v68)(char *, uint64_t, const char *);
  uint64_t v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  char *v72;
  uint64_t v73;
  char *v74;
  char *v75;
  void (*v76)(char *, const char *);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t v80;

  uint64_t v73 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v60 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v65 = (char *)&v60 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v75 = (char *)&v60 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v60 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v79 = (char *)&v60 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (void (*)(char *, const char *))((char *)&v60 - v24);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v78 = (char *)&v60 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v64 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v74 = (char *)&v60 - v30;
  uint64_t v31 = a1;
  uint64_t v66 = v29;
  uint64_t v67 = v28 + 32;
  v29();
  unint64_t v80 = v10;
  uint64_t v32 = v20;
  uint64_t v68 = *(void (**)(char *, uint64_t, const char *))(v10 + 16);
  uint64_t v69 = v10 + 16;
  v68(v20, a2, AssociatedTypeWitness);
  uint64_t v72 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v72)(a3, v8);
  uint64_t v33 = v8;
  uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v71 = v8 + 40;
  uint64_t v34 = v70(a3, v8);
  if (v34 < 0) {
    goto LABEL_10;
  }
  uint64_t v62 = v31;
  uint64_t v63 = v8 + 48;
  uint64_t v61 = v13;
  unint64_t v76 = v25;
  unint64_t v77 = a3;
  uint64_t v35 = AssociatedTypeWitness;
  uint64_t v36 = v75;
  uint64_t v37 = (void (*)(char *, char *, const char *))v68;
  if (v34)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v39 = v34;
      uint64_t v40 = v35;
      v37(v36, v32, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v36, v38, v77, v33);
      uint64_t v34 = v39;
      uint64_t v35 = v40;
      ++v38;
    }
    while (v39 != v38);
  }
  uint64_t v41 = v80 + 8;
  uint64_t v42 = *(void (**)(char *, const char *))(v80 + 8);
  uint64_t v43 = v35;
  v42(v32, v35);
  uint64_t v44 = v77;
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v66)(v78, v76, v77);
  ((void (*)(uint64_t, uint64_t))v72)(v44, v33);
  uint64_t v45 = v44;
  uint64_t v46 = v70(v44, v33);
  if (v46 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v47 = v43;
  uint64_t v48 = v33;
  uint64_t v49 = v45;
  unint64_t v80 = v41;
  uint64_t v50 = v61;
  uint64_t v51 = v65;
  unint64_t v76 = v42;
  if (v46)
  {
    uint64_t v52 = 0;
    uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v48 + 56);
    uint64_t v69 = v73 + 216;
    uint64_t v70 = v53;
    uint64_t v71 = v48 + 56;
    uint64_t v72 = (char *)v46;
    uint64_t v68 = (void (*)(char *, uint64_t, const char *))(v48 + 64);
    do
    {
      uint64_t v54 = (void (*)(char *, uint64_t, uint64_t))v70;
      ((void (*)(char *, uint64_t, uint64_t))v70)(v52, v49, v48);
      v54(v52, v49, v48);
      uint64_t v55 = v75;
      (*(void (**)(char *, char *, const char *))(v73 + 216))(v51, v50, v47);
      uint64_t v56 = v49;
      uint64_t v57 = v76;
      v76(v50, v47);
      v57(v51, v47);
      uint64_t v49 = v56;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v48 + 64))(v55, v52++, v56, v48);
    }
    while (v72 != v52);
  }
  uint64_t v58 = *(void (**)(char *, uint64_t))(v64 + 8);
  v58(v78, v49);
  v58(v74, v49);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v66)(v62, v79, v49);
}

uint64_t static SIMD<>.&>>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  uint64_t v38 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v35 = (char *)&v34 - v23;
  uint64_t v36 = v22;
  uint64_t v37 = v21 + 32;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v34 = a1;
  uint64_t v45 = v17;
  uint64_t v48 = v20;
  uint64_t v25 = v35;
  if (v24)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = v47 + 200;
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v24;
    uint64_t v39 = v7 + 64;
    uint64_t v40 = (void (**)(char *, const char *))(v49 + 8);
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(v47 + 200))(v14, v11, AssociatedTypeWitness);
      uint64_t v32 = *v40;
      (*v40)(v11, AssociatedTypeWitness);
      v32(v14, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v48, v5);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, const char *);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  void (*v37)(char *, char *, const char *);
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  void (*v42)(char *, const char *);
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  void (*v54)(char *, uint64_t, uint64_t);
  char *v55;
  uint64_t v56;
  void (*v57)(char *, const char *);
  void (*v58)(char *, uint64_t);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  void (*v66)(void);
  uint64_t v67;
  void (*v68)(char *, uint64_t, const char *);
  uint64_t v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  char *v72;
  uint64_t v73;
  char *v74;
  char *v75;
  void (*v76)(char *, const char *);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t v80;

  uint64_t v73 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v60 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v65 = (char *)&v60 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v75 = (char *)&v60 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v60 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v79 = (char *)&v60 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (void (*)(char *, const char *))((char *)&v60 - v24);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v78 = (char *)&v60 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v64 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v74 = (char *)&v60 - v30;
  uint64_t v31 = a1;
  uint64_t v66 = v29;
  uint64_t v67 = v28 + 32;
  v29();
  unint64_t v80 = v10;
  uint64_t v32 = v20;
  uint64_t v68 = *(void (**)(char *, uint64_t, const char *))(v10 + 16);
  uint64_t v69 = v10 + 16;
  v68(v20, a2, AssociatedTypeWitness);
  uint64_t v72 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v72)(a3, v8);
  uint64_t v33 = v8;
  uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v71 = v8 + 40;
  uint64_t v34 = v70(a3, v8);
  if (v34 < 0) {
    goto LABEL_10;
  }
  uint64_t v62 = v31;
  uint64_t v63 = v8 + 48;
  uint64_t v61 = v13;
  unint64_t v76 = v25;
  unint64_t v77 = a3;
  uint64_t v35 = AssociatedTypeWitness;
  uint64_t v36 = v75;
  uint64_t v37 = (void (*)(char *, char *, const char *))v68;
  if (v34)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v39 = v34;
      uint64_t v40 = v35;
      v37(v36, v32, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v36, v38, v77, v33);
      uint64_t v34 = v39;
      uint64_t v35 = v40;
      ++v38;
    }
    while (v39 != v38);
  }
  uint64_t v41 = v80 + 8;
  uint64_t v42 = *(void (**)(char *, const char *))(v80 + 8);
  uint64_t v43 = v35;
  v42(v32, v35);
  uint64_t v44 = v77;
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v66)(v78, v76, v77);
  ((void (*)(uint64_t, uint64_t))v72)(v44, v33);
  uint64_t v45 = v44;
  uint64_t v46 = v70(v44, v33);
  if (v46 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v47 = v43;
  uint64_t v48 = v33;
  uint64_t v49 = v45;
  unint64_t v80 = v41;
  uint64_t v50 = v61;
  uint64_t v51 = v65;
  unint64_t v76 = v42;
  if (v46)
  {
    uint64_t v52 = 0;
    uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v48 + 56);
    uint64_t v69 = v73 + 200;
    uint64_t v70 = v53;
    uint64_t v71 = v48 + 56;
    uint64_t v72 = (char *)v46;
    uint64_t v68 = (void (*)(char *, uint64_t, const char *))(v48 + 64);
    do
    {
      uint64_t v54 = (void (*)(char *, uint64_t, uint64_t))v70;
      ((void (*)(char *, uint64_t, uint64_t))v70)(v52, v49, v48);
      v54(v52, v49, v48);
      uint64_t v55 = v75;
      (*(void (**)(char *, char *, const char *))(v73 + 200))(v51, v50, v47);
      uint64_t v56 = v49;
      uint64_t v57 = v76;
      v76(v50, v47);
      v57(v51, v47);
      uint64_t v49 = v56;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v48 + 64))(v55, v52++, v56, v48);
    }
    while (v72 != v52);
  }
  uint64_t v58 = *(void (**)(char *, uint64_t))(v64 + 8);
  v58(v78, v49);
  v58(v74, v49);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v66)(v62, v79, v49);
}

uint64_t static SIMD<>.&+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v49 = a2;
  uint64_t v50 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v52 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v35 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v35 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  uint64_t v40 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v37 = (char *)&v35 - v23;
  uint64_t v38 = v22;
  uint64_t v39 = v21 + 32;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a1;
  uint64_t v47 = AssociatedTypeWitness;
  uint64_t v48 = v17;
  uint64_t v51 = v20;
  uint64_t v25 = v37;
  if (v24)
  {
    uint64_t v26 = v11;
    uint64_t v27 = 0;
    uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v43 = v50 + 80;
    uint64_t v44 = v28;
    uint64_t v45 = v7 + 56;
    uint64_t v46 = v24;
    uint64_t v41 = v7 + 64;
    uint64_t v42 = (void (**)(char *, const char *))(v52 + 8);
    do
    {
      uint64_t v52 = v27 + 1;
      uint64_t v29 = v14;
      uint64_t v30 = v44;
      v44(v27, a3, v7);
      v30(v27, a3, v7);
      uint64_t v31 = v47;
      uint64_t v32 = v48;
      (*(void (**)(char *, char *, const char *))(v50 + 80))(v48, v26, v47);
      uint64_t v33 = *v42;
      (*v42)(v26, v31);
      v33(v29, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v32, v27, a3, v7);
      uint64_t v14 = v29;
      uint64_t v27 = v52;
    }
    while (v46 != v52);
  }
  (*(void (**)(char *, uint64_t))(v40 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v38)(v36, v51, a3);
}

uint64_t static SIMD<>.&-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v49 = a2;
  uint64_t v50 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v52 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v35 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v35 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  uint64_t v40 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v37 = (char *)&v35 - v23;
  uint64_t v38 = v22;
  uint64_t v39 = v21 + 32;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a1;
  uint64_t v47 = AssociatedTypeWitness;
  uint64_t v48 = v17;
  uint64_t v51 = v20;
  uint64_t v25 = v37;
  if (v24)
  {
    uint64_t v26 = v11;
    uint64_t v27 = 0;
    uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v43 = v50 + 88;
    uint64_t v44 = v28;
    uint64_t v45 = v7 + 56;
    uint64_t v46 = v24;
    uint64_t v41 = v7 + 64;
    uint64_t v42 = (void (**)(char *, const char *))(v52 + 8);
    do
    {
      uint64_t v52 = v27 + 1;
      uint64_t v29 = v14;
      uint64_t v30 = v44;
      v44(v27, a3, v7);
      v30(v27, a3, v7);
      uint64_t v31 = v47;
      uint64_t v32 = v48;
      (*(void (**)(char *, char *, const char *))(v50 + 88))(v48, v26, v47);
      uint64_t v33 = *v42;
      (*v42)(v26, v31);
      v33(v29, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v32, v27, a3, v7);
      uint64_t v14 = v29;
      uint64_t v27 = v52;
    }
    while (v46 != v52);
  }
  (*(void (**)(char *, uint64_t))(v40 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v38)(v36, v51, a3);
}

uint64_t static SIMD<>.&*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v49 = a2;
  uint64_t v50 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v52 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v35 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v35 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  uint64_t v40 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v37 = (char *)&v35 - v23;
  uint64_t v38 = v22;
  uint64_t v39 = v21 + 32;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v36 = a1;
  uint64_t v47 = AssociatedTypeWitness;
  uint64_t v48 = v17;
  uint64_t v51 = v20;
  uint64_t v25 = v37;
  if (v24)
  {
    uint64_t v26 = v11;
    uint64_t v27 = 0;
    uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v43 = v50 + 96;
    uint64_t v44 = v28;
    uint64_t v45 = v7 + 56;
    uint64_t v46 = v24;
    uint64_t v41 = v7 + 64;
    uint64_t v42 = (void (**)(char *, const char *))(v52 + 8);
    do
    {
      uint64_t v52 = v27 + 1;
      uint64_t v29 = v14;
      uint64_t v30 = v44;
      v44(v27, a3, v7);
      v30(v27, a3, v7);
      uint64_t v31 = v47;
      uint64_t v32 = v48;
      (*(void (**)(char *, char *, const char *))(v50 + 96))(v48, v29, v47);
      uint64_t v33 = *v42;
      (*v42)(v26, v31);
      v33(v29, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v32, v27, a3, v7);
      uint64_t v14 = v29;
      uint64_t v27 = v52;
    }
    while (v46 != v52);
  }
  (*(void (**)(char *, uint64_t))(v40 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v38)(v36, v51, a3);
}

uint64_t static SIMD<>./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(v47 + 8) + 152))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

{
  uint64_t v5;
  uint64_t v7;
  const char *AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  char *v31;
  void (*v32)(char *, const char *);
  uint64_t v34;
  char *v35;
  void (*v36)(void);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (**v40)(char *, const char *);
  uint64_t v41;
  void (*v42)(uint64_t, uint64_t, uint64_t);
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;

  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  uint64_t v38 = v21;
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v35 = (char *)&v34 - v23;
  uint64_t v36 = v22;
  uint64_t v37 = v21 + 32;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v34 = a1;
  uint64_t v45 = v17;
  uint64_t v48 = v20;
  uint64_t v25 = v35;
  if (v24)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = v47 + 192;
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v24;
    uint64_t v39 = v7 + 64;
    uint64_t v40 = (void (**)(char *, const char *))(v49 + 8);
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(v47 + 192))(v14, v11, AssociatedTypeWitness);
      uint64_t v32 = *v40;
      (*v40)(v11, AssociatedTypeWitness);
      v32(v14, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v48, v5);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(char *, const char *);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  void (*v37)(char *, char *, const char *);
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  void (*v42)(char *, const char *);
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  void (*v54)(char *, uint64_t, uint64_t);
  char *v55;
  uint64_t v56;
  void (*v57)(char *, const char *);
  void (*v58)(char *, uint64_t);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  void (*v66)(void);
  uint64_t v67;
  void (*v68)(char *, uint64_t, const char *);
  uint64_t v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  char *v72;
  uint64_t v73;
  char *v74;
  char *v75;
  void (*v76)(char *, const char *);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t v80;

  uint64_t v73 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v60 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v65 = (char *)&v60 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v75 = (char *)&v60 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v60 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v79 = (char *)&v60 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (void (*)(char *, const char *))((char *)&v60 - v24);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v78 = (char *)&v60 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v64 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v74 = (char *)&v60 - v30;
  uint64_t v31 = a1;
  uint64_t v66 = v29;
  uint64_t v67 = v28 + 32;
  v29();
  unint64_t v80 = v10;
  uint64_t v32 = v20;
  uint64_t v68 = *(void (**)(char *, uint64_t, const char *))(v10 + 16);
  uint64_t v69 = v10 + 16;
  v68(v20, a2, AssociatedTypeWitness);
  uint64_t v72 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v72)(a3, v8);
  uint64_t v33 = v8;
  uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v71 = v8 + 40;
  uint64_t v34 = v70(a3, v8);
  if (v34 < 0) {
    goto LABEL_10;
  }
  uint64_t v62 = v31;
  uint64_t v63 = v8 + 48;
  uint64_t v61 = v13;
  unint64_t v76 = v25;
  unint64_t v77 = a3;
  uint64_t v35 = AssociatedTypeWitness;
  uint64_t v36 = v75;
  uint64_t v37 = (void (*)(char *, char *, const char *))v68;
  if (v34)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v39 = v34;
      uint64_t v40 = v35;
      v37(v36, v32, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v36, v38, v77, v33);
      uint64_t v34 = v39;
      uint64_t v35 = v40;
      ++v38;
    }
    while (v39 != v38);
  }
  uint64_t v41 = v80 + 8;
  uint64_t v42 = *(void (**)(char *, const char *))(v80 + 8);
  uint64_t v43 = v35;
  v42(v32, v35);
  uint64_t v44 = v77;
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v66)(v78, v76, v77);
  ((void (*)(uint64_t, uint64_t))v72)(v44, v33);
  uint64_t v45 = v44;
  uint64_t v46 = v70(v44, v33);
  if (v46 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v47 = v43;
  uint64_t v48 = v33;
  uint64_t v49 = v45;
  unint64_t v80 = v41;
  uint64_t v50 = v61;
  uint64_t v51 = v65;
  unint64_t v76 = v42;
  if (v46)
  {
    uint64_t v52 = 0;
    uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v48 + 56);
    uint64_t v69 = v73 + 192;
    uint64_t v70 = v53;
    uint64_t v71 = v48 + 56;
    uint64_t v72 = (char *)v46;
    uint64_t v68 = (void (*)(char *, uint64_t, const char *))(v48 + 64);
    do
    {
      uint64_t v54 = (void (*)(char *, uint64_t, uint64_t))v70;
      ((void (*)(char *, uint64_t, uint64_t))v70)(v52, v49, v48);
      v54(v52, v49, v48);
      uint64_t v55 = v75;
      (*(void (**)(char *, char *, const char *))(v73 + 192))(v51, v50, v47);
      uint64_t v56 = v49;
      uint64_t v57 = v76;
      v76(v50, v47);
      v57(v51, v47);
      uint64_t v49 = v56;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v48 + 64))(v55, v52++, v56, v48);
    }
    while (v72 != v52);
  }
  uint64_t v58 = *(void (**)(char *, uint64_t))(v64 + 8);
  v58(v78, v49);
  v58(v74, v49);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v66)(v62, v79, v49);
}

uint64_t static SIMD<>.%= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(v47 + 8) + 168))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.&= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v60 = (char *)&v57 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v72 = (char *)&v57 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v57 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  unint64_t v76 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v57 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v57 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = *(void (**)(void))(v19 + 32);
  uint64_t v71 = (char *)&v57 - v28;
  uint64_t v29 = a1;
  uint64_t v63 = v27;
  uint64_t v64 = v19 + 32;
  v27();
  uint64_t v77 = v9;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v18;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v31 = v30;
  v30(v18, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v32 = v66(a3, v7);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v19;
  uint64_t v59 = v29;
  uint64_t v33 = v65;
  uint64_t v34 = v7;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v24;
  uint64_t v36 = v62;
  if (v32)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v32;
      uint64_t v39 = v36;
      uint64_t v40 = v33;
      v31(v35, v36, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v35, v37, v73, v34);
      uint64_t v36 = v39;
      uint64_t v33 = v40;
      uint64_t v32 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v33);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v34);
  uint64_t v44 = v41;
  uint64_t v45 = v66(v41, v34);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v46 = v34;
  uint64_t v77 = v42;
  uint64_t v48 = v60;
  uint64_t v47 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v45)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v46 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v46 + 64);
    uint64_t v69 = v45;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v44, v46);
      v51(v50, v44, v46);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(v70 + 8) + 192))(v48, v47, v49);
      uint64_t v53 = v44;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v44 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v52, v50++, v53, v46);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v44);
  v55(v71, v44);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v59, v76, v44);
}

uint64_t static SIMD<>.^= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v60 = (char *)&v57 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v72 = (char *)&v57 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v57 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  unint64_t v76 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v57 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v57 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = *(void (**)(void))(v19 + 32);
  uint64_t v71 = (char *)&v57 - v28;
  uint64_t v29 = a1;
  uint64_t v63 = v27;
  uint64_t v64 = v19 + 32;
  v27();
  uint64_t v77 = v9;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v18;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v31 = v30;
  v30(v18, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v32 = v66(a3, v7);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v19;
  uint64_t v59 = v29;
  uint64_t v33 = v65;
  uint64_t v34 = v7;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v24;
  uint64_t v36 = v62;
  if (v32)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v32;
      uint64_t v39 = v36;
      uint64_t v40 = v33;
      v31(v35, v36, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v35, v37, v73, v34);
      uint64_t v36 = v39;
      uint64_t v33 = v40;
      uint64_t v32 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v33);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v34);
  uint64_t v44 = v41;
  uint64_t v45 = v66(v41, v34);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v46 = v34;
  uint64_t v77 = v42;
  uint64_t v48 = v60;
  uint64_t v47 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v45)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v46 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v46 + 64);
    uint64_t v69 = v45;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v44, v46);
      v51(v50, v44, v46);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(v70 + 8) + 224))(v48, v47, v49);
      uint64_t v53 = v44;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v44 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v52, v50++, v53, v46);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v44);
  v55(v71, v44);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v59, v76, v44);
}

uint64_t static SIMD<>.|= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v60 = (char *)&v57 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v72 = (char *)&v57 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v57 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  unint64_t v76 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v57 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v57 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = *(void (**)(void))(v19 + 32);
  uint64_t v71 = (char *)&v57 - v28;
  uint64_t v29 = a1;
  uint64_t v63 = v27;
  uint64_t v64 = v19 + 32;
  v27();
  uint64_t v77 = v9;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v18;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v31 = v30;
  v30(v18, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v32 = v66(a3, v7);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v19;
  uint64_t v59 = v29;
  uint64_t v33 = v65;
  uint64_t v34 = v7;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v24;
  uint64_t v36 = v62;
  if (v32)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v32;
      uint64_t v39 = v36;
      uint64_t v40 = v33;
      v31(v35, v36, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v35, v37, v73, v34);
      uint64_t v36 = v39;
      uint64_t v33 = v40;
      uint64_t v32 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v33);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v34);
  uint64_t v44 = v41;
  uint64_t v45 = v66(v41, v34);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v46 = v34;
  uint64_t v77 = v42;
  uint64_t v48 = v60;
  uint64_t v47 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v45)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v46 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v46 + 64);
    uint64_t v69 = v45;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v44, v46);
      v51(v50, v44, v46);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(v70 + 8) + 208))(v48, v47, v49);
      uint64_t v53 = v44;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v44 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v52, v50++, v53, v46);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v44);
  v55(v71, v44);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v59, v76, v44);
}

uint64_t static SIMD<>.&+= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v68 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v59 = (char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v58 = (char *)&v55 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v70 = (char *)&v55 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v55 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v74 = (char *)&v55 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v55 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v73 = (char *)&v55 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v57 = v27;
  uint64_t v28 = *(void (**)(void))(v27 + 32);
  uint64_t v69 = (char *)&v55 - v29;
  uint64_t v61 = v28;
  uint64_t v62 = v27 + 32;
  v28();
  uint64_t v75 = v10;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v10 + 16);
  uint64_t v63 = v10 + 16;
  char v60 = v30;
  v30(v19, a2, AssociatedTypeWitness);
  uint64_t v66 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v67 = v8 + 48;
  v66(a3, v8);
  uint64_t v64 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v65 = (void (*)(uint64_t, uint64_t, uint64_t))(v8 + 40);
  uint64_t v31 = v64(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v56 = a1;
  uint64_t v32 = AssociatedTypeWitness;
  uint64_t v71 = v24;
  uint64_t v72 = a3;
  uint64_t v33 = v70;
  uint64_t v34 = v60;
  if (v31)
  {
    uint64_t v35 = 0;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      v34(v33, v19, v32);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35, v72, v8);
      uint64_t v31 = v36;
      uint64_t v32 = v37;
      ++v35;
    }
    while (v36 != v35);
  }
  uint64_t v38 = v75 + 8;
  uint64_t v39 = v19;
  uint64_t v40 = *(void (**)(char *, const char *))(v75 + 8);
  uint64_t v41 = v32;
  v40(v39, v32);
  uint64_t v42 = v72;
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v61)(v73, v71, v72);
  v66(v42, v8);
  uint64_t v43 = v64(v42, v8);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v44 = v8;
  uint64_t v75 = v38;
  uint64_t v45 = v58;
  uint64_t v46 = v59;
  uint64_t v71 = v40;
  if (v43)
  {
    uint64_t v47 = 0;
    uint64_t v48 = *(void (**)(uint64_t, uint64_t, uint64_t))(v44 + 56);
    uint64_t v64 = (uint64_t (*)(uint64_t, uint64_t))(v68 + 80);
    uint64_t v65 = v48;
    uint64_t v66 = (void (*)(uint64_t, uint64_t))(v44 + 56);
    uint64_t v67 = v43;
    uint64_t v63 = v44 + 64;
    do
    {
      uint64_t v49 = v65;
      v65(v47, v42, v44);
      v49(v47, v42, v44);
      uint64_t v50 = v70;
      (*(void (**)(char *, char *, const char *))(v68 + 80))(v70, v46, v41);
      uint64_t v51 = v42;
      uint64_t v52 = v71;
      v71(v46, v41);
      v52(v45, v41);
      uint64_t v42 = v51;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v50, v47++, v51, v44);
    }
    while (v67 != v47);
  }
  uint64_t v53 = *(void (**)(char *, uint64_t))(v57 + 8);
  v53(v73, v42);
  v53(v69, v42);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v61)(v56, v74, v42);
}

uint64_t static SIMD<>.&-= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v68 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v59 = (char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v58 = (char *)&v55 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v70 = (char *)&v55 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v55 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v74 = (char *)&v55 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v55 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v73 = (char *)&v55 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v57 = v27;
  uint64_t v28 = *(void (**)(void))(v27 + 32);
  uint64_t v69 = (char *)&v55 - v29;
  uint64_t v61 = v28;
  uint64_t v62 = v27 + 32;
  v28();
  uint64_t v75 = v10;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v10 + 16);
  uint64_t v63 = v10 + 16;
  char v60 = v30;
  v30(v19, a2, AssociatedTypeWitness);
  uint64_t v66 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v67 = v8 + 48;
  v66(a3, v8);
  uint64_t v64 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v65 = (void (*)(uint64_t, uint64_t, uint64_t))(v8 + 40);
  uint64_t v31 = v64(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v56 = a1;
  uint64_t v32 = AssociatedTypeWitness;
  uint64_t v71 = v24;
  uint64_t v72 = a3;
  uint64_t v33 = v70;
  uint64_t v34 = v60;
  if (v31)
  {
    uint64_t v35 = 0;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      v34(v33, v19, v32);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35, v72, v8);
      uint64_t v31 = v36;
      uint64_t v32 = v37;
      ++v35;
    }
    while (v36 != v35);
  }
  uint64_t v38 = v75 + 8;
  uint64_t v39 = v19;
  uint64_t v40 = *(void (**)(char *, const char *))(v75 + 8);
  uint64_t v41 = v32;
  v40(v39, v32);
  uint64_t v42 = v72;
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v61)(v73, v71, v72);
  v66(v42, v8);
  uint64_t v43 = v64(v42, v8);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v44 = v8;
  uint64_t v75 = v38;
  uint64_t v45 = v58;
  uint64_t v46 = v59;
  uint64_t v71 = v40;
  if (v43)
  {
    uint64_t v47 = 0;
    uint64_t v48 = *(void (**)(uint64_t, uint64_t, uint64_t))(v44 + 56);
    uint64_t v64 = (uint64_t (*)(uint64_t, uint64_t))(v68 + 88);
    uint64_t v65 = v48;
    uint64_t v66 = (void (*)(uint64_t, uint64_t))(v44 + 56);
    uint64_t v67 = v43;
    uint64_t v63 = v44 + 64;
    do
    {
      uint64_t v49 = v65;
      v65(v47, v42, v44);
      v49(v47, v42, v44);
      uint64_t v50 = v70;
      (*(void (**)(char *, char *, const char *))(v68 + 88))(v70, v46, v41);
      uint64_t v51 = v42;
      uint64_t v52 = v71;
      v71(v46, v41);
      v52(v45, v41);
      uint64_t v42 = v51;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v50, v47++, v51, v44);
    }
    while (v67 != v47);
  }
  uint64_t v53 = *(void (**)(char *, uint64_t))(v57 + 8);
  v53(v73, v42);
  v53(v69, v42);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v61)(v56, v74, v42);
}

uint64_t static SIMD<>.&*= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v68 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v59 = (char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v58 = (char *)&v55 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v70 = (char *)&v55 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v55 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v74 = (char *)&v55 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v55 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v73 = (char *)&v55 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v57 = v27;
  uint64_t v28 = *(void (**)(void))(v27 + 32);
  uint64_t v69 = (char *)&v55 - v29;
  uint64_t v61 = v28;
  uint64_t v62 = v27 + 32;
  v28();
  uint64_t v75 = v10;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v10 + 16);
  uint64_t v63 = v10 + 16;
  char v60 = v30;
  v30(v19, a2, AssociatedTypeWitness);
  uint64_t v66 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v67 = v8 + 48;
  v66(a3, v8);
  uint64_t v64 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v65 = (void (*)(uint64_t, uint64_t, uint64_t))(v8 + 40);
  uint64_t v31 = v64(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v56 = a1;
  uint64_t v32 = AssociatedTypeWitness;
  uint64_t v71 = v24;
  uint64_t v72 = a3;
  uint64_t v33 = v70;
  uint64_t v34 = v60;
  if (v31)
  {
    uint64_t v35 = 0;
    do
    {
      uint64_t v36 = v31;
      uint64_t v37 = v32;
      v34(v33, v19, v32);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35, v72, v8);
      uint64_t v31 = v36;
      uint64_t v32 = v37;
      ++v35;
    }
    while (v36 != v35);
  }
  uint64_t v38 = v75 + 8;
  uint64_t v39 = v19;
  uint64_t v40 = *(void (**)(char *, const char *))(v75 + 8);
  uint64_t v41 = v32;
  v40(v39, v32);
  uint64_t v42 = v72;
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v61)(v73, v71, v72);
  v66(v42, v8);
  uint64_t v43 = v64(v42, v8);
  if (v43 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v44 = v8;
  uint64_t v75 = v38;
  uint64_t v45 = v58;
  uint64_t v46 = v59;
  uint64_t v71 = v40;
  if (v43)
  {
    uint64_t v47 = 0;
    uint64_t v48 = *(void (**)(uint64_t, uint64_t, uint64_t))(v44 + 56);
    uint64_t v64 = (uint64_t (*)(uint64_t, uint64_t))(v68 + 96);
    uint64_t v65 = v48;
    uint64_t v66 = (void (*)(uint64_t, uint64_t))(v44 + 56);
    uint64_t v67 = v43;
    uint64_t v63 = v44 + 64;
    do
    {
      uint64_t v49 = v65;
      v65(v47, v42, v44);
      v49(v47, v42, v44);
      uint64_t v50 = v70;
      (*(void (**)(char *, char *, const char *))(v68 + 96))(v70, v45, v41);
      uint64_t v51 = v42;
      uint64_t v52 = v71;
      v71(v46, v41);
      v52(v45, v41);
      uint64_t v42 = v51;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v50, v47++, v51, v44);
    }
    while (v67 != v47);
  }
  uint64_t v53 = *(void (**)(char *, uint64_t))(v57 + 8);
  v53(v73, v42);
  v53(v69, v42);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v61)(v56, v74, v42);
}

uint64_t static SIMD<>./= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v60 = (char *)&v57 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v72 = (char *)&v57 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v57 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  unint64_t v76 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v57 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v57 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = *(void (**)(void))(v19 + 32);
  uint64_t v71 = (char *)&v57 - v28;
  uint64_t v29 = a1;
  uint64_t v63 = v27;
  uint64_t v64 = v19 + 32;
  v27();
  uint64_t v77 = v9;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v18;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v31 = v30;
  v30(v18, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v32 = v66(a3, v7);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v19;
  uint64_t v59 = v29;
  uint64_t v33 = v65;
  uint64_t v34 = v7;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v24;
  uint64_t v36 = v62;
  if (v32)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v32;
      uint64_t v39 = v36;
      uint64_t v40 = v33;
      v31(v35, v36, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v35, v37, v73, v34);
      uint64_t v36 = v39;
      uint64_t v33 = v40;
      uint64_t v32 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v33);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v34);
  uint64_t v44 = v41;
  uint64_t v45 = v66(v41, v34);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v46 = v34;
  uint64_t v77 = v42;
  uint64_t v48 = v60;
  uint64_t v47 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v45)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v46 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v46 + 64);
    uint64_t v69 = v45;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v44, v46);
      v51(v50, v44, v46);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(v70 + 8) + 152))(v48, v47, v49);
      uint64_t v53 = v44;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v44 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v52, v50++, v53, v46);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v44);
  v55(v71, v44);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v59, v76, v44);
}

uint64_t static SIMD<>.%= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v60 = (char *)&v57 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v72 = (char *)&v57 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v57 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  unint64_t v76 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v57 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v57 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = *(void (**)(void))(v19 + 32);
  uint64_t v71 = (char *)&v57 - v28;
  uint64_t v29 = a1;
  uint64_t v63 = v27;
  uint64_t v64 = v19 + 32;
  v27();
  uint64_t v77 = v9;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v18;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v31 = v30;
  v30(v18, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v32 = v66(a3, v7);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v19;
  uint64_t v59 = v29;
  uint64_t v33 = v65;
  uint64_t v34 = v7;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v24;
  uint64_t v36 = v62;
  if (v32)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v32;
      uint64_t v39 = v36;
      uint64_t v40 = v33;
      v31(v35, v36, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v35, v37, v73, v34);
      uint64_t v36 = v39;
      uint64_t v33 = v40;
      uint64_t v32 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v33);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v34);
  uint64_t v44 = v41;
  uint64_t v45 = v66(v41, v34);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v46 = v34;
  uint64_t v77 = v42;
  uint64_t v48 = v60;
  uint64_t v47 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v45)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v46 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v46 + 64);
    uint64_t v69 = v45;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v44, v46);
      v51(v50, v44, v46);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(v70 + 8) + 168))(v48, v47, v49);
      uint64_t v53 = v44;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v44 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v52, v50++, v53, v46);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v44);
  v55(v71, v44);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v59, v76, v44);
}

void static SIMD<>.+ infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4CBuLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4DAuLL, 0);
}

void static SIMD<>.- infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4D0uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4DFuLL, 0);
}

void static SIMD<>.* infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4D5uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4E4uLL, 0);
}

void static SIMD<>.+= infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4F8uLL, 0);
}

void static SIMD<>.-= infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4FDuLL, 0);
}

void static SIMD<>.*= infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x502uLL, 0);
}

uint64_t static SIMD<>.- prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v82 = a1;
  uint64_t v85 = a4;
  uint64_t v76 = *(void *)(a2 - 8);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v88 = (char *)&v70 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v6);
  uint64_t v84 = (char *)&v70 - v8;
  uint64_t v75 = *(int ***)(v9 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v75, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v70 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v74 = (char *)&v70 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v83 = (char *)&v70 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v70 - v20;
  MEMORY[0x1F4188790](v19);
  uint64_t v23 = (char *)&v70 - v22;
  uint64_t v73 = *(void *)(*(void *)(a3 + 16) + 8);
  uint64_t v24 = *(void *)(v73 + 16);
  uint64_t v25 = swift_getAssociatedTypeWitness(0, (int **)v24, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = (char *)&v70 - v26;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v24, (uint64_t)AssociatedTypeWitness, (uint64_t)v25, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v25, AssociatedConformanceWitness);
  (*(void (**)(char *, const char *, uint64_t))(v24 + 24))(v27, AssociatedTypeWitness, v24);
  uint64_t v87 = v11;
  uint64_t v29 = (int *)(v11 + 16);
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v11 + 16);
  uint64_t v31 = v21;
  uint64_t v32 = v21;
  uint64_t v33 = AssociatedTypeWitness;
  uint64_t v34 = AssociatedTypeWitness;
  uint64_t v35 = v75;
  uint64_t v77 = v30;
  uint64_t v78 = v29;
  v30(v32, v23, v34);
  uint64_t v81 = v35[6];
  ((void (*)(uint64_t, int **))v81)(a2, v35);
  uint64_t v79 = v35[5];
  unint64_t v80 = (char *)(v35 + 5);
  uint64_t v36 = ((uint64_t (*)(uint64_t, int **))v79)(a2, v35);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v71 = v14;
  uint64_t v72 = v35 + 6;
  uint64_t v70 = v23;
  uint64_t v37 = v33;
  uint64_t v38 = v83;
  uint64_t v86 = a2;
  uint64_t v39 = v31;
  uint64_t v40 = v77;
  uint64_t v41 = v35;
  if (v36)
  {
    uint64_t v42 = 0;
    do
    {
      uint64_t v43 = v36;
      uint64_t v44 = v37;
      v40(v38, v39, v37);
      ((void (*)(char *, uint64_t, uint64_t, int **))v41[8])(v38, v42, v86, v41);
      uint64_t v36 = v43;
      uint64_t v37 = v44;
      ++v42;
    }
    while (v43 != v42);
  }
  uint64_t v45 = v86;
  uint64_t v46 = v87 + 8;
  uint64_t v47 = *(int **)(v87 + 8);
  uint64_t v48 = v39;
  uint64_t v49 = v37;
  ((void (*)(char *, const char *))v47)(v48, v37);
  uint64_t v50 = v84;
  (*(void (**)(char *, char *, uint64_t))(v76 + 32))(v84, v88, v45);
  ((void (*)(uint64_t, int **))v81)(v45, v41);
  uint64_t v51 = v45;
  uint64_t v52 = ((uint64_t (*)(uint64_t, int **))v79)(v45, v41);
  if (v52 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v53 = v52;
  ((void (*)(char *, const char *))v47)(v70, v49);
  uint64_t v54 = v50;
  uint64_t v87 = v46;
  uint64_t v55 = v71;
  uint64_t v81 = v47;
  uint64_t v57 = v73;
  uint64_t v56 = v74;
  if (v53)
  {
    uint64_t v58 = v41;
    uint64_t v59 = v49;
    char v60 = 0;
    uint64_t v78 = v58[7];
    uint64_t v79 = (int *)(v58 + 7);
    uint64_t v77 = (void (*)(char *, char *, const char *))(v58 + 8);
    unint64_t v80 = (char *)v53;
    do
    {
      uint64_t v88 = v60 + 1;
      uint64_t v61 = v56;
      uint64_t v62 = v78;
      ((void (*)(char *, uint64_t, int **))v78)(v60, v51, v58);
      ((void (*)(char *, uint64_t, int **))v62)(v60, v51, v58);
      uint64_t v63 = *(void (**)(char *, char *, const char *))(*(void *)(v57 + 8) + 40);
      uint64_t v64 = v51;
      uint64_t v65 = v57;
      uint64_t v66 = v83;
      v63(v61, v55, v59);
      uint64_t v67 = v81;
      ((void (*)(char *, const char *))v81)(v55, v59);
      ((void (*)(char *, const char *))v67)(v61, v59);
      uint64_t v68 = v66;
      uint64_t v57 = v65;
      uint64_t v51 = v64;
      ((void (*)(char *, char *, uint64_t, int **))v58[8])(v68, v60, v64, v58);
      uint64_t v56 = v61;
      uint64_t v54 = v84;
      char v60 = v88;
    }
    while (v80 != v88);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v76 + 8))(v54, v51);
}

uint64_t static SIMD<>.- infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v68 = a5;
  uint64_t v69 = a2;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v75 = (char *)&v58 - v23;
  uint64_t v73 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v74 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  if (v28)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v28;
      uint64_t v35 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v30, v33, v72, v8);
      uint64_t v28 = v34;
      uint64_t v29 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v36 = v72;
  uint64_t v38 = v73 + 8;
  uint64_t v37 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
  uint64_t v39 = v31;
  uint64_t v40 = v29;
  v37(v39, v29);
  uint64_t v41 = v75;
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v75, v74, v36);
  v67(v36, v8);
  uint64_t v42 = v65(v36, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v73 = v38;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v70 = v8;
  uint64_t v67 = v37;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v40;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v74 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v36, v49);
      v51(v47, v36, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(*(void *)(v68 + 16) + 8) + 8)
                                                      + 40))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v36;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v36 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v36, v49);
      uint64_t v43 = v50;
      uint64_t v41 = v75;
      uint64_t v47 = v74;
    }
    while ((char *)v66 != v74);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v41, v36);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  uint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(*(void *)(v68 + 16) + 8) + 8)
                                                      + 40))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.+ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v68 = a5;
  uint64_t v69 = a2;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v75 = (char *)&v58 - v23;
  uint64_t v73 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v74 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  if (v28)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v28;
      uint64_t v35 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v30, v33, v72, v8);
      uint64_t v28 = v34;
      uint64_t v29 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v36 = v72;
  uint64_t v38 = v73 + 8;
  uint64_t v37 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
  uint64_t v39 = v31;
  uint64_t v40 = v29;
  v37(v39, v29);
  uint64_t v41 = v75;
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v75, v74, v36);
  v67(v36, v8);
  uint64_t v42 = v65(v36, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v73 = v38;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v70 = v8;
  uint64_t v67 = v37;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v40;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v74 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v36, v49);
      v51(v47, v36, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(*(void *)(v68 + 16) + 8) + 8)
                                                      + 24))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v36;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v36 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v36, v49);
      uint64_t v43 = v50;
      uint64_t v41 = v75;
      uint64_t v47 = v74;
    }
    while ((char *)v66 != v74);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v41, v36);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  uint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(*(void *)(v68 + 16) + 8) + 8)
                                                      + 24))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.* infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v68 = a5;
  uint64_t v69 = a2;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v75 = (char *)&v58 - v23;
  uint64_t v73 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a1);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v74 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  if (v28)
  {
    uint64_t v33 = 0;
    do
    {
      uint64_t v34 = v28;
      uint64_t v35 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v30, v33, v72, v8);
      uint64_t v28 = v34;
      uint64_t v29 = v35;
      ++v33;
    }
    while (v34 != v33);
  }
  uint64_t v36 = v72;
  uint64_t v38 = v73 + 8;
  uint64_t v37 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
  uint64_t v39 = v31;
  uint64_t v40 = v29;
  v37(v39, v29);
  uint64_t v41 = v75;
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v75, v74, v36);
  v67(v36, v8);
  uint64_t v42 = v65(v36, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v73 = v38;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v70 = v8;
  uint64_t v67 = v37;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v40;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v74 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v36, v49);
      v51(v47, v36, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 16) + 8) + 64))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v36;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v36 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v36, v49);
      uint64_t v43 = v50;
      uint64_t v41 = v75;
      uint64_t v47 = v74;
    }
    while ((char *)v66 != v74);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v41, v36);
}

{
  uint64_t v8;
  const char *AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  void (*v56)(char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;

  uint64_t v68 = a5;
  uint64_t v69 = a1;
  uint64_t v71 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v60 = (char *)&v58 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v58 - v14;
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v62 = (char *)&v58 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v61 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1F4188790]((char *)&v58 - v18);
  uint64_t v21 = (char *)&v58 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v73 = (char *)&v58 - v23;
  uint64_t v74 = v10;
  uint64_t v24 = v22;
  uint64_t v26 = v25;
  uint64_t v64 = *(void (**)(uint64_t, uint64_t))(v10 + 16);
  v64(v22, a2);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  uint64_t v70 = v8 + 48;
  uint64_t v67 = v27;
  v27(a3, v8);
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v66 = v8 + 40;
  uint64_t v28 = v65(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v59 = v15;
  uint64_t v29 = v26;
  uint64_t v30 = v62;
  uint64_t v31 = v24;
  uint64_t v72 = a3;
  uint64_t v75 = v21;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v64;
  uint64_t v33 = v8;
  if (v28)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = v28;
      uint64_t v36 = v29;
      v32(v30, v31, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v33 + 64))(v30, v34, v72, v33);
      uint64_t v28 = v35;
      uint64_t v29 = v36;
      ++v34;
    }
    while (v35 != v34);
  }
  uint64_t v37 = v72;
  uint64_t v39 = v74 + 8;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v74 + 8);
  uint64_t v40 = v31;
  uint64_t v41 = v29;
  v38(v40, v29);
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v73, v75, v37);
  v67(v37, v33);
  uint64_t v42 = v65(v37, v33);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v70 = v33;
  uint64_t v74 = v39;
  uint64_t v43 = v59;
  uint64_t v44 = v60;
  uint64_t v67 = v38;
  uint64_t v45 = v62;
  if (v42)
  {
    uint64_t v46 = v41;
    uint64_t v47 = 0;
    uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v64 = (void (*)(uint64_t, uint64_t))(v70 + 56);
    uint64_t v65 = v48;
    uint64_t v63 = v70 + 64;
    uint64_t v66 = v42;
    uint64_t v49 = v70;
    do
    {
      uint64_t v75 = v47 + 1;
      uint64_t v50 = v43;
      uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))v65;
      ((void (*)(char *, uint64_t, uint64_t))v65)(v47, v37, v49);
      v51(v47, v37, v49);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 16) + 8) + 64))(v50, v44, v46);
      uint64_t v52 = v44;
      uint64_t v53 = v44;
      uint64_t v54 = v37;
      uint64_t v55 = v45;
      uint64_t v56 = (void (*)(char *, uint64_t))v67;
      v67((uint64_t)v52, v46);
      v56(v50, v46);
      uint64_t v45 = v55;
      uint64_t v37 = v54;
      uint64_t v44 = v53;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v49 + 64))(v45, v47, v37, v49);
      uint64_t v43 = v50;
      uint64_t v47 = v75;
    }
    while ((char *)v66 != v75);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v61 + 8))(v73, v37);
}

uint64_t static SIMD<>.+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(*(void *)(v47 + 16) + 8) + 8)
                                                           + 24))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(*(void *)(v47 + 16) + 8) + 8)
                                                           + 40))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a2;
  uint64_t v47 = a5;
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v34 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v39 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v37 = *(void (**)(void))(v20 + 32);
  uint64_t v38 = v20 + 32;
  v37();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v35 = a1;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v45 = v16;
  uint64_t v48 = v19;
  uint64_t v25 = v22;
  if (v23)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v41 = (void (**)(char *, const char *))(v49 + 8);
    uint64_t v42 = v27;
    uint64_t v43 = v7 + 56;
    uint64_t v44 = v23;
    uint64_t v40 = v7 + 64;
    do
    {
      uint64_t v49 = v26 + 1;
      uint64_t v28 = v5;
      uint64_t v29 = v5;
      uint64_t v30 = v42;
      v42(v26, v29, v7);
      v30(v26, v28, v7);
      uint64_t v31 = v45;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(v47 + 16) + 8) + 64))(v13, v10, v24);
      uint64_t v32 = *v41;
      (*v41)(v10, v24);
      v32(v13, v24);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v31, v26, v28, v7);
      uint64_t v5 = v28;
      uint64_t v26 = v49;
    }
    while (v44 != v49);
  }
  (*(void (**)(char *, uint64_t))(v39 + 8))(v25, v5);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v5);
}

uint64_t static SIMD<>.+= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v61 = (char *)&v57 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v72 = (char *)&v57 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v57 - v18;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = MEMORY[0x1F4188790](v17);
  uint64_t v76 = (char *)&v57 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (void (*)(char *, const char *))((char *)&v57 - v24);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v75 = (char *)&v57 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v28 = *(void (**)(void))(v20 + 32);
  uint64_t v71 = (char *)&v57 - v29;
  uint64_t v30 = a1;
  uint64_t v63 = v28;
  uint64_t v64 = v20 + 32;
  v28();
  uint64_t v77 = v9;
  uint64_t v31 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v19;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v32 = v31;
  v31(v19, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v33 = v66(a3, v7);
  if (v33 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v20;
  uint64_t v59 = v12;
  uint64_t v60 = v30;
  uint64_t v34 = v65;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v25;
  uint64_t v36 = v62;
  if (v33)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v33;
      uint64_t v39 = v36;
      uint64_t v40 = v34;
      v32(v35, v36, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v35, v37, v73, v7);
      uint64_t v36 = v39;
      uint64_t v34 = v40;
      uint64_t v33 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v7;
  uint64_t v44 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v34);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v42);
  uint64_t v45 = v41;
  uint64_t v46 = v66(v41, v42);
  if (v46 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v77 = v44;
  uint64_t v47 = v59;
  uint64_t v48 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v46)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v42 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v42 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v42 + 64);
    uint64_t v69 = v46;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v45, v42);
      v51(v50, v45, v42);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(*(void *)(v70 + 16) + 8) + 8)
                                                           + 24))(v48, v47, v49);
      uint64_t v53 = v45;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v45 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v42 + 64))(v52, v50++, v53, v42);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v45);
  v55(v71, v45);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v60, v76, v45);
}

uint64_t static SIMD<>.-= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v61 = (char *)&v57 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v72 = (char *)&v57 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v57 - v18;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = MEMORY[0x1F4188790](v17);
  uint64_t v76 = (char *)&v57 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (void (*)(char *, const char *))((char *)&v57 - v24);
  uint64_t v26 = MEMORY[0x1F4188790](v23);
  uint64_t v75 = (char *)&v57 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v28 = *(void (**)(void))(v20 + 32);
  uint64_t v71 = (char *)&v57 - v29;
  uint64_t v30 = a1;
  uint64_t v63 = v28;
  uint64_t v64 = v20 + 32;
  v28();
  uint64_t v77 = v9;
  uint64_t v31 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v19;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v32 = v31;
  v31(v19, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v33 = v66(a3, v7);
  if (v33 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v20;
  uint64_t v59 = v12;
  uint64_t v60 = v30;
  uint64_t v34 = v65;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v25;
  uint64_t v36 = v62;
  if (v33)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v33;
      uint64_t v39 = v36;
      uint64_t v40 = v34;
      v32(v35, v36, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v35, v37, v73, v7);
      uint64_t v36 = v39;
      uint64_t v34 = v40;
      uint64_t v33 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v7;
  uint64_t v44 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v34);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v42);
  uint64_t v45 = v41;
  uint64_t v46 = v66(v41, v42);
  if (v46 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v77 = v44;
  uint64_t v47 = v59;
  uint64_t v48 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v46)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v42 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v42 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v42 + 64);
    uint64_t v69 = v46;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v45, v42);
      v51(v50, v45, v42);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(*(void *)(v70 + 16) + 8) + 8)
                                                           + 40))(v48, v47, v49);
      uint64_t v53 = v45;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v45 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v42 + 64))(v52, v50++, v53, v42);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v45);
  v55(v71, v45);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v60, v76, v45);
}

uint64_t static SIMD<>.*= infix(_:_:)(uint64_t a1, void (*a2)(char *, const char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = a5;
  uint64_t v74 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v57 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v60 = (char *)&v57 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v72 = (char *)&v57 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v57 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v16);
  uint64_t v76 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (void (*)(char *, const char *))((char *)&v57 - v23);
  uint64_t v25 = MEMORY[0x1F4188790](v22);
  uint64_t v75 = (char *)&v57 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v27 = *(void (**)(void))(v19 + 32);
  uint64_t v71 = (char *)&v57 - v28;
  uint64_t v29 = a1;
  uint64_t v63 = v27;
  uint64_t v64 = v19 + 32;
  v27();
  uint64_t v77 = v9;
  uint64_t v30 = *(void (**)(char *, char *, const char *))(v9 + 16);
  uint64_t v62 = v18;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v31 = v30;
  v30(v18, (char *)v74, AssociatedTypeWitness);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
  uint64_t v69 = v7 + 48;
  v68(a3, v7);
  uint64_t v66 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v67 = (void (*)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  uint64_t v32 = v66(a3, v7);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v58 = v19;
  uint64_t v59 = v29;
  uint64_t v33 = v65;
  uint64_t v34 = v7;
  uint64_t v35 = v72;
  uint64_t v73 = a3;
  uint64_t v74 = v24;
  uint64_t v36 = v62;
  if (v32)
  {
    uint64_t v37 = 0;
    do
    {
      uint64_t v38 = v32;
      uint64_t v39 = v36;
      uint64_t v40 = v33;
      v31(v35, v36, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v35, v37, v73, v34);
      uint64_t v36 = v39;
      uint64_t v33 = v40;
      uint64_t v32 = v38;
      ++v37;
    }
    while (v38 != v37);
  }
  uint64_t v41 = v73;
  uint64_t v42 = v77 + 8;
  uint64_t v43 = *(void (**)(char *, const char *))(v77 + 8);
  v43(v36, v33);
  ((void (*)(char *, void (*)(char *, const char *), uint64_t))v63)(v75, v74, v41);
  v68(v41, v34);
  uint64_t v44 = v41;
  uint64_t v45 = v66(v41, v34);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  uint64_t v46 = v34;
  uint64_t v77 = v42;
  uint64_t v48 = v60;
  uint64_t v47 = v61;
  uint64_t v49 = v65;
  uint64_t v74 = v43;
  if (v45)
  {
    uint64_t v50 = 0;
    uint64_t v67 = *(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 56);
    uint64_t v68 = (void (*)(uint64_t, uint64_t))(v46 + 56);
    uint64_t v66 = (uint64_t (*)(uint64_t, uint64_t))(v46 + 64);
    uint64_t v69 = v45;
    do
    {
      uint64_t v51 = v67;
      v67(v50, v44, v46);
      v51(v50, v44, v46);
      uint64_t v52 = v72;
      (*(void (**)(char *, char *, const char *))(*(void *)(*(void *)(v70 + 16) + 8) + 64))(v48, v47, v49);
      uint64_t v53 = v44;
      uint64_t v54 = v74;
      v74(v47, v49);
      v54(v48, v49);
      uint64_t v44 = v53;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v52, v50++, v53, v46);
    }
    while (v69 != v50);
  }
  uint64_t v55 = *(void (**)(char *, uint64_t))(v58 + 8);
  v55(v75, v44);
  v55(v71, v44);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v63)(v59, v76, v44);
}

uint64_t SIMD<>.addProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v61 = a5;
  uint64_t v58 = a1;
  uint64_t v59 = a2;
  uint64_t v7 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v63 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v45 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v45 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v49 = (char *)&v45 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v46 = (char *)&v45 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v45 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v19);
  uint64_t v50 = v22;
  uint64_t v24 = (char *)&v45 - v23;
  uint64_t v47 = *(void (**)(void))(v22 + 32);
  uint64_t v48 = v22 + 32;
  v47();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v25 = v21;
  uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v26 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v45 = v5;
  uint64_t v57 = v11;
  uint64_t v60 = v7;
  uint64_t v27 = a3;
  uint64_t v28 = v49;
  uint64_t v29 = v46;
  uint64_t v62 = v25;
  uint64_t v30 = v24;
  if (v26)
  {
    uint64_t v31 = v14;
    uint64_t v32 = 0;
    uint64_t v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v60 + 56);
    uint64_t v34 = v60;
    uint64_t v53 = v61 + 256;
    uint64_t v54 = v33;
    uint64_t v55 = v60 + 56;
    uint64_t v56 = v26;
    uint64_t v51 = v60 + 64;
    uint64_t v52 = (void (**)(char *, const char *))(v63 + 8);
    uint64_t v64 = AssociatedTypeWitness;
    uint64_t v65 = v30;
    do
    {
      uint64_t v63 = v32 + 1;
      uint64_t v35 = v54;
      v54(v32, v27, v34);
      v35(v32, v27, v34);
      uint64_t v36 = v29;
      uint64_t v37 = v27;
      uint64_t v38 = v28;
      uint64_t v39 = v31;
      uint64_t v40 = v57;
      v35(v32, v37, v34);
      (*(void (**)(char *, char *, const char *))(v61 + 256))(v39, v40, v64);
      uint64_t v41 = *v52;
      uint64_t v42 = v40;
      uint64_t v31 = v39;
      uint64_t v28 = v38;
      uint64_t v27 = v37;
      uint64_t v29 = v36;
      uint64_t v43 = v64;
      (*v52)(v42, v64);
      v41(v31, v43);
      v41(v28, v43);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v29, v32, v27, v34);
      uint64_t v30 = v65;
      uint64_t v32 = v63;
    }
    while (v56 != v63);
  }
  (*(void (**)(char *, uint64_t))(v50 + 8))(v30, v27);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v47)(v45, v62, v27);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  const char *AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(void);
  uint64_t v32;
  void (*v33)(char *, const char *);
  uint64_t v34;
  char *v35;
  char *v36;
  void (*v37)(char *, char *, const char *);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(char *, const char *);
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  const char *v49;
  void (*v50)(uint64_t, uint64_t, uint64_t);
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  void (*v56)(char *, const char *);
  void (*v57)(char *, uint64_t);
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  void (*v65)(void);
  uint64_t v66;
  uint64_t (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  void (*v69)(char *, const char *);
  void (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;

  uint64_t v6 = v5;
  uint64_t v73 = a2;
  uint64_t v74 = a5;
  uint64_t v9 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v72 = (char *)&v59 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v63 = (char *)&v59 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v62 = (char *)&v59 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v76 = (char *)&v59 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v59 - v21;
  uint64_t v23 = *(void *)(a3 - 8);
  uint64_t v24 = MEMORY[0x1F4188790](v20);
  uint64_t v79 = (char *)&v59 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v59 - v27;
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  uint64_t v78 = (char *)&v59 - v30;
  MEMORY[0x1F4188790](v29);
  uint64_t v31 = *(void (**)(void))(v23 + 32);
  uint64_t v75 = (char *)&v59 - v32;
  uint64_t v65 = v31;
  uint64_t v66 = v23 + 32;
  v31();
  unint64_t v80 = v11;
  uint64_t v33 = *(void (**)(char *, const char *))(v11 + 16);
  uint64_t v64 = v22;
  uint64_t v69 = v33;
  ((void (*)(char *, uint64_t, const char *))v33)(v22, a1, AssociatedTypeWitness);
  uint64_t v70 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  uint64_t v71 = v9 + 48;
  v70(a3, v9);
  uint64_t v67 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v68 = v9 + 40;
  uint64_t v34 = v67(a3, v9);
  if (v34 < 0) {
    goto LABEL_10;
  }
  uint64_t v60 = v23;
  uint64_t v61 = v6;
  uint64_t v81 = a3;
  uint64_t v35 = v76;
  uint64_t v36 = v64;
  uint64_t v77 = v28;
  uint64_t v37 = (void (*)(char *, char *, const char *))v69;
  if (v34)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v39 = v34;
      v37(v35, v36, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v35, v38, v81, v9);
      uint64_t v34 = v39;
      ++v38;
    }
    while (v39 != v38);
  }
  uint64_t v40 = v80 + 8;
  uint64_t v41 = *(void (**)(char *, const char *))(v80 + 8);
  uint64_t v42 = AssociatedTypeWitness;
  v41(v36, AssociatedTypeWitness);
  uint64_t v43 = v81;
  ((void (*)(char *, char *, uint64_t))v65)(v78, v77, v81);
  v70(v43, v9);
  uint64_t v44 = v67(v43, v9);
  if (v44 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  unint64_t v80 = v40;
  uint64_t v45 = v9;
  uint64_t v47 = v62;
  uint64_t v46 = v63;
  if (v44)
  {
    uint64_t v48 = 0;
    uint64_t v70 = *(void (**)(uint64_t, uint64_t))(v45 + 56);
    uint64_t v71 = v45 + 56;
    uint64_t v67 = (uint64_t (*)(uint64_t, uint64_t))(v45 + 64);
    uint64_t v68 = v74 + 256;
    uint64_t v77 = (char *)v44;
    uint64_t v69 = v41;
    do
    {
      uint64_t v81 = v48 + 1;
      uint64_t v49 = v42;
      uint64_t v50 = (void (*)(uint64_t, uint64_t, uint64_t))v70;
      ((void (*)(uint64_t, uint64_t, uint64_t))v70)(v48, v43, v45);
      v50(v48, v43, v45);
      uint64_t v51 = v47;
      uint64_t v52 = v46;
      uint64_t v53 = v72;
      v50(v48, v43, v45);
      uint64_t v42 = v49;
      uint64_t v54 = v76;
      (*(void (**)(char *, char *, const char *))(v74 + 256))(v52, v53, v49);
      uint64_t v55 = v53;
      uint64_t v46 = v52;
      uint64_t v47 = v51;
      uint64_t v56 = v69;
      v69(v55, v49);
      v56(v46, v49);
      v56(v47, v49);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 64))(v54, v48, v43, v45);
      uint64_t v48 = v81;
    }
    while (v77 != (char *)v81);
  }
  uint64_t v57 = *(void (**)(char *, uint64_t))(v60 + 8);
  v57(v78, v43);
  v57(v75, v43);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v65)(v61, v79, v43);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  const char *AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(void);
  uint64_t v32;
  void (*v33)(char *, const char *);
  uint64_t v34;
  char *v35;
  char *v36;
  void (*v37)(char *, char *, const char *);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(char *, const char *);
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  const char *v49;
  void (*v50)(uint64_t, uint64_t, uint64_t);
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  void (*v56)(char *, const char *);
  void (*v57)(char *, uint64_t);
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  void (*v65)(void);
  uint64_t v66;
  uint64_t (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  void (*v69)(char *, const char *);
  void (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;

  uint64_t v6 = v5;
  uint64_t v73 = a1;
  uint64_t v74 = a5;
  uint64_t v9 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v72 = (char *)&v59 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v63 = (char *)&v59 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v62 = (char *)&v59 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v76 = (char *)&v59 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v59 - v21;
  uint64_t v23 = *(void *)(a3 - 8);
  uint64_t v24 = MEMORY[0x1F4188790](v20);
  uint64_t v79 = (char *)&v59 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v59 - v27;
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  uint64_t v78 = (char *)&v59 - v30;
  MEMORY[0x1F4188790](v29);
  uint64_t v31 = *(void (**)(void))(v23 + 32);
  uint64_t v75 = (char *)&v59 - v32;
  uint64_t v65 = v31;
  uint64_t v66 = v23 + 32;
  v31();
  unint64_t v80 = v11;
  uint64_t v33 = *(void (**)(char *, const char *))(v11 + 16);
  uint64_t v64 = v22;
  uint64_t v69 = v33;
  ((void (*)(char *, uint64_t, const char *))v33)(v22, a2, AssociatedTypeWitness);
  uint64_t v70 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  uint64_t v71 = v9 + 48;
  v70(a3, v9);
  uint64_t v67 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v68 = v9 + 40;
  uint64_t v34 = v67(a3, v9);
  if (v34 < 0) {
    goto LABEL_10;
  }
  uint64_t v60 = v23;
  uint64_t v61 = v6;
  uint64_t v81 = a3;
  uint64_t v35 = v76;
  uint64_t v36 = v64;
  uint64_t v77 = v28;
  uint64_t v37 = (void (*)(char *, char *, const char *))v69;
  if (v34)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v39 = v34;
      v37(v35, v36, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v35, v38, v81, v9);
      uint64_t v34 = v39;
      ++v38;
    }
    while (v39 != v38);
  }
  uint64_t v40 = v80 + 8;
  uint64_t v41 = *(void (**)(char *, const char *))(v80 + 8);
  uint64_t v42 = AssociatedTypeWitness;
  v41(v36, AssociatedTypeWitness);
  uint64_t v43 = v81;
  ((void (*)(char *, char *, uint64_t))v65)(v78, v77, v81);
  v70(v43, v9);
  uint64_t v44 = v67(v43, v9);
  if (v44 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  unint64_t v80 = v40;
  uint64_t v45 = v9;
  uint64_t v47 = v62;
  uint64_t v46 = v63;
  if (v44)
  {
    uint64_t v48 = 0;
    uint64_t v70 = *(void (**)(uint64_t, uint64_t))(v45 + 56);
    uint64_t v71 = v45 + 56;
    uint64_t v67 = (uint64_t (*)(uint64_t, uint64_t))(v45 + 64);
    uint64_t v68 = v74 + 256;
    uint64_t v77 = (char *)v44;
    uint64_t v69 = v41;
    do
    {
      uint64_t v81 = v48 + 1;
      uint64_t v49 = v42;
      uint64_t v50 = (void (*)(uint64_t, uint64_t, uint64_t))v70;
      ((void (*)(uint64_t, uint64_t, uint64_t))v70)(v48, v43, v45);
      v50(v48, v43, v45);
      uint64_t v51 = v47;
      uint64_t v52 = v46;
      uint64_t v53 = v72;
      v50(v48, v43, v45);
      uint64_t v42 = v49;
      uint64_t v54 = v76;
      (*(void (**)(char *, char *, const char *))(v74 + 256))(v52, v53, v49);
      uint64_t v55 = v53;
      uint64_t v46 = v52;
      uint64_t v47 = v51;
      uint64_t v56 = v69;
      v69(v55, v49);
      v56(v46, v49);
      v56(v47, v49);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 64))(v54, v48, v43, v45);
      uint64_t v48 = v81;
    }
    while (v77 != (char *)v81);
  }
  uint64_t v57 = *(void (**)(char *, uint64_t))(v60 + 8);
  v57(v78, v43);
  v57(v75, v43);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v65)(v61, v79, v43);
}

uint64_t SIMD<>.formSquareRoot()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v42 = a3;
  uint64_t v5 = *(void *)(a2 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v39 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v30 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v30 - v11;
  uint64_t v13 = *(void *)(a1 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v10);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v30 - v17;
  uint64_t v33 = *(void (**)(void))(v13 + 32);
  uint64_t v34 = v13 + 32;
  v33();
  (*(void (**)(uint64_t, uint64_t))(v5 + 48))(a1, v5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a1, v5);
  if (v19 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v31 = v13;
  uint64_t v32 = v3;
  uint64_t v20 = a1;
  uint64_t v40 = AssociatedTypeWitness;
  uint64_t v41 = v12;
  uint64_t v43 = v16;
  if (v19)
  {
    uint64_t v21 = v9;
    uint64_t v22 = v5;
    uint64_t v23 = 0;
    uint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 56);
    uint64_t v25 = v41;
    uint64_t v37 = v42 + 240;
    uint64_t v38 = v24;
    uint64_t v26 = v40;
    uint64_t v27 = (void (**)(char *, const char *))(v39 + 8);
    uint64_t v39 = v5 + 56;
    uint64_t v35 = v5 + 64;
    uint64_t v36 = v27;
    do
    {
      uint64_t v28 = v19;
      v38(v23, v20, v22);
      (*(void (**)(const char *))(v42 + 240))(v26);
      (*v36)(v21, v26);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v25, v23, v20, v22);
      uint64_t v19 = v28;
      ++v23;
    }
    while (v28 != v23);
  }
  (*(void (**)(char *, uint64_t))(v31 + 8))(v18, v20);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v33)(v32, v43, v20);
}

uint64_t SIMD<>.round(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v47 = a4;
  uint64_t v7 = *(void *)(a3 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v43 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v33 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v33 - v12;
  uint64_t v14 = *(void *)(a2 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = *(void (**)(void))(v14 + 32);
  uint64_t v36 = (char *)&v33 - v19;
  uint64_t v37 = v18;
  uint64_t v38 = v14 + 32;
  v18();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a2, v7);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a2, v7);
  if (v20 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v34 = v14;
  uint64_t v35 = v4;
  uint64_t v21 = a2;
  uint64_t v44 = v13;
  uint64_t v45 = a1;
  uint64_t v48 = v17;
  uint64_t v22 = v36;
  if (v20)
  {
    uint64_t v23 = v10;
    uint64_t v24 = v7;
    uint64_t v25 = 0;
    uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v27 = AssociatedTypeWitness;
    uint64_t v41 = v47 + 304;
    uint64_t v42 = v26;
    uint64_t v28 = (void (**)(char *, const char *))(v43 + 8);
    uint64_t v43 = v7 + 56;
    uint64_t v39 = v7 + 64;
    uint64_t v40 = v28;
    do
    {
      uint64_t v29 = v20;
      uint64_t v30 = v21;
      v42(v25, v21, v24);
      uint64_t v31 = v44;
      (*(void (**)(uint64_t, const char *))(v47 + 304))(v45, v27);
      (*v40)(v23, v27);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v31, v25, v30, v24);
      uint64_t v21 = v30;
      uint64_t v20 = v29;
      ++v25;
    }
    while (v29 != v25);
  }
  (*(void (**)(char *, uint64_t))(v34 + 8))(v22, v21);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v48, v21);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v96 = a6;
  uint64_t v9 = a3;
  uint64_t v88 = a2;
  LODWORD(v94) = a1;
  uint64_t v82 = a7;
  uint64_t v90 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v76 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v76 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = (char *)&v76 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v76 - v17;
  uint64_t v99 = *(void *)(v19 + 8);
  uint64_t v20 = *(int ***)(*(void *)(v99 + 24) + 16);
  uint64_t v22 = *(void *)(v21 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v22, v23, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v97 = (uint64_t)v20;
  uint64_t v93 = swift_getAssociatedTypeWitness(0, v20, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v93);
  uint64_t v92 = (char *)&v76 - v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v78 = *(v26 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v32 = (char *)&v76 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  char v98 = (char *)&v76 - v34;
  MEMORY[0x1F4188790](v33);
  unint64_t v89 = (char *)&v76 - v35;
  v103[0] = v9;
  v103[1] = a4;
  v103[2] = a5;
  v103[3] = v96;
  uint64_t v36 = type metadata accessor for SIMDMask(0, (uint64_t)v103);
  uint64_t v86 = (uint64_t)*(v36 - 1);
  uint64_t v87 = v36;
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  uint64_t v39 = (char *)&v76 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  uint64_t v84 = (char *)&v76 - v40;
  uint64_t v41 = *(void (**)(uint64_t, uint64_t))(v22 + 48);
  uint64_t v85 = v22 + 48;
  uint64_t v83 = v41;
  v41(v9, v22);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v96 = v22 + 40;
  uint64_t v42 = v95(v9, v22);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v42;
  unint64_t v80 = v32;
  char v91 = v26;
  uint64_t v79 = v29;
  uint64_t v81 = v18;
  uint64_t v100 = v12;
  if (v42)
  {
    unint64_t v44 = 0;
    uint64_t v45 = v22 + 64;
    uint64_t v46 = v89;
    while (1)
    {
      unint64_t v47 = v95(v9, v22);
      if ((v47 & 0x8000000000000000) != 0) {
        break;
      }
      if (v44 >= v47) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v77 = v45;
      uint64_t v48 = v93;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v97, (uint64_t)v91, (uint64_t)v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v50 = v92;
      if (v94)
      {
        uint64_t v51 = (uint64_t *)&unk_18162B0C8;
        uint64_t v52 = 257;
      }
      else
      {
        uint64_t v51 = &qword_18162B0B8;
        uint64_t v52 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v51, v52, v48, AssociatedConformanceWitness);
      (*(void (**)(char *))(v97 + 24))(v50);
      uint64_t v45 = v77;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v46, v44++, v9, v22);
      if (v43 == v44) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v54 = v86;
  uint64_t v53 = v87;
  uint64_t v55 = v84;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v84, v39, v87);
  uint64_t v56 = *(void (**)(char *, char *, uint64_t))(v90 + 16);
  v56(v101, v55, v9);
  v56(v102, v88, v9);
  v83(v9, v22);
  uint64_t v57 = v95(v9, v22);
  if (v57 < 0) {
    goto LABEL_16;
  }
  uint64_t v58 = v57;
  (*(void (**)(char *, Class *))(v54 + 8))(v55, v53);
  uint64_t v59 = v79;
  uint64_t v60 = (uint64_t)v91;
  uint64_t v61 = v80;
  if (v58)
  {
    uint64_t v62 = 0;
    uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
    uint64_t v94 = v99 + 192;
    uint64_t v95 = v63;
    uint64_t v96 = v22 + 56;
    uint64_t v97 = v58;
    uint64_t v92 = (char *)(v22 + 64);
    uint64_t v93 = (const char *)(v78 + 8);
    do
    {
      uint64_t v64 = v61;
      uint64_t v65 = v59;
      uint64_t v66 = (void (*)(uint64_t, uint64_t, uint64_t))v95;
      ((void (*)(uint64_t, uint64_t, uint64_t))v95)(v62, v9, v22);
      v66(v62, v9, v22);
      uint64_t v59 = v65;
      uint64_t v61 = v64;
      uint64_t v67 = v9;
      uint64_t v68 = v98;
      (*(void (**)(char *, char *, uint64_t))(v99 + 192))(v64, v59, v60);
      uint64_t v69 = *(void (**)(char *, uint64_t))v93;
      (*(void (**)(char *, uint64_t))v93)(v59, v60);
      v69(v64, v60);
      uint64_t v70 = v68;
      uint64_t v9 = v67;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v70, v62++, v67, v22);
    }
    while (v97 != v62);
  }
  uint64_t v71 = v90;
  uint64_t v72 = *(void (**)(char *, uint64_t))(v90 + 8);
  v72(v102, v9);
  v72(v101, v9);
  uint64_t v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v74 = v81;
  v73(v81, v100, v9);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, v9);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v96 = a6;
  uint64_t v9 = a3;
  uint64_t v88 = a2;
  LODWORD(v94) = a1;
  uint64_t v82 = a7;
  uint64_t v90 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v76 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v76 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = (char *)&v76 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v76 - v17;
  uint64_t v99 = *(void *)(v19 + 8);
  uint64_t v20 = *(int ***)(*(void *)(v99 + 24) + 16);
  uint64_t v22 = *(void *)(v21 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v22, v23, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v97 = (uint64_t)v20;
  uint64_t v93 = swift_getAssociatedTypeWitness(0, v20, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v93);
  uint64_t v92 = (char *)&v76 - v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v78 = *(v26 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v32 = (char *)&v76 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  char v98 = (char *)&v76 - v34;
  MEMORY[0x1F4188790](v33);
  unint64_t v89 = (char *)&v76 - v35;
  v103[0] = v9;
  v103[1] = a4;
  v103[2] = a5;
  v103[3] = v96;
  uint64_t v36 = type metadata accessor for SIMDMask(0, (uint64_t)v103);
  uint64_t v86 = (uint64_t)*(v36 - 1);
  uint64_t v87 = v36;
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  uint64_t v39 = (char *)&v76 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  uint64_t v84 = (char *)&v76 - v40;
  uint64_t v41 = *(void (**)(uint64_t, uint64_t))(v22 + 48);
  uint64_t v85 = v22 + 48;
  uint64_t v83 = v41;
  v41(v9, v22);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v96 = v22 + 40;
  uint64_t v42 = v95(v9, v22);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v42;
  unint64_t v80 = v32;
  char v91 = v26;
  uint64_t v79 = v29;
  uint64_t v81 = v18;
  uint64_t v100 = v12;
  if (v42)
  {
    unint64_t v44 = 0;
    uint64_t v45 = v22 + 64;
    uint64_t v46 = v89;
    while (1)
    {
      unint64_t v47 = v95(v9, v22);
      if ((v47 & 0x8000000000000000) != 0) {
        break;
      }
      if (v44 >= v47) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v77 = v45;
      uint64_t v48 = v93;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v97, (uint64_t)v91, (uint64_t)v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v50 = v92;
      if (v94)
      {
        uint64_t v51 = (uint64_t *)&unk_18162B0C8;
        uint64_t v52 = 257;
      }
      else
      {
        uint64_t v51 = &qword_18162B0B8;
        uint64_t v52 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v51, v52, v48, AssociatedConformanceWitness);
      (*(void (**)(char *))(v97 + 24))(v50);
      uint64_t v45 = v77;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v46, v44++, v9, v22);
      if (v43 == v44) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v54 = v86;
  uint64_t v53 = v87;
  uint64_t v55 = v84;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v84, v39, v87);
  uint64_t v56 = *(void (**)(char *, char *, uint64_t))(v90 + 16);
  v56(v101, v55, v9);
  v56(v102, v88, v9);
  v83(v9, v22);
  uint64_t v57 = v95(v9, v22);
  if (v57 < 0) {
    goto LABEL_16;
  }
  uint64_t v58 = v57;
  (*(void (**)(char *, Class *))(v54 + 8))(v55, v53);
  uint64_t v59 = v79;
  uint64_t v60 = (uint64_t)v91;
  uint64_t v61 = v80;
  if (v58)
  {
    uint64_t v62 = 0;
    uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
    uint64_t v94 = v99 + 224;
    uint64_t v95 = v63;
    uint64_t v96 = v22 + 56;
    uint64_t v97 = v58;
    uint64_t v92 = (char *)(v22 + 64);
    uint64_t v93 = (const char *)(v78 + 8);
    do
    {
      uint64_t v64 = v61;
      uint64_t v65 = v59;
      uint64_t v66 = (void (*)(uint64_t, uint64_t, uint64_t))v95;
      ((void (*)(uint64_t, uint64_t, uint64_t))v95)(v62, v9, v22);
      v66(v62, v9, v22);
      uint64_t v59 = v65;
      uint64_t v61 = v64;
      uint64_t v67 = v9;
      uint64_t v68 = v98;
      (*(void (**)(char *, char *, uint64_t))(v99 + 224))(v64, v59, v60);
      uint64_t v69 = *(void (**)(char *, uint64_t))v93;
      (*(void (**)(char *, uint64_t))v93)(v59, v60);
      v69(v64, v60);
      uint64_t v70 = v68;
      uint64_t v9 = v67;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v70, v62++, v67, v22);
    }
    while (v97 != v62);
  }
  uint64_t v71 = v90;
  uint64_t v72 = *(void (**)(char *, uint64_t))(v90 + 8);
  v72(v102, v9);
  v72(v101, v9);
  uint64_t v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v74 = v81;
  v73(v81, v100, v9);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, v9);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v96 = a6;
  uint64_t v9 = a3;
  uint64_t v88 = a2;
  LODWORD(v94) = a1;
  uint64_t v82 = a7;
  uint64_t v90 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v76 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v76 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = (char *)&v76 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v76 - v17;
  uint64_t v99 = *(void *)(v19 + 8);
  uint64_t v20 = *(int ***)(*(void *)(v99 + 24) + 16);
  uint64_t v22 = *(void *)(v21 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v22, v23, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v97 = (uint64_t)v20;
  uint64_t v93 = swift_getAssociatedTypeWitness(0, v20, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v93);
  uint64_t v92 = (char *)&v76 - v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v78 = *(v26 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v32 = (char *)&v76 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  char v98 = (char *)&v76 - v34;
  MEMORY[0x1F4188790](v33);
  unint64_t v89 = (char *)&v76 - v35;
  v103[0] = v9;
  v103[1] = a4;
  v103[2] = a5;
  v103[3] = v96;
  uint64_t v36 = type metadata accessor for SIMDMask(0, (uint64_t)v103);
  uint64_t v86 = (uint64_t)*(v36 - 1);
  uint64_t v87 = v36;
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  uint64_t v39 = (char *)&v76 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  uint64_t v84 = (char *)&v76 - v40;
  uint64_t v41 = *(void (**)(uint64_t, uint64_t))(v22 + 48);
  uint64_t v85 = v22 + 48;
  uint64_t v83 = v41;
  v41(v9, v22);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v96 = v22 + 40;
  uint64_t v42 = v95(v9, v22);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v42;
  unint64_t v80 = v32;
  char v91 = v26;
  uint64_t v79 = v29;
  uint64_t v81 = v18;
  uint64_t v100 = v12;
  if (v42)
  {
    unint64_t v44 = 0;
    uint64_t v45 = v22 + 64;
    uint64_t v46 = v89;
    while (1)
    {
      unint64_t v47 = v95(v9, v22);
      if ((v47 & 0x8000000000000000) != 0) {
        break;
      }
      if (v44 >= v47) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v77 = v45;
      uint64_t v48 = v93;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v97, (uint64_t)v91, (uint64_t)v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v50 = v92;
      if (v94)
      {
        uint64_t v51 = (uint64_t *)&unk_18162B0C8;
        uint64_t v52 = 257;
      }
      else
      {
        uint64_t v51 = &qword_18162B0B8;
        uint64_t v52 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v51, v52, v48, AssociatedConformanceWitness);
      (*(void (**)(char *))(v97 + 24))(v50);
      uint64_t v45 = v77;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v46, v44++, v9, v22);
      if (v43 == v44) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v54 = v86;
  uint64_t v53 = v87;
  uint64_t v55 = v84;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v84, v39, v87);
  uint64_t v56 = *(void (**)(char *, char *, uint64_t))(v90 + 16);
  v56(v101, v55, v9);
  v56(v102, v88, v9);
  v83(v9, v22);
  uint64_t v57 = v95(v9, v22);
  if (v57 < 0) {
    goto LABEL_16;
  }
  uint64_t v58 = v57;
  (*(void (**)(char *, Class *))(v54 + 8))(v55, v53);
  uint64_t v59 = v79;
  uint64_t v60 = (uint64_t)v91;
  uint64_t v61 = v80;
  if (v58)
  {
    uint64_t v62 = 0;
    uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
    uint64_t v94 = v99 + 208;
    uint64_t v95 = v63;
    uint64_t v96 = v22 + 56;
    uint64_t v97 = v58;
    uint64_t v92 = (char *)(v22 + 64);
    uint64_t v93 = (const char *)(v78 + 8);
    do
    {
      uint64_t v64 = v61;
      uint64_t v65 = v59;
      uint64_t v66 = (void (*)(uint64_t, uint64_t, uint64_t))v95;
      ((void (*)(uint64_t, uint64_t, uint64_t))v95)(v62, v9, v22);
      v66(v62, v9, v22);
      uint64_t v59 = v65;
      uint64_t v61 = v64;
      uint64_t v67 = v9;
      uint64_t v68 = v98;
      (*(void (**)(char *, char *, uint64_t))(v99 + 208))(v64, v59, v60);
      uint64_t v69 = *(void (**)(char *, uint64_t))v93;
      (*(void (**)(char *, uint64_t))v93)(v59, v60);
      v69(v64, v60);
      uint64_t v70 = v68;
      uint64_t v9 = v67;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v70, v62++, v67, v22);
    }
    while (v97 != v62);
  }
  uint64_t v71 = v90;
  uint64_t v72 = *(void (**)(char *, uint64_t))(v90 + 8);
  v72(v102, v9);
  v72(v101, v9);
  uint64_t v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v74 = v81;
  v73(v81, v100, v9);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, v9);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v96 = a6;
  uint64_t v9 = a3;
  LODWORD(v94) = a2;
  uint64_t v88 = a1;
  uint64_t v82 = a7;
  uint64_t v90 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v76 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v76 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = (char *)&v76 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v76 - v17;
  uint64_t v99 = *(void *)(v19 + 8);
  uint64_t v20 = *(int ***)(*(void *)(v99 + 24) + 16);
  uint64_t v22 = *(void *)(v21 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v22, v23, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v97 = (uint64_t)v20;
  uint64_t v93 = swift_getAssociatedTypeWitness(0, v20, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v93);
  uint64_t v92 = (char *)&v76 - v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v78 = *(v26 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v32 = (char *)&v76 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  char v98 = (char *)&v76 - v34;
  MEMORY[0x1F4188790](v33);
  unint64_t v89 = (char *)&v76 - v35;
  v103[0] = v9;
  v103[1] = a4;
  v103[2] = a5;
  v103[3] = v96;
  uint64_t v36 = type metadata accessor for SIMDMask(0, (uint64_t)v103);
  uint64_t v86 = (uint64_t)*(v36 - 1);
  uint64_t v87 = v36;
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  uint64_t v39 = (char *)&v76 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  uint64_t v84 = (char *)&v76 - v40;
  uint64_t v41 = *(void (**)(uint64_t, uint64_t))(v22 + 48);
  uint64_t v85 = v22 + 48;
  uint64_t v83 = v41;
  v41(v9, v22);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v96 = v22 + 40;
  uint64_t v42 = v95(v9, v22);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v42;
  unint64_t v80 = v32;
  char v91 = v26;
  uint64_t v79 = v29;
  uint64_t v81 = v18;
  uint64_t v100 = v12;
  if (v42)
  {
    unint64_t v44 = 0;
    uint64_t v45 = v22 + 64;
    uint64_t v46 = v89;
    while (1)
    {
      unint64_t v47 = v95(v9, v22);
      if ((v47 & 0x8000000000000000) != 0) {
        break;
      }
      if (v44 >= v47) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v77 = v45;
      uint64_t v48 = v93;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v97, (uint64_t)v91, (uint64_t)v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v50 = v92;
      if (v94)
      {
        uint64_t v51 = (uint64_t *)&unk_18162B0C8;
        uint64_t v52 = 257;
      }
      else
      {
        uint64_t v51 = &qword_18162B0B8;
        uint64_t v52 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v51, v52, v48, AssociatedConformanceWitness);
      (*(void (**)(char *))(v97 + 24))(v50);
      uint64_t v45 = v77;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v46, v44++, v9, v22);
      if (v43 == v44) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v54 = v86;
  uint64_t v53 = v87;
  uint64_t v55 = v84;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v84, v39, v87);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v90 + 16);
  v56(v101, v88, v9);
  v56(v102, (uint64_t)v55, v9);
  v83(v9, v22);
  uint64_t v57 = v95(v9, v22);
  if (v57 < 0) {
    goto LABEL_16;
  }
  uint64_t v58 = v57;
  (*(void (**)(char *, Class *))(v54 + 8))(v55, v53);
  uint64_t v59 = v79;
  uint64_t v60 = (uint64_t)v91;
  uint64_t v61 = v80;
  if (v58)
  {
    uint64_t v62 = 0;
    uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
    uint64_t v94 = v99 + 192;
    uint64_t v95 = v63;
    uint64_t v96 = v22 + 56;
    uint64_t v97 = v58;
    uint64_t v92 = (char *)(v22 + 64);
    uint64_t v93 = (const char *)(v78 + 8);
    do
    {
      uint64_t v64 = v61;
      uint64_t v65 = v59;
      uint64_t v66 = (void (*)(uint64_t, uint64_t, uint64_t))v95;
      ((void (*)(uint64_t, uint64_t, uint64_t))v95)(v62, v9, v22);
      v66(v62, v9, v22);
      uint64_t v59 = v65;
      uint64_t v61 = v64;
      uint64_t v67 = v9;
      uint64_t v68 = v98;
      (*(void (**)(char *, char *, uint64_t))(v99 + 192))(v64, v59, v60);
      uint64_t v69 = *(void (**)(char *, uint64_t))v93;
      (*(void (**)(char *, uint64_t))v93)(v59, v60);
      v69(v64, v60);
      uint64_t v70 = v68;
      uint64_t v9 = v67;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v70, v62++, v67, v22);
    }
    while (v97 != v62);
  }
  uint64_t v71 = v90;
  uint64_t v72 = *(void (**)(char *, uint64_t))(v90 + 8);
  v72(v102, v9);
  v72(v101, v9);
  uint64_t v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v74 = v81;
  v73(v81, v100, v9);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, v9);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v96 = a6;
  uint64_t v9 = a3;
  LODWORD(v94) = a2;
  uint64_t v88 = a1;
  uint64_t v82 = a7;
  uint64_t v90 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v76 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v76 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = (char *)&v76 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v76 - v17;
  uint64_t v99 = *(void *)(v19 + 8);
  uint64_t v20 = *(int ***)(*(void *)(v99 + 24) + 16);
  uint64_t v22 = *(void *)(v21 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v22, v23, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v97 = (uint64_t)v20;
  uint64_t v93 = swift_getAssociatedTypeWitness(0, v20, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v93);
  uint64_t v92 = (char *)&v76 - v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v78 = *(v26 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v32 = (char *)&v76 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  char v98 = (char *)&v76 - v34;
  MEMORY[0x1F4188790](v33);
  unint64_t v89 = (char *)&v76 - v35;
  v103[0] = v9;
  v103[1] = a4;
  v103[2] = a5;
  v103[3] = v96;
  uint64_t v36 = type metadata accessor for SIMDMask(0, (uint64_t)v103);
  uint64_t v86 = (uint64_t)*(v36 - 1);
  uint64_t v87 = v36;
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  uint64_t v39 = (char *)&v76 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  uint64_t v84 = (char *)&v76 - v40;
  uint64_t v41 = *(void (**)(uint64_t, uint64_t))(v22 + 48);
  uint64_t v85 = v22 + 48;
  uint64_t v83 = v41;
  v41(v9, v22);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v96 = v22 + 40;
  uint64_t v42 = v95(v9, v22);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v42;
  unint64_t v80 = v32;
  char v91 = v26;
  uint64_t v79 = v29;
  uint64_t v81 = v18;
  uint64_t v100 = v12;
  if (v42)
  {
    unint64_t v44 = 0;
    uint64_t v45 = v22 + 64;
    uint64_t v46 = v89;
    while (1)
    {
      unint64_t v47 = v95(v9, v22);
      if ((v47 & 0x8000000000000000) != 0) {
        break;
      }
      if (v44 >= v47) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v77 = v45;
      uint64_t v48 = v93;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v97, (uint64_t)v91, (uint64_t)v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v50 = v92;
      if (v94)
      {
        uint64_t v51 = (uint64_t *)&unk_18162B0C8;
        uint64_t v52 = 257;
      }
      else
      {
        uint64_t v51 = &qword_18162B0B8;
        uint64_t v52 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v51, v52, v48, AssociatedConformanceWitness);
      (*(void (**)(char *))(v97 + 24))(v50);
      uint64_t v45 = v77;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v46, v44++, v9, v22);
      if (v43 == v44) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v54 = v86;
  uint64_t v53 = v87;
  uint64_t v55 = v84;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v84, v39, v87);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v90 + 16);
  v56(v101, v88, v9);
  v56(v102, (uint64_t)v55, v9);
  v83(v9, v22);
  uint64_t v57 = v95(v9, v22);
  if (v57 < 0) {
    goto LABEL_16;
  }
  uint64_t v58 = v57;
  (*(void (**)(char *, Class *))(v54 + 8))(v55, v53);
  uint64_t v59 = v79;
  uint64_t v60 = (uint64_t)v91;
  uint64_t v61 = v80;
  if (v58)
  {
    uint64_t v62 = 0;
    uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
    uint64_t v94 = v99 + 224;
    uint64_t v95 = v63;
    uint64_t v96 = v22 + 56;
    uint64_t v97 = v58;
    uint64_t v92 = (char *)(v22 + 64);
    uint64_t v93 = (const char *)(v78 + 8);
    do
    {
      uint64_t v64 = v61;
      uint64_t v65 = v59;
      uint64_t v66 = (void (*)(uint64_t, uint64_t, uint64_t))v95;
      ((void (*)(uint64_t, uint64_t, uint64_t))v95)(v62, v9, v22);
      v66(v62, v9, v22);
      uint64_t v59 = v65;
      uint64_t v61 = v64;
      uint64_t v67 = v9;
      uint64_t v68 = v98;
      (*(void (**)(char *, char *, uint64_t))(v99 + 224))(v64, v59, v60);
      uint64_t v69 = *(void (**)(char *, uint64_t))v93;
      (*(void (**)(char *, uint64_t))v93)(v59, v60);
      v69(v64, v60);
      uint64_t v70 = v68;
      uint64_t v9 = v67;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v70, v62++, v67, v22);
    }
    while (v97 != v62);
  }
  uint64_t v71 = v90;
  uint64_t v72 = *(void (**)(char *, uint64_t))(v90 + 8);
  v72(v102, v9);
  v72(v101, v9);
  uint64_t v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v74 = v81;
  v73(v81, v100, v9);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, v9);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v96 = a6;
  uint64_t v9 = a3;
  LODWORD(v94) = a2;
  uint64_t v88 = a1;
  uint64_t v82 = a7;
  uint64_t v90 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v76 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v102 = (char *)&v76 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v101 = (char *)&v76 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v76 - v17;
  uint64_t v99 = *(void *)(v19 + 8);
  uint64_t v20 = *(int ***)(*(void *)(v99 + 24) + 16);
  uint64_t v22 = *(void *)(v21 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v22, v23, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v97 = (uint64_t)v20;
  uint64_t v93 = swift_getAssociatedTypeWitness(0, v20, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v93);
  uint64_t v92 = (char *)&v76 - v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v78 = *(v26 - 1);
  uint64_t v27 = MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v32 = (char *)&v76 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  char v98 = (char *)&v76 - v34;
  MEMORY[0x1F4188790](v33);
  unint64_t v89 = (char *)&v76 - v35;
  v103[0] = v9;
  v103[1] = a4;
  v103[2] = a5;
  v103[3] = v96;
  uint64_t v36 = type metadata accessor for SIMDMask(0, (uint64_t)v103);
  uint64_t v86 = (uint64_t)*(v36 - 1);
  uint64_t v87 = v36;
  uint64_t v37 = MEMORY[0x1F4188790](v36);
  uint64_t v39 = (char *)&v76 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v37);
  uint64_t v84 = (char *)&v76 - v40;
  uint64_t v41 = *(void (**)(uint64_t, uint64_t))(v22 + 48);
  uint64_t v85 = v22 + 48;
  uint64_t v83 = v41;
  v41(v9, v22);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v96 = v22 + 40;
  uint64_t v42 = v95(v9, v22);
  if (v42 < 0) {
    goto LABEL_16;
  }
  uint64_t v43 = v42;
  unint64_t v80 = v32;
  char v91 = v26;
  uint64_t v79 = v29;
  uint64_t v81 = v18;
  uint64_t v100 = v12;
  if (v42)
  {
    unint64_t v44 = 0;
    uint64_t v45 = v22 + 64;
    uint64_t v46 = v89;
    while (1)
    {
      unint64_t v47 = v95(v9, v22);
      if ((v47 & 0x8000000000000000) != 0) {
        break;
      }
      if (v44 >= v47) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v77 = v45;
      uint64_t v48 = v93;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v97, (uint64_t)v91, (uint64_t)v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v50 = v92;
      if (v94)
      {
        uint64_t v51 = (uint64_t *)&unk_18162B0C8;
        uint64_t v52 = 257;
      }
      else
      {
        uint64_t v51 = &qword_18162B0B8;
        uint64_t v52 = 256;
      }
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(v51, v52, v48, AssociatedConformanceWitness);
      (*(void (**)(char *))(v97 + 24))(v50);
      uint64_t v45 = v77;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v46, v44++, v9, v22);
      if (v43 == v44) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v54 = v86;
  uint64_t v53 = v87;
  uint64_t v55 = v84;
  (*(void (**)(char *, char *, Class *))(v86 + 32))(v84, v39, v87);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v90 + 16);
  v56(v101, v88, v9);
  v56(v102, (uint64_t)v55, v9);
  v83(v9, v22);
  uint64_t v57 = v95(v9, v22);
  if (v57 < 0) {
    goto LABEL_16;
  }
  uint64_t v58 = v57;
  (*(void (**)(char *, Class *))(v54 + 8))(v55, v53);
  uint64_t v59 = v79;
  uint64_t v60 = (uint64_t)v91;
  uint64_t v61 = v80;
  if (v58)
  {
    uint64_t v62 = 0;
    uint64_t v63 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 56);
    uint64_t v94 = v99 + 208;
    uint64_t v95 = v63;
    uint64_t v96 = v22 + 56;
    uint64_t v97 = v58;
    uint64_t v92 = (char *)(v22 + 64);
    uint64_t v93 = (const char *)(v78 + 8);
    do
    {
      uint64_t v64 = v61;
      uint64_t v65 = v59;
      uint64_t v66 = (void (*)(uint64_t, uint64_t, uint64_t))v95;
      ((void (*)(uint64_t, uint64_t, uint64_t))v95)(v62, v9, v22);
      v66(v62, v9, v22);
      uint64_t v59 = v65;
      uint64_t v61 = v64;
      uint64_t v67 = v9;
      uint64_t v68 = v98;
      (*(void (**)(char *, char *, uint64_t))(v99 + 208))(v64, v59, v60);
      uint64_t v69 = *(void (**)(char *, uint64_t))v93;
      (*(void (**)(char *, uint64_t))v93)(v59, v60);
      v69(v64, v60);
      uint64_t v70 = v68;
      uint64_t v9 = v67;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v70, v62++, v67, v22);
    }
    while (v97 != v62);
  }
  uint64_t v71 = v90;
  uint64_t v72 = *(void (**)(char *, uint64_t))(v90 + 8);
  v72(v102, v9);
  v72(v101, v9);
  uint64_t v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v74 = v81;
  v73(v81, v100, v9);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, v9);
}

uint64_t static SIMDMask..&= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v70 = a2;
  uint64_t v11 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v65 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v51 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v68 = (char *)&v51 - v18;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = MEMORY[0x1F4188790](v20);
  uint64_t v23 = (char *)&v51 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  uint64_t v26 = (char *)&v51 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v61 = (char *)&v51 - v27;
  v72[0] = a3;
  v72[1] = a4;
  uint64_t v67 = a5;
  v72[2] = a5;
  v72[3] = a6;
  uint64_t v29 = v28;
  uint64_t v30 = type metadata accessor for SIMDMask(0, (uint64_t)v72);
  uint64_t v59 = (uint64_t)*(v30 - 1);
  uint64_t v60 = v30;
  MEMORY[0x1F4188790](v30);
  uint64_t v58 = (char *)&v51 - v31;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  uint64_t v71 = v26;
  uint64_t v56 = v32;
  uint64_t v57 = v19 + 32;
  v32(v26, a1, a3);
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v70, a3);
  (*(void (**)(uint64_t, uint64_t))(v11 + 48))(a3, v11);
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 40))(a3, v11);
  if (v33 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v52 = v19;
  uint64_t v53 = a1;
  uint64_t v34 = v54;
  uint64_t v35 = AssociatedTypeWitness;
  uint64_t v36 = a3;
  uint64_t v69 = v23;
  uint64_t v70 = v29;
  if (v33)
  {
    uint64_t v37 = 0;
    uint64_t v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 56);
    uint64_t v63 = (void (**)(char *, const char *))(v65 + 8);
    uint64_t v64 = v38;
    uint64_t v65 = v11 + 56;
    uint64_t v66 = v33;
    uint64_t v62 = v11 + 64;
    do
    {
      uint64_t v39 = v16;
      uint64_t v40 = v34;
      uint64_t v41 = v64;
      v64(v37, v36, v11);
      v41(v37, v36, v11);
      uint64_t v34 = v40;
      uint64_t v16 = v39;
      uint64_t v42 = v36;
      uint64_t v43 = v68;
      (*(void (**)(char *, char *, const char *))(*(void *)(v67 + 8) + 192))(v39, v34, v35);
      unint64_t v44 = *v63;
      (*v63)(v34, v35);
      v44(v39, v35);
      uint64_t v45 = v43;
      uint64_t v36 = v42;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 64))(v45, v37++, v42, v11);
    }
    while (v66 != v37);
  }
  uint64_t v46 = *(void (**)(char *, uint64_t))(v52 + 8);
  v46(v69, v36);
  v46(v71, v36);
  unint64_t v47 = v61;
  uint64_t v48 = v56;
  v56(v61, v70, v36);
  uint64_t v49 = v58;
  v48(v58, v47, v36);
  return (*(uint64_t (**)(char *, char *, Class *))(v59 + 32))(v53, v49, v60);
}

uint64_t static SIMDMask..^= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v70 = a2;
  uint64_t v11 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v65 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v51 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v68 = (char *)&v51 - v18;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = MEMORY[0x1F4188790](v20);
  uint64_t v23 = (char *)&v51 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  uint64_t v26 = (char *)&v51 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v61 = (char *)&v51 - v27;
  v72[0] = a3;
  v72[1] = a4;
  uint64_t v67 = a5;
  v72[2] = a5;
  v72[3] = a6;
  uint64_t v29 = v28;
  uint64_t v30 = type metadata accessor for SIMDMask(0, (uint64_t)v72);
  uint64_t v59 = (uint64_t)*(v30 - 1);
  uint64_t v60 = v30;
  MEMORY[0x1F4188790](v30);
  uint64_t v58 = (char *)&v51 - v31;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  uint64_t v71 = v26;
  uint64_t v56 = v32;
  uint64_t v57 = v19 + 32;
  v32(v26, a1, a3);
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v70, a3);
  (*(void (**)(uint64_t, uint64_t))(v11 + 48))(a3, v11);
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 40))(a3, v11);
  if (v33 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v52 = v19;
  uint64_t v53 = a1;
  uint64_t v34 = v54;
  uint64_t v35 = AssociatedTypeWitness;
  uint64_t v36 = a3;
  uint64_t v69 = v23;
  uint64_t v70 = v29;
  if (v33)
  {
    uint64_t v37 = 0;
    uint64_t v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 56);
    uint64_t v63 = (void (**)(char *, const char *))(v65 + 8);
    uint64_t v64 = v38;
    uint64_t v65 = v11 + 56;
    uint64_t v66 = v33;
    uint64_t v62 = v11 + 64;
    do
    {
      uint64_t v39 = v16;
      uint64_t v40 = v34;
      uint64_t v41 = v64;
      v64(v37, v36, v11);
      v41(v37, v36, v11);
      uint64_t v34 = v40;
      uint64_t v16 = v39;
      uint64_t v42 = v36;
      uint64_t v43 = v68;
      (*(void (**)(char *, char *, const char *))(*(void *)(v67 + 8) + 224))(v39, v34, v35);
      unint64_t v44 = *v63;
      (*v63)(v34, v35);
      v44(v39, v35);
      uint64_t v45 = v43;
      uint64_t v36 = v42;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 64))(v45, v37++, v42, v11);
    }
    while (v66 != v37);
  }
  uint64_t v46 = *(void (**)(char *, uint64_t))(v52 + 8);
  v46(v69, v36);
  v46(v71, v36);
  unint64_t v47 = v61;
  uint64_t v48 = v56;
  v56(v61, v70, v36);
  uint64_t v49 = v58;
  v48(v58, v47, v36);
  return (*(uint64_t (**)(char *, char *, Class *))(v59 + 32))(v53, v49, v60);
}

uint64_t static SIMDMask..|= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v70 = a2;
  uint64_t v11 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v11, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  uint64_t v65 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v51 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v68 = (char *)&v51 - v18;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v21 = MEMORY[0x1F4188790](v20);
  uint64_t v23 = (char *)&v51 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  uint64_t v26 = (char *)&v51 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v61 = (char *)&v51 - v27;
  v72[0] = a3;
  v72[1] = a4;
  uint64_t v67 = a5;
  v72[2] = a5;
  v72[3] = a6;
  uint64_t v29 = v28;
  uint64_t v30 = type metadata accessor for SIMDMask(0, (uint64_t)v72);
  uint64_t v59 = (uint64_t)*(v30 - 1);
  uint64_t v60 = v30;
  MEMORY[0x1F4188790](v30);
  uint64_t v58 = (char *)&v51 - v31;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  uint64_t v71 = v26;
  uint64_t v56 = v32;
  uint64_t v57 = v19 + 32;
  v32(v26, a1, a3);
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v70, a3);
  (*(void (**)(uint64_t, uint64_t))(v11 + 48))(a3, v11);
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 40))(a3, v11);
  if (v33 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v52 = v19;
  uint64_t v53 = a1;
  uint64_t v34 = v54;
  uint64_t v35 = AssociatedTypeWitness;
  uint64_t v36 = a3;
  uint64_t v69 = v23;
  uint64_t v70 = v29;
  if (v33)
  {
    uint64_t v37 = 0;
    uint64_t v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 56);
    uint64_t v63 = (void (**)(char *, const char *))(v65 + 8);
    uint64_t v64 = v38;
    uint64_t v65 = v11 + 56;
    uint64_t v66 = v33;
    uint64_t v62 = v11 + 64;
    do
    {
      uint64_t v39 = v16;
      uint64_t v40 = v34;
      uint64_t v41 = v64;
      v64(v37, v36, v11);
      v41(v37, v36, v11);
      uint64_t v34 = v40;
      uint64_t v16 = v39;
      uint64_t v42 = v36;
      uint64_t v43 = v68;
      (*(void (**)(char *, char *, const char *))(*(void *)(v67 + 8) + 208))(v39, v34, v35);
      unint64_t v44 = *v63;
      (*v63)(v34, v35);
      v44(v39, v35);
      uint64_t v45 = v43;
      uint64_t v36 = v42;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 64))(v45, v37++, v42, v11);
    }
    while (v66 != v37);
  }
  uint64_t v46 = *(void (**)(char *, uint64_t))(v52 + 8);
  v46(v69, v36);
  v46(v71, v36);
  unint64_t v47 = v61;
  uint64_t v48 = v56;
  v56(v61, v70, v36);
  uint64_t v49 = v58;
  v48(v58, v47, v36);
  return (*(uint64_t (**)(char *, char *, Class *))(v59 + 32))(v53, v49, v60);
}

uint64_t static SIMDMask..&= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v108 = a6;
  uint64_t v8 = a3;
  LODWORD(v102) = a2;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(int ***)(*(void *)(v10 + 24) + 16);
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  unint64_t v103 = v11;
  unint64_t v101 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v101);
  uint64_t v100 = (char *)&v82 - v14;
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v85 = *(v15 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  unint64_t v89 = (char *)&v82 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v82 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v82 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  char v98 = (char *)&v82 - v25;
  uint64_t v99 = *(void *)(v8 - 8);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v82 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  int64x2_t v110 = (char *)&v82 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  int64x2_t v109 = (char *)&v82 - v32;
  MEMORY[0x1F4188790](v31);
  uint64_t v90 = (char *)&v82 - v33;
  v111[0] = v8;
  v111[1] = a4;
  v111[2] = a5;
  v111[3] = v108;
  uint64_t v34 = type metadata accessor for SIMDMask(0, (uint64_t)v111);
  uint64_t v35 = MEMORY[0x1F4188790](v34);
  uint64_t v37 = (char *)&v82 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v38 = MEMORY[0x1F4188790](v35);
  uint64_t v96 = (char *)&v82 - v39;
  MEMORY[0x1F4188790](v38);
  uint64_t v88 = v40;
  uint64_t v41 = *(void (**)(void))(v40 + 32);
  uint64_t v95 = (char *)&v82 - v42;
  uint64_t v91 = a1;
  uint64_t v97 = v43;
  uint64_t v93 = v40 + 32;
  uint64_t v92 = v41;
  v41();
  uint64_t v94 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v94(v8, v12);
  int64x2_t v104 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  uint64_t v105 = v12 + 40;
  uint64_t v44 = v104(v8, v12);
  if (v44 < 0) {
    goto LABEL_16;
  }
  uint64_t v87 = v12 + 48;
  uint64_t v107 = v10;
  uint64_t v108 = v28;
  uint64_t v106 = v23;
  uint64_t v86 = v20;
  uint64_t v45 = (uint64_t)v103;
  if (v44)
  {
    unint64_t v46 = 0;
    unint64_t v47 = (char *)(v103 + 3);
    uint64_t v84 = v12 + 64;
    while (1)
    {
      uint64_t v48 = v44;
      unint64_t v49 = v104(v8, v12);
      if ((v49 & 0x8000000000000000) != 0) {
        break;
      }
      if (v46 >= v49) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v82 = v47;
      uint64_t v50 = v101;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v45, (uint64_t)v15, (uint64_t)v101, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v52 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v83 = v15;
      uint64_t v53 = v100;
      if (v102)
      {
        uint64_t v54 = (uint64_t *)&unk_18162B0C8;
        uint64_t v55 = 257;
      }
      else
      {
        uint64_t v54 = &qword_18162B0B8;
        uint64_t v55 = 256;
      }
      v52(v54, v55, v50, AssociatedConformanceWitness);
      uint64_t v56 = v98;
      uint64_t v57 = v53;
      uint64_t v58 = v83;
      unint64_t v47 = v82;
      (*(void (**)(char *, uint64_t *, uint64_t))(v45 + 24))(v57, v83, v45);
      uint64_t v59 = v56;
      uint64_t v15 = v58;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v59, v46++, v8, v12);
      uint64_t v44 = v48;
      if (v48 == v46) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v60 = v96;
  uint64_t v61 = v97;
  ((void (*)(char *, char *, uint64_t))v92)(v96, v37, v97);
  uint64_t v62 = *(void (**)(char *, char *, uint64_t))(v99 + 16);
  uint64_t v63 = v95;
  v62(v109, v95, v8);
  v62(v110, v60, v8);
  v94(v8, v12);
  uint64_t v64 = v104(v8, v12);
  if (v64 < 0) {
    goto LABEL_16;
  }
  uint64_t v65 = *(void (**)(char *, uint64_t))(v88 + 8);
  uint64_t v105 = v64;
  v65(v60, v61);
  v65(v63, v61);
  uint64_t v66 = v89;
  uint64_t v67 = v86;
  if (v105)
  {
    uint64_t v68 = 0;
    uint64_t v69 = *(int ***)(v12 + 56);
    uint64_t v102 = v107 + 192;
    unint64_t v103 = v69;
    int64x2_t v104 = (uint64_t (*)(uint64_t, uint64_t))(v12 + 56);
    uint64_t v100 = (char *)(v12 + 64);
    unint64_t v101 = (const char *)(v85 + 8);
    do
    {
      uint64_t v70 = v8;
      uint64_t v71 = v67;
      uint64_t v72 = v66;
      uint64_t v73 = v8;
      uint64_t v74 = v103;
      ((void (*)(uint64_t, uint64_t, uint64_t))v103)(v68, v70, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v74)(v68, v73, v12);
      uint64_t v8 = v73;
      uint64_t v66 = v72;
      uint64_t v67 = v71;
      uint64_t v75 = v106;
      (*(void (**)(char *, char *, uint64_t *))(v107 + 192))(v71, v66, v15);
      uint64_t v76 = *(void (**)(char *, uint64_t *))v101;
      (*(void (**)(char *, uint64_t *))v101)(v66, v15);
      v76(v71, v15);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v75, v68++, v8, v12);
    }
    while (v105 != v68);
  }
  uint64_t v77 = v99;
  uint64_t v78 = *(void (**)(char *, uint64_t))(v99 + 8);
  v78(v110, v8);
  v78(v109, v8);
  uint64_t v79 = *(void (**)(char *, char *, uint64_t))(v77 + 32);
  unint64_t v80 = v90;
  v79(v90, v108, v8);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v79)(v91, v80, v8);
}

uint64_t static SIMDMask..^= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v108 = a6;
  uint64_t v8 = a3;
  LODWORD(v102) = a2;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(int ***)(*(void *)(v10 + 24) + 16);
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  unint64_t v103 = v11;
  unint64_t v101 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v101);
  uint64_t v100 = (char *)&v82 - v14;
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v85 = *(v15 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  unint64_t v89 = (char *)&v82 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v82 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v82 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  char v98 = (char *)&v82 - v25;
  uint64_t v99 = *(void *)(v8 - 8);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v82 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  int64x2_t v110 = (char *)&v82 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  int64x2_t v109 = (char *)&v82 - v32;
  MEMORY[0x1F4188790](v31);
  uint64_t v90 = (char *)&v82 - v33;
  v111[0] = v8;
  v111[1] = a4;
  v111[2] = a5;
  v111[3] = v108;
  uint64_t v34 = type metadata accessor for SIMDMask(0, (uint64_t)v111);
  uint64_t v35 = MEMORY[0x1F4188790](v34);
  uint64_t v37 = (char *)&v82 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v38 = MEMORY[0x1F4188790](v35);
  uint64_t v96 = (char *)&v82 - v39;
  MEMORY[0x1F4188790](v38);
  uint64_t v88 = v40;
  uint64_t v41 = *(void (**)(void))(v40 + 32);
  uint64_t v95 = (char *)&v82 - v42;
  uint64_t v91 = a1;
  uint64_t v97 = v43;
  uint64_t v93 = v40 + 32;
  uint64_t v92 = v41;
  v41();
  uint64_t v94 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v94(v8, v12);
  int64x2_t v104 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  uint64_t v105 = v12 + 40;
  uint64_t v44 = v104(v8, v12);
  if (v44 < 0) {
    goto LABEL_16;
  }
  uint64_t v87 = v12 + 48;
  uint64_t v107 = v10;
  uint64_t v108 = v28;
  uint64_t v106 = v23;
  uint64_t v86 = v20;
  uint64_t v45 = (uint64_t)v103;
  if (v44)
  {
    unint64_t v46 = 0;
    unint64_t v47 = (char *)(v103 + 3);
    uint64_t v84 = v12 + 64;
    while (1)
    {
      uint64_t v48 = v44;
      unint64_t v49 = v104(v8, v12);
      if ((v49 & 0x8000000000000000) != 0) {
        break;
      }
      if (v46 >= v49) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v82 = v47;
      uint64_t v50 = v101;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v45, (uint64_t)v15, (uint64_t)v101, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v52 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v83 = v15;
      uint64_t v53 = v100;
      if (v102)
      {
        uint64_t v54 = (uint64_t *)&unk_18162B0C8;
        uint64_t v55 = 257;
      }
      else
      {
        uint64_t v54 = &qword_18162B0B8;
        uint64_t v55 = 256;
      }
      v52(v54, v55, v50, AssociatedConformanceWitness);
      uint64_t v56 = v98;
      uint64_t v57 = v53;
      uint64_t v58 = v83;
      unint64_t v47 = v82;
      (*(void (**)(char *, uint64_t *, uint64_t))(v45 + 24))(v57, v83, v45);
      uint64_t v59 = v56;
      uint64_t v15 = v58;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v59, v46++, v8, v12);
      uint64_t v44 = v48;
      if (v48 == v46) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v60 = v96;
  uint64_t v61 = v97;
  ((void (*)(char *, char *, uint64_t))v92)(v96, v37, v97);
  uint64_t v62 = *(void (**)(char *, char *, uint64_t))(v99 + 16);
  uint64_t v63 = v95;
  v62(v109, v95, v8);
  v62(v110, v60, v8);
  v94(v8, v12);
  uint64_t v64 = v104(v8, v12);
  if (v64 < 0) {
    goto LABEL_16;
  }
  uint64_t v65 = *(void (**)(char *, uint64_t))(v88 + 8);
  uint64_t v105 = v64;
  v65(v60, v61);
  v65(v63, v61);
  uint64_t v66 = v89;
  uint64_t v67 = v86;
  if (v105)
  {
    uint64_t v68 = 0;
    uint64_t v69 = *(int ***)(v12 + 56);
    uint64_t v102 = v107 + 224;
    unint64_t v103 = v69;
    int64x2_t v104 = (uint64_t (*)(uint64_t, uint64_t))(v12 + 56);
    uint64_t v100 = (char *)(v12 + 64);
    unint64_t v101 = (const char *)(v85 + 8);
    do
    {
      uint64_t v70 = v8;
      uint64_t v71 = v67;
      uint64_t v72 = v66;
      uint64_t v73 = v8;
      uint64_t v74 = v103;
      ((void (*)(uint64_t, uint64_t, uint64_t))v103)(v68, v70, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v74)(v68, v73, v12);
      uint64_t v8 = v73;
      uint64_t v66 = v72;
      uint64_t v67 = v71;
      uint64_t v75 = v106;
      (*(void (**)(char *, char *, uint64_t *))(v107 + 224))(v71, v66, v15);
      uint64_t v76 = *(void (**)(char *, uint64_t *))v101;
      (*(void (**)(char *, uint64_t *))v101)(v66, v15);
      v76(v71, v15);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v75, v68++, v8, v12);
    }
    while (v105 != v68);
  }
  uint64_t v77 = v99;
  uint64_t v78 = *(void (**)(char *, uint64_t))(v99 + 8);
  v78(v110, v8);
  v78(v109, v8);
  uint64_t v79 = *(void (**)(char *, char *, uint64_t))(v77 + 32);
  unint64_t v80 = v90;
  v79(v90, v108, v8);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v79)(v91, v80, v8);
}

uint64_t static SIMDMask..|= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v108 = a6;
  uint64_t v8 = a3;
  LODWORD(v102) = a2;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(int ***)(*(void *)(v10 + 24) + 16);
  uint64_t v12 = *(void *)(a4 + 48);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  unint64_t v103 = v11;
  unint64_t v101 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v101);
  uint64_t v100 = (char *)&v82 - v14;
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v85 = *(v15 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v15);
  unint64_t v89 = (char *)&v82 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v82 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v82 - v22;
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  char v98 = (char *)&v82 - v25;
  uint64_t v99 = *(void *)(v8 - 8);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v82 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = MEMORY[0x1F4188790](v26);
  int64x2_t v110 = (char *)&v82 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  int64x2_t v109 = (char *)&v82 - v32;
  MEMORY[0x1F4188790](v31);
  uint64_t v90 = (char *)&v82 - v33;
  v111[0] = v8;
  v111[1] = a4;
  v111[2] = a5;
  v111[3] = v108;
  uint64_t v34 = type metadata accessor for SIMDMask(0, (uint64_t)v111);
  uint64_t v35 = MEMORY[0x1F4188790](v34);
  uint64_t v37 = (char *)&v82 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v38 = MEMORY[0x1F4188790](v35);
  uint64_t v96 = (char *)&v82 - v39;
  MEMORY[0x1F4188790](v38);
  uint64_t v88 = v40;
  uint64_t v41 = *(void (**)(void))(v40 + 32);
  uint64_t v95 = (char *)&v82 - v42;
  uint64_t v91 = a1;
  uint64_t v97 = v43;
  uint64_t v93 = v40 + 32;
  uint64_t v92 = v41;
  v41();
  uint64_t v94 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v94(v8, v12);
  int64x2_t v104 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  uint64_t v105 = v12 + 40;
  uint64_t v44 = v104(v8, v12);
  if (v44 < 0) {
    goto LABEL_16;
  }
  uint64_t v87 = v12 + 48;
  uint64_t v107 = v10;
  uint64_t v108 = v28;
  uint64_t v106 = v23;
  uint64_t v86 = v20;
  uint64_t v45 = (uint64_t)v103;
  if (v44)
  {
    unint64_t v46 = 0;
    unint64_t v47 = (char *)(v103 + 3);
    uint64_t v84 = v12 + 64;
    while (1)
    {
      uint64_t v48 = v44;
      unint64_t v49 = v104(v8, v12);
      if ((v49 & 0x8000000000000000) != 0) {
        break;
      }
      if (v46 >= v49) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      }
      uint64_t v82 = v47;
      uint64_t v50 = v101;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v45, (uint64_t)v15, (uint64_t)v101, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v52 = *(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v83 = v15;
      uint64_t v53 = v100;
      if (v102)
      {
        uint64_t v54 = (uint64_t *)&unk_18162B0C8;
        uint64_t v55 = 257;
      }
      else
      {
        uint64_t v54 = &qword_18162B0B8;
        uint64_t v55 = 256;
      }
      v52(v54, v55, v50, AssociatedConformanceWitness);
      uint64_t v56 = v98;
      uint64_t v57 = v53;
      uint64_t v58 = v83;
      unint64_t v47 = v82;
      (*(void (**)(char *, uint64_t *, uint64_t))(v45 + 24))(v57, v83, v45);
      uint64_t v59 = v56;
      uint64_t v15 = v58;
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v59, v46++, v8, v12);
      uint64_t v44 = v48;
      if (v48 == v46) {
        goto LABEL_10;
      }
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  uint64_t v60 = v96;
  uint64_t v61 = v97;
  ((void (*)(char *, char *, uint64_t))v92)(v96, v37, v97);
  uint64_t v62 = *(void (**)(char *, char *, uint64_t))(v99 + 16);
  uint64_t v63 = v95;
  v62(v109, v95, v8);
  v62(v110, v60, v8);
  v94(v8, v12);
  uint64_t v64 = v104(v8, v12);
  if (v64 < 0) {
    goto LABEL_16;
  }
  uint64_t v65 = *(void (**)(char *, uint64_t))(v88 + 8);
  uint64_t v105 = v64;
  v65(v60, v61);
  v65(v63, v61);
  uint64_t v66 = v89;
  uint64_t v67 = v86;
  if (v105)
  {
    uint64_t v68 = 0;
    uint64_t v69 = *(int ***)(v12 + 56);
    uint64_t v102 = v107 + 208;
    unint64_t v103 = v69;
    int64x2_t v104 = (uint64_t (*)(uint64_t, uint64_t))(v12 + 56);
    uint64_t v100 = (char *)(v12 + 64);
    unint64_t v101 = (const char *)(v85 + 8);
    do
    {
      uint64_t v70 = v8;
      uint64_t v71 = v67;
      uint64_t v72 = v66;
      uint64_t v73 = v8;
      uint64_t v74 = v103;
      ((void (*)(uint64_t, uint64_t, uint64_t))v103)(v68, v70, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v74)(v68, v73, v12);
      uint64_t v8 = v73;
      uint64_t v66 = v72;
      uint64_t v67 = v71;
      uint64_t v75 = v106;
      (*(void (**)(char *, char *, uint64_t *))(v107 + 208))(v71, v66, v15);
      uint64_t v76 = *(void (**)(char *, uint64_t *))v101;
      (*(void (**)(char *, uint64_t *))v101)(v66, v15);
      v76(v71, v15);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v75, v68++, v8, v12);
    }
    while (v105 != v68);
  }
  uint64_t v77 = v99;
  uint64_t v78 = *(void (**)(char *, uint64_t))(v99 + 8);
  v78(v110, v8);
  v78(v109, v8);
  uint64_t v79 = *(void (**)(char *, char *, uint64_t))(v77 + 32);
  unint64_t v80 = v90;
  v79(v90, v108, v8);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v79)(v91, v80, v8);
}

void *ObjectIdentifier._lldb_summary.unsafeMutableAddressor()
{
  return &static ObjectIdentifier._lldb_summary;
}

void *_stdlib_AtomicInt.__allocating_init(_:)(uint64_t a1)
{
  uint64_t result = swift_allocObject(v1, 0x18uLL, 7uLL);
  result[2] = a1;
  return result;
}

uint64_t _stdlib_AtomicInt.init(_:)(uint64_t a1)
{
  *(void *)(v1 + 16) = a1;
  return v1;
}

Swift::Void __swiftcall _stdlib_AtomicInt.store(_:)(Swift::Int a1)
{
  atomic_store(a1, (unint64_t *)(v1 + 16));
}

unint64_t *_swift_stdlib_atomicStoreInt(object:desired:)(unint64_t *result, unint64_t a2)
{
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.load()()
{
  return atomic_load((unint64_t *)(v0 + 16));
}

unint64_t _swift_stdlib_atomicLoadInt(object:)(unint64_t *a1)
{
  return atomic_load(a1);
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndAdd(_:)(Swift::Int a1)
{
  return atomic_fetch_add((atomic_ullong *volatile)(v1 + 16), a1);
}

unint64_t _swift_stdlib_atomicFetchAddInt(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_add(a1, a2);
}

Swift::Int __swiftcall _stdlib_AtomicInt.addAndFetch(_:)(Swift::Int a1)
{
  unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(v1 + 16), a1);
  BOOL v3 = __OFADD__(add, a1);
  Swift::Int result = add + a1;
  if (v3) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndAnd(_:)(Swift::Int a1)
{
  return atomic_fetch_and((atomic_ullong *volatile)(v1 + 16), a1);
}

unint64_t _swift_stdlib_atomicFetchAndInt(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_and(a1, a2);
}

Swift::Int __swiftcall _stdlib_AtomicInt.andAndFetch(_:)(Swift::Int a1)
{
  return atomic_fetch_and((atomic_ullong *volatile)(v1 + 16), a1) & a1;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndOr(_:)(Swift::Int a1)
{
  return atomic_fetch_or((atomic_ullong *volatile)(v1 + 16), a1);
}

unint64_t _swift_stdlib_atomicFetchOrInt(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_or(a1, a2);
}

Swift::Int __swiftcall _stdlib_AtomicInt.orAndFetch(_:)(Swift::Int a1)
{
  return atomic_fetch_or((atomic_ullong *volatile)(v1 + 16), a1) | a1;
}

uint64_t static Int.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndXor(_:)(Swift::Int a1)
{
  return atomic_fetch_xor((atomic_ullong *volatile)(v1 + 16), a1);
}

unint64_t _swift_stdlib_atomicFetchXorInt(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_xor(a1, a2);
}

Swift::Int __swiftcall _stdlib_AtomicInt.xorAndFetch(_:)(Swift::Int a1)
{
  return atomic_fetch_xor((atomic_ullong *volatile)(v1 + 16), a1) ^ a1;
}

uint64_t static Int.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

Swift::Bool __swiftcall _stdlib_AtomicInt.compareExchange(expected:desired:)(Swift::Int *expected, Swift::Int desired)
{
  Swift::Int v3 = *expected;
  Swift::Int v4 = *expected;
  atomic_compare_exchange_strong((atomic_ullong *volatile)(v2 + 16), (unint64_t *)&v4, desired);
  *expected = v4;
  return v4 == v3;
}

BOOL _swift_stdlib_atomicCompareExchangeStrongInt(object:expected:desired:)(atomic_ullong *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a2;
  atomic_compare_exchange_strong(a1, (unint64_t *)&v4, a3);
  BOOL result = v4 == v3;
  *a2 = v4;
  return result;
}

uint64_t _stdlib_AtomicInt.deinit()
{
  return v0;
}

unint64_t _swift_stdlib_atomicFetchAddInt64(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_add(a1, a2);
}

uint64_t _swift_stdlib_atomicFetchAddInt32(object:operand:)(atomic_uint *a1, unsigned int a2)
{
  return atomic_fetch_add(a1, a2);
}

unint64_t _swift_stdlib_atomicFetchAndInt64(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_and(a1, a2);
}

uint64_t _swift_stdlib_atomicFetchAndInt32(object:operand:)(atomic_uint *a1, unsigned int a2)
{
  return atomic_fetch_and(a1, a2);
}

unint64_t _swift_stdlib_atomicFetchOrInt64(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_or(a1, a2);
}

uint64_t _swift_stdlib_atomicFetchOrInt32(object:operand:)(atomic_uint *a1, unsigned int a2)
{
  return atomic_fetch_or(a1, a2);
}

unint64_t _swift_stdlib_atomicFetchXorInt64(object:operand:)(atomic_ullong *a1, unint64_t a2)
{
  return atomic_fetch_xor(a1, a2);
}

uint64_t _swift_stdlib_atomicFetchXorInt32(object:operand:)(atomic_uint *a1, unsigned int a2)
{
  return atomic_fetch_xor(a1, a2);
}

Swift::Bool __swiftcall _isspace_clocale(_:)(Swift::UInt16 a1)
{
  Swift::UInt16 v3 = a1;
  v2[2] = &v3;
  return specialized Sequence.contains(where:)((uint64_t (*)(void *))partial apply for specialized closure #1 in Sequence<>.contains(_:), (uint64_t)v2, 0x200D0C0B0A09, 0xE600000000000000) & 1;
}

uint64_t Float16.init<A>(_:)(uint64_t *a1, ValueMetadata *x1_0, uint64_t a3)
{
  v3._Swift::UInt64 rawBits = Substring.init<A>(_:)(a1, x1_0, *(void *)(*(void *)(*(void *)(a3 + 8) + 8) + 8));
  uint64_t v5 = v4;
  unsigned __int16 v13 = 0;
  unint64_t v7 = specialized String.init(_:)(v3, v14, v6, v4);
  unint64_t v9 = v8;
  swift_bridgeObjectRelease(v5);
  char v10 = specialized String.withCString<A>(_:)(v7, v9, (uint64_t)&v13, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtof16_clocale, (uint64_t (*)(void))_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v9);
  if (v10) {
    int v11 = v13;
  }
  else {
    int v11 = 0;
  }
  return v11 & 0xFFFEFFFF | (((v10 & 1) == 0) << 16);
}

uint64_t Float16.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unsigned __int16 v11 = 0;
  unint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(a4);
  char v8 = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v11, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtof16_clocale, (uint64_t (*)(void))_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v7);
  if (v8) {
    int v9 = v11;
  }
  else {
    int v9 = 0;
  }
  return v9 & 0xFFFEFFFF | (((v8 & 1) == 0) << 16);
}

__int16 Float16.init(_builtinFloatLiteral:)@<H0>(double _D0@<D0>)
{
  __asm { FCVT            H0, D0 }
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Float16(uint64_t a1@<X8>)
{
  v2._Swift::UInt64 rawBits = specialized Substring.init<A>(_:)();
  uint64_t v4 = v3;
  __int16 v11 = 0;
  unint64_t v6 = specialized String.init(_:)(v2, v12, v5, v3);
  unint64_t v8 = v7;
  swift_bridgeObjectRelease(v4);
  char v9 = specialized String.withCString<A>(_:)(v6, v8, (uint64_t)&v11, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtof16_clocale, (uint64_t (*)(void))_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v8);
  __int16 v10 = v11;
  if ((v9 & 1) == 0) {
    __int16 v10 = 0;
  }
  *(_WORD *)a1 = v10;
  *(unsigned char *)(a1 + 2) = (v9 & 1) == 0;
}

unint64_t specialized Float.init<A>(_:)(unint64_t a1, unint64_t a2)
{
  unsigned int v12 = 0;
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    char v6 = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)&v12, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtof_clocale);
  }
  else
  {
    uint64_t v3 = MEMORY[0x1F4188790](a1);
    if ((a2 & 0x2000000000000000) != 0)
    {
      *(void *)__s = v3;
      uint64_t v11 = a2 & 0xFFFFFFFFFFFFFFLL;
      char v6 = (v3 > 0x20u || ((0x100003E01uLL >> v3) & 1) == 0)
        && (unint64_t v7 = _swift_stdlib_strtof_clocale(__s, (float *)&v12)) != 0
        && *v7 == 0;
    }
    else
    {
      if ((v3 & 0x1000000000000000) != 0)
      {
        id v4 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v5 = v3 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v4 = _StringObject.sharedUTF8.getter(v3, a2);
      }
      char v6 = _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys4Int8VsAD_pqd_1_Isgyrzr_SRys5UInt8VGqd_1_sAD_pAIRszAGRsd__sAD_pRsd_0_Ri_d_1_r_1_lIetMgyrzo_Tpq5Sb_Tgq507_sSRys4f5VGxs5E35_pIgyrzo_ACxsAD_pIegyrzr_lTRSb_TGq5SRyAGGSbsAD_pIgyrzo_Tf1cn_n((uint64_t)v4, v5, (void (*)(uint64_t *__return_ptr))partial apply for specialized closure #1 in _StringGuts.withCString<A>(_:));
    }
  }
  swift_bridgeObjectRelease(a2);
  uint64_t v8 = v12;
  __s[0] = (v6 & 1) == 0;
  if ((v6 & 1) == 0) {
    uint64_t v8 = 0;
  }
  return v8 | ((unint64_t)((v6 & 1) == 0) << 32);
}

unint64_t Float.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)((char *)&v9 + 1) = 0;
  _OWORD v8[2] = (char *)&v9 + 1;
  (*(void (**)(uint64_t *__return_ptr, unsigned char *(*)@<X0>(unsigned char *@<X0>, BOOL *@<X8>), void *, ValueMetadata *, uint64_t, uint64_t))(a3 + 200))(&v9, partial apply for closure #1 in closure #1 in Float.init<A>(_:), v8, &type metadata for Bool, a2, a3);
  int v5 = v9;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  uint64_t v6 = *(unsigned int *)((char *)&v9 + 1);
  BYTE1(v9) = v5 ^ 1;
  if (!v5) {
    uint64_t v6 = 0;
  }
  return v6 | ((unint64_t)(v5 ^ 1u) << 32);
}

float Float.init(_builtinFloatLiteral:)(double a1)
{
  return a1;
}

unint64_t Float.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unsigned int v11 = 0;
  unint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(a4);
  char v8 = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v11, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtof_clocale, (uint64_t (*)(void))_swift_stdlib_strtof_clocale);
  swift_bridgeObjectRelease(v7);
  uint64_t v9 = v11;
  if ((v8 & 1) == 0) {
    uint64_t v9 = 0;
  }
  return v9 | ((unint64_t)((v8 & 1) == 0) << 32);
}

unint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Float@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = specialized Float.init<A>(_:)(a1, a2);
  *(_DWORD *)a3 = result;
  *(unsigned char *)(a3 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t specialized Double.init<A>(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v11 = 0;
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    char v6 = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)&v11, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtod_clocale);
  }
  else
  {
    uint64_t v3 = MEMORY[0x1F4188790](a1);
    if ((a2 & 0x2000000000000000) != 0)
    {
      *(void *)__s = v3;
      uint64_t v10 = a2 & 0xFFFFFFFFFFFFFFLL;
      char v6 = (v3 > 0x20u || ((0x100003E01uLL >> v3) & 1) == 0)
        && (unint64_t v7 = _swift_stdlib_strtod_clocale(__s, (double *)&v11)) != 0
        && *v7 == 0;
    }
    else
    {
      if ((v3 & 0x1000000000000000) != 0)
      {
        id v4 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v5 = v3 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v4 = _StringObject.sharedUTF8.getter(v3, a2);
      }
      char v6 = _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys4Int8VsAD_pqd_1_Isgyrzr_SRys5UInt8VGqd_1_sAD_pAIRszAGRsd__sAD_pRsd_0_Ri_d_1_r_1_lIetMgyrzo_Tpq5Sb_Tgq507_sSRys4f5VGxs5E35_pIgyrzo_ACxsAD_pIegyrzr_lTRSb_TGq5SRyAGGSbsAD_pIgyrzo_Tf1cn_n((uint64_t)v4, v5, (void (*)(uint64_t *__return_ptr))partial apply for specialized closure #1 in _StringGuts.withCString<A>(_:));
    }
  }
  swift_bridgeObjectRelease(a2);
  if (v6) {
    return v11;
  }
  else {
    return 0;
  }
}

uint64_t Double.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  v7[2] = &v9;
  (*(void (**)(unsigned __int8 *__return_ptr, unsigned char *(*)@<X0>(unsigned char *@<X0>, BOOL *@<X8>), void *, ValueMetadata *, uint64_t, uint64_t))(a3 + 200))(&v8, partial apply for closure #1 in closure #1 in Double.init<A>(_:), v7, &type metadata for Bool, a2, a3);
  int v5 = v8;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  if (v5) {
    return v9;
  }
  else {
    return 0;
  }
}

uint64_t Double.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = 0;
  unint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(v4);
  LOBYTE(v4) = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v9, (uint64_t (*)(__objc2_class **, uint64_t))_swift_stdlib_strtod_clocale, (uint64_t (*)(void))_swift_stdlib_strtod_clocale);
  swift_bridgeObjectRelease(v7);
  if (v4) {
    return v9;
  }
  else {
    return 0;
  }
}

uint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Double@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = specialized Double.init<A>(_:)(a1, a2);
  *(void *)a3 = result;
  *(unsigned char *)(a3 + 8) = v5 & 1;
  return result;
}

void Float16._value.setter(__n128 a1)
{
  *uint64_t v1 = a1.n128_u16[0];
}

uint64_t (*Float16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

double Float16.init()()
{
  return 0.0;
}

unint64_t Float16.description.getter(__n128 a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if ((~a1.n128_u32[0] & 0x7C00) == 0 && (a1.n128_u16[0] & 0x3FF) != 0) {
    return 7233902;
  }
  long long v15 = 0u;
  long long v16 = 0u;
  int64_t v2 = swift_float16ToString(&v15, 0x20uLL, a1);
  __src[0] = v15;
  __src[1] = v16;
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  size_t v3 = v2;
  if (!v2) {
    return 0;
  }
  if ((unint64_t)v2 <= 0xF)
  {
    uint64_t v8 = v2 - 8;
    uint64_t v9 = 8;
    if (v2 < 8) {
      uint64_t v9 = v2;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v9 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v9 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v9 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v9 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v9 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v9 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v9 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v10 = 0;
    if (v3 >= 9)
    {
      uint64_t v11 = 0;
      unsigned int v12 = (unsigned __int8 *)__src + 8;
      unint64_t v13 = v8 & ~(v8 >> 63);
      do
      {
        if (v13 <= v3 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v14 = *v12++;
        v10 |= (unint64_t)v14 << v11;
        v11 += 8;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    unint64_t v4 = v2 | 0xF000000000000000;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v4 = *(void *)(v5 + 24);
    }
    *(unsigned char *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }
  return result;
}

BOOL Float16.isNaN.getter(float a1)
{
  return (LOWORD(a1) & 0x3FF) != 0 && (~LODWORD(a1) & 0x7C00) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Float16(__n128 a1)
{
  a1.n128_u16[0] = *v1;
  return Float16.description.getter(a1);
}

unint64_t Float16.debugDescription.getter(__n128 a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  long long v15 = 0u;
  int64_t v1 = swift_float16ToString(&v14, 0x20uLL, a1);
  __src[0] = v14;
  __src[1] = v15;
  if (v1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  size_t v2 = v1;
  if (!v1) {
    return 0;
  }
  if ((unint64_t)v1 <= 0xF)
  {
    uint64_t v7 = v1 - 8;
    uint64_t v8 = 8;
    if (v1 < 8) {
      uint64_t v8 = v1;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v9 = 0;
    if (v2 >= 9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v2 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    unint64_t v3 = v1 | 0xF000000000000000;
    int64_t v4 = _allocateStringStorage(codeUnitCapacity:)(v1);
    *(void *)(v4 + 16) = v5;
    *(void *)(v4 + 24) = v3;
    if (v5 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v3 = *(void *)(v4 + 24);
    }
    *(unsigned char *)(v4 + 32 + (v3 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v2, (char *)(v4 + 32));
    return *(void *)(v4 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Float16(__n128 a1)
{
  a1.n128_u16[0] = *v1;
  return Float16.debugDescription.getter(a1);
}

uint64_t Float16.write<A>(to:)(__n128 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = swift_float16ToString(v8, 0x20uLL, a1);
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a4 + 32))(v8, v6, a3, a4);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Float16(uint64_t a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  a4.n128_u16[0] = *v4;
  return Float16.write<A>(to:)(a4, a1, a2, a3);
}

uint64_t static Float16.exponentBitCount.getter()
{
  return 5;
}

uint64_t static Float16.significandBitCount.getter()
{
  return 10;
}

uint64_t static Float16._infinityExponent.getter()
{
  return 31;
}

uint64_t static Float16._exponentBias.getter()
{
  return 15;
}

uint64_t static Float16._significandMask.getter()
{
  return 1023;
}

uint64_t static UInt16.- infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result = a1 - a2;
  if ((result & 0xFFFF0000) != 0) {
    __break(1u);
  }
  return result;
}

uint64_t static Float16._quietNaNMask.getter()
{
  return 512;
}

float Float16.init(bitPattern:)(int a1)
{
  return *(float *)&a1;
}

uint64_t Float16.sign.getter(float a1)
{
  return LODWORD(a1) >> 15;
}

uint64_t Float16.exponentBitPattern.getter(float a1)
{
  return (LODWORD(a1) >> 10) & 0x1F;
}

uint64_t Float16.significandBitPattern.getter(__n128 a1)
{
  return a1.n128_u16[0] & 0x3FF;
}

uint64_t static UInt16.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

uint64_t Float16.isCanonical.getter()
{
  return 1;
}

__int16 static Float16.leastNonzeroMagnitude.getter@<H0>()
{
  return 1;
}

__int16 static Float16.leastNormalMagnitude.getter@<H0>()
{
  return 1024;
}

__int16 static Float16.infinity.getter@<H0>()
{
  return 31744;
}

__int16 static Float16.nan.getter@<H0>()
{
  return 32256;
}

float Float16.init(nan:signaling:)(int a1, char a2)
{
  if ((unsigned __int16)a1 >= 0x100u) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "NaN payload is not encodable.", 29, 2, "Swift/FloatingPointTypes.swift", 30, 2, 0x198uLL, 0);
  }
  LODWORD(result) = (0x200u >> (a2 & 1)) | a1 | 0x7C00;
  return result;
}

__int16 static Float16.signalingNaN.getter@<H0>()
{
  return 32000;
}

__int16 static Float16.greatestFiniteMagnitude.getter@<H0>()
{
  return 31743;
}

__int16 static Float16.pi.getter@<H0>()
{
  return 16968;
}

__int16 Float16.ulp.getter@<H0>(float a1@<S0>)
{
  int v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (!v1) {
    return 1;
  }
  if (v1 == 31) {
    return 32256;
  }
  *(short float *)&__int16 result = COERCE_SHORT_FLOAT(LOWORD(a1) & 0x7C00) * COERCE_SHORT_FLOAT(5120);
  return result;
}

BOOL Float16.isFinite.getter(float a1)
{
  return (~LODWORD(a1) & 0x7C00) != 0;
}

BOOL Float16.isNormal.getter(float a1)
{
  return ((LODWORD(a1) >> 10) & 0x1F) != 0x1F && ((LODWORD(a1) >> 10) & 0x1F) != 0;
}

__int16 static Float16.* infix(_:_:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *(short float *)a1.n128_u16 * *(short float *)a2.n128_u16;
  return result;
}

__int16 static Float16.ulpOfOne.getter@<H0>()
{
  return 5120;
}

uint64_t Float16.exponent.getter(float a1)
{
  uint64_t v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (v1 == 31) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unsigned int v3 = LOWORD(a1) & 0x3FF;
  if (!(v1 | v3)) {
    return 0x8000000000000000;
  }
  if (v1) {
    return v1 - 15;
  }
  if ((LOWORD(a1) & 0x3FF) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return v1 - (unsigned __int16)(__clz(v3) - 16) - 9;
}

BOOL Float16.isZero.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x7FFF) == 0;
}

float Float16.significand.getter(float result)
{
  int v1 = (LODWORD(result) >> 10) & 0x1F;
  unsigned int v2 = LOWORD(result) & 0x3FF;
  if ((LOWORD(result) & 0x3FF) == 0 || v1 != 31)
  {
    if (v1)
    {
      if (v1 != 31)
      {
        int v4 = v2 | 0x3C00;
        return *(float *)&v4;
      }
    }
    else if ((LOWORD(result) & 0x3FF) != 0)
    {
      LODWORD(result) = (LODWORD(result) << ((__clz(v2) - 5) & 0xF)) & 0x3FF | 0x3C00;
      return result;
    }
    int v4 = v1 << 10;
    return *(float *)&v4;
  }
  return result;
}

BOOL Float16.isSubnormal.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x3FF) != 0 && (a1.n128_u16[0] & 0x7C00) == 0;
}

double Float16.init(sign:exponent:significand:)(char a1, uint64_t a2, float a3)
{
  *(void *)&double result = specialized Float16.init(sign:exponent:significand:)(a1 & 1, a2, a3);
  return result;
}

__int16 static Float16.- prefix(_:)@<H0>(__n128 a1@<Q0>)
{
  *(short float *)&__int16 result = -*(short float *)a1.n128_u16;
  return result;
}

__int16 static Float16.*= infix(_:_:)@<H0>(short float *a1@<X0>, __n128 a2@<Q0>)
{
  *(short float *)&__int16 result = *a1 * *(short float *)a2.n128_u16;
  *a1 = *(short float *)&result;
  return result;
}

float Float16.nextUp.getter(float result)
{
  *(short float *)&__int16 result = *(short float *)&result + COERCE_SHORT_FLOAT(0);
  if (*(short float *)&result < COERCE_SHORT_FLOAT(31744)) {
    LODWORD(result) += (SLOWORD(result) >> 15) | 1;
  }
  return result;
}

__int16 Float16.init(_builtinIntegerLiteral:)@<H0>(uint64_t *a1@<X0>, unint64_t a2@<X1>)
{
  _S0 = swift_intToFloat32(a1, a2);
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 static Float16.+ infix(_:_:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *(short float *)a1.n128_u16 + *(short float *)a2.n128_u16;
  return result;
}

uint64_t static Int16.&>> infix(_:_:)(__int16 a1, char a2)
{
  return (a1 >> (a2 & 0xF));
}

uint64_t static Int16.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

double Float16.init(signOf:magnitudeOf:)(int8x16_t a1, int8x16_t a2)
{
  v2.i64[0] = 0x8000800080008000;
  v2.i64[1] = 0x8000800080008000;
  *(void *)&double result = vbslq_s8(v2, a2, a1).u64[0];
  return result;
}

Swift::Void __swiftcall Float16.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  switch(*(unsigned char *)a1)
  {
    case 0:
      *int v1 = roundl(*v1);
      return;
    case 1:
      *int v1 = rintl(*v1);
      return;
    case 2:
      short float v2 = *v1;
      goto LABEL_9;
    case 3:
      short float v2 = *v1;
      goto LABEL_10;
    case 4:
      *int v1 = truncl(*v1);
      return;
    case 5:
      short float v2 = *v1;
      if ((*(_WORD *)v1 & 0x8000) != 0) {
LABEL_10:
      }
        *int v1 = floorl(v2);
      else {
LABEL_9:
      }
        *int v1 = ceill(v2);
      break;
    default:
      Float16._roundSlowPath(_:)(a1);
      break;
  }
}

Swift::Void __swiftcall Float16._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  char v4 = *(unsigned char *)a1;
  switch(v4)
  {
    case 0:
      short float v2 = roundl(*v1);
      goto LABEL_11;
    case 1:
      short float v2 = rintl(*v1);
      goto LABEL_11;
    case 2:
      short float v3 = *v1;
      goto LABEL_9;
    case 3:
      short float v3 = *v1;
      goto LABEL_10;
    case 4:
      short float v2 = truncl(*v1);
      goto LABEL_11;
    case 5:
      short float v3 = *v1;
      if ((*(_WORD *)v1 & 0x8000) != 0) {
LABEL_10:
      }
        short float v2 = floorl(v3);
      else {
LABEL_9:
      }
        short float v2 = ceill(v3);
LABEL_11:
      *int v1 = v2;
      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }
}

Swift::Void __swiftcall Float16.negate()()
{
  short float *v0 = -*v0;
}

__int16 static Float16.+= infix(_:_:)@<H0>(short float *a1@<X0>, __n128 a2@<Q0>)
{
  *(short float *)&__int16 result = *a1 + *(short float *)a2.n128_u16;
  *a1 = *(short float *)&result;
  return result;
}

__int16 static Float16.-= infix(_:_:)@<H0>(short float *a1@<X0>, __n128 a2@<Q0>)
{
  *(short float *)&__int16 result = *a1 - *(short float *)a2.n128_u16;
  *a1 = *(short float *)&result;
  return result;
}

__int16 static Float16./= infix(_:_:)@<H0>(short float *a1@<X0>, __n128 a2@<Q0>)
{
  *(short float *)&__int16 result = *a1 / *(short float *)a2.n128_u16;
  *a1 = *(short float *)&result;
  return result;
}

__int16 Float16.formRemainder(dividingBy:)@<H0>(__n128 _Q0@<Q0>)
{
  _H1 = *v1;
  __asm
  {
    FCVT            S2, H1
    FCVT            S1, H0; float
  }
  _S0 = remainderf(_S2, _S1);
  __asm { FCVT            H0, S0 }
  *int v1 = result;
  return result;
}

__int16 Float16.formTruncatingRemainder(dividingBy:)@<H0>(__n128 _Q0@<Q0>)
{
  _H2 = *v1;
  __asm
  {
    FCVT            S1, H0; float
    FCVT            S0, H2; float
  }
  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *int v1 = result;
  return result;
}

Swift::Void __swiftcall Float16.formSquareRoot()()
{
  _H0 = *v0;
  __asm { FCVT            S0, H0 }
  _S0 = sqrtf(_S0);
  __asm { FCVT            H0, S0 }
  __int16 *v0 = LOWORD(_S0);
}

__int16 Float16.addProduct(_:_:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *v2 + (short float)(*(short float *)a1.n128_u16 * *(short float *)a2.n128_u16);
  *short float v2 = *(short float *)&result;
  return result;
}

BOOL Float16.isEqual(to:)(__n128 a1, __n128 a2)
{
  return *(short float *)a2.n128_u16 == *(short float *)a1.n128_u16;
}

BOOL Float16.isLess(than:)(__n128 a1, __n128 a2)
{
  return *(short float *)a2.n128_u16 < *(short float *)a1.n128_u16;
}

BOOL Float16.isLessThanOrEqualTo(_:)(__n128 a1, __n128 a2)
{
  return *(short float *)a2.n128_u16 <= *(short float *)a1.n128_u16;
}

BOOL Float16.isSignalingNaN.getter(float a1)
{
  return (~LODWORD(a1) & 0x7C00) == 0 && (LOWORD(a1) & 0x3FF) != 0 && (LOWORD(a1) & 0x200) == 0;
}

__int16 Float16.binade.getter@<H0>(float a1@<S0>)
{
  int v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (v1 == 31) {
    return 32256;
  }
  if ((LOWORD(a1) & 0x3FF) == 0 || v1 != 0) {
    return LOWORD(a1) & 0xFC00;
  }
  *(short float *)&__int16 result = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT16(*(short float *)&a1 * COERCE_SHORT_FLOAT(25600)) & 0xFC00)
                          * COERCE_SHORT_FLOAT(5120);
  return result;
}

uint64_t Float16.significandWidth.getter(float a1)
{
  unsigned int v1 = __clz(__rbit32(LOWORD(a1) & 0x3FF | 0x10000));
  int v2 = (LODWORD(a1) >> 10) & 0x1F;
  if (v2) {
    BOOL v3 = v2 == 31;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if ((LOWORD(a1) & 0x3FF) != 0 && v2 == 0) {
      return 16 - (unsigned __int16)(__clz(LOWORD(a1) & 0x3FF) + v1 - 15);
    }
    else {
      return -1;
    }
  }
  else
  {
    uint64_t v6 = 10 - v1;
    if ((LOWORD(a1) & 0x3FF) != 0) {
      return v6;
    }
    else {
      return 0;
    }
  }
}

uint64_t static UInt16.bitWidth.getter()
{
  return 16;
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Float16(char a1@<W0>, void *a2@<X1>, __int16 *a3@<X2>, _WORD *a4@<X8>)
{
  float v5 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
  *a4 = LOWORD(v5);
}

__int16 protocol witness for BinaryFloatingPoint.init(_:) in conformance Float16@<H0>(_WORD *a1@<X8>, float _S0@<S0>)
{
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 protocol witness for BinaryFloatingPoint.init(_:) in conformance Float16@<H0>(_WORD *a1@<X8>, double _D0@<D0>)
{
  __asm { FCVT            H0, D0 }
  *a1 = result;
  return result;
}

__int16 Float16.init(_:)@<H0>(double _D0@<D0>)
{
  __asm { FCVT            H0, D0 }
  return result;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Float16(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  float v5 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
  *a4 = LOWORD(v5);
}

uint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Float16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_WORD *)a4 = result;
  *(unsigned char *)(a4 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.exponentBitCount.getter in conformance Float16()
{
  return 5;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Float16()
{
  return 10;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Float16(unint64_t *a1@<X8>)
{
  *a1 = ((unint64_t)*v1 >> 10) & 0x1F;
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Float16(_WORD *a1@<X8>)
{
  *a1 = *v1 & 0x3FF;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Float16(__int16 *a1@<X8>, float a2@<S0>)
{
  LOWORD(a2) = *v2;
  *a1 = Float16.binade.getter(a2);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Float16(float a1)
{
  LOWORD(a1) = *v1;
  return Float16.significandWidth.getter(a1);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Float16(char a1@<W0>, uint64_t *a2@<X1>, _WORD *a3@<X2>, __int16 *a4@<X8>, float a5@<S0>)
{
  LOWORD(a5) = *a3;
  *a4 = specialized Float16.init(sign:exponent:significand:)(a1 & 1, *a2, a5);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Float16@<D0>(unsigned __int16 *a1@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  a4.i16[0] = *a1;
  a5.i16[0] = *a2;
  v5.i64[0] = 0x8000800080008000;
  v5.i64[1] = 0x8000800080008000;
  a4.i64[0] = vbslq_s8(v5, a5, a4).u64[0];
  *a3 = a4.i16[0];
  return *(double *)a4.i64;
}

short float protocol witness for FloatingPoint.init(_:) in conformance Float16@<H0>(uint64_t a1@<X0>, short float *a2@<X8>)
{
  short float result = (short float)a1;
  *a2 = (short float)a1;
  return result;
}

__int16 Float16.init(_:)@<H0>(uint64_t a1@<X0>)
{
  *(short float *)&__int16 result = (short float)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Float16@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>, short float *a4@<X8>)
{
  if (a3[16](a2, a3) < 65)
  {
    char v10 = a3[8](a2, a3);
    uint64_t v11 = a3[15](a2, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    if (v10) {
      short float v9 = (short float)v11;
    }
    else {
      short float v9 = (short float)(unint64_t)v11;
    }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((__int16 *)&v12, a1, a2, (uint64_t)a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    short float v9 = v12;
  }
  *a4 = v9;
  return result;
}

__int16 Float16.init<A>(_:)@<H0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>)
{
  if (a3[16](a2, a3) <= 64)
  {
    char v7 = a3[8](a2, a3);
    uint64_t v8 = a3[15](a2, a3);
    (*(void (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    if (v7) {
      *(short float *)&__int16 result = (short float)v8;
    }
    else {
      *(short float *)&__int16 result = (short float)(unint64_t)v8;
    }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    return v9;
  }
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Float16@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = Float16.init<A>(exactly:)(a1, a2, a3);
  *(_WORD *)a4 = result;
  *(unsigned char *)(a4 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t Float16.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v22 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) <= 64)
  {
    char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v8, a1, a2);
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    long long v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v8, a2);
    v15(a1, a2);
    if (v13)
    {
      *(short float *)&int v16 = (short float)v14;
      int v12 = v16;
      int v17 = ~v16 & 0x7C00;
      uint64_t v18 = (uint64_t)(short float)v14;
    }
    else
    {
      *(short float *)&int v16 = (short float)(unint64_t)v14;
      int v12 = v16;
      int v17 = ~v16 & 0x7C00;
      uint64_t v18 = (unint64_t)(short float)(unint64_t)v14;
    }
    if (v17) {
      BOOL v19 = v14 == v18;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19) {
      goto LABEL_12;
    }
  }
  else
  {
    char v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)((__int16 *)&v23, a1, a2, a3);
    (*(void (**)(char *, uint64_t))(v6 + 8))(a1, a2);
    if (v11)
    {
      int v12 = v23;
LABEL_12:
      int v20 = 0;
      return v12 | (v20 << 16);
    }
  }
  int v12 = 0;
  int v20 = 1;
  return v12 | (v20 << 16);
}

void protocol witness for static FloatingPoint.nan.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 512);
  *a1 = LOWORD(v2);
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 256);
  *a1 = LOWORD(v2);
}

__int16 protocol witness for static FloatingPoint.infinity.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result = 31744;
  *a1 = 31744;
  return result;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 30, 1023);
  *a1 = LOWORD(v2);
}

__int16 protocol witness for static FloatingPoint.pi.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result = 16968;
  *a1 = 16968;
  return result;
}

void protocol witness for FloatingPoint.ulp.getter in conformance Float16(_WORD *a1@<X8>)
{
  unsigned int v3 = *v1;
  int v4 = (v3 >> 10) & 0x1F;
  if (v4)
  {
    if (v4 == 31) {
      float v5 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 512);
    }
    else {
      *(short float *)&float v5 = COERCE_SHORT_FLOAT(v3 & 0x7C00) * COERCE_SHORT_FLOAT(5120);
    }
  }
  else
  {
    LOWORD(v5) = 1;
  }
  *a1 = LOWORD(v5);
}

__int16 protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result = 5120;
  *a1 = 5120;
  return result;
}

__int16 protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result = 1024;
  *a1 = 1024;
  return result;
}

__int16 protocol witness for static FloatingPoint.leastNonzeroMagnitude.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result = 1;
  *a1 = 1;
  return result;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Float16(float a1)
{
  LOWORD(a1) = *v1;
  return Float16.sign.getter(a1);
}

uint64_t protocol witness for FloatingPoint.exponent.getter in conformance Float16@<X0>(uint64_t *a1@<X8>, float a2@<S0>)
{
  LOWORD(a2) = *v2;
  uint64_t result = Float16.exponent.getter(a2);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Float16(_WORD *a1@<X8>, float a2@<S0>)
{
  LOWORD(a2) = *v2;
  float v4 = Float16.significand.getter(a2);
  *a1 = LOWORD(v4);
}

short float protocol witness for static FloatingPoint./ infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>, short float *a3@<X8>)
{
  short float result = *a1 / *a2;
  *a3 = result;
  return result;
}

__int16 static Float16./ infix(_:_:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *(short float *)a1.n128_u16 / *(short float *)a2.n128_u16;
  return result;
}

__int16 protocol witness for static FloatingPoint./= infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>)
{
  *(short float *)&__int16 result = *a1 / *a2;
  *a1 = *(short float *)&result;
  return result;
}

__int16 protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H1 = *a1;
  _H0 = *v2;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = _stdlib_remainderf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>)
{
  _H1 = *a1;
  _H0 = *v1;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = _stdlib_remainderf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *unsigned int v1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H1 = *a1;
  _H0 = *v2;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>)
{
  _H1 = *a1;
  _H0 = *v1;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *unsigned int v1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.squareRoot() in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  _H0 = *v1;
  __asm { FCVT            S0, H0 }
  _S0 = _stdlib_squareRootf(_S0);
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formSquareRoot() in conformance Float16@<H0>()
{
  _H0 = *v0;
  __asm { FCVT            S0, H0 }
  _S0 = _stdlib_squareRootf(_S0);
  __asm { FCVT            H0, S0 }
  __int16 *v0 = result;
  return result;
}

short float protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>, short float *a3@<X8>)
{
  short float result = *v3 + (short float)(*a1 * *a2);
  *a3 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.addProduct(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>)
{
  *(short float *)&__int16 result = *v2 + (short float)(*a1 * *a2);
  *float v2 = *(short float *)&result;
  return result;
}

short float *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Float16@<X0>(short float *result@<X0>, _WORD *a2@<X1>, short float *a3@<X8>, float a4@<S1>)
{
  short float v4 = *result;
  LOWORD(a4) = *a2;
  if (*result <= *(short float *)a2) {
    goto LABEL_7;
  }
  if ((~LODWORD(a4) & 0x7C00) != 0)
  {
    short float v4 = *(short float *)a2;
LABEL_7:
    *a3 = v4;
    return result;
  }
  if ((LOWORD(a4) & 0x3FF) == 0) {
    short float v4 = *(short float *)a2;
  }
  *a3 = v4;
  return result;
}

short float *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Float16@<X0>(short float *result@<X0>, _WORD *a2@<X1>, short float *a3@<X8>, float a4@<S1>)
{
  short float v4 = *result;
  LOWORD(a4) = *a2;
  if (*(short float *)a2 < *result) {
    goto LABEL_7;
  }
  if ((~LODWORD(a4) & 0x7C00) != 0)
  {
    short float v4 = *(short float *)a2;
LABEL_7:
    *a3 = v4;
    return result;
  }
  if ((LOWORD(a4) & 0x3FF) == 0) {
    short float v4 = *(short float *)a2;
  }
  *a3 = v4;
  return result;
}

short float *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Float16@<X0>(short float *result@<X0>, short float *a2@<X1>, short float *a3@<X8>, float a4@<S1>)
{
  short float v4 = *result;
  *(short float *)&a4 = *a2;
  if (fabsl(*result) <= fabsl(*a2)) {
    goto LABEL_7;
  }
  if ((~LODWORD(a4) & 0x7C00) != 0)
  {
    short float v4 = *a2;
LABEL_7:
    *a3 = v4;
    return result;
  }
  if ((LOWORD(a4) & 0x3FF) == 0) {
    short float v4 = *a2;
  }
  *a3 = v4;
  return result;
}

short float *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Float16@<X0>(short float *result@<X0>, short float *a2@<X1>, short float *a3@<X8>, float a4@<S1>)
{
  short float v4 = *result;
  *(short float *)&a4 = *a2;
  if (fabsl(*a2) < fabsl(*result)) {
    goto LABEL_7;
  }
  if ((~LODWORD(a4) & 0x7C00) != 0)
  {
    short float v4 = *a2;
LABEL_7:
    *a3 = v4;
    return result;
  }
  if ((LOWORD(a4) & 0x3FF) == 0) {
    short float v4 = *a2;
  }
  *a3 = v4;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Float16(unsigned char *a1@<X0>, short float *a2@<X8>)
{
  LOWORD(v3) = *v2;
  short float v6 = *(short float *)v2;
  switch(*a1)
  {
    case 0:
      short float v5 = roundl(*(short float *)&v3);
      break;
    case 1:
      short float v5 = rintl(*(short float *)&v3);
      break;
    case 2:
      goto LABEL_8;
    case 3:
      goto LABEL_7;
    case 4:
      short float v5 = truncl(*(short float *)&v3);
      break;
    case 5:
      if (Float16.sign.getter(v3)) {
LABEL_7:
      }
        short float v5 = floorl(*(short float *)&v3);
      else {
LABEL_8:
      }
        short float v5 = ceill(*(short float *)&v3);
      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      short float v5 = v6;
      break;
  }
  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Float16(unsigned char *a1)
{
  switch(*a1)
  {
    case 0:
      short float v3 = roundl(*v1);
      goto LABEL_13;
    case 1:
      short float v3 = rintl(*v1);
      goto LABEL_13;
    case 2:
      short float v3 = ceill(*v1);
      goto LABEL_13;
    case 3:
      short float v3 = floorl(*v1);
      goto LABEL_13;
    case 4:
      short float v3 = truncl(*v1);
      goto LABEL_13;
    case 5:
      *(short float *)&float v2 = *v1;
      if (Float16.sign.getter(v2)) {
        short float v3 = floorl(*(short float *)&v2);
      }
      else {
        short float v3 = ceill(*(short float *)&v2);
      }
LABEL_13:
      *unsigned int v1 = v3;
      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Float16(_WORD *a1@<X8>, int a2@<S0>)
{
  *(short float *)&a2 = *v2 + COERCE_SHORT_FLOAT(0);
  if (*(short float *)&a2 < COERCE_SHORT_FLOAT(31744)) {
    a2 += ((__int16)a2 >> 15) | 1;
  }
  *a1 = a2;
}

short float protocol witness for FloatingPoint.nextDown.getter in conformance Float16@<H0>(short float *a1@<X8>, int a2@<S0>)
{
  *(short float *)&a2 = COERCE_SHORT_FLOAT(0) - *v2;
  if (*(short float *)&a2 < COERCE_SHORT_FLOAT(31744)) {
    a2 += ((__int16)a2 >> 15) | 1;
  }
  short float result = -*(short float *)&a2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Float16(short float *a1)
{
  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Float16(short float *a1)
{
  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Float16(short float *a1)
{
  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Float16(unsigned __int16 *a1, __n128 a2, __n128 a3)
{
  a2.n128_u16[0] = *a1;
  a3.n128_u16[0] = *v3;
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(a2, a3);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Float16()
{
  int v1 = (*v0 >> 10) & 0x1F;
  return v1 != 31 && v1 != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Float16()
{
  return (~*v0 & 0x7C00) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Float16()
{
  return (*v0 & 0x7FFF) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Float16()
{
  return (*v0 & 0x3FF) != 0 && (*v0 & 0x7C00) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Float16()
{
  return (*v0 & 0x7FFF) == 31744;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Float16()
{
  int v1 = *v0;
  return (v1 & 0x3FF) != 0 && (~v1 & 0x7C00) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Float16()
{
  int v1 = *v0;
  int v2 = ~v1 & 0x7C00;
  int v3 = v1 & 0x3FF;
  BOOL v4 = (v1 & 0x200) == 0;
  if (v2) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == 0;
  }
  return !v5 && v4;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Float16(float a1)
{
  LOWORD(a1) = *v1;
  return specialized FloatingPoint.floatingPointClass.getter(a1);
}

__int16 protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X8>)
{
  __int16 result = *a1;
  *a2 = *a1;
  return result;
}

short float protocol witness for static SignedNumeric.- prefix(_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X8>)
{
  short float result = -*a1;
  *a2 = result;
  return result;
}

__int16 protocol witness for SignedNumeric.negate() in conformance Float16@<H0>()
{
  *(short float *)&__int16 result = -*v0;
  short float *v0 = *(short float *)&result;
  return result;
}

short float protocol witness for Numeric.magnitude.getter in conformance Float16@<H0>(short float *a1@<X8>)
{
  short float result = fabsl(*v1);
  *a1 = result;
  return result;
}

short float Float16.magnitude.getter(__n128 a1)
{
  return fabsl(*(short float *)a1.n128_u16);
}

short float protocol witness for static Numeric.* infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>, short float *a3@<X8>)
{
  short float result = *a1 * *a2;
  *a3 = result;
  return result;
}

__int16 protocol witness for static Numeric.*= infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>)
{
  *(short float *)&__int16 result = *a2 * *a1;
  *a1 = *(short float *)&result;
  return result;
}

double protocol witness for static AdditiveArithmetic.zero.getter in conformance Float16@<D0>(_WORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0;
  return result;
}

short float protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>, short float *a3@<X8>)
{
  short float result = *a1 + *a2;
  *a3 = result;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>)
{
  *(short float *)&__int16 result = *a2 + *a1;
  *a1 = *(short float *)&result;
  return result;
}

short float protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>, short float *a3@<X8>)
{
  short float result = *a1 - *a2;
  *a3 = result;
  return result;
}

__int16 static Float16.- infix(_:_:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *(short float *)a1.n128_u16 - *(short float *)a2.n128_u16;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X1>)
{
  *(short float *)&__int16 result = *a1 - *a2;
  *a1 = *(short float *)&result;
  return result;
}

__int16 Float16.init(integerLiteral:)@<H0>(uint64_t a1@<X0>)
{
  *(short float *)&__int16 result = (short float)a1;
  return result;
}

__int16 protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Float16@<H0>(uint64_t *a1@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  _S0 = swift_intToFloat32(a1, a2);
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

short float protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Float16@<H0>(uint64_t *a1@<X0>, short float *a2@<X8>)
{
  short float result = (short float)*a1;
  *a2 = result;
  return result;
}

void Float16.hash(into:)(__n128 a1)
{
  if ((a1.n128_u16[0] & 0x7FFF) != 0) {
    Swift::UInt16 v1 = a1.n128_u16[0];
  }
  else {
    Swift::UInt16 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Float16._rawHashValue(seed:)(Swift::Int seed)
{
  if ((v1 & 0x7FFF) != 0) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v2, 2);
}

uint64_t Float16.hashValue.getter(float a1)
{
  if ((LOWORD(a1) & 0x7FFF) != 0) {
    uint64_t v1 = LODWORD(a1);
  }
  else {
    uint64_t v1 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 2);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Float16()
{
  if ((*v0 & 0x7FFF) != 0) {
    uint64_t v1 = (unsigned __int16)*v0;
  }
  else {
    uint64_t v1 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 2);
}

void protocol witness for Hashable.hash(into:) in conformance Float16()
{
  if ((*v0 & 0x7FFF) != 0) {
    Swift::UInt16 v1 = *v0;
  }
  else {
    Swift::UInt16 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Float16(uint64_t a1)
{
  if ((*v1 & 0x7FFF) != 0) {
    uint64_t v2 = (unsigned __int16)*v1;
  }
  else {
    uint64_t v2 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(a1, v2, 2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Float16(short float *a1, short float *a2)
{
  return *a1 == *a2;
}

uint64_t Int.init(_:)(float a1)
{
  return Int.init(_:)("Float16 value cannot be converted to Int because it is either infinite or NaN", 77, 0x36A2uLL, a1);
}

unint64_t UInt.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3093uLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt because the result would be less than UInt.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3096uLL, 0);
  }
  return (unint64_t)*(short float *)&a1;
}

uint64_t Float16.init(exactly:)(float a1)
{
  return LODWORD(a1);
}

uint64_t Float16.init(exactly:)(float _S0, float _S1)
{
  __asm
  {
    FCVT            H1, S0
    FCVT            S2, H1
  }
  float v7 = _S1;
  if (_S2 != _S0) {
    float v7 = 0.0;
  }
  return LODWORD(v7) | ((_S2 != _S0) << 16);
}

uint64_t Float16.init(exactly:)(double _D0, float _S1)
{
  __asm
  {
    FCVT            H1, D0
    FCVT            D2, H1
  }
  float v7 = _S1;
  if (_D2 != _D0) {
    float v7 = 0.0;
  }
  return LODWORD(v7) | ((_D2 != _D0) << 16);
}

double Double.init(_:)(__n128 _Q0)
{
  __asm { FCVT            D0, H0 }
  return result;
}

__int16 Float16.distance(to:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *(short float *)a1.n128_u16 - *(short float *)a2.n128_u16;
  return result;
}

__int16 Float16.advanced(by:)@<H0>(__n128 a1@<Q0>, __n128 a2@<Q1>)
{
  *(short float *)&__int16 result = *(short float *)a1.n128_u16 + *(short float *)a2.n128_u16;
  return result;
}

short float protocol witness for Strideable.distance(to:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X8>)
{
  short float result = *a1 - *v2;
  *a2 = result;
  return result;
}

short float protocol witness for Strideable.advanced(by:) in conformance Float16@<H0>(short float *a1@<X0>, short float *a2@<X8>)
{
  short float result = *a1 + *v2;
  *a2 = result;
  return result;
}

short float *protocol witness for static Strideable._step(after:from:by:) in conformance Float16(short float *result, uint64_t a2, char a3, short float *a4, short float *a5, short float *a6)
{
  short float v6 = *a6;
  if (a3)
  {
    short float v8 = v6 + *a4;
    goto LABEL_5;
  }
  if (!__OFADD__(a2++, 1))
  {
    short float v8 = *a5 + (short float)((short float)a2 * v6);
LABEL_5:
    *short float result = v8;
    return (short float *)a2;
  }
  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Float16(short float *a1, short float *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Float16(short float *a1, short float *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Float16(short float *a1, short float *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Float16(short float *a1, short float *a2)
{
  return *a2 < *a1;
}

void Float._value.setter(float a1)
{
  *Swift::UInt16 v1 = a1;
}

uint64_t (*Float._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Float __swiftcall Float.init()()
{
  return 0.0;
}

unint64_t Float.description.getter(float a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((~LODWORD(a1) & 0x7F800000) == 0 && (LODWORD(a1) & 0x7FFFFF) != 0) {
    return 7233902;
  }
  long long v14 = 0u;
  long long v15 = 0u;
  int64_t v2 = swift_float32ToString(&v14, 32, 0);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  size_t v3 = v2;
  if (!v2) {
    return 0;
  }
  if ((unint64_t)v2 <= 0xF)
  {
    uint64_t v7 = v2 - 8;
    uint64_t v8 = 8;
    if (v2 < 8) {
      uint64_t v8 = v2;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v9 = 0;
    if (v3 >= 9)
    {
      uint64_t v10 = 0;
      char v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    unint64_t v4 = v2 | 0xF000000000000000;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v4 = *(void *)(v5 + 24);
    }
    *(unsigned char *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }
  return result;
}

BOOL Float.isNaN.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFF) != 0 && (~LODWORD(a1) & 0x7F800000) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Float()
{
  return Float.description.getter(*v0);
}

unint64_t Float.debugDescription.getter()
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  int64_t v0 = swift_float32ToString(&v13, 32, 1);
  __src[0] = v13;
  __src[1] = v14;
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  size_t v1 = v0;
  if (!v0) {
    return 0;
  }
  if ((unint64_t)v0 <= 0xF)
  {
    uint64_t v6 = v0 - 8;
    uint64_t v7 = 8;
    if (v0 < 8) {
      uint64_t v7 = v0;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v7 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v7 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v7 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v7 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v7 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v7 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v7 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v8 = 0;
    if (v1 >= 9)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (unsigned __int8 *)__src + 8;
      unint64_t v11 = v6 & ~(v6 >> 63);
      do
      {
        if (v11 <= v1 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v12 = *v10++;
        v8 |= (unint64_t)v12 << v9;
        v9 += 8;
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    unint64_t v2 = v0 | 0xF000000000000000;
    int64_t v3 = _allocateStringStorage(codeUnitCapacity:)(v0);
    *(void *)(v3 + 16) = v4;
    *(void *)(v3 + 24) = v2;
    if (v4 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v2 = *(void *)(v3 + 24);
    }
    *(unsigned char *)(v3 + 32 + (v2 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v1, (char *)(v3 + 32));
    return *(void *)(v3 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Float()
{
  return Float.debugDescription.getter();
}

void specialized Float.write<A>(to:)()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  memset(v1, 0, sizeof(v1));
  uint64_t v0 = swift_float32ToString(v1, 32, 1);
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  _StringGuts.append(_:)(v0 | 0xD000000000000000, (unint64_t)&v1[0x7FFFFFFFFFFFFFELL] | 0x8000000000000000);
}

uint64_t Float.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v5 = swift_float32ToString(v7, 32, 1);
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a3 + 32))(v7, v5, a2, a3);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Float(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Float.write<A>(to:)(a1, a2, a3);
}

uint64_t static Float.exponentBitCount.getter()
{
  return 8;
}

uint64_t static Float.significandBitCount.getter()
{
  return 23;
}

uint64_t static Float._infinityExponent.getter()
{
  return 255;
}

uint64_t static Float._exponentBias.getter()
{
  return 127;
}

uint64_t static Float._significandMask.getter()
{
  return 0x7FFFFFLL;
}

uint64_t static Float._quietNaNMask.getter()
{
  return 0x400000;
}

Swift::Float __swiftcall Float.init(bitPattern:)(Swift::UInt32 bitPattern)
{
  return *(float *)&bitPattern;
}

uint64_t Float.sign.getter(float a1)
{
  return LODWORD(a1) >> 31;
}

uint64_t Float.exponentBitPattern.getter(float a1)
{
  return (LODWORD(a1) >> 23);
}

uint64_t Float.significandBitPattern.getter(float a1)
{
  return LODWORD(a1) & 0x7FFFFF;
}

uint64_t Float.isCanonical.getter()
{
  return 1;
}

float static Float.leastNonzeroMagnitude.getter()
{
  LODWORD(result) = 1;
  return result;
}

float static Float.leastNormalMagnitude.getter()
{
  return 1.1755e-38;
}

float static Float.infinity.getter()
{
  return INFINITY;
}

float static Float.nan.getter()
{
  return NAN;
}

float static Float.signalingNaN.getter()
{
  return NAN;
}

Swift::Float __swiftcall Float.init(nan:signaling:)(Swift::UInt32 nan, Swift::Bool signaling)
{
  if (nan >= 0x200000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "NaN payload is not encodable.", 29, 2, "Swift/FloatingPointTypes.swift", 30, 2, 0x61AuLL, 0);
  }
  LODWORD(result) = (0x400000u >> signaling) | nan | 0x7F800000;
  return result;
}

float static Float.greatestFiniteMagnitude.getter()
{
  return 3.4028e38;
}

float static Float.pi.getter()
{
  return 3.1416;
}

float Float.ulp.getter(float a1)
{
  int v2 = (LODWORD(a1) >> 23);
  if ((LODWORD(a1) >> 23))
  {
    float result = NAN;
    if (v2 != 255) {
      return COERCE_FLOAT(LODWORD(a1) & 0x7F800000) * 0.00000011921;
    }
  }
  else
  {
    LODWORD(result) = 1;
  }
  return result;
}

BOOL Float.isNormal.getter(float a1)
{
  return (LODWORD(a1) >> 23) != 255 && (LODWORD(a1) >> 23) != 0;
}

double static Float.ulpOfOne.getter()
{
  return 3.18618444e-58;
}

uint64_t Float.exponent.getter(float a1)
{
  uint64_t v1 = (LODWORD(a1) >> 23);
  if (v1 == 255) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unsigned int v3 = LODWORD(a1) & 0x7FFFFF;
  if (!(v1 | LODWORD(a1) & 0x7FFFFF)) {
    return 0x8000000000000000;
  }
  if ((LODWORD(a1) >> 23)) {
    return v1 - 127;
  }
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return v1 - __clz(v3) - 118;
}

BOOL Float.isZero.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 0;
}

float Float.significand.getter(float result)
{
  int v1 = (LODWORD(result) >> 23);
  unsigned int v2 = LODWORD(result) & 0x7FFFFF;
  if ((LODWORD(result) & 0x7FFFFF) == 0 || v1 != 255)
  {
    if ((LODWORD(result) >> 23))
    {
      if (v1 != 255)
      {
        LODWORD(result) = v2 | 0x3F800000;
        return result;
      }
    }
    else if (v2)
    {
      LODWORD(result) = (LODWORD(result) << (__clz(v2) + 24)) & 0x7FFFFF | 0x3F800000;
      return result;
    }
    LODWORD(result) = v1 << 23;
  }
  return result;
}

BOOL Float.isSubnormal.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFF) != 0 && (LODWORD(a1) & 0x7F800000) == 0;
}

Swift::Float __swiftcall Float.init(sign:exponent:significand:)(Swift::FloatingPointSign sign, Swift::Int exponent, Swift::Float significand)
{
  return specialized Float.init(sign:exponent:significand:)(sign & 1, exponent, significand);
}

float static Float.- prefix(_:)(float a1)
{
  return -a1;
}

float static Float.*= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 * a2;
  *a1 = result;
  return result;
}

float Float.nextUp.getter(float a1)
{
  float result = a1 + 0.0;
  if (result < INFINITY) {
    LODWORD(result) += (SLODWORD(result) >> 31) | 1;
  }
  return result;
}

float static Float.+ infix(_:_:)(float a1, float a2)
{
  return a1 + a2;
}

uint64_t static Int32.&>> infix(_:_:)(int a1, char a2)
{
  return (a1 >> a2);
}

uint64_t static Int32.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

Swift::Float __swiftcall Float.init(signOf:magnitudeOf:)(Swift::Float signOf, Swift::Float magnitudeOf)
{
  v2.i64[0] = 0x8000000080000000;
  v2.i64[1] = 0x8000000080000000;
  LODWORD(result) = vbslq_s8(v2, *(int8x16_t *)&magnitudeOf, *(int8x16_t *)&signOf).u32[0];
  return result;
}

Swift::Void __swiftcall Float.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  switch(*(unsigned char *)a1)
  {
    case 0:
      *int v1 = roundf(*v1);
      return;
    case 1:
      *int v1 = rintf(*v1);
      return;
    case 2:
      float v2 = *v1;
      goto LABEL_9;
    case 3:
      float v2 = *v1;
      goto LABEL_10;
    case 4:
      *int v1 = truncf(*v1);
      return;
    case 5:
      float v2 = *v1;
      if ((*(_DWORD *)v1 & 0x80000000) != 0) {
LABEL_10:
      }
        *int v1 = floorf(v2);
      else {
LABEL_9:
      }
        *int v1 = ceilf(v2);
      break;
    default:
      Float._roundSlowPath(_:)(a1);
      break;
  }
}

Swift::Void __swiftcall Float._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  char v4 = *(unsigned char *)a1;
  switch(v4)
  {
    case 0:
      float v2 = roundf(*v1);
      goto LABEL_11;
    case 1:
      float v2 = rintf(*v1);
      goto LABEL_11;
    case 2:
      float v3 = *v1;
      goto LABEL_9;
    case 3:
      float v3 = *v1;
      goto LABEL_10;
    case 4:
      float v2 = truncf(*v1);
      goto LABEL_11;
    case 5:
      float v3 = *v1;
      if ((*(_DWORD *)v1 & 0x80000000) != 0) {
LABEL_10:
      }
        float v2 = floorf(v3);
      else {
LABEL_9:
      }
        float v2 = ceilf(v3);
LABEL_11:
      *int v1 = v2;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }
}

Swift::Void __swiftcall Float.negate()()
{
  float *v0 = -*v0;
}

float static Float.+= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 + a2;
  *a1 = result;
  return result;
}

float static Float.-= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 - a2;
  *a1 = result;
  return result;
}

float static Float./= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 / a2;
  *a1 = result;
  return result;
}

Swift::Void __swiftcall Float.formRemainder(dividingBy:)(Swift::Float dividingBy)
{
  *int v1 = remainderf(*v1, dividingBy);
}

Swift::Void __swiftcall Float.formTruncatingRemainder(dividingBy:)(Swift::Float dividingBy)
{
  *int v1 = fmodf(*v1, dividingBy);
}

Swift::Void __swiftcall Float.formSquareRoot()()
{
  float *v0 = sqrtf(*v0);
}

Swift::Void __swiftcall Float.addProduct(_:_:)(Swift::Float a1, Swift::Float a2)
{
  *float v2 = *v2 + (float)(a1 * a2);
}

Swift::Bool __swiftcall Float.isEqual(to:)(Swift::Float to)
{
  return v1 == to;
}

Swift::Bool __swiftcall Float.isLess(than:)(Swift::Float than)
{
  return v1 < than;
}

Swift::Bool __swiftcall Float.isLessThanOrEqualTo(_:)(Swift::Float a1)
{
  return v1 <= a1;
}

BOOL Float.isInfinite.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 2139095040;
}

BOOL Float.isSignalingNaN.getter(float a1)
{
  return (~LODWORD(a1) & 0x7F800000) == 0 && (LODWORD(a1) & 0x7FFFFF) != 0 && (LODWORD(a1) & 0x400000) == 0;
}

float Float.binade.getter(float a1)
{
  if ((LODWORD(a1) >> 23) == 255) {
    return NAN;
  }
  if ((LODWORD(a1) & 0x7FFFFF) != 0 && !(LODWORD(a1) >> 23)) {
    return COERCE_FLOAT(COERCE_UNSIGNED_INT(a1 * 8388600.0) & 0xFF800000) * 0.00000011921;
  }
  LODWORD(result) = LODWORD(a1) & 0xFF800000;
  return result;
}

uint64_t Float.significandWidth.getter(float a1)
{
  unsigned int v1 = LODWORD(a1) & 0x7FFFFF;
  unsigned int v2 = __clz(__rbit32(LODWORD(a1) & 0x7FFFFF));
  if ((LODWORD(a1) >> 23) && (LODWORD(a1) >> 23) != 255)
  {
    uint64_t v5 = 23 - v2;
    if (v1) {
      return v5;
    }
    else {
      return 0;
    }
  }
  else
  {
    uint64_t result = -1;
    if ((LODWORD(a1) & 0x7F800000) == 0)
    {
      uint64_t v4 = 32 - (__clz(v1) + v2 + 1);
      if (v1) {
        return v4;
      }
    }
  }
  return result;
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Float(char a1@<W0>, void *a2@<X1>, int *a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
}

void protocol witness for BinaryFloatingPoint.init(_:) in conformance Float(float *a1@<X8>, float a2@<S0>)
{
  *a1 = a2;
}

float protocol witness for BinaryFloatingPoint.init(_:) in conformance Float@<S0>(float *a1@<X8>, double a2@<D0>)
{
  float result = a2;
  *a1 = result;
  return result;
}

Swift::Float __swiftcall Float.init(_:)(Swift::Double a1)
{
  return a1;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Float(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
}

unint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Float@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_DWORD *)a4 = result;
  *(unsigned char *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Float()
{
  return 23;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Float(void *a1@<X8>)
{
  *a1 = ((unint64_t)*v1 >> 23);
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Float(int *a1@<X8>)
{
  *a1 = *v1 & 0x7FFFFF;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Float(float *a1@<X8>)
{
  *a1 = Float.binade.getter(*v1);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Float()
{
  return Float.significandWidth.getter(*v0);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Float(char a1@<W0>, uint64_t *a2@<X1>, float *a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized Float.init(sign:exponent:significand:)(a1 & 1, *a2, *a3);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Float@<D0>(unsigned __int32 *a1@<X0>, unsigned __int32 *a2@<X1>, _DWORD *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  a4.i32[0] = *a1;
  a5.i32[0] = *a2;
  v5.i64[0] = 0x8000000080000000;
  v5.i64[1] = 0x8000000080000000;
  a4.i64[0] = vbslq_s8(v5, a5, a4).u64[0];
  *a3 = a4.i32[0];
  return *(double *)a4.i64;
}

float protocol witness for FloatingPoint.init(_:) in conformance Float@<S0>(uint64_t a1@<X0>, float *a2@<X8>)
{
  float result = (float)a1;
  *a2 = (float)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Float@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>, float *a4@<X8>)
{
  if (a3[16](a2, a3) < 65)
  {
    char v10 = a3[8](a2, a3);
    uint64_t v11 = a3[15](a2, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    if (v10) {
      float v9 = (float)v11;
    }
    else {
      float v9 = (float)(unint64_t)v11;
    }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unsigned int *)&v12, a1, a2, (uint64_t)a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    float v9 = v12;
  }
  *a4 = v9;
  return result;
}

float Float.init<A>(_:)(char *a1, uint64_t a2, uint64_t (**a3)(void, void))
{
  if (a3[16](a2, a3) <= 64)
  {
    char v7 = a3[8](a2, a3);
    uint64_t v8 = a3[15](a2, a3);
    (*(void (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    if (v7) {
      return (float)v8;
    }
    else {
      return (float)(unint64_t)v8;
    }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unsigned int *)&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    return v9;
  }
}

unint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Float@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = Float.init<A>(exactly:)(a1, a2, a3);
  *(_DWORD *)a4 = result;
  *(unsigned char *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t Float.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) <= 64)
  {
    char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v8, a1, a2);
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    long long v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v8, a2);
    if (v13)
    {
      float v16 = (float)v14;
      if ((float)v14 < 9.2234e18)
      {
        float v12 = (float)v14;
        if ((~LODWORD(v16) & 0x7F800000) == 0) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int because it is either infinite or NaN", 75, 2, "Swift/IntegerTypes.swift", 24, 2, 0x36EDuLL, 0);
        }
        if (v16 <= -9.2234e18) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int because the result would be less than Int.min", 84, 2, "Swift/IntegerTypes.swift", 24, 2, 0x36F0uLL, 0);
        }
        v15(a1, a2);
        if (v14 == (uint64_t)v16) {
          goto LABEL_13;
        }
LABEL_15:
        uint64_t v19 = 0;
        unsigned __int8 v18 = 1;
        goto LABEL_16;
      }
    }
    else
    {
      float v17 = (float)(unint64_t)v14;
      if ((float)(unint64_t)v14 < 1.8447e19)
      {
        float v12 = (float)(unint64_t)v14;
        if ((~LODWORD(v17) & 0x7F800000) == 0) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E1uLL, 0);
        }
        v15(a1, a2);
        if (v14 == (unint64_t)v17) {
          goto LABEL_13;
        }
        goto LABEL_15;
      }
    }
    v15(a1, a2);
    goto LABEL_15;
  }
  char v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)((unsigned int *)&v22, a1, a2, a3);
  (*(void (**)(char *, uint64_t))(v6 + 8))(a1, a2);
  if ((v11 & 1) == 0) {
    goto LABEL_15;
  }
  float v12 = v22;
LABEL_13:
  unsigned __int8 v18 = 0;
  uint64_t v19 = LODWORD(v12);
LABEL_16:
  unsigned __int8 v23 = v18;
  return v19 | ((unint64_t)v18 << 32);
}

void protocol witness for static FloatingPoint.nan.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2143289344;
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Float(float *a1@<X8>)
{
  *a1 = specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(0, 0xFFu, 0x200000);
}

void protocol witness for static FloatingPoint.infinity.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2139095040;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2139095039;
}

void protocol witness for static FloatingPoint.pi.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 1078530010;
}

float protocol witness for FloatingPoint.ulp.getter in conformance Float@<S0>(float *a1@<X8>)
{
  if ((*v1 >> 23))
  {
    if ((*v1 >> 23) != 255)
    {
      float result = COERCE_FLOAT(*v1 & 0x7F800000) * 0.00000011921;
      *a1 = result;
      return result;
    }
    float v3 = NAN;
  }
  else
  {
    LODWORD(v3) = 1;
  }
  float result = v3;
  *a1 = v3;
  return result;
}

void protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 872415232;
}

void protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 0x800000;
}

void protocol witness for static FloatingPoint.leastNonzeroMagnitude.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 1;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Float()
{
  return Float.sign.getter(*v0);
}

uint64_t protocol witness for FloatingPoint.exponent.getter in conformance Float@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = Float.exponent.getter(*v1);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Float(float *a1@<X8>)
{
  *a1 = Float.significand.getter(*v1);
}

float protocol witness for static FloatingPoint./ infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 / *a2;
  *a3 = result;
  return result;
}

float static Float./ infix(_:_:)(float a1, float a2)
{
  return a1 / a2;
}

float protocol witness for static FloatingPoint./= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *a1 / *a2;
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Float(float *a1@<X0>, float *a2@<X8>)
{
  *a2 = _stdlib_remainderf(*v2, *a1);
}

void protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Float(float *a1)
{
  *unsigned int v1 = _stdlib_remainderf(*v1, *a1);
}

void protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Float(float *a1@<X0>, float *a2@<X8>)
{
  *a2 = fmodf(*v2, *a1);
}

void protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Float(float *a1)
{
  *unsigned int v1 = fmodf(*v1, *a1);
}

void protocol witness for FloatingPoint.squareRoot() in conformance Float(float *a1@<X8>)
{
  *a1 = _stdlib_squareRootf(*v1);
}

void protocol witness for FloatingPoint.formSquareRoot() in conformance Float()
{
  float *v0 = _stdlib_squareRootf(*v0);
}

float protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *v3 + (float)(*a1 * *a2);
  *a3 = result;
  return result;
}

float protocol witness for FloatingPoint.addProduct(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *v2 + (float)(*a1 * *a2);
  *unsigned int v2 = result;
  return result;
}

float *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (*result > *a2)
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (*a2 >= *result)
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (fabsf(*result) > fabsf(*a2))
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (fabsf(*a2) >= fabsf(*result))
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Float(unsigned char *a1@<X0>, float *a2@<X8>)
{
  float v4 = *v2;
  float v8 = *v2;
  switch(*a1)
  {
    case 0:
      float v5 = roundf(v4);
      break;
    case 1:
      float v5 = rintf(v4);
      break;
    case 2:
      float v5 = ceilf(v4);
      break;
    case 3:
      float v5 = floorf(v4);
      break;
    case 4:
      float v5 = truncf(v4);
      break;
    case 5:
      char v6 = Float.sign.getter(v4);
      float v5 = ceilf(v4);
      float v7 = floorf(v4);
      if (v6) {
        float v5 = v7;
      }
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      float v5 = v8;
      break;
  }
  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Float(unsigned char *a1)
{
  switch(*a1)
  {
    case 0:
      float v2 = roundf(*v1);
      goto LABEL_13;
    case 1:
      float v2 = rintf(*v1);
      goto LABEL_13;
    case 2:
      float v2 = ceilf(*v1);
      goto LABEL_13;
    case 3:
      float v2 = floorf(*v1);
      goto LABEL_13;
    case 4:
      float v2 = truncf(*v1);
      goto LABEL_13;
    case 5:
      float v3 = *v1;
      if (Float.sign.getter(*v1)) {
        float v2 = floorf(v3);
      }
      else {
        float v2 = ceilf(v3);
      }
LABEL_13:
      *unsigned int v1 = v2;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Float(float *a1@<X8>)
{
  float v2 = *v1 + 0.0;
  if (v2 < INFINITY) {
    LODWORD(v2) += (SLODWORD(v2) >> 31) | 1;
  }
  *a1 = v2;
}

float protocol witness for FloatingPoint.nextDown.getter in conformance Float@<S0>(float *a1@<X8>)
{
  float v2 = 0.0 - *v1;
  if (v2 < INFINITY) {
    LODWORD(v2) += (SLODWORD(v2) >> 31) | 1;
  }
  float result = -v2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Float(float *a1)
{
  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Float(float *a1)
{
  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Float(float *a1)
{
  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Float(float *a1)
{
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(*a1, *v1);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Float()
{
  return (*v0 >> 23) != 255 && (*v0 >> 23) != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Float()
{
  return (~*v0 & 0x7F800000) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Float()
{
  return (*v0 & 0x7FFFFFFF) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Float()
{
  return (*v0 & 0x7FFFFF) != 0 && (*v0 & 0x7F800000) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Float()
{
  return (*v0 & 0x7FFFFFFF) == 2139095040;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Float()
{
  return (*v0 & 0x7FFFFF) != 0 && (~*v0 & 0x7F800000) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Float()
{
  return (~*v0 & 0x7F800000) == 0 && (*v0 & 0x7FFFFF) != 0 && (*v0 & 0x400000) == 0;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Float()
{
  return specialized FloatingPoint.floatingPointClass.getter(*v0);
}

float protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Float@<S0>(float *a1@<X0>, _DWORD *a2@<X8>)
{
  float result = *a1;
  *a2 = *(_DWORD *)a1;
  return result;
}

float protocol witness for static SignedNumeric.- prefix(_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float result = -*a1;
  *a2 = result;
  return result;
}

float protocol witness for SignedNumeric.negate() in conformance Float()
{
  float result = -*v0;
  float *v0 = result;
  return result;
}

float protocol witness for Numeric.magnitude.getter in conformance Float@<S0>(float *a1@<X8>)
{
  float result = fabsf(*v1);
  *a1 = result;
  return result;
}

float Float.magnitude.getter(float a1)
{
  return fabsf(a1);
}

float protocol witness for static Numeric.* infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 * *a2;
  *a3 = result;
  return result;
}

float protocol witness for static Numeric.*= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *a2 * *a1;
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 + *a2;
  *a3 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *a2 + *a1;
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 - *a2;
  *a3 = result;
  return result;
}

float static Float.- infix(_:_:)(float a1, float a2)
{
  return a1 - a2;
}

float protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *a1 - *a2;
  *a1 = result;
  return result;
}

Swift::Float __swiftcall Float.init(integerLiteral:)(Swift::Int64 integerLiteral)
{
  return (float)integerLiteral;
}

void protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Float(uint64_t *a1@<X0>, unint64_t a2@<X1>, float *a3@<X8>)
{
  *a3 = swift_intToFloat32(a1, a2);
}

float protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Float@<S0>(uint64_t *a1@<X0>, float *a2@<X8>)
{
  float result = (float)*a1;
  *a2 = result;
  return result;
}

void Float.hash(into:)(float a1)
{
  if ((LODWORD(a1) & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = LODWORD(a1);
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Float._rawHashValue(seed:)(Swift::Int seed)
{
  if ((v1 & 0x7FFFFFFF) != 0) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v2, 4);
}

uint64_t Float.hashValue.getter(float a1)
{
  if ((LODWORD(a1) & 0x7FFFFFFF) != 0) {
    uint64_t v1 = LODWORD(a1);
  }
  else {
    uint64_t v1 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 4);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Float()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    uint64_t v1 = *v0;
  }
  else {
    uint64_t v1 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 4);
}

void protocol witness for Hashable.hash(into:) in conformance Float()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = *v0;
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Float(uint64_t a1)
{
  if ((*v1 & 0x7FFFFFFF) != 0) {
    uint64_t v2 = *v1;
  }
  else {
    uint64_t v2 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(a1, v2, 4);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 == *a2;
}

void Float._toCustomAnyHashable()(uint64_t a1@<X8>, float a2@<S0>)
{
  *(void *)(a1 + 24) = &type metadata for _FloatAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _FloatAnyHashableBox;
  *(float *)a1 = a2;
}

float protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Float@<S0>(uint64_t a1@<X8>)
{
  float result = *v1;
  *(void *)(a1 + 24) = &type metadata for _FloatAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _FloatAnyHashableBox;
  *(float *)a1 = result;
  return result;
}

Swift::UInt __swiftcall UInt.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E1uLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because the result would be less than UInt.min", 86, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E4uLL, 0);
  }
  if (a1 >= 1.8447e19) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because the result would be greater than UInt.max", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E7uLL, 0);
  }
  return (unint64_t)a1;
}

uint64_t Float.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S1, H0 }
  return _S1;
}

Swift::Float __swiftcall Float.distance(to:)(Swift::Float to)
{
  return to - v1;
}

Swift::Float __swiftcall Float.advanced(by:)(Swift::Float by)
{
  return by + v1;
}

float protocol witness for Strideable.distance(to:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float result = *a1 - *v2;
  *a2 = result;
  return result;
}

float protocol witness for Strideable.advanced(by:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float result = *a1 + *v2;
  *a2 = result;
  return result;
}

float *protocol witness for static Strideable._step(after:from:by:) in conformance Float(float *result, uint64_t a2, char a3, float *a4, float *a5, float *a6)
{
  float v6 = *a6;
  if (a3)
  {
    float v8 = v6 + *a4;
    goto LABEL_5;
  }
  if (!__OFADD__(a2++, 1))
  {
    float v8 = *a5 + (float)((float)a2 * v6);
LABEL_5:
    *float result = v8;
    return (float *)a2;
  }
  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a2 < *a1;
}

void _FloatAnyHashableBox._canonicalBox.getter(uint64_t a1@<X8>, float a2@<S0>)
{
  float v3 = truncf(a2);
  if (a2 >= 0.0)
  {
    if (a2 <= -1.0 || a2 >= 1.8447e19 || v3 != a2) {
      goto LABEL_18;
    }
    uint64_t v6 = (unint64_t)a2;
    float v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
  }
  else
  {
    if (a2 <= -9.2234e18 || a2 >= 9.2234e18 || v3 != a2)
    {
LABEL_18:
      *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
      *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
      *(double *)a1 = a2;
      return;
    }
    uint64_t v6 = (uint64_t)a2;
    float v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  }
  *(void *)(a1 + 24) = __swift_instantiateConcreteTypeFromMangledName(v7);
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(void *)a1 = v6;
}

Swift::Double_optional __swiftcall Double.init(exactly:)(Swift::Float exactly)
{
  double v1 = exactly;
  result.Swift::Bool is_nil = LOBYTE(v1);
  *(Swift::Float *)&result.unsigned int value = exactly;
  return result;
}

uint64_t _FloatAnyHashableBox._unbox<A>()@<X0>(const char *a1@<X0>, char *a2@<X8>, float a3@<S0>)
{
  *(float *)&unint64_t v7 = a3;
  int v5 = swift_dynamicCast(a2, &v7, (Class *)&type metadata for Float, a1, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a1 - 1) + 56))(a2, v5 ^ 1u, 1, a1);
}

uint64_t _FloatAnyHashableBox._downCastConditional<A>(into:)(char *a1, const char *a2, uint64_t a3, uint64_t a4, float a5)
{
  float v8 = type metadata accessor for Optional(0, (uint64_t)a2, a3, a4);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  float v12 = &v20[-v11];
  uint64_t v13 = *((void *)a2 - 1);
  MEMORY[0x1F4188790](v10);
  long long v15 = &v20[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
  *(float *)&unint64_t v21 = a5;
  uint64_t v16 = swift_dynamicCast(v12, &v21, (Class *)&type metadata for Float, a2, 6uLL);
  float v17 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v13 + 56);
  if (v16)
  {
    v17(v12, 0, 1, a2);
    unsigned __int8 v18 = *(void (**)(char *, char *, const char *))(v13 + 32);
    v18(v15, v12, a2);
    v18(a1, v15, a2);
  }
  else
  {
    v17(v12, 1, 1, a2);
    (*(void (**)(char *, Class *))(v9 + 8))(v12, v8);
  }
  return v16;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _FloatAnyHashableBox(uint64_t a1@<X8>)
{
  _FloatAnyHashableBox._canonicalBox.getter(a1, *v1);
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _FloatAnyHashableBox(uint64_t a1, const char *a2)
{
  float v4 = *v2;
  outlined init with copy of MirrorPath(a1, (uint64_t)v8);
  int v5 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  if (swift_dynamicCast((char *)&v7, v8, v5, a2, 6uLL)) {
    return v4 == v7;
  }
  else {
    return 2;
  }
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _FloatAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = *v0;
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _FloatAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = *v0;
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

float protocol witness for _AnyHashableBox._base.getter in conformance _FloatAnyHashableBox@<S0>(uint64_t a1@<X8>)
{
  float result = *v1;
  *(void *)(a1 + 24) = &type metadata for Float;
  *(float *)a1 = result;
  return result;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _FloatAnyHashableBox@<X0>(const char *a1@<X0>, char *a2@<X8>)
{
  return _FloatAnyHashableBox._unbox<A>()(a1, a2, *v2);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _FloatAnyHashableBox(char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return _FloatAnyHashableBox._downCastConditional<A>(into:)(a1, a2, a3, a4, *v4);
}

void Double._value.setter(double a1)
{
  *Swift::UInt32 v1 = a1;
}

uint64_t (*Double._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Double __swiftcall Double.init()()
{
  return 0.0;
}

BOOL Double.isNaN.getter(double a1)
{
  return (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && (~*(void *)&a1 & 0x7FF0000000000000) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Double()
{
  return Double.description.getter(*v0);
}

unint64_t Double.debugDescription.getter()
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  int64_t v0 = swift_float64ToString(&v13, 32, 1);
  __src[0] = v13;
  __src[1] = v14;
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  size_t v1 = v0;
  if (!v0) {
    return 0;
  }
  if ((unint64_t)v0 <= 0xF)
  {
    uint64_t v6 = v0 - 8;
    uint64_t v7 = 8;
    if (v0 < 8) {
      uint64_t v7 = v0;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v7 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v7 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v7 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v7 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v7 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v7 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v7 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }
    uint64_t v8 = 0;
    if (v1 >= 9)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (unsigned __int8 *)__src + 8;
      unint64_t v11 = v6 & ~(v6 >> 63);
      do
      {
        if (v11 <= v1 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        unsigned int v12 = *v10++;
        v8 |= (unint64_t)v12 << v9;
        v9 += 8;
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    unint64_t v2 = v0 | 0xF000000000000000;
    int64_t v3 = _allocateStringStorage(codeUnitCapacity:)(v0);
    *(void *)(v3 + 16) = v4;
    *(void *)(v3 + 24) = v2;
    if (v4 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v2 = *(void *)(v3 + 24);
    }
    *(unsigned char *)(v3 + 32 + (v2 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v1, (char *)(v3 + 32));
    return *(void *)(v3 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Double()
{
  return Double.debugDescription.getter();
}

void specialized Double.write<A>(to:)()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  memset(v1, 0, sizeof(v1));
  uint64_t v0 = swift_float64ToString(v1, 32, 1);
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  _StringGuts.append(_:)(v0 | 0xD000000000000000, (unint64_t)&v1[0x7FFFFFFFFFFFFFELL] | 0x8000000000000000);
}

uint64_t Double.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v5 = swift_float64ToString(v7, 32, 1);
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a3 + 32))(v7, v5, a2, a3);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Double(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Double.write<A>(to:)(a1, a2, a3);
}

uint64_t static Double.exponentBitCount.getter()
{
  return 11;
}

uint64_t static Double.significandBitCount.getter()
{
  return 52;
}

uint64_t static Double._infinityExponent.getter()
{
  return 2047;
}

uint64_t static Double._exponentBias.getter()
{
  return 1023;
}

uint64_t static Double._significandMask.getter()
{
  return 0xFFFFFFFFFFFFFLL;
}

uint64_t static Double._quietNaNMask.getter()
{
  return 0x8000000000000;
}

Swift::Double __swiftcall Double.init(bitPattern:)(Swift::UInt64 bitPattern)
{
  return *(double *)&bitPattern;
}

uint64_t Double.sign.getter(double a1)
{
  return *(void *)&a1 >> 63;
}

uint64_t Double.exponentBitPattern.getter(double a1)
{
  return (*(void *)&a1 >> 52) & 0x7FFLL;
}

uint64_t Double.significandBitPattern.getter(double a1)
{
  return *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
}

uint64_t Double.isCanonical.getter()
{
  return 1;
}

double static Double.leastNonzeroMagnitude.getter()
{
  *(void *)&double result = 1;
  return result;
}

double static Double.leastNormalMagnitude.getter()
{
  return 2.22507386e-308;
}

double static Double.infinity.getter()
{
  return INFINITY;
}

double static Double.nan.getter()
{
  return NAN;
}

double static Double.signalingNaN.getter()
{
  return NAN;
}

Swift::Double __swiftcall Double.init(nan:signaling:)(Swift::UInt64 nan, Swift::Bool signaling)
{
  if (nan >> 50) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "NaN payload is not encodable.", 29, 2, "Swift/FloatingPointTypes.swift", 30, 2, 0xAC2uLL, 0);
  }
  *(void *)&Swift::Double result = (0x8000000000000uLL >> signaling) | nan | 0x7FF0000000000000;
  return result;
}

double static Double.greatestFiniteMagnitude.getter()
{
  return 1.79769313e308;
}

double static Double.pi.getter()
{
  return 3.14159265;
}

double Double.ulp.getter(double a1)
{
  uint64_t v2 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v2)
  {
    double result = NAN;
    if (v2 != 2047) {
      return COERCE_DOUBLE(*(void *)&a1 & 0x7FF0000000000000) * 2.22044605e-16;
    }
  }
  else
  {
    *(void *)&double result = 1;
  }
  return result;
}

BOOL Double.isFinite.getter(double a1)
{
  return (~*(void *)&a1 & 0x7FF0000000000000) != 0;
}

BOOL Double.isNormal.getter(double a1)
{
  return ((*(void *)&a1 >> 52) & 0x7FFLL) != 0x7FF && ((*(void *)&a1 >> 52) & 0x7FFLL) != 0;
}

double static Double.ulpOfOne.getter()
{
  return 2.22044605e-16;
}

unint64_t Double.exponent.getter(double a1)
{
  uint64_t v1 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v3 = *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
  if (!(v1 | *(void *)&a1 & 0xFFFFFFFFFFFFFLL)) {
    return 0x8000000000000000;
  }
  if (v1) {
    return v1 - 1023;
  }
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return -1011 - __clz(v3);
}

BOOL Double.isZero.getter(double a1)
{
  return (*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0;
}

double Double.significand.getter(double result)
{
  uint64_t v1 = (*(void *)&result >> 52) & 0x7FFLL;
  unint64_t v2 = *(void *)&result & 0xFFFFFFFFFFFFFLL;
  if ((*(void *)&result & 0xFFFFFFFFFFFFFLL) == 0 || v1 != 2047)
  {
    if (v1)
    {
      if (v1 != 2047)
      {
        *(void *)&double result = v2 | 0x3FF0000000000000;
        return result;
      }
    }
    else if (v2)
    {
      *(void *)&double result = (*(void *)&result << (__clz(v2) + 53)) & 0xFFFFFFFFFFFFFLL | 0x3FF0000000000000;
      return result;
    }
    *(void *)&double result = v1 << 52;
  }
  return result;
}

BOOL Double.isSubnormal.getter(double a1)
{
  return (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && (*(void *)&a1 & 0x7FF0000000000000) == 0;
}

Swift::Double __swiftcall Double.init(sign:exponent:significand:)(Swift::FloatingPointSign sign, Swift::Int exponent, Swift::Double significand)
{
  return specialized Double.init(sign:exponent:significand:)(sign & 1, exponent, significand);
}

double static Double.- prefix(_:)(double a1)
{
  return -a1;
}

double static Double.*= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 * a2;
  *a1 = result;
  return result;
}

double Double.nextUp.getter(double a1)
{
  double result = a1 + 0.0;
  if (result < INFINITY) {
    *(void *)&result += (*(uint64_t *)&result >> 63) | 1;
  }
  return result;
}

double static Double.+ infix(_:_:)(double a1, double a2)
{
  return a1 + a2;
}

uint64_t static Int64.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::Double __swiftcall Double.init(signOf:magnitudeOf:)(Swift::Double signOf, Swift::Double magnitudeOf)
{
  v2.f64[0] = NAN;
  v2.f64[1] = NAN;
  *(void *)&Swift::Double result = vbslq_s8((int8x16_t)vnegq_f64(v2), *(int8x16_t *)&magnitudeOf, *(int8x16_t *)&signOf).u64[0];
  return result;
}

Swift::Void __swiftcall Double.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  switch(*(unsigned char *)a1)
  {
    case 0:
      *uint64_t v1 = round(*v1);
      return;
    case 1:
      *uint64_t v1 = rint(*v1);
      return;
    case 2:
      double v2 = *v1;
      goto LABEL_9;
    case 3:
      double v2 = *v1;
      goto LABEL_10;
    case 4:
      *uint64_t v1 = trunc(*v1);
      return;
    case 5:
      double v2 = *v1;
      if ((*(void *)v1 & 0x8000000000000000) != 0) {
LABEL_10:
      }
        *uint64_t v1 = floor(v2);
      else {
LABEL_9:
      }
        *uint64_t v1 = ceil(v2);
      break;
    default:
      Double._roundSlowPath(_:)(a1);
      break;
  }
}

Swift::Void __swiftcall Double._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  char v4 = *(unsigned char *)a1;
  switch(v4)
  {
    case 0:
      double v2 = round(*v1);
      goto LABEL_11;
    case 1:
      double v2 = rint(*v1);
      goto LABEL_11;
    case 2:
      double v3 = *v1;
      goto LABEL_9;
    case 3:
      double v3 = *v1;
      goto LABEL_10;
    case 4:
      double v2 = trunc(*v1);
      goto LABEL_11;
    case 5:
      double v3 = *v1;
      if ((*(void *)v1 & 0x8000000000000000) != 0) {
LABEL_10:
      }
        double v2 = floor(v3);
      else {
LABEL_9:
      }
        double v2 = ceil(v3);
LABEL_11:
      *uint64_t v1 = v2;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }
}

Swift::Void __swiftcall Double.negate()()
{
  double *v0 = -*v0;
}

double static Double.+= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 + a2;
  *a1 = result;
  return result;
}

double static Double.-= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 - a2;
  *a1 = result;
  return result;
}

double static Double./= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 / a2;
  *a1 = result;
  return result;
}

Swift::Void __swiftcall Double.formRemainder(dividingBy:)(Swift::Double dividingBy)
{
  *uint64_t v1 = remainder(*v1, dividingBy);
}

Swift::Void __swiftcall Double.formTruncatingRemainder(dividingBy:)(Swift::Double dividingBy)
{
  *uint64_t v1 = fmod(*v1, dividingBy);
}

Swift::Void __swiftcall Double.formSquareRoot()()
{
  double *v0 = sqrt(*v0);
}

Swift::Void __swiftcall Double.addProduct(_:_:)(Swift::Double a1, Swift::Double a2)
{
  *double v2 = *v2 + a1 * a2;
}

Swift::Bool __swiftcall Double.isEqual(to:)(Swift::Double to)
{
  return v1 == to;
}

Swift::Bool __swiftcall Double.isLess(than:)(Swift::Double than)
{
  return v1 < than;
}

Swift::Bool __swiftcall Double.isLessThanOrEqualTo(_:)(Swift::Double a1)
{
  return v1 <= a1;
}

BOOL Double.isInfinite.getter(double a1)
{
  return (*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000;
}

BOOL Double.isSignalingNaN.getter(double a1)
{
  return (~*(void *)&a1 & 0x7FF0000000000000) == 0
      && (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0
      && (*(void *)&a1 & 0x8000000000000) == 0;
}

double Double.binade.getter(double a1)
{
  uint64_t v1 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047) {
    return NAN;
  }
  if ((*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && !v1) {
    return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1 * 4.50359963e15) & 0xFFF0000000000000) * 2.22044605e-16;
  }
  *(void *)&double result = *(void *)&a1 & 0xFFF0000000000000;
  return result;
}

uint64_t Double.significandWidth.getter(double a1)
{
  unint64_t v1 = *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
  unint64_t v2 = __clz(__rbit64(*(void *)&a1 & 0xFFFFFFFFFFFFFLL));
  uint64_t v3 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v3 && v3 != 2047)
  {
    unint64_t v6 = 52 - v2;
    if (v1) {
      return v6;
    }
    else {
      return 0;
    }
  }
  else
  {
    unint64_t v4 = 63 - (__clz(v1) + v2);
    if (v3) {
      unint64_t v4 = -1;
    }
    if (v1) {
      return v4;
    }
    else {
      return -1;
    }
  }
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Double(char a1@<W0>, void *a2@<X1>, uint64_t *a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized Double.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
}

double protocol witness for BinaryFloatingPoint.init(_:) in conformance Double@<D0>(double *a1@<X8>, float a2@<S0>)
{
  double result = a2;
  *a1 = result;
  return result;
}

void protocol witness for BinaryFloatingPoint.init(_:) in conformance Double(double *a1@<X8>, double a2@<D0>)
{
  *a1 = a2;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Double(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
}

unint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Double@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.exponentBitCount.getter in conformance Double()
{
  return 11;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Double()
{
  return 52;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Double(uint64_t *a1@<X8>)
{
  *a1 = (*v1 >> 52) & 0x7FFLL;
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Double(uint64_t *a1@<X8>)
{
  *a1 = *v1 & 0xFFFFFFFFFFFFFLL;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Double(double *a1@<X8>)
{
  *a1 = Double.binade.getter(*v1);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Double()
{
  return Double.significandWidth.getter(*v0);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Double(char a1@<W0>, uint64_t *a2@<X1>, double *a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized Double.init(sign:exponent:significand:)(a1 & 1, *a2, *a3);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Double@<D0>(unint64_t *a1@<X0>, unint64_t *a2@<X1>, void *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  a4.i64[0] = *a1;
  a5.i64[0] = *a2;
  v5.f64[0] = NAN;
  v5.f64[1] = NAN;
  a4.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v5), a5, a4).u64[0];
  *a3 = a4.i64[0];
  return *(double *)a4.i64;
}

double protocol witness for FloatingPoint.init(_:) in conformance Double@<D0>(uint64_t a1@<X0>, double *a2@<X8>)
{
  double result = (double)a1;
  *a2 = (double)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Double@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>, double *a4@<X8>)
{
  if (a3[16](a2, a3) < 65)
  {
    char v10 = a3[8](a2, a3);
    uint64_t v11 = a3[15](a2, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    if (v10) {
      double v9 = (double)v11;
    }
    else {
      double v9 = (double)(unint64_t)v11;
    }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v12, a1, a2, (uint64_t)a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
    double v9 = v12;
  }
  *a4 = v9;
  return result;
}

unint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Double@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = Double.init<A>(exactly:)(a1, a2, a3);
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v6 & 1;
  return result;
}

unint64_t Double.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) > 64)
  {
    char v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v20, a1, a2, a3);
    (*(void (**)(char *, uint64_t))(v6 + 8))(a1, a2);
    if (v11)
    {
      double v12 = v20;
      return *(void *)&v12;
    }
LABEL_15:
    double v12 = 0.0;
    return *(void *)&v12;
  }
  char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v8, a1, a2);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  long long v15 = *(void (**)(char *, uint64_t))(v6 + 8);
  v15(v8, a2);
  if ((v13 & 1) == 0)
  {
    double v17 = (double)(unint64_t)v14;
    if ((double)(unint64_t)v14 < 1.84467441e19)
    {
      double v12 = (double)(unint64_t)v14;
      if ((~*(void *)&v17 & 0x7FF0000000000000) == 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3129uLL, 0);
      }
      v15(a1, a2);
      if (v14 != (unint64_t)v17) {
        goto LABEL_15;
      }
      return *(void *)&v12;
    }
LABEL_14:
    v15(a1, a2);
    goto LABEL_15;
  }
  double v16 = (double)v14;
  if ((double)v14 >= 9.22337204e18) {
    goto LABEL_14;
  }
  double v12 = (double)v14;
  if ((~*(void *)&v16 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v16 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  v15(a1, a2);
  if (v14 != (uint64_t)v16) {
    goto LABEL_15;
  }
  return *(void *)&v12;
}

void protocol witness for static FloatingPoint.nan.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FF8000000000000;
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FF4000000000000;
}

void protocol witness for static FloatingPoint.infinity.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FF0000000000000;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FEFFFFFFFFFFFFFLL;
}

void protocol witness for static FloatingPoint.pi.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x400921FB54442D18;
}

double protocol witness for FloatingPoint.ulp.getter in conformance Double@<D0>(double *a1@<X8>)
{
  uint64_t v2 = (*v1 >> 52) & 0x7FFLL;
  if (v2)
  {
    if (v2 != 2047)
    {
      double result = COERCE_DOUBLE(*v1 & 0x7FF0000000000000) * 2.22044605e-16;
      *a1 = result;
      return result;
    }
    double v4 = NAN;
  }
  else
  {
    *(void *)&double v4 = 1;
  }
  double result = v4;
  *a1 = v4;
  return result;
}

void protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x3CB0000000000000;
}

void protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x10000000000000;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Double()
{
  return Double.sign.getter(*v0);
}

unint64_t protocol witness for FloatingPoint.exponent.getter in conformance Double@<X0>(unint64_t *a1@<X8>)
{
  unint64_t result = Double.exponent.getter(*v1);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Double(double *a1@<X8>)
{
  *a1 = Double.significand.getter(*v1);
}

double protocol witness for static FloatingPoint./ infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 / *a2;
  *a3 = result;
  return result;
}

double protocol witness for static FloatingPoint./= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *a1 / *a2;
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Double(long double *a1@<X0>, long double *a2@<X8>)
{
  *a2 = _stdlib_remainder(*v2, *a1);
}

void protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Double(long double *a1)
{
  *unint64_t v1 = _stdlib_remainder(*v1, *a1);
}

void protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Double(long double *a1@<X0>, long double *a2@<X8>)
{
  *a2 = fmod(*v2, *a1);
}

void protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Double(long double *a1)
{
  *unint64_t v1 = fmod(*v1, *a1);
}

void protocol witness for FloatingPoint.squareRoot() in conformance Double(double *a1@<X8>)
{
  *a1 = _stdlib_squareRoot(*v1);
}

void protocol witness for FloatingPoint.formSquareRoot() in conformance Double()
{
  double *v0 = _stdlib_squareRoot(*v0);
}

double protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *v3 + *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for FloatingPoint.addProduct(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *v2 + *a1 * *a2;
  *uint64_t v2 = result;
  return result;
}

double *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (*result > *a2)
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000) != 0) {
      double v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (*a2 >= *result)
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000) != 0) {
      double v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (fabs(*result) > fabs(*a2))
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000) != 0) {
      double v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (fabs(*a2) >= fabs(*result))
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000) != 0) {
      double v3 = *a2;
    }
  }
  *a3 = v3;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Double(unsigned char *a1@<X0>, double *a2@<X8>)
{
  double v4 = *v2;
  double v8 = *v2;
  switch(*a1)
  {
    case 0:
      double v5 = round(v4);
      break;
    case 1:
      double v5 = rint(v4);
      break;
    case 2:
      double v5 = ceil(v4);
      break;
    case 3:
      double v5 = floor(v4);
      break;
    case 4:
      double v5 = trunc(v4);
      break;
    case 5:
      char v6 = Double.sign.getter(v4);
      double v5 = ceil(v4);
      double v7 = floor(v4);
      if (v6) {
        double v5 = v7;
      }
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      double v5 = v8;
      break;
  }
  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Double(unsigned char *a1)
{
  switch(*a1)
  {
    case 0:
      double v2 = round(*v1);
      goto LABEL_13;
    case 1:
      double v2 = rint(*v1);
      goto LABEL_13;
    case 2:
      double v2 = ceil(*v1);
      goto LABEL_13;
    case 3:
      double v2 = floor(*v1);
      goto LABEL_13;
    case 4:
      double v2 = trunc(*v1);
      goto LABEL_13;
    case 5:
      double v3 = *v1;
      if (Double.sign.getter(*v1)) {
        double v2 = floor(v3);
      }
      else {
        double v2 = ceil(v3);
      }
LABEL_13:
      *unint64_t v1 = v2;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Double(double *a1@<X8>)
{
  double v2 = *v1 + 0.0;
  if (v2 < INFINITY) {
    *(void *)&v2 += (*(uint64_t *)&v2 >> 63) | 1;
  }
  *a1 = v2;
}

double protocol witness for FloatingPoint.nextDown.getter in conformance Double@<D0>(double *a1@<X8>)
{
  double v2 = 0.0 - *v1;
  if (v2 < INFINITY) {
    *(void *)&v2 += (*(uint64_t *)&v2 >> 63) | 1;
  }
  double result = -v2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Double(double *a1)
{
  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Double(double *a1)
{
  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Double(double *a1)
{
  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Double(double *a1)
{
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(*a1, *v1);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Double()
{
  return ((*v0 >> 52) & 0x7FFLL) != 0x7FF && ((*v0 >> 52) & 0x7FFLL) != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Double()
{
  return (~*v0 & 0x7FF0000000000000) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Double()
{
  return (*v0 & 0x7FFFFFFFFFFFFFFFLL) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Double()
{
  return (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (*v0 & 0x7FF0000000000000) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Double()
{
  return (*v0 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Double()
{
  return (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (~*v0 & 0x7FF0000000000000) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Double()
{
  return (~*v0 & 0x7FF0000000000000) == 0 && (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (*v0 & 0x8000000000000) == 0;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Double()
{
  return specialized FloatingPoint.floatingPointClass.getter(*v0);
}

double protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Double@<D0>(double *a1@<X0>, void *a2@<X8>)
{
  double result = *a1;
  *a2 = *(void *)a1;
  return result;
}

double protocol witness for static SignedNumeric.- prefix(_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double result = -*a1;
  *a2 = result;
  return result;
}

double protocol witness for SignedNumeric.negate() in conformance Double()
{
  double result = -*v0;
  double *v0 = result;
  return result;
}

double protocol witness for Numeric.magnitude.getter in conformance Double@<D0>(double *a1@<X8>)
{
  double result = fabs(*v1);
  *a1 = result;
  return result;
}

double Double.magnitude.getter(double a1)
{
  return fabs(a1);
}

double protocol witness for static Numeric.* infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for static Numeric.*= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *a2 * *a1;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 + *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *a2 + *a1;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 - *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *a1 - *a2;
  *a1 = result;
  return result;
}

Swift::Double __swiftcall Double.init(integerLiteral:)(Swift::Int64 integerLiteral)
{
  return (double)integerLiteral;
}

void protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Double(uint64_t *a1@<X0>, unint64_t a2@<X1>, double *a3@<X8>)
{
  *a3 = swift_intToFloat64(a1, a2);
}

double protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Double@<D0>(uint64_t *a1@<X0>, double *a2@<X8>)
{
  double result = (double)*a1;
  *a2 = result;
  return result;
}

void Double.hash(into:)(double a1)
{
  if ((*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *(void *)&a1;
  }
  else {
    Swift::UInt64 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Double._rawHashValue(seed:)(Swift::Int seed)
{
  if ((v1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  return specialized static Hasher._hash(seed:_:)(seed, v2);
}

uint64_t Double.hashValue.getter(double a1)
{
  if ((*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v1 = *(void *)&a1;
  }
  else {
    uint64_t v1 = 0;
  }
  return specialized static Hasher._hash(seed:_:)(0, v1);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Double()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v1 = *v0;
  }
  else {
    uint64_t v1 = 0;
  }
  return specialized static Hasher._hash(seed:_:)(0, v1);
}

void protocol witness for Hashable.hash(into:) in conformance Double()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *v0;
  }
  else {
    Swift::UInt64 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Double(uint64_t a1)
{
  if ((*v1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v2 = *v1;
  }
  else {
    uint64_t v2 = 0;
  }
  return specialized static Hasher._hash(seed:_:)(a1, v2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 == *a2;
}

void Double._toCustomAnyHashable()(uint64_t a1@<X8>, double a2@<D0>)
{
  *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
  *(double *)a1 = a2;
}

double protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Double@<D0>(uint64_t a1@<X8>)
{
  double result = *v1;
  *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
  *(double *)a1 = result;
  return result;
}

Swift::UInt __swiftcall UInt.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3129uLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because the result would be less than UInt.min", 87, 2, "Swift/IntegerTypes.swift", 24, 2, 0x312CuLL, 0);
  }
  if (a1 >= 1.84467441e19) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because the result would be greater than UInt.max", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x312FuLL, 0);
  }
  return (unint64_t)a1;
}

uint64_t Double.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            D1, H0 }
  return _D1;
}

Swift::Double_optional __swiftcall Double.init(exactly:)(Swift::Double exactly)
{
  char v1 = LOBYTE(exactly);
  result.unsigned int value = exactly;
  result.Swift::Bool is_nil = v1;
  return result;
}

Swift::Double __swiftcall Double.distance(to:)(Swift::Double to)
{
  return to - v1;
}

Swift::Double __swiftcall Double.advanced(by:)(Swift::Double by)
{
  return by + v1;
}

double protocol witness for Strideable.distance(to:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double result = *a1 - *v2;
  *a2 = result;
  return result;
}

double protocol witness for Strideable.advanced(by:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double result = *a1 + *v2;
  *a2 = result;
  return result;
}

double *protocol witness for static Strideable._step(after:from:by:) in conformance Double(double *result, uint64_t a2, char a3, double *a4, double *a5, double *a6)
{
  double v6 = *a6;
  if (a3)
  {
    double v8 = v6 + *a4;
    goto LABEL_5;
  }
  if (!__OFADD__(a2++, 1))
  {
    double v8 = *a5 + (double)a2 * v6;
LABEL_5:
    *double result = v8;
    return (double *)a2;
  }
  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a2 < *a1;
}

void _DoubleAnyHashableBox._canonicalBox.getter(uint64_t a1@<X8>, double a2@<D0>)
{
  double v3 = trunc(a2);
  if (a2 >= 0.0)
  {
    if (a2 <= -1.0 || a2 >= 1.84467441e19 || v3 != a2) {
      goto LABEL_18;
    }
    uint64_t v6 = (unint64_t)a2;
    double v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
  }
  else
  {
    if (a2 <= -9.22337204e18 || a2 >= 9.22337204e18 || v3 != a2)
    {
LABEL_18:
      *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
      *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
      *(double *)a1 = a2;
      return;
    }
    uint64_t v6 = (uint64_t)a2;
    double v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  }
  *(void *)(a1 + 24) = __swift_instantiateConcreteTypeFromMangledName(v7);
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(void *)a1 = v6;
}

uint64_t _DoubleAnyHashableBox._unbox<A>()@<X0>(const char *a1@<X0>, char *a2@<X8>, double a3@<D0>)
{
  double v7 = a3;
  int v5 = swift_dynamicCast(a2, (unint64_t *)&v7, (Class *)&type metadata for Double, a1, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a1 - 1) + 56))(a2, v5 ^ 1u, 1, a1);
}

uint64_t _DoubleAnyHashableBox._downCastConditional<A>(into:)(char *a1, const char *a2, uint64_t a3, uint64_t a4, double a5)
{
  double v8 = type metadata accessor for Optional(0, (uint64_t)a2, a3, a4);
  uint64_t v9 = (uint64_t)*(v8 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  double v12 = (char *)&v20 - v11;
  uint64_t v13 = *((void *)a2 - 1);
  MEMORY[0x1F4188790](v10);
  long long v15 = (char *)&v20 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  double v21 = a5;
  uint64_t v16 = swift_dynamicCast(v12, (unint64_t *)&v21, (Class *)&type metadata for Double, a2, 6uLL);
  double v17 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v13 + 56);
  if (v16)
  {
    v17(v12, 0, 1, a2);
    unsigned __int8 v18 = *(void (**)(char *, char *, const char *))(v13 + 32);
    v18(v15, v12, a2);
    v18(a1, v15, a2);
  }
  else
  {
    v17(v12, 1, 1, a2);
    (*(void (**)(char *, Class *))(v9 + 8))(v12, v8);
  }
  return v16;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _DoubleAnyHashableBox(uint64_t a1@<X8>)
{
  _DoubleAnyHashableBox._canonicalBox.getter(a1, *v1);
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _DoubleAnyHashableBox(uint64_t a1, const char *a2)
{
  double v4 = *v2;
  outlined init with copy of MirrorPath(a1, (uint64_t)v8);
  int v5 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  if (swift_dynamicCast((char *)&v7, v8, v5, a2, 6uLL)) {
    return v4 == v7;
  }
  else {
    return 2;
  }
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _DoubleAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *v0;
  }
  else {
    Swift::UInt64 v1 = 0;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _DoubleAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *v0;
  }
  else {
    Swift::UInt64 v1 = 0;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

double protocol witness for _AnyHashableBox._base.getter in conformance _DoubleAnyHashableBox@<D0>(uint64_t a1@<X8>)
{
  double result = *v1;
  *(void *)(a1 + 24) = &type metadata for Double;
  *(double *)a1 = result;
  return result;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _DoubleAnyHashableBox@<X0>(const char *a1@<X0>, char *a2@<X8>)
{
  return _DoubleAnyHashableBox._unbox<A>()(a1, a2, *v2);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _DoubleAnyHashableBox(char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return _DoubleAnyHashableBox._downCastConditional<A>(into:)(a1, a2, a3, a4, *v4);
}

void __swiftcall Float80.init()()
{
}

void % infix<A>(_:_:)()
{
}

void %= infix<A>(_:_:)()
{
}

uint64_t UInt8._value.setter(uint64_t result)
{
  *Swift::UInt64 v1 = result;
  return result;
}

uint64_t (*UInt8._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt8 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x58uLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt8 because the result would be less than UInt8.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x5BuLL, 0);
  }
  if (*(short float *)&a1 >= COERCE_SHORT_FLOAT(23552)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt8 because the result would be greater than UInt8.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x5EuLL, 0);
  }
  return (int)*(short float *)&a1;
}

uint64_t UInt8.init(exactly:)(__n128 a1)
{
  BOOL v1 = *(short float *)a1.n128_u16 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0));
  if (*(short float *)a1.n128_u16 >= COERCE_SHORT_FLOAT(23552)) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncl(*(short float *)a1.n128_u16) == *(short float *)a1.n128_u16);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (int)*(short float *)a1.n128_u16;
  }
  return v5 & 0xFFFFFEFF | ((v4 & 1) << 8);
}

Swift::UInt8 __swiftcall UInt8.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt8 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA4uLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt8 because the result would be less than UInt8.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA7uLL, 0);
  }
  if (a1 >= 256.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt8 because the result would be greater than UInt8.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0xAAuLL, 0);
  }
  return (int)a1;
}

Swift::UInt8_optional __swiftcall UInt8.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 256.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    LOWORD(v5) = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

Swift::UInt8 __swiftcall UInt8.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt8 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0xECuLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt8 because the result would be less than UInt8.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEFuLL, 0);
  }
  if (a1 >= 256.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt8 because the result would be greater than UInt8.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0xF2uLL, 0);
  }
  return (int)a1;
}

Swift::UInt8_optional __swiftcall UInt8.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 256.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    LOWORD(v5) = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

unsigned char *static UInt8.+= infix(_:_:)(unsigned char *result, unsigned __int8 a2)
{
  unsigned int v2 = *result + a2;
  if ((v2 >> 8)) {
    __break(1u);
  }
  else {
    *double result = v2;
  }
  return result;
}

unsigned char *static UInt8.-= infix(_:_:)(unsigned char *result, unsigned __int8 a2)
{
  int v2 = *result - a2;
  if ((v2 & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *double result = v2;
  }
  return result;
}

unsigned char *static UInt8.*= infix(_:_:)(unsigned char *result, unsigned __int8 a2)
{
  if (((*result * (unsigned __int16)a2) & 0xFF00) != 0) {
    __break(1u);
  }
  else {
    *result *= a2;
  }
  return result;
}

unsigned char *static UInt8./= infix(_:_:)(unsigned char *result, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.addingReportingOverflow(_:)(Swift::UInt8 a1)
{
  Swift::UInt8 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.subtractingReportingOverflow(_:)(Swift::UInt8 a1)
{
  Swift::UInt8 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.multipliedReportingOverflow(by:)(Swift::UInt8 by)
{
  Swift::UInt8 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.dividedReportingOverflow(by:)(Swift::UInt8 by)
{
  if (by) {
    v1 /= by;
  }
  Swift::UInt8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.remainderReportingOverflow(dividingBy:)(Swift::UInt8 dividingBy)
{
  if (dividingBy) {
    v1 %= dividingBy;
  }
  Swift::UInt8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

unsigned char *static UInt8.%= infix(_:_:)(unsigned char *result, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  }
  *result %= a2;
  return result;
}

unsigned char *static UInt8.&>>= infix(_:_:)(unsigned char *result, char a2)
{
  *Swift::tuple_partialValue_UInt8_overflow_Bool result = *result >> (a2 & 7);
  return result;
}

uint64_t UInt8._lowWord.getter(uint64_t result)
{
  return result;
}

uint64_t UInt8.Words._value.setter(uint64_t result)
{
  *unsigned __int8 v1 = result;
  return result;
}

uint64_t (*UInt8.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.Words.count.getter()
{
  return 1;
}

uint64_t UInt8.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt8.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt8.Words.indices.getter()
{
  return 0;
}

uint64_t UInt8.Words.subscript.getter(uint64_t a1, unsigned __int8 a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3B1uLL, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3B2uLL, 0);
  }
  return a2;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt8.Words@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt8.Words(uint64_t *a1, uint64_t *a2))()
{
  *a1 = UInt8.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

double protocol witness for Collection.indices.getter in conformance UInt8.Words@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = xmmword_18162ACB0;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt8.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt8.Words(uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt8_low_UInt8 __swiftcall UInt8.multipliedFullWidth(by:)(Swift::UInt8 by)
{
  Swift::UInt8 v2 = __rev16(v1 * by);
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt8_remainder_UInt8 __swiftcall UInt8.dividingFullWidth(_:)(Swift::tuple_high_UInt8_low_UInt8 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x417uLL, 0);
  }
  if (a1.high >= v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x419uLL, 0);
  }
  unsigned __int16 v3 = a1.low | (unsigned __int16)(__PAIR16__(v2, a1.high) << 8);
  unsigned int v4 = (v3 / v1) | ((v3 % v1) << 8);
  result.quotient = v4;
  result.remainder = v3;
  return result;
}

Swift::UInt8 __swiftcall UInt8.signum()()
{
  return v0 != 0;
}

uint64_t static UInt8.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt8(unsigned char *a1@<X8>)
{
  *a1 = -1;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt8(unsigned char *a1, unsigned char *a2)
{
  uint64_t v3 = (*v2 + *a2) >> 8;
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt8(unsigned char *a1, unsigned __int8 *a2)
{
  int v3 = *v2 - *a2;
  *a1 = v3;
  return (v3 & 0xFFFFFF00) != 0;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt8(unsigned char *a1, unsigned __int8 *a2)
{
  __int16 v3 = *v2 * *a2;
  *a1 = v3;
  return (v3 & 0xFF00) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt8(unsigned char *a1, unsigned char *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt8(unsigned char *a1, unsigned char *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

unsigned char *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt8(unsigned char *result, unsigned char *a2, unsigned __int8 *a3)
{
  __int16 v4 = *v3 * *a3;
  *Swift::tuple_quotient_UInt8_remainder_UInt8 result = HIBYTE(v4);
  *a2 = v4;
  return result;
}

Swift::UInt8 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt8(Swift::UInt8 *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4)
{
  Swift::UInt8 result = UInt8.dividingFullWidth(_:)((Swift::tuple_high_UInt8_low_UInt8)__PAIR16__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

unsigned __int8 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *result >> (*a2 & 7);
  return result;
}

unsigned char *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt8(unsigned char *result, unsigned char *a2)
{
  *Swift::UInt8 result = *result >> (*a2 & 7);
  return result;
}

char *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt8@<X0>(char *result@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  char v3 = 0;
  if (a2 <= 0x9FF && (a2 & 1) == 0) {
    char v3 = *result;
  }
  *a3 = v3;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8 and conformance UInt8, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned char *a6@<X8>)
{
  uint64_t v53 = a4;
  uint64_t v54 = a5;
  uint64_t v57 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v57, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v49 - v11;
  uint64_t v61 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v52 = (char *)&v49 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v60 = (char *)&v49 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unsigned __int8 v18 = (char *)&v49 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v49 - v19;
  double v21 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v22 = v21(a2, a3);
  uint64_t v58 = a1;
  uint64_t v59 = a6;
  if (v22)
  {
    uint64_t v23 = v61;
    (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v20, a1, a2);
    uint64_t v25 = AssociatedTypeWitness;
    uint64_t v24 = v57;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v27 = v55;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v25, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v24[3])(v27, a2, v24);
    LOBYTE(v25) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 32))(v20, v18, a2);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v23 + 8);
    v28(v18, a2);
    if ((v25 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    v28(v20, a2);
    a1 = v58;
  }
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v29(a2, a3) >= 8)
  {
    uint64_t v51 = v18;
    uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v61 + 16);
    v50(v60, a1, a2);
    unsigned __int8 v62 = -1;
    char v30 = v21(a2, a3);
    uint64_t v31 = v29(a2, a3);
    if (v30)
    {
      uint64_t v32 = v51;
      if (v31 < 9)
      {
        uint64_t v36 = AssociatedTypeWitness;
        uint64_t v37 = v57;
        uint64_t v38 = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v39 = v55;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v38 + 8))(&qword_18162B0B8, 256, v36, v38);
        ((void (*)(char *, uint64_t, int **))v37[3])(v39, a2, v37);
        uint64_t v40 = v60;
        LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 40))(v60, v32, a2);
        uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v32, a2);
        unsigned int v41 = v62;
        uint64_t v42 = v52;
        v50(v52, (uint64_t)v40, a2);
        if (v36)
        {
          unsigned __int8 v43 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v34(v42, a2);
          if (v41 < v43) {
LABEL_20:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          v34(v42, a2);
        }
        goto LABEL_16;
      }
      (*(void (**)(unsigned __int8 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v32, v60, a2);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v32, a2);
    }
    else
    {
      uint64_t v35 = v51;
      if (v31 <= 8)
      {
        v50(v51, (uint64_t)v60, a2);
        unsigned __int8 v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v35, a2);
        if (v62 < v44) {
          goto LABEL_20;
        }
LABEL_16:
        v34(v60, a2);
        a1 = v58;
        goto LABEL_17;
      }
      (*(void (**)(unsigned __int8 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v35, v60, a2);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v35, a2);
    }
    if (v33) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
LABEL_17:
  char v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v46 = a1;
  char v47 = v45;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v61 + 8))(v46, a2);
  *uint64_t v59 = v47;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt8()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt8()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

unsigned char *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  }
  *a3 = *result / *a2;
  return result;
}

unsigned char *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt8(unsigned char *result, unsigned char *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  }
  *result /= *a2;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  }
  *a3 = *result % *a2;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt8(unsigned char *result, unsigned char *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt8.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt8@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  uint64x2_t v120 = a5;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  int64x2_t v109 = (char *)&v106 - v10;
  uint64_t v11 = *(char **)(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v106 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v107 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v115 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  int64x2_t v114 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v108 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v116 = (char *)&v106 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v121 = (char *)&v106 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v28 = (char *)&v106 - v27;
  unsigned int v113 = *a1;
  uint64_t v30 = a4 + 64;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if (v29(a3, a4))
  {
    uint64x2_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v122(a3, a4);
    if (v31 < 64)
    {
LABEL_9:
      (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
      if (v39 < -8) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
    goto LABEL_6;
  }
  char v34 = v29(a3, a4);
  uint64x2_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v31 = v122(a3, a4);
  if ((v34 & 1) == 0)
  {
    if (v31 > 64) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (v31 > 64)
  {
LABEL_6:
    v124[0] = -8;
    uint64_t v35 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
    v35(v124, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
    if (v37) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v117 = a4 + 64;
  uint32x4_t v119 = v29;
  uint64_t v65 = AssociatedTypeWitness;
  uint64_t v66 = v111;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v68 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v65, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t, int **))v66[3])(v68, a3, v66);
  LOBYTE(v65) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
  uint64_t v69 = (void (*)(char *, uint64_t))*((void *)v11 + 1);
  v69(v28, a3);
  uint16x8_t v118 = v11;
  (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v14, a2, a3);
  if (v65)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
    LOBYTE(v49) = 0;
    goto LABEL_54;
  }
  uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
  uint64_t v11 = v118;
  uint64_t v29 = v119;
  uint64_t v30 = v117;
  if (v70 < -8) {
    goto LABEL_16;
  }
LABEL_10:
  char v40 = v29(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v41 = v122(a3, a4);
  uint32x4_t v119 = v29;
  uint64_t v117 = v30;
  if (v40)
  {
    if (v41 > 64) {
      goto LABEL_12;
    }
LABEL_15:
    (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v47 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
    uint64_t result = v47(v28, a3);
    if (v48 <= 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (v41 <= 63) {
    goto LABEL_15;
  }
LABEL_12:
  v124[0] = 8;
  unsigned __int8 v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
  v44(v124, &type metadata for Int, v45, a3, a4);
  char v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
  char v47 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
  uint64_t result = v47(v28, a3);
  if ((v46 & 1) == 0)
  {
LABEL_17:
    uint64_t v50 = v28;
    uint16x8_t v118 = (char *)v47;
    uint64_t v51 = v11 + 16;
    uint64_t v52 = (void (*)(char *, uint64_t, uint64_t))*((void *)v11 + 2);
    uint64_t v53 = v121;
    v52(v121, a2, a3);
    char v54 = v119(a3, a4);
    uint64_t v55 = v116;
    uint64_t v56 = v53;
    uint64_t v106 = v51;
    uint64_t v57 = (void (*)(char *, char *, uint64_t))v52;
    v52(v116, (uint64_t)v56, a3);
    if ((v54 & 1) == 0)
    {
      ((void (*)(char *, uint64_t))v118)(v55, a3);
      uint64_t v59 = v50;
      goto LABEL_38;
    }
    uint64_t v58 = v122(a3, a4);
    ((void (*)(char *, uint64_t))v118)(v55, a3);
    uint64_t v59 = v50;
    uint64_t v60 = v119;
    if (v58 <= 64) {
      goto LABEL_38;
    }
    uint64_t v61 = v108;
    v57(v108, v121, a3);
    v124[0] = 0x8000000000000000;
    if (v60(a3, a4))
    {
      uint64_t v62 = v122(a3, a4);
      if (v62 >= 64) {
        goto LABEL_29;
      }
    }
    else
    {
      char v71 = v60(a3, a4);
      uint64_t v62 = v122(a3, a4);
      if (v71)
      {
        if (v62 <= 64)
        {
          uint64_t v78 = AssociatedTypeWitness;
          uint64_t v77 = v111;
          uint64_t v79 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v80 = v109;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v79 + 8))(&qword_18162B0B8, 256, v78, v79);
          ((void (*)(char *, uint64_t, int **))v77[3])(v80, a3, v77);
          uint64_t v81 = v108;
          char v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v59, a3);
          uint64_t v83 = v118;
          ((void (*)(char *, uint64_t))v118)(v59, a3);
          uint64_t v84 = v107;
          v57(v107, v81, a3);
          if (v82)
          {
            ((void (*)(char *, uint64_t))v83)(v84, a3);
            goto LABEL_59;
          }
          uint64_t v85 = v124[0];
          uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v83)(v84, a3);
          BOOL v87 = v86 < v85;
          uint64_t v61 = v108;
          uint64_t v75 = v83;
          if (v87) {
            goto LABEL_59;
          }
LABEL_37:
          ((void (*)(char *, uint64_t))v75)(v61, a3);
LABEL_38:
          uint64_t v88 = v121;
          unint64_t v89 = v122;
          uint64_t v90 = v122(a3, a4);
          uint64_t v91 = v114;
          v57(v114, v88, a3);
          if (v90 < 65)
          {
            uint64_t v100 = v89(a3, a4);
            ((void (*)(char *, uint64_t))v118)(v91, a3);
            uint64_t v92 = v115;
            if (v100 != 64 || (v119(a3, a4) & 1) != 0) {
              goto LABEL_51;
            }
          }
          else
          {
            ((void (*)(char *, uint64_t))v118)(v91, a3);
            uint64_t v92 = v115;
          }
          v57(v92, v121, a3);
          v124[0] = 0x7FFFFFFFFFFFFFFFLL;
          char v93 = v119(a3, a4);
          uint64_t v94 = v122(a3, a4);
          if (v93)
          {
            if (v94 > 64)
            {
              uint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
              uint64_t v99 = v124;
LABEL_49:
              v97(v99, &type metadata for Int, v98, a3, a4);
              char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v59, v92, a3);
              unint64_t v103 = v118;
              ((void (*)(char *, uint64_t))v118)(v59, a3);
              if (v102) {
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
              }
              ((void (*)(char *, uint64_t))v103)(v92, a3);
LABEL_51:
              int64x2_t v104 = v121;
              unint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              uint64_t result = ((uint64_t (*)(char *, uint64_t))v118)(v104, a3);
              if ((v105 & 0x8000000000000000) != 0)
              {
                if (v105 > 0xFFFFFFFFFFFFFFF8)
                {
                  unsigned int v49 = v113 << -(char)v105;
                  goto LABEL_54;
                }
              }
              else if (v105 < 8)
              {
                unsigned int v49 = v113 >> v105;
                goto LABEL_54;
              }
              goto LABEL_16;
            }
          }
          else if (v94 > 63)
          {
            uint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
            uint64_t v99 = &v123;
            goto LABEL_49;
          }
          v57(v59, v92, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          unint64_t v101 = v118;
          ((void (*)(char *, uint64_t))v118)(v59, a3);
          ((void (*)(char *, uint64_t))v101)(v92, a3);
          goto LABEL_51;
        }
LABEL_29:
        uint64_t v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
        v72(v124, &type metadata for Int, v73, a3, a4);
        uint64_t v61 = v108;
        char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v59, a3);
        uint64_t v75 = v118;
        ((void (*)(char *, uint64_t))v118)(v59, a3);
        if (v74) {
          goto LABEL_59;
        }
        goto LABEL_37;
      }
      if (v62 > 64)
      {
        ((void (*)(char *, uint64_t))v118)(v61, a3);
        goto LABEL_38;
      }
    }
    v57(v59, v61, a3);
    uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v75 = v118;
    ((void (*)(char *, uint64_t))v118)(v59, a3);
    if (v76 < v124[0]) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_37;
  }
LABEL_16:
  LOBYTE(v49) = 0;
LABEL_54:
  *uint64x2_t v120 = v49;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt8(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64x2_t v120 = a1;
  int64x2_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v108 = (char *)&v105 - v8;
  uint64_t v9 = *(char **)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unsigned int v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  int64x2_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint16x8_t v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if (v27(a3, a4))
  {
    uint32x4_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if (v29 < 64)
    {
LABEL_9:
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
      if (v37 < -8) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
    goto LABEL_6;
  }
  char v32 = v27(a3, a4);
  uint32x4_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if ((v32 & 1) == 0)
  {
    if (v29 >= 64) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (v29 > 64)
  {
LABEL_6:
    int64_t v122 = -8;
    uint64_t v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v115 = a4 + 64;
  uint64_t v117 = v27;
  uint64_t v63 = AssociatedTypeWitness;
  uint64_t v64 = v110;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v66 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v63, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t, int **))v64[3])(v66, a3, v64);
  LOBYTE(v63) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
  uint64_t v67 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
  v67(v26, a3);
  uint64_t v116 = v9;
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
  if (v63)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
    LOBYTE(v47) = 0;
    goto LABEL_54;
  }
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
  uint64_t v9 = v116;
  uint64_t v27 = v117;
  uint64_t v28 = v115;
  if (v68 < -8) {
    goto LABEL_16;
  }
LABEL_10:
  char v38 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v39 = v119(a3, a4);
  uint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
LABEL_15:
    (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v45(v26, a3);
    if (v46 <= 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (v39 < 64) {
    goto LABEL_15;
  }
LABEL_12:
  int64_t v122 = 8;
  uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
  v42(&v122, &type metadata for Int, v43, a3, a4);
  char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
  unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v45(v26, a3);
  if ((v44 & 1) == 0)
  {
LABEL_17:
    uint64_t v48 = v26;
    uint64_t v116 = (char *)v45;
    unsigned int v49 = v9 + 16;
    uint64_t v50 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
    uint64_t v51 = v118;
    v50(v118, a2, a3);
    char v52 = v117(a3, a4);
    uint64_t v53 = v114;
    char v54 = v51;
    unint64_t v105 = v49;
    uint64_t v55 = (void (*)(char *, char *, uint64_t))v50;
    v50(v114, (uint64_t)v54, a3);
    if ((v52 & 1) == 0)
    {
      ((void (*)(char *, uint64_t))v116)(v53, a3);
      uint64_t v57 = v48;
      goto LABEL_38;
    }
    uint64_t v56 = v119(a3, a4);
    ((void (*)(char *, uint64_t))v116)(v53, a3);
    uint64_t v57 = v48;
    uint64_t v58 = v117;
    if (v56 <= 64) {
      goto LABEL_38;
    }
    uint64_t v59 = v107;
    v55(v107, v118, a3);
    int64_t v122 = 0x8000000000000000;
    if (v58(a3, a4))
    {
      uint64_t v60 = v119(a3, a4);
      if (v60 >= 64) {
        goto LABEL_29;
      }
    }
    else
    {
      char v69 = v58(a3, a4);
      uint64_t v60 = v119(a3, a4);
      if (v69)
      {
        if (v60 <= 64)
        {
          uint64_t v76 = AssociatedTypeWitness;
          uint64_t v75 = v110;
          uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v78 = v108;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
          ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
          uint64_t v79 = v107;
          char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
          uint64_t v81 = v116;
          ((void (*)(char *, uint64_t))v116)(v57, a3);
          char v82 = v106;
          v55(v106, v79, a3);
          if (v80)
          {
            ((void (*)(char *, uint64_t))v81)(v82, a3);
            goto LABEL_59;
          }
          int64_t v83 = v122;
          uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v81)(v82, a3);
          BOOL v85 = v84 < v83;
          uint64_t v59 = v107;
          unint64_t v73 = v81;
          if (v85) {
            goto LABEL_59;
          }
LABEL_37:
          ((void (*)(char *, uint64_t))v73)(v59, a3);
LABEL_38:
          uint64_t v86 = v118;
          BOOL v87 = v119;
          uint64_t v88 = v119(a3, a4);
          unint64_t v89 = v112;
          v55(v112, v86, a3);
          if (v88 < 65)
          {
            uint64_t v98 = v87(a3, a4);
            ((void (*)(char *, uint64_t))v116)(v89, a3);
            uint64_t v90 = v113;
            if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
              goto LABEL_51;
            }
          }
          else
          {
            ((void (*)(char *, uint64_t))v116)(v89, a3);
            uint64_t v90 = v113;
          }
          v55(v90, v118, a3);
          int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
          char v91 = v117(a3, a4);
          uint64_t v92 = v119(a3, a4);
          if (v91)
          {
            if (v92 > 64)
            {
              uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
              uint64_t v97 = &v122;
LABEL_49:
              v95(v97, &type metadata for Int, v96, a3, a4);
              char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v57, v90, a3);
              unint64_t v101 = v116;
              ((void (*)(char *, uint64_t))v116)(v57, a3);
              if (v100) {
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
              }
              ((void (*)(char *, uint64_t))v101)(v90, a3);
LABEL_51:
              char v102 = v118;
              unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              uint64_t result = ((uint64_t (*)(char *, uint64_t))v116)(v102, a3);
              unsigned int v104 = *v120;
              if ((v103 & 0x8000000000000000) != 0)
              {
                if (v103 >= 0xFFFFFFFFFFFFFFF9)
                {
                  unsigned int v47 = v104 << -(char)v103;
                  goto LABEL_54;
                }
              }
              else if (v103 < 8)
              {
                unsigned int v47 = v104 >> v103;
                goto LABEL_54;
              }
              goto LABEL_16;
            }
          }
          else if (v92 >= 64)
          {
            uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
            uint64_t v97 = &v121;
            goto LABEL_49;
          }
          v55(v57, v90, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v99 = v116;
          ((void (*)(char *, uint64_t))v116)(v57, a3);
          ((void (*)(char *, uint64_t))v99)(v90, a3);
          goto LABEL_51;
        }
LABEL_29:
        uint64_t v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v60, v61, v62);
        v70(&v122, &type metadata for Int, v71, a3, a4);
        uint64_t v59 = v107;
        char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
        unint64_t v73 = v116;
        ((void (*)(char *, uint64_t))v116)(v57, a3);
        if (v72) {
          goto LABEL_59;
        }
        goto LABEL_37;
      }
      if (v60 >= 64)
      {
        ((void (*)(char *, uint64_t))v116)(v59, a3);
        goto LABEL_38;
      }
    }
    v55(v57, v59, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v73 = v116;
    ((void (*)(char *, uint64_t))v116)(v57, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_37;
  }
LABEL_16:
  LOBYTE(v47) = 0;
LABEL_54:
  *uint64x2_t v120 = v47;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt8@<X0>(unsigned __int8 *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  uint64x2_t v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  int8x16_t v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  int8x16_t v136 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v137 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)v125 - v29;
  unsigned int v135 = *a1;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  uint32x4_t v139 = a5;
  if (v32)
  {
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v144[0] = -8;
      uint64_t v141 = v33;
      unsigned int v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v47(v144, &type metadata for Int, v48, a3, a4);
      uint64_t v33 = v141;
      char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(a2, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v49) {
        goto LABEL_28;
      }
    }
    else
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 < -8) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    int8x16_t v138 = a2;
    uint64_t v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      uint64_t v131 = v31;
      if (v41 <= 64)
      {
        uint64_t v51 = AssociatedTypeWitness;
        char v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v138;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v138, v30, a3);
        uint64_t v56 = v12;
        uint64_t v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          goto LABEL_28;
        }
        uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        uint64_t v12 = v128;
        uint64_t v31 = v131;
        uint64_t v33 = v141;
        a2 = v138;
        if (v58 < -8) {
          goto LABEL_28;
        }
      }
      else
      {
        v144[0] = -8;
        char v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        v44(v144, &type metadata for Int, v45, a3, a4);
        a2 = v138;
        char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                  + 16))(v138, v30, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
        uint64_t v31 = v131;
        uint64_t v33 = v141;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v33 = v141;
      a2 = v138;
    }
    else
    {
      a2 = v138;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v138, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      uint64_t v33 = v141;
      if (v50 < -8) {
        goto LABEL_28;
      }
    }
  }
  char v59 = v31(a3, a4);
  uint64_t v60 = a4 + 128;
  uint64_t v61 = (uint64_t (*)(uint64_t, uint64_t))a4;
  uint64_t v62 = (char *)a2;
  uint64_t v63 = v60;
  uint64_t v131 = v61;
  uint64_t v64 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v63;
  if (v59)
  {
    if (v64 > 64) {
      goto LABEL_20;
    }
  }
  else if (v64 > 63)
  {
LABEL_20:
    v144[0] = 8;
    uint64_t v67 = v131;
    uint64_t v68 = v31;
    char v69 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v70 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
    v69(v144, &type metadata for Int, v70, a3, (uint64_t (**)(uint64_t, void))v67);
    uint64_t v31 = v68;
    unint64_t v71 = v62;
    char v72 = v67;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v67 + 4) + 8) + 16))(v30, v71, a3);
    uint64_t v74 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v74(v30, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  unint64_t v71 = v62;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v62, a3);
  char v72 = v131;
  uint64_t v87 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  uint64_t v74 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v74(v30, a3);
  if (v87 <= 8)
  {
LABEL_21:
    int8x16_t v138 = v74;
    uint64_t v141 = v33;
    uint64_t v75 = v31;
    uint64_t v77 = v12 + 16;
    uint64_t v76 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    uint64_t v78 = v12;
    uint64_t v79 = v140;
    v76(v140, v71, a3);
    char v80 = v75;
    LOBYTE(v75) = v75(a3, (uint64_t)v72);
    uint64_t v81 = v137;
    uint16x8_t v126 = v76;
    uint64_t v127 = v77;
    v76(v137, v79, a3);
    uint64_t v128 = v78;
    if ((v75 & 1) == 0)
    {
      v138(v81, a3);
      goto LABEL_43;
    }
    uint64_t v82 = v141(a3, (uint64_t)v72);
    v138(v81, a3);
    if (v82 <= 64) {
      goto LABEL_43;
    }
    int64_t v83 = v130;
    v126(v130, v140, a3);
    v144[0] = 0x8000000000000000;
    if (v80(a3, (uint64_t)v72))
    {
      uint64_t v84 = v141(a3, (uint64_t)v72);
      if (v84 < 64)
      {
LABEL_36:
        v126(v30, v83, a3);
        uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v72 + 15))(a3, v72);
        uint64_t v94 = (void (*)(char *, uint64_t))v138;
        v138(v30, a3);
        if (v95 < v144[0]) {
          goto LABEL_65;
        }
        goto LABEL_42;
      }
    }
    else
    {
      char v90 = v80(a3, (uint64_t)v72);
      uint64_t v84 = v141(a3, (uint64_t)v72);
      if ((v90 & 1) == 0)
      {
        if (v84 >= 64)
        {
          v138(v83, a3);
          goto LABEL_43;
        }
        goto LABEL_36;
      }
      if (v84 <= 64)
      {
        uint64_t v131 = v80;
        uint64_t v97 = AssociatedTypeWitness;
        unint64_t v96 = v134;
        uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v99 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
        ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
        char v100 = v130;
        char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v72 + 4) + 8) + 16))(v130, v30, a3);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v30, a3);
        unint64_t v103 = v129;
        v126(v129, v100, a3);
        if (v101)
        {
          v102(v103, a3);
          goto LABEL_65;
        }
        uint64_t v104 = v144[0];
        uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v72 + 15))(a3, v72);
        v102(v103, a3);
        BOOL v106 = v105 < v104;
        int64_t v83 = v130;
        char v80 = v131;
        uint64_t v94 = v102;
        if (v106) {
LABEL_65:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_42;
      }
    }
    char v91 = (uint64_t (*)(uint64_t, void))*((void *)v72 + 12);
    unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v84, v85, v86);
    ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
    int64_t v83 = v130;
    char v72 = v131;
    char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
    uint64_t v94 = (void (*)(char *, uint64_t))v138;
    v138(v30, a3);
    if (v93) {
      goto LABEL_65;
    }
LABEL_42:
    v94(v83, a3);
LABEL_43:
    uint64_t v107 = v140;
    uint64_t v108 = v141;
    uint64_t v109 = v141(a3, (uint64_t)v72);
    int64x2_t v110 = (char *)v125[0];
    v126((char *)v125[0], v107, a3);
    if (v109 < 65)
    {
      uint64_t v119 = v108(a3, (uint64_t)v72);
      v138(v110, a3);
      uint64_t v111 = v136;
      if (v119 != 64 || (v80(a3, (uint64_t)v72) & 1) != 0) {
        goto LABEL_56;
      }
    }
    else
    {
      v138(v110, a3);
      uint64_t v111 = v136;
    }
    v126(v111, v140, a3);
    v144[0] = 0x7FFFFFFFFFFFFFFFLL;
    char v112 = v80(a3, (uint64_t)v72);
    uint64_t v113 = v141(a3, (uint64_t)v72);
    if (v112)
    {
      if (v113 > 64)
      {
        uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v72 + 12);
        unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
        uint16x8_t v118 = v144;
LABEL_54:
        ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v72);
        char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v72 + 4) + 8) + 16))(v30, v111, a3);
        int64_t v122 = (void (*)(char *, uint64_t))v138;
        v138(v30, a3);
        if (v121) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
        }
        v122(v111, a3);
LABEL_56:
        uint64_t v123 = v140;
        unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v72 + 15))(a3, v72);
        uint64_t result = v138(v123, a3);
        if ((v124 & 0x8000000000000000) != 0)
        {
          unint64_t v89 = v139;
          if (v124 > 0xFFFFFFFFFFFFFFF8)
          {
            unsigned int v88 = v135 >> -(char)v124;
            goto LABEL_59;
          }
        }
        else
        {
          unint64_t v89 = v139;
          if (v124 <= 7)
          {
            unsigned int v88 = v135 << v124;
            goto LABEL_59;
          }
        }
        LOBYTE(v88) = 0;
        goto LABEL_59;
      }
    }
    else if (v113 > 63)
    {
      uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v72 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      uint16x8_t v118 = &v143;
      goto LABEL_54;
    }
    v126(v30, v111, a3);
    (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v72 + 15))(a3, v72);
    uint64x2_t v120 = (void (*)(char *, uint64_t))v138;
    v138(v30, a3);
    v120(v111, a3);
    goto LABEL_56;
  }
LABEL_28:
  LOBYTE(v88) = 0;
  unint64_t v89 = v139;
LABEL_59:
  *unint64_t v89 = v88;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt8(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64x2_t v120 = a1;
  int64x2_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v108 = (char *)&v105 - v8;
  uint64_t v9 = *(char **)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  BOOL v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  char v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint16x8_t v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if (v27(a3, a4))
  {
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if (v29 < 64)
    {
LABEL_9:
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
      if (v37 < -8) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
    goto LABEL_6;
  }
  char v32 = v27(a3, a4);
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if ((v32 & 1) == 0)
  {
    if (v29 >= 64) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (v29 > 64)
  {
LABEL_6:
    int64_t v122 = -8;
    uint64_t v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v115 = a4 + 64;
  unint64_t v117 = v27;
  uint64_t v63 = AssociatedTypeWitness;
  uint64_t v64 = v110;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v66 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v63, AssociatedConformanceWitness);
  ((void (*)(char *, uint64_t, int **))v64[3])(v66, a3, v64);
  LOBYTE(v63) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
  uint64_t v67 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
  v67(v26, a3);
  uint64_t v116 = v9;
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
  if (v63)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
    LOBYTE(v47) = 0;
    goto LABEL_54;
  }
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
  uint64_t v9 = v116;
  uint64_t v27 = v117;
  uint64_t v28 = v115;
  if (v68 < -8) {
    goto LABEL_16;
  }
LABEL_10:
  char v38 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v39 = v119(a3, a4);
  unint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
LABEL_15:
    (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v45(v26, a3);
    if (v46 <= 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (v39 < 64) {
    goto LABEL_15;
  }
LABEL_12:
  int64_t v122 = 8;
  uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
  v42(&v122, &type metadata for Int, v43, a3, a4);
  char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
  unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v45(v26, a3);
  if ((v44 & 1) == 0)
  {
LABEL_17:
    unint64_t v48 = v26;
    uint64_t v116 = (char *)v45;
    char v49 = v9 + 16;
    uint64_t v50 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
    uint64_t v51 = v118;
    v50(v118, a2, a3);
    char v52 = v117(a3, a4);
    uint64_t v53 = v114;
    char v54 = v51;
    uint64_t v105 = v49;
    uint64_t v55 = (void (*)(char *, char *, uint64_t))v50;
    v50(v114, (uint64_t)v54, a3);
    if ((v52 & 1) == 0)
    {
      ((void (*)(char *, uint64_t))v116)(v53, a3);
      uint64_t v57 = v48;
      goto LABEL_38;
    }
    uint64_t v56 = v119(a3, a4);
    ((void (*)(char *, uint64_t))v116)(v53, a3);
    uint64_t v57 = v48;
    uint64_t v58 = v117;
    if (v56 <= 64) {
      goto LABEL_38;
    }
    char v59 = v107;
    v55(v107, v118, a3);
    int64_t v122 = 0x8000000000000000;
    if (v58(a3, a4))
    {
      uint64_t v60 = v119(a3, a4);
      if (v60 >= 64) {
        goto LABEL_29;
      }
    }
    else
    {
      char v69 = v58(a3, a4);
      uint64_t v60 = v119(a3, a4);
      if (v69)
      {
        if (v60 <= 64)
        {
          uint64_t v76 = AssociatedTypeWitness;
          uint64_t v75 = v110;
          uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v78 = v108;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
          ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
          uint64_t v79 = v107;
          char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
          uint64_t v81 = v116;
          ((void (*)(char *, uint64_t))v116)(v57, a3);
          uint64_t v82 = v106;
          v55(v106, v79, a3);
          if (v80)
          {
            ((void (*)(char *, uint64_t))v81)(v82, a3);
            goto LABEL_59;
          }
          int64_t v83 = v122;
          uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          ((void (*)(char *, uint64_t))v81)(v82, a3);
          BOOL v85 = v84 < v83;
          char v59 = v107;
          char v73 = v81;
          if (v85) {
            goto LABEL_59;
          }
LABEL_37:
          ((void (*)(char *, uint64_t))v73)(v59, a3);
LABEL_38:
          uint64_t v86 = v118;
          uint64_t v87 = v119;
          uint64_t v88 = v119(a3, a4);
          unint64_t v89 = v112;
          v55(v112, v86, a3);
          if (v88 < 65)
          {
            uint64_t v98 = v87(a3, a4);
            ((void (*)(char *, uint64_t))v116)(v89, a3);
            char v90 = v113;
            if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
              goto LABEL_51;
            }
          }
          else
          {
            ((void (*)(char *, uint64_t))v116)(v89, a3);
            char v90 = v113;
          }
          v55(v90, v118, a3);
          int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
          char v91 = v117(a3, a4);
          uint64_t v92 = v119(a3, a4);
          if (v91)
          {
            if (v92 > 64)
            {
              uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
              uint64_t v97 = &v122;
LABEL_49:
              v95(v97, &type metadata for Int, v96, a3, a4);
              char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v57, v90, a3);
              char v101 = v116;
              ((void (*)(char *, uint64_t))v116)(v57, a3);
              if (v100) {
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
              }
              ((void (*)(char *, uint64_t))v101)(v90, a3);
LABEL_51:
              char v102 = v118;
              unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              uint64_t result = ((uint64_t (*)(char *, uint64_t))v116)(v102, a3);
              unsigned int v104 = *v120;
              if ((v103 & 0x8000000000000000) != 0)
              {
                if (v103 > 0xFFFFFFFFFFFFFFF8)
                {
                  unsigned int v47 = v104 >> -(char)v103;
                  goto LABEL_54;
                }
              }
              else if (v103 < 8)
              {
                unsigned int v47 = v104 << v103;
                goto LABEL_54;
              }
              goto LABEL_16;
            }
          }
          else if (v92 >= 64)
          {
            uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
            uint64_t v97 = &v121;
            goto LABEL_49;
          }
          v55(v57, v90, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v99 = v116;
          ((void (*)(char *, uint64_t))v116)(v57, a3);
          ((void (*)(char *, uint64_t))v99)(v90, a3);
          goto LABEL_51;
        }
LABEL_29:
        unint64_t v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v60, v61, v62);
        v70(&v122, &type metadata for Int, v71, a3, a4);
        char v59 = v107;
        char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
        char v73 = v116;
        ((void (*)(char *, uint64_t))v116)(v57, a3);
        if (v72) {
          goto LABEL_59;
        }
        goto LABEL_37;
      }
      if (v60 >= 64)
      {
        ((void (*)(char *, uint64_t))v116)(v59, a3);
        goto LABEL_38;
      }
    }
    v55(v57, v59, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v73 = v116;
    ((void (*)(char *, uint64_t))v116)(v57, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_37;
  }
LABEL_16:
  LOBYTE(v47) = 0;
LABEL_54:
  *uint64x2_t v120 = v47;
  return result;
}

unsigned char *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt8(unsigned char *result, unsigned char *a2, unsigned char *a3)
{
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  }
  char v4 = *v3 / *a3;
  *a2 = *v3 % *a3;
  *uint64_t result = v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt8(unsigned __int8 *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt8(BOOL *a1@<X8>)
{
  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8(uint64_t a1@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  uint64_t v63 = a4;
  uint64_t v5 = a3;
  char v69 = a5;
  uint64_t v8 = *(void *)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v66 = (char *)&v59 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v61 = (char *)&v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v68 = (char *)&v59 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v59 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v59 - v20;
  uint64_t v64 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  char v22 = v64(a2, v5);
  uint64_t v70 = a1;
  uint64_t v71 = v12;
  uint64_t v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v67(v21, a1, a2);
  if ((v22 & 1) == 0)
  {
    uint64_t v60 = v8;
    uint64_t v62 = v19;
    uint64_t v65 = *(void (**)(char *, uint64_t))(v71 + 8);
    v65(v21, a2);
    goto LABEL_6;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v24 = v66;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v24, a2, v8);
  char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v21, v19, a2);
  uint64_t v59 = v5;
  uint64_t v26 = v19;
  uint64_t v27 = *(void (**)(char *, uint64_t))(v71 + 8);
  v27(v26, a2);
  v27(v21, a2);
  if ((v25 & 1) == 0)
  {
    uint64_t v60 = v8;
    uint64_t v62 = v26;
    uint64_t v65 = v27;
    uint64_t v5 = v59;
LABEL_6:
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v33 = v70;
    uint64_t v34 = v32(a2, v5);
    char v35 = v68;
    v67(v68, v33, a2);
    if (v34 <= 7)
    {
      uint64_t v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
      v65(v35, a2);
      uint64_t v31 = v69;
LABEL_8:
      char v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      uint64_t result = v36(v33, a2);
      char v30 = 0;
      goto LABEL_19;
    }
    unsigned __int8 v72 = -1;
    char v37 = v64(a2, v5);
    uint64_t v38 = v32(a2, v5);
    uint64_t v41 = v35;
    if (v37)
    {
      if (v38 < 9)
      {
        uint64_t v42 = v60;
        uint64_t v43 = swift_getAssociatedConformanceWitness(v60, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v44 = v66;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v43 + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, v43);
        unint64_t v45 = v62;
        (*(void (**)(char *, uint64_t, uint64_t))(v42 + 24))(v44, a2, v42);
        LOBYTE(v42) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 40))(v41, v45, a2);
        uint64_t v46 = v71;
        unsigned int v47 = v45;
        unint64_t v48 = v41;
        uint64_t v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
        v65(v47, a2);
        unsigned int v49 = v72;
        uint64_t v50 = v61;
        (*(void (**)(char *, char *, uint64_t))(v46 + 32))(v61, v48, a2);
        if ((v42 & 1) == 0)
        {
          v36((uint64_t)v50, a2);
          uint64_t v31 = v69;
          uint64_t v33 = v70;
          goto LABEL_8;
        }
        unsigned __int8 v51 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
        v36((uint64_t)v50, a2);
        BOOL v52 = v49 >= v51;
LABEL_17:
        uint64_t v31 = v69;
        uint64_t v33 = v70;
        if (v52) {
          goto LABEL_8;
        }
        goto LABEL_18;
      }
    }
    else if (v38 < 9)
    {
      uint64_t v57 = v62;
      (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v62, v35, a2);
      unsigned __int8 v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      uint64_t v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
      v65(v57, a2);
      BOOL v52 = v72 >= v58;
      goto LABEL_17;
    }
    uint64_t v53 = *(void (**)(unsigned __int8 *, uint64_t, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v54 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v38, v39, v40);
    uint64_t v55 = v62;
    v53(&v72, v63, v54, a2, v5);
    char v56 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v55, v41, a2);
    uint64_t v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
    v65(v55, a2);
    v36((uint64_t)v41, a2);
    uint64_t v31 = v69;
    uint64_t v33 = v70;
    if ((v56 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_18:
    uint64_t result = v36(v33, a2);
    char v29 = 0;
    char v30 = 1;
    goto LABEL_19;
  }
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v27)(v70, a2);
  char v29 = 0;
  char v30 = 1;
  uint64_t v31 = v69;
LABEL_19:
  unsigned char *v31 = v29;
  v31[1] = v30;
  return result;
}

unsigned char *protocol witness for static Numeric.* infix(_:_:) in conformance UInt8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  if (((*result * (unsigned __int16)*a2) & 0xFF00) != 0) {
    __break(1u);
  }
  else {
    *a3 = *result * *a2;
  }
  return result;
}

unsigned char *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt8(unsigned char *result, unsigned char *a2)
{
  if (((*result * (unsigned __int16)*a2) & 0xFF00) != 0) {
    __break(1u);
  }
  else {
    *result *= *a2;
  }
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt8()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

unsigned __int8 *protocol witness for Strideable.distance(to:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  unsigned int v3 = *result;
  unsigned int v4 = *v2;
  uint64_t v5 = v4 - v3;
  BOOL v6 = v3 >= v4;
  uint64_t v7 = v3 - v4;
  if (!v6) {
    uint64_t v7 = -v5;
  }
  *a2 = v7;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt8@<X0>(unint64_t *result@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *result;
  int v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (v3 >= 0x100) {
      goto LABEL_8;
    }
    v4 += v3;
    unint64_t v3 = v4;
    if (v4 == v4)
    {
LABEL_7:
      *a2 = v4;
      return result;
    }
    __break(1u);
  }
  unint64_t v5 = -(uint64_t)v3;
  if (v5 >= 0x100) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  v4 -= v5;
  if ((v4 & 0xFFFFFF00) == 0) {
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

unsigned __int8 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, unsigned __int8 *a2@<X1>, unsigned char *a3@<X8>)
{
  unsigned int v3 = *result + *a2;
  if ((v3 >> 8)) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

uint64_t static UInt8.+ infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result = a1 + a2;
  if ((result >> 8)) {
    __break(1u);
  }
  return result;
}

unsigned char *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt8(unsigned char *result, unsigned __int8 *a2)
{
  unsigned int v2 = *result + *a2;
  if ((v2 >> 8)) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

unsigned __int8 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, unsigned __int8 *a2@<X1>, unsigned char *a3@<X8>)
{
  int v3 = *result - *a2;
  if ((v3 & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

unsigned char *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt8(unsigned char *result, unsigned __int8 *a2)
{
  int v2 = *result - *a2;
  if ((v2 & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

uint64_t UInt8._toCustomAnyHashable()@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt8>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(unsigned char *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt8@<X0>(uint64_t a1@<X8>)
{
  char v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt8>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(unsigned char *)a1 = v3;
  return result;
}

uint64_t Int8._value.setter(uint64_t result)
{
  *unsigned __int8 v1 = result;
  return result;
}

uint64_t (*Int8._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int8 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x63BuLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(-10232)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int8 because the result would be less than Int8.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x63EuLL, 0);
  }
  if (*(short float *)&a1 >= COERCE_SHORT_FLOAT(22528)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int8 because the result would be greater than Int8.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x641uLL, 0);
  }
  return (int)*(short float *)&a1;
}

uint64_t Int8.init(exactly:)(__n128 a1)
{
  BOOL v1 = *(short float *)a1.n128_u16 > COERCE_SHORT_FLOAT(-10232);
  if (*(short float *)a1.n128_u16 >= COERCE_SHORT_FLOAT(22528)) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncl(*(short float *)a1.n128_u16) == *(short float *)a1.n128_u16);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (int)*(short float *)a1.n128_u16;
  }
  return v5 & 0xFFFFFEFF | ((v4 & 1) << 8);
}

Swift::Int8 __swiftcall Int8.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int8 because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x687uLL, 0);
  }
  if (a1 <= -129.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int8 because the result would be less than Int8.min", 86, 2, "Swift/IntegerTypes.swift", 24, 2, 0x68AuLL, 0);
  }
  if (a1 >= 128.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int8 because the result would be greater than Int8.max", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x68DuLL, 0);
  }
  return (int)a1;
}

Swift::Int8_optional __swiftcall Int8.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -129.0;
  if (exactly >= 128.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = (int)exactly;
  }
  return (Swift::Int8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

Swift::Int8 __swiftcall Int8.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int8 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x6CFuLL, 0);
  }
  if (a1 <= -129.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int8 because the result would be less than Int8.min", 87, 2, "Swift/IntegerTypes.swift", 24, 2, 0x6D2uLL, 0);
  }
  if (a1 >= 128.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int8 because the result would be greater than Int8.max", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x6D5uLL, 0);
  }
  return (int)a1;
}

Swift::Int8_optional __swiftcall Int8.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -129.0;
  if (exactly >= 128.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = (int)exactly;
  }
  return (Swift::Int8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

BOOL static Int8.< infix(_:_:)(char a1, char a2)
{
  return a1 < a2;
}

unsigned char *static Int8.-= infix(_:_:)(unsigned char *result, char a2)
{
  int v2 = (char)*result - a2;
  if ((char)(*result - a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

unsigned char *static Int8.*= infix(_:_:)(unsigned char *result, char a2)
{
  int v2 = (char)*result * a2;
  if ((char)(*result * a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

unsigned char *static Int8./= infix(_:_:)(unsigned char *result, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 128) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  }
  *uint64_t result = (char)v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.addingReportingOverflow(_:)(Swift::Int8 a1)
{
  Swift::Int8 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.subtractingReportingOverflow(_:)(Swift::Int8 a1)
{
  Swift::Int8 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.multipliedReportingOverflow(by:)(Swift::Int8 by)
{
  Swift::Int8 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.dividedReportingOverflow(by:)(Swift::Int8 by)
{
  if (by)
  {
    if (by == -1 && v1 == 128) {
      char v1 = 0x80;
    }
    else {
      v1 /= by;
    }
  }
  Swift::Int8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.remainderReportingOverflow(dividingBy:)(Swift::Int8 dividingBy)
{
  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 128) {
      char v1 = 0;
    }
    else {
      v1 %= dividingBy;
    }
  }
  Swift::Int8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

unsigned char *static Int8.%= infix(_:_:)(unsigned char *result, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 128) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  }
  *Swift::tuple_partialValue_Int8_overflow_Bool result = (char)v2 % a2;
  return result;
}

unsigned char *static Int8.&= infix(_:_:)(unsigned char *result, char a2)
{
  *result &= a2;
  return result;
}

unsigned char *static Int8.|= infix(_:_:)(unsigned char *result, char a2)
{
  *result |= a2;
  return result;
}

unsigned char *static Int8.^= infix(_:_:)(unsigned char *result, char a2)
{
  *result ^= a2;
  return result;
}

unsigned char *static Int8.&>>= infix(_:_:)(unsigned char *result, char a2)
{
  *Swift::tuple_partialValue_Int8_overflow_Bool result = (char)*result >> (a2 & 7);
  return result;
}

uint64_t static Int8.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

unsigned char *static Int8.&<<= infix(_:_:)(unsigned char *result, char a2)
{
  *Swift::tuple_partialValue_Int8_overflow_Bool result = *result << (a2 & 7);
  return result;
}

uint64_t static Int8.bitWidth.getter()
{
  return 8;
}

uint64_t Int8.leadingZeroBitCount.getter(unsigned __int8 a1)
{
  return (__clz(a1) - 24);
}

uint64_t Int8._lowWord.getter(uint64_t result)
{
  return (char)result;
}

uint64_t Int8.trailingZeroBitCount.getter(int a1)
{
  return __clz(__rbit32(a1 | 0x100));
}

uint64_t Int8.nonzeroBitCount.getter(unsigned __int8 a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t Int8.Words._value.setter(uint64_t result)
{
  *uint8x8_t v1 = result;
  return result;
}

uint64_t (*Int8.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.Words.count.getter()
{
  return 1;
}

uint64_t Int8.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int8.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int8.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int8.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int8.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int8.Words.subscript.getter(uint64_t a1, char a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x9AAuLL, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x9ABuLL, 0);
  }
  return a2;
}

uint64_t static Int8.&>> infix(_:_:)(char a1, char a2)
{
  return (a1 >> (a2 & 7));
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Int8.Words@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Int8.Words(unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int8.Words(uint64_t *a1, uint64_t *a2))()
{
  *a1 = Int8.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt8.Words@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  char v4 = *v2;
  *(void *)a2 = *result;
  *(void *)(a2 + 8) = v3;
  *(unsigned char *)(a2 + 16) = v4;
  return result;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance Int8.Words(uint64_t *a1, uint64_t *a2)
{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1]);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UInt8.Words(void *result, void *a2)
{
  if (*result < *a2 || a2[1] < *result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

{
  if (*result < *a2 || a2[1] < result[1]) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Int8.Words(uint64_t a1@<X8>)
{
  *(unsigned char *)a1 = *v1;
  *(void *)(a1 + 8) = 0;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int8.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int8.Words(uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int8.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySuqd__Isgyrzo_s4Int8V5WordsVABsAG_pAKRszr__lIetMgyrzo_Tpq5Tm(a1, a2);
}

uint64_t Int8.magnitude.getter(char a1)
{
  if (a1 >= 0) {
    return a1;
  }
  else {
    return -a1;
  }
}

Swift::tuple_high_Int8_low_UInt8 __swiftcall Int8.multipliedFullWidth(by:)(Swift::Int8 by)
{
  unsigned int v2 = bswap32(v1 * by) >> 16;
  result.high = v2;
  result.Swift::UInt64 low = v1;
  return result;
}

Swift::tuple_quotient_Int8_remainder_Int8 __swiftcall Int8.dividingFullWidth(_:)(Swift::tuple_high_Int8_low_UInt8 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA29uLL, 0);
  }
  __int16 v3 = a1.low | (unsigned __int16)(__PAIR16__(v2, a1.high) << 8);
  if (v1 == -1 && (unsigned __int16)v3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  }
  unsigned __int16 v4 = v3 / v1;
  if ((unsigned __int16)(char)v4 != v4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA33uLL, 0);
  }
  result.remainder = v3;
  result.quotient = v4;
  return result;
}

uint64_t static Int16.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << (a2 & 0xF));
}

Swift::Int8 __swiftcall Int8.signum()()
{
  return (v0 > 0) | (v0 >> 7);
}

BOOL static Int8.> infix(_:_:)(char a1, char a2)
{
  return a2 < a1;
}

uint64_t static Int8.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int8(unsigned char *a1@<X8>)
{
  *a1 = 127;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int8(unsigned char *a1@<X8>)
{
  *a1 = 0x80;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int8(unsigned char *a1, unsigned char *a2)
{
  int v3 = (char)*v2 + (char)*a2;
  BOOL v4 = v3 != (char)(*v2 + *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int8(unsigned char *a1, unsigned char *a2)
{
  int v3 = (char)*v2 - (char)*a2;
  BOOL v4 = v3 != (char)(*v2 - *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int8(unsigned char *a1, unsigned char *a2)
{
  int v3 = (char)*v2 * (char)*a2;
  BOOL v4 = v3 != (char)(*v2 * *a2);
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int8(unsigned char *a1, unsigned char *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if (!*a2 || v3 == 255 && v4 == 128)
  {
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    LOBYTE(v4) = (char)v4 / (char)v3;
  }
  *a1 = v4;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int8(unsigned char *a1, unsigned char *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if (!*a2) {
    goto LABEL_7;
  }
  if (v3 == 255 && v4 == 128)
  {
    LOBYTE(v4) = 0;
LABEL_7:
    uint64_t v5 = 1;
    goto LABEL_5;
  }
  uint64_t v5 = 0;
  LOBYTE(v4) = (char)v4 % (char)v3;
LABEL_5:
  *a1 = v4;
  return v5;
}

unsigned char *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int8(unsigned char *result, unsigned char *a2, char *a3)
{
  __int16 v4 = *v3 * *a3;
  *Swift::tuple_quotient_Int8_remainder_Int8 result = HIBYTE(v4);
  *a2 = v4;
  return result;
}

Swift::Int8 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int8(Swift::Int8 *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4)
{
  Swift::Int8 result = Int8.dividingFullWidth(_:)((Swift::tuple_high_Int8_low_UInt8)__PAIR16__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int8()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int8()
{
  return (__clz(*v0) - 24);
}

char *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int8@<X0>(char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *result >> (*a2 & 7);
  return result;
}

unsigned char *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  *Swift::Int8 result = (char)*result >> (*a2 & 7);
  return result;
}

unsigned __int8 *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *result << (*a2 & 7);
  return result;
}

uint64_t static Int8.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << (a2 & 7));
}

unsigned char *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  *Swift::Int8 result = *result << (*a2 & 7);
  return result;
}

unsigned char *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

unsigned char *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

unsigned char *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

unsigned char *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int8@<X0>(unsigned char *result@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (a2 <= 0x8FF) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int8@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int8 and conformance Int8, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, unsigned char *a6@<X8>)
{
  uint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((v38 & 0x100) != 0)
  {
    uint64_t v38 = static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._unint64_t object = (void *)0x80000001816DE7E0;
      v26._uint64_t countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        char v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if (v33) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._uint64_t countAndFlagsBits = 0xD00000000000002ELL;
        v37._unint64_t object = (void *)0x80000001816DE800;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned char *a6@<X8>)
{
  uint64_t v79 = a4;
  uint64_t v80 = a5;
  uint64_t v75 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v75, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v73 = (char *)&v72 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v76 = (char *)&v72 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  int64_t v83 = (char *)&v72 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  int64_t v19 = (char *)&v72 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v81 = (char *)&v72 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v78 = (char *)&v72 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v72 - v24;
  BOOL v85 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v26 = v85(a2, a3);
  uint64_t v86 = a1;
  uint64_t v87 = v12;
  uint64_t v88 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v88(v25, a1, a2);
  uint64_t v84 = a6;
  uint64_t v82 = a3 + 64;
  if (v26)
  {
    uint64_t v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v27 = v77(a2, a3);
    unint64_t v89 = *(void (**)(char *, uint64_t))(v12 + 8);
    v89(v25, a2);
    if (v27 <= 8)
    {
      uint64_t v34 = v86;
      char v33 = v77;
      uint64_t v35 = v77(a2, a3);
      goto LABEL_23;
    }
    unsigned __int8 v72 = v19;
    uint64_t v28 = v78;
    v88(v78, v86, a2);
    char v90 = 0x80;
    char v29 = v85;
    if (v85(a2, a3))
    {
      if (v77(a2, a3) < 8)
      {
        int64_t v30 = v81;
        v88(v81, (uint64_t)v28, a2);
        char v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v30;
LABEL_17:
        uint64_t v43 = v89;
        v89(v32, a2);
        if (v90 > v31) {
LABEL_40:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_21;
      }
      uint64_t v42 = v81;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v90, v79, v80, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v42, a2);
      uint64_t v41 = v42;
    }
    else
    {
      char v36 = v29(a2, a3);
      uint64_t v37 = v77(a2, a3);
      uint64_t v38 = v28;
      if ((v36 & 1) == 0)
      {
        if (v37 >= 8)
        {
          v89(v28, a2);
          uint64_t v34 = v86;
          int64_t v19 = v72;
          char v33 = v77;
          uint64_t v35 = v77(a2, a3);
          goto LABEL_23;
        }
        char v44 = v81;
        v88(v81, (uint64_t)v28, a2);
        char v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v44;
        goto LABEL_17;
      }
      if (v37 <= 8)
      {
        unint64_t v45 = AssociatedTypeWitness;
        uint64_t v46 = v75;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v75, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v48 = v73;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v45, AssociatedConformanceWitness);
        unsigned int v49 = v81;
        ((void (*)(char *, uint64_t, int **))v46[3])(v48, a2, v46);
        LOBYTE(v45) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v38, v49, a2);
        uint64_t v50 = v38;
        uint64_t v43 = v89;
        v89(v49, a2);
        unsigned __int8 v51 = v76;
        v88(v76, (uint64_t)v50, a2);
        if (v45)
        {
          v43(v51, a2);
          goto LABEL_40;
        }
        int v52 = v90;
        char v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v43(v51, a2);
        uint64_t v28 = v78;
        if (v52 > v53) {
          goto LABEL_40;
        }
LABEL_21:
        v43(v28, a2);
        int64_t v19 = v72;
        char v33 = v77;
        goto LABEL_22;
      }
      unint64_t v39 = v81;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v90, v79, v80, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v39, a2);
      uint64_t v41 = v39;
    }
    uint64_t v43 = v89;
    v89(v41, a2);
    if (v40) {
      goto LABEL_40;
    }
    goto LABEL_21;
  }
  unint64_t v89 = *(void (**)(char *, uint64_t))(v12 + 8);
  v89(v25, a2);
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
LABEL_22:
  uint64_t v34 = v86;
  uint64_t v35 = v33(a2, a3);
LABEL_23:
  uint64_t v54 = v35;
  v88(v19, v34, a2);
  if (v54 < 9)
  {
    uint64_t v55 = v33;
    uint64_t v62 = v33(a2, a3);
    v89(v19, a2);
    if (v62 != 8)
    {
      char v56 = v84;
      goto LABEL_37;
    }
    char v63 = v85(a2, a3);
    char v56 = v84;
    if (v63) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v55 = v33;
    v89(v19, a2);
    char v56 = v84;
  }
  uint64_t v57 = v83;
  v88(v83, v34, a2);
  char v92 = 127;
  char v58 = v85(a2, a3);
  uint64_t v59 = v55(a2, a3);
  if ((v58 & 1) == 0)
  {
    if (v59 > 7)
    {
      char v91 = 127;
      uint64_t v60 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v61 = &v91;
      goto LABEL_35;
    }
LABEL_32:
    uint64_t v64 = v81;
    v88(v81, (uint64_t)v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v65 = v89;
    v89(v64, a2);
    v65(v57, a2);
    goto LABEL_37;
  }
  if (v59 <= 8) {
    goto LABEL_32;
  }
  uint64_t v60 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v61 = &v92;
LABEL_35:
  uint64_t v66 = v81;
  v60(v61, v79, v80, a2, a3);
  char v67 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v66, v57, a2);
  uint64_t v68 = v66;
  char v69 = v89;
  v89(v68, a2);
  if (v67) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v69(v83, a2);
LABEL_37:
  char v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v89)(v34, a2);
  *char v56 = v70;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  char v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int8()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int8()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int8()
{
  return __clz(__rbit32(*v0 | 0x100));
}

unsigned __int8 *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  }
  int v4 = *result;
  if (v4 == 128 && v3 == 255) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  }
  *a3 = (char)v4 / (char)v3;
  return result;
}

uint64_t static Int8./ infix(_:_:)(unsigned __int8 a1, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  }
  if (a1 == 128 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  }
  return ((char)a1 / a2);
}

unsigned char *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  }
  int v3 = *result;
  if (v2 == 255 && v3 == 128) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  }
  *uint64_t result = (char)v3 / (char)v2;
  return result;
}

unsigned __int8 *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  }
  int v4 = *result;
  if (v4 == 128 && v3 == 255) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  }
  *a3 = (char)v4 % (char)v3;
  return result;
}

uint64_t static Int8.% infix(_:_:)(unsigned __int8 a1, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  }
  if (a1 == 128 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  }
  return ((char)a1 % a2);
}

unsigned char *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  }
  int v3 = *result;
  if (v2 == 255 && v3 == 128) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  }
  *uint64_t result = (char)v3 % (char)v2;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  *result &= *a2;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  *result |= *a2;
  return result;
}

unsigned char *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int8.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

unsigned char *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int8@<X0>(unsigned __int8 *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  uint64x2_t v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  int8x16_t v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unsigned int v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  int64_t v30 = (char *)v125 - v29;
  int v138 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  uint32x4_t v139 = a5;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 >= -8) {
        goto LABEL_19;
      }
LABEL_18:
      LOBYTE(v59) = 0;
      uint64_t v60 = v139;
      goto LABEL_60;
    }
    v144[0] = -8;
    uint64_t v141 = v33;
    unsigned int v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    char v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    char v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v137 = a2;
    uint64_t v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      uint64_t v131 = v31;
      if (v41 <= 64)
      {
        unsigned __int8 v51 = AssociatedTypeWitness;
        int v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        uint64_t v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          char v31 = v131;
          char v33 = v141;
          a2 = v137;
          if (v58 >= -8) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -8;
      char v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v31 = v131;
      char v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        char v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v33 = v141;
      if (v50 < -8) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  char v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  uint64_t v64 = (char *)a2;
  uint64_t v65 = v62;
  uint64_t v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 8;
    char v69 = v131;
    char v70 = v31;
    uint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    char v31 = v70;
    char v73 = v64;
    uint64_t v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    int v59 = (char)v138 >> 7;
    uint64_t v60 = v139;
    goto LABEL_60;
  }
  char v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  uint64_t v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 8) {
    goto LABEL_29;
  }
LABEL_22:
  uint64_t v137 = v76;
  uint64_t v141 = v33;
  uint64_t v77 = v31;
  uint64_t v79 = v12 + 16;
  uint64_t v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  uint64_t v81 = v140;
  v78(v140, v73, a3);
  uint64_t v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  int64_t v83 = v136;
  uint16x8_t v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  BOOL v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      uint64_t v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_66;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      uint64_t v131 = v82;
      uint64_t v97 = AssociatedTypeWitness;
      unint64_t v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      char v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      char v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      unint64_t v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_66;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      BOOL v85 = v130;
      uint64_t v82 = v131;
      uint64_t v94 = v102;
      if (v106) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  char v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  BOOL v85 = v130;
  uint64_t v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  uint64_t v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_66;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  uint64_t v107 = v140;
  uint64_t v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  int64x2_t v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    uint64_t v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    uint64_t v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      uint16x8_t v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      int64_t v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    uint16x8_t v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  uint64x2_t v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  uint64_t v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v60 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFF8) {
      LOBYTE(v59) = 0;
    }
    else {
      int v59 = v138 << -(char)v124;
    }
  }
  else
  {
    uint64_t v60 = v139;
    if (v124 >= 8) {
      int v59 = (char)v138 >> 7;
    }
    else {
      int v59 = (char)v138 >> v124;
    }
  }
LABEL_60:
  *uint64_t v60 = v59;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int8(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64x2_t v120 = a1;
  int64x2_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v108 = (char *)&v105 - v8;
  uint64_t v9 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  BOOL v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  char v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint16x8_t v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v32 = v27(a3, a4);
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_14;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      uint64_t v115 = a4 + 64;
      unint64_t v117 = v27;
      char v39 = AssociatedTypeWitness;
      char v40 = v110;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v108;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      uint64_t v116 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        LOBYTE(v38) = 0;
        goto LABEL_53;
      }
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      uint64_t v9 = v116;
      uint64_t v27 = v117;
      uint64_t v28 = v115;
      if (v44 < -8) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
LABEL_6:
    int64_t v122 = -8;
    char v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v37 < -8)
  {
LABEL_10:
    LOBYTE(v38) = 0;
    goto LABEL_53;
  }
LABEL_14:
  char v45 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v46 = v119(a3, a4);
  unint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v45)
  {
    if (v46 > 64) {
      goto LABEL_16;
    }
  }
  else if (v46 >= 64)
  {
LABEL_16:
    int64_t v122 = 8;
    char v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
    v49(&v122, &type metadata for Int, v50, a3, a4);
    char v51 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    int v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v52(v26, a3);
    if ((v51 & 1) == 0) {
      goto LABEL_17;
    }
LABEL_24:
    int v38 = (char)*v120 >> 7;
    goto LABEL_53;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v52(v26, a3);
  if (v68 > 8) {
    goto LABEL_24;
  }
LABEL_17:
  char v53 = v26;
  uint64_t v116 = v52;
  uint64_t v54 = (char *)v9 + 16;
  uint64_t v55 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v56 = v118;
  v55(v118, a2, a3);
  char v57 = v117(a3, a4);
  uint64_t v58 = v114;
  int v59 = v56;
  uint64_t v105 = v54;
  uint64_t v60 = (void (*)(char *, char *, uint64_t))v55;
  v55(v114, (uint64_t)v59, a3);
  if ((v57 & 1) == 0)
  {
    v116(v58, a3);
    uint64_t v62 = v53;
    goto LABEL_37;
  }
  uint64_t v61 = v119(a3, a4);
  v116(v58, a3);
  uint64_t v62 = v53;
  char v63 = v117;
  if (v61 <= 64) {
    goto LABEL_37;
  }
  uint64_t v64 = v107;
  v60(v107, v118, a3);
  int64_t v122 = 0x8000000000000000;
  if (v63(a3, a4))
  {
    uint64_t v65 = v119(a3, a4);
    if (v65 >= 64)
    {
LABEL_28:
      char v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
      v70(&v122, &type metadata for Int, v71, a3, a4);
      uint64_t v64 = v107;
      char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
      char v73 = (void (*)(char *, uint64_t))v116;
      v116(v62, a3);
      if (v72) {
        goto LABEL_59;
      }
      goto LABEL_36;
    }
LABEL_32:
    v60(v62, v64, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v73 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v69 = v63(a3, a4);
  uint64_t v65 = v119(a3, a4);
  if ((v69 & 1) == 0)
  {
    if (v65 >= 64)
    {
      v116(v64, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v65 > 64) {
    goto LABEL_28;
  }
  uint64_t v76 = AssociatedTypeWitness;
  char v75 = v110;
  uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v78 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
  ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
  uint64_t v79 = v107;
  char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
  uint64_t v81 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  uint64_t v82 = v106;
  v60(v106, v79, a3);
  if (v80)
  {
    v81(v82, a3);
    goto LABEL_59;
  }
  int64_t v83 = v122;
  uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v82, a3);
  BOOL v85 = v84 < v83;
  uint64_t v64 = v107;
  char v73 = v81;
  if (v85) {
    goto LABEL_59;
  }
LABEL_36:
  v73(v64, a3);
LABEL_37:
  uint64_t v86 = v118;
  uint64_t v87 = v119;
  uint64_t v88 = v119(a3, a4);
  uint64_t v89 = v112;
  v60(v112, v86, a3);
  if (v88 < 65)
  {
    uint64_t v98 = v87(a3, a4);
    v116(v89, a3);
    char v90 = v113;
    if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v116(v89, a3);
    char v90 = v113;
  }
  v60(v90, v118, a3);
  int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
  char v91 = v117(a3, a4);
  uint64_t v92 = v119(a3, a4);
  if ((v91 & 1) == 0)
  {
    if (v92 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      uint64_t v97 = &v121;
      goto LABEL_48;
    }
LABEL_47:
    v60(v62, v90, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v99 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    v99(v90, a3);
    goto LABEL_50;
  }
  if (v92 <= 64) {
    goto LABEL_47;
  }
  uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
  uint64_t v97 = &v122;
LABEL_48:
  v95(v97, &type metadata for Int, v96, a3, a4);
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v90, a3);
  char v101 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  if (v100) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v101(v90, a3);
LABEL_50:
  char v102 = v118;
  unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v116(v102, a3);
  int v104 = *v120;
  if ((v103 & 0x8000000000000000) != 0)
  {
    if (v103 > 0xFFFFFFFFFFFFFFF8)
    {
      int v38 = v104 << -(char)v103;
      goto LABEL_53;
    }
    goto LABEL_10;
  }
  if (v103 >= 8) {
    int v38 = (char)v104 >> 7;
  }
  else {
    int v38 = (char)v104 >> v103;
  }
LABEL_53:
  *uint64x2_t v120 = v38;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int8@<X0>(unsigned __int8 *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  uint64x2_t v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  int8x16_t v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unsigned int v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  unint64_t v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)v125 - v29;
  int v138 = *a1;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  uint32x4_t v139 = a5;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 > -9) {
        goto LABEL_19;
      }
LABEL_18:
      int v59 = (char)v138 >> 7;
      uint64_t v60 = v139;
      goto LABEL_60;
    }
    v144[0] = -8;
    uint64_t v141 = v33;
    uint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    char v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    char v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v137 = a2;
    uint64_t v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      uint64_t v131 = v31;
      if (v41 <= 64)
      {
        char v51 = AssociatedTypeWitness;
        int v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        char v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          uint64_t v31 = v131;
          char v33 = v141;
          a2 = v137;
          if (v58 >= -8) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -8;
      uint64_t v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      uint64_t v31 = v131;
      char v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        char v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v33 = v141;
      if (v50 < -8) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  char v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  uint64_t v64 = (char *)a2;
  uint64_t v65 = v62;
  uint64_t v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 8;
    char v69 = v131;
    char v70 = v31;
    unint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    uint64_t v31 = v70;
    char v73 = v64;
    uint64_t v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    LOBYTE(v59) = 0;
    uint64_t v60 = v139;
    goto LABEL_60;
  }
  char v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  uint64_t v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 8) {
    goto LABEL_29;
  }
LABEL_22:
  uint64_t v137 = v76;
  uint64_t v141 = v33;
  uint64_t v77 = v31;
  uint64_t v79 = v12 + 16;
  uint64_t v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  uint64_t v81 = v140;
  v78(v140, v73, a3);
  uint64_t v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  int64_t v83 = v136;
  uint16x8_t v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  BOOL v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      uint64_t v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_66;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      uint64_t v131 = v82;
      uint64_t v97 = AssociatedTypeWitness;
      unint64_t v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      char v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      char v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      unint64_t v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_66;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      BOOL v85 = v130;
      uint64_t v82 = v131;
      uint64_t v94 = v102;
      if (v106) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  char v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  BOOL v85 = v130;
  uint64_t v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  uint64_t v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_66;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  uint64_t v107 = v140;
  uint64_t v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  int64x2_t v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    uint64_t v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    uint64_t v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      uint16x8_t v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      int64_t v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    uint16x8_t v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  uint64x2_t v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  uint64_t v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v60 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFF8) {
      int v59 = (char)v138 >> 7;
    }
    else {
      int v59 = (char)v138 >> -(char)v124;
    }
  }
  else
  {
    uint64_t v60 = v139;
    if (v124 >= 8) {
      LOBYTE(v59) = 0;
    }
    else {
      int v59 = v138 << v124;
    }
  }
LABEL_60:
  *uint64_t v60 = v59;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int8(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v121 = a1;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v8;
  uint64_t v9 = *(char **)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v106 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v107 = (char *)&v106 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v114 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v113 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v108 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v115 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v119 = (char *)&v106 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v106 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v34 = v27(a3, a4);
    uint64x2_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v120(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v29 < 64)
      {
        (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
        if (v38 < -8) {
          goto LABEL_15;
        }
      }
      goto LABEL_16;
    }
    if (v29 <= 64)
    {
      uint64_t v116 = a4 + 64;
      uint16x8_t v118 = v27;
      char v39 = AssociatedTypeWitness;
      char v40 = v111;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v109;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      unint64_t v117 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      }
      else
      {
        uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        uint64_t v9 = v117;
        uint64_t v27 = v118;
        uint64_t v28 = v116;
        if (v44 >= -8) {
          goto LABEL_16;
        }
      }
LABEL_15:
      int v45 = (char)*v121 >> 7;
      goto LABEL_56;
    }
    goto LABEL_7;
  }
  uint64x2_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v120(a3, a4);
  if (v29 >= 64)
  {
LABEL_7:
    int64_t v123 = -8;
    uint64_t v35 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v35(&v123, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v37) {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v32 <= -9) {
    goto LABEL_15;
  }
LABEL_16:
  char v46 = v27(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v47 = v120(a3, a4);
  uint16x8_t v118 = v27;
  uint64_t v116 = v28;
  if (v46)
  {
    if (v47 > 64) {
      goto LABEL_18;
    }
  }
  else if (v47 >= 64)
  {
LABEL_18:
    int64_t v123 = 8;
    uint64_t v50 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
    v50(&v123, &type metadata for Int, v51, a3, a4);
    char v52 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    char v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v53(v26, a3);
    if (v52) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v53(v26, a3);
  if (v54 > 8)
  {
LABEL_22:
    LOBYTE(v45) = 0;
    goto LABEL_56;
  }
LABEL_23:
  uint64_t v55 = v26;
  unint64_t v117 = (char *)v53;
  uint64_t v56 = v9 + 16;
  char v57 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v58 = v119;
  v57(v119, a2, a3);
  char v59 = v118(a3, a4);
  uint64_t v60 = v115;
  char v61 = v58;
  BOOL v106 = v56;
  uint64_t v62 = (void (*)(char *, char *, uint64_t))v57;
  v57(v115, (uint64_t)v61, a3);
  if ((v59 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v117)(v60, a3);
    uint64_t v64 = v55;
    goto LABEL_40;
  }
  uint64_t v63 = v120(a3, a4);
  ((void (*)(char *, uint64_t))v117)(v60, a3);
  uint64_t v64 = v55;
  uint64_t v65 = v118;
  if (v63 <= 64) {
    goto LABEL_40;
  }
  uint64_t v66 = v108;
  v62(v108, v119, a3);
  int64_t v123 = 0x8000000000000000;
  if (v65(a3, a4))
  {
    uint64_t v67 = v120(a3, a4);
    if (v67 >= 64)
    {
LABEL_31:
      unint64_t v71 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v71(&v123, &type metadata for Int, v72, a3, a4);
      uint64_t v66 = v108;
      char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
      uint64_t v74 = v117;
      ((void (*)(char *, uint64_t))v117)(v64, a3);
      if (v73) {
        goto LABEL_61;
      }
      goto LABEL_39;
    }
LABEL_35:
    v62(v64, v66, a3);
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v74 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    if (v75 < v123) {
LABEL_61:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_39;
  }
  char v70 = v65(a3, a4);
  uint64_t v67 = v120(a3, a4);
  if ((v70 & 1) == 0)
  {
    if (v67 >= 64)
    {
      ((void (*)(char *, uint64_t))v117)(v66, a3);
      goto LABEL_40;
    }
    goto LABEL_35;
  }
  if (v67 > 64) {
    goto LABEL_31;
  }
  uint64_t v77 = AssociatedTypeWitness;
  uint64_t v76 = v111;
  uint64_t v78 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v79 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v78 + 8))(&qword_18162B0B8, 256, v77, v78);
  ((void (*)(char *, uint64_t, int **))v76[3])(v79, a3, v76);
  uint64_t v80 = v108;
  char v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
  uint64_t v82 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  int64_t v83 = v107;
  v62(v107, v80, a3);
  if (v81)
  {
    ((void (*)(char *, uint64_t))v82)(v83, a3);
    goto LABEL_61;
  }
  int64_t v84 = v123;
  uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v82)(v83, a3);
  BOOL v86 = v85 < v84;
  uint64_t v66 = v108;
  uint64_t v74 = v82;
  if (v86) {
    goto LABEL_61;
  }
LABEL_39:
  ((void (*)(char *, uint64_t))v74)(v66, a3);
LABEL_40:
  uint64_t v87 = v119;
  uint64_t v88 = v120;
  uint64_t v89 = v120(a3, a4);
  char v90 = v113;
  v62(v113, v87, a3);
  if (v89 < 65)
  {
    uint64_t v99 = v88(a3, a4);
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
    if (v99 != 64 || (v118(a3, a4) & 1) != 0) {
      goto LABEL_53;
    }
  }
  else
  {
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
  }
  v62(v91, v119, a3);
  int64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
  char v92 = v118(a3, a4);
  uint64_t v93 = v120(a3, a4);
  if ((v92 & 1) == 0)
  {
    if (v93 >= 64)
    {
      uint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
      uint64_t v98 = &v122;
      goto LABEL_51;
    }
LABEL_50:
    v62(v64, v91, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v100 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    ((void (*)(char *, uint64_t))v100)(v91, a3);
    goto LABEL_53;
  }
  if (v93 <= 64) {
    goto LABEL_50;
  }
  unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
  uint64_t v98 = &v123;
LABEL_51:
  v96(v98, &type metadata for Int, v97, a3, a4);
  char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v64, v91, a3);
  char v102 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  if (v101) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  ((void (*)(char *, uint64_t))v102)(v91, a3);
LABEL_53:
  unint64_t v103 = v119;
  unint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v117)(v103, a3);
  int v105 = *v121;
  if ((v104 & 0x8000000000000000) == 0)
  {
    if (v104 < 8)
    {
      int v45 = v105 << v104;
      goto LABEL_56;
    }
    goto LABEL_22;
  }
  if (v104 <= 0xFFFFFFFFFFFFFFF8) {
    int v45 = (char)v105 >> 7;
  }
  else {
    int v45 = (char)v105 >> -(char)v104;
  }
LABEL_56:
  unsigned char *v121 = v45;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int8(unsigned char *a1, unsigned char *a2, char *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int8(char *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int8(unsigned char *a1@<X8>)
{
  *a1 = (*v1 > 0) | (*v1 >> 7);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int8(uint64_t a1@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, uint64_t (*a4)(void *, uint64_t, uint64_t)@<X5>, unsigned char *a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    unsigned int v10 = a3();
    if ((v10 & 0x10000) != 0) {
      unsigned int v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    }
    unsigned int v11 = v10;
    swift_bridgeObjectRelease(a2);
    int v12 = (v11 >> 8) & 1;
    if (v12) {
      char v13 = 0;
    }
    else {
      char v13 = v11;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    char v13 = 0;
    LOBYTE(v12) = 1;
  }
  *a5 = v13;
  a5[1] = v12;
}

unsigned char *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  int v2 = (char)*result;
  if (v2 + (char)-*result) {
    __break(1u);
  }
  else {
    *a2 = -(char)v2;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int8()
{
  int v1 = (char)*v0;
  if (v1 + (char)-*v0) {
    __break(1u);
  }
  else {
    unsigned char *v0 = -(char)v1;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X8>)
{
  uint64_t v103 = a4;
  int64x2_t v110 = a5;
  uint64_t v99 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v97 = (char *)&v96 - v9;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  char v100 = (char *)&v96 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  char v101 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v96 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v108 = (char *)&v96 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  BOOL v106 = (char *)&v96 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v96 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v96 - v25;
  uint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v27 = v109(a2, a3);
  uint64_t v112 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v112(v26, a1, a2);
  uint64_t v107 = v17;
  BOOL v28 = (v27 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 8;
  uint64_t v102 = v10;
  uint64_t v29 = *(void (**)(char *, uint64_t))(v10 + 8);
  v29(v26, a2);
  v112(v24, a1, a2);
  uint64_t v113 = a1;
  uint64_t v111 = v29;
  uint64_t v105 = a3 + 64;
  if (!v28)
  {
    v29(v24, a2);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v32 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    goto LABEL_10;
  }
  char v114 = 0x80;
  uint64_t v30 = v109;
  if ((v109(a2, a3) & 1) == 0)
  {
    char v56 = v30(a2, a3);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    unint64_t v104 = (void (*)(char *, uint64_t, unint64_t, uint64_t, uint64_t))((a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000);
    uint64_t v57 = v31(a2, a3);
    if (v56)
    {
      if (v57 > 8)
      {
        uint64_t v60 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v61 = lazy protocol witness table accessor for type Int8 and conformance Int8(v57, v58, v59);
        uint64_t v62 = v31;
        uint64_t v63 = v106;
        v60(&v114, v103, v61, a2, a3);
        char v64 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v63, a2);
        uint64_t v65 = v63;
        uint64_t v31 = v62;
        char v37 = v111;
        v111(v65, a2);
        v37(v24, a2);
        uint64_t v38 = v110;
        uint64_t v32 = (uint64_t)v104;
        if (v64) {
          goto LABEL_39;
        }
        goto LABEL_10;
      }
      unint64_t v96 = v31;
      uint64_t v88 = AssociatedTypeWitness;
      uint64_t v87 = v99;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v90 = v97;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v88, AssociatedConformanceWitness);
      char v91 = v106;
      ((void (*)(char *, uint64_t, int **))v87[3])(v90, a2, v87);
      LOBYTE(v87) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v91, a2);
      char v37 = v111;
      v111(v91, a2);
      char v92 = v100;
      (*(void (**)(char *, char *, uint64_t))(v102 + 32))(v100, v24, a2);
      if (v87)
      {
        v37(v92, a2);
        uint64_t v38 = v110;
        goto LABEL_39;
      }
      int v93 = v114;
      char v94 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      char v37 = v111;
      char v95 = v94;
      v111(v92, a2);
      BOOL v79 = v93 <= v95;
      uint64_t v38 = v110;
      uint64_t v31 = v96;
    }
    else
    {
      if (v57 >= 8)
      {
        v111(v24, a2);
        uint64_t v32 = (uint64_t)v104;
        goto LABEL_10;
      }
      char v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      char v37 = v111;
      v111(v24, a2);
      BOOL v79 = v114 <= v78;
      uint64_t v38 = v110;
    }
    uint64_t v32 = (uint64_t)v104;
    if (v79) {
      goto LABEL_10;
    }
LABEL_39:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v37)(v113, a2);
    char v70 = 0;
    char v72 = 1;
    goto LABEL_40;
  }
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v32 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
  uint64_t v33 = v31(a2, a3);
  if (v33 >= 8)
  {
    unint64_t v104 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v73 = lazy protocol witness table accessor for type Int8 and conformance Int8(v33, v34, v35);
    uint64_t v74 = v31;
    uint64_t v75 = v106;
    v104(&v114, v103, v73, a2, a3);
    char v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v75, a2);
    uint64_t v77 = v75;
    uint64_t v31 = v74;
    char v37 = v111;
    v111(v77, a2);
    v37(v24, a2);
    uint64_t v38 = v110;
    if (v76) {
      goto LABEL_39;
    }
  }
  else
  {
    char v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    char v37 = v111;
    v111(v24, a2);
    uint64_t v38 = v110;
    if (v114 > v36) {
      goto LABEL_39;
    }
  }
LABEL_10:
  uint64_t v39 = v113;
  uint64_t v40 = v31(a2, a3);
  uint64_t v41 = v31;
  uint64_t v42 = v108;
  uint64_t v43 = v112;
  v112(v108, v39, a2);
  if (v40 >= 9)
  {
    unint64_t v104 = (void (*)(char *, uint64_t, unint64_t, uint64_t, uint64_t))v32;
    v111(v42, a2);
    uint64_t v44 = v107;
    v43(v107, v39, a2);
    uint64_t v38 = v110;
    goto LABEL_14;
  }
  uint64_t v45 = v41(a2, a3);
  v111(v42, a2);
  if (v45 != 8)
  {
    uint64_t v44 = v107;
    v112(v107, v113, a2);
    uint64_t v38 = v110;
    goto LABEL_24;
  }
  unint64_t v104 = (void (*)(char *, uint64_t, unint64_t, uint64_t, uint64_t))v32;
  char v46 = v109(a2, a3);
  uint64_t v44 = v107;
  v112(v107, v113, a2);
  uint64_t v38 = v110;
  if (v46)
  {
LABEL_24:
    uint64_t v67 = v44;
    goto LABEL_25;
  }
LABEL_14:
  v116[0] = 127;
  char v47 = v109(a2, a3);
  uint64_t v48 = v41(a2, a3);
  if (v47)
  {
    if (v48 > 8)
    {
      unint64_t v51 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int8 and conformance Int8(v48, v49, v50);
      char v53 = v106;
      v51(v116, v103, v52, a2, a3);
      char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v53, v44, a2);
      char v37 = v111;
      v111(v53, a2);
      uint64_t v55 = v44;
      goto LABEL_33;
    }
    goto LABEL_22;
  }
  if (v48 <= 7)
  {
LABEL_22:
    uint64_t v66 = v106;
    (*(void (**)(char *, char *, uint64_t))(v102 + 32))(v106, v44, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v67 = v66;
LABEL_25:
    char v37 = v111;
    v111(v67, a2);
    goto LABEL_26;
  }
  char v115 = 127;
  uint64_t v80 = v106;
  uint64_t v81 = (*(uint64_t (**)(char *, char *, uint64_t))(v102 + 32))(v106, v44, a2);
  uint64_t v82 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v85 = lazy protocol witness table accessor for type Int8 and conformance Int8(v81, v83, v84);
  BOOL v86 = v101;
  v82(&v115, v103, v85, a2, a3);
  char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v86, v80, a2);
  char v37 = v111;
  v111(v86, a2);
  uint64_t v55 = v80;
LABEL_33:
  v37(v55, a2);
  if (v54) {
    goto LABEL_39;
  }
LABEL_26:
  uint64_t v68 = (uint64_t (*)(uint64_t, uint64_t))v37;
  uint64_t v69 = v113;
  char v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = v68(v69, a2);
  char v72 = 0;
LABEL_40:
  *uint64_t v38 = v70;
  v38[1] = v72;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int8(unsigned char *a1@<X8>)
{
  int v2 = *v1;
  if (v2 < 0) {
    int v2 = -v2;
  }
  *a1 = v2;
}

unsigned char *protocol witness for static Numeric.* infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  int v3 = (char)*result * (char)*a2;
  if ((char)(*result * *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int8.* infix(_:_:)(char a1, char a2)
{
  uint64_t result = (a1 * a2);
  if ((char)(a1 * a2) != result) {
    __break(1u);
  }
  return result;
}

unsigned char *protocol witness for static Numeric.*= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  int v2 = (char)*result * (char)*a2;
  if ((char)(*result * *a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int8()
{
  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

unsigned __int8 *protocol witness for Strideable.distance(to:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  int v3 = *result;
  int v4 = (char)*v2;
  if (((v4 ^ v3) & 0x80) == 0)
  {
    int v5 = (char)v3 - v4;
    if ((char)v5 == v5)
    {
      *a2 = (char)v5;
      return result;
    }
    __break(1u);
    goto LABEL_15;
  }
  if (v4 >= 0) {
    LOBYTE(v6) = *v2;
  }
  else {
    int v6 = -v4;
  }
  if ((v3 & 0x80u) != 0) {
    int v3 = -(char)v3;
  }
  unsigned int v7 = v6 + v3;
  if ((v7 >> 8))
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v4 < 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = -(uint64_t)v7;
  }
  *a2 = v8;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int8@<X0>(void *result@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  if (v4 <= -129) {
    goto LABEL_6;
  }
  if (v4 >= 128) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int8(uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

unsigned char *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  int v3 = (char)*result + (char)*a2;
  if ((char)(*result + *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

unsigned char *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  int v2 = (char)*result + (char)*a2;
  if ((char)(*result + *a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

unsigned char *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int8@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, unsigned char *a3@<X8>)
{
  int v3 = (char)*result - (char)*a2;
  if ((char)(*result - *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int8.- infix(_:_:)(char a1, char a2)
{
  uint64_t result = (a1 - a2);
  if ((char)result != result) {
    __break(1u);
  }
  return result;
}

unsigned char *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int8(unsigned char *result, unsigned char *a2)
{
  int v2 = (char)*result - (char)*a2;
  if ((char)(*result - *a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a2 >= *a1;
}

BOOL static Int8.<= infix(_:_:)(char a1, char a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a2 < *a1;
}

void Int8.hash(into:)(int a1, Swift::UInt8 a2)
{
}

Swift::Int __swiftcall Int8._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 1);
}

uint64_t Int8.hashValue.getter(unsigned __int8 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int8(uint64_t a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 1);
}

uint64_t Int8._toCustomAnyHashable()@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int8>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(unsigned char *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int8@<X0>(uint64_t a1@<X8>)
{
  char v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int8>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(unsigned char *)a1 = v3;
  return result;
}

uint64_t UInt16._value.setter(uint64_t result)
{
  *unsigned __int8 v1 = result;
  return result;
}

uint64_t (*UInt16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt16 because it is either infinite or NaN", 80, 2, "Swift/IntegerTypes.swift", 24, 2, 0xC57uLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt16 because the result would be less than UInt16.min", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0xC5AuLL, 0);
  }
  return (int)*(short float *)&a1;
}

uint64_t UInt16.init(exactly:)(float a1)
{
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0)))
  {
    int v3 = 0;
    int v2 = 1;
  }
  else
  {
    BOOL v1 = truncl(*(short float *)&a1) != *(short float *)&a1;
    int v2 = (~LODWORD(a1) & 0x7C00) == 0 || v1;
    int v3 = (int)*(short float *)&a1;
    if (v2) {
      int v3 = 0;
    }
  }
  return v3 | (v2 << 16);
}

Swift::UInt16 __swiftcall UInt16.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt16 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCA5uLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt16 because the result would be less than UInt16.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCA8uLL, 0);
  }
  if (a1 >= 65536.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt16 because the result would be greater than UInt16.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCABuLL, 0);
  }
  return (int)a1;
}

Swift::UInt16_optional __swiftcall UInt16.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 65536.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

Swift::UInt16 __swiftcall UInt16.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt16 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCEDuLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt16 because the result would be less than UInt16.min", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCF0uLL, 0);
  }
  if (a1 >= 65536.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt16 because the result would be greater than UInt16.max", 94, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCF3uLL, 0);
  }
  return (int)a1;
}

Swift::UInt16_optional __swiftcall UInt16.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 65536.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

_WORD *static UInt16.+= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  int v2 = (unsigned __int16)*result + a2;
  if ((v2 & 0x10000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

_WORD *static UInt16.-= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  int v2 = (unsigned __int16)*result - a2;
  if ((v2 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

_WORD *static UInt16.*= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if ((((unsigned __int16)*result * a2) & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *result *= a2;
  }
  return result;
}

_WORD *static UInt16./= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.addingReportingOverflow(_:)(Swift::UInt16 a1)
{
  Swift::UInt16 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.subtractingReportingOverflow(_:)(Swift::UInt16 a1)
{
  Swift::UInt16 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.multipliedReportingOverflow(by:)(Swift::UInt16 by)
{
  Swift::UInt16 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.dividedReportingOverflow(by:)(Swift::UInt16 by)
{
  if (by) {
    v1 /= by;
  }
  Swift::UInt16 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.remainderReportingOverflow(dividingBy:)(Swift::UInt16 dividingBy)
{
  if (dividingBy) {
    v1 %= dividingBy;
  }
  Swift::UInt16 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

_WORD *static UInt16.%= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  }
  *result %= a2;
  return result;
}

uint64_t UInt16._lowWord.getter(uint64_t result)
{
  return (unsigned __int16)result;
}

uint64_t UInt16.Words._value.setter(uint64_t result)
{
  *unsigned __int16 v1 = result;
  return result;
}

uint64_t (*UInt16.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.Words.count.getter()
{
  return 1;
}

uint64_t UInt16.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt16.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt16.Words.indices.getter()
{
  return 0;
}

uint64_t UInt16.Words.subscript.getter(uint64_t a1, unsigned __int16 a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0xFB2uLL, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0xFB3uLL, 0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt16.Words(uint64_t *a1, uint64_t *a2))()
{
  *a1 = UInt16.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt16.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt16.Words(uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt16_low_UInt16 __swiftcall UInt16.multipliedFullWidth(by:)(Swift::UInt16 by)
{
  Swift::UInt16 v2 = (v1 * by) >> 16;
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt16_remainder_UInt16 __swiftcall UInt16.dividingFullWidth(_:)(Swift::tuple_high_UInt16_low_UInt16 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1018uLL, 0);
  }
  if (a1.high >= v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x101AuLL, 0);
  }
  unsigned int v2 = a1.low | (a1.high << 16);
  Swift::UInt16 v3 = v2 / v1;
  result.remainder = v2;
  result.quotient = v3;
  return result;
}

BOOL static UInt16.> infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a2 < a1;
}

Swift::UInt16 __swiftcall UInt16.signum()()
{
  return v0 != 0;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt16()
{
  return 16;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = -1;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt16(_WORD *a1, _WORD *a2)
{
  uint64_t v3 = ((unsigned __int16)*v2 + (unsigned __int16)*a2) >> 16;
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt16(_WORD *a1, unsigned __int16 *a2)
{
  int v3 = *v2 - *a2;
  *a1 = v3;
  return (v3 & 0xFFFF0000) != 0;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt16(_WORD *a1, unsigned __int16 *a2)
{
  int v3 = *v2 * *a2;
  *a1 = v3;
  return (v3 & 0xFFFF0000) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt16(_WORD *a1, _WORD *a2)
{
  unsigned int v3 = (unsigned __int16)*a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt16(_WORD *a1, _WORD *a2)
{
  unsigned int v3 = (unsigned __int16)*a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

_WORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt16(_WORD *result, _WORD *a2, unsigned __int16 *a3)
{
  int v4 = *v3 * *a3;
  *Swift::tuple_quotient_UInt16_remainder_UInt16 result = HIWORD(v4);
  *a2 = v4;
  return result;
}

Swift::UInt16 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt16(Swift::UInt16 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  Swift::UInt16 result = UInt16.dividingFullWidth(_:)((Swift::tuple_high_UInt16_low_UInt16)__PAIR32__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

unsigned __int16 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result >> (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt16(_WORD *result, _WORD *a2)
{
  *Swift::UInt16 result = (unsigned __int16)*result >> (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt16@<X0>(_WORD *result@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  if (a2 >> 9 <= 8 && (a2 & 1) == 0) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16 and conformance UInt16, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  uint64_t v53 = a4;
  uint64_t v54 = a5;
  uint64_t v57 = *(int ***)(*(void *)(a3 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v57, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v49 - v11;
  uint64_t v61 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v52 = (char *)&v49 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v60 = (char *)&v49 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v49 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v49 - v19;
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v22 = v21(a2, a3);
  uint64_t v58 = a1;
  uint64_t v59 = a6;
  if (v22)
  {
    uint64_t v23 = v61;
    (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v20, a1, a2);
    uint64_t v25 = AssociatedTypeWitness;
    uint64_t v24 = v57;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    char v27 = v55;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v25, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v24[3])(v27, a2, v24);
    LOBYTE(v25) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 32))(v20, v18, a2);
    BOOL v28 = *(void (**)(char *, uint64_t))(v23 + 8);
    v28(v18, a2);
    if ((v25 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    v28(v20, a2);
    a1 = v58;
  }
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v29(a2, a3) >= 16)
  {
    unint64_t v51 = v18;
    uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v61 + 16);
    v50(v60, a1, a2);
    unsigned __int16 v62 = -1;
    char v30 = v21(a2, a3);
    uint64_t v31 = v29(a2, a3);
    if (v30)
    {
      uint64_t v32 = v51;
      if (v31 < 17)
      {
        char v36 = AssociatedTypeWitness;
        char v37 = v57;
        uint64_t v38 = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v39 = v55;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v38 + 8))(&qword_18162B0B8, 256, v36, v38);
        ((void (*)(char *, uint64_t, int **))v37[3])(v39, a2, v37);
        uint64_t v40 = v60;
        LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 40))(v60, v32, a2);
        uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v32, a2);
        unsigned int v41 = v62;
        uint64_t v42 = v52;
        v50(v52, (uint64_t)v40, a2);
        if (v36)
        {
          unsigned __int16 v43 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v34(v42, a2);
          if (v41 < v43) {
LABEL_20:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          v34(v42, a2);
        }
        goto LABEL_16;
      }
      (*(void (**)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v32, v60, a2);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v32, a2);
    }
    else
    {
      uint64_t v35 = v51;
      if (v31 <= 16)
      {
        v50(v51, (uint64_t)v60, a2);
        unsigned __int16 v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v35, a2);
        if (v62 < v44) {
          goto LABEL_20;
        }
LABEL_16:
        v34(v60, a2);
        a1 = v58;
        goto LABEL_17;
      }
      (*(void (**)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v35, v60, a2);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v35, a2);
    }
    if (v33) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
LABEL_17:
  __int16 v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v46 = a1;
  __int16 v47 = v45;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v61 + 8))(v46, a2);
  *uint64_t v59 = v47;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt16()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt16()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_WORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  }
  *a3 = *result / *a2;
  return result;
}

uint64_t static UInt16./ infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  }
  return a1 / a2;
}

_WORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt16(_WORD *result, _WORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  }
  *result /= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  }
  *a3 = *result % *a2;
  return result;
}

uint64_t static UInt16.% infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  }
  return a1 % a2;
}

_WORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt16(_WORD *result, _WORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt16.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt16@<X0>(unsigned __int16 *a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v5 = a4;
  uint64_t v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint32x4_t v139 = (char *)&v133 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v133 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  int8x16_t v136 = (char *)&v133 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v144 = (char *)&v133 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v133 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v137 = (char *)&v133 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v145 = (char *)&v133 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  int64x2_t v149 = (char *)&v133 - v28;
  MEMORY[0x1F4188790](v27);
  int64x2_t v151 = (char *)&v133 - v29;
  unsigned int v143 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v150 = v5 + 64;
  char v31 = v30(a3, v5);
  uint64_t v147 = a5;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v33 = v32(a3, v5);
    if (v33 >= 64)
    {
      v153[0] = -16;
      uint64_t v49 = v151;
      int8x16_t v148 = v32;
      uint64_t v50 = v22;
      unint64_t v51 = v30;
      uint64_t v52 = v12;
      uint64_t v53 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v53(v153, &type metadata for Int, v54, a3, v5);
      uint64_t v12 = v52;
      char v30 = v51;
      char v22 = v50;
      uint64_t v32 = v148;
      char v55 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                            + 16))(a2, v49, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v49, a3);
      if (v55) {
        goto LABEL_28;
      }
    }
    else
    {
      char v36 = v151;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 < -16) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v30(a3, v5);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    int8x16_t v148 = v40;
    uint64_t v41 = v40(a3, v5);
    if (v39)
    {
      uint64_t v142 = v30;
      if (v41 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        unsigned __int16 v62 = v151;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a3, v59);
        uint64_t v63 = v138;
        LOBYTE(v58) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v138, v62, a3);
        char v64 = *(void (**)(char *, uint64_t))(v12 + 8);
        v64(v62, a3);
        uint64_t v133 = v12;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v15, v63, a3);
        if (v58)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
          goto LABEL_28;
        }
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
        uint64_t v12 = v133;
        char v30 = v142;
        uint64_t v32 = v148;
        a2 = v138;
        if (v65 < -16) {
          goto LABEL_28;
        }
      }
      else
      {
        v153[0] = -16;
        uint64_t v44 = v12;
        __int16 v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        __int16 v47 = v151;
        v45(v153, &type metadata for Int, v46, a3, v5);
        uint64_t v12 = v44;
        a2 = v138;
        char v48 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                              + 16))(v138, v47, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v47, a3);
        char v30 = v142;
        uint64_t v32 = v148;
        if (v48) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v32 = v148;
      a2 = v138;
    }
    else
    {
      char v56 = v151;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, v138, a3);
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v56, a3);
      uint64_t v32 = v148;
      if (v57 < -16) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v30;
  char v66 = v30(a3, v5);
  uint64_t v67 = (char *)a2;
  uint64_t v68 = v32(a3, v5);
  uint64x2_t v134 = v22;
  if (v66)
  {
    if (v68 > 64) {
      goto LABEL_20;
    }
  }
  else if (v68 > 63)
  {
LABEL_20:
    v153[0] = 16;
    unint64_t v71 = v151;
    uint64_t v72 = v12;
    unint64_t v73 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    v73(v153, &type metadata for Int, v74, a3, v5);
    uint64_t v12 = v72;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v71, v67, a3);
    int v138 = *(void (**)(void, void))(v72 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v71, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  int v93 = v151;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
  uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  int v138 = *(void (**)(void, void))(v12 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v93, a3);
  if (v94 <= 16)
  {
LABEL_21:
    int8x16_t v148 = v32;
    uint64_t v76 = v12;
    uint64_t v77 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    char v78 = v149;
    v77(v149, v67, a3);
    BOOL v79 = v142;
    char v80 = v142(a3, v5);
    uint64_t v81 = v145;
    unsigned int v135 = v77;
    v77(v145, v78, a3);
    uint64_t v133 = v12;
    if ((v80 & 1) == 0)
    {
      v138(v81, a3);
      uint64_t v87 = v79;
      uint64_t v88 = v148;
      goto LABEL_41;
    }
    uint64_t v82 = v5;
    uint64_t v83 = v5;
    uint64_t v84 = v148;
    uint64_t v85 = v148(a3, v82);
    v138(v81, a3);
    BOOL v86 = v84;
    uint64_t v5 = v83;
    uint64_t v87 = v79;
    uint64_t v88 = v86;
    if (v85 <= 64) {
      goto LABEL_41;
    }
    uint64_t v145 = (char *)(v76 + 8);
    uint64_t v89 = v137;
    v135(v137, v149, a3);
    v153[0] = 0x8000000000000000;
    if (v87(a3, v83))
    {
      uint64_t v90 = v88(a3, v83);
      if (v90 < 64)
      {
LABEL_36:
        uint64_t v105 = v151;
        v135(v151, v89, a3);
        uint64_t v106 = (*(uint64_t (**)(uint64_t, uint64_t))(v83 + 120))(a3, v83);
        unint64_t v104 = (void (*)(char *, uint64_t))v138;
        v138(v105, a3);
        if (v106 < v153[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v97 = v87(a3, v83);
      uint64_t v90 = v88(a3, v83);
      if ((v97 & 1) == 0)
      {
        if (v90 >= 64)
        {
          v138(v89, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v90 <= 64)
      {
        uint64_t v108 = AssociatedTypeWitness;
        uint64_t v107 = v141;
        uint64_t v109 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        int64x2_t v110 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v109 + 8))(&qword_18162B0B8, 256, v108, v109);
        uint64_t v111 = v151;
        ((void (*)(char *, uint64_t, int **))v107[3])(v110, a3, v107);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                           + 16))(v89, v111, a3);
        unint64_t v104 = (void (*)(char *, uint64_t))v138;
        v138(v111, a3);
        uint64_t v112 = v136;
        v135(v136, v89, a3);
        if (v141)
        {
          v104(v112, a3);
          goto LABEL_63;
        }
        uint64_t v141 = (int **)v153[0];
        uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v104(v112, a3);
        BOOL v114 = v113 < (uint64_t)v141;
        uint64_t v88 = v148;
        if (v114) {
          goto LABEL_63;
        }
LABEL_40:
        v104(v89, a3);
LABEL_41:
        char v115 = v149;
        uint64_t v116 = v88(a3, v5);
        unint64_t v117 = v134;
        v135(v134, v115, a3);
        if (v116 < 65)
        {
          uint64_t v127 = v88(a3, v5);
          uint16x8_t v118 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v117, a3);
          uint64_t v119 = v144;
          if (v127 != 64 || (v87(a3, v5) & 1) != 0)
          {
LABEL_54:
            uint64_t v131 = v149;
            unint64_t v132 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
            uint64_t result = v118(v131, a3);
            if ((v132 & 0x8000000000000000) != 0)
            {
              unint64_t v96 = v147;
              if (v132 > 0xFFFFFFFFFFFFFFF0)
              {
                unsigned int v95 = v143 << -(char)v132;
                goto LABEL_57;
              }
            }
            else
            {
              unint64_t v96 = v147;
              if (v132 < 0x10)
              {
                unsigned int v95 = v143 >> v132;
                goto LABEL_57;
              }
            }
            LOWORD(v95) = 0;
            goto LABEL_57;
          }
        }
        else
        {
          uint16x8_t v118 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v117, a3);
          uint64_t v119 = v144;
        }
        v135(v119, v149, a3);
        v153[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v120 = v87(a3, v5);
        uint64_t v121 = v88(a3, v5);
        if (v120)
        {
          if (v121 > 64)
          {
            unint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
            unint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v121, v122, v123);
            uint16x8_t v126 = v153;
            goto LABEL_52;
          }
        }
        else if (v121 > 63)
        {
          uint64_t v152 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
          unint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v121, v122, v123);
          uint16x8_t v126 = &v152;
LABEL_52:
          int8x16_t v129 = v151;
          v124(v126, &type metadata for Int, v125, a3, v5);
          char v130 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v129, v119, a3);
          v118(v129, a3);
          if (v130) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        uint64_t v128 = v151;
        v135(v151, v119, a3);
        (*(void (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v118(v128, a3);
LABEL_53:
        v118(v119, a3);
        goto LABEL_54;
      }
    }
    uint64_t v98 = v151;
    uint64_t v99 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v83 + 96);
    unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
    v99(v153, &type metadata for Int, v100, a3, v5);
    char v101 = v98;
    uint64_t v89 = v137;
    uint64_t v88 = v148;
    char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v137, v101, a3);
    uint64_t v103 = v101;
    unint64_t v104 = (void (*)(char *, uint64_t))v138;
    v138(v103, a3);
    if (v102) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  LOWORD(v95) = 0;
  unint64_t v96 = v147;
LABEL_57:
  _WORD *v96 = v95;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt16(unsigned __int16 *a1, void (*a2)(void, void), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint32x4_t v139 = (char *)&v132 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v132 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  int8x16_t v136 = (char *)&v132 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unsigned int v143 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v132 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v137 = (char *)&v132 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v144 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v148 = (char *)&v132 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  uint64_t v149 = v4 + 64;
  char v29 = v28(a3, v4);
  uint64_t v146 = a1;
  if (v29)
  {
    char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v31 = v30(a3, v4);
    if (v31 >= 64)
    {
      v152[0] = -16;
      __int16 v47 = v150;
      uint64_t v147 = v30;
      char v48 = v20;
      uint64_t v49 = v28;
      uint64_t v50 = v10;
      unint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v51(v152, &type metadata for Int, v52, a3, v4);
      uint64_t v10 = v50;
      uint64_t v28 = v49;
      uint64_t v20 = v48;
      char v30 = v147;
      char v53 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                            + 16))(a2, v47, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v47, a3);
      if (v53) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v34 = v150;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v34, a3);
      if (v35 < -16) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v37 = v28(a3, v4);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    uint64_t v147 = v38;
    uint64_t v39 = v38(a3, v4);
    if (v37)
    {
      uint64_t v142 = v28;
      if (v39 <= 64)
      {
        char v56 = AssociatedTypeWitness;
        uint64_t v57 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v59 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        uint64_t v60 = v150;
        ((void (*)(char *, uint64_t, int **))v57[3])(v59, a3, v57);
        uint64_t v61 = v138;
        LOBYTE(v56) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v138, v60, a3);
        unsigned __int16 v62 = *(void (**)(char *, uint64_t))(v10 + 8);
        v62(v60, a3);
        uint64_t v133 = v10;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v13, v61, a3);
        if (v56)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
          goto LABEL_28;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
        uint64_t v10 = v133;
        uint64_t v28 = v142;
        char v30 = v147;
        a2 = v138;
        if (v63 < -16) {
          goto LABEL_28;
        }
      }
      else
      {
        v152[0] = -16;
        uint64_t v42 = v10;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        __int16 v45 = v150;
        v43(v152, &type metadata for Int, v44, a3, v4);
        uint64_t v10 = v42;
        a2 = v138;
        char v46 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                              + 16))(v138, v45, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v45, a3);
        uint64_t v28 = v142;
        char v30 = v147;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v39 >= 64)
    {
      char v30 = v147;
      a2 = v138;
    }
    else
    {
      unint64_t v54 = v150;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, v138, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v54, a3);
      char v30 = v147;
      if (v55 < -16) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v28;
  char v64 = v28(a3, v4);
  uint64_t v65 = (char *)a2;
  uint64_t v66 = v30(a3, v4);
  uint64x2_t v134 = v20;
  if (v64)
  {
    if (v66 > 64) {
      goto LABEL_20;
    }
  }
  else if (v66 >= 64)
  {
LABEL_20:
    v152[0] = 16;
    uint64_t v69 = v150;
    uint64_t v70 = v10;
    unint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v152, &type metadata for Int, v72, a3, v4);
    uint64_t v10 = v70;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v69, v65, a3);
    int v138 = *(void (**)(void, void))(v70 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v69, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  uint64_t v91 = v150;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  int v138 = *(void (**)(void, void))(v10 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 <= 16)
  {
LABEL_21:
    uint64_t v147 = v30;
    uint64_t v74 = v10;
    char v75 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
    uint64_t v76 = v148;
    v75(v148, v65, a3);
    uint64_t v77 = v142;
    char v78 = v142(a3, v4);
    BOOL v79 = v144;
    unsigned int v135 = v75;
    v75(v144, v76, a3);
    uint64_t v133 = v10;
    if ((v78 & 1) == 0)
    {
      v138(v79, a3);
      uint64_t v85 = v77;
      BOOL v86 = v147;
      goto LABEL_41;
    }
    uint64_t v80 = v4;
    uint64_t v81 = v4;
    uint64_t v82 = v147;
    uint64_t v83 = v147(a3, v80);
    v138(v79, a3);
    uint64_t v84 = v82;
    uint64_t v4 = v81;
    uint64_t v85 = v77;
    BOOL v86 = v84;
    if (v83 <= 64) {
      goto LABEL_41;
    }
    uint64_t v144 = (char *)(v74 + 8);
    uint64_t v87 = v137;
    v135(v137, v148, a3);
    v152[0] = 0x8000000000000000;
    if (v85(a3, v81))
    {
      uint64_t v88 = v86(a3, v81);
      if (v88 < 64)
      {
LABEL_36:
        uint64_t v103 = v150;
        v135(v150, v87, a3);
        uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 120))(a3, v81);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v103, a3);
        if (v104 < v152[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v95 = v85(a3, v81);
      uint64_t v88 = v86(a3, v81);
      if ((v95 & 1) == 0)
      {
        if (v88 >= 64)
        {
          v138(v87, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v88 <= 64)
      {
        uint64_t v106 = AssociatedTypeWitness;
        uint64_t v105 = v141;
        uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v108 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
        uint64_t v109 = v150;
        ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                           + 16))(v87, v109, a3);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v109, a3);
        int64x2_t v110 = v136;
        v135(v136, v87, a3);
        if (v141)
        {
          v102(v110, a3);
          goto LABEL_63;
        }
        uint64_t v141 = (int **)v152[0];
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v102(v110, a3);
        BOOL v112 = v111 < (uint64_t)v141;
        BOOL v86 = v147;
        if (v112) {
          goto LABEL_63;
        }
LABEL_40:
        v102(v87, a3);
LABEL_41:
        uint64_t v113 = v148;
        uint64_t v114 = v86(a3, v4);
        char v115 = v134;
        v135(v134, v113, a3);
        if (v114 < 65)
        {
          uint64_t v125 = v86(a3, v4);
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
          if (v125 != 64 || (v85(a3, v4) & 1) != 0)
          {
LABEL_54:
            int8x16_t v129 = v148;
            unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
            uint64_t result = v116(v129, a3);
            uint64_t v94 = v146;
            unsigned int v131 = *v146;
            if ((v130 & 0x8000000000000000) != 0)
            {
              if (v130 >= 0xFFFFFFFFFFFFFFF1)
              {
                unsigned int v93 = v131 << -(char)v130;
                goto LABEL_57;
              }
            }
            else if (v130 < 0x10)
            {
              unsigned int v93 = v131 >> v130;
              goto LABEL_57;
            }
            LOWORD(v93) = 0;
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
        }
        v135(v117, v148, a3);
        v152[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v118 = v85(a3, v4);
        uint64_t v119 = v86(a3, v4);
        if (v118)
        {
          if (v119 > 64)
          {
            uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
            unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
            unint64_t v124 = v152;
            goto LABEL_52;
          }
        }
        else if (v119 >= 64)
        {
          uint64_t v151 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
          unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
          unint64_t v124 = &v151;
LABEL_52:
          uint64_t v127 = v150;
          v122(v124, &type metadata for Int, v123, a3, v4);
          char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v127, v117, a3);
          v116(v127, a3);
          if (v128) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        uint16x8_t v126 = v150;
        v135(v150, v117, a3);
        (*(void (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v116(v126, a3);
LABEL_53:
        v116(v117, a3);
        goto LABEL_54;
      }
    }
    unint64_t v96 = v150;
    char v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v81 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v152, &type metadata for Int, v98, a3, v4);
    uint64_t v99 = v96;
    uint64_t v87 = v137;
    BOOL v86 = v147;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  LOWORD(v93) = 0;
  uint64_t v94 = v146;
LABEL_57:
  *uint64_t v94 = v93;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt16@<X0>(unsigned __int16 *a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v5 = a4;
  uint64_t v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint32x4_t v139 = (char *)&v132 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v132 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  int8x16_t v136 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v144 = (char *)&v132 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v132 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  uint64_t v137 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v145 = (char *)&v132 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v152 = (char *)&v132 - v29;
  unsigned int v143 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v151 = v5 + 64;
  char v31 = v30(a3, v5);
  int8x16_t v148 = a5;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v147 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v33 = v32(a3, v5);
    if (v33 >= 64)
    {
      v154[0] = -16;
      uint64_t v49 = v152;
      uint64_t v149 = v32;
      uint64_t v146 = v22;
      uint64_t v50 = v30;
      uint64_t v51 = v12;
      unint64_t v52 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v53 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v52(v154, &type metadata for Int, v53, a3, v5);
      uint64_t v12 = v51;
      char v30 = v50;
      uint64_t v22 = v146;
      uint64_t v32 = v149;
      char v54 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                            + 16))(a2, v49, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v49, a3);
      if (v54) {
        goto LABEL_28;
      }
    }
    else
    {
      char v36 = v152;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v152, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 < -16) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v30(a3, v5);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v147 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    uint64_t v149 = v40;
    uint64_t v41 = v40(a3, v5);
    if (v39)
    {
      uint64_t v142 = v30;
      if (v41 <= 64)
      {
        uint64_t v57 = AssociatedTypeWitness;
        uint64_t v58 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v60 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v57, AssociatedConformanceWitness);
        uint64_t v61 = v152;
        ((void (*)(char *, uint64_t, int **))v58[3])(v60, a3, v58);
        unsigned __int16 v62 = v138;
        LOBYTE(v57) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v138, v61, a3);
        uint64_t v63 = *(void (**)(char *, uint64_t))(v12 + 8);
        v63(v61, a3);
        uint64_t v133 = v12;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v15, v62, a3);
        if (v57)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v63)(v15, a3);
          goto LABEL_28;
        }
        uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v63)(v15, a3);
        uint64_t v12 = v133;
        char v30 = v142;
        uint64_t v32 = v149;
        a2 = v138;
        if (v64 < -16) {
          goto LABEL_28;
        }
      }
      else
      {
        v154[0] = -16;
        uint64_t v44 = v12;
        __int16 v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        __int16 v47 = v152;
        v45(v154, &type metadata for Int, v46, a3, v5);
        uint64_t v12 = v44;
        a2 = v138;
        char v48 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                              + 16))(v138, v47, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v47, a3);
        char v30 = v142;
        uint64_t v32 = v149;
        if (v48) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v32 = v149;
      a2 = v138;
    }
    else
    {
      uint64_t v55 = v152;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v152, v138, a3);
      uint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v55, a3);
      uint64_t v32 = v149;
      if (v56 < -16) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v30;
  char v65 = v30(a3, v5);
  uint64_t v66 = a2;
  uint64_t v67 = v32(a3, v5);
  uint64_t v146 = v22;
  if (v65)
  {
    if (v67 > 64) {
      goto LABEL_20;
    }
  }
  else if (v67 > 63)
  {
LABEL_20:
    v154[0] = 16;
    uint64_t v70 = v152;
    uint64_t v71 = v12;
    unint64_t v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
    v72(v154, &type metadata for Int, v73, a3, v5);
    uint64_t v12 = v71;
    a2 = v66;
    char v74 = (*(uint64_t (**)(char *, void (*)(void, void), uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                          + 16))(v70, v66, a3);
    int v138 = *(void (**)(void, void))(v12 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v70, a3);
    if ((v74 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  uint64_t v91 = v152;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v152, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  int v138 = *(void (**)(void, void))(v12 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 <= 16)
  {
LABEL_21:
    uint64_t v149 = v32;
    uint64_t v75 = v12;
    uint64_t v76 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    uint64_t v77 = v150;
    v76(v150, (char *)a2, a3);
    char v78 = v142;
    char v79 = v142(a3, v5);
    uint64_t v80 = v145;
    uint64x2_t v134 = v76;
    uint64_t v135 = v12 + 16;
    v76(v145, v77, a3);
    uint64_t v133 = v12;
    if ((v79 & 1) == 0)
    {
      v138(v80, a3);
      uint64_t v85 = v149;
      BOOL v86 = v78;
      goto LABEL_43;
    }
    uint64_t v81 = v5;
    uint64_t v82 = v5;
    uint64_t v83 = v149;
    uint64_t v84 = v149(a3, v81);
    uint64_t v145 = (char *)(v75 + 8);
    v138(v80, a3);
    uint64_t v85 = v83;
    uint64_t v5 = v82;
    BOOL v86 = v78;
    if (v84 <= 64) {
      goto LABEL_43;
    }
    uint64_t v87 = v137;
    v134(v137, v150, a3);
    v154[0] = 0x8000000000000000;
    if (v78(a3, v82))
    {
      uint64_t v88 = v85(a3, v82);
      if (v88 < 64)
      {
LABEL_36:
        uint64_t v103 = v152;
        v134(v152, v87, a3);
        uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v82 + 120))(a3, v82);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v103, a3);
        if (v104 < v154[0]) {
          goto LABEL_65;
        }
        goto LABEL_42;
      }
    }
    else
    {
      char v95 = v78(a3, v82);
      uint64_t v88 = v85(a3, v82);
      if ((v95 & 1) == 0)
      {
        if (v88 >= 64)
        {
          v138(v87, a3);
          goto LABEL_43;
        }
        goto LABEL_36;
      }
      if (v88 <= 64)
      {
        uint64_t v106 = AssociatedTypeWitness;
        uint64_t v105 = v141;
        uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v108 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
        uint64_t v109 = v152;
        ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
        LOBYTE(v105) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                          + 16))(v87, v109, a3);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v109, a3);
        int64x2_t v110 = v136;
        v134(v136, v87, a3);
        if (v105)
        {
          v102(v110, a3);
          goto LABEL_65;
        }
        uint64_t v111 = v154[0];
        uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v102(v110, a3);
        BOOL v113 = v112 < v111;
        uint64_t v85 = v149;
        if (v113) {
LABEL_65:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_42;
      }
    }
    unint64_t v96 = v152;
    char v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v82 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v154, &type metadata for Int, v98, a3, v5);
    uint64_t v99 = v96;
    uint64_t v87 = v137;
    uint64_t v85 = v149;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_65;
    }
LABEL_42:
    v102(v87, a3);
LABEL_43:
    uint64_t v114 = v150;
    uint64_t v115 = v85(a3, v5);
    uint64_t v116 = v146;
    v134(v146, v114, a3);
    if (v115 < 65)
    {
      uint64_t v126 = v85(a3, v5);
      unint64_t v117 = (uint64_t (*)(char *, uint64_t))v138;
      v138(v116, a3);
      char v118 = v144;
      if (v126 != 64 || (v86(a3, v5) & 1) != 0)
      {
LABEL_56:
        unint64_t v130 = v150;
        unint64_t v131 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = v117(v130, a3);
        if ((v131 & 0x8000000000000000) != 0)
        {
          uint64_t v94 = v148;
          if (v131 > 0xFFFFFFFFFFFFFFF0)
          {
            unsigned int v93 = v143 >> -(char)v131;
            goto LABEL_59;
          }
        }
        else
        {
          uint64_t v94 = v148;
          if (v131 <= 0xF)
          {
            unsigned int v93 = v143 << v131;
            goto LABEL_59;
          }
        }
        LOWORD(v93) = 0;
        goto LABEL_59;
      }
    }
    else
    {
      unint64_t v117 = (uint64_t (*)(char *, uint64_t))v138;
      v138(v116, a3);
      char v118 = v144;
    }
    v134(v118, v150, a3);
    v154[0] = 0x7FFFFFFFFFFFFFFFLL;
    char v119 = v86(a3, v5);
    uint64_t v120 = v85(a3, v5);
    if (v119)
    {
      if (v120 > 64)
      {
        unint64_t v123 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v124 = lazy protocol witness table accessor for type Int and conformance Int(v120, v121, v122);
        uint64_t v125 = v154;
        goto LABEL_54;
      }
    }
    else if (v120 > 63)
    {
      uint64_t v153 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v123 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v124 = lazy protocol witness table accessor for type Int and conformance Int(v120, v121, v122);
      uint64_t v125 = &v153;
LABEL_54:
      char v128 = v152;
      v123(v125, &type metadata for Int, v124, a3, v5);
      char v129 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v128, v118, a3);
      v117(v128, a3);
      if (v129) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_55;
    }
    uint64_t v127 = v152;
    v134(v152, v118, a3);
    (*(void (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    v117(v127, a3);
LABEL_55:
    v117(v118, a3);
    goto LABEL_56;
  }
LABEL_28:
  LOWORD(v93) = 0;
  uint64_t v94 = v148;
LABEL_59:
  *uint64_t v94 = v93;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt16(unsigned __int16 *a1, void (*a2)(void, void), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint32x4_t v139 = (char *)&v132 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v132 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  int8x16_t v136 = (char *)&v132 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unsigned int v143 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v132 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  uint64_t v137 = (char *)&v132 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v144 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  int8x16_t v148 = (char *)&v132 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  uint64_t v149 = v4 + 64;
  char v29 = v28(a3, v4);
  uint64_t v146 = a1;
  if (v29)
  {
    char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v31 = v30(a3, v4);
    if (v31 >= 64)
    {
      v152[0] = -16;
      __int16 v47 = v150;
      uint64_t v147 = v30;
      char v48 = v20;
      uint64_t v49 = v28;
      uint64_t v50 = v10;
      uint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v51(v152, &type metadata for Int, v52, a3, v4);
      uint64_t v10 = v50;
      uint64_t v28 = v49;
      uint64_t v20 = v48;
      char v30 = v147;
      char v53 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                            + 16))(a2, v47, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v47, a3);
      if (v53) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v34 = v150;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v34, a3);
      if (v35 < -16) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v37 = v28(a3, v4);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    uint64_t v147 = v38;
    uint64_t v39 = v38(a3, v4);
    if (v37)
    {
      uint64_t v142 = v28;
      if (v39 <= 64)
      {
        uint64_t v56 = AssociatedTypeWitness;
        uint64_t v57 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v59 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        uint64_t v60 = v150;
        ((void (*)(char *, uint64_t, int **))v57[3])(v59, a3, v57);
        uint64_t v61 = v138;
        LOBYTE(v56) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v138, v60, a3);
        unsigned __int16 v62 = *(void (**)(char *, uint64_t))(v10 + 8);
        v62(v60, a3);
        uint64_t v133 = v10;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v13, v61, a3);
        if (v56)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
          goto LABEL_28;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
        uint64_t v10 = v133;
        uint64_t v28 = v142;
        char v30 = v147;
        a2 = v138;
        if (v63 < -16) {
          goto LABEL_28;
        }
      }
      else
      {
        v152[0] = -16;
        uint64_t v42 = v10;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        __int16 v45 = v150;
        v43(v152, &type metadata for Int, v44, a3, v4);
        uint64_t v10 = v42;
        a2 = v138;
        char v46 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                              + 16))(v138, v45, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v45, a3);
        uint64_t v28 = v142;
        char v30 = v147;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v39 >= 64)
    {
      char v30 = v147;
      a2 = v138;
    }
    else
    {
      char v54 = v150;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, v138, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v54, a3);
      char v30 = v147;
      if (v55 < -16) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v28;
  char v64 = v28(a3, v4);
  char v65 = (char *)a2;
  uint64_t v66 = v30(a3, v4);
  uint64x2_t v134 = v20;
  if (v64)
  {
    if (v66 > 64) {
      goto LABEL_20;
    }
  }
  else if (v66 >= 64)
  {
LABEL_20:
    v152[0] = 16;
    uint64_t v69 = v150;
    uint64_t v70 = v10;
    uint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v152, &type metadata for Int, v72, a3, v4);
    uint64_t v10 = v70;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v69, v65, a3);
    int v138 = *(void (**)(void, void))(v70 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v69, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  uint64_t v91 = v150;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  int v138 = *(void (**)(void, void))(v10 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 <= 16)
  {
LABEL_21:
    uint64_t v147 = v30;
    uint64_t v74 = v10;
    uint64_t v75 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
    uint64_t v76 = v148;
    v75(v148, v65, a3);
    uint64_t v77 = v142;
    char v78 = v142(a3, v4);
    char v79 = v144;
    uint64_t v135 = v75;
    v75(v144, v76, a3);
    uint64_t v133 = v10;
    if ((v78 & 1) == 0)
    {
      v138(v79, a3);
      uint64_t v85 = v77;
      BOOL v86 = v147;
      goto LABEL_41;
    }
    uint64_t v80 = v4;
    uint64_t v81 = v4;
    uint64_t v82 = v147;
    uint64_t v83 = v147(a3, v80);
    v138(v79, a3);
    uint64_t v84 = v82;
    uint64_t v4 = v81;
    uint64_t v85 = v77;
    BOOL v86 = v84;
    if (v83 <= 64) {
      goto LABEL_41;
    }
    uint64_t v144 = (char *)(v74 + 8);
    uint64_t v87 = v137;
    v135(v137, v148, a3);
    v152[0] = 0x8000000000000000;
    if (v85(a3, v81))
    {
      uint64_t v88 = v86(a3, v81);
      if (v88 < 64)
      {
LABEL_36:
        uint64_t v103 = v150;
        v135(v150, v87, a3);
        uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 120))(a3, v81);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v103, a3);
        if (v104 < v152[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v95 = v85(a3, v81);
      uint64_t v88 = v86(a3, v81);
      if ((v95 & 1) == 0)
      {
        if (v88 >= 64)
        {
          v138(v87, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v88 <= 64)
      {
        uint64_t v106 = AssociatedTypeWitness;
        uint64_t v105 = v141;
        uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v108 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
        uint64_t v109 = v150;
        ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                           + 16))(v87, v109, a3);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v109, a3);
        int64x2_t v110 = v136;
        v135(v136, v87, a3);
        if (v141)
        {
          v102(v110, a3);
          goto LABEL_63;
        }
        uint64_t v141 = (int **)v152[0];
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v102(v110, a3);
        BOOL v112 = v111 < (uint64_t)v141;
        BOOL v86 = v147;
        if (v112) {
          goto LABEL_63;
        }
LABEL_40:
        v102(v87, a3);
LABEL_41:
        BOOL v113 = v148;
        uint64_t v114 = v86(a3, v4);
        uint64_t v115 = v134;
        v135(v134, v113, a3);
        if (v114 < 65)
        {
          uint64_t v125 = v86(a3, v4);
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
          if (v125 != 64 || (v85(a3, v4) & 1) != 0)
          {
LABEL_54:
            char v129 = v148;
            unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
            uint64_t result = v116(v129, a3);
            uint64_t v94 = v146;
            unsigned int v131 = *v146;
            if ((v130 & 0x8000000000000000) != 0)
            {
              if (v130 > 0xFFFFFFFFFFFFFFF0)
              {
                unsigned int v93 = v131 >> -(char)v130;
                goto LABEL_57;
              }
            }
            else if (v130 < 0x10)
            {
              unsigned int v93 = v131 << v130;
              goto LABEL_57;
            }
            LOWORD(v93) = 0;
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
        }
        v135(v117, v148, a3);
        v152[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v118 = v85(a3, v4);
        uint64_t v119 = v86(a3, v4);
        if (v118)
        {
          if (v119 > 64)
          {
            uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
            unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
            unint64_t v124 = v152;
            goto LABEL_52;
          }
        }
        else if (v119 >= 64)
        {
          uint64_t v151 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
          unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
          unint64_t v124 = &v151;
LABEL_52:
          uint64_t v127 = v150;
          v122(v124, &type metadata for Int, v123, a3, v4);
          char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v127, v117, a3);
          v116(v127, a3);
          if (v128) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        uint64_t v126 = v150;
        v135(v150, v117, a3);
        (*(void (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v116(v126, a3);
LABEL_53:
        v116(v117, a3);
        goto LABEL_54;
      }
    }
    unint64_t v96 = v150;
    char v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v81 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v152, &type metadata for Int, v98, a3, v4);
    uint64_t v99 = v96;
    uint64_t v87 = v137;
    BOOL v86 = v147;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  LOWORD(v93) = 0;
  uint64_t v94 = v146;
LABEL_57:
  *uint64_t v94 = v93;
  return result;
}